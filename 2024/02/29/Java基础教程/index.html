<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础教程 | 柊</title><meta name="author" content="棨"><meta name="copyright" content="棨"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#59b9c6"><meta name="description" content="Java基础教程，包括Java概述、Java技术体系平台、Java重要特点以及Java的运行机制及运行过程。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础教程">
<meta property="og:url" content="https://chaoqijiang.github.io/2024/02/29/Java%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="柊">
<meta property="og:description" content="Java基础教程，包括Java概述、Java技术体系平台、Java重要特点以及Java的运行机制及运行过程。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chaoqijiang.github.io/Image/avatar.png">
<meta property="article:published_time" content="2024-02-29T15:35:00.000Z">
<meta property="article:modified_time" content="2025-10-10T15:43:26.320Z">
<meta property="article:author" content="棨">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="protected">
<meta property="article:tag" content="基础教程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chaoqijiang.github.io/Image/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java基础教程",
  "url": "https://chaoqijiang.github.io/2024/02/29/Java%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/",
  "image": "https://chaoqijiang.github.io/Image/avatar.png",
  "datePublished": "2024-02-29T15:35:00.000Z",
  "dateModified": "2025-10-10T15:43:26.320Z",
  "author": [
    {
      "@type": "Person",
      "name": "棨",
      "url": "https://chaoqijiang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chaoqijiang.github.io/2024/02/29/Java%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#59b9c6')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 24
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":30,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#165e83","bgDark":"#507ea4","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础教程',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/Image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴/归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/Image/topImage.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/Image/Logo.ico" alt="Logo"><span class="site-name">柊</span></a><a class="nav-page-title" href="/"><span class="site-name">Java基础教程</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴/归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java基础教程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-29T15:35:00.000Z" title="发表于 2024-02-29 23:35:00">2024-02-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-10T15:43:26.320Z" title="更新于 2025-10-10 23:43:26">2025-10-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">39.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>142分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h1><h2 id="Java技术体系平台"><a href="#Java技术体系平台" class="headerlink" title="Java技术体系平台"></a>Java技术体系平台</h2><h3 id="Java-SE（Java-Standard-Edition）：标准版"><a href="#Java-SE（Java-Standard-Edition）：标准版" class="headerlink" title="Java SE（Java Standard Edition）：标准版"></a>Java SE（Java Standard Edition）：标准版</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">支持面向桌面级应用的Java平台，提供了完整的Java核心</span><br></pre></td></tr></table></figure>


<h3 id="Java-EE（Java-Enterprise-Edition）：企业版"><a href="#Java-EE（Java-Enterprise-Edition）：企业版" class="headerlink" title="Java EE（Java Enterprise Edition）：企业版"></a>Java EE（Java Enterprise Edition）：企业版</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet、Jsp等，主要针对于Web应用程序开发。版本以前称为J2EE</span><br></pre></td></tr></table></figure>


<h3 id="Java-ME（Java-Micro-Edition）：小型版"><a href="#Java-ME（Java-Micro-Edition）：小型版" class="headerlink" title="Java ME（Java Micro Edition）：小型版"></a>Java ME（Java Micro Edition）：小型版</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">支持Java程序运行在移动终端(手机、PDA) 上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME</span><br></pre></td></tr></table></figure>


<h2 id="Java-重要特点"><a href="#Java-重要特点" class="headerlink" title="Java 重要特点"></a>Java 重要特点</h2><ol>
<li><p>Java 语言是面向对象的(oop)。</p>
</li>
<li><p>Java 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证。</p>
</li>
<li><p>Java 语言是跨平台性的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]</p>
</li>
<li><p>Java 语言是解释型的[了解]</p>
<p>解释性语言：javascript,PHP, java 编译性语言: c &#x2F; c++</p>
<p>区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行, 编译性语言, 编译后的代码, 可以直接被机器执行。</p>
</li>
<li><p>Java内置了多线程的支持。</p>
</li>
<li><p>Java是动态的。基本组成单元是类，类是在运行的时候动态装载的，可以在环境中动态的维护程序和类库。（在面向对象时就区分了编译类型和运行类型）</p>
</li>
</ol>
<h2 id="Java的运行机制及运行过程"><a href="#Java的运行机制及运行过程" class="headerlink" title="Java的运行机制及运行过程"></a>Java的运行机制及运行过程</h2><h3 id="JVM-Java虚拟机-Java-virtual-machine"><a href="#JVM-Java虚拟机-Java-virtual-machine" class="headerlink" title="JVM Java虚拟机 Java virtual machine"></a>JVM Java虚拟机 Java virtual machine</h3><ol>
<li>JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在 JDK 中。</li>
<li>对于不同的平台，有不同的虚拟机。</li>
<li>Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”。（即运行环境相等）</li>
</ol>
<h3 id="JDK-Java开发工具包-Java-Development-Kit"><a href="#JDK-Java开发工具包-Java-Development-Kit" class="headerlink" title="JDK Java开发工具包 Java Development Kit"></a>JDK Java开发工具包 Java Development Kit</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。</span><br></pre></td></tr></table></figure>


<h3 id="JRE-Java运行环境-Java-Runtime-Environment"><a href="#JRE-Java运行环境-Java-Runtime-Environment" class="headerlink" title="JRE Java运行环境 Java Runtime Environment"></a>JRE Java运行环境 Java Runtime Environment</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">包括 Java 虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序， 计算机中只需要安装 JRE 即可。</span><br></pre></td></tr></table></figure>


<h3 id="JDK、JRE-和-JVM-的包含关系"><a href="#JDK、JRE-和-JVM-的包含关系" class="headerlink" title="JDK、JRE 和 JVM 的包含关系"></a>JDK、JRE 和 JVM 的包含关系</h3><ol>
<li>JDK &#x3D; JRE + 开发工具集（例如 Javac,java 编译工具等)</li>
<li>JRE &#x3D; JVM + Java SE 标准类库（java 核心类库）</li>
<li>如果只想运行开发好的 .class 文件 只需要 JRE</li>
</ol>
<h3 id="Java-开发注意事项和细节"><a href="#Java-开发注意事项和细节" class="headerlink" title="Java 开发注意事项和细节"></a>Java 开发注意事项和细节</h3><ol>
<li>Java源文件以.java为扩展名。源文件的基本组成部分是类(class) 。</li>
<li>Java应用程序的执行入口是main()方法。它有固定的书写格式:public static void main(String[] args) {..}</li>
<li>Java语言对大小写敏感。</li>
<li>Java方法由一条条语句构成，每个语句以”；“结束。</li>
<li>大括号都是成对出现的，缺一不可。 [习惯，先写{}再写代码]</li>
<li>一个源文件中<strong>最多只能有一个public类</strong>。 其它类的个数不限。</li>
<li>如果源文件包含一个public类，则文件名<strong>必须按该类名命名</strong>!</li>
<li>一个源文件中最多只能有一个public类。其它类的个数不限，也可以将main方法写在非public类中，然后指定运行非public类，这样入口方法就是非public的main方法</li>
</ol>
<h3 id="Java中常用的转义字符"><a href="#Java中常用的转义字符" class="headerlink" title="Java中常用的转义字符"></a>Java中常用的转义字符</h3><ul>
<li>\t ：一个制表位，实现对齐的功能</li>
<li>\n ：换行符</li>
<li>\\ ：一个\</li>
<li>\“ :一个”</li>
<li>\‘ ：一个’</li>
<li>\r :一个回车 （光标回到当前行的第一个字符）</li>
</ul>
<h3 id="Java注释（comment）"><a href="#Java注释（comment）" class="headerlink" title="Java注释（comment）"></a>Java注释（comment）</h3><h4 id="Java-中的注释类型"><a href="#Java-中的注释类型" class="headerlink" title="Java 中的注释类型"></a>Java 中的注释类型</h4><ol>
<li>单行注释 &#x2F;&#x2F;</li>
<li>多行注释 &#x2F;* *&#x2F;</li>
<li>文档注释 &#x2F;** *&#x2F;</li>
</ol>
<h4 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h4><ol>
<li>被注释的文字，不会被 JVM（java 虚拟机）解释执行</li>
<li>多行注释里面不允许有多行注释嵌</li>
</ol>
<h4 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注释内容可以被JDK提供的工具Javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。一般写在类。</span><br></pre></td></tr></table></figure>


<h5 id="生成文档注释"><a href="#生成文档注释" class="headerlink" title="生成文档注释"></a>生成文档注释</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javadoc -d 文件名 -xx -yy zzz.java <span class="comment">//文件名指存放的位置，xx、yy指参数，可以通过javadoc -help进行查看，</span></span><br></pre></td></tr></table></figure>

<h3 id="Java-代码规范"><a href="#Java-代码规范" class="headerlink" title="Java 代码规范"></a>Java 代码规范</h3><ol>
<li>类、方法的注释，要以Javadoc的方式来写。</li>
<li>非Java Doc的注释，往往是给代码的维护者看的，着重告述读者为什么这样写，如何修改，注意什么问题等</li>
<li>使用tab操作， 实现缩进,默认整体向右边移动，时候用shift+ tab整体向左移</li>
<li>运算符和&#x3D;两边习惯性各加一个空格。比如:2 + 4 * 5 + 345 - 89</li>
<li>源文件使用utf-8编码</li>
<li>行宽度不要超过80字符</li>
<li>代码编写<strong>次行风格</strong>和<strong>行尾风格</strong>。</li>
</ol>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><h4 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h4><p>从当前目录开始定位，形成一个路径，含义是相对于现在这个目录，我指定的在哪里。在不同目录下该路径的含义不同。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">..\abc2				//指向上一个文件夹中的abc2文件。	..表示返回上一级</span><br></pre></td></tr></table></figure>

<h4 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h4><p>从根目录开始定位，只要是在这个计算机内就能保证路径指向的唯一性。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D;\hurr\test</span><br></pre></td></tr></table></figure>

<h3 id="Windows下简单的DOS命令"><a href="#Windows下简单的DOS命令" class="headerlink" title="Windows下简单的DOS命令"></a>Windows下简单的DOS命令</h3><ol>
<li><p>查看当前目录是有什么内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir D:\hurriedlu\test</span><br></pre></td></tr></table></figure></li>
<li><p>切换到其他目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd D:\Programs</span><br></pre></td></tr></table></figure></li>
<li><p>切换到上一级目录 (使用相对路径)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure></li>
<li><p>切换到根目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd \</span><br></pre></td></tr></table></figure></li>
<li><p>查看指定的目录下所有的子级目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tree</span><br></pre></td></tr></table></figure></li>
<li><p>清屏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cls</span><br></pre></td></tr></table></figure></li>
<li><p>退出 DOS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<hr>
</li>
</ol>
<h1 id="Java中的变量"><a href="#Java中的变量" class="headerlink" title="Java中的变量"></a>Java中的变量</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同c、c++一样，每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间(字节)。</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在Java中，整个数据类型可分为两大类：</span><br></pre></td></tr></table></figure>

<p><strong>基本数据类型</strong>和<strong>引用数据类型</strong>。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">标识符</th>
<th align="center">默认值</th>
<th align="center">存储大小(字节)</th>
<th align="left">数据范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">整型</td>
<td align="center">byte</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="left">-128~127</td>
</tr>
<tr>
<td align="center">整型</td>
<td align="center">short</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="left">-32768~32767</td>
</tr>
<tr>
<td align="center">整型</td>
<td align="center">int</td>
<td align="center">0</td>
<td align="center">4</td>
<td align="left">-2147483648~2147483647</td>
</tr>
<tr>
<td align="center">整型</td>
<td align="center">long</td>
<td align="center">0L&#x2F;0l</td>
<td align="center">8</td>
<td align="left">-2^63~2^63-1</td>
</tr>
<tr>
<td align="center">实型</td>
<td align="center">float</td>
<td align="center">0.0F&#x2F;0.0f</td>
<td align="center">4</td>
<td align="left">32位IEEEE 754单精度范围</td>
</tr>
<tr>
<td align="center">实型</td>
<td align="center">double</td>
<td align="center">0.0&#x2F;0.0D&#x2F;0.0d</td>
<td align="center">8</td>
<td align="left">64位IEEEE 754双精度范围</td>
</tr>
<tr>
<td align="center">逻辑</td>
<td align="center">boolean</td>
<td align="center">false</td>
<td align="center">1bit</td>
<td align="left">true或false</td>
</tr>
<tr>
<td align="center">字符</td>
<td align="center">char</td>
<td align="center">空</td>
<td align="center">2</td>
<td align="left">Unicode的字符范围: ‘\u0000’ (即为0)到’\uffff’ (即为65,535)</td>
</tr>
</tbody></table>
<p>同c、c++有些许不同，虽然要求任何变量在使用前必须初始化，但变量在定义的时候已经有初值了。（c中只有全局变量才有初值）</p>
<h3 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h3><ol>
<li><p>Java中各整数类型都有固定的范围和字段长度，不受操作系统的影响，保证了可移植性。</p>
</li>
<li><p>整形变量默认为int型，声明long型需要在后面加上l或者L。</p>
</li>
<li><p>同c、c++有些许不同，虽然要求任何变量在使用前必须初始化，但变量在定义的时候已经有初值了。（c中只有全局变量才有初值）</p>
</li>
<li><p>注意数据范围，小心溢出。</p>
</li>
<li><p>对于浮点型而言，其中的数值不是准确的，存储的仅是近似值。因此，在比较浮点型数据中，一般的方法是将两个数相减，如果差值小于精度的要求，就认为是相等的。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">2.7</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">8.1</span>/<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(Math.abs(num1-num2)&lt;<span class="number">0.00001</span>)</span><br><span class="line">    System.out.println(<span class="string">&quot;两个数相等&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>字符常量是用单引号括起来的单个字符，因为使用的是Unicode编码，因此可以存储汉字，且占用空间是2个字节。</p>
</li>
<li><p>在Java中char是可以进行运算的，和c相同，当成一个整数。</p>
</li>
</ol>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java在赋值和运算时，精度小的类型会自动转换为精度大的数据类型，这就是自动类型转换。</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">**char -&gt; int -&gt; long -&gt; float -&gt; double**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double**</span><br><span class="line"></span><br><span class="line">##### 自动类型转换中需要注意的细节</span><br><span class="line"></span><br><span class="line">1. 有多种类型的数据混合运算时，系统首先自动将所有数据转换成（精度）容量最大的那种数据类型，然后再进行计算。</span><br><span class="line">2. 当我们把精度(容量)大的数据类型赋值给精度(容量)小的数据类型时，就会报错，反之就会进行自动类型转换。</span><br><span class="line">3. (byte, short)和char之间不会相互自动转换。</span><br><span class="line">4. byte, short, char 他们三者可以计算，在计算时首先转换为int类型（自动）。</span><br><span class="line">5. boolean不参与转换。</span><br><span class="line">6. 自动提升原则：表达式结果的类型自动提升为操作数中最大的类型。</span><br><span class="line"></span><br><span class="line">#### 强制类型转换</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符 ( )，但可能造成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**精度降低或溢出**，格外要注意。</span><br><span class="line"></span><br><span class="line">##### 强制类型转换细节</span><br><span class="line"></span><br><span class="line">1. 当需要对精度（容量）大的转换为小的的时候，就需要使用到强制转换。</span><br><span class="line">2. 强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级。</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   int x = (int)10 * 3.5 + 5 * 1.5;		//42.5</span><br><span class="line">   int y = (int)(10 * 3.5 + 5 * 1.5); 		//42</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>char类型可以保存int的常量值，但不能保存int的变量值，需要强转。（即以字符形式存储整型值）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//ok</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//ok</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> m; <span class="comment">//错误</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> (<span class="type">char</span>)m; <span class="comment">//ok</span></span><br><span class="line">System.out.println(c3);<span class="comment">//100对应的字符</span></span><br></pre></td></tr></table></figure></li>
<li><p>byte和short，char类型在进行运算时，当做int类型处理。</p>
</li>
</ol>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每种编程语言都有自己操作内存中元素的方式，例如在 C 和 C++ 里是通过指针，而在 Java 中则是通过“引用”。</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 Java 中一切都被视为了对象，但是我们操作的标识符实际上是对象的一个引用（reference）。</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过将这个叫“引用”的标识符指向某个对象，之后便可以通过这个引用来实现操作对象了。</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最常用的引用类型就是String，它可以很方便的存储字符串。</span><br></pre></td></tr></table></figure>


<p>对于引用在后面面向对象的时候会详细的讲，这里只需要直到引用类型不能直接&#x3D;&#x3D;来判断值是否相同。</p>
<h2 id="基本数据类型与String类型的转换"><a href="#基本数据类型与String类型的转换" class="headerlink" title="基本数据类型与String类型的转换"></a>基本数据类型与String类型的转换</h2><h3 id="基本数据类型转String"><a href="#基本数据类型转String" class="headerlink" title="基本数据类型转String"></a>基本数据类型转String</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基本类型+<span class="string">&quot;&quot;</span>;	<span class="comment">//基本类型加上一个空串就行</span></span><br></pre></td></tr></table></figure>

<h3 id="String转基本类型"><a href="#String转基本类型" class="headerlink" title="String转基本类型"></a>String转基本类型</h3><p>通过基本类型的包装类调用parseXX方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.parseInt(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">Double.parseDouble(<span class="string">&quot;123.1&quot;</span> );</span><br><span class="line">Float.parseFloat(<span class="string">&quot;123.45&quot;</span>) ;</span><br><span class="line">Short.parseShort(<span class="string">&quot;12&quot;</span> ); </span><br><span class="line">Long.parseLong(<span class="string">&quot;12345&quot;</span> );</span><br><span class="line">Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">Byte.parseByte(<span class="string">&quot;12&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>在将 String 类型转成基本数据类型时，比如我们可以把 “123” , 转成一 个整数，但是不能把 “hello”转换成整数。</li>
<li>对于格式不正确的转换，会直接<strong>抛出异常，程序停止</strong>。</li>
<li>不同于c，会从头开始转换，直到不能转换为止，如123abc可以转换成整数123，但这在Java中是不可以的。</li>
</ol>
<h2 id="Java中常用编码简介"><a href="#Java中常用编码简介" class="headerlink" title="Java中常用编码简介"></a>Java中常用编码简介</h2><h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最通用的单字节编码系统，等同于国际标准ISO/IEC 646 。</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传统ASCII码规定了128个字符，只占用了一个字节中的后七位</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">扩展ASCII码扩展了128给，即一个字节八个位全都有使用。扩展ASCII码允许将每个字符的第8 位用于确定附加的128 个特殊符号字符、外来语字母和图形符号。</span><br></pre></td></tr></table></figure>


<h3 id="Unicode-编码"><a href="#Unicode-编码" class="headerlink" title="Unicode 编码"></a>Unicode 编码</h3><ul>
<li>Unicode的好处: 每一个符号都给予一 个独一无二的编码，使用Unicode没有乱码的问题。</li>
<li>Unicode的缺点:一个英文字母和一个汉字都占用2个字节，这对于存储空间来说是浪费。</li>
<li>2的16次方是65536，所以最多编码是65536个字符。</li>
<li>Unicode码兼容ASCII码。编码0- 127的字符是与ASCII的编码一样，比如’a’ 在ASCII码是0x61，在Unicode码是0x0061,都对应97。</li>
</ul>
<h3 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF-8编码"></a>UTF-8编码</h3><ol>
<li>UTF-8是在互联网上使用最广的一种Unicode的实现方式(改进)。</li>
<li>UTF-8 是一种<strong>变长的编码</strong>方式。它可以使用1-6个字节表示一个符号， 根据不同的符号而变化字节长度。</li>
<li>使用大小可变的编码字母占1个字节，汉字占3个字节。</li>
</ol>
<h2 id="Java中的加号"><a href="#Java中的加号" class="headerlink" title="Java中的加号"></a>Java中的加号</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">整个表达式从左往右进行运算，当运算符两边是数值时进行数值上的相加，当读到有非数值的时候，从此刻开始直到整个表达式结束，+号的作用变成了连接。如下：</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="number">100</span> + <span class="number">98</span>); <span class="comment">//198</span></span><br><span class="line">System.out.println(<span class="string">&quot;100&quot;</span> + <span class="number">98</span>)<span class="comment">//10098</span></span><br><span class="line">System.out.println(<span class="number">100</span> + <span class="number">3</span> + <span class="string">&quot;hello&quot;</span>);<span class="comment">//103hello</span></span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span> + <span class="number">100</span> +<span class="number">3</span>); <span class="comment">//hello1003</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>与C++中的运算符类似，此处不再详细笔记。如有不同则会在后期添加</p>
<blockquote>
<p>赋值运算符：&#x3D;</p>
<p>算数运算符：+ - * &#x2F; %</p>
<p>关系运算符：&gt; &lt; &gt;&#x3D; &lt;&#x3D; !&#x3D; &#x3D;&#x3D;</p>
<p>逻辑运算符（短路符，即一旦确定值后直接结束）： &amp;&amp; ||</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（非短路，会全部运算完）&amp; | !</span><br></pre></td></tr></table></figure>

<p>自增自减符：++ –</p>
<p>三元运算符： 条件表达式?表达式1：表达式2；</p>
<p>下标运算符：[]</p>
<p>类型转换：（）</p>
<p>其他运算符：new instanceof 位运算符 访问成员运算符</p>
</blockquote>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用于检查是否是类的对象。常用于后面的多态的向下转型。先判断这个对象引用的运行类型是否属于某个子类，是的话就可以进行向下转型。</span><br></pre></td></tr></table></figure>

<h2 id="标识符的命名"><a href="#标识符的命名" class="headerlink" title="标识符的命名"></a>标识符的命名</h2><h3 id="标识符概念"><a href="#标识符概念" class="headerlink" title="标识符概念"></a>标识符概念</h3><ol>
<li>Java 对各种变量、方法和类等命名时使用的字符序列称为标识符</li>
<li>凡是自己可以起名字的地方都叫标识符int num1 &#x3D; 90;</li>
</ol>
<h3 id="标识符的命名规则-必须遵守-与c-相同"><a href="#标识符的命名规则-必须遵守-与c-相同" class="headerlink" title="标识符的命名规则(必须遵守)与c++相同"></a>标识符的命名规则(必须遵守)与c++相同</h3><ol>
<li>由26个英文字母大小写，0-9，_或$组成。汉字也行，但不推荐。</li>
<li>数字不可以开头。</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字。</li>
<li>Java中严格区分大小写， 长度无限制。</li>
<li>标识符不能包含空格。</li>
</ol>
<h3 id="标识符命名规范"><a href="#标识符命名规范" class="headerlink" title="标识符命名规范"></a>标识符命名规范</h3><ol>
<li>包名：多单词组成时所有字母都小写：aaa.bbb.ccc</li>
<li>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰]</li>
<li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小驼峰， 简称 驼峰法]</li>
<li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li>
</ol>
<p>后面我们学习到 类，包，接口，等时，我们的命名规范要这样遵守,更加详细的看文档。</p>
<h2 id="Java中的位运算"><a href="#Java中的位运算" class="headerlink" title="Java中的位运算"></a>Java中的位运算</h2><h3 id=""><a href="#" class="headerlink" title="&amp;"></a>&amp;</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按位与：对应的两位全为1，结果为1</span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title="|"></a>|</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按位或：对应位有1为1</span><br></pre></td></tr></table></figure>

<h3 id="-2"><a href="#-2" class="headerlink" title="^"></a>^</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按位异或：对应位相异为一</span><br></pre></td></tr></table></figure>

<h3 id="-3"><a href="#-3" class="headerlink" title="~"></a>~</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按位取反</span><br></pre></td></tr></table></figure>

<h3 id="-4"><a href="#-4" class="headerlink" title="&gt;&gt;"></a>&gt;&gt;</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">算术右移 ：低位溢出，符号位不变，并用符号位补溢出的高位。</span><br></pre></td></tr></table></figure>

<h3 id="-5"><a href="#-5" class="headerlink" title="&lt;&lt;"></a>&lt;&lt;</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">算术左移 ：符号位不变,低位补 0</span><br></pre></td></tr></table></figure>

<h3 id="-6"><a href="#-6" class="headerlink" title="&gt;&gt;&gt;"></a>&gt;&gt;&gt;</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">逻辑右移：也叫无符号右移，运算规则是: 低位溢出，高位补 0</span><br></pre></td></tr></table></figure>

<h3 id="注意，没有逻辑左移！！！"><a href="#注意，没有逻辑左移！！！" class="headerlink" title="注意，没有逻辑左移！！！"></a>注意，没有逻辑左移！！！</h3><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键字的定义和特点 (不用背) 定义：被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词） 特点：关键字中所有字母都为小写。</p>
<h3 id="用于定义数据类型的关键字："><a href="#用于定义数据类型的关键字：" class="headerlink" title="用于定义数据类型的关键字："></a>用于定义数据类型的关键字：</h3><ul>
<li>class</li>
<li>interface</li>
<li>enum</li>
<li>byte</li>
<li>short</li>
<li>int </li>
<li>long</li>
<li>float</li>
<li>double</li>
<li>char</li>
<li>boolean</li>
<li>void</li>
</ul>
<h3 id="用于定义数据类型值的关键字"><a href="#用于定义数据类型值的关键字" class="headerlink" title="用于定义数据类型值的关键字"></a>用于定义数据类型值的关键字</h3><ul>
<li>true</li>
<li>false</li>
<li>null</li>
</ul>
<h3 id="用于定义流程控制的关键字"><a href="#用于定义流程控制的关键字" class="headerlink" title="用于定义流程控制的关键字"></a>用于定义流程控制的关键字</h3><ul>
<li>if</li>
<li>else</li>
<li>switch</li>
<li>case</li>
<li>default</li>
<li>while</li>
<li>do</li>
<li>for</li>
<li>break</li>
<li>continue</li>
<li>return</li>
</ul>
<h3 id="用于定义访问权限修饰符的关键字"><a href="#用于定义访问权限修饰符的关键字" class="headerlink" title="用于定义访问权限修饰符的关键字"></a>用于定义访问权限修饰符的关键字</h3><ul>
<li>private</li>
<li>protected</li>
<li>public</li>
</ul>
<h3 id="定义类、函数、变量修饰符的关键字"><a href="#定义类、函数、变量修饰符的关键字" class="headerlink" title="定义类、函数、变量修饰符的关键字"></a>定义类、函数、变量修饰符的关键字</h3><ul>
<li>abstract</li>
<li>final</li>
<li>static</li>
<li>synchronized</li>
</ul>
<h3 id="定义类与类之间关系的关键字"><a href="#定义类与类之间关系的关键字" class="headerlink" title="定义类与类之间关系的关键字"></a>定义类与类之间关系的关键字</h3><ul>
<li>extends</li>
<li>implements</li>
</ul>
<h3 id="用于建立实例及引用实例、判断实例的关键字"><a href="#用于建立实例及引用实例、判断实例的关键字" class="headerlink" title="用于建立实例及引用实例、判断实例的关键字"></a>用于建立实例及引用实例、判断实例的关键字</h3><ul>
<li>new</li>
<li>this</li>
<li>super</li>
<li>instanceof</li>
</ul>
<h3 id="用于异常处理的关键字"><a href="#用于异常处理的关键字" class="headerlink" title="用于异常处理的关键字"></a>用于异常处理的关键字</h3><ul>
<li>try</li>
<li>catch</li>
<li>finally</li>
<li>throw</li>
<li>throws</li>
</ul>
<h3 id="用于包的关键字"><a href="#用于包的关键字" class="headerlink" title="用于包的关键字"></a>用于包的关键字</h3><ul>
<li>package</li>
<li>import</li>
</ul>
<h3 id="其他修饰符关键字"><a href="#其他修饰符关键字" class="headerlink" title="其他修饰符关键字"></a>其他修饰符关键字</h3><ul>
<li>native</li>
<li>strictfp</li>
<li>transient</li>
<li>volatile</li>
<li>assert</li>
</ul>
<h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留 字 byValue、cast、future、 generic、 inner、 operator、 outer、 rest、 var 、 goto 、const。</span><br></pre></td></tr></table></figure>

<h2 id="键盘输入语句"><a href="#键盘输入语句" class="headerlink" title="键盘输入语句"></a>键盘输入语句</h2><ol>
<li>导入该类的所在包,  java.util.Scanner。</li>
<li>创建该类对象（声明变量）。</li>
<li>调用里面的功能。</li>
</ol>
<p>常用的语句如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);	<span class="comment">//定义方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scanner.nextInt();				<span class="comment">//读取int类型</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> scanner.nextDouble();			<span class="comment">//读取浮点型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.next();					<span class="comment">//读取字符串</span></span><br></pre></td></tr></table></figure>
<h1 id="数组、排序和查找"><a href="#数组、排序和查找" class="headerlink" title="数组、排序和查找"></a>数组、排序和查找</h1><h2 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组的元素类型 [] 数组名;</span><br><span class="line"></span><br><span class="line">数组的元素类型  数组名 [];</span><br></pre></td></tr></table></figure>
<h4 id="分配元素"><a href="#分配元素" class="headerlink" title="分配元素"></a>分配元素</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名 = <span class="keyword">new</span> 数组元素的类型[个数];</span><br></pre></td></tr></table></figure>
<h4 id="同时进行声明和分配元素"><a href="#同时进行声明和分配元素" class="headerlink" title="同时进行声明和分配元素"></a>同时进行声明和分配元素</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num[] = <span class="keyword">new</span> [<span class="number">10</span>];<span class="comment">//定义了一个int类型的一维数组，有10个元素，下标范围0-9</span></span><br></pre></td></tr></table></figure>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><h4 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组的元素类型 [][] 数组名;</span><br><span class="line">数组的元素类型 数组名[][];</span><br></pre></td></tr></table></figure>
<h4 id="分配元素-1"><a href="#分配元素-1" class="headerlink" title="分配元素"></a>分配元素</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名 = <span class="keyword">new</span> 数组元素的类型[个数][个数];</span><br></pre></td></tr></table></figure>
<h4 id="同时进行声明和分配元素-1"><a href="#同时进行声明和分配元素-1" class="headerlink" title="同时进行声明和分配元素"></a>同时进行声明和分配元素</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num[][] = <span class="keyword">new</span> [<span class="number">10</span>][<span class="number">12</span>];<span class="comment">//定义了一个int类型的一维数组，有10个元素，下标范围0-9</span></span><br></pre></td></tr></table></figure>
<h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><h3 id="一维数组-1"><a href="#一维数组-1" class="headerlink" title="一维数组"></a>一维数组</h3><h4 id="不利用方法"><a href="#不利用方法" class="headerlink" title="不利用方法"></a>不利用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">    System.out.println(num[i] + <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(Arrays.toString(num));<span class="comment">//利用数组类里面的toString方法，直接将整个数组转换成字符串的形式</span></span><br></pre></td></tr></table></figure>
<h3 id="二维数组-1"><a href="#二维数组-1" class="headerlink" title="二维数组"></a>二维数组</h3><h4 id="不利用方法-1"><a href="#不利用方法-1" class="headerlink" title="不利用方法"></a>不利用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">        System.out.print(arr[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="利用方法-1"><a href="#利用方法-1" class="headerlink" title="利用方法"></a>利用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.println(Arrays.toString(arr[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="与c的不同之处"><a href="#与c的不同之处" class="headerlink" title="与c的不同之处"></a>与c的不同之处</h3><ul>
<li>首先就是定义的方法不同。</li>
<li>其次就是，在二维数组中，在c里面可以以一维的方式进行访问（即第二行第一列等于第一行+1），但在java中不行。</li>
<li>java中的二维数组相当于：我定义了一个一维数组，里面存放了指向一个一维数组的地址。</li>
<li>因此，在Java中，二维数组可以不再是矩形的了，每一行的空间都可以单独的定义。比如这样：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][];</span><br><span class="line">arr[<span class="number">2</span>]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">112</span>];</span><br><span class="line">arr[<span class="number">1</span>]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">arr[<span class="number">2</span>]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">13</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>因为可以Java的特性，导致了数组的列数可能不统一，且每一行都能获取到当前行有多少列</li>
<li>有一点和C是一样的，就是数组一旦分配了就不能在更改长度，只能对该一维数组重新定义，然后把老的数组里面的值复制到新数组。</li>
<li>有一点和新版本的C是相似的，就是允许在运行的过程中分配空间，而不是在编译的时候就需要确定好。（c98以前的标准不允许）</li>
</ul>
<h1 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h1><p>在Java中，也分为三大流程控制：顺序控制 分支控制 循环控制。对应的语句和c也一样，此处不在进行笔记，不同的地方后期补足。</p>
<h2 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(暂存变量:数组名)&#123;</span><br><span class="line">    System.out.println(暂存变量);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要注意暂存变量的类型需要与数组中元素的类型相同。在每次循环中会自动的将数组中的元素一次赋值给 </span></span><br></pre></td></tr></table></figure>
<p>使用样例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> nums[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">  System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String s[] = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String t:s)&#123;</span><br><span class="line">  System.out.print(t+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果：1 3 9 a b c </span></span><br></pre></td></tr></table></figure>
<h1 id="面向对象："><a href="#面向对象：" class="headerlink" title="面向对象："></a>面向对象：</h1><h2 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h2><blockquote>
<p>把需要的属性和方法抽象出来就形成了类，将类实例化后形成对象，形成对象后可以为其个性化。</p>
</blockquote>
<ol>
<li>类是抽象的，概念的，代表一类事物,比如人类,猫类.., 即它是数据类型。</li>
<li>对象是具体的，实际的，代表一个具体事物, 即 是实例</li>
<li>类是对象的模板，对象是类的一个个体，对应一个实</li>
</ol>
<h2 id="属性、成员变量（字段）"><a href="#属性、成员变量（字段）" class="headerlink" title="属性、成员变量（字段）"></a>属性、成员变量（字段）</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>从概念或叫法上看： 成员变量 &#x3D; 属性 &#x3D; field(字段) （即 成员变量是用来表示属性的)。</p>
<p>属性是类的一个组成部分，可以是是基本数据类型,也可是引用类型(对象，数组)。</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>属性的定义语法同变量</li>
<li>属性的定义类型可以为任意类型，包含基本类型或引用类型</li>
<li>属性如果不赋值，有默认值，规则和数组、变量一致。</li>
</ol>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ol>
<li>先声明再创建</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Cat cat ; <span class="comment">//声明对象 cat </span></span><br><span class="line"><span class="number">2.</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>直接创建</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure>
<h3 id="访问对象的属性"><a href="#访问对象的属性" class="headerlink" title="访问对象的属性"></a>访问对象的属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cat.name;	<span class="comment">//对象名.属性名;</span></span><br></pre></td></tr></table></figure>
<h3 id="对象的细节"><a href="#对象的细节" class="headerlink" title="对象的细节"></a>对象的细节</h3><h4 id="类和对象的内存分配机制"><a href="#类和对象的内存分配机制" class="headerlink" title="类和对象的内存分配机制"></a>类和对象的内存分配机制</h4><h5 id="Java-内存的结构分析"><a href="#Java-内存的结构分析" class="headerlink" title="Java 内存的结构分析"></a>Java 内存的结构分析</h5><ol>
<li>栈： 一般存放基本数据类型(局部变量)。</li>
<li>堆： 存放对象(Cat cat , 数组等)。</li>
<li>方法区：常量池(常量，比如字符串)， 类加载信息</li>
</ol>
<h5 id="Java-创建对象流程的简单分析"><a href="#Java-创建对象流程的简单分析" class="headerlink" title="Java 创建对象流程的简单分析"></a>Java 创建对象流程的简单分析</h5><ol>
<li>先加载 Person 类信息(属性和方法信息, 只会加载一次。</li>
<li>在堆中分配空间（地址），进行默认初始化(看规则)</li>
<li>把地址赋给一个引用类型的变量，就指向对象</li>
<li>进行指定初始化， 比如 p.name &#x3D;”jack”</li>
</ol>
<h5 id="对象在内存中存在形式"><a href="#对象在内存中存在形式" class="headerlink" title="对象在内存中存在形式"></a>对象在内存中存在形式</h5><ol>
<li>程序运行时，会将整个类加载到”方法区“（只加载一次）。</li>
<li>当将类实例化成对象的时候，会按照方法区的类在堆中开辟一个空间，如果其中引用了字符串之类的，会将位于常量池的字符串的地址写入堆中对应的位置，如果是普通类型，会分配空间并使空间清零。</li>
<li>在栈中创建一个对象的引用变量，并将堆中的地址写入栈中。</li>
</ol>
<h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在某些情况下，我们要需要定义成员方法(简称方法)。比如人类:除了有一些属性外( 年龄，姓名..),我们人类还有一 些行为比如:可以说话、跑步..,通过学习，还可以做算术题。这时就要用成员方法才能完成。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法，也称为函数。</span><br></pre></td></tr></table></figure>

<h3 id="方法的调用机制原理"><a href="#方法的调用机制原理" class="headerlink" title="方法的调用机制原理"></a>方法的调用机制原理</h3><ol>
<li>当程序执行到方法的时候，就会开辟一个独立空间。</li>
<li>当方法执行完毕，或者执行到return语句时，就会返回到调用方法的地方继续执行（类似于中断）。</li>
<li>当整个main方法（栈）执行完毕，整个程序退出。</li>
</ol>
<blockquote>
<p>和C++一样，每个函数的空间独立，其中的局部变量的生存期和作用域都不会超出这个函数的空间</p>
</blockquote>
<h3 id="成员方法的意义"><a href="#成员方法的意义" class="headerlink" title="成员方法的意义"></a>成员方法的意义</h3><ol>
<li>提高代码的复用性。</li>
<li>可以将实现的细节封装起来，然后供其他用户来调用</li>
</ol>
<h3 id="成员方法的定义："><a href="#成员方法的定义：" class="headerlink" title="成员方法的定义："></a>成员方法的定义：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问修饰符 返回数据类型 方法名（形参列表..） &#123;<span class="comment">//方法体</span></span><br><span class="line">语句;</span><br><span class="line"><span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>形参列表：表示成员方法输入 cal(int n) ， getSum(int num1, int num2)。</li>
<li>返回数据类型：表示成员方法输出, void 表示没有返回值。</li>
<li>方法主体：表示为了实现某一功能代码块。</li>
<li>return：返回一定的值，如在方法中计算得到的值，或者状态。该语句不是必须的 。</li>
</ol>
<h3 id="方法的细节"><a href="#方法的细节" class="headerlink" title="方法的细节"></a>方法的细节</h3><ol>
<li>一个方法最多有一个返回值，如需返回多个可以借助数组或者类。</li>
<li>返回类型可以为任意类型，包含基本类型或引用类型(数组，对象)。</li>
<li>如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值; 而且要求返回值类型必须和 return 的 值类型一致或兼容。</li>
<li>如果方法是 void，则方法体中可以没有 return 语句，或者 只写 return ;</li>
<li>方法名遵循驼峰命名法，最好见名知义，表达出该功能的意思即可。</li>
<li>一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开，比如getSum(int n1,int n2)。</li>
<li>参数类型可以为任意类型，包含基本类型或引用类型，比如printArr(int[][] map[] [] )。</li>
<li>调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数! [getSum]</li>
<li>方法定义时的参数称为形式参数，简称形参;方法调用时的传入参数称为实际参数，简称实参，实参和形参的类型要一致或兼容、 个数、顺序必须致! </li>
<li>方法体里面写完成功能的具体的语包，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法!即:<strong>方法不能嵌套定义</strong>。[演示]</li>
<li>传入方法的并不是原来的元素，而是其中的值。对于普通类型来说，因为传进去的是直接的值，相当于拷贝一份进去，因此不会影响到原来变量的地址；但对引用类型来说，传入的是一个地址，针对地址的修改会直接影响到原来的值。（好像与C++中有些不太一样，String是引用类型，但如果传到函数中并对其进行修改，回到main中再输出还是修改之前值）。</li>
<li>当方法是static的时候，表示这是一个静态的方法，可以不用实例化成对象，直接通过类名.方法名进行调用。具体细节后面说。</li>
</ol>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。 就可以通过可变参数实现。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单的说就是当成一个不定长的数组，传入的一瞬间为这堆数开辟一个空间放进去，并把首地址传入。</span><br></pre></td></tr></table></figure>

<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问修饰符 返回类型 方法名(数据类型... 形参名) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> ... nums)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    sum+=nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">面向对象中，变量作用域是非常重要的。</span><br></pre></td></tr></table></figure>

<ol>
<li>在java编程中，主要的变量就是属性(成员变量)和局部变量。</li>
<li>我们说的局部变量-般是指在成员方法中定义的变量。 [举例Cat类: cry]</li>
<li>java中作用域的分类<br>全局变量:也就是属性，作用域为整个类体；<br>局部变量:也就是除了属性之外的其他变量，作用域为定义它的<strong>代码块</strong>中!</li>
<li>全局变量(属性)可以不赋值，直接使用，因为有默认值，<strong>局部变量必须赋值后，才能使用</strong>，因为没有默认值。</li>
</ol>
<h4 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ol>
<li>属性和局部变量可以重名，访问时遵循就近原则。</li>
<li>在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名。</li>
<li>属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而销毁。即在一次方法调用过程中。</li>
<li>作用域范围不同<br>全局变量&#x2F;属性:可以被本类使用，或其他类使用(通过对象调用)<br>局部变量:只能在本类中对应的方法中使用</li>
<li>修饰符不同<br>全局变量&#x2F;属性可以加修饰符<br>局部变量不可以加修饰符</li>
</ol>
<h2 id="构造方法-构造器"><a href="#构造方法-构造器" class="headerlink" title="构造方法&#x2F;构造器"></a>构造方法&#x2F;构造器</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。</span><br></pre></td></tr></table></figure>

<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ol>
<li>方法名和类名相同。</li>
<li>没有返回值。</li>
<li>在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。</li>
</ol>
<h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] 方法名(形参列表)&#123; 方法体; &#125; </span><br></pre></td></tr></table></figure>
<h3 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h3><ol>
<li>构造器的修饰符可以默认， 也可以是 public protected private</li>
<li>构造器没有返回值。</li>
<li>方法名 和类名字必须一样。</li>
<li>参数列表 和 成员方法一样的规则。</li>
<li>构造器的调用, 由系统完成。</li>
<li>一个类可以定义多个不同的构造器，即构造器重载</li>
<li>构造器是完成对象的初始化，并不是创建对象</li>
<li>在创建对象时,系统自动的调用该类的构造方法</li>
<li>如果程序员没有定义构造器，系统会自动给类生成一 个默认无参构造器(也叫默认构造器)，比如Dog (){}, 可以使用javap指令反编译查看到</li>
<li>一旦定义了自己的构造器,默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下,即: Dog( ){ }</li>
</ol>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="什么是this"><a href="#什么是this" class="headerlink" title="什么是this"></a>什么是this</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java虚拟机会给每个对象分配this，代表当前对象。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单的说，this存储的当前对象的地址，哪个对象调用this，this就代表哪个对象</span><br></pre></td></tr></table></figure>

<h3 id="this-的注意事项和使用细节"><a href="#this-的注意事项和使用细节" class="headerlink" title="this 的注意事项和使用细节"></a>this 的注意事项和使用细节</h3><ol>
<li>this 关键字可以用来访问本类的属性、方法、构造器。</li>
<li>this 用于区分当前类的属性和局部变量。</li>
<li>访问成员方法的语法：this.方法名(参数列表); 。</li>
<li>访问构造器语法：this(参数列表); 注意只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一 条语句)。</li>
<li>this 不能在类定义的外部使用，只能在类定义的方法中使用。</li>
</ol>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="包的作用"><a href="#包的作用" class="headerlink" title="包的作用"></a>包的作用</h3><ol>
<li>区分相同名称的类</li>
<li>当类较多的时候，可以很好的管理类。</li>
<li>控制访问范围。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">包的存在类似于电脑的文件夹，采用树状结构存放其中的文件。同一个包中的类不能重名，但不同包之间可以有重名的类。</span><br></pre></td></tr></table></figure>

<h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="声明存在位置"><a href="#声明存在位置" class="headerlink" title="声明存在位置"></a>声明存在位置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package 包名；</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.test;</span><br></pre></td></tr></table></figure>
<h4 id="包的引入"><a href="#包的引入" class="headerlink" title="包的引入"></a>包的引入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import 包名；</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">improt 包名;</span><br></pre></td></tr></table></figure>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用该包下面的类，可以使用通配符*。如导入Scanner类：</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">建议使用前者，用哪个导哪个。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">部分IDE如Idea回自动导，不需手写。</span><br></pre></td></tr></table></figure>

<h2 id="访问修饰符-访问权限"><a href="#访问修饰符-访问权限" class="headerlink" title="访问修饰符(访问权限)"></a>访问修饰符(访问权限)</h2><table>
<thead>
<tr>
<th>访问级别</th>
<th>访问控制修饰符</th>
<th>同类</th>
<th>同包</th>
<th>子类</th>
<th>不同包</th>
</tr>
</thead>
<tbody><tr>
<td>公开</td>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>保护</td>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>默认（不写）</td>
<td></td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>私有</td>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<ul>
<li>public：对外公开，均可访问</li>
<li>protested：对子类和同一个包中的其他类公开</li>
<li>默认：仅对同一个包中的类公开</li>
<li>private：只有本类成员可以访问，不对外公开。</li>
</ul>
<h2 id="面向对象三大特征：封装、继承、多态。"><a href="#面向对象三大特征：封装、继承、多态。" class="headerlink" title="面向对象三大特征：封装、继承、多态。"></a>面向对象三大特征：封装、继承、多态。</h2><pre><code>将共有的属性抽象出来，封装成一个个小单元，如果需要的新的功能与之前的有些区别，可以通过继承的方式增加属于自己的功能。有些功能可能之前写过了，但不太符合需求，可以通过重写的方式更新对应方法，或者做出来的可能会有好几种的用途，根据用途不同可以重载一下。重载和重写就是多态的具体实现方式。
</code></pre>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将抽象出来的数据（属性）和对数据的操作（方法）打包封装在一起，数据就会被保护在内部（私有化），想要使用只能通过对应的暴露在外面的方法进行操作，这样可以检查操作的合法性。</span><br></pre></td></tr></table></figure>

<h3 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h3><ol>
<li>隐藏实现的细节。</li>
<li>可以对数据进行验证，保证安全合法</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li><p>继承很好的解决了代码复用的问题。类似于函数但比函数功能更加丰富。</p>
</li>
<li><p>对于两个相似的类，可以抽出其中共有的属性和方法，将其封装成父类，然后通过继承的方式继承父类即可，对于有差异的地方可以在继承后的子类中添加。</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 子类名 extends 父类名&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继承的好处"><a href="#继承的好处" class="headerlink" title="继承的好处"></a>继承的好处</h4><ol>
<li>提高了代码的复用性</li>
<li>提高了代码的扩展性和维护性</li>
</ol>
<h3 id="继承的细节"><a href="#继承的细节" class="headerlink" title="继承的细节"></a>继承的细节</h3><ol>
<li>子类继承了所有的属性和方法，非私有的属性可以在子类中直接访问，私有的属性和方法只能通过父类提供的公共方法来访问使用。</li>
<li>子类没有继承父类的构造器，所以必须调用父类的构造器，以完成父类的初始化。</li>
<li>创建子类对象时，不管使用了子类的哪个构造器，默认情况下都会去调用父类的无参构造器完成父类的初始化。如果父类没有预留无参构造器，则在子类中必须手动选择父类的有参构造器，否则编译器会报错。</li>
<li>如果需要指定调用父类的某个构造器，需要显示的调用一下：super(参数列表)</li>
<li>super()在使用的时候，必须放在构造器的第一行（super() 只能在构造器中使用）</li>
<li>super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器中。</li>
<li>java的所有类都是Object类的子类，Object是所有类的基类。</li>
<li>父类的构造器的调用不限于直接父类，可以一直往上追溯到Object类。</li>
<li>子类最多继承一个父类，因为Java是单继承的，因此不存在c++中的二义性的问题。如果一个类需要继承多个类，可以将这几个类串联在一起。</li>
<li>不能滥用继承，子类和父类之间必须满足 is – a的逻辑关系。</li>
</ol>
<h3 id="继承的本质"><a href="#继承的本质" class="headerlink" title="继承的本质"></a>继承的本质</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当子类对象创建成功后，建立的查找关系。当创建了一个子类的时候，所有的属性（包括父类中的）全部都在对象内，但由于访问权限的不同不一定都可以访问。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查找属性和方法时，先从子类（最低级）开始寻找，一直找到最高类Object类。这其中如果有父类存在这个方法或者属性但权限是私有不允许访问的，则就不会继续向上查找，并报private的异常。</span><br></pre></td></tr></table></figure>

<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><ul>
<li>super代表父类的引用，用于访问父类的属性、方法、构造器。</li>
<li>super只能在类内使用，即只能在子类中通过super直接访问上一级中的属性。如果在main中将子类实例化后，不能在main中通过super访问父类。</li>
<li>要注意的是，super不能串联使用。他只能穿透一层。即有重名的属性的化，只能访问离自己最近的那个重名的。</li>
<li>super类似于一个指针（虽然java中没有指针的功能），存储了父类的地址。</li>
</ul>
<h5 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h5><ul>
<li><p>访问父类的属性（不能访问父类的private的属性）</p>
<pre><code>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>.属性名;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li><p>访问父类的方法（同样不能访问private）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>.方法名;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>访问父类的构造器：只能在<strong>第一行</strong></p>
<pre><code> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>(参数列表);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h5 id="super带来的便利"><a href="#super带来的便利" class="headerlink" title="super带来的便利"></a>super带来的便利</h5><ol>
<li>调用父类的构造器。</li>
<li>当子类与父类中的成员重名的时候，为了访问父类的成员，可以通过super访问。但仅限于访问被直接掩盖的。</li>
<li>super的访问不限于直接父类，如果爷爷类和本类中有共同的成员，也可以访问到爷爷类的成员。如果多个基类都有同名的成员，使用super访问遵循就近原则。（即只能穿透一层）</li>
</ol>
<h5 id="super和this的比较"><a href="#super和this的比较" class="headerlink" title="super和this的比较"></a>super和this的比较</h5><table>
<thead>
<tr>
<th>区别点</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody><tr>
<td>访问属性、方法</td>
<td>优先在本类中进行查找，</td>
<td>越过本类，直接在父类中进行查找</td>
</tr>
<tr>
<td>调用构造器</td>
<td>调用本类的构造器，必须放在构造器的首行</td>
<td>调用父类的构造器，必须放在构造器的首行</td>
</tr>
<tr>
<td>特殊</td>
<td>表示当前对象</td>
<td>子类访问父类的对象</td>
</tr>
</tbody></table>
<p>换句话数，this和super类似，一个存储了本类的地址，另一个存储了父类的地址。可以通过这个“地址”来控制访问</p>
<h3 id="方法重写-覆盖："><a href="#方法重写-覆盖：" class="headerlink" title="方法重写&#x2F;覆盖："></a>方法重写&#x2F;覆盖：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单的说，重写（覆盖）就是子类的一个方法，和父类的某个方法的名称、参数均一样，我们就说子类的这个方法覆盖了父类的方法。（类似于重载）</span><br></pre></td></tr></table></figure>

<h4 id="方法覆盖的注意事项和使用细节"><a href="#方法覆盖的注意事项和使用细节" class="headerlink" title="方法覆盖的注意事项和使用细节"></a>方法覆盖的注意事项和使用细节</h4><ol>
<li>子类的方法的形参列表、方法名，要和父类的对应的方法完全一致。</li>
<li>子类的方法的返回值需要和父类中被覆盖的方法保持一样，或者是父类返回类型的子类。如父类返回是Object，子类的返回类型是String，要保证子类的返回值可以向上转型为父类。</li>
<li>被覆盖的方法不能是private，否则只是在其子类中新定义了一个方法，并没有对其覆盖。</li>
<li>子类的方法不能缩小父类方法的访问权限，如父类是protected，子类可以是public、protected，但不能是private。</li>
</ol>
<h4 id="方法的重写和重载的对比"><a href="#方法的重写和重载的对比" class="headerlink" title="方法的重写和重载的对比"></a>方法的重写和重载的对比</h4><table>
<thead>
<tr>
<th align="left">名称</th>
<th>发生范围</th>
<th>方法名</th>
<th>形参列表</th>
<th>返回类型</th>
<th>修饰符</th>
</tr>
</thead>
<tbody><tr>
<td align="left">重载  (overload)</td>
<td>本类</td>
<td>必须一样</td>
<td>类型，个数或者顺序至少有一个不同。</td>
<td>无要求</td>
<td>无要求</td>
</tr>
<tr>
<td align="left">重写  (override)</td>
<td>父子类</td>
<td>必须一样</td>
<td>相同</td>
<td>子类重写的方法，返回类型和父类返回的类型一致，或者是其子类</td>
<td>子类方法不能缩小父类方法的访问范围。</td>
</tr>
</tbody></table>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li>方法或对象具有多种形态。</li>
<li>多态是面向对象的第三大特征。</li>
<li>多态是建立在封装和继承的基础上的。</li>
</ul>
<h3 id="多态的具体体现"><a href="#多态的具体体现" class="headerlink" title="多态的具体体现"></a>多态的具体体现</h3><p>1.方法的多态</p>
<ul>
<li>重写和重载。</li>
</ul>
<p>2、 对象的多态</p>
<ul>
<li>一个对象的编译类型和运行类型可以不一致。</li>
<li>编译类型在定义对象时，就已经确定了，不能更改。</li>
<li>运行类型是可以变化的（向上转型、向下转型）</li>
<li>编译类型看&#x3D;左边，运行类型看&#x3D;右边。</li>
</ul>
<h3 id="多态的注意事项"><a href="#多态的注意事项" class="headerlink" title="多态的注意事项"></a>多态的注意事项</h3><ol>
<li>多态的前提：两个对象（类）存在继承关系。</li>
<li>多态的向上转型：</li>
</ol>
<h3 id="多态的向下转型"><a href="#多态的向下转型" class="headerlink" title="多态的向下转型"></a>多态的向下转型</h3><h5 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将向上转型后的父类重新指回子类。</span><br></pre></td></tr></table></figure>

<h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子类类型 引用名 = （子类类型）父类类型;</span><br></pre></td></tr></table></figure>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>只能强转父类的引用，不能强转父类的对象。即对象是子类的，但是被父类引用了。</li>
<li>要求父类的引用必须指向的是当前目标类型的对象。</li>
<li>向下转型后，可以调用子类类型中所有的成员。</li>
</ol>
<h3 id="属性没有重写之说"><a href="#属性没有重写之说" class="headerlink" title="属性没有重写之说"></a>属性没有重写之说</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要注意，如果出现一个父类的引用指向了子类出现了向上转型的情况，当通过父类调用子类方法的时候，是可以正常调用的；但如果通过父类调用属性，则调用的会是父类自身的属性。如下代码可见：</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单的说就是，属性没有重写之说，属性的值看编译类型。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于向上转型后的引用来说，只有方法是转型成功的，属性只能看引用的类。如果非要访问可以通过向下转型进行访问。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//属性没有重写之说！属性的值看编译类型</span></span><br><span class="line">        <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();<span class="comment">//向上转型</span></span><br><span class="line">        System.out.println(base.count);<span class="comment">// ？ 看编译类型 10</span></span><br><span class="line">        base.f();</span><br><span class="line">        <span class="type">Sub</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">        System.out.println(sub.count);<span class="comment">//? 20</span></span><br><span class="line">        sub.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="comment">//父类</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;<span class="comment">//子类</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;<span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sub&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果确实需要在向上转型的同时访问子类的属性，可以手动的向下转型一下，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//属性没有重写之说！属性的值看编译类型</span></span><br><span class="line">        <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();<span class="comment">//向上转型</span></span><br><span class="line">        System.out.println(base.count);<span class="comment">// ？ 看编译类型 10</span></span><br><span class="line">        base.f();</span><br><span class="line">        <span class="type">Sub</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">        System.out.println(sub.count);<span class="comment">//? 20</span></span><br><span class="line">        sub.f();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=================================&quot;</span>);</span><br><span class="line">        System.out.println(((Sub)base).count);<span class="comment">// 20</span></span><br><span class="line">        System.out.println(sub.count);<span class="comment">//? 20</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="comment">//父类</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;<span class="comment">//子类</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;<span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sub&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java的动态绑定机制"><a href="#Java的动态绑定机制" class="headerlink" title="Java的动态绑定机制"></a><strong>Java的动态绑定机制</strong></h2><ol>
<li>当调用<strong>对象方法</strong>的时候，<strong>该方法会和该对象的内存地址&#x2F;运行类型绑定</strong>。</li>
<li>当调用<strong>对象属性</strong>的时候，<strong>没有动态绑定机制</strong>，哪里声明，就在那里使用。</li>
</ol>
<h2 id="多态的应用"><a href="#多态的应用" class="headerlink" title="多态的应用"></a>多态的应用</h2><h3 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将数组的定义类型定义为父类，里面保存的实际元素类型为子类对象。（利用向上转型的规则）</span><br></pre></td></tr></table></figure>

<h3 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在某个方法中，传入的参数可以是父类的形参，在方法中通过instanceof进行类型判断，如果属于类型A，就执行类型A对应的语句，否则就执行另一种预设的语句。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常用于面对不同身份进行不同的操作。不需要对方法进行重载就能完成。</span><br></pre></td></tr></table></figure>

<h2 id="Object类详解（equals方法）"><a href="#Object类详解（equals方法）" class="headerlink" title="Object类详解（equals方法）"></a>Object类详解（equals方法）</h2><h3 id="equals与-的区别："><a href="#equals与-的区别：" class="headerlink" title="equals与&#x3D;&#x3D;的区别："></a>equals与&#x3D;&#x3D;的区别：</h3><p>&#x3D;&#x3D;：</p>
<ol>
<li>&#x3D;&#x3D;既可以判断基本类型，也可以贩毒案引用类型。</li>
<li>如果判断的是基本类型，判断的是值是否相等。</li>
<li>如果判断的是引用类型如String，则判断是否是同一个对象。（引用类型的本质是指针，&#x3D;&#x3D;只能简单的判断两个值是否相等</li>
</ol>
<p>equals：</p>
<ol>
<li>equals是Object类中的方法，只能判断引用类型。</li>
<li>默认判断的是地址是否相同，但在子类中常常重写这个方法。如在String中就重写了，可以判断字符串的值是否相等。</li>
</ol>
<h1 id="面向对象-中级部分"><a href="#面向对象-中级部分" class="headerlink" title="面向对象 中级部分"></a>面向对象 中级部分</h1><h2 id="类变量和类方法"><a href="#类变量和类方法" class="headerlink" title="类变量和类方法"></a>类变量和类方法</h2><h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><h4 id="类变量介绍"><a href="#类变量介绍" class="headerlink" title="类变量介绍"></a>类变量介绍</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果一个类创建的所有对象都需要一个变量（如进行计数），就可以将这个变量设置在类内，并设置成静态变量。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类变量也叫静态变量/静态属性，是该类的所有对象共享的变量,任何一个该类的对象去访问它时,取到的都是相同的值，同样任何一个该类的对象去修改它时修改的也是同一个变量。而且，在类没有实例化成对象的情况下，也可以使用</span><br></pre></td></tr></table></figure>

<h4 id="类变量的定义（基本语法）"><a href="#类变量的定义（基本语法）" class="headerlink" title="类变量的定义（基本语法）"></a>类变量的定义（基本语法）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 数据类型 变量名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//这个就是类变量，他的关键字是static。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(A.n);<span class="comment">//虽然没有实例化，但还是一样可以访问。并且在访问的一瞬间，就会完成类的加载（只会加载一次）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类变量的访问"><a href="#类变量的访问" class="headerlink" title="类变量的访问"></a>类变量的访问</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名.类变量名</span><br></pre></td></tr></table></figure>
<h4 id="类变量使用时的注意事项和细节"><a href="#类变量使用时的注意事项和细节" class="headerlink" title="类变量使用时的注意事项和细节"></a>类变量使用时的注意事项和细节</h4><ol>
<li>什么时候需要用类变量：<br>当我们需要让某个类的所有对象都共享一个变量时， 就可以考虑使用类变量(静态变量):比如:定义学生类，统计所有学生共交多少钱。</li>
<li>类变量与实例变量(普通属性)区别：<br>类变量是该类的所有对象共享的，而实例变量是每个对象独享的。</li>
<li>加上static称为类变量或静态变量，否则称为实例变量&#x2F;普通变量&#x2F;非静态变量 。</li>
<li>类变量可以通过类名.类变量名或者对象名.类变量名来访问，但java设计者推荐我们使用类名.类变量名方式访问。[前提是 <strong>满足访问修饰符的访问权限和范围</strong>]。</li>
<li>实例变量不能通过类名类变量名方式访问。</li>
<li>类变量是在类加载时就初始化了,也就是说，即使你没有创建对象，只要类加载了，就可以使用类变量了。（在使用的一瞬间就会加载）</li>
<li>类变量的生命周期是随类的加载开始，随着类消亡而销毁。</li>
</ol>
<h4 id="类变量的内存布局"><a href="#类变量的内存布局" class="headerlink" title="类变量的内存布局"></a><em>类变量的内存布局</em></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">*在JDK7以前，类变量存储在方法区；在JDK8以后，则就存储在了堆中*</span><br><span class="line"></span><br><span class="line">### 类方法</span><br><span class="line"></span><br><span class="line">#### 基本介绍</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>类方法也叫静态方法，具体细节和上方的类变量类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 基本语法</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">访问修饰符 static 数据返回类型 方法名()&#123;</span><br><span class="line">  //语句体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">  public static void f()&#123;//静态方法</span><br><span class="line">    System.out.println(&quot;类A中的静态方法f()已被调用&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      A.f();//调用了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类方法的经典使用场景"><a href="#类方法的经典使用场景" class="headerlink" title="类方法的经典使用场景"></a>类方法的经典使用场景</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法提高开发效率。</span><br></pre></td></tr></table></figure>

<h4 id="类方法使用注意事项和细节"><a href="#类方法使用注意事项和细节" class="headerlink" title="类方法使用注意事项和细节"></a>类方法使用注意事项和细节</h4><ol>
<li><p>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区:</p>
<p><strong>类方法中无this的参数</strong><br><strong>普通方法中隐含着this的参数</strong></p>
</li>
<li><p>类方法可以通过类名调用，也可以通过对象名调用。</p>
</li>
<li><p>普通方法和对象有关，需要通过对象名调用，比如对象名.方法名(参数)，不能通过类名调用。</p>
</li>
<li><p>类方法中不允许使用和对象有关的关键字，比如this和super。 普通方法(成员方法)可以。</p>
</li>
<li><p>类方法(静态方法)中只能访问静态变量或静态方法.</p>
</li>
<li><p>普通成员方法，既可以访问非静态成员，也可以访问静态成员。</p>
</li>
</ol>
<p>小结:静态方法， 只能访问静态的成员,非静态的方法，可以访问静态成员和非静态成员(必须遵守访问权限)</p>
<h2 id="main方法语法"><a href="#main方法语法" class="headerlink" title="main方法语法"></a>main方法语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main方法的形式: public static void main(String[] args)&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>main方法时虚拟机调用</li>
<li>java虚拟机需要调用类的main() 方法，所以该方法的访问权限必须是public</li>
<li>java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static</li>
<li>该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数</li>
<li>java 执行的程序参数1参数2参数3 [举例说明:]</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java 运行的类名 第一个参数 第二个参数 第三个参数 ...</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对应到args数组中：第一个元素，第二个元素，第三个元素...</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>在 main()方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性。</li>
<li>但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。比如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MAIN</span> &#123;</span><br><span class="line">    <span class="comment">//静态的变量/属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="comment">//非静态的变量/属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MAIN 的 hi 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MAIN 的 cry 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//可以直接使用 name</span></span><br><span class="line"><span class="comment">//1. 静态方法 main 可以访问本类的静态成员</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name=&quot;</span> + name);</span><br><span class="line">        hi();</span><br><span class="line"><span class="comment">//2. 静态方法 main 不可以访问本类的非静态成员</span></span><br><span class="line"><span class="comment">//System.out.println(&quot;n1=&quot; + n1);//错误</span></span><br><span class="line"><span class="comment">//cry();</span></span><br><span class="line"><span class="comment">//3. 静态方法 main 要访问本类的非静态成员，需要先创建对象 , 再调用即可</span></span><br><span class="line">        <span class="type">MAIN</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MAIN</span>();</span><br><span class="line">        System.out.println(MAIN.n1);<span class="comment">//ok</span></span><br><span class="line">        MAIN.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">name=Hello</span></span><br><span class="line"><span class="comment">MAIN 的 hi 方法</span></span><br><span class="line"><span class="comment">10000</span></span><br><span class="line"><span class="comment">MAIN 的 cry 方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码化块又称为初始化块属于类中的成员[即是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过&#123;&#125;包围起来。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">但和方法不同，没有方法名，没有返回，没有叁数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。</span><br></pre></td></tr></table></figure>

<h3 id="基本语法-4"><a href="#基本语法-4" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符]&#123;</span><br><span class="line">  <span class="comment">//语句组；</span></span><br><span class="line">&#125;[;]</span><br></pre></td></tr></table></figure>
<h4 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>修饰符可选，且只能是static</li>
<li>代码块可分为两大类，一是加上修饰符的静态代码块，二是没加修饰符的普通代码块&#x2F;非静态代码块</li>
<li>逻辑语句可以为任何逻辑语句，包括但不限于输入、输出、方法调用、循环、判断等</li>
<li>结尾的分号可以缺省</li>
</ol>
<h3 id="代码块的作用、注意事项、细节"><a href="#代码块的作用、注意事项、细节" class="headerlink" title="代码块的作用、注意事项、细节"></a>代码块的作用、注意事项、细节</h3><ol>
<li><p>相当于另一种形式的构造器（对原有构造器的补充），可以进行初始化操作</p>
</li>
<li><p>使用的场景：如果多个构造器中都有重复的语句，就可以将这些重复的语句抽取到块中，提高代码的复用性。</p>
</li>
<li><p>static代码块也叫静态代码块，作用是对类进行初始化。<strong>它随着类的加载而执行，并且只会执行一次</strong>。如果是普通代码块，则在创建（实例化）出一个对象的时候，就执行一次。</p>
</li>
<li><p>类什么时候会被加载：</p>
<ol>
<li>创建对象实例的时候（new）</li>
<li>创建子类对象实例时，父类也会被加载</li>
<li>使用类的静态成员时</li>
</ol>
</li>
<li><p>普通的代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次。如果只是使用类的静态成员时，普通代码块并不会执行。</p>
</li>
<li><p>创建一个对象时，在一个类的调用顺序是：</p>
<ol>
<li>调用静态代码块和静态属性初始化（注意，静态代码块和静态属性初始化调用的优先级相等，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）。</li>
<li>调用普通代码块和普通属性的初始化（注意普通代码块和普通属性初始化调用的优先级相等，如果有多个普通代码块和多个普通变量初始化，则按他们定义的顺序调用）。</li>
<li>最后调用构造方法。（构造方法的优先级最低）</li>
</ol>
</li>
<li><p>构造器的最前面隐藏了super()和调用普通代码块的语句。（先super后普通）。</p>
</li>
<li><p>创建一个子类对象时（继承关系），他们的静态代码块、静态属性初始化、普通代码块、普通属性初始化、构造方法的调用顺序如下：</p>
<ol>
<li><p>父类的静态代码块和静态属性（按定义的顺序执行）；</p>
</li>
<li><p>子类的静态代码块和静态属性（按定义的顺序执行）；</p>
</li>
<li><p>父类的普通代码块和普通属性初始化；</p>
</li>
<li><p>父类的构造方法；</p>
</li>
<li><p>子类的普通代码块和普通属性初始化；</p>
</li>
<li><p>子类的构造方法；</p>
<blockquote>
<p>个人理解：</p>
<p>将子类实例化的过程：</p>
<p>首先调用了子类的构造方法，因为构造方法第一条语句是super，因此会去调用父类的构造方法，父类的构造方法里也有一个super，有去寻找直接父类的父类直到Object为止。到达Object后，运行Object的静态代码块（因为加载类了），然后加载下一级的静态代码，一直到被实例化的子类为止。将子类加载完后，然后依次将各个类都进行实例化，此时首先运行Object类的普通代码块和构造方法（因为创建对象了），然后按照普通代码块和属性、构造方法的顺序，直到子类完成。（算是递归的思想？好像不太对，因为调用的不是自身）</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<p>小结:</p>
<ol>
<li>static代码块是类加载时执行，只会执行一次。（因为类只会执行一次）</li>
<li>普通代码块是在创建对象时调用的，创建一次，调用一次。（每个对象各调用一次）</li>
<li>类加载的3种情况， 需要记住。（上面第四条）</li>
</ol>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><h5 id="样例1：无继承，两次调用类的静态属性，再实例化对象"><a href="#样例1：无继承，两次调用类的静态属性，再实例化对象" class="headerlink" title="样例1：无继承，两次调用类的静态属性，再实例化对象"></a>样例1：无继承，两次调用类的静态属性，再实例化对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;···············&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次调用静态属性&quot;</span>);</span><br><span class="line">        System.out.println(A.n1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;···············&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次调用静态属性&quot;</span>);</span><br><span class="line">        System.out.println(A.n1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;···············&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次实例化对象&quot;</span>);</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//静态属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;<span class="comment">//普通属性</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通代码块被执行&quot;</span>);<span class="comment">//普通代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块被执行&quot;</span>);<span class="comment">//静态代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果如下：</p>
<p>···············<br>第一次调用静态属性<br>静态代码块被执行<br>100<br>···············<br>第二次调用静态属性<br>100<br>···············<br>第一次实例化对象<br>普通代码块被执行</p>
</blockquote>
<h5 id="样例2-有继承，连续调用两次子类的静态属性，调用一次继承得到的父类的属性，然后将子类实例化成对象"><a href="#样例2-有继承，连续调用两次子类的静态属性，调用一次继承得到的父类的属性，然后将子类实例化成对象" class="headerlink" title="样例2 有继承，连续调用两次子类的静态属性，调用一次继承得到的父类的属性，然后将子类实例化成对象"></a>样例2 有继承，连续调用两次子类的静态属性，调用一次继承得到的父类的属性，然后将子类实例化成对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;···············&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次调用子类的静态属性&quot;</span>);</span><br><span class="line">        System.out.println(B.n3);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;···············&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次调用子类静态属性&quot;</span>);</span><br><span class="line">        System.out.println(B.n3);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;···············&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次调用父类静态属性&quot;</span>);</span><br><span class="line">        System.out.println(B.n1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;···············&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次实例化对象&quot;</span>);</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类A的构造方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//静态属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;<span class="comment">//普通属性</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类A:普通代码块被执行&quot;</span>);<span class="comment">//普通代码块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类A:静态代码块被执行&quot;</span>);<span class="comment">//静态代码块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类B:普通代码块被执行&quot;</span>);<span class="comment">//普通代码块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类B:静态代码块被执行&quot;</span>);<span class="comment">//静态代码块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span> <span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类B的构造方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：</p>
<p>···············<br>第一次调用子类的静态属性<br>类A:静态代码块被执行<br>类B:静态代码块被执行<br>300<br>···············<br>第二次调用子类静态属性<br>300<br>···············<br>第一次调用父类静态属性<br>100<br>···············<br>第一次实例化对象<br>类A:普通代码块被执行<br>类A的构造方法被调用<br>类B:普通代码块被执行<br>类B的构造方法被调用</p>
</blockquote>
<h5 id="样例3-三次继承继承，直接对子类进行实例化操作"><a href="#样例3-三次继承继承，直接对子类进行实例化操作" class="headerlink" title="样例3 三次继承继承，直接对子类进行实例化操作"></a>样例3 三次继承继承，直接对子类进行实例化操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类A的构造方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//静态属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;<span class="comment">//普通属性</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类A:普通代码块被执行&quot;</span>);<span class="comment">//普通代码块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类A:静态代码块被执行&quot;</span>);<span class="comment">//静态代码块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类B:普通代码块被执行&quot;</span>);<span class="comment">//普通代码块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类B:静态代码块被执行&quot;</span>);<span class="comment">//静态代码块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span> <span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类B的构造方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n4</span> <span class="operator">=</span> <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类C:普通代码块被执行&quot;</span>);<span class="comment">//普通代码块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类C:静态代码块被执行&quot;</span>);<span class="comment">//静态代码块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span> <span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类C的构造方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：</p>
<p>类A:静态代码块被执行<br>类B:静态代码块被执行<br>类C:静态代码块被执行<br>类A:普通代码块被执行<br>类A的构造方法被调用<br>类B:普通代码块被执行<br>类B的构造方法被调用<br>类C:普通代码块被执行<br>类C的构造方法被调用</p>
</blockquote>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><ol>
<li>静态方法和属性的使用。</li>
<li>设计模式是在大量的事件中总结和理论化之后优选的代码结构、编程风格以及解决问题的思考方式。设计模式类似于数学的公式，免得我们自己再思考和摸索。</li>
</ol>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单例，就是指单个实例。所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对于某个类只能存在一个对象实例，并且该类只提供一个获取其对象实例的方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单例模式有两种实现方式，一是饿汉式，二是懒汉式。具体特点在后面。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">大致的实现步骤如下：</span><br></pre></td></tr></table></figure>

<pre><code>        1. 构造器私有化，防止直接new。
        2. 在类的内部创建一个对象
        3. 向外暴露一个静态的方法，以获取其创建的对象
</code></pre>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类A的对象&quot;</span>);</span><br><span class="line">        <span class="comment">//A a = new A();//不再能通过new的方式进行新建</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> A.getA();<span class="comment">//只能通过暴露的接口获取到对象。在获取的一瞬间对象就会被创建出来。</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        <span class="type">A</span> <span class="variable">b</span> <span class="operator">=</span> A.getA();</span><br><span class="line">        System.out.println(a == b);<span class="comment">//不管怎么获取，获取到的都是同一个对象。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String ID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();<span class="comment">//饿汉式的特点：直接创建对象，不管是否有需求。为了能在静态方法中返回，需要设置成静态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">A</span><span class="params">()</span> &#123;<span class="comment">//私有化构造函数防止被new，除此之外和普通的构造函数一样。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;类A的构造器被调用&quot;</span>);</span><br><span class="line">        name = <span class="string">&quot;nono&quot;</span>;</span><br><span class="line">        ID = <span class="string">&quot;00001&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">getA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name:&quot;</span> + name + <span class="string">&quot;  ID:&quot;</span> + ID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：</p>
<p>获取类A的对象<br>类A的构造器被调用<br>name:nono  ID:00001<br>true</p>
</blockquote>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类A的对象&quot;</span>);</span><br><span class="line">        <span class="comment">//A a = new A();//不再能通过new的方式进行新建</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> A.getInstanceA();<span class="comment">//只能通过暴露的接口获取到对象。在获取的一瞬间对象才会被创建出来。</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        <span class="type">A</span> <span class="variable">b</span> <span class="operator">=</span> A.getInstanceA();</span><br><span class="line">        System.out.println(a == b);<span class="comment">//同样，不管怎么获取，获取到的都是同一个对象。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String ID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> A a;<span class="comment">//懒汉式特点：类加载的时候不会自动创建对象，只有在调用的时候才会创建</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">A</span><span class="params">()</span> &#123;<span class="comment">//构造函数仍然是私有化的，防止被new，除此之外和普通的构造函数一样。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;类A的构造器被调用&quot;</span>);</span><br><span class="line">        name = <span class="string">&quot;nono&quot;</span>;</span><br><span class="line">        ID = <span class="string">&quot;00001&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">getInstanceA</span><span class="params">()</span> &#123;<span class="comment">//只有调用这个方法的时候，对象才会被创建出来，节省空间，但有可能会造成线程异常。比如在多线程访问时，多个线程都进来了但对象还没创建好，这时就会造成重复创建的问题。只会保留最后一个创建的对象</span></span><br><span class="line">        <span class="keyword">if</span>(a == <span class="literal">null</span>) &#123;<span class="comment">//如果还没有创建对象，就创建</span></span><br><span class="line">            a = <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name:&quot;</span> + name + <span class="string">&quot;  ID:&quot;</span> + ID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：</p>
<p>获取类A的对象<br>类A的构造器被调用<br>name:nono  ID:00001<br>true</p>
</blockquote>
<h4 id="饿汉式和懒汉式的区别"><a href="#饿汉式和懒汉式的区别" class="headerlink" title="饿汉式和懒汉式的区别"></a>饿汉式和懒汉式的区别</h4><ol>
<li>二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建。</li>
<li>饿汉式不存在线程安全问题，懒汉式存在线程安全问题。</li>
<li>饿汉式存在浪费资源的可能。因为如果一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。</li>
<li>在我们javaSE标准类中，java.lang.Runtime就是经典的单例模式。</li>
</ol>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><h3 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final中文意思:最后的，最终的。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final可以修饰类、属性、方法和局部变量。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在某些情况下，可能有以下需求，就会使用到final：</span><br></pre></td></tr></table></figure>

<pre><code>    1. 当不希望类被继承时，可以用final修饰；
    2. 当不希望父类的某个方法被子类覆盖/重写(override)时，可以用final关键字修饰；
    3. 当不希望类的的某个属性的值被修改，可以用final修饰；
    4. 当不希望某个局部变量被修改，可以使用final修饰；
</code></pre>
<blockquote>
<p>简单的说，只要经过final修饰，只要本质还是原来的，就不允许修改。</p>
</blockquote>
<h3 id="使用方法-样例-："><a href="#使用方法-样例-：" class="headerlink" title="使用方法(样例)："></a>使用方法(样例)：</h3><h4 id="样例1-要求某一个类不能被其他类继承"><a href="#样例1-要求某一个类不能被其他类继承" class="headerlink" title="样例1 要求某一个类不能被其他类继承"></a>样例1 要求某一个类不能被其他类继承</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果要求下面的类A不能被其他类所继承，可以在前面加上final修饰</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*//此时就会报错</span></span><br><span class="line"><span class="comment">class B extends A&#123; &#125;*/</span></span><br></pre></td></tr></table></figure>
<h4 id="样例2-要求类中的某个方法不能被子类修改（重写-覆盖）"><a href="#样例2-要求类中的某个方法不能被子类修改（重写-覆盖）" class="headerlink" title="样例2 要求类中的某个方法不能被子类修改（重写&#x2F;覆盖）"></a>样例2 要求类中的某个方法不能被子类修改（重写&#x2F;覆盖）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//如果希望某个类中的某个方法不被改写或覆盖，同样也可以用final修饰一下</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是类A独有的方法，不允许被重写&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    此时如果想要重写父类中的被final修饰了的方法是不可以的</span></span><br><span class="line"><span class="comment">    public final void fun()&#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;对类A的方法进行重写&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="样例3-要求类中的某个属性不能被修改（即设置成常量）"><a href="#样例3-要求类中的某个属性不能被修改（即设置成常量）" class="headerlink" title="样例3 要求类中的某个属性不能被修改（即设置成常量）"></a>样例3 要求类中的某个属性不能被修改（即设置成常量）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//如果希望某个类中的某个属性不被改写或覆盖，同样也可以用final修饰一下</span></span><br><span class="line">    <span class="comment">//被final修饰的属性必须赋初值。赋初值的地方可以有三种。一是在定义时如a1，二是利用构造方法，三是利用代码块。</span></span><br><span class="line">    <span class="comment">//需要注意的是，初始化的地方只能在三个里面选一个。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> a2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> a3;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        a3 = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public void fun()&#123;//如果试图修改这个属性，就会报错。</span></span><br><span class="line"><span class="comment">        a=1;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        a2 = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">200</span>;<span class="comment">//但子类可以对这个继承下来的属性进行重写</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public void fun() &#123;//如果不重写就试图修改这个属性，就会报错。</span></span><br><span class="line"><span class="comment">        super.a = 1;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="样例4-要求类中的某个属性不能被修改，且这个属性是静态的"><a href="#样例4-要求类中的某个属性不能被修改，且这个属性是静态的" class="headerlink" title="样例4  要求类中的某个属性不能被修改，且这个属性是静态的"></a>样例4  要求类中的某个属性不能被修改，且这个属性是静态的</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//可以直接赋初值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">public</span> <span class="type">int</span> n2 ;</span><br><span class="line">    <span class="comment">//static final public int n3 ;//但不可以在普通代码块或者构造方法中初始化。因为这个两个的根本是对象，而静态是属于类的。</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        n2 = <span class="number">200</span>;<span class="comment">//也可以在静态代码块中赋初值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        n3 = 300;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    public A()&#123;</span></span><br><span class="line"><span class="comment">        n3 = 300;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="final使用注意事项和细节"><a href="#final使用注意事项和细节" class="headerlink" title="final使用注意事项和细节"></a>final使用注意事项和细节</h3><ol>
<li><p>final修饰的属性又叫常量，一般用XX_XX_XX来命名；&#x2F;&#x2F;即全大写，类似于c中define的标准</p>
</li>
<li><p>**final修饰的属性在定义时必须赋初值，并且以后不能再修改，赋值可以在如下位置之一 [选择一个位置赋初值即可，只能选择一个] **;<br>①定义时:如public final double TAX RATE&#x3D;0.08<br>②在构造器中<br>③在代码块中。</p>
</li>
<li><p>如果final修饰的属性是静态的，则初始化的位置只能是<br>①定义时<br>②在静态代码块不能在构造器中赋值。</p>
</li>
<li><p>final类不能继承，但是可以实例化对象。</p>
</li>
<li><p>如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。</p>
</li>
<li><p>一般来说，如果一个类已经是final类了，就没必要再将方法修饰成final方法。（修饰成final方法的目的在于防止子类的重写，但final类就已经不允许有子类，不可能会在子类中对方法进行重写）</p>
</li>
<li><p>final不能修饰构造方法（构造器）。（因为子类不会继承父类的构造器）</p>
</li>
<li><p>final和static往往都会搭配使用，效率更高，不会导致类加载。因为底层的编译器对此做了优化。</p>
<p>我们知道，在类加载的时候会同时加载静态代码块，可以利用静态代码块来检查类是否被加载了。</p>
<p>比如以下代码，会在调用类A的静态属性之前，先将类进行加载，因为在输出100之前，会先输出 类A被加载了 ;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(A.n1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类A被加载了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果改成下方的样子,在属性前面加上一个final，类A就就不会被加载，会直接输出100；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(A.n1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;<span class="comment">//此时调用n1的值的时候，类就不会加载了。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;类A被加载了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>各种包装类如Integer,Double,Float,Boolean,String等都是final类。</p>
</li>
</ol>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当父类的某些方法需要声明但又不确定如何实现时，就可以将其声明为抽象方法，那么这个类就是抽象类。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰的类就是抽象类。</span><br></pre></td></tr></table></figure>

<h3 id="抽象类的介绍"><a href="#抽象类的介绍" class="headerlink" title="抽象类的介绍"></a>抽象类的介绍</h3><ol>
<li><p>用abstract关键字类修饰一个类时，这个类就叫做抽象类。<strong>一旦类是抽象类，那么这个类就不能实例化</strong>，因为对编译器来说这个类并没有完成全部的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">abstract</span> 类名&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用abstract关键字来修饰一个方法时，这个方法就是抽象方法。需要注意的是，<strong>抽象方法只有声明，没有方法体</strong>。<strong>如果需要定义抽象方法，则该对象所处的类一定要是抽象类</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">abstract</span> 类名&#123;</span><br><span class="line">  访问修饰符 <span class="keyword">abstract</span> 返回类型 方法名(参数列表);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>抽象类的价值更多作用时在于设计，是设计者设计好后，让子类继承并实现抽象类。</p>
</li>
<li><p>抽象类在框架和设计模式中使用的比较多。</p>
</li>
</ol>
<h3 id="抽象类的使用样例"><a href="#抽象类的使用样例" class="headerlink" title="抽象类的使用样例"></a>抽象类的使用样例</h3><h4 id="样例1-abstract类，但没有抽象方法"><a href="#样例1-abstract类，但没有抽象方法" class="headerlink" title="样例1 abstract类，但没有抽象方法"></a>样例1 abstract类，但没有抽象方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//A a = new A();//虽然其中没有任何成员，但依然不能实例化成对象。报错信息：&#x27;A&#x27; 为 abstract；无法实例化。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;<span class="comment">//如果仅是抽象类没有抽象方法，可以不需要继承实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="样例2-abstract方法"><a href="#样例2-abstract方法" class="headerlink" title="样例2 abstract方法"></a>样例2 abstract方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//A a = new A();//抽象类不能实例化成对象报错信息：&#x27;A&#x27; 为 abstract；无法实例化。</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(b.sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... num)</span>;<span class="comment">//如果类中含有抽象方法，则类必须也是抽象类（加上abstract修饰符）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... num)</span> &#123;<span class="comment">//抽象类中必须要有一个子类实现父类的抽象方法，不然会报错。如果没有抽象方法，可以不用继承</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">            sum += num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象类使用的注意事项和细节"><a href="#抽象类使用的注意事项和细节" class="headerlink" title="抽象类使用的注意事项和细节"></a>抽象类使用的注意事项和细节</h3><ol>
<li>抽象类不能被实例化。</li>
<li>抽象类不一定包含抽象方法。</li>
<li>一旦类包含了abstract方法则这个类必须声明为abstract。</li>
<li>abstract只能修饰类和方法，不能修饰属性和其它的。</li>
<li>抽象类可以有任意成员[抽象类本质还是类] ,比如:非抽象方法、构造器、静态属性等等。</li>
<li>抽象方法不能有主体，即不能实现。</li>
<li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类。</li>
</ol>
<ol start="8">
<li>抽象方法不能使用private、 final和static来修饰， 因为这些关键字都是和重写相违背的。</li>
</ol>
<h3 id="抽象类最佳实践-模板设计模式"><a href="#抽象类最佳实践-模板设计模式" class="headerlink" title="抽象类最佳实践-模板设计模式"></a>抽象类最佳实践-模板设计模式</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</span><br></pre></td></tr></table></figure>

<h4 id="模板设计模式能解决的问题"><a href="#模板设计模式能解决的问题" class="headerlink" title="模板设计模式能解决的问题"></a>模板设计模式能解决的问题</h4><ol>
<li>当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</li>
<li>编写一个抽象父类， 父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，就是一种模板模式。</li>
</ol>
<h4 id="案例：求-求和-过程中的时间，可以是求1-2-n的值，也可以是求1x2xn的值"><a href="#案例：求-求和-过程中的时间，可以是求1-2-n的值，也可以是求1x2xn的值" class="headerlink" title="案例：求 求和 过程中的时间，可以是求1+2+n的值，也可以是求1x2xn的值"></a>案例：求 求和 过程中的时间，可以是求1+2+n的值，也可以是求1x2xn的值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.fun(<span class="number">1000000000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;.................................&quot;</span>);</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.fun(<span class="number">1000000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">long</span> n)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">strat</span> <span class="operator">=</span> System.currentTimeMillis();<span class="comment">//获取现在的时间，（精确到毫秒）</span></span><br><span class="line">        job(n);<span class="comment">//大体的公式放在这，具体的实现细节由子类完成</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();<span class="comment">//获取现在的时间，（精确到毫秒）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;消耗的时间为 &quot;</span> + (end - strat));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">(<span class="type">long</span> n)</span>;<span class="comment">//中间需要进行一些运算，但目前还不知道运算的过程，所以设置成抽象类，由子类进行计算</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">(<span class="type">long</span> n)</span> &#123;<span class="comment">//子类完成具体的实现过程</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">(<span class="type">long</span> n)</span> &#123;<span class="comment">//而且可以个性化</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum *= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：</p>
<p>消耗的时间为 316<br>……………………………<br>消耗的时间为 719</p>
</blockquote>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接口就是给出一些没有实现的方法,封装到一 起，到某个类要使用的时候，在根据具体情况把这些方法写出来。</span><br></pre></td></tr></table></figure>

<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义接口 </span></span><br><span class="line">访问修饰符 interface 接口名 &#123;</span><br><span class="line">   <span class="comment">//接口内的方法，修饰符默认带有public 和 abstract （对于方法）。不可以是别的</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将接口应用到某个类某个类</span></span><br><span class="line">class 类名 implements 接口 [,接口<span class="number">2</span> ,接口<span class="number">3.</span>..]&#123;</span><br><span class="line">	自己属性:</span><br><span class="line">	自己方法;</span><br><span class="line">  <span class="comment">//类似于继承了抽象类，必须实现接口中定义的所有方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//某个类通过接口调用其他的类</span></span><br><span class="line">class 类名 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(UsbInterface usbInterface)</span>&#123;<span class="comment">//方法名正常，就是形参变成了定义的接口。编译器会自动调用类的对应实现的方法。如下方样例所示。类似于抽象类和向上转型的集合？系统会自动调用，不需要自己声明了</span></span><br><span class="line">        usbInterface.start();<span class="comment">//</span></span><br><span class="line">        usbInterface.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="样例1-接口入门"><a href="#样例1-接口入门" class="headerlink" title="样例1 接口入门"></a>样例1 接口入门</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.Interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="type">Camera</span> <span class="variable">camera</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera</span>();</span><br><span class="line"></span><br><span class="line">        computer.work(phone);</span><br><span class="line">        computer.work(camera);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UsbInterface</span> &#123;<span class="comment">//定义了一个接口，使用该接口的类必须实现其中定义的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;<span class="comment">//默认自带了abstractb和public关键字，所以自己加不加都行。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">UsbInterface</span> &#123;<span class="comment">//被接口规范了的类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;<span class="comment">//按照接口中定义的声明，实现具体的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;手机开始工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机停止工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span> <span class="keyword">implements</span> <span class="title class_">UsbInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;相机开始工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;相机停止工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(UsbInterface usbInterface)</span> &#123;<span class="comment">//调用被 UsbInterface 接口所规范的类</span></span><br><span class="line">        usbInterface.start();</span><br><span class="line">        usbInterface.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果</p>
<p>手机开始工作<br>手机停止工作<br>相机开始工作<br>相机停止工作</p>
</blockquote>
<h4 id="样例2-一个方法实现多个接口（被多个接口所约束）"><a href="#样例2-一个方法实现多个接口（被多个接口所约束）" class="headerlink" title="样例2 一个方法实现多个接口（被多个接口所约束）"></a>样例2 一个方法实现多个接口（被多个接口所约束）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.Interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">InterfacrTest1</span> <span class="variable">interfacrTest1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfacrTest1</span>();<span class="comment">//用于接口测试的类1</span></span><br><span class="line">        <span class="type">InterfacrTest2</span> <span class="variable">interfacrTest2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfacrTest2</span>();<span class="comment">//用于接口测试的类2</span></span><br><span class="line"></span><br><span class="line">        interfacrTest1.work1(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;...........&quot;</span>);</span><br><span class="line">        interfacrTest2.work2(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface1</span> &#123;<span class="comment">//定义了一个接口，使用该接口的类必须实现其中定义的方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>;<span class="comment">//默认自带了abstractb和public关键字，所以自己加不加都行。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">t</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface2</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">MyInterface1</span>, MyInterface2 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重名的fun被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;参数名不同的fun被执行，内容是：&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;未重名的t被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterfacrTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work1</span><span class="params">(MyInterface1 myInterface1)</span> &#123;</span><br><span class="line">        myInterface1.fun();</span><br><span class="line">        myInterface1.t();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterfacrTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work2</span><span class="params">(MyInterface2 myInterface2)</span> &#123;</span><br><span class="line">        myInterface2.fun();</span><br><span class="line">        myInterface2.fun(<span class="string">&quot;参数不同的fun在测试&quot;</span>);</span><br><span class="line">        <span class="comment">//myInterface2.t();//虽然一个类能被多个接口所规范，但每个接口只能调用该接口自己声明的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果</p>
<p>重名的fun被执行<br>未重名的t被执行<br>………..<br>重名的fun被执行<br>参数名不同的fun被执行，内容是：参数不同的fun在测试</p>
</blockquote>
<h4 id="样例3-接口的继承"><a href="#样例3-接口的继承" class="headerlink" title="样例3 接口的继承"></a>样例3 接口的继承</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.Interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">InterfacrTest1</span> <span class="variable">interfacrTest1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfacrTest1</span>();<span class="comment">//用于接口测试的类1</span></span><br><span class="line">        <span class="type">InterfacrTest2</span> <span class="variable">interfacrTest2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfacrTest2</span>();<span class="comment">//用于接口测试的类2</span></span><br><span class="line"></span><br><span class="line">        interfacrTest1.work1(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;...................&quot;</span>);</span><br><span class="line">        interfacrTest2.work2(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface1</span> &#123;<span class="comment">//定义了一个接口，使用该接口的类必须实现其中定义的方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">t</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface2</span> <span class="keyword">extends</span> <span class="title class_">MyInterface1</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">MyInterface2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fun被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;t被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterfacrTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work1</span><span class="params">(MyInterface1 myInterface1)</span> &#123;</span><br><span class="line">        <span class="comment">//myInterface1.fun();//因为在接口1中，并没有这个方法</span></span><br><span class="line">        myInterface1.t();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterfacrTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work2</span><span class="params">(MyInterface2 myInterface2)</span> &#123;</span><br><span class="line">        myInterface2.fun();</span><br><span class="line">        myInterface2.t();<span class="comment">//接口的子类一样可以调用父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：</p>
<p>t被执行<br>……………….<br>fun被执行<br>t被执行</p>
</blockquote>
<h4 id="样例4-带属性和方法体的接口"><a href="#样例4-带属性和方法体的接口" class="headerlink" title="样例4 带属性和方法体的接口"></a>样例4 带属性和方法体的接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.Interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">InterfaceTest</span> <span class="variable">interfaceTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceTest</span>();<span class="comment">//实例化用户测试的函数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;通过接口调用的..............................&quot;</span>);</span><br><span class="line">        interfaceTest.work1(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;通过对象调用的..............................&quot;</span>);</span><br><span class="line">        interfaceTest.work2(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface1</span> &#123;<span class="comment">//定义了一个接口，使用该接口的类必须实现其中定义的方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">t</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;<span class="comment">//可以理解为switch里面的default？可以被重写，如果没被重写就实现这个方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接口中可以带有语句&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以带有属性。属性好像自带了public static final关键字？</span></span><br><span class="line">    <span class="comment">// 在idea中如果写上这个三个关键字会变成灰色，鼠标移上去会提示  修饰符 &#x27;final/static/public&#x27; 对于接口字段是冗余的</span></span><br><span class="line">    <span class="comment">// 可以通过接口名直接调用,但不能修改</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//protected int n2 = 200;会报错 此处不允许使用修饰符 &#x27;protected&#x27;。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">MyInterface1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口中的t()的实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;<span class="comment">//被接口规范的方法可以含有接口中没被声明的方法</span></span><br><span class="line">        System.out.println(MyInterface1.n1);</span><br><span class="line">        <span class="comment">//MyInterface1.n1++;//不能修改，会提示  无法将值赋给 final 变量 &#x27;n1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterfaceTest</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work1</span><span class="params">(MyInterface1 myInterface1)</span>&#123;</span><br><span class="line">        myInterface1.t();<span class="comment">//接口中声明的</span></span><br><span class="line">        myInterface1.fun();<span class="comment">//接口中带有方法体的</span></span><br><span class="line">        <span class="comment">//myInterface1.test();//接口中没有声明的类是不可以被接口调用的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work2</span><span class="params">(A a)</span>&#123;</span><br><span class="line">        a.t();<span class="comment">//接口中被声明的方法也可以通过对象名的方式进行调用</span></span><br><span class="line">        a.test();<span class="comment">//单独的方法自然也是可以被调用的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：</p>
<p>通过接口调用的…………………………<br>接口中的t()的实现<br>接口中可以带有语句<br>通过对象调用的…………………………<br>接口中的t()的实现<br>100</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.Interface_;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="type">Camera</span> <span class="variable">camera</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera</span>();</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        computer.work(phone);</span><br><span class="line">        computer.work(camera);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//new UsbInterface();//与抽象类类似，接口也不允许被实例化。&#x27;UsbInterface&#x27; 为 abstract；无法实例化</span></span><br><span class="line">        System.out.println(<span class="string">&quot;在main()中调用接口中的属性&quot;</span> + UsbInterface.n);<span class="comment">//通过接口名直接调用接口里面的属性</span></span><br><span class="line">        <span class="comment">//UsbInterface.n = 200;接口里面的属性自带了static和final关键字</span></span><br><span class="line"></span><br><span class="line">        computer.test2(phone);</span><br><span class="line">        computer.test1(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UsbInterface</span> &#123;<span class="comment">//定义了一个接口，使用该接口的类必须实现其中定义的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;<span class="comment">//默认自带了abstractb和public关键字，所以自己加不加都行。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;<span class="comment">//可以理解为switch里面的default？可以被重写，如果没被重写就实现这个方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接口中带有语句&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//也可以带有属性。属性好像自带了static和final关键字？可以通过接口名直接调用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">UsbInterface</span> &#123;<span class="comment">//同时接口好像还可以被继承？</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">UsbInterface</span> &#123;<span class="comment">//被接口规范了的类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;<span class="comment">//按照接口中定义的声明，实现具体的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;手机开始工作...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机停止工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Phone:接口中的类可以被重写&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span> <span class="keyword">implements</span> <span class="title class_">UsbInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;相机开始工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;相机停止工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(UsbInterface usbInterface)</span> &#123;</span><br><span class="line">        usbInterface.start();</span><br><span class="line">        usbInterface.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        t.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public void test2(T t) &#123;//同样也符合继承的规范：子类继承了所有的父类</span></span><br><span class="line"><span class="comment">        t.fun();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(UsbInterface usbInterface)</span> &#123;<span class="comment">//但运行被调用的类也必须得是由子类规范过的类，不兼容父类规范的类</span></span><br><span class="line">        usbInterface.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类A:通过被继承的接口来规定一个类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：</p>
<p>手机开始工作…<br>手机停止工作<br>相机开始工作<br>相机停止工作<br>在main()中调用接口中的属性100<br>Phone:重写接口中已有的类<br>类A:通过被继承的接口来规定一个类</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接口是更加抽象的抽象的类，抽象类里的方法可以有方法体，接口里的所有方法都没有方法体[jdk7.0] 。接口体现了程序设计的多态和高内聚低偶合的设计思想。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特别说明: Jdk8.0后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">与抽象类类似，接口也不允许被实例化。</span><br></pre></td></tr></table></figure>

<h3 id="注意事项和细节-1"><a href="#注意事项和细节-1" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h3><ol>
<li>接口不能被实例化。</li>
<li>接口中所有的方法都是 public 方法, 接口中抽象方法，可以不用 abstract 修饰。</li>
<li>一个普通类实现接口,就<strong>必须将该接口的所有方法都实现</strong>,可以使用 alt+enter 来解决。</li>
<li>抽象类去实现接口时，可以不实现接口的抽象方法。</li>
<li>一个类同时可以实现多个接口。</li>
<li>接口中的属性只能是final的，而且是public static final修饰符。比如:int a&#x3D;1;实际上是public static final int a&#x3D;1; (必须初始化)。</li>
<li>接口中属性的访问形式:接口名.属性名。</li>
<li>接口不能继承其它的类，但是可以继承多个别的接口。</li>
<li>接口的修饰符只能是public和默认，这点和类的修饰符是一样的。（默认的在接口中会被看作是public？）</li>
</ol>
<h3 id="接口与继承类的区别"><a href="#接口与继承类的区别" class="headerlink" title="接口与继承类的区别"></a>接口与继承类的区别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当子类继承了父类，就自动的拥有了父类的所有功能；如果子类需要扩展功能，可以通过 实现接口 的方式扩展。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以把 实现接口 理解为对java单继承机制的一种补充。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">继承的价值主要在于解决了代码的复用性和可维护性；</span><br><span class="line">		接口的价值注意在于设计，设计好各种规范（方法），让其他类去实现这些方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接口比继承更加灵活，继承满足是是某个（is a），而接口只需要满足像一个...(like a)的关系。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接口在一定的程度上实现了代码的解耦（接口规范性+动态绑定）</span><br></pre></td></tr></table></figure>

<h3 id="接口的多态性"><a href="#接口的多态性" class="headerlink" title="接口的多态性"></a>接口的多态性</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接口类型的变量 可以指向 实现了该接口的对象实例。（如在上方的样例1 中，类computer就可以接收实现了UsbInterface usbInterface接口的类，并通过该接口调用在接口中声明的所有方法与属性）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用接口的多态可以实现一个接口的数组。比如：</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.Interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        I[] i = <span class="keyword">new</span> <span class="title class_">I</span>[<span class="number">2</span>];<span class="comment">//定义了一个接口数组i</span></span><br><span class="line">        i[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">A</span>();<span class="comment">//数组的第一个位置指向了一个A类的对象</span></span><br><span class="line">        i[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">B</span>();<span class="comment">//数组的第一个位置指向了一个B类的对象</span></span><br><span class="line">        i[<span class="number">0</span>].f();<span class="comment">//并且可以通过接口调用在接口中声明了的方法或属性</span></span><br><span class="line">        <span class="comment">//i[1].t();//但不能调用类中私有的属性</span></span><br><span class="line">        ((A)i[<span class="number">0</span>]).t();<span class="comment">//如果要调用类中私有的方法或属性，也可以使用向下转型的套路。不过需要多一重括号？</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">I</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//定义了一个类A，并实现了接口I的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">I</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//定义了一个类B，并实现了接口I的方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同时接口的多态还具有传递性，可以相互继承。如语法样例1中的接口的继承。</span><br></pre></td></tr></table></figure>

<h4 id="接口多态中的二义性"><a href="#接口多态中的二义性" class="headerlink" title="接口多态中的二义性"></a>接口多态中的二义性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为一个类可以同时进行继承和实现接口的功能，因此就会出现“二义性”</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">I</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//等价于public static final int x = 1;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;<span class="comment">//普通属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">T</span> <span class="keyword">implements</span> <span class="title class_">I</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//System.out.println(x);//此时就会报错，因为编译器不知道是要哪个里面的x。报错信息：对 &#x27;x&#x27; 的引用不明确，&#x27;T.x&#x27; 和 &#x27;I.x&#x27; 均匹配</span></span><br><span class="line">       System.out.println(I.x);<span class="comment">//因为接口里面的属性是静态的，所以可以通过接口名.属性名进行访问</span></span><br><span class="line">       System.out.println(<span class="built_in">super</span>.x);<span class="comment">//或者使用super关键字指定访问父类的x</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class)，嵌套其他类的类称为外部类(outer class)。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内部类是我们类的第五大成员[属性、方法、构造器、代码块、内部类]，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类的组成：</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;<span class="comment">//外部类</span></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">(<span class="type">int</span> n1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n1 = n1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义在外部类的局部位置上（比如方法内）：局部内部类（有类名）、</span><br></pre></td></tr></table></figure>
<p><strong>匿名内部类（无类名）</strong>；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义在外部类的成员位置上：成员内部类（非static）、静态内部类（static）；</span><br></pre></td></tr></table></figure>

<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">局部内部类是定义在外部类的局部位置，比如方法中或块中，并且有类名。</span><br></pre></td></tr></table></figure>

<h5 id="演示代码"><a href="#演示代码" class="headerlink" title="演示代码"></a>演示代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.innerclass_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="number">100</span>);</span><br><span class="line">        outer.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//局部内部类是定义在外部类的局部位置， 比如方法中，并且有类名。</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inter</span>&#123;<span class="comment">//局部内部类，本质还是一个类，里面也可以有五大类</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Outer:n3 = &quot;</span>+n3);<span class="comment">//可以直接访问外部类的所有成员， 包含私有的。</span></span><br><span class="line">                m2();<span class="comment">//同样也可以访问到外部的方法</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Inter:n1 = &quot;</span>+n1);<span class="comment">//当重名发生时，遵守就近原则。</span></span><br><span class="line">              <span class="comment">//外部类.this的含义：因为外部类不一定是静态的，因此直接可能不能访问到，加上this表示找的时这个类的对象。</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Inter:Outer:n1 = &quot;</span>+Outer.<span class="built_in">this</span>.n1);<span class="comment">//如果需要访问外部类的成员,可以同外部类名.this.成员名 的方式进行访问</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public class InnerTest&#123;&#125;//作为方法的一个成员，是不可以有访问权限的管理。但可以用final进行只读保护，就像其他方法成员一样</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InnerTest</span> <span class="keyword">extends</span> <span class="title class_">Inter</span>&#123;&#125;<span class="comment">//内部类也是可以被继承的（如果能访问到）</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Inter</span> <span class="variable">inter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inter</span>();<span class="comment">//在作用域内内部类也可以实例化成对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Inter n2:&quot;</span>+inter.n2);<span class="comment">//并通过对象访问其中的属性</span></span><br><span class="line">        inter.f1();<span class="comment">//内部类的方法也可以通过对象调用</span></span><br><span class="line">        inter.f2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">(<span class="type">int</span> n1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n1 = n1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：</p>
<p>Inter n2:200<br>Outer:n3 &#x3D; 300<br>Inter:n1 &#x3D; 1<br>Inter:Outer:n1 &#x3D; 100</p>
</blockquote>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">匿名内部类时定义在外部类的局部位置，比如方法中或代码块中，且没有类名.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">匿名内部类的本质还是类，而且是一个内部的类，他没有名字（有名字但不是开发者命名，是由系统自动生成）</span><br></pre></td></tr></table></figure>

<h5 id="基本语法-5"><a href="#基本语法-5" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类或接口(参数列表)&#123;</span><br><span class="line">  类体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="基于接口的匿名类-演示"><a href="#基于接口的匿名类-演示" class="headerlink" title="基于接口的匿名类 演示"></a>基于接口的匿名类 演示</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需求：使用接口来定义一个类，并用这个类创建一个对象</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传统的方法是将新建一个类，但由于只需要使用一次，后面不会再用到，因此可以使用匿名内部类来简化以下编写的流程。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比如这样：</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">I</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">I</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;老虎在叫....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>在上方的片段中，tiger的编译类型是I，运行类型是匿名类。匿名类的命名规范为外部类名$编号</p>
<p>这个匿名的内部类一旦实例化成tiger后，就会直接抛弃，而对象名tiger，可以在生存期内无限次被使用。</p>
<p>具体实现代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.innerclass_;</span><br><span class="line"><span class="comment">//匿名内部类的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//基于接口的匿名内部类</span></span><br><span class="line">        <span class="comment">//使用接口I，并创建一个对象。传统方式：写一个类，实现该接口，并创建对象。但由于这个类只会使用一次，且一会不会再使用。可以使用内部类来简化。如下所示</span></span><br><span class="line">        <span class="comment">//此时tiger的编译类型是I；运行类型是匿名的内部类。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        下方这个匿名内部类约等于以下语句</span></span><br><span class="line"><span class="comment">            class XXXX implements I&#123;</span></span><br><span class="line"><span class="comment">                public void cry() &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(&quot;老虎在叫&quot;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            而其中的XXXX就是系统分配的一个类名。具体的名字是:外部类名$编号。比如这里就是Other$01.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">I</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">I</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;老虎在叫....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        tiger.cry();<span class="comment">//通过将匿名对象实例化后的变量访问其中的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;tiger的类名为 &quot;</span>+tiger.getClass());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I</span>&#123;<span class="comment">//接口</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="基于类的匿名类"><a href="#基于类的匿名类" class="headerlink" title="基于类的匿名类"></a>基于类的匿名类</h5><h6 id="基本构成："><a href="#基本构成：" class="headerlink" title="基本构成："></a>基本构成：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(<span class="string">&quot;jack&quot;</span>) &#123;<span class="comment">//这就完成了一个基于类的匿名内部类。括号内的值会传给父类A的构造函数.相当于继承了A这个类，但没有重写任何方法。</span></span><br><span class="line">          	<span class="comment">//内部匿名类的语句组;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;传入的值为：&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名类中不允许存在构造函数（因为创建完就丢弃，没有构造的意义）</p>
<p>匿名内部类的调用方式：</p>
<p>对象名.内部类的参数；</p>
<p>也可以不创建对象名直接调用，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">A</span>(<span class="string">&quot;Tom&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;不创建对象名直接调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.test();<span class="comment">//new出来直接调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(String s)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;传入的值为：&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>匿名内部类通常会当作实参直接传递。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        fun(<span class="keyword">new</span> <span class="title class_">I</span>()&#123;<span class="comment">//直接把创造出来的基于接口的匿名内部类的对象作为实参传入到定义好的方法中</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;<span class="comment">//在匿名类中完成接口所定义的功能</span></span><br><span class="line">                System.out.println(<span class="string">&quot;这是一幅名画&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);     </span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(I i)</span>&#123;<span class="comment">//定义一个方法，可以使用符合这个接口的对象</span></span><br><span class="line">        i.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I</span>&#123;<span class="comment">//定义一个接口</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>更改为传统的写法如下（硬编码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        fun(<span class="keyword">new</span> <span class="title class_">C</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(I i)</span>&#123;<span class="comment">//定义一个方法，可以使用符合这个接口的对象</span></span><br><span class="line">        i.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I</span>&#123;<span class="comment">//定义一个接口</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">I</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一幅名画&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两者在功能上一模一样，都是输出一句&quot;这是一幅名画&quot;，但在写法上，传统的方法需要先定义一个类，而这个类很有可能只会被使用一次之后就不会再被使用，占地方，而且看代码的时候比较啰嗦。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前者适合只用一次的场景，后者更适合需要复用的场景。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>全部实验样例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.innerclass_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名内部类的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.method();</span><br><span class="line">        outer.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基于类的匿名内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//a的编译类型：A;a的运行类型：匿名</span></span><br><span class="line">        <span class="comment">//相当于继承了A这个类，但没有重写任何方法。</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(<span class="string">&quot;jack&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类重写了test方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;在匿名内部类中的n被打印：&quot;</span> + n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        a.test();<span class="comment">//运行时会动态绑定，根据实际的对象调用对应的方法</span></span><br><span class="line">        System.out.println(a.n);<span class="comment">//但属性同样不参与动态绑定，只能按照编译类型调用</span></span><br><span class="line">        a.fun1();<span class="comment">//但参与动态绑定的内部类回去找自身的变量而非找编译类型变量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">A</span>(<span class="string">&quot;Tom&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;不创建对象名直接调用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//基于抽象类的匿名类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Anima</span> <span class="variable">anima</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Anima</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;在基于抽象类的匿名内部类中的eat（）&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        anima.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;传入的值为：&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类A中的test（）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在普通外部类中的n被打印：&quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Anima</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="内部类的细节"><a href="#内部类的细节" class="headerlink" title="内部类的细节"></a>内部类的细节</h4><ol>
<li>匿名内部类的语法比较奇特，请大家注意，因为匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征，对前面代码分析可以看出这个特点，因此可以调用匿名内部类方法。</li>
<li>可以直接访问外部类的所有成员， 包含私有的。(私有的访问权限在于类内，而内部类就在类中，因此可以方法私有)</li>
<li>不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final 修饰，因为局部变量也可以使用final。</li>
<li>作用域:仅仅在定义它的方法或代码块中。（类似于网络中的内部网络。内部网络可以访问外网的资源，但外网不能主动联系内网从的成员，因为找不到，除非借助端口转发？）</li>
<li>局部内部类 的成员访向 外部类 的成员：当作自己的成员一样直接访问。</li>
<li>外部类 访向 局部内部类的成员：需要实例化一个内部类的变量，通过对象的名字去找他。前提是能找到（在作用域范围内）</li>
<li>外部其他类 不能直接访问到 局部内部类(因为局部内部类地位是一个局部变量)</li>
<li>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员) 去访问。</li>
</ol>
<blockquote>
<ol>
<li>局部内部类定义在方法中&#x2F;代码块</li>
<li>作用域在方法体或者代码块中</li>
<li>本质仍然是一个类</li>
</ol>
</blockquote>
<h3 id="外部类"><a href="#外部类" class="headerlink" title="外部类"></a>外部类</h3><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><h5 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类的一个方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="细节讨论"><a href="#细节讨论" class="headerlink" title="细节讨论"></a>细节讨论</h5><ul>
<li><p>成员内部类就是一个成员，因此它的作用域和外部类的其他成员一样，为整个类体。</p>
</li>
<li><p>定义在外部类的成员位置。不能有static修饰。</p>
</li>
<li><p>它可以直接访问外部类的所有成员（包括私有的）。但如果反过来外部类的成员（和内部类平级的）想要访问内部类内的数据，需要先创建对象。（或者加static，和普通类一样）</p>
</li>
<li><p>它也可以添加访问修饰符，因为他的地位就是一个成员。</p>
</li>
<li><p>成员内部类的方法不能加static修饰,除非这个内部类已经是static的了。或者java版本升级到16以上。</p>
</li>
<li><p>如果想在类A中访问外部类B中的内部类C，可以有一下三种方式。（ABC三者的关系：A、B平级，B、C内部外部）如下代码所示。或者在外部类B中创建对应的方法，通过方法调用内部类实例化后的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、靠实例化后的对象来创建一个内部类的对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    B.<span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> b.<span class="keyword">new</span> <span class="title class_">C</span>();<span class="comment">//相当于把new C()当作是b的一个成员</span></span><br><span class="line"></span><br><span class="line">    <span class="type">B</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    B.<span class="type">C</span> <span class="variable">c2</span> <span class="operator">=</span> b1.<span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;c=&quot;</span>+c.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;c2=&quot;</span>+c2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;位于内部类的say()被执行，外部类的成员 n1 = &quot;</span> + n1 + <span class="string">&quot; name = &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、在外部类中，编写一个方法，返回内部类的对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;位于内部类的say()被执行，外部类的成员 n1 = &quot;</span> + n1 + <span class="string">&quot; name = &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> C <span class="title function_">getInterC</span><span class="params">()</span>&#123;<span class="comment">//在外部类中实例化并返回，同样需要借助外部类的对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、或者用静态的方法：</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.Interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.inter01.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inter01</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;<span class="comment">//需要注意的是，此处的成员内部类的方法不能加static修饰,除非这个内部类已经是static的了。或者java版本升级到16以上</span></span><br><span class="line">            <span class="comment">//内部类可以访问外部类中所有的成员，包括私有的。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;位于内部类的say()被执行，外部类的成员 n1 = &quot;</span> + n1 + <span class="string">&quot; name = &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要注意，内部类不能被外面的类（不是外部类）直接实例化，因为找不到这个类。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Inter01</span> <span class="variable">inter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inter01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inter02</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">Inter02</span> <span class="variable">inter02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inter02</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t</span><span class="params">()</span>&#123;<span class="comment">//创建一个跳板，其他类可以通过这个方法访问到内部类的数据</span></span><br><span class="line">        inter02.t();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果外部类和内部类的成员重名时，会遵循就近原则，会访问到重名的内部类的成员。如果内部类想要访问重名了的外部类的成员，需要使用“外部类名.this.成员”的语法进行访问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;直接访问n会访问到内部类的n，会输出200.：&quot;</span>+n);</span><br><span class="line">            System.out.println(<span class="string">&quot;如果需要访问外部类的n，需要特殊处理，比如这样就能访问到外部的值：&quot;</span>+A.<span class="built_in">this</span>.n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">静态内部类是定义在外部类的成员位置，并有static修饰。</span><br></pre></td></tr></table></figure>

<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ol>
<li>可以直接访问外部类的所有静态成员，包括私有，<strong>但不能访问非静态的成员</strong>。</li>
<li>可以添加任意的修饰符，因为地位就是一个成员。</li>
<li>作用域：和成员一样，为整个类体。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.Interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;<span class="comment">//静态内部类有static修饰</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;可以直接访问静态成员（类外）或者类内的所有成员 n2 = &quot;</span> + n2 + <span class="string">&quot;  n3 = &quot;</span> + n3);</span><br><span class="line">            <span class="comment">//System.out.println(n1);//但不能访问类外的非静态成员</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">t</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;外部类可以直接访问静态内部类中的静态成员而不需要实例化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">B</span>().say();<span class="comment">//作用域在整个类中，因为可以在类外访问内部类的成员。</span></span><br><span class="line">        <span class="comment">// 需要注意的是虽然是静态的内部类，但还需要实例化之后才能访问。因为里面的方法不是静态的，只有类是静态的</span></span><br><span class="line">        B.t();<span class="comment">//可以直接访问内部类的静态成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>静态内部类可以直接访问所有外部类的成员；但外部类想要访问内部类的成员则需要先实例化成对象。或者内部类的成员也是静态的。</li>
<li>外部其他类想要使用静态内部类的方式为：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//1、外部类名.</span></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">A</span>.B().fun();<span class="comment">//对于静态内部类的非静态成员需要先实例化成对象</span></span><br><span class="line">       A.B.t();<span class="comment">//如果成员也是静态的，就可以直接访问</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">       <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;在其他类中访问了静态内部类中的普通变量&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">t</span><span class="params">()</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;在其他类中访问了静态内部类中的静态变量&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li><p>同样如果外部类和静态内部类重名时，仍然遵守就近原则。如果想访问外部对象，可以使用 外部类名.成员 的方式进行访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.Interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        A.<span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>.B();</span><br><span class="line">        b.t();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;就近原则，访问到内部类的成员&quot;</span> + n);</span><br><span class="line">            System.out.println(<span class="string">&quot;访问外部则需要类名.成员名&quot;</span> + A.n);<span class="comment">//需要注意的是，外部的成员需要是静态的。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内部类共有四种，局部内部类、匿名内部类、成员内部类、静态内部类。前两者是在成员内部，后两者的存在地位就是普通类的一个成员（本质）。（重点是匿名内部类）</span><br></pre></td></tr></table></figure>


<h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><h2 id="自定义枚举"><a href="#自定义枚举" class="headerlink" title="自定义枚举"></a>自定义枚举</h2><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li>将构造器私有化，防止被直接的new；</li>
<li>去掉set相关的方法，防止属性被修改；</li>
<li>在类的内部直接创建固定的对象；</li>
<li>在第三步的语句前加入final防止被修改；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、在类的内部直接创建固定的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;炎热&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义枚举的注意事项"><a href="#自定义枚举的注意事项" class="headerlink" title="自定义枚举的注意事项"></a>自定义枚举的注意事项</h3><ol>
<li>样式类似于单例模式中的饿汉式；</li>
<li>不需要提供set方法，因为对象值通常都是只读的；</li>
<li>对枚举的对象或属性一般都使用final+static共同修饰，实现优化；（在使用的时候不会加载类，java8+）</li>
<li>枚举对象根据需要，可以有多个属性；（如上方的样例）</li>
</ol>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol>
<li>构造器私有化；</li>
<li>本类内部创建一组对象；</li>
<li>对外暴露对象（通过为对象添加 public final static 修饰符） ；</li>
<li>可以提供 get 方法，但是不要提供 set；</li>
</ol>
<h2 id="enum关键字的枚举"><a href="#enum关键字的枚举" class="headerlink" title="enum关键字的枚举"></a>enum关键字的枚举</h2><h3 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h3><ol>
<li>使用关键字 enum 替代 class；</li>
<li>public static final Season SPRING &#x3D; new Season(“春天”, “温暖”) 直接使用SPRING(“春天”, “温暖”) ；（常量名(实参列表)）</li>
<li>如果有多个常量(对象)， 使用 ,号间隔即可；（可能编译器只认一条语句？）</li>
<li>如果使用 enum 来实现枚举，要求将定义常量对象，写在最前面（与this或super的地位相同）；</li>
<li>如果我们使用的是无参构造器，创建常量对象，则可以省略 ()；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.chapter.enum_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season.SPRING);</span><br><span class="line">        System.out.println(Season.SUMMER);</span><br><span class="line">        System.out.println(Season.AUTUMN);</span><br><span class="line">        System.out.println(Season.WINTER);</span><br><span class="line">        System.out.println(Season.OTHER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    <span class="comment">//不再定义对象，直接使用常量名（实参列表）的方式进行说明）</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;温暖&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;炎热&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;凉爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;寒冷&quot;</span>),</span><br><span class="line">    OTHER;<span class="comment">//若使用无参构造器，则可以不用加括号。</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Season() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：</p>
<p>Season{name&#x3D;’春天’, desc&#x3D;’温暖’}<br>Season{name&#x3D;’夏天’, desc&#x3D;’炎热’}<br>Season{name&#x3D;’秋天’, desc&#x3D;’凉爽’}<br>Season{name&#x3D;’冬天’, desc&#x3D;’寒冷’}<br>Season{name&#x3D;’null’, desc&#x3D;’null’}</p>
</blockquote>
<h3 id="enum枚举的注意事项"><a href="#enum枚举的注意事项" class="headerlink" title="enum枚举的注意事项"></a>enum枚举的注意事项</h3><ol>
<li><p>当使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类, 而且是一个 final 类；（具体见javap反编译出的内容）</p>
<blockquote>
<p>反编译结果：</p>
<p>Compiled from “Test.java”<br>final class net.hurr.chapter.enum_.Season extends java.lang.Enum&lt;net.hurr.chapter.enum_.Season&gt; {<br>public static final net.hurr.chapter.enum_.Season SPRING;<br>public static final net.hurr.chapter.enum_.Season SUMMER;<br>public static final net.hurr.chapter.enum_.Season AUTUMN;<br>public static final net.hurr.chapter.enum_.Season WINTER;<br>public static final net.hurr.chapter.enum_.Season OTHER;<br>public static net.hurr.chapter.enum_.Season[] values();<br>public static net.hurr.chapter.enum_.Season valueOf(java.lang.String);<br>public java.lang.String toString();<br>static {};<br>}</p>
<p>具体代码：</p>
<p>enum Season {<br>SPRING(“春天”,”温暖”),<br>SUMMER(“夏天”,”炎热”),<br>AUTUMN(“秋天”,”凉爽”),<br>WINTER(“冬天”,”寒冷”),<br>OTHER;&#x2F;&#x2F;若使用无参构造器，则可以不用加括号。<br>private String name;<br>private String desc;</p>
<p>private Season(String name, String desc) {<br>this.name &#x3D; name;<br>this.desc &#x3D; desc;<br>}<br>Season() {<br>}<br>@Override<br>public String toString() {<br>return “Season{“ +<br>“name&#x3D;’” + name + ‘&#39;‘ +<br>“, desc&#x3D;’” + desc + ‘&#39;‘ +<br>‘}’;<br>}<br>}</p>
</blockquote>
</li>
<li><p>传统的 public static final Season2 SPRING &#x3D; new Season2(“春天”, “温暖”); 简化成 SPRING(“春天”, “温暖”)；（调用了有参构造器，由实参判断）</p>
</li>
<li><p>如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略；</p>
</li>
<li><p>当有多个枚举对象时，使用逗号间隔，最后有一个分号结尾；</p>
</li>
<li><p>枚举对象必须放在枚举类的行首；</p>
</li>
<li><p>如果直接输出toString（没有重写的情况下会继承父类的），则会输出常量名。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Gender</span> <span class="variable">a</span> <span class="operator">=</span> Gender.BOY;</span><br><span class="line">        <span class="type">Gender</span> <span class="variable">b</span> <span class="operator">=</span> Gender.BOY;</span><br><span class="line">        <span class="type">Gender</span> <span class="variable">c</span> <span class="operator">=</span> Gender.GIRL;</span><br><span class="line">        System.out.println(a + <span class="string">&quot;  &quot;</span> + b + <span class="string">&quot;  &quot;</span> + c);</span><br><span class="line">      	System.out.println(a == b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Gender</span> &#123;</span><br><span class="line">    BOY, GIRL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">BOY  BOY  GIRL</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>枚举类型只要常量名相同就是同一个。见上方代码，不管BOY被分给了几次，他们都是同一个。具体原理看自定义的枚举的实现方法，在枚举类每个名字不同的常量只有一个实例，调用不过是将这个实例的地址传给不同的对象。</p>
</li>
<li></li>
</ol>
<h2 id="enum的常用方法"><a href="#enum的常用方法" class="headerlink" title="enum的常用方法"></a>enum的常用方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用enum关键字的时候，会隐式的继承Enum类，这样我们就可以使用 Enum 类相关的方法。</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>方法名</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>valueOf</td>
<td>将给定的字符串转换成枚举类型（或者说返回与字符串相同的枚举类型）。如果枚举类内没有匹配的字符串，会抛异常。语法：Season autumn &#x3D; Season.valueOf(“AUTUMN”);</td>
</tr>
<tr>
<td>values</td>
<td>隐藏方法，在源码中无法查看。返回一个数组，数组的内容是当前枚举类中的所有常量。数组类型为对应的枚举类</td>
</tr>
<tr>
<td>toString</td>
<td>得到当前枚举常量的名称。你可以通过重写这个方法未使得到的结果更易读。</td>
</tr>
<tr>
<td>equals</td>
<td>在枚举类型中可以直接使用”&#x3D;&#x3D;“来比较两个枚举常量是否相等。Enum提供的这个equals0方法，也是直接使用”等于“实现的。</td>
</tr>
<tr>
<td>hashCode</td>
<td>Enum实现了hashCode()来和equals())保持一致。 它也是不可变的。</td>
</tr>
<tr>
<td>getDeclanngClass</td>
<td>得到枚举常量所属枚举类型的Class对象。可以用它来判断两个枚举常量是否属千同-一个枚举类型。</td>
</tr>
<tr>
<td>name</td>
<td>得到当前枚举常量的名称。toString如果没有重写则同样输出当前常量的名字。</td>
</tr>
<tr>
<td>ordinal</td>
<td>得到当前枚举常量的次序。（从0开始编号，编号的顺序为当前常量在枚举类中的位置）</td>
</tr>
<tr>
<td>compareTo</td>
<td>比较两个枚举常量的大小(按照声明的顺序排列，即通过ordinal得到的数) 。返回当前枚举类型减去传入的类型之间相差的个数。等于0时表示两个枚举类型相176                    56 80等。</td>
</tr>
<tr>
<td>clonee</td>
<td>枚举类型不能被Clone。为了防止子类实现克隆方法，Enum实现了一个仅抛出CloneNotSupprtedException异常的不变Clone()</td>
</tr>
</tbody></table>
<h3 id="enum的注意事项"><a href="#enum的注意事项" class="headerlink" title="enum的注意事项"></a>enum的注意事项</h3><ol>
<li><p>使用enum关键字后，就不能再继承其他类了，因为enum会隐式的继承Enum类，而Java中只有单继承，不支持多继承。、</p>
</li>
<li><p>除了不能继承其他的类外，enum类也不能被其他类继承</p>
</li>
<li><p>enum实现的枚举类的本质仍然还是一个类，因此是可以实现接口的，可以被接口所规范。使用时可以通过枚举出的对象.方法名。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.chapter.enum_;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        E.TEST.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">E</span> <span class="keyword">implements</span> <span class="title class_">I</span> &#123;</span><br><span class="line">    TEST;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;播放音乐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="注解（Annotation）"><a href="#注解（Annotation）" class="headerlink" title="注解（Annotation）"></a>注解（Annotation）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置等。</span><br></pre></td></tr></table></figure>

<h2 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素。</span><br></pre></td></tr></table></figure>

<h2 id="三个基本的-Annotation"><a href="#三个基本的-Annotation" class="headerlink" title="三个基本的 Annotation"></a>三个基本的 Annotation</h2><ol>
<li>@Override: 限定某个方法，是重写父类方法, 该注解只能用于方法；</li>
<li>@Deprecated: 用于表示某个程序元素(类, 方法等)已过时；</li>
<li>@SuppressWarnings: 抑制编译器警告</li>
</ol>
<h2 id="基本的-Annotation-应用案例"><a href="#基本的-Annotation-应用案例" class="headerlink" title="基本的 Annotation 应用案例"></a>基本的 Annotation 应用案例</h2><h3 id="Override-注解的案例"><a href="#Override-注解的案例" class="headerlink" title="@Override 注解的案例"></a>@Override 注解的案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;AAA&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//放在方法前</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override  放在方法的上一行，表示下面的方法重写了父类的方法。如果不加照样是重写的，但加上的话编译器就会去检查该方法是否真的重写了父类的方法，如果重写了，则编译通过；如果没有重写，则会编译报错。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">它的价值就在于语法校验。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在源码中为：</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上方代码中的@interface 就表明了这是一个注解类。（注意这不是接口！！！）</span><br></pre></td></tr></table></figure>

<h4 id="Override的使用说明"><a href="#Override的使用说明" class="headerlink" title="@Override的使用说明"></a>@Override的使用说明</h4><ol>
<li>@Override表示指定重写父类的方法(从编译层面验证)， 如果父类没有对应方法，则会报错</li>
<li>如果不写@Override注解，而父类仍有public void fly00，仍然构成重写；</li>
<li>@Override只能修饰方法，不能修饰其它类，包，属性等等；</li>
<li>查看@Override注解源码为@ Target(ElementType.METHOD)说明只能修饰方法；</li>
<li>@Target是<strong>修饰注解的注解，称为元注解</strong>， 记住这个概念；</li>
</ol>
<h3 id="Deprecated-注解的案例"><a href="#Deprecated-注解的案例" class="headerlink" title="@Deprecated 注解的案例"></a>@Deprecated 注解的案例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用于表示某个程序的元素（比如类、方法）已经过时。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只要在类前面加上这个注解，编译器在自动联想搜索的时候，就不会优先选中这个。但这并不代表不能用，还是可以选中的，只是不在第一位了，或者说不推荐使用了。而且选中之后会在使用该类的地方加上删除线。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">他可以修饰构造器、字段（属性）、局部变量、方法、包、参数、类型。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">他的用处就是做一个过渡，在版本升级的时候提示某些正在使用的东西在后期是会被淘汰的。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">源码：</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">    String <span class="title function_">since</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">forRemoval</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SuppressWarnings-注解的案例"><a href="#SuppressWarnings-注解的案例" class="headerlink" title="@SuppressWarnings 注解的案例"></a>@SuppressWarnings 注解的案例</h3><ul>
<li>当我们不希望看到这些警告的时候，可以使用 SuppressWarnings 注解来抑制警告信息</li>
<li>在{“”} 中，可以写入你希望抑制(不显示)警告信息</li>
<li>作用的范围与放置的位置有关。他只会作用于下方第一个对象。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以指定的警告类型有：</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>关键字</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>抑制所有警告</td>
</tr>
<tr>
<td>boxing</td>
<td>抑制与封装&#x2F;拆装作业相关的警告</td>
</tr>
<tr>
<td>cast</td>
<td>抑制与强制转型作业相关的警告</td>
</tr>
<tr>
<td>dep-ann</td>
<td>抑制与淘汰注释相关的警告</td>
</tr>
<tr>
<td>deprecation</td>
<td>抑制与淘汰的相关警告</td>
</tr>
<tr>
<td>fallthrough</td>
<td>抑制与switch陈述式中遗漏break相关的警告</td>
</tr>
<tr>
<td>finally</td>
<td>抑制与未传回finally区块相关的警告</td>
</tr>
<tr>
<td>hiding</td>
<td>抑制与隐藏变数的区域变数相关的警告</td>
</tr>
<tr>
<td>incomplete-switch</td>
<td>抑制与switch陈述式(enum case)中遗漏项目相关的警告</td>
</tr>
<tr>
<td>javadoc</td>
<td>抑制与javadoc相关的警告</td>
</tr>
<tr>
<td>nls</td>
<td>抑制与非nls字串文字相关的警告</td>
</tr>
<tr>
<td>null</td>
<td>抑制与空值分析相关的警告</td>
</tr>
<tr>
<td>rawtypes</td>
<td>抑制与使用raw类型相关的警告</td>
</tr>
<tr>
<td>resource</td>
<td>抑制与使用Closeable类型的资源相关的警告</td>
</tr>
<tr>
<td>restriction</td>
<td>抑制与使用不建议或禁止参照相关的警告</td>
</tr>
<tr>
<td>serial</td>
<td>抑制与可序列化的类别遗漏serialVersionUID栏位相关的警告</td>
</tr>
<tr>
<td>static-access</td>
<td>抑制与静态存取不正确相关的警告</td>
</tr>
<tr>
<td>static-method</td>
<td>抑制与可能宣告为static的方法相关的警告</td>
</tr>
<tr>
<td>super</td>
<td>抑制与置换方法相关但不含super呼叫的警告</td>
</tr>
<tr>
<td>synthetic-access</td>
<td>抑制与内部类别的存取未最佳化相关的警告</td>
</tr>
<tr>
<td>sync-override</td>
<td>抑制因为置换同步方法而遗漏同步化的警告</td>
</tr>
<tr>
<td>unchecked</td>
<td>抑制与未检查的作业相关的警告</td>
</tr>
<tr>
<td>unqualified-field-access</td>
<td>抑制与栏位存取不合格相关的警告</td>
</tr>
<tr>
<td>unused</td>
<td>抑制与未用的程式码及停用的程式码相关的警告</td>
</tr>
</tbody></table>
<h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在想要使用的对象的上一行，写上：</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;关键字&quot;)</span></span><br></pre></td></tr></table></figure>
<p>如：让编译器忽略下方的类中所有的因未被使用所造成的警告：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JDK的元注解"><a href="#JDK的元注解" class="headerlink" title="JDK的元注解"></a>JDK的元注解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单的说就是修饰注解的注解。</span><br></pre></td></tr></table></figure>


<h3 id="元注解的种类"><a href="#元注解的种类" class="headerlink" title="元注解的种类"></a>元注解的种类</h3><table>
<thead>
<tr>
<th>注解类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>Retention</td>
<td>指定注解的作用范围，三种 SOURCE,CLASS,RUNTIM</td>
</tr>
<tr>
<td>Target</td>
<td>指定注解可以在哪些地方使用</td>
</tr>
<tr>
<td>Documented</td>
<td>指定该注解是否会在 javadoc中体现</td>
</tr>
<tr>
<td>Inherited</td>
<td>子类会继承父类的注解</td>
</tr>
</tbody></table>
<h4 id="Retention注解"><a href="#Retention注解" class="headerlink" title="Retention注解"></a>Retention注解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只能用于修饰一个 Annotation （注解）定义, 用于指定该 Annotation 可以保留多长时间（或者说保留范围）, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值:</span><br></pre></td></tr></table></figure>

<ol>
<li>RetentionPolicy.SOURCE: 编译器使用后，直接丢弃这种策略的注释。简单的说就是只在源码阶段是生效的，往后的.class文件不保留；</li>
<li>RetentionPolicy.CLASS: 编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 不会保留注解。 这是默认值。简单的说就是上一个的扩展版，将注解保留至class文件1中；</li>
<li>RetentionPolicy.RUNTIME:编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注解. 程序可以 通过反射获取该注解。这是所有注解中保留范围最长的，当程序在运行的时候，jvm虚拟机仍然会去读取该注解，并作出相应的处理。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如下方的Deprecated注解的源码，就有这个注解的存在</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">    String <span class="title function_">since</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">forRemoval</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的Retention的值为RetentionPolicy.RUNTIME，因此在javac编译的时候，就会提示一下信息：</p>
<blockquote>
<p>注: Test.java使用或覆盖了已过时的 API。<br>注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。</p>
</blockquote>
<h4 id="Target注解"><a href="#Target注解" class="headerlink" title="Target注解"></a>Target注解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target也包含一个名为value的成员变量。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比如下方的一个SupperssWarnings注解的一个源码</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以看到其中就有Target注解的存在，正因为他的存在，所以这个SupperssWarnings注解就可以用于修饰TYPE（类型）, FIELD（字段/属性）, METHOD（方法）, PARAMETER（参数）, CONSTRUCTOR（构造器）, LOCAL_VARIABLE, MODULE这些类型。</span><br></pre></td></tr></table></figure>

<h4 id="Documented注解"><a href="#Documented注解" class="headerlink" title="Documented注解"></a>Documented注解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用于指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">即在生成文档时，可以看到该注解。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如如下的Deprecated注解的源码，就有这个注解的存在</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">    String <span class="title function_">since</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">forRemoval</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>将程序执行中发生的不正常的情况称为异常。</p>
<p><strong>根据异常的发生情况可以分成两大类：运行时异常和编译时异常。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行异常是指在运行阶段会触发的异常，比如数组越界、空间不足等情况。运行时异常编译器检查不出来。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。</span><br></pre></td></tr></table></figure>
<p><strong>对于运行时异常，可以不作处理</strong>，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">而</span><br></pre></td></tr></table></figure>
<p><strong>编译异常是必须要处理</strong>的，不然通过不了编译。比如打开文件但文件不存在等情况</p>
<p><strong>执行过程中所发生的异常事件可分为两大类：ERROR（错误）和Exception。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR： Java虚拟机无法解决的严重问题。如: JVM系统内部错误、资源耗尽等严重情况。比如: StackOverflowError[栈溢出]和OOM(out of memory)，Error 是严重错误，程序会崩溃。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等，Exception 分为两大类:运行时异常[程序运行时，发生的异常]和编译时异常[编程时，编译器检查出的异常]。</span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>当异常发生时，对异常的处理方式。</p>
<ul>
<li>try - catch - finally<ul>
<li>将捕获到的异常自行处理。</li>
</ul>
</li>
<li>throws<ul>
<li>发生异常后不处理，直接抛出，谁调用谁接收。</li>
</ul>
</li>
</ul>
<h2 id="try-catch异常处理"><a href="#try-catch异常处理" class="headerlink" title="try - catch异常处理"></a>try - catch异常处理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java提供try和catch块来处理异常。try块用于包含可能出错的代码。catch块用于处理try块中发生的异常。可以根据需要在程序中有多个try...catch块。</span><br></pre></td></tr></table></figure>


<h3 id="基本语法-6"><a href="#基本语法-6" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//可能会出异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常)&#123;</span><br><span class="line">  <span class="comment">//出异常后会执行的代码。</span></span><br><span class="line">  <span class="comment">//catch块可以有多个，</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">//不管异常是否发生，此处的代码都会被执行。如关闭连接、释放资源等。此块可以缺省不写。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;异常信息为：&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序继续执行&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：</p>
<p>异常信息为：For input string: “aaa”<br>程序继续执行</p>
</blockquote>
<h3 id="try-catch的细节"><a href="#try-catch的细节" class="headerlink" title="try - catch的细节"></a>try - catch的细节</h3><ol>
<li><p>如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块；如果存在finally块，还会执行finally块中的语句。</p>
</li>
<li><p>如果异常没有发生，则顺序执行try的代码块，不会进入到catch。如果存在finally块，还会执行finally块中的语句。</p>
</li>
<li><p>如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)则使用finally {}。需要注意的是，一旦有这个finally，哪怕 try或catch里面有return，也不会退出，而是执行finally语句块。虽然return暂时不会执行，但return后面的语句照样会被执行。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> n1=<span class="number">2</span>,n2=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n1/n2;<span class="comment">//出现异常</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">return</span> ++i;<span class="comment">//注意，此处的++i执行了，但并没有返回，因为下面的finally有返回了。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ++i;<span class="comment">//执行了并且返回了。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  System.out.println(fun());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行结果：2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>如果finally中没有return退出语句，则还是会回到catch中执行对应的return。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="type">int</span> n1=<span class="number">2</span>,n2=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n1/n2;<span class="comment">//制造异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            <span class="keyword">return</span> i;<span class="comment">//执行到此i会被暂时保存，直到执行完finally为止。如果finally中没有结束程序，再回头将保存的给返回回去。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(fun());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果：</span></span><br><span class="line"><span class="comment">//i = 4</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>可以有多个catch语句捕获不同的异常(进行不同的业务处理)，要求<strong>父类异常在后，子类异常在前</strong>，比如(Exception 在后，NullPointerException 在前）。如果发生异常，只会匹配一个catch。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如：</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">            person = <span class="literal">null</span>;<span class="comment">//空指针异常，NullPointerException</span></span><br><span class="line">            System.out.println(person.getName());</span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>, n2 = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n1 / n2;<span class="comment">//算数异常，</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空指针异常：&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;算术异常：&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;其他异常&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>可以省略catch，直接进行try-finally配合使用，这种用法<strong>相当于没有捕获异常</strong>，因此程序会直接崩掉&#x2F;退出。比如发生异常后不进行处理，只负责关闭一些连接然后崩溃。因为没有处理异常，所以会被默认的throws抛出，层层上抛，直到JJVM机，然后JVM将异常信息打出来，并结束程序。</li>
</ol>
<h3 id="案例：利用try-catch使的用户输入的必须是整数，不是就重输"><a href="#案例：利用try-catch使的用户输入的必须是整数，不是就重输" class="headerlink" title="案例：利用try - catch使的用户输入的必须是整数，不是就重输"></a>案例：利用try - catch使的用户输入的必须是整数，不是就重输</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                num = Integer.parseInt(scanner.next());<span class="comment">//如果输入的字符串不是纯整数，就会抛异常；</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//只要抛异常就不会执行退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入有误，请重新输入&quot;</span>);<span class="comment">//检测到异常后输出提示信息让用户重新输入。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h2><h3 id="基本介绍和使用细节"><a href="#基本介绍和使用细节" class="headerlink" title="基本介绍和使用细节"></a>基本介绍和使用细节</h3><ol>
<li><p>如果个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</p>
</li>
<li><p>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p>
</li>
<li><p>对于<strong>编译异常</strong>，程序中必须处理，比如 try - catch 或者throws。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;<span class="comment">//针对编译异常必须要有对应的异常处理才能通过。可以抛出对应的FileNotFoundException异常或者对应异常的父类异常Exception</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://test.txt&quot;</span>);<span class="comment">//这里创建了一个文件流，但因为不存在文件所以会报异常（编译异常）</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对于<strong>运行异常</strong>，程序中如果没有处理，默认就是throws的方式处理。知道throws到JVM虚拟机为止。JVM处理异常的功能就是，将异常打印出来，并中断运行。</p>
</li>
<li><p>子类重写父类的方法时，所抛出的异常类型要么和父类抛出的异常一致， 要么为父类抛出的异常的类型的子类型。或者说子类不能扩大父类的异常范围，也不能和父类没有关系。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> ArithmeticException&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> ArithmeticException &#123;<span class="comment">//只能是父类类A中原函数抛出异常的子类或者他自己，不能比父类大，如Exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必throws。</p>
</li>
<li><p>如果一个方法调用了另一个存在编译异常且直接throws抛出的方法，则在调用该方法的时候必须明确的处理。</p>
<p>哪怕只是抛出但并没有真正的触发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">        f2();<span class="comment">//哪怕只是抛出但并没有真正的触发也得处理</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f2();<span class="comment">//对于调用的方法如果存在编译异常，则必须对这个异常进行显示(明确)的处理，再次throws抛出或者try</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);<span class="comment">//也可以捕获了再抛出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;<span class="comment">//此处不做处理 直接抛出</span></span><br><span class="line">        <span class="comment">//创建一个编译异常</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://test.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>或者在方法内就try - catch处理掉，或者捕获后再抛出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        f2();<span class="comment">//可以不处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f2();<span class="comment">//也可以处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;<span class="comment">//此处不做处理 直接抛出</span></span><br><span class="line">        <span class="comment">//创建一个编译异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://test.txt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);<span class="comment">//如果这样抛，也可以调用者也可以不用处理。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对于<strong>运行异常调用者可以不进行处理。因为存在默认的处理机制</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        f2();<span class="comment">//可以不处理，因为有默认的处理机制</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f2();<span class="comment">//也可以处理一下</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> <span class="keyword">throws</span> ArithmeticException&#123;<span class="comment">//此处不做处理 直接抛出</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当程序中出现了某些&quot;错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息。</span><br></pre></td></tr></table></figure>

<h3 id="自定义异常的步骤"><a href="#自定义异常的步骤" class="headerlink" title="自定义异常的步骤"></a>自定义异常的步骤</h3><ol>
<li>定义类自定义异常类名(程序员自己写)继承Exception或RuntimeException；</li>
<li>如果继承Exception，属于编译异常；</li>
<li>如果继承RuntimeException，属于运行异常（一般来说，继承RuntimeException，因为可以使用默认的异常处理机制）；</li>
</ol>
<h4 id="样例：要求：当我们接收Person对象年龄时，要求范围在18-120之间，否则抛出一个自定义异常-要求继承RuntimeException-并给出提示信息"><a href="#样例：要求：当我们接收Person对象年龄时，要求范围在18-120之间，否则抛出一个自定义异常-要求继承RuntimeException-并给出提示信息" class="headerlink" title="样例：要求：当我们接收Person对象年龄时，要求范围在18 - 120之间，否则抛出一个自定义异常(要求继承RuntimeException)并给出提示信息"></a>样例：要求：当我们接收Person对象年龄时，要求范围在18 - 120之间，否则抛出一个自定义异常(要求继承RuntimeException)并给出提示信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age1</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(age1 &gt;= <span class="number">18</span> &amp;&amp; age1 &lt;= <span class="number">120</span>)) &#123;<span class="comment">//设定一个范围</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;年龄需要在18-120之间&quot;</span>);<span class="comment">//通过构造器设置异常的信息</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄范围正常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;<span class="comment">//自定义一个异常类，因为要求是运行时异常，所以继承RuntimeException</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span> &#123;<span class="comment">//类的构造函数</span></span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：</p>
<p>Exception in thread “main” net.hurr.exception_.AgeException: 年龄需要在18-120之间<br>at net.hurr.exception_.Test.main(Test.java:10)</p>
</blockquote>
<h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><table>
<thead>
<tr>
<th>名字</th>
<th>意义</th>
<th>位置</th>
<th>后面跟的东西</th>
</tr>
</thead>
<tbody><tr>
<td>throws</td>
<td>异常处理的一种方式</td>
<td>方法的声明处</td>
<td>异常类型</td>
</tr>
<tr>
<td>throw</td>
<td>手动生成异常的关键字</td>
<td>方法体中</td>
<td>异常对象</td>
</tr>
</tbody></table>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">针对八种基本定义相应的引用类型——包装类。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有了类的特点，就可以调用类中的方法。</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
<th>父类</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Boolean</td>
<td></td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
<td></td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
<td>Number</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
<td>Number</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
<td>Number</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
<td>Number</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
<td>Number</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
<td>Number</td>
</tr>
</tbody></table>
<h3 id="包装类与基本数据类型的转换"><a href="#包装类与基本数据类型的转换" class="headerlink" title="包装类与基本数据类型的转换"></a>包装类与基本数据类型的转换</h3><ul>
<li>jdk5前的手动装箱和拆箱方式，装箱:基本类型-&gt;包装类型，反之，就是拆箱</li>
</ul>
<ul>
<li>jdk5以后(含jdk5)的自动装箱和拆箱方式<ul>
<li>自动装箱底层调用的是valueOf方法，比如Integer.valueOf()</li>
</ul>
</li>
</ul>
<h3 id="装箱和拆箱的演示"><a href="#装箱和拆箱的演示" class="headerlink" title="装箱和拆箱的演示"></a>装箱和拆箱的演示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//int &lt;---&gt; Integer</span></span><br><span class="line"><span class="comment">//手动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(n1);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> Integer.valueOf(n1);<span class="comment">//或者这样</span></span><br><span class="line"><span class="comment">//手动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk5（包括5）以后的自动装箱拆箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> n2;<span class="comment">//底层依然是Integer.valueOf(),本质仍然是手动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> integer2;<span class="comment">//同样，底层也还是手动拆箱的intValue()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同理，其他的数据类型也可以这么玩</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">Character</span> <span class="variable">C</span> <span class="operator">=</span> c;</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">20.2</span>);</span><br></pre></td></tr></table></figure>
<h3 id="包装类型与String类型的相互转换"><a href="#包装类型与String类型的相互转换" class="headerlink" title="包装类型与String类型的相互转换"></a>包装类型与String类型的相互转换</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包装类 -&gt; String</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">//方式1：相当于生成一个新的串赋值给s1，而i的值不会变</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> n+<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">//方式2：比较传统，几乎所有包装类都有这个方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> n.toString();      </span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;a&#x27;</span>).toString();</span><br><span class="line"><span class="comment">//方式3 相当于转换了两次，i变成了obj，obj再到string</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//String -&gt; 包装类</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> Double.parseDouble(str);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(str);<span class="comment">//利用Integer的构造方法</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，当包装类与基本类型相比较的时候，比较的是值而非类型或地址。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line">System.out.println(n1 == n2);</span><br></pre></td></tr></table></figure>
<p>执行之后会显示true。但Sting没有基本类型，所以如果这么比较，会是false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol>
<li>String对象用于保存字符串，也就是一组字符序列。</li>
<li>字符串常量对象是用双引号括起的字符序列。例如: “你好”、 “12.97”、 “boy”等。</li>
<li>字符串的字符使用Unicode字符编码，一个字符(不区分字母还是汉字)占两个字节。</li>
<li>String类较常用构造器(其它看手册):</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(String original);</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a,<span class="type">int</span> startIndex,<span class="type">int</span> count)<span class="comment">//从字符数组中初始化，从第几位开始，获取几个</span></span><br></pre></td></tr></table></figure>
<h3 id="创建-String对象的方式"><a href="#创建-String对象的方式" class="headerlink" title="创建 String对象的方式"></a>创建 String对象的方式</h3><ul>
<li>方式一:直接赋值String s1 &#x3D; “hurriedlu”;</li>
<li>方式二:调用构造器String s2 &#x3D; new String(“hurriedlu”);</li>
</ul>
<h4 id="两种创建-String对象的区别"><a href="#两种创建-String对象的区别" class="headerlink" title="两种创建 String对象的区别"></a>两种创建 String对象的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一：先从常量池查看是否有对应字符串的数据空间，如果有，直接指向;如果没有则重新创建，然后指向。</span><br></pre></td></tr></table></figure>
<p><strong>s1最终指向的是常量池的空间地址</strong>。<br>        方式二：先在堆中创建空间，里面维护了value属性，指向常量池的对应字符串的空间。如果常量池没有”hsp”,重新创建，如果有，直接通过value指向。 s2最终指向的是堆中的空间地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单的说，方式一的直接赋值相当于直接指向对应的空间，方式二通过构造函数的方式赋值相当于先创建一个对象，再由对象指向对应的空间。</span><br></pre></td></tr></table></figure>

<h3 id="String的父类和接口"><a href="#String的父类和接口" class="headerlink" title="String的父类和接口"></a>String的父类和接口</h3><p>接口：Serializable（实现了这个接口说明这个类可以串行化，以便在网络中传输），Comparable（实现了这个接口说明这个类可以相互比较），CharSequence。</p>
<h3 id="String的特性"><a href="#String的特性" class="headerlink" title="String的特性"></a>String的特性</h3><ol>
<li>String是一个final类， 代表不可变的字符序列，也就是说不能被其他类所继承并改写。</li>
<li>字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的。</li>
<li>String的底层还是数组，在String类中维护了一个可变长度的finial类型的value数组，字符串就存储在这个数组中。value一旦指向了某块地址，就不能再指向其他的地址（空间）了。但这块地址的值还是可以随便修改的。</li>
</ol>
<h3 id="常见的误区"><a href="#常见的误区" class="headerlink" title="常见的误区"></a>常见的误区</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;========================================&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1：&quot;</span>);</span><br><span class="line">        <span class="comment">//1、求输出结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s1.equals(s2));<span class="comment">//T，因为equals函数是值比较</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//T,因为指向的是同一个常量池中的地址。</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========================================&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2：&quot;</span>);</span><br><span class="line">        <span class="comment">//2、求输出结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;hurr&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hurr&quot;</span>);</span><br><span class="line">        System.out.println(s3.equals(s4));<span class="comment">//T,因为是值比较</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//F,s3是直接指向常量池中的字符串，s4是指向堆中的一个对象，所以地址不同</span></span><br><span class="line">        System.out.println(s3 == s4.intern());<span class="comment">//T,因为intern方法是返回常量池的地址，而s3也是常量池中的一个地址</span></span><br><span class="line">        System.out.println(s4 == s3.intern());<span class="comment">//F,因为intern方法是返回常量池的地址，而s4是堆中一个对象的地址</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========================================&quot;</span>);</span><br><span class="line">        <span class="comment">//3、问：以下语句创建了几个对象？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        s5 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        <span class="comment">//一共创建了两个对象。字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的。</span></span><br><span class="line">        <span class="comment">//因此，原来的仍然会保留，只是又新建了一个World的字符串，然后将s5指向了这个字符串。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、问：以下语句创建了几个对象？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        <span class="comment">//注意，只创建了一个。因为编译器在底层有一个优化，避免了两个字符串没有使用却要占地方，因此等价于String s6 = &quot;HelloWorld&quot;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、问：以下语句创建了几个对象？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s9</span> <span class="operator">=</span> s7 + s8;</span><br><span class="line">        <span class="comment">//一共创建了三个。具体流程如下：</span></span><br><span class="line">        <span class="comment">//1. 首先新建一个s9的对象；2. 在常量池中创建一个Hello；3. 在第二步创建的常量后面追加World；4. 将s9中的value指针指向第二步创建的常量。</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========================================&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6：&quot;</span>);</span><br><span class="line">        <span class="comment">//6、问：以下语句的输出情况</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s10</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s11</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s12</span> <span class="operator">=</span> (s7 + s8).intern();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s13</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">        System.out.println(s12 == s13);<span class="comment">//T</span></span><br><span class="line">        System.out.println(s12.equals(s13));<span class="comment">//T</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="String-常用的方法"><a href="#String-常用的方法" class="headerlink" title="String 常用的方法"></a>String 常用的方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String类是保存字符串常量的。每次更新都需要重新开辟空间，效率较低，因此java设计者还提供了StringBuilder和StringBuffer来增强String的功能，并提高效率。</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>equals</td>
<td>比较两个字符串（String对象）的值是否相等。s1.equal(s2);</td>
</tr>
<tr>
<td>equalsIgnoreCase</td>
<td>比较两个字符串是否相等（忽略大小写）。s1.equalsIgnoreCase(s2);</td>
</tr>
<tr>
<td>length</td>
<td>返回字符串的长度。s1.length();</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>intern()</td>
<td>如果常量池已经包含一个等于此String的对象，就返回池中的字符串；否则将此String添加到池中，并返回此String对象的引用<br />简单的说就是，返回常量池对应的字符串的地址，相当于返回用方式1新建出来的String对象。</td>
</tr>
</tbody></table>
<p>equals &#x2F;&#x2F;区分大小写，判断内容是否相等<br>equalslgnoreCase &#x2F;&#x2F;忽略大小写的判断内容是否相等<br>length &#x2F;获取字符的个数，宇符串的长度<br>indexOf &#x2F;&#x2F;获取字符在字符串中第1次出现的索引,索引从开始，如果找不到，返回-1<br>lastIndexOf &#x2F;&#x2F;获取字符在字符串中最后1次出现的索引,索引从开始，如找不到，返回-1<br>substring &#x2F;&#x2F;截取指定范围的子串<br>trim &#x2F;&#x2F;去前后空格<br>charAt:获取某索引处的字符，注意不能使用Str[index]这种方式</p>
<p>toUpperCase<br>toLowerCase<br>concat<br>replace替换字符串中的字符<br>split分割字符串，对于某些分割字符，我们需要转义比如| l\等<br>案例: String poem &#x3D; “锄禾日当午,汗滴禾下土，谁知盘中餐,粒粒皆辛苦”:和文<br>件路径.<br>compareTo &#x2F;&#x2F;比较两个字符串的大小<br>toCharArray &#x2F;&#x2F;转换成字符数组<br>format &#x2F;&#x2F;格式字符串，%s宇符串%c字符%d整型%.2f浮点型<br>案例，将一个人的信息格式化输出</p>
<h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><ul>
<li>java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删。</li>
<li>很多方法与String相同，但StringBuffer是可变长度的。</li>
<li>StringBuffer是一个容器。</li>
</ul>
<h4 id="StringBuffer的特性"><a href="#StringBuffer的特性" class="headerlink" title="StringBuffer的特性"></a>StringBuffer的特性</h4><ol>
<li>StringBuffer 的直接父类 是 AbstractStringBuilder；</li>
<li>StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化；</li>
<li>在父类中 AbstractStringBuilder 有属性 char[] value,不是 final，因此该 value 数组存放在堆中而不是常量池；</li>
<li>StringBuffer 是一个 final 类，不能被继承 ；</li>
<li>因为 StringBuffer 字符内容是存在 char[] value, 所有的变化(增加&#x2F;删除) 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String</li>
</ol>
<h4 id="String-和-StringBuffer的区别"><a href="#String-和-StringBuffer的区别" class="headerlink" title="String 和 StringBuffer的区别"></a>String 和 StringBuffer的区别</h4><ol>
<li>String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址， 效率较低&#x2F;&#x2F;private final char value[];</li>
<li>StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次更新地址（只有在空间不够的时候才会更新，即不支持动态调整空间），效率较高<br>&#x2F;&#x2F;char[] value; &#x2F;这个放在堆.</li>
</ol>
<h4 id="StringBuffer的构造器"><a href="#StringBuffer的构造器" class="headerlink" title="StringBuffer的构造器"></a>StringBuffer的构造器</h4><p>StringBuffer()<br>构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符。<br>简单的说就是，创建一个大小为 16 的char[]，用于存放字符内容。</p>
<p>StringBuffer(CharSequence seq)<br>public java.lang StringBuilder(CharSequence seq)构造-一个字符串缓冲区，它包含与指定的CharSequence相同的字符。</p>
<p>StringBuffer(int capacity) &#x2F;&#x2F;capacity [容量]<br>构造一个不带字符，但具有指定初始容量的字符串缓冲区。即对char[]大小进行指定<br>和第一个构造器类似，简单的说就是可以指定初始空间的大小。</p>
<p>StringBuffer(String str)<br>构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容。<br>简单的说就是用已有的str对象创建一个StringBuffer对象，其空间大小为str字符串的长度+16.<br>需要注意的是，如果str是一个空串，则会抛出空指针异常。因为在源码中需要先计算。如下代码所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">会抛出空指针异常。（java.lang.NullPointerException）因为在底层会先获取str的长度，而空串是没有长度的。</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果用于初始化的数组</p>
<h4 id="String-和-StringBuffer相互转换"><a href="#String-和-StringBuffer相互转换" class="headerlink" title="String 和 StringBuffer相互转换"></a>String 和 StringBuffer相互转换</h4><h5 id="String-转-StringBuffer"><a href="#String-转-StringBuffer" class="headerlink" title="String 转 StringBuffer"></a>String 转 StringBuffer</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单的说就是利用上方第四个构造器，创建一个StringBuffer对象；</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hurriedlu&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);<span class="comment">//注意，返回的只是一个利用str的值创建StringBuffer的对象，对他本身没有影响。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同样也可以利用追加的方式</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">stringBuffer1 = stringBuffer1. append(str);<span class="comment">//将str的值追加到新创的append里面。</span></span><br></pre></td></tr></table></figure>
<h5 id="StringBuffer-转-String"><a href="#StringBuffer-转-String" class="headerlink" title="StringBuffer 转 String"></a>StringBuffer 转 String</h5><p>同样也可以利于构造器进行转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hurriedlu&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(stringBuffer);</span><br></pre></td></tr></table></figure>
<p>利用StringBuffer的toString方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hurriedlu&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> stringBuffer3.toString();</span><br></pre></td></tr></table></figure>
<h4 id="StringBuffer的常用方法"><a href="#StringBuffer的常用方法" class="headerlink" title="StringBuffer的常用方法"></a>StringBuffer的常用方法</h4><ol>
<li><p>追加（增）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">s.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">s.append(<span class="string">&quot;worle&quot;</span>);</span><br><span class="line">s.append(<span class="string">&quot;!&quot;</span>).append(<span class="number">100</span>).append(<span class="literal">true</span>).append(<span class="number">10.5</span>);<span class="comment">//append可以连，且返回值都是StringBuffer的类型。</span></span><br><span class="line">System.out.println(s);<span class="comment">//hello,worle!100true10.5</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要注意的是，如果追加的字符串是空，是null，则将null转换成字符串的“null”追加到后面。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>删</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">s.delete(<span class="number">5</span>,<span class="number">10</span>);<span class="comment">//删除字符串序列中大于等于start,小于end的字符，小于10的字符。（序号从0起，左闭右开，类似于c++里面的迭代器）</span></span><br><span class="line">System.out.println(s);<span class="comment">//hello</span></span><br></pre></td></tr></table></figure></li>
<li><p>（替换）改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello123world&quot;</span>);</span><br><span class="line">s.replace(<span class="number">5</span>,<span class="number">8</span>,<span class="string">&quot;,&quot;</span>);<span class="comment">//同上面的删除功能，左闭右开，从0起，将区间内的文字替换成第三个参数</span></span><br><span class="line">System.out.println(s);<span class="comment">//hello,world</span></span><br></pre></td></tr></table></figure></li>
<li><p>查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;123123123&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> s.indexOf(<span class="string">&quot;2&quot;</span>);<span class="comment">//返回第一次出现实参数据的位置，此处返回1.因为序列是从0起</span></span><br><span class="line">System.out.println(index);</span><br></pre></td></tr></table></figure></li>
<li><p>插</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello,!&quot;</span>);</span><br><span class="line">s.insert(<span class="number">6</span>,<span class="string">&quot;World&quot;</span>);<span class="comment">//从0起，在第6个的位置插入参数2的数据,原来在参数1及后面的位置的数据自动后移</span></span><br><span class="line">System.out.println(s);<span class="comment">//Hello,World!</span></span><br></pre></td></tr></table></figure></li>
<li><p>长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();<span class="comment">//返回字符串的长度</span></span><br><span class="line">System.out.println(len);<span class="comment">//5</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuilder一个可变的字符序列。此类提供一个与StringBuffer兼容的APl,但不保证同步(换句话说就是StringBuilder不是线程安全的)。该类被设计用作StringBuffer的一个简易替换，</span><br></pre></td></tr></table></figure>
<p><strong>用在字符串缓冲区被单个线程使用的时候</strong>。如果可能，建议优先采用该类！因为在大多数实现中，它比StringBuffer要快。<br>        在StringBuilder上的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据。</p>
<h4 id="StringBuilder-常用方法"><a href="#StringBuilder-常用方法" class="headerlink" title="StringBuilder 常用方法"></a>StringBuilder 常用方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuilder和StringBuffer均代表可变的字符序列，方法是一样的，所以使用和StringBuffer一样。</span><br></pre></td></tr></table></figure>

<h4 id="StringBuilder的特点"><a href="#StringBuilder的特点" class="headerlink" title="StringBuilder的特点"></a>StringBuilder的特点</h4><ol>
<li>StringBuilder 继承 AbstractStringBuilder 类；</li>
<li>实现了 Serializable ,说明 StringBuilder 对象是可以串行化(可以串行话说明对象可以网络传输，也可以保存到文件)</li>
<li>StringBuilder 是 final 类, 不能被继承；</li>
<li>StringBuilder 对象字符序列仍然是存放在其父类 AbstractStringBuilder 的 char[] value，因此，字符序列是存放在堆中的；</li>
<li>StringBuilder 的方法没有做互斥的处理,即没有 synchronized 关键字,因此最好<strong>只在单线程的情况下使用</strong>。</li>
</ol>
<h3 id="String、StringBuffer-和-StringBuilder的比较"><a href="#String、StringBuffer-和-StringBuilder的比较" class="headerlink" title="String、StringBuffer 和 StringBuilder的比较"></a>String、StringBuffer 和 StringBuilder的比较</h3><ol>
<li>StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样；</li>
<li>String:不可变字符序列，效率低，但是<strong>复用率高</strong>（因为字符串只会出现一次，后续的都会指向常量池中这唯一的一个）；</li>
<li>StringBuffer:可变字符序列、效率较高(增删)、线程安全；</li>
<li>StringBuilder: 可变字符序列、<strong>效率最高</strong>、<strong>线程不安全</strong>；</li>
<li>String使用注意说明:<br>string s&#x3D;”a”; &#x2F;&#x2F;创建了一个字符串<br>S +&#x3D; “b”; &#x2F;&#x2F;实际上原来的”a”字符串对象已经丢弃了（但还存在），现在又产生了一个字符串s+”b” (也就是” ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。结论:如果我们对String做大量修改，不要使用String</li>
</ol>
<h3 id="String、StringBuffer-和-StringBuilder-的应用场景"><a href="#String、StringBuffer-和-StringBuilder-的应用场景" class="headerlink" title="String、StringBuffer 和 StringBuilder 的应用场景"></a>String、StringBuffer 和 StringBuilder 的应用场景</h3><ol>
<li>如果字符串存在大量的修改操作，-般使用StringBuffer或StringBuilder</li>
<li>如果字符事存在大量的修改操作，并在单线程的情况，使用StringBuilder</li>
<li>如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer</li>
<li>如果我们字符串很少修改，被多个对象引用，使用String,比如配置信息等</li>
</ol>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。</p>
<h3 id="Math常用的方法（均为静态方法）"><a href="#Math常用的方法（均为静态方法）" class="headerlink" title="Math常用的方法（均为静态方法）"></a>Math常用的方法（均为静态方法）</h3><h4 id="abs-求绝对值"><a href="#abs-求绝对值" class="headerlink" title="abs  求绝对值"></a>abs  求绝对值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> Math.abs(-<span class="number">2</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">n2</span> <span class="operator">=</span> Math.abs(-<span class="number">9.8</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;n1 = &quot;</span> + n1 + <span class="string">&quot;   n2 = &quot;</span> + n2);<span class="comment">//n1 = 2   n2 = 9.8</span></span><br></pre></td></tr></table></figure>
<h4 id="pow-求幂（返回值为double）"><a href="#pow-求幂（返回值为double）" class="headerlink" title="pow 求幂（返回值为double）"></a>pow 求幂（返回值为double）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> Math.pow(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//8.0，2的3次方</span></span><br></pre></td></tr></table></figure>
<h4 id="ceil-向上取整（返回大于等于该参数的最小整数，返回值依然是double）"><a href="#ceil-向上取整（返回大于等于该参数的最小整数，返回值依然是double）" class="headerlink" title="ceil 向上取整（返回大于等于该参数的最小整数，返回值依然是double）"></a>ceil 向上取整（返回大于等于该参数的最小整数，返回值依然是double）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> Math.ceil(<span class="number">2.8</span>);<span class="comment">//3.0</span></span><br></pre></td></tr></table></figure>
<h4 id="floor-向下取整（返回小于等于该参数的最小整数，返回值依然是double）"><a href="#floor-向下取整（返回小于等于该参数的最小整数，返回值依然是double）" class="headerlink" title="floor 向下取整（返回小于等于该参数的最小整数，返回值依然是double）"></a>floor 向下取整（返回小于等于该参数的最小整数，返回值依然是double）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> Math.floor(<span class="number">2.8</span>);<span class="comment">//2.0</span></span><br></pre></td></tr></table></figure>
<h4 id="round-四舍五入（返回值为long，约等于Math-floor-该参数-0-5-？）"><a href="#round-四舍五入（返回值为long，约等于Math-floor-该参数-0-5-？）" class="headerlink" title="round 四舍五入（返回值为long，约等于Math.floor(该参数+0.5)？）"></a>round 四舍五入（返回值为long，约等于Math.floor(该参数+0.5)？）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">s</span> <span class="operator">=</span> Math.round(<span class="number">2.8</span>);<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<h4 id="sqrt-求算数平方根（要求参数为大于等于0的非负数）"><a href="#sqrt-求算数平方根（要求参数为大于等于0的非负数）" class="headerlink" title="sqrt 求算数平方根（要求参数为大于等于0的非负数）"></a>sqrt 求算数平方根（要求参数为大于等于0的非负数）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">sqrt</span> <span class="operator">=</span> Math.sqrt(<span class="number">9</span>);<span class="comment">//3.0</span></span><br></pre></td></tr></table></figure>
<h4 id="random-求随机数（返回一个大于等于0并且小于1之间的一个小数）"><a href="#random-求随机数（返回一个大于等于0并且小于1之间的一个小数）" class="headerlink" title="random 求随机数（返回一个大于等于0并且小于1之间的一个小数）"></a>random 求随机数（返回一个大于等于0并且小于1之间的一个小数）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">rand</span> <span class="operator">=</span> Math.random()</span><br></pre></td></tr></table></figure>
<p>扩展：求一个给定的范围之间的随机数（大于等于a , 小于等于b）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>)(a + Math.random() * (b - a + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h4 id="max-min-返回最大值和最小值"><a href="#max-min-返回最大值和最小值" class="headerlink" title="max , min 返回最大值和最小值"></a>max , min 返回最大值和最小值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">maxx</span> <span class="operator">=</span> Math.max(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//3</span></span><br><span class="line"><span class="type">int</span> <span class="variable">minn</span> <span class="operator">=</span> Math.max(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>该类的主要作用就是用于管理和操作数组（如排序、搜索等）</p>
<h3 id="Arrays的常用方法"><a href="#Arrays的常用方法" class="headerlink" title="Arrays的常用方法"></a>Arrays的常用方法</h3><h4 id="toString-以字符串形式返回数组中的元素"><a href="#toString-以字符串形式返回数组中的元素" class="headerlink" title="toString    以字符串形式返回数组中的元素"></a>toString    以字符串形式返回数组中的元素</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(arr));<span class="comment">//[1, 3, 7, 5]</span></span><br></pre></td></tr></table></figure>
<h4 id="sort排序（同c-一样，默认从小到大，也支持自定义）"><a href="#sort排序（同c-一样，默认从小到大，也支持自定义）" class="headerlink" title="sort排序（同c++一样，默认从小到大，也支持自定义）"></a>sort排序（同c++一样，默认从小到大，也支持自定义）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));<span class="comment">//[-1, 1, 3, 5, 7]</span></span><br></pre></td></tr></table></figure>
<p>支持的数组类型：int,long,short,char,byte,float,double等。</p>
<p>同时，在Java中也支持sort的排序规则自定义（利用实现了Comparable接口的一个匿名内部类，要求实现 compare方法）。（ sort(T[] a , Comparator &lt;? super T&gt; c ) ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, -<span class="number">1</span>&#125;;<span class="comment">//注意这里一定要是Integer,不能是int数组</span></span><br><span class="line">Arrays.sort(arr,<span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1,Object o2)</span>&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> (Integer) o1;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> (Integer) o2;</span><br><span class="line">    <span class="keyword">return</span> i2-i1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(arr));<span class="comment">//[7, 5, 3, 1, -1]</span></span><br></pre></td></tr></table></figure>
<h4 id="binarySearch-通过二分搜索法进行查找，要求必须排好序"><a href="#binarySearch-通过二分搜索法进行查找，要求必须排好序" class="headerlink" title="binarySearch    通过二分搜索法进行查找，要求必须排好序"></a>binarySearch    通过二分搜索法进行查找，要求必须排好序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, -<span class="number">1</span>&#125;;<span class="comment">//注意这里一定要是Integer,不能是int数组</span></span><br><span class="line">Arrays.sort(arr);<span class="comment">//因为查找是基于二分的，所以要求序列有序.[-1, 1, 3, 5, 7]</span></span><br><span class="line"><span class="type">int</span> index;</span><br><span class="line"><span class="comment">//index = Arrays.binarySearch(arr, 5);//3</span></span><br><span class="line">index = Arrays.binarySearch(arr, <span class="number">0</span>);<span class="comment">//-2</span></span><br><span class="line"><span class="comment">//这个方法的一个特点就是，如果找不到，就返回这个数应该在的位置，并置为负数。简单的说就是返回左右指针相等的那个值的负数</span></span><br></pre></td></tr></table></figure>
<h4 id="copyOf-数组元素复制"><a href="#copyOf-数组元素复制" class="headerlink" title="copyOf    数组元素复制"></a>copyOf    数组元素复制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, -<span class="number">1</span>&#125;;<span class="comment">//注意这里一定要是Integer,不能是int数组</span></span><br><span class="line">Integer num[] = Arrays.copyOf(arr,arr.length);<span class="comment">//从arr数组复制，复制arr.length个元素</span></span><br><span class="line">System.out.println(arr == num);<span class="comment">//F，这是两个除了值一样其余完全不相干的数组</span></span><br><span class="line">System.out.println(Arrays.equals(arr,num));<span class="comment">//T</span></span><br></pre></td></tr></table></figure>
<h4 id="fill-数组元素填充"><a href="#fill-数组元素填充" class="headerlink" title="fill 数组元素填充"></a>fill 数组元素填充</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, -<span class="number">1</span>&#125;;<span class="comment">//注意这里一定要是Integer,不能是int数组</span></span><br><span class="line">Arrays.fill(arr,<span class="number">0</span>);<span class="comment">//全部填充</span></span><br><span class="line">System.out.println(Arrays.toString(arr));<span class="comment">//[0, 0, 0, 0, 0]</span></span><br><span class="line">Arrays.fill(arr,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>);<span class="comment">//将数组arr中从下标1（包含）到3（不包含）的元素的值填充为2.</span></span><br><span class="line">System.out.println(Arrays.toString(arr));<span class="comment">//[0, 2, 2, 0, 0]</span></span><br></pre></td></tr></table></figure>
<h4 id="equals-比较两个数组元素的内容是否完全一-致"><a href="#equals-比较两个数组元素的内容是否完全一-致" class="headerlink" title="equals 比较两个数组元素的内容是否完全一 致"></a>equals 比较两个数组元素的内容是否完全一 致</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr1[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr2[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(Arrays.equals(arr1,arr2));<span class="comment">//T</span></span><br><span class="line"><span class="comment">//需要注意两个数组的类型必须一样，哪怕一个是int一个是Integer都不行</span></span><br></pre></td></tr></table></figure>
<h4 id="asList-将一组值，转换成list"><a href="#asList-将一组值，转换成list" class="headerlink" title="asList 将一组值，转换成list"></a>asList 将一组值，转换成list</h4><ol>
<li>asList 方法，会将数组中的数据转成一个 List 集合</li>
<li>返回的 asList 编译类型 List（是接口）</li>
<li>asList 运行类型 java.util.Arrays#ArrayList, 是 Arrays 类的一个静态内部类 private static class ArrayList extends AbstractList implements RandomAccess, java.io.Serializable</li>
</ol>
<h3 id="Arrays项目：将自定义类型用sort的形式进行排序"><a href="#Arrays项目：将自定义类型用sort的形式进行排序" class="headerlink" title="Arrays项目：将自定义类型用sort的形式进行排序"></a>Arrays项目：将自定义类型用sort的形式进行排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.hurr.annotation_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Book books[] = <span class="keyword">new</span> <span class="title class_">Book</span>[<span class="number">4</span>];</span><br><span class="line">        books[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        books[<span class="number">0</span>].setName(<span class="string">&quot;红楼梦&quot;</span>);</span><br><span class="line">        books[<span class="number">0</span>].setPricr(<span class="number">100.0</span>);</span><br><span class="line">        books[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        books[<span class="number">1</span>].setName(<span class="string">&quot;知音漫客&quot;</span>);</span><br><span class="line">        books[<span class="number">1</span>].setPricr(<span class="number">90.0</span>);</span><br><span class="line">        books[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        books[<span class="number">2</span>].setName(<span class="string">&quot;青年文摘&quot;</span>);</span><br><span class="line">        books[<span class="number">2</span>].setPricr(<span class="number">5.0</span>);</span><br><span class="line">        books[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        books[<span class="number">3</span>].setName(<span class="string">&quot;Java 从入门到入土&quot;</span>);</span><br><span class="line">        books[<span class="number">3</span>].setPricr(<span class="number">900.0</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(books, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Book&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Book o1, Book o2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (o2.getPricr() &gt; o1.getPricr()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (o2.getPricr() == o1.getPricr()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(books));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double pricr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String name, Double pricr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.pricr = pricr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getPricr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pricr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPricr</span><span class="params">(Double pricr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pricr = pricr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, pricr=&quot;</span> + pricr +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//[Book&#123;name=&#x27;Java 从入门到入土&#x27;, pricr=900.0&#125;, Book&#123;name=&#x27;红楼梦&#x27;, pricr=100.0&#125;, Book&#123;name=&#x27;知音漫客&#x27;, pricr=90.0&#125;, Book&#123;name=&#x27;青年文摘&#x27;, pricr=5.0&#125;]</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><h3 id="System常用的方法"><a href="#System常用的方法" class="headerlink" title="System常用的方法"></a>System常用的方法</h3><h4 id="exit-退出当前程序"><a href="#exit-退出当前程序" class="headerlink" title="exit    退出当前程序"></a>exit    退出当前程序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.exit(-<span class="number">1</span>);<span class="comment">//括号中的参数代表一个状态，一般来说都写0，代表正常退出。反映在“进程已结束,退出代码0”</span></span><br></pre></td></tr></table></figure>
<h4 id="arraycopy-复制数组元素，比较适合底层调用，一般使用Arrays-copyOf完成数组的复制。"><a href="#arraycopy-复制数组元素，比较适合底层调用，一般使用Arrays-copyOf完成数组的复制。" class="headerlink" title="arraycopy :复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成数组的复制。"></a>arraycopy :复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成数组的复制。</h4><blockquote>
<p>该方法的五个参数如下所示</p>
<p>@param    src    the source array .     源数组的地址<br>@param    srcPos    starting position in the source array .        从源数组的第几个位置开始拷贝<br>@param    dest    the destination array。    目标数组的地址<br>@param    destPos    starting position in the destination data.    拷贝到目标数组的哪个位置<br>@param    Length     the number of array elements to be copied。    从源数组拷贝多少个元素到目标数组。不能超过源数组长度</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">System.arraycopy(num, <span class="number">0</span>, arr, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr));<span class="comment">//[1, 2, 3, 0, 0]</span></span><br></pre></td></tr></table></figure>
<h4 id="currentTimeMillens-返回当前时间距离1970-1-1的毫秒数"><a href="#currentTimeMillens-返回当前时间距离1970-1-1的毫秒数" class="headerlink" title="currentTimeMillens    返回当前时间距离1970-1-1的毫秒数"></a>currentTimeMillens    返回当前时间距离1970-1-1的毫秒数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(System.currentTimeMillis());</span><br></pre></td></tr></table></figure>
<h4 id="gc-运行垃圾回收机制"><a href="#gc-运行垃圾回收机制" class="headerlink" title="gc    运行垃圾回收机制"></a>gc    运行垃圾回收机制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.gc();</span><br></pre></td></tr></table></figure>
<h2 id="BigInteger-和-BigDecimal-类"><a href="#BigInteger-和-BigDecimal-类" class="headerlink" title="BigInteger 和 BigDecimal 类"></a>BigInteger 和 BigDecimal 类</h2><p>应用场景:</p>
<ol>
<li>如果一个数非常大，大到长整型都装不下的时候，就可以利用 BigInteger 或 BigDecimald进行处理存储</li>
<li>BigInteger适合保存比较大的整型</li>
<li>BigDecimal适合保存精度更高的浮点型(小数)</li>
<li>在对大数进行加减乘除的时候，需要使用其对应的的方法处理，不能直接相加。</li>
</ol>
<h3 id="BigInteger-和-BigDecimald的常用方法"><a href="#BigInteger-和-BigDecimald的常用方法" class="headerlink" title="BigInteger 和 BigDecimald的常用方法"></a>BigInteger 和 BigDecimald的常用方法</h3><h4 id="add-加"><a href="#add-加" class="headerlink" title="add    加"></a>add    加</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12312312312312312312312123123123&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12312312312312312312312123123123&quot;</span>);</span><br><span class="line">System.out.println(bigInteger1);</span><br><span class="line">bigInteger1 = bigInteger1.add(bigInteger2);</span><br><span class="line">System.out.println(bigInteger1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">12312312312312312312312123123123</span></span><br><span class="line"><span class="comment">24624624624624624624624246246246</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="subtract-减"><a href="#subtract-减" class="headerlink" title="subtract    减"></a>subtract    减</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;24624624624624624624624246246246&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12312312312312312312312123123123&quot;</span>);</span><br><span class="line">System.out.println(bigInteger1);</span><br><span class="line">bigInteger1 = bigInteger1.subtract(bigInteger2);</span><br><span class="line">System.out.println(bigInteger1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">24624624624624624624624246246246</span></span><br><span class="line"><span class="comment">12312312312312312312312123123123</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="multiply-乘"><a href="#multiply-乘" class="headerlink" title="multiply    乘"></a>multiply    乘</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12312312312312312312312123123123&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12312312312312312312312123123123&quot;</span>);</span><br><span class="line">System.out.println(bigInteger1);</span><br><span class="line">bigInteger1 = bigInteger1.multiply(bigInteger2);</span><br><span class="line">System.out.println(bigInteger1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">12312312312312312312312123123123</span></span><br><span class="line"><span class="comment">151593034475917358800237024411796154713271830424740055417273129</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="divide-除"><a href="#divide-除" class="headerlink" title="divide    除"></a>divide    除</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;151593034475917358800237024411796154713271830424740055417273129&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12312312312312312312312123123123&quot;</span>);</span><br><span class="line">System.out.println(bigInteger1);</span><br><span class="line">bigInteger1 = bigInteger1.divide(bigInteger2);</span><br><span class="line">System.out.println(bigInteger1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">151593034475917358800237024411796154713271830424740055417273129</span></span><br><span class="line"><span class="comment">12312312312312312312312123123123</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="第一代日期类-Date-java-util-Date"><a href="#第一代日期类-Date-java-util-Date" class="headerlink" title="第一代日期类 Date (java.util.Date)"></a>第一代日期类 Date (java.util.Date)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">精确到毫秒，代表特定的瞬间</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">//获取当前系统时间，即从1970年1月1日到现在经过了多少毫秒</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前日期=&quot;</span> + d1);<span class="comment">//默认输出的日期格式为英文状态的星期 月份 天 时间 年份。即Sat May 28 17:21:19 CST 2022</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">9234567</span>); <span class="comment">//通过指定毫秒数得到时间</span></span><br><span class="line">System.out.println(<span class="string">&quot;d2=&quot;</span> + d2); <span class="comment">//显示通过毫秒数创建的日期</span></span><br></pre></td></tr></table></figure>
<h4 id="SimpleDateFormat-格式化和解析日期"><a href="#SimpleDateFormat-格式化和解析日期" class="headerlink" title="SimpleDateFormat 格式化和解析日期"></a>SimpleDateFormat 格式化和解析日期</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">//获取当前系统时间</span></span><br><span class="line">System.out.println(d1);<span class="comment">//因为默认的格式不便于读写，可以通过SimpleDateForma类对Date对象进行格式化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个SimpleDateFormat对象，可以指定相应的格式。如年月日时分秒星期。</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">SDF</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss E a&quot;</span>);</span><br><span class="line">System.out.println(SDF.format(d1));<span class="comment">//格式化后输出当前的日期，2022年05月28日 18:03:01 周六 下午</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2022年05月28日 05:30:02 周六</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>字母</th>
<th>日期或时间元素</th>
<th>表示</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>G</td>
<td>Era标志符</td>
<td>Text</td>
<td>AD</td>
</tr>
<tr>
<td>y</td>
<td>年</td>
<td>Year</td>
<td>1996；96（四位&#x2F;两位）</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
<td>Month</td>
<td>July；Jul；07</td>
</tr>
<tr>
<td>w</td>
<td>一年中的第几周</td>
<td>Number</td>
<td>27</td>
</tr>
<tr>
<td>W</td>
<td>一个月中的第几周</td>
<td>Number</td>
<td>2</td>
</tr>
<tr>
<td>D</td>
<td>一年中的第几天</td>
<td>Number</td>
<td>189</td>
</tr>
<tr>
<td>d</td>
<td>一个月中的第几天</td>
<td>Number</td>
<td>10</td>
</tr>
<tr>
<td>F</td>
<td>一个月中的第几个星期</td>
<td>Number</td>
<td>2</td>
</tr>
<tr>
<td>E</td>
<td>星期几</td>
<td>Text</td>
<td>周六</td>
</tr>
<tr>
<td>a</td>
<td>am&#x2F;pm标记</td>
<td>Text</td>
<td>PM；下午</td>
</tr>
<tr>
<td>H</td>
<td>小时（0-23）</td>
<td>Number</td>
<td>0</td>
</tr>
<tr>
<td>k</td>
<td>小时（1-24）</td>
<td>Number</td>
<td>24</td>
</tr>
<tr>
<td>K</td>
<td>am&#x2F;pm中的小时（0-11）</td>
<td>Number</td>
<td>0</td>
</tr>
<tr>
<td>h</td>
<td>am&#x2F;pm中的小时（1-12）</td>
<td>Number</td>
<td>12</td>
</tr>
<tr>
<td>m</td>
<td>分钟</td>
<td>Number</td>
<td>30</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
<td>Number</td>
<td>55</td>
</tr>
<tr>
<td>S</td>
<td>毫秒</td>
<td>Number</td>
<td>998</td>
</tr>
<tr>
<td>z</td>
<td>时区</td>
<td>Genera1 time zone</td>
<td>Pacific Standard Time; PST; GMT-08:00</td>
</tr>
<tr>
<td>Z</td>
<td>时区</td>
<td>RFC 822 time zone</td>
<td>-0800</td>
</tr>
</tbody></table>
<h3 id="第二代日期类，主要就是Calendar类-日历-。"><a href="#第二代日期类，主要就是Calendar类-日历-。" class="headerlink" title="第二代日期类，主要就是Calendar类(日历)。"></a>第二代日期类，主要就是Calendar类(日历)。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Calendar类是一个抽象类，它为特定瞬间与组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。</span><br></pre></td></tr></table></figure>

<h4 id="Calendar的说明"><a href="#Calendar的说明" class="headerlink" title="Calendar的说明"></a>Calendar的说明</h4><ol>
<li><p>Calendar 是一个抽象类， 并且构造器是 private，如果需要创建对象，需要通过 getInstance() 来获取实例；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br></pre></td></tr></table></figure></li>
<li><p>提供大量的方法和字段，如果需要获取某个字段，可以参照如下格式；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">c.get(Calendar.字段名);</span><br></pre></td></tr></table></figure></li>
<li><p>Calendar 没有提供对应的格式化的类，因此需要自己组合来输出（灵活）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">System.out.println(<span class="string">&quot;年：&quot;</span>+c.get(Calendar.YEAR));</span><br><span class="line">System.out.println(<span class="string">&quot;月：&quot;</span>+(c.get(Calendar.MONTH)+<span class="number">1</span>));<span class="comment">//因为月是从0开始编号的</span></span><br><span class="line">System.out.println(<span class="string">&quot;日：&quot;</span>+c.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(<span class="string">&quot;时：&quot;</span>+c.get(Calendar.HOUR));</span><br><span class="line">System.out.println(<span class="string">&quot;分：&quot;</span>+c.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(<span class="string">&quot;秒：&quot;</span>+c.get(Calendar.SECOND));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">年：2022</span></span><br><span class="line"><span class="comment">月：5</span></span><br><span class="line"><span class="comment">日：28</span></span><br><span class="line"><span class="comment">时：7</span></span><br><span class="line"><span class="comment">分：57</span></span><br><span class="line"><span class="comment">秒：43</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR &#x3D;&#x3D;改成&#x3D;&gt; Calendar.HOUR_OF_DAY</p>
</li>
</ol>
<h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JDK 1.0中包含了一个java.util.Date类,但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar也存在问题是:</span><br></pre></td></tr></table></figure>

<ol>
<li>可变性:像日期和时间这样的类应该是不可变的。</li>
<li>偏移性: Date中的年份是从1900开始的， 而月份都从0开始。</li>
<li>格式化:格式化只对Date有用，Calendar则不行。</li>
<li>此外，它们也不是线程安全的;不能处理闰秒等(每隔2天，多出1s)。</li>
</ol>
<p>因此，在<strong>JDK8</strong>引入了新的类：</p>
<p>LocalDate(日期&#x2F;年月日)、LocalTime(时间&#x2F;时分秒)、LocalDateTime(日期时间&#x2F;年月日时分秒)</p>
<p>LocalDate只包含日期，可以获取日期字段<br>LocalTime只包含时间，可以获取时间字段<br>LocalDateTime包含日期+时间，可以获取日期和时间字段</p>
<h4 id="LocalDateTime的常用方法以及通过DateTimeFormatter格式化输出"><a href="#LocalDateTime的常用方法以及通过DateTimeFormatter格式化输出" class="headerlink" title="LocalDateTime的常用方法以及通过DateTimeFormatter格式化输出"></a>LocalDateTime的常用方法以及通过DateTimeFormatter格式化输出</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、使用now返回当前的日期时间，返回值是一个LocalDateTime的对象</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();<span class="comment">//LocalDate和LocalTime也有now方法，可以分别获取当前的日期和时间</span></span><br><span class="line">System.out.println(ldt);<span class="comment">//2022-05-28T20:11:25.378881600</span></span><br><span class="line"><span class="comment">//2、单独提取现在的年月日时分秒</span></span><br><span class="line">System.out.println(<span class="string">&quot;年：&quot;</span>+ldt.getYear());</span><br><span class="line">System.out.println(<span class="string">&quot;月：&quot;</span>+ldt.getMonth());</span><br><span class="line">System.out.println(<span class="string">&quot;日：&quot;</span>+ldt.getDayOfMonth());</span><br><span class="line">System.out.println(<span class="string">&quot;时：&quot;</span>+ldt.getHour());</span><br><span class="line">System.out.println(<span class="string">&quot;分：&quot;</span>+ldt.getMinute());</span><br><span class="line">System.out.println(<span class="string">&quot;秒：&quot;</span>+ldt.getSecond());</span><br><span class="line"><span class="comment">//3、格式化显示：依靠DateTimeFormatter。整个过程类似于SimpleDateFormat,但还有更多的功能。具体见手册中DateTimeFormatter部分</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(dtf.format(LocalDateTime.now()));</span><br></pre></td></tr></table></figure>
<h4 id="Instant-时间戳"><a href="#Instant-时间戳" class="headerlink" title="Instant 时间戳"></a>Instant 时间戳</h4><p>类似于Date，提供了一系列和Date类转换的方式：</p>
<h5 id="获取当前的时间戳"><a href="#获取当前的时间戳" class="headerlink" title="获取当前的时间戳"></a>获取当前的时间戳</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();<span class="comment">//利用Instant类的now方法（静态）获取当前的时间戳</span></span><br><span class="line">System.out.println(now);<span class="comment">//2022-05-28T12:32:09.611215Z</span></span><br></pre></td></tr></table></figure>
<h5 id="Instant-转-Date"><a href="#Instant-转-Date" class="headerlink" title="Instant 转 Date"></a>Instant 转 Date</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(instant);</span><br></pre></td></tr></table></figure>
<h5 id="Date-转-Instant"><a href="#Date-转-Instant" class="headerlink" title="Date 转 Instant:"></a>Date 转 Instant:</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> date.tolnstant();</span><br></pre></td></tr></table></figure>
<p>案例演示:<br>Instant now &#x3D; Instant. now0;<br>System. out.println(now);<br>Date date &#x3D; Date. from(now);<br>Instant instant &#x3D; date.tolnstant();</p>
<h4 id="常用的LocalDateTime方法"><a href="#常用的LocalDateTime方法" class="headerlink" title="常用的LocalDateTime方法"></a>常用的LocalDateTime方法</h4><p>plus  过多少</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合解决了数组的一些局限性，比如：</p>
<ol>
<li>长度开始时必须指定，而且一旦指定，不能更改；</li>
<li>保存的必须为同类型的元素；</li>
<li>使用数组进行增加&#x2F;删除元素比较麻烦；</li>
</ol>
<h2 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a>集合的特点</h2><ol>
<li>可以动态保存任意多个对象（不限类型），使用比较方便；</li>
<li>提供了一系列方便的操作对象的方法: add、remove. set. get（增删改查）等；</li>
<li>使用集合添加,删除新元素简洁明了；</li>
</ol>
<h2 id="集合的框架体系"><a href="#集合的框架体系" class="headerlink" title="集合的框架体系"></a>集合的框架体系</h2><p>集合主要分为两组，根据实现的接口不同分别是单列集合和双列集合，他们分别存储了一个元素或一个具有两个元素的键值对。</p>
<p>其中的单列集合Collection接口继承了Iterator类</p>
<p><img src="/./Image/Other/image-20220606164037696.png" alt="image-20220606164037696"></p>
<p><img src="/./Image/Other/image-20220606164150235.png" alt="image-20220606164150235"></p>
<h2 id="实现了Collection-接口（单列）的子类的特点"><a href="#实现了Collection-接口（单列）的子类的特点" class="headerlink" title="实现了Collection 接口（单列）的子类的特点"></a>实现了Collection 接口（单列）的子类的特点</h2><ol>
<li>collection实现子类可以存放多个元素，每个元素可以是0bject；</li>
<li>有些Collection的实现类，可以存放重复的元素，有些不可以；</li>
<li>有些Collection的实现类，有些是有序的(List，即存入的顺序和读取的顺序一致),有些不是有序(Set，即存入顺序和读出的顺序并不相同)；</li>
<li>Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的；</li>
</ol>
<h3 id="Collection-接口的常用方法-以ArrayList进行演示"><a href="#Collection-接口的常用方法-以ArrayList进行演示" class="headerlink" title="Collection 接口的常用方法(以ArrayList进行演示)"></a>Collection 接口的常用方法(以ArrayList进行演示)</h3><ol start="0">
<li><p>创建集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//创建一个ArrayList集合，用List接口进行接收，本段演示均基于这个集合</span></span><br></pre></td></tr></table></figure></li>
<li><p>add:添加单个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);<span class="comment">//只要是基于Object的对象都可以放入，换句话说就是可以放入所有的对象</span></span><br><span class="line">list.add(<span class="number">10</span>);<span class="comment">//放入基本数据类型会自动装箱成为一个对应包装类的对象</span></span><br><span class="line">list.add(<span class="literal">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list = &quot;</span> + list);<span class="comment">//list = [Hello, 10, true]</span></span><br></pre></td></tr></table></figure></li>
<li><p>remove:删除指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String)list.remove(<span class="number">0</span>);<span class="comment">//可以删除指定第几个（从0起），如果使用索引删除则返回被删除的对象</span></span><br><span class="line">System.out.println(s);<span class="comment">//Hello</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>));<span class="comment">//如果删除的是指定的对象的话，返回的就是是否删除成功</span></span><br><span class="line">System.out.println(b);<span class="comment">//true</span></span><br><span class="line">b = list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">11</span>));<span class="comment">//删除一个不存在的对象</span></span><br><span class="line">System.out.println(b);<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;list = &quot;</span> + list);<span class="comment">//list = [true]</span></span><br></pre></td></tr></table></figure></li>
<li><p>contains:查找元素是否存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (list.contains(<span class="literal">true</span>)) &#123;<span class="comment">//查找list里面是否存在一个true的对象，返回值为布尔型</span></span><br><span class="line">    System.out.println(<span class="string">&quot;存在&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (list.contains(<span class="literal">false</span>)) &#123;<span class="comment">//查找list里面是否存在一个true的对象，返回值为布尔型</span></span><br><span class="line">    System.out.println(<span class="string">&quot;存在&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果：</span></span><br><span class="line"><span class="comment">//存在</span></span><br><span class="line"><span class="comment">//不存在</span></span><br></pre></td></tr></table></figure></li>
<li><p>size:获取元素个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(list.size());<span class="comment">//获取当前list的个数，并输出出来，结果是1</span></span><br></pre></td></tr></table></figure></li>
<li><p>isEmpty:判断是否为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;list集合是空的吗 &quot;</span> + list.isEmpty());<span class="comment">//判断集合是否为空//list集合是空的吗 false</span></span><br></pre></td></tr></table></figure></li>
<li><p>clear:清空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.clear();<span class="comment">//清空整个集合的元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;list集合是空的吗 &quot;</span> + list.isEmpty());<span class="comment">//然后再判断一下集合是否为空//list集合是空的吗 true</span></span><br></pre></td></tr></table></figure></li>
<li><p>addAll:添加多个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//临时创建一个集合并存入一些元素</span></span><br><span class="line">arrayList.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;hurriedlu&quot;</span>);</span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">list.addAll(arrayList);<span class="comment">//只要是实现了Collection接口的对象都可以被添加进来。</span></span><br><span class="line">System.out.println(<span class="string">&quot;list = &quot;</span> + list);<span class="comment">//list = [hello, hurriedlu, 100]</span></span><br></pre></td></tr></table></figure></li>
<li><p>containsAll:查找(判断)多个元素是否都存在，只要有一个元素不存在就返回false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断arrayList中所有的元素是否都存在，这个arrayList可以是任何实现了Collection接口的对象。</span></span><br><span class="line">System.out.println(list.containsAll(arrayList));<span class="comment">//true</span></span><br><span class="line">list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>));<span class="comment">//删除掉一个元素再判断</span></span><br><span class="line">System.out.println(list.containsAll(arrayList));<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
<li><p>removeAll：删除多个元素。只要有一个被删掉就返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.add(<span class="string">&quot;hurriedlu&quot;</span>);<span class="comment">//添加一个存在的</span></span><br><span class="line">list.add(<span class="string">&quot;hurr&quot;</span>);<span class="comment">//添加一个之前不存在的</span></span><br><span class="line"><span class="comment">// 删除和arrayList有关的元素，并输出一下结果.</span></span><br><span class="line">System.out.println(list.removeAll(arrayList));<span class="comment">//true</span></span><br><span class="line"><span class="comment">//看一下剩余的对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;list = &quot;</span> + list);<span class="comment">//list = [hurr]</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chaoqijiang.github.io">棨</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chaoqijiang.github.io/2024/02/29/Java%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">https://chaoqijiang.github.io/2024/02/29/Java基础教程/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://chaoqijiang.github.io" target="_blank">柊</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/protected/">protected</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">基础教程</a></div><div class="post-share"><div class="social-share" data-image="/Image/avatar.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/02/28/HTTP%20%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%97%E8%A1%A8/" title="HTTP 状态码列表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">HTTP 状态码列表</div></div><div class="info-2"><div class="info-item-1">HTTP 状态码列表</div></div></div></a><a class="pagination-related" href="/2024/03/12/%E6%B6%88%E9%99%A4B%E7%AB%99%E5%B9%BF%E5%91%8A%E5%B1%8F%E8%94%BD%E6%8F%92%E4%BB%B6%E7%9A%84%E6%8F%90%E7%A4%BA%E4%BF%A1%E6%81%AF/" title="消除B站广告屏蔽插件的提示信息"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">消除B站广告屏蔽插件的提示信息</div></div><div class="info-2"><div class="info-item-1">消除B站广告屏蔽插件的提示信息</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%9F%E6%88%90/" title="AI提示词_学习笔记生成"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-08</div><div class="info-item-2">AI提示词_学习笔记生成</div></div><div class="info-2"><div class="info-item-1">AI提示词，用于引导AI生成学习笔记，根据提示的设定，对没有基础背景背景的小白生成学习笔记。</div></div></div></a><a class="pagination-related" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E8%AF%95%E9%A2%98%E7%94%9F%E6%88%90/" title="AI提示词_试题生成"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-08</div><div class="info-item-2">AI提示词_试题生成</div></div><div class="info-2"><div class="info-item-1">AI提示词，用于根据提示信息生成对应的试题，帮助学习者检验理解深度。</div></div></div></a><a class="pagination-related" href="/2025/10/08/Golang_swag/" title="Golang swag 库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-08</div><div class="info-item-2">Golang swag 库</div></div><div class="info-2"><div class="info-item-1">Go swag 从入门到实践，带你一步步掌握如何自动生成 API 文档。从安装、使用注解到理解其工作原理，再到常见问题的解决，让你轻松应对团队协作中的文档需求。</div></div></div></a><a class="pagination-related" href="/2024/04/22/Office%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/" title="Office操作指南"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-22</div><div class="info-item-2">Office操作指南</div></div><div class="info-2"><div class="info-item-1">Office操作指南</div></div></div></a><a class="pagination-related" href="/2025/10/06/Golang_validator/" title="Golang validator 库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-06</div><div class="info-item-2">Golang validator 库</div></div><div class="info-2"><div class="info-item-1">主要讲解如何在Go中使用validator库进行数据验证。通过一系列章节，你将学会如何使用validator库来确保你的数据符合预期。从基本的验证规则到自定义的验证函数，再到处理错误信息的高级技巧，本教程将带你一步步深入学习。validator 是一个非常强大的库，它可以帮助你确保你的数据在进入程序之前就已经是干净、合规的。让我们一起开始这段学习之旅吧！</div></div></div></a><a class="pagination-related" href="/2024/02/28/HTTP%20%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%97%E8%A1%A8/" title="HTTP 状态码列表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-28</div><div class="info-item-2">HTTP 状态码列表</div></div><div class="info-2"><div class="info-item-1">HTTP 状态码列表</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/Image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">棨</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:chaoqijiang@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">Java概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.1.</span> <span class="toc-text">Java技术体系平台</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-SE%EF%BC%88Java-Standard-Edition%EF%BC%89%EF%BC%9A%E6%A0%87%E5%87%86%E7%89%88"><span class="toc-number">1.1.1.</span> <span class="toc-text">Java SE（Java Standard Edition）：标准版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-EE%EF%BC%88Java-Enterprise-Edition%EF%BC%89%EF%BC%9A%E4%BC%81%E4%B8%9A%E7%89%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">Java EE（Java Enterprise Edition）：企业版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-ME%EF%BC%88Java-Micro-Edition%EF%BC%89%EF%BC%9A%E5%B0%8F%E5%9E%8B%E7%89%88"><span class="toc-number">1.1.3.</span> <span class="toc-text">Java ME（Java Micro Edition）：小型版</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E9%87%8D%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">Java 重要特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%8F%8A%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">Java的运行机制及运行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-Java%E8%99%9A%E6%8B%9F%E6%9C%BA-Java-virtual-machine"><span class="toc-number">1.3.1.</span> <span class="toc-text">JVM Java虚拟机 Java virtual machine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-Java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85-Java-Development-Kit"><span class="toc-number">1.3.2.</span> <span class="toc-text">JDK Java开发工具包 Java Development Kit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JRE-Java%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83-Java-Runtime-Environment"><span class="toc-number">1.3.3.</span> <span class="toc-text">JRE Java运行环境 Java Runtime Environment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK%E3%80%81JRE-%E5%92%8C-JVM-%E7%9A%84%E5%8C%85%E5%90%AB%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.4.</span> <span class="toc-text">JDK、JRE 和 JVM 的包含关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-number">1.3.5.</span> <span class="toc-text">Java 开发注意事项和细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">1.3.6.</span> <span class="toc-text">Java中常用的转义字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E6%B3%A8%E9%87%8A%EF%BC%88comment%EF%BC%89"><span class="toc-number">1.3.7.</span> <span class="toc-text">Java注释（comment）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84%E6%B3%A8%E9%87%8A%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">Java 中的注释类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">使用细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">1.3.7.3.</span> <span class="toc-text">文档注释</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">1.3.7.3.1.</span> <span class="toc-text">生成文档注释</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83"><span class="toc-number">1.3.8.</span> <span class="toc-text">Java 代码规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84"><span class="toc-number">1.3.9.</span> <span class="toc-text">路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">1.3.9.1.</span> <span class="toc-text">相对路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">1.3.9.2.</span> <span class="toc-text">绝对路径</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E4%B8%8B%E7%AE%80%E5%8D%95%E7%9A%84DOS%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.10.</span> <span class="toc-text">Windows下简单的DOS命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">Java中的变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-1"><span class="toc-number">2.1.1.</span> <span class="toc-text">使用细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.2.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">自动类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8EString%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.</span> <span class="toc-text">基本数据类型与String类型的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%ACString"><span class="toc-number">2.3.1.</span> <span class="toc-text">基本数据类型转String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E8%BD%AC%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">String转基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A0%81%E7%AE%80%E4%BB%8B"><span class="toc-number">2.4.</span> <span class="toc-text">Java中常用编码简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ASCII%E7%A0%81"><span class="toc-number">2.4.1.</span> <span class="toc-text">ASCII码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unicode-%E7%BC%96%E7%A0%81"><span class="toc-number">2.4.2.</span> <span class="toc-text">Unicode 编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UTF-8%E7%BC%96%E7%A0%81"><span class="toc-number">2.4.3.</span> <span class="toc-text">UTF-8编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E5%8A%A0%E5%8F%B7"><span class="toc-number">2.5.</span> <span class="toc-text">Java中的加号</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof"><span class="toc-number">3.1.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E5%91%BD%E5%90%8D"><span class="toc-number">3.2.</span> <span class="toc-text">标识符的命名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E6%A6%82%E5%BF%B5"><span class="toc-number">3.2.1.</span> <span class="toc-text">标识符概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99-%E5%BF%85%E9%A1%BB%E9%81%B5%E5%AE%88-%E4%B8%8Ec-%E7%9B%B8%E5%90%8C"><span class="toc-number">3.2.2.</span> <span class="toc-text">标识符的命名规则(必须遵守)与c++相同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">3.2.3.</span> <span class="toc-text">标识符命名规范</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">3.3.</span> <span class="toc-text">Java中的位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.3.1.</span> <span class="toc-text">&amp;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">|</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-2"><span class="toc-number">3.3.3.</span> <span class="toc-text">^</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-3"><span class="toc-number">3.3.4.</span> <span class="toc-text">~</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-4"><span class="toc-number">3.3.5.</span> <span class="toc-text">&gt;&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-5"><span class="toc-number">3.3.6.</span> <span class="toc-text">&lt;&lt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-6"><span class="toc-number">3.3.7.</span> <span class="toc-text">&gt;&gt;&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%8C%E6%B2%A1%E6%9C%89%E9%80%BB%E8%BE%91%E5%B7%A6%E7%A7%BB%EF%BC%81%EF%BC%81%EF%BC%81"><span class="toc-number">3.3.8.</span> <span class="toc-text">注意，没有逻辑左移！！！</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.4.</span> <span class="toc-text">关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A"><span class="toc-number">3.4.1.</span> <span class="toc-text">用于定义数据类型的关键字：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%80%BC%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.4.2.</span> <span class="toc-text">用于定义数据类型值的关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%AE%9A%E4%B9%89%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.4.3.</span> <span class="toc-text">用于定义流程控制的关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%AE%9A%E4%B9%89%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.4.4.</span> <span class="toc-text">用于定义访问权限修饰符的关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E5%8F%98%E9%87%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.4.5.</span> <span class="toc-text">定义类、函数、变量修饰符的关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.4.6.</span> <span class="toc-text">定义类与类之间关系的关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%BB%BA%E7%AB%8B%E5%AE%9E%E4%BE%8B%E5%8F%8A%E5%BC%95%E7%94%A8%E5%AE%9E%E4%BE%8B%E3%80%81%E5%88%A4%E6%96%AD%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.4.7.</span> <span class="toc-text">用于建立实例及引用实例、判断实例的关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.4.8.</span> <span class="toc-text">用于异常处理的关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%8C%85%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.4.9.</span> <span class="toc-text">用于包的关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.4.10.</span> <span class="toc-text">其他修饰符关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-number">3.5.</span> <span class="toc-text">保留字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.6.</span> <span class="toc-text">键盘输入语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE"><span class="toc-number">4.</span> <span class="toc-text">数组、排序和查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.</span> <span class="toc-text">数组的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.1.</span> <span class="toc-text">一维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%85%83%E7%B4%A0"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">分配元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E8%BF%9B%E8%A1%8C%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%86%E9%85%8D%E5%85%83%E7%B4%A0"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">同时进行声明和分配元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.2.</span> <span class="toc-text">二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E-1"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%85%83%E7%B4%A0-1"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">分配元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E8%BF%9B%E8%A1%8C%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%86%E9%85%8D%E5%85%83%E7%B4%A0-1"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">同时进行声明和分配元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.2.</span> <span class="toc-text">数组的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">一维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">不利用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">利用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-1"><span class="toc-number">4.2.2.</span> <span class="toc-text">二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">不利用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">利用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8Ec%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">4.2.3.</span> <span class="toc-text">与c的不同之处</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">程序控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.1.</span> <span class="toc-text">增强for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">语法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">面向对象：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">6.1.</span> <span class="toc-text">类与对象的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%88%E5%AD%97%E6%AE%B5%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">属性、成员变量（字段）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.2.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">6.2.2.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.3.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.3.1.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">6.3.2.</span> <span class="toc-text">访问对象的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">6.3.3.</span> <span class="toc-text">对象的细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">类和对象的内存分配机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java-%E5%86%85%E5%AD%98%E7%9A%84%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">6.3.3.1.1.</span> <span class="toc-text">Java 内存的结构分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%B5%81%E7%A8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90"><span class="toc-number">6.3.3.1.2.</span> <span class="toc-text">Java 创建对象流程的简单分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%9C%A8%E5%BD%A2%E5%BC%8F"><span class="toc-number">6.3.3.1.3.</span> <span class="toc-text">对象在内存中存在形式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">成员方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">6.4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">6.4.2.</span> <span class="toc-text">方法的调用机制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">6.4.3.</span> <span class="toc-text">成员方法的意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">6.4.4.</span> <span class="toc-text">成员方法的定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">6.4.5.</span> <span class="toc-text">方法的细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">6.5.</span> <span class="toc-text">可变参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.5.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">6.5.2.</span> <span class="toc-text">基本语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">6.6.</span> <span class="toc-text">作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">6.6.1.</span> <span class="toc-text">基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-number">6.6.1.1.</span> <span class="toc-text">注意事项和细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">6.7.</span> <span class="toc-text">构造方法&#x2F;构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">6.7.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">6.7.2.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-number">6.7.3.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%AF%B4%E6%98%8E"><span class="toc-number">6.7.4.</span> <span class="toc-text">具体说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-number">6.8.</span> <span class="toc-text">this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFthis"><span class="toc-number">6.8.1.</span> <span class="toc-text">什么是this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">6.8.2.</span> <span class="toc-text">this 的注意事项和使用细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">6.9.</span> <span class="toc-text">包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">6.9.1.</span> <span class="toc-text">包的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2"><span class="toc-number">6.9.2.</span> <span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%AD%98%E5%9C%A8%E4%BD%8D%E7%BD%AE"><span class="toc-number">6.9.2.1.</span> <span class="toc-text">声明存在位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">6.9.2.2.</span> <span class="toc-text">包的引入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">6.9.2.2.1.</span> <span class="toc-text">作用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">6.10.</span> <span class="toc-text">访问修饰符(访问权限)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%EF%BC%9A%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%E3%80%82"><span class="toc-number">6.11.</span> <span class="toc-text">面向对象三大特征：封装、继承、多态。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">6.12.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">6.12.1.</span> <span class="toc-text">封装的好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">6.13.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="toc-number">6.13.0.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">6.13.0.2.</span> <span class="toc-text">继承的好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">6.13.1.</span> <span class="toc-text">继承的细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">6.13.2.</span> <span class="toc-text">继承的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#super"><span class="toc-number">6.13.2.1.</span> <span class="toc-text">super</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-3"><span class="toc-number">6.13.2.1.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#super%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%BE%BF%E5%88%A9"><span class="toc-number">6.13.2.1.2.</span> <span class="toc-text">super带来的便利</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#super%E5%92%8Cthis%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">6.13.2.1.3.</span> <span class="toc-text">super和this的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99-%E8%A6%86%E7%9B%96%EF%BC%9A"><span class="toc-number">6.13.3.</span> <span class="toc-text">方法重写&#x2F;覆盖：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">6.13.3.1.</span> <span class="toc-text">方法覆盖的注意事项和使用细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">6.13.3.2.</span> <span class="toc-text">方法的重写和重载的对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">6.14.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">6.14.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%93%E7%8E%B0"><span class="toc-number">6.14.2.</span> <span class="toc-text">多态的具体体现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">6.14.3.</span> <span class="toc-text">多态的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">6.14.4.</span> <span class="toc-text">多态的向下转型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%AC%E8%B4%A8"><span class="toc-number">6.14.4.0.1.</span> <span class="toc-text">本质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-2"><span class="toc-number">6.14.4.0.2.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">6.14.4.0.3.</span> <span class="toc-text">特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%B2%A1%E6%9C%89%E9%87%8D%E5%86%99%E4%B9%8B%E8%AF%B4"><span class="toc-number">6.14.5.</span> <span class="toc-text">属性没有重写之说</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="toc-number">6.15.</span> <span class="toc-text">Java的动态绑定机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">6.16.</span> <span class="toc-text">多态的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">6.16.1.</span> <span class="toc-text">多态数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-number">6.16.2.</span> <span class="toc-text">多态参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object%E7%B1%BB%E8%AF%A6%E8%A7%A3%EF%BC%88equals%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">6.17.</span> <span class="toc-text">Object类详解（equals方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#equals%E4%B8%8E-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">6.17.1.</span> <span class="toc-text">equals与&#x3D;&#x3D;的区别：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%AD%E7%BA%A7%E9%83%A8%E5%88%86"><span class="toc-number">7.</span> <span class="toc-text">面向对象 中级部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.</span> <span class="toc-text">类变量和类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-number">7.1.1.</span> <span class="toc-text">类变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">类变量介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%EF%BC%89"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">类变量的定义（基本语法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">7.1.1.3.</span> <span class="toc-text">类变量的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-number">7.1.1.4.</span> <span class="toc-text">类变量使用时的注意事项和细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">7.1.1.5.</span> <span class="toc-text">类变量的内存布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%8F%E5%85%B8%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.1.1.6.</span> <span class="toc-text">类方法的经典使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-number">7.1.1.7.</span> <span class="toc-text">类方法使用注意事项和细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text">main方法语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-number">7.2.1.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">7.3.</span> <span class="toc-text">代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">7.3.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-4"><span class="toc-number">7.3.2.</span> <span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-3"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E3%80%81%E7%BB%86%E8%8A%82"><span class="toc-number">7.3.3.</span> <span class="toc-text">代码块的作用、注意事项、细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B"><span class="toc-number">7.3.3.1.</span> <span class="toc-text">样例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B1%EF%BC%9A%E6%97%A0%E7%BB%A7%E6%89%BF%EF%BC%8C%E4%B8%A4%E6%AC%A1%E8%B0%83%E7%94%A8%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%86%8D%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.3.3.1.1.</span> <span class="toc-text">样例1：无继承，两次调用类的静态属性，再实例化对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B2-%E6%9C%89%E7%BB%A7%E6%89%BF%EF%BC%8C%E8%BF%9E%E7%BB%AD%E8%B0%83%E7%94%A8%E4%B8%A4%E6%AC%A1%E5%AD%90%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%EF%BC%8C%E8%B0%83%E7%94%A8%E4%B8%80%E6%AC%A1%E7%BB%A7%E6%89%BF%E5%BE%97%E5%88%B0%E7%9A%84%E7%88%B6%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%86%E5%AD%90%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%88%90%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.3.3.1.2.</span> <span class="toc-text">样例2 有继承，连续调用两次子类的静态属性，调用一次继承得到的父类的属性，然后将子类实例化成对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B3-%E4%B8%89%E6%AC%A1%E7%BB%A7%E6%89%BF%E7%BB%A7%E6%89%BF%EF%BC%8C%E7%9B%B4%E6%8E%A5%E5%AF%B9%E5%AD%90%E7%B1%BB%E8%BF%9B%E8%A1%8C%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">7.3.3.1.3.</span> <span class="toc-text">样例3 三次继承继承，直接对子类进行实例化操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.4.</span> <span class="toc-text">单例设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.4.1.</span> <span class="toc-text">什么是设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.4.2.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">7.4.2.1.</span> <span class="toc-text">饿汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">7.4.2.2.</span> <span class="toc-text">懒汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%92%8C%E6%87%92%E6%B1%89%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.4.2.3.</span> <span class="toc-text">饿汉式和懒汉式的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.5.</span> <span class="toc-text">final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-5"><span class="toc-number">7.5.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-%E6%A0%B7%E4%BE%8B-%EF%BC%9A"><span class="toc-number">7.5.2.</span> <span class="toc-text">使用方法(样例)：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B1-%E8%A6%81%E6%B1%82%E6%9F%90%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%85%B6%E4%BB%96%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-number">7.5.2.1.</span> <span class="toc-text">样例1 要求某一个类不能被其他类继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B2-%E8%A6%81%E6%B1%82%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%AD%90%E7%B1%BB%E4%BF%AE%E6%94%B9%EF%BC%88%E9%87%8D%E5%86%99-%E8%A6%86%E7%9B%96%EF%BC%89"><span class="toc-number">7.5.2.2.</span> <span class="toc-text">样例2 要求类中的某个方法不能被子类修改（重写&#x2F;覆盖）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B3-%E8%A6%81%E6%B1%82%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7%E4%B8%8D%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9%EF%BC%88%E5%8D%B3%E8%AE%BE%E7%BD%AE%E6%88%90%E5%B8%B8%E9%87%8F%EF%BC%89"><span class="toc-number">7.5.2.3.</span> <span class="toc-text">样例3 要求类中的某个属性不能被修改（即设置成常量）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B4-%E8%A6%81%E6%B1%82%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7%E4%B8%8D%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9%EF%BC%8C%E4%B8%94%E8%BF%99%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%98%AF%E9%9D%99%E6%80%81%E7%9A%84"><span class="toc-number">7.5.2.4.</span> <span class="toc-text">样例4  要求类中的某个属性不能被修改，且这个属性是静态的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-number">7.5.3.</span> <span class="toc-text">final使用注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">7.6.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.6.1.</span> <span class="toc-text">抽象类的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B"><span class="toc-number">7.6.2.</span> <span class="toc-text">抽象类的使用样例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B1-abstract%E7%B1%BB%EF%BC%8C%E4%BD%86%E6%B2%A1%E6%9C%89%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">7.6.2.1.</span> <span class="toc-text">样例1 abstract类，但没有抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B2-abstract%E6%96%B9%E6%B3%95"><span class="toc-number">7.6.2.2.</span> <span class="toc-text">样例2 abstract方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-number">7.6.3.</span> <span class="toc-text">抽象类使用的注意事项和细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.6.4.</span> <span class="toc-text">抽象类最佳实践-模板设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-6"><span class="toc-number">7.6.4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%83%BD%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.6.4.2.</span> <span class="toc-text">模板设计模式能解决的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%B1%82-%E6%B1%82%E5%92%8C-%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%98%AF%E6%B1%821-2-n%E7%9A%84%E5%80%BC%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%98%AF%E6%B1%821x2xn%E7%9A%84%E5%80%BC"><span class="toc-number">7.6.4.3.</span> <span class="toc-text">案例：求 求和 过程中的时间，可以是求1+2+n的值，也可以是求1x2xn的值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.7.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-7"><span class="toc-number">7.7.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-3"><span class="toc-number">7.7.2.</span> <span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B1-%E6%8E%A5%E5%8F%A3%E5%85%A5%E9%97%A8"><span class="toc-number">7.7.2.1.</span> <span class="toc-text">样例1 接口入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B2-%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%88%E8%A2%AB%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E6%89%80%E7%BA%A6%E6%9D%9F%EF%BC%89"><span class="toc-number">7.7.2.2.</span> <span class="toc-text">样例2 一个方法实现多个接口（被多个接口所约束）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B3-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">7.7.2.3.</span> <span class="toc-text">样例3 接口的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B4-%E5%B8%A6%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E4%BD%93%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.7.2.4.</span> <span class="toc-text">样例4 带属性和方法体的接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-1"><span class="toc-number">7.7.3.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.7.4.</span> <span class="toc-text">接口与继承类的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">7.7.5.</span> <span class="toc-text">接口的多态性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%A4%9A%E6%80%81%E4%B8%AD%E7%9A%84%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-number">7.7.5.1.</span> <span class="toc-text">接口多态中的二义性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">7.8.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-8"><span class="toc-number">7.8.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">7.8.2.</span> <span class="toc-text">内部类的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">7.8.2.1.</span> <span class="toc-text">局部内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA%E4%BB%A3%E7%A0%81"><span class="toc-number">7.8.2.1.1.</span> <span class="toc-text">演示代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">7.8.2.2.</span> <span class="toc-text">匿名内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-5"><span class="toc-number">7.8.2.2.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BF%E5%90%8D%E7%B1%BB-%E6%BC%94%E7%A4%BA"><span class="toc-number">7.8.2.2.2.</span> <span class="toc-text">基于接口的匿名类 演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E5%8C%BF%E5%90%8D%E7%B1%BB"><span class="toc-number">7.8.2.2.3.</span> <span class="toc-text">基于类的匿名类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90%EF%BC%9A"><span class="toc-number">7.8.2.2.3.1.</span> <span class="toc-text">基本构成：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">7.8.2.3.</span> <span class="toc-text">内部类的细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E7%B1%BB"><span class="toc-number">7.8.3.</span> <span class="toc-text">外部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">7.8.3.1.</span> <span class="toc-text">成员内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-4"><span class="toc-number">7.8.3.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E8%AE%A8%E8%AE%BA"><span class="toc-number">7.8.3.1.2.</span> <span class="toc-text">细节讨论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">7.8.3.2.</span> <span class="toc-text">静态内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">7.8.3.2.1.</span> <span class="toc-text">特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">7.8.4.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.</span> <span class="toc-text">枚举和注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE"><span class="toc-number">8.1.</span> <span class="toc-text">自定义枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.1.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.1.2.</span> <span class="toc-text">自定义枚举的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">8.1.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#enum%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%9E%9A%E4%B8%BE"><span class="toc-number">8.2.</span> <span class="toc-text">enum关键字的枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">8.2.1.</span> <span class="toc-text">实现方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.2.2.</span> <span class="toc-text">enum枚举的注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#enum%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text">enum的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#enum%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.3.1.</span> <span class="toc-text">enum的注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%EF%BC%88Annotation%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">注解（Annotation）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-9"><span class="toc-number">9.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84-Annotation"><span class="toc-number">9.2.</span> <span class="toc-text">三个基本的 Annotation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84-Annotation-%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">9.3.</span> <span class="toc-text">基本的 Annotation 应用案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Override-%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="toc-number">9.3.1.</span> <span class="toc-text">@Override 注解的案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Override%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-number">9.3.1.1.</span> <span class="toc-text">@Override的使用说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deprecated-%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="toc-number">9.3.2.</span> <span class="toc-text">@Deprecated 注解的案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SuppressWarnings-%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="toc-number">9.3.3.</span> <span class="toc-text">@SuppressWarnings 注解的案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="toc-number">9.3.3.1.</span> <span class="toc-text">用法：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK%E7%9A%84%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.4.</span> <span class="toc-text">JDK的元注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">9.4.1.</span> <span class="toc-text">元注解的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Retention%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.4.1.1.</span> <span class="toc-text">Retention注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Target%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.4.1.2.</span> <span class="toc-text">Target注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Documented%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.4.1.3.</span> <span class="toc-text">Documented注解</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">10.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">10.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">10.2.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-catch%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">10.3.</span> <span class="toc-text">try - catch异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-6"><span class="toc-number">10.3.1.</span> <span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-1"><span class="toc-number">10.3.1.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">10.3.2.</span> <span class="toc-text">try - catch的细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%88%A9%E7%94%A8try-catch%E4%BD%BF%E7%9A%84%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84%E5%BF%85%E9%A1%BB%E6%98%AF%E6%95%B4%E6%95%B0%EF%BC%8C%E4%B8%8D%E6%98%AF%E5%B0%B1%E9%87%8D%E8%BE%93"><span class="toc-number">10.3.3.</span> <span class="toc-text">案例：利用try - catch使的用户输入的必须是整数，不是就重输</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#throws"><span class="toc-number">10.4.</span> <span class="toc-text">throws</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">10.4.1.</span> <span class="toc-text">基本介绍和使用细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">10.5.</span> <span class="toc-text">自定义异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">10.5.1.</span> <span class="toc-text">自定义异常的步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%EF%BC%9A%E8%A6%81%E6%B1%82%EF%BC%9A%E5%BD%93%E6%88%91%E4%BB%AC%E6%8E%A5%E6%94%B6Person%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E6%97%B6%EF%BC%8C%E8%A6%81%E6%B1%82%E8%8C%83%E5%9B%B4%E5%9C%A818-120%E4%B9%8B%E9%97%B4%EF%BC%8C%E5%90%A6%E5%88%99%E6%8A%9B%E5%87%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8-%E8%A6%81%E6%B1%82%E7%BB%A7%E6%89%BFRuntimeException-%E5%B9%B6%E7%BB%99%E5%87%BA%E6%8F%90%E7%A4%BA%E4%BF%A1%E6%81%AF"><span class="toc-number">10.5.1.1.</span> <span class="toc-text">样例：要求：当我们接收Person对象年龄时，要求范围在18 - 120之间，否则抛出一个自定义异常(要求继承RuntimeException)并给出提示信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.5.2.</span> <span class="toc-text">throw和throws的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">11.</span> <span class="toc-text">常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">11.1.</span> <span class="toc-text">包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.1.1.</span> <span class="toc-text">包装类与基本数据类型的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%E7%9A%84%E6%BC%94%E7%A4%BA"><span class="toc-number">11.1.2.</span> <span class="toc-text">装箱和拆箱的演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E4%B8%8EString%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.1.3.</span> <span class="toc-text">包装类型与String类型的相互转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">11.2.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">11.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-String%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">11.2.2.</span> <span class="toc-text">创建 String对象的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%88%9B%E5%BB%BA-String%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.2.2.1.</span> <span class="toc-text">两种创建 String对象的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%9A%84%E7%88%B6%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.2.3.</span> <span class="toc-text">String的父类和接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">11.2.4.</span> <span class="toc-text">String的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%AF%E5%8C%BA"><span class="toc-number">11.2.5.</span> <span class="toc-text">常见的误区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.6.</span> <span class="toc-text">String 常用的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuffer"><span class="toc-number">11.2.7.</span> <span class="toc-text">StringBuffer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuffer%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">11.2.7.1.</span> <span class="toc-text">StringBuffer的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E5%92%8C-StringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.2.7.2.</span> <span class="toc-text">String 和 StringBuffer的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuffer%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">11.2.7.3.</span> <span class="toc-text">StringBuffer的构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E5%92%8C-StringBuffer%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.2.7.4.</span> <span class="toc-text">String 和 StringBuffer相互转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#String-%E8%BD%AC-StringBuffer"><span class="toc-number">11.2.7.4.1.</span> <span class="toc-text">String 转 StringBuffer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StringBuffer-%E8%BD%AC-String"><span class="toc-number">11.2.7.4.2.</span> <span class="toc-text">StringBuffer 转 String</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuffer%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.7.5.</span> <span class="toc-text">StringBuffer的常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder"><span class="toc-number">11.2.8.</span> <span class="toc-text">StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuilder-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.8.1.</span> <span class="toc-text">StringBuilder 常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuilder%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">11.2.8.2.</span> <span class="toc-text">StringBuilder的特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E3%80%81StringBuffer-%E5%92%8C-StringBuilder%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">11.2.9.</span> <span class="toc-text">String、StringBuffer 和 StringBuilder的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E3%80%81StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">11.2.10.</span> <span class="toc-text">String、StringBuffer 和 StringBuilder 的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math%E7%B1%BB"><span class="toc-number">11.3.</span> <span class="toc-text">Math类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Math%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%9D%87%E4%B8%BA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">11.3.1.</span> <span class="toc-text">Math常用的方法（均为静态方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#abs-%E6%B1%82%E7%BB%9D%E5%AF%B9%E5%80%BC"><span class="toc-number">11.3.1.1.</span> <span class="toc-text">abs  求绝对值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pow-%E6%B1%82%E5%B9%82%EF%BC%88%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%BAdouble%EF%BC%89"><span class="toc-number">11.3.1.2.</span> <span class="toc-text">pow 求幂（返回值为double）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ceil-%E5%90%91%E4%B8%8A%E5%8F%96%E6%95%B4%EF%BC%88%E8%BF%94%E5%9B%9E%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E8%AF%A5%E5%8F%82%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B4%E6%95%B0%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BE%9D%E7%84%B6%E6%98%AFdouble%EF%BC%89"><span class="toc-number">11.3.1.3.</span> <span class="toc-text">ceil 向上取整（返回大于等于该参数的最小整数，返回值依然是double）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#floor-%E5%90%91%E4%B8%8B%E5%8F%96%E6%95%B4%EF%BC%88%E8%BF%94%E5%9B%9E%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E%E8%AF%A5%E5%8F%82%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B4%E6%95%B0%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BE%9D%E7%84%B6%E6%98%AFdouble%EF%BC%89"><span class="toc-number">11.3.1.4.</span> <span class="toc-text">floor 向下取整（返回小于等于该参数的最小整数，返回值依然是double）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#round-%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%EF%BC%88%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%BAlong%EF%BC%8C%E7%BA%A6%E7%AD%89%E4%BA%8EMath-floor-%E8%AF%A5%E5%8F%82%E6%95%B0-0-5-%EF%BC%9F%EF%BC%89"><span class="toc-number">11.3.1.5.</span> <span class="toc-text">round 四舍五入（返回值为long，约等于Math.floor(该参数+0.5)？）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sqrt-%E6%B1%82%E7%AE%97%E6%95%B0%E5%B9%B3%E6%96%B9%E6%A0%B9%EF%BC%88%E8%A6%81%E6%B1%82%E5%8F%82%E6%95%B0%E4%B8%BA%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E0%E7%9A%84%E9%9D%9E%E8%B4%9F%E6%95%B0%EF%BC%89"><span class="toc-number">11.3.1.6.</span> <span class="toc-text">sqrt 求算数平方根（要求参数为大于等于0的非负数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#random-%E6%B1%82%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%88%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E0%E5%B9%B6%E4%B8%94%E5%B0%8F%E4%BA%8E1%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%95%B0%EF%BC%89"><span class="toc-number">11.3.1.7.</span> <span class="toc-text">random 求随机数（返回一个大于等于0并且小于1之间的一个小数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#max-min-%E8%BF%94%E5%9B%9E%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">11.3.1.8.</span> <span class="toc-text">max , min 返回最大值和最小值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays"><span class="toc-number">11.4.</span> <span class="toc-text">Arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">11.4.1.</span> <span class="toc-text">Arrays的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#toString-%E4%BB%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BD%A2%E5%BC%8F%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">11.4.1.1.</span> <span class="toc-text">toString    以字符串形式返回数组中的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sort%E6%8E%92%E5%BA%8F%EF%BC%88%E5%90%8Cc-%E4%B8%80%E6%A0%B7%EF%BC%8C%E9%BB%98%E8%AE%A4%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7%EF%BC%8C%E4%B9%9F%E6%94%AF%E6%8C%81%E8%87%AA%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="toc-number">11.4.1.2.</span> <span class="toc-text">sort排序（同c++一样，默认从小到大，也支持自定义）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binarySearch-%E9%80%9A%E8%BF%87%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%9F%A5%E6%89%BE%EF%BC%8C%E8%A6%81%E6%B1%82%E5%BF%85%E9%A1%BB%E6%8E%92%E5%A5%BD%E5%BA%8F"><span class="toc-number">11.4.1.3.</span> <span class="toc-text">binarySearch    通过二分搜索法进行查找，要求必须排好序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#copyOf-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%A4%8D%E5%88%B6"><span class="toc-number">11.4.1.4.</span> <span class="toc-text">copyOf    数组元素复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fill-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%A1%AB%E5%85%85"><span class="toc-number">11.4.1.5.</span> <span class="toc-text">fill 数组元素填充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#equals-%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%B8%80-%E8%87%B4"><span class="toc-number">11.4.1.6.</span> <span class="toc-text">equals 比较两个数组元素的内容是否完全一 致</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asList-%E5%B0%86%E4%B8%80%E7%BB%84%E5%80%BC%EF%BC%8C%E8%BD%AC%E6%8D%A2%E6%88%90list"><span class="toc-number">11.4.1.7.</span> <span class="toc-text">asList 将一组值，转换成list</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%B0%86%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E7%94%A8sort%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">11.4.2.</span> <span class="toc-text">Arrays项目：将自定义类型用sort的形式进行排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System"><span class="toc-number">11.5.</span> <span class="toc-text">System</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#System%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">11.5.1.</span> <span class="toc-text">System常用的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#exit-%E9%80%80%E5%87%BA%E5%BD%93%E5%89%8D%E7%A8%8B%E5%BA%8F"><span class="toc-number">11.5.1.1.</span> <span class="toc-text">exit    退出当前程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#arraycopy-%E5%A4%8D%E5%88%B6%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%EF%BC%8C%E6%AF%94%E8%BE%83%E9%80%82%E5%90%88%E5%BA%95%E5%B1%82%E8%B0%83%E7%94%A8%EF%BC%8C%E4%B8%80%E8%88%AC%E4%BD%BF%E7%94%A8Arrays-copyOf%E5%AE%8C%E6%88%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%8D%E5%88%B6%E3%80%82"><span class="toc-number">11.5.1.2.</span> <span class="toc-text">arraycopy :复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成数组的复制。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#currentTimeMillens-%E8%BF%94%E5%9B%9E%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E8%B7%9D%E7%A6%BB1970-1-1%E7%9A%84%E6%AF%AB%E7%A7%92%E6%95%B0"><span class="toc-number">11.5.1.3.</span> <span class="toc-text">currentTimeMillens    返回当前时间距离1970-1-1的毫秒数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gc-%E8%BF%90%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">11.5.1.4.</span> <span class="toc-text">gc    运行垃圾回收机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigInteger-%E5%92%8C-BigDecimal-%E7%B1%BB"><span class="toc-number">11.6.</span> <span class="toc-text">BigInteger 和 BigDecimal 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BigInteger-%E5%92%8C-BigDecimald%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">11.6.1.</span> <span class="toc-text">BigInteger 和 BigDecimald的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#add-%E5%8A%A0"><span class="toc-number">11.6.1.1.</span> <span class="toc-text">add    加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#subtract-%E5%87%8F"><span class="toc-number">11.6.1.2.</span> <span class="toc-text">subtract    减</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#multiply-%E4%B9%98"><span class="toc-number">11.6.1.3.</span> <span class="toc-text">multiply    乘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#divide-%E9%99%A4"><span class="toc-number">11.6.1.4.</span> <span class="toc-text">divide    除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">11.7.</span> <span class="toc-text">日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB-Date-java-util-Date"><span class="toc-number">11.7.1.</span> <span class="toc-text">第一代日期类 Date (java.util.Date)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SimpleDateFormat-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%92%8C%E8%A7%A3%E6%9E%90%E6%97%A5%E6%9C%9F"><span class="toc-number">11.7.1.1.</span> <span class="toc-text">SimpleDateFormat 格式化和解析日期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB%EF%BC%8C%E4%B8%BB%E8%A6%81%E5%B0%B1%E6%98%AFCalendar%E7%B1%BB-%E6%97%A5%E5%8E%86-%E3%80%82"><span class="toc-number">11.7.2.</span> <span class="toc-text">第二代日期类，主要就是Calendar类(日历)。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Calendar%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">11.7.2.1.</span> <span class="toc-text">Calendar的说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">11.7.3.</span> <span class="toc-text">第三代日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalDateTime%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E9%80%9A%E8%BF%87DateTimeFormatter%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-number">11.7.3.1.</span> <span class="toc-text">LocalDateTime的常用方法以及通过DateTimeFormatter格式化输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Instant-%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-number">11.7.3.2.</span> <span class="toc-text">Instant 时间戳</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-number">11.7.3.2.1.</span> <span class="toc-text">获取当前的时间戳</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Instant-%E8%BD%AC-Date"><span class="toc-number">11.7.3.2.2.</span> <span class="toc-text">Instant 转 Date</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Date-%E8%BD%AC-Instant"><span class="toc-number">11.7.3.2.3.</span> <span class="toc-text">Date 转 Instant:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84LocalDateTime%E6%96%B9%E6%B3%95"><span class="toc-number">11.7.3.3.</span> <span class="toc-text">常用的LocalDateTime方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">12.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">12.1.</span> <span class="toc-text">集合的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB"><span class="toc-number">12.2.</span> <span class="toc-text">集合的框架体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BA%86Collection-%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%8D%95%E5%88%97%EF%BC%89%E7%9A%84%E5%AD%90%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">12.3.</span> <span class="toc-text">实现了Collection 接口（单列）的子类的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E4%BB%A5ArrayList%E8%BF%9B%E8%A1%8C%E6%BC%94%E7%A4%BA"><span class="toc-number">12.3.1.</span> <span class="toc-text">Collection 接口的常用方法(以ArrayList进行演示)</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E9%80%9A%E7%94%A8%E8%93%9D%E5%9B%BE/" title="高可用高并发后端架构通用蓝图">高可用高并发后端架构通用蓝图</a><time datetime="2025-10-08T15:42:00.000Z" title="发表于 2025-10-08 23:42:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%9F%E6%88%90/" title="AI提示词_学习笔记生成">AI提示词_学习笔记生成</a><time datetime="2025-10-08T15:15:00.000Z" title="发表于 2025-10-08 23:15:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E8%AF%95%E9%A2%98%E7%94%9F%E6%88%90/" title="AI提示词_试题生成">AI提示词_试题生成</a><time datetime="2025-10-08T15:15:00.000Z" title="发表于 2025-10-08 23:15:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/Golang_swag/" title="Golang swag 库">Golang swag 库</a><time datetime="2025-10-08T15:07:00.000Z" title="发表于 2025-10-08 23:07:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/06/Golang_validator/" title="Golang validator 库">Golang validator 库</a><time datetime="2025-10-06T15:00:00.000Z" title="发表于 2025-10-06 23:00:00">2025-10-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/Image/topImage.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By 棨</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>