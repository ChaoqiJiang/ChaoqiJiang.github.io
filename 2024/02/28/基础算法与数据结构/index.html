<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>基础算法与数据结构 | 柊</title><meta name="author" content="棨"><meta name="copyright" content="棨"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#59b9c6"><meta name="description" content="基础算法与数据结构，包括排序、查找、二分、高精度、前缀和与差分、双指针、位运算、区间合并等基础算法，以及链表、栈、队列、等基础数据结构。">
<meta property="og:type" content="article">
<meta property="og:title" content="基础算法与数据结构">
<meta property="og:url" content="https://chaoqijiang.github.io/2024/02/28/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="柊">
<meta property="og:description" content="基础算法与数据结构，包括排序、查找、二分、高精度、前缀和与差分、双指针、位运算、区间合并等基础算法，以及链表、栈、队列、等基础数据结构。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chaoqijiang.github.io/Image/avatar.png">
<meta property="article:published_time" content="2024-02-28T04:08:00.000Z">
<meta property="article:modified_time" content="2025-10-10T15:53:39.628Z">
<meta property="article:author" content="棨">
<meta property="article:tag" content="protected">
<meta property="article:tag" content="基础算法">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chaoqijiang.github.io/Image/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "基础算法与数据结构",
  "url": "https://chaoqijiang.github.io/2024/02/28/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",
  "image": "https://chaoqijiang.github.io/Image/avatar.png",
  "datePublished": "2024-02-28T04:08:00.000Z",
  "dateModified": "2025-10-10T15:53:39.628Z",
  "author": [
    {
      "@type": "Person",
      "name": "棨",
      "url": "https://chaoqijiang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chaoqijiang.github.io/2024/02/28/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#59b9c6')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 24
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":30,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#165e83","bgDark":"#507ea4","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基础算法与数据结构',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/Image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴/归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/Image/topImage.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/Image/Logo.ico" alt="Logo"><span class="site-name">柊</span></a><a class="nav-page-title" href="/"><span class="site-name">基础算法与数据结构</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴/归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">基础算法与数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-28T04:08:00.000Z" title="发表于 2024-02-28 12:08:00">2024-02-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-10T15:53:39.628Z" title="更新于 2025-10-10 23:53:39">2025-10-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">22.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>87分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="思想：基于分治。"><a href="#思想：基于分治。" class="headerlink" title="思想：基于分治。"></a>思想：基于分治。</h4><ol>
<li><p>确定分界点。在数组中随便找一个值，以划分出左右两堆数；</p>
<blockquote>
<p>常见方法</p>
<ol>
<li>直接取左边界，即q[ l ]；（边界不能是i）</li>
<li>直接取中间值，即q[ ( l + r ) &#x2F; 2 ]；</li>
<li>直接取右边界，即q[ r ]；（边界不能是j）</li>
<li>也可以直接随机一个值</li>
</ol>
</blockquote>
</li>
<li><p><strong>调整区间。使得第一步确定的分界点x左边的区间全部 ≤ x，右边区间全部 ≥ x；</strong></p>
<blockquote>
<ol>
<li>方法1，思想简单但需要额外空间。比较暴力，需要两个额外空间，但时间复杂度还好，是线性的</li>
<li>需要两个额外的数组 a[ ] , b[ ]；</li>
<li>扫描整个数组q[ l ~ r ]，若 q[ i ] &lt;&#x3D; x ，则将q [ i ] 存入a [] 数组，否则存入b[ ]数组；</li>
<li>先将数组a[ ]中的所有数据存取q[ ]，然后将数组b[ ]中的所有数据存入q[ ]；</li>
<li>方法2，时间复杂度空间复杂度都很好</li>
<li>需要两个额外的数组指针，设这两个指针为 i ， j，并将指针 i 指向数组的最左边，指针 j 指向数组的最右边。</li>
<li>判断指针 i 是否大于 x ，如果不大于，指针后移，直到找到第一个大于 x 的地方；</li>
<li>同理判断指针 j 是否小于 x ，如果小于，指针前移，直到找到第一个小于 x 的地方；</li>
<li>交换指针 i 和 j 指向空间的数据；</li>
<li>重复2 - 4步，直到指针 i j 相遇为止</li>
</ol>
</blockquote>
</li>
<li><p>递归处理左右两端，使得左右区间全部有序</p>
</li>
</ol>
<h4 id="实现代码：对数组进行排序"><a href="#实现代码：对数组进行排序" class="headerlink" title="实现代码：对数组进行排序"></a>实现代码：对数组进行排序</h4><h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> x = nums[(l + r) / <span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = r + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (nums[i] &lt; x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">while</span> (nums[j] &gt; x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(nums, l, j);</span><br><span class="line">    qsort(nums, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="C-C-："><a href="#C-C-：" class="headerlink" title="C&#x2F;C++："></a>C&#x2F;C++：</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, nums[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 快速排序，范围要求是左开右闭</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;nums&quot;&gt;要排序的数组&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;l&quot;&gt;左边界（开始迭代器）&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;r&quot;&gt;右边界（结束迭代器）&lt;/param&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)<span class="comment">//如果当左右边界相等的时候，证明已经递归到当前区域只有一个元素，也就表示当前区域已经有序了，可以直接退出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = nums[(l + r) / <span class="number">2</span>];<span class="comment">//随便选一个数当作分界点</span></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>;<span class="comment">//生成本轮循环的左边界（要求各多算一个）</span></span><br><span class="line">    <span class="type">int</span> j = r + <span class="number">1</span>;<span class="comment">//生成本轮循环的右边界（要求各多算一个）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;<span class="comment">//开始本轮循环 要求左右边界不能碰面</span></span><br><span class="line">        <span class="keyword">do</span> &#123;<span class="comment">//必须要do while,先++后判断</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (nums[i] &lt; x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;<span class="comment">//同理 先--后判断</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">while</span> (nums[j] &gt; x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)<span class="comment">//可能会有越界的行为，因此在交换前需要先判断</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">qsort</span>(nums, l, j);<span class="comment">//递归循环左边界，分界点一定要是j而不能是i</span></span><br><span class="line">    <span class="built_in">qsort</span>(nums, j + <span class="number">1</span>, r);<span class="comment">//递归循环右边界</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qsort</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> num[] = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">int</span> nums[],<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)<span class="comment">//如果当左右边界相等的时候，证明已经递归到当前区域只有一个元素，也就表示当前区域已经有序了，可以直接退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[(l + r) / <span class="number">2</span>];<span class="comment">//随便选一个数当作分界点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>;<span class="comment">//生成本轮循环的左边界（要求各多算一个）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> r + <span class="number">1</span>;<span class="comment">//生成本轮循环的右边界（要求各多算一个）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;<span class="comment">//开始本轮循环 要求左右边界不能碰面</span></span><br><span class="line">            <span class="keyword">do</span> &#123;<span class="comment">//必须要do while,先++后判断</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (nums[i] &lt; x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;<span class="comment">//同理 先--后判断</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">while</span> (nums[j] &gt; x);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)<span class="comment">//可能会有越界的行为，因此在交换前需要先判断</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        qsort(nums, l, j);<span class="comment">//递归循环左边界，分界点一定要是j而不能是i</span></span><br><span class="line">        qsort(nums, j + <span class="number">1</span>, r);<span class="comment">//递归循环右边界</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qsort(num, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(num));</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            System.out.print(num[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="思想：依然是分治"><a href="#思想：依然是分治" class="headerlink" title="思想：依然是分治"></a>思想：依然是分治</h4><p>但具体实现的方式与快排不相同</p>
<ol>
<li>确定in数。</li>
<li>递归排序左右两边</li>
<li>归并。把两个有序的数组合并成一个数组</li>
</ol>
<h4 id="实现代码：对数组进行排序-1"><a href="#实现代码：对数组进行排序-1" class="headerlink" title="实现代码：对数组进行排序"></a>实现代码：对数组进行排序</h4><h5 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_sort(q, l, mid);</span><br><span class="line">    merge_sort(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="C-C"><a href="#C-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, nums[N], tmp[N];<span class="comment">//数据长度，数据，辅助数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 归并排序</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;nums&quot;&gt;要排序的数组&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;l&quot;&gt;左边界&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;r&quot;&gt;右边界&lt;/param&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)<span class="comment">//当当前区域只有一个甚至一个元素都没有的时候，这个区域就有序了，可以退出了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;<span class="comment">//算出整个数据的中间位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始递归排序左右两边      </span></span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, l, mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始归并到辅助数组</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;<span class="comment">//存储当前进度</span></span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>;<span class="comment">//两个区域的首地址</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[j])</span><br><span class="line">            tmp[k++] = nums[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[k++] = nums[j++];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行扫尾，将剩余元素全部直接接到辅助数组的末尾</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        tmp[k++] = nums[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">        tmp[k++] = nums[j++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将辅助数组中的数据复制到原始数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) &#123;</span><br><span class="line">        nums[i] = tmp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="第K个数-第K小的数（快排-二分）"><a href="#第K个数-第K小的数（快排-二分）" class="headerlink" title="第K个数&#x2F;第K小的数（快排+二分）"></a>第K个数&#x2F;第K小的数（快排+二分）</h4><blockquote>
<h4 id="第k个数"><a href="#第k个数" class="headerlink" title="第k个数"></a>第k个数</h4><p>给定一个长度为 n 的整数数列，以及一个整数 k，请用快速选择算法求出数列从小到大排序后的第 k 个数。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 k。</p>
<p>第二行包含 n 个整数（所有整数均在 1∼10^9^ 范围内），表示整数数列。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示数列的第 k 小数。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000<br>1≤k≤n</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 4 1 5 3</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul>
<li>首先这个数是否存在比较好判断（如果k大于n，直接报错即可），并且此题目保证了k ≤ n</li>
<li>在快排的时候，每次快排完成都可以使key左边的都比key小，右边的都比key大。因此，key的位置x就是整个序列中第x小的数。</li>
<li>快排完事之后递归之前，计算一下key的位置，看是否大于de</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, k, num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKth</span><span class="params">(<span class="type">int</span> num[], <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//基础的快排部分</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span> num[l];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> key = num[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (num[i] &lt; key);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (num[j] &gt; key);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(num[i], num[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快排之后得出一个序列，key左边的都比key小，右边的都比key大。此时，key这个数的位置，就是key在序列中的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lcnt = j - l + <span class="number">1</span>;<span class="comment">//计算出key的位置。位置等于k的位置减去左边界</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= lcnt)<span class="comment">//如果要找到数在key的位置的前面，或者就是key</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findKth</span>(num, l, j, k);<span class="comment">//递归查找左边界到key这段距离</span></span><br><span class="line">    <span class="keyword">else</span><span class="comment">//否则答案的位置就在key的右侧（不包括key）。递归查找key下一个位置到右边界的区间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findKth</span>(num, j + <span class="number">1</span>, r, k - lcnt);<span class="comment">//假设要查找第7小的数，已经找到第5小的了，只需要在第六小开始的位置找出第2小的就行</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf_s</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf_s</span>(<span class="string">&quot;%d&quot;</span>, &amp;num[i]);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">findKth</span>(num, <span class="number">0</span>, n - <span class="number">1</span>, k) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>虽然快排和归并都是nlgn级别的复杂度，但这是在宏观上的量级，在使用的时候，一般来说快排比归并快了两到三倍。</li>
</ol>
<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><h4 id="思想：本质是找边界"><a href="#思想：本质是找边界" class="headerlink" title="思想：本质是找边界"></a>思想：本质是找边界</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个区间，在这个区间上定义了某种性质，使得这个性质在整个范围的右半边是满足的，在左半边是不满足的；（即利用这个性质可以将整个范围一分为二）</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">![image-20220628124834662](./Image/Other/image-20220628124834662.png)</span><br><span class="line"></span><br><span class="line">查找边界1：</span><br><span class="line"></span><br><span class="line">1. 首先还是计算出mid的值，mid = (l+r) / 2;</span><br><span class="line">2. 检查获取到的mid的值 if ( check( mid )  ) 看是否成立</span><br><span class="line">   1. 若为true，则表示mid的位置可能是答案，因此范围缩小至 [ mid , r ]；因此更新方式为  l = mid ;</span><br><span class="line">   2. 若为false，则表示在答案在 l 到 mid - 1 （因为是整数二分，数是离散的）; 因此更新方式为 r = mid -1;</span><br><span class="line"></span><br><span class="line">查找边界2：</span><br><span class="line"></span><br><span class="line">1. 首先还是计算出mid的值，mid = (l+r) / 2;</span><br><span class="line">2. 检查获取到的mid的值 if ( check( mid )  ) 看是否成立</span><br><span class="line">   1. 若为true，则表示mid的位置可能是答案，因此范围缩小至 [ l , mid ]；因此更新方式为  r = mid ;</span><br><span class="line">   2. 若为false，则表示在答案在 [ mid+1 , r ]  ; 因此更新方式为 l = mid + 1;</span><br><span class="line"></span><br><span class="line">简单的说就是根据查找边界的不同，mid的更新是下取整还是上取整。</span><br><span class="line"></span><br><span class="line">#### 模板</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">整数二分算法模板 —— 模板题 AcWing 789. 数的范围</span><br><span class="line">bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质</span><br><span class="line"></span><br><span class="line">//前边界</span><br><span class="line">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="line">int bsearch_1(int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">    while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r &gt;&gt; 1;</span><br><span class="line">        if (check(mid)) r = mid;    // check()判断mid是否满足性质</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;//如果保证必然有解，可以输出，否则需要判断一下当前的l的位置是否是要找的数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后边界</span><br><span class="line">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="line">int bsearch_2(int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">    while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r + 1 &gt;&gt; 1;//对mid进行上取整</span><br><span class="line">        if (check(mid)) l = mid;</span><br><span class="line">        else r = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="模板的使用说明"><a href="#模板的使用说明" class="headerlink" title="模板的使用说明"></a>模板的使用说明</h5><ol>
<li>如果说要查找的数是唯一的，或者随便一个等值的，则两个模板随便一个就行。</li>
<li>如果需要查找的数（或者相关的数据）是这些个等值的数列的第一个，则需要用第一个模板（mid下取整），反之需要用第二个模板。</li>
</ol>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><blockquote>
<h4 id="数的范围"><a href="#数的范围" class="headerlink" title="数的范围"></a>数的范围</h4><p>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。</p>
<p>对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。</p>
<p>如果数组中不存在该元素，则返回 <code>-1</code>。</p>
<h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n 和 q，表示数组长度和询问个数。</p>
<p>第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。</p>
<p>接下来 q 行，每行包含一个整数 k，表示一个询问元素。</p>
<h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p>
<p>如果数组中不存在该元素，则返回 <code>-1</code>。</p>
<h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000<br>1≤q≤10000<br>1≤k≤10000</p>
<h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 3 3 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">5 5</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure></blockquote>
<h5 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;<span class="comment">//数据量</span></span><br><span class="line"><span class="type">int</span> n, m, x, num[N];<span class="comment">//升序排序序列的长度，询问次数，询问的元素的值，存储序列的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 基于循环的二分查找，用于查找这个区间的左边界。</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;l&quot;&gt;要查找的序列的起始位置&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;r&quot;&gt;要查找的序列的结束位置（长度）&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;x&quot;&gt;要查找的值&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;查找到的下标&lt;/returns&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)<span class="comment">//只要左边界与右边界不相等，就证明这个范围内的数不止一个，可以继续循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;<span class="comment">//计算mid，下取整</span></span><br><span class="line">        <span class="keyword">if</span> (num[mid] &gt;= x)<span class="comment">//如果mid的值大于等于查找的值，就证明答案可能在左边界到mid的位置</span></span><br><span class="line">            r = mid;<span class="comment">//缩小右边界，因为mid的位置可能是答案，所以r = mid</span></span><br><span class="line">        <span class="keyword">else</span><span class="comment">//如果不满足条件，就证明答案在mid的右边，并且mid的位置不会是答案</span></span><br><span class="line">            l = mid + <span class="number">1</span>;<span class="comment">//因此缩小左边界，到全部都是可能是答案的新的左边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num[l] == x)<span class="comment">//循环完事，检查一下找到的数据是否满足要求</span></span><br><span class="line">        <span class="keyword">return</span> l;<span class="comment">//满足，就输出要求的下标</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不满足，证明没有找到，直接输出-1.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 基于递归的二分查找，用于查找这个区间的左边界</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;l&quot;&gt;要查找的序列的起始位置&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;r&quot;&gt;要查找的序列的结束位置（长度）&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;x&quot;&gt;要查找的值&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;查找到的下标&lt;/returns&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find3</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">if</span> (num[l] == x)</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num[mid] &gt;= x)</span><br><span class="line">        <span class="built_in">find3</span>(l, mid, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">find3</span>(mid + <span class="number">1</span>, r, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 基于循环的二分查找，用于查找这个区间的右边界。</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;l&quot;&gt;要查找的序列的起始位置&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;r&quot;&gt;要查找的序列的结束位置（长度）&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;x&quot;&gt;要查找的值&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;查找到的下标&lt;/returns&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;<span class="comment">//查找右边界的时候需要上取整</span></span><br><span class="line">        <span class="keyword">if</span> (num[mid] &lt;= x)<span class="comment">//查找右边界，如果说答案大于等于mid的位置，就收缩左边界到mid</span></span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;<span class="comment">//否则就证明答案在小于mid的位置，收缩右边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num[l] == x)</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 基于循环的循环查找，用于查找这个区间的右边界。</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;l&quot;&gt;要查找的序列的起始位置&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;r&quot;&gt;要查找的序列的结束位置（长度）&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;x&quot;&gt;要查找的值&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;查找到的下标&lt;/returns&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find4</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">if</span> (num[l] == x)</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (num[mid] &lt;= x)</span><br><span class="line">        <span class="built_in">find4</span>(mid, r, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">find4</span>(l, mid - <span class="number">1</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf_s</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<span class="comment">//获取序列的长度和询问的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//读入序列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf_s</span>(<span class="string">&quot;%d&quot;</span>, &amp;num[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)<span class="comment">//开始询问</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf_s</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);<span class="comment">//读入询问的数值</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">find3</span>(<span class="number">0</span>, n - <span class="number">1</span>, x) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">find4</span>(<span class="number">0</span>, n - <span class="number">1</span>, x) &lt;&lt; endl;<span class="comment">//调用函数运算并直接输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="浮点二分"><a href="#浮点二分" class="headerlink" title="浮点二分"></a>浮点二分</h3><p>同上面的整数二分类似，而且更加简单，因为不用考虑边界问题。如下例题：利用二分的方法求出一个数的三次方根。</p>
<p>为什么可行：</p>
<ul>
<li>首先一个数的三次方根是必然存在的</li>
<li>其次三次方是具有单调性的（偶数次方也可以二分，二分的左边界是0）</li>
</ul>
<blockquote>
<h4 id="数的三次方根"><a href="#数的三次方根" class="headerlink" title="数的三次方根"></a>数的三次方根</h4><p>给定一个浮点数 n，求它的三次方根。</p>
<h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含一个浮点数 n。</p>
<h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个浮点数，表示问题的解。</p>
<p>注意，结果保留 6 位小数。</p>
<h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>−10000 ≤ n ≤ 10000</p>
<h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000.00</span><br></pre></td></tr></table></figure>

<h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.000000</span><br></pre></td></tr></table></figure></blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">double</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 利用二分查找找出一个数的三次方根</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;n&quot;&gt;&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;&lt;/returns&gt;</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">double</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> l = <span class="number">-10000</span>, r = <span class="number">10000</span>;<span class="comment">//设置左右边界</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(l - r) &gt;= <span class="number">0.0000001</span>)<span class="comment">//算出的精度要比要求的精度多至少1位，因为存在四舍五入。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;<span class="comment">//获取mid的值</span></span><br><span class="line">        <span class="keyword">if</span> (mid * mid * mid &gt;= n)<span class="comment">//判断计算出来的值是大了还是小了</span></span><br><span class="line">            r = mid;<span class="comment">//如果大了，就证明答案在mid左边，收缩右边界</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid;<span class="comment">//否则就在mid的右边，收缩左边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为浮点数不是精确的数，不存在绝对边界，因此不需要边界判断</span></span><br><span class="line">    <span class="keyword">return</span> l;<span class="comment">//因为必然有解，所以可以直接返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;n);<span class="comment">//读入</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf&quot;</span>, binarySearch(n));<span class="comment">//计算并输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="用二分法求算数根的好处："><a href="#用二分法求算数根的好处：" class="headerlink" title="用二分法求算数根的好处："></a>用二分法求算数根的好处：</h4><ol>
<li>精度可以做到非常高，而用pow()函数进行求解的话最高精度只能做到小数点后六位。</li>
<li>效率高，二分的时间复杂度是logn</li>
</ol>
<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><p>大整数：一个长度在10^6^的数；</p>
<p>普通数：数值小于10^9^的一个数；</p>
<p>大整数的实现（存储）：把大整数的每一位都存入到数组中，利用数组进行逐位存储 。</p>
<p>整个大整数的运算是一种模拟的体现，通过模拟我们手动运算的方法实现的。</p>
<h3 id="两个大整数相加"><a href="#两个大整数相加" class="headerlink" title="两个大整数相加"></a>两个大整数相加</h3><h4 id="具体实现思想："><a href="#具体实现思想：" class="headerlink" title="具体实现思想："></a>具体实现思想：</h4><ol>
<li>将两个大数均以倒序的形式存储到数组中，以便实现运算过程的进位问题。<br>如一个数是“123456789“，则在存储的时候，下标为0的位置存储的是”9“，下标为1的位置存储的是”8“，下标为8的位置存储的是”1“</li>
<li>设一个临时遍历 t，并置初值为0，用于存储每一位相加后的值。</li>
<li>从下标0到数组长度-1开始，逐位读取并相加两个数组的当前位置（如果有）</li>
<li>将两个数相加完成后的值模除10（对10取余）后存入到答案数组，然后t除以10去掉已经存入答案的值后，剩余的值进入下轮循环继续参与运算</li>
</ol>
<h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><p>模板</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//高精度加法 —— 模板题 AcWing 791. 高精度加法</span></span><br><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; B)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.size() || i &lt; B.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t += B[i];</span><br><span class="line"></span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t = t / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="number">0</span> )</span><br><span class="line">        C.push_back(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="使用stl库"><a href="#使用stl库" class="headerlink" title="使用stl库"></a>使用stl库</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; B)</span> &#123;<span class="comment">//之所以用引用是因为引用传入的是一个地址，如果不加引用符号则需要把A、B全部复制一遍</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;<span class="comment">//进位辅助的临时变量，只需要在开始置0即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.size() || i &lt; B.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size()) t += A[i];<span class="comment">//要是没超过A的位置，或者说是当运行和到这一位的时候，A数组中仍然有值，就加上A[i]；</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t += B[i];<span class="comment">//同理</span></span><br><span class="line"></span><br><span class="line">        C.push_back(t % <span class="number">10</span>);<span class="comment">//将临时变量模除10后存入答案数组，因为是10进制运算所以这个地方要模除10</span></span><br><span class="line">        t = t / <span class="number">10</span>;<span class="comment">//将存入的值删除后，剩余的值继续参与下轮循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="number">0</span> )<span class="comment">//要是t不空 证明还有进位没有存入到答案数组</span></span><br><span class="line">        C.push_back(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;<span class="comment">//利用string实现大数的一个读入</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;A, B;<span class="comment">//之所以用vector容器，是因为vector有一个size属性比较方便，且没有位数的限制</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;<span class="comment">//读入a,b</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//逆序存入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//逆序存入到vector数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        B.push_back(b[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//逆序存入到vector数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = add(A, B);<span class="comment">//c++11的新东西，auto。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//因为是倒序存入，因此在读出的时候也需要倒序</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用普通的char数组完成"><a href="#使用普通的char数组完成" class="headerlink" title="使用普通的char数组完成"></a>使用普通的char数组完成</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> A[N], B[N], C[N];</span><br><span class="line"><span class="type">char</span> * <span class="title function_">add</span><span class="params">(<span class="type">char</span> A[], <span class="type">char</span> B[],<span class="type">int</span> lenA,<span class="type">int</span> lenB)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;<span class="comment">//辅助的临时变量，只需要在开始置0即可</span></span><br><span class="line">    <span class="comment">//const int lenA = sizeof(A) / sizeof(char);//存储A数组的长度，后面用的时候可以不用在计算了。因为不涉及到修改，就设置成const属性</span></span><br><span class="line">   <span class="comment">// const int lenB = sizeof(B) / sizeof(char);//同理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lenA || i &lt; lenB; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; lenA) t = t + A[i];<span class="comment">//要是没超过A的位置，或者说是当运行和到这一位的时候，A数组中仍然有值，就加上A[i]。、</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; lenB) t = t + B[i];<span class="comment">//同理</span></span><br><span class="line"></span><br><span class="line">        C[i] = t % <span class="number">10</span>;</span><br><span class="line">        k++;</span><br><span class="line">        t = t / <span class="number">10</span>;<span class="comment">//将存入的值删除后，剩余的值继续参与下轮循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="number">0</span>)<span class="comment">//要是t不空 证明还有进位没有存入到答案数组</span></span><br><span class="line">        C[k++] = t;<span class="comment">//因为最多就有1位的进位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;<span class="comment">//利用string实现大数的一个读入</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;<span class="comment">//读入a,b</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;<span class="comment">//倒序存储时记录长度的辅助变量</span></span><br><span class="line">    <span class="comment">//逆序存入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A[k++] = a[i] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//之间将字符转成值存入，后续就可以不用再转换了</span></span><br><span class="line">    k = <span class="number">0</span>;<span class="comment">//辅助变量置0以便下次使用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        B[k++] = b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    add(A, B,a.size(),b.size());<span class="comment">//c++11的新东西，auto。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;<span class="comment">//一个标志位，用于去除先导的0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="keyword">sizeof</span>(C) / <span class="keyword">sizeof</span>(<span class="type">char</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//因为是倒序存入，因此在读出的时候也需要倒序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag || C[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两个大整数相减"><a href="#两个大整数相减" class="headerlink" title="两个大整数相减"></a>两个大整数相减</h3><h4 id="具体实现思想"><a href="#具体实现思想" class="headerlink" title="具体实现思想"></a>具体实现思想</h4><ol>
<li>同大整数加法类似，都是逆序输入两个数；不同之处在于进行减法运算的时候最好进行一下判断，可以避免很大的麻烦。因为题目已经声明两个数都是正整数，因此不需要判断是否存在负数的情况。如果需要的话在输入输出阶段判断一下即可。因为任意的两个数相减都可以转换成两个数 绝对值的相加或相减；</li>
<li>如果大数A 小于 大数B 的话，A - B 可以转换成 （A - B) * -1;</li>
<li>在减法函数中，需要一个辅助标志位 t ，表示上一位数在运算过程中是否发生进位的行为，并且临时存储当前位的运算结果</li>
<li>将t进行修正后存入答案数组。修正方法：若 t &gt;&#x3D; 0，则直接存入，否则将t + 10 存入答案（因为是十进制）</li>
<li>判断t是否小于0（上一步只是相加但并未改变t） ，如果是，将 t 置 1 表示发生了进位，否则置0。</li>
<li>循环4，5步直到算出答案。此时答案可能存在前导0，因此需要删除。此时存在一个例外的情况就是，如果答案只有1位，哪怕这位是0也不能删除。因此条件为：如果答案位数大于1，且答案的最高位为0，就可以删除最高位。</li>
<li>倒序输出答案。根据第2步的判断，要不要在输出前加一个负号。</li>
</ol>
<h4 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a>实现代码</h4><h5 id="使用stl库-1"><a href="#使用stl库-1" class="headerlink" title="使用stl库"></a>使用stl库</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//C = A - B</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; B)</span> &#123;<span class="comment">//之所以用引用是因为引用传入的是一个地址，如果不加引用符号则需要把A、B全部复制一遍</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;<span class="comment">//减法运算过程的借位标识符。有借位值为1，否则为0.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)<span class="comment">//在进入这个函数的时候已经确保了A一定是大于等于B的，因此长度上以A为准即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;<span class="comment">//获取被减数。如果有借位先将借位偿还</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size())<span class="comment">//判断一下B是否有这一位，只有存在这一位的情况才需减去</span></span><br><span class="line">            t = t - B[i];<span class="comment">//算出 被减数 减去 减数 后的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*if(t &gt;= 0)//如果够减,直接将答案存入</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            C.push_back(t);</span></span><br><span class="line"><span class="comment">            t = 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            C.push_back(t+10);</span></span><br><span class="line"><span class="comment">            t = 1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//判断是否需要进位的语句也可以写成如下样式</span></span><br><span class="line">        C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>)</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//减法运算后的结果可能存在前导0的情况，需要去除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>)<span class="comment">//如果答案只有一位，哪怕这位是0也需要保留。如果位数大于1位，并且最高位为0，则最高位需要弹出</span></span><br><span class="line">    &#123;</span><br><span class="line">        C.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较两个大整数的大小 ， 是否存在 A &gt;= B</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; B)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() != B.size())<span class="comment">//如果位数不同，可以根据位数进行判断</span></span><br><span class="line">        <span class="keyword">return</span> A.size() &gt; B.size();</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果位数相同，则从最高位依次与下一位相比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//因为是逆序存储，因此判断的时候也需要逆序判断</span></span><br><span class="line">            <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">                <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果全部判断完都没有判断出大小，则证明两个数相等。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//注意：题目声明了a b 两个数均为正整数，不存在负数的情况。如果没有声明，则需要在读入后进行一次判断，判断两个数的首位是否存在负号。如果存在则需要加一个标记。</span></span><br><span class="line">    <span class="comment">//任意两个数相减都可以转换为两个数的绝对值相加或相减，因此如果存在负数只需要在输入输出的时候特判一下即可</span></span><br><span class="line">    <span class="built_in">string</span> a, b;<span class="comment">//利用string实现大数的一个读入</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;A, B;<span class="comment">//之所以用vector容器，是因为vector有一个size属性比较方便，且没有位数的限制</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;<span class="comment">//读入a,b</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//逆序存入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//逆序存入到vector数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        B.push_back(b[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//逆序存入到vector数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为题目中有“计算结果可能为负数”，即表示，A可能小于B,因此需要判断一下</span></span><br><span class="line">    <span class="comment">//3 - 5 可以转换为 (5 - 3) * -1 。</span></span><br><span class="line">    <span class="keyword">if</span> (cmp(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = sub(A, B);<span class="comment">//c++11的新东西，auto。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//因为是倒序存入，因此在读出的时候也需要倒序</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = sub(B, A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);<span class="comment">//如果A小于B，则证明结果是负数，需要提前打出负号，并将运算改为B-A</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//因为是倒序存入，因此在读出的时候也需要倒序</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一个大整数与一个普通整数相乘"><a href="#一个大整数与一个普通整数相乘" class="headerlink" title="一个大整数与一个普通整数相乘"></a>一个大整数与一个普通整数相乘</h3><h4 id="具体实现思想-1"><a href="#具体实现思想-1" class="headerlink" title="具体实现思想"></a>具体实现思想</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同大整数相加的原理类似，但实现想法相比实际笔算有些许的不同。设大数A有5位，依次是A[0]，A[1]，...，A[4]；小整数为b，答案C[0] = A[0] x b，C[1] = A[1] x b；因为是十进制的相乘，每一位数最大值是9，因此需要一个进位辅助 t ，将每一位中大于9的部分进行暂存，并在下一位运算的过程中继续参与运算，直到t空为止。</span><br></pre></td></tr></table></figure>


<ol>
<li>首先逆序读入；</li>
<li>特判一下b是否等于0，如果等于0则直接结束运算并输出一个0；</li>
<li>大整数的每一位依次乘上小整数，并将结果存入辅助进位的变量t，将t模除10后写入对应的答案位；</li>
<li>t除以10去除写入答案的值，然后继续第3步直到大整数A的每一位都运算完成；</li>
<li>继续将t写入答案，然后除以10，直到t &#x3D; 0为止；</li>
<li>逆序输出答案；</li>
</ol>
<h4 id="实现代码-4"><a href="#实现代码-4" class="headerlink" title="实现代码"></a>实现代码</h4><h5 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;<span class="comment">//存储进位的辅助变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果大数A没有循环完，则每次都将大数A与小数b进行相乘</span></span><br><span class="line">    <span class="comment">//当大数循环完，但t中还有数没有写到答案中，则依然继续循环，但不再进行大数与小数的相乘</span></span><br><span class="line">    <span class="comment">//当大数循环完，t也被清空了，就结束循环</span></span><br><span class="line">    <span class="comment">//根据之前的程序设计，是否在此处进行前导零的删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.size() || t != <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.size())</span><br><span class="line">            t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//如果没有进行特判，则在退出之前需要删除多余的前导0.（当其中小数是0时就会出现多余的前导0）</span></span><br><span class="line">	  <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用stl库-2"><a href="#使用stl库-2" class="headerlink" title="使用stl库"></a>使用stl库</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;<span class="comment">//存储进位的辅助变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">        t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (t) &#123;<span class="comment">//把剩余进位继续写入</span></span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意 可能存在前导0的情况，需要处理掉,或者检测到b = 0 的时候，直接输出一个0.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里做了下特判，因为出现多余的0的情况只在b是0的时候，当我们检测到其中一个除数是0的时候，可以直接输出0。</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//逆序读入</span></span><br><span class="line">        A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C = mul(A, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//再次逆序输出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="一个大整数与一个普通整数相除"><a href="#一个大整数与一个普通整数相除" class="headerlink" title="一个大整数与一个普通整数相除"></a>一个大整数与一个普通整数相除</h3><h4 id="具体实现思想-2"><a href="#具体实现思想-2" class="headerlink" title="具体实现思想"></a>具体实现思想</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">除法比较特殊，是从最高位开始算的， 整个过程模拟笔算，</span><br></pre></td></tr></table></figure>


<ol>
<li>把前一位的余数*10+这一位的余数，然后除以除数，把能除的部分写入到商（答案）中，</li>
<li>接着把上一步得到的数模除一下除数，留下本次的余数，并参与到下次的运算。</li>
<li>运算结束可以根据需求反转一下</li>
<li>去除前导0，结束运算</li>
</ol>
<h4 id="实现代码-5"><a href="#实现代码-5" class="headerlink" title="实现代码"></a>实现代码</h4><h5 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//大数A，小数b，余数r</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;<span class="comment">//商</span></span><br><span class="line">    r = <span class="number">0</span>;<span class="comment">//余数 引用传回</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.push_back(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    reverse(C.begin(),C.end());</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//去除前导0</span></span><br><span class="line">    <span class="keyword">while</span>(C.size()&gt;<span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>)</span><br><span class="line">        C.pop_back();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用stl库-3"><a href="#使用stl库-3" class="headerlink" title="使用stl库"></a>使用stl库</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//大数A，小数b，余数r</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;<span class="comment">//商</span></span><br><span class="line">    r = <span class="number">0</span>;<span class="comment">//余数 引用传回</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    除法比较特殊，是从最高位开始算的</span></span><br><span class="line"><span class="comment">    整个过程模拟笔算</span></span><br><span class="line"><span class="comment">    把前一位的余数*10+这一位的余数，然后除以除数，把能除的部分写入到商（答案）中</span></span><br><span class="line"><span class="comment">    然后把上一步得到的数模除一下除数，留下本次的余数，并参与到下次的运算。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.push_back(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//因为除法相比于其他的运算是反过来的，是从最高位开始运算的，这里需要反转一下</span></span><br><span class="line">    <span class="comment">//否则就是输出的时候反过来输出。但这带来了一个新的问题：先导0很难去除</span></span><br><span class="line">    <span class="comment">//所以还是反转一下比较好，这样好去除先导0，并且输出可以不用另外更改</span></span><br><span class="line">    reverse(C.begin(),C.end());<span class="comment">//  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//去除前导0</span></span><br><span class="line">    <span class="keyword">while</span>(C.size()&gt;<span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>)</span><br><span class="line">        C.pop_back();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//逆序读入</span></span><br><span class="line">        A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C = div(A, b, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//再次逆序输出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; r &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h2><h3 id="前缀和（一维）"><a href="#前缀和（一维）" class="headerlink" title="前缀和（一维）"></a>前缀和（一维）</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>有一个长度为n的数组a，为：a[1]，a[2]，a[3]，…，a[n]；</p>
<p>对应的前缀和数组为：s[1]，s[2]，…，s[n]；s[ i ] &#x3D; a[ 1 ] + a[ 2 ] + … + a[ i ]</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">快速的求出数组中一段数的和。</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用前缀和进行计算可以将时间复杂度由原来的 O( n ) 降低到 O( 1 )；</span><br></pre></td></tr></table></figure>


<h4 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h4><h5 id="前缀和预处理"><a href="#前缀和预处理" class="headerlink" title="前缀和预处理"></a>前缀和预处理</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s[ i ] = s[ i - 1 ] + a[ i ];</span><br></pre></td></tr></table></figure>


<h5 id="使用前缀和"><a href="#使用前缀和" class="headerlink" title="使用前缀和"></a>使用前缀和</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[ l ] ~ a[ r ]的和 = S[r] - S[ l - 1 ]</span><br></pre></td></tr></table></figure>


<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>前缀和数组在预处理阶段是 O(n)，在使用的时候是 O(1)</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>在使用前缀和的时候，一般使得数组下标从1起，空出开头的一个，方便计算。</li>
</ol>
<h4 id="模板-4"><a href="#模板-4" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="例题：795-前缀和"><a href="#例题：795-前缀和" class="headerlink" title="例题：795.前缀和"></a>例题：795.前缀和</h4><blockquote>
<p>输入一个长度为 n 的整数序列。</p>
<p>接下来再输入 m 个询问，每个询问输入一对 l,r。</p>
<p>对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。</p>
<h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 m。</p>
<p>第二行包含 n 个整数，表示整数数列。</p>
<p>接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。</p>
<h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 m 行，每行输出一个询问的结果。</p>
<h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ l ≤ r ≤ n<br>1 ≤ n,m ≤ 100000<br>−1000 ≤ 数列中元素的值 ≤ 1000</p>
<h4 id="输入样例：-3"><a href="#输入样例：-3" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 1 3 6 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>

<h4 id="输出样例：-3"><a href="#输出样例：-3" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure></blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,l,r;</span><br><span class="line"><span class="type">int</span> nums[N],s[N];<span class="comment">//输入的数组，对应的前缀和数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nums[i]);</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + nums[i];<span class="comment">//输入的同时对前缀和进行一个初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r] - s[l - <span class="number">1</span>]);<span class="comment">//利用前缀和公式直接求出指定区间的和,区间和的计算  </span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="前缀和（二维）"><a href="#前缀和（二维）" class="headerlink" title="前缀和（二维）"></a>前缀和（二维）</h3><p>用于快速的求出一个子矩阵内的和。</p>
<p>原理和一维的前缀和相同，这里不再赘述。</p>
<h4 id="前缀和矩阵的预处理公式"><a href="#前缀和矩阵的预处理公式" class="headerlink" title="前缀和矩阵的预处理公式"></a>前缀和矩阵的预处理公式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s[ i, j ] = s[ i - 1, j ] + s[ i , j - 1 ] - s[ i - 1 , j - 1 ] + a[ i , j ]</span><br></pre></td></tr></table></figure>


<h4 id="区间和的计算"><a href="#区间和的计算" class="headerlink" title="区间和的计算"></a>区间和的计算</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s[x2,y2]  - s[x2,y1-1] - s[x1-1,y2-1 ] + s[x1-1,y1-1]</span><br></pre></td></tr></table></figure>


<p><img src="/./Image/Other/image-20220630154949763.png" alt="image-20220630154949763"></p>
<h4 id="模板-5"><a href="#模板-5" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="例题：796-子矩阵的和"><a href="#例题：796-子矩阵的和" class="headerlink" title="例题：796. 子矩阵的和"></a>例题：796. 子矩阵的和</h4><blockquote>
<p>输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。</p>
<p>对于每个询问输出子矩阵中所有数的和。</p>
<h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 n，m，q。</p>
<p>接下来 n 行，每行包含 m 个整数，表示整数矩阵。</p>
<p>接下来 q 行，每行包含四个整数 x1,y1,x2,y2，表示一组询问。</p>
<h4 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 qq 行，每行输出一个询问的结果。</p>
<h4 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ n, m ≤ 1000<br>1 ≤ q ≤ 200000<br>1 ≤ x1 ≤ x2 ≤n<br>1 ≤ y1 ≤ y2 ≤m<br>−1000 ≤ 矩阵内元素的值 ≤ 1000</p>
<h4 id="输入样例：-4"><a href="#输入样例：-4" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 3</span><br><span class="line">1 7 2 4</span><br><span class="line">3 6 2 8</span><br><span class="line">2 1 2 3</span><br><span class="line">1 1 2 2</span><br><span class="line">2 1 3 4</span><br><span class="line">1 3 3 4</span><br></pre></td></tr></table></figure>

<h4 id="输出样例：-4"><a href="#输出样例：-4" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">17</span><br><span class="line">27</span><br><span class="line">21</span><br></pre></td></tr></table></figure></blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nums[N][N], s[N][N];</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nums[i][j]);</span><br><span class="line">            s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + nums[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="差分（前缀和的逆运算）"><a href="#差分（前缀和的逆运算）" class="headerlink" title="差分（前缀和的逆运算）"></a>差分（前缀和的逆运算）</h3><p>差分就是给你一个前缀和数组，让你根据数组还原出原来的数组</p>
<p>对于一维数据来说，就是设给定一个前缀和数组s[n]，然后假想一个数组b，使得s数组是b数组的前缀和，此时，b就成为s的差分，s是b的前缀和；</p>
<p>对于二维数据，也是类似的，给定一个原数组a[i,j]，构造一个b矩阵b[i,j]，使得a数组是b数组的前缀和。</p>
<p>对于差分算法来说，都可以不用考虑构造的问题，假定初始数组都是0即可，对于原有的数据视为插入即可。</p>
<h4 id="差分的作用"><a href="#差分的作用" class="headerlink" title="差分的作用"></a>差分的作用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于一维数据来说，给定一个数组，要求在数组中指定的区域（l，r）中每个数都加上一个指定的数c。如果次数较多，可以使用 差分 算法实现。差分算法的实现要求是首先用O(n)的时间构造出一个辅助数组（不是必须的），之后的所有操作就可以在O(1)内完成，最后在用O(n)的时间算出全部。</span><br></pre></td></tr></table></figure>


<h4 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><ol>
<li>假定原数组a[n]全部是0，此时辅助的差分数组b内也全部都是0。</li>
<li>将输入的数据视为插入。就是说，可以看作进行了n次的插入操作。<br>如a[1]是2的话，可以看作进行了如下的操作：原数组的[1,1] + a[1] ； 原数组的[n,n] + a[n]。<br>此时，就规避了构造的问题。</li>
<li>此时，就可以总结出一个规律：想对一个区间全部加上一个数，就可以进行b[l] + c ; b[r + 1] - c;实现。</li>
<li>按照1到3的思路来说，原数组a[i]就没有存在的需要，只需要一个差分数组b[i]即可。输入原数组的时候，可以视为进行了插入操作，即b[i] +&#x3D; c , b[i + 1] -&#x3D; c;<br>在全部输入完成后，只需要对着辅助数组求一遍前缀和即可还原为原数组的数据。如b[i] +&#x3D; b[i-1]；</li>
</ol>
<h5 id="模板-6"><a href="#模板-6" class="headerlink" title="模板"></a>模板</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="number">1</span>] -= c</span><br></pre></td></tr></table></figure>

<h5 id="例题-：797-差分"><a href="#例题-：797-差分" class="headerlink" title="例题 ：797. 差分"></a>例题 ：797. 差分</h5><blockquote>
<p>输入一个长度为 n 的整数序列。</p>
<p>接下来输入 m 个操作，每个操作包含三个整数 l,r,c 表示将序列中 [l,r] 之间的每个数加上 c。</p>
<p>请你输出进行完所有操作后的序列。</p>
<h4 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 m。</p>
<p>第二行包含 n 个整数，表示整数序列。</p>
<p>接下来 m 行，每行包含三个整数 l，r，c 表示一个操作。</p>
<h4 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 n 个整数，表示最终序列。</p>
<h4 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ n,m ≤ 100000<br>1 ≤ l ≤ r ≤ n<br>−1000 ≤ c≤1000<br>−1000 ≤ 整数序列中元素的值 ≤ 1000</p>
<h4 id="输入样例：-5"><a href="#输入样例：-5" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">3 5 1</span><br><span class="line">1 6 1</span><br></pre></td></tr></table></figure>

<h4 id="输出样例：-5"><a href="#输出样例：-5" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 5 3 4 2</span><br></pre></td></tr></table></figure></blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b[N];<span class="comment">//差分数组</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r+<span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line">        insert(i,i,c);<span class="comment">//把原数组视为逐个插入</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//多轮插入</span></span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;c);<span class="comment">//读入每轮的范围及数值</span></span><br><span class="line">        insert(l,r,c);<span class="comment">//插入</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//整合并输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] += b[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于一维差分来说，是给一段距离加上一个值；</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">而对于二维差分来说，是给一个子矩阵加上一个值；</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">操作的时间复杂度来说，由原先的整个子矩阵变成了四个点，由O(n) 下降到 O(1)</span><br></pre></td></tr></table></figure>


<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><ol>
<li>不考虑构造，假定初始a[i,j]都是0，同样b[i,j]也就都为0了。对于a[i，j]中原有的数据，依次遍历插入即可；</li>
<li>对于插入方法来说，<ol>
<li>一维插入方法是：b[l] +&#x3D; c; b[r+1] -&#x3D; c;</li>
<li>二维的插入方法是：（设要插入的子矩阵的左上角坐标为：x1,y1，右下角的坐标为：x2,y2）<ol>
<li>b[x1 , y1] +&#x3D; c; &#x2F;&#x2F;先将从子矩阵左上角到整个大矩阵的右下角所有的值都加上c</li>
<li>b[x2 + 1 , y1] -&#x3D; c;  &#x2F;&#x2F;然后将子矩阵左下角到整个大矩阵右下角所有的值减去c</li>
<li>b[x1 , y2 + 1] -&#x3D; c;  &#x2F;&#x2F;接着将子矩阵右上角到整个大矩阵右下角所有的值减去c</li>
<li>b[x2+1 , y2+1] +&#x3D; c;  &#x2F;&#x2F;因为第2、3步的操作导致了子矩阵右下角到整个大矩阵右下角所有的值减去两遍c，因此需要补回一个。</li>
</ol>
</li>
</ol>
</li>
<li>最后输出的时候求一下b数组的前缀和就可以了。</li>
</ol>
<h5 id="模板-7"><a href="#模板-7" class="headerlink" title="模板"></a>模板</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span><br><span class="line">S[x1, y1] += c, S[x2 + <span class="number">1</span>, y1] -= c, S[x1, y2 + <span class="number">1</span>] -= c, S[x2 + <span class="number">1</span>, y2 + <span class="number">1</span>] += c</span><br><span class="line">位运算 —— 模板题 AcWing <span class="number">801.</span> 二进制中<span class="number">1</span>的个数</span><br><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line">返回n的最后一位<span class="number">1</span>：lowbit(n) = n &amp; -n</span><br></pre></td></tr></table></figure>

<h5 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h5><blockquote>
<p>输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c 其中 (x1,y1)和 (x2,y2)表示一个子矩阵的左上角坐标和右下角坐标。</p>
<p>每个操作都要将选中的子矩阵中的每个元素的值加上 c。</p>
<p>请你将进行完所有操作后的矩阵输出。</p>
<h4 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n,m,q。</p>
<p>接下来 n 行，每行包含 m 个整数，表示整数矩阵。</p>
<p>接下来 q 行，每行包含 5 个整数 x1,y1,x2,y2,c 表示一个操作。</p>
<h4 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。</p>
<h4 id="数据范围-6"><a href="#数据范围-6" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ n,m ≤ 1000<br>1 ≤ q ≤ 100000<br>1 ≤ x1 ≤ x2 ≤ n<br>1 ≤ y1 ≤ y2 ≤ m<br>−1000 ≤ c ≤ 1000<br>−1000 ≤ 矩阵内元素的值 ≤ 1000</p>
<h4 id="输入样例：-6"><a href="#输入样例：-6" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 3</span><br><span class="line">1 2 2 1</span><br><span class="line">3 2 2 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 2 2 1</span><br><span class="line">1 3 2 3 2</span><br><span class="line">3 1 3 4 1</span><br></pre></td></tr></table></figure>

<h4 id="输出样例：-6"><a href="#输出样例：-6" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3 4 1</span><br><span class="line">4 3 4 1</span><br><span class="line">2 2 2 2</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> b[N][N];</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维差分的核心</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> c)</span>&#123;</span><br><span class="line"> b[x1][y1] += c;</span><br><span class="line"> b[x1][y2+<span class="number">1</span>] -= c;</span><br><span class="line"> b[x2+<span class="number">1</span>][y1] -= c;</span><br><span class="line"> b[x2+<span class="number">1</span>][y2+<span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="type">int</span> c,x1,x2,y1,y2;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n ,&amp;m ,&amp;q);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//将原数组的数据视为插入，依次进行读取处理</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c);</span><br><span class="line">         insert(i,j,i,j,c);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//开始多轮修改</span></span><br><span class="line"> <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;c);</span><br><span class="line">     insert(x1,y1,x2,y2,c);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//修改完成后，根据差分数组b进行一次前缀和的运算，并且输出出来</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;= m; j++)&#123;</span><br><span class="line">         b[i][j] = b[i][j] + b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);<span class="comment">//直接输出</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>简单的说双指针算法就是有两个指针来进行操作的算法。</p>
<p>两个指针可以指向不同的序列，可以指向相同序列中不同的位置 。</p>
<p>双指针算法的应用范围非常广，有时甚至都意识不到。比如常见的快排、归并排序都应用到了双指针的思想。</p>
<h3 id="模板-8"><a href="#模板-8" class="headerlink" title="模板"></a>模板</h3><p>一般的写法就一种情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="keyword">while</span>(j &lt; i &amp;&amp; check(i,j))</span><br><span class="line">    &#123;</span><br><span class="line">      	j++;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//每个题目的具体逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的说 双指针算法的核心思想就是，将原始的双重循环O( n ^ n  )的算法，通过某种性质优化到一重循环O(n)</p>
<h3 id="样例1：给定一个字符串-将其转换成一个个单词输出"><a href="#样例1：给定一个字符串-将其转换成一个个单词输出" class="headerlink" title="样例1：给定一个字符串 将其转换成一个个单词输出"></a>样例1：给定一个字符串 将其转换成一个个单词输出</h3><blockquote>
<p>给定一个字符串 将其转换成一个个单词输出。保证字符串首字符不是空格，且单词之间的分隔符是空格</p>
<p>如：abc def ghi</p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc</span><br><span class="line">	def</span><br><span class="line">	ghi</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="type">char</span> str[<span class="number">1000</span>];</span><br><span class="line"> gets(str);</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//利用双指针算法算出当前单词的结束位置</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)&#123;</span><br><span class="line">     <span class="type">int</span> j = i;</span><br><span class="line">     <span class="keyword">while</span>(j &lt; n &amp;&amp; str[j] != <span class="string">&#x27; &#x27;</span>)<span class="comment">//只要j没到终点，且当前j是非空格（分界符）</span></span><br><span class="line">         j++;<span class="comment">//直到j指向分界符</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//往下就是这道题的具体逻辑</span></span><br><span class="line">     <span class="keyword">for</span>(; i &lt; j; i++)&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; str[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<h3 id="样例2：799-最长连续不重复子序列"><a href="#样例2：799-最长连续不重复子序列" class="headerlink" title="样例2：799. 最长连续不重复子序列"></a>样例2：799. 最长连续不重复子序列</h3><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ol>
<li>有两个指针i，j，j 在前 i 在后。i每次后移增加新的数据</li>
<li>每次增加完，检查 j 到 i 之间有没有重复数据，如果有，则 j 指针后移（j指针只能后移，因为序列是有序的，不可能存在前一个区间内有重复数字，新加入一个数后区间内重复数字消失了，只有一种情况就是新增加的数导致了区间内有重复的数据），直到整个区间内没有重复数字位置。（具体操作见后面）</li>
<li>计算已有的记录和当前区间的长度，如果当前的更长就更新记录</li>
<li>检查方法：类似于哈希，哈希公式就是数值本身。即f( x ) &#x3D; x ;</li>
</ol>
<h4 id="具体题目及代码"><a href="#具体题目及代码" class="headerlink" title="具体题目及代码"></a>具体题目及代码</h4><blockquote>
<p>给定一个长度为 nn 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p>
<h4 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n。</p>
<p>第二行包含 n 个整数（均在 0∼105 范围内），表示整数序列。</p>
<h4 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p>
<h4 id="数据范围-7"><a href="#数据范围-7" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ n ≤ 105</p>
<h4 id="输入样例：-7"><a href="#输入样例：-7" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 2 3 5</span><br></pre></td></tr></table></figure>

<h4 id="输出样例：-7"><a href="#输出样例：-7" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];<span class="comment">//读入的数据</span></span><br><span class="line"><span class="type">int</span> s[N];<span class="comment">//当前i到j之间，每一个数出现的次数</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> res;<span class="comment">//答案，或者说是最长的记录</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">     s[a[i]]++;<span class="comment">//i指针后移后，将新的数对应的地方++，表示多了这一个数</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//条件1：j&lt;=i可以不用写，因为当j &gt; i的时候，区间里就没有数了，此时一定满足没有重复数的要求。</span></span><br><span class="line">     <span class="comment">//条件2：新加入的数是a[i]，因此判断当前是否有不止一个的数。</span></span><br><span class="line">     <span class="comment">//如果i指针当前指向的数不止一个，即表明j到i之间的数存在重复，且重复的位置是新入的i指针指向的位置。（因为在上一次循环已经排除了重复，最坏的可能就是上一轮中 i 和 j 都指向他自己</span></span><br><span class="line">     <span class="comment">//假定重复的值是j指向的位置，只需要将s中j指向的个数--，然后j指针后移，直到j到i的区间内不存在重复即可</span></span><br><span class="line">     <span class="keyword">while</span>(j &lt;= i &amp;&amp; s[a[i]]&gt;<span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         s[a[j]] -- ;<span class="comment">//</span></span><br><span class="line">         j ++ ;</span><br><span class="line">     &#125;</span><br><span class="line">     res = max(res,i - j + <span class="number">1</span>);<span class="comment">//此时计算一下j到i之间有多少个数，并将这个数与已有的记录进行比较，如果大于就更新一下。</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<h4 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h4><blockquote>
<p>AcWing 799. 最长连续不重复子序列-从暴力到双指针的详细过程    原题链接    简单<br>作者：    bbk ,  2020-10-27 20:55:03 ,  所有人可见 ,  阅读 1836</p>
<p>给定一个长度为n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。<br>输入格式:<br>第一行包含整数n。<br>第二行包含n个整数（均在0~100000范围内），表示整数序列。<br>输出格式:<br>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。数据范围:<br>1≤n≤1000001≤n≤100000<br>输入样例:：</p>
<p>5<br>1 2 2 3 5</p>
<p>输出样例：</p>
<p>3</p>
<p>思路：<br>暴力法：<br>当然可以用暴力法：对每个 i 和 j 都遍历一遍，对每个 i 和 j 都check一下中间的数据是否满足给定的条件。这样的时间复杂度是O(n^2)；数据稍微大点就会超时。<br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">  <span class="keyword">if</span> (check(v1,j, i) == <span class="number">0</span>)<span class="comment">//检查 i 和 j 之间是否有重复的数字</span></span><br><span class="line">      res = max(res, i - j + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//check函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; v1, <span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l+<span class="number">1</span>; i &lt;=r ; i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt; i; j++)</span><br><span class="line">      <span class="keyword">if</span> (v1[i] == v1[j])</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针法一：<br>仔细考虑暴力法就会发现，暴力法在解题时有很多地方是重复计算了 ( i 指针在 j 指针的后面，i是遍历的整个数组的，j 是遍历 0 到 i 的)：</p>
<p>比如 j &#x3D; 0，i &#x3D; 5，此时发现 i，j 是满足题解条件的；那么后面的 j &#x3D; 1到5，i &#x3D; 5 就不用计算了，肯定是满足条件的。</p>
<p>所以引出了双指针法：还是上面的例子，双指针法就是说，既然发现 j &#x3D; 0，i &#x3D; 5满足题解条件，那就不用计算 j &#x3D; 1到5，i &#x3D; 5了，直接计算 j &#x3D; 1，i &#x3D; 6，如果不满足条件，那就计算 j &#x3D; 2，i &#x3D; 6，然后接着计算。</p>
<p>这样就是 i 和 j 指针都是从前移到后，也就是计算2n次。时间复杂度是O(2n)。</p>
<p>核心代码如下：（但是还会超时）。</p>
<p>for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i++)<br>{<br>while (j &lt;&#x3D; i)<br>{<br>if (check(v1, j, i) &#x3D;&#x3D; 0)<br>{<br>res &#x3D; max(res, i - j + 1);<br>break;<br>}<br>else<br>j++;<br>}<br>}</p>
<p>&#x2F;&#x2F;找得到重复的数返回1<br>int check(vector<int>&amp; v1, int l, int r)<br>{<br>for (int i &#x3D; l + 1; i &lt;&#x3D; r; i++)<br>for (int j &#x3D; l; j &lt; i; j++)<br>{<br>if (v1[i] &#x3D;&#x3D; v1[j])<br>return 1;<br>}<br>return 0;<br>}</p>
<p>双指针法二（最终版）：<br>但是上面代码还是超时，为什么呢？因为check函数写的不好，循环太多，直接是暴力计算找重复数字的，显然不好。</p>
<p>所以引出一个新的check方法：对于寻找是否有重复数字，一般用hash，没人用暴力。所以用hash就可以计算。</p>
<p>但是这道题还有一种计算方法：</p>
<p>用一个辅助数组S保存原数组V1每个元素存在的次数，和hash类似。<br>比如说 V1 &#x3D; {1,2, 2, 3, 5 }。那 S就是 {0,1,2,1,0,1 }。S[V1[i]]表示的是V1[i]的个数。<br>此处我们用S数组只保存 j 和 i 指针之间的数的个数。</p>
<p>算法思路： 如果j &#x3D; 0，i &#x3D; 5，此时检查S数组元素都是 &lt;&#x3D;1的。那下一步的情况就是 i 。i之后将S数组更新，只需要检查S[v1[i]]元素是不是比1大即可，因为随着 i 的递增，S数组中变化的只有S[v1[i]]元素。<br>如果检查S[v1[i]]元素发现该元素比 1 大。那说明 j 指针和 i 指针之间有某个元素出现了两次。所以 i 指针保持不动， j 指针往后移动( j 指针不可能往前移动的，上次j指针往后移动就是因为 j 和 i之间有重复元素，这一往前移动肯定有重复元素)。j 指针往后移动之前需要先更新S数组，即进行 S[v1[j]]– 操作。然后 j 指针再往后移动。移动之后只需要检查 i 指针对应的S[v1[i]]元素是否大于1即可。（因为 j 指针移动之后只有两种情况，1.重复元素刚好没了，则S[v1[i]]肯定&#x3D;&#x3D;1；2.重复元素还在，那S[v1[i]]&#x3D;&#x3D;2，需要 j 继续往后移动 )。等S[v1[i]]&#x3D;&#x3D;1 时，说明 j 和 i 之间已经没有重复元素了，可以更新res值，然后 i++。</p>
<p>核心代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">S[v1[i]]++;</span><br><span class="line"><span class="keyword">while</span> ( S[v1[i]] &gt; <span class="number">1</span>) --S[v1[j++]];</span><br><span class="line">res = max(res, i - j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N  100010</span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">v1</span><span class="params">(n,<span class="number">0</span>)</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; v1[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">S</span><span class="params">(N,<span class="number">0</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">  S[v1[i]]++;</span><br><span class="line">  <span class="keyword">while</span> ( S[v1[i]] &gt; <span class="number">1</span>) --S[v1[j++]];</span><br><span class="line">  res = max(res, i - j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者：bbk<br>链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/23474/">https://www.acwing.com/solution/content/23474/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="样例3：800-数组元素的目标和"><a href="#样例3：800-数组元素的目标和" class="headerlink" title="样例3：800. 数组元素的目标和"></a>样例3：800. 数组元素的目标和</h3><blockquote>
<p>给定两个升序排序的有序数组 AA 和 BB，以及一个目标值 xx。</p>
<p>数组下标从 00 开始。</p>
<p>请你求出满足 A[i]+B[j]&#x3D;xA[i]+B[j]&#x3D;x 的数对 (i,j)(i,j)。</p>
<p>数据保证有唯一解。</p>
<h4 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 n,m,xn,m,x，分别表示 AA 的长度，BB 的长度以及目标值 xx。</p>
<p>第二行包含 nn 个整数，表示数组 AA。</p>
<p>第三行包含 mm 个整数，表示数组 BB。</p>
<h4 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含两个整数 ii 和 jj。</p>
<h4 id="数据范围-8"><a href="#数据范围-8" class="headerlink" title="数据范围"></a>数据范围</h4><p>数组长度不超过 105105。<br>同一数组内元素各不相同。<br>1≤数组元素≤1091≤数组元素≤109</p>
<h4 id="输入样例：-8"><a href="#输入样例：-8" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5 6</span><br><span class="line">1 2 4 7</span><br><span class="line">3 4 6 8 9</span><br></pre></td></tr></table></figure>

<h4 id="输出样例：-8"><a href="#输出样例：-8" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1</span><br></pre></td></tr></table></figure></blockquote>
<h4 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h4><p>首先，因为两个数组的解是唯一的，不存在多种配对的问题。</p>
<ul>
<li>首先让i指针指向a数组开头（即a数组中最小的数）</li>
<li>然后让j指针指向b数组的结尾（即b数组中最大的数）</li>
<li>此时可以发现，i不动，j前移；i与j指针指向的数相加的结果必然是从大到小的。</li>
<li>因此，利用这个性质，使得j不停的前移，直到两个指针指向的数的和小于等于要求的值</li>
<li>此时，j停止移动，判断i与j指向的数是否相等，相等就输出，不等就进入下轮循环，i指针后移，j指针不动，直到匹配为止</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, x;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//读入数据</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *利用双指针开始配对</span></span><br><span class="line"><span class="comment">    * 首先让i指针指向a数组开头（即a数组中最小的数）</span></span><br><span class="line"><span class="comment">    * 然后让j指针指向b数组的结尾（即b数组中最大的数）</span></span><br><span class="line"><span class="comment">    * 此时可以发现，i不动，j前移；i与j指针指向的数相加的结果必然是从大到小的。</span></span><br><span class="line"><span class="comment">    * 因此，利用这个性质，使得j不停的前移，直到两个指针指向的数的和小于等于要求的值</span></span><br><span class="line"><span class="comment">    * 此时，j停止移动，判断i与j指向的数是否相等，相等就输出，不等就进入下轮循环，i指针后移，j指针不动，直到匹配为止</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; b[j] + a[i] &gt; x)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span> (a[i] + sb[j] == x) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, j);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="样例4：2816-判断子序列"><a href="#样例4：2816-判断子序列" class="headerlink" title="样例4：2816. 判断子序列"></a>样例4：2816. 判断子序列</h3><blockquote>
<p>给定一个长度为 n 的整数序列 a1,a2,…,an 以及一个长度为 m 的整数序列 b1,b2,…,bm。</p>
<p>请你判断 a 序列是否为 b 序列的子序列。</p>
<p>子序列指序列的一部分项按<strong>原有次序排列</strong>而得的序列，例如序列 {a1,a3,a5} 是序列 {a1,a2,a3,a4,a5} 的一个子序列。</p>
<h4 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n,m。</p>
<p>第二行包含 n 个整数，表示 a1,a2,…,an。</p>
<p>第三行包含 m 个整数，表示 b1,b2,…,bm。</p>
<h4 id="输出格式-9"><a href="#输出格式-9" class="headerlink" title="输出格式"></a>输出格式</h4><p>如果 a 序列是 b 序列的子序列，输出一行 <code>Yes</code>。</p>
<p>否则，输出 <code>No</code>。</p>
<h4 id="数据范围-9"><a href="#数据范围-9" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤m≤10^5^<br>−10^9^ ≤ ai , bi ≤ 10^9^</p>
<h4 id="输入样例：-9"><a href="#输入样例：-9" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 5</span><br><span class="line">1 3 5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

<h4 id="输出样例：-9"><a href="#输出样例：-9" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure></blockquote>
<h4 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读入序列后，设两个指针分别指向两个序列的起始位置，若两指针指向的值相等，则两个序列的指针都后移一个；若不等，则子序列的不移动，长序列的继续后移，进行判断，直到两个序列中任意一个到达终点为止。此时判断子序列有没有走完，如果走完了说明就是子序列，否则就不是子序列。</span><br></pre></td></tr></table></figure>


<h4 id="实现代码-6"><a href="#实现代码-6" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">      </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(i &lt; n  &amp;&amp; j &lt; m)&#123;<span class="comment">//指针不能到头</span></span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[j])<span class="comment">//如果匹配的话子序列的指针后移</span></span><br><span class="line">            i++;</span><br><span class="line">        j++;<span class="comment">//不管是否匹配长序列都回后移，</span></span><br><span class="line">    &#125;<span class="comment">//直到子序列到头达成匹配或者长序列到头匹配失败退出</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(i == n)<span class="comment">//此时判断子序列的指针有没有到头，以判断是否是子序列</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="lowbit-x-：返回x的最后一位1"><a href="#lowbit-x-：返回x的最后一位1" class="headerlink" title="lowbit( x )：返回x的最后一位1"></a>lowbit( x )：返回x的最后一位1</h3><p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 1010B		lowbit( x ) = 10B;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 101000B	lowbit( x ) = 1000B;</span><br></pre></td></tr></table></figure>


<h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x &amp; -x</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x &amp; -x; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数在c中是以补码的形式存在的，而负数的补码是正数取反+1。</span><br></pre></td></tr></table></figure>


<p>设x的二进制数是：			1010 . . . 100 . . . 0</p>
<p>则x取反后的二进制是：	0101 . . . 011 . . . 1</p>
<p>取反后+1的结果等于：	  0101 . . . 100 . . . 0</p>
<p>因此，在c中将一个数取反+1后再和这个数相与的结果就是，0101 . . . 100 . . . 0 ，前面因为取反和原数不一样，因此在与的过程中全部变0，后面因为一样就全部保留了。</p>
<h4 id="常用地方"><a href="#常用地方" class="headerlink" title="常用地方"></a>常用地方</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">求一个数的二进制中1的个数(奇偶校验？)</span><br></pre></td></tr></table></figure>


<h5 id="例题：801-二进制中1的个数"><a href="#例题：801-二进制中1的个数" class="headerlink" title="例题：801. 二进制中1的个数"></a>例题：801. 二进制中1的个数</h5><blockquote>
<p>给定一个长度为 n 的数列，请你求出数列中每个数的二进制表示中 1 的个数。</p>
<h4 id="输入格式-10"><a href="#输入格式-10" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n。</p>
<p>第二行包含 n 个整数，表示整个数列。</p>
<h4 id="输出格式-10"><a href="#输出格式-10" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 n 个整数，其中的第 ii 个数表示数列中的第 i 个数的二进制表示中 1 的个数。</p>
<h4 id="数据范围-10"><a href="#数据范围-10" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ n ≤ 100000,<br>0 ≤ 数列中元素的值 ≤ 10^9^</p>
<h4 id="输入样例：-10"><a href="#输入样例：-10" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

<h4 id="输出样例：-10"><a href="#输出样例：-10" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 2 1 2</span><br></pre></td></tr></table></figure>

<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> n, x, res = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"> <span class="keyword">while</span> (n -- )&#123;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">     <span class="keyword">while</span>(x)&#123;</span><br><span class="line">         x -= lowbit(x);<span class="comment">//每次减去最后一个1</span></span><br><span class="line">         res++;<span class="comment">//减一个计数器+1</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res);</span><br><span class="line">     res = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<h2 id="离散化（特指整数的有序的离散化）"><a href="#离散化（特指整数的有序的离散化）" class="headerlink" title="离散化（特指整数的有序的离散化）"></a>离散化（特指整数的有序的离散化）</h2><p>暂时回避</p>
<h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><blockquote>
<p>给定 n 个区间 [li,ri][li,ri]，要求合并所有有交集的区间。</p>
<p>注意如果在端点处相交，也算有交集。</p>
<p>输出合并完成后的区间个数。</p>
<p>例如：[1,3][1,3] 和 [2,6][2,6] 可以合并为一个区间 [1,6][1,6]。</p>
<h4 id="输入格式-11"><a href="#输入格式-11" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n。</p>
<p>接下来 n 行，每行包含两个整数 l 和 r。</p>
<h4 id="输出格式-11"><a href="#输出格式-11" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示合并区间完成后的区间个数。</p>
<h4 id="数据范围-11"><a href="#数据范围-11" class="headerlink" title="数据范围"></a>数据范围</h4><p>1 ≤ n ≤ 100000<br>−10^9^ ≤ li ≤ ri ≤ 10^9^</p>
<h4 id="输入样例：-11"><a href="#输入样例：-11" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">5 6</span><br><span class="line">7 8</span><br><span class="line">7 9</span><br></pre></td></tr></table></figure>

<h4 id="输出样例：-11"><a href="#输出样例：-11" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>我们知道区间的开头和结尾，可以开一个数组存下来</li>
<li>将所有区间进行排序，排序规则为左端点降序</li>
<li>依次检查每个区间的右端点，如果左端点超过已有记录，就证明是一个新的区间，res++;</li>
<li>如果右区间超过但左区间小于等于记录，就证明区间是连续的，刷新一下右端点即可</li>
<li>输出res</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, l, r;</span><br><span class="line"><span class="built_in">vector</span>&lt;PII&gt; nums;<span class="comment">//利用vector数组进行存储所有区间的左右端点，方便后续的排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sort的仿函数可写可不写，因为默认就是根据pair的键值（第一个值，左端点）进行升序排序的</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">MyCom</span><span class="params">(PII x, PII y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x.first &lt; y.first)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        nums.push_back(&#123; l,r &#125;);<span class="comment">//依次读入区间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行排序，要求左端点升序排序</span></span><br><span class="line">    <span class="comment">//sort(nums.begin(),nums.end(),MyCom);</span></span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给记录设置一个区间，要求这个区间比题目要求的所有的区间都要小</span></span><br><span class="line">    l = r = <span class="number">-1e9</span> - <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;<span class="comment">//区间个数，初始化成0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果区间左端点大于已有区间的右端点，证明两个区间不连续，区间数++，刷新区间</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt; nums[i].first) &#123;</span><br><span class="line">            l = nums[i].first;</span><br><span class="line">            r = nums[i].second;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//能到这里就证明，当前区间的左端点一定是小于等于记录的右端点，证明是连续的，只需要更新右端点即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; nums[i].second)</span><br><span class="line">        &#123;</span><br><span class="line">            r = nums[i].second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出答案</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="链表与邻接表：树与图的存储"><a href="#链表与邻接表：树与图的存储" class="headerlink" title="链表与邻接表：树与图的存储"></a>链表与邻接表：树与图的存储</h2><p>使用数组来模拟链表的存在，虽然会造成内存泄漏，但可以大幅提高速度。</p>
<p>因为c++中的new是非常耗时间的，因此在竞赛或者笔试的时候，不要使用传统的结构体链表。(一般的数据范围都在10^5以上，如果new的话必定会超时)</p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><blockquote>
<p>实现一个单链表，链表初始为空，支持三种操作：</p>
<ol>
<li>向链表头插入一个数；</li>
<li>删除第 k 个插入的数后面的数；</li>
<li>在第 k 个插入的数后插入一个数。</li>
</ol>
<p>现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。</p>
<p><strong>注意</strong>:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。</p>
<h4 id="输入格式-12"><a href="#输入格式-12" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 M，表示操作次数。</p>
<p>接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：</p>
<ol>
<li><code>H x</code>，表示向链表头插入一个数 x。</li>
<li><code>D k</code>，表示删除第 kk 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。</li>
<li><code>I k x</code>，表示在第 kk 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。</li>
</ol>
<h4 id="输出格式-12"><a href="#输出格式-12" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，将整个链表从头到尾输出。</p>
<h4 id="数据范围-12"><a href="#数据范围-12" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤M≤100000<br><strong>所有操作保证合法。</strong></p>
<h4 id="输入样例：-12"><a href="#输入样例：-12" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">H 9</span><br><span class="line">I 1 1</span><br><span class="line">D 1</span><br><span class="line">D 0</span><br><span class="line">H 6</span><br><span class="line">I 3 6</span><br><span class="line">I 4 5</span><br><span class="line">I 4 5</span><br><span class="line">I 3 4</span><br><span class="line">D 6</span><br></pre></td></tr></table></figure>

<h4 id="输出样例：-12"><a href="#输出样例：-12" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 4 6 5</span><br></pre></td></tr></table></figure></blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>类似于传统的结构体链表，不过改成用数组来模拟（变成静态链表）</p>
<p>分别开辟一个数组e，存储每个节点的数据；ne，存储每个节点的加一个节点的地址。e与ne数组的联系在于下标，换句话说就是，e[i] 与 ne[i] 是一组的。以及变量head，存储头节点的位置；idx，存储使用了多少个节点（idx始终指向第一个未被使用的节点）</p>
<p>当程序运行的时候需要进行初始化，将head置为-1，idx置为0。</p>
<p>对于头节点的插入操作，只需要简单的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_head</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  	e[idx] = x;<span class="comment">//将数据读入到节点</span></span><br><span class="line">		ne[idx] = head;<span class="comment">//将下一个节点的指针置为头指针指向的位置</span></span><br><span class="line">		head = idx ++;<span class="comment">//将头指针指向新插入的节点，并且数量++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于指定位置的插入，也很简单，可以在O(1)的时间内完成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">		e[idx] = x;<span class="comment">//同样读入到节点</span></span><br><span class="line">		ne[idx] = ne[k];<span class="comment">//将新节点的next指针指向第k个位置原本指向的位置</span></span><br><span class="line">		ne[k] = idx ++;<span class="comment">//将第k个位置的指针指向新加入的节点，同时idx++便于下一步操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于删除来说，就不需要再考虑空间的事了，可以直接的进行p-&gt;next &#x3D; p-&gt;next-&gt;next的操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">		ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但需要注意的是，如果要删除的节点是头节点，则需要这么做</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">del_head</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		head = ne[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于模拟链表的遍历，和传统链表也很相似：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">//i从头节点开始，直到遇到-1（head的初始化值）为止，i的下一位是ne[i]</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = head; i != <span class="number">-1</span> ; i = ne[i])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,e[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现代码-7"><a href="#实现代码-7" class="headerlink" title="实现代码"></a>实现代码</h4><p>需要注意的是，k需要-1.因为题是从1起，而数组是从0起</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//head 头节点的下标</span></span><br><span class="line"><span class="comment">//e[i] 节点i的值</span></span><br><span class="line"><span class="comment">//ne[i] 节点i的next指针是多少</span></span><br><span class="line"><span class="comment">//idx  存储当前已经用了多少</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    head = <span class="number">-1</span>;<span class="comment">//-1表示空</span></span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插入到头节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_to_head</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="comment">//idx存储了最新的节点可用的下标是什么</span></span><br><span class="line">    e[idx] = x;<span class="comment">//将x输入到e中新的节点</span></span><br><span class="line">    ne[idx] = head;<span class="comment">//将新的节点的指针指向head；</span></span><br><span class="line">    head = idx;<span class="comment">//将head的指针指向到新插入的头节点的位置</span></span><br><span class="line">    idx++;<span class="comment">//将idx的值++，方便下次使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插入到下标为k的节点的后面</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标是k的点的后一个点删掉</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        <span class="comment">//scanf(&quot;%c&quot;,&amp;op);</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//scanf(&quot;%d&quot;,&amp;x);</span></span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            add_to_head(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//scanf(&quot;%d&quot;, &amp;k);</span></span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>)<span class="comment">//特判一下删除头节点的情况</span></span><br><span class="line">                head = ne[head];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                remove(k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//scanf(&quot;%d%d&quot;, &amp;k, &amp;x);</span></span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            add(k - <span class="number">1</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head; i != <span class="number">-1</span> ; i = ne[i])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,e[i]);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>与单链表类似，只不过多了一个指针</p>
<h4 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h4><blockquote>
<p>实现一个双链表，双链表初始为空，支持 55 种操作：</p>
<ol>
<li>在最左侧插入一个数；</li>
<li>在最右侧插入一个数；</li>
<li>将第 k 个插入的数删除；</li>
<li>在第 k 个插入的数左侧插入一个数；</li>
<li>在第 k 个插入的数右侧插入一个数</li>
</ol>
<p>现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。</p>
<p><strong>注意</strong>:题目中第 k 个插入的数并不是指当前链表的第 kk 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。</p>
<h4 id="输入格式-13"><a href="#输入格式-13" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 M，表示操作次数。</p>
<p>接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：</p>
<ol>
<li><code>L x</code>，表示在链表的最左端插入数 x。</li>
<li><code>R x</code>，表示在链表的最右端插入数 x。</li>
<li><code>D k</code>，表示将第 k 个插入的数删除。</li>
<li><code>IL k x</code>，表示在第 k 个插入的数左侧插入一个数。</li>
<li><code>IR k x</code>，表示在第 k 个插入的数右侧插入一个数。</li>
</ol>
<h4 id="输出格式-13"><a href="#输出格式-13" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，将整个链表从左到右输出。</p>
<h4 id="数据范围-13"><a href="#数据范围-13" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤M≤100000<br>所有操作保证合法。</p>
<h4 id="输入样例：-13"><a href="#输入样例：-13" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">R 7</span><br><span class="line">D 1</span><br><span class="line">L 3</span><br><span class="line">IL 2 10</span><br><span class="line">D 3</span><br><span class="line">IL 2 7</span><br><span class="line">L 8</span><br><span class="line">R 9</span><br><span class="line">IL 4 7</span><br><span class="line">IR 2 2</span><br></pre></td></tr></table></figure>

<h4 id="输出样例：-13"><a href="#输出样例：-13" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 7 7 3 2 9</span><br></pre></td></tr></table></figure></blockquote>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>和单链表类似，一个存储数据的数组e[N]，一个存储当前节点的左侧的数组l[N]，当前节点的右侧的数组r[N]，和下一个节点的地址idx。</p>
<p>首先对数组进行初始化：一共有两个节点，下标分别是0和1，链表的最右边节点的下标是1，即 <code>r[0] = 1</code>；然后将最左边的节点设为0，即<code>l[1] = 0</code></p>
<p>对于插入到节点右侧的数据，可以进行如下操作：</p>
<ul>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将数据写入到新的节点</span><br></pre></td></tr></table></figure>

<ul>
<li>e[idx] &#x3D; x;</li>
</ul>
</li>
<li>将新创建的节点入队<ul>
<li>l[idx] &#x3D; k , r[idx] &#x3D; r[k];</li>
</ul>
</li>
<li>然后使得前后节点接受新插入的节点<ul>
<li>l[r[k]] &#x3D; idx  , r[k] &#x3D; idx;</li>
</ul>
</li>
<li>最后，idx++，为下次插入做准备</li>
</ul>
<p>对于插入到节点左侧的数据，可以视为对指定节点的前一个节点进行尾插操作，可以对上方教程进行复用</p>
<ul>
<li>insert(l[k],x);</li>
</ul>
<p>对于删除指定节点，可以直接修改前后指针即可。</p>
<ul>
<li>&#x2F;&#x2F;第k个节点右边的左侧不再是k，而是k之前的节点<ul>
<li><pre><code>l[r[k]] = l[k];
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- ```</span><br><span class="line">  //同理，第k个节点左边的右侧不再是k，而是k右边的节点。</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code>r[l[k]] = r[k];
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 实现代码</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">/*</span><br><span class="line">注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。</span><br><span class="line">*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5+10;</span><br><span class="line">int e[N],l[N],r[N],idx;</span><br><span class="line"></span><br><span class="line">//初始化</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    r[0] = 1;//链表的最右边是1</span><br><span class="line">    l[1] = 0;//最左边是0</span><br><span class="line">    idx = 2;//起始节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在第k个节点的右边插入一个元素</span><br><span class="line">void insert(int k,int x)</span><br><span class="line">&#123;</span><br><span class="line">    //将数据写入新的节点</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    //将新的节点连入链接</span><br><span class="line">    l[idx] = k;//新节点的左边是指定的位置</span><br><span class="line">    r[idx] = r[k];//新节点的右边是指定位置的右边</span><br><span class="line">    //将原链接指向新的节点</span><br><span class="line">    l[r[k]] = idx;//第k个节点后一个节点的左边变成新插入的节点</span><br><span class="line">    r[k] = idx;//第k个节点的右边变成新插入的节点</span><br><span class="line">    idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在第k个节点的左边插入一个节点</span><br><span class="line">void insert_front(int k,int x)</span><br><span class="line">&#123;</span><br><span class="line">    //第k个节点的左边，可以视作 l[k] ，因此可以写作：</span><br><span class="line">    insert(l[k],x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除第k个节点</span><br><span class="line">void remove(int k)</span><br><span class="line">&#123;</span><br><span class="line">    //第k个节点右边的左侧不再是k，而是k之前的节点</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">    //同理，第k个节点左边的右侧不再是k，而是k右边的节点。</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">  </span><br><span class="line">    int m;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    string op;</span><br><span class="line">    int k,x;</span><br><span class="line">    while(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; op;//读入每行的开头</span><br><span class="line">        //一次根据开头判断要干的事</span><br><span class="line">        if(op == &quot;L&quot;)//最左端插入，相当于在头节点的右侧插入</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            insert(0, x);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(op == &quot;R&quot;)//最右端插入，相当于在尾节点的左侧插入</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            insert_front(1, x );</span><br><span class="line">        &#125;</span><br><span class="line">        else if(op == &quot;D&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            remove(k + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(op == &quot;IL&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            insert_f(k + 1, x);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(op == &quot;IR&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            insert(k + 1,x);</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = r[0]; i != 1; i = r[i])</span><br><span class="line">        printf(&quot;%d &quot;,e[i]);</span><br><span class="line">  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="栈与队列：单调队列、单调栈"><a href="#栈与队列：单调队列、单调栈" class="headerlink" title="栈与队列：单调队列、单调栈"></a>栈与队列：单调队列、单调栈</h2><h3 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h3><h4 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h4><blockquote>
<p>实现一个栈，栈初始为空，支持四种操作：</p>
<ol>
<li><code>push x</code> – 向栈顶插入一个数 x；</li>
<li><code>pop</code> – 从栈顶弹出一个数；</li>
<li><code>empty</code> – 判断栈是否为空；</li>
<li><code>query</code> – 查询栈顶元素。</li>
</ol>
<p>现在要对栈进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。</p>
<h4 id="输入格式-14"><a href="#输入格式-14" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 M，表示操作次数。</p>
<p>接下来 M 行，每行包含一个操作命令，操作命令为 <code>push x</code>，<code>pop</code>，<code>empty</code>，<code>query</code> 中的一种。</p>
<h4 id="输出格式-14"><a href="#输出格式-14" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个 <code>empty</code> 和 <code>query</code> 操作都要输出一个查询结果，每个结果占一行。</p>
<p>其中，<code>empty</code> 操作的查询结果为 <code>YES</code> 或 <code>NO</code>，<code>query</code> 操作的查询结果为一个整数，表示栈顶元素的值。</p>
<h4 id="数据范围-14"><a href="#数据范围-14" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤M≤100000<br>1≤x≤10^9^<br>所有操作保证合法。</p>
<h4 id="输入样例：-14"><a href="#输入样例：-14" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">push 5</span><br><span class="line">query</span><br><span class="line">push 6</span><br><span class="line">pop</span><br><span class="line">query</span><br><span class="line">pop</span><br><span class="line">empty</span><br><span class="line">push 4</span><br><span class="line">query</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<h4 id="输出样例：-14"><a href="#输出样例：-14" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br><span class="line">YES</span><br><span class="line">4</span><br><span class="line">NO</span><br></pre></td></tr></table></figure></blockquote>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>首先用数组模拟一个栈，对栈的所有操作都可以转换成如下的操作：</p>
<ul>
<li>入栈：stk[++ tt] &#x3D; x;</li>
<li>出栈：tt –;</li>
<li>判断是否为空：if(tt &gt; 0) 不空 else 空</li>
<li>栈顶元素stk[tt]</li>
</ul>
<p>其中：stk数组就是模拟栈的数组，tt为栈顶元素的指针</p>
<h4 id="实现代码-8"><a href="#实现代码-8" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟栈的数组，栈顶指针（栈顶下标）</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    stk[++ tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈（弹出）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    tt --;</span><br><span class="line">    <span class="keyword">return</span> stk[tt];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空，空为真</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tt &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看栈顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> stk[tt];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m, x;</span><br><span class="line">    <span class="built_in">string</span> op;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;pop&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(empty())</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;query&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模拟队列"><a href="#模拟队列" class="headerlink" title="模拟队列"></a>模拟队列</h3><h4 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h4><blockquote>
<p>实现一个队列，队列初始为空，支持四种操作：</p>
<ol>
<li><code>push x</code> – 向队尾插入一个数 x；</li>
<li><code>pop</code> – 从队头弹出一个数；</li>
<li><code>empty</code> – 判断队列是否为空；</li>
<li><code>query</code> – 查询队头元素。</li>
</ol>
<p>现在要对队列进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。</p>
<h4 id="输入格式-15"><a href="#输入格式-15" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 M，表示操作次数。</p>
<p>接下来 M 行，每行包含一个操作命令，操作命令为 <code>push x</code>，<code>pop</code>，<code>empty</code>，<code>query</code> 中的一种。</p>
<h4 id="输出格式-15"><a href="#输出格式-15" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个 <code>empty</code> 和 <code>query</code> 操作都要输出一个查询结果，每个结果占一行。</p>
<p>其中，<code>empty</code> 操作的查询结果为 <code>YES</code> 或 <code>NO</code>，<code>query</code> 操作的查询结果为一个整数，表示队头元素的值。</p>
<h4 id="数据范围-15"><a href="#数据范围-15" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤M≤100000<br>1≤x≤10^9^<br>所有操作保证合法。</p>
<h4 id="输入样例：-15"><a href="#输入样例：-15" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">push 6</span><br><span class="line">empty</span><br><span class="line">query</span><br><span class="line">pop</span><br><span class="line">empty</span><br><span class="line">push 3</span><br><span class="line">push 4</span><br><span class="line">pop</span><br><span class="line">query</span><br><span class="line">push 6</span><br></pre></td></tr></table></figure>

<h4 id="输出样例：-15"><a href="#输出样例：-15" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">6</span><br><span class="line">YES</span><br><span class="line">4</span><br></pre></td></tr></table></figure></blockquote>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>和模拟栈类似，相比模拟栈多了一个队头指针，出队的时候用队头指针的后移实现；判断队空是由队头指针是否大于队尾指针实现。</p>
<h4 id="实现代码-9"><a href="#实现代码-9" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟队列的数组，队头，队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">1</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//需要注意的是，下标为0的地方是闲置不用的，模拟栈不需要考虑这点，但队列需要。</span></span><br><span class="line"><span class="comment">//因此，队列在空的情况下队头指针是大于队尾指针的（）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    q[++ tt] = x;<span class="comment">//先后移队尾指针，然后再将数据写入到队尾指针指向的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    hh ++;<span class="comment">//队头指针后移</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(hh &gt; tt)<span class="comment">//只要出现队头大于队尾的情况，就是空的。队头等于队尾的时候表示还有一个元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看队头元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">query</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> q[hh];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m, x;</span><br><span class="line">    <span class="built_in">string</span> op;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;pop&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(empty())</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;query&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><h4 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h4><blockquote>
<p>给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</p>
<h4 id="输入格式-16"><a href="#输入格式-16" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 N，表示数列长度。</p>
<p>第二行包含 N 个整数，表示整数数列。</p>
<h4 id="输出格式-16"><a href="#输出格式-16" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。</p>
<h4 id="数据范围-16"><a href="#数据范围-16" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤10^5^<br>1≤数列中元素≤10^9^</p>
<h4 id="输入样例：-16"><a href="#输入样例：-16" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 7 5</span><br></pre></td></tr></table></figure>

<h4 id="输出样例：-16"><a href="#输出样例：-16" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 3 -1 2 2</span><br></pre></td></tr></table></figure></blockquote>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>要求是左边第一个小的数（也可以是左&#x2F;右边 第一个 最大&#x2F;小的数），可以利用栈的特性实现。</p>
<ol>
<li>判断当前栈是否为空，如果不为空判断栈顶元素是否比输入的数小（或者大），不满足就出栈，直到栈空。</li>
<li>再次判断栈是否为空，如果不是空的，那么栈顶元素就是需要的了。如果栈空了，就证明没匹配到，输出-1</li>
<li>不管上面如何，将输入的数入栈，供下个数使用。</li>
</ol>
<h4 id="实现代码-10"><a href="#实现代码-10" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span>(tt != <span class="number">0</span> &amp;&amp; stk[tt] &gt;= x)<span class="comment">//如果栈不为空，同时栈顶元素大于等于当前的元素，那么栈顶元素就不会用到了，可以出栈了</span></span><br><span class="line">            tt --;</span><br><span class="line">        <span class="keyword">if</span>(tt != <span class="number">0</span>)<span class="comment">//如果栈仍然不为空，那么当前的栈顶的元素就是需要的数，直接输出</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; stk[tt] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">          </span><br><span class="line">        stk[++ tt] = x;<span class="comment">//把元素入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单调队列（滑动窗口）"><a href="#单调队列（滑动窗口）" class="headerlink" title="单调队列（滑动窗口）"></a>单调队列（滑动窗口）</h3><h4 id="例题-7"><a href="#例题-7" class="headerlink" title="例题"></a>例题</h4><blockquote>
<p>给定一个大小为 n≤10^6^ 的数组。</p>
<p>有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。</p>
<p>你只能在窗口中看到 k 个数字。</p>
<p>每次滑动窗口向右移动一个位置。</p>
<p>以下是一个例子：</p>
<p>该数组为 <code>[1 3 -1 -3 5 3 6 7]</code>，kk 为 33。</p>
<table>
<thead>
<tr>
<th align="left">窗口位置</th>
<th align="left">最小值</th>
<th align="left">最大值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[1 3 -1] -3 5 3 6 7</td>
<td align="left">-1</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">1 [3 -1 -3] 5 3 6 7</td>
<td align="left">-3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">1 3 [-1 -3 5] 3 6 7</td>
<td align="left">-3</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">1 3 -1 [-3 5 3] 6 7</td>
<td align="left">-3</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">1 3 -1 -3 [5 3 6] 7</td>
<td align="left">3</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">1 3 -1 -3 5 [3 6 7]</td>
<td align="left">3</td>
<td align="left">7</td>
</tr>
</tbody></table>
<p>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p>
<h4 id="输入格式-17"><a href="#输入格式-17" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含两行。</p>
<p>第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。</p>
<p>第二行有 n 个整数，代表数组的具体数值。</p>
<p>同行数据之间用空格隔开。</p>
<h4 id="输出格式-17"><a href="#输出格式-17" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出包含两个。</p>
<p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p>
<p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p>
<h4 id="输入样例：-17"><a href="#输入样例：-17" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure>

<h4 id="输出样例：-17"><a href="#输出样例：-17" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure></blockquote>
<h4 id="实现代码-11"><a href="#实现代码-11" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原始数据，单调队列</span></span><br><span class="line"><span class="type">int</span> a[N],q[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断队头是否已经滑出窗口</span></span><br><span class="line">        <span class="comment">//因为窗口只会后移一位，因此不需要循环</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh])</span><br><span class="line">            hh ++;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i])</span><br><span class="line">            tt --;</span><br><span class="line">      </span><br><span class="line">        q[++ tt] = i;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断队头是否已经滑出窗口</span></span><br><span class="line">        <span class="comment">//因为窗口只会后移一位，因此不需要循环</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh])</span><br><span class="line">            hh ++;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i])</span><br><span class="line">            tt --;</span><br><span class="line">      </span><br><span class="line">        q[++ tt] = i;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="他人题解1"><a href="#他人题解1" class="headerlink" title="他人题解1"></a>他人题解1</h4><blockquote>
<p>解题思路（以最大值为例）：</p>
<p>由于我们需要求出的是滑动窗口的最大值。</p>
<p>如果当前的滑动窗口中有两个下标 i 和 j ，其中i在j的左侧（i&lt;j），并且i对应的元素不大于j对应的元素（nums[i]≤nums[j]），则：</p>
<p>当滑动窗口向右移动时，只要 i 还在窗口中，那么 j 一定也还在窗口中。这是由于 i 在 j 的左侧所保证的。</p>
<p>因此，由于 nums[j] 的存在，nums[i] 一定不会是滑动窗口中的最大值了，我们可以将nums[i]永久地移除。</p>
<p>因此我们可以使用一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组nums中对应的值是严格单调递减的。</p>
<p>当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。</p>
<p>为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果新元素大于等于队尾元素，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。</p>
<p>由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。</p>
<p>窗口向右移动的时候。因此我们还需要不断从队首弹出元素保证队列中的所有元素都是窗口中的，因此当队头元素在窗口的左边的时候，弹出队头。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1000010;</span><br><span class="line">int a[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> int n, k;</span><br><span class="line"> cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"> for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];//读入数据</span><br><span class="line"> deque&lt;int&gt; q;</span><br><span class="line"> for(int i = 1; i &lt;= n; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     while(q.size() &amp;&amp; q.back() &gt; a[i]) //新进入窗口的值小于队尾元素，则队尾出队列</span><br><span class="line">         q.pop_back();</span><br><span class="line">     q.push_back(a[i]);//将新进入的元素入队</span><br><span class="line">     if(i - k &gt;= 1 &amp;&amp; q.front() == a[i - k])//若队头是否滑出了窗口，队头出队 </span><br><span class="line">         q.pop_front();</span><br><span class="line">     if(i &gt;= k)//当窗口形成，输出队头对应的值</span><br><span class="line">         cout &lt;&lt; q.front() &lt;&lt;&quot; &quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> q.clear();</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"> //最大值亦然</span><br><span class="line"> for(int i = 1; i &lt;= n; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     while(q.size() &amp;&amp; q.back() &lt; a[i]) q.pop_back();</span><br><span class="line">     q.push_back(a[i]);</span><br><span class="line">     if(i - k &gt;= 1 &amp;&amp; a[i - k] == q.front()) q.pop_front(); </span><br><span class="line">     if(i &gt;= k) cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：Hasity</span><br><span class="line">链接：https://www.acwing.com/solution/content/97229/</span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></blockquote>
<h4 id="他人题解2"><a href="#他人题解2" class="headerlink" title="他人题解2"></a>他人题解2</h4><blockquote>
<p>思路：</p>
<p>最小值和最大值分开来做，两个for循环完全类似，都做以下四步：</p>
<p>解决队首已经出窗口的问题;<br>解决队尾与当前元素a[i]不满足单调性的问题;<br>将当前元素下标加入队尾;<br>如果满足条件则输出结果;<br>需要注意的细节：</p>
<p>上面四个步骤中一定要先3后4，因为有可能输出的正是新加入的那个元素;<br>队列中存的是原数组的下标，取值时要再套一层，a[q[]];<br>算最大值前注意将hh和tt重置;<br>此题用cout会超时，只能用printf;<br>hh从0开始，数组下标也要从0开始。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[N], q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> n, k;</span><br><span class="line"> <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">     <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt; q[hh]) ++ hh;                  <span class="comment">// 若队首出窗口，hh加1</span></span><br><span class="line">     <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) -- tt;    <span class="comment">// 若队尾不单调，tt减1</span></span><br><span class="line">     q[++ tt] = i;                                  <span class="comment">// 下标加到队尾</span></span><br><span class="line">     <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);       <span class="comment">// 输出结果</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> hh = <span class="number">0</span>; tt = <span class="number">-1</span>;                                   <span class="comment">// 重置！</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt; q[hh]) ++ hh;</span><br><span class="line">     <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) -- tt;</span><br><span class="line">     q[++ tt] = i;</span><br><span class="line">     <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote>
<h2 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h2><h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h2 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h2><p>[li,ri]:</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chaoqijiang.github.io">棨</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chaoqijiang.github.io/2024/02/28/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">https://chaoqijiang.github.io/2024/02/28/基础算法与数据结构/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://chaoqijiang.github.io" target="_blank">柊</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/protected/">protected</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">基础算法</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post-share"><div class="social-share" data-image="/Image/avatar.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/01/31/linux%E4%B8%8B%E9%80%9A%E8%BF%87CURL%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0%E5%8A%9F%E8%83%BD/" title="linux下通过CURL实现自动签到功能"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">linux下通过CURL实现自动签到功能</div></div><div class="info-2"><div class="info-item-1">linux下通过CURL实现自动签到功能</div></div></div></a><a class="pagination-related" href="/2024/02/28/HTTP%20%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%97%E8%A1%A8/" title="HTTP 状态码列表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">HTTP 状态码列表</div></div><div class="info-2"><div class="info-item-1">HTTP 状态码列表</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2022/09/08/%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%B1%BB_%E6%80%9D%E6%83%B3_%E6%95%88%E7%8E%87/" title="排序的总类 思想 效率"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-08</div><div class="info-item-2">排序的总类 思想 效率</div></div><div class="info-2"><div class="info-item-1">各类排序算法的介绍，包括思想、效率等。</div></div></div></a><a class="pagination-related" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E8%AF%95%E9%A2%98%E7%94%9F%E6%88%90/" title="AI提示词_试题生成"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-08</div><div class="info-item-2">AI提示词_试题生成</div></div><div class="info-2"><div class="info-item-1">AI提示词，用于根据提示信息生成对应的试题，帮助学习者检验理解深度。</div></div></div></a><a class="pagination-related" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%9F%E6%88%90/" title="AI提示词_学习笔记生成"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-08</div><div class="info-item-2">AI提示词_学习笔记生成</div></div><div class="info-2"><div class="info-item-1">AI提示词，用于引导AI生成学习笔记，根据提示的设定，对没有基础背景背景的小白生成学习笔记。</div></div></div></a><a class="pagination-related" href="/2023/06/07/ESP8266%E5%BC%95%E8%84%9A%E8%AF%B4%E6%98%8E/" title="ESP8266引脚说明"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-07</div><div class="info-item-2">ESP8266引脚说明</div></div><div class="info-2"><div class="info-item-1">ESP8266引脚说明</div></div></div></a><a class="pagination-related" href="/2023/12/01/Docker%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" title="Docker基础教程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-01</div><div class="info-item-2">Docker基础教程</div></div><div class="info-2"><div class="info-item-1">Docker基础教程</div></div></div></a><a class="pagination-related" href="/2023/06/07/ESP8266%E7%9B%B8%E5%85%B3%E6%A1%88%E4%BE%8B%E7%AC%94%E8%AE%B0/" title="ESP8266相关案例笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-07</div><div class="info-item-2">ESP8266相关案例笔记</div></div><div class="info-2"><div class="info-item-1">ESP8266相关案例笔记</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/Image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">棨</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:chaoqijiang@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">基础算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B3%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%88%86%E6%B2%BB%E3%80%82"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">思想：基于分治。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%EF%BC%9A%E5%AF%B9%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">实现代码：对数组进行排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.1.1.2.1.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-C-%EF%BC%9A"><span class="toc-number">1.1.1.2.2.</span> <span class="toc-text">C&#x2F;C++：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java"><span class="toc-number">1.1.1.2.3.</span> <span class="toc-text">Java</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B3%EF%BC%9A%E4%BE%9D%E7%84%B6%E6%98%AF%E5%88%86%E6%B2%BB"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">思想：依然是分治</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%EF%BC%9A%E5%AF%B9%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F-1"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">实现代码：对数组进行排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-1"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-C"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">C&#x2F;C++</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%ACK%E4%B8%AA%E6%95%B0-%E7%AC%ACK%E5%B0%8F%E7%9A%84%E6%95%B0%EF%BC%88%E5%BF%AB%E6%8E%92-%E4%BA%8C%E5%88%86%EF%BC%89"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">第K个数&#x2F;第K小的数（快排+二分）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%ACk%E4%B8%AA%E6%95%B0"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">第k个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">数据范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">输入样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A"><span class="toc-number">1.1.3.7.</span> <span class="toc-text">输出样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.1.3.8.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">1.1.3.9.</span> <span class="toc-text">实现代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86"><span class="toc-number">1.3.</span> <span class="toc-text">二分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">整数二分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B3%EF%BC%9A%E6%9C%AC%E8%B4%A8%E6%98%AF%E6%89%BE%E8%BE%B9%E7%95%8C"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">思想：本质是找边界</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-number">1.3.1.1.1.</span> <span class="toc-text">模板的使用说明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">数的范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-1"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-1"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-1"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">数据范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A-1"><span class="toc-number">1.3.1.7.</span> <span class="toc-text">输入样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A-1"><span class="toc-number">1.3.1.8.</span> <span class="toc-text">输出样例：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-1"><span class="toc-number">1.3.1.8.1.</span> <span class="toc-text">实现代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E4%BA%8C%E5%88%86"><span class="toc-number">1.3.2.</span> <span class="toc-text">浮点二分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">数的三次方根</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-2"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-2"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-2"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">数据范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A-2"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">输入样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A-2"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">输出样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BA%8C%E5%88%86%E6%B3%95%E6%B1%82%E7%AE%97%E6%95%B0%E6%A0%B9%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9A"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">用二分法求算数根的好处：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.4.</span> <span class="toc-text">高精度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-number">1.4.1.</span> <span class="toc-text">两个大整数相加</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">具体实现思想：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-2"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">实现代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8stl%E5%BA%93"><span class="toc-number">1.4.1.2.1.</span> <span class="toc-text">使用stl库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%99%AE%E9%80%9A%E7%9A%84char%E6%95%B0%E7%BB%84%E5%AE%8C%E6%88%90"><span class="toc-number">1.4.1.2.2.</span> <span class="toc-text">使用普通的char数组完成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9B%B8%E5%87%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">两个大整数相减</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%80%9D%E6%83%B3"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">具体实现思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-3"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">实现代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8stl%E5%BA%93-1"><span class="toc-number">1.4.2.2.1.</span> <span class="toc-text">使用stl库</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B8%8E%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E6%95%B4%E6%95%B0%E7%9B%B8%E4%B9%98"><span class="toc-number">1.4.3.</span> <span class="toc-text">一个大整数与一个普通整数相乘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%80%9D%E6%83%B3-1"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">具体实现思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-4"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">实现代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-2"><span class="toc-number">1.4.3.2.1.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8stl%E5%BA%93-2"><span class="toc-number">1.4.3.2.2.</span> <span class="toc-text">使用stl库</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B8%8E%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E6%95%B4%E6%95%B0%E7%9B%B8%E9%99%A4"><span class="toc-number">1.4.4.</span> <span class="toc-text">一个大整数与一个普通整数相除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%80%9D%E6%83%B3-2"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">具体实现思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-5"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">实现代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-3"><span class="toc-number">1.4.4.2.1.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8stl%E5%BA%93-3"><span class="toc-number">1.4.4.2.2.</span> <span class="toc-text">使用stl库</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86"><span class="toc-number">1.5.</span> <span class="toc-text">前缀和与差分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%88%E4%B8%80%E7%BB%B4%EF%BC%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">前缀和（一维）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">计算方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.5.1.3.1.</span> <span class="toc-text">前缀和预处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.5.1.3.2.</span> <span class="toc-text">使用前缀和</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.5.1.5.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-4"><span class="toc-number">1.5.1.6.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%9A795-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.5.1.7.</span> <span class="toc-text">例题：795.前缀和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-3"><span class="toc-number">1.5.1.8.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-3"><span class="toc-number">1.5.1.9.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-3"><span class="toc-number">1.5.1.10.</span> <span class="toc-text">数据范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A-3"><span class="toc-number">1.5.1.11.</span> <span class="toc-text">输入样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A-3"><span class="toc-number">1.5.1.12.</span> <span class="toc-text">输出样例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%88%E4%BA%8C%E7%BB%B4%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">前缀和（二维）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E7%9F%A9%E9%98%B5%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E5%85%AC%E5%BC%8F"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">前缀和矩阵的预处理公式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">区间和的计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-5"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%9A796-%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">例题：796. 子矩阵的和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-4"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-4"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-4"><span class="toc-number">1.5.2.7.</span> <span class="toc-text">数据范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A-4"><span class="toc-number">1.5.2.8.</span> <span class="toc-text">输入样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A-4"><span class="toc-number">1.5.2.9.</span> <span class="toc-text">输出样例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%EF%BC%88%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E9%80%86%E8%BF%90%E7%AE%97%EF%BC%89"><span class="toc-number">1.5.3.</span> <span class="toc-text">差分（前缀和的逆运算）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">差分的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">一维差分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">1.5.3.2.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-6"><span class="toc-number">1.5.3.2.2.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-%EF%BC%9A797-%E5%B7%AE%E5%88%86"><span class="toc-number">1.5.3.2.3.</span> <span class="toc-text">例题 ：797. 差分</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-5"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-5"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-5"><span class="toc-number">1.5.3.5.</span> <span class="toc-text">数据范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A-5"><span class="toc-number">1.5.3.6.</span> <span class="toc-text">输入样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A-5"><span class="toc-number">1.5.3.7.</span> <span class="toc-text">输出样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="toc-number">1.5.3.8.</span> <span class="toc-text">二维差分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">1.5.3.8.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-7"><span class="toc-number">1.5.3.8.2.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-number">1.5.3.8.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-6"><span class="toc-number">1.5.3.9.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-6"><span class="toc-number">1.5.3.10.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-6"><span class="toc-number">1.5.3.11.</span> <span class="toc-text">数据范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A-6"><span class="toc-number">1.5.3.12.</span> <span class="toc-text">输入样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A-6"><span class="toc-number">1.5.3.13.</span> <span class="toc-text">输出样例：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.</span> <span class="toc-text">双指针算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.6.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-8"><span class="toc-number">1.6.2.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B1%EF%BC%9A%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%B0%86%E5%85%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%AA%E5%8D%95%E8%AF%8D%E8%BE%93%E5%87%BA"><span class="toc-number">1.6.3.</span> <span class="toc-text">样例1：给定一个字符串 将其转换成一个个单词输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B2%EF%BC%9A799-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.6.4.</span> <span class="toc-text">样例2：799. 最长连续不重复子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">实现思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E9%A2%98%E7%9B%AE%E5%8F%8A%E4%BB%A3%E7%A0%81"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">具体题目及代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-7"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-7"><span class="toc-number">1.6.4.4.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-7"><span class="toc-number">1.6.4.5.</span> <span class="toc-text">数据范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A-7"><span class="toc-number">1.6.4.6.</span> <span class="toc-text">输入样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A-7"><span class="toc-number">1.6.4.7.</span> <span class="toc-text">输出样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%96%E4%BA%BA%E9%A2%98%E8%A7%A3"><span class="toc-number">1.6.4.8.</span> <span class="toc-text">他人题解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B3%EF%BC%9A800-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-number">1.6.5.</span> <span class="toc-text">样例3：800. 数组元素的目标和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-8"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-8"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-8"><span class="toc-number">1.6.5.3.</span> <span class="toc-text">数据范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A-8"><span class="toc-number">1.6.5.4.</span> <span class="toc-text">输入样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A-8"><span class="toc-number">1.6.5.5.</span> <span class="toc-text">输出样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-1"><span class="toc-number">1.6.5.6.</span> <span class="toc-text">实现思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">1.6.5.7.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B4%EF%BC%9A2816-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.6.6.</span> <span class="toc-text">样例4：2816. 判断子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-9"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-9"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-9"><span class="toc-number">1.6.6.3.</span> <span class="toc-text">数据范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A-9"><span class="toc-number">1.6.6.4.</span> <span class="toc-text">输入样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A-9"><span class="toc-number">1.6.6.5.</span> <span class="toc-text">输出样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-2"><span class="toc-number">1.6.6.6.</span> <span class="toc-text">实现思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-6"><span class="toc-number">1.6.6.7.</span> <span class="toc-text">实现代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">1.7.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lowbit-x-%EF%BC%9A%E8%BF%94%E5%9B%9Ex%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%BD%8D1"><span class="toc-number">1.7.1.</span> <span class="toc-text">lowbit( x )：返回x的最后一位1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%9C%B0%E6%96%B9"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">常用地方</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%9A801-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">1.7.1.3.1.</span> <span class="toc-text">例题：801. 二进制中1的个数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-10"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-10"><span class="toc-number">1.7.1.5.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-10"><span class="toc-number">1.7.1.6.</span> <span class="toc-text">数据范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A-10"><span class="toc-number">1.7.1.7.</span> <span class="toc-text">输入样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A-10"><span class="toc-number">1.7.1.8.</span> <span class="toc-text">输出样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">1.7.1.9.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96%EF%BC%88%E7%89%B9%E6%8C%87%E6%95%B4%E6%95%B0%E7%9A%84%E6%9C%89%E5%BA%8F%E7%9A%84%E7%A6%BB%E6%95%A3%E5%8C%96%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">离散化（特指整数的有序的离散化）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6"><span class="toc-number">1.9.</span> <span class="toc-text">区间合并</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-11"><span class="toc-number">1.9.0.1.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-11"><span class="toc-number">1.9.0.2.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-11"><span class="toc-number">1.9.0.3.</span> <span class="toc-text">数据范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A-11"><span class="toc-number">1.9.0.4.</span> <span class="toc-text">输入样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A-11"><span class="toc-number">1.9.0.5.</span> <span class="toc-text">输出样例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">1.9.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-number">1.9.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%9A%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">2.1.</span> <span class="toc-text">链表与邻接表：树与图的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-12"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-12"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-12"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">数据范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A-12"><span class="toc-number">2.1.1.5.</span> <span class="toc-text">输入样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A-12"><span class="toc-number">2.1.1.6.</span> <span class="toc-text">输出样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-number">2.1.1.7.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-7"><span class="toc-number">2.1.1.8.</span> <span class="toc-text">实现代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">双链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-3"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-13"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-13"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-13"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">数据范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A-13"><span class="toc-number">2.1.2.5.</span> <span class="toc-text">输入样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A-13"><span class="toc-number">2.1.2.6.</span> <span class="toc-text">输出样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-number">2.1.2.7.</span> <span class="toc-text">思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%EF%BC%9A%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E3%80%81%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">2.2.</span> <span class="toc-text">栈与队列：单调队列、单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E6%A0%88"><span class="toc-number">2.2.1.</span> <span class="toc-text">模拟栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-4"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-14"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-14"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-14"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">数据范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A-14"><span class="toc-number">2.2.1.5.</span> <span class="toc-text">输入样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A-14"><span class="toc-number">2.2.1.6.</span> <span class="toc-text">输出样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-number">2.2.1.7.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-8"><span class="toc-number">2.2.1.8.</span> <span class="toc-text">实现代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97"><span class="toc-number">2.2.2.</span> <span class="toc-text">模拟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-5"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-15"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-15"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-15"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">数据范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A-15"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">输入样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A-15"><span class="toc-number">2.2.2.6.</span> <span class="toc-text">输出样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-number">2.2.2.7.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-9"><span class="toc-number">2.2.2.8.</span> <span class="toc-text">实现代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">2.2.3.</span> <span class="toc-text">单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-6"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-16"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-16"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4-16"><span class="toc-number">2.2.3.4.</span> <span class="toc-text">数据范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A-16"><span class="toc-number">2.2.3.5.</span> <span class="toc-text">输入样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A-16"><span class="toc-number">2.2.3.6.</span> <span class="toc-text">输出样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-number">2.2.3.7.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-10"><span class="toc-number">2.2.3.8.</span> <span class="toc-text">实现代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89"><span class="toc-number">2.2.4.</span> <span class="toc-text">单调队列（滑动窗口）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-7"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-17"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-17"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A-17"><span class="toc-number">2.2.4.4.</span> <span class="toc-text">输入样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A-17"><span class="toc-number">2.2.4.5.</span> <span class="toc-text">输出样例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-11"><span class="toc-number">2.2.4.6.</span> <span class="toc-text">实现代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%96%E4%BA%BA%E9%A2%98%E8%A7%A31"><span class="toc-number">2.2.4.7.</span> <span class="toc-text">他人题解1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%96%E4%BA%BA%E9%A2%98%E8%A7%A32"><span class="toc-number">2.2.4.8.</span> <span class="toc-text">他人题解2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmp"><span class="toc-number">2.3.</span> <span class="toc-text">kmp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie"><span class="toc-number">2.4.</span> <span class="toc-text">Trie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">2.5.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">2.6.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash%E8%A1%A8"><span class="toc-number">2.7.</span> <span class="toc-text">Hash表</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/12/Hexo%E6%96%B0%E5%A2%9E%E5%88%86%E7%B1%BB%E6%A0%87%E7%AD%BE%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E8%AF%A6%E8%A7%A3/" title="Hexo 新增分类、标签与自定义页面详解">Hexo 新增分类、标签与自定义页面详解</a><time datetime="2025-10-12T05:46:03.000Z" title="发表于 2025-10-12 13:46:03">2025-10-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E9%80%9A%E7%94%A8%E8%93%9D%E5%9B%BE/" title="高可用高并发后端架构通用蓝图">高可用高并发后端架构通用蓝图</a><time datetime="2025-10-08T15:42:00.000Z" title="发表于 2025-10-08 23:42:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E8%AF%95%E9%A2%98%E7%94%9F%E6%88%90/" title="AI提示词_试题生成">AI提示词_试题生成</a><time datetime="2025-10-08T15:15:00.000Z" title="发表于 2025-10-08 23:15:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%9F%E6%88%90/" title="AI提示词_学习笔记生成">AI提示词_学习笔记生成</a><time datetime="2025-10-08T15:15:00.000Z" title="发表于 2025-10-08 23:15:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/Golang_swag/" title="Golang swag 库">Golang swag 库</a><time datetime="2025-10-08T15:07:00.000Z" title="发表于 2025-10-08 23:07:00">2025-10-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/Image/topImage.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By 棨</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>