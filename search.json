[{"title":"Hexo 新增分类、标签与自定义页面详解","url":"/2025/10/12/Hexo新增分类标签与自定义页面详解/","content":"\n\n本文介绍如何在 Hexo 博客中创建「分类（categories）」「标签（tags）」页面，以及如何扩展出一个「友情链接」等自定义页面。内容基于 Butterfly 主题实测整理。\n\n---\n\n##  一、Hexo 原生动态页面机制\n\nHexo 本身内置 4 种可自动更新的动态页面：\n\n| 页面类型               | 是否自动更新 | 说明                       |\n| ---------------------- | ------------ | -------------------------- |\n| `index`（首页）        | 是           | 自动列出文章（分页）       |\n| `archives`（归档页）   | 是           | 自动按时间归档             |\n| `categories`（分类页） | 是           | 自动根据文章头部的分类生成 |\n| `tags`（标签页）       | 是           | 自动根据文章头部的标签生成 |\n\n这四类页面不需要你手动维护内容，Hexo 在生成站点时会自动扫描所有文章的 Front Matter（头部注解）并动态更新。\n\n---\n\n## 二、创建分类与标签页面\n\n在博客根目录执行：\n\n```bash\nhexo new page categories\nhexo new page tags\n```\n\n系统会生成：\n\n```bash\nsource/categories/index.md\nsource/tags/index.md\n```\n\n修改内容如下：\n\n### categories 页面\n\n```yaml\n---\ntitle: 分类\ndate: 2025-10-12 12:00:00\ntype: categories\n---\n```\n\n### tags 页面\n\n```yaml\n---\ntitle: 标签\ndate: 2025-10-12 12:00:00\ntype: tags\n---\n```\n\n> 注意：type: 必须写成 categories 与 tags，否则主题无法识别。\n\n## 三、配置 Butterfly 菜单\n\n在 `_config.butterfly.yml` 中添加：\n\n```yaml\nmenu:\n  home: / || fa fa-home\n  archives: /archives/ || fa fa-archive\n  categories: /categories/ || fa fa-folder-open\n  tags: /tags/ || fa fa-tags\n  about: /about/ || fa fa-user\n```\n\n执行以下命令重新生成：\n\n```bash\nhexo clean\nhexo g\nhexo s\n```\n\n\n\n访问：\n\nhttp://localhost:4000/categories/\n\nhttp://localhost:4000/tags/\n\n即可看到页面。\n\n## 四、关于自定义页面（例如友情链接）\n\n假设要新增一个“友情链接”页：\n\n```bash\nhexo new page links\n```\n\n生成文件：\n\n```bash\nsource/links/index.md\n```\n\n默认内容为：\n\n```yaml\n---\ntitle: 友情链接\ndate: 2025-10-12 12:00:00\n---\n```\n\n此页面为 **静态页面**，你需要自己在 Markdown 中写内容：\n\n```\n# 友情链接\n\n- [我的 GitHub](https://github.com/hurri)\n- [Hexo 官网](https://hexo.io/)\n- [开源中国](https://www.oschina.net/)\n```\n\nHexo 会在生成时将其转成静态 HTML，但不会自动更新。\n\n-----\n\n## 五、让自定义页面实现“自动更新”\n\n通过 `_data/links.yml` 自动生成\n\nButterfly 支持通过数据文件方式维护友情链接。\n\n1. 新建文件：`source/_data/links.yml`\n\n   ```\n   - name: 我的GitHub\n     link: https://github.com/hurri\n     avatar: https://avatars.githubusercontent.com/u/1234567\n     descr: 开发与分享\n   - name: Hexo 官网\n     link: https://hexo.io/\n     avatar: https://hexo.io/icon.png\n     descr: 博客框架\n   ```\n\n2. 编辑 `source/links/index.md`\n\n   ```\n   ---\n   title: 友情链接\n   date: 2025-10-12 12:00:00\n   type: link\n   layout: links\n   ---\n   ```\n\n3. 在 `_config.butterfly.yml` 中启用：\n\n   ```\n   link:\n     enable: true\n     data: links.yml\n   ```\n\n> 这样每次你修改 `_data/links.yml` 并执行 `hexo g`，页面会自动更新，无需再编辑 Markdown。\n\n------\n\n## 六、总结对比\n\n| 页面类型                                     | 来源            | 是否自动更新 | 更新方式               |\n| -------------------------------------------- | --------------- | ------------ | ---------------------- |\n| `index` / `archives` / `categories` / `tags` | Hexo 内置生成器 | 自动         | 文章变化时自动生成     |\n| 自定义静态页（如 links、about）              | 用户创建        | 手动         | 编辑 `index.md`        |\n| 自定义带模板页                               | 主题或插件      | 自动         | 从 `_data/` 或逻辑渲染 |\n\n------\n\n## 七、推荐实践\n\n- 分类 / 标签 / 归档页 → 用 `type:` 自动生成\n- 友情链接 / 导航页 → 用 `_data/*.yml` 文件维护\n- 特殊展示页（项目展示、作品集） → 自定义 `layout` 模板\n\n这样既能保持自动化，又能保持整洁可维护的结构。\n\n\n","tags":["protected","Hexo","Butterfly","博客运维"],"categories":["Hexo"]},{"title":"高可用高并发后端架构通用蓝图","url":"/2025/10/08/高可用高并发后端架构通用蓝图/","content":"\n# 核心设计原则\n\n在深入细节之前，整个架构遵循以下几个核心原则：\n\n1.  **无单点（No Single Point of Failure）**: 系统中任何一个组件的故障都不会导致整个系统瘫痪。所有服务和数据存储都必须是集群化的或有冗余备份。\n2.  **水平扩展（Horizontal Scaling / Scale-Out）**: 当负载增加时，可以通过简单地增加更多服务器节点来提升系统的处理能力，而不是升级单个服务器的硬件（垂直扩展）。\n3.  **服务拆分与隔离（Decoupling & Isolation）**: 将庞大的单体应用拆分为更小、更专注的服务。服务之间的故障不会相互影响，可以独立部署和扩展。\n4.  **异步化（Asynchronous Communication）**: 对于非核心、耗时的操作，采用消息队列进行异步处理，可以削峰填谷，提高系统的响应速度和吞吐量。\n5.  **数据分片与多副本（Sharding & Replication）**: 对海量数据进行分片存储以分散压力，同时为数据创建多个副本以保证高可用和容灾。\n\n---\n\n\n\n# 架构笔记：一次请求的旅程\n\n## 概览\n\n### 1. 客户端与网络接入层 (Client & Edge)\n\n这是用户请求的起点，也是系统抵御外部风险和加速内容分发的第一道防线。\n\n*   **核心职责**:\n    *   解析域名，将用户流量导向正确的入口。\n    *   缓存静态资源（图片、JS、CSS），减少对后端服务器的请求。\n    *   抵御网络攻击（如DDoS、SQL注入）。\n*   **高可用/高并发策略**:\n    *   **DNS 负载均衡**: 配置多个IP地址，DNS服务可以根据负载或地理位置返回一个最优的IP。\n    *   **CDN (内容分发网络)**: 将静态资源分发到全球各地的边缘节点，用户就近访问，极大提升加载速度并分担源站压力。\n    *   **WAF (Web应用防火墙)**: 在流量进入系统前进行过滤和清洗。\n*   **主流技术**: Cloudflare, AWS CloudFront, Akamai, F5, 各大云厂商的DNS/WAF服务。\n\n### 2. 流量接入层 (Traffic Ingress)\n\n流量穿过边缘网络后，到达我们自己数据中心的入口。\n\n*   **核心职责**:\n    *   作为所有内部服务的统一入口。\n    *   SSL/TLS 卸载（解密HTTPS流量）。\n    *   将请求根据URL路径、域名等规则，均匀地转发到后端的API网关集群。\n*   **高可用/高并发策略**:\n    *   **负载均衡器集群**: 使用至少两台负载均衡器组成集群（例如，通过 **Keepalived + VIP** 实现主备切换），避免单点故障。\n    *   **健康检查 (Health Checks)**: 负载均衡器会持续检查后端网关节点的健康状况，自动剔除故障节点，将流量转发到健康节点。\n    *   **四层/七层负载均衡**: L4（TCP/UDP）转发速度快，L7（HTTP）可以根据请求内容做更智能的路由。\n*   **主流技术**: Nginx, HAProxy, F5 BIG-IP, 各大云厂商的负载均衡器（ALB/NLB）。\n\n### 3. API网关层 (API Gateway)\n\n网关是微服务架构的“门面”，处理所有服务的通用横切关注点。\n\n*   **核心职责**:\n    *   **路由**: 将请求精确地路由到对应的后端业务服务。\n    *   **认证与授权**: 校验用户身份（Token/JWT），确保用户有权限访问该API。\n    *   **限流与熔断**: 防止突发流量冲垮后端服务，当某个服务不可用时快速失败（熔断），避免雪崩效应。\n    *   **日志、监控、协议转换**等。\n*   **高可用/高并发策略**:\n    *   **无状态与集群部署**: 网关本身是无状态的，可以轻松地水平扩展多个节点。\n    *   **服务发现**: 网关从**服务注册中心**动态获取后端服务的地址列表，实现自动的服务上下线感知。\n    *   **熔断降级**: 集成Hystrix, Sentinel等库，实现对下游服务的保护。\n*   **主流技术**: Kong, Spring Cloud Gateway, Zuul, Traefik。\n\n### 4. 业务服务层 (Application Services)\n\n这是实现核心业务逻辑的地方。\n\n*   **核心职责**: 处理具体的业务请求，如订单处理、用户管理、商品查询等。\n*   **高可用/高并发策略**:\n    *   **微服务化**: 将复杂的业务拆分成多个独立的服务，每个服务都可以独立部署、扩展和容错。\n    *   **无状态服务**: 将会话状态等信息存储在外部的缓存或数据库中，使得任何一个服务节点都可以处理任意用户的请求，为水平扩展奠定基础。\n    *   **容器化与编排**: 使用 Docker 将服务打包成镜像，通过 Kubernetes (K8s) 等平台进行自动化部署、扩缩容和故障自愈。\n*   **主流技术**:\n    *   **服务框架**: Spring Boot (Java), Django/Flask (Python), Express (Node.js), Go-kit/Gin (Go)。\n    *   **服务治理**: Spring Cloud (Java), Istio (Service Mesh)。\n    *   **容器编排**: Kubernetes, Docker Swarm。\n\n### 5. 数据与状态层 (Data & State)\n\n这是系统的心脏，数据的可靠性和性能直接决定了整个系统的质量。\n\n*   **缓存集群 (Cache Cluster)**:\n    *   **职责**: 缓存热点数据，降低对数据库的访问压力，提升响应速度。\n    *   **HA/HC策略**: 使用 **Redis Sentinel/Cluster** 或 **Memcached** 集群。通过数据分片分散存储压力，通过主从复制/多副本保证数据可用性。\n*   **消息队列集群 (Message Queue Cluster)**:\n    *   **职责**: 服务间解耦、异步处理、流量削峰。例如，用户下单后，将“生成订单”、“扣减库存”、“发送通知”等消息放入队列，由下游服务异步消费。\n    *   **HA/HC策略**: 使用 **Kafka, RabbitMQ, RocketMQ** 等集群。Topic/Queue可以有多个分区（Partition）以支持高并发读写，数据有多副本保证不丢失。\n*   **数据库集群 (Database Cluster)**:\n    *   **职责**: 持久化存储核心业务数据。\n    *   **HA/HC策略**:\n        *   **读写分离 (Read/Write Splitting)**: 采用主从（Master-Slave）架构，主库负责写，多个从库负责读，分散读取压力。\n        *   **分库分表 (Sharding)**: 当单表数据量过大时，将数据水平拆分到多个库或多个表中。\n        *   **高可用切换**: 使用MHA, Galera Cluster, 或云数据库的HA方案实现主库故障时自动切换。\n    *   **主流技术**: MySQL, PostgreSQL, TiDB (分布式数据库)。\n*   **对象存储/搜索引擎**:\n    *   **职责**: **对象存储** (S3, MinIO) 用于存储图片、视频等非结构化大文件。**搜索引擎** (Elasticsearch, Solr) 提供复杂的全文检索功能。\n    *   **HA/HC策略**: 这些系统天生就是分布式的，通过增加节点即可线性扩展，数据自动分片和复制。\n\n### 6. 运维与可观测性 (Operations & Observability)\n\n这是保证系统稳定运行的“眼睛”和“大脑”。\n\n*   **集中式日志系统 (Centralized Logging)**:\n    *   **职责**: 收集所有服务节点的日志，提供统一的查询和分析界面，便于快速定位问题。\n    *   **技术栈**: **ELK** (Elasticsearch, Logstash, Kibana) 或 **EFK** (Elasticsearch, Fluentd, Kibana)。\n*   **监控与告警系统 (Monitoring & Alerting)**:\n    *   **职责**: 持续收集系统各项性能指标（CPU, 内存, QPS, 延迟等），通过仪表盘进行可视化展示，并在指标异常时自动告警。\n    *   **技术栈**: **Prometheus + Grafana** (事实标准), Zabbix。\n*   **分布式追踪系统 (Distributed Tracing / APM)**:\n    *   **职责**: 跟踪一个请求在多个微服务之间的完整调用链，帮助分析性能瓶颈和排查分布式系统中的复杂问题。\n    *   **技术栈**: SkyWalking, Jaeger, Zipkin。\n\n通过以上六层的协同工作，我们构建了一个具有弹性、容错和高性能的后端系统，能够从容应对高并发的挑战，并保证在部分组件失效时，核心服务依然可用。\n\n\n\n---\n\n## **第一章：客户端与网络接入层 (Client & Network Access Layer)**\n\n### **1.1 本章定位：系统的“护城河”与“先锋部队”**\n\n这是整个系统架构的最外层，是用户请求到达我们应用的第一站。你可以把它想象成一座城堡的**护城河**与**城墙**。它的核心目标有两个：\n\n1.  **加速 (Acceleration)**: 让合法的、常规的请求尽可能快地得到响应。\n2.  **防御 (Defense)**: 将非法的、恶意的攻击流量阻挡在外，保护内部核心服务的安全和稳定。\n\n在高并发场景下，如果这一层设计不当，海量请求和潜在攻击会瞬间冲垮后端的服务器，谈高可用就无从说起。因此，这一层是实现高可用、高并发的**第一道防线**。\n\n---\n\n### **1.2 核心组件详解**\n\n##### **A. DNS (Domain Name System) - 智能交通调度员**\n\n*   **核心职责**:\n    将人类易于记忆的域名（如 `www.example.com`）解析成机器能够识别的IP地址（如 `93.184.216.34`）。这是互联网的“电话簿”。\n\n*   **如何实现高可用与高并发**:\n    1.  **DNS 负载均衡 (DNS Load Balancing)**:\n        *   **机制**: 一个域名可以配置解析到**多个不同的IP地址**。当用户发起DNS查询时，DNS服务器会根据预设的策略（如轮询、加权轮询）返回其中一个IP。这样，来自不同用户的请求就会被自然地分发到不同的服务器入口，实现了最基础的负载均衡。\n        *   **高可用价值**: 如果其中一个IP地址对应的服务器集群发生故障，我们可以从DNS解析记录中移除该IP。用户的后续请求就会被解析到其他健康的IP上，实现了**数据中心级别的故障转移**。\n    2.  **智能DNS解析 (GeoDNS / Latency-based Routing)**:\n        *   **机制**: 更高级的DNS服务（通常由专业DNS提供商或云厂商提供）可以判断DNS查询请求来自哪个地理位置或哪个运营商网络。然后，它会返回一个物理距离最近、访问延迟最低的服务器IP地址。\n        *   **高并发价值**: 将用户流量“就近”引入，极大地提升了访问速度和用户体验，同时也分散了不同区域的流量，避免单一入口的拥堵。\n\n*   **技术实现与选型**:\n    *   基础：Bind9 (自建)\n    *   云服务商：AWS Route 53, Google Cloud DNS, 阿里云DNS\n    *   专业DNS服务商：Cloudflare DNS, DNSPod\n\n##### **B. CDN (Content Delivery Network) - 分布式前哨仓库**\n\n*   **核心职责**:\n    缓存网站的**静态资源**（如图片、视频、JavaScript文件、CSS文件等），并将其分发到全球各地靠近用户的“边缘节点”（Edge Nodes / PoPs）上。\n\n*   **如何实现高可用与高并发**:\n    1.  **极大降低源站负载 (Offloading Traffic)**:\n        *   **机制**: 当用户第一次请求一个静态资源时，CDN边缘节点会从我们的源站服务器拉取该资源并缓存起来。后续所有对该资源的请求，都将直接由CDN边缘节点响应，不再需要访问我们的源站。\n        *   **高并发价值**: 网站流量中通常有70%-80%是静态资源。将这部分流量剥离出去，意味着我们的后端服务器只需要处理剩余20%-30%的动态API请求。这使得后端服务可以专注于核心业务逻辑，承载远超以往的并发量。\n    2.  **天然的分布式与高可用**:\n        *   **机制**: CDN服务商在全球拥有成百上千的节点。这些节点本身就是高可用的。如果某个节点或区域出现故障，流量会自动被路由到其他健康的节点。\n        *   **高可用价值**: 它不仅缓存了内容，实际上也为我们的静态资源提供了一个极其强大的、分布式的冗余系统。即使我们的源站短暂宕机，只要CDN缓存未过期，用户依然可以访问网站的静态部分。\n    3.  **加速访问，提升用户体验**:\n        *   **机制**: 用户总是从物理距离最近的CDN节点获取资源，减少了网络传输的延迟（RTT - Round-Trip Time）。\n        *   **价值**: 更快的加载速度意味着更低的用户流失率，这在高并发系统中至关重要。\n\n*   **技术实现与选型**:\n    *   云服务商：AWS CloudFront, Google Cloud CDN, Azure CDN, 阿里云CDN, 腾讯云CDN\n    *   专业CDN服务商：Cloudflare, Akamai, Fastly\n\n##### **C. WAF (Web Application Firewall) - 智能安全卫士**\n\n*   **核心职责**:\n    部署在Web服务器之前，对HTTP/HTTPS请求进行检测和过滤，防御常见的Web应用攻击，如SQL注入、跨站脚本（XSS）、DDoS攻击等。\n\n*   **如何实现高可用**:\n    1.  **保障服务的可用性 (Protecting Availability)**:\n        *   **机制**: WAF是保障**可用性**的关键组件。分布式拒绝服务（DDoS）攻击的目的就是通过海量的垃圾流量耗尽服务器的带宽、CPU或内存资源，导致正常用户无法访问。WAF能够识别并清洗这些恶意流量，只放行合法的请求。\n        *   **高可用价值**: 如果没有WAF，在高并发时期，一次小规模的DDoS攻击就可能导致整个系统瘫痪。WAF确保了后端服务的“存活权”。\n    2.  **防止数据泄露和篡改**:\n        *   **机制**: 通过防御SQL注入等攻击，WAF防止了数据库被拖库或恶意修改，间接保护了系统的稳定和数据的完整性，这也是高可用的一个方面（系统能正确提供服务）。\n\n*   **技术实现与选型**:\n    *   通常与CDN服务集成在一起，如Cloudflare的WAF功能。\n    *   云服务商：AWS WAF, 阿里云WAF等。\n    *   硬件/软件：F5 BIG-IP ASM, ModSecurity (开源)。\n\n---\n\n### **1.3 本章总结**\n\n在这一层，我们通过**DNS**的智能调度，将用户流量导向最合适的数据中心入口；通过**CDN**，将绝大部分静态资源请求“拦截”在全球各地的边缘节点，极大地减轻了后端压力；最后通过**WAF**，清洗掉恶意攻击流量。\n\n**架构图中的流程:**\n\n```\n[ 用户 ] --- 1. DNS查询 ---> [ DNS服务器 ]\n   |                                 | 2. 返回最优IP (CDN节点/WAF入口)\n   |                                 |\n   +----- 3. 发起HTTP/HTTPS请求 ---> [ CDN / WAF 全球边缘节点 ]\n                                       |\n                                       | 4. a) 如果是静态资源 -> 直接从CDN缓存返回\n                                       | b) 如果是动态API请求 -> 清洗过滤后，转发到下一层...\n                                       |\n                                       V\n                                  (流量接入层)\n```\n\n当流量安全、稳定地穿过这第一道防线后，它将抵达我们数据中心的正式入口——**流量接入层**。我们将在下一章详细探讨。\n\n\n\n## **第二章：流量接入层 (Traffic Ingress Layer)**\n\n### **2.1 本章定位：系统的“总接待”与“安检口”**\n\n如果说第一章是“城墙”和“护城河”，那么这一层就是城堡的**唯一主城门**和**卫兵**。所有外部请求，无论好坏，最终都会汇聚于此。它的核心职责是：\n\n1.  **统一入口 (Unified Entry Point)**: 成为所有后端服务的唯一流量入口，避免将内部服务直接暴露在公网上，增强安全性。\n2.  **分发与均衡 (Distribution & Balancing)**: 将海量的并发请求，稳定、高效、均匀地分发给后端的多个处理单元（通常是API网关集群）。\n3.  **协议处理 (Protocol Handling)**: 集中处理一些网络层面的通用任务，如HTTPS解密，让后端服务可以更专注于业务逻辑。\n\n这一层是实现**后端服务水平扩展**和**高可用**的基础。如果这里的负载均衡器宕机，那么整个系统就与外界“失联”了。\n\n---\n\n### **2.2 核心组件详解**\n\n##### **A. 负载均衡器 (Load Balancer, LB)**\n\n这是本层的核心组件，通常是一个集群而非单个设备。\n\n*   **核心职责**:\n    监听来自公网的特定端口（如80, 443），并将收到的请求根据预设的策略转发给后端服务器池（Server Pool）中的一个健康节点。\n\n*   **如何实现高可用与高并发**:\n    1.  **高可用 - 消除单点故障 (HA Cluster)**:\n        *   **机制**: 负载均衡器本身绝不能是单点。在生产环境中，至少会部署**两台**负载均衡器，构成**主备（Active-Passive）**或**主主（Active-Active）**集群。\n        *   **Keepalived + VIP (Virtual IP)** 是一种常见的开源实现方案。集群共享一个虚拟的IP地址（VIP）。正常情况下，VIP由主（Master）节点持有，所有流量都经过它。Keepalived会通过VRRP协议在主备节点间发送心跳包。一旦主节点宕机，备（Backup）节点会立即检测到心跳丢失，并在几秒内接管VIP。对于客户端来说，它们访问的IP地址从未改变，故障切换是透明的。\n        *   **高可用价值**: 确保了流量入口的7x24小时可用。即使一台LB物理机宕机、重启或进行维护，服务也不会中断。\n\n    2.  **高并发 - 水平扩展后端 (Horizontal Scaling)**:\n        *   **机制**: 负载均衡器后面可以连接**任意数量**的后端服务器（比如API网关节点）。当并发量上升时，我们只需要向服务器池中添加新的节点，LB就会自动将流量分发给它们。\n        *   **负载均衡算法 (Balancing Algorithms)**:\n            *   **轮询 (Round Robin)**: 按顺序依次分发，简单公平。\n            *   **加权轮询 (Weighted Round Robin)**: 按权重分配，适用于服务器性能不一的场景。\n            *   **最少连接 (Least Connections)**: 将请求发给当前连接数最少的服务器，适合处理长连接。\n            *   **IP哈希 (IP Hash)**: 根据客户端IP地址计算哈希值，确保来自同一客户端的请求总是发往同一台后端服务器。这对于需要维持会话状态（Session Stickiness）的场景很有用。\n        *   **高并发价值**: 负载均衡器是实现后端服务**无缝水平扩展**的关键。它将单个服务的处理能力从“一台服务器的上限”扩展到了“整个集群的综合处理能力”。\n\n    3.  **健康检查 (Health Checks)**:\n        *   **机制**: 负载均衡器会以固定的频率，主动向后端服务器池中的每个节点发送“探测”请求（比如一个HTTP GET请求或一个TCP连接请求）。\n        *   如果服务器返回了预期的健康状态码（如HTTP 200），则认为该节点健康。\n        *   如果服务器超时未响应或返回错误状态，LB会将其标记为“不健康”，并**自动停止向该节点转发新的流量**。当节点恢复后，健康检查通过，LB会再次将其加入到服务池中。\n        *   **高可用价值**: 这是实现**自动故障转移 (Automatic Failover)** 的核心机制。它能实时、自动地隔离故障节点，保证用户的请求总是被发送到能够正常处理的服务器上，极大提升了系统的健壮性。\n\n##### **B. SSL/TLS 卸载 (SSL/TLS Offloading)**\n\n*   **核心职责**:\n    我们现在的Web服务普遍使用HTTPS来加密传输内容，保障数据安全。HTTPS的加解密过程（特别是握手阶段）会消耗大量的CPU资源。\n    **SSL卸载**就是将这个加解密的工作**集中**在负载均衡器上完成。\n\n*   **如何实现高并发**:\n    1.  **降低后端服务CPU消耗**:\n        *   **机制**: 外部请求 `(Client --HTTPS--> LB)` 到达LB后，LB负责解密，然后以普通的HTTP协议将请求转发给内部的后端服务器 `(LB --HTTP--> Backend Server)`。返回的响应也是同理。\n        *   **高并发价值**: 这意味着后端的成百上千个业务服务节点不再需要各自消耗CPU资源去处理加解密。它们可以把宝贵的计算资源全部用于执行核心业务逻辑，从而提升整体的应用处理性能和吞吐量。\n    2.  **简化证书管理**:\n        *   **机制**: 所有的SSL/TLS证书只需要在负载均衡器这一层进行部署和更新，而不需要在每一个后端服务节点上都去管理证书。\n        *   **价值**: 简化了运维，降低了因证书过期或配置错误导致服务不可用的风险。\n\n*   **技术实现与选型**:\n    *   **软件负载均衡器**: Nginx, HAProxy, LVS (Linux Virtual Server)\n    *   **硬件负载均衡器**: F5 BIG-IP, A10 Networks\n    *   **云服务商**: AWS (ALB/NLB/ELB), Google Cloud Load Balancing, 阿里云SLB\n\n---\n\n### **2.3 本章总结**\n\n在流量接入层，我们通过一个**高可用的负载均衡器集群**，为整个后端系统提供了一个稳定、统一的入口。它利用**健康检查**机制实现了后端服务的自动故障转移，通过**负载均衡算法**将高并发流量均匀地分发出去，并通过**SSL卸载**为后端服务减负。\n\n**架构图中的流程:**\n\n```\n            (从第一层: CDN/WAF)\n                    |\n                    V\n[ Internet ] --> [ VIP: 123.45.67.89 ]\n                    |\n         +--------------------------+\n         |     高可用负载均衡器集群     |\n         |                          |\n         | [ LB 1 (Master) ] <---> [ LB 2 (Backup) ] -- 心跳检测 --\n         +--------------------------+\n                    |\n                    | 1. SSL/TLS 解密\n                    | 2. 根据负载均衡算法选择一个后端节点\n                    | 3. 健康检查，确保节点存活\n                    |\n                    V\n     (转发到下一层: API网关集群的某个节点)\n```\n\n现在，解密后的、干净的、被均匀分发的流量，即将进入微服务架构的“咽喉”——**API网关层**。我们将在下一章探讨它的作用。\n\n\n\n## **第三章：API网关层 (API Gateway Layer)**\n\n### **3.1 本章定位：微服务的“智能门面”与“中央管制塔”**\n\n如果说流量接入层是城堡的“主城门”，那么API网关层就是城门后的**中央广场**和**卫队长**。所有进入城堡的请求都会在这里进行身份核查、登记，并被指引到正确的目的地（具体的业务服务）。它不是简单地转发流量，而是进行了大量的**应用层（L7）**处理。\n\n核心职责：\n\n1.  **统一门面 (Unified Facade)**: 为外部客户端（Web、App、第三方服务）提供一个单一、稳定、规范的API入口，隐藏内部微服务的复杂性和部署细节。\n2.  **横切关注点处理 (Cross-Cutting Concerns)**: 集中处理所有或大部分微服务都需要的通用功能，如认证、授权、限流、日志记录等，避免在每个微服务中重复实现。\n3.  **请求路由与编排 (Routing & Orchestration)**: 精确地将请求路由到下游的某个或某些微服务，甚至可以将多个微服务的调用结果聚合成一个单一的响应。\n\n这一层是保障微服务架构**安全、稳定、可治理**的核心。没有它，成百上千的微服务将如一盘散沙，难以管理和保护。\n\n---\n\n### **3.2 核心组件与策略详解**\n\n#### **A. 动态路由 (Dynamic Routing)**\n\n*   **核心职责**:\n    根据请求的特征（如URL路径、HTTP方法、Header头等），将其转发到正确的后端微服务实例。例如，将 `/users/...` 的请求路由到用户服务，将 `/orders/...` 的请求路由到订单服务。\n\n*   **如何实现高可用**:\n    1.  **服务发现 (Service Discovery)**:\n        *   **机制**: API网关本身并**不知道**后端服务的具体IP地址和端口。相反，它会与一个**服务注册中心 (Service Registry)** 集成（如 Nacos, Consul, Eureka）。\n        *   每个微服务实例在启动时，会主动向注册中心“报到”（注册），并定时发送心跳来表明自己还活着。\n        *   API网关会从注册中心订阅服务列表。当有新的服务实例上线或旧的实例下线（因宕机或主动关闭）时，注册中心会实时通知网关。\n        *   **高可用价值**: 这是实现**动态、自动化的服务伸缩和故障转移**的关键。当订单服务从3个实例扩容到5个时，网关能立刻感知到并开始向新实例转发流量。当某个实例因故障心跳停止时，网关也会立刻将其从路由列表中移除，避免将请求发往一个“死”的服务。整个过程无需人工干预。\n\n#### **B. 安全屏障 (Security Shield)**\n\n*   **核心职责**:\n    作为所有内部服务的安全前哨，保护它们免受未授权的访问。\n\n*   **高可用策略**:\n    1.  **认证 (Authentication)**:\n        *   **机制**: 集中处理用户身份验证。客户端的请求通常会携带一个身份凭证（如 JWT Token, API Key）。API网关负责校验这个凭证的合法性、有效性。只有通过验证的请求才会被放行到后端服务。\n        *   **价值**: 将认证逻辑从所有业务服务中剥离出来，简化了业务服务的开发。更重要的是，它确保了任何一个内部服务都不会被匿名或非法请求直接访问。\n    2.  **授权 (Authorization)**:\n        *   **机制**: 在认证通过后，网关还可以进一步检查该用户是否有**权限**执行当前的操作。例如，检查用户角色是否是“管理员”才能访问某个管理API。\n        *   **价值**: 实现了更细粒度的访问控制，进一步增强了系统的安全性。\n\n#### **C. 流量管制 (Traffic Control)**\n\n*   **核心职责**:\n    保护后端服务免受突发流量或恶意攻击的冲击，防止系统因过载而崩溃（即“雪崩效应”）。\n\n*   **如何实现高可用与高并发**:\n    1.  **限流 (Rate Limiting)**:\n        *   **机制**: 对特定的API、用户或IP地址设置请求速率上限（如每秒100次请求）。当请求速率超过阈值时，网关会直接拒绝多余的请求（通常返回 `429 Too Many Requests` 错误）。\n        *   **高并发价值**: 这是一种**主动的自我保护机制**。它可以防止某个用户或恶意脚本的滥用导致整个服务不可用，确保系统在极限负载下仍能为大部分用户提供有保障的服务。常用的算法有令牌桶、漏桶算法。\n    2.  **熔断 (Circuit Breaking)**:\n        *   **机制**: 网关会持续监控对下游某个微服务的调用情况（如错误率、响应延迟）。当发现该服务的错误率超过设定的阈值时（比如10秒内失败率达到50%），网关会“熔断”对此服务的调用。\n        *   在接下来的一个时间窗口内（如30秒），所有发往该服务的请求都会被网关**立即失败 (Fail Fast)**，直接返回一个错误，而不再真正去调用那个可能已经崩溃的服务。\n        *   时间窗口过后，熔断器会进入“半开”状态，尝试放行少量请求。如果这些请求成功，则关闭熔断器，恢复正常调用；如果依然失败，则继续保持熔断。\n        *   **高可用价值**:\n            *   **防止雪崩效应**: 避免了对一个已知故障服务的无效、重复调用，这些调用会消耗网关自身的线程和连接资源。\n            *   **给下游服务恢复时间**: 停止发送流量，让故障服务有机会重启或恢复。\n            *   **快速失败**: 让上游调用方能迅速得到失败响应，而不是长时间等待超时，提升了用户体验。\n    3.  **降级 (Degradation)**:\n        *   **机制**: 在系统负载过高或非核心服务出现问题时，为了保住核心功能，会有策略地关闭或简化一些次要功能。这种策略可以在网关层实现，例如，当检测到系统压力大时，网关可以返回一个静态的、默认的响应，而不是去调用后端的推荐服务。\n        *   **高可用价值**: 舍卒保车，确保在极端情况下，系统核心功能依然可用。\n\n---\n\n### **3.3 本章总结**\n\nAPI网关是微服务架构的“守护神”。它通过与**服务注册中心**联动，实现了服务的**动态路由**和自动故障转移。通过集中的**认证授权**，构筑了坚实的安全防线。更重要的是，它利用**限流、熔断、降级**等“保险丝”机制，在面对高并发和下游故障时，能有效保护整个系统的稳定性，防止连锁反应导致的全面崩溃。\n\n**架构图中的流程:**\n\n```\n            (从第二层: 负载均衡器)\n                    |\n                    V\n        +-----------------------+      +-----------------------+\n        |     API Gateway 1     |      |     API Gateway 2     | ...\n        +-----------------------+      +-----------------------+\n                 |    ^                            ^\n                 |    | 2. 订阅服务列表             |\n                 |    +--------------------------+ |\n                 |                               | |\n                 v 1. 请求进入                    | V\n        +----------------------------------------+ |\n        | 3. 安全: 认证/授权                       | |\n        | 4. 流量控制: 限流/熔断                   | |\n        | 5. 根据请求路径，查找服务地址              | |\n        +----------------------------------------+ |\n                 |                                 |\n                 |         (服务注册中心)             |\n                 v         Nacos/Consul            |\n  +----------------------+                         |\n  | [用户服务实例列表]     | <-------------------------+\n  | [订单服务实例列表]     |\n  +----------------------+\n                 |\n                 V\n     (转发到下一层: 具体的业务服务集群)\n```\n\n现在，经过层层校验和管制的请求，终于到达了真正处理业务逻辑的地方——**业务服务层**。我们将在下一章探讨如何设计这一层来实现高可用。\n\n\n\n## **第四章：业务服务层 (Application Services Layer)**\n\n### **4.1 本章定位：系统的“大脑”与“功能单元”**\n\n这一层是整个架构的**核心价值所在**。无论是用户注册、商品浏览、下单支付，还是后台的数据分析，所有的业务功能都在这里实现。它不再是单一的庞然大物，而是一个由多个**自治、专注、可独立部署**的服务组成的集群。\n\n核心设计目标：\n\n1.  **高内聚，低耦合 (High Cohesion, Low Coupling)**: 每个服务只做一件事并把它做好。服务之间通过定义良好的API进行通信，互不了解对方的内部实现。\n2.  **弹性与可扩展性 (Elasticity & Scalability)**: 能够根据业务负载的变化，自动、快速地增加或减少服务实例的数量，以最高效的方式利用资源。\n3.  **故障隔离 (Fault Isolation)**: 一个服务的故障不应该导致整个系统的瘫痪。故障的影响范围应被限制在服务内部或其直接调用方。\n\n这一层的设计直接决定了系统能否在业务快速发展的同时，保持技术上的灵活性和稳定性。\n\n---\n\n### **4.2 核心组件与策略详解**\n\n#### **A. 微服务化 (Microservices)**\n\n*   **核心职责**:\n    将一个庞大的单体应用（Monolith）按照业务边界（Domain Boundary）拆分成多个更小、更独立的服务。例如，一个电商系统可以拆分为：用户服务、商品服务、订单服务、支付服务、库存服务等。\n\n*   **如何实现高可用与高并发**:\n    1.  **独立部署与扩展 (Independent Deployment & Scaling)**:\n        *   **机制**: 每个微服务都可以独立地进行开发、测试、部署和升级。例如，在“双十一”大促期间，我们可以只针对“订单服务”和“商品服务”进行大规模扩容（比如扩容到100个实例），而“用户服务”（主要是登录，压力相对较小）可能只需要10个实例。\n        *   **高并发价值**: 实现了**资源的精细化、按需分配**。我们可以把计算资源集中在最需要的地方，从而以更低的成本支撑更高的并发量。而在单体应用中，我们只能对整个应用进行扩容，即使只有10%的代码是性能瓶颈，也必须为另外90%的非瓶颈代码付出同样的扩容成本。\n    2.  **故障隔离 (Fault Isolation)**:\n        *   **机制**: 如果“推荐服务”因为一个内存泄漏的BUG而频繁崩溃，它不会影响到核心的“订单服务”或“支付服务”的运行。最坏的情况只是用户暂时看不到商品推荐。\n        *   **高可用价值**: 这大大提高了整个系统的**健壮性**。故障的影响被“防火墙”隔离在了单个服务的边界内，避免了“一颗老鼠屎坏了一锅汤”的情况。\n    3.  **技术栈异构 (Technology Heterogeneity)**:\n        *   **机制**: 不同的服务可以根据其业务特点选择最适合的技术栈。例如，可以用Java/Spring Boot来编写复杂的业务逻辑服务，用Python/Django来做数据分析服务，用Go来写需要高性能网络I/O的中间件服务。\n        *   **价值**: 允许团队使用最合适的工具解决问题，有助于提升开发效率和系统性能。\n\n#### **B. 无状态服务 (Stateless Service)**\n\n*   **核心职责**:\n    这是实现**无缝水平扩展**的**基石**。无状态服务指的是，服务本身不存储任何与特定请求或会话相关的状态信息。对于任何一个请求，集群中的任意一个实例处理的结果都应该是一样的。\n\n*   **如何实现高可用与高并发**:\n    *   **机制**: 那么状态信息（如用户的登录会话、购物车内容）存到哪里去呢？答案是：**外部化存储**。通常我们会把这些状态存放在一个共享的、高性能的外部系统中，如**分布式缓存（Redis）**或数据库。\n    *   **高可用/高并发价值**:\n        *   **任意扩展**: 因为每个实例都不包含独一无二的数据，所以我们可以随时增加新的实例来分担流量，也可以随时下线任何一个实例而不用担心数据丢失。\n        *   **请求自由路由**: 负载均衡器可以把同一个用户的连续请求发送到不同的服务实例上，这极大简化了负载均衡策略。\n        *   **快速故障恢复**: 如果一个实例宕机，Kubernetes等编排工具可以立刻启动一个新实例来替代它。由于状态在外部，新实例可以立即投入工作，无缝衔接。\n\n#### **C. 容器化与编排 (Containerization & Orchestration)**\n\n*   **核心职责**:\n    提供一种标准化的、与环境无关的应用打包、分发和运行方式，并自动化地管理这些应用的生命周期。\n\n*   **如何实现高可用与高并发**:\n    1.  **Docker - 标准化打包**:\n        *   **机制**: Docker将应用及其所有依赖（库、配置文件等）打包成一个轻量、可移植的“容器”镜像。这个镜像可以在任何支持Docker的机器上以完全相同的方式运行，解决了“在我电脑上明明是好的”这一经典问题。\n        *   **价值**: 实现了**环境一致性**，极大地简化了部署流程，是实现快速、可靠的持续集成/持续部署（CI/CD）的基础。\n    2.  **Kubernetes (K8s) - 自动化编排**:\n        *   **机制**: Kubernetes是一个容器编排平台，你可以把它看作是管理成千上万个容器的“操作系统”。我们只需要向K8s声明我们期望的状态（例如，“我需要我的订单服务运行10个副本”），K8s就会自动地完成剩下的一切。\n        *   **高可用价值**:\n            *   **自愈 (Self-healing)**: K8s会持续监控所有容器的健康状况。如果一个容器崩溃了，K8s会**自动**在另一台健康的物理机上重新启动一个新的容器来替代它。\n            *   **自动扩缩容 (Auto-scaling)**: 我们可以配置策略，让K8s根据CPU或内存的使用率，**自动**增加或减少服务的副本数量（即容器实例数）。当流量高峰来临时，系统自动扩容；当流量低谷时，自动缩容，节省成本。\n            *   **滚动更新 (Rolling Update)**: 在发布新版本时，K8s可以逐个地替换旧的容器实例，而不是一次性全部停止。这保证了应用在更新过程中**服务不中断**。\n\n---\n\n### **4.3 本章总结**\n\n业务服务层是高可用架构的“血肉”。通过**微服务化**，我们将系统拆分为灵活、自治的单元；通过**无状态设计**，我们为这些单元的自由伸缩奠定了基础；最终，通过**Docker和Kubernetes**，我们获得了强大的自动化运维能力，包括自愈、自动扩缩容和零停机发布。这三者结合，共同构建了一个既能应对高并发冲击，又能在故障面前快速恢复的弹性服务集群。\n\n**架构图中的流程:**\n\n```\n            (从第三层: API网关)\n                    |\n                    V\n+-------------------------------------------------------------+\n|               Kubernetes Cluster (多台物理/虚拟机)             |\n|                                                             |\n|   +--------------+      +--------------+      +--------------+  |\n|   | 订单服务 Pod 1 |      | 订单服务 Pod 2 | ...  | 订单服务 Pod N |  |  <- 自动扩缩容\n|   +--------------+      +--------------+      +--------------+  |\n|         ^                                                     |\n|         | Service A (e.g., Order Service)                     |\n|         |                                                     |\n|   +--------------+      +--------------+                      |\n|   | 用户服务 Pod 1 |      | 用户服务 Pod 2 | ...                  |  <- 故障自愈\n|   +--------------+      +--------------+                      |\n|         ^                                                     |\n|         | Service B (e.g., User Service)                      |\n|         |                                                     |\n|   +-----+--------+                                            |\n|   |  ... 其他服务  |                                            |\n|   +--------------+                                            |\n|                                                             |\n+-------------------------------------------------------------+\n         |           |            |\n         |           |            | (读写数据/状态)\n         V           V            V\n      (下一层: 数据与状态层 - 缓存/消息队列/数据库)\n```\n\n业务逻辑处理完毕后，不可避免地需要与数据打交道。下一章，我们将深入探讨架构的“地基”——**数据与状态层**，看看如何让数据存储也实现高可用和高并发。\n\n\n\n## **第五章：数据与状态层 (Data & State Layer)**\n\n### **5.1 本章定位：系统的“中央银行”与“记忆中心”**\n\n这一层是所有业务数据的最终归宿和状态信息的管理者。它负责**持久化存储（Durability）**核心数据，并提供**高性能的数据访问（Performance）**。在分布式系统中，数据的**一致性（Consistency）**和**可用性（Availability）**是这一层永恒的主题。\n\n核心设计挑战：\n\n1.  **高可用性**: 即使部分存储节点发生硬件故障、网络分区，数据也不能丢失，并且服务应尽可能保持可用。\n2.  **高性能/高并发**: 必须能够支撑上层成千上万个服务实例同时进行的高并发读写请求。\n3.  **可扩展性**: 当数据量或访问量增长时，必须有能力平滑地扩展存储容量和吞吐能力。\n\n这一层的设计往往是整个架构中最昂贵、最复杂的部分，但也是决定系统质量上限的关键。\n\n---\n\n### **5.2 核心组件与策略详解**\n\n#### **A. 缓存集群 (Cache Cluster) - 高速公路的“快车道”**\n\n*   **核心职责**:\n    在内存中存储那些被**频繁读取**但**不经常修改**的数据（即“热点数据”），例如商品信息、用户配置、首页内容等。其目的是**减少对后端慢速存储（如关系型数据库）的直接访问**。\n\n*   **如何实现高可用与高并发**:\n    1.  **读写分离与数据冗余 (Replication)**:\n        *   **机制**: 使用**主从（Master-Slave）架构**。写操作只在主节点进行，然后异步地复制到多个从节点。读操作可以由所有的从节点来分担。\n        *   **高并发价值**: 极大地提升了读性能，因为可以水平扩展多个从节点来应对海量的读取请求。\n        *   **高可用价值**: 当主节点宕机时，可以从从节点中选举一个新的主节点（例如通过 **Redis Sentinel** 机制），实现**自动故障转移**，保证写入服务在短时间内恢复。\n    2.  **数据分片 (Sharding)**:\n        *   **机制**: 当单个Redis实例的内存容量或QPS达到瓶颈时，需要将数据分散到多个实例中。**Redis Cluster** 方案通过哈希槽（hash slots）的方式，自动将不同的key-value映射到不同的物理节点上。客户端请求任何一个节点，如果数据不在该节点，它会被透明地重定向到正确的节点。\n        *   **高并发/高扩展性价值**: 打破了单机内存和CPU的限制，使得缓存集群的容量和吞吐能力可以**理论上无限地水平扩展**。\n\n*   **缓存使用模式**:\n    *   **Cache-Aside (旁路缓存)**: 最常用的模式。读：先读缓存，没有则读数据库，然后写回缓存。写：先更新数据库，然后删除缓存。\n    *   **Read-Through / Write-Through**: 缓存作为唯一的数据源对应用透明，由缓存服务自身负责与数据库的同步。\n\n*   **技术选型**: Redis, Memcached\n\n#### **B. 消息队列集群 (Message Queue Cluster) - 系统的“减震器”与“耦合器”**\n\n*   **核心职责**:\n    提供一个异步通信的中间层，主要用于**服务解耦、流量削峰、异步处理**。\n\n*   **如何实现高可用与高并发**:\n    1.  **异步处理 (Asynchronous Processing)**:\n        *   **机制**: 对于一些非核心、耗时的操作，主流程不必等待其完成。例如，用户下单后，订单服务只需成功写入数据库并向MQ发送一条“订单创建成功”的消息，就可以立即向上游返回成功响应。至于后续的扣减库存、发送通知邮件/短信、增加用户积分等操作，都由下游的订阅者服务异步地去消费这条消息来完成。\n        *   **高并发价值**: 极大地缩短了核心链路的响应时间，显著提升了用户体验和系统的吞吐量。\n    2.  **流量削峰 (Traffic Shaping / Peak Shaving)**:\n        *   **机制**: 在秒杀、大促等场景下，瞬间的流量洪峰可能会冲垮数据库。MQ此时可以作为一个巨大的“蓄水池”。前端应用以其最大能力将请求写入MQ，而后端的消费者服务则以自己平稳的处理速率（如每秒1000个订单）从MQ中拉取并处理。\n        *   **高并发价值**: 它将瞬时的高峰流量“拉平”成一段时间内的平稳流量，保护了后端脆弱的存储系统，是应对流量脉冲的“核武器”。\n    3.  **高可用与数据持久化**:\n        *   **机制**: 现代MQ（如 Kafka, RocketMQ）天生就是**分布式集群**。数据（消息）被写入到Topic的不同分区（Partition）中，每个分区都有多个副本（Replicas）分布在不同的物理机（Broker）上。\n        *   **高可用价值**: 即使某个Broker宕机，存储在其上的分区副本依然在其他Broker上可用，保证了消息不丢失和服务不中断。\n\n*   **技术选型**: Kafka (高吞吐量，日志场景), RocketMQ (金融级可靠性), RabbitMQ (功能灵活，成熟稳定)\n\n#### **C. 数据库集群 (Database Cluster) - 数据的“金库”**\n\n*   **核心职责**:\n    作为系统最核心、最权威的数据存储，保证数据的ACID特性（原子性、一致性、隔离性、持久性）。\n\n*   **如何实现高可用与高并发**:\n    1.  **读写分离 (Read/Write Splitting)**:\n        *   **机制**: 与缓存类似，采用**主从复制**架构。一个主库（Master）负责所有写操作（INSERT, UPDATE, DELETE），多个从库（Slaves）同步主库的数据，并对外提供读服务（SELECT）。应用层或数据库中间件会根据SQL语句的类型，将写请求路由到主库，读请求路由到从库。\n        *   **高并发价值**: 大部分应用的读写比远大于1（例如10:1）。通过水平扩展从库数量，可以线性提升系统的读性能。\n    2.  **分库分表 (Sharding)**:\n        *   **机制**: 当单一数据库或单一数据表的容量或写入并发量达到极限时，需要进行水平拆分。\n            *   **分库**: 将不同业务的数据存到不同的数据库中（如用户库、订单库）。\n            *   **分表**: 将一张大表（如订单表）按照某种规则（如用户ID哈希取模、按时间范围）水平拆分到多张物理表中。这些物理表可以分布在同一个数据库，也可以分布在不同的数据库中。\n        *   **高并发/高扩展性价值**: 这是解决数据库写入瓶颈和存储容量瓶颈的终极方案。它将压力分散到多个物理节点上，实现了数据库的水平扩展。\n    3.  **高可用架构**:\n        *   **机制**:\n            *   **主从+自动切换**: 使用MHA (Master High Availability) 或 Orchestrator 等工具监控主库状态，一旦主库宕机，能自动在几秒到几十秒内将一个从库提升为新主库，并让其他从库指向新主。\n            *   **多主同步/分布式数据库**: 采用 Galera Cluster, Percona XtraDB Cluster (PXC) 等方案实现多节点同时可写，或者直接采用原生分布式数据库如 TiDB, CockroachDB。\n        *   **高可用价值**: 确保了数据库服务的连续性，将RTO（恢复时间目标）降到最低。\n\n*   **技术选型**:\n    *   关系型: MySQL, PostgreSQL\n    *   数据库中间件: ShardingSphere, MyCAT\n    *   分布式数据库: TiDB, CockroachDB, Google Spanner\n    *   NoSQL: MongoDB, Cassandra (适用于特定场景)\n\n---\n\n### **5.3 本章总结**\n\n数据与状态层是架构中最需要精雕细琢的部分。我们通过引入**缓存集群**作为高速挡箭牌，保护了数据库；通过**消息队列**实现了系统的削峰和解耦；并通过**数据库的读写分离、分库分表和高可用架构**，确保了核心数据存储的性能、可扩展性和永不宕机。这三者共同构成了坚实可靠的数据基座。\n\n**架构图中的交互:**\n\n```\n     (从第四层: 业务服务层)\n             |\n             |  (高频读/状态存储)\n+------------+-------------+\n|                          |\nV                          V\n[ Cache Cluster ]         [ Message Queue Cluster ] <--- (异步/削峰) --- [业务服务层]\n(e.g., Redis)             (e.g., Kafka)\n  ^   |                      |   ^\n  |   | (低频读/核心写)      |   | (异步消费)\n  |   |                      V   |\n  |   +------> [ DB Proxy / Middleware ] ----> [ Database Cluster ]\n  |                 (e.g., ShardingSphere)       (e.g., MySQL主从/分片)\n  |                                                  ^\n  +--------------------------------------------------+\n                (缓存未命中时回源)\n```\n\n至此，一个完整的业务请求流程已经走完。但是，系统要能长期稳定运行，还需要一双“眼睛”来时刻监控它。下一章，我们将探讨最后的支撑体系——**运维与可观测性**。\n\n\n\n## **第六章：运维与可观测性 (Operations & Observability)**\n\n### **6.1 本章定位：系统的“神经网络”与“健康监护中心”**\n\n这一层不直接处理用户的业务请求，但它像一个无处不在的神经网络，渗透到架构的每一个角落。它的核心职责是**“让不可见变为可见”**，确保我们能够实时、清晰地了解系统内部正在发生的一切，并在问题发生时（甚至在发生前）提供足够的信息来进行预警、定位和解决。\n\n可观测性的三大支柱：\n\n1.  **日志 (Logging)**: 回答 **“发生了什么？”**。记录离散的、具体的事件。\n2.  **指标 (Metrics)**: 回答 **“情况怎么样？”**。聚合的、可量化的数据，用于衡量系统健康状况和趋势。\n3.  **追踪 (Tracing)**: 回答 **“为什么会这样？”**。记录单个请求在分布式系统中的完整调用链路，用于诊断性能瓶颈和错误根源。\n\n这一层是提升团队**运维效率**、保障系统**SLA（服务等级协议）**、实现**快速故障恢复**的基石。\n\n---\n\n### **6.2 核心组件与策略详解**\n\n#### **A. 集中式日志系统 (Centralized Logging)**\n\n*   **核心职责**:\n    在微服务架构中，日志散落在成百上千个服务实例的文件系统中，手动排查问题如同大海捞针。集中式日志系统的任务就是将所有这些分散的日志**收集（Collect）、聚合（Aggregate）、存储（Store）**起来，并提供一个统一的**搜索（Search）**和**分析（Analyze）**界面。\n\n*   **典型工作流 (ELK/EFK Stack)**:\n    1.  **数据采集 (Shipper)**: 在每个业务服务器节点上部署一个轻量级的日志采集代理（Agent），如 **Filebeat** 或 **Fluentd**。这个代理负责监听本地的日志文件（如 `app.log`, `nginx_access.log`），并将新增的日志行实时发送出去。\n    2.  **数据处理与转发 (Processor)**: （可选但常用）采集到的原始日志通常是无格式的文本。它们会被发送到一个中间处理层，如 **Logstash** 或 Fluentd，在这里进行**解析（Parsing）**（如将一行文本解析成JSON结构，提取出时间、日志级别、请求ID等字段）、**过滤（Filtering）**和**丰富（Enriching）**（如根据IP地址添加地理位置信息）。\n    3.  **数据存储与索引 (Storage & Indexing)**: 处理干净的、结构化的日志数据最终被发送到 **Elasticsearch** 集群中。Elasticsearch 会对这些数据进行索引，以提供**毫秒级的全文搜索能力**。\n    4.  **数据可视化与查询 (Visualization)**: 运维和开发人员通过 **Kibana** 的Web界面，可以像使用Google一样，方便地查询、筛选、聚合日志，并创建各种仪表盘来监控日志趋势（如错误日志数量的变化）。\n\n*   **高可用价值**:\n    *   **故障排查效率提升几个数量级**: 当用户报告问题时，开发人员可以通过一个唯一的请求ID（Trace ID），在Kibana中一键搜出这个请求经过的所有服务的全部相关日志。\n    *   **实时告警**: 可以基于日志内容设置告警。例如，当某个服务的错误日志（ERROR level）在5分钟内超过100条时，自动通过钉钉、Slack或邮件通知相关人员。\n\n#### **B. 监控与告警系统 (Monitoring & Alerting)**\n\n*   **核心职责**:\n    持续地、周期性地采集系统的**聚合指标（Metrics）**，并将其可视化，同时基于这些指标设置告警规则。\n\n*   **典型工作流 (Prometheus + Grafana Stack)**:\n    1.  **指标暴露 (Exposition)**: 应用程序（或通过中间件/exporter）需要以一种标准格式（如Prometheus的文本格式）通过一个HTTP端点（如 `/metrics`）暴露出自身的内部状态指标。例如：当前活跃请求数、API平均响应时间、JVM内存使用率、数据库连接池状态等。\n    2.  **指标拉取 (Scraping)**: **Prometheus Server** 会定期（如每15秒）主动地从这些端点“拉取”指标数据，并将其存储在自己的时序数据库（TSDB）中。\n    3.  **查询与告警 (Querying & Alerting)**: Prometheus 提供了强大的查询语言（PromQL），可以对收集到的指标进行复杂的查询和聚合。**Alertmanager** 组件则负责根据预设的告警规则（如“CPU使用率连续5分钟超过80%”）进行去重、分组，并将告警发送到指定的通知渠道。\n    4.  **可视化 (Visualization)**: **Grafana** 是一个开源的可视化平台，它可以连接到Prometheus作为数据源，通过配置丰富的图表、仪表盘，将枯燥的指标数据以直观、美观的方式展示出来。\n\n*   **高可用价值**:\n    *   **宏观健康度概览**: 通过仪表盘，运维人员可以一目了然地看到整个集群的健康状况，快速发现异常波动。\n    *   **趋势分析与容量规划**: 长期存储的指标数据可以用于分析业务增长趋势，为未来的扩容提供数据支持。\n    *   **主动发现问题**: 告警系统能够在问题影响到最终用户之前，就通知相关人员介入处理，实现“预防胜于治疗”。\n\n#### **C. 分布式追踪系统 (Distributed Tracing / APM)**\n\n*   **核心职责**:\n    当一个请求跨越多个微服务时，追踪系统能够将这个请求在每个服务内部的耗时、调用关系串联起来，形成一个完整的**调用链（Trace）**视图。\n\n*   - **典型工作流 (SkyWalking / Jaeger)**:\n\n    1.  **数据埋点 (Instrumentation)**: 通过在应用程序中引入一个Agent或SDK（通常是无侵入的字节码增强技术），自动地在服务调用的入口和出口进行“埋点”。当一个请求进入服务A时，Agent会生成一个唯一的 **Trace ID** 和一个 **Span ID**。当服务A调用服务B时，它会通过HTTP Header或RPC元数据将Trace ID和父Span ID传递给服务B。\n    2.  **数据上报 (Reporting)**: 每个服务中的Agent会将各自的Span信息（包含服务名、接口名、开始/结束时间、标签、日志等）异步地上报给追踪系统的**收集器（Collector）**。\n    3.  **数据处理与存储 (Processing & Storage)**: 收集器接收到来自各个服务的Span数据，将属于同一个Trace ID的Span组合起来，构建出完整的调用链拓扑关系，并将其存储起来（通常使用Elasticsearch或Cassandra）。\n    4.  **数据展示 (UI)**: 追踪系统提供一个Web UI，开发人员可以根据Trace ID查询，或者根据服务、接口等维度查找慢请求或错误请求，并查看其详细的甘特图，清晰地看到每个环节的耗时。\n\n*   **高可用价值**:\n\n    *   **性能瓶颈定位**: 当一个API响应缓慢时，通过调用链视图可以一目了然地看到是哪个下游服务的调用慢，还是哪个数据库查询慢，或是服务内部的某个方法耗时长。\n    *   **分布式系统错误分析**: 可以清晰地看到错误是在哪个服务节点上首次发生的，以及它是如何影响到上游服务的。\n    *   **服务依赖关系可视化**: 追踪系统可以根据收集到的数据，自动生成整个系统的服务依赖拓扑图，帮助理解复杂的系统结构。\n\n---\n\n### **6.3 本章总结**\n\n运维与可观测性是保障高可用架构“名副其实”的最后一块拼图，也是最关键的一块。**集中式日志**提供了事后追溯的详细线索，**监控告警**提供了宏观实时的健康心跳，而**分布式追踪**则提供了深入微观世界的性能“手术刀”。这三者结合，为我们构建了一个强大的、立体化的“作战指挥室”，使得我们有能力驾驭复杂、庞大的分布式系统，确保其持续稳定、高效地运行。\n\n**至此，我们已经完整地走完了构建一个高可用、高并发后端架构的六个核心章节。从外到内，从请求的入口到数据的存储，再到全方位的监控，每一层都环环相扣，共同支撑起一个强大而有弹性的系统。**","tags":["AI","protected","杂谈","架构"],"categories":["技术","架构"]},{"title":"AI提示词_学习笔记生成","url":"/2025/10/08/AI提示词_学习笔记生成/","content":"\n# 学习笔记生成\n\n你是一位耐心、善于解释的教师，擅长为完全没有专业背景的小白生成学习笔记。请遵循以下要求：\n\n【读者定位】\n\n- 完全没有专业背景，但懂最基础概念（如程序结构、变量、函数，或电路、电压、电流等基础概念，视领域而定）。\n\n【任务说明】\n\n1. 学习主题：__{填写领域主题，例如“RabbitMQ”或“模拟电子元件”}__\n2. 学习目标：__{填写希望掌握的核心内容，例如“消息队列基础、队列、交换机、消息发布订阅”}__\n\n【生成流程】\n\n1. **生成学习笔记大纲**\n\n   - 按章节或小节列出学习顺序\n\n   - 每个章节用一句话说明要讲解的核心内容\n\n   - 大纲必须考虑小白的理解顺序，由浅入深\n\n   - 示例大纲格式：\n\n     ```\n     第1章：XXX是什么？（一句话解释）\n     第2章：XXX的基本使用方法\n     第3章：XXX的高级应用\n     第4章：练习与复习\n     ```\n\n2. **确认大纲**\n\n   - 在生成完整内容前，请把大纲输出给我确认\n   - 待我确认大纲无误后，再生成详细内容\n\n3. **生成详细内容**\n\n   - 每章内容应包括：\n     - 简单易懂的语言解释概念\n     - 类比或生活中的例子\n     - 示例或练习题（例如代码示例、电路练习等）\n     - 章节小结或关键点总结\n   - 风格要求：\n     - 口语化、易懂\n     - 条理清晰，章节分明\n     - 鼓励思考，适当提出问题让读者自问自答\n\n","tags":["使用教程","AI","protected"],"categories":["AI提示词"]},{"title":"AI提示词_试题生成","url":"/2025/10/08/AI提示词_试题生成/","content":"\n\n# 试题生成\n\n你是一位耐心且富有创造力的教师，擅长为学习者设计检验知识掌握程度的练习题和提问。请遵循以下要求：\n\n【读者定位】\n\n- 学习者已经掌握部分知识，但需要通过练习来检验理解深度。\n- 假设学习者已经熟悉基础概念，但可能对复杂应用或细节理解不足。\n\n【任务说明】\n\n1. 学习领域：__{填写领域，例如“RabbitMQ”或“模拟电子元件”}__\n2. 已掌握内容：__{填写你已经掌握的知识点，例如“队列、交换机、基本消息发布与订阅”}__\n3. 目标：生成一份检验学习者掌握程度的练习题或提问，帮助发现理解的薄弱环节。\n\n【题目要求】\n\n- 题型多样：\n  - 选择题（多选/单选）\n  - 填空题\n  - 简答题\n  - 实操题或小实验题（例如代码编写、电路设计、配置操作）\n- 每题应有清晰的题目描述，必要时提供上下文或示例\n- 尽量设计**由浅入深**的题目，既考基础知识，也涉及实际应用\n- 对每题给出**参考答案或解析**，说明正确思路和关键点\n- 鼓励思考，不只是死记硬背\n- 如果适用，题目可以带有实际操作步骤或小实验指导\n\n【输出格式】\n\n按题型分类，例如：\n一、选择题\n\nXXX？\nA. ...\nB. ...\nC. ...\nD. ...\n正确答案：B\n解析：...\n\n二、填空题\n\nXXX\n正确答案：...\n\n三、简答题\n\nXXX\n参考答案：...\n\n四、实操题/小实验\n\nXXX\n指导步骤：...\n参考答案：...","tags":["使用教程","AI","protected"],"categories":["AI提示词"]},{"title":"Golang swag 库","url":"/2025/10/08/Golang_swag/","content":"\n\n\n# Go swag 从入门到实践\n\n**第1章：我们为什么需要 API 文档？—— 问题的起源**\n\n*   核心内容：讲解在团队协作和项目开发中，一份清晰的 API 文档是多么重要，以及手动维护文档的痛点。\n\n**第2章：Swag 是什么？—— 会写注释就会写文档的“魔法”**\n\n*   核心内容：介绍 `swag` 这个工具，把它比作一个能自动帮你把代码注释“翻译”成漂亮网页文档的“魔法师”。\n\n**第3-章：快速上手：三步生成你的第一个 API 文档**\n\n*   核心内容：通过一个最简单的 “Hello, World” 级别的 Go Web 项目，手把手带你完成安装、添加注释、生成并查看文档的全过程。\n\n**第4章：Swag 的“魔法咒语”：常用注解（Annotations）详解**\n\n*   核心内容：详细拆解 `swag` 的核心——注解语法，学习如何描述 API 的名称、参数、返回值等关键信息。\n\n**第5章：揭秘 Swag：它是如何工作的？**\n\n*   核心内容：简单说明 `swag` 的工作原理，让你明白它并不是真的“魔法”，而是一个代码解析和文件生成工具。\n\n**第6章：避坑指南：使用 Swag 的注意事项**\n\n*   核心内容：总结一些新手在使用 `swag` 时容易犯的错误和需要注意的地方，让你少走弯路。\n\n**第7章：总结与下一步**\n\n*   核心内容：回顾本次学习的重点，并为你指出接下来可以继续学习的方向。\n\n---\n\n\n\n## **第1章：我们为什么需要 API 文档？—— 问题的起源**\n\n嘿，同学！在学习任何一个新工具，尤其是像 `swag` 这样的“自动化”工具之前，我们必须先搞清楚一个最根本的问题：**我们到底遇到了什么麻烦，以至于需要一个新工具来拯救我们？**\n\n只有理解了“痛点”，我们才能真正明白这个工具的价值。\n\n### **1.1 一个生活中的场景：去餐厅吃饭**\n\n想象一下，你走进一家装修精美的餐厅，准备享用大餐。你（**客户端**，比如手机 App 或网页）坐下来，服务员递给你一本菜单（**API 文档**）。\n\n这本菜单上写得清清楚楚：\n\n*   **有什么菜？**（宫保鸡丁、鱼香肉丝……）\n*   **每道菜需要什么？**（比如，“牛排”这道菜，你需要告诉服务员要“七分熟”还是“全熟”。）\n*   **这道菜上上来是什么样的？**（菜单上的图片告诉你，这道菜有主食、有蔬菜沙拉。）\n\n你通过菜单，知道了这家餐厅的厨房（**服务端/后端**）能为你做什么。你点了一份“七分熟的牛排”，服务员把这个请求告诉了后厨。后厨一通操作，最后把一份完美的牛排端到你面前。\n\n整个过程非常顺利，因为你们之间有一份清晰的“沟通契约”——**菜单**。\n\n<br>\n\n> **关键概念：API**\n> 在软件开发中，**API** (Application Programming Interface，应用程序编程接口) 就扮演着“菜单”的角色。它定义了不同的软件部分之间如何沟通。后端程序员（厨师）开发好功能后，提供一份 API“菜单”，前端程序员（顾客）或其他服务就知道如何调用这些功能了。\n\n---\n\n### **1.2 软件开发中的“餐厅故事”：小明与小红的协作**\n\n现在，我们把场景切换到一家软件公司。\n\n-   **小明**：后端工程师，我们的“厨师”。他负责开发服务器的功能，比如“用户注册”、“获取商品列表”等。\n-   **小红**：前端工程师，我们的“顾客”。她负责开发用户能直接看到的网页或 App 界面。\n\n有一天，产品经理要求做一个“用户注册”的功能。\n\n**小明（厨师）** 在后端吭哧吭哧写好了代码，实现了一个功能：只要别人给他一个`用户名`和`密码`，他就能在数据库里创建一个新用户，并返回“注册成功”或“用户已存在”的消息。\n\n现在问题来了，小明怎么告诉**小红（顾客）** 这个功能该怎么用呢？\n\n小红心里有一堆问题，就像你看菜单时一样：\n\n1.  **我该访问哪个地址才能找到你这个“注册”功能？** （就像餐厅的门牌号和几号桌）\n\n    > *专业术语叫：**Endpoint** 或 **URL***\n\n2.  **我该用什么方法来请求？是 GET 还是 POST？** （就像你是要“点餐”还是只是“看看菜单”）\n\n3.  **我需要提供哪些信息给你？** 是 `username` 和 `password` 吗？还是 `user` 和 `pwd`？这些信息是放在哪里给你？\n\n    > *专业术语叫：**请求参数 (Request Parameters)***\n\n4.  **你处理完后，会返回给我什么？** 是返回一个简单的字符串 `\"注册成功\"`，还是一个包含更多信息的复杂结构（比如 JSON 对象）？成功和失败时返回的样子一样吗？\n\n    > *专业术语叫：**响应体 (Response Body)***\n\n你看，如果这些信息沟通不清楚，小红就完全没法开始工作。她可能会因为一个参数名写错（比如把 `username` 写成了 `user`），而调试大半天，最后发现是小明没告诉她。\n\n于是，最原始的“API 文档”诞生了。可能是一份 Word 文档，一个 Wiki 页面，甚至是聊天记录。小明在里面写清楚上面所有问题的答案，然后发给小红。\n\n\n\n---\n\n### **1.3 手动维护文档的“噩梦”**\n\n一开始，一切看起来都还不错。小明把文档写好，小红照着开发，项目顺利上线。\n\n但软件是不断迭代的。不久后，产品经理又提了新需求：“注册时，除了用户名和密码，还需要用户提供一个`邮箱(email)`”。\n\n**小明（厨师）** 立刻修改了他的代码，现在“注册”功能需要三个参数了：`username`, `password`, `email`。他急着下班，或者 只是 忘了，**没有去更新那份 Word 文档**。\n\n**灾难发生了！**\n\n几天后，小红发现所有新用户都注册不了了。她查了半天代码，看不出问题，最后跑去问小明。小明一拍脑袋：“哎呀！我加了个 `email` 参数，忘了和你说，也忘了更新文档了！”\n\n这就是手动维护 API 文档的**核心痛点**：\n\n1.  **容易忘记更新**：代码是“唯一真实”的，文档是“副本”。程序员改了代码后，很容易忘记或懒得去同步修改那个独立的文档。\n2.  **文档与代码不一致**：这是最致命的。一份过时的、错误的文档比没有文档更可怕，因为它会误导使用者，浪费大量调试时间。\n3.  **费时费力**：写文档本身就是一件枯燥的工作。每次修改代码，都要去找到对应的文档位置进行修改，效率极低。\n4.  **格式不统一**：张三写的文档喜欢用表格，李四写的喜欢用列表。团队里没有统一的、美观的、易于阅读的 API 文档格式。\n\n**想一想**：如果餐厅的菜单更新不及时，厨师新加了一道菜，或者某道菜的做法变了（比如“宫保鸡丁”现在默认加辣了），但菜单上还是老样子，顾客点餐时会发生多少误会和麻烦？\n\n---\n\n### **1.4 问题的总结与解决思路**\n\n好了，到现在我们已经把问题搞得很清楚了：\n\n1.  团队协作需要清晰的 API 文档（菜单）。\n2.  手动维护这份文档（菜单）非常痛苦，且极易出错。\n\n那么，有没有一种理想的方法，能够让“菜单”和“厨房里的菜谱”永远保持同步呢？\n\n**当然有！**\n\n我们能不能找到一种方法，让**代码自己来描述自己**？然后用一个工具，自动读取这些描述，生成一份永远不会过时、格式优美、交互友好的网页版“菜单”？\n\n这，就是 `swag` 准备为我们做的事情。它就是那个能自动根据厨师的菜谱（代码注释），打印出精美菜单（API 文档网页）的“魔法打印机”。\n\n### **本章小结**\n\n*   **API 是什么？** 它是软件不同部分之间沟通的桥梁，就像餐厅的菜单，定义了你能请求什么，以及会得到什么。\n*   **为什么需要 API 文档？** 因为它是指导开发者如何正确使用 API 的说明书，是团队协作的基石。\n*   **手动维护文档有什么问题？** 容易过时、与代码不一致、耗费时间、格式混乱。\n*   **我们的目标是什么？** 找到一种自动化的方式，让代码和文档永远保持同步。\n\n现在，你是不是已经深刻理解了我们即将学习的 `swag` 是为了解决什么问题而存在的？带着这个问题，我们下一章就来正式认识一下这位“魔法师”！\n\n\n\n---\n\n## **第2章：Swag 是什么？—— 会写注释就会写文档的“魔法”**\n\n上一章我们聊了手动维护 API 文档的种种痛苦，并且提出了一个美好的设想：能不能让代码自己来解释自己，然后有个工具自动帮我们生成文档？\n\n现在，揭晓答案的时刻到了！`swag` 就是来实现这个美好设想的工具。\n\n### **2.1 Swag 的自我介绍**\n\n你可以把 `swag` 想象成一位非常聪明的“文档翻译官”。\n\n它本身不是一个重量级的大软件，而是一个 Go 语言的工具库。它的核心工作流程非常简单：\n\n1.  **阅读你的代码**：它会去扫描你项目里的 Go 代码文件。\n2.  **寻找特殊注释**：它不会关心你所有的代码逻辑，只关心那些你按照特定格式写的“特殊注释”（我们后面会叫它**注解**，英文是 Annotation）。\n3.  **翻译成文档**：它把这些“特殊注释”翻译成一种标准化的 API 描述文件（叫做 OpenAPI/Swagger 规范文件）。\n4.  **生成网页**：最后，它利用这个标准文件，为你生成一套漂亮、可交互的 HTML 网页，也就是我们最终看到的 API 文档。\n\n> **一句话总结**：`swag` 是一个 Go 工具，它能将你代码里的**特定注释**，自动转换成**交互式 API 文档**。\n\n---\n\n### **2.2 回到我们的“餐厅”比喻**\n\n还记得小明和小红的故事吗？小明是厨师（后端），小红是顾客（前端）。\n\n在没有 `swag` 的世界里，小明（厨师）除了要写好自己的菜谱（代码），还得额外花时间去手写一份菜单（Word 文档），并且要时刻记着菜谱一改，菜单也要跟着改，心力交瘁。\n\n现在有了 `swag` 这个“魔法打印机”，情况完全不同了：\n\n1.  **在菜谱上做笔记**：小明现在不用写单独的菜单了。他只需要在自己的“宫保鸡丁”菜谱（代码文件）旁边，用“魔法荧光笔”（`swag` 的注解语法）直接写下笔记。\n\n    ```go\n    // 这是我的做菜代码...\n    // @菜名: 宫保鸡丁\n    // @描述: 一道经典的川味菜肴，酸甜可口。\n    // @需要食材: 鸡丁, 花生, 辣椒\n    // @返回样式: { \"status\": \"成功\", \"dish\": \"宫保鸡丁一份\" }\n    func GongBaoJiDingHandler(w http.ResponseWriter, r *http.Request) {\n        // ...复杂的炒菜过程...\n    }\n    ```\n\n2.  **一键打印**：当小明写完代码和这些笔记后，他只要在电脑上敲一个命令（比如 `swag init`），这个“魔法打印机”就会“嗡嗡嗡”地工作起来。\n\n3.  **生成精美菜单**：`swag` 会自动扫描所有菜谱上的“魔法笔记”，然后“duang”的一下，生成一份图文并茂、格式精美的网页菜单，直接交给小红。\n\n从此以后，小明只需要关心他的代码（菜谱）。只要菜谱里的做法或所需食材（API 参数）变了，他顺手改一下旁边的笔记，再敲一下命令，小红看到的菜单就自动更新了！\n\n**代码和文档，从此实现了完美的同步！** 这就是 `swag` 的核心价值。\n\n---\n\n### **2.3 最终的文档长什么样？—— Swagger UI**\n\n你可能会好奇，`swag` 生成的文档到底是什么样的？仅仅是把注释搬到网页上吗？\n\n远不止如此！`swag` 实际上是遵循一个业界非常流行的标准，叫做 **OpenAPI 规范**（它的前身就是大名鼎鼎的 **Swagger 规范**）。\n\n你可以理解为，`swag` 先是把你的注释翻译成了一份“标准数据文件”（一个 `json` 或 `yaml` 文件），这份文件以一种通用的格式描述了你所有的 API。\n\n然后，一个叫做 **Swagger UI** 的工具会读取这份标准文件，并把它渲染成一个非常酷的交互式网页。\n\n它有什么特点呢？\n\n*   **清晰的列表**：把你所有的 API 按照模块（比如“用户管理”、“商品管理”）分门别类地列出来。\n*   **详细的信息**：点开任何一个 API，你都能看到它的 URL、请求方法（GET/POST 等）、详细描述、所有参数的说明（参数名、类型、是否必需等）以及返回数据的格式。\n*   **在线调试功能（杀手级功能！）**：这是最棒的部分！在文档页面上，你可以直接填写参数，然后点击一个 \"Try it out\" 或 \"Execute\" 按钮，**直接调用这个 API**！你不用写任何代码，就能立刻测试后端接口是否正常工作，返回的数据对不对。这对前端的小红来说，简直是天大的福音！\n\n**想一想**：这就像在餐厅的电子菜单上，你不仅能看到菜品的图片和介绍，旁边还有一个“试吃”按钮。你点一下，服务员就会立刻给你端上一小份样品尝尝。这体验是不是太棒了？\n\n---\n\n### **本章小结**\n\n*   **Swag 是什么？** 一个能把 Go 代码中的“特殊注释”自动生成为 API 文档的工具。\n*   **它的工作原理？** 读取代码注释 -> 生成遵循 OpenAPI 规范的中间文件 -> 利用 Swagger UI 渲染成交互式网页。\n*   **它的核心价值？** **让文档与代码保持同步**，彻底解决手动维护文档的痛点，实现“代码即文档”。\n*   **最终产出物？** 一个美观、清晰、且支持**在线调试**的 API 文档网站。\n\n好了，现在我们已经知道了 `swag` 是什么，以及它为什么这么神奇。是不是已经跃跃欲试，想亲手生成一份自己的 API 文档了？\n\n下一章，我们就来动手实践！准备好你的 Go 环境，我们要开始写代码了！\n\n\n\n准备好了吗？让我们开始搭建你的第一个自动化 API 文档！\n\n---\n\n## **第3章：快速上手：三步生成你的第一个 API 文档**\n\n理论说再多，不如亲手敲一遍代码。这一章，我们会像拼乐高一样，一步步搭建一个最简单的 Go Web 项目，并用 `swag` 为它生成一份漂亮的 API 文档。\n\n整个过程可以清晰地分为三步：**搭建项目 -> 添加注解 -> 生成文档**。\n\n### **第零步：环境准备（磨刀不误砍柴工）**\n\n在开始之前，请确保你的电脑已经安装好了 Go 语言环境。你可以在终端（命令行工具）里输入以下命令来检查：\n\n```bash\ngo version\n```\n\n如果你能看到类似 `go version go1.18 linux/amd64` 这样的输出，就说明环境没问题。\n\n接下来，创建一个新的项目文件夹，并进入这个文件夹。\n\n```bash\nmkdir my-swag-app\ncd my-swag-app\n```\n\n然后，初始化 Go 的模块管理，这会生成一个 `go.mod` 文件。\n\n```bash\ngo mod init my-swag-app\n```\n\n### **第一步：安装 Swag 与搭建基础项目**\n\n**1. 安装 Swag 命令行工具**\n\n`swag` 主要包含两部分：一个是能生成文档的**命令行工具**，另一个是能在我们网页里展示文档页面的**代码库**。我们先来安装命令行工具。\n\n在终端里运行：\n\n```bash\ngo install github.com/swaggo/swag/cmd/swag@latest\n```\n\n安装成功后，你可以通过 `swag -v` 命令来验证。如果能看到版本号，就说明成功了。\n\n**2. 搭建一个简单的 Web 服务器**\n\n为了演示，我们将使用一个非常流行的 Go Web 框架 `Gin`，因为它简单快捷。同时，我们还需要 `gin-swagger` 和 `files` 这两个库，它们是 `swag` 的好搭档，用来在 `Gin` 项目里展示文档页面。\n\n安装这三个库：\n\n```bash\ngo get -u github.com/gin-gonic/gin\ngo get -u github.com/swaggo/gin-swagger\ngo get -u github.com/swaggo/files\n```\n\n接下来，在你的项目文件夹 `my-swag-app` 中，创建一个 `main.go` 文件，然后把下面的代码复制进去。这是一个最基础的、不包含任何 `swag` 注解的 Web 服务器。\n\n**`main.go` (初始版本)**\n\n```go\npackage main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc main() {\n\t// 1. 创建路由引擎\n\tr := gin.Default()\n\n\t// 2. 定义一个 API 路由\n\t// 当用户访问 /hello?name=张三 时，会调用 PingHandler 函数\n\tr.GET(\"/hello\", PingHandler)\n\t\n\t// 3. 启动服务，监听在 8080 端口\n\tr.Run(\":8080\")\n}\n\n// PingHandler 是这个 API 的处理函数\nfunc PingHandler(c *gin.Context) {\n\t// 从 URL 查询参数中获取 \"name\" 的值，如果没有，则默认为 \"Guest\"\n\tname := c.DefaultQuery(\"name\", \"Guest\")\n\t\n\t// 返回一个 JSON 响应\n\tc.JSON(http.StatusOK, gin.H{\n\t\t\"message\": \"pong, \" + name,\n\t})\n}\n```\n\n现在，你可以运行这个程序：\n\n```bash\ngo run main.go\n```\n\n然后在浏览器或 Postman 等工具中访问 `http://localhost:8080/hello?name=Coder`，你会看到返回结果：`{\"message\":\"pong, Coder\"}`。\n\n很好！我们的基础项目已经跑起来了。\n\n### **第二步：添加“魔法咒语”—— 编写 Swag 注解 (Annotation)**\n\n现在，我们要开始对代码“施法”了。`swag` 的注解本质上就是一种特殊格式的注释，它总是以 `@` 符号开头。\n\n我们将为我们的项目添加两种注解：\n\n1.  **全局注解**：写在 `main` 函数的上方，用来描述整个项目的基本信息，比如标题、版本号、API 的基础路径等。\n2.  **API 注解**：写在具体的 `Handler` 函数（处理请求的函数）上方，用来描述这一个 API 的所有细节。\n\n现在，请用下面的代码**完整替换**你的 `main.go` 文件。仔细看新增的那些注释。\n\n**`main.go` (添加注解后)**\n\n```go\npackage main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n\t\n\t// 引入 swag 必需的库\n\t_ \"my-swag-app/docs\" // 注意这里的路径！ `my-swag-app` 是你的 go.mod 里的模块名\n\tswaggerFiles \"github.com/swaggo/files\"\n\tginSwagger \"github.com/swaggo/gin-swagger\"\n)\n\n\n// @title           我的第一个 Swag API\n// @version         1.0\n// @description     这是一个使用 Gin 和 Swag 构建的示例服务.\n// @termsOfService  http://swagger.io/terms/\n\n// @contact.name   API Support\n// @contact.url    http://www.swagger.io/support\n// @contact.email  support@swagger.io\n\n// @license.name  Apache 2.0\n// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html\n\n// @host      localhost:8080\n// @BasePath  /\n\n// @schemes http\nfunc main() {\n\tr := gin.Default()\n\n\t// API 路由\n\tr.GET(\"/hello\", PingHandler)\n\n\t// 文档路由\n\t// 访问 http://localhost:8080/swagger/index.html 就可以看到文档了\n\tr.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n\n\tr.Run(\":8080\")\n}\n\n// PingHandler 回复一个问候\n// @Summary      Ping example\n// @Description  这是一个 \"ping\" API 的示例，它会带上你的名字进行回复.\n// @Tags         示例API\n// @Accept       json\n// @Produce      json\n// @Param        name   query      string  false  \"你的名字\" default(Guest)\n// @Success      200    {object}   map[string]string\n// @Router       /hello [get]\nfunc PingHandler(c *gin.Context) {\n\tname := c.DefaultQuery(\"name\", \"Guest\")\n\tc.JSON(http.StatusOK, gin.H{\n\t\t\"message\": \"pong, \" + name,\n\t})\n}\n```\n\n**代码讲解**：\n\n*   **全局注解（`main` 函数上方）**：\n    *   `@title`, `@version`, `@description`: 定义了文档的标题、版本和描述。\n    *   `@host`: 告诉 `swag` 我们的服务地址是什么，这在在线调试时非常重要。\n    *   `@BasePath`: API 的基础路径，我们这里是根路径 `/`。\n*   **API 注解（`PingHandler` 函数上方）**：\n    *   `@Summary`: API 的一句话简介，会显示在列表里。\n    *   `@Description`: 更详细的描述。\n    *   `@Tags`: API 的分组标签，方便管理。\n    *   `@Accept`/`@Produce`: 定义这个 API 接收和返回的数据格式（这里是 `json`）。\n    *   `@Param`: **非常重要**！用来定义参数。格式是：`参数名` `参数位置` `数据类型` `是否必需` `注释` `其他属性`。\n        *   `name query string false \"你的名字\"` 的意思是：有一个名叫 `name` 的参数，它在 `query`（URL `?` 后面）里，类型是 `string`，不是必需的 (`false`)，注释是 \"你的名字\"。\n    *   `@Success`: 定义成功响应。格式是：`HTTP状态码` `{返回数据结构}` `注释`。我们这里 `200` 表示成功，返回一个键值都是字符串的 map。\n    *   `@Router`: 定义路由路径和 HTTP 方法。格式是：`路径` `[HTTP方法]`。\n\n### **第三步：生成并查看文档**\n\n万事俱备，只欠东风！现在，我们在项目根目录下（`my-swag-app` 文件夹）打开终端，运行 `swag` 的初始化命令：\n\n```bash\nswag init\n```\n\n执行后，你会看到类似这样的输出：\n`create docs.go`\n`create swagger.json`\n`create swagger.yaml`\n\n同时，你的项目文件夹里会多出一个 `docs` 文件夹，里面就装着 `swag` 帮我们生成的文档资源。\n\n**最后一步，让我们的程序跑起来！**\n\n```bash\ngo run main.go\n```\n\n服务启动后，打开你的浏览器，访问这个神奇的地址：\n\n**http://localhost:8080/swagger/index.html**\n\n**见证奇迹的时刻！** 你会看到一个漂亮的 API 文档页面，上面清晰地列出了我们刚刚定义的 \"Ping example\" API。你可以点开它，看到所有详细信息，甚至可以在页面上输入你的名字，点击 \"Try it out\"，然后 \"Execute\"，亲身体验在线调试的快感！\n\n---\n\n### **本章小结**\n\n恭喜你！你已经成功地使用 `swag` 生成了你的第一个 API 文档。我们来回顾一下这个核心流程：\n\n1.  **安装工具**：安装 `swag` 命令行工具和相关的 Go 库 (`gin-swagger`, `files`)。\n2.  **编写注解**：在 `main` 函数上写**全局注解**，在处理函数上写**API 注解**。\n3.  **生成文档**：运行 `swag init` 命令，生成 `docs` 文件夹。\n4.  **集成与运行**：在代码中添加文档路由，然后运行程序，访问 `/swagger/index.html` 查看。\n\n这个流程会成为你未来工作的日常。每当你修改了 API 的逻辑或参数，你只需要：\n**修改代码/注解 -> 重新运行 `swag init` -> 重启你的服务**\n你的文档就永远和代码保持同步了！\n\n现在你已经掌握了基本操作，但你可能对 `@Param`、`@Success` 等注解的具体写法还有很多疑问。别担心，下一章，我们将深入学习这些“魔法咒语”的详细语法和更多用法。\n\n\n\n\n\n你已经学会了如何“让 `swag` 跑起来”，现在是时候深入理解它背后的“语法规则”了。只有掌握了这些规则，你才能随心所欲地生成任何你想要的文档。\n\n这一章，我们就来详细拆解 `swag` 的核心——注解（Annotations），也就是我们之前说的“魔法咒语”。\n\n---\n\n## **第4章：Swag 的“魔法咒语”：常用注解（Annotations）详解**\n\n把注解想象成你在填写一份非常详细的“API 注册表”。这份表单上的每一项（比如“名称”、“功能”、“所需材料”等），都对应一个 `@` 开头的注解。`swag` 工具就是一个严格的“审查员”，它会读取你填写的这份表单，并据此生成最终的文档。\n\n我们将注解分为几大类来学习：**API 身份信息**、**请求信息**、**响应信息**和**路由信息**。\n\n### **4.1 API 的“身份证”：我是谁，我做什么？**\n\n这类注解用来描述 API 的基本信息，让别人一眼就能看懂它的用途。\n\n*   **`@Summary`**\n\n    *   **用途**：API 的一句话摘要，是它的“标题”。通常在文档列表中显示。\n\n    *   **语法**：`@Summary 任意描述性文字`\n\n    *   **示例**：\n\n        ```go\n        // @Summary 获取单个用户信息\n        ```\n\n*   **`@Description`**\n\n    *   **用途**：API 的详细描述。可以写多行，用来解释更复杂的业务逻辑或注意事项。\n\n    *   **语法**：`@Description 更详细的说明，可以换行。`\n\n    *   **示例**：\n\n        ```go\n        // @Description 根据用户ID获取用户的详细信息，包括姓名、年龄和注册日期。\n        // @Description 注意：如果用户ID不存在，将返回404错误。\n        ```\n\n*   **`@Tags`**\n\n    *   **用途**：为 API 分组。在文档页面上，相同 `Tags` 的 API 会被归类到一起，非常利于管理。\n\n    *   **语法**：`@Tags 标签名1,标签名2` (多个标签用逗号隔开)\n\n    *   **示例**：\n\n        ```go\n        // @Tags 用户管理\n        ```\n\n*   **`@ID`**\n\n    *   **用途**：为操作设置一个唯一的标识符。在某些高级应用（如生成客户端代码）中会用到，通常可以省略。\n\n    *   **语法**：`@ID 操作的唯一ID`\n\n    *   **示例**：\n\n        ```go\n        // @ID GetUserByID\n        ```\n\n---\n\n### **4.2 “顾客”需要提供什么？—— 定义请求参数 `@Param`**\n\n这是最重要、也是最复杂的注解之一。它告诉使用者，调用这个 API 需要提供哪些数据。\n\n*   **`@Param`**\n\n    *   **用途**：定义一个请求参数。每个参数都需要单独写一行 `@Param` 注解。\n    *   **语法**：`@Param 参数名 参数位置 数据类型 是否必需 \"注释\" [其他属性]`\n    *   **参数详解**：\n        1.  **参数名 (Parameter Name)**：例如 `userID`、`username`。\n        2.  **参数位置 (Parameter In)**：参数从哪里来？\n            *   `query`：URL 中 `?` 后面的参数，如 `/users?id=123`。\n            *   `path`：URL 路径中的一部分，如 `/users/123` (需要配合 Gin 的 `:id` 格式)。\n            *   `header`：HTTP 请求头里的参数，如 `Authorization` Token。\n            *   `body`：整个 HTTP 请求体，通常用于 POST/PUT 请求，用来传递复杂的 JSON 数据。\n            *   `formData`：表单数据，用于 `application/x-www-form-urlencoded` 或 `multipart/form-data` 格式的提交。\n        3.  **数据类型 (Data Type)**：参数的类型，如 `string`、`int`、`boolean`、`file` 等。\n        4.  **是否必需 (Required)**：`true` 或 `false`。\n        5.  **注释 (Comment)**：用双引号括起来的参数描述。\n        6.  **其他属性 (Attributes)**：可选，用于提供更多约束，如 `default(Guest)`、`enums(male,female)`、`maxLength(10)` 等。\n\n*   **`@Param` 示例大合集**\n\n    **1. `query` 参数（最常见）**\n\n    ```go\n    // @Param   page  query     int  false  \"页码\" default(1)\n    // @Param   size  query     int  false  \"每页大小\" default(10)\n    ```\n\n    **2. `path` 参数**\n\n    ```go\n    // @Summary 获取单个用户信息\n    // @Param   id   path      int  true   \"用户ID\"\n    // @Router /users/{id} [get]\n    // Gin 路由应该这样写: r.GET(\"/users/:id\", GetUser)\n    ```\n\n    *注意：`@Router` 里的路径 `{id}` 必须和 `@Param` 里的 `id` 对应。*\n\n    **3. `body` 参数（用于提交 JSON）**\n\n    ```go\n    // @Summary 创建一个新用户\n    // @Accept  json\n    // @Param   user body      models.User  true   \"用户信息\"\n    // @Router /users [post]\n    // 这里的 `models.User` 是你项目里定义的一个 Go 结构体 (struct)，我们稍后会讲。\n    ```\n\n    *`@Accept` 注解用来声明此 API 接收的数据格式。*\n\n---\n\n### **4.3 “厨师”会返回什么？—— 定义响应 `@Success` & `@Failure`**\n\n这两个注解用来告诉使用者，API 调用成功或失败时，会返回什么样的数据。\n\n*   **语法**：`@Success/@Failure HTTP状态码 {返回类型} 数据模型 \"注释\"`\n\n*   **参数详解**：\n\n    1.  **HTTP状态码 (HTTP Status Code)**：如 `200` (成功)、`400` (错误请求)、`404` (未找到)、`500` (服务器内部错误)。\n    2.  **返回类型 (Response Type)**：通常是 `object` (单个对象) 或 `array` (对象数组)。\n    3.  **数据模型 (Data Model)**：\n        *   可以是基础类型，如 `string`, `int`。\n        *   可以是 `map[string]string` 这样的简单集合。\n        *   **最常用的是**：指向你项目中定义的 Go 结构体，如 `models.User` 或 `[]models.User` (表示用户数组)。\n    4.  **注释 (Comment)**：对这个响应的描述。\n\n*   **`@Success` & `@Failure` 示例**\n\n    **1. 返回简单消息**\n\n    ```go\n    // @Success 200 {object} map[string]string \"{\"message\": \"操作成功\"}\"\n    // @Failure 400 {object} map[string]string \"{\"error\": \"无效的输入\"}\"\n    ```\n\n    **2. 返回一个复杂对象（结构体）**\n\n    ```go\n    // @Success 200 {object} models.User \"成功返回用户信息\"\n    ```\n\n    **3. 返回一个对象数组**\n\n    ```go\n    // @Success 200 {array} models.User \"成功返回用户列表\"\n    ```\n\n    *`@Produce` 注解用来声明此 API 返回的数据格式，通常是 `application/json`。*\n\n---\n\n### **4.4 API 的“门牌号” —— 定义路由 `@Router`**\n\n这个注解至关重要，它把所有信息和具体的 URL 路径、HTTP 方法绑定在了一起。\n\n*   **`@Router`**\n\n    *   **用途**：定义 API 的路由路径和请求方法。\n\n    *   **语法**：`@Router /path/to/resource [http_method]`\n\n    *   **示例**：\n\n        ```go\n        // @Router /users [post]        // 创建用户\n        // @Router /users/{id} [get]      // 获取单个用户\n        // @Router /users/{id} [put]      // 更新单个用户\n        // @Router /users/{id} [delete]   // 删除单个用户\n        ```\n\n---\n\n### **4.5 综合实战：定义一个完整的 CRUD**\n\n现在，让我们把所有学到的注解整合起来，为一个 `User` 模型定义一个完整的创建和查询 API。\n\n**首先，创建一个 `models` 文件夹，并在其中创建 `user.go` 文件**\n\n**`models/user.go`**\n\n```go\npackage models\n\n// User 代表一个用户模型\ntype User struct {\n    ID   int    `json:\"id\" example:\"1\"`\n    Name string `json:\"name\" example:\"John Doe\"`\n    Age  int    `json:\"age\" example:\"30\"`\n}\n```\n\n*这里的 `json:\"...\"` 是 Go 的结构体标签，用于序列化为 JSON。`example:\"...\"` 是 `swag` 的注解，用于在文档中生成示例值。*\n\n**然后，修改你的 `main.go`，添加新的路由和处理函数**\n\n**`main.go` (片段)**\n\n```go\n// ... import 部分省略 ...\nimport \"my-swag-app/models\" // 引入你的模型包\n\n// ... 全局注解部分省略 ...\n\n// GetUserByID 根据ID获取用户信息\n// @Summary      获取单个用户\n// @Description  根据给定的用户ID返回用户数据\n// @Tags         用户管理\n// @Produce      json\n// @Param        id   path      int  true  \"用户 ID\"\n// @Success      200  {object}  models.User\n// @Failure      404  {object}  map[string]string\n// @Router       /users/{id} [get]\nfunc GetUserByID(c *gin.Context) {\n    // 实际项目中这里应该是查询数据库的逻辑\n    // 我们这里为了演示，直接返回一个假数据\n    id := c.Param(\"id\")\n    if id == \"1\" {\n        user := models.User{ID: 1, Name: \"John Doe\", Age: 30}\n        c.JSON(http.StatusOK, user)\n        return\n    }\n    c.JSON(http.StatusNotFound, gin.H{\"error\": \"User not found\"})\n}\n\n// CreateUser 创建一个新用户\n// @Summary      创建用户\n// @Description  从请求体中接收用户信息并创建一个新用户\n// @Tags         用户管理\n// @Accept       json\n// @Produce      json\n// @Param        user   body      models.User  true  \"用户信息\"\n// @Success      201    {object}  models.User\n// @Failure      400    {object}  map[string]string\n// @Router       /users [post]\nfunc CreateUser(c *gin.Context) {\n    var user models.User\n    // 将请求体中的 JSON 绑定到 user 结构体\n    if err := c.ShouldBindJSON(&user); err != nil {\n        c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n        return\n    }\n    // 实际项目中这里是存入数据库的逻辑\n    // 我们这里为了演示，假装设置一个ID并返回\n    user.ID = 2 \n    c.JSON(http.StatusCreated, user)\n}\n\nfunc main() {\n    // ...\n    r := gin.Default()\n\n    // 用户管理 API 路由组\n    userRoutes := r.Group(\"/users\")\n    {\n        userRoutes.GET(\"/:id\", GetUserByID)\n        userRoutes.POST(\"\", CreateUser)\n    }\n\n    r.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n    // ...\n    r.Run(\":8080\")\n}\n```\n\n**操作步骤：**\n\n1.  保存以上代码。\n2.  在终端运行 `swag init`。\n3.  运行 `go run main.go`。\n4.  访问 `http://localhost:8080/swagger/index.html`。\n\n你会看到一个新的 \"用户管理\" 分组，里面包含了我们刚刚定义的两个 API。点开 \"创建用户\" (`POST /users`)，你会发现它的请求体部分已经为你生成了一个包含 `name` 和 `age` 的 JSON 示例，这就是 `@Param` 引用 `models.User` 结构体的强大之处！\n\n---\n\n### **本章小结**\n\n我们详细学习了 `swag` 最核心的几类注解：\n\n*   **身份注解**：`@Summary`, `@Description`, `@Tags`，用于描述 API 的基本信息。\n*   **请求注解**：`@Param`，用于定义输入的参数，是功能最强大的注解。\n*   **响应注解**：`@Success`, `@Failure`，用于定义不同情况下的输出。\n*   **路由注解**：`@Router`，用于将所有信息与 URL 和 HTTP 方法绑定。\n\n掌握了这些，你就掌握了 `swag` 的 80%。剩下的就是不断练习，熟悉各种参数位置 (`query`, `path`, `body` 等) 和数据类型 (基础类型、自定义结构体、数组) 的组合使用。\n\n接下来，我们将简单聊聊 `swag` 到底是怎么工作的，揭开它神秘的“魔法”面纱。\n\n\n\n到现在为止，你已经掌握了 `swag` 的使用方法，能够熟练地通过写注释来生成漂亮的 API 文档了。对你来说，`swag` 可能还像一个神奇的“黑盒子”：我写了注释，敲了命令，漂亮的网页就出来了。\n\n这一章，我们就来打开这个“黑盒子”，用最简单的方式看一看它内部的构造。理解了它的工作原理，你不仅能更好地使用它，还能在遇到问题时，更快地找到原因。\n\n---\n\n## **第5章：揭秘 Swag：它是如何工作的？**\n\n`swag` 并不是真的有什么“魔法”，它本质上是一个**代码解析器**和**文件生成器**的组合。它的整个工作流程，就像一个高度自动化的工厂流水线。\n\n让我们把 `swag init` 这个命令的执行过程拆解成三个主要步骤：\n\n### **步骤一：扫描与解析（流水线的第一站：原材料检验）**\n\n当你运行 `swag init` 时，`swag` 工具首先会像一个勤劳的机器人，开始扫描你项目中的所有 `.go` 文件。\n\n但它不是漫无目的地扫描，它的目标非常明确：**寻找那些以 `// @` 开头的特殊注释行**。\n\n在这个过程中，它利用了 Go 语言自带的一个强大工具包——`go/ast` (Abstract Syntax Tree，抽象语法树)。\n\n*   **什么是抽象语法树（AST）？**\n    你可以把它想象成对你代码的一种“结构化解剖”。`go/ast` 包能够把你的 Go 代码文本，转换成一个程序能够理解的、树状的数据结构。在这棵“树”上，每个节点都代表了代码的一部分，比如一个函数声明、一个变量定义、或者一行注释。\n\n    **生活中的类比：**\n    这就像一位语法老师在分析一个句子：“勤劳的小明（主语）昨天（状语）高兴地（状语）完成了（谓语）家庭作业（宾语）。”\n    老师并不是把这句话当成一串无意义的文字，而是解析出了它的语法结构。\n\n    `swag` 就是这样一位“语法老师”，它能准确地识别出：“哦，这行注释 `// @Summary 获取用户信息` 是挂在 `GetUserByID` 这个函数声明节点上面的！”\n\n通过这种方式，`swag` 就能把注解和它们所描述的函数精确地关联起来。\n\n### **步骤二：翻译与整合（流水线的第二站：加工与组装）**\n\n`swag` 找到了所有的注解和它们对应的代码结构后，就开始了“翻译”工作。\n\n它的目标是生成一份遵循 **OpenAPI 3.0 规范**（或旧版的 Swagger 2.0）的 `swagger.json` 或 `swagger.yaml` 文件。\n\n*   **什么是 OpenAPI 规范？**\n    它是一个用来描述 RESTful API 的国际标准格式。你可以把它理解成 API 界的“普通话”。这份规范用 JSON 或 YAML 格式，极其严谨地定义了描述一个 API 所需的全部元素：路径、操作（GET/POST）、参数、请求体、响应、数据模型等等。\n    全世界有成千上百的工具都认识这门“普通话”，比如 Postman、Swagger UI 等。\n\n`swag` 的翻译工作就是把 `swag` 自定义的注解格式，转换成 OpenAPI 规范的标准格式。\n\n*   `// @Summary 获取用户信息`  ->  会被翻译成 JSON 中 `summary` 字段。\n*   `// @Param id path int true \"用户ID\"` -> 会被翻译成 `parameters` 数组中的一个对象，里面详细定义了 `name: \"id\"`, `in: \"path\"`, `required: true`, `schema: { \"type\": \"integer\" }` 等等。\n*   `// @Success 200 {object} models.User` -> 会被翻译成 `responses` 对象下的 `200` 字段，并且会去解析 `models.User` 这个结构体，把它也转换成 OpenAPI 规范里的 `schemas` 定义。\n\n所有 API 的信息都被翻译和整合后，最终形成一个巨大的、结构化的 `swagger.json` 文件。这个文件才是 `swag` 的**核心产物**。\n\n你可以打开你项目 `docs` 目录下的 `swagger.json` 文件看一看，虽然内容很多，但仔细观察，你就能找到和你写的注解一一对应的字段。\n\n### **步骤三：打包与呈现（流水线的最后一站：包装与上架）**\n\n`swag` 生成了标准的 `swagger.json` 文件，但这个 JSON 文件是给机器看的，对人类并不友好。所以，还需要最后一步：**展示**。\n\n这一步其实主要由两个我们之前安装的库来完成：\n\n1.  **`github.com/swaggo/files`**\n    这个库里内置了 **Swagger UI** 的所有静态资源文件（HTML, CSS, JavaScript）。Swagger UI 是一个开源项目，它的唯一工作就是读取 OpenAPI 规范文件（比如我们的 `swagger.json`），并把它渲染成我们看到的那个漂亮的、可交互的网页。\n\n2.  **`github.com/swaggo/gin-swagger`**\n    这是一个适配器（Adapter），它的作用是把 Swagger UI 和 Gin 框架无缝地结合起来。我们在 `main.go` 里写的那行代码：\n\n    ```go\n    r.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n    ```\n\n    它的意思就是：创建一个路由 `/swagger/`，当用户访问这个地址时，就由 `gin-swagger` 这个“中间人”来处理。它会负责加载 `swaggo/files` 里的 HTML 页面，并把我们生成的 `docs/swagger.json` 文件的内容喂给这个页面。\n\n于是，当你在浏览器里访问 `http://localhost:8080/swagger/index.html` 时：\n\n1.  Gin 框架匹配到路由，请求被 `gin-swagger` 接管。\n2.  `gin-swagger` 返回 Swagger UI 的主 HTML 页面。\n3.  浏览器加载这个 HTML 页面，页面里的 JavaScript 代码会去请求 `/swagger/doc.json` (这是 `gin-swagger` 自动配置的另一个内部路由)。\n4.  `gin-swagger` 读取我们项目里 `docs/swagger.json` 文件的内容，并返回给浏览器。\n5.  Swagger UI 的 JavaScript 拿到 JSON 数据后，动态地在页面上渲染出所有的 API 列表、参数输入框、示例等等。\n\n至此，整个流程全部完成！\n\n---\n\n## **本章小结**\n\n现在，我们再回头看 `swag`，它是不是清晰多了？\n\n*   **`swag init` 命令做了什么？**\n    1.  **解析 (Parse)**：使用 `go/ast` 解析 Go 源代码，找到 `@` 注解和它们关联的函数。\n    2.  **生成 (Generate)**：将解析到的信息，翻译成标准的 `swagger.json` 和 `swagger.yaml` 文件，并存放在 `docs` 目录。\n    3.  **创建入口 (Create Entrypoint)**：生成一个 `docs/docs.go` 文件，这个文件里包含了生成的 JSON/YAML 数据，并注册自己，让 `gin-swagger` 这样的库能找到它。\n\n*   **程序运行时发生了什么？**\n    1.  `gin-swagger` 负责创建一个路由。\n    2.  `swaggo/files` 提供了 Swagger UI 的静态页面。\n    3.  当用户访问文档页时，`gin-swagger` 把 `docs/swagger.json` 的内容提供给 Swagger UI 的前端页面进行渲染。\n\n理解了这个原理，你就能明白为什么每次修改了注解之后，都必须**重新运行 `swag init`**。因为 `swagger.json` 文件不会自动更新，你必须手动触发这个“翻译和生成”的过程。\n\n好了，原理我们已经搞懂了。在学习的最后，我将为你总结一些新手常遇到的“坑”以及一些最佳实践，帮助你在未来的使用中少走弯路。\n\n\n\n\n\n好的，同学！我们已经到达了学习之旅的尾声。\n\n你现在已经知道了 `swag` 是什么，怎么用，以及它背后的工作原理。可以说，你已经从一个“小白”成长为一名合格的 `swag` 使用者了。\n\n但在实际的开发道路上，我们总会遇到一些小石子、小水坑。这一章，作为老师，我将把我的一些经验传授给你，帮你提前识别并绕开这些常见的“坑”，让你的 `swag` 之旅更加顺畅。\n\n---\n\n## **第6章：避坑指南：使用 Swag 的注意事项**\n\n这一章更像是一份“温馨提示清单”。当你遇到问题时，不妨回来查阅一下，很可能答案就在这里。\n\n### **1. 忘了这一步，一切都白费：`swag init`**\n\n*   **现象**：我明明在代码里改了注解，为什么刷新文档页面一点变化都没有？\n*   **原因**：这是99%的新手都会犯的错误。`swag` 不会实时监控你的代码变化。文档页面依赖的是 `docs` 目录下的 `swagger.json` 文件，而这个文件只有在你运行 `swag init` 命令时才会被更新。\n*   **黄金法则**：**每次修改完任何 `@` 注解后，都必须重新在项目根目录下执行 `swag init` 命令。**\n*   **进阶技巧**：可以结合一些文件监控工具（如 `air`、`fresh` 等），配置成在 `.go` 文件保存时自动执行 `swag init`，实现自动化。\n\n---\n\n### **2. 神秘的 `import _ \"...\"`**\n\n*   **现象**：我运行了 `swag init`，`docs` 目录也生成了，程序也能跑，但访问文档页时一片空白，或者提示 “Failed to load API definition.”。\n\n*   **原因**：`swag` 在生成 `docs/docs.go` 文件时，会使用一个 `init()` 函数来注册生成的 swagger 规范。为了让你的主程序能够执行到这个 `init()` 函数，你必须在你的 `main.go`（或者程序的入口文件）里匿名导入（`import _ \"...\"`）这个 `docs` 包。\n\n*   **正确姿势**：确保你的 `main.go` 中有下面这行代码，并且路径正确。\n\n    ```go\n    import _ \"my-swag-app/docs\" \n    // \"my-swag-app\" 是你 go.mod 文件里定义的模块名\n    ```\n\n    匿名导入的 `_` 意味着：我不需要使用这个包里的任何变量或函数，我只是想让你这个包的代码被加载，从而执行它的 `init()` 函数。\n\n---\n\n### 3. 结构体（Struct）无法正确解析\n\n*   **现象**：我在 `@Success` 或 `@Param` 中引用了一个自定义的结构体，比如 `models.User`，但是在文档页面上，这个模型（Model）的字段显示不出来，或者是空的。\n\n*   **原因与解决方案**：\n\n    1.  **没有写 `json` 标签**：`swag` 默认通过 `json:\"...\"` 标签来识别字段名。请确保你的结构体字段都有这个标签。\n\n        ```go\n        // 错误示例\n        type User struct {\n            ID int\n        }\n        // 正确示例\n        type User struct {\n            ID int `json:\"id\"`\n        }\n        ```\n\n    2.  **字段是私有的**：Go 语言中，首字母小写的字段是包内私有的，`swag` 无法在外部解析它们。请确保所有需要展示在文档中的字段名**首字母大写**。\n\n        ```go\n        // 错误示例\n        type User struct {\n            id int `json:\"id\"`\n        }\n        // 正确示例\n        type User struct {\n            ID int `json:\"id\"`\n        }\n        ```\n\n    3.  **引用了其他包的结构体**：如果你的结构体引用了来自其他第三方库的结构体，`swag` 可能无法解析它。解决方法是创建一个新的、你自己的结构体（有时称为 DTO - Data Transfer Object），只包含你需要的字段，然后在你的处理函数中进行数据转换。\n\n---\n\n### **4. `@Param` 和 `@Router` 的路径参数不匹配**\n\n*   **现象**：定义了路径参数，但在文档里无法正确渲染，或者在线调试时参数没有传递。\n\n*   **原因**：`@Param` 注解中定义的路径参数名，必须和 `@Router` 注解中的占位符完全一致。\n\n*   **正确姿势**：\n\n    ```go\n    // @Param   userID   path      int  true  \"用户 ID\"\n    // @Router /users/{userID} [get] \n    // 这里都是 userID，保持一致\n    \n    // 错误姿势\n    // @Param   id   path      int  true  \"用户 ID\"\n    // @Router /users/{userID} [get] \n    // 一个是 id，一个是 userID，不匹配，会出错\n    ```\n\n---\n\n### **5. 全局注解（`main` 函数上方）到底写在哪？**\n\n*   **规定**：`swag` 会扫描整个项目来寻找 API 注解（写在 `Handler` 函数上的），但**全局注解只会寻找 `main` 包**（也就是包含 `func main()` 的那个文件）里的注释。\n*   **最佳实践**：始终将 `@title`, `@version`, `@host` 等全局注解写在 `main.go` 文件中 `main` 函数的上方。不要把它们放在其他文件里，否则 `swag` 会找不到。\n\n---\n\n### **6. 文档部署到服务器上访问不了？—— `@host` 和 `@BasePath` 的重要性**\n\n*   **现象**：文档在本地 `localhost:8080` 访问完全正常，但部署到服务器上（比如 `api.mydomain.com/v1`）之后，在线调试功能 (“Try it out”) 点击 “Execute” 没反应，或者请求的地址不对。\n\n*   **原因**：`swag` 文档页面里的调试工具，会根据 `@host` 和 `@BasePath` 来拼接最终的请求 URL。如果你这里写的是 `localhost:8080`，那无论你在哪里访问这个文档，它都会往 `localhost:8080` 发请求。\n\n*   **部署时的正确配置**：\n\n    ```go\n    // @host      api.mydomain.com\n    // @BasePath  /v1\n    ```\n\n    这样配置后，`swag` 生成的文档在调用 `/users/{id}` 这个 API 时，就会正确地请求 `http://api.mydomain.com/v1/users/{id}`。\n\n*   **动态配置**：在不同的环境（开发、测试、生产）中，`host` 可能会不同。你可以考虑使用 `swag` 的一些高级功能，或者编写脚本，在持续集成/持续部署（CI/CD）流程中动态地修改这些注解或生成的 `swagger.json` 文件。\n\n---\n\n### **本章小结**\n\n我们总结了几个最常见的新手问题和注意事项：\n\n1.  **改完注解，必跑 `swag init`**。\n2.  **检查 `main.go` 是否有 `import _ \"...\"`**。\n3.  **结构体字段必须首字母大写，并有 `json` 标签**。\n4.  **`@Param` 和 `@Router` 的路径参数名要一致**。\n5.  **全局注解写在 `main` 函数之上**。\n6.  **部署时，正确配置 `@host` 和 `@BasePath`**。\n\n记住这些，可以帮你节省大量的调试时间。现在，我们来进行最后的内容总结，并展望一下未来。\n\n\n\n经过前面六个章节的学习和实践，你已经从一个对 `swag` 毫无概念的小白，成长为一名能够独立使用它来为 Go 项目生成专业 API 文档的开发者了。\n\n现在，让我们一起花几分钟时间，回顾一下我们走过的路，并看看前方的风景。\n\n---\n\n## **第7章：总结与下一步**\n\n### **7.1 我们的学习回顾（我们学到了什么？）**\n\n让我们像看电影回放一样，快速过一遍本次学习的核心要点：\n\n*   **问题的起源（第1章）**：我们明白了为什么需要 API 文档，以及手动维护文档是多么痛苦。这是我们学习 `swag` 的根本动机——**自动化，让代码与文档同步**。\n\n*   **Swag 的真面目（第2章）**：我们认识了 `swag`，知道它是一个能将 Go 代码中的**特殊注释**，自动转换为**交互式 API 网页**的“魔法”工具。这个网页不仅好看，还能在线调试。\n\n*   **第一次亲密接触（第3章）**：我们亲手实践了 `swag` 的三步走核心流程：**安装工具 -> 添加注解 -> 运行 `swag init` 生成文档**。你成功生成了人生中第一个由代码自动生成的 API 文档！\n\n*   **“魔法咒语”大全（第4章）**：我们深入学习了 `swag` 的各种注解，如 `@Summary`, `@Tags`, `@Param`, `@Success`, `@Router` 等，并学会了如何使用它们来精确描述一个 API 的方方面面，包括如何引用自定义的结构体。\n\n*   **揭开魔法的面纱（第5章）**：我们探究了 `swag` 的工作原理，了解到它并非魔法，而是一个**代码解析器** + **OpenAPI 规范生成器**。这个过程让我们知其然，更知其所以然。\n\n*   **前人的智慧（第6章）**：我们总结了新手在使用 `swag` 时最容易遇到的几个“坑”，比如忘记运行 `swag init`、匿名导入路径错误等，为未来的实战扫清了障碍。\n\n到此，你已经构建起了一个关于 `swag` 的完整知识体系。恭喜你，你已经掌握了一项能极大提升开发效率和团队协作质量的实用技能！\n\n---\n\n### **7.2 知识的延伸（接下来可以学什么？）**\n\n学习永无止境。当你熟练掌握了 `swag` 的基础用法后，你可能还想探索更多，这里我为你指出几个可以继续深入的方向：\n\n1.  **深入 OpenAPI 规范**：\n    `swag` 只是一个生成器，它所遵循的 **OpenAPI 规范**才是 API 描述领域的核心。花一点时间去阅读 OpenAPI 3.0 的官方文档，你会对 API 设计有更深刻的理解，也能解锁 `swag` 注解中更多高级的用法（比如定义安全策略 `Security`、组件 `Components` 等）。\n\n2.  **探索更复杂的注解**：\n    我们这次学习主要覆盖了最常用的注解。`swag` 还支持更多高级注解，例如：\n    *   `@Security`: 用于定义 API 的认证方式，比如 JWT Token, API Key, OAuth2 等。\n    *   `@Accept` / `@Produce`: 除了 `json`，还支持 `xml`, `html`, `plain` 等多种格式。\n    *   `@Example`: 为请求体或响应体提供更具体的示例。\n\n3.  **自动化 `swag init`**：\n    在实际项目中，每次修改都手动运行 `swag init` 还是有些繁琐。你可以研究一下如何将其集成到你的开发流程中。比如使用 `air` 这个 Go 的热重载工具，在配置文件中添加一条命令，让它在监控到 `.go` 文件变化时，自动帮你执行 `swag init`。\n\n4.  **尝试其他 Go Web 框架**：\n    我们这次课程用的是 `Gin` 框架。`swag` 社区也为其他流行的 Go 框架提供了适配器，比如 `Echo`, `Fiber`, `Chi` 等。你可以尝试在不同的框架中使用 `swag`，加深理解。\n\n---\n\n### **7.3 最后的叮嘱**\n\n同学，工具是为人服务的。`swag` 的价值不仅仅在于生成一份漂亮的文档，更在于它背后所倡导的一种**“文档驱动”**或**“代码即文档”**的开发理念。\n\n养成在写代码的同时，就写好注解的习惯，这会让你未来的自己和你的同事都感激不尽。一份清晰、准确、永远与代码同步的 API 文档，是专业软件项目中不可或缺的一环。\n\n希望这次学习笔记能真正帮助到你。如果在未来的学习和工作中遇到任何问题，随时都可以回来复习。\n\n**现在，合上笔记，去你的项目中，开始享受 `swag` 带来的便捷和快乐吧！**\n\n**祝你编程愉快！**\n\n\n\n\n\n# 附录\n\n## Swagger 注解参考与实战模板（Swag for Go）\n\n> 适用于 `github.com/swaggo/swag` + `github.com/swaggo/gin-swagger`\n> 文件可直接放入项目 `/docs/` 目录供开发参考。\n\n------\n\n### 一、常用注解说明表（带调用示例）\n\n| 注解名                | 作用         | 常用位置 | 说明                                                         | 示例注解                                                    | API 调用示例                                |\n| --------------------- | ------------ | -------- | ------------------------------------------------------------ | ----------------------------------------------------------- | ------------------------------------------- |\n| **@Summary**          | 接口简要描述 | 函数顶部 | 展示在 Swagger UI 接口列表中                                 | `// @Summary 获取用户信息`                                  | ——                                          |\n| **@Description**      | 接口详细描述 | 函数顶部 | 可多行描述细节、约束等                                       | `// @Description 根据用户ID查询详细资料`                    | ——                                          |\n| **@Tags**             | 接口分组     | 函数顶部 | Swagger 左侧菜单分组                                         | `// @Tags 用户管理`                                         | ——                                          |\n| **@Accept**           | 接收类型     | 函数顶部 | `json`, `multipart/form-data`, `x-www-form-urlencoded` 等    | `// @Accept json`                                           | ——                                          |\n| **@Produce**          | 响应类型     | 函数顶部 | `json`, `xml`, `plain` 等                                    | `// @Produce json`                                          | ——                                          |\n| **@Param (query)**    | URL 查询参数 | 函数顶部 | `@Param name query string true \"用户名\"`，`true`为必填，`false`为可选 | `// @Param name query string true \"用户名\"`                 | `GET /api/user?name=Tom`                    |\n| **@Param (path)**     | 路径参数     | 函数顶部 | URL 占位符参数（REST 风格），必填（一般必须为 `true`，因为路径里必须有值） | `// @Param id path int true \"用户ID\"`                       | `GET /api/user/123`                         |\n| **@Param (header)**   | Header 参数  | 函数顶部 | 适合传 Token 或版本号，`true`为必填，`false`为可选           | `// @Param Authorization header string true \"Bearer Token\"` | `curl -H \"Authorization: Bearer XXX\" ...`   |\n| **@Param (formData)** | 表单参数     | 函数顶部 | 用于 `POST` 的表单数据，`true`为必填，`false`为可选          | `// @Param username formData string true \"用户名\"`          | `POST /login  (username=Tom&password=123)`  |\n| **@Param (file)**     | 文件上传参数 | 函数顶部 | `multipart/form-data`，`true`为必填，`false`为可选           | `// @Param file formData file true \"上传文件\"`              | `curl -F \"file=@avatar.png\" /upload/avatar` |\n| **@Param (body)**     | JSON 请求体  | 函数顶部 | 用于 POST/PUT 请求体，`true`为必填，`false`为可选            | `// @Param data body User true \"用户信息\"`                  | `POST /user {\"name\":\"Tom\",\"age\":18}`        |\n| **@Param (cookie)**   | Cookie 参数  | 函数顶部 | 从 cookie 读取数据，`true`为必填，`false`为可选              | `// @Param session cookie string false \"Session ID\"`        | `Cookie: session=abcd1234`                  |\n| **@Success**          | 成功返回     | 函数顶部 | 定义返回结构体与 HTTP 码                                     | `// @Success 200 {object} User \"返回用户信息\"`              | 响应体：`{\"id\":1,\"name\":\"Tom\"}`             |\n| **@Failure**          | 失败返回     | 函数顶部 | 描述错误信息结构体                                           | `// @Failure 400 {object} ErrorResponse \"参数错误\"`         | 响应体：`{\"code\":400,\"msg\":\"invalid\"}`      |\n| **@Router**           | 路由定义     | 函数顶部 | 指定接口路径与方法                                           | `// @Router /user/{id} [get]`                               | `GET /user/123`                             |\n| **@Security**         | 鉴权机制     | 函数顶部 | 对应 securityDefinitions                                     | `// @Security ApiKeyAuth`                                   | `curl -H \"Authorization: Bearer TOKEN\" ...` |\n| **@Deprecated**       | 废弃标记     | 函数顶部 | 标记接口为过时                                               | `// @Deprecated`                                            | ——                                          |\n\n------\n\n###  二、@Param 类型详细表（含请求示例）\n\n| 类型             | 用途        | 数据类型        | 示例注解                                          | API 请求示例                          |\n| ---------------- | ----------- | --------------- | ------------------------------------------------- | ------------------------------------- |\n| `query`          | URL 参数    | string/int/bool | `@Param user_id query int true \"用户ID\"`          | `/user?user_id=1`                     |\n| `path`           | 路径参数    | string/int      | `@Param id path int true \"用户ID\"`                | `/user/1`                             |\n| `header`         | 请求头      | string          | `@Param Authorization header string true \"Token\"` | `curl -H \"Authorization: Bearer abc\"` |\n| `formData`       | 表单数据    | string/int      | `@Param username formData string true \"用户名\"`   | `curl -d \"username=Tom\"`              |\n| `formData(file)` | 上传文件    | file            | `@Param file formData file true \"上传头像\"`       | `curl -F \"file=@a.png\"`               |\n| `body`           | JSON 请求体 | object          | `@Param data body User true \"用户信息\"`           | `curl -X POST -d '{\"name\":\"Tom\"}'`    |\n| `cookie`         | Cookie      | string          | `@Param session cookie string false \"Session ID\"` | `Cookie: session=abcd`                |\n\n### 三、`@Success` / `@Failure` 的 `{类型}` 参数\n\n#### `@Success` / `@Failure` 的 `{类型}` 参数支持哪些格式？\n\n在 `swaggo`（`github.com/swaggo/swag`）中，`@Success` / `@Failure` 注解的语法如下：\n\n```\n@Success <HTTP状态码> {<类型>} <数据模型> \"<描述>\"\n```\n\n其中 `{<类型>}` 是用于 **描述响应数据结构的**，常见取值如下：\n\n| `{类型}`         | 含义                            | 适用场景                           | 示例                                            |\n| ---------------- | ------------------------------- | ---------------------------------- | ----------------------------------------------- |\n| **object对象**   | 返回的是结构体对象（JSON 对象） | 最常见，接口返回 JSON 时通常是这个 | `// @Success 200 {object} models.LoginResp`     |\n| **array数组**    | 返回的是数组（JSON 数组）       | 列表、分页等场景                   | `// @Success 200 {array} models.UserResp`       |\n| **string字符串** | 返回纯文本字符串                | 错误提示、状态文本等               | `// @Failure 500 {string} string \"内部错误\"`    |\n| **integer整型**  | 返回纯数值（整数）              | 简单的状态码或数量                 | `// @Success 200 {integer} int \"成功状态码\"`    |\n| **number数字**   | 返回浮点数                      | 例如温度、坐标等                   | `// @Success 200 {number} float64 \"测量值\"`     |\n| **boolean布尔**  | 返回 true/false 布尔值          | 状态检查类接口                     | `// @Success 200 {boolean} bool \"是否在线\"`     |\n| **file文件**     | 返回文件（二进制流）            | 文件下载接口                       | `// @Success 200 {file} file \"导出的Excel文件\"` |\n\n------\n\n#### 如果你的接口返回 JSON —— 应该用 `{object}` 或 `{array}`，而不是 `{string}`\n\n这是最关键的一点：\n\n> ⚠️ 即使你的响应是 “JSON 字符串格式”，也应该写 `{object}`，因为 swagger 的目的不是展示原始传输内容，而是展示数据结构。\n\n举例说明：\n\n假设接口返回：\n\n```json\n{\n  \"code\": 200,\n  \"msg\": \"ok\",\n  \"data\": {\n    \"user_id\": 123,\n    \"name\": \"Tom\"\n  }\n}\n```\n\n你应该写成：\n\n```\n// @Success 200 {object} models.CommonResp \"请求成功\"\n```\n\n而不是：\n\n```\n// ❌ 错误：这样 swagger 只会认为是纯文本\n// @Success 200 {string} string \"返回JSON字符串\"\n```\n\n因为 `{string}` 告诉 swagger：返回的是纯文本，而 swagger UI 就不会解析字段结构，也不会显示字段说明。\n\n------\n\n#### 几个常见的写法对比表\n\n| 返回内容            | 推荐写法               | 错误写法          | 说明                         |\n| ------------------- | ---------------------- | ----------------- | ---------------------------- |\n| JSON 对象（结构体） | `{object} models.Resp` | `{string} string` | 应描述结构体，而非字符串     |\n| JSON 数组           | `{array} models.Item`  | `{string} string` | swagger 会显示为数组元素类型 |\n| 普通字符串          | `{string} string`      | `{object}`        | 简单文本响应                 |\n| 文件流              | `{file} file`          | `{object}`        | 特殊响应类型（下载）         |\n\n------\n\n#### 完整例子\n\n```\n// @Summary 登录接口\n// @Description 用户通过账号密码登录\n// @Tags 用户\n// @Accept json\n// @Produce json\n// @Param data body models.LoginReq true \"登录请求体\"\n// @Success 200 {object} models.LoginResp \"登录成功\"\n// @Failure 400 {object} models.ErrorResp \"请求错误\"\n// @Failure 500 {string} string \"服务器内部错误\"\n// @Router /api/v1/login [post]\nfunc Login(c *gin.Context) {\n    // ...\n}\n```\n\n------\n\n#### 小结一句话记住：\n\n| 返回类型                                    | 对应 swagger 类型 | 备注   |\n| ------------------------------------------- | ----------------- | ------ |\n| Go 结构体 / map                             | `{object}`        | 最常用 |\n| Go 切片 / 数组                              | `{array}`         | ✅      |\n| Go stringGo 字符串                          | `{string}`        | ✅      |\n| Go int / int64Go int / int64 整数 / 整数 64 | `{integer}`       | ✅      |\n| Go float32 / float64                        | `{number}`        | ✅      |\n| Go boolGo 布尔                              | `{boolean}`       | ✅      |\n| 文件下载                                    | `{file}`          | ✅      |\n\n\n\n------\n\n###  三、结构体定义示例\n\n```\ntype User struct {\n    ID   int    `json:\"id\" example:\"1\"`\n    Name string `json:\"name\" example:\"Tom\"`\n    Age  int    `json:\"age\" example:\"25\"`\n}\n\ntype ErrorResponse struct {\n    Code int    `json:\"code\" example:\"400\"`\n    Msg  string `json:\"msg\" example:\"参数错误\"`\n}\n```\n\n------\n\n###  四、接口模板（全部注解示例）\n\n#### 获取用户信息（GET + Path）\n\n```\n// @Summary 获取用户信息\n// @Description 通过用户ID获取详细信息\n// @Tags 用户管理\n// @Accept json\n// @Produce json\n// @Param id path int true \"用户ID\"\n// @Param token header string false \"访问令牌\"\n// @Success 200 {object} User \"用户信息\"\n// @Failure 400 {object} ErrorResponse \"参数错误\"\n// @Failure 404 {object} ErrorResponse \"用户不存在\"\n// @Router /user/{id} [get]\nfunc GetUser(c *gin.Context) { ... }\n\n// 调用示例：\n// GET ./user/123\n// Header: Authorization: Bearer TOKEN\n```\n\n------\n\n#### 创建用户（POST + Body）\n\n```\n// @Summary 创建新用户\n// @Description 使用 JSON 提交用户数据\n// @Tags 用户管理\n// @Accept json\n// @Produce json\n// @Param data body User true \"用户信息\"\n// @Success 201 {object} User \"创建成功\"\n// @Failure 400 {object} ErrorResponse \"参数错误\"\n// @Router /user [post]\nfunc CreateUser(c *gin.Context) { ... }\n\n// 调用示例：\n// POST ./user\n// Body: {\"name\":\"Tom\",\"age\":25}\n```\n\n------\n\n#### 用户登录（POST + FormData）\n\n```\n// @Summary 用户登录\n// @Description 表单提交方式登录\n// @Tags 登录认证\n// @Accept x-www-form-urlencoded\n// @Produce json\n// @Param username formData string true \"用户名\"\n// @Param password formData string true \"密码\"\n// @Success 200 {string} string \"登录成功\"\n// @Failure 401 {object} ErrorResponse \"用户名或密码错误\"\n// @Router /login [post]\nfunc Login(c *gin.Context) { ... }\n\n// 调用示例：\n// POST ./login\n// Body: username=Tom&password=123456\n```\n\n------\n\n#### 上传头像（POST + File）\n\n```go\n// @Summary 上传头像\n// @Description 上传用户头像文件\n// @Tags 文件上传\n// @Accept multipart/form-data\n// @Produce json\n// @Param user_id formData int true \"用户ID\"\n// @Param file formData file true \"头像文件\"\n// @Success 200 {string} string \"上传成功\"\n// @Failure 400 {object} ErrorResponse \"文件无效\"\n// @Router /upload/avatar [post]\nfunc UploadAvatar(c *gin.Context) { ... }\n\n// 调用示例：\n// curl -F \"user_id=1\" -F \"file=@avatar.png\" ./upload/avatar\n```\n\n------\n\n#### 带鉴权接口（Header + Security）\n\n```go\n// @Summary 获取当前用户资料\n// @Description 需要登录并携带 Bearer Token\n// @Tags 用户资料\n// @Security ApiKeyAuth\n// @Accept json\n// @Produce json\n// @Param Authorization header string true \"Bearer Token\"\n// @Success 200 {object} User \"用户信息\"\n// @Failure 401 {object} ErrorResponse \"未授权\"\n// @Router /profile [get]\nfunc GetProfile(c *gin.Context) { ... }\n\n// 调用示例：\n// GET ./profile\n// Header: Authorization: Bearer eyJhbGci...\n```\n\n------\n\n#### Cookie 示例接口\n\n```Go\n// @Summary 检查用户会话\n// @Description 根据 Cookie 中的 session 判断是否登录\n// @Tags 登录认证\n// @Accept json\n// @Produce json\n// @Param session cookie string false \"Session ID\"\n// @Success 200 {string} string \"Session 有效\"\n// @Failure 401 {string} string \"未登录\"\n// @Router /session/check [get]\nfunc CheckSession(c *gin.Context) { ... }\n\n// 调用示例：\n// GET ./session/check\n// Cookie: session=abc123\n```\n\n------\n\n### 五、Swagger 安全认证定义示例（在 docs/init.go 中）\n\n```\n// @securityDefinitions.apikey ApiKeyAuth\n// @in header\n// @name Authorization\n```\n\n------\n\n### 六、小结\n\n| 常见场景  | 推荐注解组合                                                | 示例路径         |\n| --------- | ----------------------------------------------------------- | ---------------- |\n| GET 查询  | `@Param query/path` + `@Success`                            | `/user/{id}`     |\n| POST 创建 | `@Param body` + `@Accept json`                              | `/user`          |\n| 表单提交  | `@Param formData` + `@Accept x-www-form-urlencoded`         | `/login`         |\n| 文件上传  | `@Param file formData file` + `@Accept multipart/form-data` | `/upload/avatar` |\n| 认证接口  | `@Security ApiKeyAuth` + `@Param header`                    | `/profile`       |","tags":["使用教程","AI","protected","Golang","三方库","swag"],"categories":["技术","Golang"]},{"title":"Golang validator 库","url":"/2025/10/06/Golang_validator/","content":"\n\n\n# **Golang validator 库**\n\n## 概览\n\n**第1章：为什么需要“数据检查员”？—— validator 库简介**\n\n- （本章核心：用一个生活中的例子，让你明白为什么程序里需要一个专门检查数据的工具。）\n\n**第2章：上岗第一天！—— validator 的基本使用**\n\n- （本章核心：手把手带你完成最简单的“检查”任务，让你对 validator 的工作流程有个整体印象。）\n\n**第3-1章：检查员的“规则手册”—— 常用验证标签（上）**\n\n- （本章核心：学习最常用的检查规则，比如“不能为空”、“必须是邮箱格式”、“长度必须达标”等。）\n\n**第3-2章：检查员的“规则手册”—— 常用验证标签（下）**\n\n- （本章核心：继续学习更多实用的检查规则，比如数字大小比较、多选一等，让你的检查能力变得更强。）\n\n**第4章：“检查不通过！”—— 如何看懂并处理错误信息**\n\n- （本章核心：学习当数据不符合规则时，如何获取、理解并展示友好的错误提示。）\n\n**第5章：制定你自己的“特殊规则”—— 自定义验证函数**\n\n- （本章核心：学习当 validator 自带规则不够用时，如何创建一条完全属于你自己的、独一无二的检查规则。）\n\n**第6章：经验之谈 —— 使用 validator 的注意事项与技巧**\n\n- （本章核心：总结一些高手们在实际工作中会注意的小细节和最佳实践，帮你避免踩坑。）\n\n**第7章：实战演练 —— 用户注册信息校验**\n\n- （本章核心：将前面学到的所有知识串联起来，完成一个完整的、贴近真实场景的练习。\n\n---\n\n## 第1章：为什么需要“数据检查员”？—— validator 库简介\n\n同学你好！在我们开始学习具体的代码之前，我想先问你一个问题：你有没有在网上注册账号或者填写表格的经历？\n\n一定有吧！比如你在注册一个新邮箱时，如果密码栏你没填，系统会提示“密码不能为空”；如果你输入的邮箱地址不带`@`符号，它会说“请输入有效的邮箱格式”。\n\n这个过程，其实就是 **数据校验**（Data Validation）。\n\n### 生活中的“数据检查”\n\n我们来把这个场景具体化一下：\n\n想象一下，你正在一个重要的网站上填写一份个人信息登记表。这张表上有几个栏目：\n\n*   **姓名**: （必填）\n*   **年龄**: （必填，且必须是 18 岁以上）\n*   **邮箱**: （必填，且格式必须正确，比如 `xxx@example.com`）\n*   **个人简介**: （选填，但如果填写，长度不能超过 200 字）\n\n当你填完点击“提交”时，网站后台的程序就像一个一丝不苟的办事员。它会拿起你的表格，一项一项地检查：\n\n1.  “姓名填了吗？嗯，填了，通过。”\n2.  “年龄是 25，大于 18，通过。”\n3.  “邮箱是 `my-email@qq.com`，格式正确，通过。”\n4.  “个人简介写了 150 个字，没超过 200，通过。”\n\n所有检查都通过后，这位“办事员”才会满意地盖上“合格”的章，把你的信息存入数据库。如果任何一项不合格，他就会把表格退给你，并告诉你哪里填错了。\n\n### 程序世界的“数据检查”：又长又麻烦的 if-else\n\n在我们的 Go 程序里，我们当然也需要这样一位“办事员”。否则，用户提交了乱七八糟的数据，比如年龄填了-5岁，或者邮箱写成了“我的邮箱”，那我们的程序可能就会出问题，甚至崩溃。\n\n在没有 `validator` 库之前，我们是怎么实现这个“办事员”的呢？通常是这样的：\n\n假设我们用一个结构体 `User` 来表示用户提交的信息：\n\n```go\n// User 结构体，用来存放用户注册信息\ntype User struct {\n    Name    string\n    Age     int\n    Email   string\n    Intro   string\n}\n```\n\n为了检查一个 `User` 对象里的数据是否合格，我们可能会写一个充满 `if-else` 的函数：\n\n```go\nimport (\n    \"errors\"\n    \"strings\"\n)\n\n// 手动检查用户信息的函数\nfunc validateUserManually(user User) error {\n    // 1. 检查姓名是不是空的\n    if user.Name == \"\" {\n        return errors.New(\"姓名不能为空\")\n    }\n\n    // 2. 检查年龄是不是小于18岁\n    if user.Age < 18 {\n        return errors.New(\"年龄必须年满18周岁\")\n    }\n\n    // 3. 检查邮箱格式是不是正确 (一个非常简化的检查)\n    if !strings.Contains(user.Email, \"@\") {\n        return errors.New(\"请输入有效的邮箱格式\")\n    }\n    \n    // 4. 检查个人简介长度\n    if len(user.Intro) > 200 {\n        return errors.New(\"个人简介不能超过200个字符\")\n    }\n\n    // 所有检查都通过了，返回 nil (表示没有错误)\n    return nil\n}\n```\n\n**思考一下：** 上面这段代码有什么问题？\n\n乍一看好像没问题，功能也实现了。但想象一下，如果 `User` 结构体有 30 个字段需要检查呢？那我们的 `validateUserManually` 函数是不是会变得超级长、超级复杂？每次新增或修改一个检查规则，都要小心翼翼地去改动那一大堆 `if-else`，非常容易出错，而且代码看起来一点也不优雅。\n\n### 我们的“超级检查员”登场：validator 库\n\n为了解决这种“体力活”，社区里的大神们就开发了 `validator` 库。\n\n`validator` 就像一个高度自动化、自带规则手册的“超级检查员”。我们不再需要手写一大堆 `if-else`，而是用一种更简单、更直观的方式，直接在我们的结构体上“贴标签”（在 Go 语言里这叫 `Tag`），告诉检查员每个字段需要遵守什么规则。\n\n同样是上面的 `User` 结构体，用了 `validator` 之后会变成这样（先混个眼熟，下一章我们就来写）：\n\n```go\ntype User struct {\n    Name    string `validate:\"required\"`\n    Age     int    `validate:\"required,gte=18\"`\n    Email   string `validate:\"required,email\"`\n    Intro   string `validate:\"lte=200\"`\n}\n```\n\n你看，规则（`required` 表示必填，`gte=18` 表示大于等于18，`email` 表示邮箱格式）直接写在了字段的后面。代码是不是瞬间清爽了很多？\n\n当我们把一个 `User` 对象交给 `validator` 时，它会自动读取这些“标签”，然后一次性帮我们把所有的规则都检查一遍。我们只需要处理最终的检查结果就行了。\n\n**`validator` 库的好处：**\n\n*   **代码更整洁：** 验证规则和数据结构定义在一起，一目了然。\n*   **开发效率高：** 大量内置的常用规则（比如判空、邮箱、URL、IP地址等）开箱即用，不用自己重复造轮子。\n*   **易于维护：** 修改规则只需要改动标签，而不用去动复杂的逻辑代码。\n*   **功能强大：** 支持自定义规则，满足各种刁钻的检查需求。\n\n### 本章小结\n\n好了，第一章的内容就是这么多。我们没有写任何实际能运行的代码，但我们搞清楚了一个最重要的问题：**为什么需要 `validator`？**\n\n*   **数据校验是什么？** 它是保证我们程序接收到的数据是正确、有效、符合预期的“守门员”。\n*   **为什么它很重要？** 它可以防止“垃圾数据”进入我们的系统，保证程序的稳定和安全。\n*   **传统方式的痛点？** 手写 `if-else` 来做校验，在字段多、规则复杂时，会变得冗长、混乱且难以维护。\n*   **`validator` 库的价值？** 它提供了一种声明式、自动化的方式来完成数据校验，让我们的代码更简洁、开发效率更高。\n\n现在你已经知道了我们为什么需要这位“检查员”，下一章，我们就正式带它上岗，亲手写下第一段 `validator` 的代码，看看它到底是怎么工作的！\n\n\n\n没问题，我们继续！\n\n上一章我们理解了“为什么”，现在我们来解决“怎么做”的问题。准备好，我们要让这位“检查员”正式上岗了！\n\n---\n\n## 第2章：上岗第一天！—— validator 的基本使用\n\n在这一章，我们的目标非常简单：完成一次最基本的“数据检查”任务。我们会经历从“请人”（安装库）到“下达指令”（编写代码）再到“看报告”（检查结果）的全过程。\n\n### 第一步：招聘检查员（安装 validator 库）\n\n在 Go 语言中，“招聘”一个外部库，就是用一个命令把它下载到你的电脑里。\n\n打开你的终端（命令行工具），输入下面的命令然后回车：\n\n```bash\ngo get github.com/go-playground/validator/v10\n```\n\n看到一些下载信息滚动，最后没有报红色的错误，就说明我们的“检查员”已经成功“入职”了！`v10` 是它的版本号，目前这是最稳定和推荐的版本。\n\n### 第二步：给他一本“规则手册”（定义带标签的结构体）\n\n我们的检查员很厉害，但他不是神，他不知道你的数据需要遵守什么规则。所以，我们需要给他一本“规则手册”。在 `validator` 里，这本手册就是带有 `validate` 标签的结构体。\n\n我们还是用上一章的 `User` 例子，但为了简单起见，这次我们只检查一个字段：`Name`。\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/go-playground/validator/v10\"\n)\n\n// User 结构体，我们的“规则手册”\ntype User struct {\n    // 我们给 Name 字段贴上了一个叫 `validate` 的标签\n    // 标签里的 \"required\" 就是一条规则，意思是“这个字段是必填的，不能为空”\n    Name string `validate:\"required\"`\n    Age  int    // 这个字段没有标签，validator 会忽略它\n}\n```\n\n**看这里！** `validate:\"required\"` 就是我们给检查员下的指令。\n\n*   `validate`：这是告诉 `validator` 库：“嘿，看这里，这个字段有检查规则！”\n*   `\"required\"`：这就是具体的规则，意思是“必须有值”（不能是空字符串、0、nil 等）。\n\n### 第三步：让他开始工作（创建实例并执行校验）\n\n“手册”准备好了，现在我们要创建一个“检查员”实例，然后把需要检查的数据交给他。\n\n我们来看一个完整的、可以运行的例子：\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/go-playground/validator/v10\"\n)\n\n// User 结构体，定义了验证规则\ntype User struct {\n    Name string `validate:\"required\"`\n    Age  int    // Age 字段没有规则，所以不会被检查\n}\n\nfunc main() {\n    // 1. 创建一个 validator “检查员”实例\n    validate := validator.New()\n\n    // --- 场景一：提供一份合格的数据 ---\n    fmt.Println(\"--- 场景一：合格数据 ---\")\n    userOK := User{\n        Name: \"Alice\", // Name 字段有值\n        Age:  25,\n    }\n\n    // 2. 把 userOK 交给检查员，让他按照结构体里的标签规则进行检查\n    err := validate.Struct(userOK)\n\n    // 3. 查看检查报告\n    if err != nil {\n        // 如果 err 不是 nil，说明有错误，检查不通过！\n        fmt.Printf(\"数据校验失败, 错误: %v\\n\", err)\n    } else {\n        // 如果 err 是 nil，说明没错误，检查通过！\n        fmt.Println(\"数据校验成功!\")\n    }\n\n    fmt.Println(\"\\n--- 场景二：提供一份不合格的数据 ---\")\n    // --- 场景二：提供一份不合格的数据 ---\n    userFail := User{\n        Name: \"\", // Name 字段是空的，不符合 \"required\" 规则\n        Age:  30,\n    }\n\n    // 2. 同样地，把 userFail 交给检查员检查\n    err = validate.Struct(userFail)\n\n    // 3. 查看检查报告\n    if err != nil {\n        fmt.Printf(\"数据校验失败, 错误: %v\\n\", err)\n    } else {\n        fmt.Println(\"数据校验成功!\")\n    }\n}\n```\n\n**自己动手试试：**\n把上面这段代码保存为一个 `main.go` 文件，然后在终端里进入到这个文件所在的目录，运行 `go run main.go`，看看会输出什么？\n\n你应该会看到类似下面的结果：\n\n```\n--- 场景一：合格数据 ---\n数据校验成功!\n\n--- 场景二：不合格的数据 ---\n数据校验失败, 错误: Key: 'User.Name' Error:Field validation for 'Name' failed on the 'required' tag\n```\n\n**结果分析：**\n\n*   在**场景一**中，`userOK` 里的 `Name` 字段是 \"Alice\"，不为空，符合 `required` 规则，所以 `validate.Struct()` 返回的 `err` 是 `nil`，程序打印“数据校验成功!”。\n*   在**场景二**中，`userFail` 里的 `Name` 字段是空字符串 `\"\"`，违反了 `required` 规则，所以 `validate.Struct()` 返回了一个具体的错误信息，程序打印了“数据校验失败”和那串有点难懂的错误。\n\n**想一想：**\n那个错误信息 `Key: 'User.Name' Error:Field validation for 'Name' failed on the 'required' tag` 是什么意思？\n虽然它看起来有点“程序员化”，但仔细读读，它其实在告诉我们：`User` 结构体的 `Name` 字段，在 `required` 这个规则上，验证失败了。\n（别担心这个错误信息太丑，我们在后面的章节会学习如何把它变得更友好！）\n\n### 本章小结\n\n恭喜你！你已经成功让 `validator` 帮你完成了第一次检查工作。我们来回顾一下核心的三个步骤：\n\n1.  **准备工作**：通过 `go get` 安装库。\n2.  **定义规则**：在结构体的字段后面，使用 `validate` 标签来声明验证规则（例如 `validate:\"required\"`）。\n3.  **执行校验**：\n    *   通过 `validator.New()` 创建一个校验器实例。\n    *   调用 `validate.Struct(你的结构体实例)` 来执行校验。\n    *   检查返回的 `error` 是否为 `nil`，`nil` 代表成功，非 `nil` 代表失败。\n\n现在你已经掌握了 `validator` 最基本的工作流程。但是，一个只会检查“不能为空”的检查员能力还远远不够。下一章，我们将为他的“规则手册”增加更多、更强大的规则，让他能应对更复杂的检查任务！\n\n好的，我们马上进入第三章！\n\n我们的检查员已经学会了最基本的一招——`required`（不能为空）。但这显然不够用，就像一个交通警察只会检查司机有没有系安全带一样，他还需要学会检查是否超速、是否闯红灯等等。\n\n现在，我们就来给他的“规则手册”增加几页，让他学会更多强大的检查技巧！由于规则比较多，我们把它分成上下两部分来学习。\n\n---\n\n## 第3-1章：检查员的“规则手册”—— 常用验证标签（上）\n\n在这一章，我们主要学习一些最常用、最基础的验证规则，它们主要和长度、大小、格式有关。\n\n### 规则一：关于“长度”的检查\n\n在网站注册时，我们经常看到“用户名长度必须在6到20个字符之间”这样的提示。这就是对长度的限制。\n\n*   `min=x`：最小长度/个数不能小于 `x`。\n*   `max=x`：最大长度/个数不能超过 `x`。\n*   `len=x`：长度/个数必须正好等于 `x`。\n\n这些规则不仅能用在字符串上，还能用在数组、切片等有“长度”概念的东西上。\n\n**示例：**\n\n```go\ntype User struct {\n    Username string `validate:\"min=3,max=20\"` // 用户名长度在3到20之间\n    UserType string `validate:\"len=5\"`      // 用户类型必须是5个字符，比如 \"admin\"\n    Hobbies  []string `validate:\"max=5\"`    // 兴趣爱好最多只能选5个\n}\n```\n\n**重点：如何组合多个规则？**\n\n你可能已经注意到了 `validate:\"min=3,max=20\"`。如果一个字段需要同时满足多个规则怎么办？很简单，**用逗号 `,` 把它们隔开就行了！** 这句话的意思就是，`Username` 字段必须**同时满足**最小长度为3 **和** 最大长度为20。\n\n### 规则二：关于“数字大小”的检查\n\n这个规则非常直观，就是我们数学里学过的 `>`、`>=`、`<`、`<=`。\n\n*   `gt=x`：必须 **大于** `x` (Greater Than)\n*   `gte=x`：必须 **大于或等于** `x` (Greater Than or Equal)\n*   `lt=x`：必须 **小于** `x` (Less Than)\n*   `lte=x`：必须 **小于或等于** `x` (Less Than or Equal)\n\n**示例：**\n\n```go\ntype Product struct {\n    Price    float64 `validate:\"gt=0\"`  // 价格必须大于0\n    Quantity int     `validate:\"gte=1\"` // 库存数量必须大于等于1\n    Rating   int     `validate:\"min=1,max=5\"` // 评分在1到5星之间 (这里用min/max更合适)\n}\n```\n\n**思考一下：** 为什么评分用 `min=1,max=5` 而不是 `gte=1,lte=5`？\n对于整数来说，这两种写法效果是一样的！`min/max` 通常用于描述长度、数量，而 `gte/lte` 用于描述数值的范围，但在这里它们可以通用。这说明规则的选择有时也很灵活。\n\n### 规则三：关于“特定格式”的检查\n\n`validator` 最强大的功能之一，就是它内置了很多对通用格式的检查，我们不需要自己用复杂的方法去判断。\n\n*   `email`：必须是有效的邮箱格式。\n*   `url`：必须是有效的 URL 链接格式。\n*   `ip`：必须是有效的 IP 地址格式（包括 IPv4 和 IPv6）。\n\n**示例：**\n\n```go\ntype ContactInfo struct {\n    Email   string `validate:\"required,email\"` // 必填，且必须是邮箱格式\n    Website string `validate:\"url\"`            // 选填，但如果填了，必须是URL格式\n}\n```\n\n你看，检查一个复杂的邮箱格式，我们只需要写上 `email` 这五个字母就行了，是不是超级方便？\n\n### 实战演练：组合使用\n\n好了，我们已经学了好几个新规则了。现在我们把它们组合起来，创建一个更真实的“用户注册表单”结构体，并进行校验。\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/go-playground/validator/v10\"\n)\n\n// RegisterForm 定义了一个用户注册表单的结构和它的验证规则\ntype RegisterForm struct {\n    Username string   `validate:\"required,min=3,max=20\"`\n    Age      int      `validate:\"required,gte=18,lte=120\"`\n    Email    string   `validate:\"required,email\"`\n    Tags     []string `validate:\"max=5\"`\n}\n\nfunc main() {\n    validate := validator.New()\n\n    // --- 场景一：一份填写完美的表单 ---\n    fmt.Println(\"--- 场景一：完美表单 ---\")\n    formOK := RegisterForm{\n        Username: \"Jack\",\n        Age:      25,\n        Email:    \"jack@example.com\",\n        Tags:     []string{\"music\", \"sports\"},\n    }\n    err := validate.Struct(formOK)\n    if err == nil {\n        fmt.Println(\"表单校验通过！\")\n    }\n\n    // --- 场景二：一份问题百出的表单 ---\n    fmt.Println(\"\\n--- 场景二：问题表单 ---\")\n    formFail := RegisterForm{\n        Username: \"Li\", // 太短，不满足 min=3\n        Age:      16,   // 太小，不满足 gte=18\n        Email:    \"this-is-not-an-email\", // 格式错误\n        Tags:     []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"}, // 标签太多，不满足 max=5\n    }\n    err = validate.Struct(formFail)\n    if err != nil {\n        // 这里我们先简单打印错误，下一章会学习如何处理它\n        fmt.Printf(\"表单校验失败: %v\\n\", err)\n    }\n}\n```\n\n**运行结果：**\n\n```\n--- 场景一：完美表单 ---\n表单校验通过！\n\n--- 场景二：问题表单 ---\n表单校验失败: Key: 'RegisterForm.Username' Error:Field validation for 'Username' failed on the 'min' tag\n```\n\n**注意：** 在场景二中，虽然表单有多个错误，但 `validator` 默认只要发现一个错误就会停止并返回。我们会在后面的章节学习如何一次性获取所有错误。目前你只需要知道，只要 `err` 不是 `nil`，就代表数据有问题。\n\n### 本章小结\n\n太棒了！我们给检查员的“规则手册”增加了厚厚的一叠。来总结一下今天学到的核心规则：\n\n*   **组合规则**：用逗号 `,` 分隔，表示“并且”的关系。\n*   **长度规则**：\n    *   `min=x` (最小长度)\n    *   `max=x` (最大长度)\n    *   `len=x` (固定长度)\n*   **数值规则**：\n    *   `gt=x` (大于 `>`)\n    *   `gte=x` (大于等于 `>=`)\n    *   `lt=x` (小于 `<`)\n    *   `lte=x` (小于等于 `<=`)\n*   **格式规则**：\n    *   `email` (邮箱格式)\n    *   `url` (链接格式)\n    *   `ip` (IP地址格式)\n\n这些规则已经能覆盖我们日常开发中 80% 的校验需求了。但这还不是全部！在下一节课，我们会学习更多高级和有趣的规则，比如“二选一”、“密码确认”等场景，让我们的检查员变得更加智能！\n\n当然！我们的检查员已经掌握了基础技能，现在是时候让他学习一些更酷、更智能的“高级招式”了。\n\n---\n\n## 第3-2章：检查员的“规则手册”—— 常用验证标签（下）\n\n在上一节，我们学习了关于长度、数字和基本格式的规则。这一节，我们将接触一些更灵活、更强大的规则，它们能处理一些更复杂的场景，比如“多选一”或者“两个字段必须相等”。\n\n### 规则四：多选一（从固定选项里选）\n\n想象一下，你有一个表示“订单状态”的字段，它的值只能是“待处理”、“处理中”或“已发货”这三种之一，绝不能是其他任何值。这时 `oneof` 规则就派上用场了。\n\n*   `oneof=value1 value2 value3`：字段的值必须是后面列出的值之一。\n\n**请注意：** 多个选项之间是用 **空格** 分隔的，而不是逗号！\n\n**示例：**\n\n```go\ntype Order struct {\n    Status string `validate:\"oneof=pending processing shipped\"` // 状态只能是这三个字符串之一\n    Color  string `validate:\"oneof='red blue' 'green yellow'\"` // 如果选项本身包含空格，可以用单引号 ' ' 括起来\n}\n```\n\n### 规则五：字段间的比较（跨字段验证）\n\n这是个非常实用的功能！最经典的场景就是“注册时，确认密码必须和密码一致”。\n\n*   `eqfield=FieldName`：当前字段的值必须 **等于** `FieldName` 字段的值。\n*   `nefield=FieldName`：当前字段的值必须 **不等于** `FieldName` 字段的值。\n\n**示例：**\n\n```go\ntype SignUpForm struct {\n    Password        string `validate:\"required,min=8\"`\n    ConfirmPassword string `validate:\"required,eqfield=Password\"` // 此字段必须和 Password 字段的值相等\n    \n    OldPassword     string `validate:\"required,min=8\"`\n    NewPassword     string `validate:\"required,min=8,nefield=OldPassword\"` // 新密码不能和旧密码一样\n}\n```\n\n有了这个，我们再也不用在代码里手动写 `if form.Password != form.ConfirmPassword` 这样的逻辑了！\n\n### 规则六：深入检查（校验切片或数组中的每一个元素）\n\n这个规则超级重要！假设你有一个订单，订单里包含一个商品列表（一个切片），你需要确保列表里的 **每一个** 商品都符合规定（比如商品名不能为空，价格必须大于0）。这时候就要用 `dive` 规则了。\n\n*   `dive`：告诉检查员，“请深入到这个数组/切片/map 的内部，对里面的每一个元素都进行检查”。\n\n`dive` 规则本身不带参数，它需要和内部元素的结构体标签配合使用。\n\n**示例：**\n让我们来看一个完整的订单校验场景。\n\n```go\n// 首先，定义列表里单个元素的规则\ntype Item struct {\n    SKU   string  `validate:\"required\"`       // 商品编号必填\n    Price float64 `validate:\"required,gt=0\"`  // 价格必填且大于0\n}\n\n// 然后，在订单结构体里使用 dive\ntype Order struct {\n    OrderID string `validate:\"required\"`\n    // 1. required: 订单必须有商品，Items 列表不能为空\n    // 2. min=1: 列表里至少要有一个商品\n    // 3. dive: 请深入到 Items 列表内部，对每一个 Item 对象进行校验\n    //    (校验规则就是 Item 结构体上定义的那些标签)\n    Items   []Item `validate:\"required,min=1,dive\"`\n}\n```\n\n**思考一下：** 如果 `Items` 字段的标签是 `validate:\"required\"` 而没有 `dive`，会发生什么？\n`validator` 只会检查 `Items` 这个切片本身是不是 `nil`，但它完全不会关心切片里面的 `Item` 对象的 `SKU` 和 `Price` 是否合法。`dive` 就像一个指令，告诉检查员：“打开这个包裹，检查里面的每个小盒子！”\n\n### 实战演练：一个复杂的订单校验\n\n我们来把刚刚学的 `dive` 和 `oneof` 结合起来，写一个完整的例子。\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/go-playground/validator/v10\"\n)\n\ntype Item struct {\n    Name  string `validate:\"required\"`\n    Price int    `validate:\"gt=0\"`\n}\n\ntype PurchaseOrder struct {\n    UserEmail string `validate:\"required,email\"`\n    // 订单类型只能是 'online' 或 'store'\n    Type      string `validate:\"required,oneof=online store\"`\n    // 商品列表不能为空，且列表里的每个 Item 都要符合规则\n    Items     []Item `validate:\"required,min=1,dive\"`\n}\n\nfunc main() {\n    validate := validator.New()\n\n    // --- 场景一：一个合法的订单 ---\n    fmt.Println(\"--- 场景一：合法订单 ---\")\n    orderOK := PurchaseOrder{\n        UserEmail: \"customer@test.com\",\n        Type:      \"online\",\n        Items: []Item{\n            {Name: \"Laptop\", Price: 1200},\n            {Name: \"Mouse\", Price: 25},\n        },\n    }\n    err := validate.Struct(orderOK)\n    if err == nil {\n        fmt.Println(\"订单校验通过！\")\n    }\n\n    // --- 场景二：一个非法的订单 (商品价格为0) ---\n    fmt.Println(\"\\n--- 场景二：非法订单 ---\")\n    orderFail := PurchaseOrder{\n        UserEmail: \"customer@test.com\",\n        Type:      \"store\",\n        Items: []Item{\n            {Name: \"Keyboard\", Price: 60},\n            {Name: \"USB Cable\", Price: 0}, // 这里的 Price 不满足 \"gt=0\"\n        },\n    }\n    err = validate.Struct(orderFail)\n    if err != nil {\n        fmt.Printf(\"订单校验失败: %v\\n\", err)\n    }\n}\n```\n\n**运行结果：**\n\n```\n--- 场景一：合法订单 ---\n订单校验通过！\n\n--- 场景二：非法订单 ---\n订单校验失败: Key: 'PurchaseOrder.Items[1].Price' Error:Field validation for 'Price' failed on the 'gt' tag\n```\n\n看到那个错误信息 `PurchaseOrder.Items[1].Price` 了吗？它非常精确地告诉我们：是 `PurchaseOrder` 结构体的 `Items` 字段里的、索引为 `1` 的那个元素的 `Price` 字段，在 `gt` 规则上校验失败了！这就是 `dive` 的强大之处。\n\n### 本章小结\n\n我们的检查员又学会了三项强大的技能，变得更加全能了：\n\n*   **多选一**：`oneof=value1 value2` (注意是空格分隔)，确保值在一个给定的集合内。\n*   **跨字段比较**：\n    *   `eqfield=FieldName` (等于另一个字段)\n    *   `nefield=FieldName` (不等于另一个字段)\n*   **深入校验**：`dive`，用于校验切片/数组/map中的每一个元素，必须和元素自身的结构体标签配合使用。\n\n到目前为止，你已经掌握了 `validator` 90% 以上的常用功能！你已经可以应对绝大多数的数据校验场景了。\n\n不过，我们一直看到那个不太友好的错误信息。如果数据校验失败了，我们总不能把 `Key: 'PurchaseOrder.Items[1].Price' ...` 这样一长串东西直接展示给用户看吧？下一章，我们就来解决这个问题，学习如何优雅地处理和翻译这些错误信息。\n\n好的，我们继续！\n\n到目前为止，我们的“检查员”工作完成得非常出色，总能准确地发现问题。但是，他写的“错误报告”实在是太“专业”了，就像医生写的病历一样，普通人（用户）根本看不懂。\n\n`Key: 'User.Name' Error:Field validation for 'Name' failed on the 'required' tag`\n\n把这个给用户看，用户估计会一脸茫然。所以，这一章我们的任务就是学会当一个“翻译官”，把这些专业的错误报告翻译成用户能看懂的友好提示，比如“用户名不能为空”。\n\n---\n\n## 第4章：“检查不通过！”—— 如何看懂并处理错误信息\n\n当 `validate.Struct()` 返回的 `error` 不为 `nil` 时，就表示校验失败了。这个 `error` 对象里其实包含了非常丰富的错误信息，我们需要学会如何把它解析出来。\n\n### 第一步：拆开“错误”这个大包裹\n\n`validator` 返回的错误不是一个普通的 `error`，它是一个特殊类型 `validator.ValidationErrors`。我们可以把它想象成一个装满了“具体错误项”的包裹。我们需要先把它从通用的 `error` 类型里“拆”出来。\n\n这在 Go 语言里叫做 **类型断言**。你可以这么理解：我们拿到一个盒子（`error`），我们猜测（或者说我们确定）里面装的是苹果（`validator.ValidationErrors`），于是我们就尝试把它当成苹果拿出来。\n\n```go\nerr := validate.Struct(someStruct)\nif err != nil {\n    // 这里进行类型断言\n    validationErrors, ok := err.(validator.ValidationErrors)\n    if !ok {\n        // 如果 ok 是 false，说明这不是一个校验错误，可能是别的意外，直接打印\n        fmt.Println(\"An unexpected error:\", err)\n        return\n    }\n    // 如果 ok 是 true，说明类型断言成功！\n    // validationErrors 就是我们想要的、包含了所有校验失败信息的对象\n    fmt.Println(\"恭喜，我们成功拆开了错误包裹！\")\n    // 接下来就可以处理 validationErrors 了\n}\n```\n\n### 第二步：遍历每一个“错误项”\n\n一个表单提交过来，可能同时有好几个字段都不合格（比如用户名太短，并且邮箱格式也不对）。`validationErrors` 其实是一个切片（可以理解为列表），里面装着每一个字段的具体错误信息。所以，我们可以用一个 `for` 循环来遍历它。\n\n里面的每一项都是一个 `validator.FieldError` 对象，它包含了关于单个字段校验失败的所有细节。\n\n我们来看一个 `FieldError` 包含了哪些有用的信息（我们只挑最重要的几个）：\n\n*   `.Field()`: 返回字段的 **名称** (比如 `Name`, `Age`)。\n*   `.Tag()`: 返回导致失败的那个 **规则标签** (比如 `required`, `min`, `email`)。\n*   `.Value()`: 返回导致失败的那个 **不合法的值** (比如空字符串 `\"\"`，不合法的邮箱地址 `abcde`)。\n*   `.Param()`: 返回规则标签的 **参数** (比如规则是 `min=6`，那 `.Param()` 返回的就是 `6`)。\n\n**示例：把错误信息“说人话”**\n\n结合上面的知识，我们来写一个例子，把专业的错误报告翻译成对用户友好的提示。\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/go-playground/validator/v10\"\n)\n\ntype User struct {\n    Username string `validate:\"required,min=3\"`\n    Email    string `validate:\"required,email\"`\n    Age      int    `validate:\"gte=18\"`\n}\n\nfunc main() {\n    validate := validator.New()\n\n    user := User{\n        Username: \"a\",    // 违反 min=3\n        Email:    \"test\", // 违反 email\n        Age:      17,     // 违反 gte=18\n    }\n\n    err := validate.Struct(user)\n    if err != nil {\n        // 进行类型断言\n        validationErrors, ok := err.(validator.ValidationErrors)\n        if !ok {\n            fmt.Println(err)\n            return\n        }\n\n        // 遍历所有错误\n        for _, fieldError := range validationErrors {\n            // 根据不同的字段和规则，生成不同的错误信息\n            switch fieldError.Field() {\n            case \"Username\":\n                if fieldError.Tag() == \"required\" {\n                    fmt.Println(\"用户名是必填的！\")\n                } else if fieldError.Tag() == \"min\" {\n                    // 使用 Param() 获取参数\n                    fmt.Printf(\"用户名长度不能小于 %s 个字符！\\n\", fieldError.Param())\n                }\n            case \"Email\":\n                if fieldError.Tag() == \"required\" {\n                    fmt.Println(\"邮箱是必填的！\")\n                } else if fieldError.Tag() == \"email\" {\n                    fmt.Println(\"邮箱格式不正确！\")\n                }\n            case \"Age\":\n                if fieldError.Tag() == \"gte\" {\n                    fmt.Printf(\"年龄必须大于或等于 %s 岁！\\n\", fieldError.Param())\n                }\n            }\n        }\n    }\n}\n```\n\n**运行结果：**\n你会看到，这次的输出非常清晰友好！\n\n```\n用户名长度不能小于 3 个字符！\n邮箱格式不正确！\n年龄必须大于或等于 18 岁！\n```\n\n（注意：错误的顺序可能每次不一样，因为 `validator` 内部是并发校验的）\n\n**思考一下：** 上面的 `switch-case` 和 `if-else` 是不是还是有点繁琐？如果结构体变得非常复杂，这里的代码也会变得很长。\n\n是的，这只是最基础的错误处理方式。在真实的项目中，大家通常会结合“翻译库”（如 `go-i18n`）或者自己写一个“错误消息映射表”（`map`），来把 `fieldError.Tag()` 自动映射成对应的错误消息，这样代码会更优雅。但原理都是一样的：**遍历 `validationErrors`，获取每一个 `FieldError`，然后根据它的 `.Field()` 和 `.Tag()` 来生成消息。**\n\n### 本章小结\n\n这一章是 `validator` 从“能用”到“好用”的关键一步。我们学会了如何处理它返回的错误：\n\n1.  **核心概念**：校验失败返回的 `error` 实际上是 `validator.ValidationErrors` 类型，它是一个包含了所有错误详情的集合。\n2.  **关键步骤**：\n    *   使用 **类型断言** `err.(validator.ValidationErrors)` 来拆开错误包裹。\n    *   使用 `for` 循环 **遍历** `validationErrors` 切片。\n3.  **信息提取**：在循环中，从 `FieldError` 对象中提取关键信息：\n    *   `.Field()` 获取字段名。\n    *   `.Tag()` 获取失败的规则。\n    *   `.Param()` 获取规则的参数。\n4.  **最终目的**：根据提取出的信息，组合成用户能看懂的、友好的错误提示。\n\n现在，你不仅能让检查员发现问题，还能让他用清晰的语言把问题报告出来。这已经非常接近一个专业的开发者了！\n\n不过，如果检查员自带的“规则手册”里没有我们想要的规则怎么办？比如，我想检查一个字段“必须是有效的中国手机号码”，`validator` 可没有内置这个规则。别担心，下一章，我们就来学习终极技巧：给他编写一本属于我们自己的“独家规则手册”！\n\n\n\n## 第5章：制定你自己的“特殊规则”—— 自定义验证函数\n\n这一章，我们将学习 `validator` 的终极技巧：创建并注册一个我们自己写的验证函数。这让 `validator` 的能力可以无限扩展，去适应任何奇特的业务需求。\n\n这听起来可能有点复杂，但其实是一个非常清晰的三步流程：\n\n1.  **编写规则**：写一个符合 `validator` 要求的函数。\n2.  **登记规则**：把我们写的函数告诉 `validator` 实例，并给它起一个名字（也就是标签名）。\n3.  **使用规则**：像使用 `required` 一样，在结构体里使用我们自己起的名字。\n\n### 第一步：编写规则（定义一个验证函数）\n\n一个自定义验证函数有固定的格式，就像填表一样，你必须按照它的模板来写：\n\n```go\nfunc(fl validator.FieldLevel) bool\n```\n\n*   它必须是一个函数。\n*   它只接收一个参数，类型是 `validator.FieldLevel`。\n*   它必须返回一个 `bool` 类型的值 (`true` 表示验证通过，`false` 表示验证失败)。\n\n**`validator.FieldLevel` 是什么？**\n你可以把它想象成检查员在检查某个具体字段时，拿到的“工作台”。这个工作台上放着关于这个字段的所有信息，比如它的值、它的类型、它的名字等等。\n\n我们最常用的就是通过 `fl.Field().String()` 来获取这个字段 **作为字符串的值**。\n\n**示例：创建一个检查“手机号”的函数**\n我们来写一个函数，规则是：手机号必须是 11 位，并且以 '1' 开头。（这是一个简化的规则，真实的手机号校验会更复杂，通常使用正则表达式，但原理是相通的）。\n\n```go\nimport (\n    \"github.com/go-playground/validator/v10\"\n    \"strings\"\n    \"unicode/utf8\"\n)\n\n// isValidMobile 是我们的自定义验证函数\nfunc isValidMobile(fl validator.FieldLevel) bool {\n    // 1. 从 \"工作台\" (fl) 上获取字段的值，并转为字符串\n    mobile := fl.Field().String()\n\n    // 2. 编写我们的检查逻辑\n    // 规则1：长度必须是 11 位\n    if utf8.RuneCountInString(mobile) != 11 {\n        return false // 不通过\n    }\n    // 规则2：必须以 '1' 开头\n    if !strings.HasPrefix(mobile, \"1\") {\n        return false // 不通过\n    }\n\n    // 3. 所有规则都满足了\n    return true // 通过！\n}\n```\n\n### 第二步：登记规则（注册自定义函数）\n\n我们写好了规则，但检查员还不知道它的存在。我们需要在创建 `validator` 实例后，把它“登记”到检查员的规则手册里，并给它起一个响亮的名字（标签）。\n\n这个登记动作通过 `validate.RegisterValidation()` 函数完成。\n\n```go\n// 1. 创建检查员实例\nvalidate := validator.New()\n\n// 2. 登记我们的新规则\n// 第一个参数是我们要起的 \"标签名\"，比如叫 \"is-valid-mobile\"\n// 第二个参数是我们上面写的函数 isValidMobile\nerr := validate.RegisterValidation(\"is-valid-mobile\", isValidMobile)\nif err != nil {\n    // 如果注册失败，一般是标签名有问题，程序应该中止\n    panic(\"Failed to register validation\")\n}\n```\n\n现在，检查员的规则手册里就多了一页，标题是 `is-valid-mobile`，内容就是我们 `isValidMobile` 函数里的逻辑。\n\n### 第三步：使用规则（在结构体里贴上新标签）\n\n一旦注册成功，我们就可以像使用任何内置标签一样，使用我们自己的 `is-valid-mobile` 标签了！\n\n```go\ntype UserProfile struct {\n    Name   string `validate:\"required\"`\n    Mobile string `validate:\"required,is-valid-mobile\"` // 看！我们用上了自己的规则！\n}\n```\n\n### 实战演练：完整的自定义校验流程\n\n下面是一个可以完整运行的例子，把上面三步串联了起来。\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/go-playground/validator/v10\"\n    \"strings\"\n    \"unicode/utf8\"\n)\n\n// UserProfile 结构体使用了我们的自定义标签\ntype UserProfile struct {\n    Name   string `validate:\"required\"`\n    Mobile string `validate:\"required,is-valid-mobile\"`\n}\n\n// 我们的自定义验证函数\nfunc isValidMobile(fl validator.FieldLevel) bool {\n    mobile := fl.Field().String()\n    if utf8.RuneCountInString(mobile) != 11 {\n        return false\n    }\n    if !strings.HasPrefix(mobile, \"1\") {\n        return false\n    }\n    return true\n}\n\nfunc main() {\n    // 1. 创建 validator 实例\n    validate := validator.New()\n\n    // 2. 注册我们的自定义函数\n    validate.RegisterValidation(\"is-valid-mobile\", isValidMobile)\n\n    // --- 场景一：合法的手机号 ---\n    fmt.Println(\"--- 场景一：合法手机号 ---\")\n    profileOK := UserProfile{Name: \"Bob\", Mobile: \"13800138000\"}\n    err := validate.Struct(profileOK)\n    if err == nil {\n        fmt.Println(\"校验通过！\")\n    }\n\n    // --- 场景二：非法的手机号 (太短) ---\n    fmt.Println(\"\\n--- 场景二：非法手机号 ---\")\n    profileFail := UserProfile{Name: \"Charlie\", Mobile: \"12345\"}\n    err = validate.Struct(profileFail)\n    if err != nil {\n        // 我们同样可以处理这个自定义规则的错误\n        validationErrors := err.(validator.ValidationErrors)\n        for _, fieldError := range validationErrors {\n            if fieldError.Field() == \"Mobile\" && fieldError.Tag() == \"is-valid-mobile\" {\n                fmt.Println(\"手机号码格式不正确，必须是11位且以1开头！\")\n            }\n        }\n    }\n}\n```\n\n**运行结果：**\n\n```\n--- 场景一：合法手机号 ---\n校验通过！\n\n--- 场景二：非法手机号 ---\n手机号码格式不正确，必须是11位且以1开头！\n```\n\n### 本章小结\n\n太厉害了！你已经掌握了 `validator` 最核心、最灵活的用法。我们来回顾一下自定义校验的“三部曲”：\n\n1.  **定义函数**：创建一个函数，签名必须是 `func(fl validator.FieldLevel) bool`，并在函数体内实现你的校验逻辑。\n2.  **注册函数**：使用 `validate.RegisterValidation(\"your-tag-name\", yourFunction)` 将函数和标签名绑定，并注册到 `validator` 实例中。\n3.  **使用标签**：在你的结构体 `validate` 标签中，像使用内置标签一样使用你自定义的 `your-tag-name`。\n\n有了这个能力，再也没有 `validator` 无法完成的校验任务了。从现在起，你可以为你的项目量身定做任何你需要的“检查规则”。\n\n到这里，`validator` 的主要功能我们已经全部学完了。接下来的章节，我们会聊一些经验之谈和最佳实践，帮助你在真实项目中用得更稳、更好。最后再通过一个完整的实战练习来巩固所有知识。\n\n---\n\n## 第6章：经验之谈 —— 使用 validator 的注意事项与技巧\n\n这一章我们不学新功能，而是围绕“如何更好地使用”展开。\n\n### 技巧一：校验器实例，全局单例就够了\n\n你在前面的例子中可能注意到了，我们每次都是在 `main` 函数里用 `validator.New()` 创建一个新的校验器实例。在小程序里这样做没问题，但在一个大的Web应用里，每次处理一个请求就创建一个新的实例，是一种浪费。\n\n`validator` 的实例是 **并发安全** 的，这意味着在多个协程（goroutine，你可以简单理解为多个任务同时进行）中共享同一个实例是完全安全的。\n\n**最佳实践：**\n在你的项目中，只创建一个全局的 `validator` 实例，然后在所有需要校验的地方重复使用它。如果需要注册自定义验证，也在程序启动时一次性完成注册。\n\n```go\npackage main\n\nimport \"github.com/go-playground/validator/v10\"\n\n// 在包级别（全局）创建一个 Validator 实例\nvar validate *validator.Validate\n\n// init 函数在包被导入时自动执行，是进行初始化的好地方\nfunc init() {\n    validate = validator.New()\n\n    // 如果有自定义验证，也在这里一次性注册好\n    // validate.RegisterValidation(\"my-tag\", myValidationFunc)\n}\n\n// 你的业务函数可以直接使用这个全局的 validate 实例\nfunc HandleUserRegistration(user User) {\n    err := validate.Struct(user)\n    if err != nil {\n        // ... 处理错误\n    }\n    // ...\n}\n```\n\n这样做的好处是：\n\n*   **性能更好**：避免了重复创建对象的开销。\n*   **管理方便**：所有自定义规则的注册都集中在一个地方，清晰明了。\n\n### 技巧二：校验单个变量，而不仅仅是结构体\n\n我们一直都在用 `validate.Struct()` 来校验整个结构体。但有时，你可能只想校验一个独立的变量。比如，你想确认某个函数接收的字符串参数 `email` 是不是合法的邮箱格式。\n\n`validator` 提供了 `validate.Var()` 方法来满足这个需求。\n\n**示例：**\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/go-playground/validator/v10\"\n)\n\nfunc main() {\n    validate := validator.New()\n\n    // --- 场景一：校验一个合法的邮箱字符串 ---\n    emailOK := \"test@example.com\"\n    // 第一个参数是变量本身，第二个参数是应用在它身上的规则\n    err := validate.Var(emailOK, \"required,email\")\n    if err == nil {\n        fmt.Println(\"emailOK 是一个合法的邮箱地址！\")\n    }\n\n    // --- 场景二：校验一个非法的 IP 地址字符串 ---\n    ipFail := \"127.0.0\"\n    err = validate.Var(ipFail, \"ip\")\n    if err != nil {\n        fmt.Printf(\"ipFail 不是一个合法的 IP 地址: %v\\n\", err)\n    }\n}\n```\n\n`validate.Var()` 非常适合用在那些不方便或不需要定义一个完整结构体的零散校验场景中。\n\n### 技巧三：注意 `required` 与 `omitempty` 的区别\n\n这是一个新手很容易混淆的地方。\n\n*   `required`：**必须存在**。字段不能是其类型的“零值”（比如 `int` 的 `0`，`string` 的 `\"\"`，指针或切片的 `nil`）。如果不存在，就报错。\n*   `omitempty`：**如果有值，才校验**。`omit` 是忽略的意思。这个标签告诉 `validator`：“如果这个字段是零值，那就跳过它，别管它后面的其他规则了。但如果它有值，那就请继续检查后面的规则。”\n\n**一个经典的例子：更新用户信息**\n假设用户只想更新他的昵称，提交的 JSON 数据可能只包含 `nickname` 字段，而 `email` 字段是空的。\n\n```go\ntype UserUpdateForm struct {\n    // 如果 nickname 不为空，则必须满足最小长度为2\n    Nickname string `validate:\"omitempty,min=2\"`\n\n    // 如果 email 不为空，则必须是 email 格式\n    Email    string `validate:\"omitempty,email\"`\n}\n\n// 场景一：用户只更新昵称\nform1 := UserUpdateForm{Nickname: \"NewName\"}\n// 校验会通过，因为 Email 是空字符串，`omitempty` 使 `email` 规则被跳过。\n\n// 场景二：用户更新了一个错误的邮箱\nform2 := UserUpdateForm{Email: \"not-an-email\"}\n// 校验会失败，因为 Email 不为空，所以 `email` 规则被触发且校验失败。\n\n// 场景三：用户啥也没填\nform3 := UserUpdateForm{}\n// 校验会通过，因为两个字段都是空，所有规则都被 `omitempty` 跳过了。\n```\n\n**记住这个组合**：`omitempty` 经常和其它规则一起使用，用于“可选字段”的校验，非常实用！\n\n### 技巧四：校验嵌套结构体\n\n如果你的结构体里包含了另一个结构体，`validator` 默认是不会自动深入进去校验的。你需要明确告诉它。\n\n和 `dive` 校验切片/数组类似，对于嵌套的结构体，你只需要在字段上加上 `dive` 标签，或者简单地加上 `required`（或其他任何标签）来触发校验。更规范的方式是在嵌套的结构体字段上直接进行校验。\n\n```go\ntype Address struct {\n    Street string `validate:\"required\"`\n    City   string `validate:\"required\"`\n}\n\ntype User struct {\n    Name    string  `validate:\"required\"`\n    // Address 字段本身是必填的（不能是nil），\n    // 并且需要对 Address 内部的字段进行校验\n    Address Address `validate:\"required\"` \n}\n```\n\n**更正与修改:**\n实际上，对于嵌套结构体，`validator` 默认就会递归地进行校验。你只需要确保在外层结构体验证时，内层结构体的字段也已经定义了标签。上面的`validate:\"required\"`是针对`Address`这个结构体本身不能是零值，而它内部的`Street`和`City`的`required`标签会在校验`User`时被自动检查。\n\n为了更清晰地表达“请深入校验”，通常可以直接写 `validate:\"\"` 配合内部的标签，或者如果该嵌套结构体本身是可选的指针类型，则可以使用`dive`。\n\n```go\ntype UserWithOptionalAddress struct {\n    Name    string   `validate:\"required\"`\n    // 如果 Address 字段存在（不是nil），则深入校验其内部\n    Address *Address `validate:\"omitempty,dive\"`\n}\n```\n\n*   对于`struct`类型，`validator`会自动深入。\n*   对于`*struct`（指针）、`[]struct`（切片）等，使用`dive`来告诉校验器需要深入检查。\n\n### 本章小结\n\n这一章我们没有学习新标签，而是修炼了“内功”，让使用 `validator` 的方式更加地道和高效：\n\n*   **全局单例**：整个应用共享一个 `validator` 实例，在 `init` 函数中初始化和注册规则。\n*   **校验单个变量**：使用 `validate.Var()` 来校验零散的变量。\n*   **可选字段校验**：`omitempty` 是处理“非必填但有值时需满足规则”场景的利器。\n*   **嵌套结构体**：对于指针、切片、数组或 map 里的结构体，记得使用 `dive` 来进行深度校验。\n\n掌握了这些技巧，你就可以自信地在任何规模的项目中使用 `validator` 库了。理论学习已经足够，下一章，我们将把目前学到的所有知识融会贯通，完成一个最终的实战演练！\n\n好的，激动人心的时刻到了！\n\n我们已经学习了 `validator` 的方方面面，从基础概念到高级技巧。现在是时候把所有知识碎片拼接到一起，像在真实项目中那样，完成一个完整的、有挑战性的任务了。\n\n---\n\n## 第7章：实战演练 —— 用户注册信息校验\n\n**演练目标：**\n我们要创建一个用户注册的后端校验逻辑。这个逻辑需要能够接收一个模拟的用户注册表单，并使用 `validator` 对其进行全面的校验。最后，将专业的校验错误翻译成对用户友好的提示信息列表。\n\n**需求清单：**\n\n1.  **用户名 (Username)**:\n    *   必填。\n    *   长度在 4 到 20 个字符之间。\n    *   不能包含 \"admin\" 这个词（这是个自定义规则！）。\n2.  **密码 (Password)**:\n    *   必填。\n    *   长度至少为 8 个字符。\n3.  **确认密码 (ConfirmPassword)**:\n    *   必填。\n    *   必须和 `Password` 字段的值一致。\n4.  **邮箱 (Email)**:\n    *   必填。\n    *   必须是有效的邮箱格式。\n5.  **年龄 (Age)**:\n    *   非必填。\n    *   但如果填写了，必须年满 18 周岁。\n6.  **兴趣爱好 (Hobbies)**:\n    *   非必填。\n    *   但如果填写了，最多只能选择 5 个。\n    *   每个兴趣爱好的字符串本身不能为空（深入校验！）。\n\n**错误处理要求：**\n将所有校验失败的信息收集起来，格式化成一个清晰的 `map[string]string`，其中 `key` 是字段名，`value` 是友好的错误提示。\n\n好了，需求明确，我们开始动手吧！\n\n### 第一步：定义结构体和自定义验证函数\n\n根据需求清单，我们需要先设计我们的 `RegisterForm` 结构体，并为 \"不能包含 admin\" 这个特殊需求编写一个自定义验证函数。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/go-playground/validator/v10\"\n\t\"strings\"\n)\n\n// 1. 定义我们的注册表单结构体，并贴上所有需要的标签\ntype RegisterForm struct {\n\tUsername        string   `validate:\"required,min=4,max=20,no-admin\"`\n\tPassword        string   `validate:\"required,min=8\"`\n\tConfirmPassword string   `validate:\"required,eqfield=Password\"`\n\tEmail           string   `validate:\"required,email\"`\n\tAge             int      `validate:\"omitempty,gte=18\"`\n\tHobbies         []string `validate:\"omitempty,max=5,dive,required\"`\n}\n\n// 2. 编写自定义验证函数 `noAdmin`\nfunc noAdmin(fl validator.FieldLevel) bool {\n\t// 判断字段值（转为小写后）是否包含 \"admin\"\n\treturn !strings.Contains(strings.ToLower(fl.Field().String()), \"admin\")\n}\n```\n\n**代码解析：**\n\n*   `Username`: 我们用了一个自定义标签 `no-admin`，准备稍后注册它。\n*   `Age`: 使用 `omitempty,gte=18`，完美实现了“可选但填了就要大于等于18”的需求。\n*   `Hobbies`: `omitempty` 表示整个爱好列表可以不填。`max=5` 限制列表长度。`dive` 表示要深入列表内部。最后的 `required` 是应用在 `dive` 之后的，意思是列表里的 **每个字符串** 都不能为空。\n\n### 第二步：初始化校验器并注册自定义规则\n\n我们遵循最佳实践，把校验器和自定义规则的注册放在一起。\n\n```go\n// 在这个文件中，我们直接在 main 函数里初始化\n// 在真实项目中，这部分代码应该在程序的初始化阶段（如 init 函数）\nfunc setupValidator() *validator.Validate {\n\tvalidate := validator.New()\n\t// 注册 \"no-admin\" 标签对应的验证函数\n\terr := validate.RegisterValidation(\"no-admin\", noAdmin)\n\tif err != nil {\n\t\tpanic(\"Failed to register custom validation\")\n\t}\n\treturn validate\n}\n```\n\n### 第三步：编写校验和错误翻译的核心逻辑\n\n这是本次实战的核心。我们将创建一个函数，它接收一个 `RegisterForm`，返回一个 `map` 形式的错误信息。\n\n```go\n// translateErrors 函数负责执行校验并翻译错误\nfunc translateErrors(validate *validator.Validate, form interface{}) map[string]string {\n\terr := validate.Struct(form)\n\tif err == nil {\n\t\treturn nil // 如果没有错误，返回 nil\n\t}\n\n\t// 类型断言，获取 ValidationErrors\n\tvalidationErrors, ok := err.(validator.ValidationErrors)\n\tif !ok {\n\t\t// 如果不是校验错误，返回一个通用错误\n\t\treturn map[string]string{\"error\": \"An unexpected error occurred\"}\n\t}\n\n\t// 创建一个 map 用于存放翻译后的错误信息\n\terrorMap := make(map[string]string)\n\n\tfor _, fieldError := range validationErrors {\n\t\t// 使用 switch-case 为每个字段和规则生成友好的消息\n\t\tfield := fieldError.Field()\n\t\ttag := fieldError.Tag()\n\n\t\tswitch field {\n\t\tcase \"Username\":\n\t\t\tswitch tag {\n\t\t\tcase \"required\":\n\t\t\t\terrorMap[field] = \"用户名是必填项。\"\n\t\t\tcase \"min\":\n\t\t\t\terrorMap[field] = \"用户名长度不能少于4个字符。\"\n\t\t\tcase \"max\":\n\t\t\t\terrorMap[field] = \"用户名长度不能超过20个字符。\"\n\t\t\tcase \"no-admin\":\n\t\t\t\terrorMap[field] = \"用户名不能包含 'admin'。\"\n\t\t\t}\n\t\tcase \"Password\":\n\t\t\tif tag == \"min\" {\n\t\t\t\terrorMap[field] = \"密码长度不能少于8个字符。\"\n\t\t\t}\n\t\tcase \"ConfirmPassword\":\n\t\t\tif tag == \"eqfield\" {\n\t\t\t\terrorMap[field] = \"两次输入的密码不一致。\"\n\t\t\t}\n\t\tcase \"Email\":\n\t\t\tif tag == \"email\" {\n\t\t\t\terrorMap[field] = \"请输入有效的邮箱地址。\"\n\t\t\t}\n\t\tcase \"Age\":\n\t\t\tif tag == \"gte\" {\n\t\t\t\terrorMap[field] = \"必须年满18周岁。\"\n\t\t\t}\n\t\tcase \"Hobbies\":\n\t\t\tif tag == \"max\" {\n\t\t\t\terrorMap[field] = \"最多只能选择5个兴趣爱好。\"\n\t\t\t} else if tag == \"required\" {\n\t\t\t\t// 这个 required 是 dive 之后的，说明是列表内的元素有问题\n\t\t\t\terrorMap[field] = \"兴趣爱好不能为空字符串。\"\n\t\t\t}\n\t\t}\n\t}\n\treturn errorMap\n}\n```\n\n### 第四步：整合与测试\n\n现在，我们把所有部分组合在 `main` 函数里，并创建几个测试用例来看看我们的成果。\n\n```go\nfunc main() {\n\t// 1. 初始化校验器\n\tvalidate := setupValidator()\n\n\t// --- 测试用例 1: 一个问题百出的表单 ---\n\tfmt.Println(\"--- 测试用例 1: 问题表单 ---\")\n\tbadForm := RegisterForm{\n\t\tUsername:        \"adm\",                  // 太短，且包含'adm'(我们的小写检查会发现) -> 修正：太短\n\t\tPassword:        \"123\",                  // 太短\n\t\tConfirmPassword: \"456\",                  // 与密码不一致\n\t\tEmail:           \"test@\",                // 格式错误\n\t\tAge:             16,                     // 年龄太小\n\t\tHobbies:         []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"}, // 太多爱好\n\t}\n\terrors := translateErrors(validate, badForm)\n\tif errors != nil {\n\t\tfmt.Println(\"校验失败，错误信息如下：\")\n\t\tfor field, msg := range errors {\n\t\t\tfmt.Printf(\"- %s: %s\\n\", field, msg)\n\t\t}\n\t}\n\n\t// --- 测试用例 2: 另一个问题表单，包含自定义规则失败 ---\n\tfmt.Println(\"\\n--- 测试用例 2: 用户名含 admin ---\")\n\tadminForm := RegisterForm{\n\t\tUsername:        \"super-admin-user\",\n\t\tPassword:        \"12345678\",\n\t\tConfirmPassword: \"12345678\",\n\t\tEmail:           \"admin@test.com\",\n\t}\n\terrors = translateErrors(validate, adminForm)\n\tif errors != nil {\n\t\tfmt.Println(\"校验失败，错误信息如下：\")\n\t\tfor field, msg := range errors {\n\t\t\tfmt.Printf(\"- %s: %s\\n\", field, msg)\n\t\t}\n\t}\n\n\n\t// --- 测试用例 3: 一个完美的表单 ---\n\tfmt.Println(\"\\n--- 测试用例 3: 完美表单 ---\")\n\tgoodForm := RegisterForm{\n\t\tUsername:        \"gooduser\",\n\t\tPassword:        \"password123\",\n\t\tConfirmPassword: \"password123\",\n\t\tEmail:           \"good@user.com\",\n\t\tAge:             25,\n\t\tHobbies:         []string{\"coding\", \"reading\"},\n\t}\n\terrors = translateErrors(validate, goodForm)\n\tif errors == nil {\n\t\tfmt.Println(\"表单校验通过，可以进行注册！\")\n\t}\n}\n```\n\n**预期运行结果：**\n\n```\n--- 测试用例 1: 问题表单 ---\n校验失败，错误信息如下：\n- Username: 用户名长度不能少于4个字符。\n- Password: 密码长度不能少于8个字符。\n- ConfirmPassword: 两次输入的密码不一致。\n- Email: 请输入有效的邮箱地址。\n- Age: 必须年满18周岁。\n- Hobbies: 最多只能选择5个兴趣爱好。\n\n--- 测试用例 2: 用户名含 admin ---\n校验失败，错误信息如下：\n- Username: 用户名不能包含 'admin'。\n\n--- 测试用例 3: 完美表单 ---\n表单校验通过，可以进行注册！\n```\n\n### 本章总结与复习\n\n恭喜你！你已经成功地将我们前面六章学到的所有知识点融会贯通，解决了一个非常贴近真实项目的需求。\n\n我们再回顾一下这个过程中用到的所有知识点：\n\n*   **基本使用**：`validator.New()` 创建实例，`validate.Struct()` 执行校验。\n*   **常用标签**：`required`, `min`, `max`, `eqfield`, `email`, `gte`。\n*   **高级标签**：`omitempty`, `dive`。\n*   **自定义规则**：自己写了 `noAdmin` 函数，并通过 `RegisterValidation` 注册了 `no-admin` 标签。\n*   **错误处理**：通过类型断言获取 `ValidationErrors`，遍历它，并根据 `Field()` 和 `Tag()` 将错误信息翻译成用户友好的 `map`。\n*   **最佳实践**：将校验器的创建和注册逻辑封装起来。\n\n通过这个实战，你应该对 `validator` 库的强大和便捷有了非常深刻的理解。它几乎是所有 Go Web 开发和 API 开发项目中的必备工具。希望这份学习笔记能成为你未来项目开发中的好帮手！\n\n课程到此结束，继续探索和练习吧！\n\n\n\n\n\n# 附录\n\n## Go Validator 常用校验标签总览（含用途说明）\n\n| 作用描述                           | 校验标签（可直接复制） | 适用类型                 | 含义说明                         | 示例                            |\n| ---------------------------------- | ---------------------- | ------------------------ | -------------------------------- | ------------------------------- |\n| 判断是否等于指定值                 | `eq`                   | 所有类型                 | 等于指定值                       | `eq=100` → 值必须等于100        |\n| 判断是否不等于指定值               | `ne`                   | 所有类型                 | 不等于指定值                     | `ne=0` → 值不能等于0            |\n| 判断是否大于指定值或长度           | `gt`                   | 数字、字符串、切片、数组 | 大于指定值/长度                  | `gt=10` → 数字>10；长度>10      |\n| 判断是否大于等于指定值或长度       | `gte`                  | 数字、字符串、切片、数组 | 大于等于指定值/长度              | `gte=1` → 值≥1                  |\n| 判断是否小于指定值或长度           | `lt`                   | 数字、字符串、切片、数组 | 小于指定值/长度                  | `lt=5` → 数字<5；长度<5         |\n| 判断是否小于等于指定值或长度       | `lte`                  | 数字、字符串、切片、数组 | 小于等于指定值/长度              | `lte=100` → 值≤100              |\n| 判断长度是否等于指定值             | `len`                  | 字符串、切片、数组       | 长度等于指定值                   | `len=6` → 长度必须为6           |\n| 判断是否达到最小值或最小长度       | `min`                  | 数字、字符串、切片、数组 | 最小值/长度下限                  | `min=3` → 值或长度≥3            |\n| 判断是否超过最大值或最大长度       | `max`                  | 数字、字符串、切片、数组 | 最大值/长度上限                  | `max=10` → 值或长度≤10          |\n| 判断值是否在给定集合内             | `oneof`                | 所有类型                 | 值必须是给定选项之一             | `oneof=red green blue`          |\n| 强制字段必须有值                   | `required`             | 所有类型                 | 不可为零值或空值                 | `required`                      |\n| 允许字段为空时跳过其他校验         | `omitempty`            | 所有类型                 | 为空则跳过后续校验               | `omitempty,gte=1,lte=10`        |\n| 校验邮箱格式                       | `email`                | 字符串                   | 必须为合法邮箱                   | `email`                         |\n| 校验URL格式                        | `url`                  | 字符串                   | 必须为合法URL                    | `url`                           |\n| 校验URI格式                        | `uri`                  | 字符串                   | 必须为合法URI                    | `uri`                           |\n| 校验是否为IPv4或IPv6地址           | `ip`                   | 字符串                   | IPv4 或 IPv6 地址                | `ip`                            |\n| 校验是否为IPv4地址                 | `ipv4`                 | 字符串                   | IPv4 地址格式                    | `ipv4`                          |\n| 校验是否为IPv6地址                 | `ipv6`                 | 字符串                   | IPv6 地址格式                    | `ipv6`                          |\n| 校验是否为合法UUID（任意版本）     | `uuid`                 | 字符串                   | UUID v1~v5                       | `uuid`                          |\n| 校验是否为UUID v4                  | `uuid4`                | 字符串                   | 仅限 UUID v4                     | `uuid4`                         |\n| 校验时间格式                       | `datetime`             | 字符串                   | 指定格式的时间字符串             | `datetime=2006-01-02`           |\n| 校验是否只包含字母                 | `alpha`                | 字符串                   | 仅允许字母字符                   | `alpha`                         |\n| 校验是否只包含字母和数字           | `alphanum`             | 字符串                   | 仅允许字母和数字                 | `alphanum`                      |\n| 校验是否仅包含数字字符             | `numeric`              | 字符串                   | 仅数字（可字符串形式）           | `numeric`                       |\n| 校验布尔格式                       | `boolean`              | 字符串                   | \"true\"/\"false\"/\"1\"/\"0\"           | `boolean`                       |\n| 校验是否包含指定子串               | `contains`             | 字符串                   | 必须包含指定内容                 | `contains=@`                    |\n| 校验是否不包含指定子串             | `excludes`             | 字符串                   | 不得包含指定内容                 | `excludes=admin`                |\n| 校验是否以指定前缀开头             | `startswith`           | 字符串                   | 必须以指定前缀开头               | `startswith=ABC`                |\n| 校验是否以指定后缀结尾             | `endswith`             | 字符串                   | 必须以指定后缀结尾               | `endswith=.com`                 |\n| 校验是否为Base64格式               | `base64`               | 字符串                   | Base64 字符串                    | `base64`                        |\n| 校验是否为十六进制字符串           | `hexadecimal`          | 字符串                   | 十六进制格式                     | `hexadecimal`                   |\n| 校验是否为颜色的十六进制格式       | `hexcolor`             | 字符串                   | #RRGGBB 或 #RGB                  | `hexcolor`                      |\n| 校验是否为RGB格式                  | `rgb`                  | 字符串                   | rgb(255,255,255) 格式            | `rgb`                           |\n| 校验是否为RGBA格式                 | `rgba`                 | 字符串                   | rgba(255,255,255,1) 格式         | `rgba`                          |\n| 校验是否不包含任意给定字符         | `excludesall`          | 字符串                   | 不允许出现指定字符集合           | `excludesall=!@#`               |\n| 校验是否不包含特定Unicode符号      | `excludesrune`         | 字符串                   | 不允许包含特定字符               | `excludesrune=你`               |\n| 校验路径是否为文件                 | `file`                 | 文件路径                 | 必须是存在的文件                 | `file`                          |\n| 校验路径是否为目录                 | `dir`                  | 文件路径                 | 必须是存在的目录                 | `dir`                           |\n| 比较当前字段是否等于另一个字段     | `eqfield`              | 同结构体内字段           | 当前字段等于指定字段             | `eqfield=Password`              |\n| 比较当前字段是否不等于另一个字段   | `nefield`              | 同结构体内字段           | 当前字段不等于指定字段           | `nefield=Username`              |\n| 比较当前字段是否大于另一个字段     | `gtfield`              | 同结构体内字段           | 大于指定字段                     | `gtfield=MinAge`                |\n| 比较当前字段是否大于等于另一个字段 | `gtefield`             | 同结构体内字段           | 大于等于指定字段                 | `gtefield=MinAge`               |\n| 比较当前字段是否小于另一个字段     | `ltfield`              | 同结构体内字段           | 小于指定字段                     | `ltfield=MaxAge`                |\n| 比较当前字段是否小于等于另一个字段 | `ltefield`             | 同结构体内字段           | 小于等于指定字段                 | `ltefield=MaxAge`               |\n| 正则匹配自定义规则                 | `regexp`               | 字符串                   | 匹配指定正则表达式               | `regexp=^[A-Z]{3}[0-9]{4}$`     |\n| 条件必填：若其他字段存在           | `required_with`        | 同结构体内字段           | 若指定字段存在，则本字段必填     | `required_with=Email`           |\n| 条件必填：若其他字段存在任意       | `required_with_all`    | 同结构体内字段           | 若任意一个字段存在，则必填       | `required_with_all=Phone Email` |\n| 条件必填：若其他字段不存在         | `required_without`     | 同结构体内字段           | 若指定字段不存在，则必填         | `required_without=Email`        |\n| 条件排除：若某字段存在             | `excluded_with`        | 同结构体内字段           | 若指定字段存在，则本字段不得存在 | `excluded_with=Password`        |\n| 切片唯一性校验                     | `unique`               | 切片、数组               | 所有元素必须唯一                 | `unique`                        |","tags":["使用教程","AI","protected","Golang","三方库","validator"],"categories":["技术","Golang"]},{"title":"Redis学习笔记","url":"/2025/08/26/Redis学习笔记/","content":"\n# 大纲\n\n## **Redis 核心概念与基础**\n\n1. **Redis 是什么？**\n   - Redis 简介：内存数据结构存储，可用作数据库、缓存和消息中间件。\n   - 核心优势：高性能（基于内存）、丰富的数据类型、原子性操作。\n   - 主要应用场景：缓存系统、分布式会话、排行榜、计数器、消息队列、分布式锁等。\n2. **安装与启动**\n   - 在不同操作系统（Linux, macOS, Windows/WSL, Docker）上安装 Redis。\n   - 启动 Redis 服务器。\n   - 使用 redis-cli：连接、执行命令、PING/PONG 测试。\n   - Redis 配置文件 (redis.conf) 的基本介绍。\n3. **Redis 五大核心数据类型（理论与 redis-cli 实战）**\n   - **String (字符串)**\n     - 简介：最基本的数据类型，可以是字符串、整数或浮点数。\n     - 常用命令：SET, GET, DEL, INCR, DECR, SETEX, MSET。\n       常用命令：SET， GET， DEL， INCR， DECR， SETEX， MSET。\n   - **List (列表)**\n     - 简介：字符串列表，按插入顺序排序，底层是双向链表。\n     - 常用命令：LPUSH, RPUSH, LPOP, RPOP, LRANGE, LLEN。 兰奇，莱伦。\n   - **Hash (哈希/字典)**\n     - 简介：键值对集合，适合存储对象。\n     - 常用命令：HSET, HGET, HGETALL, HDEL, HKEYS, HVALS。\n       HGETALL， HDEL， HKEYS， HVALS。\n   - **Set (集合)**\n     - 简介：无序的、唯一的字符串集合。\n     - 常用命令：SADD, SREM, SMEMBERS, SISMEMBER, SUNION, SINTER。\n       SISMEMBER、SUNION、SINTER。\n   - **Sorted Set (ZSET / 有序集合)\n     Sorted Set （ZSET / 有序集合）**\n     - 简介：唯一的字符串集合，每个成员都关联一个 double 类型的分数（score），并按分数排序。\n     - 常用命令：ZADD, ZREM, ZRANGE, ZREVRANGE, ZRANGEBYSCORE, ZCARD。\n       常用命令：ZADD， ZREM， ZRANGE， ZREVRANGE， ZRANGEBYSCORE， ZCARD。\n4. **通用键命令 (Key Commands)**\n   - KEYS pattern: 查找所有符合给定模式的 key（生产环境慎用）。\n   - EXISTS key: 检查 key 是否存在。\n   - TYPE key: 返回 key 所存储的值的类型。\n   - EXPIRE key seconds: 为 key 设置过期时间。\n   - TTL key: 查看 key 的剩余生存时间。\n   - RENAME key newkey: 重命名 key。\n     Rename 的 Newkie：重命名 Ki。\n\n## **Go 与 Redis 集成**\n\n1. **准备 Go 环境**\n   - 选择一个 Redis Go 客户端：go-redis/redis (推荐) vs gomodule/redigo。\n   - 安装 go-redis 库：go get github.com/go-redis/redis/v9。\n2. **连接 Redis**\n   - 创建 Redis 客户端 (redis.NewClient)。\n   - 配置连接选项：地址、密码、数据库编号。\n   - 连接池的概念与配置。\n   - 测试连接：在 Go 中执行 Ping 命令。\n3. **在 Go 中操作 Redis 核心数据类型**\n   - **String 操作**\n     - Set(ctx, key, value, expiration)\n       Set（ctx， key， value， expiration）\n     - Get(ctx, key) Get（ctx， 键）\n     - 错误处理：redis.Nil 的特殊处理。\n   - **List 操作**\n     - LPush(ctx, key, values...)\n       LPush（ctx， key， values...）\n     - RPop(ctx, key) RPop（ctx，密钥）\n     - LRange(ctx, key, start, stop)\n       LRange（ctx， key， start， stop）\n   - **Hash 操作**\n     - HSet(ctx, key, field, value)\n       HSet（ctx， 键， 字段， 值）\n     - HGet(ctx, key, field) HGet（ctx， 键， 字段）\n     - HGetAll(ctx, key) HGetAll（ctx，密钥）\n   - **Set 操作**\n     - SAdd(ctx, key, members...)\n       SAdd（ctx， key， members...）\n     - SMembers(ctx, key) SMembers（ctx， 密钥）\n   - **Sorted Set 操作 Sorted Set 作**\n     - ZAdd(ctx, key, members...) (使用 redis.Z 结构)\n       ZAdd（ctx， key， members...） （使用 redis.Z 结构）\n     - ZRange(ctx, key, start, stop)\n       ZRange（ctx， key， start， stop）\n4. **上下文管理 (context.Context)\n   上下文管理 (context. Context)**\n   - 为什么 go-redis 的每个操作都需要 context？\n   - 使用 context 控制超时和取消操作。\n\n## **Redis 进阶主题与 Go 实战**\n\n1. **事务 (Transactions) 事务 （Transactions）**\n   - Redis 事务：MULTI, EXEC, DISCARD, WATCH 命令。\n     Redis 事务：MULTI， EXEC， DISCARD， WATCH 命令\n   - go-redis 中的 Pipeline 和 TxPipeline：一次性发送多个命令，减少网络开销。\n   - 在 Go 中使用 WATCH 实现乐观锁。\n2. **发布/订阅 (Pub/Sub)**\n   - Pub/Sub 模式简介。\n   - 在 Go 中创建订阅者 (Subscribe)。 订阅）。\n   - 在 Go 中创建发布者 (Publish)。\n   - 实现一个简单的实时聊天室或通知系统。\n3. **持久化 (Persistence) 持久化 （Persistence）**\n   - **RDB (快照)**：工作原理、优缺点。\n   - **AOF (只追加文件)**：工作原理、优缺点。\n   - 如何选择合适的持久化策略。\n4. **Lua 脚本**\n   - 为什么需要 Lua 脚本？（保证原子性、减少网络请求）。\n   - 在 Go 中执行 Lua 脚本 (Eval, EvalSha)。 Eval， EvalSha）。\n   - 一个使用 Lua 脚本实现原子性操作的例子（例如：安全的库存扣减）。\n5. **Redis Streams (流) Redis Streams （流）**\n   - 简介：强大的、支持消费者组的消息队列。\n   - 核心命令：XADD, XREAD, XGROUP CREATE, XREADGROUP。\n     XGROUP 创建，XREADGROUP。\n   - 在 Go 中使用 Streams 实现一个可靠的消息队列。\n\n## **高级应用与实战模式**\n\n1. **构建缓存层 (Caching)**\n   - 缓存模式：Cache-Aside (旁路缓存)。\n   - 在 Go Web 应用中集成 Redis 缓存，减轻数据库压力。\n   - 缓存穿透、缓存击穿、缓存雪崩问题及其解决方案。\n2. **实现分布式锁**\n   - 基于 SETNX 的基本实现。\n   - 带有超时和唯一请求 ID 的安全分布式锁实现。\n   - Redlock 算法思想简介。\n3. **位图 (Bitmaps) 与 HyperLogLogs\n   位图 （Bitmaps） 与 HyperLogLogs**\n   - **Bitmaps**：用于高效存储布尔信息（如用户签到、在线状态）。\n     - Go 中的 SetBit, GetBit, BitCount 操作。\n   - **HyperLogLogs**：用于基数统计（如统计独立访客数），占用空间极小。\n     - Go 中的 PFAdd, PFCount 操作。\n\n## **运维与最佳实践**\n\n1. **Redis 高可用与扩展**\n   - **主从复制 (Replication)**：数据备份与读写分离。\n   - **哨兵 (Sentinel)**：实现高可用，自动故障转移。\n   - **集群 (Cluster)**：分布式方案，解决单机瓶颈。\n2. **性能与监控**\n   - INFO 命令：获取 Redis 实例的详细信息。\n   - SLOWLOG 命令：查找慢查询。\n   - 常见性能优化技巧。\n   - 内存管理与淘汰策略（LRU, LFU 等）。\n\n\n\n# **Redis 核心概念与基础**\n\n在正式用 Go 语言连接和操作 Redis 之前，我们必须先牢固地掌握 Redis 本身的核心概念。这部分内容将完全聚焦于 Redis 的理论知识和基础操作，我们将使用 redis-cli 这个官方命令行工具来与 Redis 服务进行交互和学习。\n\n## **1. Redis 是什么？**\n\nRedis (REmote DIctionary Server，远程字典服务) 是一个开源的、使用 C 语言编写的、高性能的 **键值 (Key-Value) 存储系统**。\n\n它通常被称作“数据结构服务器”，因为它的值（value）可以是多种复杂的数据结构，而不仅仅是简单的字符串。这些数据结构的设计使得 Redis 在处理特定业务场景时极为高效。\n\n- **核心定位**：基于内存的存储，同时支持持久化。这意味着数据主要存储在内存中，以实现极高的读写速度，但也可以将数据定期或实时地写入磁盘，以防止服务器重启后数据丢失。\n- **核心优势**：\n  - **极高的性能**：由于数据在内存中，读写速度非常快，官方数据称其读操作可达 11万次/秒，写操作可达 8.1万次/秒。\n  - **丰富的数据类型**：支持字符串、列表、哈希、集合、有序集合等多种数据结构，这让它能灵活应对各种应用场景。\n  - **原子性操作**：Redis 的所有操作都是原子性的，这意味着一个操作要么完全执行，要么完全不执行，不会出现中间状态。这得益于其单线程的事件处理模型。\n  - **多功能性**：除了作为数据库，它还可以用作**缓存系统**和**消息中间件** (Pub/Sub, Streams)。\n- **主要应用场景**：\n  - **缓存系统**：为高频访问的数据提供快速读取，减轻后端数据库（如 MySQL）的压力。\n  - **分布式会话存储**：在分布式 Web 应用中，将用户的 session 信息存储在 Redis 中，实现多台服务器间的会话共享。\n  - **排行榜**：利用有序集合 (Sorted Set) 的分数排序功能，轻松实现实时排行榜，如游戏积分榜、热门文章榜。\n  - **计数器**：利用 String 类型的 INCR 原子性自增命令，实现如文章阅读量、点赞数等高并发计数功能。\n  - **消息队列**：利用 List 的 LPUSH/RPOP 或更专业的 Streams 类型，实现简单的消息队列，用于任务解耦和异步处理。\n  - **分布式锁**：利用 SETNX (SET if Not eXists) 命令，在分布式系统中实现资源的互斥访问。\n\n------\n\n\n\n## **2. 安装与启动**\n\n学习 Redis 最好的方式就是亲手实践。\n\n- **在 Linux (Ubuntu/Debian) 上安装**：\n\n  ```\n  sudo apt update\n  sudo apt install redis-server\n  ```\n\n- **在 macOS 上安装**：\n\n  ```\n  brew install redis\n  ```\n\n- **在 Windows 上安装**：\n  官方推荐使用 WSL (Windows Subsystem for Linux)。在 WSL 环境中，可以按照 Linux 的方式进行安装。\n\n- **使用 Docker (推荐，跨平台最方便)**：\n  这是最简单、最干净的安装方式，不会污染你的主机环境。\n\n  ```\n  # 运行一个名为 my-redis 的 Redis 容器，并将容器的 6379 端口映射到主机的 6379 端口\n  docker run --name my-redis -p 6379:6379 -d redis\n  ```\n\n**启动服务与连接**\n\n安装完成后，Redis 服务通常会自动启动。你可以使用 redis-cli (Redis Command Line Interface) 来连接并与之交互。\n\n1. 打开你的终端。\n\n2. 输入 redis-cli 并回车。\n\n   ```\n   $ redis-cli\n   127.0.0.1:6379>\n   ```\n\n3. 看到这个提示符就代表你已经成功连接了。现在，来执行你的第一个 Redis 命令——PING。\n\n   ```\n   127.0.0.1:6379> PING\n   PONG\n   ```\n\n   如果服务器返回 PONG，说明连接正常，服务器正在运行。\n\n**配置文件**\n\nRedis 的所有配置都在一个名为 redis.conf 的文件中。你可以在里面修改端口、设置密码、配置持久化策略等。这个文件通常位于 /etc/redis/redis.conf (Linux) 或你的 Homebrew 安装目录下。在后面的进阶部分我们会接触到它。\n\n------\n\n\n\n## **3. Redis 五大核心数据类型**\n\n这是 Redis 的精髓所在。下面我将为你详细介绍 Redis 的五种核心数据类型：String、List、Hash、Set 和 Sorted Set。\n\n对于每种数据类型，我都会从以下几个方面进行阐述：\n\n1.  **简介**：它是什么，有什么特点。\n2.  **内部实现**：简述其底层的实现原理，这有助于理解其性能特征。\n3.  **应用场景**：在实际开发中通常用它来做什么。\n4.  **Redis CLI 示例**：通过 `redis-cli` 命令行工具进行操作演示。\n5.  **Go 语言示例**：使用流行的 `go-redis/redis` 库进行代码实现。\n\n---\n\n### Go 语言环境准备\n\n在开始 Go 语言示例之前, 请确保你已经安装了 Go 环境，并获取了 `go-redis` 库：\n\n```sh\ngo get github.com/go-redis/redis/v9\n```\n\n我们将使用下面的 Go 代码模板来连接 Redis，并为每种数据类型创建独立的演示函数。\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis/v8\"\n)\n\nvar ctx = context.Background()\n\n// 全局 Redis 客户端\nvar rdb *redis.Client\n\nfunc init() {\n\t// 初始化 Redis 客户端\n\trdb = redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\", // Redis 服务器地址\n\t\tPassword: \"\",               // 没有密码，就留空\n\t\tDB:       0,                // 使用默认的 DB\n\t})\n\n\t// 测试连接\n\t_, err := rdb.Ping(ctx).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"成功连接到 Redis!\")\n}\n\nfunc main() {\n    // 运行各个数据类型的示例\n    stringDemo()\n    listDemo()\n    hashDemo()\n    setDemo()\n    sortedSetDemo()\n}\n\n// ... 下面将实现各个 demo 函数\n```\n\n---\n\n### 1. 字符串 (String)\n\n#### 简介\n\nString 是 Redis 最基本的数据类型，也是最常用的。它可以存储任何形式的字符串，包括文本、序列化的 JSON、甚至是二进制数据（如图片），最大可以存储 512MB 的数据。\n\n#### 内部实现\n\nRedis 的 String 类型并不是 C 语言的原生字符串，而是自己实现的一种名为 **简单动态字符串 (Simple Dynamic String, SDS)** 的数据结构。SDS 相比 C 字符串有以下优点：\n\n*   **O(1) 复杂度获取字符串长度**：SDS 结构中直接记录了长度。\n*   **杜绝缓冲区溢出**：在修改字符串时，SDS 会自动检查空间并进行扩容。\n*   **二进制安全**：可以存储任意二进制数据，不会因为遇到 `\\0` 字符而截断。\n\n#### 应用场景\n\n*   **缓存**：缓存用户信息、文章内容、全页缓存等。\n*   **计数器**：利用 `INCR`、`DECR` 等原子操作实现网站访问量、点赞数、库存数量等。\n*   **分布式锁**：利用 `SETNX` (SET if Not eXists) 命令的原子性实现。\n*   **共享 Session**：在分布式系统中存储用户会话信息。\n\n#### Redis CLI 示例\n\n```sh\n# 设置一个键值对\n# SET key value\n> SET user:1:name \"Alice\"\nOK\n\n# 获取一个键的值\n# GET key\n> GET user:1:name\n\"Alice\"\n\n# 设置一个会自动过期的键 (10秒后过期)\n# SETEX key seconds value\n> SETEX session:token \"some-random-token\" 10\nOK\n\n# 对数字进行原子自增\n# INCR key\n> SET views:article:123 100\nOK\n> INCR views:article:123\n(integer) 101\n> GET views:article:123\n\"101\"\n\n# 只有当 key 不存在时才设置\n# SETNX key value\n> SETNX lock:payment:order:456 1\n(integer) 1  # 成功设置，返回 1\n> SETNX lock:payment:order:456 1\n(integer) 0  # 设置失败，因为 key 已存在，返回 0\n\n# 批量设置\n# MSET key1 value1 key2 value2 ...\n> MSET user:1:email \"alice@example.com\" user:1:city \"New York\"\nOK\n\n# 批量获取\n# MGET key1 key2 ...\n> MGET user:1:name user:1:email\n1) \"Alice\"\n2) \"alice@example.com\"\n```\n\n#### Go 语言示例\n\n```go\nfunc stringDemo() {\n\t// 打印一个分隔符，表示当前正在演示字符串相关的 Redis 操作\n\tfmt.Println(\"\\n--- String Demo ---\")\n\t\n\t// --- SET 操作：设置一个字符串类型的键值对 ---\n\t// 使用 rdb.Set() 将键 \"user:1:name\" 的值设为 \"Bob\"\n\t// 第三个参数是过期时间，0 表示永不过期\n\t// .Err() 用于获取执行结果中的错误信息\n\terr := rdb.Set(ctx, \"user:1:name\", \"Bob\", 0).Err()\n\tif err != nil {\n\t\t// 如果设置失败，抛出异常并终止程序（学习时便于发现问题）\n\t\tpanic(err)\n\t}\n\n\t// --- GET 操作：获取指定键的值 ---\n\t// 使用 rdb.Get() 获取键 \"user:1:name\" 的当前值\n\t// .Result() 返回实际的值和可能的错误\n\tname, err := rdb.Get(ctx, \"user:1:name\").Result()\n\tif err != nil {\n\t\t// 如果获取失败（例如键不存在），报错\n\t\tpanic(err)\n\t}\n\t// 成功获取后打印结果\n\tfmt.Println(\"user:1:name:\", name)\n\n\t// --- SETEX：设置带过期时间的键值对 ---\n\t// SetEX 类似于 Set，但明确指定过期时间为 10 秒\n\t// 这里模拟设置一个会话 token，10 秒后自动失效\n\terr = rdb.Set(ctx, \"session:token\", \"some-random-token-go\", 10*time.Second).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"session:token 设置成功，10秒后过期\")\n\n\t// --- INCR：原子性自增操作 ---\n\t// 先设置初始浏览量为 1000\n\trdb.Set(ctx, \"views:article:456\", 1000, 0)\n\t// 调用 Incr 对该键的值原子性地加 1\n\t// 原子性意味着在高并发下不会出现数据竞争问题\n\tnewViews, err := rdb.Incr(ctx, \"views:article:456\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// 打印自增后的最新浏览量\n\tfmt.Println(\"文章 456 的新浏览量:\", newViews)\n\n\t// --- SETNX：SET if Not eXists，常用于实现分布式锁 ---\n\t// 尝试设置键 \"lock:payment:order:789\"，只有当它不存在时才设置成功\n\t// 同时设置 10 秒过期时间，防止死锁\n\t// 返回布尔值表示是否设置成功\n\tlocked, err := rdb.SetNX(ctx, \"lock:payment:order:789\", \"process-1\", 10*time.Second).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif locked {\n\t\t// 设置成功，说明获得了“锁”\n\t\tfmt.Println(\"成功获取锁 lock:payment:order:789\")\n\t\t// 此处可以执行关键业务逻辑（如支付处理）\n\t\t// 注意：业务完成后应调用 Del 删除锁，或依赖过期自动释放\n\t\t// 示例代码中注释掉了释放锁的操作，实际使用需谨慎管理锁生命周期\n\t} else {\n\t\t// 设置失败，说明锁已被其他进程持有\n\t\tfmt.Println(\"获取锁 lock:payment:order:789 失败\")\n\t}\n\t\n\t// --- MSET：批量设置多个键值对 ---\n\t// 一次性设置用户的多个字段（名称和邮箱），减少网络往返开销\n\terr = rdb.MSet(ctx, \"user:2:name\", \"Charlie\", \"user:2:email\", \"charlie@example.com\").Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// --- MGET：批量获取多个键的值 ---\n\t// 一次性获取用户的所有相关信息，提高效率\n\tvals, err := rdb.MGet(ctx, \"user:2:name\", \"user:2:email\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// vals 是一个 []interface{} 类型的切片，包含对应键的值\n\tfmt.Println(\"批量获取 user:2 的信息:\", vals)\n}\n```\n\n---\n\n### 2. 列表 (List)\n\n#### 简介\n\nList 是一个**有序的字符串集合**，其元素可以重复。它本质上是一个双向链表，所以从列表的头部（Left）或尾部（Right）添加或移除元素非常快，时间复杂度是 O(1)。但是通过索引访问元素则比较慢，时间复杂度是 O(N)。\n\n#### 内部实现\n\n在 Redis 3.2 之前，List 底层由 `ziplist` (压缩列表) 或 `linkedlist` (双向链表) 实现。之后，统一由 **`quicklist`** 实现。`quicklist` 是一个 `ziplist` 的双向链表，它结合了两者的优点，既节省空间，又保证了插入和删除的效率。\n\n#### 应用场景\n\n*   **消息队列/任务队列**：利用 `LPUSH` 生产消息，`RPOP` 消费消息（或者反过来），可以实现简单的消息队列。`BRPOP` (阻塞式弹出) 更适合做任务队列。\n*   **文章/动态列表**：比如微博的关注人动态，最新评论列表。每当有新动态，`LPUSH` 进列表，然后用 `LTRIM` 保持列表的固定长度。\n*   **栈和队列**：`LPUSH` + `LPOP` 实现一个栈 (FILO)；`LPUSH` + `RPOP` 实现一个队列 (FIFO)。\n\n#### Redis CLI 示例\n\n```sh\n# 从左侧推入元素\n# LPUSH key element [element ...]\n> LPUSH tasks \"task1\"\n(integer) 1\n> LPUSH tasks \"task2\" \"task3\"\n(integer) 3\n# 当前列表: [\"task3\", \"task2\", \"task1\"]\n\n# 从右侧推入元素\n# RPUSH key element [element ...]\n> RPUSH tasks \"task0\"\n(integer) 4\n# 当前列表: [\"task3\", \"task2\", \"task1\", \"task0\"]\n\n# 查看列表长度\n# LLEN key\n> LLEN tasks\n(integer) 4\n\n# 查看列表范围内的元素 (0 是第一个, -1 是最后一个)\n# LRANGE key start stop\n> LRANGE tasks 0 -1\n1) \"task3\"\n2) \"task2\"\n3) \"task1\"\n4) \"task0\"\n\n# 从左侧弹出一个元素\n# LPOP key\n> LPOP tasks\n\"task3\"\n# 当前列表: [\"task2\", \"task1\", \"task0\"]\n\n# 从右侧弹出一个元素\n# RPOP key\n> RPOP tasks\n\"task0\"\n# 当前列表: [\"task2\", \"task1\"]\n\n# 阻塞式地从右侧弹出一个元素，如果列表为空，等待 10 秒\n# BRPOP key [key ...] timeout\n> BRPOP new_tasks 10\n# (如果 10 秒内没有元素推入 new_tasks，则返回 nil)\n```\n\n#### Go 语言示例\n\n```go\nfunc listDemo() {\n\t// 打印一个分隔提示，表示接下来将演示 Redis 的 List（列表）类型操作\n\t// List 在 Redis 中是一个有序的字符串元素集合，支持从两端插入和删除，非常适合用作队列或栈\n\tfmt.Println(\"\\n--- List Demo ---\")\n\n\t// 定义一个键名，用于存储任务列表\n\t// 键的命名通常采用冒号分隔的层级结构（如 \"资源类型:ID:字段\"），便于组织和理解\n\tlistKey := \"tasks:go\"\n\n\t// --- 清理旧数据：防止之前测试残留数据影响本次演示 ---\n\t// 使用 Del 删除指定键，如果该键存在则删除，不存在也不会报错\n\t// 这是为了保证每次运行 demo 时都从一个干净的状态开始\n\trdb.Del(ctx, listKey)\n\n\t// --- LPUSH：Left Push，从列表的左侧（头部）插入一个或多个元素 ---\n\t// 语法：LPush(上下文, 键名, 要插入的值...)\n\t// 插入顺序是 \"task3\", \"task2\", \"task1\"\n\t// 因为是从左边插入，所以最终顺序是：task1 -> task2 -> task3（task1 在最左边）\n\trdb.LPush(ctx, listKey, \"task3\", \"task2\", \"task1\")\n\t\n\t// 查看当前列表的长度（元素个数）\n\t// LLen 返回的是 Redis 的整数响应，.Val() 是将其转换为 Go 的 int64 类型\n\tfmt.Println(\"LPUSH 后，任务列表长度:\", rdb.LLen(ctx, listKey).Val())\n\t// 此时列表中的实际顺序为：[\"task1\", \"task2\", \"task3\"]（从左到右）\n\n\t// --- RPUSH：Right Push，从列表的右侧（尾部）插入元素 ---\n\t// 在列表末尾添加 \"task0\"\n\t// 当前列表变为：[\"task1\", \"task2\", \"task3\", \"task0\"]\n\trdb.RPush(ctx, listKey, \"task0\")\n\t\n\t// 再次查看列表长度，确认新增了一个元素\n\tfmt.Println(\"RPUSH 后，任务列表长度:\", rdb.LLen(ctx, listKey).Val())\n\n\t// --- LRANGE：获取列表中指定范围的元素 ---\n\t// 语法：LRANGE(key, start, stop)\n\t// 参数说明：\n\t//   start: 起始索引（从0开始）\n\t//   stop:  结束索引（-1 表示最后一个，-2 表示倒数第二个，以此类推）\n\t// 这里传入 (0, -1) 表示获取整个列表的所有元素\n\ttasks, err := rdb.LRange(ctx, listKey, 0, -1).Result()\n\tif err != nil {\n\t\t// 如果发生错误（比如连接问题），程序崩溃便于调试\n\t\tpanic(err)\n\t}\n\t// 打印当前列表中的所有任务\n\t// 注意顺序：[\"task1\", \"task2\", \"task3\", \"task0\"]\n\tfmt.Println(\"当前任务列表:\", tasks)\n\n\t// --- LPOP：Left Pop，从列表左侧（头部）移除并返回一个元素 ---\n\t// 这个操作会把最左边的元素取出来，并从列表中删除它\n\t// 类似于“取队列的第一个任务来处理”\n\ttask, err := rdb.LPop(ctx, listKey).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// 此时被弹出的是 \"task1\"\n\tfmt.Println(\"LPOP 弹出的任务:\", task)\n\t// 弹出后列表变为：[\"task2\", \"task3\", \"task0\"]\n\n\t// --- RPOP：Right Pop，从列表右侧（尾部）移除并返回一个元素 ---\n\t// 与 LPOP 相对，从右边取出元素\n\t// 这类似于栈的操作（后进先出）\n\ttask, err = rdb.RPop(ctx, listKey).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// 此时被弹出的是最右边的 \"task0\"\n\tfmt.Println(\"RPOP 弹出的任务:\", task)\n\t// 弹出后列表变为：[\"task2\", \"task3\"]\n\n\t// 再次使用 LRANGE 获取剩余的所有任务，验证前面的操作结果\n\ttasks, _ = rdb.LRange(ctx, listKey, 0, -1).Result()\n\t// 注意这里忽略了错误（_），仅用于展示目的，生产环境中仍需检查错误\n\tfmt.Println(\"弹出后剩余的任务列表:\", tasks)\n}\n```\n\n---\n\n### 3. 哈希 (Hash)\n\n#### 简介\n\nHash 是一个**字符串字段 (field) 和字符串值 (value) 的映射表**，它非常适合用来存储对象。你可以把它看作是 `Map<String, String>`。相比于将整个对象序列化成 JSON 字符串存入 String 类型，Hash 的优势在于可以对对象中的单个字段进行读写，节省网络开销。\n\n#### 内部实现\n\nHash 底层采用 `ziplist` (压缩列表) 或 `hashtable` (哈希表) 存储。当字段数量较少且值较短时，使用 `ziplist` 非常节省内存。当超过阈值时，会自动转换为 `hashtable` 以保证查询效率。\n\n#### 应用场景\n\n*   **存储对象**：用户信息（用户名、年龄、邮箱）、商品信息（名称、价格、库存）等。\n*   **购物车**：用一个 Hash 存储用户的购物车，`field` 是商品 ID，`value` 是商品数量。\n*   **缓存**：相比 String 缓存整个对象，Hash 可以只缓存对象的某些字段，或只更新某个变化的字段。\n\n#### Redis CLI 示例\n\n```sh\n# 设置单个字段\n# HSET key field value\n> HSET user:1 name \"Alice\"\n(integer) 1\n\n# 设置多个字段\n# HSET key field1 value1 field2 value2 ...\n> HSET user:1 age 25 email \"alice@example.com\"\n(integer) 2\n\n# 获取单个字段的值\n# HGET key field\n> HGET user:1 name\n\"Alice\"\n\n# 获取多个字段的值\n# HMGET key field1 field2 ...\n> HMGET user:1 name age city\n1) \"Alice\"\n2) \"25\"\n3) (nil) # city 字段不存在\n\n# 获取所有字段和值\n# HGETALL key\n> HGETALL user:1\n1) \"name\"\n2) \"Alice\"\n3) \"age\"\n4) \"25\"\n5) \"email\"\n6) \"alice@example.com\"\n\n# 对字段的值进行原子自增\n# HINCRBY key field increment\n> HSET product:100 stock 50\n(integer) 1\n> HINCRBY product:100 stock -5  # 卖出 5 个\n(integer) 45\n\n# 获取所有字段\n# HKEYS key\n> HKEYS user:1\n1) \"name\"\n2) \"age\"\n3) \"email\"\n```\n\n#### Go 语言示例\n\n```go\nfunc hashDemo() {\n\t// 打印一个分隔提示，表示接下来将演示 Redis 的 Hash（哈希）类型操作\n\t// Hash 类似于一个“小型对象”或“字典”，适合存储一个实体的多个字段\n\tfmt.Println(\"\\n--- Hash Demo ---\")\n\n\t// 定义一个键名，用于表示用户 3 的信息\n\t// 使用冒号分隔命名空间：user:3:go 表示“用户3的Go语言示例数据”\n\tuserKey := \"user:3:go\"\n\n\t// --- 清理旧数据：确保每次运行 demo 都从干净状态开始 ---\n\t// 删除之前可能存在的同名键，避免影响本次演示结果\n\t// 即使键不存在，Del 也不会报错\n\trdb.Del(ctx, userKey)\n\n\t// --- HSET：Hash Set，设置一个或多个字段-值对到指定的 hash 键中 ---\n\t// 语法：HSet(上下文, 键名, 字段1, 值1, 字段2, 值2, ...)\n\t// 这里给 user:3:go 设置了三个字段：name, age, email\n\terr := rdb.HSet(ctx, userKey, \"name\", \"David\", \"age\", 30, \"email\", \"david@example.com\").Err()\n\tif err != nil {\n\t\t// 如果设置失败（比如连接中断），直接 panic 中断程序以便调试\n\t\tpanic(err)\n\t}\n\t// 提示信息：说明用户信息已成功写入 Redis\n\tfmt.Println(\"HSET 设置用户信息\")\n\t// 此时 Redis 中存储的数据结构类似于：\n\t// user:3:go = {\n\t//   \"name\":  \"David\",\n\t//   \"age\":   \"30\",\n\t//   \"email\": \"david@example.com\"\n\t// }\n\n\t// --- HGET：Hash Get，获取 hash 中某个字段的值 ---\n\t// 语法：HGet(上下文, 键名, 字段名)\n\t// 这里我们只想获取用户的姓名\n\tname, err := rdb.HGet(ctx, userKey, \"name\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// 成功获取后打印结果\n\tfmt.Println(\"获取用户名:\", name) // 输出：David\n\n\t// --- HMGET：Hash Multiple Get，批量获取多个字段的值 ---\n\t// 语法：HMGet(上下文, 键名, 字段1, 字段2, ...)\n\t// 可以一次请求多个字段，提高效率\n\t// 注意：如果某个字段不存在（如 \"city\"），其返回值为 nil（在 Go 中表现为 interface{} 类型的 nil）\n\tfields, err := rdb.HMGet(ctx, userKey, \"name\", \"age\", \"city\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// 打印结果：[David 30 <nil>]，其中 city 不存在所以是 nil\n\tfmt.Println(\"批量获取用户信息:\", fields)\n\n\t// --- HGETALL：获取 hash 中所有的字段和值 ---\n\t// 语法：HGetAll(上下文, 键名)\n\t// 返回值是一个 map[string]string，包含所有字段及其对应的值\n\tuser, err := rdb.HGetAll(ctx, userKey).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// 打印整个用户信息 map\n\t// 输出示例：map[age:30 email:david@example.com name:David]\n\tfmt.Println(\"获取所有用户信息 (map):\", user)\n\n\t// --- HINCRBY：对 hash 中某个字段进行整数增减操作（原子性）---\n\t// 常用于库存、积分、浏览量等需要频繁更新的数值型字段\n\t// 语法：HIncrBy(上下文, 键名, 字段名, 步长)\n\t// 这里我们模拟减少商品库存：商品 101 的 stock 字段减去 2\n\t// 如果键或字段不存在，Redis 会先创建并初始化为 0，再进行运算\n\tnewStock, err := rdb.HIncrBy(ctx, \"product:101:go\", \"stock\", -2).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// 假设原库存是 100，则 newStock = 98\n\t// 如果之前没有设置过，Redis 会自动设为 0，然后 0 - 2 = -2\n\tfmt.Println(\"商品 101 减库存后剩余:\", newStock)\n}\n```\n\n---\n\n### 4. 集合 (Set)\n\n#### 简介\n\nSet 是一个**无序且唯一的字符串集合**。它的主要特点是元素唯一不重复，并且提供了高效的集合运算，如交集、并集、差集等。\n\n#### 内部实现\n\nSet 底层采用 `intset` (整数集合) 或 `hashtable` (哈希表)。当所有元素都是整数且数量不多时，使用 `intset` 存储，非常节省内存。否则，转换为 `hashtable`。\n\n#### 应用场景\n\n*   **标签系统**：一篇文章可以有多个标签，用 Set 存储一篇文章的所有标签。`SISMEMBER` 可以快速判断文章是否有某个标签。\n*   **共同好友/关注**：利用 `SINTER` (交集) 计算两个用户的共同好友。\n*   **抽奖系统**：用 `SADD` 将所有参与用户ID加入集合，用 `SRANDMEMBER` 或 `SPOP` 随机抽取中奖用户。\n*   **点赞/收藏**：用 Set 存储对某篇文章点赞的所有用户 ID，可以快速判断某用户是否已点赞。\n*   **独立 IP 统计**：用 Set 存储访问某页面的所有 IP 地址，集合的大小就是独立 IP 数。\n\n#### Redis CLI 示例\n\n```sh\n# 添加一个或多个成员\n# SADD key member [member ...]\n> SADD tags:article:1 \"redis\" \"database\" \"nosql\"\n(integer) 3\n\n# 查看集合的所有成员\n# SMEMBERS key\n> SMEMBERS tags:article:1\n1) \"redis\"\n2) \"nosql\"\n3) \"database\"\n\n# 判断成员是否存在于集合中\n# SISMEMBER key member\n> SISMEMBER tags:article:1 \"redis\"\n(integer) 1\n> SISMEMBER tags:article:1 \"mysql\"\n(integer) 0\n\n# 获取集合的成员数量\n# SCARD key\n> SCARD tags:article:1\n(integer) 3\n\n# 集合运算\n> SADD user:1:friends \"A\" \"B\" \"C\" \"D\"\n(integer) 4\n> SADD user:2:friends \"C\" \"D\" \"E\" \"F\"\n(integer) 4\n\n# 交集 (共同好友)\n# SINTER key [key ...]\n> SINTER user:1:friends user:2:friends\n1) \"C\"\n2) \"D\"\n\n# 并集 (所有好友)\n# SUNION key [key ...]\n> SUNION user:1:friends user:2:friends\n1) \"A\"\n2) \"B\"\n3) \"C\"\n4) \"D\"\n5) \"E\"\n6) \"F\"\n\n# 差集 (user1 有但 user2 没有的好友)\n# SDIFF key [key ...]\n> SDIFF user:1:friends user:2:friends\n1) \"A\"\n2) \"B\"\n```\n\n#### Go 语言示例\n\n```go\nfunc setDemo() {\n\t// 打印一个分隔提示，表示接下来将演示 Redis 的 Set（集合）类型操作\n\t// Set 是 Redis 中一种无序、不重复的字符串元素集合，非常适合用于“关系”类数据的存储\n\tfmt.Println(\"\\n--- Set Demo ---\")\n\n\t// 定义两个键名，分别代表用户1和用户2的好友列表\n\t// 使用清晰的命名规则：user:<ID>:friends:<tag>，便于理解和维护\n\tuser1FriendsKey := \"user:1:friends:go\"\n\tuser2FriendsKey := \"user:2:friends:go\"\n\n\t// --- 清理旧数据：确保每次运行 demo 都在一个干净的环境中 ---\n\t// 使用 Del 删除之前可能存在的数据，避免历史数据干扰当前演示\n\t// 可以同时删除多个键\n\trdb.Del(ctx, user1FriendsKey, user2FriendsKey)\n\n\t// --- SADD：Set Add，向集合中添加一个或多个成员 ---\n\t// 语法：SAdd(上下文, 键名, 成员1, 成员2, ...)\n\t// 特点：\n\t//   - 集合中**元素是唯一的**，重复添加同一个值只会保存一份\n\t//   - 元素**无序**，不保证插入顺序\n\t//  为用户1添加三位朋友：Alice、Bob、Charlie\n\trdb.SAdd(ctx, user1FriendsKey, \"Alice\", \"Bob\", \"Charlie\")\n\t// 为用户2添加三位朋友：Charlie、David、Eve\n\trdb.SAdd(ctx, user2FriendsKey, \"Charlie\", \"David\", \"Eve\")\n\t// 注意：Charlie 同时出现在两个用户的集合中\n\n\t// --- SMEMBERS：获取集合中的所有成员 ---\n\t// 语法：SMembers(上下文, 键名)\n\t// 返回集合中所有的元素（无序）\n\tfriends, err := rdb.SMembers(ctx, user1FriendsKey).Result()\n\tif err != nil {\n\t\t// 如果出错（如连接失败），直接 panic 终止程序以便调试\n\t\tpanic(err)\n\t}\n\t// 打印用户1的所有朋友\n\t// 输出可能是：[Alice Bob Charlie] 或任意顺序，因为 Set 是无序的\n\tfmt.Println(\"User 1 的朋友:\", friends)\n\n\t// --- SISMEMBER：判断某个元素是否是集合的成员 ---\n\t// 语法：SIsMember(上下文, 键名, 元素)\n\t// 返回布尔值：true 表示存在，false 表示不存在\n\tisFriend, err := rdb.SIsMember(ctx, user1FriendsKey, \"Bob\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// 判断 Bob 是否在用户1的朋友列表中\n\tfmt.Println(\"Bob 是 User 1 的朋友吗?\", isFriend) // 应该输出 true\n\n\t// --- SINTER：Set Intersection，求多个集合的交集 ---\n\t// 语法：SInter(上下文, 键1, 键2, ...)\n\t// 返回同时存在于所有指定集合中的元素\n\t// 这里用于找出“用户1和用户2共同的朋友”\n\tcommonFriends, err := rdb.SInter(ctx, user1FriendsKey, user2FriendsKey).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// 因为只有 \"Charlie\" 同时出现在两个集合中，所以交集就是 [\"Charlie\"]\n\tfmt.Println(\"共同的朋友:\", commonFriends)\n\n\t// --- SUNION：Set Union，求多个集合的并集 ---\n\t// 语法：SUnion(上下文, 键1, 键2, ...)\n\t// 返回所有集合中的**去重合并结果**\n\t// 即：把两个集合的所有元素放在一起，并自动去除重复项\n\tallFriends, err := rdb.SUnion(ctx, user1FriendsKey, user2FriendsKey).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// 结果包含：Alice, Bob, Charlie, David, Eve（共5人，Charlie 不重复）\n\tfmt.Println(\"所有的朋友:\", allFriends)\n}\n```\n\n---\n\n### 5. 有序集合 (Sorted Set / ZSet)\n\n#### 简介\n\nSorted Set 和 Set 类似，也是一个**不允许重复**的字符串集合。但不同的是，每个成员都会关联一个 `double` 类型的**分数 (score)**。Redis 正是根据这个分数来为集合中的成员进行排序。成员是唯一的，但分数可以重复。\n\n#### 内部实现\n\nSorted Set 底层由 `ziplist` 或 `skiplist` (跳跃表) + `hashtable` 实现。\n\n*   当元素数量少、成员值短时，使用 `ziplist` 节省内存。\n*   否则，使用 `skiplist` 和 `hashtable` 的组合：\n    *   **Skiplist**：保证了元素的有序性，并能以 O(logN) 的时间复杂度进行查找和范围查询。\n    *   **Hashtable**：存储成员到分数的映射，可以 O(1) 的时间复杂度获取指定成员的分数。\n        这种组合设计让 Sorted Set 在保持排序的同时，也拥有高效的单点查询能力。\n\n#### 应用场景\n\n*   **排行榜**：游戏积分榜、文章热度榜、销售额排行榜等。`score` 就是积分/热度值。\n*   **带权重的任务队列**：`score` 可以作为任务的优先级或执行时间，分数越小（或越大）的任务优先被处理。\n*   **延时队列**：用 `score` 存储任务的执行时间戳，然后轮询第一个元素，看时间戳是否已到。\n*   **范围查找**：比如查找积分在 1000 到 2000 之间的所有玩家。\n\n#### Redis CLI 示例\n\n```sh\n# 添加一个或多个成员及其分数\n# ZADD key score member [score member ...]\n> ZADD leaderboard 100 \"player1\" 250 \"player2\" 80 \"player3\" 300 \"player4\"\n(integer) 4\n\n# 增加某个成员的分数\n# ZINCRBY key increment member\n> ZINCRBY leaderboard 50 \"player1\"\n\"150\" # 返回 player1 的新分数\n\n# 按分数从低到高获取排名\n# ZRANGE key start stop [WITHSCORES]\n> ZRANGE leaderboard 0 -1 WITHSCORES\n1) \"player3\"\n2) \"80\"\n3) \"player1\"\n4) \"150\"\n5) \"player2\"\n6) \"250\"\n7) \"player4\"\n8) \"300\"\n\n# 按分数从高到低获取排名\n# ZREVRANGE key start stop [WITHSCORES]\n> ZREVRANGE leaderboard 0 2 WITHSCORES # 获取前三名\n1) \"player4\"\n2) \"300\"\n3) \"player2\"\n4) \"250\"\n5) \"player1\"\n6) \"150\"\n\n# 获取指定成员的分数\n# ZSCORE key member\n> ZSCORE leaderboard \"player2\"\n\"250\"\n\n# 获取指定成员的排名 (从低到高, 排名从 0 开始)\n# ZRANK key member\n> ZRANK leaderboard \"player2\"\n(integer) 2\n```\n\n#### Go 语言示例\n\n```go\nfunc sortedSetDemo() {\n\t// 打印一个分隔提示，表示接下来将演示 Redis 的 Sorted Set（有序集合）类型操作\n\t// Sorted Set 是 Redis 中最强大的数据结构之一，特别适合用于“排行榜”类场景\n\tfmt.Println(\"\\n--- Sorted Set Demo ---\")\n\n\t// 定义一个键名，用于存储排行榜数据\n\t// leaderboard:go 表示“Go 示例中的排行榜”\n\tleaderboardKey := \"leaderboard:go\"\n\n\t// --- 清理旧数据：确保每次运行 demo 都从干净状态开始 ---\n\t// 删除之前可能存在的同名键，避免历史数据干扰本次演示\n\trdb.Del(ctx, leaderboardKey)\n\n\t// --- ZADD：Sorted Set Add，向有序集合中添加成员及其分数 ---\n\t// 语法：ZAdd(上下文, 键名, &redis.Z{Score: 分数, Member: 成员}, ...)\n\t// 特点：\n\t//   - 每个成员（Member）都有一个对应的分数（Score）\n\t//   - 成员唯一（不能重复），但分数可以相同\n\t//   - 所有成员会根据分数**自动排序**（从小到大）\n\t// 这里添加三位玩家及其初始分数：\n\t//   player1: 100 分\n\t//   player2: 250 分\n\t//   player3: 80 分\n\trdb.ZAdd(ctx, leaderboardKey,\n\t\t&redis.Z{Score: 100, Member: \"player1\"},\n\t\t&redis.Z{Score: 250, Member: \"player2\"},\n\t\t&redis.Z{Score: 80, Member: \"player3\"},\n\t)\n\t// 提示信息：说明玩家已加入排行榜\n\tfmt.Println(\"添加玩家到排行榜\")\n\t// 此时按分数升序排列为：player3(80) → player1(100) → player2(250)\n}\n\n\t// --- ZINCRBY：对某个成员的分数进行增减（原子操作）---\n\t// 语法：ZIncrBy(上下文, 键名, 增量, 成员名)\n\t// 类似于 Hash 中的 HIncrBy，但用于 Sorted Set\n\t// 这里给 player1 加 50 分\n\tnewScore, err := rdb.ZIncrBy(ctx, leaderboardKey, 50, \"player1\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// 原来是 100 分，加 50 后变成 150 分\n\tfmt.Println(\"player1 增加 50 分后，新分数为:\", newScore)\n\t// 更新后排名变为：player3(80) → player1(150) → player2(250)\n\n\t// --- ZREVRANGE WITHSCORES：从高到低获取指定范围的成员（带分数）---\n\t// 语法：ZRevRangeWithScores(上下文, 键名, 开始索引, 结束索引)\n\t// 注意：\n\t//   - ZRevRange 是“倒序”（从高分到低分）\n\t//   - WithScores 表示同时返回分数\n\t//   - 索引从 0 开始\n\t// 这里获取 Top 3 玩家（最高分的前3名）\n\ttopPlayers, err := rdb.ZRevRangeWithScores(ctx, leaderboardKey, 0, 2).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// 打印排行榜前3名\n\tfmt.Println(\"排行榜 Top 3:\")\n\tfor _, player := range topPlayers {\n\t\t// player.Member 是玩家名称（string 类型）\n\t\t// player.Score 是分数（float64 类型），使用 %.0f 不显示小数\n\t\tfmt.Printf(\"  - 玩家: %s, 分数: %.0f\\n\", player.Member, player.Score)\n\t}\n\t// 输出示例：\n\t//   - 玩家: player2, 分数: 250\n\t//   - 玩家: player1, 分数: 150\n\t//   - 玩家: player3, 分数: 80\n\n\t// --- ZRANK：获取成员在有序集合中的排名（从小到大）---\n\t// 语法：ZRank(上下文, 键名, 成员名)\n\t// 返回值是从 0 开始的索引：\n\t//   分数最低的排第 0 名，第二低的排第 1 名，依此类推\n\t// 所以 ZRank 是“升序排名”\n\trank, err := rdb.ZRank(ctx, leaderboardKey, \"player2\").Result()\n\tif err != nil {\n\t\t// 如果成员不存在，Redis 返回 redis.Nil 错误\n\t\tif err == redis.Nil {\n\t\t\tfmt.Println(\"player2 不在排行榜中\")\n\t\t} else {\n\t\t\t// 其他错误（如网络问题）则 panic\n\t\t\tpanic(err)\n\t\t}\n\t} else {\n\t\t// 成功获取排名\n\t\t// 当前 player2 分数最高，所以 ZRank 返回 2（他是第3个，索引从0开始）\n\t\tfmt.Printf(\"player2 的排名 (从0开始) 是: %d\\n\", rank)\n\t}\n\t// 注意：如果想从 1 开始显示排名，可以写成 rank + 1\n}\n```\n\n### 总结\n\n以上就是 Redis 五种核心数据类型的详细介绍和示例。理解每种数据类型的特点和适用场景，是高效使用 Redis 的关键。在实际应用中，往往需要组合使用这些数据类型来解决复杂问题。\n\n\n\n\n\n# **Go 与 Redis 集成**\n\n## **1. 准备 Go 环境**\n\n在开始之前，你需要选择一个 Go 语言的 Redis 客户端库。目前社区中最主流的有以下两个：\n\n1.  **`go-redis/redis`**: 这是一个功能非常全面、性能优秀且API设计现代化的库。它内置了连接池管理，并与 Go 的 `context` 机制深度集成，是目前新项目的首选。**（本笔记将使用此库进行教学）**\n2.  `gomodule/redigo`: 这是一个更老牌、更轻量级的库，API 风格更接近原始的 Redis 命令。虽然依然稳定可靠，但对于新手而言，`go-redis` 的封装更友好。\n\n**安装 `go-redis` 库**\n\n首先，确保你的 Go 环境已经搭建好。然后，在你的项目目录下，打开终端并执行以下命令来安装 `go-redis` 的最新版本（v9）：\n\n```bash\ngo get github.com/go-redis/redis/v9\n```\n\n## **2. 连接 Redis**\n\n使用 `go-redis` 连接 Redis 非常简单。你只需要创建一个 `redis.Client` 实例，并提供 Redis 服务器的连接信息即可。\n\n*   **连接选项 (`redis.Options`)**:\n    *   `Addr`: Redis 服务器的地址，格式为 `\"host:port\"`。例如 `\"localhost:6379\"`。\n    *   `Password`: Redis 的密码，如果没有设置则留空。\n    *   `DB`: 要连接的数据库编号，默认为 `0`。Redis 支持 0-15 共 16 个数据库。\n\n*   **连接池 (Connection Pool)**:\n    你不需要手动管理连接池！`go-redis` 客户端在内部已经实现并维护了一个高效的连接池。每次你执行命令时，它会自动从池中获取一个连接，使用完毕后会放回池中，这大大提升了高并发场景下的性能。\n\n**示例代码：连接并测试**\n\n让我们创建一个简单的 Go 程序来连接本地 Redis 服务并测试连通性。\n\n`main.go`\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/go-redis/redis/v9\"\n)\n\n// 定义一个全局的 redis.Client 变量\nvar rdb *redis.Client\n\n// initClient 函数用于初始化 Redis 连接\nfunc initClient() (err error) {\n\t// 创建一个新的 Redis 客户端\n\trdb = redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\", // Redis 服务器地址\n\t\tPassword: \"\",               // Redis 密码，没有则留空\n\t\tDB:       0,                // 使用默认的 DB 0\n\t\tPoolSize: 10,               // 连接池大小\n\t})\n\n\t// context.Background() 返回一个空的 Context，它永远不会被取消，没有值，也没有截止日期。\n\t// 它通常由 main 函数、初始化和测试使用，并作为传入请求的顶级 Context。\n\tctx := context.Background()\n\n\t// 使用 Ping 命令测试连接\n\t_, err = rdb.Ping(ctx).Result()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc main() {\n\terr := initClient()\n\tif err != nil {\n\t\tfmt.Printf(\"连接 Redis 失败, error: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"成功连接到 Redis！\")\n\n\t// 在这里可以开始执行 Redis 操作...\n}\n```\n\n**代码解析**：\n\n1.  我们导入了 `context` 和 `github.com/go-redis/redis/v9` 包。\n2.  `redis.NewClient` 接收一个 `redis.Options` 结构体指针，用于配置连接参数。\n3.  我们使用 `rdb.Ping(ctx).Result()` 来发送 `PING` 命令。`go-redis` 的所有命令都遵循 `Command(ctx, args...).Result()` 的模式。`.Result()` 会等待命令执行完成，并返回最终结果和错误。\n\n---\n\n## **3. 在 Go 中操作 Redis 核心数据类型**\n\n现在，我们将把第一部分用 `redis-cli` 执行的命令，全部用 Go 代码重新实现一遍。\n\n**重要提示**：`go-redis` 的每一个操作都需要一个 `context.Context` 参数。在接下来的示例中，我们为了简化，将一直使用 `context.Background()`。在后面的小节会专门讲解 `context` 的重要性。\n\n### **3.1 String 操作**\n\n```go\nfunc stringOperations(ctx context.Context) {\n\tfmt.Println(\"--- String 操作 ---\")\n\t// Set(ctx, key, value, expiration)\n\t// expiration 参数为 0 表示没有过期时间\n\terr := rdb.Set(ctx, \"user:1:name\", \"Chris\", 0).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Get(ctx, key)\n\tval, err := rdb.Get(ctx, \"user:1:name\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"获取 user:1:name:\", val)\n\n\t// 当 Get 的 key 不存在时，会返回 redis.Nil 错误\n\tval2, err := rdb.Get(ctx, \"non_existent_key\").Result()\n\tif err == redis.Nil {\n\t\tfmt.Println(\"non_existent_key 不存在\")\n\t} else if err != nil {\n\t\tpanic(err)\n\t} else {\n\t\tfmt.Println(\"non_existent_key:\", val2)\n\t}\n    \n    // SetEX 设置一个带过期时间的键\n    err = rdb.Set(ctx, \"session_token\", \"some-random-string\", 10 * time.Second).Err()\n    if err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// 在 main 函数中调用\n// stringOperations(context.Background())\n```\n\n**要点**：错误处理。当一个键不存在时，`Get` 操作会返回一个特殊的错误 `redis.Nil`。你需要显式地检查这个错误，而不是把它当作一个普通错误来处理。\n\n### **3.2 List 操作**\n\n```go\nfunc listOperations(ctx context.Context) {\n\tfmt.Println(\"\\n--- List 操作 ---\")\n\t// 先清理一下，防止重复运行导致列表过长\n\trdb.Del(ctx, \"tasks\")\n\n\t// LPUSH 从左侧推入\n\trdb.LPush(ctx, \"tasks\", \"Task A\", \"Task B\")\n\t// RPUSH 从右侧推入\n\trdb.RPush(ctx, \"tasks\", \"Task C\")\n\n\t// LRange 获取列表所有元素\n\ttasks, err := rdb.LRange(ctx, \"tasks\", 0, -1).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"当前任务列表:\", tasks) // 输出: [Task B, Task A, Task C]\n\n\t// LPop 从左侧弹出一个元素\n\ttask, err := rdb.LPop(ctx, \"tasks\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"处理任务:\", task) // 输出: Task B\n}\n\n// 在 main 函数中调用\n// listOperations(context.Background())\n```\n\n### **3.3 Hash 操作**\n\n```go\nfunc hashOperations(ctx context.Context) {\n\tfmt.Println(\"\\n--- Hash 操作 ---\")\n\tuserKey := \"user:2\"\n\trdb.Del(ctx, userKey) // 清理\n\n\t// HSet 设置哈希字段，可以使用 map[string]interface{}\n\tfields := map[string]interface{}{\"username\": \"dave\", \"email\": \"dave@example.com\"}\n\terr := rdb.HSet(ctx, userKey, fields).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\trdb.HSet(ctx, userKey, \"age\", 35)\n\n\t// HGetAll 获取所有字段和值\n\tallFields, err := rdb.HGetAll(ctx, userKey).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"用户 User:2 的信息:\", allFields) // 输出 map[age:35 email:dave@example.com username:dave]\n}\n\n// 在 main 函数中调用\n// hashOperations(context.Background())\n```\n\n### **3.4 Set 操作**\n\n```go\nfunc setOperations(ctx context.Context) {\n\tfmt.Println(\"\\n--- Set 操作 ---\")\n\tpost1Tags := \"tags:post:1\"\n\tpost2Tags := \"tags:post:2\"\n\trdb.Del(ctx, post1Tags, post2Tags) // 清理\n\n\t// SAdd 添加集合成员\n\trdb.SAdd(ctx, post1Tags, \"redis\", \"go\", \"database\")\n\trdb.SAdd(ctx, post2Tags, \"go\", \"docker\")\n\n\t// SMembers 获取所有成员\n\tmembers, err := rdb.SMembers(ctx, post1Tags).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"文章1的标签:\", members)\n\n\t// SInter 计算交集\n\tcommonTags, err := rdb.SInter(ctx, post1Tags, post2Tags).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"文章1和文章2的共同标签:\", commonTags) // 输出: [go]\n}\n\n// 在 main 函数中调用\n// setOperations(context.Background())\n```\n\n### **3.5 Sorted Set (ZSET) 操作**\n\n```go\nfunc zsetOperations(ctx context.Context) {\n\tfmt.Println(\"\\n--- Sorted Set 操作 ---\")\n\tleaderboardKey := \"leaderboard\"\n\trdb.Del(ctx, leaderboardKey) // 清理\n\n\t// ZAdd 添加成员和分数，需要使用 redis.Z 结构体\n\tmembers := []redis.Z{\n\t\t{Score: 2500, Member: \"Alice\"},\n\t\t{Score: 3100, Member: \"Bob\"},\n\t\t{Score: 1800, Member: \"Charlie\"},\n\t}\n\trdb.ZAdd(ctx, leaderboardKey, members...)\n\n\t// ZRevRange 按分数从高到低获取 Top 2\n\ttopPlayers, err := rdb.ZRevRangeWithScores(ctx, leaderboardKey, 0, 1).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"排行榜 Top 2:\")\n\tfor _, player := range topPlayers {\n\t\tfmt.Printf(\"  玩家: %s, 分数: %.0f\\n\", player.Member, player.Score)\n\t}\n}\n\n// 在 main 函数中调用\n// zsetOperations(context.Background())\n```\n\n---\n\n## **4. 上下文管理 (`context.Context`)**\n\n你可能已经注意到，`go-redis/v9` 的每个命令都需要一个 `context.Context` 作为第一个参数。这不是一个繁琐的设计，而是 Go 语言中处理请求、超时和取消操作的最佳实践。\n\n*   **为什么需要 `context`？**\n    在一个网络应用中，一个操作（比如一次 Redis 查询）不应该无限期地等待下去。如果 Redis 服务器因为高负载而响应缓慢，或者网络出现问题，我们不希望整个应用程序被这个慢查询拖垮。`context` 提供了一种机制，可以为操作设定一个“截止日期”（Timeout）或一个“取消信号”。\n\n*   **使用 `context` 控制超时**\n    假设我们希望一个 Redis 查询最多只能执行 50 毫秒，否则就立即放弃并返回一个超时错误。我们可以这样做：\n\n    ```go\n    func contextExample() {\n        fmt.Println(\"\\n--- Context 超时示例 ---\")\n        // 创建一个有 50 毫秒超时的 context\n        ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n        // defer cancel() 是一个好习惯，用于在函数退出时释放 context 相关的资源\n        defer cancel()\n    \n        // 假设这是一个执行很慢的命令，例如在一个巨大的集合中查找\n        // 为了模拟，我们这里还是用 Get，但关键是看超时的效果\n        _, err := rdb.Get(ctx, \"some_key\").Result()\n    \n        // 检查返回的错误是否是 context 的超时错误\n        if err != nil {\n            // 在 Go 1.20+ 中，可以使用 errors.Is\n            if errors.Is(err, context.DeadlineExceeded) {\n                fmt.Println(\"Redis 操作超时了！\")\n            } else {\n                // 其他错误，比如 redis.Nil\n                fmt.Printf(\"发生错误: %v\\n\", err)\n            }\n        }\n    }\n    ```\n\n**总结**：`context` 是构建健壮、高可用的 Go 应用程序的基石。在每次调用 Redis 命令时，都应该传递一个合适的 `context`。对于一个 Web 请求，你应该把请求自带的 `context` (`r.Context()`) 一路传递下来；对于后台任务，可以创建一个带超时的 `context`\n\n\n\n\n\n好的，我们进入第三部分。这部分内容将带你了解 Redis 更强大、更专业的特性，并学习如何在 Go 中利用这些特性来构建更复杂的应用。\n\n---\n\n# **Redis 进阶主题与 Go 实战**\n\n## **1. 事务 (Transactions)**\n\n在很多场景下，我们需要一次性执行多个命令，并希望这个操作序列是**原子性**的，即要么全部成功，要么全部失败。\n\n*   **Redis 事务命令**:\n    *   `MULTI`: 开启一个事务块，此后的命令都会进入一个队列，而不会立即执行。\n    *   `EXEC`: 原子性地执行队列中的所有命令。\n    *   `DISCARD`: 清空事务队列，放弃事务。\n    *   `WATCH key [key ...]`: 监视一个或多个 key。如果在 `MULTI` 执行之前，任何被 `WATCH` 的 key 被其他客户端修改了，那么整个事务将被取消，`EXEC` 会返回一个空回复。这提供了一种**乐观锁 (Optimistic Locking)** 的机制。\n\n*   **`go-redis` 中的实现：`Pipeline` 和 `TxPipeline`**\n    `go-redis` 提供了两种方式来批量执行命令：\n    1.  **`Pipeline`**: 将多个命令打包一次性发送给 Redis，用于减少网络往返时延 (RTT)。**它不保证原子性**，只是一个性能优化手段。\n    2.  **`TxPipeline` (Transactional Pipeline)**: 这才是真正的事务实现。它会自动在命令序列前后加上 `MULTI` 和 `EXEC`，从而保证原子性。\n\n**Go 实战：使用 `WATCH` 和 `TxPipeline` 实现乐观锁**\n\n一个经典的场景：在高并发下更新一个计数器。我们希望读取当前值，加 1，然后写回。这个过程必须是原子的，否则可能导致数据丢失。\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/go-redis/redis/v9\"\n\t\"time\"\n)\n\n// ... (省略 initClient 和 rdb 变量定义) ...\n\n// optimisticIncrement 函数安全地增加一个 key 的值\nfunc optimisticIncrement(ctx context.Context, key string) error {\n\t// TxFn 是一个事务函数，go-redis 会在 WATCH 和 MULTI/EXEC 块中执行它\n\ttxf := func(tx *redis.Tx) error {\n\t\t// 1. 在事务中获取当前值\n\t\tcurrentVal, err := tx.Get(ctx, key).Int()\n\t\tif err != nil && err != redis.Nil {\n\t\t\treturn err // 如果是 redis.Nil 以外的错误，则返回\n\t\t}\n\n\t\t// 2. 计算新值\n\t\tnewValue := currentVal + 1\n\n\t\t// 3. 使用 tx.Pipelined 执行 SET 命令\n\t\t// Pipelined 在事务中是必需的，它会将命令放入队列\n\t\t_, err = tx.Pipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\tpipe.Set(ctx, key, newValue, 0)\n\t\t\treturn nil\n\t\t})\n\t\treturn err\n\t}\n\n\t// rdb.Watch 会自动处理重试逻辑\n\t// 如果在 txf 执行期间，被 WATCH 的 key (\"counter\") 发生变化，\n\t// 整个 txf 函数会从头开始重试，直到成功为止。\n\terr := rdb.Watch(ctx, txf, key)\n\treturn err\n}\n\nfunc transactionExample() {\n\tfmt.Println(\"\\n--- 事务与乐观锁示例 ---\")\n\tctx := context.Background()\n\tcounterKey := \"counter\"\n\trdb.Set(ctx, counterKey, \"0\", 0) // 初始化计数器\n\n\terr := optimisticIncrement(ctx, counterKey)\n\tif err != nil {\n\t\tfmt.Printf(\"增加计数器失败: %v\\n\", err)\n\t} else {\n\t\tfinalValue, _ := rdb.Get(ctx, counterKey).Result()\n\t\tfmt.Printf(\"成功增加计数器，当前值为: %s\\n\", finalValue)\n\t}\n}\n```\n\n**代码解析**:\n\n1.  `rdb.Watch` 是 `go-redis` 对乐观锁事务的高级封装。它接收一个要监视的 `key` 和一个事务函数 `txf`。\n2.  `go-redis` 会自动执行 `WATCH key` 命令。\n3.  然后它会执行你传入的 `txf` 函数。在 `txf` 内部，你通过 `tx` 对象（一个 `redis.Tx` 实例）来读取和写入数据。\n4.  `tx.Pipelined` 用于将写命令（如 `SET`）放入事务队列。\n5.  `go-redis` 会自动执行 `EXEC`。如果因为 `key` 被其他客户端修改而导致 `EXEC` 失败，`rdb.Watch` 会自动**重试**整个 `txf` 函数，直到事务成功执行。\n\n---\n\n## **2. 发布/订阅 (Pub/Sub)**\n\nPub/Sub 是一种消息通信模式，发送者（发布者, Publisher）将消息发送到特定的“频道 (Channel)”，而不关心谁会接收。接收者（订阅者, Subscriber）可以订阅一个或多个频道，并接收发送到这些频道的消息。\n\n*   **用途**: 实时聊天系统、消息通知、服务间解耦。\n\n**Go 实战：实现一个简单的实时通知系统**\n\n我们将创建两个 Go 程序：一个作为订阅者，持续监听；另一个作为发布者，发送消息。\n\n**订阅者 (`subscriber.go`)**\n\n```go\nfunc subscriber() {\n\tfmt.Println(\"订阅者已启动，正在监听 'my-channel'...\")\n\tctx := context.Background()\n\t\n\t// Subscribe 返回一个 *PubSub 对象\n\tpubsub := rdb.Subscribe(ctx, \"my-channel\")\n\t\n\t// defer pubsub.Close() 是一个好习惯\n\tdefer pubsub.Close()\n\n\t// Receive 从频道接收消息。这是一个阻塞操作。\n\t// 通常在一个新的 goroutine 中运行。\n\tfor msg := range pubsub.Channel() {\n\t\tfmt.Printf(\"从频道 [%s] 收到消息: %s\\n\", msg.Channel, msg.Payload)\n\t}\n}\n```\n\n**发布者 (`publisher.go`)**\n\n```go\nfunc publisher() {\n\tctx := context.Background()\n\t\n\t// 等待几秒钟，确保订阅者已经准备好\n\ttime.Sleep(2 * time.Second)\n\n\tfmt.Println(\"发布者开始发送消息...\")\n\terr := rdb.Publish(ctx, \"my-channel\", \"Hello, this is a message from publisher!\").Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\ttime.Sleep(1 * time.Second)\n\n\terr = rdb.Publish(ctx, \"my-channel\", \"This is the second message.\").Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n```\n\n**如何运行**：\n\n1.  在一个终端中运行订阅者程序。\n2.  在另一个终端中运行发布者程序。\n3.  你将看到订阅者的终端打印出从发布者收到的消息。\n\n---\n\n## **3. 持久化 (Persistence)**\n\n持久化是指将内存中的数据写入到磁盘，防止因进程退出或服务器宕机导致数据丢失。Redis 提供了两种主要的持久化方式：\n\n1.  **RDB (Redis Database) 快照**\n    *   **工作原理**: 在指定的时间间隔内，将内存中的数据集快照写入一个名为 `dump.rdb` 的二进制文件中。你可以配置如 `save 900 1` (900秒内有1次写入)、`save 300 10` 等规则。\n    *   **优点**:\n        *   生成的文件是紧凑的二进制文件，非常适合备份。\n        *   恢复大数据集时，速度比 AOF 快。\n    *   **缺点**:\n        *   由于是间隔性保存，如果 Redis 在两次快照之间宕机，会丢失最后一次快照后的所有数据。\n        *   `fork()` 子进程进行保存时，如果数据集巨大，可能会导致服务器短暂停止服务几毫秒或更久。\n\n2.  **AOF (Append Only File) 只追加文件**\n    *   **工作原理**: 以日志的形式，记录下每一个**写**操作命令。当 Redis 重启时，会重新执行 AOF 文件中的所有命令来恢复数据集。\n    *   **优点**:\n        *   数据持久性更高。可以配置为每秒同步 (`everysec`)，最多只会丢失 1 秒的数据。\n        *   AOF 文件是一个只追加的日志文件，即使出现写入不完整的情况，也可以用 `redis-check-aof` 工具轻松修复。\n    *   **缺点**:\n        *   对于相同的数据集，AOF 文件通常比 RDB 文件大。\n        *   数据恢复速度通常慢于 RDB。\n\n**如何选择？**\n\n*   **如果只追求高性能，可以接受分钟级别的数据丢失**：单独使用 RDB。\n*   **如果追求数据安全，不希望丢失任何数据**：单独使用 AOF (配置为 `always` 同步，但会影响性能)。\n*   **官方推荐，也是最安全的做法**：**同时开启 RDB 和 AOF**。在这种情况下，当 Redis 重启时，会优先使用 AOF 文件来恢复数据，因为它能保证数据的完整性最高。而 RDB 文件则可以用于做更方便的冷备份。\n\n在 Go 代码层面，你不需要直接操作持久化，这是 Redis 服务器的配置 (`redis.conf`) 和运维工作。\n\n---\n\n## **4. Lua 脚本**\n\n当某些操作需要原子性，但 Redis 没有提供现成的命令时（比如“判断库存并扣减”），Lua 脚本就派上了用场。\n\n*   **为什么需要 Lua 脚本？**\n    1.  **原子性**: Redis 会将整个 Lua 脚本作为一个原子操作执行，中间不会被其他命令插入。\n    2.  **减少网络开销**: 将多个命令组合在一个脚本中，只需一次网络请求，而不是多次。\n    3.  **复用性**: 脚本可以被缓存，通过 `EVALSHA` 命令使用 SHA1 校验和来调用，避免了重复传输脚本内容。\n\n**Go 实战：使用 Lua 脚本实现安全的库存扣减**\n\n```go\nfunc luaScriptExample() {\n\tfmt.Println(\"\\n--- Lua 脚本示例 ---\")\n\tctx := context.Background()\n\tstockKey := \"product:1:stock\"\n\trdb.Set(ctx, stockKey, 10, 0) // 初始化库存为 10\n\n\t// Lua 脚本：\n\t// KEYS[1]: 库存的 key\n\t// ARGV[1]: 本次要扣减的数量\n\t// 如果当前库存 >= 扣减数量，则执行扣减并返回 1；否则，什么都不做，返回 0。\n\tluaScript := `\n        local current_stock = tonumber(redis.call('GET', KEYS[1]))\n        local purchase_quantity = tonumber(ARGV[1])\n        if current_stock >= purchase_quantity then\n            redis.call('DECRBY', KEYS[1], purchase_quantity)\n            return 1\n        else\n            return 0\n        end\n    `\n\t\n\t// 创建一个 redis.Script 实例\n\tscript := redis.NewScript(luaScript)\n\n\t// 第一次尝试购买 3 个，应该成功\n\tresult, err := script.Run(ctx, rdb, []string{stockKey}, 3).Int()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"购买 3 个，结果: %d (1=成功, 0=失败)\\n\", result)\n\n\t// 第二次尝试购买 10 个，应该失败\n\tresult, err = script.Run(ctx, rdb, []string{stockKey}, 10).Int()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"购买 10 个，结果: %d (1=成功, 0=失败)\\n\", result)\n\n\tfinalStock, _ := rdb.Get(ctx, stockKey).Result()\n\tfmt.Printf(\"最终库存: %s\\n\", finalStock) // 应该是 7\n}\n```\n\n**代码解析**:\n\n1.  我们定义了一个 Lua 脚本字符串。`KEYS[1]` 对应传入的第一个 key，`ARGV[1]` 对应第一个参数。\n2.  `redis.NewScript` 创建一个脚本对象。\n3.  `script.Run` 负责执行脚本。它会智能地先尝试用 `EVALSHA`，如果服务器没有缓存该脚本，它会自动使用 `EVAL` 发送脚本内容，并将其缓存起来。\n\n---\n\n## **5. Redis Streams (流)**\n\nRedis Streams 是 Redis 5.0 引入的全新数据类型，它是一个功能强大的、支持持久化的消息队列。它借鉴了 Kafka 的设计思想，特别是**消费者组 (Consumer Group)** 的概念。\n\n*   **相比于 List 实现的消息队列，Streams 的优势**:\n    *   **支持消费者组**: 允许多个消费者共同消费同一个流，每个消息只会被组内的一个消费者处理，非常适合横向扩展。\n    *   **消息持久化**: 消息是持久的，除非显式删除。\n    *   **消息 ID 和有序性**: 每个消息都有一个唯一的、按时间排序的 ID。\n    *   **支持阻塞读取**: 和 `BLPOP` 类似，但功能更强大。\n\n**Go 实战：使用 Streams 实现一个简单的消息队列**\n\n**生产者 (`producer_stream.go`)**\n\n```go\nfunc streamProducer() {\n\tfmt.Println(\"Stream 生产者启动...\")\n\tctx := context.Background()\n\tstreamKey := \"mystream\"\n\n\t// XAdd 命令用于向流中添加消息\n\t// * 表示让 Redis 自动生成消息 ID\n\t// \"name\", \"alice\", \"age\", \"25\" 是消息的键值对内容\n\terr := rdb.XAdd(ctx, &redis.XAddArgs{\n\t\tStream: streamKey,\n\t\tValues: map[string]interface{}{\"name\": \"alice\", \"age\": \"25\"},\n\t}).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\terr = rdb.XAdd(ctx, &redis.XAddArgs{\n\t\tStream: streamKey,\n\t\tValues: map[string]interface{}{\"name\": \"bob\", \"age\": \"30\"},\n\t}).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"已向 'mystream' 发送两条消息\")\n}\n```\n\n**消费者 (`consumer_stream.go`)**\n\n```go\nfunc streamConsumer() {\n\tfmt.Println(\"Stream 消费者启动...\")\n\tctx := context.Background()\n\tstreamKey := \"mystream\"\n\n\t// XRead 命令用于从一个或多个流中读取消息\n\t// \"0\" 表示从头开始读取所有消息\n\t// Count: 10 表示一次最多读取 10 条\n\t// Block: 0 表示无限期阻塞等待新消息\n\tstreams, err := rdb.XRead(ctx, &redis.XReadArgs{\n\t\tStreams: []string{streamKey, \"0\"},\n\t\tCount:   10,\n\t\tBlock:   0,\n\t}).Result()\n\n\tif err != nil && err != redis.Nil {\n\t\tpanic(err)\n\t}\n\n\tfor _, stream := range streams {\n\t\tfmt.Printf(\"从流 [%s] 中读取到 %d 条消息:\\n\", stream.Stream, len(stream.Messages))\n\t\tfor _, msg := range stream.Messages {\n\t\t\tfmt.Printf(\"  ID: %s, 内容: %v\\n\", msg.ID, msg.Values)\n\t\t}\n\t}\n}\n```\n\n**说明**：\n这是一个最简单的消费者模型。在实际应用中，你会使用**消费者组 (`XGROUP CREATE`, `XREADGROUP`)** 来实现更可靠、可扩展的消息处理，并处理消息确认 (`XACK`)。\n\n---\n\n第三部分内容到此结束。你已经掌握了 Redis 的事务处理、消息模式和高级数据结构。这些是构建复杂、健壮和高性能应用的关键。在下一部分，我们将探讨如何将这些技术应用到具体的实战模式中，例如构建缓存层和实现分布式锁。\n\n\n\n好的，我们现在进入第四部分。在这一部分，我们将把之前学到的所有知识融会贯通，应用到一些常见且高级的实战模式中。这些模式是构建可扩展、高性能后端服务的核心组件。\n\n---\n\n# **高级应用与实战模式**\n\n## **1. 构建缓存层 (Caching)**\n\n将 Redis 用作缓存是其最广泛的应用场景。通过将热点数据（高频访问且不频繁变更的数据）放入 Redis，可以极大地降低后端数据库的压力，并显著提升应用程序的响应速度。\n\n*   **核心缓存模式：Cache-Aside (旁路缓存)**\n    这是最常用、最经典的缓存模式，其逻辑非常清晰：\n\n    1.  **读操作**：\n        *   应用先请求 Redis 获取数据。\n        *   如果 Redis 中有数据（**缓存命中**），则直接返回给应用。\n        *   如果 Redis 中没有数据（**缓存未命中**），则应用去请求数据库。\n        *   应用从数据库获取数据后，**将数据写入 Redis**（并设置一个过期时间），然后再返回给应用。\n    2.  **写操作**：\n        *   先更新数据库。\n        *   然后**直接删除 Redis 中对应的缓存**。\n\n    **为什么是删除缓存，而不是更新缓存？**\n    因为更新缓存的操作路径更复杂，可能存在并发问题（例如，两个并发的写操作，缓存的最终值可能与数据库不一致）。而删除缓存则简单有效，下次读取时会自然地从数据库加载最新数据并回填缓存（这个过程也叫“懒加载”）。\n\n**Go 实战：为获取文章详情接口添加缓存**\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/go-redis/redis/v9\"\n\t\"time\"\n)\n\n// ... (省略 initClient 和 rdb 变量定义) ...\n\n// Article 结构体\ntype Article struct {\n\tID      string `json:\"id\"`\n\tTitle   string `json:\"title\"`\n\tContent string `json:\"content\"`\n\tAuthor  string `json:\"author\"`\n}\n\n// 模拟一个缓慢的数据库查询\nfunc getArticleFromDB(id string) (*Article, error) {\n\tfmt.Printf(\"慢查询：正在从数据库获取文章 %s...\\n\", id)\n\ttime.Sleep(500 * time.Millisecond) // 模拟 I/O 延迟\n\t// 实际应用中，这里会是 SQL 查询\n\treturn &Article{\n\t\tID:      id,\n\t\tTitle:   \"Go-Redis 实战\",\n\t\tContent: \"这是一篇关于如何在 Go 中使用 Redis 的文章...\",\n\t\tAuthor:  \"Gemini\",\n\t}, nil\n}\n\n// GetArticleByID 实现了 Cache-Aside 模式\nfunc GetArticleByID(ctx context.Context, id string) (*Article, error) {\n\tcacheKey := fmt.Sprintf(\"article:%s\", id)\n\n\t// 1. 先从 Redis 读取\n\tval, err := rdb.Get(ctx, cacheKey).Result()\n\tif err == nil { // 缓存命中\n\t\tfmt.Printf(\"缓存命中：从 Redis 获取文章 %s\\n\", id)\n\t\tvar article Article\n\t\tif err := json.Unmarshal([]byte(val), &article); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &article, nil\n\t}\n\t\n\t// 仅当错误是 redis.Nil 时，才继续执行，否则说明是 Redis 服务出错了\n\tif err != redis.Nil {\n\t\treturn nil, err // Redis 服务错误，直接返回\n\t}\n\n\t// 2. 缓存未命中，从数据库读取\n\tarticle, err := getArticleFromDB(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// 3. 将数据写入 Redis，并设置过期时间\n\tjsonData, err := json.Marshal(article)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t\n\t// 设置 1 分钟的缓存过期时间\n\terr = rdb.Set(ctx, cacheKey, jsonData, 1*time.Minute).Err()\n\tif err != nil {\n\t\t// 即使缓存设置失败，也应该将从数据库读到的结果返回给用户\n\t\t// 但需要记录日志\n\t\tfmt.Printf(\"警告：设置缓存失败: %v\\n\", err)\n\t}\n\n\treturn article, nil\n}\n```\n\n**缓存问题与解决方案**\n\n*   **缓存穿透**: 查询一个**绝对不存在**的数据。这会导致每次请求都“穿透”缓存，直接打到数据库，失去了缓存的意义。\n    *   **解决方案**: 当从数据库查询不到数据时，也在 Redis 中缓存一个**空值**或特殊占位符，并设置一个较短的过期时间（如 30 秒），防止恶意攻击。\n*   **缓存击穿**: 一个**热点 Key** 在某个时刻突然过期，导致大量并发请求瞬间全部打到数据库上，可能导致数据库崩溃。\n    *   **解决方案**: 使用互斥锁。当缓存未命中时，只允许第一个请求去查询数据库并回填缓存，其他请求则等待。在 Go 中，`golang.org/x/sync/singleflight` 包是实现此模式的利器。\n*   **缓存雪崩**: 大量 Key 在**同一时间**集中过期，导致数据库瞬时压力剧增。\n    *   **解决方案**: 在设置 Key 的过期时间时，增加一个**随机值**，比如 `过期时间 = 基础时间 + random(1, 300)` 秒，将过期时间点打散。\n\n---\n\n## **2. 实现分布式锁**\n\n在分布式系统中（例如，你的服务部署了多个实例），当需要修改某个共享资源时，需要一种机制来保证同一时间只有一个实例能够执行修改操作。这就是分布式锁。\n\n*   **核心思想**: 利用 Redis 的 `SET key value NX PX milliseconds` 原子命令。\n    *   `SET key value`: 尝试设置一个 key。\n    *   `NX`: (if Not eXists) 只有当 `key` 不存在时，`SET` 操作才会成功。\n    *   `PX milliseconds`: 为这个 `key` 设置一个以毫秒为单位的过期时间。\n    *   `value`: 必须是一个唯一的随机字符串（如 UUID），用于标识锁的持有者。\n\n**为什么必须是原子命令？**\n如果分两步 `SETNX` 和 `EXPIRE`，那么在执行完 `SETNX` 后，服务实例崩溃，`EXPIRE` 没能执行，这个锁将永远无法被释放，造成“死锁”。\n\n**为什么 `value` 必须唯一？**\n为了安全地释放锁。假设客户端 A 获取了锁（过期时间 10 秒），但由于网络延迟或 GC，它的业务执行了 15 秒。此时，锁已经被 Redis 自动释放，客户端 B 获取了同一个锁。然后客户端 A 执行完毕，执行 `DEL` 命令，它会错误地释放掉客户端 B 的锁。\n\n**Go 实战：实现一个安全、可重入性低的分布式锁**\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"github.com/go-redis/redis/v9\"\n\t\"github.com/google/uuid\"\n\t\"time\"\n)\n\n// AcquireLock 尝试获取一个分布式锁\n// lockKey: 锁的名称\n// lockValue: 锁的唯一标识\n// expiration: 锁的过期时间\nfunc AcquireLock(ctx context.Context, lockKey string, lockValue string, expiration time.Duration) (bool, error) {\n\t// SetNX 返回一个 bool 类型的 val，true 表示设置成功，false 表示 key 已存在\n\treturn rdb.SetNX(ctx, lockKey, lockValue, expiration).Result()\n}\n\n// ReleaseLock 安全地释放一个分布式锁\n// 使用 Lua 脚本保证“比较”和“删除”的原子性\nfunc ReleaseLock(ctx context.Context, lockKey string, lockValue string) error {\n\t// Lua 脚本：\n\t// 如果 key 的值等于我们传入的 value，就删除这个 key，并返回 1；否则返回 0。\n\tluaScript := `\n        if redis.call('GET', KEYS[1]) == ARGV[1] then\n            return redis.call('DEL', KEYS[1])\n        else\n            return 0\n        end\n    `\n\tscript := redis.NewScript(luaScript)\n\tresult, err := script.Run(ctx, rdb, []string{lockKey}, lockValue).Int()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif result == 0 {\n\t\treturn errors.New(\"锁释放失败：可能锁已被他人持有或已过期\")\n\t}\n\treturn nil\n}\n\n// 分布式锁使用示例\nfunc distributedLockExample() {\n\tfmt.Println(\"\\n--- 分布式锁示例 ---\")\n\tctx := context.Background()\n\tlockKey := \"my-distributed-lock\"\n\t// 为每个锁请求生成一个唯一ID\n\tlockValue := uuid.New().String()\n\n\t// 尝试获取锁，有效期 10 秒\n\tlocked, err := AcquireLock(ctx, lockKey, lockValue, 10*time.Second)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif locked {\n\t\tfmt.Println(\"成功获取锁！正在执行业务逻辑...\")\n\t\ttime.Sleep(5 * time.Second) // 模拟业务处理\n\t\tfmt.Println(\"业务逻辑执行完毕，准备释放锁。\")\n\t\t\n\t\terr := ReleaseLock(ctx, lockKey, lockValue)\n\t\tif err != nil {\n\t\t\tfmt.Println(err.Error())\n\t\t} else {\n\t\t\tfmt.Println(\"成功释放锁！\")\n\t\t}\n\t} else {\n\t\tfmt.Println(\"获取锁失败，其他进程正在处理。\")\n\t}\n}\n```\n\n---\n\n## **3. 位图 (Bitmaps) 与 HyperLogLogs**\n\n这是两种非常高级且节省内存的数据结构，它们实际上是基于 Redis 的 String 类型实现的。\n\n### **3.1 Bitmaps (位图)**\n\n你可以将一个 String 值看作是一个无限大的 bit 数组。Bitmaps 提供了一系列命令，让你能够像操作数组一样，设置或获取某一个 bit 位的值（0 或 1）。\n\n*   **用途**: 非常适合用于记录大量用户的布尔状态，例如：\n    *   用户每日签到状态\n    *   用户是否在线\n    *   用户是否看过某篇文章\n\n*   **优点**: 极度节省空间。记录 1 亿用户的签到状态，每天只需要 `100,000,000 bits / 8 / 1024 / 1024 ≈ 12 MB` 的空间。\n\n**Go 实战：记录用户每日签到**\n\n```go\nfunc bitmapExample() {\n\tfmt.Println(\"\\n--- Bitmaps 签到示例 ---\")\n\tctx := context.Background()\n\t\n\t// Key 的格式：sign:{yyyyMMdd}\n\ttoday := time.Now().Format(\"20060102\")\n\tsignKey := fmt.Sprintf(\"sign:%s\", today)\n\n\t// 假设有三个用户，ID 分别为 100, 101, 102\n\t// SetBit(key, offset, value)\n\t// offset 就是用户 ID\n\t// value 1 表示签到，0 表示未签到\n\n\t// 用户 100 签到\n\trdb.SetBit(ctx, signKey, 100, 1)\n\t// 用户 102 签到\n\trdb.SetBit(ctx, signKey, 102, 1)\n\n\t// 检查用户 100 和 101 是否签到\n\tisSigned100, _ := rdb.GetBit(ctx, signKey, 100).Result()\n\tisSigned101, _ := rdb.GetBit(ctx, signKey, 101).Result()\n\tfmt.Printf(\"用户 100 今天是否签到: %d (1=是, 0=否)\\n\", isSigned100)\n\tfmt.Printf(\"用户 101 今天是否签到: %d (1=是, 0=否)\\n\", isSigned101)\n\n\t// 统计今天总的签到人数\n\ttotalSigned, _ := rdb.BitCount(ctx, signKey, nil).Result()\n\tfmt.Printf(\"今天总签到人数: %d\\n\", totalSigned)\n}\n```\n\n### **3.2 HyperLogLogs (HLL)**\n\nHyperLogLog 是一种**概率性**数据结构，用于进行**基数统计**（即统计一个集合中不重复元素的数量）。\n\n*   **用途**: 在需要统计巨大数量的独立访客（UV）、独立 IP 数等场景下，它非常有用。\n*   **优点**: 占用空间极小且固定。在 Redis 中，每个 HLL key 只占用 12KB 的内存，就可以统计高达 2^64 个不同元素的基数。\n*   **缺点**: 统计结果是一个**估算值**，存在一定的误差（标准误差为 0.81%）。你无法获取具体是哪些元素，只能获取它们的总数。\n\n**Go 实战：统计网站每日独立访客 (UV)**\n\n```go\nfunc hyperLogLogExample() {\n\tfmt.Println(\"\\n--- HyperLogLog 统计 UV 示例 ---\")\n\tctx := context.Background()\n\tuvKey := fmt.Sprintf(\"uv:%s\", time.Now().Format(\"20060102\"))\n\n\t// 模拟用户访问，每个用户有一个唯一的 ID (可以是 userID, sessionID, IP地址等)\n\t// PFAdd(key, elements...)\n\trdb.PFAdd(ctx, uvKey, \"user1\", \"user2\", \"user3\")\n\trdb.PFAdd(ctx, uvKey, \"user2\", \"user3\", \"user4\", \"user5\") // 重复的 user2, user3 不会增加计数\n\n\t// PFCount(key) 获取基数估算值\n\tuvCount, err := rdb.PFCount(ctx, uvKey).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"今天网站的估算独立访客数 (UV): %d\\n\", uvCount)\n}\n```\n\n---\n\n第四部分到此结束。你现在已经学会了如何使用 Redis 来构建企业级的缓存系统、实现健壮的分布式锁，以及利用 Bitmaps 和 HyperLogLogs 进行高效的数据统计。这些模式是在真实世界项目中非常有价值的技能。在最后一部分，我们将讨论一些关于运维和最佳实践的话题。\n\n\n\n\n\n\n\n好的，我们来到了这份学习笔记的最后一个部分。这部分内容将超越代码层面，聚焦于如何在生产环境中健康、高效地运行和维护 Redis，并总结一些重要的开发最佳实践。\n\n---\n\n# **运维与最佳实践**\n\n一个稳定可靠的 Redis 服务，离不开合理的架构设计和持续的监控维护。\n\n## **1. Redis 高可用与扩展**\n\n当业务流量增长，单个 Redis 实例可能会遇到瓶颈，或者成为系统的单点故障 (Single Point of Failure)。Redis 提供了多种方案来解决这个问题。\n\n### **1.1 主从复制 (Replication)**\n\n*   **工作原理**: 配置一个 Redis 实例（**Master**）和多个其他实例（**Slaves**）。所有写操作都在 Master 上进行，然后 Master 会异步地将数据变更同步给所有的 Slaves。Slaves 通常是只读的。\n*   **主要用途**:\n    1.  **数据冗余**: 当 Master 宕机时，Slave 上有完整的数据备份，可以手动将其提升为新的 Master，但这个过程需要人工介入。\n    2.  **读写分离**: 对于读多写少的场景，可以将所有读请求分发到多个 Slave 节点上，从而分担 Master 的读取压力，提高整体性能。\n*   **缺点**: 无法实现自动故障转移。如果 Master 宕机，系统将无法写入，直到运维人员手动处理。\n\n### **1.2 哨兵 (Sentinel)**\n\n*   **工作原理**: Sentinel 是一个独立的进程，它通过“监视”一组 Master-Slave 节点来工作。它是一个高可用性的解决方案。\n\n*   **核心功能**:\n\n    1.  **监控 (Monitoring)**: Sentinel 会持续检查 Master 和 Slaves 是否正常工作。\n    2.  **通知 (Notification)**: 当某个 Redis 实例出现问题时，Sentinel 可以通过 API 向管理员或其他应用程序发送通知。\n    3.  **自动故障转移 (Automatic Failover)**: 这是 Sentinel 最核心的功能。如果 Master 宕机，Sentinel 会在 Slaves 中选举出一个新的 Master，并通知其他 Slaves 连接到新的 Master。同时，它也会通知客户端新的 Master 地址。\n    4.  **配置提供者 (Configuration Provider)**: 客户端连接时，可以直接向 Sentinel 查询当前 Master 的地址，而不需要在代码中硬编码。\n\n*   **架构**: 为了保证 Sentinel 本身的可用性，生产环境通常会部署一个由 3 个或 5 个 Sentinel 进程组成的集群。\n\n*   **在 Go 中连接 Sentinel 管理的 Redis**\n    `go-redis` 提供了专门的客户端来连接 Sentinel。\n\n    ```go\n    // 使用 NewFailoverClient 连接由 Sentinel 管理的集群\n    rdb := redis.NewFailoverClient(&redis.FailoverOptions{\n        MasterName:    \"mymaster\", // 在 Sentinel 配置文件中定义的主节点名称\n        SentinelAddrs: []string{\"sentinel1:26379\", \"sentinel2:26379\", \"sentinel3:26379\"},\n    })\n    ```\n\n### **1.3 集群 (Cluster)**\n\n*   **工作原理**: 当数据量巨大，单个 Master 的内存无法容纳，或者写请求的 QPS 过高时，就需要 Redis Cluster。它是一种**分布式**解决方案，通过**分片 (Sharding)** 将数据分散存储在多个 Redis 节点上。\n\n*   **核心概念**:\n\n    *   **哈希槽 (Hash Slot)**: Redis Cluster 预设了 16384 个哈希槽。当一个 key 需要存储时，Cluster 会对这个 key 使用 CRC16 算法计算出一个值，然后对 16384 取模，决定这个 key 应该存放在哪个槽里。\n    *   **节点分工**: 每个 Master 节点负责一部分哈希槽。例如，一个 3 主 3 从的集群，可能是：\n        *   Node A (Master) 负责 0 - 5500 槽\n        *   Node B (Master) 负责 5501 - 11000 槽\n        *   Node C (Master) 负责 11001 - 16383 槽\n    *   **高可用**: Cluster 中的每个 Master 节点都可以有自己的 Slave 节点，当 Master 宕机时，其对应的 Slave 会自动提升为新的 Master，接管哈希槽，保证服务不中断。\n\n*   **在 Go 中连接 Redis Cluster**\n    客户端必须是“集群感知”的，`go-redis` 完美支持。\n\n    ```go\n    // 使用 NewClusterClient 连接 Redis 集群\n    rdb := redis.NewClusterClient(&redis.ClusterOptions{\n        Addrs: []string{\"node1:7001\", \"node2:7002\", \"node3:7003\"},\n        // ... 其他选项，如密码等\n    })\n    ```\n\n| 方案         | 解决的问题                       | 优点                         | 缺点                                            |\n| :----------- | :------------------------------- | :--------------------------- | :---------------------------------------------- |\n| **主从复制** | 数据备份、读扩展                 | 结构简单，易于部署           | 无自动故障转移                                  |\n| **哨兵**     | 高可用、自动故障转移             | 自动切换主库，保证服务可用性 | 无法解决单 Master 的写瓶颈和内存限制            |\n| **集群**     | 高可用、海量数据存储、高并发写入 | 同时提供高可用和水平扩展能力 | 架构更复杂，部分命令（如涉及多 key 的）使用受限 |\n\n---\n\n## **2. 性能与监控**\n\n*   **`INFO` 命令**:\n    这是最重要的监控命令，它返回关于 Redis 服务器的全方位信息。在 `redis-cli` 中执行 `INFO`，你会看到多个部分。\n    *   `# Memory`:\n        *   `used_memory_human`: 当前已使用的内存，是监控内存是否溢出的核心指标。\n        *   `mem_fragmentation_ratio`: 内存碎片率。大于 1.5 表明碎片较多，可能需要重启实例来整理。小于 1 表明 Redis 使用的内存超过了系统分配的内存，可能在进行内存交换（Swap），性能会急剧下降。\n    *   `# Stats`:\n        *   `total_connections_received`: 累计连接数。\n        *   `total_commands_processed`: 累计处理的命令数 (QPS/OPS)。\n        *   `keyspace_hits` & `keyspace_misses`: 缓存命中和未命中的次数。缓存命中率 = `hits / (hits + misses)`，这个比率是衡量缓存效率的关键。\n    *   `# Persistence`: RDB 和 AOF 的相关信息。\n\n*   **`SLOWLOG` 命令**:\n    Redis 会记录执行时间超过指定阈值（通过 `slowlog-log-slower-than` 配置）的命令。使用 `SLOWLOG GET [number]` 可以查看这些慢命令，是排查性能瓶颈的重要工具。\n\n---\n\n## **3. Go 开发最佳实践**\n\n1.  **统一的键命名规范**:\n    为你的 Key 设计一个清晰、有层次的命名空间，可以极大地提高可维护性。推荐使用冒号分隔。\n    *   **格式**: `项目名:业务模块:对象类型:对象ID:[字段]`\n    *   **示例**: `myproject:user:profile:1001`, `myproject:cache:article:8809`\n\n2.  **避免重量级命令**:\n    因为 Redis 是单线程处理命令，一个慢命令会阻塞所有其他客户端的请求。\n    *   **绝对禁止在生产环境使用 `KEYS`**。请使用 `SCAN` 命令进行安全的、基于游标的迭代。\n    *   谨慎使用 `HGETALL`, `LRANGE 0 -1`, `SMEMBERS` 等命令操作包含数万甚至数百万个元素的巨大 Key，这可能导致长时间阻塞。如果需要，考虑分批获取。\n\n3.  **为缓存键设置合理的过期时间**:\n    这是防止 Redis 内存被无用数据耗尽的最重要手段。\n    *   **永不过期的数据要警惕**。确保它们是确实需要永久存在的。\n    *   使用随机化过期时间来**防止缓存雪崩**。\n\n4.  **理解内存管理与淘汰策略**:\n    当 Redis 内存使用达到 `maxmemory` 上限时，会触发**数据淘汰策略 (Eviction Policy)**。\n    *   在 `redis.conf` 中配置 `maxmemory-policy`。\n    *   常用策略：\n        *   `volatile-lru`: (默认) 从已设置过期时间的 key 中，淘汰最近最少使用的。\n        *   `allkeys-lru`: 从所有 key 中，淘汰最近最少使用的。\n        *   `volatile-lfu`: (Redis 4.0+) 从已设置过期时间的 key 中，淘汰最不经常使用的。\n        *   `allkeys-lfu`: 从所有 key 中，淘汰最不经常使用的。\n        *   `noeviction`: 不淘汰任何数据，后续的写操作会直接返回错误。\n\n5.  **Go 客户端使用技巧**:\n    *   **复用 `redis.Client` 对象**: `redis.Client` 是并发安全的，并且内置了连接池。你应该在应用启动时初始化一个全局的客户端实例，并在所有地方复用它，而不是每次请求都创建一个新的。\n    *   **善用 `context` 控制超时**: 为每个 Redis 操作传递带有超时的 `context`，可以防止因为 Redis 慢查询而拖垮整个应用。\n    *   **使用 `Pipeline` 批量操作**: 当你需要连续执行多个命令且不要求原子性时，使用 `Pipeline` 可以显著减少网络延迟，提升性能。\n\n---\n\n**总结**\n\n恭喜你！至此，你已经系统地学习了从 Redis 的基础概念、五大数据类型，到在 Go 语言中的实战应用，再到事务、发布订阅等高级主题，最后覆盖了分布式锁、缓存模式以及运维和最佳实践。\n\nRedis 是一个功能极其强大且应用广泛的工具。这份笔记为你打下了坚实的基础，但真正的精通来自于不断的实践。现在，尝试在你的下一个项目中引入 Redis，解决实际问题吧！\n\n\n\n\n\n\n\n# 实际案例\n\n## Pub/Sub模型\n\n- 程序 A：发布者（Publisher）\n- 程序 B：订阅者（Subscriber），可以有 1 个，也可以有 N 个同时运行\n- 当发布者发送消息时，所有订阅者都会实时收到\n\n下面我给你写两个完全独立的 Go 程序，直接可运行。\n\n------\n\n### publisher\n\n```go\n// publisher.go\n// 声明这个文件属于 main 包\npackage main\n\n// 导入需要的标准库和第三方包\nimport (\n\t\"context\" // 用于处理上下文，如超时、取消等\n\t\"fmt\"     // 用于格式化输入输出\n\t\"time\"    // 用于处理时间和日期\n\n\t\"github.com/redis/go-redis/v9\" // Redis 的 Go 客户端库\n)\n\n// 创建一个空的 context.Background()，它是所有 context 的根节点\n// 通常在主函数、初始化和测试时使用\nvar ctx = context.Background()\n\n// 程序的入口函数\nfunc main() {\n\t// 创建一个新的 Redis 客户端实例\n\t// &redis.Options 结构体包含了连接 Redis 的配置选项\n\t// Addr 指定了 Redis 服务器的地址，这里是本地默认端口 6379\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr: \"localhost:6379\", // Redis 服务器地址\n\t})\n\n\t// 使用 for 循环发布 10 条消息\n\tfor i := 0; i < 100000; i++ {\n\t\t// 获取当前时间并格式化为 \"2006-01-02 15:04:05\" 的格式\n\t\t// 注意：Go 的时间格式化模板是固定的，必须使用 2006-01-02 15:04:05 这个特定时间\n\t\tcurrentTime := time.Now().Format(\"2006-01-02 15:04:05\")\n\n\t\t// 创建消息内容，包含序号和当前时间\n\t\t// fmt.Sprintf 用于格式化字符串，%d 是整数的占位符，%s 是字符串的占位符\n\t\tmsg := fmt.Sprintf(\"消息 %d - %s\", i, currentTime)\n\n\t\t// 使用 Publish 方法向 \"demo-channel\" 频道发布消息\n\t\t// ctx 是上下文，\"demo-channel\" 是频道名，msg 是消息内容\n\t\t// .Err() 用于获取发布操作可能产生的错误\n\t\terr := rdb.Publish(ctx, \"demo-channel\", msg).Err()\n\n\t\t// 检查发布操作是否出错\n\t\tif err != nil {\n\t\t\t// 如果出错，打印错误信息并退出程序\n\t\t\tfmt.Println(\"发布失败:\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// 打印成功发布的消息内容\n\t\tfmt.Println(\"已发布:\", msg)\n\n\t\t// 暂停 1 秒\n\t\t// time.Sleep 用于让程序休眠指定的时间\n\t\t// 1 * time.Second 表示 1 秒\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}\n```\n\n\n\n-----\n\n### subscriber\n\n```go\n// subscriber.go\n// 声明这个文件属于 main 包\npackage main\n\n// 导入需要的标准库和第三方包\nimport (\n\t\"context\" // 用于处理上下文，如超时、取消等\n\t\"fmt\"     // 用于格式化输入输出\n\n\t\"github.com/redis/go-redis/v9\" // Redis 的 Go 客户端库\n)\n\n// 创建一个空的 context.Background()，它是所有 context 的根节点\n// 通常在主函数、初始化和测试时使用\nvar ctx = context.Background()\n\n// 程序的入口函数\nfunc main() {\n\t// 创建一个新的 Redis 客户端实例\n\t// &redis.Options 结构体包含了连接 Redis 的配置选项\n\t// Addr 指定了 Redis 服务器的地址，这里是本地默认端口 6379\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr: \"localhost:6379\",\n\t})\n\n\t// 使用 Redis 客户端订阅名为 \"demo-channel\" 的频道\n\t// Subscribe 方法返回一个订阅对象\n\tsub := rdb.Subscribe(ctx, \"demo-channel\")\n\n\t// 获取订阅频道的消息通道\n\t// Channel() 返回一个 channel，用于接收订阅到的消息\n\tch := sub.Channel()\n\n\t// 打印提示信息，表示开始订阅\n\tfmt.Println(\"开始订阅 demo-channel ...\")\n\n\t// 使用 for-range 循环持续监听频道消息\n\t// 每当有新消息到达时，msg 变量就会接收到消息\n\t// 这个循环会一直运行，直到程序被终止或通道关闭\n\tfor msg := range ch {\n\t\t// 打印接收到的消息内容\n\t\t// msg.Payload 包含了消息的实际内容\n\t\tfmt.Printf(\"收到消息: %s\\n\", msg.Payload)\n\t}\n}\n```\n\n\n\n----\n\n\n\n### 使用方法\n\n1. 启动一个或多个订阅者（可以开 N 个终端同时运行 `subscriber.go`）：\n\n```\ngo run subscriber.go\n```\n\n1. 启动发布者：\n\n```\ngo run publisher.go\n```\n\n1. 你会看到所有订阅者**同时收到相同的消息**：\n\n```\n收到消息: 消息 0\n收到消息: 消息 1\n收到消息: 消息 2\n...\n```\n\n------\n\n 特别说明：\n\n- **Pub/Sub 不会存储消息**，如果订阅者启动得比发布者晚，之前发过的消息收不到。\n- 如果你需要“后来的订阅者还能收到旧消息”，那就要用 **Redis Streams**。\n- 由于接收端是管道，因此会阻塞住。如果不想被阻塞，可能需要添加defalut等语句。\n- 当没有订阅者时：\n  - 发布者照常 `PUBLISH`，Redis 会执行成功。\n  - 不过这个消息不会被任何人接收到，相当于“丢弃”。\n  - Redis 会告诉你有多少个订阅者收到了消息（一般返回 `0`）。\n- 当没有发布者时：\n  - 订阅者执行 `SUBSCRIBE` 后就会挂起，等待消息。\n  - 这时没有消息，它就一直阻塞在那里，不会报错。\n  - 一旦有发布者发消息，它会立刻收到。\n- 发布者和订阅者都不存在\n  - Redis 什么都不会做，就静静待在那里，也不会报错。\n\n----\n\n**总结**\n\n- Pub/Sub 是**松耦合**的，发布者和订阅者可以任意存在或缺失。\n- 最多只是消息“没人接收”，但不会抛异常或报错。\n- 所以在 Go 代码里，不需要加额外的错误处理来保证“对方一定在线”。\n\n-----\n\n\n\n## Streams模型\n\n### Pub/Sub和 Streams 的区别\n\nRedis 里的 **Pub/Sub** 和 **Streams** 看似都是消息机制，但它们的定位和能力差别很大。你可以把它们理解成两个层级的工具：\n\n------\n\n####  1. Pub/Sub\n\n**特点：**\n\n- **即时性**：消息只会实时发送给在线订阅者。\n- **不存储**：消息发出去，如果没人订阅，就直接丢弃。\n- **无状态**：订阅者断开再连，不会收到历史消息。\n- **简单**：轻量级实现，性能高，延迟低。\n\n**适用场景：**\n\n- 聊天室（在线用户实时收到消息）。\n- 实时通知（告警推送、在线状态广播）。\n- 对消息可靠性要求不高的系统。\n\n------\n\n#### 2. Streams\n\n**特点：**\n\n- **持久化**：消息会存储在 Redis 里，直到显式删除。\n- **可回溯**：消费者可以从任意 ID 开始读消息，能获取历史消息。\n- **消费者组**：支持多个消费者分工合作（类似 Kafka 的 consumer group）。\n- **确认机制**：消费者需要 ACK，保证消息至少被消费一次。\n- **功能更全**：可以做消息队列、日志系统。\n\n**适用场景：**\n\n- 日志收集（存储和回放）。\n- 任务队列（保证任务不会丢失，失败可以重新消费）。\n- 事件流处理（IoT 数据、交易流水）。\n\n------\n\n#### 3. 核心区别对比表\n\n| 特性           | Pub/Sub              | Streams                |\n| -------------- | -------------------- | ---------------------- |\n| **消息存储**   | 不存储               | 持久化存储             |\n| **历史消息**   | 不可获取             | 可回溯                 |\n| **消费者模式** | 广播给所有订阅者     | 消费者组分工，避免重复 |\n| **可靠性**     | 无保证，消息可能丢   | 支持 ACK，保证至少一次 |\n| **性能**       | 高，延迟低           | 略高开销               |\n| **适用场景**   | 即时通知、在线聊天室 | 队列、日志、任务分发   |\n\n------\n\n#### 4. 类比一下\n\n- **Pub/Sub = 广播电台**：主播一说话，听众当场能听见；错过就没有了。\n- **Streams = 点播系统**：内容会存下来，你可以随时点播，还能多人分工听不同部分。\n\n------\n\n 总结：\n\n- 如果你要做 **实时消息推送**，选 Pub/Sub。\n- 如果你要做 **可靠队列 / 日志流**，选 Streams。\n\n\n\n### Producer\n\n```go\n// producer.go\npackage main // 声明这是 main 包，表示这是一个可执行程序\n\nimport ( // 导入所需的包\n\t\"context\" // 用于上下文控制\n\t\"fmt\"     // 用于格式化输入输出\n\t\"os\"      // 用于操作系统相关功能，如获取命令行参数\n\t\"strconv\" // 用于字符串和其他基本类型之间的转换\n\n\t\"github.com/redis/go-redis/v9\" // Redis 客户端库\n)\n\nvar ctx = context.Background() // 创建一个空的上下文，用于 Redis 操作\n\nfunc main() { // 程序入口函数\n\tif len(os.Args) < 2 { // 检查命令行参数数量\n\t\tfmt.Println(\"用法: go run producer.go <N>\") // 打印使用说明\n\t\treturn                                    // 退出程序\n\t}\n\n\tN, _ := strconv.Atoi(os.Args[1]) // 将第一个参数转换为整数（要发送的消息数量）\n\tif N <= 0 {                      // 检查 N 是否小于等于 0\n\t\tfmt.Println(\"不发送任何消息 (N=0)\") // 打印提示信息\n\t\treturn                       // 退出程序\n\t}\n\n\trdb := redis.NewClient(&redis.Options{ // 创建 Redis 客户端\n\t\tAddr: \"localhost:6379\", // Redis 服务器地址\n\t})\n\n\tfor i := 1; i <= N; i++ { // 循环 N 次，发送 N 条消息\n\t\tid, err := rdb.XAdd(ctx, &redis.XAddArgs{ // 向流中添加消息\n\t\t\tStream: \"demo-stream\", // 指定要添加消息的流名称\n\t\t\tValues: map[string]interface{}{ // 定义消息内容\n\t\t\t\t\"msg\": fmt.Sprintf(\"消息 %d\", i), // 创建格式化的消息文本\n\t\t\t},\n\t\t}).Result()\n\t\tif err != nil { // 检查添加是否出错\n\t\t\tfmt.Println(\"发送失败:\", err) // 打印错误信息\n\t\t\treturn                    // 退出程序\n\t\t}\n\t\tfmt.Printf(\"已发送: 消息 %d (ID=%s)\\n\", i, id) // 打印发送成功的消息和其ID\n\t}\n}\n```\n\n### Consumer\n\n```go\n// consumer.go\npackage main // 声明这是 main 包，表示这是一个可执行程序\n\nimport ( // 导入所需的包\n\t\"context\" // 用于上下文控制\n\t\"fmt\"     // 用于格式化输入输出\n\t\"os\"      // 用于操作系统相关功能，如获取命令行参数\n\t\"strconv\" // 用于字符串和其他基本类型之间的转换\n\n\t\"github.com/redis/go-redis/v9\" // Redis 客户端库\n)\n\nvar ctx = context.Background() // 创建一个空的上下文，用于 Redis 操作\n\nfunc main() { // 程序入口函数\n\n\tif len(os.Args) < 2 { // 检查命令行参数数量\n\t\tfmt.Println(\"用法: go run consumer.go <N>\") // 打印使用说明\n\t\treturn                                    // 退出程序\n\t}\n\n\tfmt.Println(\"开始接收消息...\")\n\n\tN, _ := strconv.Atoi(os.Args[1]) // 将第一个参数转换为整数（要接收的消息数量）\n\tif N <= 0 {                      // 检查 N 是否小于等于 0\n\t\tfmt.Println(\"不接收任何消息 (N=0)\") // 打印提示信息\n\t\treturn                       // 退出程序\n\t}\n\n\trdb := redis.NewClient(&redis.Options{ // 创建 Redis 客户端\n\t\tAddr: \"localhost:6379\", // Redis 服务器地址\n\t})\n\n\tlastID := \"0\" // 初始化最后读取的消息ID为\"0\"，表示从头开始读取\n\tcount := 0    // 初始化已接收消息计数器\n\n\tfor count < N { // 循环直到接收到 N 条消息\n\t\tstreams, err := rdb.XRead(ctx, &redis.XReadArgs{ // 从流中读取消息\n\t\t\tStreams: []string{\"demo-stream\", lastID}, // 指定要读取的流和起始ID\n\t\t\tCount:   1,                               // 每次读取最多 1 条消息\n\t\t\tBlock:   0,                               // 阻塞等待新消息，0 表示无限等待\n\t\t}).Result()\n\t\tif err != nil { // 检查读取是否出错\n\t\t\tfmt.Println(\"接收失败:\", err) // 打印错误信息\n\t\t\treturn                    // 退出程序\n\t\t}\n\n\t\tfor _, msg := range streams[0].Messages { // 遍历接收到的消息\n\t\t\tfmt.Printf(\"收到消息: ID=%s, 内容=%v\\n\", msg.ID, msg.Values) // 打印消息ID和内容\n\n\t\t\t// 删除消息\n\t\t\tdeleted, err := rdb.XDel(ctx, \"demo-stream\", msg.ID).Result()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"删除消息 %s 失败: %v\\n\", msg.ID, err)\n\t\t\t} else if deleted > 0 {\n\t\t\t\tfmt.Printf(\"消息 %s 已删除\\n\", msg.ID)\n\t\t\t}\n\n\t\t\tlastID = msg.ID // 更新最后读取的消息ID\n\t\t\tcount++         // 增加已接收消息计数器\n\t\t\tif count >= N { // 检查是否已接收足够的消息\n\t\t\t\tbreak // 跳出循环\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n\n\n\n\n### 使用方法\n\n1. **先清空旧的 Stream（避免历史消息干扰）：**\n\n```bash\nredis-cli DEL demo-stream\n```\n\n1. **运行 Producer 发送消息：**\n\n```\ngo run producer.go 5\n```\n\n会输出：\n\n```\n已发送: 消息 1 (ID=1725349102374-0)\n已发送: 消息 2 (ID=1725349102375-0)\n...\n```\n\n1. **运行 Consumer 接收消息：**\n\n```\ngo run consumer.go 5\n```\n\n会输出：\n\n```\n收到消息: ID=1725349102374-0, 内容=map[msg:消息 1]\n收到消息: ID=1725349102375-0, 内容=map[msg:消息 2]\n...\n```\n\n------\n\n### 特性验证\n\n- 如果 **先运行 Producer**，消息会存储在 Stream 里；Consumer 之后启动，依然能读到之前的消息。\n- 如果 **先运行 Consumer**，它会阻塞等待，直到 Producer 发消息才会收到。\n- 如果传 `N=0`，则双方都不会发送/接收任何消息，不会报错。\n- 如果接收端没有删除，则所有信息都会被redis保留。\n  - `deleted, err := rdb.XDel(ctx, \"demo-stream\", msg.ID).Result()`\n\n#### Redis **Stream 消息 ID** 和 **消息内容格式** \n\n##### ID 是怎么生成的？\n\nRedis Stream 的消息 ID 由两部分组成：\n\n```\n<ID> = <毫秒级时间戳>-<序列号>\n```\n\n比如：`1756907190367-1`\n\n- **1756907190367**：消息写入时的毫秒级时间戳（Unix epoch）。\n- **1**：同一毫秒内的顺序号（避免冲突）。\n\n举个例子：\n\n- 如果你在同一毫秒内调用两次 `XADD`：\n  - 第一次 → `1756907190367-0`\n  - 第二次 → `1756907190367-1`\n- 如果时间戳变了，就从 `-0` 开始。\n\n这个 ID 是 Redis 自动生成的（除非你手动指定），所以全局唯一，能保证消息顺序。\n\n------\n\n#####  2. 发送的消息内容是什么格式？\n\n在 Redis Stream 里，每条消息的内容本质是一个 **键值对集合**，类似于哈希表。\n\n在 Go 里，调用 `XAdd` 时传的就是一个 **`map[string]interface{}`**：\n\n```go\nid, _ := rdb.XAdd(ctx, &redis.XAddArgs{\n    Stream: \"demo-stream\",\n    Values: map[string]interface{}{\n        \"user\": \"alice\",\n        \"msg\":  \"hello world\",\n    },\n}).Result()\n```\n\nRedis 里存的就是：\n\n```\nID=1756907190367-1\nuser => alice\nmsg  => hello world\n```\n\n------\n\n#####  3. 那么，能不能直接发 JSON？\n\n可以的，但 Redis 本身不会帮你序列化 JSON。你需要在 Go 里手动把对象转成 JSON 字符串，再存进去：\n\n```go\nimport \"encoding/json\"\n\n// 假设有一个结构体\ntype Message struct {\n    User string `json:\"user\"`\n    Msg  string `json:\"msg\"`\n}\n\nm := Message{User: \"alice\", Msg: \"hello world\"}\njsonData, _ := json.Marshal(m)\n\nid, _ := rdb.XAdd(ctx, &redis.XAddArgs{\n    Stream: \"demo-stream\",\n    Values: map[string]interface{}{\n        \"data\": string(jsonData), // 存 JSON 字符串\n    },\n}).Result()\n```\n\nRedis 里就是：\n\n```\nID=1756907190367-1\ndata => {\"user\":\"alice\",\"msg\":\"hello world\"}\n```\n\n读取时再 `json.Unmarshal` 回 Go 结构体即可。\n\n------\n\n#####  4. 总结\n\n- **ID**：`<毫秒时间戳>-<同毫秒内的序列号>`，Redis 自动生成，保证顺序。\n- **消息体**：一个 `map[string]interface{}`，可以存多个字段。\n- 如果想发 JSON，就把 JSON 当成一个字符串存到 map 的 value 里。\n","tags":["protected","Redis"],"categories":["Redis"]},{"title":"Linux 命令大全","url":"/2025/07/27/Linux 命令大全/","content":"\n# Linux 命令大全\n\n![Linux 命令大全](./Image/Linux命令大全.assets/cover-linux-commands-tutorial.webp)\n\n这里收集并整理各种实用的 Linux 命令，大致分为如下几大类。\n\n### 文件管理\n\nawk、chmod、diff、find、less、mc、patch、rm、tar、umask、wc、zip、cat、chown、echo、grep、ln、more、read、sed、tee、unzip、xz、chattr、cp、file、head、locate、mv、tail、touch、vim、zcat ......\n\n### 磁盘管理\n\nblkid、df、eject、lsblk、mkfs、popd、stat、sync、cd、dirs、fdisk、ls、mount、pushd、rsync、swapoff、tree、dd、du、fsck、mkdir、parted、pwd、sfdisk、swapon、umount ......\n\n### 进程管理\n\nbg、fg、ipcs、killall、lsof、nohup、pidof、ps、renice、top、chrt、htop、jobs、kill、nice、pgrep、pkill、taskset ......\n\n### 系统管理\n\naddgroup、delgroup、fbset、history、lsb_release、nproc、rmmod、sysctl、uptime、whois、adduser、deluser、getcap、hwclock、lscpu、passwd、screen、systemctl、useradd、who、chroot、depmod、getconf、id、lsmod、poweroff、setcap、timedatectl、userdel、chsh、dmesg、groupadd、insmod、modinfo、printenv、shutdown、time、usermod、crontab、env、groupdel、last、modprobe、sudo、type、watch、date、export、groupmod、locale、neofetch、reboot、su、unset、whoami ......\n\n### 网络管理\n\narp、ftp、ip、nethogs、nmap、ntop、route、ss、trippy、curl、ifconfig、iptables、netstat、nmcli、ntopng、scp、tcpdump、ufw、dig、ifstat、mtr、networkctl、nm-connection-editor、ping、socat、tcptrack、wget、ethr、iftop、nc、nfsstat、nmtui、pppd、speedtest、telnet、wvdialconf、ethtool、iperf、netcat、nload、nslookup、ssh、traceroute、wvdial ......\n\n### 设备管理\n\ngpiodetect、gpioinfo、i2cdetect、i2cset、lspci、minicom、ppsctl、spi-pipe、usb_modeswitch、gpiofind、gpiomon、i2cdump、i2ctransfer、lsusb、mmc、stty、xrandr、gpioget、gpioset、i2cget、lshw、microcom、modpoll、spi-config、udevadm ......\n\n### 系统监控\n\ndmidecode、free、iostat、numactl、pmap、smartctl、vmstat ......\n\n### 系统服务\n\nchronyc、chronyd ......\n\n### 包管理工具\n\napt-cache、apt-config、apt-get、apt、dnf、dpkg、flatpak、pkg、snap、yum ......\n\n### 开发工具\n\ngcc、install、ldconfig、ldd、nm、objdump、readelf、size ......\n\n### 调试工具\n\ncyclitest、declare、hexdump、ltrace、memtester、seq、strace、timeout ......\n\n### 实用工具\n\nascii、convert、dos2unix、gpsd、jq、phc_ctl、pv、redshift、capinfos、cwebp、dwebp、gpsmon、mergecap、pmc、qrencode、ronn、cgps、debootstrap、editcap、gpspipe、phc2sys、ptp4l ......\n\n### 音视频\n\nalsamixer、amixer、aplay、arecord ......\n\n### 命令帮助\n\ncommand、info、man、whatis、whereis、which ......\n\n提示\n\n注意：命令的选项参数和功能可能会因 Linux 发行版而有所不同，建议查阅相应发行版的文档以获取详细信息。\n\n\n\n# Linux apt 命令 - APT软件包管理工具\n\n## 介绍\n\n**apt**（英文全拼：Advanced Packaging Tool）是 Debian/Ubuntu 系统中的 Shell 前端软件包管理器。该命令提供了查找、安装、升级、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。\n\n提示：apt 命令执行需要超级管理员权限（root）。\n\n**语法**：\n\n```bash\napt [options] [command] [package ...]\n```\n\n\n\n**选项**：\n\n- ```\n  options\n  ```\n\n   \n\n  ：可选选项，例如：\n\n  - `-h` ：显示帮助信息。\n  - `-y` ：将安装过程中所有提示选择设为 yes。\n  - `-q` ：不显示安装的过程等等。\n\n- ```\n  command\n  ```\n\n   \n\n  ：要进行的操作，例如：\n\n  - `update` ：更新软件包索引信息。\n  - `upgrade` ：升级当前已安装的软件包（如果可更新）。\n  - `full-upgrade` ：升级当前已安装的软件包（升级前先删除需要更新软件包）。\n  - `install` ：安装软件包。\n  - `reinstall` ：重新安装软件包。\n  - `remove` ：卸载软件包（保留软件的配置文件）。\n  - `purge` ：卸载软件包（不保留软件的配置文件）。\n  - `autoremove` ：清理不再使用的依赖和库文件。\n  - `satisfy` ：使系统满足依赖关系字符串（Apt 1.9 的新命令）。\n  - `search` ：查找软件包。\n  - `show` ：显示软件包具体信息，例如版本号、安装大小、依赖关系等信息。\n  - `list` ：列出可更新的软件包及版本信息。\n  - `edit-sources` ：编辑 sources.list 配置文件。\n\n- `package` ：安装的包名。\n\n提示：在使用 apt 命令时，如果不太记得完整的软件包名称，可以只输入前面一部分的字符，然后按下 **Tab** 键自动搜索和补全。\n\n## 示例\n\n更新软件包索引信息（可通过该方式查看近期可更新的软件包）\n\n```bash\nsudo apt update\n```\n\n\n\n更新软件包索引信息后升级软件包（使用 yes 选项）\n\n```bash\nsudo apt update && sudo apt upgrade -y\n```\n\n\n\n安装 vim 软件包\n\n```bash\nsudo apt install vim\n```\n\n\n\n安装 vim 软件包，如果软件包已经存在，则不要升级它\n\n```bash\nsudo apt install vim --no-upgrade\n```\n\n\n\n只升级 vim 软件包，如果不存在就不要安装它\n\n```bash\nsudo apt install vim --only-upgrade\n```\n\n\n\n安装指定软件包版本（**package_name** 为包名，**version_number** 为版本号。）\n\n```bash\nsudo apt install <package_name>=<version_number>\n```\n\n\n\n卸载 vim 软件包\n\n```bash\nsudo apt remove vim\n```\n\n\n\n查找名为 libiphone 的相关包\n\n```bash\napt search libiphone\n```\n\n\n\n查看 vim 包的相关信息\n\n```bash\napt show vim\n```\n\n\n\n列出所有已安装的软件包的版本信息\n\n```bash\napt list --all-versions\n```\n\n\n\n列出所有已安装的软件包\n\n```bash\napt list --installed\n```\n\n\n\n列出可更新的软件包及版本信息\n\n```bash\napt list --upgradeable\n```\n\n\n\n\n\n# Linux apt-get 命令 - APT软件包管理工具\n\n## 介绍\n\n**apt-get** 是基于 Debian 的操作系统（包括 Debian、Ubuntu、Linux Mint 等）中用来安装和卸载软件的包管理器命令。主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。\n\n注意\n\n老版本的 Linux 系统只支持 apt-get 命令，在新版本的 Linux 系统中，[apt](https://getiot.tech/linux-command/apt/) 集成了 apt-get、apt-cache 的常用命令，因此可用 apt 命令代替 apt-get 命令。\n\n提示：apt-get 命令执行需要超级管理员权限（root）。\n\n**语法**：\n\n```bash\napt-get [options] [command] [package ...]\n```\n\n\n\n**选项**：\n\n- `-h, --help`：查看帮助文档。\n- `-v, --version`：查看 apt-get 的版本。\n- `-y`：在需要确认的场景中回应 yes。\n- `-s, --dry-run`：模拟执行并输出结果。\n- `-d, --download-only`：把包下载到缓存中而不安装。\n- `--only-upgrade`：更新当前版本的包而不是安装新的版本。\n- `--no-upgrade`：在执行 install 命令时，不安装已安装包的更新。\n- `-q, --quiet`：减少输出。\n- `--purge`：配合 remove 命令删除包的配置文件。\n- `--reinstall`：重新安装已安装的包或其新版本。\n\n**子命令**：\n\n- **update**\n\n  update 命令用于更新软件包索引文件，/etc/apt/sources.list 文件中的配置指定了软件包索引文件的来源。更新了包索引文件后就可以得到可用的包的更新信息和新的包信息。于是系统就知道有哪些软件的哪些版本可以从什么地方（源）下载安装。在安装或升级软件包之前先执行 update 命令是一个好习惯。\n\n- **install**\n\n  install 命令用于安装或者升级软件包。每个软件包都有一个包名，执行子命令时需要指定包名。在安装时，该软件包所依赖的包也将被安装。\n\n- **upgrade**\n\n  upgrade 命令用于从 /etc/apt/sources.list 中列出的源安装系统上当前安装的所有包的最新版本。在任何情况下，当前安装的软件包都不会被删除，尚未安装的软件包也不会被检索和安装。如果当前安装的软件包的新版本不能在不更改另一个软件包的安装状态的情况下升级，则将保留当前版本。必须提前执行 update 命令以便 apt-get 知道已安装的包是否有新版本可用。\n\n  注意 update 与 upgrade 的区别：update 是更新软件列表，upgrade 是更新软件。\n\n- **dist-upgrade**\n\n  除执行升级功能外，dist-upgrade 还智能地处理与新版本软件包的依赖关系的变化。apt-get 有一个 \"智能\" 的冲突解决系统，如果有必要，它将尝试升级最重要的包，以牺牲不那么重要的包为代价。因此，distr -upgrade 命令可能会删除一些包。因此在更新系统中的包时，建议按顺序执行下面的命令：\n\n  ```bash\n  $ apt-get update\n  $ apt-get upgrade -y\n  $ apt-get dis-upgrade -y\n  ```\n\n  \n\n- **remove**\n\n  remove 是 install 的反向操作，即删除软件包。值得一提的是，使用 remove 命令删除一个软件包时，会将其配置文件留在系统上。\n\n- **purge**\n\n  purge 命令与 remove 命令类似，purge 命令在删除包的同时也删除了包的配置文件。\n\n- **autoremove**\n\n  autoremove 命令用于删除自动安装的软件包，这些软件包当初是为了满足其他软件包对它的依赖关系而安装的，而现在已经不再需要了。\n\n- **download**\n\n  download 命令把指定包的二进制文件下载到当前目录中。注意，是类似 *.deb 这样的包文件。\n\n- **clean**\n\n  clean 命令清除在本地库中检索到的包。它从 /var/cache/apt/archives/ 和 /var/cache/apt/archives/partial/ 目录删除除锁文件之外的所有内容。\n\n- **autoclean**\n\n  与 clean 命令类似，autoclean 命令清除检索到的包文件的本地存储库。不同之处在于，它只删除不能再下载的软件包文件，而且这些文件在很大程度上是无用的。这允许长时间维护缓存，而不至于大小失控。\n\n- **source**\n\n  source 命令用于下载软件包的源代码。默认会下载最新可用版本的源代码到当前目录中。\n\n- **changelog**\n\n  changelog 命令尝试下载并显示软件包的更新日志。\n\n## 示例\n\n查看帮助文档：\n\n```bash\napt-get -h\n```\n\n\n\n更新包索引文件：\n\n```bash\nsudo apt-get update\n```\n\n\n\n安装 nginx 软件包：\n\n```bash\nsudo apt-get install nginx\n```\n\n\n\n安装 nginx 软件包，并在需要确认的场景中回应 yes：\n\n```bash\nsudo apt-get install -y nginx\n```\n\n\n\n更新指定的包（注意，不是通过 upgrade 命令完成的，而是使用 intall 命令）：\n\n```bash\nsudo apt-get install vim\n```\n\n\n\n重新安装已安装的包：\n\n```bash\nsudo apt-get install --reinstall curl\n```\n\n\n\n安装指定版本的包：\n\n```bash\nsudo apt-get install tree=1.7.0-5\n```\n\n\n\n把包下载到缓存中而不安装（把软件包的下载和安装步骤分开）：\n\n```bash\nsudo apt-get install -d nginx\nsudo apt-get upgrade -d\nsudo apt-get dist-upgrade -d\n```\n\n\n\n删除包（只删除程序文件，保留相关的配置文件）：\n\n```bash\nsudo apt-get remove vim\n```\n\n\n\n彻底清除包（同时删除程序文件及其配置文件）：\n\n```bash\nsudo apt-get purge vim\n```\n\n\n\n在执行 remove 命令时使用 --purge 选项的效果等同于执行 purge 命令：\n\n```bash\nsudo apt-get remove --purge vim\n```\n\n\n\n删除包后执行一下 autoremove，可以自动删除不再需要的软件包：\n\n```bash\nsudo apt-get autoremvoe\n```\n\n\n\n在执行 install/remove 命令时使用 --autoremove 选项，可以同时删除无用的依赖包，类似在执行完 install/remove 命令后再执行一次 autoremove 命令：\n\n```bash\nsudo apt-get remove --autoremove vim\n```\n\n\n\n清除系统中缓存的包安装文件：\n\n```bash\nsudo apt-get clean\n```\n\n\n\n自动清除不能再下载的软件包文件：\n\n```bash\nsudo apt-get autoclean\n```\n\n\n\n查看已安装包的更改日志：\n\n```bash\napt-get changelog tree\n```\n\n\n\n下载包的源代码：\n\n```bash\napt-get source tree\n```\n\n\n\n\n\n# Linux apt-config 命令 - 管理 APT 配置文件\n\n## 介绍\n\n**apt-config** 命令是 Debian 系操作系统（包括 Ubuntu）中用于显示或操作 APT（Advanced Package Tool）软件包管理系统配置项的工具。它允许用户查看 APT 的各种配置选项，包括软件源、包管理器的行为和其他相关设置。通过此命令，用户可以了解系统上 APT 的当前配置，并在需要时进行相应的调整。\n\n提示\n\napt-config 命令主要用于 Debug 和编写 Shell 脚本。\n\n**语法**：\n\n```bash\napt-config [选项] 命令\n```\n\n\n\n**常用命令**：\n\n- `shell`：通过 shell 求值来获取设置值。\n- `dump`：显示活动的设置选项。\n\n## 示例\n\n显示所有配置项\n\n```bash\napt-config dump\n```\n\n\n\n\n\n# Linux apt-cache 命令 - 查询软件包信息\n\n## 介绍\n\n**apt-cache** 命令是一个用于查询 APT 软件包缓存的工具，它提供了有关已安装或可用软件包的信息，包括软件包的描述、依赖关系、版本号、可用性等。它是 Debian 和基于 Debian 的 Linux 发行版（例如 Ubuntu）中 APT 软件包管理系统的一部分。\n\n**语法**：\n\n```bash\napt-cache [选项] 命令\napt-cache [选项] show 软件包1 [软件包2 ...]\n```\n\n\n\n**常用命令**：\n\n- `showsrc`：显示源文件的各项记录。\n- `search`：根据正则表达式搜索软件包列表。\n- `depends`：显示该软件包的依赖关系信息。\n- `rdepends`：显示所有依赖于该软件包的软件包名字。\n- `show`：以便于阅读的格式介绍该软件包。\n- `pkgnames`：列出所有软件包的名字。\n- `policy`：显示软件包的安装设置状态。\n\n## 示例\n\n搜索包含关键词的软件包\n\n```bash\napt-cache search firefox\n```\n\n\n\n显示特定软件包的详细信息\n\n```bash\napt-cache show firefox\n```\n\n\n\n\n\n# Linux dpkg 命令 - 管理 Debian 软件包\n\n## 介绍\n\n**dpkg**（英文全拼：Debian package）命令是 Debian Linux 系统用来安装、创建和管理软件包的实用工具。它是 Debian 软件包管理器的基础，由伊恩·默多克创建于1993年。\n\n从名称可以看出，dpkg 是专门为 Debian 开发的套件管理系统，方便软件的安装、更新及移除。实际上，所有源自 Debian 的 Linux 发行版都可以使用 dpkg 来管理软件包，例如 Ubuntu、Knoppix 等。\n\ndpkg 本身是一个底层的工具，被用于安装、卸载和查询 .deb 软件包相关的信息。上层的工具，如 apt 则被用于从远程获取软件包以及处理复杂的软件包关系。\n\n**语法**：\n\n```shell\ndpkg [option...] action\n```\n\n\n\n**选项**：\n\n- `-i`, `--install` ：安装软件包。\n- `-r`, `--remove` ：删除软件包。\n- `-l`, `--list` ：显示已安装软件包列表。\n- `-L`, `--listfiles` ：显示于软件包关联的文件。\n- `-c` ：显示软件包内文件列表。\n- `-?`, `--help` ：显示帮助信息。\n- `--version` ：显示版本信息。\n\n## 示例\n\n安装软件包\n\n```shell\ndpkg -i <package-file>\ndpkg -i helloworld_1.0.deb  # 以 helloworld_1.0.deb 软件包为例\n```\n\n\n\n安装一个目录（如 /usr/local/src）下面所有的软件包\n\n```bash\ndpkg -R /usr/local/src\n```\n\n\n\n释放软件包，但是不进行配置\n\n```bash\ndpkg --unpack <package-file>\n```\n\n\n\n重新配置和释放软件包\n\n```bash\ndpkg --configure <package-file>\n```\n\n\n\n卸载软件包（保留其配置信息）\n\n```shell\ndpkg -r <package-file>\n```\n\n\n\n卸载软件包（包括配置信息）\n\n```bash\ndpkg -P <package-file>\ndpkg --purge <package-file>\n```\n\n\n\n列出已安装的软件包\n\n```shell\ndpkg -l\ndpkg -l | grep helloworld # 在已安装的软件包中搜索 helloworld\n```\n\n\n\n列出软件包的内容（目录信息）\n\n```shell\ndpkg -c <package-file>\n```\n\n\n\n从软件包里面读取软件的信息\n\n```bash\ndpkg -A <package-file>\n```\n\n\n\n替代软件包的信息\n\n```bash\ndpkg --update-avail [Packages-file]\n```\n\n\n\n合并软件包信息\n\n```bash\ndpkg --merge-avail [Packages-file]\n```\n\n\n\n丢失所有的 Uninstall 的软件包信息\n\n```bash\ndpkg --forget-old-unavail\n```\n\n\n\n删除软件包的 Avaliable 信息\n\n```bash\ndpkg --clear-avail\n```\n\n\n\n查找只有部分安装的软件包信息\n\n```bash\ndpkg -C\n```\n\n\n\n比较同一个包的不同版本之间的差别\n\n```bash\ndpkg --compare-versions ver1 op ver2\n```\n\n\n\n创建一个 deb 文件\n\n```bash\ndpkg -b <directory> <package-file>\ndpkg --build <directory> <package-file>\n```\n\n\n\n显示一个 deb 软件包的描述信息\n\n```bash\ndpkg -I <package-file>\n```\n\n\n\n报告指定软件包的状态信息（是否已安装）\n\n```bash\ndpkg -s <package-file>\n```\n\n\n\n显示一个软件包安装到系统里面的文件目录信息（该软件包必须已安装）\n\n```bash\ndpkg -L <package-file>\ndpkg -L vim # 以 vim 为例\n```\n\n\n\n搜索指定软件包里面的文件（模糊查询）\n\n```bash\ndpkg -S <filename-search-pattern>\n```\n\n\n\n\n\n# Linux dnf 命令 - 软件包管理工具\n\n## 介绍\n\n**dnf**（Dandified Yum）是用于在基于 RPM 的 Linux 发行版中进行软件包管理的工具，如 Fedora、RHEL（Red Hat Enterprise Linux）以及它们的衍生发行版。值得一提的是，`dnf` 是 `yum` 的下一代版本，首次出现在 Fedora 18 这个发行版中，旨在提供更快的性能和更丰富的功能。\n\n**语法**：\n\n```bash\ndnf [参数]\n```\n\n\n\n**选项**：\n\n- `repolist`：显示系统中可用的 dnf 软件库。\n- `list`：列出用户系统上的所有来自软件库的可用软件包和所有已经安装在系统上的软件包。\n- `search <包名>`：搜索软件库中的软件包。\n- `provides <路径>`：查找某一文件的提供者。\n- `info <包名>`：查看软件包详情。\n- `install <包名>`：安装软件包。\n- `update <包名>`：升级软件包。\n- `check-update`：检查系统软件包的更新。\n- `update`：升级所有系统软件包。\n- `remove`：删除软件包。\n- `autoremove`：删除无用孤立的软件包。\n- `clean all`：删除缓存的无用软件包。\n- `help <命令名>`：获取有关某条命令的使用帮助。\n- `help`：查看所有的dnf命令及其用途。\n- `history`：查看dnf命令的执行历史。\n- `grouplist`：查看所有的软件包组。\n- `groupinstall <软件包组名称>`：安装一个软件包组。\n- `groupupdate <软件包组名称>`：升级一个软件包组中的软件包。\n- `groupremove <软件包组名称>`：删除一个软件包组。\n- `distro-sync`：更新软件包到最新的稳定发行版。\n- `reinstall <包名>`：重新安装特定软件包。\n- `downgrade <包名>`：回滚某个特定软件的版本。\n- `--version`：查看 dnf 包管理器版本。\n\n## 示例\n\n安装软件包（安装指定名称的软件包及其依赖项）：\n\n```bash\ndnf install <软件包名称>\n```\n\n\n\n将系统中所有已安装的软件包升级到最新版本：\n\n```bash\ndnf upgrade\n```\n\n\n\n搜索软件包：\n\n```bash\ndnf search <关键词>\n```\n\n\n\n显示软件包信息（包括版本、依赖关系等详细信息）：\n\n```bash\ndnf info <软件包名称>\n```\n\n\n\n移除软件包：\n\n```bash\ndnf remove <软件包名称>\n```\n\n\n\n检查可用更新：\n\n```bash\ndnf check-update\n```\n\n\n\n列出已安装软件包：\n\n```bash\ndnf list installed\n```\n\n\n\n清理 dnf 缓存（包括软件包和元数据）：\n\n```bash\ndnf clean all\n```\n\n\n\n列出软件包的文件信息：\n\n```bash\ndnf repoquery -l <软件包名称>\n```\n\n\n\n启用/禁用指定的软件仓库：\n\n```bash\ndnf config-manager --set-enabled <仓库名称>\ndnf config-manager --set-disabled <仓库名称>\n```\n\n\n\n\n\n# Linux yum 命令 - 管理 RPM 软件包\n\n## 介绍\n\n**yum** 是用于在基于 RPM 的 Linux 发行版（例如 RHEL、CentOS、Fedora 等）中进行软件包管理的工具。其作用包括安装、升级和删除 rpm 软件包、搜索和显示软件包信息、处理软件包的依赖关系，以及管理软件源配置等。\n\n提示\n\nyum 是“Yellowdog Updater, Modified”的缩写，其中的 “Yellow Dog” 是指由 Fixstars 公司发布 Yellow Dog Linux 发行版（最后一个版本是2012年8月发布的 7.0）。\n\n**语法**：\n\n```bash\nyum [command] [package ...]\n```\n\n\n\n**选项**：\n\n- `install`：安装一个或多个 rpm 软件包。\n- `update`：升级系统中所有已安装的 rpm 软件包。\n- `check-update`：检查系统中所有已安装的 rpm 软件包是否有可用的更新。\n- `remove`：卸载一个或多个已安装的 rpm 软件包。\n- `list`：列出已安装的软件包信息。\n- `search`：搜索可用的软件包。\n- `info`：显示指定的 rpm 软件包的描述信息和概要信息。\n- `clean`：清理 yum 过期的缓存。\n- `shell`：进入 yum 的 shell 交互界面。\n- `resolvedep`：显示 rpm 软件包的依赖关系。\n- `localinstall`：安装本地的 rpm 软件包。\n- `localupdate`：显示本地 rpm 软件包进行更新。\n- `deplist`：显示 rpm 软件包的所有依赖关系。\n- `provides`：查询某个程序所在安装包。\n\n## 示例\n\n安装 nginx 软件包：\n\n```bash\nsudo yum install nginx\n```\n\n\n\n升级所有已安装的软件包：\n\n```bash\nsudo yum update\n```\n\n\n\n删除已安装的 nginx 软件包：\n\n```bash\nsudo yum remove nginx\n```\n\n\n\n查询 nginx 软件包信息：\n\n```bash\nyum info nginx\n```\n\n\n\n搜索可用的软件包（例如 apache）：\n\n```bash\nyum search apache\n```\n\n\n\n显示已安装软件包列表：\n\n```bash\nyum list installed\n```\n\n\n\n检查系统中所有已安装软件包是否有可用的更新：\n\n```bash\nyum check-update\n```\n\n\n\n\n\n# Linux pkg 命令 - 管理 FreeBSD 软件包\n\n## 介绍\n\n**pkg** 命令是 FreeBSD 操作系统中用于管理软件包的工具，包括安装、升级、删除软件包，以及查询软件包信息等功能。\n\n**语法**：\n\n```bash\npkg [command] [package ...]\n```\n\n\n\n**选项**：\n\n- `-i, install`：安装一个或多个软件包。\n- `-u, upgrade`：升级已安装的软件包。\n- `-r, remove`：卸载一个或多个已安装的软件包。\n- `-f, fetch`：下载软件包但不安装。\n- `-l, list`：列出已安装的软件包。\n- `-s, search`：搜索可用的软件包。\n- `-I, info`：显示软件包的详细信息。\n- `-q, query`：查询已安装文件属于哪个软件包。\n\n## 示例\n\n安装 nginx 软件包：\n\n```bash\nsudo pkg install nginx\n```\n\n\n\n升级系统中所有已安装的软件包：\n\n```bash\nsudo pkg upgrade\n```\n\n\n\n卸载已安装的 nginx 软件包：\n\n```bash\nsudo pkg remove nginx\n```\n\n\n\n查询软件包信息：\n\n```bash\npkg info nginx\n```\n\n\n\n搜索可用的软件包（例如 apache）：\n\n```bash\npkg search apache\n```\n\n\n\n显示已安装软件包列表：\n\n```bash\npkg list\n```\n\n\n\n查询 `/usr/local/bin/nginx` 文件属于哪个软件包：\n\n```bash\npkg query %n /usr/local/bin/nginx\n```\n\n\n\n\n\n# Linux flatpak 命令 - 管理 Flatpak 应用程序\n\n## 介绍\n\n**flatpak** 是各种不同的 Linux 发行版上分发和运行应用程序的全新打包格式，并且使用该格式打包的软件可安全运行。你可以访问[官网](https://flatpak.org/)以获得关于 flatpak 打包格式的详细介绍。\n\n想要在你的计算机上体验 Flatpak 格式的安装包，首先需要安装 flatpak 命令，它通常不会预先安装，但可在大多数 Linux 发行版的默认仓库中找到。例如，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install flatpak\n```\n\n\n\n**语法**：\n\n```bash\nflatpak [OPTION...] {COMMAND}\n```\n\n\n\n**选项**：\n\n- `-h`, `--help`：显示帮助信息并退出。Show help options and exit.\n- `-v`, `--verbose`：在命令处理期间打印调试信息。使用 -vv 获取更多详细信息。\n- `--ostree-verbose`：在命令处理期间打印 OSTree 调试信息。\n- `--version`：打印版本信息并退出。\n- `--default-arch`：打印默认的体系架构（如 x86_64 ）并退出。\n- `--supported-arches`：按优先顺序打印支持的体系架构并退出。\n- `--gl-drivers`：打印活动的 GL 驱动程序列表并退出。\n\n**命令**：\n\n| Flatpak 命令                  | 描述                                             |\n| ----------------------------- | ------------------------------------------------ |\n| `flatpak build-bundle`        | 从本地存储库创建单文件包。                       |\n| `flatpak build-commit-from`   | 基于现有提交（可能来自另一个存储库）创建新提交。 |\n| `flatpak build-export`        | 从构建目录创建存储库。                           |\n| `flatpak build-finish`        | 完成构建目录。                                   |\n| `flatpak build-import-bundle` | 将文件包导入本地存储库。                         |\n| `flatpak build-init`          | 初始化构建目录。                                 |\n| `flatpak build-sign`          | 签署应用程序或运行时。                           |\n| `flatpak build-update-repo`   | 从构建目录创建存储库。                           |\n| `flatpak build`               | 在目录中构建。                                   |\n| `flatpak config`              | 管理配置。                                       |\n| `flatpak create-usb`          | 将应用程序和/或运行时复制到可移动媒体上。        |\n| `flatpak document-export`     | 将文件导出到沙盒应用程序。                       |\n| `flatpak document-info`       | 显示有关导出文件的信息。                         |\n| `flatpak document-list`       | 列出导出的文件。                                 |\n| `flatpak document-unexport`   | 停止导出文件。                                   |\n| `flatpak permission-remove`   | 列出权限。                                       |\n| `flatpak permission-list`     | 列出权限。                                       |\n| `flatpak permission-show`     | 列出权限。                                       |\n| `flatpak permission-reset`    | 重置权限。                                       |\n| `flatpak enter`               | 输入应用程序。                                   |\n| `flatpak info`                | 显示有关已安装应用程序或运行时的信息。           |\n| `flatpak install`             | 安装应用程序或运行时。                           |\n| `flatpak list`                | 列出已安装的应用程序和/或运行时。                |\n| `flatpak make-current`        | 使特定版本的应用程序成为最新版本。               |\n| `flatpak override`            | 覆盖应用程序要求。                               |\n| `flatpak remote-add`          | 添加远程仓库。                                   |\n| `flatpak remote-delete`       | 删除远程仓库。                                   |\n| `flatpak remote-info`         | 在远程显示有关应用程序或运行时的信息。           |\n| `flatpak remote-ls`           | 显示可用的运行时和应用程序。                     |\n| `flatpak remote-modify`       | 修改远程仓库。                                   |\n| `flatpak remotes`             | 列出远程仓库。                                   |\n| `flatpak repair`              | 修复 flatpak 安装。                              |\n| `flatpak repo`                | 显示有关本地存储库的信息。                       |\n| `flatpak run`                 | 在 runtime 中运行应用程序或打开 shell。          |\n| `flatpak search`              | 搜索应用程序和运行时。                           |\n| `flatpak uninstall`           | 卸载应用程序或运行时。                           |\n| `flatpak update`              | 更新应用程序或运行时。                           |\n\n## 示例\n\n列出在系统中已经配置好远程仓库：\n\n```bash\nflatpak remotes\n```\n\n\n\n使用 `.flatpakrepo` 文件添加远程仓库：（ `.flatpakrepo` 文件包含远程仓库的信息和 GPG 秘钥）\n\n```bash\nflatpak remote-add --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo\n```\n\n\n\n移除远程仓库 flathub：\n\n```bash\nflatpak remote-delete flathub\n```\n\n\n\n查找远程仓库中的 GIMP 应用：\n\n```bash\nflatpak search gimp\n```\n\n\n\n以 Flatpak 包的形式安装 GIMP 图像处理软件：\n\n```bash\nflatpak install https://flathub.org/repo/appstream/org.gimp.GIMP.flatpakref\n```\n\n\n\n\n\n# Linux snap 命令 - 管理 Snap 应用包\n\n## 介绍\n\n**Snap** 是 Canonical（开发 Ubuntu 系统的公司）推出的一种新的软件打包格式，其目的是为了彻底解决 Linux 依赖性的问题，Snap 软件包拥有更加稳定和安全的特性。同时，snap 也是 Linux 上安装 snap 软件包的命令。\n\n如果你使用的是 Ubuntu 16.04 LTS 或更高版本，那么可以直接使用 snap 命令，无需额外安装。\n\n**语法**：\n\n```bash\nsnap <command> [<options>...]\n```\n\n\n\n## 示例\n\nsnap 显示已安装的 snap 软件的基本信息：\n\n```bash\nsnap list\n```\n\n\n\nsnap 搜索包（在应用商店搜索）：\n\n```bash\nsnap find <package_name>\n```\n\n\n\nsnap 安装一个包：\n\n```bash\nsnap install <package_name>\n```\n\n\n\nsnap 更新所有软件包：\n\n```bash\nsnap refresh\n```\n\n\n\nsnap 更新指定软件包：\n\n```bash\nsnap refresh <package_name>\n```\n\n\n\nsnap 卸载软件包：\n\n```bash\nsnap remove <package_name>\n```\n\n\n\nsnap 检查系统中最近的快照更改：\n\n```bash\nsnap changes\n```\n\n\n\nsnap 还原到以前安装的版本：\n\n```bash\nsnap revert <package_name>\n```\n\n\n\n注意：部分 snap 命令需要添加 sudo 增加 root 权限。\n\n\n\n# Linux man 命令 - 查看命令手册页\n\n## 介绍\n\n**man**（英文全拼：manuals）命令用于列出指定命令的说明文档，内容包括命令描述、语法、选项说明及相关命令等。\n\n实际上，man 不仅可用于查看命令的使用手册，也可以查看软件服务配置文件、系统调用、库函数等帮助信息。\n\nman 手册页文件存放在 /usr/share/man 目录下。\n\n**语法**：\n\n```bash\nman [选项...] [章节] 手册页...\n```\n\n\n\n**选项**：\n\n- `-f`, `--whatis` ：等同于 whatis。\n- `-k`, `--apropos` ：等同于 apropos。\n- `-K`, `--global-apropos` ：在所有页面中搜索文字。\n- `-l`, `--local-file` ：把“手册页”参数当成本地文件名来解读。\n- `-w`, `--where`, `--path`, `--location` ：输出手册页的物理位置。\n- `-W`, `--where-cat`, `--location-cat` ：输出 cat 文件的物理位置。\n- `-c`, `--catman` ：由 catman 使用，用来对过时的 cat 页重新排版。\n- `-R`, `--recode=编码` ：以指定编码输出手册页源码。\n\n**章节**：\n\n| 章节号 | 说明                                        |\n| ------ | ------------------------------------------- |\n| 1      | 可执行程序或 shell 命令                     |\n| 2      | 系统调用（内核提供的函数）                  |\n| 3      | 库调用（程序库中的函数）                    |\n| 4      | 特殊文件（通常位于 /dev）                   |\n| 5      | 文件格式和约定，例如 /etc/passwd            |\n| 6      | 游戏                                        |\n| 7      | 杂项（包括宏包和规范，如 man(7)，groff(7)） |\n| 8      | 系统管理命令（通常只针对 root 用户）        |\n| 9      | 内核例程 （非标准）                         |\n\n## 示例\n\n查看 man 命令本身的用法\n\n```bash\nman man\n```\n\n\n\n将会打开一个字符阅读器，按 Enter 键或 Down 键逐行下翻，按 Up 键逐行上翻，按 q 键退出。\n\n查看 cp 命令的用法\n\n```bash\nman cp\n```\n\n\n\n查看 /etc/passwd 文件信息\n\n```bash\nman /etc/passwd\n```\n\n\n\n查看 chown 函数的用法（而不是 chown 命令，数字 2 指定章节不可忽略）\n\n```bash\nman 2 chown\n```\n\n\n\n查看线程创建函数的用法（数字 3 指定章节可忽略）\n\n```bash\nman 3 pthread_create\n```\n\n\n\n\n\n# Linux info 命令 - 查看命令和程序的文档\n\n## 介绍\n\n**info**（英文全拼：informations）命令用于阅读 Linux 下 info 格式的帮助信息。\n\n就内容来说，info 页面比 [man](https://getiot.tech/linux-command/man/) page 编写得要更好、更容易理解，也更友好，并支持链接跳转功能。但 man page 使用起来更容易，一个 man page 只有一页，而 info 页面则将内容组织成多个区段（称为节点），每个区段也可能包含子区段（称为子节点）。因此掌握 info 命令，需要学习如何在单独的 info 页面中浏览导航，以及如何在节点和子节点之间切换。\n\ninfo 文档存放在 /usr/share/info 目录中，该目录提供了整个软件包的帮助文档。\n\n**语法**：\n\n```bash\ninfo [选项] [参数]\n```\n\n\n\n**选项**：\n\n- `-d` ：添加包含 info 格式帮助文档的目录。\n- `-f` ：指定要读取的 info 格式的帮助文档。\n- `-n` ：指定首先访问的 info 帮助文件的节点。\n- `-o` ：输出被选择的节点内容到指定文件。\n- `-w` ：显示 info 文档的物理位置。\n\n**参数**：指定需要获得帮助的主题，可以是指令、函数或配置文件。\n\n## 示例\n\n查看 Automake 手册\n\n```bash\ninfo Automake\n```\n\n\n\n查看 info 命令本身的 info 文档\n\n```bash\ninfo info\n```\n\n\n\n显示 ls 命令 info 文档的位置\n\n```bash\ninfo -w ls\n```\n\n\n\n\n\n# Linux whatis 命令 - 显示命令简要说明\n\n## 介绍\n\n**whatis** 命令是用于查询一个命令执行什么功能，并将查询结果打印到终端上。\n\nwhatis 命令在用 `catman` 命令创建的数据库中查找选项参数中指定的命令、系统调用、库函数或特殊文件名。实际上，whatis 命令显示手册部分的页眉行，等同于使用 `man -f` 命令。\n\n简单来说，如果你想知道某个不熟悉命令是干什么用的，那么可以使用 whatis 命令来快速查看。\n\n**语法**：\n\n```bash\nwhatis [选项...] 关键词...\n```\n\n\n\n**选项**：\n\n- `-d`, `--debug` ：输出调试信息。\n- `-v`, `--verbose` ：输出详细的警告信息。\n- `-r`, `--regex` ：把每个关键词都当作正则表达式解读。\n- `-w`, `--wildcard` ：关键词里包含通配符。\n- `-l`, `--long` ：不要把输出按终端宽度截断。\n- `-C`, `--config-file=文件` ：使用该用户设置文件。\n- `-L`, `--locale=区域` ：定义本次搜索所使用的区域设置。\n- `-m`, `--systems=系统` ：使用来自其它系统的手册页。\n- `-M`, `--manpath=路径` ：设置搜索手册页的路径为 PATH。\n- `-s`, `--sections=列表`, `--section=列表` ：仅在这些分区中搜索（冒号分隔）。\n- `-?`, `--help` ：显示帮助列表。\n- `--usage` ：显示一份简洁的用法信息。\n- `-V`, `--version` ：显示版本信息。\n\n## 示例\n\n查看 ls 命令的功能\n\n```bash\n$ whatis ls\nls (1)               - list directory contents\n```\n\n\n\n查看 cp 命令的功能\n\n```bash\n$ whatis cp\ncp (1)               - copy files and directories\n```\n\n\n\n查看 chown 命令的功能\n\n```bash\n$ whatis chown\nchown (1)            - change file owner and group\nchown (2)            - change ownership of a file\n```\n\n\n\n查看 man 命令的功能\n\n```bash\n$ whatis man\nman (1)              - an interface to the system reference manuals\nman (7)              - macros to format man pages\n```\n\n\n\n\n\n# Linux whereis 命令 - 查找命令的路径和相关文件\n\n## 介绍\n\n**whereis** 命令用来定位命令的二进制程序、源代码文件和 man 手册页等相关文件的路径。\n\nwhereis 命令查找速度非常快，因为它不是在磁盘中乱找，而是在一个数据库中查询；数据库是 linux 系统自动创建的，包含有本地所有文件的信息，并且每天通过自动执行 updatedb 命令更新一次。正因为这样，whereis 命令的搜索结果有时候会不准确，比如刚添加的文件可能搜不到， 原因就是该数据库文件没有被更新。\n\n注意：该指令只能用于查找二进制文件、源代码文件和 man手册页，一般文件的定位需使用 [locate](https://getiot.tech/linux-command/locate/) 命令。\n\n**语法**：\n\n```bash\nwhereis [options] [-BMS directory... -f] name...\n```\n\n\n\n**选项**：\n\n- `-b` ：只查找二进制文件。\n- `-B <目录>` ：只在设置的目录下查找二进制文件。\n- `-f` ：不显示文件名前的路径名称。\n- `-m` ：只查找说明文件。\n- `-M <目录>` ：只在设置的目录下查找说明文件。\n- `-s` ：只查找原始代码文件。\n- `-S <目录>` ：只在设置的目录下查找原始代码文件。\n- `-u` ：查找不包含指定类型的文件。\n\n## 示例\n\n查看 ssh 程序的位置\n\n```bash\n$ whereis ssh\nssh: /usr/bin/ssh /etc/ssh /usr/share/man/man1/ssh.1.gz\n```\n\n\n\n查看 ssh 的二进制程序的路径\n\n```bash\n$ whereis -b ssh\nssh: /usr/bin/ssh /etc/ssh\n```\n\n\n\n查看 ssh 命令的 man 手册页的路径\n\n```bash\n$ whereis -m ssh\nssh: /usr/share/man/man1/ssh.1.gz\n```\n\n\n\n\n\n# Linux which 命令 - 查找命令的完整路径\n\n## 介绍\n\n**which** 命令的作用是在 PATH 变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。\n\n运维人员在日常工作中经常使用 which 命令来检查某个系统命令是否存在，或者找出所执行命令所对应的具体位置。\n\n**语法**：\n\n```bash\nwhich [-a] filename ...\n```\n\n\n\n**选项**：\n\n- `-a` ：显示所有匹配的路径名\n\n## 示例\n\n查找 mysql 命令的路径\n\n```bash\n$ which mysql\n/usr/bin/mysql\n```\n\n\n\n查看所有匹配 mysql 的路径\n\n```bash\n$ which -a mysql\n/usr/bin/mysql\n/bin/mysql\n```\n\n\n\n\n\n# Linux command 命令 - 执行外部命令\n\n## 介绍\n\n**command** 命令用于执行一个简单命令或者显示命令的相关信息。command 命令可带 ARGS 参数运行指定的命令且抑制 shell 函数查询或显示。也就是说，当系统内定义了与 Linux 命令相同的函数时，使用 command 命令忽略 shell 函数，而执行相应的 Linux 命令。\n\n**语法：**\n\n```bash\ncommand [-pVv] 命令 [参数 ...]\n```\n\n\n\n**选项：**\n\n- `-p`：搜索命令对应的路径，使用 PATH 变量的一个默认值以确保所有的标准工具都能被找到。\n- `-V`：不执行命令，而是搜索命令并打印命令的详细描述。\n- `-v`：不执行命令，但搜索命令和打印命令的描述，和 [type](https://getiot.tech/linux-command/type/) 内建命令相似。\n\n## 示例\n\n使用 command 命令调用执行 echo 命令\n\n```bash\n$ command echo GetIoT.tech\nGetIoT.tech\n```\n\n\n\n搜索 nvm 命令，可用作检查 nvm 是否安装成功\n\n```bash\n$ command -v nvm\nnvm\n```\n\n\n\n搜索 free 命令并显示详细信息\n\n```bash\n$ command -V free\nfree 是 /usr/bin/free\n```\n\n\n\n搜索 fdisk 命令对应的路径\n\n```bash\n$ command -p fdisk\n命令 'fdisk' 可在以下位置找到\n * /sbin/fdisk\n * /usr/sbin/fdisk\nfdisk：未找到命令\n```\n\n\n\n\n\n# Linux ascii 命令 - 显示字符的 ASCII 码\n\n## 介绍\n\n**ascii** 命令用于查询 [ASCII 码字符](https://getiot.tech/computerbasics/ascii/) 与字节（数字）的对应关系。\n\n**语法**：\n\n```bash\nascii [-dxohv] [-t] [char-alias...]\n```\n\n\n\n**选项**：\n\n- `-t` ：脚本友好模式，仅返回字符的 ISO、十进制、十六进制、八进制、二进制编码。\n- `-s` ：解析多个字符，解析字符串的便捷方式。\n- `-a` ：以垂直方向（4 列 x 16 行）而不是默认的 16 行 x 4 列打印。此选项仅与 -d -o -x -b 组合，并且必须在它们之前。\n- `-d` ：以十进制输出 ASCII 表。\n- `-x` ：以十六进制输出 ASCII 表。\n- `-o` ：以八进制输出 ASCII 表。\n- `-b` ：以二进制输出 ASCII 表。\n- `-h`, `-?` ：显示帮助信息，并输出一个简单的 ASCII 表。\n- `-v` ：显示版本信息。\n\n**参数**：字符或字符串。\n\n## 示例\n\n以十进制输出 ASCII 表\n\n```bash\n$ ascii -d\n```\n\n\n\n输出如下：\n\n```bash\n    0 NUL    16 DLE    32      48 0    64 @    80 P    96 `   112 p \n    1 SOH    17 DC1    33 !    49 1    65 A    81 Q    97 a   113 q \n    2 STX    18 DC2    34 \"    50 2    66 B    82 R    98 b   114 r \n    3 ETX    19 DC3    35 #    51 3    67 C    83 S    99 c   115 s \n    4 EOT    20 DC4    36 $    52 4    68 D    84 T   100 d   116 t \n    5 ENQ    21 NAK    37 %    53 5    69 E    85 U   101 e   117 u \n    6 ACK    22 SYN    38 &    54 6    70 F    86 V   102 f   118 v \n    7 BEL    23 ETB    39 '    55 7    71 G    87 W   103 g   119 w \n    8 BS     24 CAN    40 (    56 8    72 H    88 X   104 h   120 x \n    9 HT     25 EM     41 )    57 9    73 I    89 Y   105 i   121 y \n   10 LF     26 SUB    42 *    58 :    74 J    90 Z   106 j   122 z \n   11 VT     27 ESC    43 +    59 ;    75 K    91 [   107 k   123 { \n   12 FF     28 FS     44 ,    60 <    76 L    92 \\   108 l   124 | \n   13 CR     29 GS     45 -    61 =    77 M    93 ]   109 m   125 } \n   14 SO     30 RS     46 .    62 >    78 N    94 ^   110 n   126 ~ \n   15 SI     31 US     47 /    63 ?    79 O    95 _   111 o   127 DEL\n```\n\n\n\n查询字符 R 对应的 ASCII 编码\n\n```bash\n$ ascii -t \"R\"\n5/2   82   0x52   0o122   01010010\n```\n\n\n\n其中第一列表示字符 R 位于 ASCII 表的第5列第2行（从0开始），第二列表示其对应的十进制编码，第三列表示其对应的十六进制编码，第四列表示其对应的八进制编码，第五列表示其对应的二进制编码。\n\n查询字符串 \"getiot\" 对应的 ASCII 编码\n\n```bash\n$ ascii -s \"getiot\"\n6/7   103   0x67   0o147   01100111\n6/5   101   0x65   0o145   01100101\n7/4   116   0x74   0o164   01110100\n6/9   105   0x69   0o151   01101001\n6/15   111   0x6F   0o157   01101111\n7/4   116   0x74   0o164   01110100\n```\n\n\n\n\n\n# Linux convert 命令 - 图像格式转换工具\n\n## 介绍\n\n**convert** 命令用于对图像进行转换，支持包括转换图像格式、调整图像大小、模糊、裁剪、翻转、合并等功能。\n\nconvert 命令由 [ImageMagick](https://imagemagick.org/index.php) 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install imagemagick\n```\n\n\n\n**语法**：\n\n```bash\nconvert [input-option] input-file [output-option] output-file\n```\n\n\n\n## 示例\n\nConvert 的 resize 子命令应该是在 ImageMagick 中使用较多的命令，它实现了图片任意大小的缩放，唯一需要掌握的就是如何使用它的一些参数测试设定值：\n\n此说明文件中所用的原始文件（src.png），宽度：400，高度：300\n\n```bash\n$ file src.png \nsrc.png: PNG image data, 400 x 300, 8-bit/color RGB, non-interlaced\n```\n\n\n\n命令格式：\n\n```bash\n-resize {width}x{height}{%} {@} {!} {<} {>} {^}\n```\n\n\n\n默认时，宽度和高度表示要最终需要转换图像的最大尺寸，同时 convert 会控制图片的宽和高，保证图片按比例进行缩放。如：\n\n```bash\nconvert -resize 200x150 src.png dst.png\n```\n\n\n\n转换后的 dst.png 的图片大小（宽度为 200，而高度已经按比例调整为 150）。也可以只指定宽度或者高度，按比例对图片进行缩放。\n\n只指定宽度：\n\n```bash\nconvert -resize 200 src.png dst.png\n```\n\n\n\n只指定高度：\n\n```bash\nconvert -resize x150 src.png dst.png\n```\n\n\n\n如果需要转换成 200x200，而图片无需保持原有比例，可以在宽高后面加上一个感叹号 !。如：\n\n```bash\nconvert -resize 200x200! src.png dst.png\n```\n\n\n\n默认都是使用像素作为单位，也可以使用百分比来形象图片的缩放。如：\n\n```bash\nconvert -resize 50%x100%! src.png dst.png\n```\n\n\n\n或者\n\n```bash\nconvert -resize 50%x100% src.png dst.png\n```\n\n\n\n此参数只会按你的比例计算后缩放，不保持原有比例。（结果尺寸为 200×300）\n\n使用 @ 来指定图片的像素个数。如：\n\n```bash\nconvert -resize \"10000@\" src.png dst.png\n```\n\n\n\n此命令执行后，dst.png 图片大小为（115×86），图片保持原有比例（115×86 = 9080 < 10000）。\n\n当原始文件大于指定的宽高时，才进行图片放大缩小，可使用 > 命令后缀。如：\n\n```bash\nconvert -resize \"200x100>\" src.png dst.png\n```\n\n\n\n此命令执行后，dst.png 图片大小为（133×100），图片保持原有比例。\n\n```bash\nconvert -resize \"200x100>!\" src.png dst.png\n```\n\n\n\n此命令执行后，dst.jpg 图片大小为（100×50），图片不保持原有比例。\n\n当原始文件小于指定的宽高时，才进行图片放大转换，可使用 < 命令后缀。如：\n\n```bash\nconvert -resize \"100x500<\" src.png dst.png \n```\n\n\n\n或者\n\n```bash\nconvert -resize \"100x100<!\" src.png dst.png\n```\n\n\n\n此命令执行后，dst.png 和 src.png 大小相同，因为原始图片宽比 100 大。如：\n\n```bash\nconvert -resize \"600x600<\" src.png dst.png\n```\n\n\n\n此命令执行后，dst.png 图片大小为（600×450），图片保持原有比例。如：\n\n```bash\nconvert -resize \"600x600<!\" src.png dst.png\n```\n\n\n\n此命令执行后，dst.png 图片大小为（600×600），图片不保持原有比例。\n\n使用 ^ 命令后缀可以使用宽高中较小的那个值作为尺寸。如：\n\n```bash\nconvert -resize \"600x600^\" src.png dst.png\n```\n\n\n\n此命令执行后，dst.png 图片大小为（800×600），图片保持原有比例。\n\n```bash\nconvert -resize \"600x400^\" src.png dst.png\n```\n\n\n\n此命令执行后，dst.png 图片大小为（600×450），图片保持原有比例。\n\n\n\n# Linux qrencode 命令 - 生成二维码的工具\n\n## 介绍\n\n**qrencode**（英文全拼：QR Encode）命令用于根据输入文本生成二维码，可保存为 PNG 或 EPS 格式图片。\n\n在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```shell\nsudo apt install qrencode\n```\n\n\n\n**语法**：\n\n```shell\nqrencode [OPTION]...  [STRING]\n```\n\n\n\n**选项**：\n\n- `-o`, `--output=FILENAME` ：将图像输出到 FILENAME 文件，如果指定 `-` 则输出到标准输出。\n- `-r`, `--read-from=FILENAME` ：从 FILENAME 文件读取输入数据。\n- `-s`, `--size=NUMBER` ：指定二维码中每个点的像素大小（默认为 3）。\n- `-m`, `--margin=NUMBER` ：指定 margin 宽度（默认为 4）\n- `-d`, `--dpi=NUMBER` ：指定生成 PNG 图片的 DPI（默认为 72）\n- `-t`, `--type=TYPE` ：指定生成的图片类型（默认为 PNG），支持参数包括 PNG、PNG32、EPS、SVG、XPM、ANSI、ANSI256、ASCII、ASCIIi、UTF8、ANSIUTF8。\n- `-i`, `--ignorecase` ：忽略大小写区别，仅使用大写字母。\n- `-h`, `--help` ：显示帮助信息。\n- `-V`, `--version` ：显示版本信息。\n\n**参数**：字符串 STRING，如果没有给定则从标准输入获取\n\n## 示例\n\n根据 URL 在标准输出生成二维码\n\n```shell\necho \"https://getiot.tech\" | qrencode -o - -t ANSI\n```\n\n\n\n生成二维码图片\n\n```shell\nqrencode -o qrcode.png 'https://getiot.tech'\n```\n\n\n\n如下：\n\n![img](./Image/Linux命令大全.assets/qrcode.png)\n\n指定生成图片的像素尺寸\n\n```shell\nqrencode -s 4 -o qrcode.png 'https://getiot.tech'\n```\n\n\n\n\n\n# Linux dos2unix 命令 - 转换文本文件格式\n\n## 介绍\n\n**dos2unix** 是一个 DOS/Mac - Unix 文件格式转换器。\n\nWindows 格式文件的换行符是 `\\r\\n`，而 Linux 使用的换行符是 `\\n`。dos2unix 命令其实就是将文件中的 `\\r\\n` 转换为 `\\n`。\n\nDos2unix 软件包包括两个工具 —— dos2unix 和 unix2dos，用于将纯文本文件在 DOS 或 Mac 格式与 Unix 格式之间相互转换。在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install dos2unix\n```\n\n\n\n**语法**：\n\n```bash\ndos2unix [options] [file ...] [-n infile outfile ...]\n```\n\n\n\n**选项**：\n\n- `--allow-chown` ：允许修改文件所有者。\n- `-ascii` ：只转换换行符（默认）。\n- `-iso` ：在 DOS 和 ISO-8859-1 字符集之间转换。\n- `-7` ：转换 8 位字符到 7 位空间。\n- `-b`, `--keep-bom` ：保留 UTF-8 BOM 头。\n- `-c`, `--convmode <convmode>` ：转换模式 convmode 包括 ascii、7bit、iso 或 mac，默认为 ascii。\n- `-f`, `--force` ：强制转换二进制文件。\n- `-h`, `--help` ：显示本说明文字\n- `-i`, `--info[=FLAGS] <file>` ：显示文件信息，file 是需要分析的文件。\n- `-k`, `--keepdate` ：保留输出文件时间。\n- `-L`, `--license` ：显示软件协议。\n- `-l`, `--newline` ：加入额外的换行符。\n- `-m`, `--add-bom` ：添加 UTF-8 BOM头（默认为UTF-8）。\n- `-n`, `--newfile <infile> <outfile>` ：写入新文件，infile 为新文件模式中的原始文件，outfile 为新文件模式中的输出文件。\n- `--no-allow-chown` ：不允许修改文件所有者（默认选项）。\n- `-o`, `--oldfile <file>` ：写入原文件（默认），file 为旧文件模式中要转换的文件。\n- `-q`, `--quiet` ：安静模式，不显示所有警告。\n- `-r`, `--remove-bom` ：移除 UTF-8 BOM 头（默认）。\n- `-s`, `--safe` ：跳过二进制文件（默认）。\n- `-u`, `--keep-utf16` ：保留 UTF-16 编码。\n- `-ul`, `--assume-utf16le` ：假定输入文件格式为 UTF-16LE。\n- `-ub`, `--assume-utf16be` ：假定输入文件格式为 UTF-16BE。\n- `-v`, `--verbose` ：显示更多信息。\n- `-F`, `--follow-symlink` ：根据符号链接转换其目标文件。\n- `-R`, `--replace-symlink` ：取代符号链接为转换后的文件（原链接目标文件保持不变）。\n- `-S`, `--skip-symlink` ：保持符号链接及其目标不变（默认）。\n- `-V`, `--version` ：显示版本号。\n\n## 示例\n\n在源文件基础上将此文件从 dos 格式转换为 unix 格式\n\n```bash\ndos2unix book.csv\n```\n\n\n\n保留源文件\n\n```bash\ndos2unix -n book.csv newbook.csv\n```\n\n\n\n不改变转换后文件的时间戳\n\n```bash\ndos2unix -k book.csv\n```\n\n\n\n静默转换\n\n```bash\ndos2unix -q book.csv\n```\n\n\n\n\n\n# Linux ronn 命令 - 转换 Markdown 为 man 页\n\n## 介绍\n\n**ronn** 命令用于将 markdown 文档（roff 格式）转换成 Linux 标准的 manpages 帮助文档。\n\nronn-format 基于 markdown，但包含额外的规则和语法，用于编写手册。关于 ronn-format 的介绍可以通过 `man ronn-format` 获取。\n\n在默认模式下，ronn 将一个或多个输入文件转换为 HTML 或 roff 输出文件。--roff、--html 和 --fragment 选项指示生成哪些输出文件。可以指定多个格式参数来生成多个输出文件。输出文件以输入文件命名并写入相同的目录。--server 和 --man 选项将输出行为从文件生成更改为提供动态生成的 HTML 联机帮助页或与 man 一样查看文件。\n\n如果没有文件参数，ronn 将充当简单的过滤器。Ronn 源文本从标准输入读取，roff 输出写入标准输出。使用 --html、--roff 和 / 或 --fragment 选项来选择输出格式。\n\n**语法**：\n\n```shell\nronn <options> <file>...\nronn -m|--man <file>\nronn -S|--server <file> ...\nronn --pipe [<file>...]\nronn < file\n```\n\n\n\n**选项**：\n\n- 模式选项改变生成文件的默认行为：\n  - `--pipe` ：写入标准输出而不是生成文件。\n  - `-m`, `--man` ：像 man 一样显示帮助手册。\n  - `-S`, `--server` ：在 http://localhost:1207/ 提供服务文件。\n  - `--port <port>` ：使用指定端口而不是默认的 1207 运行服务器。\n  - `-o`, `--output-dir <dir>` ：将生成的文件写入指定目录。\n- 格式选项控制生成哪些文件格式：\n  - `-r`, `--roff` ：生成 roff 格式输出。\n  - `-5`, `--html` ：生成带有布局的整个 HTML 页面。\n  - `-f`, `--fragment` ：生成 HTML 片段。\n  - `--markdown` ：生成后处理的（post-processed）markdown 格式输出。\n- 文档属性：\n  - `--date=<date>` ：发布日期（底部居中），格式为 YYYY-MM-DD。\n  - `--manual=<name>` ：手册名称（顶部居中）。\n  - `--organization=<name>` ：出版团体或个人（左下）。\n- 其他选项：\n  - `-w`, `--warnings` ：在 stderr 上显示 troff 警告。\n  - `-W disable` ：预先启用的 troff 警告。\n  - `--version` ：显示 ronn 的版本信息。\n  - `--help` ：显示帮助信息。\n\n## 示例\n\n转换 atinout.1.ronn 文件\n\n```shell\nronn atinout.1.ronn\n```\n\n\n\n\n\n# Linux cwebp 命令 - 将图像转换为 WebP 格式\n\n## 介绍\n\n**cwebp**（英文全拼：compress WebP）命令用于将 JPEG、PNG 或 TIFF 格式的图片编码成 WebP 格式。\n\nWebP 格式是谷歌在 2010 年推出的新一代图片格式，旨在加快图片加载速度。图片压缩体积大约只有 JPEG 的2/3，能节省大量的服务器宽带资源和数据空间。WebP 既支持有损压缩也支持无损压缩，相较编码 JPEG 文件，编码同样质量的 WebP 文件需要占用更多的计算资源。\n\ncwebp 命令由 webp 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install webp\n```\n\n\n\n相关命令：[dwebp](https://getiot.tech/linux-command/dwebp/)\n\n**语法**：\n\n```bash\ncwebp [options] input_file -o output_file.webp\n```\n\n\n\n**选项**：\n\n- `-h`, `-help` ：显示帮助信息（简单版）。\n- `-H`, `-longhelp` ：显示帮助信息（详细版）。\n- `-q <float>` ：品质参数（0：最小，100：最优），缺省值为 75。\n- `-alpha_q <int>` ：为 alpha 压缩指定一个 0 到 100 的数值。alpha 无损压缩用 100，小于 100 将产生有损压缩。默认值100。\n- `-preset <string>` ：指定一组预定义的值用来区分不同的文件材料。可能的值有 default、photo、picture、drawing、icon、text。由于 -preset 覆盖其他参数的值（除了 -q），这个值最好出现在所有参数最前面。\n- `-z <int>` ：切换无损压缩模式级别从 0 到 9，0 最快，9 最慢。速度越快文件越大。比较好的默认值是 6。这个参数是一个预定义压缩质量快捷阐述。如果参数 -q 或者 -m 被随后用到，这个 -z 就无效了。\n- `-m <int>` ：制定压缩模式。这个参数控制了编码的速度，压缩文件大小，质量。值范围为 0 到 6，默认 4。值越大，花费时间越大用来检查额外的编码能力和质量。小的值会产生快的压缩速度，大的文件和低的压缩质量。\n- `-segments <int>` ：更改在 sns 算法分段期间要使用的分区数。段的范围应为 1 到 4，默认值为 4。除非使用 -low_memory，否则此选项对方法 3 及更高版本无效。\n- `-size <int>` ：为输出文件指定一个目标大小（单位 bytes），压缩器将多次压缩以接近这个目标。如果 -size 和 -psnr 同时使用, 那么 -size 优先。\n- `-psnr <float>` ：指定目标 PSNR（以 dB 为单位）以尝试达到压缩输出。 压缩程序将通过几次部分编码，以便尽可能接近此目标。 如果同时使用 -size 和 -psnr，则以 -size 值为准。\n- `-s <int> <int>` ：YUV 的输入大小（宽 x 高）。\n- `-sns <int>` ：指定空间噪声整形的幅度（0：off，100：最大），缺省值为 50。\n- `-f <int>` ：指定解过滤器的强度（0：off，100：最大），缺省值为 60。\n- `-sharpness <int>` ：指定过滤的清晰度（0：最清晰，7：最不清晰），缺省值为 0。\n- `-strong` ：使用强过滤替代简单过滤（默认开启强过滤）。\n- `-nostrong` ：禁用强过滤，使用简单过滤。\n- `-sharp_yuv` ：如果需要，请使用更准确，更清晰的 RGB-> YUV 转换。 请注意，此过程比默认的“快速” RGB-> YUV 转换要慢。\n- `-partition_limit <int>` ：限制质量以适应第一个分区的 512k 限制（0：无降级，100：完全降级），缺省值为 0。\n- `-pass <int>` ：设置选项 -size 或 -psnr 程序执行期间要使用的最大通过次数。参数范围 1 到 10，默认值为 1。如果使用选项 -size 或 -psnr，但未指定 -pass，则将使用默认值 6。\n- `-crop <x> <y> <w> <h>` ：从左边顶部的点开始 (x_position, y_position) 计算来裁切图片。裁切区域必须在原文件图片区域内。\n- `-resize <w> <h>` ：调整源文件的宽高。如果任意一个宽或者高的参数为 0，那么将按比例计算。\n- `-mt` ：如果支持，采用多线程编码。\n- `-low_memory` ：通过节省四倍于压缩大小（通常）来减少有损编码的内存使用。 这将使编码变慢，并且输出的大小和失真会稍有不同。\n- `-map <int>` ：输出额外的 ASCII 映射编码信息。 可能的映射值范围是1到6。这仅是为了帮助调试。\n- `-print_psnr` ：计算并报告平均 PSNR（峰值信噪比）。\n- `-print_ssim` ：计算并报告平均 SSIM（结构相似性指标）。\n- `-print_lsim` ：计算并报告局部相似性度量（像素邻居中的最低误差之和）。\n- `-d <file.pgm>` ：转储压缩的输出（PGM 文件）。\n- `-alpha_method <int>` ：指定用于 alpha 压缩的算法：0 或 1。算法 0 表示无压缩，1 使用 WebP 无损格式进行压缩。 预设值为 1。\n- `-alpha_filter <string>` ：指定 Alpha 平面的预测过滤方法。有效值：none、fast、best，默认为 fast。\n- `-exact` ：将 RGB 值保留在透明区域中。默认为关闭，以帮助压缩。\n- `-blend_alpha <hex>` ：将颜色与以十六进制写入的 RGB 值表示的背景颜色混合，例如 0xc0e0d0 代表红色=0xc0，绿色=0xe0，蓝色=0xd0。\n- `-noalpha` ：使用此选项将丢弃 Alpha 通道。\n- `-lossless` ：无损编码图片处理。意味着整个图片，包含透明区域、看不见的像素值（R/G/B 或 Y/U/V）都会被保存。\n- `-near_lossless <int>` ：指定无损压缩级别对图片处理预处理（0..100=off），缺省值为 100。这个参数用来调整像素帮助图片的可压缩性，但是尽可能减少图片可见区域质量。\n- `-hint <string>` ：指定有关输入图像类型的提示。可能的值为：photo、picture 或 graph。\n- `-metadata <string>` ：逗号分隔的元数据列表，如果存在，则从输入复制到输出。有效值：all、none、exif、icc、xmp。默认为 none。\n- `-short` ：仅出于测试目的打印简要信息（输出文件大小和 PSNR）。\n- `-quiet` ：安静模式（不打印任何东西）。\n- `-version` ：打印版本信息并退出。\n- `-noasm` ：禁用所有装配优化。\n- `-v` ：打印更多信息（特别是编码时间）。\n- `-progress` ：报告编码进度（百分比）。\n\n## 示例\n\n```bash\ncwebp -q 80 image.png -o image.webp\n```\n\n\n\n\n\n# Linux dwebp 命令 - 将 WebP 图像转换为其他格式\n\n## 介绍\n\n**dwebp**（英文全拼：decompress WebP）命令用于将 WebP 格式图片解码成 PNG、PAM、PPM 或 PGM 格式。\n\nWebP 格式是谷歌在 2010 年推出的新一代图片格式，旨在加快图片加载速度。图片压缩体积大约只有 JPEG 的2/3，能节省大量的服务器宽带资源和数据空间。WebP 既支持有损压缩也支持无损压缩，相较编码 JPEG 文件，编码同样质量的 WebP 文件需要占用更多的计算资源。\n\ndwebp 命令由 webp 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```shell\nsudo apt install webp\n```\n\n\n\n相关命令：[cwebp](https://getiot.tech/linux-command/cwebp/)\n\n**语法**：\n\n```shell\ndwebp [options] input_file.webp\n```\n\n\n\n**选项**：\n\n- `-h` ：打印帮助信息。\n- `-version` ：打印版本信息。\n- `-bmp` ：将输出格式更改为未压缩的 BMP。\n- `-tiff` ：将输出格式更改为未压缩的 TIFF。\n- `-pam` ：将输出格式更改为 PAM（保留 alpha 通道）。\n- `-ppm` ：将输出格式更改为 PPM（丢弃 alpha 通道）。\n- `-pgm` ：将输出格式更改为 PGM。\n- `-yuv` ：将输出格式更改为 YUV。\n\n## 示例\n\n将 picture.webp 图片解码为 PNG 格式\n\n```shell\ndwebp picture.webp -o output.png\n```\n\n\n\n将 picture.webp 图片解码为 PPM 格式\n\n```shell\ndwebp picture.webp -ppm -o output.ppm\n```\n\n\n\n\n\n# Linux pv 命令 - 显示数据传输进度\n\n## 介绍\n\n**pv**（英文全拼：pipe viewer）命令用于通过管道监控数据处理的进度信息。这些信息包括已经耗费的时间、完成的百分比（通过进度条显示）、当前的速度、全部传输的数据，以及估计剩余的时间。\n\n**语法**：\n\n```shell\npv [OPTION] [FILE]...\n```\n\n\n\n**选项**：\n\n- `-p`, `--progress` ：显示进度条。\n- `-t`, `--timer` ：显示任务已经进行的时长。\n- `-e`, `--eta` ：显示剩余多长时间完成。\n- `-I`, `--fineta` ：以绝对时间显示预计完成时间。\n- `-r`, `--rate` ：显示当前传输速率。\n- `-a`, `--average-rate` ：显示平均传输速率。\n- `-b`, `--bytes` ：显示传输的字节数。\n- `-T`, `--buffer-percent` ：显示正在使用的传输缓冲区的百分比。\n- `-A`, `--last-written NUM` ：显示最后写入的 NUM 个字节。\n- `-F`, `--format FORMAT` ：设置输出格式为 FORMAT。\n- `-n`, `--numeric` ：显示进度百分比数字，而不是可视化信息。\n- `-q`, `--quiet` ：安静模式，不要输出任何传输信息。\n- `-W`, `--wait` ：在传输第一个字节之前不显示任何内容。\n- `-D`, `--delay-start SEC` ：在经过 SEC 秒数之前不显示任何内容。\n- `-s`, `--size SIZE` ：将估计数据大小设置为 SIZE 字节。\n- `-l`, `--line-mode` ：计数行而不是字节。\n- `-0`, `--null` ：行是 null-terminated 的。\n- `-i`, `--interval SEC` ：每 SEC 秒更新一次。\n- `-w`, `--width WIDTH` ：假设终端是 WIDTH 个字符宽。\n- `-H`, `--height HEIGHT` ：假设终端是 HEIGHT 行高。\n- `-N`, `--name NAME` ：使用 NAME 作为可视信息的前缀。\n- `-f`, `--force` ：强制输出，即使标准错误不是终端也输出。\n- `-c`, `--cursor` ：使用光标定位转义序列。\n- `-L`, `--rate-limit RATE` ：将传输限制为每秒 RATE 字节。\n- `-B`, `--buffer-size BYTES` ：使用 BYTES 的缓冲区大小。\n- `-C`, `--no-splice` ：从不使用 splice()，始终使用读/写。\n- `-E`, `--skip-errors` ：跳过输入中的读取错误。\n- `-S`, `--stop-at-size` ：在传输 --size 字节后停止。\n- `-R`, `--remote PID` ：更新进程 PID 的设置。\n- `-P`, `--pidfile FILE` ：在 FILE 中保存进程 ID。\n- `-d`, `--watchfd PID[:FD]` ：监视进程 PID 打开的文件 FD。\n- `-h`, `--help` ：显示帮助信息并退出。\n- `-V`, `--version` ：显示版本信息并退出。\n\n## 示例\n\n复制文件时显示进度条（如果没有指定选项，默认使用 -p, -t, -e, -r 和 -b 选项）\n\n```shell\n$ pv getiot.db > getiot.db.bak\n```\n\n\n\n将 /var/log/syslog 文件打包成 zip 压缩包，并显示进度\n\n```shell\n$ pv /var/log/syslog | zip > syslog.zip\n```\n\n\n\n使用 tar 命令解压缩时显示进度条\n\n```shell\n$ pv rootfs.tar.bz2 | tar -jxf - -C rootfs/\n12.3MiB 0:00:02 [6.15MiB/s] [=========>                                     ] 21% ETA 0:00:07\n```\n\n\n\n解压完成\n\n```shell\n$ pv rootfs.tar.bz2 | tar -jxf - -C rootfs/\n57.8MiB 0:00:10 [5.53MiB/s] [==============================================>] 100%\n```\n\n\n\n\n\n# Linux redshift 命令 - 护眼色温调节工具\n\n## 介绍\n\nLinux 中的 **redshift** 命令可以根据一天中的时间设置显示器的色温。它通过改变显示器配色和亮度来加强用户夜间坐在屏幕前的体验，减少由于显示屏对眼睛造成的压力。\n\n启动时，用户可以根据经度和纬度来配置地理坐标，redshift 会根据太阳的位置平滑地调整屏幕地配色和亮度。通常，夜间的屏幕色温会调向偏暖色。这是因为 redshift 有两个默认的色温值（日间色温：6500K，夜间色温：4500K），中性温度值为 6500K，使用此值不会改变显示器的色温，将色温设置为高于此值的值会导致更多的蓝光，而设置较低的值会导致更多的红光。\n\nredshift 通常不会预先安装，但可在大多数 Linux 发行版的默认仓库中找到。例如，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install redshift\n```\n\n\n\n**语法**：\n\n```bash\nredshift [-l LAT:LON | -l PROVIDER:OPTIONS] [-t DAY:NIGHT] [OPTIONS...]\n```\n\n\n\n**选项**：\n\n- `-h`：显示此帮助信息。\n- `-v`：详细输出。\n- `-V`：显示程序版本。\n- `-b DAY:NIGHT`：设置要应用的屏幕亮度（介于 0.1 和 1.0 之间）。\n- `-c FILE`：从指定的配置文件加载设置。\n- `-g R:G:B`：设置要应用的额外伽马校正。\n- `-l LAT:LON`：设置当前的位置。\n- `-l PROVIDER`：选择位置自动更新提供者（输入“list”以查看可用的提供者）。\n- `-m METHOD`：用于设置色温的方法（键入“list”以查看可用方法）。\n- `-o`：单次模式（不连续调节色温）。\n- `-O TEMP`：单次手动模式（设置色温）。\n- `-p`：打印模式（仅打印参数并退出）。\n- `-P`：在应用新的色彩效果之前重置现有的伽玛斜线（gamma ramps）。\n- `-x`：重置模式（从屏幕上移除调整）。\n- `-r`：禁用色温之间的淡入淡出。\n- `-t DAY:NIGHT`：指定色温调整的时间点（白天/晚上）。\n\n## 示例\n\n自动获取地理位置来调整屏幕色温\n\n```bash\n$ redshift \n正在尝试位置服务”geoclue2“。\n正在使用服务”geoclue2“。\n正在使用模式 ”randr“。\nWaiting for initial location to become available...\n位置：23.11 北纬, 113.25 东经\n```\n\n\n\n\n\n# Linux ptp4l 命令 - PTP 时间同步\n\n## 介绍\n\n**ptp4l**（英文全拼：PTP for Linux）命令用于 PTP 同步。\n\nptp4l 是根据适用于 Linux 的 IEEE 标准 1588 的精确时间协议（PTP）的实现，它实现了边界时钟（Boundary Clock）和普通时钟（Ordinary Clock），支持硬件时钟同步和软件时间同步（系统时钟同步）。\n\n相关命令：[phc2sys](https://getiot.tech/linux-command/phc2sys/)、[phc_ctl](https://getiot.tech/linux-command/phc_ctl/)、[pmc](https://getiot.tech/linux-command/pmc/)\n\n关于 PTP 详细介绍，请参考《[PTP 精确时间协议](https://getiot.tech/protocol/ptp/)》。\n\n**安装**：\n\nptp4l 命令由 LinuxPTP 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install linuxptp\n```\n\n\n\n**语法**：\n\n```bash\nptp4l  [ -AEP246HSLmqsv ] \n       [ -f config ] \n       [ -p phc-device ] \n       [ -l print-level ] \n       [ -i interface ] \n       [ long-options ] ...\n```\n\n\n\n**选项**：\n\n延迟机制选项\n\n- `-A`：自动模式，自动选择 E2E 延迟机制，当收到对等延迟请求时切换到 P2P。\n- `-E`：E2E 模式，请求应答延迟机制（默认）。注意：单个 PTP 通信路径上的所有时钟必须使用相同的机制。\n- `-P`：P2P 模式，对等延迟机制。\n\n网络传输选项\n\n- `-2`：IEEE 802.3\n- `-4`：UDP IPv4（默认）\n- `-6`：UDP IPv6\n\n时间戳选项\n\n- `-H`：硬件时间戳（默认）\n- `-S`：软件模拟时间戳\n- `-L`：老的硬件时间戳，LEGACY HW 需要配合 PHC 设备使用。\n\n其他选项\n\n- `-f [file]`：从指定文件 file 中读取配置，默认情况下不读取任何配置文件。\n- `-i [dev]`：选择 PTP 接口设备，例如 eth0（可多次指定），必须至少使用此选项或配置文件指定一个端口。\n- `-p [dev]`：此选项用于在旧 Linux 内核上指定要使用的 PHC 设备（例如 `/dev/ptp0` 时钟设备），默认为 auto，忽略软件/LEGACY HW 时间戳。\n- `-s`：从时钟模式（Slave only mode），将覆盖配置文件。\n- `-t`：透明时钟模式。\n- `-l [num]`：将日志记录级别设置为 num，默认为 6。\n- `-m`：将消息打印到 stdout。\n- `-q`：不打印消息到 syslog。\n- `-h`, `--help` ：显示帮助信息并退出。\n- `-V`, `--version` ：显示版本信息并退出。\n\n## 示例\n\n要使用 ptp4l，首先得确定网卡支持的同步类型，可通过 [ethtool](https://getiot.tech/linux-command/ethtool/) 命令测试。\n\n```bash\nsudo ethtool -T eth0\n```\n\n\n\n对于支持硬件时间戳的主机，可通过以下命令运行主时钟\n\n```bash\nsudo ptp4l -m -H -i eth0\n```\n\n\n\n运行 slave 时钟\n\n```bash\nsudo ptp4l -i eth0 -m -H -s\n```\n\n\n\n若主机不支持硬件时间戳，可通过以下命令启用 PTP 软件时间戳\n\n```bash\nsudo ptp4l -m -S -i eth0          # 主时钟\nsudo ptp4l -m -S -s -i eth0       # 从时钟\n```\n\n\n\n将 ptp4l 作为服务运行\n\n```bash\nsudo systemctl start ptp4l\n```\n\n\n\n- ptp4l 的配置文件：/etc/linuxptp/ptp4l.conf\n- 服务配置文件：/lib/systemd/system/ptp4l.service\n\n\n\n# Linux phc2sys 命令 - 同步 PTP 时钟与系统时钟\n\n## 介绍\n\n**phc2sys**（英文全拼：PTP hardware clock to system）命令用于同步两个或多个时钟。最常见的用法是，将系统时钟同步到网卡上的 PTP 硬件时钟（PHC）。PHC 本身可以使用 `ptp4l` 同步，系统时钟被视为从属时钟，而网卡上的时钟则为主时钟。\n\n相关命令：[ptp4l](https://getiot.tech/linux-command/ptp4l/)、[phc_ctl](https://getiot.tech/linux-command/phc_ctl/)、[pmc](https://getiot.tech/linux-command/pmc/)\n\n关于 PTP 详细介绍，请参考《[PTP 精确时间协议](https://getiot.tech/protocol/ptp/)》。\n\n**安装**：\n\nphc2sys 命令由 LinuxPTP 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install linuxptp\n```\n\n\n\n**语法**：\n\n```bash\nphc2sys -a [ -r ] [ -r ] [ options ]\nphc2sys [ -d pps-device ] [ -s device ] [ -c device ] [ -O offset ] [ -w ] [ options ]\n```\n\n\n\n**选项**：\n\n自动配置：\n\n- `-a`：开启自动配置。\n- `-r`：同步系统（实时）时钟，重复 `-r` 将其也视为时间源。\n\n手动配置：\n\n- `-c [dev|name]`：从时钟（CLOCK_REALTIME）。\n- `-d [dev]`：主 PPS 设备。\n- `-s [dev|name]`：主时钟。\n- `-O [offset]`：从主时间偏移量，默认为 0。\n- `-w`：等待 ptp4l。\n\n通用选项：\n\n- `-E [pi|linreg]`：时钟伺服，默认为 pi。\n- `-P [kp]`：比例常数，默认为 0.7。\n- `-I [ki]`：积分常数，默认为 0.3。\n- `-S [step]`：设置步阈值，默认不开启。\n- `-F [step]`：仅在开始时设置步阈值，默认为 0.00002。\n- `-R [rate]`：以 HZ 为单位的从属时钟更新率，默认为 1 HZ。\n- `-N [num]`：每次更新的主时钟读数数量，默认为 5。\n- `-L [limit]`：以 ppb 为单位的健全频率限制，默认为 200000000。\n- `-M [num]`：NTP SHM 段号，默认为 0。\n- `-u [num]`：摘要统计中的时钟更新次数，默认为 0。\n- `-n [num]`：域编号（domain number），默认为 0。\n- `-x`：通过伺服而不是内核应用闰秒。\n- `-z [path]`：UDS 的服务器地址（/var/run/ptp4l）。\n- `-l [num]`：将日志记录级别设置为 num，默认为 6。\n- `-t [tag]`：为日志消息添加标记（tag）。\n- `-m`：将消息打印到标准输出（stdout）。\n- `-q`：不要将消息打印到系统日志（syslog）。\n- `-v`：显示版本信息并退出。\n- `-h`：显示帮助信息并退出。\n\n## 示例\n\n将系统时钟同步到网卡上的 PTP 硬件时钟（PHC），使用 `-s` 可按设备或网络接口指定主时钟，使用 `-w` 可等待直到 `ptp4l` 进入已同步状态：\n\n```bash\nsudo phc2sys -s eth0 -w\n```\n\n\n\nPTP 按国际原子时（TAI）运行，而系统时钟使用的是协调世界时（UTC）。如果不指定 `-w` 来等待 `ptp4l` 同步，可以使用 `-O` 来指定 TAI 与 UTC 之间的偏差（以秒为单位）：\n\n```bash\nsudo phc2sys -s eth0 -O -35\n```\n\n\n\n将 `phc2sys` 作为服务运行：\n\n```bash\nsudo systemctl start phc2sys\n```\n\n\n\n\n\n# Linux phc_ctl 命令 - 管理 PTP 硬件时钟\n\n## 介绍\n\n**phc_ctl**（英文全拼：PTP hardware clock control）是 linuxptp 套件中的一个命令，可以用来直接控制 PHC 时钟设备。`phc_ctl` 命令通常用于调试目的，很少用于设备的一般控制。对于 PHC 时钟设备的一般控制，应该使用 `phc2sys` 命令。\n\n相关命令：[ptp4l](https://getiot.tech/linux-command/ptp4l/)、[phc2sys](https://getiot.tech/linux-command/phc2sys/)、[pmc](https://getiot.tech/linux-command/pmc/)\n\n关于 PTP 详细介绍，请参考《[PTP 精确时间协议](https://getiot.tech/protocol/ptp/)》。\n\n**安装**：\n\nptp4l 命令由 LinuxPTP 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install linuxptp\n```\n\n\n\n**语法**：\n\n```bash\nphc_ctl [ options ] <device> [ commands ]\n```\n\n\n\n其中，device 用于指定以太网卡或 PTP 时钟设备。\n\n**选项**：\n\n- `-l print-level`：设置日志记录级别。\n- `-q`：不将消息打印到 syslog 系统日志。\n- `-Q`：不将消息打印到 stdout 标准输出。\n- `-v`：打印软件版本并退出。\n- `-h`：打印帮助信息并退出。\n\n**命令**：\n\n除了选项，还可以指定带有参数的命令（command），并且可以指定多个命令依次执行。\n\n- `set [seconds]`：设置 PHC 时间（默认为 CLOCK_REALTIME 上的时间）。\n- `get`：获取 PHC 时间。\n- `adj <seconds>`：通过偏移量 seconds 调整 PHC 时间。\n- `freq [ppb]`：调整 PHC 频率（默认返回当前偏移）。\n- `cmp`：将 PHC 偏移量与 CLOCK_REALTIME 进行比较。\n- `caps`：显示设备功能（如果没有指定命令，默认为该模式）。\n- `wait <seconds>`：命令之间暂停 seconds 秒。\n\n提示\n\n命令中的参数 seconds 被读取为双精度浮点值。\n\n## 示例\n\n从 PTP 设备读取当前时钟时间：\n\n```bash\nphc_ctl /dev/ptp0 get\n```\n\n\n\n将 PHC 时钟时间设置为 CLOCK_REALTIME：\n\n```bash\nphc_ctl /dev/ptp0 set\n```\n\n\n\n将 PHC 时钟时间设置为 0（自 Epoch 纪元以来的秒数，即 1970-01-01 00:00:00 UTC）：\n\n```bash\nphc_ctl /dev/ptp0 set 0.0\n```\n\n\n\n通过将转换频率设置为正 10%，将时钟重置为 0.0 时间，等待 10 秒，然后读取时间，快速检查频率转换的完整性。回读的时间应（大约）为 11 秒，因为时钟转动速度快了 10%。\n\n```bash\nphc_ctl /dev/ptp0 freq 100000000 set 0.0 wait 10.0 get\n```\n\n\n\n\n\n# Linux pmc 命令 - 管理 PTP 网络\n\n## 介绍\n\n**pmc**（英文全拼：PTP management client）是一个根据 IEEE 1588 标准实现的 PTP 管理客户端程序，可用于获取 ptp4l 的更详细信息。\n\npmc 从标准输入或命令行读取按名称和管理 ID（MANAGEMENT IDS）指定的操作。然后通过选定的传输发送操作，并列显收到的任何答复。支持三种操作：`GET` 检索指定的信息，`SET` 更新指定的信息，`CMD`（或 `COMMAND`）发起指定的事件。默认情况下，管理命令针对所有端口。\n\n相关命令：[ptp4l](https://getiot.tech/linux-command/ptp4l/)、[phc2sys](https://getiot.tech/linux-command/phc2sys/)、[phc_ctl](https://getiot.tech/linux-command/phc_ctl/)\n\n关于 PTP 详细介绍，请参考《[PTP 精确时间协议](https://getiot.tech/protocol/ptp/)》。\n\n**安装**：\n\npmc 命令由 LinuxPTP 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install linuxptp\n```\n\n\n\n**语法**：\n\n```bash\npmc [options] [commands]\n```\n\n\n\n**选项**：\n\n网络传输选项\n\n- `-2`：使用 IEEE 802.3\n- `-4`：使用 UDP IPV4（默认）\n- `-6`：使用 UDP IPV6\n- `-u`：使用本地 UDS（Unix Domain Socket）\n\n其他选项\n\n- `-b [num]`：边界跳数（boundary hops），默认为 1。\n- `-d [num]`：域名（domain number），默认0。\n- `-f [file]`：从文件中读取配置。\n- `-i [dev]`：要使用的网络接口设备，网络默认为 eth0，UDS 为 `/var/run/pmc.$pid`。\n- `-s [path]`：UDS 的服务器地址，默认为 `/var/run/ptp4l`。\n- `-t [hex]`：传输特定字段，默认 0x0。\n- `-z`：使用 GET 操作发送零长度 TLV 值。\n- `-h`：打印帮助信息。\n- `-v`：打印版本信息。\n\n**命令**：\n\npmc 支持 `GET`、`SET`、`CMD` 三种操作，操作后面带上管理 ID，指定需要操作的目标。支持的管理 ID 包括：\n\n- `ANNOUNCE_RECEIPT_TIMEOUT`\n- `CLOCK_ACCURACY`\n- `CLOCK_DESCRIPTION`\n- `CURRENT_DATA_SET`\n- `DEFAULT_DATA_SET`\n- `DELAY_MECHANISM`\n- `DOMAIN`\n- `GRANDMASTER_SETTINGS_NP`\n- `LOG_ANNOUNCE_INTERVAL`\n- `LOG_MIN_PDELAY_REQ_INTERVAL`\n- `LOG_SYNC_INTERVAL`\n- `NULL_MANAGEMENT`\n- `PARENT_DATA_SET`\n- `PORT_DATA_SET`\n- `PORT_DATA_SET_NP`\n- `PRIORITY1`\n- `PRIORITY2`\n- `SLAVE_ONLY`\n- `TIMESCALE_PROPERTIES`\n- `TIME_PROPERTIES_DATA_SET`\n- `TIME_STATUS_NP`\n- `TRACEABILITY_PROPERTIES`\n- `USER_DESCRIPTION`\n- `VERSION_NUMBER`\n\n## 示例\n\n获取本地 ptp4l 运行信息（`CURRENT_DATA_SET`）\n\n```bash\nsudo pmc -u -b 0 'GET CURRENT_DATA_SET'\n```\n\n\n\n获取本地 ptp4l 运行信息（`TIME_STATUS_NP`）\n\n```bash\nsudo pmc -u -b 0 'GET TIME_STATUS_NP'\n```\n\n\n\n\n\n# Linux gpsd 命令 - 管理 GPS 接收器服务\n\n## 介绍\n\n**gpsd**（英文全拼：GPS daemon）是 Linux 系统中用于接收和处理 GPS 数据的守护进程，它可以监控通过串口或 USB 端口连接到主机计算机上的一个或多个 GPS 或 AIS 接收器，并将所有 GPS 传感器位置、航向、速度等数据通过 TCP 端口 2947 提供给客户端查询。\n\ngpsd 服务是 [GPSD](https://gitlab.com/gpsd/gpsd) 项目的一部分，该项目提供一系列管理 GPS 设备和其他用于导航与精确计时的传感器的工具。\n\n扩展阅读：《[Linux 使用 gpsd 获取 GPS 数据](https://getiot.tech/linux-note/linux-get-gps-data-using-gpsd/)》、《[libgps 使用教程](https://getiot.tech/awesome-c/libgps/)》。\n\n**安装**：\n\ngpsd 命令由 gpsd 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install gpsd\n```\n\n\n\n**语法**：\n\n```bash\ngpsd [OPTIONS] device...\n```\n\n\n\n**选项**：\n\n- `-b`：bluetooth-safe 模式，打开只读数据源。\n- `-D integer`：设置调试等级（默认为 0）。\n- `-F sockfile`：指定控制套接字（control socket）的位置。\n- `-f FRAMING`：将设备帧固定为 `FRAMING`（例如 8N1、8O1 等）。\n- `-G`：使 gpsd 监听 `INADDR_ANY`，在此二进制文件中强制启用。\n- `-h`：显示帮助信息。\n- `-n`：不要等待客户端连接来轮询 GPS。\n- `-N`：不要进入后台。\n- `-P pidfile`：设置记录进程 ID 的文件。\n- `-r`：即使没有修正也使用 GPS 时间。\n- `-S PORT`：设置守护进程的端口（默认端口为 2947）\n- `-s SPEED`：将设备速度固定为 `SPEED`。\n- `-V`：显示版本信息并退出。\n\n## 示例\n\n假设你在 Linux 系统的最小编号的 USB 端口（/dev/ttyUSB0）上连接了 GPS 设备，并且想要在默认的 2947 端口上读取它的报告，那么只需以 root 身份执行下面命令即可：\n\n```bash\nsudo gpsd /dev/ttyUSB0\n```\n\n\n\n你可以执行下面命令将当前用户（非 root 用户）添加到 dialout 用户组，这样可以免去每次都要添加 `sudo`。\n\n```bash\nsudo usermod -a -G dialout $USER\n```\n\n\n\n注意：上述命令在重启系统后生效。\n\n\n\n# Linux cgps 命令 - 显示 GPS 信息和位置\n\n## 介绍\n\n**cgps** 是 gpsd 软件包中的一个客户端命令行工具，它可以以更友好的方式展示 GPS 数据（NMEA 报文格式），可用于测试 GPS 设备故障情况。\n\n**语法**：\n\n```bash\ncgps [-h] [-l {d|m|s}] [-m] [-s] [-V] [server[:port:[device]]]\n```\n\n\n\n**选项**：\n\n- `-D debug-level`：设置 debug 等级。\n\n- `-l {d|m|s}`：选择 lat/lon 输出格式，其中：\n\n  `d` 表示 `DD.ddddddd`（默认）\n\n  `m` 表示 `DD MM.mmmmmm'`\n\n  `s` 表示 `DD MM' SS.sssss\"`\n\n- `-m`：显示你的磁轨（但不是真实的磁轨），这是计算值，而不是测量值。磁力变化总是可能会出现较大的误差，但通常优于两度。\n\n- `-s`：安静模式（不打印原始 gpsd 数据）。\n\n- `-h`：显示帮助信息。\n\n- `-V`：显示版本信息。\n\n## 示例\n\n连接好 GPS 设备，启动 gpsd 守护进程后，执行 `cgps` 启动客户端：\n\n```bash\ncgps\n```\n\n\n\n可以看到类似如下的数据展示界面：\n\n![img](./Image/Linux命令大全.assets/linux-gpsd-cgps.png)\n\n提示：可参考《[Linux 使用 gpsd 获取 GPS 数据](https://getiot.tech/linux-note/linux-get-gps-data-using-gpsd/)》。\n\n\n\n# Linux gpsmon 命令 - 监控 GPS 数据和状态\n\n## 介绍\n\n**gpsmon**（英文全拼：GPS monitor）是 GPSD 软件包中的一个监视器工具，用于监视来自 GPS 的数据包并将其与诊断信息一起显示。它支持可用于以各种方式调整 GPS 设置的命令，有些与设备无关，有些则随 GPS 芯片组类型而变化。当连接到未知的 GPS 类型时，它依然会表现得很正常，因为它只会转储数据包。\n\ngpsmon 经常用于诊断 GPS 设备，因为它不会修改原始数据，不进行任何插值或建模来得出爬升/下沉或误差估计。哪怕当数据质量太低时，它也不会丢弃报告。\n\n**语法**：\n\n```bash\ngpsmon [-?hVn] [-l logfile] [-D debuglevel] [-t type] [server[:port:[device]]]\n```\n\n\n\n**选项**：\n\n- `-L`：以表格形式列出 gpsmon 内置支持哪些 GPS 设备类型，以及哪些通用命令可以应用于哪些 GPS 类型。注意，这并未列出与各个 GPS 类型相关的特定于类型的命令。\n- `-n`：强制 gpsmon 请求 NMEA0183 数据包，而不是来自 gpsd 的原始数据流。\n- `-a`：启用不使用屏幕绘制的特殊调试模式。数据包正常转储；键入任何字符都会暂停数据包转储并显示命令提示符。主要是 GPSD 开发人员对该功能感兴趣。\n- `-F sockfile`：该选项仅在客户端模式下有效，它指定程序应向其发送设备控制字符串的控制套接字。必须在本地文件系统上指定 Unix 域套接字的有效路径名。\n- `-l logfile`：将日志记录设置为在设备打开时立即输出到指定文件。\n- `-t type`：设置设备类型。设备类型通过一个字符串区分，它包含驱动程序类型名称的前缀。\n- `-D debuglevel`：设置调试等级，这可能仅对 GPSD 代码的开发人员有用。你可以参阅 packet-getter 源代码以获取相关值。\n- `-h`：显示帮助信息。\n- `-V`：显示版本信息并退出。\n\n## 示例\n\n连接好 GPS 设备，启动 gpsd 守护进程后，执行 `gpsmon` 启动监视器客户端：\n\n```bash\ngpsmon\n```\n\n\n\n可以看到类似如下的数据展示界面：\n\n![img](./Image/Linux命令大全.assets/linux-gpsd-gpsmon.png)\n\n列出 gpsmon 内置支持哪些 GPS 设备类型：\n\n```bash\n$ gpsmon -L\nGeneral commands available per type. '+' means there are private commands.\ni l q ^S ^Q       x  \tNMEA0183\ni l q ^S ^Q n     x  \tGarmin NMEA\ni l q ^S ^Q n     x  \tGarmin Serial binary\ni l q ^S ^Q       x +\tAshtech\ni l q ^S ^Q       x  \tSan Jose Navigation FV18\ni l q ^S ^Q       x  \tFuruno Electric GH-79L4\ni l q ^S ^Q     x x  \tMTK-3301\ni l q ^S ^Q          \tAIVDM\ni l q ^S ^Q n s   x +\tSiRF\ni l q ^S ^Q n s x x +\tu-blox\ni l q ^S ^Q         +\tiTalk\ni l q ^S ^Q n s   x +\tSuperStarII\ni l q ^S ^Q       x +\tMotorola Oncore\ni l q ^S ^Q   s   x +\tTrue North\ni l q ^S ^Q          \tJSON slave driver\n```\n\n\n\n\n\n# Linux gpspipe 命令 - 显示 GPS 数据流\n\n## 介绍\n\n**gpspipe**（英文全拼：GPS pipe）是 GPSD 软件包中的一个命令行工具，用于连接 gpsd 守护进程并将接收到的数据输出到 stdout。这使得 gpspipe 可用作从 gpsd 到另一个程序或文件的管道，从而实现读取实时的 GPS 数据流的功能。\n\ngpspipe 的输出将包含原始 NMEA 或本地 GPSD 语句之一或两者，每行都可以选择带有时间戳。gpspipe 默认从本地主机的 2947 端口上获取并监视 gpsd 打开的所有设备，你也可以选择指定的服务器、TCP/IP 端口号和远程设备。\n\n提示\n\n执行 gpspipe 命令不需要 root 权限，并且可以与连接到本地 gpsd 的其他工具同时运行。\n\n**语法**：\n\n```bash\ngpspipe [OPTIONS] [server[:port[:device]]]\n```\n\n\n\n**选项**：\n\n- `-2`：设置 split24 标志。\n- `-d`：作为守护进程运行。\n- `-h`：显示帮助信息。\n- `-l`：连接 gpsd 之前休眠十秒钟。\n- `-n [count]`：计数数据包后退出。\n- `-o [file]`：将输出写入文件。\n- `-P`：在 NMEA 或原始模式下包含 JSON 格式的 PPS 信息。\n- `-p`：在 JSON 中包含分析信息。\n- `-r`：转储原始 NMEA。\n- `-R`：转储超级原始模式（GPS 二进制）。\n- `-s [serial dev]`：在串口上模拟 4800bps NMEA GPS（需要与 `-r` 选项一起使用）。\n- `-S`：设置缩放标志（用于 AIS 和子帧数据）。\n- `-T [format]`：设置时间戳格式（类似于 strftime，隐含 `-t` 选项）。\n- `-t`：为数据添加时间戳。\n- `-u`：usec 时间戳（隐含 `-t` 选项）。使用 `-uu` 输出 *sec.usec*。\n- `-v`：打印一个小旋转器（spinner）。\n- `-V`：显示版本信息并退出。\n- `-w`：转储 gpsd 本机数据。\n- `-x [seconds]`：指定延迟 seconds 秒后退出。\n- `-Z`：设置时间戳格式为 iso8601（隐含 `-t` 选项）。\n\n提示\n\n选项 `-r`、`-R` 或 `-w` 必须选择一个或多个；如果使用 `-d` 选项，那么必须使用 `-o` 选项。\n\n## 示例\n\n以默认格式显示 GPS 数据：\n\n```bash\ngpspipe\n```\n\n\n\n以原始 NMEA 格式显示 GPS 数据：\n\n```bash\ngpspipe -r\n```\n\n\n\n使用 grep 命令在 gpspipe 中过滤数据并显示特定信息。例如，要显示 GPS Fix 数据：\n\n```bash\ngpspipe -w | grep -m 1 'TPV' | jq '.tpv | {lat, lon, alt}'\n```\n\n\n\n这会在标准输出中显示最新的 GPS Fix 数据，并仅显示经度、纬度和高度信息。在此命令中，管道（`|`）符号用于将 gpspipe 所生成的输出输入到 grep 中。-m 参数指定仅匹配一次，以便仅显示最新数据。你可以根据你的需求，使用其他选项来过滤数据。\n\n注意：在上述命令中，使用了 [jq](https://getiot.tech/linux-command/jq/) 命令来格式化 JSON 数据并仅显示特定字段。\n\n\n\n# Linux debootstrap 命令 - 创建 Debian 基础文件系统\n\n## 介绍\n\n**debootstrap** 是 Debian/Ubuntu 下的一个工具，用于构建一套基本的系统（根文件系统）。生成的目录符合 Linux 文件系统标准（FHS），即包含了 /boot、/etc、/bin、/usr 等等目录，但它比发行版本的 Linux 体积小很多，当然功能也没那么强大，因此，只能说是“基本的系统”。\n\ndebootstrap 通常用于安装基本的 Debian 系统到一个指定目录，以便在该目录中进行 [chroot](https://getiot.tech/linux-command/chroot/) 操作；或者用于创建一个用于安装新系统的基础文件系统，以测试不同 Debian 版本和系统架构。\n\n**语法**：\n\n```bash\ndebootstrap [OPTION]... <suite> <target> [<mirror> [<script>]]\n```\n\n\n\n**选项**：\n\n- `--arch=A`：指定目标系统的架构，如 amd64、i386、powerpc 等。\n- `--variant=X`：指定文件系统的变种，常见的有 `buildd`、`fakechroot`、`minbase` 等。\n- `--components=A,B,C`：指定要包含的软件包组件，如 `main`、`contrib`、`non-free`。\n- `--include=A,B,C`：指定要包含在安装中的额外软件包。\n- `--exclude=A,B,C`：指定要从安装中排除的软件包。\n\n## 示例\n\n在指定目录中创建一个基本的 Debian 系统：\n\n```bash\nsudo debootstrap stable /path/to/installation/directory\n```\n\n\n\n在指定目录中创建一个基本的 Debian 系统，并指定架构和变种：\n\n```bash\nsudo debootstrap --arch amd64 --variant=minbase buster /path/to/installation/directory\n```\n\n\n\n在指定目录中创建一个基本的 Debian 系统，并包含 `build-essential` 和 `git` 软件包：\n\n```bash\nsudo debootstrap buster /path/to/installation/directory --include=build-essential,git\n```\n\n\n\n在指定目录中创建一个基本的 Debian 系统，但排除安装 `python` 软件包：\n\n```bash\nsudo debootstrap buster /path/to/installation/directory --exclude=python\n```\n\n\n\n在指定目录中创建一个基本的 Debian 系统，使用指定的本地镜像源：\n\n```bash\nsudo debootstrap --arch amd64 --variant=minbase --include=build-essential,git,locales buster /path/to/installation/directory http://ftp.us.debian.org/debian\n```\n\n\n\n提示\n\n请注意，`debootstrap` 命令需要在具有 `sudo` 权限的系统上运行。上述示例中的版本（如 `buster`）和软件包名称应根据实际需求进行调整。此外，要在创建的 Debian 系统中进行 chroot，你可能需要额外的配置，如 `mount`、`chroot` 等。\n\n\n\n# Linux capinfos 命令 - 显示 pcap 文件信息\n\n## 介绍\n\n**capinfos** 是 Wireshark 工具集中的一个命令，用于查看 pcap 文件（网络捕获文件）的基本信息，包括文件大小、记录数量、时间戳范围等信息。\n\n使用前请确保你的系统上已经安装 Wireshark 工具，如果未安装，可以参考下面安装方法：\n\n- Ubuntu\n- CentOS/RHEL\n\n```bash\nsudo apt install wireshark\n```\n\n\n\n相关命令：[editcap](https://getiot.tech/linux-command/editcap/), [mergecap](https://getiot.tech/linux-command/mergecap/)\n\n**语法**：\n\n```bash\ncapinfos [options] <infile> ...\n```\n\n\n\n**选项**：\n\n- General infos:\n  - `-t`：显示捕获文件的类型。\n  - `-E`：显示捕获文件封装（encapsulation）。\n  - `-I`：显示抓包文件接口信息。\n  - `-F`：显示附加捕获文件信息。\n  - `-H`：显示文件的 SHA256、RIPEMD160 和 SHA1 哈希值。\n  - `-k`：显示捕获的注释（comment）。\n- Size infos:\n  - `-c`：显示数据包数量。\n  - `-s`：显示文件的大小（以字节为单位）。\n  - `-d`：显示所有数据包的总长度（以字节为单位）。\n  - `-l`：显示数据包大小限制（快照长度）。\n- Time infos:\n  - `-u`：显示捕获持续时间（以秒为单位）。\n  - `-a`：显示捕获开始时间。\n  - `-e`：显示捕获结束时间。\n  - `-o`：显示捕获文件的时间顺序状态（True/False）。\n  - `-S`：将开始和结束时间显示为秒。\n- Statistic infos:\n  - `-y`：显示平均数据速率（以字节/秒为单位）。\n  - `-i`：显示平均数据速率（以位/秒为单位）。\n  - `-z`：显示平均数据包大小（以字节为单位）。\n  - `-x`：显示平均数据包速率（以数据包/秒为单位）。\n- Metadata infos:\n  - `-n`：显示已解析的 IPv4 和 IPv6 地址的数量。\n  - `-D`：显示解密密钥（decryption secrets）的数量。\n- Output format:\n  - `-L`：生成长报告（默认）。\n  - `-T`：生成表格报告。\n  - `-M`：在长报告中显示机器可读的值。\n- Table report options:\n  - `-R`：生成头记录（默认）。\n  - `-r`：不生成头记录。\n  - `-B`：用 TAB 字符分隔信息（默认）。\n  - `-m`：用逗号（`,`）字符分隔信息。\n  - `-b`：用 SPACE（空格）字符分隔信息。\n  - `-N`：不引用信息（默认）。\n  - `-q`：用单引号（`'`）引用信息。\n  - `-Q`：用双引号（`\"`）引用信息。\n- Miscellaneous:\n  - `-h, --help`：显示帮助信息并退出。\n  - `-v, --version`：显示版本信息并退出。\n  - `-C`：如果文件打开失败则取消处理（默认为继续）。\n  - `-A`：生成所有信息（默认）。\n  - `-K`：禁用显示捕获注释（comment）。\n\n## 示例\n\n不带任何选项参数，以默认方式显示 pcap 文件的所有基本信息：\n\n```bash\n$ capinfos 2023-09-26-14-31-42-30s.pcap\nFile name:           2023-09-26-14-31-42-30s.pcap\nFile type:           Wireshark/tcpdump/... - pcap\nFile encapsulation:  Ethernet\nFile timestamp precision:  microseconds (6)\nPacket size limit:   file hdr: 65535 bytes\nNumber of packets:   300 k\nFile size:           261 MB\nData size:           256 MB\nCapture duration:    30.096327 seconds\nFirst packet time:   2023-09-26 14:33:25.555011\nLast packet time:    2023-09-26 14:33:55.651338\nData byte rate:      8,512 kBps\nData bit rate:       68 Mbps\nAverage packet size: 854.00 bytes\nAverage packet rate: 9,967 packets/s\nSHA256:              4cd82ce1b8fd3d498794d14e2ada82a3acbafca64f1e699574e58a6deec600cc\nRIPEMD160:           347128fa0c6a4aeabcdeb71b1e6cdaf94d100999\nSHA1:                a800fa328b3e65af40d2b783b37e0a2b5d80591f\nStrict time order:   True\nNumber of interfaces in file: 1\nInterface #0 info:\n                     Encapsulation = Ethernet (1 - ether)\n                     Capture length = 65535\n                     Time precision = microseconds (6)\n                     Time ticks per second = 1000000\n                     Number of stat entries = 0\n                     Number of packets = 300000\n```\n\n\n\n显示 pcap 文件的总大小：\n\n```bash\n$ capinfos -s 2023-09-26-14-31-42-30s.pcap\nFile name:           2023-09-26-14-31-42-30s.pcap\nFile size:           261 MB\n```\n\n\n\n显示 pcap 文件的时间长度：\n\n```bash\n$ capinfos -u 2023-09-26-14-31-42-30s.pcap\nFile name:           2023-09-26-14-31-42-30s.pcap\nCapture duration:    30.096327 seconds\n```\n\n\n\n显示 pcap 文件的数据包总量：\n\n```bash\n$ capinfos -c 2023-09-26-14-31-42-30s.pcap\nFile name:           2023-09-26-14-31-42-30s.pcap\nNumber of packets:   300 k\n```\n\n\n\n\n\n# Linux editcap 命令 - 编辑和转换 pcap 文件\n\n## 介绍\n\n**editcap** 是 Wireshark 工具集中的一个命令，用于编辑 pcap 文件（网络捕获文件），包括截断、拆分、过滤等操作。这个命令允许你对捕获的网络流量进行一些基本的编辑，以便更好地分析和处理。\n\n使用前请确保你的系统上已经安装 Wireshark 工具，如果未安装，可以参考下面安装方法：\n\n- Ubuntu\n- CentOS/RHEL\n\n```bash\nsudo apt install wireshark\n```\n\n\n\n相关命令：[capinfos](https://getiot.tech/linux-command/capinfos/), [mergecap](https://getiot.tech/linux-command/mergecap/)\n\n**语法**：\n\n```bash\neditcap [options] ... <infile> <outfile> [ <packet#>[-<packet#>] ... ]\n```\n\n\n\n**选项**：\n\n- `-r`：保留选定的数据包（默认是删除它们）。\n- `-A <start time>`：只读取时间戳晚于（或等于）给定时间的数据包。时间格式为 `YYYY-MM-DDThh:mm:ss[.nnnnnnnnn][Z|+-hh:mm]`。\n- `-B <stop time>`：只读取时间戳早于给定时间的数据包。时间格式同上。\n- `-s <snaplen>`：将每个数据包截断为最大值 `<snaplen>` 字节数据。\n- `-C [offset:]<choplen>`：将每个数据包切割 `<choplen>` 字节。正值在数据包开始处截断，负值在数据包结尾处截断。如果可选偏移量位于长度之前，则截断的字节将从该值开始偏移。正偏移量是从数据包开始处开始的，负偏移量是从数据包结束处开始的。你可以多次使用此选项，允许数据包内最多有 2 个斩波区域（chopping regions），前提是至少 1 个 choplen 为正值，至少 1 个为负值。\n- `-c <packets per file>`：根据统一的数据包计数将数据包输出拆分到不同的文件，每个文件最多为 `<packets per file>`。\n- `-i <seconds per file>`：根据统一的时间间隔将数据包输出拆分到不同的文件，每个文件的最大时间间隔为 `<seconds per file>`。\n- `-F <capture type>`：设置输出文件类型，默认为 pcapng。空的 `-F` 选项将列出文件类型。\n- `-T <encap type>`：设置输出文件封装类型，默认与输入文件相同。空的 `-T` 选项将列出封装类型。\n\n## 示例\n\n假设有个 30 秒的 pcap 文件 2023-09-26-14-31-42-30s.pcap，我们先用 [`capinfos`](https://getiot.tech/linux-command/capinfos/) 命令查看它的起始和结束时间：\n\n```bash\n$ capinfos -a 2023-09-26-14-31-42-30s.pcap\nFile name:           2023-09-26-14-31-42-30s.pcap\nFirst packet time:   2023-09-26 14:33:25.555011\n$ capinfos -e 2023-09-26-14-31-42-30s.pcap\nFile name:           2023-09-26-14-31-42-30s.pcap\nLast packet time:    2023-09-26 14:33:55.651338\n```\n\n\n\n现在，我们前后分别偏移 10 秒，即截取中间的 10 秒数据：\n\n```bash\neditcap -A 2023-09-26T14:33:35 -B 2023-09-26T14:33:45 2023-09-26-14-31-42-30s.pcap 2023-09-26-14-31-42-10s.pcap\n```\n\n\n\n按 1000 个包为间隔将 pcap 文件拆分成多个文件：\n\n```bash\neditcap -c 1000 2023-09-26-14-31-42-30s.pcap output.pcap\n```\n\n\n\n此时会在当前目录生成许多 `output_00*` 开头的 pcap 文件，例如 output_00214_20230926143347.pcap。\n\n\n\n# Linux mergecap 命令 - 合并多个 pcap 文件\n\n## 介绍\n\n**mergecap** 是 Wireshark 工具集中的一个命令，用于将多个 pcap 文件（网络捕获文件）合并为一个文件。这个命令允许你将多个捕获文件的数据合并到一个文件中，方便进行整体分析和处理。\n\n使用前请确保你的系统上已经安装 Wireshark 工具，如果未安装，可以参考下面安装方法：\n\n- Ubuntu\n- CentOS/RHEL\n\n```bash\nsudo apt install wireshark\n```\n\n\n\n相关命令：[editcap](https://getiot.tech/linux-command/editcap/), [capinfos](https://getiot.tech/linux-command/capinfos/)\n\n**语法**：\n\n```bash\nmergecap [options] -w <outfile>|- <infile> [<infile> ...]\n```\n\n\n\n**选项**：\n\n- `-a`：连接而不是合并文件，默认是根据帧时间戳进行合并。\n- `-s <snaplen>`：将数据包截断为 `<snaplen>` 数据字节。\n- `-w <outfile>|-`：将输出文件名设置为 `<outfile>` 或标准输出的 `-`。\n- `-F <capture type>`：设置输出文件类型； 默认为 pcapng。空的 `-F` 选项将列出文件类型。\n- `-I <IDB merge mode>`：设置接口描述块的合并模式，默认为 all。空的 `-I` 选项将列出合并模式。\n\n## 示例\n\n列出支持的所有合并模式：\n\n```bash\n$ mergecap -I\nmergecap: option requires an argument: I\nmergecap: The available IDB merge modes for the \"-I\" flag are:\n    none\n    all\n    any\n```\n\n\n\n将合并 `file1.pcap` 和 `file2.pcap` 两个文件，并将结果保存到 `new.pcap` 中：\n\n```bash\nmergecap file1.pcap file2.pcap -w new.pcap\n```\n\n\n\n也可以使用通配符来检索输入文件，例如：\n\n```bash\nmergecap file*.pcap -w new.pcap\n```\n\n\n\n在输入文件特别多的情况下非常有用！\n\n\n\n# Linux jq 命令 - JSON 数据处理器\n\n## 介绍\n\n**jq** 是一个轻量级的和灵活的命令行 JSON 处理器，用于解析、查询和转换 JSON 数据。它可以帮助用户在命令行中轻松地处理和操作 JSON 格式的数据。\n\njq 的一个常见的使用场景是处理 JSON 输入，设置过滤器应用于其 JSON 文本输入，并将过滤器的结果生成为新的 JSON 文本打印到标准输出。最简单的过滤器是 `.`，它将 jq 的输入未经修改地复制到其输出中（格式设置除外）。\n\n另外，需要注意的是，jq 当前仅支持 64 位双精度浮点数（IEEE754）。\n\n- 项目主页：https://jqlang.github.io/jq\n- GitHub 仓库：https://github.com/jqlang/jq\n\n**安装**：\n\n使用前请确保你的系统上已经安装 jq 工具，如果未安装，可以参考下面安装方法：\n\n- Debian/Ubuntu\n- CentOS/RHEL\n\n```bash\nsudo apt install jq\n```\n\n\n\n**语法**：\n\n```bash\njq [options] <jq filter> [file...]\njq [options] --args <jq filter> [strings...]\njq [options] --jsonargs <jq filter> [JSON_TEXTS...]\n```\n\n\n\n**选项**：\n\n- `-c`：使用紧凑而不是漂亮的输出。\n- `-n`：使用 `null` 作为单个输入值。\n- `-e`：根据输出设置退出状态代码。\n- `-s`：将所有输入读取（slurp）到数组中；对其应用过滤器。\n- `-r`：输出原始字符串，而不是 JSON 文本。\n- `-R`：读取原始字符串，而不是 JSON文本。\n- `-C`：为 JSON 着色。\n- `-M`：单色（不要为 JSON 着色）。\n- `-S`：在输出上排序对象的键。\n- `--tab`：使用制表符进行缩进。\n- `--arg a v`：将变量 `$a` 设置为值 `<v>`。\n- `--argjson a v`：将变量 `$a` 设置为 JSON 格式的值 `<v>`。\n- `--slurpfile a f`：将变量 `$a` 设置为从 `<f>` 读取的 JSON 文本数组。\n- `--rawfile a f`：将变量 `$a` 设置为包含 `<f>` 内容的字符串。\n- `--args`：其余参数是字符串参数，而不是文件。\n- `--jsonargs`：其余的参数是 JSON 参数，而不是文件。\n- `--`：终止参数处理。\n\n## 示例\n\n以漂亮的方式输出全部 JSON 数据：\n\n```bash\n$ echo '{ \"home\": { \"bedroom\": { \"temperature\": 25.0 } } }' | jq '.'\n{\n  \"home\": {\n    \"bedroom\": {\n      \"temperature\": 25\n    }\n  }\n}\n```\n\n\n\n以紧凑的方式输出全部 JSON 数据：\n\n```bash\n$ echo '{ \"home\": { \"bedroom\": { \"temperature\": 25.0 } } }' | jq -c '.'\n{\"home\":{\"bedroom\":{\"temperature\":25}}}\n```\n\n\n\n获取一个键的值（可以试试 `.home`、`.home.bedroom`、`.home?` 等过滤条件）：\n\n```bash\n$ echo '{ \"home\": { \"bedroom\": { \"temperature\": 25.0 } } }' | jq '.home.bedroom.temperature'\n25\n```\n\n\n\n数组运算（可以试试 `.[]`、`.[]?`、`.[2]`、`.[0:10]` 等过滤条件）：\n\n```bash\n$ echo '[{\"name\":\"bedroom1\", \"temp\":22.0}, {\"name\":\"bedroom2\", \"temp\":28.0}]' | jq '.[1]'\n{\n  \"name\": \"bedroom2\",\n  \"temp\": 28\n}\n```\n\n\n\n构造一个数组/对象（通过 `[], {}`）：\n\n```bash\n$ echo '{\"user\":\"stedolan\",\"titles\":[\"JQ Primer\", \"More JQ\"]}' | jq '{user, title: .titles[]}'\n{\n  \"user\": \"stedolan\",\n  \"title\": \"JQ Primer\"\n}\n{\n  \"user\": \"stedolan\",\n  \"title\": \"More JQ\"\n}\n```\n\n\n\n计算一个值的长度（通过 `length`）：\n\n```bash\n$ echo '[[1,2], \"string\", {\"a\":2}, null]' | jq '.[] | length'\n2\n6\n1\n0\n```\n\n\n\n取出数组中的键（通过 `keys`）：\n\n```bash\n$ echo '{\"abc\": 1, \"abcd\": 2, \"Foo\": 3}' | jq 'keys'\n[\n  \"Foo\",\n  \"abc\",\n  \"abcd\"\n]\n```\n\n\n\n使用多个过滤器（通过 `,`）：\n\n```bash\n$ echo '{ \"foo\": 42, \"bar\": \"something else\", \"baz\": true}' | jq '.foo, .bar'\n42\n\"something else\"\n```\n\n\n\n通过管道将一个过滤器的输出当做下一个过滤器的输入（通过 `|`）：\n\n```bash\n$ echo '[{\"name\":\"bedroom1\", \"temp\":22.0}, {\"name\":\"bedroom2\", \"temp\":28.0}]' | jq '.[] | .name'\n\"bedroom1\"\n\"bedroom2\"\n```\n\n\n\n通过 `select()` 选择器筛选，选出大于等于 3 的值：\n\n```bash\n$ echo '[1,5,3,2,0,4,7]' | jq 'map(select(. >= 3))'\n[\n  5,\n  3,\n  4,\n  7\n]\n```\n\n\n\n通过 `map()` 将每个输入的值加一：\n\n```bash\n$ echo '[1,2,3]' | jq 'map(.+1)'\n[\n  2,\n  3,\n  4\n]\n```\n\n\n\n条件判断（`if-then-else-end`）：\n\n```bash\n$ echo '2' | jq 'if . == 0 then \"zero\" elif . == 1 then \"one\" else \"many\" end'\n\"many\"\n```\n\n\n\n在字符串中插入值并进行运算（通过 `\\()` 表达式）：\n\n```bash\n$ echo '12' | jq '\"The input was \\(.), which is one less than \\(.+1)\"'\n\"The input was 12, which is one less than 13\"\n```\n\n\n\n\n\n# Linux gcc 命令 - GNU C 编译器\n\n## 介绍\n\n**GCC**（英文全拼：GNU Compiler Collection）是 GNU 工具链的主要组成部分，是一套以 GPL 和 LGPL 许可证发布的程序语言编译器自由软件，由 Richard Stallman 于 1985 年开始开发。\n\nGCC 原名为 GNU C语言编译器，因为它原本只能处理 C 语言，但如今的 GCC 不仅可以编译 C、C++ 和 Objective-C，还可以通过不同的前端模块支持各种语言，包括 Java、Fortran、Ada、Pascal、Go 和 D 语言等等。\n\nGCC 的编译过程可以划分为四个阶段：预处理（Pre-Processing）、编译（Compiling）、汇编（Assembling）以及链接（Linking）。\n\n![img](./Image/Linux命令大全.assets/gcc-process.png)\n\nLinux 程序员可以根据自己的需要控制 GCC 的编译阶段，以便检查或使用编译器在该阶段的输出信息，帮助调试和优化程序。以 C 语言为例，从源文件的编译到可执行文件的运行，整个过程大致如下。\n\n![img](./Image/Linux命令大全.assets/what-happens-when-you-type-gcc.png)\n\n各文件后缀说明如下：\n\n| 后缀             | 描述                    | 后缀     | 描述           |\n| ---------------- | ----------------------- | -------- | -------------- |\n| .c               | C 源文件                | .s/.S    | 汇编语言源文件 |\n| .C/.cc/.cxx/.cpp | C++ 源文件              | .o/.obj  | 目标文件       |\n| .h               | C/C++ 头文件            | .a/.lib  | 静态库         |\n| .i/.ii           | 经过预处理的 C/C++ 文件 | .so/.dll | 动态库         |\n\n**语法**：\n\n```bash\ngcc [options] file...\n```\n\n\n\n**选项**：\n\n- `-pass-exit-codes` ：从一个阶段以最高错误代码退出。\n- `--target-help` ：显示特定于目标的命令行选项。\n- `--help={common|optimizers|params|target|warnings|[^]{joined|separate|undocumented}}[,...]` ：显示特定类型的命令行选项（使用 `-v --help` 显示子进程的命令行选项）。\n- `-dumpspecs` ：显示所有内置规范字符串。\n- `-dumpversion` ：显示编译器的版本。\n- `-dumpmachine` ：显示编译器的目标处理器。\n- `-print-search-dirs` ：显示编译器搜索路径中的目录。\n- `-print-libgcc-file-name` ：显示编译器配套库的名称。\n- `-print-file-name=<lib>` ：显示库 `<lib>` 的完整路径。\n- `-print-prog-name=<prog>` ：显示编译器组件 `<prog>` 的完整路径。\n- `-print-multiarch` ：显示目标的规范化 GNU 三元组，用作库路径中的一个组件。\n- `-print-multi-directory` ：显示 libgcc 版本的根目录。\n- `-print-multi-lib` ：显示命令行选项和多个库搜索目录之间的映射。\n- `-print-multi-os-directory` ：显示操作系统库的相对路径。\n- `-print-sysroot` ：显示目标库目录。\n- `-print-sysroot-headers-suffix` ：显示用于查找标题的 sysroot 后缀。\n- `-Wa,<options>` ：将逗号分隔的 `<options>` 传递给汇编器（assembler）。\n- `-Wp,<options>` ：将逗号分隔的 `<options>` 传递给预处理器（preprocessor）。\n- `-Wl,<options>` ：将逗号分隔的 `<options>` 传递给链接器（linker）。\n- `-Xassembler <arg>` ：将 `<arg>` 传递给汇编器（assembler）。\n- `-Xpreprocessor <arg>` ：将 `<arg>` 传递给预处理器（preprocessor）。\n- `-Xlinker <arg>` ：将 `<arg>` 传递给链接器（linker）。\n- `-save-temps` ：不用删除中间文件。\n- `-save-temps=<arg>` ：不用删除指定的中间文件。\n- `-no-canonical-prefixes` ：在构建其他 gcc 组件的相对前缀时，不要规范化路径。\n- `-pipe` ：使用管道而不是中间文件。\n- `-time` ：为每个子流程的执行计时。\n- `-specs=<file>` ：使用 `<file>` 的内容覆盖内置规范。\n- `-std=<standard>` ：假设输入源为 `<standard>`。\n- `--sysroot=<directory>` ：使用 `<directory>` 作为头文件和库的根目录。\n- `-B <directory>` ：将 `<directory>` 添加到编译器的搜索路径。\n- `-v` ：显示编译器调用的程序。\n- `-###` ：与 `-v` 类似，但引用的选项和命令不执行。\n- `-E` ：仅执行预处理（不要编译、汇编或链接）。\n- `-S` ：只编译（不汇编或链接）。\n- `-c` ：编译和汇编，但不链接。\n- `-o <file>` ：指定输出文件。\n- `-pie` ：创建一个动态链接、位置无关的可执行文件。\n- `-I` ：指定头文件的包含路径。\n- `-L` ：指定链接库的包含路径。\n- `-shared` ：创建共享库/动态库。\n- `-static` ：使用静态链接。\n- `--help` ：显示帮助信息。\n- `--version` ：显示编译器版本信息。\n\n## 示例\n\n### 阶段编译\n\n假设有文件 hello.c，内容如下：\n\n```c\n#include <stdio.h>\n\nint main(void)\n{\n    printf(\"Hello, GetIoT\\n\");\n    return 0;\n}\n```\n\n\n\n编译 hello.c，默认输出 a.out\n\n```bash\ngcc hello.c\n```\n\n\n\n编译 hello.c 并指定输出文件为 hello\n\n```bash\ngcc hello.c -o hello\n```\n\n\n\n只执行预处理，输出 hello.i 源文件\n\n```bash\ngcc -E hello.c -o hello.i\n```\n\n\n\n只执行预处理和编译，输出 hello.s 汇编文件\n\n```bash\ngcc -S hello.c\n```\n\n\n\n也可以由 hello.i 文件生成 hello.s 汇编文件\n\n```bash\ngcc -S hello.i -o hello.s\n```\n\n\n\n只执行预处理、编译和汇编，输出 hello.o 目标文件\n\n```bash\ngcc -c hello.c\n```\n\n\n\n也可以由 hello.i 或 hello.s 生成目标文件 hello.o\n\n```bash\ngcc -c hello.i -o hello.o\ngcc -c hello.s -o hello.o\n```\n\n\n\n由 hello.o 目标文件链接成可执行文件 hello\n\n```bash\ngcc hello.o -o hello\n```\n\n\n\n### 使用静态库\n\n创建一个 foo.c 文件，内容如下：\n\n```c\n#include <stdio.h>\n\nvoid foo(void)\n{\n    printf(\"Here is a static library\\n\");\n}\n```\n\n\n\n将 foo.c 编译成静态库 libfoo.a\n\n```bash\ngcc -c foo.c             # 生成 foo.o 目标文件\nar rcs libfoo.a foo.o    # 生成 libfoo.a 静态库\n```\n\n\n\n查看文件描述\n\n```bash\n$ file *\nfoo.c:    C source, ASCII text\nfoo.o:    ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped\nlibfoo.a: current ar archive\n```\n\n\n\n修改 hello.c 文件，调用 foo 函数\n\n```c\n#include <stdio.h>\n\nvoid foo(void);\n\nint main(void)\n{\n    printf(\"Hello, GetIoT\\n\");\n    foo();\n    return 0;\n}\n```\n\n\n\n编译 hello.c 并链接静态库 libfoo.a（加上 `-static` 选项）\n\n```bash\ngcc hello.c -static libfoo.a -o hello\n```\n\n\n\n也可以使用 `-L` 指定库的搜索路径，并使用 `-l` 指定库名\n\n```bash\ngcc hello.c -static -L. -lfoo -o hello\n```\n\n\n\n运行结果\n\n```bash\n$ ./hello\nHello, GetIoT\nHere is a static library\n```\n\n\n\n查看 hello 文件描述\n\n```bash\n$ file hello\nhello: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=b72236c2211dd8f0c3003bc02ad5e70bb2354e8c, for GNU/Linux 3.2.0, not stripped\n```\n\n\n\n### 使用共享库\n\n修改 foo.c 文件，内容如下：\n\n```c\n#include <stdio.h>\n\nvoid foo(void)\n{\n    printf(\"Here is a shared library\\n\");\n}\n```\n\n\n\n将其编译为动态库/共享库（由于动态库可以被多个进程共享加载，所以需要使用 `-fPIC` 选项生成位置无关的代码\n\n```bash\ngcc foo.c -shared -fPIC -o libfoo.so\n```\n\n\n\nhello.c 代码无需修改，内容仍然如下：\n\n```c\n#include <stdio.h>\n\nvoid foo(void);\n\nint main(void)\n{\n    printf(\"Hello, GetIoT\\n\");\n    foo();\n    return 0;\n}\n```\n\n\n\n编译 hello.c 并链接共享库 libfoo.so\n\n```bash\ngcc hello.c libfoo.so -o hello\n```\n\n\n\n也可以使用 `-L` 和 `-l` 选项指定库的路径和名称\n\n```bash\ngcc hello.c -L. -lfoo -o hello\n```\n\n\n\n但是此时运行 hello 程序失败\n\n```bash\n$ ./hello\n./hello: error while loading shared libraries: libfoo.so: cannot open shared object file: No such file or directory\n```\n\n\n\n原因是找不到 libfoo.so 共享库\n\n```bash\n$ ldd hello\n        linux-vdso.so.1 (0x00007fff5276d000)\n        libfoo.so => not found\n        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fcc90fa7000)\n        /lib64/ld-linux-x86-64.so.2 (0x00007fcc911bd000)\n```\n\n\n\n这是因为 libfoo.so 并不在 Linux 系统的默认搜索目录中，解决办法是我们主动告诉系统，libfoo.so 共享库在哪里。\n\n**方式一**：设置环境变量 `LD_LIBRARY_PATH`\n\n```bash\nexport LD_LIBRARY_PATH=$(pwd)\n```\n\n\n\n将 libfoo.so 所在的当前目录添加到 `LD_LIBRARY_PATH` 变量，再次执行 hello\n\n```bash\n$ ./hello\nHello, GetIoT\nHere is a shared library\n```\n\n\n\n**方式二**：使用 rpath 将共享库位置嵌入到程序\n\n```bash\ngcc hello.c -L. -lfoo -Wl,-rpath=`pwd` -o hello\n```\n\n\n\nrpath 即 run path，是种可以将共享库位置嵌入程序中的方法，从而不用依赖于默认位置和环境变量。这里在链接时使用 `-Wl,-rpath=/path/to/yours` 选项，`-Wl` 会发送以逗号分隔的选项到链接器，注意逗号分隔符后面没有空格哦。\n\n这种方式要求共享库必须有一个固定的安装路径，欠缺灵活性，不过如果设置了 `LD_LIBRARY_PATH`，程序加载时也是会到相应路径寻找共享库的。\n\n**方式三**：将 libfoo.so 共享库添加到系统路径\n\n```bash\nsudo cp libfoo.so /usr/lib/\n```\n\n\n\n执行程序\n\n```bash\n$ ./hello\nHello, GetIoT\nHere is a shared library\n```\n\n\n\n如果 hello 程序仍然运行失败，请尝试执行 [ldconfig](https://getiot.tech/linux-command/ldconfig/) 命令更新共享库的缓存列表。\n\n此时，再次查看 hello 程序的共享库依赖\n\n```bash\n$ ldd hello\n        linux-vdso.so.1 (0x00007ffecfbb1000)\n        libfoo.so => /lib/libfoo.so (0x00007f3f3f1ad000)\n        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3f3efbb000)\n        /lib64/ld-linux-x86-64.so.2 (0x00007f3f3f1d6000)\n```\n\n\n\n可以看到 libfoo.so 已经被发现了，其中 /lib 是 /usr/lib 目录的软链接。\n\n示例代码可以在 [GitHub](https://github.com/getiot/linux-c/tree/main/hello) 找到。\n\n\n\n# Linux ldd 命令 - 显示可执行文件的依赖库\n\n## 介绍\n\n**ldd**（英文全拼：list dynamic dependencies）命令列出程序或库文件的动态依赖关系（所依赖的共享库列表）。\n\n**语法**：\n\n```bash\nldd [option]... file...\n```\n\n\n\n**选项**：\n\n- `--version`：打印指令版本号\n- `-v`：详细信息模式，打印所有相关信息\n- `-u`：打印未使用的直接依赖\n- `-d`：执行重定位和报告任何丢失的对象\n- `-r`：执行数据对象和函数的重定位，并且报告任何丢失的对象和函数\n- `--help`：显示帮助信息\n\n**参数**：指定可执行程序或者库文件\n\n**原理**： ldd 不是个可执行程式，而只是个 shell 脚本；ldd 显示可执行模块的 dependency 的工作原理，其实质是通过 ld-linux.so（elf 动态库的装载器）来实现的。\n\n## 示例\n\n示例：查看 ls 程序运行所依赖的库\n\n```bash\n$ ldd /bin/ls\n        linux-vdso.so.1 (0x00007ffcc3563000)\n        libselinux.so.1 => /lib64/libselinux.so.1 (0x00007f87e5459000)\n        libcap.so.2 => /lib64/libcap.so.2 (0x00007f87e5254000)\n        libc.so.6 => /lib64/libc.so.6 (0x00007f87e4e92000)\n        libpcre.so.1 => /lib64/libpcre.so.1 (0x00007f87e4c22000)\n        libdl.so.2 => /lib64/libdl.so.2 (0x00007f87e4a1e000)\n        /lib64/ld-linux-x86-64.so.2 (0x00005574bf12e000)\n        libattr.so.1 => /lib64/libattr.so.1 (0x00007f87e4817000)\n        libpthread.so.0 => /lib64/libpthread.so.0 (0x00007f87e45fa000)\n```\n\n\n\n每一行会有两列或三列，含义如下：\n\n- 第1列：程序需要依赖什么库\n- 第2列：系统提供的与程序需要的库所对应的库\n- 第3列：库加载的开始地址\n\n通过上面的信息，我们可以得到以下几个信息：\n\n1. 通过对比第1列和第2列，我们可以分析程序需要依赖的库和系统实际提供的，是否相匹配\n2. 通过观察第3列，我们可以知道在当前的库中的符号在对应的进程的地址空间中的开始位置\n\n如果依赖的某个库找不到，通过这个命令可以迅速定位问题所在。\n\n\n\n# Linux ldconfig 命令 - 更新共享库缓存\n\n## 介绍\n\n**ldconfig** 命令用于管理 Linux 系统的动态链接库。\n\n执行 ldconfig 命令，默认会在 `/lib` 和 `/usr/lib` 目录以及动态库配置文件 `/etc/ld.so.conf` 内所列出的目录下，搜索出可共享的动态链接库（格式如 `lib*.so*`），进而创建出动态装入程序（ld.so）所需的连接和缓存文件。缓存文件默认为 `/etc/ld.so.cache`，此文件保存已排好序的动态链接库名字列表，为了让动态链接库为系统所共享，就需要运行动态链接库的管理命令 ldconfig。\n\nldconfig 通常在系统启动时运行，当用户安装了一个新的动态链接库时，就需要手动运行该命令，以更新缓存文件。ldconfig 所做操作只与程序运行时有关，和编译过程没有关系，因此编译时需要加 `-L` 指定库路径的还得加上。\n\n**语法**：\n\n```bash\nldconfig [-nNvXV] [-f conf] [-C cache] [-r root] directory...\nldconfig -l [-v] library...\nldconfig -p\n```\n\n\n\n**选项**：\n\n- `-v` 或 `--verbose` ：用此选项时，ldconfig 将显示正在扫描的目录及搜索到的动态链接库，还有它所创建的连接的名字。\n- `-n` ：用此选项时，ldconfig 仅扫描命令行指定的目录，不扫描默认目录（/lib、/usr/lib），也不扫描配置文件 /etc/ld.so.conf 所列的目录。\n- `-N` ：指示 ldconfig 不重建缓存文件（/etc/ld.so.cache），若未用 `-X` 选项，ldconfig 照常更新文件的连接。\n- `-X` ：指示 ldconfig 不更新文件的连接，若未用 `-N` 选项，则缓存文件正常更新。\n- `-f CONF` ：指定动态链接库的配置文件为 CONF，系统默认为 /etc/ld.so.conf。\n- `-C CACHE` ：指定生成的缓存文件为 CACHE，系统默认的是 /etc/ld.so.cache，此文件存放已排好序的可共享的动态链接库的列表。\n- `-r ROOT` ：改变应用程序的根目录为 ROOT（是调用 chroot 函数实现的）。选择此项时，系统默认的配置文件 /etc/ld.so.conf，实际对应的为 ROOT/etc/ld.so.conf。如用 -r /usr/zzz 时，打开配置文件 /etc/ld.so.conf 时，实际打开的是 /usr/zzz/etc/ld.so.conf 文件。用此选项，可以大大增加动态链接库管理的灵活性。\n- `-l` ：通常情况下，ldconfig 搜索动态链接库时将自动建立动态链接库的连接，选择此项时，将进入专家模式，需要手工设置连接，一般用户不用此项。\n- `-p` 或 `--print-cache` ：指示 ldconfig 打印出当前缓存文件所保存的所有共享库的名字。\n- `-c FORMAT` 或 `--format=FORMAT` ：指定缓存文件所使用的格式，共有三种：old（老格式），new（新格式）和 compat（兼容格式，此为默认格式）。\n- `-V`, `--version` ：显示版本信息并退出。\n- `-?` 或 `--help` 或 `--usage` ：显示帮助信息并退出。\n\n## 示例\n\n将 libfoo.so 共享库添加到系统标准库路径\n\n```bash\n$ cp /home/username/foo/libfoo.so /usr/lib\n$ chmod 0755 /usr/lib/libfoo.so\n```\n\n\n\n更新共享库缓存列表\n\n```bash\n$ sudo ldconfig\n```\n\n\n\n更新完成后检查（从当前缓存文件的中搜索 libfoo.so 库）\n\n```bash\n$ ldconfig -p | grep foo\n\tlibfoo.so (libc6) => /usr/lib/libfoo.so\n```\n\n\n\n\n\n# Linux objdump 命令 - 显示目标文件信息\n\n## 介绍\n\n**objdump** 命令用于显示二进制目标文件的信息，也就是以一种可阅读的格式让开发者更多地了解二进制文件可能带有的附加信息。它是 GNU Binutils 工具集中的一个命令。\n\n**语法**：\n\n```bash\nobjdump <options> <file>\n```\n\n\n\n**选项**：\n\n- `-a`, `--archive-headers` ：显示档案库的成员信息，类似 `ls -l` 将 lib*.a 的信息列出。\n- `-b`, `--target=BFDNAME` ：指定目标码格式。这不是必须的，objdump 能自动识别许多格式。\n- `-C`, `--demangle[=STYLE]` ：将底层的符号名解码成用户级名字，除了去掉所开头的下划线之外，还使得 C++ 函数名以可理解的方式显示出来。\n- `-d`, `--disassemble` ：反汇编可执行的 section 内容。\n- `-D`, `--disassemble-all` ：反汇编所有 section 内容。\n- `-e`, `--debugging-tags` ：类似 -g 选项，但是生成的信息是和 ctags 工具相兼容的格式。\n- `-f`, `--file-headers` ：显示文件头信息。\n- `-g`, `--debugging` ：显示调试信息。企图解析保存在文件中的调试信息并以 C 语言的语法显示出来。仅仅支持某些类型的调试信息。有些其他的格式被 `readelf -w` 支持。\n- `-h`, `--[section-]headers` ：显示目标文件各个 section 的头部摘要信息。\n- `-i`, `--info` ：显示对于 -b 或者 -m 选项可用的架构和目标格式列表。\n- `-j`, `--section=NAME` ：仅仅显示指定名称为 name 的 section 的信息。\n- `-m`, `--architecture=MACHINE` ：指定反汇编目标文件时使用的架构，当待反汇编文件本身没描述架构信息的时候（比如 S-records），这个选项很有用。可以用 -i 选项列出这里能够指定的架构。\n- `-r`, `--reloc` ：显示文件的重定位入口。如果和 -d 或者 -D 一起使用，重定位部分以反汇编后的格式显示出来。\n- `-R`, `--dynamic-reloc` ：显示文件的动态重定位入口，仅仅对于动态目标文件有意义，比如某些共享库。\n- `-s`, `--full-contents` ：显示指定 section 的完整内容。默认所有的非空 section 都会被显示。\n- `-S`, `--source` ：尽可能反汇编出源代码，尤其当编译的时候指定了-g 这种调试参数时，效果比较明显。隐含了-d 参数。\n- `--start-address=ADDR` ：从指定地址开始显示数据，该选项影响 -d、-r 和 -s 选项的输出。\n- `--stop-address=ADDR` ：显示数据直到指定地址为止，该项影响 -d、-r 和 -s 选项的输出。\n- `-t`, `--syms` ：显示文件的符号表入口。类似于 `nm -s` 提供的信息。\n- `-T`, `--dynamic-syms` ：显示文件的动态符号表入口，仅仅对动态目标文件意义，比如某些共享库。它显示的信息类似于 `nm -D|--dynamic` 显示的信息。\n- `-x`, `--all-headers` ：显示所有可用的头信息，包括符号表、重定位入口。-x 等价于 -a -f -h -r -t 同时指定。\n- `-z`, `--disassemble-zeroes` ：一般反汇编输出将省略大块的零，该选项使得这些零块也被反汇编。\n- `-H`, `--help` ：显示帮助信息。\n- `-v`, `--version` ：显示版本信息。\n\n## 示例\n\n查看本机目标结构（使用大端还是小端存储）\n\n```bash\nobjdump -i\n```\n\n\n\n查看所有的符号以及它们所在段（显示符号表入口）\n\n```bash\nobjdump -t main.o\n```\n\n\n\n打印主要段的信息\n\n```bash\nobjdump -h main.o\n```\n\n\n\n打印更多的详细信息\n\n```bash\nobjdump -x main.o\n```\n\n\n\n将所有段的内容以十六进制方式打印出来\n\n```bash\nobjdump -s main.o\n```\n\n\n\n显示 main.o 文件中的 text 段的内容\n\n```bash\nobjdump --section=.text -s main.o\n```\n\n\n\n将所有包含指令的段反汇编\n\n```bash\nobjdump -d main.o\n```\n\n\n\n\n\n# Linux readelf 命令 - 显示 ELF 文件信息\n\n## 介绍\n\n**readelf** 命令用于显示一个或者多个 ELF 格式目标文件的信息。可以支持 32 位或 64 位的 elf 格式文件，也支持包含 elf 文件的文档（这里一般指的是使用 ar 命令将一些 elf 文件打包之后生成的例如 lib*.a 之类的静态库文件）。\n\nreadelf 和 [objdump](https://getiot.tech/linux-command/objdump/) 提供的功能类似，但是它显示的信息更为具体，并且它不依赖 BFD 库（BFD 库是一个 GNU 项目，它的目标就是希望通过一种统一的接口来处理不同的目标文件），所以即使 BFD 库有什么 bug 存在的话也不会影响到 readelf 程序。\n\n**语法**\n\n```shell\nreadelf <options> elf-file ...\n```\n\n\n\n**选项**\n\n- `-a`, `--all` ：显示全部信息，等价于 -h -l -S -s -r -d -V -A -I。\n- `-h`, `--file-header` ：显示 ELF 文件开始的文件头信息。\n- `-l`, `--program-headers` ：显示程序头（段头）信息（如果有的话）。\n- `--segments` ：是 --program-headers 的别名。\n- `-S`, `--section-headers` ：显示节头信息（如果有的话）。\n- `--sections` ：是 --section-headers 的别名。\n- `-g`, `--section-groups` ：显示节组信息（如果有的话）。\n- `-t`, `--section-details` ：显示节的详细信息（-S 的）。\n- `-e`, `--headers` ：显示全部头信息，等价于 -h -l -S。\n- `-s`, `--syms` ：显示符号表段中的项（如果有的话）。\n- `--symbols` ：是 --syms 的别名。\n- `-n`, `--notes` ：显示 note 段（内核注释）的信息。\n- `-r`, `--relocs` ：显示可重定位段的信息。\n- `-u`, `--unwind` ：显示 unwind 段信息。当前只支持 IA64 ELF 的 unwind 段信息。\n- `-d`, `--dynamic` ：显示动态段的信息。\n- `-V`, `--version-info` ：显示版本段的信息。\n- `-A`, `--arch-specific` ：显示 CPU 构架信息。\n- `-D`, `--use-dynamic` ：使用动态段中的符号表显示符号，而不是使用符号段。\n- `-x`, `--hex-dump=<number|name>` ：以十六进制方式显示指定段内内容。number 指定段表中段的索引，或字符串指定文件中的段名。\n- `-p`, `--string-dump=<number|name>` ：以字符串方式显示指定段内内容。number 指定段表中段的索引，或字符串指定文件中的段名。\n- `-R`, `--relocated-dump=<number|name>` ：以重定位字节方式显示指定段内内容。number 指定段表中段的索引，或字符串指定文件中的段名。\n- `-w[lLiaprmfFsoRtUuTgAckK]` ：显示调试段中指定的内容。\n- `-I`, `--histogram` ：显示符号的时候，显示 bucket list 长度的柱状图。\n- `-W`, `--wide` ：宽行输出。\n- `-H`, `--help` ：显示帮助信息。\n- `-v`, `--version` ：显示版本信息。\n\n## 示例\n\n读取可执行文件 a.out 的 ELF 文件头信息\n\n```shell\n$ readelf -h a.out\nELF 头：\n  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n  类别:                              ELF64\n  数据:                              2 补码，小端序 (little endian)\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI 版本:                          0\n  类型:                              EXEC (可执行文件)\n  系统架构:                          Advanced Micro Devices X86-64\n  版本:                              0x1\n  入口点地址：               0x401040\n  程序头起点：          64 (bytes into file)\n  Start of section headers:          15288 (bytes into file)\n  标志：             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           56 (bytes)\n  Number of program headers:         11\n  Size of section headers:           64 (bytes)\n  Number of section headers:         29\n  Section header string table index: 28\n```\n\n\n\n读取目标文件 ldal.o 的 ELF 文件头信息\n\n```shell\n$ readelf -h ldal.o\nELF 头：\n  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n  类别:                              ELF64\n  数据:                              2 补码，小端序 (little endian)\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI 版本:                          0\n  类型:                              REL (可重定位文件)\n  系统架构:                          Advanced Micro Devices X86-64\n  版本:                              0x1\n  入口点地址：               0x0\n  程序头起点：          0 (bytes into file)\n  Start of section headers:          25320 (bytes into file)\n  标志：             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           0 (bytes)\n  Number of program headers:         0\n  Size of section headers:           64 (bytes)\n  Number of section headers:         26\n  Section header string table index: 25\n```\n\n\n\n读取共享库文件 libldal.so 的 ELF 文件头信息\n\n```shell\n$ readelf -h libldal.so\nELF 头：\n  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n  类别:                              ELF64\n  数据:                              2 补码，小端序 (little endian)\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI 版本:                          0\n  类型:                              DYN (共享目标文件)\n  系统架构:                          Advanced Micro Devices X86-64\n  版本:                              0x1\n  入口点地址：               0x6140\n  程序头起点：          64 (bytes into file)\n  Start of section headers:          226976 (bytes into file)\n  标志：             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           56 (bytes)\n  Number of program headers:         11\n  Size of section headers:           64 (bytes)\n  Number of section headers:         36\n  Section header string table index: 35\n```\n\n\n\n查看可执行文件 a.out 的 ELF 文件程序头表信息\n\n```shell\n$ readelf -l a.out\n\nElf 文件类型为 EXEC (可执行文件)\nEntry point 0x401040\nThere are 11 program headers, starting at offset 64\n\n程序头：\n  Type           Offset             VirtAddr           PhysAddr\n                 FileSiz            MemSiz              Flags  Align\n  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040\n                 0x0000000000000268 0x0000000000000268  R      0x8\n  INTERP         0x00000000000002a8 0x00000000004002a8 0x00000000004002a8\n                 0x000000000000001c 0x000000000000001c  R      0x1\n      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]\n  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000\n                 0x0000000000000438 0x0000000000000438  R      0x1000\n  LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000\n                 0x00000000000004a5 0x00000000000004a5  R E    0x1000\n  LOAD           0x0000000000002000 0x0000000000402000 0x0000000000402000\n                 0x0000000000000258 0x0000000000000258  R      0x1000\n  LOAD           0x0000000000002e10 0x0000000000403e10 0x0000000000403e10\n                 0x0000000000000420 0x0000000000000428  RW     0x1000\n  DYNAMIC        0x0000000000002e20 0x0000000000403e20 0x0000000000403e20\n                 0x00000000000001d0 0x00000000000001d0  RW     0x8\n  NOTE           0x00000000000002c4 0x00000000004002c4 0x00000000004002c4\n                 0x0000000000000044 0x0000000000000044  R      0x4\n  GNU_EH_FRAME   0x00000000000020e0 0x00000000004020e0 0x00000000004020e0\n                 0x000000000000004c 0x000000000000004c  R      0x4\n  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000\n                 0x0000000000000000 0x0000000000000000  RW     0x10\n  GNU_RELRO      0x0000000000002e10 0x0000000000403e10 0x0000000000403e10\n                 0x00000000000001f0 0x00000000000001f0  R      0x1\n\n Section to Segment mapping:\n  段节...\n   00\n   01     .interp\n   02     .interp .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt\n   03     .init .plt .text .fini\n   04     .rodata .eh_frame_hdr .eh_frame\n   05     .init_array .fini_array .dynamic .got .got.plt .data .bss\n   06     .dynamic\n   07     .note.gnu.build-id .note.ABI-tag\n   08     .eh_frame_hdr\n   09\n   10     .init_array .fini_array .dynamic .got\n```\n\n\n\n显示 a.out 文件中的所有段，即查看段表\n\n```shell\n$ readelf -S a.out\nThere are 29 section headers, starting at offset 0x3bb8:\n\n节头：\n  [号] 名称              类型             地址              偏移量\n       大小              全体大小          旗标   链接   信息   对齐\n  [ 0]                   NULL             0000000000000000  00000000\n       0000000000000000  0000000000000000           0     0     0\n  [ 1] .interp           PROGBITS         00000000004002a8  000002a8\n       000000000000001c  0000000000000000   A       0     0     1\n  [ 2] .note.gnu.build-i NOTE             00000000004002c4  000002c4\n       0000000000000024  0000000000000000   A       0     0     4\n  [ 3] .note.ABI-tag     NOTE             00000000004002e8  000002e8\n       0000000000000020  0000000000000000   A       0     0     4\n  [ 4] .gnu.hash         GNU_HASH         0000000000400308  00000308\n       000000000000001c  0000000000000000   A       5     0     8\n  [ 5] .dynsym           DYNSYM           0000000000400328  00000328\n       0000000000000060  0000000000000018   A       6     1     8\n  [ 6] .dynstr           STRTAB           0000000000400388  00000388\n       000000000000003f  0000000000000000   A       0     0     1\n  ......\n```\n\n\n\n\n\n# Linux size 命令 - 显示目标文件的大小\n\n## 介绍\n\nLinux 系统中的 **size** 命令用于显示指定目标文件或可执行文件各段的大小及其总和。\n\n通常，size 针对每个目标文件或可执行文件，包括档案文件中的每个模块生成一行输出信息。其中，*objfiles* 是需要考察的一个或一组目标文件或可执行文件，也可以是一个 ar 档案文件，表示考察其中的所有模块文件。如果未指定文件，默认的输入文件是当前目录中的 a.out 文件。\n\n**语法**：\n\n```bash\nsize [选项] [文件]\n```\n\n\n\n**选项**：\n\n- `-A|-B|-G, --format={sysv|berkeley|gnu}`：指定代码段的显示格式。其中，\n\n  - `-A` 或 `--format=sysv` 表示 System V 格式；\n  - `-B` 或 `--format=berkeley` 表示默认的 Berkeley 格式；\n  - `-G` 或 `--format=gnu` 表示 GNU 格式。\n\n- `-o|-d|-x, --radix={8|10|16}`：指定输出数值的表示方式，其中，\n\n  - `-o` 或 `--radix=8` 表示八进制数值；\n  - `-d` 或 `--radix=10` 表示十进制数值；\n  - `-x` 或 `--radix=16` 表示十六进制数值。\n\n  在每一行输出信息中，各段的总和总是采用两种形式分别给出：十进制与十六进制数值（`-d` 或 `-x` 选项），八进制与十六进制数值（`-o` 选项）。\n\n- `-t, --totals`：最后增加一行统计数据，显示所有目标文件或可执行文件的纵向累计（仅适用于 `-B` 选项的 Berkeley 显示格式）。\n\n- `--common`：显示目标文件或可执行文件中通用标识符（*COM* syms）部分占用的空间总和。当使用 Berkeley 格式显示时，这个数据包含在 bss 段中。\n\n- `--target=<bfdname>`：设置二进制文件格式。\n\n- `@<file>`：从指定的文件 `<file>` 中读取命令行选项。\n\n- `-h, --help`：显示帮助信息。\n\n- `-v, --version`：显示版本信息。\n\n## 示例\n\n采用默认的 Berkeley 格式显示 bash 和 find 命令文件各段的大小与总和：\n\n```shell\n$ size -B /bin/bash /bin/find\n   text\t   data\t    bss\t    dec\t    hex\tfilename\n1127345\t  47356\t  40056\t1214757\t 128925\t/bin/bash\n 300059\t  10408\t   2712\t 313179\t  4c75b\t/bin/find\n```\n\n\n\n在上述基础上增加一行统计数据：\n\n```bash\n$ size -Bt /bin/bash /bin/find\n   text\t   data\t    bss\t    dec\t    hex\tfilename\n1127345\t  47356\t  40056\t1214757\t 128925\t/bin/bash\n 300059\t  10408\t   2712\t 313179\t  4c75b\t/bin/find\n1427404\t  57764\t  42768\t1527936\t 175080\t(TOTALS)\n```\n\n\n\n\n\n# Linux nm 命令 - 列出目标文件的符号表\n\n## 介绍\n\n**nm**（英文全拼：names）命令是 [GNU Binutils](https://www.gnu.org/software/binutils/) 二进制工具集的一员，用于显示二进制文件（例如库文件和可执行文件等）中的符号。如果没有为 nm 命令指明目标文件，则 nm 假定目标文件是 a.out。\n\n**语法**：\n\n```bash\nnm [选项] [文件]\n```\n\n\n\n**选项**：\n\n- `-A`, `-o`, `--print-file-name` ：在找到的各个符号的名字前加上文件名，而不是在此文件的所有符号前只出现文件名一次。\n- `-a`, `--debug-syms` ：显示调试符号。\n- `-B`, `--format=bsd` ：用来兼容 MIPS 的 nm。\n- `-C`, `--demangle[=STYLE]` ：将低级符号名解码（demangle）成用户级名字，比如去除编译时添加的前置下划线，这样可以使得 C++ 函数名具有可读性。不同的编译器符号修饰风格不同，可以使用 =STYLE 参数来选择合适的解码风格。\n- `-D`, `--dynamic` ：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。\n- `-f`, `--format=FORMAT` ：FORMAT 可取值 bsd、sysv 或 posix，该选项在 GNU nm 中有用，默认为 bsd。\n- `-g`, `--extern-only` ：仅显示外部符号。\n- `-h`, `--help` ：显示帮助信息。\n- `-l`, `--line-numbers` ：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。\n- `-n`, `-v`, `--numeric-sort` ：按符号对应地址的顺序排序，而非按符号名的字符顺序。\n- `-P`, `--portability` ：使用 POSIX.2 标准输出格式代替默认的输出格式。等同于 -f posix。\n- `-p`, `--no-sort` ：按目标文件中遇到的符号顺序显示，不排序。\n- `-r`, `--reverse-sort` ：逆序排序。例如，升序变为降序。\n- `-S`, `--print-size` ：以 BSD 输出样式输出已定义符号的值和大小。对于不记录符号大小的目标文件格式，此选项不起作用，除非使用了--size sort，在这种情况下，将显示计算的大小。\n- `-s`, `--print-armap` ：当列出库中成员的符号时，同时列出索引。索引的内容包含：模块与其包含的名字的定义之间的映射。\n- `-t`, `--radix=RADIX` ：使用基数 radix 进制显示符号值。radix 只能为 d（十进制）、o（八进制）或 x（十六进制）。\n- `-u`, `--undefined-only` ：仅显示没有定义的符号。\n- `-V`, `--version` ：显示版本信息并退出。\n- `-X` ：为了与 AIX 版本的 nm 兼容，选项 -X 将被忽略。它可接受一个参数，该参数必须是字符串 32_64。AIX nm 的默认模式对应于 -X 32，GNU nm 不支持模式 -X 32。\n- `--defined-only` ：仅显示有定义的符号。\n- `--no-demangle` ：不解码低级符号名，这是默认选项。\n- `--plugin NAME` ：加载名为 name 的插件以添加对额外目标类型的支持。只有在启用插件支持的情况下构建了工具链时，此选项才可用。\n- `--size-sort` ：按符号大小排列。\n- `--special-syms` ：显示目标相关的具体特殊含义的符号。这些符号通常被特定目标文件用于某些特殊处理，当包含在正常符号列表中时通常不起作用。例如，对于 ARM 目标，此选项将跳过用于标记 ARM 代码、Thumb 代码和数据之间转换的映射符号。\n- `--synthetic` ：输出合成符号。合成符号是链接器为各种目的创建的特殊符号，默认情况下不会显示它们，因为它们不是二进制文件源代码的一部分。\n- `--target=BFDNAME` ：指定系统默认格式以外的目标文件格式。\n\n## 示例\n\n假设 hello.c 代码如下：\n\n```c\n#include <stdio.h>\n\nstatic int g_test;\nint baud_table[5] = {9600, 19200, 38400, 57600, 115200};\n\nint main(void)\n{\n    int l_test;\n    printf(\"Hello, GetIoT\\n\");\n    return 0;\n}\n```\n\n\n\n执行 `gcc hello.c` 编译后，查看 a.out 文件中所有的符号\n\n```bash\n$ nm a.out \n0000000000004010 D baud_table\n0000000000004024 B __bss_start\n0000000000004024 b completed.8060\n                 w __cxa_finalize@@GLIBC_2.2.5\n0000000000004000 D __data_start\n0000000000004000 W data_start\n0000000000001090 t deregister_tm_clones\n0000000000001100 t __do_global_dtors_aux\n0000000000003dc0 d __do_global_dtors_aux_fini_array_entry\n0000000000004008 D __dso_handle\n0000000000003dc8 d _DYNAMIC\n0000000000004024 D _edata\n0000000000004030 B _end\n00000000000011e8 T _fini\n0000000000001140 t frame_dummy\n0000000000003db8 d __frame_dummy_init_array_entry\n000000000000215c r __FRAME_END__\n0000000000003fb8 d _GLOBAL_OFFSET_TABLE_\n                 w __gmon_start__\n0000000000002014 r __GNU_EH_FRAME_HDR\n0000000000004028 b g_test\n0000000000001000 t _init\n0000000000003dc0 d __init_array_end\n0000000000003db8 d __init_array_start\n0000000000002000 R _IO_stdin_used\n                 w _ITM_deregisterTMCloneTable\n                 w _ITM_registerTMCloneTable\n00000000000011e0 T __libc_csu_fini\n0000000000001170 T __libc_csu_init\n                 U __libc_start_main@@GLIBC_2.2.5\n0000000000001149 T main\n                 U puts@@GLIBC_2.2.5\n00000000000010c0 t register_tm_clones\n0000000000001060 T _start\n0000000000004028 D __TMC_END__\n```\n\n\n\n## 符号说明\n\n对于每一个符号来说，其类型如果是小写的，则表明该符号是 local 的；大写则表明该符号是 global（external）的。\n\n- A 该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。\n\n- B 该符号的值出现在非初始化数据段（bss）中。例如，在一个文件中定义全局 static int test。则该符号 test 的类型为 b，位于 bss section 中。其值表示该符号在 bss 段中的偏移。一般而言，bss 段分配于 RAM 中。\n\n- C 该符号为 common。common symbol 是未初始话数据段。该符号没有包含于一个普通 section 中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个 c 文件中，定义 int test，并且该符号在别的地方会被引用，则该符号类型即为 C。否则其类型为 B。\n\n- D 该符号位于初始化数据段中。一般来说，分配到 data section 中。\n\n  例如：定义全局 `int baud_table[5] = {9600, 19200, 38400, 57600, 115200};`，会分配到初始化数据段中。\n\n- G 该符号也位于初始化数据段中。主要用于 small object 提高访问 small data object 的一种方式。\n\n- I 该符号是对另一个符号的间接引用。\n\n- N 该符号是一个 debugging 符号。\n\n- R 该符号位于只读数据区。\n\n  例如：定义全局 `const int test[] = {123, 123};`，则 test 就是一个只读数据区的符号。\n\n- S 符号位于非初始化数据区，用于 small object。\n\n- T 该符号位于代码区 text section。\n\n- U 该符号在当前文件中是未定义的，即该符号的定义在别的文件中。\n\n  例如：当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为 C，在使用它的文件中，其类型为 U。\n\n- V 该符号是一个 weak object。\n\n- W 该符号是一个弱符号，没有被专门标记为 weak object 符号。\n\n- ? 该符号类型没有定义\n\n\n\n# Linux install 命令 - 复制并安装文件\n\n## 介绍\n\n**install** 命令用于安装、升级软件，或者备份数据。\n\ninstall 的功能和 [cp](https://getiot.tech/linux-command/cp/) 命令类似，都可以将文件/目录拷贝到指定的位置。不同的是，install 允许你控制目标文件的属性，通常用于程序的 Makefile 文件（执行 `make install`），使用它来将程序拷贝到目标（安装）目录。\n\n**语法**：\n\n```shell\ninstall [OPTION]... [-T] SOURCE DEST\ninstall [OPTION]... SOURCE... DIRECTORY\ninstall [OPTION]... -t DIRECTORY SOURCE...\ninstall [OPTION]... -d DIRECTORY...\n```\n\n\n\n**选项**：\n\n- `--backup[=CONTROL]` ：为每个已存在的目的地文件进行备份。\n- `-b` ：类似 `--backup`，但不接受任何参数。\n- `-C`, `--compare` ：比较每对源文件和目标文件，在某些情况下，根本不修改目标\n- `-d`, `--directory` ：所有参数都作为目录处理，而且会创建指定目录的所有主目录。\n- `-D` ：创建 `DEST` 前的所有主目录，然后将 `SOURCE` 复制至 `DEST`，在第一种使用格式中有用。\n- `-g`, `--group=GROUP` ：自行设定所属组，而不是进程目前的所属组。\n- `-m`, `--mode=MODE` ：自行设定权限模式（类似 chmod），而不是 rwxr-xr-x。\n- `-o`, `--owner=OWNER` ：自行设定所有者（只适用于 root 用户）。\n- `-p`, `--preserve-timestamps` ：以 `SOURCE` 文件的访问/修改时间作为相应的目的地文件的时间属性。\n- `-s`, `--strip` ：用 strip 命令删除 symbol table，只适用于第一和第二种使用格式。\n- `-S`, `--suffix=SUFFIX` ：自行指定备份文件的后缀。\n- `-t`, `--target-directory=DIRECTORY` ：将所有 `SOURCE` 参数复制到 `DIRECTORY` 中。\n- `-T`, `--no-target-directory` ：将 `DEST` 视为普通文件。\n- `-v`, `--verbose` ：处理每个文件/目录时显示详细信息（打印出名称）。\n- `--help` ：显示帮助信息并退出。\n- `--version` ：显示版本信息并退出。\n\n## 示例\n\n将 libfoo.so 安装到系统库路径\n\n```shell\ninstall libfoo.so /usr/local/lib\n```\n\n\n\n结果等效于\n\n```shell\ncp libfoo.so /usr/local/lib\n```\n\n\n\n将 hello 程序安装到指定目录，并创建该目录前的主目录\n\n```shell\ninstall -D hello /opt/bin/hello\n```\n\n\n\n结果等效于\n\n```shell\nmkdir -p /opt/bin && cp hello /opt/bin/hello\n```\n\n\n\n提示：以上所有 install 命令执行时都需要 root 权限（加上 sudo 执行）。\n\n\n\n# Linux cat 命令 - 显示文件内容\n\n## 介绍\n\n**cat**（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。常用于在 Shell 终端中显示文件内容。\n\n注意：当文件较大时，文本在屏幕上迅速闪过（滚屏），用户往往看不清所显示的内容。因此，一般用 [more](https://getiot.tech/linux-command/more/) 等命令分屏显示。为了控制滚屏，可以按 Ctrl+S 键，停止滚屏；按 Ctrl+Q 键可以恢复滚屏。按 Ctrl+C（中断）键可以终止该命令的执行，并且返回 Shell 提示符状态。\n\n**语法**：\n\n```bash\ncat [-AbeEnstTuv] [--help] [--version] fileName\n```\n\n\n\n**选项**：\n\n- `-n`, `--number` ：由 1 开始对所有输出的行数编号。\n- `-b`, `--number-nonblank` ：和 `-n` 相似，只不过对于空白行不编号。\n- `-s`, `--squeeze-blank` ：当遇到有连续两行以上的空白行，就代换为一行的空白行。\n- `-v`, `--show-nonprinting` ：使用 `^` 和 `M-` 符号，除了 LFD 和 TAB 之外。\n- `-E`, `--show-ends` ：在每行结束处显示 `$`。\n- `-T`, `--show-tabs` ：将 TAB 字符显示为 `^I`。\n- `-A`, `--show-all` ：等价于 `-vET` 选项。\n- `-e` ：等价于 `-vE` 选项。\n- `-t` ：等价于 `-vT` 选项。\n\n## 示例\n\n把 textfile1 文件的内容加上行号后输入 textfile2 文件\n\n```bash\ncat -n textfile1 > textfile2\n```\n\n\n\n把 textfile1 和 textfile2 文件的内容加上行号（空白行不加）之后将内容附加到 textfile3 文件\n\n```bash\ncat -b textfile1 textfile2 >> textfile3\n```\n\n\n\n清空 test.txt 文档内容\n\n```bash\ncat /dev/null > test.txt\n```\n\n\n\ncat 也可以用来制作镜像文件\n\n```bash\ncat /dev/sdb1 > image-file\n```\n\n\n\n也可以将镜像文件写到磁盘\n\n```bash\ncat image-file > /dev/sdb1\n```\n\n\n\n将多个拆解的 zip 包（如 linux.zip.001、linux.zip.002 和 linux.zip.003）合并成一个 zip 包\n\n```bash\ncat linux.zip* > linux.zip\n```\n\n\n\n\n\n# Linux zcat 命令 - 查看压缩文件内容\n\n## 介绍\n\n**zcat** 命令用于查看压缩文件的内容，而无需对其进行解压缩。\n\n它将压缩文件扩展为标准输出，使你可以查看其内容。zcat 的运行效果与 `gunzip -c` 命令完全相同。\n\n**语法**：\n\n```bash\nzcat [OPTION]... [FILE]...\n```\n\n\n\n**选项**：\n\n- `-c`, `--stdout` ：将文件内容写到标准输出，保持原始文件不变。\n- `-d`, `--decompress` ：执行解压缩操作。\n- `-f`, `--force` ：强制覆盖输出文件并压缩链接。\n- `-h`, `--help` ：显示帮助信息。\n- `-k`, `--keep` ：保留（不删除）输入文件。\n- `-l`, `--list` ：列出压缩文件内容。\n- `-L`, `--license` ：显示软件许可信息。\n- `-n`, `--no-name` 不保存或恢复原始名称和时间戳。\n- `-N`, `--name` ：保存或恢复原始名称和时间戳。\n- `-q`, `--quiet` ：禁用警告信息。\n- `-r`, `--recursive` ：在目录上执行递归操作。\n- `--rsyncable` ：制作 rsync-friendly 存档文件。\n- `-S`, `--suffix=SUF` ：指定 gzip 格式的压缩包的后缀，当后缀不是标准压缩包后缀时使用此选项。\n- `--synchronous` ：同步输出（如果系统崩溃，这会更安全，但速度更慢）。\n- `-t`, `--test` ：测试压缩文件的完整性。\n- `-v`, `--verbose` ：详细模式。\n- `-V`, `--version` ：显示版本信息。\n- `-1`, `--fast` ：更快的压缩速度。\n- `-9`, `--best` ：更高的压缩比。\n\n**参数**：指定压缩文件名。\n\n提示：zcat 是 gzip 软件包中的一个实用程序，上述许多选项参数对于 zcat 查看压缩文件内容来说是无实际效果的。另外，zutils 软件包也提供了 zcat 命令，两者在使用上有一些区别，因此要留意你正在使用的是哪个 zcat 命令。\n\n## 示例\n\n当 Linux 内核配置 `CONFIG_IKCONFIG` 和 `CONFIG_IKCONFIG_PROC` 为 `y` 时，在 /proc 会中出现 config.gz 文件。它是内核提供给用户的当前 Linux 内核配置文件副本，并且是经过 gzip 格式压缩的。\n\n例如，在 /proc/config.gz 文件中查找 IKCONFIG 配置信息：\n\n```bash\nroot@npi:~# zcat /proc/config.gz | grep IKCONFIG\nCONFIG_IKCONFIG=y\nCONFIG_IKCONFIG_PROC=y\n```\n\n\n\n列出 /proc/config.gz 文件信息：\n\n```bash\nroot@npi:~# zcat -l /proc/config.gz\n         compressed        uncompressed  ratio uncompressed_name\n              34042              149025  77.2% /proc/config\n```\n\n\n\n\n\n# Linux echo 命令 - 输出字符串内容\n\n## 介绍\n\n**echo** 命令用于在 Shell 终端中输出内容（比如 shell 变量的值，或者直接输出指定的字符串）。\n\nLinux 的 echo 命令，在 shell 编程中极为常用，通常起到一个提示的作用。\n\n**语法**：\n\n```bash\necho [OPTION]... [STRING]...\n```\n\n\n\n**选项**：\n\n- `-n` ：不输出尾随的换行符。\n- `-e` ：激活转义字符。\n\n## 示例\n\n显示普通字符串\n\n```bash\necho \"Welcome to getiot.tech\"\n```\n\n\n\n这里的双引号完全可以省略，以下命令与上面实例效果一致\n\n```bash\necho Welcome to getiot.tech\n```\n\n\n\n显示转义字符\n\n```bash\necho \"\\\"Welcome to getiot.tech\\\"\"\n```\n\n\n\n不换行显示\n\n```bash\necho -n \"Welcome to getiot.tech\"\n```\n\n\n\n转义输出（显示换行符）\n\n```bash\necho -e \"Welcome to getiot.tech\\n\"\n```\n\n\n\n将显示结果重定向至文件\n\n```bash\necho \"Welcome to getiot.tech\" > file.txt\n```\n\n\n\n把十六进制数据 0xdd 0xff 发送到串口 /dev/ttyUSB0\n\n```bash\necho -e -n \"\\xdd\\xff\" > /dev/ttyUSB0\n```\n\n\n\n显示命令执行结果\n\n```bash\necho `date`\n```\n\n\n\n注意：这里使用的是反引号 **`**，而不是单引号 **'**。\n\n\n\n# Linux chmod 命令 - 改变文件权限\n\n## 介绍\n\n**chmod**（英文全拼：change mode）是 Linux 系统中用于改变文件权限的一个命令。对于文件或者目录的普通权限，共有 3 种，分别是 r（读取）、w（写入）和 x（执行）。chmod 是 Linux 系统中关于权限的重要命令之一，另外一个是 [`chown`](https://getiot.tech/linux-command/chown/) 命令。\n\n**语法**：\n\n```bash\nchmod [who] [operator] [permission] FILE...\nchmod [OPTION]... OCTAL-MODE FILE...\n```\n\n\n\n**选项**：\n\n- `-c`：若该文件权限确实已经更改，才显示其更改动作。\n- `-f`：若该文件权限无法被更改也不要显示错误讯息。\n- `-v`：显示权限变更的详细资料。\n- `-R`：对目前目录下的所有文件与子目录进行相同的权限变更（即以递归的方式逐个变更）。\n\n每个模式字符串都应该匹配如下格式：`[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+`。\n\n其中，who 包含的选项及其含义：\n\n- `u`：文件属主权限（Owner）\n- `g`：属组用户权限（Group）\n- `o`：其他用户权限（Other Users）\n- `a`：所有用户（文件属主、属组用户及其他用户）\n\noperator 包含的选项及其含义：\n\n- `+`：增加权限\n- `-`：取消权限\n- `=`：设定权限\n\npermission 包含的选项及其含义：\n\n- `r`：读权限\n- `w`：写权限\n- `x`：执行权限\n- `s`：文件属主和组 set-ID\n- `t`：粘性位 *\n- `l`：给文件加锁，使其他用户无法访问\n\n另外，权限也可以使用“八进制模式”来描述，针对文件属主、属组用户及其他用户，均可用 rwx 表示，组成一个八进制数字。\n\n![img](./Image/Linux命令大全.assets/chmod-permission.jpeg)\n\n每个数字代表一种权限：\n\n| r (read) | w (write) | x (execute) |    -     |\n| :------: | :-------: | :---------: | :------: |\n|  读权限  |  写权限   | 可执行权限  | 没有权限 |\n|    4     |     2     |      1      |    0     |\n\n这样就会产生 8 x 8 x 8 = 256 种权限组合，例如：\n\n- `400` 文件属主可读\n- `200` 文件属主可写\n- `100` 文件属主可执行\n- `040` 属组用户可读\n- `020` 属组用户可写\n- `010` 属组用户可执行\n- `004` 其他用户可读\n- `002` 其他用户可写\n- `001` 其他用户可执行\n- `777` 所有用户可读可写可执行\n\n## 示例\n\n下面以文件 getiot 为例说明。\n\n赋予文件属主执行权限：\n\n```bash\nchmod u+x getiot\n```\n\n\n\n赋予属组用户写权限：\n\n```bash\nchmod g+w getiot\n```\n\n\n\n赋予属组用户和其他用户执行权限：\n\n```bash\nchmod go+x getiot\n```\n\n\n\n收回所有用户的执行权限：\n\n```bash\nchmod a-x getiot\n```\n\n\n\n收回属组用户和其他用户的写权限：\n\n```bash\nchmod og-w getiot\n```\n\n\n\n将文件权限修改为 755：\n\n```bash\nchmod 755 getiot\n```\n\n\n\n将 /temp 目录下的所有文件权限修改为 755：\n\n```bash\nchmod -R 755 getiot\n```\n\n\n\n\n\n# Linux chown 命令 - 改变文件所有者\n\n## 介绍\n\n**chown**（英文全拼：change owner）是 Linux 系统中用于改变文件所有者和文件关联组的一个命令。chown 是 Linux 系统中关于权限的重要命令之一，另外一个是 [`chmod`](https://getiot.tech/linux-command/chmod/) 命令。\n\n**语法**：\n\n```bash\nchown [OPTION]... [OWNER][:[GROUP]] FILE...\n```\n\n\n\n注意，这里的文件名可以使用空格分开的文件列表，在文件名中可以包含通配符。\n\n**选项**：\n\n- `OWNER`：新的文件拥有者的用户名或用户 ID。\n- `GROUP`：新的文件拥有者的用户组名或组 ID。\n- `-c`：显示更改的部分的信息。\n- `-f`：忽略错误信息。\n- `-h`：修复符号链接。\n- `-v`：显示详细的处理信息。\n- `-R`：递归处理指定目录以及其子目录下的所有文件。\n- `--help`：显示帮助信息并退出。\n- `--version`：显示版本信息并退出。\n\n## 示例\n\n将文件 getiot 的拥有者权限修改为 rudy：\n\n```bash\nchown rudy:rudy getiot\n```\n\n\n\n将 /opt/data 目录的拥有者权限修改为 rudy：\n\n```bash\nchown -R rudy:rudy /opt/data\n```\n\n\n\n\n\n# Linux less 命令 - 分页查看文件\n\n## 介绍\n\n**less** 与 [more](https://getiot.tech/linux-command/more/) 类似，less 可以随意浏览文件，支持翻页和搜索，支持向上翻页和向下翻页。（less 命令允许用户向前或向后浏览文件，而 more 命令只能向前浏览 ）\n\n**语法**：\n\n```bash\nless [options] file...\n```\n\n\n\n**参数说明**：\n\n- `-b <缓冲区大小>` ：设置缓冲区的大小\n- `-e` ：当文件显示结束后，自动离开\n- `-f` ：强迫打开特殊文件，例如外围设备代号、目录和二进制文件\n- `-g` ：只标志最后搜索的关键词\n- `-i` ：忽略搜索时的大小写\n- `-m` ：显示类似 more 命令的百分比\n- `-N` ：显示每行的行号\n- `-o <文件名>` ：将 less 输出的内容在指定文件中保存起来\n- `-Q` ：不使用警告音\n- `-s` ：显示连续空行为一行\n- `-S` ：行过长时间将超出部分舍弃\n- `-x <数字>` ：将\"tab\"键显示为规定的数字空格\n\n**命令内部操作**：\n\n- `/字符串` ：向下搜索\"字符串\"的功能\n- `?字符串` ：向上搜索\"字符串\"的功能\n- `n` ：重复前一个搜索（与 / 或 ? 有关）\n- `N` ：反向重复前一个搜索（与 / 或 ? 有关）\n- `b` ：向上翻一页\n- `d` ：向后翻半页\n- `h` ：显示帮助界面\n- `Q` ：退出less 命令\n- `u` ：向前滚动半页\n- `y` ：向前滚动一行\n- 空格键 ：滚动一页\n- 回车键 ：滚动一行\n- `[pagedown]` ： 向下翻动一页\n- `[pageup]` ： 向上翻动一页\n\n## 示例\n\n查看文件 getiot.log\n\n```bash\nless getiot.log\n```\n\n\n\nps 查看进程信息并通过 less 分页显示\n\n```bash\nps -ef | less\n```\n\n\n\n查看命令历史使用记录并通过 less 分页显示\n\n```bash\nhistory | less\n```\n\n\n\n浏览多个文件\n\n```bash\nless getiot1.log getiot2.log\n```\n\n\n\n说明：输入 `:n` 后，切换到 getiot1.log；输入 `:p` 后，切换到 getiot2.log\n\n\n\n# Linux more 命令 - 分页查看文件\n\n## 介绍\n\n**more** 命令类似 [cat](https://getiot.tech/linux-command/cat/) ，不过会以一页一页的形式显示，更方便使用者逐页阅读。\n\nmore 最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。\n\n**语法**：\n\n```bash\nmore [options] file...\n```\n\n\n\n**选项**：\n\n- `-num` ：指定每屏显示的行数。\n- `+num` ：从第 num 行开始显示。\n- `-d` ：提示使用者，在画面下方显示 [Press space to continue, 'q' to quit.] ，如果使用者按错键，则会显示 [Press 'h' for instructions.] 而不是 '哔' 声。\n- `-l` ：取消遇见特殊字元 `^L`（送纸字元）时会暂停的功能。\n- `-f` ：计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）。\n- `-p` ：不以卷动的方式显示每一页，而是先清除萤幕后再显示内容。\n- `-c` ：与 `-p` 相似，不同的是先显示内容再清除其他旧资料。\n- `-s` ：当遇到有连续两行以上的空白行，就代换为一行的空白行。\n- `-u` ：不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）。\n- `+/pattern` ：在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示。\n\n**命令内部操作**：\n\n- Space 键：显示文本的下一屏内容\n- Enter 键：向下n行，需要定义，默认为1行\n- 斜线符 `\\`：接着输入一个模式，可以在文本中寻找下一个相匹配的模式\n- H 键：显示帮助屏\n- B 键：显示上一屏内容\n- Q 键：退出 more 命令\n- Ctrl+F、空格键：向下滚动一屏\n- Ctrl+B：返回上一屏\n- `=`： 输出当前的行号\n- `:f`：输出文件名和当前的行号\n- `V`：调用 vi 编辑器\n- `!`：调用 Shell，并执行命令\n\n## 示例\n\n显示文件 file 的内容，显示之前先清屏，附已显示的百分比：\n\n```bash\nmore -dc file\n```\n\n\n\n显示文件 file 的内容，每10行显示一次，而且在显示之前先清屏：\n\n```bash\nmore -c -10 file\n```\n\n\n\n显示文件 file 的内容，每5行显示一次，而且在显示之后再清屏：\n\n```bash\nmore -p -5 file\n```\n\n\n\n逐页显示 file 文档内容，如有连续两行以上空白行则以一行空白行显示 ：\n\n```bash\nmore -s file\n```\n\n\n\n从第 20 行开始显示 file 之文档内容 ：\n\n```bash\nmore +20 file\n```\n\n\n\n\n\n# Linux diff 命令 - 比较文件差异\n\n## 介绍\n\n**diff**（英文全拼：different）命令用于在 Linux 系统中比较文件的差异。\n\ndiff 以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则 diff 会比较目录中相同文件名的文件，但不会比较其中子目录。\n\n**语法**：\n\n```bash\ndiff [OPTION]... FILES\n```\n\n\n\n**选项**：\n\n- `-a` ：diff 预设只会逐行比较文本文件。\n- `-b` ：不检查空格字符的不同。\n- `-W` ： 在使用 `-y` 参数时，指定栏宽。\n- `-x` ： 不比较选项中所指定的文件或目录。\n- `-X=<FILE>` ：您可以将文件或目录类型存成文本文件，指定此文本文件。\n- `-y` ：以并列的方式显示文件的异同之处。\n- `--help` ：查看帮助信息。\n- `--left-column` ：在使用 `-y` 参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。\n- `--suppress-common-lines` ：在使用 `-y` 参数时，仅显示不同之处。\n\n## 示例\n\n比较两个文件\n\n```bash\ndiff testfile1 testfile2\n```\n\n\n\n比较两个文件，且以并排格式输出\n\n```bash\ndiff testfile1 testfile2 -y -W 50\n```\n\n\n\n比较两个文件，将差异保存到另一个文件\n\n```bash\ndiff testfile1 testfile2 > testfile.patch\n```\n\n\n\n\n\n# Linux patch 命令 - 应用文件补丁\n\n## 介绍\n\n**patch** 命令用于修补文件（给文件打补丁）。Linux 早期正是使用 patch 命令来合并代码。\n\n**语法**：\n\n```bash\npatch [options] [originalfile [patchfile]]\n```\n\n\n\n**选项**：\n\n- `-i <patchfile>` 或 `--input=<patchfile>` ：指定补丁文件。\n- `-p<num>` 或 `--strip=<num>` ：设置欲剥离几层路径名称（文件名是可以包含路径的，与 diff 命令配合）。\n- `-E` 或 `--remove-empty-files` ：删除应用补丁后为空文件的文件。\n- `-o <outfile>` 或 `--output=<outfile>` ：输出到一个文件而不是直接覆盖文件。\n\n## 示例\n\n使用 patch 命令将文件 testfile1 升级，其升级补丁文件为 testfile.patch（补丁文件可由 [diff](https://getiot.tech/linux-command/diff/) 命令生成）：\n\n```bash\npatch -p0 testfile1 testfile.patch \n```\n\n\n\n在 Linux 开发中也常常会用到 patch 命令，比如内核打上 `PREEMPT_RT` 实时补丁：\n\n```bash\npatch -p1 < patch-5.4.47-rt28.patch\n```\n\n\n\n\n\n# Linux find 命令 - 查找文件或目录\n\n## 介绍\n\n**find** 命令是 Linux 系统管理员中最强大的工具之一。find 命令会根据用户指定的表达式（权限、类型、日期、所有权、大小等条件）在目录层次结构中搜索文件和目录，并且可以对每个匹配的文件执行用户指定的操作。另外，也可以将 find 命令与其他工具结合使用，例如 [`grep`](https://getiot.tech/linux-command/grep/) 或 [`sed`](https://getiot.tech/linux-command/sed/)，实现更复杂的功能。\n\n**语法**：\n\n```bash\nfind [-H] [-L] [-P] [-Olevel] [-D debugopts] [path...] [expression]\n```\n\n\n\n**选项**：\n\n- `path...` 路径属性定义搜索文件的起始目录，可以指定一个或多个起始目录。\n- `expression` 表达式属性由选项，搜索模式和由运算符分隔的动作组成。\n\n要在目录中搜索文件，调用 `find` 命令的用户需要对起始目录以及子目录具有读取权限。\n\n让我们看一下示例 `find -L /var/www -name \"*.js\"`。选项`-L`告诉`find`命令跟随符号链接。\n\n`/var/www`是find命令搜索的开始目录。表达式`-name \"*.js`告诉`find`搜索以`.js`结尾的文件JavaScript文件。\n\n## 示例\n\n### 按名称查找/搜索文件\n\n通过名称查找文件可能是 `find` 命令的最常见用法。要使用文件名查找文件，请在要搜索的文件名后加上 `-name` 选项。\n\n例如，要在 `/home/getiot` 目录中搜索名为 `document.pdf` 的文件，可以使用命令 `find /home/getiot -type f -name document.pdf`。\n\nfind 的 `-name` 选项是区分大小写的，如果你需要运行不区分大小写的搜索，请将 `-name` 选项更改为 `-iname`。find 命令将匹配 `Document.pdf`，`DOCUMENT.pdf` 等。\n\n```bash\nfind /home/getiot -type f -iname document.pdf\n```\n\n\n\n### 按文件扩展名查找文件\n\n根据扩展名搜索文件与按名称搜索文件相同。例如，要在 `/var/log/nginx` 目录中查找所有以 `.log.gz` 结尾的文件，可以使用下面命令。\n\n```bash\nfind /var/log/nginx -type f -name '*.log.gz'\n```\n\n\n\n值得一提的是，使用通配符时，必须加单/双引号或用反斜杠`\\`转义星号符号`*`，以避免shell解释它。\n\n要查找与正则表达式 `*.log.gz` 不匹配的所有文件，可以使用 find 命令的 `-not` 选项。例如，要查找所有未以 `*.log.gz` 结尾的文件，你可以使用以下 find 命令。\n\n```bash\nfind /var/log/nginx -type f -not -name '*.log.gz'\n```\n\n\n\n### 按类型查找文件\n\n有时你可能需要搜索指定的文件类型，例如普通文件，目录或符号链接。在 Linux 中，一切都是文件，包括目录。\n\n要根据文件的类型搜索文件，请使用 find 的 `-type` 选项指定文件类型。这里我们列出了 Linux 中所有文件的类型。\n\n`f` 是常规文件，`d` 是目录，`l` 是[符号链接](https://getiot.tech/linux/linux-hard-soft-link/)，`c` 是字符设备，`b` 是块设备，`p` 是命名管道 FIFO，`s` 是 socket 套接字。\n\n例如，要在当前工作目录中查找所有目录，可以使用命令 `find . -type d`，这里 `.` 表是当前目录，`-type d` 指定文件类型是目录。\n\n常见示例是使用 [`chmod`](https://getiot.tech/linux-command/chmod/) 命令将网站文件权限递归更改为 `644`，目录权限更改为 `755`：\n\n```bash\nfind /var/www/my_website -type d -exec chmod 0755 {} \\;\nfind /var/www/my_website -type f -exec chmod 0644 {} \\;\n```\n\n\n\n### 按大小查找文件\n\n要根据文件大小查找文件，请使用 find 命令的 `-size` 选项，之后指定文件的大小。你可以使用以下后缀指定文件大小。\n\n如果你使用 `-size` 选项，但为指定文件的大小，find 将会使用 512 字节作为大小进行文件的搜索。\n\n`b` 是 512 字节，`c` 是字节，`w` 是两字节，`k` 千字节即 kb， `M` 是兆字节，即 MB，`G` 是千兆字节即是 GB。\n\n例如命令 `find /tmp -type f -size 1024c` 将在 `/tmp` 目录中找到所有 1024 字节的文件。\n\nfind 命令还允许你搜索大于或小于指定大小的文件。你可以使用加减符号和文件的大小表示大于或者小于，`+` 符号表示大于，`-` 减符号表示小于。\n\n例如命令 `find . -type f -size -1M`，将在当前工作目录中搜索所有小于 `1MB` 的文件。注意大小值之前的是减号符号 `-`。\n\n命令 `find . -type f -size +1M` 将搜索大小大于 `1MB` 的文件，注意大小值之前的是加号符号 `+`。\n\n你甚至可以搜索大小范围内的文件。以下 find 命令将在当前目录下搜索/查找 `1MB` 到和 `2MB` 之间的所有文件。\n\n```bash\nfind . -type f -size +1M -size 21M\n```\n\n\n\n### 按日期查找文件\n\n`find`命令还可以根据文件的最后修改，访问或更改时间来搜索文件。与按大小搜索时相同，使用加号和减号表示大于或小于。\n\n例如命令 `find /etc/dovecot/conf.d -name \"*.conf\" -mtime 5`。将搜索 `/etc/dovecot/conf.d` 目录下以 `.conf` 结尾并且在最近五天内已被修改的所有文件。\n\n除了使用 24 小时作为单位之外，你还可以使用分钟、小时、秒等单位作为搜索的条件。我们将在这里列出这些选项。\n\n`-amin` 表示文件最后的访问时间，以分钟作为单位。`-atime` 表示最后的访问时间，以 24 小时作为单位，即一天。这两个选项都表示在指定访问时间之内。\n\n`-cmin` 表示文件在最后更改时间，以分钟作为单位。`-ctime` 表示文件在最后更改时间，但以 24 小时作为单位，即一天。这两个选项都表示在指定最后更改时间之内。\n\n`-mmin` 表示文件的最后修改时间，以分钟作为单位。`-mtime` 表示文件的最后修改时间，但以 24 小时作为单位，即一天。这两个选项都表示在指定修改时间之内。\n\n如果你需要指定修改，访问或更改时间之外作为搜索条件。你可以使用 find 的 `-daystart` 选项。它将会修改以上选项为时间之外。\n\n这是根据修改日期过滤文件的另一个示例。以下命令将列出 `/home` 目录中 30 多天之后修改的所有文件，包括 30 天的。\n\n```bash\nfind /home -mtime +30 -daystart\n```\n\n\n\n### 按权限查找文件\n\nfind 的 `-perm` 选项可让你根据文件权限搜索文件。你可以使用文件权限的符号模式，或者数字模式进行搜索。\n\n我们建议你使用数字模式，因为符号模式会显得更复杂，这不易于阅读。你可以在数字模式前加上减号 `-` 或斜线 `/`。\n\n如果将斜线 `/` 用作前缀，则至少是用户，组或其他人的其中一个权限位与文件匹配。如果将减号 `-` 用作前缀，则文件的权限位必须全匹配。\n\n```bash\nfind . -perm /444\nfind . -perm -664\n```\n\n\n\n### 按所有者查找文件\n\nfind 的 `-user` 和 `-group` 选项允许你要查找指定用户或组拥有的文件。例如命令 `find / -user getiot`，将会搜索用户 `getiot` 拥有的所有文件和目录。\n\n这是一个真实的例子。假设你要查找 `www-data` 用户拥有的所有文件，并将匹配文件的所有权从 `www-data` 更改为 `nginx`。\n\n```bash\nfind / -user www-data -type f  -exec chown nginx {} \\;\n```\n\n\n\n### 查找并删除文件\n\n将 `-delete` 选项附加到匹配表达式的末尾。find 将会删除所有匹配的文件。\n\n建议仅在确定结果与要删除的文件匹配时，使用 `-delete` 选项。你可以先打印匹配的文件，然后再加 `-delete` 选项。请谨慎使用 `-delete` 选项。\n\n对于目录的删除，find 的 `--delete` 选项只能删除与 `rmdir` 相同的空目录。例如，要从 `/var/log/` 中删除所有以 `.temp` 结尾的文件，你可以运行以下 find 命令。\n\n```bash\nfind /var/log/ -name `*.temp` -delete\n```\n\n\n\n\n\n# Linux grep 命令 - 搜索文本内容\n\n## 介绍\n\n**grep**（英文全拼：Global Regular Expression Print）命令是一个强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。\n\ngrep 的工作方式是在一个或多个文件中搜索字符串模板，如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。在 shell 脚本中常常使用 grep 命令进行一些自动化的文本处理工作。\n\n相关命令：egrep、fgrep、rgrep\n\n**语法**：\n\n```bash\ngrep [OPTION...] PATTERNS [FILE...]\ngrep [OPTION...] -e PATTERNS ... [FILE...]\ngrep [OPTION...] -f PATTERN_FILE ... [FILE...]\n```\n\n\n\n**选项**：\n\n- `-a`, `--text` ：不要忽略二进制的数据。\n- `-b`, `--byte-offset` ：在显示符合样式的那一行之前，标示出该行第一个字符的编号。\n- `-c`, `--count` ：计算符合样式的列数。\n- `-A`, `--after-context=NUM` ：除了显示符合范本样式的那一列之外，并显示该行之后的内容。\n- `-B`, `--before-context=NUM` ：除了显示符合样式的那一行之外，并显示该行之前的内容。\n- `-C`, `--context=NUM` ：除了显示符合样式的那一行之外，并显示该行之前后的内容。\n- `-d`, `--directories=ACTION` ：当指定要查找的是目录而非文件时，必须使用这项参数，否则 grep 指令将回报信息并停止动作。\n- `-e`, `--regexp=PATTERNS` ：指定字符串做为查找文件内容的样式。\n- `-f`, `--file=FILE` ：指定规则文件，其内容含有一个或多个规则样式，让 grep 查找符合规则条件的文件内容，格式为每行一个规则样式。\n- `-E`, `--extended-regexp` ：将样式为延伸的正则表达式来使用。\n- `-F`, `--fixed-regexp` ：将样式视为固定字符串的列表。\n- `-G`, `--basic-regexp` ：将样式视为普通的表示法来使用。\n- `-h`, `--no-filename` ：在显示符合样式的那一行之前，不标示该行所属的文件名称。\n- `-H`, `--with-filename` ：在显示符合样式的那一行之前，表示该行所属的文件名称。\n- `-i`, `--ignore-case` ：忽略字符大小写的差别。\n- `-l`, `--file-with-matches` ：列出文件内容符合指定的样式的文件名称。\n- `-L`, `--files-without-match` ：列出文件内容不符合指定的样式的文件名称。\n- `-n`, `--line-number` ：在显示符合样式的那一行之前，标示出该行的列数编号。\n- `-o`, `--only-matching` ：只显示匹配 PATTERN 部分。\n- `-q`, `--quiet`, `--silent` ：不显示任何信息。\n- `-r`, `--recursive` ：递归查找指定目录下的所有文件。\n- `-s`, `--no-messages` : 不显示错误信息。\n- `-v`, `--invert-match` ：显示不包含匹配文本的所有行。\n- `-w`, `--word-regexp` ：只显示全字符合的列。\n- `-x`, `--line-regexp` ：只显示全列符合的列。\n- `-V`, `--version` ：显示版本信息。\n\n## 示例\n\n### 查找进程\n\n查找指定进程（init 进程）\n\n```bash\nps -ef | grep init\n```\n\n\n\n查找指定进程个数\n\n```bash\nps -ef | grep init -c\n```\n\n\n\n查找指定进程，但不显示 grep 查找进程本身\n\n```bash\nps -ef | grep init | grep -v \"grep\"\n```\n\n\n\n### 查找文件内容\n\n假设文件 dialogue.txt 内容如下：\n\n```bash\nRudy: Hello, Welcome to getiot.tech website.\nTina: Hello, Rudy. That is so cool.\nRudy: Thanks, I'm so glad you like it.\nTina: Of courses, I've subscribed it.\n```\n\n\n\nkeywords.txt 文件保存关键字：\n\n```bash\ngetiot\nhello\n```\n\n\n\n从文件中读取关键词进行搜索\n\n```bash\ncat dialogue.txt | grep -f keywords.txt\n```\n\n\n\n从文件中读取关键词进行搜索，并显示行号\n\n```bash\ncat dialogue.txt | grep -nf keywords.txt\n```\n\n\n\n从文件中查找关键词 getiot\n\n```bash\ngrep \"getiot\" dialogue.txt\n```\n\n\n\n从文件中查找关键词 hello（不区分大小写）\n\n```bash\ngrep -i \"hello\" dialogue.txt\n```\n\n\n\n从当前目录中递归查找关键词，并显示行号\n\n```bash\ngrep -rn \"getiot\" ./*\n```\n\n\n\n找出以 R 开头的行内容\n\n```bash\ncat dialogue.txt | grep ^R\n```\n\n\n\n输出非 R 开头的行内容\n\n```bash\ncat dialogue.txt | grep ^[^R]\n```\n\n\n\n输出以 it. 结尾的行内容\n\n```bash\ncat dialogue.txt | grep it.$\n```\n\n\n\n显示包含 so 或者 to 字符的内容行\n\n```bash\ncat dialogue.txt | grep -E \"so|to\"\n```\n\n\n\n\n\n# Linux read 命令 - 读取用户输入\n\n## 介绍\n\n**read** 命令用于从标准输入读取当行数据。\n\nread 是一个 bash 的内建命令，这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。\n\n### 语法\n\n```bash\nread [选项] [参数]\n```\n\n\n\n**参数说明:**\n\n- `-a` ：后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。\n- `-d` ：后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。\n- `-p` ：后面跟提示信息，即在输入前打印提示信息。\n- `-e` ：在输入的时候可以使用命令补全功能。\n- `-n` ：后跟一个数字，定义输入文本的长度，很实用。\n- `-r` ：屏蔽 `\\`，如果没有该选项，则 `\\` 作为一个转义字符，有的话 `\\` 就是个正常的字符了。\n- `-s` ：安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。\n- `-t` ：后面跟秒数，定义输入字符的等待时间。\n- `-u` ：后面跟 fd，从文件描述符中读入，该文件描述符可以是 exec 新开启的。\n\n## 示例\n\n简单读取键盘输入：\n\n```bash\n#!/bin/bash\necho \"输入网站名: \"\nread file\necho \"你输入的网站名是 $file\"\nexit 0\n```\n\n\n\n允许在 read 命令行中直接指定一个提示：\n\n```bash\n#!/bin/bash \nread -p \"输入网站名:\" file \necho \"你输入的网站名是 $file\"  \nexit 0\n```\n\n\n\n指定 read 命令等待输入的秒数。当计时满时，read 命令返回一个非零退出状态：\n\n```bash\n#!/bin/bash \nif read -t 5 -p \"输入网站名:\" file \nthen\n\techo \"你输入的网站名是 $file\" \nelse     \n\techo \"\\n抱歉，你输入超时了。\" \nfi \nexit 0\n```\n\n\n\n设置 read 命令计数输入的字符。当输入的字符数目达到预定数目时，自动退出，并将输入的数据赋值给变量：\n\n```bash\n#!/bin/bash \nread -n1 -p \"Do you want to continue [Y/N]?\" answer\necho \"\"\ncase $answer in \nY | y)       \n\techo \"fine ,continue\";; \nN | n)       \n\techo \"ok,good bye\";; \n*)      \n\techo \"error choice\";;  \nesac \nexit 0\n```\n\n\n\n使 read 命令中输入的数据不显示在命令终端上：\n\n```bash\n#!/bin/bash \nread -s -p \"请输入您的密码:\" pass \necho -e \"\\n您输入的密码是 $pass\" \nexit 0\n```\n\n\n\n\n\n# Linux umask 命令 - 设置文件权限掩码\n\n## 介绍\n\n**umask** 命令用于显示或设置创建文件的权限掩码。在 Linux 系统中，权限掩码是由3个八进制的数字所组成，将现有的存取权限减掉权限掩码后，即可产生建立文件时预设的权限。\n\n**语法**：\n\n```bash\numask [-p] [-S] [mode]\n```\n\n\n\n**选项**：\n\n- `-p` ：以文字的方式来表示权限掩码。\n- `-S` ：输出的权限掩码可直接作为指令来执行。\n\n**参数**：\n\n- `mode`（可选）：八进制数或符号组合。\n\n## 示例\n\n查看系统当前权限掩码：\n\n```bash\n$ umask \n0002\n```\n\n\n\n以文字的方式输出权限掩码：\n\n```bash\n$ umask -p\numask 0002\n```\n\n\n\n以符号组合的方式输出权限掩码：\n\n```bash\n$ umask -S\nu=rwx,g=rwx,o=rx\n```\n\n\n\n输出的结果 `u=rwx,g=rwx,o=rx` 转化为八进制数等于 `775`。\n\n提示\n\n- `u` 符号代表当前用户。\n- `g` 符号代表和当前用户在同一个组的用户，以下简称组用户。\n- `o` 符号代表其他用户。\n- `a` 符号代表所有用户。\n- `r` 符号代表读权限以及八进制数 `4`。\n- `w` 符号代表写权限以及八进制数 `2`。\n- `x` 符号代表执行权限以及八进制数 `1`。\n- `+` 符号代表添加目标用户相应的权限。\n- `-` 符号代表删除目标用户相应的权限。\n- `=` 符号代表添加目标用户相应的权限，删除未提到的权限。\n\n为组用户添加写权限：\n\n```bash\numask g+w\n```\n\n\n\n删除其他用户的写、执行权限：\n\n```bash\numask o-wx\n```\n\n\n\n赋值全部用户所有权限：\n\n```bash\numask a=rwx\n```\n\n\n\n上述命令等效于：\n\n```bash\numask u=rwx,g=rwx,o=rwx\n```\n\n\n\n清除其他用户的读、写、执行权限：\n\n```bash\numask o=\n```\n\n\n\n\n\n# Linux touch 命令 - 创建或更新文件\n\n## 介绍\n\n**touch** 命令有两个功能：一是创建新的空文件，二是改变已有文件的时间戳属性。\n\ntouch 命令会根据当前的系统时间更新指定文件的访问时间和修改时间。如果文件不存在，将会创建新的空文件。\n\n**语法**：\n\n```bash\ntouch [OPTION]... FILE...\n```\n\n\n\n**选项**：\n\n- `-a` ：改变文件的读取时间记录。\n- `-m` ：改变文件的修改时间记录。\n- `-c` ：假如目标文件不存在，不会建立新的文件。与 `--no-create` 的效果一样。\n- `-f` ：不使用，是为了与其他 unix 系统的相容性而保留。\n- `-r` ：使用参考文件的时间记录，与 `--file` 的效果一样。\n- `-d` ：设定时间与日期，可以使用各种不同的格式。\n- `-t` ：设定文件的时间记录，格式与 date 指令相同。\n- `--no-create` ：不会建立新档案。\n- `--help` ：显示帮助信息。\n- `--version` ：显示版本信息。\n\n## 示例\n\n创建空文件\n\n```bash\ntouch file.txt\n```\n\n\n\n批量创建文件\n\n```bash\ntouch file{1..5}.txt \n```\n\n\n\n修改文件的 access（访问）时间\n\n```bash\ntouch -a file.txt\n```\n\n\n\n提示：文件的 access（访问）时间可通过 [stat](https://getiot.tech/linux-command/stat/) 命令查看。\n\n\n\n# Linux cp 命令 - 复制文件或目录\n\n## 介绍\n\n**cp**（英文全拼：copy）命令用于复制文件或目录。\n\n可以将多个文件复制到一个具体的文件名或一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。\n\n**语法**：\n\n```bash\ncp [options] source dest\ncp [options] source... directory\n```\n\n\n\n**选项**：\n\n- `-a`：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于 dpR 参数组合。\n- `-b`：覆盖已存在的文件目标前将目标文件备份。\n- `-d`：当复制符号链接时，把目标文件或目录也建立为符号链接，并指向与源文件或目录链接的原始文件或目录。\n- `-f`：覆盖已经存在的目标文件而不给出提示。\n- `-i`：与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 \"y\" 时目标文件将被覆盖。\n- `-p`：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。\n- `-r`：递归复制文件和目录。若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。\n- `-l`：对源文件建立硬链接，而非复制文件。\n- `-s`：对源文件建立符号链接，而非复制文件。\n- `-v`：详细显示 cp 命令执行的操作过程。\n\n## 示例\n\n复制文件（源文件 testfile1，目标文件 testfile2）\n\n```bash\ncp testfile1 testfile2\n```\n\n\n\n将文件 testfile1 复制到目录 dir 里\n\n```bash\ncp testfile1 dir/\n```\n\n\n\n同时将文件 testfile1 和 testfile2 复制到目录 dir 里\n\n```bash\ncp testfile1 testfile2 dir/\n```\n\n\n\n复制目录\n\n```bash\ncp -r dir1 dir2\n```\n\n\n\n\n\n# Linux rm 命令 - 删除文件或目录\n\n## 介绍\n\n**rm**（英文全拼：remove）命令用于删除一个文件或者目录。\n\nrm 是常用的命令，它可以删除一个指定文件或目录，也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。\n\nrm 是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令。所以，在执行 rm 命令之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。\n\n**语法**：\n\n```bash\nrm [OPTION]... [FILE]...\n```\n\n\n\n**选项**：\n\n- `-i` ：删除前逐一询问确认。\n- `-f` ：即使文件属性为只读，也直接删除，无需逐一确认。\n- `-r` ：将目录及其里面的文件逐一删除。\n\n## 示例\n\n删除文件：\n\n```bash\nrm test.txt\n```\n\n\n\n删除目录：\n\n```bash\nrm -r dir/\n```\n\n\n\n删除前逐一询问确认：\n\n```bash\n$ rm -i dir/*\n```\n\n\n\n直接删除，不作任何提示：\n\n```bash\nrm -f test.txt.bz2  \n```\n\n\n\n清空系统中所有的文件（谨慎！除非你知道自己在干嘛，否则永远不要使用）：\n\n```bash\nrm -rf /*\n```\n\n\n\n如果不小心创建了一些特殊文件，可不好删除，比如一个名为 `-D` 的文件。执行 `rm -D` 会将文件名误认为选项，这时候可以通过文件的 inode 硬链接编号来删除。\n\n首先，使用 [stat](https://getiot.tech/linux-command/stat/) 命令查看 inode 号：\n\n```bash\n  文件：./-D\n  大小：0               块：0          IO 块：4096   普通空文件\n设备：816h/2070d        Inode：9568258     硬链接：1\n权限：(0664/-rw-rw-r--)  Uid：( 1000/    rudy)   Gid：( 1000/    rudy)\n最近访问：2021-04-14 15:12:32.962045401 +0800\n最近更改：2021-04-14 15:12:32.962045401 +0800\n最近改动：2021-04-14 15:12:32.962045401 +0800\n```\n\n\n\n或者，使用 [ls](https://getiot.tech/linux-command/ls/) 命令加 `-i` 选项查看 inode 号：\n\n```bash\n$ ls -il\n9568258 -rw-rw-r--   1 rudy rudy         0 4月  14 15:12 -D\n```\n\n\n\n接着使用 [find](https://getiot.tech/linux-command/find/) 命令通过 inode 号查找文件并使用 rm 命令删除：\n\n```bash\n$ find . -inum 9568258 -exec rm -i {} \\;\nrm：是否删除普通空文件 './-D'？ y\n```\n\n\n\n为避免删错文件，这里使用了 rm 的交互式删除。\n\n不需要交互时，可以将 rm 后的 `-i` 选项去掉，或者直接使用 delete 进行删除：\n\n```bash\n$ find . -inum 9568258 -delete\n```\n\n\n\n\n\n# Linux mv 命令 - 移动或重命名文件\n\n## 介绍\n\n**mv**（英文全拼：move）命令用于移动文件或对其重命名。\n\n**语法**：\n\n```bash\nmv [options] source dest\nmv [options] source... directory\n```\n\n\n\n**选项**：\n\n- `-b` ：当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。\n- `-i` ：如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 \"y\" 表示直接覆盖，输入 \"n\" 表示取消该操作。\n- `-f` ：如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。\n- `-n` ：不要覆盖任何已存在的文件或目录。\n- `-u` ：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。\n\n## 示例\n\n将文件 testfile1 重命名为 testfile2：\n\n```bash\nmv testfile1 testfile2\n```\n\n\n\n将文件 file 移动到目录 dir 中：\n\n```bash\nmv file dir/\n```\n\n\n\n将目录 dir1 移动目录 dir2 中（前提是目录 dir2 已存在，若不存在为重命名）：\n\n```bash\nmv dir1/ dir2/\n```\n\n\n\n\n\n# Linux vim 命令 - 文本编辑器\n\n## 介绍\n\n**vim** 是 Linux 系统中非常流行的一个文本编辑器，绝大多数 Linux 系统都会内置 vim。\n\nvim 是 Vi IMproved 的简写，从名字可以看出，它是从 vi 发展出来的一个文本编辑器，提供了代码补完、编译及错误跳转等方便编程的功能。同时，可通过 vim 插件扩展其功能，将 vim 打造成一款强大的 IDE 工具。\n\n可以说，vim 是 Linux 系统中的一个神兵利器。但对于初学者来说，vim 可能会显得有些复杂，因为要想熟练使用它，需要记住很多操作命令。\n\n提示\n\nVim 的第一个版本由布莱姆·米勒在1991年发布，如今代码托管在 [GitHub](https://github.com/vim/vim) 上。\n\n**语法**：\n\n```bash\nvim [参数] [文件 ..]        # 编辑指定的文件\nvim [参数] -               # 从标准输入(stdin)读取文本\nvim [参数] -t tag          # 编辑 tag 定义处的文件\nvim [参数] -q [errorfile]  # 编辑第一个出错处的文件\n```\n\n\n\n**选项**：\n\n- `--`：在这以后只有文件名。\n- `-v`：Vi 模式（同 \"vi\"）。\n- `-e`：Ex 模式（同 \"ex\"）。\n- `-E`：改进的 Ex 模式。\n- `-s`：安静（批处理）模式（只能与 \"ex\" 一起使用）。\n- `-d`：Diff 模式（同 \"vimdiff\"）。\n- `-y`：容易模式（同 \"evim\"，无模式）。\n- `-R`：只读模式（同 \"view\"）。\n- `-Z`：限制模式（同 \"rvim\"）。\n- `-m`：不可修改（写入文件）。\n- `-M`：文本不可修改。\n- `-b`：二进制模式。\n- `-l`：Lisp 模式。\n- `-C`：兼容传统的 Vi（compatible）。\n- `-N`：不完全兼容传统的 Vi（nocompatible）。\n- `-V[N][fname]`：将 N 等级的详细消息记录到 fname 文件。\n- `-D`：调试模式。\n- `-n`：不使用交换文件，只使用内存。\n- `-r`：列出交换文件并退出。\n- `-r (跟文件名)`：恢复崩溃的会话。\n- `-L`：同 `-r`。\n- `-A`：以 Arabic 模式启动。\n- `-H`：以 Hebrew 模式启动。\n- `-T <terminal>`：设定终端类型为 `<terminal>`。\n- `--not-a-term`：跳过输入/输出不是终端的警告。\n- `--ttyfail`：如果输入或输出不是终端则退出。\n- `-u <vimrc>`：使用 `<vimrc>` 替代任何 .vimrc。\n- `--noplugin`：不加载 plugin 脚本。\n- `-p[N]`：打开 N 个标签页（默认值：每个文件一个）。\n- `-o[N]`：打开 N 个窗口（默认值：每个文件一个）。\n- `-O[N]`：同 -o 但垂直分割。\n- `+`：启动后跳到文件末尾。\n- `+<lnum>`：启动后跳到第 `<lnum>` 行。\n- `--cmd <command>`：加载任何 vimrc 文件前执行 `<command>`。\n- `-c <command>`：加载第一个文件后执行 `<command>`。\n- `-S <session>`：加载第一个文件后执行文件 `<session>`。\n- `-s <scriptin>`：从文件 `<scriptin>` 读入正常模式的命令。\n- `-w <scriptout>`：将所有输入的命令追加到文件 `<scriptout>`。\n- `-W <scriptout>`：将所有输入的命令写入到文件 `<scriptout>`。\n- `-x`：编辑加密的文件。\n- `--startuptime <file>`：将启动时序消息（startup timing messages）写入文件 `<file>`。\n- `-i <viminfo>`：使用 `<viminfo>` 取代 .viminfo。\n- `--clean`：Vim 默认模式，没有插件，没有 viminfo。\n- `-h, --help`：打印帮助信息。\n- `--version`：打印版本信息。\n\n## 示例\n\n打开当前目录下的 hello.txt 文件：\n\n```bash\nvim hello.txt\n```\n\n\n\n同时打开 hello.txt 和 world.txt 文件：\n\n- 首先执行 `vim hello.txt` 打开其中一个文件；\n- 然后在 vim 中输入 `:split world.txt`，打开另一个文件（默认是上下分隔窗口）；\n- 如果想要左右分割窗口，则输入 `:vsplit world.txt`。\n\n关于 vim 编辑器的详细使用方法，可参考《[Vim 文本编辑器](https://getiot.tech/linux/linux-vim-text-editor/)》。\n\n\n\n# Linux file 命令 - 识别文件类型\n\n## 介绍\n\n**file** 命令用于探测 Linux 系统中指定文件的类型，也可用来辨别一些文件的编码格式。\n\n与 Windows 系统通过扩展名来确定文件类型不同，file 命令通过查看文件的头部信息来获取文件类型。file 命令对文件的检查分为文件系统、魔法幻数检查和语言检查 3 个过程。\n\n**语法**：\n\n```bash\nfile [options] <file> ...\n```\n\n\n\n**选项**：\n\n- `-b`, `--brief` ：列出辨识结果时，不显示文件名称。\n- `-c`, `--checking-printout` ：详细显示指令执行过程，便于排错或分析程序执行的情形。\n- `-f`, `--files-from <namefile>` ：指定名称文件，其内容有一个或多个文件名称时，让 file 依序辨识这些文件，格式为每列一个文件名称。\n- `-L`, `--dereference` ：直接显示符号连接所指向的文件类别。\n- `-m`, `--magic-file <magicfiles>` ：指定魔法数字文件。\n- `-z`, `--uncompress` ：尝试去解读压缩文件的内容。\n- `-v`, `--version` ：显示版本信息。\n- `--help` ：显示帮助信息。\n\n## 示例\n\n查看当前目录下的 main.c 文件类型\n\n```bash\n$ file main.c \nmain.c: C source, ASCII text\n```\n\n\n\n查看当前目录下的 README.md 文件类型\n\n```bash\n$ file README.md \nREADME.md: UTF-8 Unicode text\n```\n\n\n\n查看 /bin/sh 文件类型（软链接）\n\n```bash\n$ file /bin/sh\n/bin/sh: symbolic link to dash\n```\n\n\n\n查看系统 /etc/profile 文件类型（不显示文件名称）\n\n```bash\n$ file -b /etc/profile\nASCII text\n```\n\n\n\n查看当前用户主目录的文件类型\n\n```bash\n$ file $HOME\n/home/rudy: directory\n```\n\n\n\n\n\n# Linux tee 命令 - 读取并输出到文件\n\n## 介绍\n\n**tee** 命令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件 。\n\n**语法**：\n\n```shell\ntee [OPTION]... [FILE]...\n```\n\n\n\n**选项**：\n\n- `-a`, `--append` ：附加到既有文件的后面，而非覆盖它．\n- `-i`, `--ignore-interrupts` ：忽略中断信号。\n- `--help` ：显示帮助。\n- `--version` ：显示版本信息。\n\n## 示例\n\n将用户输入的数据同时保存到文件 file1 和 file2 中：\n\n```sh\ntee file1 file2 \n```\n\n\n\n将 ping 的信息输出到终端，同时也写入到文件中：\n\n```shell\nping google.com | tee output.txt\n```\n\n\n\n\n\n# Linux wc 命令 - 统计文件内容\n\n## 介绍\n\n**wc**（英文全拼：word counts）命令统计指定文件中的字节数、字数、行数，并将统计结果显示输出。\n\n**语法**：\n\n```bash\nwc [OPTION]... [FILE]...\n```\n\n\n\n**选项**：\n\n- `-c`, `--bytes` ：只显示字节数。\n- `-m`, `--chars` ：只显示字符数。\n- `-l`, `--lines` ：显示行数。\n- `-w`, `--words` ：只显示字数。\n- `--help` ：在线帮助。\n- `--version` ：显示版本信息。\n\n## 示例\n\n统计文件字数：\n\n```bash\nwc -w test.txt \n```\n\n\n\n统计文件字节数：\n\n```bash\nwc -c test.txt \n```\n\n\n\n统计文件字符数：\n\n```bash\nwc -m test.txt \n```\n\n\n\n统计文件行数：\n\n```bash\nwc -l test.txt \n```\n\n\n\n打印最长行的长度：\n\n```bash\nwc -L test.txt\n```\n\n\n\n统计当前目录下的文件和目录总数：\n\n```bash\nls | wc -w\n```\n\n\n\n\n\n# Linux awk 命令 - 文本处理工具\n\n## 介绍\n\n**awk** 是一种强大的文本处理工具，用于在 Unix 和 Linux 系统中处理和分析文本数据。它是一种基于模式匹配和动作执行的编程语言，通常用于从结构化文本中提取和操作数据。awk 常常用于处理行格式的文本数据，例如日志文件或表格数据。\n\nawk 提供了丰富的功能，允许用户执行复杂的文本处理任务。它在脚本编程和数据分析中都非常有用。需要注意的是，awk 使用空格或制表符作为默认字段分隔符，但可以通过 `-F` 选项来指定其他分隔符。\n\n**语法**：\n\n```bash\nawk '模式 { 动作 }' 文件\n```\n\n\n\n- **模式**：指定要匹配的条件，如果省略模式，则默认匹配所有行。\n- **动作**：指定在匹配到模式时要执行的操作，可以是打印、计算、赋值等。\n\n## 示例\n\n打印文件中每行的第二列和第四列：\n\n```bash\nawk '{print $2, $4}' filename\n```\n\n\n\n将 `ls -l` 的结果作为输入，打印其中每行的第二列和第四列：\n\n```bash\nls -l | awk '{print $2, $4}'\n```\n\n\n\n计算文件中第一列的总和，并在文件末尾输出总和值：\n\n```bash\nawk '{sum += $1} END {print \"Sum =\", sum}' filename\n```\n\n\n\n打印包含指定模式的所有行：\n\n```bash\nawk '/pattern/ {print}' filename\n```\n\n\n\n根据第三列的值打印相应的消息：\n\n```bash\nawk '{if ($3 > 50) print $1, \"High\"; else print $1, \"Low\"}' filename\n```\n\n\n\n使用冒号作为字段分隔符，打印 `/etc/passwd` 文件中的第一列和第三列：\n\n```bash\nawk -F':' '{print $1, $3}' /etc/passwd\n```\n\n\n\n\n\n# Linux sed 命令 - 流编辑器\n\n## 介绍\n\n**sed**（流编辑器）是一个在 Linux 和 Unix 系统上广泛使用的文本处理工具。它允许用户通过脚本或命令行对文本进行基本的编辑和转换。sed 主要用于处理文本流，它可以从输入流中读取文本，对文本进行处理，并将处理后的文本送到输出流。sed 命令在文本处理和脚本编程中非常有用，可以通过组合多个命令来执行复杂的文本编辑任务。\n\n**语法**：\n\n```bash\nsed [选项]... '动作' [输入文件]...\n```\n\n\n\n**选项**：\n\n- `-n, --quiet, --silent`：禁止默认输出，只有经过处理的行才会输出。\n- `--debug`：对程序运行进行标注。\n- `-e 脚本, --expression=脚本`：允许多个编辑命令，添加“脚本”到程序的运行列表。\n- `-f 脚本文件, --file=脚本文件`：添加“脚本文件”到程序的运行列表。\n- `--follow-symlinks`：直接修改文件时跟随软链接。\n- `-i[扩展名], --in-place[=扩展名]`：直接修改文件内容，而不是输出到标准输出（如果指定扩展名则备份文件）。\n- `-l N, --line-length=N`：指定 `l` 命令的换行期望长度。\n- `--posix`：关闭所有 GNU 扩展。\n- `-E, -r, --regexp-extended`：在脚本中使用扩展正则表达式（为保证可移植性使用 `POSIX -E`）。\n- `-s, --separate`：将输入文件视为各个独立的文件而不是单个长的连续输入流。\n- `--sandbox`：在沙盒模式中进行操作（禁用 e/r/w 命令）。\n- `-u, --unbuffered`：从输入文件读取最少的数据，更频繁的刷新输出。\n- `-z, --null-data`：使用 NUL 字符分隔各行。\n- `--help`：打印帮助并退出。\n- `--version`：输出版本信息并退出。\n\n动作通常以单引号括起来，其中包含一个或多个 `sed` 命令，如替换、删除、添加等。\n\n- `a`：新增，a 的后面可以接字串，而这些字串会在新的一行出现（目前的下一行）。\n- `c`：取代，c 的后面可以接字串，这些字串可以取代 `n1,n2` 之间的行。\n- `d`：删除，后面通常不接任何字串。\n- `i`：插入，i 的后面可以接字串，这些字串会在新的一行出现（目前的上一行）。\n- `p`：打印，亦即将某个选择的数据印出。通常会与参数 `sed -n` 一起运行。\n- `s`：取代，可以直接进行取代的工作，通常这个 s 的动作可以搭配正则表达式，例如 `1,20s/old/new/g`。\n\n## 示例\n\n在文件中查找 `old_text` 并将其替换为 `new_text`：\n\n```bash\nsed 's/old_text/new_text/' filename\n```\n\n\n\n删除包含指定模式（`pattern`）的行：\n\n```bash\nsed '/pattern/d' filename\n```\n\n\n\n只显示包含指定模式的行：\n\n```bash\nsed -n '/pattern/p' filename\n```\n\n\n\n分别在第 3 行之前和之后添加新行：\n\n```bash\nsed '3i\\New line before the 3rd line' filename\nsed '3a\\New line after the 3rd line' filename\n```\n\n\n\n直接修改文件内容，而不是在标准输出中显示结果：\n\n```bash\nsed -i 's/old_text/new_text/' filename\n```\n\n\n\n需要注意的是，sed 不会修改原始文件，除非使用 `-i` 选项。\n\n\n\n# Linux head 命令 - 显示文件头部\n\n## 介绍\n\n**head** 命令可用于查看文件的开头部分的内容，默认显示前 10 行的内容。\n\n**语法**：\n\n```bash\nhead [OPTION]... [FILE]...\n```\n\n\n\n**选项**：\n\n- `-q` ：隐藏文件名。\n- `-v` ：显示文件名。\n- `-c`, `--bytes=[-]NUM` ：显示的字节数。\n- `-n`, `--lines=[-]NUM` ：显示的行数。\n\n## 示例\n\n显示 getiot.log 文件的开头 10 行：\n\n```bash\nhead getiot.log\n```\n\n\n\n显示 getiot.log 文件的开头 5 行：\n\n```bash\nhead -n 5 getiot.log\n```\n\n\n\n显示 getiot.log 文件除最后 5 行外的其他所有内容：\n\n```bash\nhead -n -5 getiot.log\n```\n\n\n\n显示 getiot.log 文件前 233 个字节：\n\n```bash\nhead -c 233 getiot.log\n```\n\n\n\n\n\n# Linux tail 命令 - 显示文件尾部\n\n## 介绍\n\n**tail** 命令可用于查看文件的末尾部分的内容，默认显示后 10 行的内容。有一个常用的参数 **-f** 常用于查阅正在改变的日志文件。\n\n**语法**：\n\n```shell\ntail [OPTION]... [FILE]...\n```\n\n\n\n**选项**：\n\n- `-f` ：循环读取。\n- `-q` ：不显示处理信息。\n- `-v` ：显示详细的处理信息。\n- `-c`, `--bytes=[+]NUM` ：显示的字节数。\n- `-n`, `--lines=[+]NUM` ：显示文件的尾部 n 行内容。\n- `--pid=PID` ：与 `-f` 合用，表示在进程 ID、PID 死掉之后结束。\n- `-q`, `--quiet`, `--silent` ：从不输出给出文件名的首部。\n- `-s`, `--sleep-interval=S` ：与 `-f` 合用，表示在每次反复的间隔休眠S秒。\n\n## 示例\n\n显示 getiot.log 文件的最后 10 行：\n\n```shell\ntail getiot.log\n```\n\n\n\n跟踪名为 getiot.log 的文件的增长情况：\n\n```shell\ntail -f getiot.log\n```\n\n\n\n此命令显示 getiot.log 文件的最后 10 行。当将某些行添加至 getiot.log 文件时，tail 命令会继续显示这些行。 显示一直继续，直到您按下（Ctrl-C）组合键停止显示。\n\n显示文件 getiot.log 的内容，从第 20 行至文件末尾：\n\n```shell\ntail -n +20 notes.log\n```\n\n\n\n显示文件 getiot.log 的最后 5 个字符：\n\n```shell\ntail -c 5 notes.log\n```\n\n\n\n\n\n# Linux tar 命令 - 压缩或解压缩文件\n\n## 介绍\n\n**tar**（英文全拼：tape archive）命令用于在磁带、或者磁盘上创建和提取归档文件。\n\ntar 命令默认只是把多个文件打包放到一起，并不会对文件进行压缩，如果想要进行压缩或解压缩操作，则需要使用对应的选项参数。\n\n**语法**：\n\ntar 命令的用法有三种风格\n\n- 传统风格\n\n  ```shell\n  tar {A|c|d|r|t|u|x}[GnSkUWOmpsMBiajJzZhPlRvwo] [ARG...]\n  ```\n\n  \n\n- UNIX 风格\n\n  ```shell\n  tar -A [OPTIONS] ARCHIVE ARCHIVE\n  tar -c [-f ARCHIVE] [OPTIONS] [FILE...]\n  tar -d [-f ARCHIVE] [OPTIONS] [FILE...]\n  tar -t [-f ARCHIVE] [OPTIONS] [MEMBER...]\n  tar -r [-f ARCHIVE] [OPTIONS] [FILE...]\n  tar -u [-f ARCHIVE] [OPTIONS] [FILE...]\n  tar -x [-f ARCHIVE] [OPTIONS] [MEMBER...]\n  ```\n\n  \n\n- GNU 风格\n\n  ```shell\n  tar {--catenate|--concatenate} [OPTIONS] ARCHIVE ARCHIVE\n  tar --create [--file ARCHIVE] [OPTIONS] [FILE...]\n  tar {--diff|--compare} [--file ARCHIVE] [OPTIONS] [FILE...]\n  tar --del--extractete [--file ARCHIVE] [OPTIONS] [MEMBER...]\n  tar --append [-f ARCHIVE] [OPTIONS] [FILE...]\n  tar --list [-f ARCHIVE] [OPTIONS] [MEMBER...]\n  tar --test-label [--file ARCHIVE] [OPTIONS] [LABEL...]\n  tar --update [--file ARCHIVE] [OPTIONS] [FILE...]\n  tar --update [-f ARCHIVE] [OPTIONS] [FILE...]\n  tar {--extract|--get} [-f ARCHIVE] [OPTIONS] [MEMBER...]\n  ```\n\n  \n\n**选项**：\n\n- `-A`, `--catenate` ：将新增的归档文件附加到已存在的另一个归档文件。\n- `-c`, `--create` ：建立新的归档文件。\n- `-d`, `--diff` ：对比归档文件内和文件系统上的文件的差异。\n- `-k`, `--keep-old-files` ：解压时不替换存在的文件，而将其认为是错误。\n- `-m`, `--touch` ：不要解压文件的修改时间。\n- `-r`, `--append` ：将新增文件附加到已存在的归档文件的结尾。\n- `-S`, `--sparse` ：高效处理离散文件。\n- `-t`, `--list` ：列出归档文件的内容。\n- `-u`, `--update` ：仅置换较归档文件内的文件更新的文件。\n- `-x`, `--extract`, `--get` ：从归档文件中提取文件。\n- `-f <ARCHIVE>` ：指定归档文件。\n- `-j`, `--bzip2` ：通过 bzip2 命令处理归档文件。\n- `-J`, `--xz` ：通过 xz 命令处理归档文件。\n- `-z`, `--gzip`, `--gunzip`, `--ungzip` ：通过 gzip 命令处理归档文件。\n- `-Z`, `--compress`, `--uncompress` ：通过 compress 命令处理归档文件。\n- `-v`, `--verbose` ：显示命令执行过程。\n- `--exclude=PATTERN` ：排除 PATTERN 匹配的所有文件。\n\n## 示例\n\n使用 gzip 格式压缩文件（将 hello.c 和 world.c 压缩为 getiot.tar.gz）：\n\n```shell\n$ touch hello.c world.c\n$ tar zcvf getiot.tar.gz hello.c world.c \nhello.c\nworld.c\n```\n\n\n\n列出压缩文件内容：\n\n```shell\n$ tar ztvf getiot.tar.gz \n-rw-rw-r-- rudy/rudy         0 2021-05-25 23:56 hello.c\n-rw-rw-r-- rudy/rudy         0 2021-05-25 23:56 world.c\n```\n\n\n\n解压文件（解压到 /tmp 目录）：\n\n```shell\n$ tar zxvf getiot.tar.gz -C /tmp\nhello.c\nworld.c\n```\n\n\n\n压缩当前目录下的所有文件（排除 .git 目录）：\n\n```shell\ntar jcvf getiot.tar.bz2 --exclude=.git ./*\n```\n\n\n\n\n\n# Linux xz 命令 - 压缩或解压缩文件\n\n## 介绍\n\n**xz** 命令是为 POSIX 平台开发具有高压缩率的工具。它使用 LZMA2 压缩算法，生成的压缩文件比 POSIX 平台传统使用的 gzip、bzip2 生成的压缩文件更小，而且解压缩速度也很快。\n\n最初 XZ Utils 的是基于 LZMA-SDK 开发，但是 LZMA-SDK 包含了一些 Windows 平台的特性，而 XZ Utils 为适应 POSIX 平台作了大幅的修改。XZ Utils 的出现也是为了取代 POSIX 系统中旧的 LZMA Utils。\n\nxz 命令由 XZ Utils 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\n$ sudo apt install xz-utils\n```\n\n\n\n**语法**：\n\n```bash\nxz [option...]  [file...]\n```\n\n\n\n**选项**：\n\n- `-z, --compress`：强制压缩。\n- `-d, --decompress`：强制解压缩。\n- `-t, --test`：测试压缩文件完整性。\n- `-l, --list`：列出 .xz 文件的信息。\n- `-k, --keep`：保留（不要删除）输入文件。\n- `-f, --force`：强制覆写输出文件和（解）压缩链接。\n- `-c, --stdout`：向标准输出写入，同时不要删除输入文件。\n- `-0 ... -9`：压缩预设等级；默认为 6；使用 7-9 的等级之前，请先考虑压缩和解压缩所需的内存用量！（会占用大量内存空间）\n- `-e, --extreme`：尝试使用更多 CPU 时间来改进压缩比率；不会影响解压缩的内存需求量。\n- `-T, --threads=数量`：使用最多指定数量的线程；默认值为 1；设置为 0 可以使用与处理器内核数量相同的线程数。\n- `-q, --quiet`：不显示警告信息；指定两次可不显示错误信息。\n- `-v, --verbose`：输出详细信息；指定两次可以输出更详细的信息。\n- `-h, --help`：显示本短帮助信息并退出。\n- `-H, --long-help`：显示长帮助信息（同时列出高级选项）。\n- `-V, --version`：显示软件版本号并退出。\n\n## 示例\n\n压缩一个文件 hello.txt，压缩成功后生成 hello.txt.xz：\n\n```bash\nxz hello.txt\n```\n\n\n\n解压 hello.txt.xz 文件，并保持原文件不被删除：\n\n```bash\nxz -d -k hello.txt.xz\n```\n\n\n\n注意\n\nxz 在压缩和解压的时候，默认都会将原文件删除，如果不希望删除原文件，请使用 `-k` 选项。\n\n查看 .xz 文件的基本信息（包括压缩率、校验方式等），可与 `-v` 或 `-vv` 选项配合显示更详尽的信息：\n\n```bash\n$ xz -l  hello.txt.xz\nStrms  Blocks   Compressed Uncompressed  Ratio  Check   Filename\n    1       1        856 B      5,913 B  0.145  CRC64   hello.txt.xz\n```\n\n\n\n使用参数 -0, -1, -2, … -6, … -9 或参数 `--fast`, `--best` 设定压缩率：\n\n```bash\n$ xz -k7 hello.txt\n$ xz -k --fast hello.txt\n```\n\n\n\n再次查看 hello.txt.xz 文件基本信息，可以发现压缩大小和压缩比例和之前不一样了：\n\n```bash\n$ xz -l hello.txt.xz \nStrms  Blocks   Compressed Uncompressed  Ratio  Check   Filename\n    1       1        896 B      5,913 B  0.152  CRC64   hello.txt.xz\n```\n\n\n\n提示\n\nxz 命令的默认的压缩率预设值为 -6 ，对于大多数系统来说，甚至是一些较旧的系统，-4 … -6 压缩率预设值都不错的表现。\n\n借助 [`xargs`](https://getiot.tech/linux-command/xargs/) 命令并行压缩多文件，例如将 /var/log 目录下所有的扩展名为 .log 的文件压缩在一起：\n\n```bash\nfind /var/log -type f -iname \"*.log\" -print0 | xargs -P4 -n16 xz -T1\n```\n\n\n\n\n\n# Linux mc 命令 - 字符界面文件管理器\n\n## 介绍\n\n**mc**（英文全拼：Midnight Commander）是一个基于字符的目录浏览器和文件管理器。\n\n在 Linux 的世界中，使用图形文件管理器可以轻松完成许多常见的文件操作，但命令行工具通常有更多额外功能和灵活性，而 mc 则将图形文件管理器和命令行工具这两个世界联系在一起了。\n\nmc 的设计基于文件管理器的一个普遍概念 —— 双目录窗口，同时显示两个目录的列表，用于显示文件/目录移动或复制等操作的源（source）和目标（destination）。执行 mc 之后，将会看到菜单式的文件管理程序，共分成 5 个部分。\n\n![img](./Image/Linux命令大全.assets/midnight-commander-screen-layout.png)\n\n1. **左右目录面板** —— 屏幕中央是两个大的目录面板，在任何时刻都会有其中之一（称为“当前面板”）处于活动状态，按 Tab 键可切换当前面板。\n2. **功能键标签** —— 最下面一栏包含最常用的功能快捷键，使用功能键（F1 到 F10）进行选择，从左到右依次是：帮助、目录、显示、编辑、复制、更名或移动、新建目录、删除、菜单、退出。\n3. **菜单栏** —— 最上面一栏包含一组下拉菜单的菜单栏，可通过功能键 F9 激活菜单栏。\n4. **命令行** —— 在功能键标签栏上方有一个 shell 提示符，可以按常规方式输入命令。一个特别有用的命令是 `cd`，后面加目录路径名，便可切换当前面板中显示的目录。\n5. **迷你状态行** —— 在目录面板最底部，命令行上方，是迷你状态行，该区域用于显示有关当前所选项目的补充信息，例如符号链接的目标。\n\n概括来说，mc 是一个强大的工具，并拥有广泛的功能，包括：\n\n- 涵盖所有常见的文件和目录操作，例如复制、移动、重命名、链接和删除；\n- 允许操纵文件和目录权限；\n- 可以将远程系统（通过 FTP 或 SSH）视为本地目录；\n- 可以将存档文件（例如 .tar 和 .zip）视为本地目录；\n- 允许创建用户自定义的常用目录“hotlist”；\n- 可以根据文件名或文件内容搜索文件，并将搜索结果视为目录。\n\nmc 项目网址：[https://midnight-commander.org](https://midnight-commander.org/)\n\n## 示例\n\n### 切换列表显示格式\n\n循环按 `Alt + t` 可以切换当前面板的显示格式，比如输出 `ls -l` 的效果。另外，按 `Ctrl + x` 再按 `i`，可在另一个面板显示当前面板选中项的详细信息，再次按 `Ctrl + x` 再按 `i` 即可关闭。\n\n![img](./Image/Linux命令大全.assets/midnight-commander-information-mode.png)\n\n### 设置另一个面板的目录\n\n可以通过当前面板设置另一个面板的显示目录，例如移动光标到某一目录，按 `Alt + o` 将会在另一个面板中显示该目录下的子目录和文件，按 `Alt + i` 则将另一个面板显示与当前面板相同的目录。\n\n\n\n# Linux zip 命令 - 压缩文件为 zip 格式\n\n## 介绍\n\n**zip** 命令用于打包和压缩文件，压缩后的文件后缀名为 .zip。\n\nzip 命令可以将一个或多个压缩文件与有关文件的信息（名称、路径、日期、上次修改的时间、保护和检查信息以验证文件完整性）一起放入一个压缩存档中。\n\n**语法**：\n\n```bash\nzip [-options] [-b path] [-t mmddyyyy] [-n suffixes] [zipfile list] [-xi list]\n```\n\n\n\n**选项**：\n\n- `-q` ：不显示指令执行过程。\n- `-r` ：递归处理，将指定目录下的所有文件和子目录一并处理。\n- `-z`, `--archive-comment` ：替压缩文件加上注释。\n- `-v`, `--verbose` ：显示指令执行过程。\n- `-n`, `--suffixes <suffixes>` ：不压缩具有特定字尾字符串的文件。\n- `-sf`, `--show-files` ：显示压缩包中的文件。\n\n## 示例\n\n假设当前目录下有一个 test 目录，里面有两个文件：\n\n```bash\ntest/\n├── hello.c\n└── world.c\n```\n\n\n\n将 test 目录下所有文件（和文件夹）打包为当前目录下的 test.zip：\n\n```bash\n$ zip -q -r test.zip test\n```\n\n\n\n不解压直接查看压缩包中的内容：\n\n```bash\n$ zip -sf test.zip \nArchive contains:\n  test/\n  test/world.c\n  test/hello.c\nTotal 3 entries (12 bytes)\n```\n\n\n\n\n\n# Linux unzip 命令 - 解压缩 zip 文件\n\n## 介绍\n\n**unzip** 命令用于列出、测试和提取 zip 格式存档中的文件。\n\n**语法**：\n\n```shell\nunzip [-Z] [-opts[modifiers]] file[.zip] [list] [-x xlist] [-d exdir]\n```\n\n\n\n**选项**：\n\n- `-l` ：显示压缩文件内所包含的文件。\n- `-c` ：将解压缩的结果显示到屏幕上，并对字符做适当的转换。\n- `-n` ：解压缩时不要覆盖原有的文件。\n- `-j` ：不处理压缩文件中原有的目录路径。\n- `-v` ：显示压缩文件的详细信息和诊断信息。\n- `-d exdir` ：指定解压目录。\n\n## 示例\n\n将 test.zip 解压缩到当前目录：\n\n```shell\n$ unzip test.zip\n```\n\n\n\n将 test.zip 解压缩到当前目录的 tmp 目录下：\n\n```shell\n$ unzip test.zip -d tmp\n```\n\n\n\n列出压缩文件 test.zip 中的内容：\n\n```shell\n$ unzip -l test.zip \nArchive:  test.zip\n  Length      Date    Time    Name\n---------  ---------- -----   ----\n        0  2021-06-06 00:38   test/\n        6  2021-06-06 00:38   test/world.c\n        6  2021-06-06 00:38   test/hello.c\n---------                     -------\n       12                     3 files\n```\n\n\n\n列出压缩文件 test.zip 的详细信息：\n\n```shell\n$ unzip -v test.zip \nArchive:  test.zip\n Length   Method    Size  Cmpr    Date    Time   CRC-32   Name\n--------  ------  ------- ---- ---------- ----- --------  ----\n       0  Stored        0   0% 2021-06-06 00:38 00000000  test/\n       6  Stored        6   0% 2021-06-06 00:38 363a3020  test/world.c\n       6  Stored        6   0% 2021-06-06 00:38 363a3020  test/hello.c\n--------          -------  ---                            -------\n      12               12   0%                            3 files\n```\n\n\n\n验证压缩文件 test.zip 的完整性：\n\n```shell\n$ unzip -t test.zip \nArchive:  test.zip\n    testing: test/                    OK\n    testing: test/world.c             OK\n    testing: test/hello.c             OK\nNo errors detected in compressed data of test.zip.\n```\n\n\n\n\n\n# Linux chattr 命令 - 改变文件属性\n\n## 介绍\n\n**chattr**（英文全拼：change file attributes）命令用于修改 Linux 文件系统中的文件属性。\n\n**语法**：\n\n```bash\nchattr [ -RVf ] [ -v version ] [ -p project ] [ mode ] files...\n```\n\n\n\n**选项**：\n\n- `-R` ：递归处理目录下的所有文件。\n- `-V` ：显示指令执行过程。\n- `-f` ：禁止显示大多数错误消息。\n- `-v version` ：设置文件的版本/代号。\n- `-p project` ：设置文件的项目编号。\n- `+<属性>`：开启文件或目录的该项属性。\n- `-<属性>`：关闭文件或目录的该项属性。\n- `=<属性>`：指定文件或目录的该项属性。\n\n**模式**：\n\n通用格式为：`+-=[aAcCdDeijsStTu]`，其中 `aAcCdDeijsStTu` 表示可以赋予文件的新属性，说明如下。\n\n- `a`：让文件或目录仅供附加用途。\n- `A`：当一个具有 `A` 属性的文件被访问时，它的 atime 记录不会被修改。\n- `c`：将文件或目录压缩后存放。\n- `d`：将文件或目录排除在倾倒操作之外。\n- `i`：不得任意更动文件或目录。\n- `j`：如果文件系统安装有 `data=order` 或 `data=writeback` 选项，则具有 `j` 属性的文件在写入文件本身之前将其所有数据写入 ext 3 日志。\n- `s`：当删除具有 `s` 属性集的文件时，其块将被归零并写回磁盘。\n- `S`：当修改具有 `S` 属性集的文件时，更改将同步写入磁盘；这相当于应用于文件子集的“同步”挂载选项。\n- `u`：当删除具有 `u` 属性集的文件时，它的内容将被保存。\n\n## 示例\n\n用 chattr 命令防止系统中某个关键文件被修改（加锁）：\n\n```bash\nchattr +i /opt/test.txt\n```\n\n\n\n然后试一下 [rm](https://getiot.tech/linux-command/rm/)、[mv](https://getiot.tech/linux-command/mv/)、rename 等命令操作于该文件，都是得到 “Operation not permitted” 的结果。\n\n执行下面命令可以解锁该文件：\n\n```bash\nchattr -i /opt/test.txt\n```\n\n\n\n让某个文件只能往里面追加内容，不能删除，一些日志文件适用于这种操作：\n\n```bash\nchattr +a /data/user_act.log\n```\n\n\n\n\n\n# Linux ln 命令 - 创建文件链接\n\n## 介绍\n\n**ln**（英文全拼：link）命令是 Linux 系统中非常重要的命令，它的作用是为某一个文件在另一个位置建立一个同步的链接。\n\nLinux 文件系统中的链接（link）可分为两种 —— 硬链接（hard link）与软链接/符号链接（symbolic link）。软链接类似于 Windows 系统中的快捷方式。\n\n**语法**：\n\n```bash\nln [OPTION]... [-T] TARGET LINK_NAME\nln [OPTION]... TARGET\nln [OPTION]... TARGET... DIRECTORY\nln [OPTION]... -t DIRECTORY TARGET...\n```\n\n\n\n**选项**：\n\n- `--backup[=CONTROL]` ：为每个已存在的目标文件创建备份文件。\n- `-b` ：类似 --backup，但不接受任何参数。\n- `-d`, `-F`, `--directory` ：允许超级用户尝试创建指向目录的硬链接（注意：此操作可能因系统限制而失败）。\n- `-f`, `--force` ：强行删除任何已存在的目标文件。\n- `-i`, `--interactive` ：删除目标文件前进行确认。\n- `-L`, `--logical` ：如目标为符号链接，本次创建链接时将其解引用。\n- `-n`, `--no-dereference` ：如果给定链接名是一个链接至某目录的符号链接，将其作为普通文件处理。\n- `-P`, `--physical` ：创建直接指向符号链接文件的硬链接。\n- `-r`, `--relative` ：创建相对于链接位置的符号链接。\n- `-s`, `--symbolic` ：创建符号链接而非硬链接。\n- `-S`, `--suffix=后缀` ：自行指定备份文件的后缀。\n- `-t`, `--target-directory=目录` ：在指定目录中创建链接。\n- `-T`, `--no-target-directory` ：总是将给定的链接名当作普通文件。\n- `-v`, `--verbose` ：列出每个链接的文件名称。\n- `--help` ：显示此帮助信息并退出。\n- `--version` ：显示版本信息并退出。\n\n## 示例\n\n假设当前目录下有一个 libldal.so.1.0.0 共享库文件，可以通过如下命令创建软链接 libldal.so.1 和 libldal.so：\n\n```bash\nln -s libldal.so.1.0.0 libldal.so.1\nln -s libldal.so.1 libldal.so\n```\n\n\n\n创建软链接后的文件情况：\n\n```bash\nlrwxrwxrwx 1 root root     12 Sep  2 16:15 libldal.so -> libldal.so.1\nlrwxrwxrwx 1 root root     16 Sep  2 16:14 libldal.so.1 -> libldal.so.1.0.0\n-rwxr-xr-x 1 root root 278416 Sep  2 16:12 libldal.so.1.0.0\n```\n\n\n\n\n\n# Linux locate 命令 - 快速查找文件\n\n## 介绍\n\n**locate** 命令用于在 Linux 系统中查找符合条件的文档，作用类似于 find 命令。不过，locate 命令会去保存文档和目录名称的数据库内，查找合乎范本样式条件的文档或目录。一般情况，我们只需要输入 `locate <filename>` 即可查找指定文件。\n\n相关命令：[which](https://getiot.tech/linux-command/which/)、[whereis](https://getiot.tech/linux-command/whereis/)、[find](https://getiot.tech/linux-command/find/)\n\n**安装**：\n\nlocate 命令由 mlocate 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install mlocate\n```\n\n\n\n在安装 mlocate 软件包期间，Linux 系统将创建一个 cron 作业，该作业每24小时运行一次 `updatedb` 命令，这样可以确保数据库得到定期更新。有关 cron 作业的更多信息，请检查 `/etc/cron.daily/mlocate` 文件。\n\n如果需要手动更新数据库，可以通过 root 或具有 sudo 特权的用户身份运行 `updatedb` 命令。更新过程将花费一些时间，具体取决于文件和目录的数量以及系统的速度。\n\n与功能强大的 `find` 命令相比，`locate` 命令的运行速度更快，使用方法更简单。但它缺少许多高级功能，只能按文件名进行搜索。\n\n**语法**：\n\n```bash\nlocate [-d  path | --database=path] [-e | -E | --[non-]existing] [-i |\n       --ignore-case] [-0 | --null] [-c | --count] [-w |  --wholename]  [-b  |\n       --basename]  [-l  N  |  --limit=N]  [-S | --statistics] [-r | --regex ]\n       [--regextype R] [--max-database-age D] [-P | -H  |  --nofollow]  [-L  |\n       --follow] [--version] [-A | --all] [-p | --print] [--help] pattern...\n```\n\n\n\n**选项**：\n\n- `-b`, `--basename`：仅匹配路径名的基本名称。\n- `-c`, `--count`：只输出找到的数量。\n- `-d`, `--database DBPATH`：使用 DBPATH 指定的数据库，而不是默认数据库 /var/lib/mlocate/mlocate.db。\n- `-e`, `--existing`：仅打印当前现有文件的条目。\n- `-1`：如果是 1，则启动安全模式。在安全模式下，使用者不会看到权限无法看到的档案。这会使速度减慢，因为 locate 必须到实际的档案系统中取得档案的权限资料。\n- `-0`, `--null`：在输出上带有 NUL 的单独条目。\n- `-S`, `--statistics`：不搜索条目，打印有关每个数据库的统计信息。\n- `-q`：安静模式，不会显示任何错误讯息。\n- `-P`, `--nofollow`, `-H`：检查文件存在时不要遵循尾随的符号链接。\n- `-l`, `--limit`, `-n LIMIT`：将输出（或计数）限制为 LIMIT 个条目。\n- `-n`：至多显示 n 个输出。\n- `-m`, `--mmap`：被忽略，为了向后兼容。\n- `-r`, `--regexp REGEXP`：使用基本正则表达式。\n- `--regex`：使用扩展正则表达式。\n- `-q`, `--quiet`：安静模式，不会显示任何错误讯息。\n- `-s`, `--stdio`：被忽略，为了向后兼容。\n- `-o`：指定资料库存的名称。\n- `-h`, `--help`：显示帮助。\n- `-i`, `--ignore-case`：忽略大小写。\n- `-V`, `--version`：显示版本信息。\n\n## 示例\n\n查找 passwd 文件，输入以下命令：\n\n```bash\nlocate passwd\n```\n\n\n\n搜索 etc 目录下所有以 sh 开头的文件 ：\n\n```bash\nlocate /etc/sh\n```\n\n\n\n忽略大小写搜索当前用户目录下所有以 r 开头的文件 ：\n\n```bash\nlocate -i ~/r\n```\n\n\n\n\n\n# Linux ls 命令 - 列出目录内容\n\n## 介绍\n\n**ls**（英文全拼：list files）命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)，在 Linux 中是使用率较高的命令。ls 命令的输出信息可以进行彩色加亮显示，以分区不同类型的文件。\n\n**语法**：\n\n```bash\nls [选项] <参数>\n```\n\n\n\n**选项**：\n\n- `-a`：显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）；\n- `-A`：显示除影藏文件“.”和“..”以外的所有文件列表；\n- `-C`：多列显示输出结果。这是默认选项；\n- `-l`：与“-C”选项功能相反，所有输出信息用单列格式输出，不输出为多列；\n- `-F`：在每个输出项后追加文件的类型标识符，具体含义：“`*`”表示具有可执行权限的普通文件，“`/`”表示目录，“`@`”表示符号链接，“`|`”表示命令管道 FIFO，“`=`”表示 sockets 套接字。当文件为普通文件时，不输出任何标识符；\n- `-b`：将文件中的不可输出的字符以反斜线“`\\`”加字符编码的方式输出；\n- `-c`：与“-lt”选项连用时，按照文件状态时间排序输出目录内容，排序的依据是文件的索引节点中的ctime字段。与“-l”选项连用时，则排序的一句是文件的状态改变时间；\n- `-d`：仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表；\n- `-f`：此参数的效果和同时指定“aU”参数相同，并关闭“lst”参数的效果；\n- `-i`：显示文件索引节点号（inode）。一个索引节点代表一个文件；\n- `--file-type`：与“`-F`”选项的功能相同，但是不显示“`*`”；\n- `-k`：以 KB（千字节）为单位显示文件大小；\n- `-l`：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；\n- `-m`：用“`,`”号区隔每个文件和目录的名称；\n- `-n`：以用户识别码和群组识别码替代其名称；\n- `-r`：以文件名反序排列并输出目录内容列表；\n- `-s`：显示文件和目录的大小，以区块为单位；\n- `-t`：用文件和目录的更改时间排序；\n- `-L`：如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录；\n- `-R`：递归处理，将指定目录下的所有文件及子目录一并处理；\n- `--full-time`：列出完整的日期与时间；\n- `--color[=WHEN]`：使用不同的颜色高亮显示不同类型的。\n\n**参数**：指定要显示列表的目录或文件\n\n## 示例\n\n显示当前目录下非影藏文件与目录\n\n```bash\nls\n```\n\n\n\n显示当前目录下包括影藏文件在内的所有文件列表\n\n```bash\nls -a\n```\n\n\n\n输出长格式列表（列出文件和文件夹的详细信息）\n\n```bash\nls -l\n```\n\n\n\n显示文件的 inode 信息（索引节点（index inode 简称为“inode”）是 Linux 中一个特殊的概念，具有相同的索引节点号的两个文本本质上是同一个文件（除文件名不同外）。）\n\n```bash\nls -i -l README.md SUMMARY.md\n```\n\n\n\n水平输出文件列表\n\n```bash\nls -m\n```\n\n\n\n垂直输出文件列表\n\n```bash\nls -1\n```\n\n\n\n最近修改的文件显示在最上面\n\n```bash\nls -t\n```\n\n\n\n显示递归文件\n\n```bash\nls -R\n```\n\n\n\n打印文件的 UID 和 GID\n\n```bash\nls -n\n```\n\n\n\n列出可读文件和文件夹详细信息\n\n```bash\nls -lh\n```\n\n\n\n显示文件夹信息\n\n```bash\nls -ld /etc/\n```\n\n\n\n按时间列出文件和文件夹详细信息\n\n```bash\nls -lt\n```\n\n\n\n按修改时间列出文件和文件夹详细信息\n\n```bash\nls -ltr\n```\n\n\n\n按照特殊字符对文件进行分类\n\n```bash\nls -F\n```\n\n\n\n列出文件并标记颜色分类\n\n```bash\nls --color=auto\n```\n\n\n\n\n\n# Linux lsblk 命令 - 列出块设备信息\n\n## 介绍\n\n**lsblk**（英文全拼：list block devices）命令用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出 RAM 盘的信息。常见的块设备包括硬盘、闪存盘、CD-ROM 等等。\n\n**语法**：\n\n```bash\nlsblk [options] [device...]\n```\n\n\n\n**选项**：\n\n```bash\n-a, --all            显示所有设备。\n-b, --bytes          以bytes方式显示设备大小。\n-d, --nodeps         不显示 slaves 或 holders。\n-D, --discard        print discard capabilities。\n-e, --exclude <list> 排除设备 (default: RAM disks)。\n-f, --fs             显示文件系统信息。\n-h, --help           显示帮助信息。\n-i, --ascii          use ascii characters only。\n-m, --perms          显示权限信息。\n-l, --list           使用列表格式显示。\n-n, --noheadings     不显示标题。\n-o, --output <list>  输出列。\n-P, --pairs          使用key=\"value\"格式显示。\n-r, --raw            使用原始格式显示。\n-t, --topology       显示拓扑结构信息。\n```\n\n\n\n## 示例\n\n列出系统所有块设备（默认以树状展示）\n\n```bash\n$ lsblk\nNAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT\nloop0    7:0    0   9.1M  1 loop /snap/canonical-livepatch/97\n...\nsda      8:0    0 931.5G  0 disk\n├─sda1   8:1    0 930.9G  0 part\n└─sda2   8:2    0   642M  0 part\nsdb      8:16   0   944G  0 disk\n├─sdb1   8:17   0 190.8G  0 part /\n├─sdb2   8:18   0     1K  0 part\n├─sdb5   8:21   0  15.7G  0 part [SWAP]\n└─sdb6   8:22   0 737.6G  0 part /home\nsdc      8:32   1  29.7G  0 disk\n├─sdc1   8:33   1  1023M  0 part\n└─sdc2   8:34   1  28.7G  0 part\n```\n\n\n\n指定块设备：\n\n```bash\n$ lsblk /dev/sdc\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsdc      8:32   1 29.7G  0 disk\n├─sdc1   8:33   1 1023M  0 part\n└─sdc2   8:34   1 28.7G  0 part\n```\n\n\n\n七个栏目说明如下：\n\n| 序号 |     字段     | 描述                                                         |\n| :--: | :----------: | ------------------------------------------------------------ |\n|  1   |    `NAME`    | 这是块设备名。                                               |\n|  2   |  `MAJ:MIN`   | 本栏显示主要和次要设备号。                                   |\n|  3   |     `RM`     | 本栏显示设备是否可移动设备。例如，在本例中设备 sdc 的 RM 值为1，表明它是可移动设备。 |\n|  4   |    `SIZE`    | 本栏列出设备的容量大小信息。例如，190.8G 表明该设备大小为 190.8GB，而 1K 表明该设备大小为 1KB。 |\n|  5   |     `RO`     | 该项表明设备是否为只读。例如，loop0 设备的 RO 值为1，表明它是只读的。 |\n|  6   |    `TYPE`    | 本栏显示块设备是否是磁盘或磁盘上的一个分区。                 |\n|  7   | `MOUNTPOINT` | 本栏指出设备挂载的挂载点。                                   |\n\n默认选项不会列出所有空设备。要查看这些空设备，请使用以下命令：\n\n```bash\nlsblk -a\n```\n\n\n\nlsblk命令也可以用于列出一个特定设备的拥有关系，同时也可以列出组和模式。可以通过以下命令来获取这些信息：\n\n```bash\nlsblk -m\n```\n\n\n\n该命令也可以只获取指定设备的信息。这可以通过在提供给lsblk命令的选项后指定设备名来实现。例如，你可能对了解以字节显示你的磁盘驱动器大小比较感兴趣，那么你可以通过运行以下命令来实现：\n\n```bash\nlsblk -b /dev/sda\n\n# 等价于\n\nlsblk --bytes /dev/sda\n```\n\n\n\n你也可以组合几个选项来获取指定的输出。例如，你也许想要以列表格式列出设备，而不是默认的树状格式。你可能也对移除不同栏目名称的标题感兴趣。可以将两个不同的选项组合，以获得期望的输出，命令如下：\n\n```bash\nlsblk -nl\n```\n\n\n\n要获取 SCSI 设备的列表，你只能使用 -S 选项。该选项是大写字母 S，不能和 -s 选项混淆，该选项是用来以颠倒的顺序打印依赖的。\n\n```bash\nlsblk -S\n```\n\n\n\nlsblk 列出 SCSI 设备，而 -s 是逆序选项（将设备和分区的组织关系逆转过来显示），其将给出如下输出。输入命令：\n\n```bash\nlsblk -s\n```\n\n\n\n列出块设备的 LABLE、UUID 等信息\n\n```bash\nlsblk -f\n```\n\n\n\n\n\n# Linux blkid 命令 - 显示块设备信息\n\n## 介绍\n\n**blkid**（英文全称：block id）命令主要用来对系统的块设备（包括交换分区）所使用的文件系统类型、LABEL、UUID 等信息进行查询。\n\n**语法**：\n\n```bash\nblkid [选项]\n```\n\n\n\n**选项**：\n\n- `-g`, `--garbage-collect` ：收集 blkid 缓存\n- `-o`, `--output <format>` ：指定输出格式\n- `-s`, `--match-tag <tag>` ：显示指定 tag 的信息\n- `-p`, `--probe` ：低级超级块探测（旁路缓存）\n- `-i`, `--info` ：收集有关 I/O 限制的信息\n\n注：UUID（Universally unique identifier）在 Linux 块设备中用作唯一标识符。使用如下命令也可以查看块设备的 UUID：\n\n```bash\nls -l /dev/disk/by-uuid/\n```\n\n\n\n## 示例\n\n显示指定设备 UUID\n\n```bash\nblkid -s UUID /dev/sda5 \n```\n\n\n\n显示所有设备 LABEL\n\n```bash\nblkid -s LABEL \n```\n\n\n\n以列表方式查看详细信息\n\n```bash\nblkid -o list \n```\n\n\n\n显示所有设备\n\n```bash\nblkid -o device \n```\n\n\n\n显示所有设备文件系统\n\n```bash\nblkid -s TYPE \n```\n\n\n\n\n\n# Linux cd 命令 - 切换当前目录\n\n## 介绍\n\n**cd**（英文全拼：change directory）命令用于切换当前工作目录。\n\n**语法**：\n\n```bash\ncd [dirName]\n```\n\n\n\n**参数**：\n\n- `dirName` 可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录（也就是刚 login 时所在的目录）。\n- 另外，**`~`** 也表示为 home 目录的意思， **`.`** 则是表示目前所在的目录， **`..`** 则表示目前目录位置的上一层目录。\n\n## 示例\n\n进入 /etc/apache2 目录\n\n```bash\ncd /etc/apache2\n```\n\n\n\n跳到当前用户的 home 目录\n\n```bash\ncd\n```\n\n\n\n或\n\n```bash\ncd ~\n```\n\n\n\n返回上级目录（若当前目录为“/“，则执行完后还在“/\"；\"..\"为上级目录的意思）\n\n```bash\ncd ..\n```\n\n\n\n返回上两级目录\n\n```bash\ncd ../..\n```\n\n\n\n返回进入此目录之前所在的目录\n\n```bash\ncd -\n```\n\n\n\n把上个命令的参数作为 cd 参数使用\n\n```bash\ncd !$\n```\n\n\n\n\n\n# Linux df 命令 - 显示磁盘使用情况\n\n## 介绍\n\n**df**（英文全拼：disk free） 命令用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计。\n\n语法：\n\n```bash\ndf [OPTION]... [FILE]...\n```\n\n\n\n选项：\n\n- `-a` 或 `--all`：包含全部的文件系统；\n- `--block-size=<区块大小>`：以指定的区块大小来显示区块数目；\n- `-h` 或 `--human-readable`：以可读性较高的方式来显示信息；\n- `-H` 或 `--si`：与-h参数相同，但在计算时是以 1000 Bytes 为换算单位而非 1024 Bytes；\n- `-i` 或 `--inodes`：显示 inode 的信息；\n- `-k` 或 `--kilobytes`：指定区块大小为 1024 字节；\n- `-l` 或 `--local`：仅显示本地端的文件系统；\n- `-m` 或 `--megabytes`：指定区块大小为 1048576 字节；\n- `--no-sync`：在取得磁盘使用信息前，不要执行 sync 指令，此为预设值；\n- `-P` 或 `--portability`：使用 POSIX 的输出格式；\n- `--sync`：在取得磁盘使用信息前，先执行sync指令；\n- `-t <文件系统类型>` 或 `--type=<文件系统类型>`：仅显示指定文件系统类型的磁盘信息；\n- `-T` 或 `--print-type`：显示文件系统的类型；\n- `-x <文件系统类型>` 或 `--exclude-type=<文件系统类型>`：不要显示指定文件系统类型的磁盘信息；\n- `--help`：显示帮助；\n- `--version`：显示版本信息。\n\n## 示例\n\n显示文件系统的磁盘使用情况统计\n\n```bash\n$ df \nFilesystem     1K-blocks    Used     Available Use% Mounted on \nudev             3914416         0   3914416    0%   /dev\ntmpfs             788796      1956    786840    1%   /run\n/dev/sdb1      195811956  96620276  89175324   53%   /\ntmpfs            3943968    303828   3640140    8%   /dev/shm\ntmpfs               5120         4      5116    1%   /run/lock\n```\n\n\n\n第1列指定文件系统的名称，第2列指定一个特定的文件系统1K-块（1K是1024字节）为单位的总内存，Used 和 Available 列表示已使用和可用的内存容量，Use% 列显示使用的内存的百分比，而最后一列\"Mounted on\"显示的文件系统的挂载点。\n\ndf 也可以显示磁盘使用的文件系统信息\n\n```bash\n$ df /dev/shm/\nFilesystem     1K-blocks    Used      Available Use% Mounted on \ntmpfs          3943968      293584    3650384    8%   /dev/shm\n```\n\n\n\n用 `-i` 选项的 `df` 命令的输出显示 `inode` 信息而非块使用量\n\n```bash\ndf -i \n```\n\n\n\n显示所有的信息:\n\n```bash\ndf --total \n```\n\n\n\n我们看到输出的末尾，包含一个额外的行，显示总的每一列。\n\n用 `-h` 选项，通过它可以产生可读的格式 df 命令的输出\n\n```bash\ndf -h\n```\n\n\n\n输出的数字以 G（千兆字节）、M（兆字节）和 K（千字节）为单位。\n\n\n\n# Linux dirs 命令 - 显示当前目录栈\n\n## 介绍\n\n**dirs** 命令用于显示当前记住的目录列表（目录栈）。通过 `pushd` 命令可以将目录存入列表中；`popd` 命令可用于遍历弹出列表。\n\n所谓的目录栈（或目录堆栈），其实就是在内存中的一个列表，这个列表用于存放目录条目信息。\n\n和 cd 命令一样，dirs、pushd、popd 命令也是 bash 的内建命令，因此无法使用 which 命令查找，只要登录到 bash，就可以使用这几个命令。\n\n**语法**：\n\n```bash\ndirs [选项] [参数]\n```\n\n\n\n**选项**：\n\n- `-c`：删除所有元素以清空目录栈\n- `-l`：不打印与主目录相关的波浪号前缀的目录\n- `-p`：每行一个条目打印目录栈\n- `-v`：每行一个条目，以栈中位置为前缀打印目录栈\n\n**参数**：\n\n- `+N`：显示 dirs 不带选项启动时显示的目录列表左起中第 N 个目录，从零开始。\n- `-N`：显示 dirs 不带选项启动时显示的目录列表右起中第 N 个目录，从零开始。\n\n## 示例\n\n显示当前的目录栈\n\n```bash\n$ dirs\n~/workspace\n```\n\n\n\n显示当前的目录栈（不带波浪号前缀）\n\n```bash\n$ dirs -l\n/home/rudy/workspace\n```\n\n\n\n使用 pushd 命令将指定目录（/usr/lib/fonts 和 /usr/share/fonts）压入目录栈中\n\n```bash\n$ pushd /usr/lib/fonts\n/usr/lib/fonts ~\n$ pushd /usr/share/fonts/\n/usr/share/fonts /usr/lib/fonts ~\n```\n\n\n\n按条目显示目录列表\n\n```bash\n$ dirs -p -v\n 0  /usr/share/fonts\n 1  /usr/lib/fonts\n 2  ~\n```\n\n\n\n在最近两个目录之间切换\n\n```bash\n$ pushd\n```\n\n\n\n注意：用 pushd 不加参数在最近的两个目录之间切换时，当前目录总是位于堆栈的最上面。\n\n在多个目录之间切换，比如切换到 **~** 目录\n\n```bash\n$ pushd +2\n```\n\n\n\n从目录堆栈中删除目录（从堆栈顶端删除）\n\n```bash\n$ popd \n```\n\n\n\n从目录堆栈中删除指定目录（删除堆栈中第1个目录）\n\n```bash\n$ popd +1\n```\n\n\n\n清空目录堆栈\n\n```bash\n$ dirs -c\n```\n\n\n\n\n\n# Linux pushd 命令 - 将目录压入目录栈\n\nLinux **pushd** 命令把原目录和当前目录压入到一个虚拟的目录堆栈中（可通过 dirs 命令查看），如果不指定参数，则会回到前一个目录，并把堆栈中最近的两个目录作交换。\n\n具体参考 [dirs 命令用法](https://getiot.tech/linux-command/dirs/)\n\n\n\n# Linux popd 命令 - 恢复目录栈顶部目录\n\nLinux **popd** 命令弹出目录堆栈中的目录，与 dirs 和 pushd 命令配合使用。\n\n具体参考 [dirs 命令用法](https://getiot.tech/linux-command/dirs/)\n\n\n\n# Linux du 命令 - 显示文件和目录大小\n\n## 介绍\n\n**du**（英文全拼：disk usage）命令用于显示指定的目录或文件所占用的磁盘空间。\n\n**语法**：\n\n```bash\ndu [-abcDhHklmsSx] [-L <符号连接>] [-X <文件>]\n   [--block-size]\n   [--exclude=<目录或文件>]\n   [--max-depth=<目录层数>]\n   [--help]\n   [--version]\n   [目录或文件]\n```\n\n\n\n**参数说明**：\n\n- `-a` 或 `-all` 显示目录中个别文件的大小。\n- `-b` 或 `-bytes` 显示目录或文件大小时，以 byte 为单位。\n- `-c` 或 `--total` 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。\n- `-D` 或 `--dereference-args` 显示指定符号连接的源文件大小。\n- `-h` 或 `--human-readable` 以 K，M，G 为单位，提高信息的可读性。\n- `-H` 或 `--si` 与 `-h` 参数相同，但是 K，M，G 是以 1000 为换算单位。\n- `-k` 或 `--kilobytes` 以 1024 bytes 为单位。\n- `-l` 或 `--count-links` 重复计算硬件连接的文件。\n- `-L <符号连接>` 或 `--dereference <符号连接>` 显示选项中所指定符号连接的源文件大小。\n- `-m` 或 `--megabytes` 以 1MB 为单位。\n- `-s` 或 `--summarize` 仅显示总计。\n- `-S` 或 `--separate-dirs` 显示个别目录的大小时，并不含其子目录的大小。\n- `-x` 或 `--one-file-xystem` 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。\n- `-X <文件>` 或 `--exclude-from=<文件>` 在 `<文件>` 指定目录或文件。\n- `--exclude=<目录或文件>` 略过指定的目录或文件。\n- `--max-depth=<目录层数>` 超过指定层数的目录后，予以忽略。\n- `--help` 显示帮助。\n- `--version` 显示版本信息。\n\n## 示例\n\n显示目录或者文件所占空间\n\n```bash\n$ du\n49012   ./dir\n57188   .\n```\n\n\n\n只显示当前目录下面的子目录的目录大小和当前目录的总的大小，最下面的 57188 为当前目录的总大小。\n\n显示指定文件（当前目录下所有文件和目录）所占空间\n\n```bash\n$ du ./*\n49012   ./dir\n4       ./file1\n8168    ./file2\n```\n\n\n\n以方便阅读的格式显示当前目录所占空间情况\n\n```bash\n$ du -sh ./*\n48M     ./dir\n4.0K    ./file1\n8.0M    ./file2\n```\n\n\n\n\n\n# Linux mkdir 命令 - 创建目录\n\n## 介绍\n\n**mkdir**（英文全拼：make directory）命令用于创建目录。\n\n**语法**：\n\n```bash\nmkdir [选项] dirName\n```\n\n\n\n**选项**：\n\n- `-Z`：设置安全上下文，当使用 SELinux 时有效；\n- `-m <目标属性>` 或 `--mode<目标属性>`：建立目录的同时设置目录的权限；\n- `-p` 或 `--parents`：若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；\n- `--version`：显示版本信息。\n\n**参数**：\n\n参数 `dirName` 为将要创建的目录名称。如果在目录名的前面没有加任何路径名，则在当前目录下创建由 `dirName` 指定的目录；如果给出了一个已经存在的路径，将会在该目录下创建一个指定的目录。在创建目录时，应保证新建的目录与它所在目录下的文件没有重名。\n\n## 示例\n\n在当前目录下创建一个名为 getiot 的子目录\n\n```bash\nmkdir getiot\n```\n\n\n\n创建并设置 getiot 目录权限为 700\n\n```bash\nmkdir -m 700 getiot\n```\n\n\n\n在当前目录下创建 getiot/linux 目录（如果 getiot 目录不存在，则创建一个）\n\n```bash\nmkdir -p getiot/linux \n```\n\n\n\n注意：如果不加 -p 参数，且 getiot 目录不存在，会产生错误。\n\n\n\n# Linux pwd 命令 - 显示当前工作目录\n\n## 介绍\n\n**pwd**（英文全拼：print working directory） 命令用于显示用户当前所在的工作目录（以绝对路径显示）。\n\n**语法**：\n\n```bash\npwd [选项]\n```\n\n\n\n**选项**：\n\n- `-L` 或 `--logical`：使用 PWD 环境变量，即使它包含符号链接\n- `-P` 或 `--physical`：避免使用符号链接\n- `--help`：查看帮助\n- `--version`：显示版本信息\n\n## 示例\n\n查看当前所在目录\n\n```bash\n$ pwd\n/home/rudy/workspace\n```\n\n\n\n在 workspace 下创建一个 dir 目录，并创建一个 dir_link 软链接指向 dir 目录\n\n```bash\nmkdir dir\nln -s dir/ dir_link\n```\n\n\n\n切换到 dir_link 目录\n\n```bash\ncd dir_link\n```\n\n\n\n查看当前所在目录\n\n```bash\n$ pwd\n/home/rudy/workspace/dir_link\n```\n\n\n\n以 logical 方式查看当前所在目录\n\n```bash\n$ pwd -L\n/home/rudy/workspace/dir_link\n```\n\n\n\n以 physical 方式查看当前所在目录\n\n```bash\n$ pwd -P\n/home/rudy/workspace/dir\n```\n\n\n\n\n\n# Linux mount 命令 - 挂载文件系统\n\n## 介绍\n\n**mount** 命令用于挂载系统外的文件系统到指定加载点。\n\n相关命令：[umount](https://getiot.tech/linux-command/umount/)\n\n**语法**：\n\n```bash\nmount [选项] [参数]\n```\n\n\n\n详细语法格式：\n\n```bash\nmount [-l|-h|-V]\nmount -a [-fFnrsvw] [-t fstype] [-O optlist]\nmount [-fnrsvw] [-o options] device|dir\nmount [-fnrsvw] [-t fstype] [-o options] device dir\n```\n\n\n\n**参数**：\n\n- `-V`：显示程序版本。\n- `-h`：显示辅助信息。\n- `-l`：显示以加载的文件系统列表。\n- `-v`：冗长模式，输出指令执行的详细信息，通常和 `-f` 用来除错。\n- `-a`：将 /etc/fstab 中定义的所有档案系统挂上。\n- `-F`：这个命令通常和 `-a` 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。\n- `-f`：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 `-v` 一起使用。\n- `-n`：加载没有写入文件“/etc/mtab”中的文件系统。\n- `-r`：将文件系统加载为只读模式。\n- `-s-r`：等于 `-o ro`\n- `-w`：等于 `-o rw`\n- `-L`：将含有特定标签的硬盘分割挂上。\n- `-U`：将档案分割序号为 的档案系统挂下。`-L` 和 `-U` 必须在 /proc/partition 这种档案存在时才有意义。\n- `-t`：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。\n- `-o async`：打开非同步模式，所有的档案读写动作都会用非同步模式执行。\n- `-o sync`：在同步模式下执行。\n- `-o atime`、`-o noatime`：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。\n- `-o auto`、`-o noauto`：打开/关闭自动挂上模式。\n- `-o defaults`：使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.\n- `-o dev`、`-o nodev-o exec`、`-o noexec` 允许执行档被执行。\n- `-o suid`、`-o nosuid`：允许执行档在 root 权限下执行。\n- `-o user`、`-o nouser`：使用者可以执行 mount/umount 的动作。\n- `-o remount`：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是只读的系统，现在用可读写的模式重新挂上。\n- `-o ro`：用只读模式挂载。\n- `-o rw`：用可读写模式挂载。\n- `-o loop=`：使用 loop 模式用来将一个档案当成硬盘分割挂载上系统。\n\n**参数**：\n\n- 设备文件名：指定要加载的文件系统对应的设备名（如 /dev/sdb1）；\n- 加载点：指定加载点目录。\n\n## 示例\n\n将 /dev/sdb1 挂载到 /mnt 目录\n\n```bash\nmount /dev/sdb1 /mnt\n```\n\n\n\n将 /dev/sdb1 以只读方式挂载到 /mnt 目录\n\n```bash\nmount -o ro /dev/sdb1 /mnt\n```\n\n\n\n挂载光盘设备到 /mnt/cdrom 目录（目录不存在，需要先创建）\n\n```bash\nmount -t auto /dev/cdrom /mnt/cdrom\n```\n\n\n\n将 /tmp/image.iso 这个光碟的 image 档使用 loop 模式挂载到 /mnt/cdrom 目录。用这种方法可以将一般网络上可以找到的 Linux 光碟 ISO 档在不烧录成光碟的情况下查看其内容。\n\n```bash\nmount -o loop /tmp/image.iso /mnt/cdrom\n```\n\n\n\n将远程 NFS 网络文件系统挂载到本地 /mnt 目录\n\n```bash\nmount -t nfs -o nolock 192.168.30.189:/srv/nfs/ /mnt/\n```\n\n\n\n\n\n# Linux umount 命令 - 卸载文件系统\n\n## 介绍\n\n**umount**（英文全拼：unmount）命令用于卸载文件系统。\n\n利用设备名或挂载点都能 umount 文件系统，不过最好还是通过挂载点卸载，以免使用绑定挂载（一个设备，多个挂载点）时产生混乱。如果存在多个挂载点，每次执行 umount 会按先进后出的方式卸载。\n\n相关命令：[mount](https://getiot.tech/linux-command/mount/)\n\n**语法**：\n\n```bash\numount [选项] [参数]\n```\n\n\n\n详细语法格式：\n\n```bash\numount -a [-dflnrv] [-t fstype] [-O option...]\numount [-dflnrv] {directory|device}...\numount -h|-V\n```\n\n\n\n**选项**：\n\n- `-a` 卸载 /etc/mtab 中记录的所有文件系统。\n- `-h` 显示帮助。\n- `-n` 卸载时不要将信息存入 /etc/mtab 文件中。\n- `-r` 若无法成功卸载，则尝试以只读的方式重新挂载文件系统。\n- `-t <文件系统类型>` 仅卸载选项中所指定的文件系统。\n- `-v` 执行时显示详细的信息。\n- `-V` 显示版本信息。\n\n**参数**：文件系统（可以是设备名或挂载点）。\n\n## 示例\n\n通过设备名卸载，并打印详细信息：\n\n```bash\n$ sudo umount -v /dev/sdc1\numount: /mnt (/dev/sdc1) unmounted\n```\n\n\n\n通过挂载点卸载，并打印详细信息：\n\n```bash\n$ sudo umount -v /mnt\numount: /mnt unmounted\n```\n\n\n\n注意：执行 umount 命令需要 root 权限，因此需要在命令前添加 sudo。\n\n如果设备正忙，执行 umount 将会失败。卸载失败的常见原因是，某个打开的 shell 当前目录为挂载点里的某个目录。\n\n```bash\n$ sudo umount -v /mnt\numount: /mnt: target is busy.\n```\n\n\n\n有时，导致设备忙的原因并不好找。碰到这种情况时，可以用 [lsof](https://getiot.tech/linux-command/lsof/) 列出已打开文件，然后搜索列表查找待卸载的挂载点。\n\n```bash\n$ lsof | grep mnt\nbash    1894    rudy  cwd    DIR    8,33    4096    1 /mnt\n```\n\n\n\n从上面的输出可知，无法卸载的原因在于，rudy 运行的 PID 为 1894 的 bash 进程打开了挂载点 /mnt。\n\n应对系统文件正忙的另一种方法是执行延迟卸载：\n\n```bash\n$ sudo umount -vl /mnt\n```\n\n\n\n延迟卸载（lazy unmount）会立即卸载目录树里的文件系统，等到设备不再繁忙时才清理所有相关资源。卸载可移动存储介质还可以用 [eject](https://getiot.tech/linux-command/eject/) 命令。\n\n下面命令会卸载 cdrom 分区并弹出 CD：\n\n```bash\n$ sudo eject /dev/cdrom\n```\n\n\n\n\n\n# Linux eject 命令 - 弹出可移动介质\n\n## 介绍\n\n**eject** 命令用于退出抽取式设备。若设备已挂载，则先将该设备卸载再退出。\n\neject 允许可移动介质（典型是 CD-ROM、软盘、磁带、或者 JAZ 以及 zip 磁盘）在软件控制下弹出。该命令也可以控制一些多盘片 CD-ROM 控制器，控制一些设备支持的自动弹出功能，以及控制一些 CD-ROM 驱动器磁盘托盘的关闭。\n\n**语法**：\n\n```bash\neject [选项] [参数]\n```\n\n\n\n详细语法格式：\n\n```bash\neject [-vnrsfmqp] [<name>]\neject [-vn] -d\neject [-vn] -a on|off|1|0 [<name>]\neject [-vn] -c slot [<name>]\neject [-vn] -i on|off|1|0 [<name>]\neject [-vn] -t [<name>]\neject [-vn] -T [<name>]\neject [-vn] -x <speed> [<name>]\neject [-vn] -X [<name>]\n```\n\n\n\n**选项**：\n\n- `-a <开关>` 或 `--auto <开关>`：控制设备的自动退出功能。\n- `-c <光驱编号>` 或 `--changerslut <光驱编号>`：选择光驱柜中的光驱。\n- `-d` 或 `--default`：显示预设的设备，而不是实际执行动作。\n- `-f` 或 `--floppy`：退出抽取式磁盘。\n- `-h` 或 `--help`：显示帮助。\n- `-n` 或 `--noop`：显示指定的设备。\n- `-q` 或 `--tape`：退出磁带。\n- `-r` 或 `--cdrom`：退出光盘。\n- `-s` 或 `--scsi`：以 SCSI 指令来退出设备。\n- `-t` 或 `--trayclose`：关闭光盘的托盘。\n- `-v` 或 `--verbose`：执行时，显示详细的说明。\n\n**参数**：指定弹出的文件 name，可以是设备名或挂载点。\n\n## 示例\n\n不加参数默认弹出\n\n```bash\n$ eject\n```\n\n\n\n指定弹出设备\n\n```bash\n$ eject -r /dev/cdrom\n```\n\n\n\n\n\n# Linux stat 命令 - 显示文件或文件系统状态\n\n## 介绍\n\n**stat**（英文全拼：status）命令用于显示文件或文件系统的状态，以文字的格式来显示 inode 的内容。\n\n**语法**：\n\n```bash\nstat [OPTION]... FILE...\n```\n\n\n\n**选项**：\n\n- `-L`：支持符号连接\n- `-f`：显示文件系统状态而非文件状态\n- `-t`：以简洁方式输出信息\n- `--help`：显示指令的帮助信息\n- `--version`：显示指令的版本信息\n\n**参数**：文件或目录\n\n## 示例\n\n假设当前目录下由 dir 目录及软链接 dir_link\n\n```bash\n$ ls -ld dir*\ndrwxr-xr-x 2 root root 4096 Apr 13 10:33 dir\nlrwxrwxrwx 1 root root    3 Apr 13 13:55 dir_link -> dir\n```\n\n\n\n查看 dir 目录的 inode 内容\n\n```bash\n$ stat dir\n  File: dir\n  Size: 4096            Blocks: 8          IO Block: 4096   directory\nDevice: b302h/45826d    Inode: 2752621     Links: 2\nAccess: (0755/drwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)\nAccess: 2021-04-13 10:33:54.796081184 +0000\nModify: 2021-04-13 10:33:47.508153771 +0000\nChange: 2021-04-13 10:33:47.508153771 +0000\n Birth: 2021-04-13 10:33:08.968537620 +0000\n```\n\n\n\n查看 dir_link 目录的 inode 内容\n\n```bash\nstat dir_link\n  File: dir_link -> dir\n  Size: 3               Blocks: 0          IO Block: 4096   symbolic link\nDevice: b302h/45826d    Inode: 2752631     Links: 1\nAccess: (0777/lrwxrwxrwx)  Uid: (    0/    root)   Gid: (    0/    root)\nAccess: 2021-04-13 13:55:59.591319842 +0000\nModify: 2021-04-13 13:55:54.755368008 +0000\nChange: 2021-04-13 13:55:54.755368008 +0000\n Birth: 2021-04-13 13:55:54.755368008 +0000\n```\n\n\n\n查看 file 文件的 inode 内容\n\n```bash\n$ stat file\n  File: file\n  Size: 8360846         Blocks: 16336      IO Block: 4096   regular file\nDevice: b302h/45826d    Inode: 2752632     Links: 1\nAccess: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)\nAccess: 2021-04-13 13:59:07.161451669 +0000\nModify: 2021-04-13 13:59:07.197451310 +0000\nChange: 2021-04-13 13:59:07.197451310 +0000\n Birth: 2021-04-13 13:59:07.161451669 +0000\n```\n\n\n\n\n\n# Linux tree 命令 - 以树形结构显示目录\n\n## 介绍\n\n**tree** 命令以树状图列出目录的内容。执行 tree 指令，会列出指定目录下的所有文件，包括子目录里的文件。\n\n**语法**：\n\n```bash\ntree [选项] [参数]\n```\n\n\n\n详细语法格式：\n\n```bash\ntree [-acdfghilnpqrstuvxACDFQNSUX]  [-L level [-R]] [-H baseHREF] \n     [-T title] [-o filename] [--nolinks] [-P pattern] [-I pattern]\n     [--inodes] [--device] [--noreport] [--dirsfirst] [--version] \n     [--help] [--filelimit #] [--si] [--prune] [--du] [--timefmt  format]\n     [--matchdirs] [--fromfile] [--] [directory ...]\n```\n\n\n\n**选项**：\n\n- `-a` 显示所有文件和目录。\n- `-A` 使用 ASNI 绘图字符显示树状图而非以 ASCII 字符组合。\n- `-C` 在文件和目录清单加上色彩，便于区分各种类型。\n- `-d` 显示目录名称而非内容。\n- `-D` 列出文件或目录的更改时间。\n- `-f` 在每个文件或目录之前，显示完整的相对路径名称。\n- `-F` 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上 \"`*`\"、\"`/`\"、\"`=`\"、\"`@`\"、\"`|`\" 号。\n- `-g` 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。\n- `-i` 不以阶梯状列出文件或目录名称。\n- `-L level` 限制目录显示层级。\n- `-l` 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。\n- `-n` 不在文件和目录清单加上色彩。\n- `-N` 直接列出文件和目录名称，包括控制字符。\n- `-p` 列出权限标示。\n- `-P <范本样式>` 只显示符合范本样式的文件或目录名称。\n- `-q` 用 \"`?`\" 号取代控制字符，列出文件和目录名称。\n- `-s` 列出文件或目录大小。\n- `-t` 用文件和目录的更改时间排序。\n- `-u` 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。\n- `-x` 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。\n\n**参数**：目录（可以是绝对路径或相对路径）。\n\n## 示例\n\n以树状图列出当前目录结构\n\n```bash\n$ tree\n.\n├── file\n├── subdir1\n│   ├── hello.txt\n│   └── world.txt\n└── subdir2\n    ├── hello.txt\n    └── world.txt\n\n2 directories, 5 files\n```\n\n\n\n只显示一级目录\n\n```bash\n$ tree -L 1\n.\n├── file\n├── subdir1\n└── subdir2\n\n2 directories, 1 file\n```\n\n\n\n\n\n# Linux fdisk 命令 - 管理磁盘分区表\n\n## 介绍\n\n**fdisk** 是一个创建和维护分区表的程序，它兼容 DOS 类型的分区表、BSD 或者 SUN 类型的磁盘列表。\n\nfdisk 命令可用于观察硬盘实体使用情况，也可对硬盘分区。它采用传统的问答式界面，而非类似 DOS fdisk 的 cfdisk 互动式操作界面，因此在使用上较为不便，但功能却丝毫不打折扣。\n\n**语法**：\n\n```bash\nfdisk [选项] [参数]\n```\n\n\n\n**选项**：\n\n- `-b <分区大小>`：指定每个分区的大小。\n- `-l`：列出指定的外围设备的分区表状况。\n- `-s <分区编号>`：将指定的分区大小输出到标准输出上，单位为区块。\n- `-u`：搭配 \"`-l`\" 参数列表，会用分区数目取代柱面数目，来表示每个分区的起始地址。\n- `-v`：显示版本信息。\n\n**参数**： 指定要进行分区或者显示分区的硬盘设备文件。\n\n**分区菜单操作说明**：\n\n- `m` ：显示菜单和帮助信息\n- `a` ：活动分区标记/引导分区\n- `d` ：删除分区\n- `l` ：显示分区类型\n- `n` ：新建分区\n- `p` ：显示分区信息\n- `q` ：退出不保存\n- `t` ：设置分区号\n- `v` ：进行分区检查\n- `w` ：保存修改\n- `x` ：扩展应用，高级功能\n\n## 示例\n\n显示当前分区情况：\n\n```bash\n$ sudo fdisk -l\n\nDisk /dev/sda: 10.7 GB, 10737418240 bytes\n255 heads, 63 sectors/track, 1305 cylinders\nUnits = cylinders of 16065 * 512 = 8225280 bytes\n\n  Device Boot   Start     End   Blocks  Id System\n/dev/sda1  *      1     13   104391  83 Linux\n/dev/sda2       14    1305  10377990  8e Linux LVM\n\nDisk /dev/sdb: 5368 MB, 5368709120 bytes\n255 heads, 63 sectors/track, 652 cylinders\nUnits = cylinders of 16065 * 512 = 8225280 bytes\n\nDisk /dev/sdb doesn't contain a valid partition table\n```\n\n\n\n对磁盘进行分区，首先选择要进行操作的磁盘（如 /dev/sdb）：\n\n```bash\n$ sudo fdisk /dev/sdb\n```\n\n\n\n输入 `m` 列出可以执行的命令：\n\n```bash\ncommand (m for help): m\nCommand action\n   a   toggle a bootable flag\n   b   edit bsd disklabel\n   c   toggle the dos compatibility flag\n   d   delete a partition\n   l   list known partition types\n   m   print this menu\n   n   add a new partition\n   o   create a new empty DOS partition table\n   p   print the partition table\n   q   quit without saving changes\n   s   create a new empty Sun disklabel\n   t   change a partition's system id\n   u   change display/entry units\n   v   verify the partition table\n   w   write table to disk and exit\n   x   extra functionality (experts only)\n```\n\n\n\n输入`p`列出磁盘目前的分区情况：\n\n```bash\nCommand (m for help): p\n\nDisk /dev/sdb: 3221 MB, 3221225472 bytes\n255 heads, 63 sectors/track, 391 cylinders\nUnits = cylinders of 16065 * 512 = 8225280 bytes\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/sdb1               1           1        8001   8e  Linux LVM\n/dev/sdb2               2          26      200812+  83  Linux\n```\n\n\n\n输入`d`然后选择分区，删除现有分区：\n\n```bash\nCommand (m for help): d\nPartition number (1-4): 1\n\nCommand (m for help): d\nSelected partition 2\n```\n\n\n\n查看分区情况，确认分区已经删除：\n\n```bash\nCommand (m for help): print\n\nDisk /dev/sdb: 3221 MB, 3221225472 bytes\n255 heads, 63 sectors/track, 391 cylinders\nUnits = cylinders of 16065 * 512 = 8225280 bytes\n\n   Device Boot      Start         End      Blocks   Id  System\n\nCommand (m for help):\n```\n\n\n\n输入`n`建立新的磁盘分区，首先建立两个主磁盘分区：\n\n```bash\nCommand (m for help): n\nCommand action\n   e   extended\n   p   primary partition (1-4)\np    # 建立主分区\nPartition number (1-4): 1  # 分区号\nFirst cylinder (1-391, default 1):  # 分区起始位置\nUsing default value 1\nlast cylinder or +size or +sizeM or +sizeK (1-391, default 391): 100  # 分区结束位置，单位为扇区\n\nCommand (m for help): n  # 再建立一个分区\nCommand action\n   e   extended\n   p   primary partition (1-4)\np \nPartition number (1-4): 2  # 分区号为2\nFirst cylinder (101-391, default 101):\nUsing default value 101\nLast cylinder or +size or +sizeM or +sizeK (101-391, default 391): +200M  # 分区结束位置，单位为M\n```\n\n\n\n确认分区建立成功：\n\n```bash\nCommand (m for help): p\n\nDisk /dev/sdb: 3221 MB, 3221225472 bytes\n255 heads, 63 sectors/track, 391 cylinders\nUnits = cylinders of 16065 * 512 = 8225280 bytes\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/sdb1               1         100      803218+  83  Linux\n/dev/sdb2             101         125      200812+  83  Linux\n```\n\n\n\n再建立一个逻辑分区：\n\n```bash\nCommand (m for help): n\nCommand action\n   e   extended\n   p   primary partition (1-4)\ne  # 选择扩展分区\nPartition number (1-4): 3\nFirst cylinder (126-391, default 126):\nUsing default value 126\nLast cylinder or +size or +sizeM or +sizeK (126-391, default 391):\nUsing default value 391\n```\n\n\n\n确认扩展分区建立成功：\n\n```bash\nCommand (m for help): p\n\nDisk /dev/sdb: 3221 MB, 3221225472 bytes\n255 heads, 63 sectors/track, 391 cylinders\nUnits = cylinders of 16065 * 512 = 8225280 bytes\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/sdb1               1         100      803218+  83  Linux\n/dev/sdb2             101         125      200812+  83  Linux\n/dev/sdb3             126         391     2136645    5  Extended\n```\n\n\n\n在扩展分区上建立两个逻辑分区：\n\n```bash\nCommand (m for help): n\nCommand action\n   l   logical (5 or over)\n   p   primary partition (1-4)\nl # 选择逻辑分区\nFirst cylinder (126-391, default 126):\nUsing default value 126\nLast cylinder or +size or +sizeM or +sizeK (126-391, default 391): +400M    \n\nCommand (m for help): n\nCommand action\n   l   logical (5 or over)\n   p   primary partition (1-4)\nl\nFirst cylinder (176-391, default 176):\nUsing default value 176\nLast cylinder or +size or +sizeM or +sizeK (176-391, default 391):\nUsing default value 391\n```\n\n\n\n确认逻辑分区建立成功：\n\n```bash\nCommand (m for help): p\n\nDisk /dev/sdb: 3221 MB, 3221225472 bytes\n255 heads, 63 sectors/track, 391 cylinders\nUnits = cylinders of 16065 * 512 = 8225280 bytes\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/sdb1               1         100      803218+  83  Linux\n/dev/sdb2             101         125      200812+  83  Linux\n/dev/sdb3             126         391     2136645    5  Extended\n/dev/sdb5             126         175      401593+  83  Linux\n/dev/sdb6             176         391     1734988+  83  Linux\n\nCommand (m for help):\n```\n\n\n\n从上面的结果我们可以看到，在硬盘sdb我们建立了2个主分区（sdb1，sdb2），1个扩展分区（sdb3），2个逻辑分区（sdb5，sdb6）\n\n注意：主分区和扩展分区的磁盘号位1-4，也就是说最多有4个主分区或者扩展分区，逻辑分区开始的磁盘号为5，因此在这个实验中试没有 sdb4 的。\n\n最后对分区操作进行保存：\n\n```bash\nCommand (m for help): w\nThe partition table has been altered!\n\nCalling ioctl() to re-read partition table.\nSyncing disks.\n```\n\n\n\n建立好分区之后我们还需要对分区进行格式化才能在系统中使用磁盘。\n\n在 sdb1 上建立 ext2 分区：\n\n```bash\n$ sudo mkfs.ext2 /dev/sdb1\n```\n\n\n\n在 sdb6 上建立 ext3 分区：\n\n```bash\n$ sudo mkfs.ext3 /dev/sdb6\n```\n\n\n\n建立两个目录 `/oracle` 和 `/web`，将新建好的两个分区挂载到系统：\n\n```bash\n$ sudo mkdir /oracle\n$ sudo mkdir /web\n$ sudo mount /dev/sdb1 /oracle\n$ sudo mount /dev/sdb6 /web\n```\n\n\n\n查看分区挂载情况：\n\n```bash\n$ df -h\n文件系统              容量  已用 可用 已用% 挂载点\n/dev/mapper/VolGroup00-LogVol00\n                      6.7G  2.8G  3.6G  44% /\n/dev/sda1              99M   12M   82M  13% /boot\ntmpfs                 125M     0  125M   0% /dev/shm\n/dev/sdb1             773M  808K  733M   1% /oracle\n/dev/sdb6             1.7G   35M  1.6G   3% /web\n```\n\n\n\n如果需要每次开机自动挂载则需要修改 `/etc/fstab` 文件，加入两行配置：\n\n```bash\n/dev/sdb1       /oracle    ext2    defaults      0 0\n/dev/sdb6       /web       ext3    defaults      0 0\n```\n\n\n\n\n\n# Linux sfdisk 命令 - 管理磁盘分区表\n\n## 介绍\n\n**sfdisk** 命令用于显示或操作磁盘分区表。\n\n与 [fdisk](https://getiot.tech/linux-command/fdisk/) 菜单式交互操作不同，sfdisk 是一个面向脚本的工具，由命令驱动（从文件或 stdin 读取输入），因此通常用于在 shell 脚本中对硬盘进行分区或对分区表进行备份和恢复。\n\n**语法**：\n\n```bash\nsfdisk [options] device [-N partition-number]\nsfdisk [options] command\n```\n\n\n\n**选项**：\n\n- `-d` ：显示硬盘分区的设置。\n- `-g` ：输出模块的载入信息。\n- `-l` ：显示后硬盘分区的相关设置。\n- `-s` ：显示分区的大小，单位为区块。\n- `-T` ：显示所有 sfdisk 能辨识的文件系统 ID。\n- `-V` ：检查硬盘分区是否正常。\n- `-x` ：显示扩展分区中的逻辑分区。\n- `-N` ：按照从标准输入读取的分区表，在指定的块设备上创建分区表。\n- `-A` ：打开指定分区的启动标记（仅可用于 MBR 分区表）。\n- `--delete` ：删除指定/全部的分区。\n- `-J` ：按照 JSON 格式导出指定块设备的现有分区表。\n- `-F` ：列出指定/全部块设备上尚未被分区的剩余空间。\n- `-r` ：按照各分区的起始扇区，对现有分区进行重新编号。\n- `-a` ：仅在现有的分区表上添加新分区，而不是创建一个全新的分区表。\n- `-f` ：禁用所有一致性检查，强制执行看上去明显的错误动作。\n- `-n` ：模拟操作（并不真正写入块设备）。\n- `-o` ：仅输出指定的字段。\n- `-q` ：不显示所有多余的信息。\n- `-X` ：指定分区表的类型。如果未明确指定此选项，那么表示使用块设备上的现有类型。 如果现有块设备上不存在分区表，那么默认为 dos 类型（MBR）。\n- `-h`, `--help` ：显示帮助信息。\n- `-v`, `--version` ：显示版本信息。\n\n## 示例\n\nsfdisk 读取以下形式的行，每行填充一个分区描述符。当字段不存在或为空时，将使用默认值。\n\n```bash\n<start> <size> <id> <bootable> <c,h,s> <c,h,s>\n```\n\n\n\n例如，文件 emmc_partition_table.txt 记录 eMMC 分区信息：\n\n```bash\n# partition table of /dev/mmcblk0\nunit: sectors\n\n/dev/mmcblk0p1 : start=    20480, size=  2097152, Id= c, bootable\n/dev/mmcblk0p2 : start=  2117632, size= 46137344, Id=83\n/dev/mmcblk0p3 : start= 48254976, size= 10485760, Id=83\n/dev/mmcblk0p4 : start= 58740736, size=122142719, Id= 5  # extended partition\n/dev/mmcblk0p5 : start= 58741736, size= 41943040, Id=83\n/dev/mmcblk0p6 : start=100684776, size= 20971520, Id=83\n```\n\n\n\n使用该分区表对块设备 /dev/mmcblk0 进行分区\n\n```bash\nsfdisk /dev/mmcblk0 < emmc_partition_table.txt\n```\n\n\n\n查看指定硬盘分区的信息\n\n```bash\nsfdisk -l /dev/mmcblk0\n```\n\n\n\n输出内容如下：\n\n```bash\nDisk /dev/mmcblk0: 58.25 GiB, 62537072640 bytes, 122142720 sectors\nUnits: sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisklabel type: dos\nDisk identifier: 0x1bbe4bb6\n\nDevice         Boot     Start       End  Sectors  Size Id Type\n/dev/mmcblk0p1 *        20480   2117631  2097152    1G  c W95 FAT32 (LBA)\n/dev/mmcblk0p2        2117632  48254975 46137344   22G 83 Linux\n/dev/mmcblk0p3       48254976  58740735 10485760    5G 83 Linux\n/dev/mmcblk0p4       58740736 122142719 63401984 30.2G  5 Extended\n/dev/mmcblk0p5       58741736 100684775 41943040   20G 83 Linux\n/dev/mmcblk0p6      100684776 121656295 20971520   10G 83 Linux\n```\n\n\n\n查看指定硬盘分区的设置\n\n```bash\nsfdisk -d /dev/mmcblk0\n```\n\n\n\n输出内容如下：\n\n```bash\nlabel: dos\nlabel-id: 0x1bbe4bb6\ndevice: /dev/mmcblk0\nunit: sectors\n\n/dev/mmcblk0p1 : start=       20480, size=     2097152, type=c, bootable\n/dev/mmcblk0p2 : start=     2117632, size=    46137344, type=83\n/dev/mmcblk0p3 : start=    48254976, size=    10485760, type=83\n/dev/mmcblk0p4 : start=    58740736, size=    63401984, type=5\n/dev/mmcblk0p5 : start=    58741736, size=    41943040, type=83\n/dev/mmcblk0p6 : start=   100684776, size=    20971520, type=83\n```\n\n\n\n删除 /dev/mmcblk0 块设备上的所有分区\n\n```bash\nsfdisk --delete /dev/mmcblk0\n```\n\n\n\n\n\n# Linux parted 命令 - 管理磁盘分区\n\n## 介绍\n\n**parted** 是 GNU 组织开发的一个磁盘/硬盘分区操作的程序。它支持多种分区表格式，包括 MS-DOS 和 GPT。可用于为新操作系统创建空间、重新组织磁盘使用（例如调整分区大小）以及将数据复制到新硬盘等操作。\n\n与 [fdisk](https://getiot.tech/linux-command/fdisk/) 命令不同，parted 支持调整分区的大小，作为一种设计用于 GNU/Linux 的工具，它没有构建成处理与 fdisk 关联的多种分区类型。但是，parted 可以处理最常见的分区格式，包括：ext2、ext3、fat16、fat32、NTFS、ReiserFS、JFS、XFS、UFS、HFS 以及 Linux 交换分区。\n\n**语法**：\n\n```bash\nparted [options] [device [command [options...]...]]\n```\n\n\n\n**选项**：\n\n- `-l`, `--list`：列出所有块设备的分区配置。\n- `-m`, `--machine`：显示机器可解析的输出。\n- `-s`, `--script`：从不提示用户。\n- `-a`, `--align=[none|cyl|min|opt]`：新分区的对齐。\n- `-h`, `--help`：打印帮助信息。\n- `-v`, `--version`：显示版本信息。\n\n**命令**：\n\n- `align-check <type> <partition>`：检查分区是否满足类型的对齐约束。类型 type 必须是\"minimal\"（最小）或 \"optimal\"（最佳）之一。\n- `mklabel <label-type>`：创建新的磁盘卷标（分区表）。\n- `mkpart [part-type name fs-type] start end`：在起始点和结束点之间创建一个分区。\n- `name <partition> <name>`：将指定“分区编号”的分区命名为“名称”。\n- `print [devices|free|list,all|数字]`：显示分区表、可用设备、剩余空间、所有分区或特殊分区。\n- `quit`：退出程序。\n- `rescue <start> <end>`：挽救临近“起始点”、“终止点”的遗失的分区。\n- `resizepart <partition> <end>`：改变分区的大小。\n- `rm <NUMBER>`：删除编号为 `NUMBER` 的分区。\n- `select <device>`：选择要编辑的设备。\n- `set <partition> <flag> <state>`：改变指定“编号”分区的标志。\n- `toggle <partition> <flag>`：切换“编号”分区上的“标志”状态。\n- `unit <unit>`：设置缺省的“单位”。\n\n## 示例\n\n直接输入 `parted` 命令，默认选择系统中可用的第一个硬盘驱动器（如 /dev/sda），执行该命令需要 root 权限。\n\n```bash\n$ sudo parted \nGNU Parted 3.3\n使用 /dev/sda\n欢迎使用 GNU Parted！输入 'help' 来查看命令列表。\n(parted) \n```\n\n\n\n查看指定硬盘中所有可用的分区，显示硬盘属性，如型号、大小、扇区大小和分区表。\n\n```bash\n$ sudo parted /dev/sda print\n型号：ATA RD-S325MMN-M01T4 (scsi)\n磁盘 /dev/sda: 1014GB\n扇区大小 (逻辑/物理)：512B/512B\n分区表：msdos\n磁盘标志：\n\n编号  起始点  结束点  大小    类型     文件系统  标志\n 1    1049kB  1014GB  1014GB  primary  ext4\n```\n\n\n\n\n\n# Linux fsck 命令 - 检查和修复文件系统\n\n## 介绍\n\n**fsck**（英文全拼：file system check）命令用于检查与修复 Linux 文件系统，并且可以同时检查一个或多个 Linux 文件系统。\n\n**语法**：\n\n```bash\nfsck [-sACVRP] [-t fstype] [--] [fsck-options] filesys [...]\n```\n\n\n\n**选项**：\n\n- `-a`：自动修复文件系统，不询问任何问题。\n- `-A`：依照 /etc/fstab 配置文件的内容，检查文件内所列的全部文件系统。\n- `-N`：不执行指令，仅列出实际执行会进行的动作。\n- `-P`：当搭配 \"`-A`\" 参数使用时，则会同时检查所有的文件系统。\n- `-r`：采用互动模式，在执行修复时询问问题，让用户得以确认并决定处理方式。\n- `-R`：当搭配\"-A\"参数使用时，则会略过/目录的文件系统不予检查。\n- `-s`：依序执行检查作业，而非同时执行。\n- `-t <文件系统类型>`：指定要检查的文件系统类型。\n- `-T`：执行 fsck 指令时，不显示标题信息。\n- `-V`：显示指令执行过程。\n\n**参数**：指定文件系统 filesys，可以是设备名或挂载点。\n\n## 示例\n\n检查 msdos 文件系统的 /dev/hda5 是否正常，如果有异常便自动修复 :\n\n```bash\n$ sudo fsck -t msdos -a /dev/hda5\n```\n\n\n\nLinux 的文件系统损坏会导致系统不正常关机，出错的时候如果系统提示是哪一块硬盘的分区有问题，比如是 /dev/hda2，接着就可以用如下的命令去对付它：\n\n```bash\n$ sudo fsck -y /dev/hda2\n```\n\n\n\n结束后使用 reboot 命令重启系统这样就好了！\n\n如果不知道时哪个地方出了问题，可以直接：\n\n```bash\n$ sudo fsck\n```\n\n\n\n在随后的多个确认对话框中输入 `:y`\n\n结束后同样使用 reboot 命令重启系统这样就好了！\n\n\n\n# Linux sync 命令 - 同步文件系统缓存\n\n## 介绍\n\n**sync**（英文全拼：synchronize）命令用于数据同步，强制将内存缓冲区中的数据立即写入磁盘。\n\n在 Linux/Unix 系统中，在文件或数据处理过程中一般先放到内存缓冲区（filesystem buffer）中，等到适当的时候再写入磁盘，以提高系统的运行效率。\n\n用户通常不需执行 sync 命令，系统会自动周期性执行 update 或 bdflush 操作，将缓冲区的数据写入磁盘。只有在 update 或 bdflush 无法执行或用户需要非正常关机时，才需手动执行 sync 命令。在关闭 Linux 系统时也会自动执行 sync 命令。\n\n**语法**：\n\n```bash\nsync [OPTION] [FILE]...\n```\n\n\n\n**选项**：\n\n- `-d, --data`：仅同步文件数据，不同步不需要的元数据（metadata）。\n- `-f, --file-system`：同步包含文件的文件系统。\n- `--help`：显示帮助信息。\n- `--version`：显示版本信息。\n\n## 示例\n\n手动的输入 sync 命令来真正地去写磁盘\n\n```bash\nsync\n```\n\n\n\n\n\n# Linux rsync 命令 - 远程数据同步工具\n\n## 介绍\n\n**rsync**（英文全拼：remote synchronize）是 Linux 系统中的一个远程数据同步工具，可通过 LAN/WAN 快速同步多台主机间的文件。需要注意的是，rsync 可以在本地主机和远程主机之间，或者在两个本地目录之间同步文件，但不支持两台远程主机之间的同步。\n\nrsync 使用所谓的“rsync算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。\n\n**语法**：\n\n```bash\nrsync [OPTION]... SRC [SRC]... DEST\nrsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST\nrsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST\nrsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST\nrsync [OPTION]... [USER@]HOST:SRC [DEST]\nrsync [OPTION]... [USER@]HOST::SRC [DEST]\nrsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]\n```\n\n\n\n**选项**：\n\n- `-v`, `--verbose`：详细模式输出。\n- `-q`, `--quiet`：精简输出模式。\n- `-c`, `--checksum`：打开校验开关，强制对文件传输进行校验。\n- `-a`, `--archive`：归档模式，表示以递归方式传输文件，并保持所有文件属性。\n- `-r`, `--recursive`：对子目录以递归模式处理。\n- `-R`, `--relative`：使用相对路径信息。\n- `-b`, `--backup`：创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为 ~filename。可以使用 `--suffix` 选项来指定不同的备份文件前缀。\n- `--backup-dir`：将备份文件（如 ~filename）存放在在目录下。\n- `-suffix=SUFFIX`：定义备份文件前缀。\n- `-u`, `--update`：仅仅进行更新，也就是跳过所有已经存在于 DST，并且文件时间晚于要备份的文件，不覆盖更新的文件。\n- `-l`, `--links`：保留软链结。\n- `-L`, `--copy-links`：想对待常规文件一样处理软链结。\n- `--copy-unsafe-links`：仅仅拷贝指向 SRC 路径目录树以外的链结。\n- `--safe-links`：忽略指向 SRC 路径目录树以外的链结。\n- `-H`, `--hard-links`：保留硬链结。\n- `-p`, `--perms`：保持文件权限。\n- `-o`, `--owner`：保持文件属主信息。\n- `-g`, `--group`：保持文件属组信息。\n- `-D`, `--devices`：保持设备文件信息。\n- `-t`, `--times`：保持文件时间信息。\n- `-S`, `--sparse`：对稀疏文件进行特殊处理以节省 DST 的空间。\n- `-n`, `--dry-run`：现实哪些文件将被传输。\n- `-w`, `--whole-file`：拷贝文件，不进行增量检测。\n- `-x`, `--one-file-system`：不要跨越文件系统边界。\n- `-B`, `--block-size=SIZE`：检验算法使用的块尺寸，默认是 700 字节。\n- `-e`, `--rsh=command`：指定使用rsh、ssh方式进行数据同步。\n- `--rsync-path=PATH`：指定远程服务器上的rsync命令所在路径信息。\n- `-C`, `--cvs-exclude`：使用和 CVS 一样的方法自动忽略文件，用来排除那些不希望传输的文件。\n- `--existing`：仅仅更新那些已经存在于 DST 的文件，而不备份那些新创建的文件。\n- `--delete`：删除那些 DST 中 SRC 没有的文件。\n- `--delete-excluded`：同样删除接收端那些被该选项指定排除的文件。\n- `--delete-after`：传输结束以后再删除。\n- `--ignore-errors`：及时出现 IO 错误也进行删除。\n- `--max-delete=NUM`：最多删除 NUM 个文件。\n- `--partial`：保留那些因故没有完全传输的文件，以是加快随后的再次传输。\n- `--force`：强制删除目录，即使不为空。\n- `--numeric-ids`：不将数字的用户和组 ID 匹配为用户名和组名。\n- `--timeout=time`：IP 超时时间，单位为秒。\n- `-I`, `--ignore-times`：不跳过那些有同样的时间和长度的文件。\n- `--size-only`：当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。\n- `--modify-window=NUM`：决定文件是否时间相同时使用的时间戳窗口，默认为 0。\n- -T --temp-dir=DIR：在 DIR 中创建临时文件。\n- `--compare-dest=DIR`：同样比较 DIR 中的文件来决定是否需要备份。\n- `-P`：等同于 `--partial`。\n- `--progress`：显示备份过程。\n- `-z`, `--compress`：对备份的文件在传输时进行压缩处理。\n- `--exclude=PATTERN`：指定排除不需要传输的文件模式。\n- `--include=PATTERN`：指定不排除而需要传输的文件模式。\n- `--exclude-from=FILE`：排除 FILE 中指定模式的文件。\n- `--include-from=FILE`：不排除 FILE 指定模式匹配的文件。\n- `--version`：打印版本信息。\n- `--address`：绑定到特定的地址。\n- `--config=FILE`：指定其他的配置文件，不使用默认的 rsyncd.conf 文件。\n- `--port=PORT`：指定其他的 rsync 服务端口。\n- `--blocking-io`：对远程 shell 使用阻塞 I/O。\n- `--stats`：给出某些文件的传输状态。\n- `--progress`：在传输时显示传输过程。\n- `--log-format=formAT`：指定日志文件格式。\n- `--password-file=FILE`：从 FILE 中得到密码。\n- `--bwlimit=KBPS`：限制 I/O 带宽，单位为 KBytes per second。\n- `-h`, `--help`：显示帮助信息。\n\n## 示例\n\n关联两个本地的目录，保持文件同步：\n\n```bash\nrsync -r /Dir1 /Dir2\n```\n\n\n\n列出本地指定目录内的文件列表：\n\n```bash\nrsync /Dir1\n```\n\n\n\n将本地目录（/web_root）与远程目录（192.168.1.10:/web_root）相关联，保持文件同步：\n\n```bash\nrsync -r /web_root 192.168.1.10:/web_root\n```\n\n\n\n将远程目录（192.168.1.10:/web_root）与本地目录（/web_root）相关联，保持文件同步：\n\n```bash\nrsync -r 192.168.1.10:/web_root /web_root\n```\n\n\n\n\n\n# Linux mkfs 命令 - 创建文件系统\n\n## 介绍\n\n**mkfs**（英文全拼：make file system）命令用于在特定的分区上建立 Linux 文件系统。\n\nmkfs 本身并不执行建立文件系统的工作，而是去调用相关的程序来执行。\n\n**语法**：\n\n```bash\nmkfs [options] [-t type] [fs-options] device [size]\n```\n\n\n\n**选项**：\n\n- `-t <文件系统类型>`：指定要建立何种文件系统，Linux 的默认值为 ext2。\n- `-c`：在制作文件系统前，检查该分区是否有坏轨。\n- `-l bad_blocks_file`：将有坏轨的 block 资料加到 bad_blocks_file 里面。\n- `-V`：详细显示模式（如果不带参数则显示版本信息）。\n\n**参数**：\n\n- `device`：指定要创建的文件系统对应的设备文件名。\n- `size`：指定文件系统的磁盘块数。\n\n## 示例\n\n在 `/dev/hda5` 上建一个 msdos 的文件系统，同时检查是否有坏轨存在，并且将过程详细列出来：\n\n```bash\n$ sudo mkfs -V -t msdos -c /dev/hda5\n```\n\n\n\n将 sdb1 分区格式化为 ext3 格式：\n\n```bash\n$ sudo mfks -t ext3 /dev/sdb1\n```\n\n\n\n将 sdb1 分区格式化为 ext3 格式，并检查坏轨，且详细显示：\n\n```bash\n$ sudo mfks -V -t ext3 -c /dev/sdb1\n```\n\n\n\n**注意**：这里的文件系统是要指定的，比如 ext2、ext3、ext4、reiserfs、fat32、msdos 等。如果不想指定文件系统，可使用 mkfs.ext2、mkfs.ext3、mkfs.fat 等命令。\n\n\n\n# Linux dd 命令 - 数据复制和转换\n\n## 介绍\n\n**dd**（英文全拼：disk dump）命令用于读取、转换并输出数据。可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。\n\ndd 命令功能很强大的，对于一些比较底层的问题，使用 dd 命令往往可以得到出人意料的效果。用的比较多的还是用 dd 来备份裸设备。\n\n提示\n\n裸设备（raw device，也称裸分区或原始分区）是一种没有经过格式化，不被 Linux 系统通过文件系统来读取的特殊块设备文件。裸设备不被操作系统直接管理，不经过文件系统的缓冲，直接由应用程序对它进行读写操作。因此 I/O 效率更高，不少数据库都能通过使用裸设备作为存储介质来提高 I/O 效率。\n\n**语法**：\n\n```bash\ndd [选项]\n```\n\n\n\n**选项**：\n\n- `if=<文件>`：输入文件名，即指定源文件。\n\n- `of=<文件>`：输出文件名，即指定目的文件。\n\n- `bs=<字节数>`：将 ibs（输入）与 obs（输出）设成指定的字节数。（bs 是 block size 的缩写）\n\n- `ibs=<字节数>`：每次读取的字节数，即指定一个块的大小。\n\n- `obs=<字节数>`：每次输出的字节数，即指定一个块的大小。\n\n- `cbs=<字节数>`：转换时，每次只转换指定的字节数（即指定转换缓冲区大小）。\n\n- `count=<区块数>`：仅读取指定的区块数，块大小等于 (i/o)bs 指定的字节数。\n\n- `skip=<区块数>`：一开始从输入文件读取时，跳过指定的区块数。\n\n- `seek=<区块数>`：一开始写入到输出文件时，跳过指定的区块数。\n\n- ```\n  conv=<关键字>\n  ```\n\n  ：指定文件转换的方式；关键字可以是：\n\n  - conversion：用指定的参数转换文件\n  - ascii：转换 ebcdic 为 ascii\n  - ebcdic：转换 ascii 为 ebcdic\n  - ibm：转换 ascii 为 alternate ebcdic\n  - block：把每一行转换为长度为 cbs，不足部分用空格填充\n  - unblock：使每一行的长度都为 cbs，不足部分用空格填充\n  - lcase：把大写字符转换为小写字符\n  - ucase：把小写字符转换为大写字符\n  - swap：交换输入的每对字节\n  - noerror：出错时不停止\n  - notrunc：不截短输出文件\n  - sync：将每个输入块填充到 ibs 个字节，不足部分用空（NUL）字符补齐\n  - fdatasync：在完成之前实际写入数据到输出文件\n  - fsync：类似于 fdatasync，但同时会写入 metadata 元数据\n\n- `--help`：显示帮助信息。\n\n- `--version`：显示版本信息。\n\n另外，块大小可以使用的计量单位如下表所示。\n\n| 单元大小         | 代码 |\n| ---------------- | ---- |\n| 字节（1B）       | c    |\n| 字节（2B）       | w    |\n| 块（512B）       | b    |\n| 千字节（1024B）  | k    |\n| 兆字节（1024KB） | M    |\n| 吉字节（1024MB） | G    |\n\n## 示例\n\n将 openwrt.img 写入 TF 卡（/dev/sdx）：\n\n```bash\ndd if=/tmp/upload/openwrt.img of=/dev/sdx\n```\n\n\n\n将 flash.bin 写入 TF 卡，并偏移 33 个区块：\n\n```bash\ndd if=flash.bin of=/dev/sdx bs=1k seek=33 conv=fsync\n```\n\n\n\n创建一个 1M 大小的文件：\n\n```bash\n$ dd if=/dev/zero of=output.txt bs=1M count=1\n1+0 records in\n1+0 records out\n1048576 bytes (1.0 MB) copied, 0.006107 seconds, 172 MB/s\n```\n\n\n\n该命令创建了一个 1M 大小的文件 output.txt。\n\n```bash\n$ du -sh output.txt \n1.1M    output.txt\n```\n\n\n\n说明：**/dev/zero** 是一个字符设备，会不断返回 0 值字节（`\\0`）。上述命令可用来测试内存操作速度。\n\n将 testfile 文件中的所有英文字母转换为大写，然后转成为 testfile_1 文件：\n\n```bash\ndd if=testfile of=testfile_1 conv=ucase \n```\n\n\n\n由标准输入设备读入字符串，并将字符串转换成大写后，再输出到标准输出设备：\n\n```bash\ndd conv=ucase \n```\n\n\n\n输入以上命令后按回车键，输入字符串，再按回车键，按组合键 Ctrl+D 退出，出现以下结果：\n\n```bash\n$ dd conv=ucase\nhello, getiot.tech  # 输入字符串后按回车键\nHELLO, GETIOT.TECH  # 按组合键Ctrl+D退出，转换成大写结果\n记录了0+1 的读入\n记录了0+1 的写出\n19字节已复制，9.27639 s，0.0 kB/s\n```\n\n\n\n### 读写测试\n\n在 Linux 系统中，我们经常用 dd 命令使用 /dev/zero 和 /dev/null 设备来测试硬盘读写速度，配合 [time](https://getiot.tech/linux-command/time/) 命令可以计算 dd 命令执行过程的资源使用情况（比如 cpu 时间）。\n\n**测试硬盘写能力**\n\n```bash\ntime dd if=/dev/zero of=/testw.dbf bs=4k count=100000\n```\n\n\n\n因为 /dev/zero 是一个伪设备，它只产生空字符流，对它不会产生 IO，所以，IO 都会集中在 of 文件中，of 文件只用于写，所以这个命令相当于测试磁盘的写能力。命令结尾添加 `oflag=direct` 将跳过内存缓存，添加 `oflag=sync` 将跳过 hdd 缓存。\n\n**测试硬盘读能力**\n\n```bash\ntime dd if=/dev/sdb of=/dev/null bs=4k\n```\n\n\n\n因为 /dev/sdb 是一个物理分区，对它的读取会产生 IO，/dev/null 是伪设备，相当于黑洞，of 到该设备不会产生 IO，所以，这个命令的 IO 只发生在 /dev/sdb 上，也相当于测试磁盘的读能力。（Ctrl+C 终止测试）\n\n**测试同时读写能力**\n\n```bash\ntime dd if=/dev/sdb of=/testrw.dbf bs=4k\n```\n\n\n\n**测试纯写入性能**\n\n```bash\ndd if=/dev/zero of=test bs=8k count=10000 oflag=direct\n```\n\n\n\n**测试纯读取性能**\n\n```bash\ndd if=test of=/dev/null bs=8k count=10000 iflag=direct\n```\n\n\n\n注意：dd 只能提供一个大概的测试结果，而且是连续 I/O 而不是随机 I/O，理论上文件规模越大，测试结果越准确。 同时，iflag/oflag 提供 direct 模式，direct 模式是把写入请求直接封装成 I/O 指令发到磁盘，非 direct 模式只是把数据写入到系统缓存就认为 I/O 成功，并由操作系统决定缓存中的数据什么时候被写入磁盘。\n\n\n\n# Linux swapon 命令 - 启用交换空间\n\n## 介绍\n\n**swapon** 命令用于检查或启用 Linux 系统中用于分页和交换的设备和文件。\n\n相关命令：[swapoff](https://getiot.tech/linux-command/swapoff/)\n\n**语法**：\n\n```bash\nswapon [options] [specialfile...]\n```\n\n\n\n**选项**：\n\n- `-a`, `--all` ：使能所有在 /etc/fstab 中被标记为 \"swap\" 的块设备，带 \"noauto\" 选项的除外，已被用作 swap 的设备也将会默默跳过。\n\n- `-d`, `--discard[=policy]` ：如果 swap 设备支持丢弃或修剪操作，则启用交换丢弃。这可能会提高某些固态设备的性能，但通常不会。该选项允许在两种可用的交换丢弃策略之间进行选择：\n\n  - `--discard=once` 对整个交换区域执行一次丢弃操作；\n  - `--discard=pages` 在它们可用于重用之前异步丢弃已释放的交换页面。\n\n  如果未选择任何策略，则默认行为是启用两种丢弃类型。 /etc/fstab 挂载选项discard、discard=once 或discard=pages 也可用于启用丢弃标志。\n\n- `-e`, `--ifexists` ：默默跳过不存在的设备，/etc/fstab 挂载选项 \"nofail\" 也可用于跳过不存在的设备。\n\n- `-f`, `--fixpgsz` ：如果交换空间的页面大小与当前运行内核的页面大小不匹配，则重新初始化（执行 mkswap）交换空间，mkswap 会初始化整个设备并且不检查坏块。\n\n- `-h`, `--help` ：显示帮助信息并退出。\n\n- `-L label` ：使用具有指定标签的分区（可以访问 /proc/partitions 获知）。\n\n- `-o`, `--options opts` ：通过 fstab 兼容的逗号分隔字符串指定交换选项。\n\n- `-p`, `--priority priority` ：指定 swap 设备的优先级。优先级是一个介于 -1 和 32767 之间的值，数字越大表示优先级越高，可以将 `pri=value` 添加到 /etc/fstab 的选项字段以与 `swapon -a` 一起使用，如果未定义优先级，则默认为 -1。\n\n- `-s`, `--summary` ：按设备显示 swap 使用情况摘要，相当于 \"cat /proc/swaps\"。此输出格式已被弃用，使用 `--show` 能得到更好地控制输出数据。\n\n- `--show[=column...]` ：显示可定义的交换区域表。\n\n- `--output-all` ：输出所有可用的列。\n\n- `--noheadings` ：显示 `--show` 输出时不要打印标题。\n\n- `--raw` ：显示 `--show` 输出时忽略表格对齐。\n\n- `--bytes` ：显示 `--show` 输出时以字节为单位，而不是用户友好的单位。\n\n- `-U uuid` ：使用 uuid 指定磁盘分区。\n\n- `-v`, `--verbose` ：详细模式。\n\n- `-V`, `--version` ：显示版本信息并退出。\n\n**参数**：指定的 swap 设备（分区、逻辑卷或文件）。\n\n## 示例\n\n读取 swap 区域的摘要信息（以千字节为单位）\n\n```bash\n$ swapon -s\nFilename          Type           Size          Used        Priority\n/dev/sdb5         partition      16438268      100352      -2\n```\n\n\n\n禁用 /dev/sdb5 交换区域\n\n```bash\n$ sudo swapoff /dev/sdb5\n```\n\n\n\n再启用 /dev/sdb5 交换区域\n\n```bash\n$ sudo swapon /dev/sdb5\n```\n\n\n\n启用交换区域时可附加选项\n\n```bash\n$ swapon -o pri=1,discard=pages,nofail /dev/sdb5\n```\n\n\n\n\n\n# Linux swapoff 命令 - 禁用交换空间\n\n## 介绍\n\n**swapoff** 命令用于关闭 Linux 系统中用于分页和交换的设备和文件。\n\n相关命令：[swapon](https://getiot.tech/linux-command/swapon/)\n\n**语法**：\n\n```bash\nswapoff [-va] [specialfile...]\n```\n\n\n\n**选项**：\n\n- `-a`, `--all` ：禁用所有在 /etc/fstab 中被标记为 \"swap\" 的块设备。\n- `-v`, `--verbose` ：详细模式。\n- `-h`, `--help` ：显示帮助信息并退出。\n- `-V`, `--version` ：显示版本信息并退出。\n\n**参数**：指定的 swap 设备（分区、逻辑卷或文件）。\n\n## 示例\n\n查看当前 Linux 系统内存和 swap 区域情况\n\n```bash\n$ free -h\n            总计         已用        空闲      共享    缓冲/缓存    可用\n内存：     7.5Gi       2.8Gi       199Mi     282Mi   4.5Gi     4.1Gi\n交换：      15Gi        98Mi        15Gi\n```\n\n\n\n查找 swap 对应的块设备\n\n```bash\n$ sudo fdisk -l | grep swap\n/dev/sdb5       400003072  432879615   32876544  15.7G 82 Linux swap / Solaris\n```\n\n\n\n关闭该交换区域\n\n```bash\n$ sudo swapoff /dev/sdb5\n```\n\n\n\n再次查看 swap 区域情况\n\n```bash\n$ free -h\n            总计         已用        空闲      共享    缓冲/缓存    可用\n内存：     7.5Gi       2.8Gi       145Mi     335Mi   4.5Gi     4.1Gi\n交换：        0B          0B          0B\n```\n\n\n\n\n\n# Linux chronyd 命令 - Chrony 服务守护进程\n\n## 介绍\n\n**chronyd**（英文全拼：chrony daemon）是 Chrony 时间同步服务的守护进程。Chrony 是网络时间协议（NTP）的一种实现，也是一个类 Unix 系统上 ntpd 服务的替代品，包括 chronyc 客户端和 chronyd 服务端两部分。\n\nchronyd 可以将时钟与 NTP 服务器、参考时钟（例如 GPS 接收器）同步，并通过 chronyc 使用手表和键盘进行手动输入。它还可以作为 NTPv4（RFC 5905）服务器和对等方运行，为网络中的其他计算机提供时间服务。\n\n提示\n\n如果在命令行上没有指定配置指令，chronyd 将从配置文件中读取它们，默认位置是 /etc/chrony/chrony.conf。另外，chronyd 运行的消息和警告将记录到 syslog 系统日志中。\n\n**语法**：\n\n```bash\nchronyd [-4|-6] [-n|-d] [-q|-Q] [-r] [-R] [-s] [-t TIMEOUT] [-f FILE|COMMAND...]\n```\n\n\n\n**选项**：\n\n- `-4`：使用此选项，主机名将仅解析为 IPv4 地址，并且仅创建 IPv4 套接字。\n- `-6`：使用此选项，主机名将仅解析为 IPv6 地址，并且仅创建 IPv6 套接字。\n- `-f file`：此选项可用于指定配置文件的备用位置（默认为 /etc/chrony/chrony.conf）。\n- `-n`：当在此模式下运行时，程序不会将自身与终端分离。\n- `-d`：在此模式下运行时，程序不会将自身与终端分离，并且所有消息都将写入终端而不是系统日志。当 chronyd 编译时带有调试支持时，可以使用此选项两次来打印调试消息。\n- `-l file`：此选项指定一个应该用于记录而不是系统日志或终端的文件。\n- `-q`：当在此模式下运行时，chronyd 将设置一次系统时钟并退出。该模式下，它不会与终端分离。\n- `-Q`：此选项与 `-q` 选项类似，不同之处在于它仅打印偏移量而不对时钟进行任何更正，并且它允许 chronyd 在没有 root 权限的情况下启动。\n- `-r`：此选项将尝试重新加载，然后删除包含每个服务器和正在使用的参考时钟的示例历史记录的文件。这些文件应位于配置文件中 dumpdir 指令指定的目录中。如果你出于任何原因想要暂时停止并重新启动 chronyd，则此选项非常有用，例如安装新版本。但是，它只能用于内核可以维持时钟补偿但不受 chronyd 控制的系统（即 Linux、FreeBSD、NetBSD、Solaris 和 macOS 10.13 或更高版本）。\n- `-R`：使用此选项时，将忽略 initstepslew 指令和使用正限制的 makestep 指令。该选项在重新启动 chronyd 时很有用，并且可以与 `-r` 选项结合使用。\n- `-s`：此选项将从计算机的实时时钟（RTC）设置系统时钟或由 driftfile 指令指定的文件的最后修改时间。仅 Linux 支持实时时钟。如果与 `-r` 标志结合使用，chronyd 将在从 RTC 设置系统时钟后尝试保留旧样本。这可用于允许 chronyd 对系统重新启动期间的增益或丢失率执行长期平均，并且对于间歇性访问网络且在不使用时关闭的系统非常有用。为了使其正常工作，它依赖于 chronyd 能够确定计算机上次打开时 RTC 和系统时钟之间差异的准确统计数据。如果漂移文件的最后修改时间晚于当前时间和 RTC 时间，系统时间将被设置为它以恢复 chronyd 先前停止时的时间。这对于没有 RTC 或 RTC 损坏（例如没有电池）的计算机很有用。\n- `-t timeout`：此选项设置超时（以秒为单位），超过此时间 chronyd 将退出。如果时钟不同步，它将以非零状态退出。这对于缩短等待测量的最大时间的 `-q` 或 `-Q` 选项很有用，或者与 `-r` 选项一起限制 chronyd 运行的时间，但仍然允许它调整系统时钟的频率。\n- `-u user`：此选项设置 chronyd 在启动后将切换到的系统用户的名称，以放弃 root 权限。它覆盖用户指令（默认_chrony）。在 Linux 上，chronyd 需要在编译时支持 libcap 库。在 macOS 上，FreeBSD、NetBSD 和 Solaris chronyd 分叉为两个进程。子进程保留 root 权限，但只能代表父进程执行非常有限范围的特权系统调用。\n- `-F level`：当 chronyd 编译为支持 Linux 安全计算（seccomp）工具时，此选项配置系统调用过滤器。在级别 1 中，当进行禁止的系统调用时，进程将被终止；在级别 -1 中，将抛出 `SIGSYS` 信号；在级别 0 中，过滤器被禁用（默认为 0）。建议仅当已知过滤器适用于安装 chrony 的系统版本时才启用过滤器，因为过滤器还需要允许从 chronyd 正在使用的库（例如 libc）以及库的不同版本或实现进行的系统调用 可能会进行不同的系统调用。如果过滤器缺少某些系统调用，即使在正常操作下，chronyd 也可能被终止。\n- `-P priority`：在 Linux 上，此选项将以指定的优先级（必须在 0 到 100 之间）选择 `SCHED_FIFO` 实时调度程序。在 macOS 上，此选项的值必须为 0（默认值）以禁用线程时间限制策略，或为 1 以启用该策略。其他系统不支持此选项。\n- `-m`：此选项会将 chronyd 锁定到 RAM 中，这样它就永远不会被调出。注意，此模式仅在 Linux 上受支持。\n- `-x`：该选项禁用系统时钟的控制。chronyd 不会尝试对时钟进行任何调整。它将假设时钟自由运行，并且仍然跟踪其相对于估计真实时间的偏移和频率。此选项允许 chronyd 在无法调整或设置系统时钟（例如在某些容器中）的情况下运行，以便作为 NTP 服务器运行。当另一个进程控制系统时钟时，不建议运行 chronyd（带或不带 `-x`）。\n- `-v`：打印 chronyd 的版本号并退出。\n\n## 示例\n\n启动 chronyd 守护进程：\n\n```bash\nsudo systemctl start chronyd\n```\n\n\n\n停止 chronyd 守护进程：\n\n```bash\nsudo systemctl stop chronyd\n```\n\n\n\n重新加载 chronyd 的配置文件：\n\n```bash\nsudo systemctl reload chronyd\n```\n\n\n\n\n\n# Linux chronyc 命令 - Chrony 服务交互工具\n\n## 介绍\n\n**chronyc**（英文全称：chrony command-line）命令用于设置时间与时钟服务器的同步工作。Chrony 是 Linux 系统中一个用于保持系统时间与 NTP 时钟服务器或 GPS 同步的服务，chronyc 则是 chronyd 服务的配置工具。\n\n**语法**：\n\n```bash\nchronyc [-h HOST] [-p PORT] [-n] [-c] [-d] [-4|-6] [-m] [COMMAND]\n```\n\n\n\n**选项**：\n\n- `-4`：使用此选项，主机名将仅解析为 IPv4 地址。\n- `-6`：使用此选项，主机名将仅解析为 IPv6 地址。\n- `-n`：此选项禁用将 IP 地址解析为主机名，以避免缓慢的 DNS 查找。\n- `-c`：此选项允许以逗号分隔值（CSV）格式打印报告。IP 地址不会解析为主机名，时间将打印为自纪元以来的秒数，并且以秒为单位的值不会转换为其他单位。\n- `-d`：如果 chronyc 编译时带有调试支持，则此选项启用调试消息的打印。\n- `-m`：通常，命令行上的所有参数都被解释为一个命令。使用此选项可以指定多个命令，每个参数都将被解释为一个完整的命令。\n- `-h <host>`：此选项允许用户指定要联系运行 chronyd 程序的主机（或逗号分隔的地址列表）。这允许远程监控，而无需先通过 SSH 连接到另一台主机。默认是联系在运行 chronyc 的同一主机上运行的 chronyd。\n- `-p <port>`：此选项允许用户指定目标 chronyd 用于其监控连接的 UDP 端口号。默认为 323；通常不需要改变。\n- `-f <file>`：此选项将被忽略，仅用于兼容性目的。\n- `-a`：此选项将被忽略，仅用于兼容性目的。\n- `-v`：显示其版本号并退出。\n\n**常用命令**：\n\n- `sources`：时间同步源\n- `sourcestats`：时间同步源状态\n- `-v`：详细信息模式\n\n## 示例\n\n查看 chronyd 的状态信息，包括系统时钟的偏移和调整信息：\n\n```bash\n$ chronyc tracking \nReference ID    : CA760151 (time.neu.edu.cn)\nStratum         : 2\nRef time (UTC)  : Wed Apr 19 19:24:17 2023\nSystem time     : 0.003332454 seconds slow of NTP time\nLast offset     : -0.003015077 seconds\nRMS offset      : 0.002894906 seconds\nFrequency       : 18.189 ppm fast\nResidual freq   : -0.488 ppm\nSkew            : 0.811 ppm\nRoot delay      : 0.055464264 seconds\nRoot dispersion : 0.002117821 seconds\nUpdate interval : 1031.6 seconds\nLeap status     : Normal\n```\n\n\n\n显示与 chronyd 同步的 NTP 服务器的详细信息：\n\n```bash\n$ chronyc sources\n210 Number of sources = 8\nMS Name/IP address         Stratum Poll Reach LastRx Last sample               \n===============================================================================\n^- prod-ntp-3.ntp4.ps5.cano>     2  10   177   61m    -14ms[  -20ms] +/-  163ms\n^? prod-ntp-4.ntp1.ps5.cano>     0   6     0     -     +0ns[   +0ns] +/-    0ns\n^? prod-ntp-3.ntp4.ps5.cano>     0   6     0     -     +0ns[   +0ns] +/-    0ns\n^? prod-ntp-5.ntp4.ps5.cano>     0   6     0     -     +0ns[   +0ns] +/-    0ns\n^* time.neu.edu.cn               1  10   377   169  +2287us[ -728us] +/-   28ms\n^+ 119.28.183.184                2  10   377   30m    +56us[-3936us] +/-   60ms\n^? 2001:67c:21bc:1e::123         0   6     0     -     +0ns[   +0ns] +/-    0ns\n^? 2603:c020:0:8369::feeb:d>     0   6     0     -     +0ns[   +0ns] +/-    0ns\n```\n\n\n\n\n\n# Linux free 命令 - 显示内存使用情况\n\n## 介绍\n\n**free** 命令用于显示系统内存的使用情况，包括物理内存、交换内存（swap）和内核缓冲区（buffer）内存。其显示的信息来自 /proc/meminfo 文件。\n\n在 Linux 系统监控的工具中，free 命令是最经常使用的命令之一。\n\n**语法**：\n\n```bash\nfree [options]\n```\n\n\n\n**参数**：\n\n- `-b`, `--bytes` ：以 Bytes 为单位显示内存使用情况。\n- `-k`, `--kibi` ：以 Kibibytes 为单位显示内存使用情况（默认）。\n- `-m`, `--mebi` ：以 Mebibytes 为单位显示内存使用情况。\n- `-g`, `--gibi` ：以 Gibibytes 为单位显示内存使用情况。\n- `--tebi` ：以 Tebibytes 为单位显示内存使用情况。\n- `--pebi` ：以 Pebibytes 为单位显示内存使用情况。\n- `--kilo` ：以 Kilobytes 为单位显示内存使用情况。\n- `--mega` ：以 Megabytes 为单位显示内存使用情况。\n- `--giga` ：以 Gigabytes 为单位显示内存使用情况。\n- `--tera` ：以 Terabytes 为单位显示内存使用情况。\n- `--peta` ：以 Petabytes 为单位显示内存使用情况。\n- `-h`, `--human` ：以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。\n- `-w`, `--wide` ：以 wide 模式显示，每行长度超过 80 个字符，buffers 和 cache 会分开两列显示。\n- `-c`, `--count count` ：显示结果统计次数，需要结合 -s 选项。\n- `-l`, `--lohi` ：显示详细的低和高内存统计信息。\n- `-s`, `--seconds delay` ：以 delay 秒为间隔连续显示。\n- `--si` ：使用 kilo、mega、giga 等（1000 倍）替代 kibi、mebi、gibi（1024 倍）。\n- `-t`, `--total` ：增加一行显示列总计。\n- `--help` ：显示帮助信息。\n- `-V`, `--version` ：显示版本信息。\n\n## 示例\n\n显示系统内存使用情况\n\n```bash\n$ free\n            total        used        free      shared  buff/cache   available\nMem:      7887904     2914244     1405500      352828     3568160     4316020\nSwap:    16438268           0    16438268\n```\n\n\n\n加上 -h 选项，输出的结果会友好很多\n\n```bash\n$ free -h\n            total        used        free      shared  buff/cache   available\nMem:        7.5Gi       2.8Gi       1.3Gi       344Mi       3.4Gi       4.1Gi\nSwap:        15Gi          0B        15Gi\n```\n\n\n\n输出内容解释：\n\n- **Mem** 行是内存的使用情况。\n- **Swap** 行是交换空间的使用情况。\n- **total** 列显示系统总计可用物理内存和交换空间大小。\n- **used** 列显示已用的物理内存和交换空间。\n- **free** 列显示还有多少空闲的物理内存和交换空间可以使用。\n- **shared** 列显示共享内存大小。\n- **buff/cache** 列显示内核缓冲区/页面高速缓存使用的组合内存。\n- **available** 列显示还可以被应用程序使用的物理内存大小。\n\n每隔1秒打印一次内存使用情况\n\n```bash\n$ free -h -s 1\n```\n\n\n\n利用 [watch](https://getiot.tech/linux-command/watch/) 命令也能达到循环输出的效果\n\n```bash\n$ watch -n 1 free -h\n```\n\n\n\n\n\n# Linux pmap 命令 - 显示进程内存映射\n\n## 介绍\n\n**pmap**（英文全拼：process memory map）命令用于查看进程的内存映射。\n\npmap 实际上是一个 Sun OS 上的命令，Linux 仅支持其有限的功能。可以显示一个或多个进程的内存状态，其报告进程的地址空间和内存状态信息。对查看完整的进程地址空间很有帮助。\n\n**语法**：\n\n```shell\npmap [options] pid [...]\n```\n\n\n\n**选项**：\n\n- `-x`, `--extended` ：显示扩展格式。\n- `-d`, `--device` ：显示设备格式。\n- `-q`, `--quiet` ：不显示 header 和 footer 行。\n- `-A`, `--range low,high` ：将给定范围内的结果限制为低地址和高地址范围。请注意，low 和 high 参数是用逗号分隔的单个字符串。\n- `-X` ：显示比 -x 选项更多的详细信息。注意：格式根据 /proc/PID/smaps 更改。\n- `-XX` ：显示内核提供的一切。\n- `-p`, `--show-path` ：在映射列中显示文件的完整路径。\n- `-c`, `--read-rc` ：读取默认配置。\n- `-C`, `--read-rc-from file` ：从文件 file 中读取配置。\n- `-n`, `--create-rc` ：创建新的默认配置。\n- `-N`, `--create-rc-to file` ：创建新的配置，并保存到文件。\n- `-h`, `--help` ：显示帮助信息并退出。\n- `-V`, `--version` ：显示版本信息并退出。\n\n**参数**：进程 PID（可接多个参数）\n\n## 示例\n\n查看单一进程内存状态\n\n```shell\n$ pmap 5969\n5969:   /usr/share/typora/Typora README.md\n0000315900000000     48K rw---   [ anon ]\n000031590000c000    208K -----   [ anon ]\n0000315900040000      4K rw---   [ anon ]\n0000315900041000      4K -----   [ anon ]\n0000315900042000     64K r-x--   [ anon ]\n...\n00007fc4383b8000     28K rw--- libepoxy.so.0.0.0\n00007fc4383bf000     16K r---- libcairo-gobject.so.2.11600.0\n00007fc4383c3000      8K r-x-- libcairo-gobject.so.2.11600.0\n00007fc4383c5000      8K r---- libcairo-gobject.so.2.11600.0\n00007fc4383c7000      4K ----- libcairo-gobject.so.2.11600.0\n00007fc4383c8000      8K r---- libcairo-gobject.so.2.11600.0\n00007fc4383ca000      4K rw--- libcairo-gobject.so.2.11600.0\n00007fc4383cb000     64K r---- libsystemd.so.0.28.0\n00007fc4383db000    468K r-x-- libsystemd.so.0.28.0\n00007fc438450000    148K r---- libsystemd.so.0.28.0\n00007fc438475000     12K r---- libsystemd.so.0.28.0\n00007fc438478000      4K rw--- libsystemd.so.0.28.0\n...\n00007fff3fc90000    132K rw---   [ stack ]\n00007fff3fcc8000     16K r----   [ anon ]\n00007fff3fccc000      8K r-x--   [ anon ]\nffffffffff600000      4K --x--   [ anon ]\n total          4931388K\n```\n\n\n\n查看多进程内存状态\n\n```shell\n$ pmap 5969 5972 5973\n```\n\n\n\n以扩展形式显示进程内存\n\n```shell\n$ pmap -x 5969\n5969:   /usr/share/typora/Typora README.md\nAddress           Kbytes     RSS   Dirty Mode  Mapping\n0000315900000000      48      48      48 rw---   [ anon ]\n000031590000c000     208       0       0 -----   [ anon ]\n0000315900040000       4       4       4 rw---   [ anon ]\n0000315900041000       4       0       0 -----   [ anon ]\n0000315900042000      64      64      64 r-x--   [ anon ]\n...\n00007fc4383b8000      28      28      28 rw--- libepoxy.so.0.0.0\n00007fc4383bf000      16      16       0 r---- libcairo-gobject.so.2.11600.0\n00007fc4383c3000       8       8       0 r-x-- libcairo-gobject.so.2.11600.0\n00007fc4383c5000       8       8       0 r---- libcairo-gobject.so.2.11600.0\n00007fc4383c7000       4       0       0 ----- libcairo-gobject.so.2.11600.0\n00007fc4383c8000       8       8       8 r---- libcairo-gobject.so.2.11600.0\n00007fc4383ca000       4       4       4 rw--- libcairo-gobject.so.2.11600.0\n00007fc4383cb000      64      64       0 r---- libsystemd.so.0.28.0\n00007fc4383db000     468      60       0 r-x-- libsystemd.so.0.28.0\n00007fc438450000     148       0       0 r---- libsystemd.so.0.28.0\n00007fc438475000      12      12      12 r---- libsystemd.so.0.28.0\n00007fc438478000       4       4       4 rw--- libsystemd.so.0.28.0\n...\n00007fff3fc90000     132      88      88 rw---   [ stack ]\n00007fff3fcc8000      16       0       0 r----   [ anon ]\n00007fff3fccc000       8       4       0 r-x--   [ anon ]\nffffffffff600000       4       0       0 --x--   [ anon ]\n---------------- ------- ------- ------- \ntotal kB         4931388  163028   44052\n```\n\n\n\n各字段说明如下：\n\n- Address：内存开始地址；\n- Kbytes：占用内存的字节数（KB）；\n- RSS：保留内存的字节数（KB）；\n- Dirty：脏页的字节数（包括共享和私有的）（KB）；\n- Mode：内存的权限包括 read、write、execute、shared、private（写时复制）；\n- Mapping：占用内存的文件，或 [anon]（分配的内存）、[stack]（堆栈）。\n\n\n\n# Linux vmstat 命令 - 统计虚拟内存情况\n\n## 介绍\n\n**vmstat**（英文全拼：virtual memory statistics）命令用于统计 Linux 系统虚拟内存使用情况，可实时动态监视操作系统的虚拟内存、进程、CPU 活动。\n\n**语法**：\n\n```shell\nvmstat [options] [delay [count]]\n```\n\n\n\n**选项**：\n\n- `delay` ：两次输出之间的延迟时间，如果未指定，则只打印一次报告（包含自启动以来的平均值）\n- `count` ：统计次数（定义 delay 参数时生效），如果未指定，默认为无限次。\n- `-a`, `--active` ：显示处于 active 和 inactive 状态的内存量。\n- `-f`, `--forks` ：显示自启动以来的 forks 数，包括 `fork()`、`vfork()` 和 `clone()` 系统调用，相当于创建的任务总数。每个进程由一个或多个任务表示，具体取决于线程使用情况。该选项不支持重复显示。\n- `-m`, `--slabs` ：显示 slab 信息。\n- `-n`, `--one-header` ：在周期性输出时，只显示一次头部信息。\n- `-s`, `--stats` ：显示各种事件计数器和内存统计信息的表格。该选项不支持重复显示。\n- `-d`, `--disk` ：报告磁盘统计信息。\n- `-D`, `--disk-sum` ：报告有关磁盘活动的一些摘要统计信息。\n- `-p`, `--partition device` ：显示磁盘分区详细统计。\n- `-S`, `--unit character` ：在 1000 (k)、1024 (K)、1000000 (m) 或 1048576 (M) 字节之间切换。注意：这不会改变 block (bi/bo) 字段单位，这些字段始终以块为单位进行测量。\n- `-t`, `--timestamp` ：在每一行后面附上时间戳。\n- `-w`, `--wide` ：以宽模式输出（适用于具有更高内存量的系统），输出宽度超过每行 80 个字符。\n- `-V`, `--version` ：显示版本信息并退出。\n- `-h`, `--help` ：显示帮助信息并退出。\n\n## 示例\n\n显示系统虚拟内存统计信息（连续输出 5 次，每次间隔 5 秒）\n\n```shell\n$ vmstat 5 5\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0 407004 111360 308324    0    0  5039    30   65  243 12  6 78  4  0\n 1  0      0 407508 111372 308328    0    0     0    42  980  762 26  1 73  0  0\n 2  0      0 407256 111392 308332    0    0     0    47  974  749 26  1 73  0  0\n 3  0      0 919572 111400 308340    0    0     0    28  818  680 13  2 85  0  0\n 0  0      0 919288 111676 308428    0    0     0   614 1200 1325  1  3 97  0  0\n```\n\n\n\n字段含义：\n\n- Procs\n\n  （进程）\n\n  - r ：运行队列中进程数量\n  - b ：等待 IO 的进程数量\n\n- Memory\n\n  （内存）\n\n  - swpd ：使用虚拟内存大小\n  - free ：可用内存大小\n  - buff ：用作缓冲区的内存大小\n  - cache ：用作缓存的内存大小\n\n- Swap\n\n  - si ：每秒从交换区写到内存的大小\n  - so ：每秒写入交换区的内存大小\n\n- IO\n\n  （现在的 Linux 版本块的大小为 1024 bytes）\n\n  - bi ：每秒读取的块数\n  - bo ：每秒写入的块数\n\n- System\n\n  - in ：每秒中断数，包括时钟中断\n  - cs ：每秒上下文切换数\n\n- CPU\n\n  （以百分比表示）\n\n  - us ：用户进程执行时间（user time）\n  - sy ：系统进程执行时间（system time）\n  - id ：空闲时间（包括 IO 等待时间）（idle time）\n  - wa ：等待 IO 时间（wait time）\n\n\n\n# Linux iostat 命令 - 显示 I/O 统计信息\n\n## 介绍\n\n**iostat**（英文全拼：I/O statistics）是 Linux 系统中用于查看系统的磁盘 I/O（输入/输出）统计信息的命令。它能够提供关于磁盘和 CPU 使用情况的详细报告，对于监控系统性能和磁盘活动非常有用。\n\n和 [vmstat](https://getiot.tech/linux-command/vmstat/) 一样，iostat 也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。iostat 命令由 sysstat 软件包提供，使用前需要安装，安装命令如下。\n\n- Debian/Ubuntu\n- RedHat/CentOS\n\n```bash\nsudo apt install sysstat\n```\n\n\n\n**语法**：\n\n```bash\niostat [选项] [间隔时间] [次数]\n```\n\n\n\n**选项**：\n\n- `-c`：显示 CPU 使用情况。\n- `-d`：显示磁盘活动情况。\n- `-k`：以 KB 为单位显示磁盘活动情况。\n- `-m`：以 MB 为单位显示磁盘活动情况。\n- `-t`：在输出中添加时间戳。\n\n**间隔时间**：指定报告之间的时间间隔，单位为秒。\n\n**次数**：指定生成报告的次数。\n\n## 示例\n\n显示整体系统的平均磁盘活动情况：\n\n```bash\n$ iostat \nLinux 5.14.0-1059-oem (Latitude-3420) \t2023年12月19日 \t_x86_64_\t(8 CPU)\n\navg-cpu:  %user   %nice %system %iowait  %steal   %idle\n           4.17    0.04    1.32    0.16    0.00   94.31\n\nDevice             tps    kB_read/s    kB_wrtn/s    kB_dscd/s    kB_read    kB_wrtn    kB_dscd\nloop0             0.00         0.00         0.00         0.00         17          0          0\nloop1             0.01         0.26         0.00         0.00      30552          0          0\nnvme0n1          22.66       223.72       438.86         0.00   26153612   51304365          0\nsda               5.50        95.04       165.04         0.00   11110209   19294060          0\nsdb               0.02         0.24         0.01         0.00      27975       1368          0\n```\n\n\n\nCPU 属性值说明：\n\n- `%user`：CPU 处在用户模式下的时间百分比。\n- `%nice`：CPU 处在带 NICE 值的用户模式下的时间百分比。\n- `%system`：CPU 处在系统模式下的时间百分比。\n- `%iowait`：CPU 等待输入输出完成时间的百分比。\n- `%steal`：管理程序维护另一个虚拟处理器时，虚拟 CPU 的无意识等待时间百分比。\n- `%idle`：CPU 空闲时间百分比。\n\n提示\n\n如果 `%iowait` 的值过高，表示硬盘存在 I/O 瓶颈；`%idle` 值高，表示 CPU 较空闲；如果 `%idle` 值高但系统响应慢时，有可能是 CPU 等待分配内存，此时应加大内存容量。`%idle` 值如果持续低于 10，那么系统的 CPU 处理能力相对较低，表明系统中最需要解决的资源是 CPU。\n\n显示磁盘活动详细信息（包括读取和写入速率、I/O 等待时间等）：\n\n```bash\niostat -d\n```\n\n\n\n显示 CPU 使用情况的报告（包括用户、系统和空闲时间）：\n\n```bash\niostat -c\n```\n\n\n\n每 5 秒显示一次磁盘活动的详细报告：\n\n```bash\niostat -d 5\n```\n\n\n\n以 MB 为单位显示磁盘活动情况（而不是默认的块大小）：\n\n```bash\niostat -m\n```\n\n\n\n\n\n# Linux dmidecode 命令 - 读取 DMI 信息\n\n## 介绍\n\n**dmidecode** 命令主要是通过 DMI 获取 Linux 主机的硬件信息。遵循 SMBIOS/DMI 标准，输出的信息包括 BIOS、系统、主板、处理器、内存、缓存等等。\n\nDMI（Desktop Management Interface）是帮助收集电脑系统信息的管理系统，它的主要组成部分是 MIF（Management InformationFormat）数据库，这个数据库包括了所有有关电脑系统和配件的信息。dmidecode 的工作原理就是将 DMI 数据库中的信息解码，以人类可读的文本方式显示出来。但由于 DMI 信息可以人为修改，因此里面的信息不一定是系统准确的信息。\n\nDMI 信息的收集必须在严格遵照 SMBIOS 规范的前提下进行。SMBIOS（System Management BIOS）是主板或系统制造者以标准格式显示产品管理信息所需遵循的统一规范。SMBIOS 和 DMI 是由行业指导机构 Desktop Management Task Force (DMTF) 起草的开放性的技术标准，其中 DMI 设计适用于任何的平台和操作系统。DMI 充当了管理工具和系统层之间接口的角色，它建立了标准的可管理系统更加方便了电脑厂商和用户对系统的了解。\n\n**语法**：\n\n```shell\ndmidecode [OPTIONS]\n```\n\n\n\n**选项**：\n\n- `-d`, `--dev-mem FILE` ：从设备文件（默认为 /dev/mem）读取信息。\n- `-h`, `--help` ：显示帮助信息。\n- `-q`, `--quiet` ：输出尽可能少的信息。\n- `-s`, `--string KEYWORD` ：只显示指定 DMI 字符串的信息。\n- `-t`, `--type TYPE` ：只显示指定类型的条目。\n- `-H`, `--handle HANDLE` ：只显示指定句柄的条目内容。\n- `-u`, `--dump` ：显示未解码的原始条目内容。\n- `--dump-bin FILE` ：将 DMI 数据转储到一个二进制文件中。\n- `--from-dump FILE` ：从一个二进制文件读取 DMI 数据。\n- `-V`, `--version` ：显示版本信息。\n\n**关键字 KEYWORD 的合法字符串包括**：\n\n- bios-vendor\n- bios-version\n- bios-release-date\n- system-manufacturer\n- system-product-name\n- system-version\n- system-serial-number\n- system-uuid\n- baseboard-manufacturer\n- baseboard-product-name\n- baseboard-version\n- baseboard-serial-number\n- baseboard-asset-tag\n- chassis-manufacturer\n- chassis-type\n- chassis-version\n- chassis-serial-number\n- chassis-asset-tag\n- processor-family\n- processor-manufacturer\n- processor-version\n- processor-frequency\n\n**类型 TYPE 的合法字符串包括**：\n\n- bios\n- system\n- baseboard\n- chassis\n- processor\n- memory\n- cache\n- connector\n- slot\n\n## 示例\n\n不带选项执行通常会输出所有的硬件信息（该命令需要 root 权限，请自行添加 sudo）\n\n```shell\ndmidecode\n```\n\n\n\n查看服务器型号\n\n```shell\ndmidecode | grep 'Product Name'\n```\n\n\n\n查看主板的序列号\n\n```shell\ndmidecode |grep 'Serial Number'\n```\n\n\n\n查看系统序列号\n\n```shell\ndmidecode -s system-serial-number\n```\n\n\n\n查看内存信息\n\n```shell\ndmidecode -t memory\n```\n\n\n\n查看 BIOS 信息（对应 type 为 0）\n\n```shell\ndmidecode -t 0\n```\n\n\n\n以简洁形式输出所有硬件信息\n\n```shell\ndmidecode -q\n```\n\n\n\n\n\n# Linux smartctl 命令 - 管理 SMART 磁盘\n\n## 介绍\n\n**smartctl** 是用于 SMART 磁盘的控制和监视的一个实用程序。SMART 是 Self-Monitoring, Analysis and Reporting Technology 的缩写，即“自监控、分析和报告技术”，该技术内置于大多数 ATA/SATA 和 SCSI/SAS 硬盘驱动器和固态驱动器中。\n\nSMART 的目的是监控硬盘的可靠性和预测硬盘故障，并进行不同类型的硬盘自检。smartctl 还支持一些与 SMART 无关的功能，在 Linux 物理服务器中非常有用。\n\nsmartctl 命令由 smartmontools 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install smartmontools\n```\n\n\n\n**语法：**\n\n```bash\nsmartctl [options] device\n```\n\n\n\n**选项：**\n\n- `-h`, `--help`, `--usage`：显示帮助信息并退出。\n- `-V`, `--version`, `--copyright`, `--license`：打印许可证、版权和版本信息并退出。\n- `-i`, `--info`：显示设备的身份信息。\n- `--identify[=[w][nvb]]`：显示来自 IDENTIFY DEVICE 数据的字（words）和位（bits）。\n- `-g NAME`, `--get=NAME`：获取设备设置。\n- `-a`, `--all`：显示设备的所有 SMART 信息。\n- `-x`, `--xall`：显示设备的所有信息。\n- `--scan`：扫描设备。\n- `--scan-open`：扫描设备并尝试打开每个设备。\n- `-j`, `--json[=[cgiosuv]]`：以 JSON 格式打印输出。\n- `-q TYPE`, `--quietmode=TYPE`：设置安静模式。\n- `-d TYPE`, `--device=TYPE`：指定设备类型。\n- `-T TYPE`, `--tolerance=TYPE`：设置宽容模式。\n- `-b TYPE`, `--badsum=TYPE`：设置错误校验和的操作。\n- `-r TYPE`, `--report=TYPE`：报告交易。\n- `-n MODE[,STATUS]`, `--nocheck=MODE[,STATUS]`：如果是 never, sleep, standby, idle 模式则不检查。\n- `-s VALUE`, `--smart=VALUE`：在设备上启用或禁用 SMART (on/off)。\n- `-o VALUE`, `--offlineauto=VALUE`：在设备上启用或禁用自动离线测试 (on/off)。\n- `-S VALUE`, `--saveauto=VALUE`：在设备上启用或禁用属性自动保存 (on/off)。\n- `-s NAME[,VALUE]`, `--set=NAME[,VALUE]`：启用或禁用设备设置 (on/off)。\n- `-H`, `--health`：显示设备 SMART 健康状态。\n- `-c`, `--capabilities`：显示设备 SMART 功能。\n- `-A`, `--attributes`：显示设备 SMART 供应商特定的属性和值。\n- `-f FORMAT`, `--format=FORMAT`：设置属性的输出格式。\n- `-l TYPE`, `--log=TYPE`：显示设备日志。\n- `-v N,OPTION`, `--vendorattribute=N,OPTION`：设置供应商属性 N 的显示选项。\n- `-F TYPE`, `--firmwarebug=TYPE`：使用固件错误解决方法。\n- `-P TYPE`, `--presets=TYPE`：驱动器特定的预设。\n- `-B [+]FILE`, `--drivedb=[+]FILE`：从 FILE 读取并替换（add）驱动器数据库（默认是 +/etc/smart_drivedb.h，然后是 /var/lib/smartmontools/drivedb/drivedb.h）。\n- `-t TEST`, `--test=TEST`：运行测试。\n- `-C`, `--captive`：在捕获模式下进行测试（需要同时使用 -t 选项）。\n- `-X`, `--abort`：中止设备上的任何非强制测试。\n\n## 示例\n\n打印 /dev/sda 设备的所有 SMART 信息\n\n```bash\nsmartctl --all /dev/sda\n```\n\n\n\n在第一个磁盘上（/dev/sda）启用 SMART\n\n```bash\nsmartctl --smart=on --offlineauto=on --saveauto=on /dev/sda\n```\n\n\n\n执行扩展磁盘自检\n\n```bash\nsmartctl --test=long /dev/sda\n```\n\n\n\n打印自检和属性错误\n\n```bash\nsmartctl --attributes --log=selftest --quietmode=errorsonly /dev/sda\n```\n\n\n\n打印 3ware RAID 控制器上第三个 ATA 磁盘的所有 SMART 信息\n\n```bash\nsmartctl --all --device=3ware,2 /dev/sda\nsmartctl --all --device=3ware,2 /dev/twe0\nsmartctl --all --device=3ware,2 /dev/twa0\nsmartctl --all --device=3ware,2 /dev/twl0\n```\n\n\n\n打印连接到第 1 个 HighPoint RAID 控制器第 1 个通道的第 3 个 PMPort 的 SATA 磁盘的所有 SMART 信息\n\n```bash\nsmartctl --all --device=hpt,1/1/3 /dev/sda\n```\n\n\n\n打印 Areca RAID 控制器上第一个机箱的第三个 ATA 磁盘的所有 SMART 信息\n\n```bash\nsmartctl --all --device=areca,3/1 /dev/sg2\n```\n\n\n\n\n\n# Linux numactl 命令 - 设置 NUMA 策略\n\n## 介绍\n\n**numactl**（英文全拼：NUMA Control）命令用于查看当前服务器的 NUMA 节点配置和运行状态，可通过该工具将进程绑定到指定 CPU core，由指定 CPU core 来运行对应进程。\n\nnumactl 通常不会预先安装，但可在大多数 Linux 发行版的默认仓库中找到。例如，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\n$ sudo apt install numactl\n```\n\n\n\n安装完成后会有两个命令：`numactl` 和 `numastat`\n\n**语法**：\n\n```bash\nnumactl  [  --all ] [ --interleave nodes ] [ --preferred node ] [ --membind nodes ] \n         [ --cpunodebind nodes ] [ --physcpubind cpus ] [ --localalloc ] [--] command {arguments ...}\nnumactl --show\nnumactl --hardware\nnumactl [ --huge ] [ --offset offset ] [ --shmmode shmmode ] [ --length length ] [ --strict ]\n        [ --shmid id ] --shm shmkeyfile | --file tmpfsfile\n        [ --touch ] [ --dump ] [ --dump-nodes ] memory policy\n```\n\n\n\n**选项**：\n\n- `--interleave=nodes`, `-i nodes`：这个选项用于设定内存的交织分配模式。也就是说系统在为多个节点分配内存空间的时候，将会以轮询分发的方式被分配给这多个节点。如果在当前众多的交织分配内存节点中的目标节点无法正确的分配内存空间的话，内存空间将会由其他的节点来分配。\n\n- `--membind=nodes`, `-m nodes`：选项 `--membind` 仅用来从节点中分配内存空间所用。如果在这些节点中无法分配出所请求的空间大小的话该分配操作将会失败。\n\n- `--cpunodebind=nodes`, `-N nodes`：上述命令仅用于施加在运行与 CPU 上的进程。这个命令用于显示 CPU 的个数，CPU 数目信息同样记录在系统中的存放处理器领域信息的 /proc/cpuinfo 文件夹下，或者是按照关联的 CPU 信息，在当前的 CPU 集中所存放。\n\n- `--localalloc`, `-l`：这个命令选项通常是为当前的节点分配内存的。\n\n- `--preferred=node`：该命令由于指定优先分配内存空间的节点，如果无法将空间分配给该节点的话，应该分配给该节点上的空间将会被分发到其他的节点上，该命令选项后面仅接收一个单独的节点标号。\n\n- `--show`, `-s`：该命令用于显示 NUMA 机制作用在当前运行的那些进程上。\n\n- `--hardware`, `-H`：该命令用于显示当前系统中有多少个可用的节点。\n\n- `--huge`：当创建一个基于大内存页面的系统级的共享内存段的时候,使用 `--huge` 这个选项。`--huge` 选项仅在 `--shmid` 或是 `--shm` 命令的后面使用才有效。\n\n- `--offset`：该参数选项用于指定共享内存段中的位移量的偏移。默认的情况下偏移量是 0 。有效的偏移量单位是 m、g、k，分别表示 MB、GB 和 KB，没有指定则被认为是以字节为单位。\n\n- `--strict`：这个参数选项 当施加了 NUMA 调度机制的共享内存段区域的页面被施加了另一个机制而导致错误的时候，使用 `--strict` 选项将会把错误信息显示出来，默认情况是不使用该选项的。\n\n- `--shmmode <shmmode>`：该选项仅在 `--shmid` 或是 `--shm` 之前使用才会生效。当创建一个共享内存段的时候，通过整型数值来指定共享内存的共享的模式类型。\n\n- `--length <length>`：将策略应用于共享内存段中的长度范围或使段长度变长，默认是使用剩余长度，需要创建共享内存段时指定新段的长度。有效的单位是 m、g、k，分别表示 MB、GB 和 KB，没有指定则被认为是以字节为单位。\n\n- `--shmid <id>`：通过 ID 号码来创建或使用一个共享内存段。(如果共享内存段已经存在，那么通过 shmid 来指定下面要使用某个 ID 的共享内存段 ; 如果该 ID 对应的共享内存段并不存在的话，那么就创建一个)。\n\n- `--shm <shmkeyfile>`：通过存放在 shmkeyfile（共享内存-键文件）中的 ID 号码来创建或者是使用一个共享内存段。访问 shmkeyfile 文件的进程是通过 `fork(3 arguments)` 方法来实现的。\n\n- `--file <tmpfsfile>`：将 NUMA 机制施加于文件上面，这个文件属于 tmpfs 或者是 hugetlbfs 这种特殊的文件系统。\n\n- `--touch`：通过将 NUMA 机制施加于刚刚页面上来实现内存的早期 NUMA 化。默认情况下是不使用该选项，如果存在映射或是访问页面的应用的话，将会使用该早期实行 NUMA 机制的这种方法。\n\n- ```\n  --dump\n  ```\n\n  ：该选项用于废除将已经 NUMA 化的特定区域上的 NUMA 性质。\n\n  ```\n  --dump\n  ```\n\n   \n\n  选项后面，有效指定 node 的书写方式为：\n\n  - `all`：用于将所有的节点上的 NUMA 特性移除；\n  - `number`：通过指定 node 后接的数值来废除该数字对应的 node；\n  - `number1(number2)`：node number1（node number2）上的 NUMA 特性将会被移除；\n  - `number1-number2`：node number1 -- node number2 区间上的所有存在的 node 的 NUMA 特性将会被移除；\n  - `!nodes`：除了 nodes 所指定的节点以外的所有节点上的 NUMA 特性全都会被移除。\n\n## 示例\n\n1、查看当前的 NUMA 运行状态\n\n```bash\n$ numastat\n                           node0\nnuma_hit              2011064712\nnuma_miss                      0\nnuma_foreign                   0\ninterleave_hit             47040\nlocal_node            2011064712\nother_node                     0\n```\n\n\n\n字段说明：\n\n- `numa_hit` 表示节点内 CPU 核访问本地内存的次数。\n- `numa_miss` 表示节点内核访问其他节点内存的次数。跨节点的内存访问会存在高延迟从而降低性能，因此 `numa_miss` 的值应当越低越好，如果过高，则应当考虑绑核。\n\n2、查看当前服务器的 NUMA 配置\n\n```bash\nnumactl -H\n```\n\n\n\n3、将应用程序 test 绑定到 0~7 核运行\n\n```bash\nnumactl -C 0-7 ./test\n```\n\n\n\n\n\n# Linux export 命令 - 导出环境变量\n\n## 介绍\n\n**export** 是 Linux 系统中用于设置环境变量的命令，也是一个重要系统命令。环境变量是一种在操作系统级别上保存配置信息和可在不同进程之间共享的变量。使用 `export` 可以将变量从当前 shell 传递到其子 shell。\n\n**语法**：\n\n```bash\nexport [-fn] [NAME[=VALUE] ...]\nexport -p\n```\n\n\n\n**选项**：\n\n- `-f`：指 shell 函数。\n- `-n`：删除每个 `NAME` 名称的导出属性。\n- `-p`：显示所有导出的变量和函数的列表。\n\n`export` 将标记每个 `NAME` 名称为自动导出到后续命令执行的环境。如果提供了 `VALUE` 则导出前将其作为赋值。\n\n## 示例\n\n创建一个名为 `MY_VARIABLE` 的环境变量，并将其值设置为 \"Hello\"：\n\n```bash\nexport MY_VARIABLE=\"Hello\"\n```\n\n\n\n设置路径变量（`PATH`），将 `/usr/local/bin` 添加到现有的 `PATH` 环境变量中：\n\n```bash\nexport PATH=$PATH:/usr/local/bin\n```\n\n\n\n\n\n# Linux unset 命令 - 取消环境变量\n\n## 介绍\n\n**unset** 命令用于删除已定义的 shell 变量（包括环境变量）或函数的值和属性。注意，unset 命令不能够删除具有只读属性（参考 readonly）的 shell 变量和环境变量。\n\n**语法**：\n\n```bash\nunset [-f] [-v] [-n] [NAME ...]\n```\n\n\n\n**选项**：\n\n- `-f`：将每个 `NAME` 视为函数。\n- `-v`：将每个 `NAME` 视为变量。\n- `-n`：将每个 `NAME` 视为名称引用，只取消其本身而非其指向的变量。\n\n**参数**：对每一个 `NAME` 名称，删除对应的变量或函数。\n\n提示\n\nunset 是 bash 内建命令，相关的帮助信息可通过命令 `help unset` 查看。\n\n## 示例\n\n先使用 [export](https://getiot.tech/linux-command/export/) 创建一个环境变量 `GETIOT_ROOT` 及其对应的值：\n\n```bash\n$ export GETIOT_ROOT=/opt/getiot\n```\n\n\n\n查看 `GETIOT_ROOT` 环境变量的值：\n\n```bash\n$ echo $GETIOT_ROOT\n/opt/getiot\n```\n\n\n\n取消 `GETIOT_ROOT` 环境变量定义：\n\n```bash\n$ unset GETIOT_ROOT\n```\n\n\n\n再次查看该环境变量可发现其值为空。\n\n在 Shell 脚本编程中，通常使用 [declare](https://getiot.tech/linux-command/declare/) 声明变量，例如声明一个整型变量：\n\n```bash\n$ declare -i paper_size=100\n```\n\n\n\n删除该变量：\n\n```bash\n$ unset -v paper_size\n```\n\n\n\n通过 function 创建一个 Shell 函数：\n\n```bash\n$ function show_result(){ echo 'Last Command Return: $?'; }\n```\n\n\n\n删除该函数：\n\n```bash\n$ unset -f show_result\n```\n\n\n\n\n\n# Linux env 命令 - 显示环境变量\n\n## 介绍\n\n**env** 是一个用于显示或设置环境变量的命令。在 Linux 系统中，它通常用于在运行命令时设置临时环境变量，以影响该命令的行为。\n\nenv 命令在脚本和命令行中非常有用，特别是当你想要在执行命令时设置特定的环境变量时。它提供了一种在不改变当前 shell 环境的情况下，临时修改环境变量的方法。\n\n**语法**：\n\n```bash\nenv [选项]... [-] [名称=值]... [命令 [参数]...]\n```\n\n\n\n**选项**：\n\n- `-i, --ignore-environment`：以空环境启动（清除所有环境变量）。\n- `-0, --null`：以 `NUL` 空字符而非换行符结束每一输出行。\n- `-u, --unset=名称`：从当前环境中移除一个变量。\n- `-C, --chdir=目录`：将工作目录变更为指定目录。\n- `-S, --split-string=S`：处理并将 `S` 拆分为单独的参数，用于在 shebang（`#!`）行上传递多个参数。\n- `-v, --debug`：打印每个处理步骤的详细信息。\n- `--help`：显示帮助信息并退出。\n- `--version`：显示版本信息并退出。\n\n## 示例\n\n显示当前 shell 的所有环境变量：\n\n```bash\nenv\n```\n\n\n\n设置环境变量 `VAR` 的值为 `value`，然后运行 `command`：\n\n```bash\nenv VAR=value command\n```\n\n\n\n清除所有环境变量，然后仅设置 `VAR` 变量，并运行 `command`：\n\n```bash\nenv -i VAR=value command\n```\n\n\n\n移除指定环境变量，并运行 `command`：\n\n```bash\nenv -u VAR command\n```\n\n\n\n\n\n# Linux printenv 命令 - 打印环境变量\n\n## 介绍\n\n**printenv** 命令用于显示当前环境变量的值。它在 Linux 和 Unix 系统上广泛使用，允许用户查看当前 shell 进程中定义的所有环境变量。\n\n注意\n\nprintenv 只能查看当前 shell 的环境变量，如果有子 shell 或新的进程，则它们将具有独立的环境。\n\n和 [env](https://getiot.tech/linux-command/env/) 命令不同，`printenv` 主要用于显示环境变量，而不提供设置环境变量的功能。而 `env` 不仅可以显示环境变量，还可以在运行命令时设置环境变量。\n\n**语法**：\n\n```bash\nprintenv [选项]... [变量]...\n```\n\n\n\n**选项**：\n\n- `-0, --null`：以空字符而非换行符结束每一输出行。\n- `--help`：显示帮助信息并退出。\n- `--version`：显示版本信息并退出。\n\n如果没有指定变量，则打印出所有变量的名称和值。\n\n## 示例\n\n显示当前 shell 进程中定义的所有环境变量及其值：\n\n```bash\nprintenv\n```\n\n\n\n显示环境变量 `PATH` 的值：\n\n```bash\nprintenv PATH\n```\n\n\n\n\n\n# Linux passwd 命令 - 更改用户密码\n\n## 介绍\n\n在 Linux 系统中，**passwd** 命令用于设置用户的认证信息，包括用户密码、账户锁定、密码失效等。直接运行 passwd 命令修改当前的用户密码，对其他用户的密码操作需要管理员权限。\n\n**语法**：\n\n```bash\npasswd [选项] [用户名]\n```\n\n\n\n**选项**：\n\n- `-a, --all`：报告所有帐户的密码状态。\n- `-d, --delete`：删除指定帐户的密码。\n- `-e, --expire`：强制使指定帐户的密码过期。\n- `-h, --help`：显示此帮助信息并推出。\n- `-k, --keep-tokens`：仅在过期后修改密码。\n- `-i, --inactive INACTIVE`：密码过期后设置密码不活动为 `INACTIVE`。\n- `-l, --lock`：锁定指定的帐户。\n- `-n, --mindays MIN_DAYS`：设置到下次修改密码所须等待的最短天数为 `MIN_DAYS`。\n- `-q, --quiet`：安静模式。\n- `-r, --repository REPOSITORY`：在 `REPOSITORY` 库中改变密码。\n- `-R, --root CHROOT_DIR`：chroot 到的目录。\n- `-S, --status`：报告指定帐户密码的状态。\n- `-u, --unlock`：解锁被指定帐户。\n- `-w, --warndays WARN_DAYS`：设置过期警告天数为 `WARN_DAYS`。\n- `-x, --maxdays MAX_DAYS`：设置到下次修改密码所须等待的最多天数为 `MAX_DAYS`。\n\n## 示例\n\n修改当前登陆的账户密码：\n\n```bash\npasswd\n```\n\n\n\n修改其他用户密码（假设有 getiot 用户）：\n\n```bash\npasswd getiot\n```\n\n\n\n锁定 getiot 用户密码，不允许修改其密码：\n\n```bash\npasswd -l getiot\n```\n\n\n\n解除锁定 getiot 用户密码，允许修改其密码：\n\n```bash\npasswd -u getiot\n```\n\n\n\n下次登录 getiot 账号时强制修改其密码：\n\n```bash\npasswd -e getiot\n```\n\n\n\n清除登录 getiot 账号密码（清除之后登录时无需密码，风险极大）：\n\n```bash\npasswd -d getiot\n```\n\n\n\n查询密码状态：\n\n```bash\npasswd -S getiot\n```\n\n\n\n\n\n# Linux useradd 命令 - 添加新用户\n\n## 介绍\n\n在 Linux 系统中，**useradd** 命令用来创建新的用户或更改用户的信息。\n\nuseradd 可用来建立用户帐号，而当帐号建好之后，再通过 [passwd](https://getiot.tech/linux-command/passwd/) 命令设定帐号的密码。使用 useradd 命令所建立的帐号，实际上是保存在 /etc/passwd 文本文件中。\n\n提示\n\n使用 `useradd` 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。\n\n**语法**：\n\n```bash\nuseradd [选项] 用户名\nuseradd -D\nuseradd -D [选项]\n```\n\n\n\n**选项**：\n\n- `-b, --base-dir BASE_DIR`：新账户的主目录的基目录。\n- `-c, --comment COMMENT`：新账户的 GECOS 字段。\n- `-d, --home-dir HOME_DIR`：新账户的主目录。\n- `-D, --defaults `：显示或更改默认的 useradd 配置。\n- `-e, --expiredate EXPIRE_DATE`：新账户的过期日期。\n- `-f, --inactive INACTIVE`：新账户的密码不活动期。\n- `-g, --gid GROUP `：新账户主组的名称或 ID。\n- `-G, --groups GROUPS`：新账户的附加组列表。\n- `-h, --help`：显示帮助信息。\n- `-k, --skel SKEL_DIR`：使用此目录作为骨架目录。\n- `-K, --key KEY=VALUE`：不使用 /etc/login.defs 中的默认值。\n- `-l, --no-log-init`：不要将此用户添加到最近登录和登录失败数据库。\n- `-m, --create-home`：创建用户的主目录。\n- `-M, --no-create-home `：不创建用户的主目录。\n- `-N, --no-user-group`：不创建同名的组。\n- `-o, --non-unique `：允许使用重复的 UID 创建用户。\n\n## 示例\n\n创建新用户 getiot：\n\n```bash\nuseradd getiot\n```\n\n\n\n创建新用户 getiot，但不创建家目录，并且禁止登录：\n\n```bash\nuseradd -M -s /sbin/nologin getiot\n```\n\n\n\n创建新用户 getiot，并指定 UID 为 888，指定归属用户组为 root、dialout 成员，其 shell 类型为 /bin/sh：\n\n```bash\nuseradd -u 888 -s /bin/sh -G root,dialout getiot\n```\n\n\n\n创建新用户 getiot，设置家目录为 /data/getiot，用户过期时间为 2030/12/31，过期后两天停权：\n\n```bash\nuseradd -e \"2030/12/31\" -f 2 -d /data/getiot getiot\n```\n\n\n\n\n\n# Linux userdel 命令 - 删除用户\n\n## 介绍\n\n在 Linux 系统中，**userdel** 命令用于删除指定的用户及与该用户相关的文件。在实现上，userdel 命令其实只是修改了系统的用户账号文件 /etc/passwd、/etc/shadow 以及 /etc/group 文件。这与 Linux系统“一切操作皆文件”的思想正好吻合。\n\n值得注意的是，如果有该要删除用户相关的进程正在运行，userdel 命令通常不会删除该用户账号。如果确实必须要删除，建议先终止用户进程，然后再执行 userdel 命令进行删除。不过，userdel 命令也提供了一个面对这种情况的选项，即 `-f` 选项。\n\n提示\n\n使用 `userdel` 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。\n\n**语法**：\n\n```bash\nuserdel [选项] 用户名\n```\n\n\n\n**选项**：\n\n- `-f, --force`：强制删除用户账号。\n- `-r, --remove`：删除用户主目录及其中的所有文件。\n- `-R, --root CHROOT_DIR`：chroot 到指定目录。\n- `-Z, --selinux-user`：为用户删除所有的 SELinux 用户映射。\n- `-h, --help`：显示帮助信息。\n\n## 示例\n\n删除用户 getiot，但不删除其家目录及文件：\n\n```bash\nuserdel getiot\n```\n\n\n\n删除用户 getiot，并将其家目录及文件一并删除：\n\n```bash\nuserdel -r getiot\n```\n\n\n\n\n\n# Linux usermod 命令 - 修改用户属性\n\n## 介绍\n\n在 Linux 系统中，**usermod** 命令用于修改用户账号的各项设定。在实现上，usermod 命令其实只是修改了系统的用户账号文件 /etc/passwd、/etc/shadow 以及 /etc/group 文件。\n\nusermod 命令不允许你改变正在线上的使用者帐号名称。另外，当 usermod 命令用来改变 user id，必须确认系统中没有该用户相关的进程正在运行。\n\n提示\n\n使用 `usermod` 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。\n\n**语法**：\n\n```bash\nusermod [选项] 用户名\n```\n\n\n\n**选项**：\n\n- `-c, --comment 注释`：修改用户账号的备注文字（GECOS 字段）。\n- `-d, --home HOME_DIR`：设置用户的新主目录。\n- `-e, --expiredate EXPIRE_DATE`：设定帐户过期的日期为 `EXPIRE_DATE`。\n- `-f, --inactive INACTIVE`：过期 `INACTIVE` 天数后，设定密码为失效状态。\n- `-g, --gid GROUP`：强制使用 `GROUP` 为新主组。\n- `-G, --groups GROUPS`：新的附加组列表 `GROUPS`。\n- `-a, --append GROUP`：将用户追加至上边 `-G` 中提到的附加组中，并不从其它组中删除此用户。\n- `-h, --help`：显示帮助信息。\n- `-l, --login LOGIN`：设置新的登录名称。\n- `-L, --lock`：锁定用户帐号。\n- `-m, --move-home`：将家目录内容移至新位置（仅于 `-d` 一起使用）。\n- `-o, --non-unique`：允许使用重复的（非唯一的）UID。\n- `-p, --password PASSWORD`：将加密过的密码（`PASSWORD`）设为新密码。\n- `-R, --root CHROOT_DIR`：chroot 到指定目录。\n- `-s, --shell SHELL`：该用户帐号的新登录 shell。\n- `-u, --uid UID`：用户帐号的新 UID。\n- `-U, --unlock`：解锁用户帐号。\n- `-v, --add-subuids FIRST-LAST`：添加子 UID 范围。\n- `-V, --del-subuids FIRST-LAST`：移除子 UID 范围。\n- `-w, --add-subgids FIRST-LAST`：添加子 GID 范围。\n- `-W, --del-subgids FIRST-LAST`：移除子 GID 范围。\n- `-Z, --selinux-user SEUSER`：用户账户的新 SELinux 用户映射。\n\n## 示例\n\n更改用户 getiot 的家目录为 /home/linux：\n\n```bash\nusermod -d /home/linux getiot\n```\n\n\n\n将用户 getiot 添加到组 dialout 中：\n\n```bash\nusermod -G dialout getiot\n```\n\n\n\n修改 getiot 的用户名为 linux：\n\n```bash\nusermod -l linux getiot\n```\n\n\n\n锁定账号 getiot：\n\n```bash\nusermod -L getiot\n```\n\n\n\n解除对 getiot 的锁定：\n\n```bash\nusermod -U getiot\n```\n\n\n\n\n\n# Linux groupadd 命令 - 添加用户组\n\n## 介绍\n\n**groupadd** 命令用于在 Linux 系统中创建新的用户组（group）。它允许系统管理员通过命令行创建和管理用户组。\n\n提示\n\n使用 `groupadd` 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。\n\n**语法**：\n\n```bash\ngroupadd [选项] group\n```\n\n\n\n**选项**：\n\n- `-f, --force`：若用户组已存在，则以成功状态退出。\n- `-g, --gid GID`：指定用户组的组 ID（GID）。如果不指定，系统将自动分配。\n- `-h, --help`：显示帮助信息。\n- `-K, --key KEY=VALUE`：设置新用户组的属性（覆盖配置文件 /etc/login.defs）。这允许管理员设置各种用户组属性。\n- `-o, --non-unique`：允许使用重复的 GID。这在某些情况下可能有用。\n- `-p, --password PASSWORD`：设置用户组密码。\n- `-r, --system`：创建系统用户组。注意，系统工作组的组 ID 小于 500。\n- `-R, --root CHROOT_DIR`：应用 `CHROOT_DIR` 目录中的更改并使用 `CHROOT_DIR` 目录中的配置文件。\n- `-P, --prefix PREFIX_DIR`：应用 `PREFIX_DIR` 目录中的更改并使用 `PREFIX_DIR` 目录中的配置文件。此选项不会 chroot，旨在准备交叉编译目标。一些限制：NIS 和 LDAP 用户/组未经过验证；PAM 身份验证使用主机文件；没有 SELINUX 支持。\n\n## 示例\n\n创建一个名为 students 的新用户组：\n\n```bash\nsudo groupadd students\n```\n\n\n\n创建一个名为 students 的新用户组，并指定组 ID（GID）为 1001：\n\n```bash\nsudo groupadd -g 1001 students\n```\n\n\n\n\n\n# Linux groupdel 命令 - 删除用户组\n\n## 介绍\n\n**groupdel** 命令用于在 Linux 系统中删除指定用户组。它允许系统管理员通过命令行删除不再需要的用户组，本质上是修改的系统中的 /ect/group 和 /ect/gshadow 文件。\n\n你可以使用 [`userdel`](https://getiot.tech/linux-command/userdel/) 命令修改系统用户文件，删除与 GROUP 相关的所有项目。需要注意的是，若该群组中仍包括某些用户，则必须先删除这些用户后，才能删除群组。\n\n提示\n\n使用 `groupdel` 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。\n\n**语法**：\n\n```bash\ngroupdel [选项] GROUP\n```\n\n\n\n**选项**：\n\n- `-h, --help`：显示帮助信息并退出。\n- `-R, --root CHROOT_DIR`：在 `CHROOT_DIR` 目录中应用更改并使用 `CHROOT_DIR` 目录中的配置文件。\n- `-P, --prefix PREFIX_DIR`：应用 `PREFIX_DIR` 目录中的更改并使用 `PREFIX_DIR` 目录中的配置文件。此选项不会 chroot，旨在准备交叉编译目标。一些限制：NIS 和 LDAP 用户/组未经过验证；PAM 身份验证使用主机文件；没有 SELINUX 支持。\n- `-f, --force`：强制删除。\n\n## 示例\n\n删除名为 students 的用户组：\n\n```bash\nsudo groupdel students\n```\n\n\n\n强制删除名为 students 的用户组，即使该组有用户成员：\n\n```bash\nsudo groupdel -f students\n```\n\n\n\n\n\n# Linux groupmod 命令 - 修改用户组\n\n## 介绍\n\n**groupmod** 命令用于在 Linux 系统中修改用户组的属性。通过 `groupmod` 命令，管理员可以更改用户组的名称或 GID（组 ID），以及其他一些属性。\n\n不过建议大家不要随意修改用户名、组名和 GID，因为非常容易造成管理员逻辑混乱。如果非要修改用户名或组名，建议先删除旧的，再建立新的。\n\n提示\n\n使用 `groupmod` 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。\n\n**语法**：\n\n```bash\ngroupmod [选项] GROUP\n```\n\n\n\n**选项**：\n\n- `-g, --gid GID`：将组 ID 改为 `GID`。\n- `-h, --help`：显示帮助信息。\n- `-n, --new-name NEW_GROUP`：将组名修改为 `NEW_GROUP`。\n- `-o, --non-unique`：允许使用重复的 GID。\n- `-p, --password PASSWORD`：将密码更改为（加密过的）`PASSWORD`。\n- `-R, --root CHROOT_DIR`：在 `CHROOT_DIR` 目录中应用更改并使用 `CHROOT_DIR` 目录中的配置文件。\n- `-P, --prefix PREFIX_DIR`：应用 `PREFIX_DIR` 目录中的更改并使用 `PREFIX_DIR` 目录中的配置文件。此选项不会 chroot，旨在准备交叉编译目标。一些限制：NIS 和 LDAP 用户/组未经过验证；PAM 身份验证使用主机文件；没有 SELINUX 支持。\n\n## 示例\n\n修改用户组的名称：\n\n```bash\nsudo groupmod -n newgroupname oldgroupname\n```\n\n\n\n修改用户组的组 ID（GID）：\n\n```bash\nsudo groupmod -g 1001 groupname\n```\n\n\n\n\n\n# Linux adduser 命令 - 添加新用户\n\n## 介绍\n\n**adduser** 命令用于在 Linux 系统中添加新用户。在一些发行版中，`adduser` 实际上是 [`useradd`](https://getiot.tech/linux-command/useradd/) 命令的一个符号链接，而另一些发行版中，`adduser` 是一个对 [`useradd`](https://getiot.tech/linux-command/useradd/)、[`groupadd`](https://getiot.tech/linux-command/groupadd/) 和 [`usermod`](https://getiot.tech/linux-command/usermod/) 命令进行封装的脚本程序，提供一些交互式的步骤以更方便地配置用户信息。大多数情况下，两者可以互相替代。\n\n提示\n\n使用 `adduser` 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。\n\n**语法**：\n\n```bash\nadduser [options] user\nadduser [options] user group\n```\n\n\n\n**选项**：\n\n- `--conf FILE`：使用指定的配置文件替代默认的 /etc/adduser.conf。\n- `--disabled-login`：不要运行 `passwd` 来设置密码。在设置密码之前，用户将无法使用其帐户。\n- `--disabled-password`：类似于 `--disabled-login` 选项，但仍然可以登录（例如使用 SSH RSA 密钥），但不能使用密码身份验证。\n- `--force-badname`：默认情况下，将根据配置文件中指定的可配置正则表达式 `NAME_REGEX`（如果指定了 `--system`，则为 `NAME_REGEX_SYSTEM`）检查用户和组名称。此选项强制 adduser 和 addgroup 仅对名称的有效性应用弱检查。`NAME_REGEX` 在 adduser.conf 中描述。\n- `--gecos GECOS`：为生成的新条目设置 gecos 字段。如果给出此选项，adduser 将不会询问指纹信息。\n- `--gid ID`：创建组时，此选项强制新的组 ID 为给定的数字。创建用户时，此选项会将用户放入该组中。\n- `--group`：与 `--system` 结合使用时，将创建与系统用户具有相同名称和 ID 的组。如果不与 `--system` 结合使用，则会创建具有给定名称的组。如果程序作为 addgroup 调用，则这是默认操作。\n- `--help`：显示帮助信息。\n\n## 示例\n\n添加名为 getiot 的新用户，并按照提示设置密码等信息：\n\n```bash\n$ sudo adduser getiot\n```\n\n\n\n\n\n# Linux deluser 命令 - 删除用户\n\n## 介绍\n\n在许多 Linux 发行版中，**deluser** 是一个命令行工具，是对 [`userdel`](https://getiot.tech/linux-command/userdel/) 和 [`groupdel`](https://getiot.tech/linux-command/groupdel/) 命令进行封装的脚本，用于删除系统中的用户账户。这个命令通常会删除用户的主目录以及与之相关的文件和组。\n\n提示\n\n使用 `deluser` 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。\n\n**语法**：\n\n```bash\ndeluser [options] user\ndeluser [options] user group\n```\n\n\n\n**选项**：\n\n- `--conf FILE`：使用 `FILE` 替代默认的 /etc/deluser.conf 和 /etc/adduser.conf 文件。\n- `--group`：删除一个组。如果程序作为 delgroup 调用，则这是默认操作。\n- `--help`：显示帮助信息。\n- `--quiet`：禁止显示进度信息。\n- `--system`：仅当用户/组是系统用户/组时才删除。这可以避免意外删除非系统用户/组。此外，如果用户不存在，则不会返回错误值。该选项主要用于 Debian 软件包维护者脚本。\n- `--only-if-empty`：仅在没有成员留下时才删除。\n- `--backup`：将 userhome 和 mailspool 文件中包含的所有文件备份到名为 `/$user.tar.bz2` 或 `/$user.tar.gz` 的文件中。\n- `--backup-to`：备份文件不放在 `/` 下，而是放在该参数指定的目录下。这也隐式设置了 `--backup`。\n- `--remove-home`：删除用户的主目录及其邮件池。如果指定了 `--backup`，则执行备份后将删除文件。\n- `--remove-all-files`：从该用户拥有的系统中删除所有文件。注意：`--remove-home` 不再起作用。如果指定了 `--backup`，则执行备份后将删除文件。\n- `--version`：显示版本和版权信息。\n\n## 示例\n\n删除用户 getiot（保留主目录）：\n\n```bash\nsudo deluser getiot\n```\n\n\n\n删除用户并删除主目录：\n\n```bash\nsudo deluser --remove-home getiot\n```\n\n\n\n删除用户及其主目录和所有相关文件：\n\n```bash\nsudo deluser --remove-all-files getiot\n```\n\n\n\n备份用户主目录并删除用户：\n\n```bash\nsudo deluser --backup getiot\n```\n\n\n\n将用户从 students 组中删除：\n\n```bash\nsudo deluser getiot students\n```\n\n\n\n\n\n# Linux addgroup 命令 - 添加用户组\n\n## 介绍\n\n在 Linux 系统中，**addgroup** 命令用于创建新的用户组（group）。`addgroup` 在不同的发行版中有不同的实现，它可能是 [`groupadd`](https://getiot.tech/linux-command/groupadd/) 的别名，也可能是一个脚本程序，可以更方便地创建用户组。\n\n提示\n\n使用 `addgroup` 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。\n\n**语法**：\n\n```bash\naddgroup [options] group\n```\n\n\n\n**选项**：\n\n- `--quiet | -q`：不将进程信息发给 stdout。\n- `--force-badname`：允许与 `NAME_REGEX[_SYSTEM]` 配置变量不匹配的用户名。\n- `--extrausers`：使用额外的用户作为数据库。\n- `--help | -h`：显示帮助信息。\n- `--version | -v`：显示版本信息。\n- `--conf | -c FILE`：使用 `FILE` 作为配置文件。\n\n## 示例\n\n创建一个新用户组 students：\n\n```bash\nsudo addgroup students\n```\n\n\n\n\n\n# Linux delgroup 命令 - 删除用户组\n\n## 介绍\n\n在 Linux 系统中，**delgroup** 命令用于删除用户组（group）。`delgroup` 在不同的发行版中有不同的实现，它可能是 [`groupdel`](https://getiot.tech/linux-command/groupdel/) 的别名，也可能是一个脚本程序，可以更方便地创建用户组。\n\n提示\n\n使用 `delgroup` 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。\n\n**语法**：\n\n```bash\ndelgroup [options] [--only-if-empty] group\n```\n\n\n\n**选项**：\n\n- `--quiet | -q`：不将进程信息发给 stdout。\n- `--system`：只有当该用户组是系统用户组时才删除。\n- `--only-if-empty`：只有当该用户组中无成员时才删除。\n- `--help | -h`：显示帮助信息。\n- `--version | -v`：显示版本信息。\n- `--conf | -c FILE`：使用 `FILE` 作为配置文件。\n\n## 示例\n\n删除 students 用户组：\n\n```bash\nsudo addgroup students\n```\n\n\n\n等效于：\n\n```bash\nsudo deluser --group students\n```\n\n\n\n\n\n# Linux uptime 命令 - 显示系统运行时间\n\n## 介绍\n\n**uptime** 命令用于显示系统运行时间。\n\n和 [who](https://getiot.tech/linux-command/who/) 命令一样，uptime 命令也会从 /var/run/utmp 文件获取系统信息，也可以从 /proc/uptime 中读取。\n\n**语法**：\n\n```shell\nuptime [options]\n```\n\n\n\n**选项**：\n\n- `-p`, `--pretty` ：以漂亮的格式显示正常运行时间。\n- `-s`, `--since` ：以 yyyy-mm-dd HH:MM:SS 格式显示系统启动时间。\n- `-h`, `--help` ：显示帮助信息。\n- `-V`, `--version` ：显示版本信息。\n\n## 示例\n\n显示系统运行时间：\n\n```shell\n$ uptime \n 00:00:01 up  5:27,  1 user,  load average: 0.33, 0.40, 0.33\n```\n\n\n\n以更便于阅读的格式显示系统运行时间：\n\n```shell\n$ uptime -p\nup 5 hours, 27 minutes\n```\n\n\n\n显示系统启动时间：\n\n```shell\n$ uptime -s\n2021-04-30 18:32:54\n```\n\n\n\n\n\n# Linux time 命令 - 统计命令执行时间\n\n## 介绍\n\n**time** 命令用于计算特定指令执行时所需消耗的时间及系统资源等数据。例如 cpu 时间、内存、IO 资源等。\n\n我们经常用 time 命令来计算某个程序的运行耗时（real），用户态 cpu 耗时（user），系统态 cpu 耗时（sys）。\n\n**语法**：\n\n```shell\ntime [options] COMMAND [arguments]\n```\n\n\n\n**选项**：\n\n- `-o`, `--output=FILE` ：指定结果输出文件。将 time 的输出写入文件中，如果文件已经存在，则覆盖其内容。\n- `-a`, `--append` ：配合 `-o` 选项使用，将结果写入到文件的末端，而不会覆盖原有内容。\n- `-f`, `--format FORMAT` ：以 FORMAT 格式字符串设定显示方式。如果没有指定，则使用系统预设的格式，亦可通过系统环境变量 `TIME` 来设定该格式。\n\n## 示例\n\n直接执行 time 命令（显示 real、user、sys 时间）：\n\n```shell\n$ time\n\nreal    0m0.000s\nuser    0m0.000s\nsys     0m0.000s\n```\n\n\n\n其中，real 表示程序运行耗时，user 表示用户态 cpu 耗时，sys 表示内核态 cpu 耗时。\n\n计算 `sleep 2` 命令的执行时间：\n\n```shell\n$ time sleep 2\n\nreal    0m2.004s\nuser    0m0.001s\nsys     0m0.001s\n```\n\n\n\n计算硬盘写测试所用的时间：\n\n```shell\ntime dd if=/dev/zero of=testw.dbf bs=4k count=102400\n102400+0 records in\n102400+0 records out\n419430400 bytes (419 MB, 400 MiB) copied, 1.98527 s, 211 MB/s\n\nreal    0m1.990s\nuser    0m0.104s\nsys     0m1.866s\n```\n\n\n\n注意：real time 表示时钟走过的时间，user time 表示程序在用户态占用 cpu 的时间，sys time 表示程序在内核态占用 cpu 的时间。real、user 和 sys 三者之间没有严格的关系，user + sys 不等于 real 时间，在多核系统中，user + sys 可能会大于 real 时间。\n\n我们可以这样计算程序运行期间的 CPU 占用率：\n\n```shell\n%cpu_usage = (user_time + sys_time)/real_time * 100%\n```\n\n\n\n\n\n# Linux date 命令 - 显示/设置日期时间\n\n## 介绍\n\n**date** 命令用于显示或设置 Linux 系统的日期和时间。\n\n**语法**：\n\n```bash\ndate [OPTION]... [+FORMAT]\ndate [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\n```\n\n\n\n**选项**：\n\n- `-d`, `--date=STRING` ：显示字符串所指的日期与时间，字符串前后必须加上双引号。\n- `-s`, `--set=STRING` ：根据字符串来设置日期与时间，字符串前后必须加上双引号。\n- `-u`, `--utc`, `--universal` ：以 UTC 时间显示或设置。\n- `--help` ：显示帮助信息。\n- `--version` ：显示版本信息。\n\n**参数**：指定显示时使用的日期时间格式。\n\n具体的日期格式字符串列表如下：\n\n- `%H` 小时，24小时制（00~23）\n- `%I` 小时，12小时制（01~12）\n- `%k` 小时，24小时制（0~23）\n- `%l` 小时，12小时制（1~12）\n- `%M` 分钟（00~59）\n- `%p` 显示出 AM 或 PM\n- `%r` 显示时间，12小时制（`hh:mm:ss %p`）\n- `%s` 从1970年1月1日 00:00:00 到目前经历的秒数\n- `%S` 显示秒（00~59）\n- `%T` 显示时间，24小时制（`hh:mm:ss`）\n- `%X` 显示时间的格式（`%H:%M:%S`）\n- `%Z` 显示时区，日期域（CST）\n- `%a` 显示星期的缩写（Sun~Sat）\n- `%A` 显示星期的全称（Sunday~Saturday）\n- `%h`, `%b` 显示月份的缩写（Jan~Dec）\n- `%B` 显示月份的全称（January~December）\n- `%c` 显示日期和时间（Tue Nov 20 14:12:58 2012）\n- `%d` 显示一个月的第几天（01~31）\n- `%x`, `%D` 显示日期（`mm/dd/yy`）\n- `%j` 显示一年的第几天（001~366）\n- `%m` 显示月份（01~12）\n- `%w` 显示一个星期的第几天（0 代表星期天）\n- `%W` 显示一年的第几个星期（00~53，星期一为第一天）\n- `%y` 显示年份的最后两个数字（1999 则是 99）\n\n## 示例\n\n显示当前日期（年、月、日）：\n\n```bash\n$ date +\"%Y year %m month %d day\"\n2021 year 05 month 30 day\n```\n\n\n\n显示昨天日期：\n\n```bash\n$ date -d \"1 day ago\" +\"%Y-%m-%d\"\n2021-05-29\n```\n\n\n\n显示前天日期：\n\n```bash\ndate -d \"-2 day\"\n```\n\n\n\n显示 30 秒后的时间：\n\n```bash\ndate -d \"30 second\"\n```\n\n\n\n以指定时间显示（而不是当前时间）：\n\n```bash\ndate --date=\"2060/01/01 08:00:00\"\n```\n\n\n\n重新设定系统时间：\n\n```bash\ndate --set=\"2060/01/01 08:00:00\"\n```\n\n\n\n查看当前日期的时间戳：\n\n```bash\ndate +%s\n```\n\n\n\n查看指定日期的时间戳：\n\n```bash\ndate -d '2020-12-01 00:00:00' +%s\n```\n\n\n\n将时间戳转换为时间显示：\n\n```bash\ndate -d @1669345425\n```\n\n\n\n\n\n# Linux dmesg 命令 - 显示内核消息\n\n## 介绍\n\n**dmesg**（英文全拼：diagnostic messages）命令用于显示和控制 Linux 内核环形缓冲区中的信息。\n\nkernel 会将开机信息存储在 ring buffer 中。开机时来不及查看的信息，后续可利用 dmesg 来仔细查看。同时，开机信息也会保存在 /var/log/dmesg 文件里。\n\ndmesg 中的 'd' 通常被认为是 display 或 debug 的意思，但最开始的含义应该是 diagnostic，也就是诊断信息。\n\n**语法**：\n\n```shell\ndmesg [options]\n```\n\n\n\n**选项**：\n\n- `-c`, `--read-clear` ：显示信息后，清除 ring buffer 中的内容。\n- `-s`, `--buffer-size <size>` ：指定用于查询的缓冲区大小。预设置为 8196，刚好等于 ring buffer 的大小。\n- `-n`, `--console-level <level>` ：设置记录信息的层级。\n- `-k`, `--kernel` ：打印内核信息。\n- `-H`, `--human` ：以便于人类阅读的方式输出。\n\n## 示例\n\n输出所有诊断信息：\n\n```shell\ndmesg\n```\n\n\n\n上述命令输出的内容很多，不便于查看，可以加 `-H` 参数：\n\n```shell\ndmesg -H\n```\n\n\n\n通常可以使用管道配合其他工具查看，比如 more 分页显示：\n\n```shell\ndmesg | more\n```\n\n\n\n按关键词搜索：\n\n```shell\ndmesg | grep usb\n```\n\n\n\n忽略大小写搜索关键词：\n\n```shell\ndmesg | grep -i memory \n```\n\n\n\n显示开机信息的前20行：\n\n```shell\ndmesg | head -20\n```\n\n\n\n显示开机信息的最后20行：\n\n```shell\ndmesg | tail -20\n```\n\n\n\n清空 dmesg 环形缓冲区中的日志：\n\n```shell\ndmesg -c\n```\n\n\n\n\n\n# Linux uname 命令 - 显示系统信息\n\n## 介绍\n\n**uname** 是一个 Linux 命令，用于显示操作系统和内核的相关信息，包括内核名称、操作系统类型、内核版本等。它是一个非常有用的工具，可以快速获取关于系统的基本信息。\n\n**语法**：\n\n```shell\nuname [OPTION]...\n```\n\n\n\n**选项**：\n\n- `-a`, `--all`：显示所有信息，包括内核名称、主机名、内核版本、内核发布号、机器硬件名称、处理器类型、硬件平台和操作系统。\n- `-s`, `--kernel-name`：显示内核名称。\n- `-n`, `--nodename`：显示网络节点主机名。\n- `-r`, `--kernel-release`：显示内核发布号。\n- `-v`, `--kernel-version`：显示内核版本。\n- `-m`, `--machine`：显示机器硬件名称。\n- `-p`, `--processor`：显示处理器类型（有时是“unknown”）。\n- `-i`, `--hardware-platform`：显示硬件平台（有时是“unknown”）。\n- `-o`, `--operating-system`：显示操作系统名称。\n- `--help`：显示帮助信息并退出。\n- `--version`：显示版本信息并退出。\n\n## 示例\n\n显示所有信息：\n\n```bash\n$ uname -a\nLinux Latitude-3420 5.15.0-107-generic #117~20.04.1-Ubuntu SMP Tue Apr 30 10:35:57 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux\n```\n\n\n\n显示操作系统名称：\n\n```bash\n$ uname -o\nGNU/Linux\n```\n\n\n\n显示内核名称：\n\n```bash\n$ uname -s\nLinux\n```\n\n\n\n显示内核发布号：\n\n```bash\n$ uname -r\n5.15.0-107-generic\n```\n\n\n\n显示内核版本：\n\n```bash\n$ uname -v\n#117~20.04.1-Ubuntu SMP Tue Apr 30 10:35:57 UTC 2024\n```\n\n\n\n显示网络节点主机名：\n\n```bash\n$ uname -n\nLatitude-3420\n```\n\n\n\n显示机器硬件名称：\n\n```bash\n$ uname -m\nx86_64\n```\n\n\n\n显示处理器类型：\n\n```bash\n$ uname -p\nx86_64\n```\n\n\n\n显示硬件平台：\n\n```bash\n$ uname -i\nx86_64\n```\n\n\n\n\n\n# Linux hwclock 命令 - 显示/设置硬件时钟\n\n## 介绍\n\n**hwclock**（英文全拼：hardware clock）命令用于显示与设定硬件时钟（RTC）。\n\n在 Linux 系统中，有硬件时钟与系统时钟等两种时钟。硬件时钟保存在 RTC 中，由外置电池供电，系统掉电后仍会继续工作。在系统启动是，系统时钟会从硬件时钟获取，以便得到一个相对准确的时钟，之后系统时钟便独立工作，通常还会从 NTP 服务器同步更新时间。更新后的系统时间可以通过 hwclock 命令回写到硬件时钟。\n\n**语法**：\n\n```bash\nhwclock [function] [option...]\n```\n\n\n\n**功能**：\n\n- `-r`, `--show` ：读取硬件时钟，并按 ISO 8601 格式输出（默认功能）。\n- `--get` ：读取硬件时钟，等效于 `--show`。\n- `--set` ：根据 `--date` 选项给定的值设定硬件时钟。\n- `-s`, `--hctosys` ：从硬件时钟设定系统时钟。\n- `-w`, `--systohc` ：从系统时钟设定硬件时钟。\n- `-V`, `--version` ：显示版本信息并退出。\n- `-h`, `--help` ：显示帮助信息并退出。\n\n**选项**：\n\n- `-D`, `--debug` ：显示 hwclock 执行时详细的信息（该选项已过时，建议使用 `--verbose`）。\n- `--date=date_string` ：与 `--set` 功能一起使用，用于指定日期时间字符串。\n- `--delay=seconds` ：此选项允许在设置时钟时间时覆盖内部使用的延迟。rtc_cmos 的默认值为 0.5 (500ms)，对于其他 RTC 类型，延迟为 0。如果 RTC 类型无法确定（从 sysfs），那么它也默认为 0.5 以向后兼容。\n- `--directisa` ：hwclock 预设从 /dev/rtc 设备来存取硬件时钟。若无法存取时，可用此参数直接以 I/O 指令来存取硬件时钟。\n- `--test` ：仅测试程序，而不会实际更改硬件时钟。\n- `-l`, `--localtime` ：使用本地时间进行设置。\n- `-u`, `--utc` ：使用 UTC 时间进行设置。\n- `-v`, `--verbose` ：显示 hwclock 执行时详细的信息。\n\n注意：hwclock 命令的功能（function）是互斥的，同一时间只能指定一个功能；选项（option）则可以灵活使用。\n\n## 示例\n\n使用硬件时钟作为参考（看作 UTC 时间），设置系统时钟：\n\n```bash\nhwclock --utc --hctosys\n```\n\n\n\n将系统时钟回同步到硬件时钟（看作 UTC 时间）：\n\n```bash\nhwclock --utc --systohc\n```\n\n\n\n\n\n# Linux screen 命令 - 多窗口终端\n\n## 介绍\n\n**screen** 命令是一个多重视窗管理程序，这里的“视窗”是指一个全屏幕的文字模式画面。用户可以通过该软件同时连接多个本地或远程的命令行会话（通常是交互式 shell），并在其间自由切换。通常，在使用 [telnet](https://getiot.tech/linux-command/telnet/) 登入主机或是使用老式的终端机时，才有可能用到 screen 程序。\n\n使用前请确保你的系统上已经安装 screen 命令，如果未安装，可以参考下面安装方法：\n\n- Debian/Ubuntu\n- CentOS/RHEL\n\n```bash\nsudo apt install screen\n```\n\n\n\n**语法**：\n\n```bash\nscreen [-opts] [cmd [args]]\nscreen -r [host.tty]\n```\n\n\n\n**选项**：\n\n- `-A`：将所有的视窗都调整为目前终端机的大小。\n- `-d`：将指定的 screen 作业离线。\n- `-m`：即使目前已在作业中的 screen 作业，仍强制建立新的 screen 作业。\n- `-r [session]`：恢复离线的 screen 作业。\n- `-R`：先试图恢复离线的作业，若找不到离线的作业，即建立新的 screen 作业。\n- `-s <shell>`：指定建立新视窗时，所要执行的 shell。\n- `-S <sockname>`：指定 screen 作业的名称，使用 `<pid>.sockname` 代替 `<pid>.<tty>.<host>`。\n- `-x`：恢复之前离线的 screen 作业。\n- `-ls [match]`：显示目前所有的 screen 作业。\n- `-list`：显示目前所有的 screen 作业。\n- `-wipe`：检查目前所有的 screen 作业，并删除已经无法使用的 screen 作业。\n- `-v`：显示版本信息。\n\n## 示例\n\n**创建窗口**\n\n直接输入 screen，创建一个新的窗口：\n\n```bash\nscreen\n```\n\n\n\n但是这样启动的 screen 会话没有名字，实践上推荐为每个 screen 会话取一个名字方便分辨，例如：\n\n```bash\nscreen -S getiot\n```\n\n\n\nscreen 启动后，会创建第一个窗口，也就是窗口 No. 0，并在其中打开一个系统默认的 shell（一般是 bash）。当执行 `screen` 命令之后，会立刻又返回到命令提示符，仿佛什么也没有发生似的，其实你已经进入 screen 的世界了。（执行 `exit` 退出 screen 窗口）\n\n也可以在 screen 命令之后加入你喜欢的参数，使之直接打开你指定的程序，例如：\n\n```bash\nscreen vi getiot.txt\n```\n\n\n\nscreen 创建一个执行 `vi getiot.txt` 的单窗口会话，退出 vi 将退出该窗口/会话。\n\n**查看窗口**\n\n打开多个窗口后，可以使用快捷键 `Ctrl`+`A` 再按 `W` 列出当前所有窗口。如果使用文本终端，这个列表会列在屏幕左下角，如果使用 X 环境下的终端模拟器，这个列表会列在标题栏里。窗口列表一般像下面这样：\n\n```bash\n0$ bash  1-$ bash  2*$ bash  \n```\n\n\n\n这个例子中，我们开启了三个窗口，其中 `*` 号表示当前位于窗口 2，`-` 号表示上一次切换窗口时位于窗口 1。\n\n**会话分离与恢复**\n\n你可以不中断 screen 窗口中程序的运行而暂时断开（detach）screen 会话，并在随后时间重新连接（attach）该会话，重新控制各窗口中运行的程序。例如，我们打开一个 screen 窗口编辑 /tmp/getiot.txt 文件：\n\n```bash\nscreen vi /tmp/getiot.txt\n```\n\n\n\n之后我们想暂时退出做点别的事情，比如出去散散步，那么在 screen 窗口键入 `Ctrl`+`A` 再按 `D`，screen 会给出 detached 提示：\n\n```bash\n[detached from 35507.getiot]\n```\n\n\n\n半个小时之后回来了，找到该 screen 会话：\n\n```bash\n$ screen -ls\nThere is a screen on:\n\t35507.getiot\t(2024年02月23日 15时55分40秒)\t(Detached)\n1 Socket in /run/screen/S-rudy.\n```\n\n\n\n重新连接会话：\n\n```shell\nscreen -r 35507\n```\n\n\n\n或者：\n\n```bash\nscreen -r 35507.getiot\n```\n\n\n\n会话中的一切都还在。\n\n当然，如果你在另一台机器上没有分离一个 screen 会话，就无从恢复会话了。这时可以使用下面命令强制将这个会话从它所在的终端分离，转移到新的终端上来：\n\n**清除 dead 会话**\n\n如果由于某种原因其中一个会话死掉了（例如人为杀掉该会话），这时 `screen -ls` 会显示该会话为 dead 状态。可以使用下面命令清除该会话：\n\n```bash\nscreen -wipe\n```\n\n\n\n**关闭或杀死一个 screen 会话**\n\n正常情况下，当你退出一个窗口中最后一个程序（通常是 bash）后，这个窗口就关闭了。另一个关闭窗口的方法是使用 `Ctrl`+`A` 键，然后按下 `K` 键，最后当提示你是否要杀死这个会话时按下 `Y` 键，这个快捷键会杀死当前的窗口，同时也将杀死这个窗口中正在运行的进程。\n\n如果一个 screen 会话中最后一个窗口被关闭了，那么整个 screen 会话也就退出了，screen 进程会被终止。\n\n\n\n# Linux fbset 命令 - 帧缓冲设置\n\n## 介绍\n\n**fbset**（英文全拼：framebuffer set）命令用于显示或设置 Linux 系统中帧缓冲区的大小，同时还兼具调整画面的分辨率、位置、高低宽窄、色彩深度等功能，并可决定是否启动显卡的各项硬件特性。\n\n提示\n\n所谓的“帧缓冲设备”就是一块用于图形显示的内存区域，使用 `fbset` 命令可以查看和更改与该设备相关的设置。\n\n帧缓冲设备提供了一个简单而独特的接口来访问不同类型的图形显示，可通过位于 /dev 目录中的特殊设备节点进行访问，这些节点的命名方案始终为 `fb<n>`，其中 n 是所使用的帧缓冲区设备的编号。\n\nfbset 使用位于 /etc/fb.modes 中的自己的视频模式数据库，该数据库中可以定义无限数量的视频模式。\n\n**语法**：\n\n```bash\nfbset [options] [mode]\n```\n\n\n\n**选项**：\n\n- `-a, --all`：改变所有使用该设备之虚拟终端机的显示模式。\n- `-db <信息文件>`：指定显示模式的信息文件，预设值文件名称为 fb.modes，存放在/etc目录下\n- `-fb <外围设备代号>`：指定用来做为输出帧缓冲区的外围设备，预设置为 `/dev/fd0`。\n- `-h, -help`：显示帮助信息。\n- `-i, --info`：列出所有帧缓冲区的相关信息。\n- `-ifb <外围设备代号>`：使用另一个帧缓冲区外围设备的设置值。\n- `-n, --now`：马上改变显示模式。\n- `-ofb <外围设备代号>`：该选项参数效果和指定 `-fb` 参数相同。\n- `-s, --show`：列出目前显示模式之设置。\n- `-v, --verbose`：显示指令执行过程。\n- `-V, --version`：显示版本信息。\n- `-x, --xfree86`：使用 XFree86 兼容模式。\n- `--test`：仅做测试，并不改变现行的显示模式。\n\n## 示例\n\n要设置 X 窗口系统使用的视频模式，请在 rc.local 中插入以下内容：\n\n```bash\nfbset -fb /dev/fb0 640x480-60\n```\n\n\n\n并使 X 窗口系统知道所使用的帧缓冲设备：\n\n```bash\nexport FRAMEBUFFER=/dev/fb0\n```\n\n\n\n\n\n# Linux insmod 命令 - 加载内核模块\n\n## 介绍\n\n**insmod**（英文全拼：install module）命令用于将模块载入 Linux 内核。\n\nLinux 是一个允许用户在运行时加载内核模块以扩展内核功能的操作系统，LKM（Loadable Kernel Modules，可加载内核模块）通常用于添加对新硬件（作为设备驱动程序）和文件系统的支持，或用于增加系统调用。insmod 命令将带有/不带参数的内核目标文件（.ko）载入内核。\n\n**语法**：\n\n```shell\ninsmod [filename] [module options...]\n```\n\n\n\n**选项**：\n\n- `-V`, `--version` ：显示版本信息。\n- `-h`, `--help` ：显示帮助信息。\n\n**参数**：模块文件名（可带参数）\n\n## 示例\n\n将当前目录下的 getiot.ko 模块载入内核：\n\n```shell\nsudo insmod getiot.ko\n```\n\n\n\n执行 insmod 命令需要 root 权限，因此需要添加 sudo，可通过 dmesg 命令查看内核模块的打印信息。\n\n指定模块载入内核：\n\n```shell\nsudo insmod /home/rudy/getiot.ko\n```\n\n\n\n加载内核模块时传入参数：\n\n```shell\nsudo insmod getiot.ko user=\"Rudy\"\n```\n\n\n\n上述命令后面带的参数将传递给运行的内核模块，至于接收和使用什么参数则取决于该模块是怎么写的。\n\n\n\n# Linux lsmod 命令 - 列出加载模块\n\n## 介绍\n\n**lsmod**（英文全拼：list modules）命令用于显示已经加载到内核中的模块的状态信息。\n\n由于 Linux 操作系统内核支持模块化的特性，因此在编译内核时，无须把全部的功能都编译进内核，可以将这些功能编译成一个个单独的模块，待需要时再分别载入。\n\n实际上，lsmod 的工作原理是从 /proc/modules 文件读取当前已加载的内核模块的信息，再以更方便用户阅读的格式显示。因此，lsmod 命令的用法很简单，不需要任何选项参数。\n\n## 示例\n\n查看当前系统已加载的内核模块\n\n```bash\n$ lsmod\nModule                  Size  Used by\nrfcomm                 81920  4\ncmac                   16384  3\nalgif_hash             16384  1\nalgif_skcipher         16384  1\naf_alg                 28672  6 algif_hash,algif_skcipher\nbnep                   24576  2\nbinfmt_misc            24576  1\namdgpu               5214208  0\niommu_v2               20480  1 amdgpu\ngpu_sched              36864  1 amdgpu\nsnd_hda_codec_hdmi     61440  1\nintel_rapl_msr         20480  0\nintel_rapl_common      28672  1 intel_rapl_msr\n......\n```\n\n\n\n如果内核模块很多，不利于阅读，可以配合 [grep](https://getiot.tech/linux-command/grep/) 等命令进行过滤。\n\n比如查看是否已加载 coretemp 模块\n\n```bash\n$ lsmod | grep coretemp\ncoretemp               20480  0\n```\n\n\n\n\n\n# Linux rmmod 命令 - 移除内核模块\n\n## 介绍\n\n**rmmod**（英文全拼：remove module）命令用于移除已载入内核的模块。\n\n**语法**：\n\n```shell\nrmmod [options] modulename\n```\n\n\n\n**选项**：\n\n- `-f`, `--force` ：强制移除模块，使用此选项比较危险。\n- `-s`, `--syslog` ：将错误信息输出至 syslog 服务，而标准输出。\n- `-v`, `--verbose` ：显示指令执行的详细信息。\n\n**参数**：模块名\n\n## 示例\n\n卸载 getiot.ko 模块（模块名不需要带后缀）\n\n```shell\nrmmod getiot\n```\n\n\n\n卸载 getiot 模块并显示执行信息\n\n```shell\nrmmod -v getiot\n```\n\n\n\n卸载 getiot 模块并将错误信息写入 syslog\n\n```shell\nrmmod -s getiot\n```\n\n\n\n删除正在使用的 getiot 模块（谨慎使用）\n\n```shell\nrmmod -f getiot\n```\n\n\n\n\n\n# Linux modinfo 命令 - 显示模块信息\n\n## 介绍\n\n**modinfo**（英文全拼：module information）命令用于显示指定的 Linux 内核模块的相关信息。\n\n默认情况下，为了便于阅读，会以 `fieldname : value` 的格式列出模块的每个属性。\n\n**语法**：\n\n```bash\nmodinfo [-0] [-F field] [modulename|filename...]\n```\n\n\n\n**选项**：\n\n- `-F`, `--field` ：仅在一行上显示 field 值，这对于脚本较为有用。常用的 field 有 author、description、licence、param、depends、alias、filename。\n- `-0`, `--null` ：使用 ASCII 码的 `0` 字符分隔 field 值，而不是一个换行符。（该选项对脚本比较有用）\n- `-a`、`-d`、`-l`、`-p`、`-n` ：这些分别是 author、description、license、param、filename 的简短形式，用于显示对应的信息。\n- `-V`, `--version` ：显示版本信息。\n\n**参数**：模块名或文件名。如果使用模块名，而没有指定文件名，则会在 `/lib/modules/$(uname -r)` 目录中搜索，就像 [modprobe](https://getiot.tech/linux-command/modprobe/) 一样。\n\n## 示例\n\n显示 sg 模块（SCSI generic 驱动）的信息\n\n```bash\nmodinfo sg \n```\n\n\n\n显示 sg 模块的开发人员信息\n\n```bash\nmodinfo -a sg\n```\n\n\n\n显示 sg 模块的描述信息\n\n```bash\nmodinfo -d sg\n```\n\n\n\n显示 sg 模块的许可信息\n\n```bash\nmodinfo -l sg\n```\n\n\n\n显示 sg 模块所支持的参数\n\n```bash\nmodinfo -p sg\n```\n\n\n\n\n\n# Linux modprobe 命令 - 自动加载模块\n\n## 介绍\n\n**modprobe**（英文全拼：modules probe）命令用于智能地向内核中加载模块或者从内核中移除模块。\n\nmodprobe 可载入指定的个别模块，或是载入一组相依的模块。modprobe 会根据 [depmod](https://getiot.tech/linux-command/depmod/) 所产生的相依关系，决定要载入哪些模块。若在载入过程中发生错误，则 modprobe 会卸载整组的模块。需要注意的是为了方便，模块名中的 `-` 和 `_` 是没有区别的。\n\nmodprobe 命令会查找 `/lib/modules/'uname -r'` 目录中的模块和文件 (`uname -r` 是内核版本），但是不会查找 `/etc/modprobe.conf` 和 `/etc/modprobe.d/` 目录下配置所排除的内容。\n\nmodprobe 命令不会修改模块内容，解析模块内容和使用模块参数是在内核中进行的，所以如果模块装载失败，内核会将失败的日志通过 dmesg 打印出来。\n\n**语法**：\n\n```bash\nmodprobe [options] modulename\nmodprobe [options] -a modulename [modulename...]\n```\n\n\n\n**选项**：\n\n- `-a`, `--all` ：载入全部的模块。\n- `-c`, `--show-conf` ：显示所有模块的设置信息。\n- `-d`, `--debug` ：使用排错模式。\n- `-l`, `--list` ：显示可用的模块。\n- `-r`, `--remove` ：模块闲置不用时，即自动卸载模块。\n- `-t`, `--type` ：指定模块类型。\n- `-v`, `--verbose` ：执行时显示详细的信息。\n- `-V`, `--version` ：显示版本信息。\n- `-h` ：显示帮助。\n\n**参数**：模块名（使用 `-a` 选项可以接多个模块名）\n\n## 示例\n\n查看 modules 的配置文件：\n\n```bash\nmodprobe -c\n```\n\n\n\n这里，可以查看 modules 的配置文件，比如模块的 alias 别名是什么等，会打印许多行信息。\n\n加载 spidev 模块：\n\n```bash\nsudo modprobe spidev\n```\n\n\n\n卸载 spidev 模块：\n\n```bash\nsudo modprobe -r spidev\n```\n\n\n\n\n\n# Linux depmod 命令 - 处理模块依赖\n\n## 介绍\n\n**depmod**（英文全拼：dependency modules）命令用于分析可载入模块的相依性，生成内核模块及其关联映射文件的依赖关系描述列表。\n\n执行 depmod 命令将分析 `/lib/modules/'uname -r'` 目录中的内核模块（`uname -r` 是内核版本），并根据模块集中存在的符号创建一个类似于 Makefile 的依赖文件，名为 modules.dep。通常在构建嵌入式系统时，需要由这个命令来生成相应的文件，供 [modprobe](https://getiot.tech/linux-command/modprobe/) 在安装模块时使用。\n\n实际上，depmod 和 modprobe 命令工具简化了 Linux 模块化内核，方便系统维护人员进行管理。\n\n**语法**：\n\n```shell\ndepmod [options]\n```\n\n\n\n详细语法格式\n\n```shell\ndepmod [ -a ] [ -b basedir ] [ -e ] [ -F System.map ] [ -n ] [ -v ] [ version ] [ -A ]\n       [-n] [-v] [-A] [-P prefix] [-w] [version]\n\ndepmod [-e] [-E Module.symvers] [-F System.map] [-m] [-n] [-v] [-P prefix]\n       [-w] [version] [filename...][Tex]\n```\n\n\n\n**选项**：\n\n- `-a`, `--all` ：分析所有可用的模块；\n- `-d`, `debug` ：执行排错模式；\n- `-e` ：输出无法参照的符号；\n- `-i` ：不检查符号表的版本；\n- `-s`, `--system-log` ：在系统记录中记录错误；\n- `-v`, `--verbose` ：执行时显示详细的信息；\n- `-V`, `--version` ：显示版本信息；\n- `--help` ：显示帮助。\n\n## 示例\n\n从默认位置检索模块文件，之后就可以将其载入内核\n\n```shell\nsudo ln -s /path/to/your-kernel-module.ko /lib/modules/`uname -r`\nsudo depmod -a\nsudo modprobe your-kernel-module\n```\n\n\n\n\n\n# Linux neofetch 命令 - 系统信息展示\n\n## 介绍\n\n**Neofetch** 是一个快速、高度可定制的系统信息脚本，用 Bash 编写。主要用于系统信息的截图，支持 Linux、BSD、Mac OS X、iOS 和 Windows 操作系统。\n\nNeofetch 会收集有关系统软硬件的信息，并在终端中显示结果。默认情况下，系统信息将与操作系统的 logo 一起显示。你可以进一步地自定义使用 ascii 图像或其他任何图片，还可以配置 Neofetch 显示的信息、信息的显示位置和时间。\n\nNeofetch 通常不会预先安装，但可在大多数 Linux 发行版的默认仓库中找到。例如，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install neofetch\n```\n\n\n\n## 示例\n\n在我的 Ubuntu 上直接执行 `neofetch`，输出结果如下：\n\n![img](./Image/Linux命令大全.assets/neofetch.png)\n\n列出的信息包括：\n\n- OS：已安装操作系统的名称\n- Host：笔记本型号\n- Kernel：内核详细信息\n- Uptime：系统运行时间\n- Packages：默认和其他软件包管理器安装的软件数量\n- Shell：默认 shell\n- Resolution：屏幕分辨率\n- DE：桌面环境\n- WM：窗口管理器\n- WM Theme：窗口管理器的主题\n- Theme：系统主题\n- Icons：系统图标\n- Terminal：默认终端\n- CPU：CPU 类型\n- GPU：GPU 类型\n- Memory：已安装的内存\n\n\n\n# Linux who 命令 - 显示当前登录用户\n\n## 介绍\n\n**who** 命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。\n\n**语法**：\n\n```shell\nwho [OPTION]... [ FILE | ARG1 ARG2 ]\n```\n\n\n\n**选项**：\n\n- `-a`, `--all` ：等价于 `-b -d --login -p -r -t -T -u`。\n- `-b`, `--boot` ：显示最近一次系统启动的时间。\n- `-H`, `--heading` ：打印行头标题。\n- `-q`, `--count` ：只显示登录的账户名称和总人数。\n- `-r`, `--runlevel` ：打印当前运行等级。\n- `-s`, `--short` ：简短输出，只打印账户名称、线路和时间。\n- `-u`, `--users` ：列出登录的所有用户。\n- `--help` ：显示帮助信息。\n- `--version` ：显示版本信息。\n\n**参数**：如果没有指定 FILE，则默认使用 /var/run/utmp。\n\n## 示例\n\n显示当前系统登录的用户\n\n```shell\nwho\n```\n\n\n\n显示当前系统登录的用户，并显示标题栏\n\n```shell\nwho -H\n```\n\n\n\n显示系统启动时间\n\n```shell\nwho -b\n```\n\n\n\n精简模式显示\n\n```shell\nwho -q\n```\n\n\n\n\n\n# Linux whoami 命令 - 显示当前用户\n\n## 介绍\n\n在 Linux 系统中，**whoami** 命令可用于打印与当前有效用户 ID 关联的用户名。这个工具可以用来获取本地系统上当前用户（访问令牌）的用户名和组信息，以及相应的安全标识符（SID）、声明、本地系统上当前用户的权限、登录标识符（登录 ID）。\n\n提示\n\nwhoami 命令显示自身的用户名称，本指令相当于执行 `id -un` 指令。\n\n**语法**：\n\n```bash\nwhoami [OPTION]...\n```\n\n\n\n**选项**：\n\n- `--help`：显示帮助信息。\n- `--version`：显示版本信息。\n\n## 示例\n\n查询当前登录的用户名：\n\n```bash\nwhoami\n```\n\n\n\n\n\n# Linux whois 命令 - 查询域名信息\n\n## 介绍\n\n**whois** 命令用来查找并显示指定用户账号、域名相关信息，包括域名注册时间、拥有者、邮箱等。\n\n使用前请确保你的系统上已经安装 whois 工具，在 Debian/Ubuntu 系统上可以使用如下命令进行安装：\n\n```bash\n$ sudo apt install whois\n```\n\n\n\n**语法**：\n\n```bash\nwhois [OPTION]... OBJECT...\n```\n\n\n\n**选项**：\n\n- `-a`：搜寻所有数据库。\n- `-c`：找到最小的包含一个 mnt-irt 属性的匹配。\n- `-d`：同时返回 DNS 反向查询的代理对象（需支持 RPSL 协议）。\n- `-F`：快速输出原始数据。\n- `-H`：隐藏法律声明内容。\n- `-i ATTR`：进行一次反向查询。\n- `-l`：将精确度降低一级的查询（需支持 RPSL 协议）。\n- `-L`：找到所有低精确度匹配。\n- `-m`：找到第一级较高精确度匹配。\n- `-M`：找到所有较高精确度匹配。\n- `-r`：查询联系信息时关闭递归查询。\n- `-R`：显示本地域名对象副本。\n- `-x`：精确匹配。\n- `-h[主机]`：连接到指定 HOST 服务器。\n- `-p[端口]`：连接到指定 PORT 端口。\n- `-t[类型]`：查询指定类型对象头信息。\n- `-T[类型]`：查找指定类型的对象。\n- `-v[类型]`：查询指定类型对象冗余信息。\n- `-q [版本|类型]`：查询特定的服务器信息（需支持 RPSL 协议）。\n\n## 示例\n\n显示指定用户信息：\n\n```bash\nwhois root\n```\n\n\n\n查询域名描述信息：\n\n```bash\nwhois getiot.tech\n```\n\n\n\n查询域名信息省略法律声明：\n\n```bash\nwhois -H getiot.tech\n```\n\n\n\n指定端口查询：\n\n```bash\nwhois -p 80 getiot.tech\n```\n\n\n\n\n\n# Linux watch 命令 - 重复执行命令\n\n## 介绍\n\n**watch** 命令用于在 Linux 系统中周期性地执行一个程序，并全屏显示该程序的输出信息。\n\n默认的，watch 命令会以 2 秒一次的频率重复运行参数中指定的命令，直到运行被中断。\n\n**语法**：\n\n```bash\nwatch [options] command\n```\n\n\n\n**选项**：\n\n- `-d`, `–differences` ：以高亮的形式显示出两次更新不同的部分，方便用户查看更改。\n- `-n`, `–interval seconds` ：指定更新间隔，允许的最小时间间隔是 0.1 秒。\n- `-p`, `–precise` ：尝试以 interval 间隔运行参数中的命令（默认间隔为 2 秒）。\n- `-t`, `–no-title` ：不显示头部信息，包括运行间隔、运行命令、当前时间等信息。\n- `-b`, `–beep` ：当命令异常退出时，发出蜂鸣声。\n- `-e`, `–errexit` ：冻结命令错误的更新，并在按键后退出。\n- `-g`, `–chgexit` ：当命令输出更改时，退出执行。\n- `-c`, `–color` ：解释 ANSI 颜色和样式。\n- `-x`, `–exec` ：此选项提供给 `sh -c`，这意味着您可能需要使用额外的引号才能获得所需的效果。\n\n**参数**：command 命令及其选项参数\n\n## 示例\n\n周期显示系统内存使用情况，并高亮显示差异\n\n```bash\nwatch -d  free -m\n```\n\n\n\n每秒刷新一次\n\n```bash\nwatch -n 1 free -m\n```\n\n\n\n不显示头部信息\n\n```bash\nwatch -t free -m\n```\n\n\n\n\n\n# Linux su 命令 - 切换用户身份\n\n## 介绍\n\n在 Linux 系统中，**su**（英文全拼：substitute user）命令用于切换当前用户身份到指定用户，或者以指定用户的身份执行命令或程序。\n\n普通用户切换到 root 用户，可以使用 `su --` 或 `su root`，但是必须输入 root 密码才能完成切换。root 用户切换到普通用户，可以使用 `su <username>`，不需要输入任何密码即可完成切换。\n\n**语法**：\n\n```bash\nsu [options] [-] [user [argument...]]\n```\n\n\n\n**选项**：\n\n- `-c, --command`：执行完指定的指令后，即恢复原来的身份。\n- `-f, --fast`：适用于 csh 与 tsch，使 shell 不用去读取启动文件。\n- `-l, --login`：改变身份时，也同时变更工作目录，以及 HOME、SHELL、USER、logname，此外，也会变更 PATH 变量。\n- `-m, -p, --preserve-environment`：变更身份时，不要变更环境变量。\n- `-s, --shell`：指定要执行的 shell。\n- `--help`：显示帮助信息。\n- `--version`：显示版本信息。\n\n## 示例\n\n切换到 getiot 用户，但环境变量仍然是当前用户的：\n\n```bash\nsu getiot\n```\n\n\n\n切换到 getiot 用户，并改变为 getiot 用户环境变量：\n\n```bash\nsu - getiot\n```\n\n\n\n\n\n# Linux sudo 命令 - 以超级用户执行\n\n## 介绍\n\n在 Linux 系统中，**sudo** 是一种权限管理机制，管理员可以授权于一些普通用户去执行一些 root 执行的操作，而不需要知道 root 的密码。\n\nsudo 允许一个已授权用户以超级用户或者其它用户的角色运行一个命令。当然，能做什么不能做什么都是通过安全策略来指定的。sudo 支持插件架构的安全策略，并能把输入输出写入日志。第三方可以开发并发布自己的安全策略和输入输出日志插件，并让它们无缝的和 sudo 一起工作。默认的安全策略记录在 /etc/sudoers 文件中。而安全策略可能需要用户通过密码来验证他们自己。也就是在用户执行 sudo 命令时要求用户输入自己账号的密码。如果验证失败，sudo 命令将会退出。\n\n**语法**：\n\n```bash\nsudo -h | -K | -k | -V\nsudo -v [-AknS] [-g group] [-h host] [-p prompt] [-u user]\nsudo -l [-AknS] [-g group] [-h host] [-p prompt] [-U user] [-u user] [command]\nsudo [-AbEHknPS] [-r role] [-t type] [-C num] [-g group] [-h host] [-p prompt] [-T timeout] [-u user] [VAR=value] [-i|-s] [<command>]\nsudo -e [-AknS] [-r role] [-t type] [-C num] [-g group] [-h host] [-p prompt] [-T timeout] [-u user] file ...\n```\n\n\n\n**选项**：\n\n- `-A, --askpass`：使用助手程序进行密码提示。\n- `-b, --background`：在后台运行命令。\n- `-B, --bell`：出现提示时按响铃。\n- `-C, --close-from=num`：关闭所有 >= num 的文件描述符。\n- `-E, --preserve-env`：在执行命令时保留用户环境。\n- `--preserve-env=list`：保留特定的环境变量。\n- `-e, --edit`：编辑文件而非执行命令。\n- `-g, --group=group`：以指定的用户组或 ID 执行命令。\n- `-H, --set-home`：将 HOME 变量设为目标用户的主目录。\n- `-h, --help`：显示帮助信息。\n- `-h, --host=host`：在主机上运行命令（如果插件支持）。\n- `-i, --login`：以目标用户身份运行一个登录 shell；可同时指定一条命令。\n- `-K, --remove-timestamp`：完全移除时间戳文件。\n- `-k, --reset-timestamp`：无效的时间戳文件。\n- `-l, --list`：列出用户权限或检查某个特定命令；对于长格式，使用两次。\n- `-n, --non-interactive`：非交互模式，不提示。\n- `-P, --preserve-groups`：保留组向量，而非设置为目标的组向量。\n- `-p, --prompt=prompt`：使用指定的密码提示。\n- `-r, --role=role`：以指定的角色创建 SELinux 安全环境。\n- `-S, --stdin`：从标准输入读取密码。\n- `-s, --shell`：以目标用户运行 shell；可同时指定一条命令。\n- `-t, --type=type`：以指定的类型创建 SELinux 安全环境。\n- `-T, --command-timeout=timeout`：在超出指定时间后终止命令。\n- `-U, --other-user=user`：在列表模式中显示用户的权限。\n- `-u, --user=user`：以指定用户或 ID 运行命令（或编辑文件）。\n- `-V, --version`：显示版本信息。\n- `-v, --validate`：更新用户的时间戳而不执行命令。\n- `--`：停止处理命令行参数。\n\n## 示例\n\n切换到 root 用户：\n\n```bash\nsudo su\n```\n\n\n\n指定用户执行命令：\n\n```bash\nsudo -u getiot ls -l\n```\n\n\n\n以 root 权限执行上一条命令：\n\n```bash\nsudo !!\n```\n\n\n\n列出目前的权限：\n\n```bash\nsudo -l\n```\n\n\n\n列出 sudo 的版本信息：\n\n```bash\nsudo -V\n```\n\n\n\n\n\n# Linux id 命令 - 显示用户 ID 信息\n\n## 介绍\n\n**id** 命令可以显示真实有效的用户 ID（UID）和组 ID（GID）。UID 是对一个用户的单一身份标识。组 ID（GID）则对应多个 UID。id 命令已经默认预装在大多数 Linux 系统中。要使用它，只需要在你的控制台输入 id。\n\n当我们想知道某个用户的 UID 和 GID 时，id 命令是非常有用的。一些程序可能需要 UID/GID 来运行。id 使我们更加容易地找出用户的 UID 以 GID 而不必在 /etc/group 文件中搜寻。\n\n**语法**：\n\n```bash\nid [OPTION]... [USER]\n```\n\n\n\n**选项**：\n\n- `-g`, `--group` ：显示用户所属群组的 ID。\n- `-G`, `--groups` ：显示用户所属附加群组的 ID。\n- `-n`, `--name` ：显示用户，所属群组或附加群组的名称。\n- `-r`, `--real` ：显示实际 ID（UID）。\n- `-u`, `--user` ：显示用户 ID（EUID）。\n- `--help` ：显示帮助。\n- `--version` ：显示版本信息。\n\n## 示例\n\n不带选项输入 id 会显示如下，结果会使用活跃用户：\n\n```bash\n$ id\nuid=1000(rudy) gid=1000(rudy) groups=1000(rudy),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),131(lxd),132(sambashare)\n```\n\n\n\n解释：用户 rudy 的用户 ID 是 1000，组 ID 是 1000。同时，用户 rudy 是下面组的成员：\n\n- rudy 组（GID = 1000）\n- adm 组（GID = 4）\n- cdrom 组（GID = 24）\n- sudo 组（GID = 27）\n- dip 组（GID = 30）\n- plugdev 组（GID = 46）\n- lpadmin 组（GID = 120）\n- lxd 组（GID = 131）\n- sambashare 组（GID = 132）\n\n输出所有不同的组 ID（包括有效的、真实的和补充的）：\n\n```bash\n$ id -G\n1000 4 24 27 30 46 120 131 132\n```\n\n\n\n结果只会显示 GID 号。你可以和 `/etc/group` 文件比较。下面是 `/etc/group` 文件的示例内容：\n\n只输出有效的组 ID：\n\n```bash\n$ id -g\n1000\n```\n\n\n\n输出特定用户信息：\n\n```bash\n$ id mysql\nuid=112(mysql) gid=116(mysql) groups=116(mysql)\n```\n\n\n\n\n\n# Linux type 命令 - 显示命令类型\n\n## 介绍\n\n**type** 命令用于显示指定命令的类型，判断给出的指令是内部指令还是外部指令。\n\n**语法**：\n\n```shell\ntype [-afptP] NAME [NAME ...]\n```\n\n\n\n**选项**：\n\n- `-a` ：显示所有包含名称为 NAME 的可执行文件的位置；包括别名、内建和函数。仅当 `-p` 选项没有使用时\n\n- `-f` ：抑制 shell 函数查询\n\n- `-P` ：为每个 NAME 名称惊醒 PATH 路径搜索（显示绝对路径），即使它是别名、内建或函数，并且返回将被执行的磁盘上文件的名称。\n\n- `-p` ：返回将被执行的磁盘上文件的名称，或者当 `type -t NAME` 不返回 `file` 时，不返回任何值。\n\n- ```\n  -t\n  ```\n\n   \n\n  ：返回下列词中的任何一个：\n\n  - `alias` ：别名。\n  - `keyword` ：关键字，Shell 保留字。\n  - `function` ：函数，Shell 函数。\n  - `builtin` ：内建命令，Shell 内建命令。\n  - `file` ：文件，磁盘文件，外部命令。\n  - `unfound` ：没有找到。\n\n**参数**：NAME，将要解析的命令。\n\n## 示例\n\n别名\n\n```shell\n$ type ls\nls is aliased to `ls --color=tty'\n```\n\n\n\nShell 关键字\n\n```shell\n$ type if\nif is a shell keyword\n```\n\n\n\nShell 内建命令\n\n```shell\n$ type cd\ncd is a shell builtin\n```\n\n\n\n一般文件（外部命令）\n\n```shell\n$ type date\ndate is /bin/date\n```\n\n\n\n```shell\n$ type mysql\nmysql is /usr/bin/mysql\n```\n\n\n\n没有找到\n\n```shell\n$ type nginx\n-bash: type: nginx: not found\n```\n\n\n\n\n\n# Linux history 命令 - 显示命令历史\n\n## 介绍\n\n**history** 命令用于列出当前用户的历史操作记录。可带数字参数用于指定需要查看的最近的命令条目。\n\nhistory 的工作原理是启动 Shell 时读取环境变量 `HISTFILE` 文件（默认是 ~/.bash_history）中的历史记录，存储在相应内存的缓冲区中，以便于用户可以通过上下方向键或符号 `!` 指定序号查找历史命令。用户在 Shell 中的所有操作记录都会存储在缓冲区中，直到退出 Shell，或者显式执行回写。\n\n除了 `HISTFILE` 变量，history 命令还受如下一些环境变量影响：\n\n- `HISTSIZE` ：该变量用于控制存储历史命令的条目数量，默认为 1000，即仅能够存储 1000 条历史命令。\n- `HISTFILESIZE` ：控制历史记录文件中的最大个数。\n- `HISTIGNORE` ：设置哪些命令不记录到历史记录。\n- `HISTTIMEFORMAT` ：设置历史命令显示的时间格式。\n- `HISTCONTROL` ：扩展的控制选项。比如 ignorespace 表示忽略空格开头的命令，ignoredups 表示忽略连续重复命令，ignoreboth 表示上述两个参数都设置。\n\n**语法**：\n\n```bash\nhistory [选项] [参数]\n```\n\n\n\n**选项**：\n\n- `-c` ：清空当前历史命令。\n- `-a` ：将历史命令缓冲区中命令写入历史命令文件中。\n- `-r` ：将历史命令文件中的命令读入当前历史命令缓冲区。\n- `-w` ：将当前历史命令缓冲区命令写入历史命令文件中。\n\n**参数**：打印最近的 n 条历史命令。\n\n## 示例\n\n显示最近使用的10条历史命令\n\n```bash\nhistory  10\n```\n\n\n\n将当前缓冲区中的历史命令写入历史命令文件（~/.bash_history）\n\n```bash\nhistory  -w\n```\n\n\n\n\n\n# Linux last 命令 - 显示登录记录\n\n## 介绍\n\n**last** 命令用于显示 Linux 系统近期用户或终端的登录情况，通过查看系统记录的日志文件内容，进而使管理员可以获知谁曾经或者企图连接系统。\n\n执行 last 命令时，它会读取 /var/log/wtmp 文件，并把该文件记录的登录系统或终端的用户名单全部显示出来。默认显示 /var/log/wtmp 的记录，/var/log/btmp 能显示的更详细，可以显示远程登录，例如 ssh 登录。\n\n相关命令：[uptime](https://getiot.tech/linux-command/uptime/)，[who](https://getiot.tech/linux-command/who/)\n\n**语法**：\n\n```bash\nlast [options] [username...] [tty...]\n```\n\n\n\n**选项**：\n\n- `-R`, `--nohostname` ：省略 hostname 的栏位。\n- `-f`, `--file <file>` ：指定文件以替代默认的 /var/log/wtmp。\n- `-F`, `--fulltimes` ：显示完整的登录和登出时间和日期。\n- `-n`, `--limit number` ：显示最近的 number 行记录。\n- `username` ：显示 username 的登录信息。\n- `-x`, `--system` ：显示系统关机条目和运行级别更改信息。\n\n## 示例\n\n简略显示最新的5行记录\n\n```bash\nlast -n 5 -R\n```\n\n\n\n使用 /var/log/btmp 文件\n\n```bash\nsudo last -f /var/log/btmp\n```\n\n\n\n显示系统历史启动的时间\n\n```bash\nlast -x reboot\n```\n\n\n\n只查看最后一次系统启动的时间\n\n```bash\nlast -x reboot | head -1\n```\n\n\n\n显示系统历史关机时间\n\n```bash\nlast -x shutdown\n```\n\n\n\n只查看最后一次系统关机的时间\n\n```bash\nlast -x shutdown | head -1\n```\n\n\n\n\n\n# Linux lscpu 命令 - 显示 CPU 架构信息\n\n## 介绍\n\n**lscpu**（英文全拼：list cpu）命令用来显示 CPU 的相关信息。\n\n该命令从 sysfs 和 /proc/cpuinfo 收集 cpu 体系结构信息，再以易读的格式输出，输出的信息包含 cpu 数量、核心数、线程数、套接字 和 NUMA（Non-Uniform Memory Access）、缓存等。但并不一定所有的字段都有数据显示，这和所支持的 CPU 架构有关系，如果指定了不支持的字段，那么 lscpu 将打印字段名，但不显示数据。\n\n**语法**：\n\n```bash\nlscpu [选项]\n```\n\n\n\n**选项**：\n\n- `-a`, `--all` ：同时打印在线和离线 CPU（-e 选项默认值）。\n- `-b`, `--online` ：只打印在线 CPU（-p 选项默认值）。\n- `-B`, `--bytes` ：以字节为单位打印。\n- `-C`, `--caches[=<list>]` ：以易读的格式打印 cache 信息。\n- `-c`, `--offline` ：只打印离线 CPU。\n- `-J`, `--json` ：使用 JSON 格式作为默认或扩展格式。\n- `-e`, `--extended[=<列表>]` ：打印扩展的可读格式。\n- `-p`, `--parse[=<列表>]` ：打印可解析格式。\n- `-s`, `--sysroot <目录>` ：以指定目录作为系统根目录。\n- `-x`, `--hex` ：打印十六进制掩码而非 CPU 列表。\n- `-y`, `--physical` ：打印物理 ID 而非逻辑 ID。\n- `-h`, `--help` ：显示帮助信息。\n- `-V`, `--version` ：显示版本信息。\n\n## 示例\n\n在 i.MX8MQ 上执行 lscpu，查看 CPU 信息\n\n```bash\nroot@imx8mqevk:~# lscpu\nArchitecture:                    aarch64\nCPU op-mode(s):                  32-bit, 64-bit\nByte Order:                      Little Endian\nCPU(s):                          4\nOn-line CPU(s) list:             0-3\nThread(s) per core:              1\nCore(s) per socket:              4\nSocket(s):                       1\nNUMA node(s):                    1\nVendor ID:                       ARM\nModel:                           4\nModel name:                      Cortex-A53\nStepping:                        r0p4\nCPU max MHz:                     1300.0000\nCPU min MHz:                     800.0000\nBogoMIPS:                        16.66\nNUMA node0 CPU(s):               0-3\nVulnerability Itlb multihit:     Not affected\nVulnerability L1tf:              Not affected\nVulnerability Mds:               Not affected\nVulnerability Meltdown:          Not affected\nVulnerability Spec store bypass: Not affected\nVulnerability Spectre v1:        Mitigation; __user pointer sanitization\nVulnerability Spectre v2:        Not affected\nVulnerability Srbds:             Not affected\nVulnerability Tsx async abort:   Not affected\nFlags:                           fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid\n```\n\n\n\n各字段说明如下：\n\n```bash\nArchitecture:        # 架构\nCPU op-mode(s):      # CPU运行模式\nByte Order:          # 字节序\nCPU(s):              # 逻辑CPU颗数\nOn-line CPU(s) list: # 在线CPU列表\nThread(s) per core:  # 每个核的线程数\nCore(s) per socket:  # 每个CPU插槽核数/每颗物理CPU核数\nCPU socket(s):       # CPU插槽数\nNUMA node(s):        # NUMA节点\nVendor ID:           # CPU厂商ID\nCPU family:          # CPU系列\nModel:               # 型号\nModel name:          # 型号名称\nStepping:            # 步进\nCPU MHz:             # CPU主频\nCPU max MHz:         # CPU最大主频\nCPU min MHz:         # CPU最小主频\nVirtualization:      # CPU支持的虚拟化技术\nL1d cache:           # 一级缓存（CPU的L1数据缓存）\nL1i cache:           # 一级缓存（CPU的L1指令缓存）\nL2 cache:            # 二级缓存\n...\n```\n\n\n\n另外，除了 lscpu，通常还会从 /sys 和 /proc 获取 CPU 相关信息\n\n```bash\ncat /proc/cpuinfo\n```\n\n\n\n查看 cpu0 当前工作频率\n\n```bash\ncat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq\n```\n\n\n\n\n\n# Linux chsh 命令 - 更改登录 Shell\n\n## 介绍\n\n**chsh**（英文全拼：change shell）命令用于更改用户登录 shell。\n\n**语法**：\n\n```bash\nchsh [选项] [登录]\n```\n\n\n\n**选项**：\n\n- `-R`, `--root CHROOT_DIR` ：在 `CHROOT_DIR` 目录中应用更改并使用 `CHROOT_DIR` 目录中的配置文件。\n- `-s`, `--shell SHELL` ：用户的新登录 shell 的名称（将此字段设置为空会让系统选择默认的登录 shell）。\n- `-h`, `--help` ：显示帮助信息并退出。\n\n## 示例\n\n查看系统支持的 shell\n\n```bash\n$ cat /etc/shells \n# /etc/shells: valid login shells\n/bin/sh\n/bin/bash\n/usr/bin/bash\n/bin/rbash\n/usr/bin/rbash\n/bin/dash\n/usr/bin/dash\n```\n\n\n\n查看当前登录的 shell\n\n```bash\n$ echo $SHELL\n/bin/bash\n```\n\n\n\n查看当前用户设置的默认 shell\n\n```bash\n$ cat /etc/passwd | grep sh\nrudy:x:1000:1000:rudy,,,:/home/rudy:/bin/bash\n```\n\n\n\n将当前用户的默认 shell 由 bash 修改为 dash\n\n```bash\n$ chsh -s /bin/dash\n```\n\n\n\n再次查看当前用户设置的默认 shell\n\n```bash\n$ cat /etc/passwd | grep sh\nrudy:x:1000:1000:rudy,,,:/home/rudy:/bin/dash\n```\n\n\n\n将当前用户的默认 shell 设置回 bash\n\n```bash\n$ chsh -s /bin/bash\n```\n\n\n\n\n\n# Linux chroot 命令 - 改变根目录\n\n## 介绍\n\n**chroot**（英文全称：change root directory）命令用于改变根目录。\n\nLinux 系统的目录结构默认都是以 root 根目录（即 `/`）开始的，使用 chroot 命令可以将指定的目录作为根目录。\n\n**语法**：\n\n```bash\nchroot [OPTION] NEWROOT [COMMAND [ARG]...]\n```\n\n\n\n**选项**：\n\n- `--groups=G_LIST` ：指定补充组，如 g1, g2, ... , gN。\n- `--userspec=USER:GROUP` ：指定使用的用户和组（通过 ID 或 name）。\n- `--skip-chdir` ：不用将工作目录更改为 `/`。\n- `--help` ：显示帮助信息并退出。\n- `--version` ：显示版本信息并退出。\n\n如果没有指定 COMMAND 命令，chroot 默认会执行 `${SHELL} -i`，进入 shell 交互模式。\n\n## 示例\n\n假设 /opt/rootfs 目录是一个可用的文件系统\n\n```bash\n$ ls /opt/rootfs/\nbin  boot  dev  etc  home  lib  media  mnt  opt  proc  run  sbin  sys  tmp  usr  var\n```\n\n\n\n先执行下面命令查看当前进程指向的根目录\n\n```bash\n$ ls -ld /proc/self/root\nlrwxrwxrwx 1 root root 0 Jun  5 14:14 /proc/self/root -> /\n```\n\n\n\n查看当前根文件系统的 /etc/version 信息\n\n```bash\n$ cat /etc/version\n20210330083304\n```\n\n\n\n查看执行 chroot 后的 /etc/version 信息\n\n```bash\n$ sudo chroot /opt/rootfs cat /etc/version\n20210605043324\n```\n\n\n\n不带命令执行 chroot\n\n```bash\n$ sudo chroot /opt/rootfs\n```\n\n\n\n再次查看此时的 /etc/version 信息\n\n```bash\n$ cat /etc/version\n20210605043324\n```\n\n\n\n执行 `exit` 退出并返回到原来的根文件系统。\n\n\n\n# Linux getconf 命令 - 查询系统配置变量\n\n## 介绍\n\n**getconf**（英文全拼：get system configuration）命令用于查询系统配置变量的值。\n\n**语法**：\n\n```bash\ngetconf -a\ngetconf [-v specification] system_var\ngetconf [-v specification] path_var pathname\n```\n\n\n\n**选项**：\n\n- `-a` ：显示当前系统的所有配置变量（configuration variables）及其值。\n- `-v` ：指示获取配置变量的规范和版本。\n\n**参数**：\n\n- `system_var` ：系统变量（具体系统变量名称参考 sysconf 或 confstr 定义）。\n- `path_var` ：路径名称（具体参考 pathconf 定义），必须带上 pathname 参数。\n\n## 示例\n\n查看当前系统的所有配置变量及其对应的值\n\n```bash\n$ getconf  -a\nLINK_MAX                           65000\n_POSIX_LINK_MAX                    65000\nMAX_CANON                          255\n_POSIX_MAX_CANON                   255\nMAX_INPUT                          255\n_POSIX_MAX_INPUT                   255\nNAME_MAX                           255\n_POSIX_NAME_MAX                    255\nPATH_MAX                           4096\n_POSIX_PATH_MAX                    4096\nPIPE_BUF                           4096\n_POSIX_PIPE_BUF                    4096\n...\n```\n\n\n\n查看 Linux 内存页大小（单位字节）\n\n```bash\n$ getconf PAGE_SIZE\n4096\n```\n\n\n\n查看 /usr 目录内的文件名允许的最大字节数\n\n```bash\n$ getconf NAME_MAX /usr\n255\n```\n\n\n\n查看 Linux 系统位数（32 位 / 64 位）\n\n```bash\n$ getconf LONG_BIT\n64\n```\n\n\n\n\n\n# Linux crontab 命令 - 定时任务表\n\n## 介绍\n\n**crontab**（英文全拼：cron table）命令用于查看或设定在 Linux 系统中定期执行程序。\n\ncron 是 Linux 系统中常用的任务规划软件，cron 是一个守护进程，用户可以通过 crontab 命令要求系统在特定的时间执行特定的任务。适用于需要周期性自动化执行的工作。\n\n**语法**：\n\n```bash\ncrontab [ -u user ] file\ncrontab [ -u user ] [ -i ] { -e | -l | -r }\n```\n\n\n\n**选项**：\n\n- `-u user` ：指定操作时程表（crontab）的用户，如果不指定，则使用当前用户。\n- `-e` ：执行文字编辑器来设定时程表，支持多种文字编辑器，如 nano、vim、emacs 等。\n- `-r` ：删除目前的时程表。\n- `-l` ：列出目前的时程表。\n- `-i` ：使用 -r 选项删除时程表之前提示用户输入 'y/Y' 回复。\n\ncrontab 时间格式如下所示，用户也可以将所有的设定先存放在文件中，再从 file 参数引入。\n\n```bash\nf1   f2   f3   f4   f5   program\n*    *    *    *    *    *\n-    -    -    -    -    - command to be executed\n|    |    |    |    |\n|    |    |    |    +----- day of week (0-7) (Sunday=0/7) OR sun,mon,tue,wed,thu,fri,sat\n|    |    |    +---------- month (1-12) OR jan,feb,mar,apr ...\n|    |    +--------------- day of month (1-31)\n|    +-------------------- hour (0-23)\n+------------------------- minute (0-59)\n```\n\n\n\n- 其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。\n- 当 f1 为 `*` 时表示每分钟都要执行 program，f2 为 `*` 时表示每小时都要执行程序，其余类推。\n- 当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其余类推。\n- 当 f1 为 `*/n` 时表示每 n 分钟个时间间隔执行一次，f2 为 `*/n` 表示每 n 小时个时间间隔执行一次，其余类推。\n- 当 f1 为 a, b, c,... 时表示第 a, b, c,... 分钟要执行，f2 为 a, b, c,... 时表示第 a, b, c...个小时要执行，其余类推。\n\n## 示例\n\n每一分钟执行一次 getiot.sh 脚本\n\n```bash\n* * * * * /opt/getiot.sh 1>/dev/null 2>&1\n```\n\n\n\n每十分钟检查一次磁盘空间\n\n```bash\n*/10 * * * * /home/getiot/bin/check-disk-space\n```\n\n\n\n每天上午 9 点到下午 6 点，每一小时检查一次数据库\n\n```bash\n00 09-18 * * * /home/getiot/bin/check-db-status\n```\n\n\n\n每个工作日（周一到周五）上午 9 点到下午 6 点，每一小时检查一次数据库\n\n```bash\n00 09-18 * * 1-5 /home/getiot/bin/check-db-status\n```\n\n\n\n在 12 月内，每天的早上 6 点到 12 点，每隔 3 个小时执行一次 /usr/bin/backup\n\n```bash\n00 06-12/3 * 12 * /usr/bin/backup\n```\n\n\n\n周一到周五每天下午 5 点给 [rudy@getiot.tech](mailto:rudy@getiot.tech) 寄一封信\n\n```bash\n00 17 * * 1-5 mail -s \"hi\" rudy@getiot.tech < /tmp/maildata\n```\n\n\n\n\n\n# Linux reboot 命令 - 重启系统\n\n## 介绍\n\n在 Linux 系统中，**reboot** 命令用于重新启动计算机，类似于 Windows 系统中的 `restart` 命令。需要注意，机器重启必须要 root 用户才有权限。\n\n**语法**：\n\n```bash\nreboot [OPTIONS...]\n```\n\n\n\n**选项**：\n\n- `-n`：在重启之前不做将记忆体资料写回硬盘的动作，即没有同步操作。\n- `-w`：并不会真的重启，只是把记录写到 /var/log/wtmp 文件里。\n- `-d`：不把记录写到 /var/log/wtmp 文件里（`-n` 选项包含了 `-d`）。\n- `-f`：强制重启，不呼叫 `shutdown` 这个指令。\n- `-i`：在重启之前先把所有网络相关的设备停止。\n\n## 示例\n\n重新启动机器：\n\n```bash\nreboot\n```\n\n\n\n模拟重开机：\n\n```bash\nreboot -w\n```\n\n\n\n\n\n# Linux poweroff 命令 - 关闭系统电源\n\n## 介绍\n\n在 Linux 系统中，**poweroff** 命令用来关闭计算机操作系统并且切断系统电源。如果确认系统中已经没有用户存在且所有数据都已保存，需要立即关闭系统，可以使用 `poweroff` 命令。\n\n**语法**：\n\n```bash\npoweroff [OPTIONS...]\n```\n\n\n\n**选项**：\n\n- `-n`：关闭操作系统时不执行 sync 操作。\n- `-w`：不真正关闭操作系统，仅在日志文件 /var/log/wtmp 中记录。\n- `-d`：关闭操作系统时，不将操作写入日志文件 /var/log/wtmp 中添加相应的记录。\n- `-f`：强制关闭操作系统。\n- `-i`：关闭操作系统之前关闭所有的网络接口。\n- `-h`：关闭操作系统之前将系统中所有的硬件设置为备用模式。\n\n## 示例\n\n关闭计算机操作系统并且切断系统电源：\n\n```bash\npoweroff\n```\n\n\n\n在关闭操作系统之前将系统中所有的硬件设置为备用模式：\n\n```bash\npoweroff -h\n```\n\n\n\n\n\n# Linux shutdown 命令 - 系统关机命令\n\n## 介绍\n\n在 Linux 系统中，**shutdown** 命令用来系统关机命令。shutdown 指令可以关闭所有程序，并依用户的需要，进行重新开机或关机的动作。\n\n**语法**：\n\n```bash\nshutdown [OPTIONS...] [TIME] [WALL...]\n```\n\n\n\n**选项**：\n\n- `-c`：当执行 `shutdown -h 11:50` 指令时，只要按 `+` 键就可以中断关机的指令。\n- `-f`：重新启动时不执行 [fsck](https://getiot.tech/linux-command/fsck/)。\n- `-F`：重新启动时执行 [fsck](https://getiot.tech/linux-command/fsck/)。\n- `-h`：将系统关机。\n- `-k`：只是送出信息给所有用户，但不会实际关机。\n- `-n`：不调用init程序进行关机，而由 shutdown 自己进行。\n- `-r`：shutdown 之后重新启动。\n- `-t`：送出警告信息和删除信息之间要延迟多少秒。\n\n## 示例\n\n现在立即关机：\n\n```bash\n$ sudo shutdown -h now\n```\n\n\n\n立即重新启动：\n\n```bash\n$ sudo shutdown -r now\n```\n\n\n\n指定 10 分钟后关机：\n\n```shell\n$ sudo shutdown +10\n```\n\n\n\n指定 10 分钟后关机，同时送出警告信息给登入用户：\n\n```bash\n$ sudo shutdown +10 \"System will shutdown after 10 minutes\"\n```\n\n\n\n指定关机时间：\n\n```shell\n$ sudo shutdown -h 22:12\n```\n\n\n\n取消按预定时间关闭系统：\n\n```bash\n$ shutdown -c\n```\n\n\n\n\n\n# Linux systemctl 命令 - 系统和服务管理\n\n## 介绍\n\n**systemctl**（英文全拼：system control）用于控制 systemd 系统和管理服务。\n\nsystemd 是目前 Linux 系统上主要的系统守护进程管理工具，由于 init 一方面对于进程的管理是串行化的，容易出现阻塞情况，另一方面 init 也仅仅是执行启动脚本，并不能对服务本身进行更多的管理。所以许多 Linux 发行版都由 systemd 取代了 init 作为默认的系统进程管理工具。\n\nsystemd 所管理的所有系统资源都称作 Unit，通过 systemd 命令集可以方便的对这些 Unit 进行管理。比如 systemctl、hostnamectl、timedatectl、localctl 等命令，这些命令虽然改写了 init 时代用户的命令使用习惯（不再使用 chkconfig、service 等命令），但确实也提供了很大的便捷性。\n\n**语法**：\n\n```bash\nsystemctl [OPTIONS...] COMMAND [UNIT...]\n```\n\n\n\n**选项**：\n\ncommand 选项字如下：\n\n- `start`：启动指定的 unit。\n- `stop`：关闭指定的 unit。\n- `restart`：重启指定 unit。\n- `reload`：重载指定 unit。\n- `enable`：系统开机时自动启动指定 unit，前提是配置文件中有相关配置。\n- `disable`：开机时不自动运行指定 unit。\n- `status`：查看指定 unit 当前运行状态。\n\n**参数**：unit 是要配置的服务名称。\n\n## 示例\n\n重新加载 systemd unit 配置文件\n\n```bash\nsystemctl --system daemon-reload\n```\n\n\n\n查看一个 service 的状态\n\n```bash\nsystemctl status xxx.service\n```\n\n\n\n启动和停止这个 service（本次启动有效）\n\n```bash\nsystemctl start xxx.service\nsystemctl stop xxx.service\n```\n\n\n\n使能或关闭一个 service（下次启动有效）\n\n```bash\nsystemctl enable xxx.service\nsystemctl disable xxx.service\n```\n\n\n\n上述 xxx.service 的后缀都是可以省略的，例如 nginx.service 可以直接写 nginx。\n\n\n\n# Linux timedatectl 命令 - 时间日期控制\n\n## 介绍\n\n**timedatectl**（英文全拼：timedate control）命令用于在 Linux 中设置或查询系统时间、日期和时区等配置。在 Linux 运维中，通常使用此命令来设置或更改当前的日期、时间和时区，或启用自动系统时钟与远程 NTP 服务器同步，以确保 Linux 系统始终保持正确的时间。\n\nsystemd 是目前 Linux 系统上主要的系统守护进程管理工具，由于 init 一方面对于进程的管理是串行化的，容易出现阻塞情况，另一方面 init 也仅仅是执行启动脚本，并不能对服务本身进行更多的管理。所以许多 Linux 发行版都由 systemd 取代了 init 作为默认的系统进程管理工具。\n\nsystemd 所管理的所有系统资源都称作 Unit，通过 systemd 命令集可以方便的对这些 Unit 进行管理。比如 [systemctl](https://getiot.tech/linux-command/systemctl/)、hostnamectl、timedatectl、localctl 等命令，这些命令虽然改写了 init 时代用户的命令使用习惯（不再使用 chkconfig、service 等命令），但确实也提供了很大的便捷性。\n\n从版本号 213 的 systemd 开始，包括了一个名为 **systemd-timesyncd** 的守护进程，将能够和远程的 NTP 服务器同步时间。此守护进程并不是为了取代已有的 NTP 服务，而是作为 SNTP 协议的实现客户端，它可用于更高级的任务和资源有限的系统。从版本号 216 的 systemd 开始，systemd-timesyncd 守护进程默认启用。\n\n**语法**：\n\n```shell\ntimedatectl [OPTIONS...] COMMAND ...\n```\n\n\n\n**命令**：\n\n- `status` ：显示当前的时间设置。\n- `show` ：显示 systemd-timedated 的属性。\n- `set-time TIME` ：设置系统时间。\n- `set-timezone ZONE` ：设置系统时区。\n- `list-timezones` ：显示已知时区。\n- `set-local-rtc BOOL` ：控制 RTC 是否在当地时间。（BOOL 的值可以是 1 / true 或 0 / false）\n- `set-ntp BOOL` ：启用或禁用网络时间同步。（BOOL 的值可以是 1 / true 或 0 / false）\n- `timesync-status` ：显示 systemd-timesyncd 的状态。\n- `show-timesync` ：显示 systemd-timesyncd 的属性。\n\n**选项**：\n\n- `-h`, `--help` ：显示帮助信息。\n- `--version` ：显示软件包版本。\n- `--no-pager` ：不用将输出通过管道传输到寻呼机（pager）。\n- `--no-ask-password` ：不提示输入密码。\n- `-H`, `--host=[USER@]HOST` ：在远程主机上操作。\n- `-M`, `--machine=CONTAINER` ：在本地容器上操作。\n- `--adjust-system-clock` ：更改本地 RTC 模式时调整系统时钟。\n- `--monitor` ：监控 systemd-timesyncd 的状态。\n- `-p`, `--property=NAME` ：仅显示此名称的属性。\n- `-a`, `--all` ：显示所有属性，包括空属性。\n- `--value` ：显示属性时，只打印值。\n\n## 示例\n\n显示系统当前时间和日期\n\n```shell\n$ timedatectl status\n               Local time: Tue 2021-09-14 16:02:41 CST\n           Universal time: Tue 2021-09-14 08:02:41 UTC\n                 RTC time: Tue 2021-09-14 16:02:35\n                Time zone: Asia/Shanghai (CST, +0800)\nSystem clock synchronized: yes\n              NTP service: active\n          RTC in local TZ: no\n```\n\n\n\n显示 systemd-timedated 的属性\n\n```shell\n$ timedatectl show\nTimezone=Asia/Shanghai\nLocalRTC=no\nCanNTP=yes\nNTP=yes\nNTPSynchronized=yes\nTimeUSec=Tue 2021-09-14 16:42:06 CST\nRTCTimeUSec=Tue 2021-09-14 16:42:06 CST\n```\n\n\n\n显示系统所有可用的时区\n\n```shell\n$ timedatectl list-timezones\n```\n\n\n\n将本地时区从上海（Asia/Shanghai）设置为阿姆斯特丹（Europe/Amsterdam）\n\n```shell\n$ timedatectl set-timezone \"Europe/Amsterdam\"\n```\n\n\n\n将本地时区设置为协调世界时（UTC）\n\n```shell\n$ timedatectl set-timezone UTC\n```\n\n\n\n设置系统时间（格式：`HH:MM:SS`）\n\n```shell\n$ timedatectl set-time \"07:25:46\"\n```\n\n\n\n设置系统日期（格式：`YYYY-MM-DD`）\n\n```shell\n$ timedatectl set-time \"2021-12-12\"\n```\n\n\n\n如果只设置日期，那么时间将默认设置为 \"00:00:00\"（建议同时设置日期和时间）\n\n```shell\n$ timedatectl set-time \"2021-12-12 07:25:46\"\n```\n\n\n\n将硬件时钟（RTC）设置为本地时区（不建议，RTC 时钟统一使用 UTC 更恰当，避免在时区更改和夏令时调整方面产生各种问题）\n\n```shell\n$ timedatectl set-local-rtc 1\n```\n\n\n\n将硬件时钟（RTC）设置为协调世界时间（UTC）\n\n```shell\n$ timedatectl set-local-rtc 0\n```\n\n\n\n启用 NTP 自动时间同步\n\n```shell\n$ timedatectl set-ntp true\n```\n\n\n\n禁用 NTP 自动时间同步\n\n```shell\n$ timedatectl set-ntp false\n```\n\n\n\n查看 systemd-timesyncd 服务的状态\n\n```shell\n$ timedatectl timesync-status\n       Server: 91.189.94.4 (ntp.ubuntu.com)\nPoll interval: 17min 4s (min: 32s; max 34min 8s)\n         Leap: normal\n      Version: 4\n      Stratum: 2\n    Reference: 91EECB0E\n    Precision: 1us (-23)\nRoot distance: 29.922ms (max: 5s)\n       Offset: +2.497ms\n        Delay: 199.540ms\n       Jitter: 5.834ms\n Packet count: 6\n    Frequency: +13.039ppm\n```\n\n\n\nsystemd-timedated 可能默认配置了谷歌的 NTP 服务器（如 time1.google.com），为了顺利完成网络时间同步，您可以编辑 /etc/systemd/timesyncd.conf 文件添加自己的 NTP 服务器地址。\n\n相关文章：[Linux 时间同步](https://getiot.tech/linux/linux-date-time-synchronization/)\n\n\n\n# Linux nproc 命令 - 显示可用处理器数\n\n## 介绍\n\n**nproc** 命令用于打印 Linux 系统当前进程可用的处理器数，注意此数目可能小于实际的 CPU 核心数。\n\n**语法**：\n\n```bash\nnproc [OPTION]...\n```\n\n\n\n**选项**：\n\n- `--all`：打印所拥有的处理器数目。\n- `--ignore=N`：可能的话，排除 N 个处理单元。\n- `--help`：显示此帮助信息并退出。\n- `--version`：显示版本信息并退出。\n\n## 示例\n\n在我的 Ubuntu 上直接执行 `nproc`，输出结果如下：\n\n```bash\n$ nproc \n8\n```\n\n\n\n`nproc` 命令本身很简单，更多的是用在 Shell 脚本中，例如 `make` 时以进程可用的最大核心数进行编译：\n\n```bash\nmake -j$(nproc)\n```\n\n\n\n\n\n# Linux lsb_release 命令 - 显示 LSB 信息\n\n## 介绍\n\n**lsb_release** 命令用于打印 Linux 发行版的系统信息，其中 LSB 是 Linux Standard Base 的缩写。需要注意，该命令并非在所有 Linux 系统上都可用，只在一部分 Linux 系统可用，例如 Ubuntu。\n\nlsb_release 命令输出的信息通常位于 `/etc/lsb-release` 文件。另外，在所有基于 systemd 的 Linux 发行版中，都会使用 `/etc/os-release` 文件作为发行版的信息存储，保存诸如 Linux 发行版的类型、版本型号等基本信息。\n\n**语法**：\n\n```bash\nlsb_release [options]\n```\n\n\n\n**选项**：\n\n- `-h`, `--help`：显示帮助信息。\n- `-v`, `--version`：显示系统支持的 LSB 模块。\n- `-i`, `--id`：显示发行版的 ID。\n- `-d`, `--description`：显示发行版的描述信息。\n- `-r`, `--release`：显示发行版的发布版本号。\n- `-c`, `--codename`：显示发行版的代号。\n- `-a`, `--all`：显示发行版的所有信息。\n- `-s`, `--short`：以简短格式显示，和其他选项配合使用。\n\n## 示例\n\n显示当前 Linux 发行版的所有信息：\n\n```bash\n$ lsb_release -a\nNo LSB modules are available.\nDistributor ID:\tUbuntu\nDescription:\tUbuntu 20.04.4 LTS\nRelease:\t20.04\nCodename:\tfocal\n```\n\n\n\n作为对比，这里将 `/etc/lsb-release` 文件内容打印出来：\n\n```bash\n$ cat /etc/lsb-release \nDISTRIB_ID=Ubuntu\nDISTRIB_RELEASE=20.04\nDISTRIB_CODENAME=focal\nDISTRIB_DESCRIPTION=\"Ubuntu 20.04.4 LTS\"\n```\n\n\n\n同时将 `/etc/os-release` 文件内容也打印出来：\n\n```bash\n$ cat /etc/os-release \nNAME=\"Ubuntu\"\nVERSION=\"20.04.4 LTS (Focal Fossa)\"\nID=ubuntu\nID_LIKE=debian\nPRETTY_NAME=\"Ubuntu 20.04.4 LTS\"\nVERSION_ID=\"20.04\"\nHOME_URL=\"https://www.ubuntu.com/\"\nSUPPORT_URL=\"https://help.ubuntu.com/\"\nBUG_REPORT_URL=\"https://bugs.launchpad.net/ubuntu/\"\nPRIVACY_POLICY_URL=\"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy\"\nVERSION_CODENAME=focal\nUBUNTU_CODENAME=focal\n```\n\n\n\n\n\n# Linux sysctl 命令 - 读取/设置内核参数\n\n## 介绍\n\n**sysctl**（英文全拼：system control）命令被用于在 Linux 内核运行时动态地修改内核的运行参数。可用的内核参数会导出到 /proc 文件系统的 sys 目录中，其中包含一些 TCP/IP 堆栈和虚拟内存系统的高级选项，可用来控制 Linux 网络配置，这些参数对于系统性能非常重要。\n\n**语法**：\n\n```bash\nsysctl [options] [variable[=value] ...]\n```\n\n\n\n**选项**：\n\n- `-a`, `--all`：显示所有变量。\n- `--deprecated`：将不推荐使用的参数包含到列表中。\n- `-b`, `--binary`：打印值但不换行。\n- `-e`, `--ignore`：忽略未知变量错误。\n- `-N`, `--names`：打印没有值的变量名称。\n- `-n`, `--values`：仅打印给定变量的值。\n- `-p`, `--load[=<file>]`：从文件中读取值。\n- `--system`：从所有系统目录读取值。\n- `-r`, `--pattern <expression>`：选择与表达式匹配的设置。\n- `-q`, `--quiet`：不回显变量集。\n- `-w`, `--write`：允许将值写入变量。\n- `-h`, `--help`：显示帮助信息。\n- `-V`, `--version`：显示版本信息。\n\n## 示例\n\n查看所有可读变量：\n\n```bash\nsysctl -a\n```\n\n\n\n重新加载 /etc/sysctl.conf 配置文件，使配置生效：\n\n```bash\nsysctl -p\n```\n\n\n\n\n\n# Linux locale 命令 - 显示区域设置\n\n## 介绍\n\n**locale** 命令用于显示 Linux 系统本地语言环境等有关信息。如果未指定任何选项与参数，locale 将会显示 `LC_*` 系列环境变量表示的每个本地语言环境类别的当前设置。\n\n**语法**：\n\n```bash\nlocale [选项...] [names]\nlocale [选项...] [-a|-m]\n```\n\n\n\n其中，`names` 是 IEEE Std 1003.1-2001 定义的本地语言环境的类别，例如：\n\n| 类别          | 定义                           |\n| ------------- | ------------------------------ |\n| `LC_CTYPE`    | 字符集编码定义                 |\n| `LC_COLLATE`  | 排序原则与顺序定义             |\n| `LC_TIME`     | 日期与时间格式定义             |\n| `LC_NUMERIC`  | 非钱币的小数点与千分号定义     |\n| `LC_MONETARY` | 钱币符号、小数点与千分号等定义 |\n| `LC_MESSAGES` | 肯定与否定回答定义             |\n| `LC_NAME`     | 称呼定义                       |\n\n**选项**：\n\n- `-a`, `--all-locales`：输出系统支持的所有本地语言环境。\n- `-m`, `--charmaps`：显示可用字符集的名字，如 UTF-8（中文字符集）。\n- `-c`, `--category-name`：显示命令行参数指定的本地语言类别的详细定义。有效的本地语言类别是 `LC_CTYPE` 等。\n- `-k`, `--keyword-name`：显示选定关键字（如 ctype-class-names）的定义。\n- `-v`, `--verbose`：详细显示模式。\n- `--usage`：显示命令的简要用法。\n- `-?`, `--help`：显示命令的帮助信息，然后退出。\n- `-V`, `--version`：显示命令的版本和版权等信息，然后退出。\n\n## 示例\n\n显示系统支持的所有本地语言环境：\n\n```bash\n$ locale -av\nlocale: zh_CN.utf8      archive: /usr/lib/locale/locale-archive\n-------------------------------------------------------------------------------\n    title | Chinese locale for Peoples Republic of China\n    email | bug-glibc-locales@gnu.org\n language | Chinese\nterritory | China\n revision | 0.1\n     date | 2000-07-25\n  codeset | UTF-8\n```\n\n\n\n显示本地语言环境的时间表示种类与方式：\n\n```bash\n$ locale -cv LC_TIME\nLC_TIME\n日;一;二;三;四;五;六\n星期日;星期一;星期二;星期三;星期四;星期五;星期六\n1月;2月;3月;4月;5月;6月;7月;8月;9月;10月;11月;12月\n一月;二月;三月;四月;五月;六月;七月;八月;九月;十月;十一月;十二月\n上午;下午\n%Y年%m月%d日 %A %H时%M分%S秒\n%Y年%m月%d日\n%H时%M分%S秒\n%p %I时%M分%S秒\n```\n\n\n\n\n\n# Linux setcap 命令 - 设置文件特殊权限\n\n## 介绍\n\n**setcap**（英文全拼：set capabilities）是在 Linux 系统中用于设置特殊权限的命令工具。它允许普通用户在执行特定程序时获得一些超过其正常权限的能力。具体来说，`setcap` 命令允许用户向可执行文件或动态链接库（共享对象）设置特殊的能力。这些能力使得程序能够执行某些通常需要超级用户权限才能完成的操作，例如绑定低于 1024 端口、访问摄像头、修改网络设置等。\n\n通过使用 `setcap` 命令，用户不需要将整个程序以 root 身份运行，而只需为其设置所需的能力即可。这提供了更加灵活和安全的权限控制方式，同时避免了用户以超级用户身份运行程序带来的潜在风险。需要注意的是，`setcap` 命令需要以超级用户（root）身份执行，因为设置特殊能力是一个需要特权的操作。使用时应当慎重，确保仅将特定的能力赋予可信任的程序。\n\n相关命令：[getcap](https://getiot.tech/linux-command/getcap/)\n\n**语法**：\n\n```bash\nsetcap [-q] [-v] [-n <rootid>] (-r|-|<caps>) <filename>\n```\n\n\n\n**选项**：\n\n- `-q`：以简洁方式输出。\n- `-v`：用于验证指定的功能当前是否与该文件关联（v 是 verify 的意思）。如果提供了 `-v` 和 `-n`，则还会验证 `-n <rootid>` 参数。\n- `-n <rootid>`：设置仅在具有此 rootid 所有者的命名空间中使用的文件功能。\n- `-r`：从文件中删除功能集。请注意，设置空功能集与删除它不同，空集可用于保证文件不会以特权执行。\n- `-`：从标准输入读取功能。在这种情况下，功能集以空行终止。\n\n**参数**：\n\n- `caps`：功能集。详细参考下面说明。\n- `filename`：文件名称。\n\n## 权限\n\nLinux 内核从 2.2 版本开始，就增加了 Capabilities 的概念与机制，并随着版本升高逐步得到改进。在 Linux 中，root 权限被分割为以下 29 种能力：\n\n```bash\nCAP_CHOWN            # 修改文件属主的权限\nCAP_DAC_OVERRIDE     # 忽略文件的 DAC 访问限制\nCAP_DAC_READ_SEARCH  # 忽略文件读及目录搜索的 DAC 访问限制\nCAP_FOWNER           # 忽略文件属主 ID 必须和进程用户 ID 相匹配的限制\nCAP_FSETID           # 允许设置文件的 setuid 位\nCAP_KILL             # 允许对不属于自己的进程发送信号\nCAP_SETGID           # 允许改变进程的组 ID\nCAP_SETUID           # 允许改变进程的用户 ID\nCAP_SETPCAP          # 允许向其他进程转移能力以及删除其他进程的能力\nCAP_LINUX_IMMUTABLE  # 允许修改文件的 IMMUTABLE 和 APPEND 属性标志\nCAP_NET_BIND_SERVICE # 允许绑定到小于 1024 的端口\nCAP_NET_BROADCAST    # 允许网络广播和多播访问\nCAP_NET_ADMIN        # 允许执行网络管理任务\nCAP_NET_RAW          # 允许使用原始套接字\nCAP_IPC_LOCK         # 允许锁定共享内存片段\nCAP_IPC_OWNER        # 忽略 IPC 所有权检查\nCAP_SYS_MODULE       # 允许插入和删除内核模块\nCAP_SYS_RAWIO        # 允许直接访问 /devport,/dev/mem,/dev/kmem 及原始块设备\nCAP_SYS_CHROOT       # 允许使用 chroot() 系统调用\nCAP_SYS_PTRACE       # 允许跟踪任何进程\nCAP_SYS_PACCT        # 允许执行进程的 BSD 式审计\nCAP_SYS_ADMIN        # 允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等\nCAP_SYS_BOOT         # 允许重新启动系统\nCAP_SYS_NICE         # 允许提升优先级及设置其他进程的优先级\nCAP_SYS_RESOURCE     # 忽略资源限制\nCAP_SYS_TIME         # 允许改变系统时钟\nCAP_SYS_TTY_CONFIG   # 允许配置 TTY 设备\nCAP_MKNOD            # 允许使用 mknod() 系统调用\nCAP_LEASE            # 允许修改文件锁的 FL_LEASE 标志\n```\n\n\n\n使用 `setcap` 命令可以分割 root 用户的特权，即将 root 的特权分割成不同的能力，每种能力代表一定的特权操作。例如，能力 `CAP_SYS_MODULE` 表示用户能够加载（或卸载）内核模块的特权操作，而 `CAP_SETUID` 表示用户能够修改进程用户身份的特权操作。在 Capbilities 中系统将根据进程拥有的能力来进行特权操作的访问控制。\n\n在 Capilities 中，只有进程和可执行文件才具有能力，每个进程拥有三组能力集，分别称为 cap_effective、cap_inheritable、cap_permitted（分别简记为：`pE`、`pI`、`pP`），其中：\n\n- cap_permitted 表示进程所拥有的最大能力集；\n- cap_effective 表示进程当前可用的能力集，可以看做是 cap_permitted 的一个子集；\n- cap_inheitable 则表示进程可以传递给其子进程的能力集。\n\n系统根据进程的 cap_effective 能力集进行访问控制，cap_effective 为 cap_permitted 的子集，进程可以通过取消 cap_effective 中的某些能力来放弃进程的一些特权。\n\n可执行文件也拥有三组能力集，对应于进程的三组能力集，分别称为 cap_effective、cap_allowed 和 cap_forced（分别简记为 `fE`、`fI`、`fP`），其中：\n\n- cap_allowed 表示程序运行时可从原进程的 cap_inheritable 中集成的能力集；\n- cap_forced 表示运行文件时必须拥有才能完成其服务的能力集；\n- cap_effective 则表示文件开始运行时可以使用的能力。\n\n## 示例\n\n安装 Wireshark 的时候，有一步是给 dumpcap 读网卡的权限，使得普通用户也可以使用 Wireshark 进行抓包：\n\n```bash\n$ sudo setcap 'CAP_NET_RAW+eip CAP_NET_ADMIN+eip' /usr/sbin/dumpcap\n```\n\n\n\n给可执行文件 /bin/ping 加上 “cap_net_admin,cap_net_raw+ep” 权限，普通用户即可使用 ping：\n\n```bash\n$ sudo setcap 'cap_net_admin,cap_net_raw+ep' /bin/ping\n```\n\n\n\n给 nginx 加上使用 1024 以内端口的权限（无需 root 权限）：\n\n```bash\n$ sudo setcap 'cap_net_bind_service=+eip' /usr/sbin/nginx\n```\n\n\n\n清除 nginx 可执行文件附加的权限：\n\n```bash\n$ sudo setcap -r nginx\n```\n\n\n\n\n\n# Linux getcap 命令 - 查看文件的特殊权限\n\n## 介绍\n\n**getcap** 命令是在 Linux 系统中用于查看文件的特殊权限（capabilities）的工具。通过运行 `getcap` 命令，你可以查询指定文件或目录上设置的特殊权限。这些特殊权限描述了该文件或目录在执行时是否有一些超出普通权限的能力。\n\n特殊权限是 Linux 内核引入的一种机制，可以让特定的程序在没有完全超级用户权限的情况下执行一些具有特权的操作。而不需要将整个程序或脚本设置为以超级用户身份运行。\n\n通过 `getcap` 命令，你可以了解到哪些文件具有特殊权限，以及它们所具有的特权。这可以帮助你对系统中的文件和程序进行安全审计和权限管理。\n\n需要注意的是，`getcap` 命令同样需要超级用户（root）权限才能查看特殊权限。可能并不是每个文件或目录都会设置特殊权限，所以返回结果中可能会有空白行。同时，应当只赋予可信任的程序特殊权限，并遵循安全最佳实践。\n\n相关命令：[setcap](https://getiot.tech/linux-command/setcap/)\n\n**语法**：\n\n```bash\ngetcap [-v] [-n] [-r] [-h] filename [ ... ]\n```\n\n\n\n**选项**：\n\n- `-h`：打印命令的简明使用说明。\n- `-n`：打印与文件功能关联的任何非零名称空间 rootid 值。\n- `-r`：递归搜索文件。\n- `-v`：显示所有搜索到的条目，即使它没有文件功能。\n\n**参数**：\n\n- `filename`：文件名称或目录路径。\n\n## 示例\n\n查看 /bin/ping 可执行文件的特殊权限（这将显示指定文件的特殊权限，如果有的话）：\n\n```bash\n$ getcap /bin/ping\n/bin/ping = cap_net_raw+ep\n```\n\n\n\n列出系统 /bin 目录中所有具有特殊权限的文件：\n\n```bash\n$ getcap -r /bin/*\n/bin/dumpcap = cap_net_admin,cap_net_raw+eip\n/bin/gnome-keyring-daemon = cap_ipc_lock+ep\n/bin/mtr-packet = cap_net_raw+ep\n/bin/ping = cap_net_raw+ep\n/bin/traceroute6.iputils = cap_net_raw+ep\n```\n\n\n\n将输出结果保存到文件：\n\n```bash\ngetcap -r /bin/* > capabilities.txt\n```\n\n\n\n使用重定向操作符 `>`，可以将结果输出到指定的文件中，以便后续查阅或分析。\n\n\n\n# Linux arp 命令 - 显示和修改 ARP 缓存\n\n## 介绍\n\n在 Linux 系统中，**arp**（英文全拼：Address Resolution Protocol）命令用于显示和修改系统的 ARP 缓存表，即存储 IP 地址与对应 MAC 地址的映射关系。\n\n**语法**：\n\n```bash\narp [选项] [参数]\n```\n\n\n\n详细语法格式：\n\n```bash\narp [-vn] [-H type] [-i if] [-ae] [hostname]\narp [-v] [-i if] -d hostname [pub]\narp [-v] [-H type] [-i if] -s hostname hw_addr [temp]\narp [-v] [-H type] [-i if] -s hostname hw_addr [netmask nm] pub\narp [-v] [-H type] [-i if] -Ds hostname ifname [netmask nm] pub\narp [-vnD] [-H type] [-i if] -f [filename]\n```\n\n\n\n**选项**：\n\n- `-a`：以另一种（BSD）风格显示 ARP 缓存的所有条目（主机）。\n- `-e`：以默认（Linux）样式显示 ARP 缓存的所有条目（主机）。\n- `-s, --set`：设置一个新的 ARP 记录。\n- `-d, --delete`：删除指定记录。\n- `-v, --verbose`：显示详细的 ARP 缓存条目，包括缓存条目的统计信息。\n- `-n, --numeric`：以数字方式（不解析名称）显示 ARP 缓存中的条目。\n- `-i, --device`：指定网络接口（如 eth0）。\n- `-D, --use-device`：读取所给定设备的硬件地址。\n- `-A, -p, --protocol`：指定协议族。\n- `-f, --file`：从文件或 /etc/ethers 中读取新记录。\n\n## 示例\n\n显示本机 ARP 缓存表中所有记录：\n\n```bash\narp\n```\n\n\n\n以数字方式显示指定主机 ARP 缓存表条目：\n\n```bash\narp -n 192.168.0.1\n```\n\n\n\n删除指定主机网卡上的 ARP 条目（例如 eth1 上 192.168.0.1）：\n\n```bash\narp -i eth1 -d 192.168.0.1\n```\n\n\n\n这将使用 eth1 的 MAC 地址应答 eth0 上 192.168.0.2 的 ARP 请求：\n\n```bash\narp -i eth0 -Ds 192.168.0.2 eth1 pub\n```\n\n\n\n添加对指定的 IP 地址和 MAC 地址进行静态映射的条目：\n\n```bash\narp -s 192.168.0.10 c0:25:a5:29:12:e1\n```\n\n\n\n\n\n# Linux ifconfig 命令 - 网络接口配置命令\n\n## 介绍\n\n**ifconfig**（英文全拼：network interfaces configuring）命令用于配置和显示 Linux 内核中网络接口的网络参数。\n\nifconfig 命令由 net-tools 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install net-tools\n```\n\n\n\n注意，通过 ifconfig 命令配置的网卡信息是临时的，在网卡重启或机器重启后，配置就不存在。\n\n**语法**：\n\n```bash\nifconfig [-v] [-a] [-s] [interface]\nifconfig [-v] interface [aftype] options | address ...\n```\n\n\n\n**选项参数**：\n\n- `add <地址>` ：设置网络设备 IPv6 的 ip 地址；\n- `del <地址>` ：删除网络设备 IPv6 的 IP 地址；\n- `down` ：关闭指定的网络设备；\n- `hw <网络设备类型> <硬件地址>` ：设置网络设备的类型与硬件地址；\n- `io_addr <I/O地址>` ：设置网络设备的 I/O 地址；\n- `irq <IRQ地址>` ：设置网络设备的 IRQ；\n- `media <网络媒介类型>` ：设置网络设备的媒介类型；\n- `mem_start <内存地址>` ：设置网络设备在主内存所占用的起始地址；\n- `metric <数目>` ：指定在计算数据包的转送次数时，所要加上的数目；\n- `mtu <字节>` ：设置网络设备的 MTU；\n- `netmask <子网掩码>` ：设置网络设备的子网掩码；\n- `tunnel <地址>` ：建立 IPv4 与 IPv6 之间的隧道通信地址；\n- `up` ：启动指定的网络设备；\n- `-broadcast <地址>` ：将要送往指定地址的数据包当成广播数据包来处理；\n- `-pointopoint <地址>` ：与指定地址的网络设备建立直接连线，此模式具有保密功能；\n- `-promisc` ：关闭或启动指定网络设备的 promiscuous 模式；\n- `address`：指定网络设备的 IP 地址；\n- `interface` ：指定网络设备的名称。\n\n## 示例\n\n显示网络设备信息\n\n```bash\nifconfig\n```\n\n\n\n启动关闭指定网卡\n\n```bash\nifconfig eth0 down\nifconfig eth0 up \n```\n\n\n\n为网卡配置和删除 IPv6 地址\n\n```bash\nifconfig eth0 add 33ffe:3240:800:1005::2/64\nifconfig eth0 del 33ffe:3240:800:1005::2/64\n```\n\n\n\n修改网卡 MAC 地址（修改前须先关闭网卡）\n\n```bash\nifconfig eth0 hw ether 00:AA:BB:CC:DD:EE\n```\n\n\n\n配置 IP 地址\n\n```bash\nifconfig eth0 192.168.1.56\n```\n\n\n\n配置 IP 地址和子网掩码\n\n```bash\nifconfig eth0 192.168.1.56 netmask 255.255.255.0\n```\n\n\n\n配置 IP 地址和子网掩码以及广播地址\n\n```bash\nifconfig eth0 192.168.1.56 netmask 255.255.255.0 broadcast 192.168.1.255\n```\n\n\n\n\n\n# Linux ip 命令 - 显示或设置网络设备\n\n## 介绍\n\n**ip** 命令是 Linux 系统中的一个网络配置工具，主要用于显示或设置网络设备，功能非常全面，可完全替代 [ifconfig](https://getiot.tech/linux-command/ifconfig/) 命令。\n\n**语法**：\n\n```shell\nip [ OPTIONS ] OBJECT { COMMAND | help }\n```\n\n\n\n**选项**：\n\n- `-V`：显示命令的版本信息。\n- `-s`：输出更详细的信息。\n- `-f`：强制使用指定的协议族。\n- `-4`：指定使用的网络层协议是 IPv4 协议。\n- `-6`：指定使用的网络层协议是 IPv6 协议。\n- `-0`：输出信息每条记录输出一行，即使内容较多也不换行显示。\n- `-r`：显示主机时，不使用 IP 地址，而使用主机的域名。\n- `help`：为该命令的帮助信息。\n\n常用 OBJECT 对象及其含义如下：\n\n| OBJECT                   | 缩写           | 描述                                     |\n| ------------------------ | -------------- | ---------------------------------------- |\n| `address`                | `a` 或 `addr`  | 设备上的协议（IPv4 或 IPv6）地址         |\n| `addrlabel`              | `addrl`        | 用于协议地址选择的标签配置               |\n| `l2tp`                   |                | IP 上的以太网隧道（L2TPv3）              |\n| `link`                   | `l`            | 网络设备                                 |\n| `maddress`               | `m` 或 `maddr` | 多播地址                                 |\n| `monitor`                |                | 监视 netlink 消息                        |\n| `mroute`                 | `mr`           | 组播路由缓存条目                         |\n| `mrule`                  |                | 组播路由策略数据库中的规则               |\n| `neighbour`              | `n` 或 `neigh` | 管理 ARP 或 NDISC 缓存条目               |\n| `netns`                  |                | 管理网络命名空间                         |\n| `ntable`                 |                | 管理邻居高速缓存（neighbor cache）的操作 |\n| `route`                  | `r`            | 路由表条目                               |\n| `rule`                   | `ru`           | 路由策略数据库中的规则                   |\n| `tcp_metrics/tcpmetrics` |                | 管理 TCP 指标（Metrics）                 |\n| `token`                  |                | 管理令牌化（tokenized）的接口标识符      |\n| `tunnel`                 | `t`            | IP 上的隧道（tunnel）                    |\n| `tuntap`                 |                | 管理 TUN/TAP 设备                        |\n| `xfrm`                   | `x`            | 管理 IPSec 策略                          |\n\n## 示例\n\n显示所有网络接口的信息：\n\n```bash\nip a\n```\n\n\n\n只显示 TCP/IP IPv4 的网络接口：\n\n```bash\nip -4 a\n```\n\n\n\n只显示 TCP/IP IPv6 的网络接口：\n\n```bash\nip -6 a\n```\n\n\n\n显示指定接口的 TCP/IP 详细信息，下面四个命令是等效的：\n\n```bash\nip a show eth0\nip a list eth0\nip a show dev eth0\nip a list dev eth0\n```\n\n\n\n只显示正在运行的网络接口：\n\n```bash\nip link show up\n```\n\n\n\n为指定网络接口设置 IP 地址的格式是 `ip a add {ip_addr/mask} dev {interface}`，例如下面两个命令是等效的：\n\n```bash\nip a add 192.168.1.200/255.255.255.0 dev eth0\nip a add 192.168.1.200/24 dev eth0\n```\n\n\n\n为指定网络接口上添加广播地址：\n\n```bash\nip addr add broadcast 172.20.10.255 dev eth0\n```\n\n\n\n从网络接口中删除 IP 地址：\n\n```bash\nip a del 192.168.1.200/24 dev eth0\n```\n\n\n\n在所有 ppp（Point-to-Point）接口上禁用 IP 地址：\n\n```bash\nip -4 addr flush label \"ppp*\"\n```\n\n\n\n关闭 eth1 网卡：\n\n```bash\nip link set dev eth1 down\n```\n\n\n\n启动 eth1 网卡：\n\n```bash\nip link set dev eth1 up\n```\n\n\n\n设置 eth0 网络接口的 txqueuelen（传输队列长度）大小为 10000：\n\n```bash\nip link set txqueuelen 10000 dev eth0\n```\n\n\n\n设置 eth0 网络接口的 MTU 值为 9000：\n\n```bash\nip link set mtu 9000 dev eth0\n```\n\n\n\n显示邻居（ARP）缓存：\n\n```bash\n$ ip n show\n192.168.1.3 dev eth0 lladdr 86:e5:ec:b7:bd:d3 STALE\n192.168.1.1 dev eth0 lladdr 3c:57:4f:f8:18:48 REACHABLE\nfe80::1 dev eth0 lladdr 3c:57:4f:f8:18:48 router REACHABLE\n```\n\n\n\n输出结果的最后一个字段显示此条目的“**neighbour unreachability detection**”机器的状态，一共有 3 种状态：\n\n- **`STALE`**：邻居是有效的（valid），但可能已经无法访问，因此内核将尝试在第一次传输时检查它。\n- **`DELAY`**：一个数据包已经发送给过时的（STALE 状态）邻居，内核正在等待确认。\n- **`REACHABLE`**：邻居是有效的（valid），而且显然是可以联系到的（reachable）。\n\n添加一个 ARP 条目的格式是 `ip neigh add {IP-HERE} lladdr {MAC/LLADDRESS} dev {DEVICE} nud {STATE}`。例如，在设备 eth0 上为邻居 192.168.1.5 添加一个永久 ARP 条目：\n\n```bash\nip neigh add 192.168.1.5 lladdr 00:1a:30:38:a8:00 dev eth0 nud perm\n```\n\n\n\nnud 邻居状态（neighbour state）有 4 种：\n\n- **`permanent`**：邻居条目永远有效，只能由管理员指定删除。\n- **`noarp`**：邻居条目是有效的，将不会尝试验证此项，但可以在其生存期过期时将其删除。\n- **`stale`**：邻居的条目是有效的，但可疑。如果 `ip neigh` 选项有效且地址未被此命令更改，则该选项不会更改邻居状态。\n- **`reachable`**：在可达性超时过期之前，邻居条目是有效的。\n\n删除一个 ARP 条目的格式是 `ip neigh del {IPAddress} dev {DEVICE}`，例如：\n\n```bash\nip neigh del 192.168.1.5 dev eth1\n```\n\n\n\n更改是设备 eth1 上邻居 192.168.1.100 的状态为 reachable：\n\n```bash\nip neigh chg 192.168.1.100 dev eth1 nud reachable\n```\n\n\n\n刷新 ARP 记录：\n\n```bash\nip -s -s n flush 192.168.1.5\n```\n\n\n\n显示路由表，下面几个命令是等效的：\n\n```bash\nip r\nip r list\nip route\nip route list\n```\n\n\n\n增加一个新的路由，命令格式如下：\n\n```bash\nip route add {NETWORK/MASK} via {GATEWAYIP}\nip route add {NETWORK/MASK} dev {DEVICE}\n## Add default route using ip ##\nip route add default {NETWORK/MASK} dev {DEVICE}\nip route add default {NETWORK/MASK} via {GATEWAYIP}\n```\n\n\n\n通过网关 192.168.1.254 向网络 192.168.1.0/24 添加一个普通路由：\n\n```bash\nip route add 192.168.1.0/24 via 192.168.1.254\n```\n\n\n\n通过 192.168.1.254 网关路由通过 eth0 网络接口连接的所有流量：\n\n```bash\nip route add 192.168.1.0/24 dev eth0\n```\n\n\n\n删除前面添加的一条网关路由：\n\n```bash\nip route del 192.168.1.0/24 dev eth0\n```\n\n\n\n删除默认网关路由：\n\n```bash\nip route del default\n```\n\n\n\n更改 eth0 网卡的 MAC 地址：\n\n```bash\n## show MAC address ##\nip link show eth0\n## disable interface ##\nip link set dev eth0 down\n## set new MAC address ##\nip link set dev eth0 address XX:YY:ZZ:AA:BB:CC\nip link set dev eth0 up\n```\n\n\n\n\n\n# Linux route 命令 - 显示或操作 IP 路由表\n\n## 介绍\n\n**route** 命令用于显示和操作 Linux 内核 IP 路由表。它的主要用途是在使用 ifconfig 程序配置后，设置一个网络接口（网卡）到特定主机或网络的静态路由。当使用 add 或 del 选项时，route 会修改路由表，如果没有这些选项，则会显示路由表的当前内容。也可通过 /proc/net/route 查看路由表信息。\n\n提示\n\n基础知识：要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者一个同时位于两个网络的网关来实现。\n\n在 Linux 系统中，设置路由通常是为了解决以下问题：该 Linux 系统在一个局域网中，局域网中有一个网关，能够让机器访问 Internet，那么就需要将这台机器的 IP 地址设置为 Linux 机器的默认路由。要注意的是，直接在命令行下执行 route 命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了。可以在 /etc/rc.local 中添加 route 命令来保证该路由设置永久有效。\n\n**语法**：\n\n```shell\nroute [-nNvee] [-FC] [<AF>]           # 显示核心路由表\nroute [-v] [-FC] {add|del|flush} ...  # 为AF修改路由表\nroute {-h|--help} [<AF>]              # Detailed usage syntax for specified AF\nroute {-V|--version}                  # 显示版本和作者信息并退出\n```\n\n\n\n**选项**：\n\n- `-v`, `--verbose` ：显示详细的处理信息。\n- `-n`, `--numeric` ：不解析名称。\n- `-e`, `--extend` ：显示更多信息。\n- `-F`, `--fib` ：显示发送信息（默认）。\n- `-C`, `--cache` ：显示路由缓存，而不是 FIB。\n- `add` ：添加一条路由。\n- `del` ：删除一条路由。\n- `-net` ：目标地址是一个网络（network）。\n- `-host` ：目标地址是一个主机（host）。\n- `netmask NM` ：当添加一个网络路由时，需要使用网络掩码。\n- `gw GW` ：路由数据包通过网关。注意，你指定的网关必须能够到达。\n- `metric M` ：设置路由跳数。\n- `mss M` ：将路由的 MTU（最大传输单元）设置为 M 字节。MTU 即 Maximum Transmission Unit，MSS 即 Maximum Segment Size。\n- `window W` ：将此路由上的连接的 TCP 窗口大小设置为 W 字节。这通常仅用于 AX.25 网络并且驱动程序无法处理背靠背帧（back to back frames）。\n- `irtt I` ：将此路由上 TCP 连接的初始往返时间（initial round trip time）设置为 I 毫秒 (1-12000)。这通常仅用于 AX.25 网络。如果省略，则使用 RFC 1122 默认值 300 毫秒。\n- `reject` ：安装阻塞路由，这将强制路由查找失败，以达到屏蔽该路由的效果。例如，这用于在使用默认路由之前屏蔽网络。注意，这不适用于防火墙。\n- `mod, dyn, reinstate` ：安装动态或修改过的路由。这些标志用于诊断目的，通常仅由路由守护程序设置。\n- `dev If` ：强制路由与指定的设备相关联，否则内核将尝试自行确定设备（通过检查现有路由和设备规范，以及路由添加到的位置）。在大多数普通网络中，您不需要这个。如果 `dev If` 是命令行上的最后一个选项，则可以省略 `dev` 这个词，因为它是默认值。否则，路由修饰符（公制网络掩码 `gw dev`）的顺序无关紧要。\n\n## 示例\n\n显示当前路由：\n\n```shell\n$ route\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         *               0.0.0.0         U     0      0        0 ppp0\n10.64.64.64     *               255.255.255.255 UH    0      0        0 ppp0\n192.168.30.0    *               255.255.254.0   U     0      0        0 eth0\n```\n\n\n\n显示当前路由（不解析名称，列出速度会比 route 快）：\n\n```shell\n$ route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         0.0.0.0         0.0.0.0         U     0      0        0 ppp0\n10.64.64.64     0.0.0.0         255.255.255.255 UH    0      0        0 ppp0\n192.168.30.0    0.0.0.0         255.255.254.0   U     0      0        0 eth0\n```\n\n\n\n各字段说明如下：\n\n| 字段        | 说明                                                         |\n| ----------- | ------------------------------------------------------------ |\n| Destination | 目标网段或者主机                                             |\n| Gateway     | 网关地址，`*` 表示目标是本主机所属的网络，不需要路由         |\n| Genmask     | 子网掩码                                                     |\n| Flags       | 路由标志，用于标记当前网络节点的状态，各标记说明如下： - `U` 即 Up，表示此路由当前为启动状态 - `H` 即 Host，表示此网关为一主机 - `G` 即 Gateway，表示此网关为一路由器 - `R` 即 Reinstate Route，使用动态路由重新初始化的路由 - `D` 即 Dynamically，此路由是动态性地写入 - `M` 即 Modified，此路由是由路由守护程序或导向器动态修改 - `!` 表示此路由当前为关闭状态 |\n| Metric      | 跃点（路由距离），到达指定网络所需的中转数（Linux 内核暂时没有使用） |\n| Ref         | 路由项引用次数（Linux 内核暂时没有使用）                     |\n| Use         | 此路由项被路由软件查找的次数                                 |\n| Iface       | 该路由表项对应的输出接口                                     |\n\n增加到主机的路由信息：\n\n```shell\nroute add -host 192.16.128.1 dev eth0\nroute add -host 192.16.128.1 gw 192.16.128.254\n```\n\n\n\n添加网关/设置网关（增加一条到达 224.0.0.0 的路由）：\n\n```shell\nroute add -net 224.0.0.0 netmask 240.0.0.0 dev eth0\n```\n\n\n\n屏蔽一条路由（增加一条屏蔽的路由，目的地址为 224.x.x.x 将被拒绝）：\n\n```shell\nroute add -net 224.0.0.0 netmask 240.0.0.0 reject\n```\n\n\n\n删除路由记录：\n\n```shell\nroute del -net 224.0.0.0 netmask 240.0.0.0\nroute del -net 224.0.0.0 netmask 240.0.0.0 reject\n```\n\n\n\n删除和添加设置默认网关：\n\n```shell\nroute del default gw 192.168.120.240\nroute add default gw 192.168.120.240\n```\n\n\n\n\n\n# Linux ethtool 命令 - 查询设置网卡参数\n\n## 介绍\n\n**ethtool**（英文全拼：ethernet tool）命令用于查看和修改网络设备（尤其是有线以太网设备）的驱动参数和硬件设置。你可以根据需要更改以太网卡的参数，包括自动协商、速度、双工和局域网唤醒等参数。\n\n**安装**：\n\n默认情况下，大多数 Linux 发行版应该已经安装了 ethtool 工具，如果没有，可以参考如下命令进行安装。\n\n```bash\n# Linux 对于 RHEL/CentOS 6/7 系统，使用 yum 命令安装\nsudo yum install -y ethtool\n\n# Linux 对于 RHEL/CentOS 8 和 Fedora 系统，使用 dnf 命令安装\nsudo dnf install -y ethtool\n\n# Linux 对于基于 Debian/Ubuntu 的系统，使用 apt 或 apt-get 命令安装\nsudo apt-get install ethtool\n\n# Linux 对于 openSUSE 系统，使用 zypper 命令安装\nsudo zypper install -y ethtool\n\n# Linux 对于 Arch Linux 系统，使用 pacman 命令安装\nsudo pacman -S ethtool\n```\n\n\n\n**语法**：\n\n```bash\nethtool [选项] [devname]\n```\n\n\n\n**选项**：\n\n- `-a` ：查看网卡中接收模块 RX、发送模块 TX 和 Autonegotiate 模块的状态（启动 on 或 停用 off）。\n- `-A` ：修改网卡中接收模块 RX、发送模块 TX 和 Autonegotiate 模块的状态（启动 on 或 停用 off）。\n- `-c` ：display the Coalesce information of the specified ethernet card。\n- `-C` ：Change the Coalesce setting of the specified ethernet card。\n- `-g` ：Display the rx/tx ring parameter information of the specified ethernet card。\n- `-G` ：change the rx/tx ring setting of the specified ethernet card。\n- `-i` ：显示网卡驱动的信息，如驱动的名称、版本等。\n- `-d` ：显示 register dump 信息，部分网卡驱动不支持该选项。\n- `-e` ：显示 EEPROM dump 信息，部分网卡驱动不支持该选项。\n- `-E` ：修改网卡 EEPROM byte。\n- `-k` ：显示网卡 Offload 参数的状态（on 或 off），包括 rx-checksumming、tx-checksumming 等。\n- `-K` ：修改网卡 Offload 参数的状态。\n- `-p` ：用于区别不同 ethX 对应网卡的物理位置，常用的方法是使网卡 port 上的 led 不断的闪；N 指示了网卡闪的持续时间，以秒为单位。\n- `-r` ：如果 auto-negotiation 模块的状态为 on，则 restarts auto-negotiation。\n- `-S` ：显示 NIC- and driver-specific 的统计参数，如网卡接收/发送的字节数、接收/发送的广播包个数等。\n- `-t` ：让网卡执行自我检测，有两种模式（offline 或 online）。\n- `-s` ：修改网卡的部分配置，包括网卡速度、单工/全双工模式、mac 地址等。\n\n**参数**：`devname`（网卡名称，可通过 [ip](https://getiot.tech/linux-command/ip/) 或 [ifconfig](https://getiot.tech/linux-command/ifconfig/) 命令查看）\n\n## 示例\n\n查看 eth0 网卡的硬件配置信息\n\n```bash\nethtool eth0\n```\n\n\n\n查看 eth0 网卡的驱动程序和固件版本\n\n```bash\nethtool -i eth0\n```\n\n\n\n查看 eth0 网卡的自动协商、RX 和 TX 等详细信息\n\n```bash\nethtool -a eth0\n```\n\n\n\n查看 eth0 网卡网络使用情况统计\n\n```bash\nethtool -S eth0\n```\n\n\n\n从多个物理接口中识别出特定网卡（闪烁网卡上的 LED）\n\n```bash\nethtool -p eth0\n```\n\n\n\n修改 eth0 以太网设备的速度为百兆（进行此操作时，网卡会自动掉线，您需要使用 ifup、ip 或 nmcli 命令将其重新上线）\n\n```bash\nethtool -s eth0 speed 100\nip link set eth0 up\n```\n\n\n\n启用/禁用以太网卡的自动协商\n\n```bash\nethtool -s eth0 autoneg off\nethtool -s eth0 autoneg on\n```\n\n\n\n同时修改多个配置参数\n\n```bash\nethtool –s eth0 speed 1000 duplex full autoneg off\n```\n\n\n\n注意：在系统重启后，使用 ethtool 所做的更改将恢复为默认值。如果需要使设置永久生效，您需要根据您的 Linux 发行版进行操作，可能需要将这些配置更新到正确的文件中。\n\n查看网卡是否支持 PTP 硬件\n\n```bash\n$ sudo ethtool -T eth0\nTime stamping parameters for eth0:\nCapabilities:\n        hardware-transmit     (SOF_TIMESTAMPING_TX_HARDWARE)\n        software-transmit     (SOF_TIMESTAMPING_TX_SOFTWARE)\n        hardware-receive      (SOF_TIMESTAMPING_RX_HARDWARE)\n        software-receive      (SOF_TIMESTAMPING_RX_SOFTWARE)\n        software-system-clock (SOF_TIMESTAMPING_SOFTWARE)\n        hardware-raw-clock    (SOF_TIMESTAMPING_RAW_HARDWARE)\nPTP Hardware Clock: 0\nHardware Transmit Timestamp Modes:\n        off                   (HWTSTAMP_TX_OFF)\n        on                    (HWTSTAMP_TX_ON)\nHardware Receive Filter Modes:\n        none                  (HWTSTAMP_FILTER_NONE)\n        all                   (HWTSTAMP_FILTER_ALL)\n```\n\n\n\n注意：对于 gPTP 同步，需要硬件支持，PTP Hardware Clock 选项要求为 1。\n\n\n\n# Linux netstat 命令 - 显示网络统计信息\n\n## 介绍\n\n**netstat**（英文全拼：network statistics）命令用于显示网络连接、路由表、接口统计、伪连接和组播成员等信息。\n\n**语法**：\n\n```bash\nnetstat [OPTION]...\n```\n\n\n\n**选项**：\n\n- `-a` ：显示所有连线中的 socket。\n- `-p` ：显示正在使用 socket 的程序识别码和程序名称。\n- `-t` ：仅显示 TCP 传输协议的连线状况。\n- `-u` ：仅显示 UDP 传输协议的连线状况。\n- `-l` ：仅显示处于 Listen（监听）状态的 socket。\n- `-i` ：显示网络界面信息表单。\n- `-n` ：直接使用 IP 地址，不通过域名服务器。\n\n## 示例\n\n显示详细的网络状况\n\n```bash\nnetstat -a\n```\n\n\n\n显示 UDP 连接状况\n\n```bash\nnetstat -nu\n```\n\n\n\n显示 UDP 端口号的使用情况\n\n```bash\nnetstat -apu\n```\n\n\n\n显示 TCP、UDP 的端口和进程等相关情况\n\n```bash\nnetstat -tunlp\n```\n\n\n\n显示所有 4000 端口使用情况\n\n```bash\nnetstat -tunlp | grep 4000\n```\n\n\n\n显示网卡列表\n\n```bash\nnetstat -i\n```\n\n\n\n显示组播组的关系\n\n```bash\nnetstat -g \n```\n\n\n\n\n\n# Linux nslookup 命令 - 查询 DNS 域名和 IP\n\n## 介绍\n\n**nslookup**（英文全拼：name server lookup）是一个域名查询工具，可用于查询 DNS 记录信息、查看域名解析是否正常。nslookup 是诊断网络故障的常用工具之一。\n\n**语法**：\n\n```bash\nnslookup [-option] [name | -] [server]\n```\n\n\n\nnslookup 有两种工作模式，即“交互模式”（Interactive mode）和“非交互模式”（Non-interactive mode）。在“交互模式”下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。而在“非交互模式”下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息。\n\n进入交互模式的方法是直接输入 nslookup 命令（不加任何参数），此时 nslookup 会连接到默认的域名服务器（即 `/etc/resolv.conf` 的第一个 dns 地址）。或者输入 `nslookup -nameserver/ip` 命令指定 dns 地址。在交互模式输入想要查询的域名即可，输入 `exit` 退出交互模式。\n\n而非交互模式，则直接输入 `nslookup 域名` 就可以了。在非交互模式，可以在域名 name 后面添加 DNS 服务器地址，指定要使用的域名服务器。\n\n## 示例\n\n查询 getiot.tech 域名信息：\n\n```bash\n$ nslookup getiot.tech\nServer:\t\t127.0.0.53\nAddress:\t127.0.0.53#53\n\nNon-authoritative answer:\nName:\tgetiot.tech\nAddress: 42.192.64.149\n```\n\n\n\n指定 DNS 服务器查询 getiot.tech 域名信息：\n\n```bash\n$ nslookup getiot.tech 8.8.8.8\nServer:\t\t8.8.8.8\nAddress:\t8.8.8.8#53\n\nNon-authoritative answer:\nName:\tgetiot.tech\nAddress: 42.192.64.149\n```\n\n\n\n\n\n# Linux telnet 命令 - 远程登录协议命令\n\n## 介绍\n\n**telnet** 命令用于登录远程主机，并对远程主机进行管理。但由于 telnet 采用明文传送报文，安全性不好，因此通常会使用更安全的 [ssh](https://getiot.tech/linux-command/ssh/) 方式登录远程主机。如今，很多 Linux 服务器都已经不开放 telnet 服务。\n\n提示\n\nTelnet 是一种应用层协议（端口 23），使用于互联网及局域网中，以虚拟终端的形式提供双向、以文字字符串为主的命令行接口交互功能。属于 TCP/IP 协议族的其中之一，是互联网远程登录服务的标准协议和主要方式。\n\n**语法**：\n\n```bash\ntelnet [OPTION] [host [port]]\n```\n\n\n\n**选项**：\n\n- `-8`：允许使用 8 位字符资料，包括输入与输出。\n- `-a`：尝试自动登入远端系统。\n- `-b <address>`：使用别名指定远端主机名称。\n- `-d`：启动排错模式。\n- `-e <escapechar>`：设置脱离字符。\n- `-E`：滤除脱离字符。\n- `-l <user>`：指定要登入远端主机的用户名称。\n- `-L`：允许输出 8 位字符资料。\n- `-n <tracefile>`：指定文件记录相关信息。\n- `-r`：使用类似 rlogin 指令的用户界面。\n- `-S <tos>`：设置 telnet 连线所需的 ip TOS 信息。\n- `-x`：假设主机有支持数据加密的功能，就使用它。\n\n## 示例\n\n登录远程主机 192.168.1.100，登录时需要输入用户名和密码：\n\n```bash\ntelnet 192.168.1.100\n```\n\n\n\n\n\n# Linux ssh 命令 - 远程登录安全协议\n\n## 介绍\n\n**ssh**（SecureShell 的缩写）命令是 OpenSSH 套件的组成部分，是一个用于登录到远程机器并在远程机器上执行命令的客户端程序。它的目的是取代 rlogin 和 rsh，并在一个不安全的网络上提供两个不受信任的主机之间的安全加密通信。图形化应用程序 X11 连接和任意 TCP 端口也可以通过 ssh 安全通道进行转发。\n\n除了 `ssh` 客户端命令以外，OpenSSH 套件还包括下面几个命令：\n\n- [ssh-keygen](https://www.ssh.com/ssh/keygen)：用于为 ssh 生成、管理和转换认证密钥，它支持 RSA 和 DSA 两种认证密钥。\n- [ssh-copy-id](https://www.ssh.com/ssh/copy-id)：将把本地的 ssh 公钥文件安装到远程主机对应的账户下。\n- [ssh-agent](https://www.ssh.com/ssh/agent)：代理持有单点登录的私钥，可以将它理解为一个密钥管理器。\n- [ssh-add](https://www.ssh.com/ssh/add)：向代理添加密钥的工具。\n- [scp](https://www.ssh.com/ssh/scp)：具有类 RCP 命令接口的文件传输客户端。\n- [sftp](https://www.ssh.com/ssh/sftp)：具有类 FTP 命令接口的文件传输客户端。\n- [sshd](https://www.ssh.com/ssh/sshd)：OpenSSH 服务端。\n\nSSH 的故事\n\nSSH 在20世纪90年代取代了 Unix 和 Linux 中的一些旧命令和协议，包括 telnet、 rlogin 和 rsh。SSH 在 TCP/IP 端口22上运行，这刚好是在 ftp（21 端口）和 telnet（23 端口）之间，它们是20年前的。阅读《[The story of getting SSH port 22](https://www.ssh.com/academy/ssh/port#how-ssh-port-became-22)》 可以了解 SSH 如何获得端口22的故事。\n\n**语法**：\n\n```bash\nssh [OPTIONS] [-p PORT] [USER@]HOSTNAME [COMMAND]\n```\n\n\n\n**选项**：\n\n- `-1`：强制只使用协议第一版。\n- `-2`：强制只使用协议第二版。\n- `-4`：强制只使用 IPv4 地址。\n- `-6`：强制只使用 IPv6 地址。\n- `-A`：允许转发认证代理的连接。可以在配置文件中对每个主机单独设定这个参数。\n- `-a`：禁止转发认证代理的连接。\n- `-b BIND_ADDRESS`：在拥有多个地址的本地机器上，指定连接的源地址。\n- `-C`：压缩所有数据。压缩算法与 gzip 使用的相同。\n- `-c {blowfish | 3des | des}`：选择会话的密码算法。3des 是默认算法。\n- `-c CIPHER_SPEC`：另外, 对于协议第二版，这里可以指定一组用逗号隔开、按优先顺序排列的加密算法。\n- `-D [BIND_ADDRESS:]PORT`：指定一个本地主机动态的应用程序级的转发端口。工作原理是这样的，本地机器上分配了一个 socket 侦听 port 端口，一旦这个端口上有了连接，该连接就经过安全通道转发出去，根据应用程序的协议可以判断出远程主机将和哪里连接。目前支持 SOCKS4 和 SOCKS5 协议，而 ssh 将充当 SOCKS 服务器. 只有 root 才能转发特权端口。可以在配置文件中指定动态端口的转发。\n- `-e ESCAPE_CHAR`：设置 pty 会话的转义字符，默认为字符 ~。转义字符只在行首有效，转义字符后面跟一个点表示结束连接，后跟一个 control-Z 表示挂起连接，跟转义字符自己表示输出转义字符自身。把转义字符设为 none 则禁止 转义功能，使会话完全透明。\n- `-F CONFIGFILE`：指定 ssh 指令的配置文件，将忽略系统级配置文件 /etc/ssh/ssh_config 和用户级配置文件 ~/.ssh/config。\n- `-f`：ssh 在执行命令前退至后台。\n- `-g`：允许远端主机连接本地的转发端口。\n- `-I SMARTCARD_DEVICE`：指定智能卡设备。智能卡里面存储了用户的 RSA 私钥。\n- `-i IDENTITY_FILE`：指定一个 RSA 或 DSA 认证所需的身份（私钥）文件。协议第一版的默认文件是 ~/.ssh/identity 以及协议第二版的 ~/.ssh/id_rsa 和 ~/.ssh/id_dsa 文件。可以同时使用多个 -i 选项，也可以在配置文件中指定多个身份文件。\n- `-K`：启用基于 GSSAPI 的身份验证和向服务器转发 GSSAPI 凭据。\n- `-k`：禁用向服务器转发 GSSAPI 凭据。\n- `-L [BIND_ADDRESS:]PORT:HOST:HOSTPORT`：将本地主机的地址和端口接收到的数据通过安全通道转发给远程主机的地址和端口。\n- `-l LOGIN_NAME`：指定登录远程主机的用户。可以在配置文件中对每个主机单独设定这个参数。\n- `-M`：将 ssh 客户端置于主模式进行连接共享。多个 -M 选项将 ssh 置于主模式，并在接受从连接之前进行确认。\n- `-m MAC_SPEC`：对于协议第二版，可以指定一组用逗号隔开，按优先顺序排列的 MAC (message authentication code) 算法。\n- `-N`：不执行远程命令，用于转发端口。仅限协议第二版。\n- `-n`：把 stdin 重定向到 /dev/null，防止从 stdin 读取数据。在后台运行时一定会用到这个选项。\n- `-O CTL_CMD`：控制主动连接多路复用主进程。参数 `CTL_CMD` 将被传递给主进程。`CTL_CMD` 可取值 check（检查主进程是否正在运行）和 exit（让主进程退出）。\n- `-o OPTION`：可以在这里给出某些选项，格式和配置文件中的格式一样。它用来设置那些没有单独的命令行标志的选项。\n- `-p PORT`：指定远程主机的端口。可以在配置文件中对每个主机单独设定这个参数。\n- `-q`：安静模式。消除大多数的警告和诊断信息。\n- `-R [BIND_ADDRESS:]PORT:HOST:HOSTPORT`：将远程主机上的地址和端口接收的数据通过安全通道转发给本地主机的地址和端口。\n- `-S CTL_PATH`：指定用于连接共享的控制套接字的位置。\n- `-s`：用于请求远程系统上的子系统调用。子系统是 SSH2 协议的一个特性，它有助于将 SSH 用作其他应用程序（如 sftp(1)）的安全传输。子系统通过远程命令指定。\n- `-T`：禁止分配伪终端。\n- `-t`：强制分配伪终端。这可用于在远程计算机上执行基于屏幕的任意程序，例如菜单服务。多个 -t 选项强制分配终端, 即使没有本地终端。\n- `-V`：显示版本信息并退出。\n- `-v`：冗详模式。打印关于运行情况的调试信息。在调试连接、认证和配置问题时非常有用。多个 -v 选项能够增加冗详程度，最多三个。\n- `-W HOST:PORT`：将客户端上的标准输入和输出通过安全通道转发给指定主机的端口。\n- `-w LOCAL_TUN[:REMOTE_TUN]`：指定客户端和服务端之间转发的隧道设备。\n- `-X`：允许 X11 转发，可以在配置文件中对每个主机单独设定这个参数。\n- `-x`：禁止 X11 转发。\n- `-Y`：启用受信任的 X11 转发。受信任的 X11 转发不受 X11 安全扩展控制的约束。\n- `-y`：使用 syslog 系统模块发送日志信息。默认情况下，此信息被发送到 stderr。\n\n## 示例\n\n使用指定用户名（root）登录远程主机\n\n```bash\nssh root@192.168.1.100\n```\n\n\n\n使用指定用户名（root）和端口（3600）登录远程主机\n\n```bash\nssh -p3600 root@192.168.1.100\n```\n\n\n\n输入用户登录密码后完成登录。\n\n如果未指明端口和用户名，则分别由配置文件 ~/.ssh/ssh_config 和 /etc/ssh/ssh_config 中的 Port 和 User 选项决定。如果配置文件未指定，则端口默认为 22 ，用户名默认为当前用户。\n\n也可以在 ~/.ssh/config 配置文件中设置远程服务器别名，格式如下：\n\n```bash\nHost 服务器名A\n    User 用户名\n    Hostname 服务器ip\n    Port 端口号\n    Identityfile 本地私钥地址\n```\n\n\n\n例如：\n\n```bash\nHost nanopi\n\tHostName 192.168.1.100\n\tUser pi\n\tPort 22\n\tIdentityFile ~/.ssh/id_ed25519\n```\n\n\n\n这样，你就可以直接指定 nanopi 配置登录远程主机，命令如下：\n\n```text\nssh nanopi\n```\n\n\n\n## 配置说明\n\n下面是 ~/.ssh/config 配置文件的配置选项：\n\n- 必须配置\n\n  - `Host`：指定配置块。\n  - `User`：指定登录用户。\n  - `Hostname`：指定服务器地址，通常用 `ip` 地址。\n  - `Port`：指定端口号，默认值为 `22`。\n\n- 可选\n\n  - `Identityfile`：指定本地认证私钥地址。\n\n  - `ForwardAgent yes`：允许 `ssh-agent` 转发。\n\n  - `IdentitiesOnly`：指定`ssh`是否仅使用配置文件或命令行指定的私钥文件进行认证。值为 `yes` 或 `no`，默认为 `no`，该情况可在 `ssh-agent` 提供了太多的认证文件时使用。\n\n  - `IdentityFile`：指定认证私钥文件。\n\n  - ```\n    StrictHostKeyChecking\n    ```\n\n    ：有 3 种选项。\n\n    - `ask`：默认值，第一次连接陌生服务器时提示是否添加，同时如果远程服务器公钥改变时拒绝连接。\n    - `yes`：不会自动添加服务器公钥到 `~/.ssh/known_hosts` 中，同时如果远程服务器公钥改变时拒绝连接。\n    - `no`：自动增加新的主机键到 `~/.ssh/known_hosts` 中。\n\n另外，编辑 ~/.ssh/config 配置文件时还需要注意以下几点：\n\n- 通过 `Host` 指定配置块，用 `tab` 键来区分配置头和内置参数。\n- 所有参数值都可使用通配符设定，比如可以设置一个 `Host` 值为星号（`*`），用于设置全局配置。\n- 配置文件不区分大小写，所以 `Host` 和 `host` 一样。\n- 注释用 `#` 号开头。\n\n\n\n# Linux scp 命令 - 远程安全复制文件\n\n## 介绍\n\n**scp**（SecureCopy 的缩写）命令是 OpenSSH 套件的组成部分，是一个具有类 RCP 命令接口的文件传输客户端。用于在 Linux 下进行远程拷贝文件的命令，和它类似的命令有 [`cp`](https://getiot.tech/linux-command/cp/)，不过 `cp` 只是在本机进行拷贝不能跨服务器，而且 scp 传输是加密的。\n\nscp 占用资源少，不会对系统负荷造成太大影响，与之类似的 [`rsync`](https://getiot.tech/linux-command/rsync/) 虽然速度相当快，但会导致硬盘 I/O 非常高，而 scp 基本不影响系统正常使用。\n\n**语法**：\n\n```bash\nscp [OPTION] source ... target\n```\n\n\n\n**选项**：\n\n- `-1`：强制 scp 命令使用协议 ssh1\n- `-2`：强制 scp 命令使用协议 ssh2\n- `-4`：强制 scp 命令只使用 IPv4 寻址\n- `-6`：强制 scp 命令只使用 IPv6 寻址\n- `-B`：使用批处理模式（传输过程中不询问传输口令或短语）\n- `-C`：允许压缩（将 -C 标志传递给 ssh，从而打开压缩功能）\n- `-p`：保留原文件的修改时间，访问时间和访问权限。\n- `-q`：不显示传输进度条。\n- `-r`：递归复制整个目录。\n- `-v`：详细方式显示输出。scp 和 ssh 会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。\n- `-c cipher`：以 cipher 将数据传输进行加密，这个选项将直接传递给 ssh。\n- `-F ssh_config`：指定一个替代的 ssh 配置文件，此参数直接传递给 ssh。\n- `-i identity_file`：从指定文件中读取传输时使用的密钥文件，此参数直接传递给 ssh。\n- `-l limit`：限定用户所能使用的带宽，以 Kbit/s 为单位。\n- `-o ssh_option`：可用于以 ssh_config 中使用的格式将选项传递给 ssh。\n- `-P port`：注意是大写的P，port 是指定数据传输用到的端口号\n- `-S program`：指定加密传输时所使用的程序。此程序必须能够理解 ssh 的选项。\n\n## 示例\n\n假设远程服务器 IP 地址为 192.168.1.100，用户名为 root。\n\n将本地文件（例如 /opt/file.tar.gz）复制到远程服务器的 /opt 目录：\n\n```bash\nscp /opt/file.tar.gz root@192.168.1.100:/opt/\n```\n\n\n\n从远程服务器复制文件 file.tar.gz 到本地 /opt 目录：\n\n```bash\nscp root@192.168.1.100:/opt/file.tar.gz /opt/\n```\n\n\n\n将本地目录（例如 /var/www/html）复制到远程服务器的 /opt 目录：\n\n```bash\nscp -r /var/www/html root@192.168.1.100:/opt/\n```\n\n\n\n\n\n# Linux ftp 命令 - 文件传输协议客户端\n\n## 介绍\n\n**ftp** 命令是 FTP 文件传输协议（File Transfer Protocol）的客户端工具，用于本地主机和远程文件服务器之间上传和下载文件。ftp 命令使用 FTP 协议和远程文件服务器进行通信。\n\nFTP 协议使用明文传送用户的认证信息，和容易被局域网内的嗅探软件截获，所以使用 ftp 命令时要格外注意。\n\n匿名 FTP 服务器在登录时使用“anonymous”作为用户名，用任意的电子邮件作为密码。通常，匿名 FTP 服务器只能下载文件，而不允许用户上传文件。\n\n**语法**：\n\n```shell\nftp [-46pinegvd] [host [port]]\n```\n\n\n\n**选项**：\n\n- `-d` ：使用调试模式运行（会详细显示指令执行过程，便于排错或分析程序执行的情况）。\n- `-i` ：关闭互动模式，在遇到问题时不询问用户而直接执行。\n- `-g` ：关闭本地主机文件名称支持特殊字符的扩充特性。\n- `-n` ：不使用自动登录。\n- `-v` ：显示指令执行过程的详细信息。\n- `-t` ：激活数据包包追踪。\n- `-4` ：只使用 IPv4。\n- `-6` ：只使用 IPv6。\n\n**参数**：主机名或 IP 地址，以及端口号\n\n## 示例\n\n启动 vsftpd 服务（FTP 默认端口为 21）\n\n```shell\n$ sudo service vsftpd start \n```\n\n\n\n打开 ftp 客户端，进入交互界面\n\n```shell\n$ ftp\nftp>\n```\n\n\n\n在交互界面中查看内部命令的帮助\n\n```shell\nftp> help\n```\n\n\n\n在交互界面连接 FTP 服务器\n\n```shell\nftp> open 192.168.1.100\n```\n\n\n\n如果端口不是 21，则需要指定端口（比如 2020）\n\n```shell\nftp> open 192.168.1.100 2020\n```\n\n\n\n从服务器中下载文件到本地\n\n```shell\nftp> get remote-file local-file\n```\n\n\n\n将一个本地的文件上传到服务器\n\n```shell\nftp> put local-file remote-file\n```\n\n\n\n退出 ftp 客户端\n\n```shell\nftp> quit\n```\n\n\n\n\n\n# Linux curl 命令 - 网络请求传输工具\n\n## 介绍\n\n**curl**（英文全拼：CommandLine URL）命令是在命令行方式下工作，利用 URL 的语法进行数据的传输或者文件的传输。\n\n通常大家会把 curl 理解为下载工具，但其实它的功能十分强大。curl 支持包括 HTTP、HTTPS、FTP 等传输协议，还支持 POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等功能。甚至可用于网页处理流程和数据检索自动化。\n\nURL 即 Uniform Resource Locator（统一资源定位符），是用于完整地描述 Internet 上网页和其他资源的地址的一种标识方法。比如 `https://getiot.tech` 就是一个 URL。\n\n**语法**：\n\n```bash\ncurl [options / URLs]\n```\n\n\n\n**选项**：\n\n- `-a`, `--append` ：上传文件时，附加到目标文件。\n- `-A`, `--user-agent <string>` ：设置用户代理发送给服务器。\n- `-anyauth` ：可以使用“任何”身份验证方法。\n- `-b`, `--cookie <name=string/file>` ：cookie 字符串或文件读取位置。\n- `-c`, `--cookie-jar <file>` ：操作结束后把 cookie 写入到这个文件中。\n- `-C`, `--continue-at <offset>` ：断点续转。\n- `-d`, `--data <data>` ：以 post 的方式传送数据。\n- `-D`, `--dump-header <file>` ：把 header 信息写入到该文件中。\n- `-e`, `--referer` ：来源网址。\n- `-E`, `--cert <cert[:passwd]>` ：客户端证书文件和密码（SSL）。\n- `-f`, `--fail` ：连接失败时不显示 http 错误。\n- `-F`, `--form <name=content>` ：模拟 http 表单提交数据。\n- `-G`, `--get` ：以 get 的方式来发送数据。\n- `-H`, `--header <line>` ：自定义头信息传递给服务器。\n- `-I`, `--head` ：只显示请求头信息。\n- `-o`, `--output <file>` ：写入文件而不是标准输出。\n- `-O`, `--remote-name` ：将输出写入与远程文件名字相同的文件。\n- `-s`, `--silent` ：静默模式。不输出任何东西。\n- `-u`, `--user <user[:password]>` ：设置服务器的用户和密码。\n- `-U`, `--proxy-user <user[:password]>` ：设置代理用户名和密码。\n\n## 示例\n\n抓取“人人都懂物联网”网站首页：\n\n```bash\ncurl https://getiot.tech\n```\n\n\n\n将网页数据保存到本地文件：\n\n```bash\ncurl https://getiot.tech > index.html\n```\n\n\n\n设置 cookies：\n\n```bash\ncurl https://getiot.tech --cookie \"user=root;pass=123456\"\n```\n\n\n\n设置用户代理字符串：\n\n```bash\ncurl URL --user-agent \"Mozilla/5.0\"\ncurl URL -A \"Mozilla/5.0\"\n```\n\n\n\n进行 HTTP 或者 FTP 的登录认证（可以指定密码，也可以不指定密码在后续操作中输入密码）：\n\n```bash\ncurl -u user:pwd https://getiot.tech\ncurl -u user https://getiot.tech\n```\n\n\n\n只打印响应头部信息：\n\n```bash\ncurl -I https://getiot.tech\n```\n\n\n\n下载远程文件：\n\n```bash\ncurl -O https://static.getiot.tech/flag-of-china.png\n```\n\n\n\n下载远程文件，并重命名：\n\n```bash\ncurl -o test.png https://static.getiot.tech/flag-of-china.png\n```\n\n\n\n下载远程文件，并显示下载进度：\n\n```bash\ncurl -# -O https://static.getiot.tech/flag-of-china.png\n```\n\n\n\n下载并执行 nvm 的安装脚本（`-o-` 选项指定将下载的数据输出到标准输出，而不是保存为文件，这意味着下载的内容会被直接传输到管道）：\n\n```bash\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash\n```\n\n\n\n\n\n# Linux wget 命令 - 网络文件下载工具\n\n## 介绍\n\n**wget** 是一个用于从 web 下载文件的 Linux 命令行工具。支持 HTTP、HTTPS 和 FTP 协议，可以使用 HTTP 代理。\n\n**语法**：\n\n```bash\nwget [option]... [URL]...\n```\n\n\n\n**选项**：\n\n- 启动参数\n\n  - `-V`, `--version` ：显示版本信息后退出。\n  - `-h`, `--help` ：显示帮助信息后退出。\n  - `-b`, `--background` ：启动后转入后台执行。\n  - `-e`, `--execute=COMMAND` ：执行 .wgetrc 格式的命令（wgetrc 格式参见 /etc/wgetrc 或 ~/.wgetrc）。\n\n- 记录和输入文件参数\n\n  - `-o`, `--output-file=FILE` ：把记录写到 FILE 文件中。\n  - `-a`, `--append-output=FILE` ：把记录追加到 FILE 文件中。\n  - `-d`, `--debug` ：打印调试输出。\n  - `-q`, `–quiet` ：安静模式（没有输出）。\n  - `-v`, `--verbose` ：冗长模式（这是缺省设置）。\n  - `-nv`, `--non-verbose` ：关闭冗长模式，但不是安静模式。\n  - `-i`, `--input-file=FILE` ：下载在 FILE 文件中出现的 URLs。\n  - `-F`, `--force-html` ：把输入文件当作 HTML 格式文件对待。\n  - `-B`, `--base=URL` ：将 URL 作为在 `-i` 参数指定的文件中出现的相对链接的前缀。\n  - `--sslcertfile=FILE` ：可选客户端证书。\n  - `--sslcertkey=KEYFILE` ：可选客户端证书的 KEYFILE。\n  - `--egd-file=FILE` ：指定 EGD socket 的文件名。\n\n- 下载参数\n\n  - `--bind-address=ADDRESS` ：指定本地使用地址（主机名或 IP，当本地有多个 IP 或名字时使用）。\n  - `-t`, `--tries=NUMBER` ：设定最大尝试链接次数（0 表示无限制）。\n  - `-O`, `--output-document=FILE` ：把文档写到 FILE 文件中。\n  - `-nc`, `--no-clobber` ：不要覆盖存在的文件或使用 .# 前缀。\n  - `-c`, `--continue` ：接着下载没下载完的文件。\n  - `--progress=TYPE` ：设定进程条标记。\n  - `-N`, `--timestamping` ：不要重新下载文件除非比本地文件新。\n  - `-S`, `--server-response` ：打印服务器的回应。\n  - `--spider` ：不下载任何东西。\n  - `-T`, `--timeout=SECONDS` ：设定响应超时的秒数。\n  - `-w`, `--wait=SECONDS` ：两次尝试之间间隔 SECONDS 秒。\n  - `--waitretry=SECONDS` ：在重新链接之间等待 1…SECONDS 秒。\n  - `--random-wait` ：在下载之间等待 0…2*WAIT 秒。\n  - `-Y`, `--proxy=on/off` ：打开或关闭代理。\n  - `-Q`, `--quota=NUMBER` ：设置下载的容量限制。\n  - `--limit-rate=RATE` ：限定下载输率。\n\n- 目录参数\n\n  - `-nd`, `--no-directories` ：不创建目录。\n  - `-x`, `--force-directories` ：强制创建目录。\n  - `-nH`, `--no-host-directories` ：不创建主机目录。\n  - `-P`, `--directory-prefix=PREFIX` ：将文件保存到目录 `PREFIX/…`。\n  - `--cut-dirs=NUMBER` ：忽略 NUMBER 层远程目录。\n\n- HTTP 选项参数\n\n  - `--http-user=USER` ：设定 HTTP 用户名为 USER。\n  - `--http-passwd=PASS` ：设定 http 密码为 PASS。\n  - `-C`, `--cache=on/off` ：允许/不允许服务器端的数据缓存（一般情况下允许）。\n  - `-E`, `--html-extension` ：将所有 text/html 文档以 .html 扩展名保存。\n  - `--ignore-length` ：忽略 `Content-Length` 头域。\n  - `--header=STRING` ：在 headers 中插入字符串 STRING。\n  - `--proxy-user=USER` ：设定代理的用户名为 USER。\n  - `--proxy-passwd=PASS` ：设定代理的密码为 PASS。\n  - `--referer=URL` ：在 HTTP 请求中包含 `Referer: URL` 头。\n  - `-s`, `--save-headers` ：保存 HTTP 头到文件。\n  - `-U`, `--user-agent=AGENT` ：设定代理的名称为 AGENT 而不是 Wget/VERSION。\n  - `--no-http-keep-alive` ：关闭 HTTP 活动链接（永久链接）。\n  - `--cookies=off` ：不使用 cookies。\n  - `--load-cookies=FILE` ：在开始会话前从文件 FILE 中加载 cookie。\n  - `--save-cookies=FILE` ：在会话结束后将 cookies 保存到 FILE 文件中。\n\n- FTP 选项参数\n\n  - `-nr`, `–dont-remove-listing` ：不移走 .listing 文件。\n  - `-g`, `--glob=on/off` ：打开或关闭文件名的 globbing 机制。\n  - `--passive-ftp` ：使用被动传输模式（缺省值）。\n  - `--active-ftp` ：使用主动传输模式。\n  - `--retr-symlinks` ：在递归的时候，将链接指向文件（而不是目录）。\n\n- 递归下载参数\n\n  - `-r`, `--recursive` ：递归下载。\n  - `-l`, `--level=NUMBER` ：最大递归深度（inf 或 0 代表无穷）。\n  - `--delete-after` ：在现在完毕后局部删除文件。\n  - `-k`, `--convert-links` ：转换非相对链接为相对链接。\n  - `-K`, `--backup-converted` ：在转换文件 X 之前，将之备份为 X.orig。\n  - `-m`, `--mirror` ：等价于 `-r -N -l inf -nr`。\n  - `-p`, `--page-requisites` ：下载显示 HTML 文件的所有图片。\n\n- 递归下载中的包含和不包含\n\n  （accept/reject）\n\n  - `-A`, `--accept=LIST` ：分号分隔的被接受扩展名的列表。\n  - `-R`, `--reject=LIST` ：分号分隔的不被接受的扩展名的列表。\n  - `-D`, `--domains=LIST` ：分号分隔的被接受域的列表。\n  - `--exclude-domains=LIST` ：分号分隔的不被接受的域的列表。\n  - `--follow-ftp` ：跟踪 HTML 文档中的 FTP 链接。\n  - `--follow-tags=LIST` ：分号分隔的被跟踪的 HTML 标签的列表。\n  - `-G`, `--ignore-tags=LIST` ：分号分隔的被忽略的 HTML 标签的列表。\n  - `-H`, `--span-hosts` ：当递归时转到外部主机。\n  - `-L`, `--relative` ：仅仅跟踪相对链接。\n  - `-I`, `--include-directories=LIST` ：允许目录的列表。\n  - `-X`, `--exclude-directories=LIST` ：不被包含目录的列表。\n  - `-np`, `--no-parent` ：不要追溯到父目录。\n\n## 示例\n\n**下载单个文件**\n\n```bash\nwget https://github.com/getiot/helloworld/archive/refs/tags/v1.0.zip\n```\n\n\n\n**下载并以指定文件名保存**（wget 默认会以最后一个符号 `/` 后面的字符来命名下载文件）\n\n```bash\nwget -O helloworld.zip https://github.com/getiot/helloworld/archive/refs/tags/v1.0.zip\n```\n\n\n\n**限速下载**（wget 默认会占用全部可能的宽带下载，当需要下载大文件时，就有必要进行限速）\n\n```bash\nwget --limit-rate=300k https://github.com/getiot/helloworld/archive/refs/tags/v1.0.zip\n```\n\n\n\n**断点续传**（使用 -c 选项可以在重新启动 wget 时继续接着下载，而不是重新下载一个文件）\n\n```bash\nwget -c https://github.com/getiot/helloworld/archive/refs/tags/v1.0.zip\n```\n\n\n\n**后台下载**\n\n```bash\nwget -b https://github.com/getiot/helloworld/archive/refs/tags/v1.0.zip\n\nContinuing in background, pid 1840.\nOutput will be written to `wget-log'.\n```\n\n\n\n对于下载非常大的文件的时候，我们可以使用 `-b` 选项进行后台下载，输出记录在 wget-log 文件，可以使用以下命令查看下载进度：\n\n```bash\ntail -f wget-log\n```\n\n\n\n**伪装代理名称下载**（有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求，可以通过 `--user-agent` 选项参数伪装）\n\n```bash\nwget --user-agent=\"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16\" https://github.com/getiot/helloworld/archive/refs/tags/v1.0.zip\n```\n\n\n\n**增加重试次数**（wget 默认重试 20 次连接下载文件）\n\n```bash\nwget --tries=40 https://github.com/getiot/helloworld/archive/refs/tags/v1.0.zip\n```\n\n\n\n**下载多个文件**\n\n```bash\nwget -i filelist.txt\n```\n\n\n\nfilelist.txt 文件记录下载链接文件，例如：\n\n```bash\ncat > filelist.txt\nhttps://github.com/getiot/helloworld/archive/refs/tags/v1.0.zip\nhttps://github.com/getiot/helloworld/archive/refs/tags/v2.0.zip\nhttps://github.com/getiot/helloworld/archive/refs/tags/v3.0.zip\n...\n```\n\n\n\n**镜像网站**（下载整个网站到本地）\n\n```bash\nwget --mirror -p --convert-links -P ./LOCAL <URL>\n```\n\n\n\n说明：\n\n- `--miror` 开启镜像下载。\n- `-p` 下载所有为 html 页面显示正常的文件。\n- `--convert-links` 下载后，转换成本地的链接。\n- `-P ./LOCAL` 保存所有文件和目录到本地指定目录。\n\n**过滤指定格式下载**（下载一个网站，但不希望下载图片）\n\n```bash\nwget --reject=gif <URL>\n```\n\n\n\n**把下载信息存入日志文件**\n\n```bash\nwget -o download.log <URL>\n```\n\n\n\n**限制总下载文件大小**（如果下载的文件超过 5M 则退出下载，该选项只对递归下载有效）\n\n```bash\nwget -Q5m -i filelist.txt\n```\n\n\n\n**下载指定格式文件**\n\n```bash\nwget -r -A.pdf <URL>\n```\n\n\n\n可以在以下情况使用该功能：\n\n- 下载一个网站的所有图片。\n- 下载一个网站的所有视频。\n- 下载一个网站的所有 PDF 文件。\n\n**FTP 下载**\n\n```bash\nwget --ftp-user=USERNAME --ftp-password=PASSWORD <URL>\n```\n\n\n\n\n\n# Linux ping 命令 - 测试网络连接状态\n\n## 介绍\n\n**ping** 是一个非常常用的计算机网络测试工具，用于测试数据包能否透过 IP 协议到达特定主机，从而判断网络的连通性。无论是 Linux、Windows、macOS 还是嵌入式 RTOS 都会提供 ping 命令。ping 的运作原理是向目标主机传出一个 ICMP 的请求回显数据包，并等待接收回显回应数据包。程序会按时间和成功响应的次数估算丢失数据包率（丢包率）和数据包往返时间（网络时延，Round-trip delay time）。\n\n**语法**：\n\n```bash\nping [options] <destination>\n```\n\n\n\n**选项**：\n\n- `<destination>`：IP 地址或 DNS 域名。\n- `-a`：使用听得见的（audible）ping。\n- `-A`：使用自适应（adaptive）ping。\n- `-B`：粘性源地址（sticky source address）。\n- `-c <count>`：在 `<count>` 个回复后停止。\n- `-D`：打印时间戳。\n- `-d`：使用 `SO_DEBUG` 套接字选项。\n- `-f`：flood ping。\n- `-h`：打印帮助信息。\n- `-I <interface>`：指定网卡接口名称或 IP 地址。\n- `-i <interval>`：指定发送每个数据包之间的时间间隔（秒数）。\n- `-L`：抑制组播（multicast）数据包的环回（loopback）。\n- `-l <preload>`：在等待回复时发送 `<preload>` 个包数。\n- `-m <mark>`：标记发出的数据包。\n- `-M <pmtud opt>`：定义 mtu 发现，可以是 `<do|dont|want>` 之一。\n- `-n`：没有 DNS 名称解析。\n- `-O`：报告未完成的答复。\n- `-p <pattern>`：填充字节的内容。\n- `-q`：安静的输出。\n- `-Q <tclass>`：使用服务质量 `<tclass>` 位。\n- `-s <size>`：使用 `<size>` 作为要发送的数据字节数。\n- `-S <size>`：使用 `<size>` 作为 `SO_SNDBUF` 套接字选项的值。\n- `-t <ttl>`：定义生存时间。\n- `-U`：打印用户到用户（user-to-user）的延迟（latency）。\n- `-v`：详细输出。\n- `-V`：打印版本信息并退出。\n- `-w <deadline>`：回复等待 `<deadline>` 秒。\n- `-W <timeout>`：等待响应的时间。\n\n**IPv4 专用选项**：\n\n- `-4`：使用 IPv4。\n- `-b`：允许 ping 广播。\n- `-R`：记录路由。\n- `-T <timestamp>`：定义时间戳，可以是 `<tsonly|tsandaddr|tsprespec>` 之一。\n\n**IPv6 专用选项**：\n\n- `-6`：使用 IPv6。\n- `-F <flowlabel>`：定义流标签，默认为随机。\n- `-N <nodeinfo opt>`：使用 icmp6 节点信息查询。\n\n## 示例\n\n测试本机与「人人都懂物联网」网站的连通情况\n\n```bash\nping getiot.tech\n```\n\n\n\n测试本机与 192.168.0.2 设备的网络连通情况\n\n```bash\nping 192.168.0.2\n```\n\n\n\n指定网卡进行 ping 测试（网卡名称可通过 [ifconfig](https://getiot.tech/linux-command/ifconfig/) 命令查看）\n\n```bash\nping -I eth0 192.168.0.2\n```\n\n\n\n测试 1000 次\n\n```bash\nping -c 1000 192.168.0.2\n```\n\n\n\n以时间间隔 2 秒测试 1000 次\n\n```bash\nping -i 2 -c 1000 192.168.0.2\n```\n\n\n\n\n\n# Linux dig 命令 - 域名查询工具\n\n## 介绍\n\n**dig**（英文全拼：domain information groper）是一个用来灵活探测 DNS 的工具。它会打印出受请求的 DNS 域名服务器的回应。\n\n多数 DNS 管理员利用 dig 作为 DNS 问题的故障诊断，因为它灵活性好、易用、输出清晰。虽然通常情况下 dig 使用命令行参数，但它也可以按批处理模式从文件读取搜索请求。\n\n**语法**：\n\n```bash\ndig [选项] [参数]\n```\n\n\n\n详细语法格式\n\n```bash\ndig [@server] [-b address] [-c class] [-f filename] [-k filename] [-m]\n    [-p port#] [-q name] [-t type] [-v] [-x addr] [-y [hmac:]name:key]\n    [[-4] | [-6]] [name] [type] [class] [queryopt...]\n```\n\n\n\n**选项**：\n\n- `@<server>` ：指定进行域名解析的域名服务器。\n- `-b <address>` ：设置所要询问地址的源 IP 地址。这必须是主机网络接口上的某一合法的地址。当主机具有多个IP地址，指定使用本机的哪个IP地址向域名服务器发送域名查询请求。\n- `-c <class>` ：缺省查询类（IN for internet）由选项 -c 重设。class 可以是任何合法类，比如查询 Hesiod 记录的 HS 类或查询 CHAOSNET 记录的 CH 类。\n- `-f <filename>` ：使 dig 在批处理模式下运行，通过从文件 filename 读取一系列搜索请求加以处理。文件包含许多查询；每行一个。文件中的每一项都应该以和使用命令行接口对 dig 的查询相同的方法来组织。\n- `-k <filename>` ：要签署由 dig 发送的 DNS 查询以及对它们使用事务签名（TSIG）的响应，用 选项 -k 指定 TSIG 密钥文件。\n- `-p <port>` ：如果需要查询一个非标准的端口号，则使用 -p 选项。port 是 dig 将发送其查询的端口号，而不是标准的 DNS 端口号 53。该选项可用于测试已在非标准端口号上配置成侦听查询的域名服务器。\n- `-t <type>` ：设置查询类型为 type。可以是 BIND9 支持的任意有效查询类型。缺省查询类型是 A，除非提供 -x 选项来指示一个逆向查询。通过指定 AXFR 的 type 可以请求一个区域传输。当需要增量区域传输（IXFR）时，type 设置为 ixfr=N。增量区域传输将包含自从区域的 SOA 记录中的序列号改为 N 之后对区域所做的更改。\n- `-x <addr>` ：逆向查询（将地址映射到名称）可以通过 -x 选项加以简化。addr 是一个 以小数点为界的 IPv4 地址或冒号为界的 IPv6 地址。当使用这个选项时，无需提供 name、class 和 type 参数。dig 自动运行类似 `11.12.13.10.in-addr.arpa` 的域名查询，并分别设置查询类型和类为 PTR 和 IN。\n- `-y [hmac:]name:key` ：您可以通过命令行上的 -y 选项指定 TSIG 密钥；name 是 TSIG 密码的名称，key 是实际的密码。密码是 64 位加密字符串，通常由 dnssec-keygen（8）生成。当在多用户系统上使用选项 -y 时应该谨慎，因为密码在 ps（1）的输出或 shell 的历史文件中可能是可见的。当同时使用 dig 和 TSCG 认证时，被查询的名称服务器需要知道密码和解码规则。在 BIND 中，通过提供正确的密码和 named.conf 中的服务器声明实现。\n- `-4` ：只使用 IPv4。\n- `-6` ：只使用 IPv6。\n- `-h` ：显示指令帮助信息。\n\n**参数**：\n\n- 主机（name）：指定要查询域名主机。\n- 查询类型（type）：指定 DNS 查询的类型。\n- 查询类（class）：指定查询 DNS 的 class。\n- 查询选项（queryopt）：指定查询选项。使用不同的查询选项会影响搜索方式和结果显示，每个查询选项被带前缀（+）的关键字标识，通常前缀是求反关键字含义的字符串 no，其他关键字分配各选项的值（比如超时时间间隔），它们的格式形如 +keyword=value。\n\n**查询选项**：\n\n- `+[no]tcp` ：查询域名服务器时使用 [不使用] TCP。缺省行为是使用 UDP，除非是 AXFR 或 IXFR 请求，才使用 TCP 连接。\n- `+[no]vc` ：查询名称服务器时使用 [不使用] TCP。+[no]tcp 的备用语法提供了向下兼容。 vc 代表虚电路。\n- `+[no]ignore` ：忽略 UDP 响应的中断，而不是用 TCP 重试。缺省情况运行 TCP 重试。\n- `+domain=somename` ：设定包含单个域 somename 的搜索列表，好像被 /etc/resolv.conf 中的域伪指令指定，并且启用搜索列表处理，好像给定了 +search 选项。\n- `+[no]search` ：使用 [不使用] 搜索列表 或 resolv.conf 中的域伪指令（如果有的话）定义的搜索列表。缺省情况不使用搜索列表。\n- `+[no]defname` ：不建议看作 +[no]search 的同义词。\n- `+[no]aaonly` ：该选项不做任何事。它用来提供对设置成未实现解析器标志的 dig 的旧版本的兼容性。\n- `+[no]adflag` ：在查询中设置 [不设置] AD（真实数据）位。目前 AD 位只在响应中有标准含义，而查询中没有，但是出于完整性考虑在查询中这种性能可以设置。\n- `+[no]cdflag` ：在查询中设置 [不设置] CD（检查禁用）位。它请求服务器不运行响应信息的 DNSSEC 合法性。\n- `+[no]recursive` ：切换查询中的 RD（要求递归）位设置。在缺省情况下设置该位，也就是说 dig 正常情形下发送递归查询。当使用 查询选项 +nssearch 或 +trace 时，递归自动禁用。\n- `+[no]nssearch` ：这个选项被设置时，dig 试图寻找包含待搜名称的网段的权威域名服务器，并显示网段中每台域名服务器的 SOA 记录。\n- `+[no]trace` ：切换为待查询名称从根名称服务器开始的代理路径跟踪。缺省情况不使用跟踪。一旦启用跟踪，dig 使用迭代查询解析待查询名称。它将按照从根服务器的参照，显示来自每台使用解析查询的服务器的应答。\n- `+[no]cmd` ：设定在输出中显示指出 dig 版本及其所用的查询选项的初始注释。缺省情况下显示注释。\n- `+[no]short` ：提供简要答复。缺省值是以冗长格式显示答复信息。\n- `+[no]identify` ：当启用 +short 选项时，显示 [或不显示] 提供应答的 IP 地址和端口号。如果请求简短格式应答，缺省情况不显示提供应答的服务器的源地址和端口号。\n- `+[no]comments` ：切换输出中的注释行显示。缺省值是显示注释。\n- `+[no]stats` ：该查询选项设定显示统计信息：查询进行时，应答的大小等等。缺省显示查询统计信息。\n- `+[no]qr` ：显示 [不显示] 发送的查询请求。缺省不显示。\n- `+[no]question` ：当返回应答时，显示 [不显示] 查询请求的问题部分。缺省作为注释显示问题部分。\n- `+[no]answer` ：显示 [不显示] 应答的回答部分。缺省显示。\n- `+[no]authority` ：显示 [不显示] 应答的权限部分。缺省显示。\n- `+[no]additional` ：显示 [不显示] 应答的附加部分。缺省显示。\n- `+[no]all` ：设置或清除所有显示标志。\n- `+time=T` ：为查询设置超时时间为 T 秒。缺省是5秒。如果将 T 设置为小于1的数，则以1秒作为查询超时时间。\n- `+tries=A` ：设置向服务器发送 UDP 查询请求的重试次数为 A，代替缺省的 3 次。如果把 A 小于或等于 0，则采用 1 为重试次数。\n- `+ndots=D` ：出于完全考虑，设置必须出现在名称 D 的点数。缺省值是使用在 /etc/resolv.conf 中的 ndots 语句定义的，或者是 1，如果没有 ndots 语句的话。带更少点数的名称 被解释为相对名称，并通过搜索列表中的域或文件 /etc/resolv.conf 中的域伪指令进行搜索。\n- `+bufsize=B` ：设置使用 EDNS0 的 UDP 消息缓冲区大小为 B 字节。缓冲区的最大值和最小值分别为 65535 和 0。超出这个范围的值自动舍入到最近的有效值。\n- `+[no]multiline` ：以详细的多行格式显示类似 SOA 的记录，并附带可读注释。缺省值是每单个行上显示一条记录，以便于计算机解析 dig 的输出。\n\n## 示例\n\n不加任何参数，可以显示 internet 上的13个根域服务器\n\n```bash\n$ dig\n\n; <<>> DiG 9.16.1-Ubuntu <<>>\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 61518\n;; flags: qr rd ra; QUERY: 1, ANSWER: 13, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; udp: 65494\n;; QUESTION SECTION:\n;.\t\t\t\tIN\tNS\n\n;; ANSWER SECTION:\n.\t\t\t203341\tIN\tNS\tj.root-servers.net.\n.\t\t\t203341\tIN\tNS\tb.root-servers.net.\n.\t\t\t203341\tIN\tNS\ti.root-servers.net.\n.\t\t\t203341\tIN\tNS\th.root-servers.net.\n.\t\t\t203341\tIN\tNS\tk.root-servers.net.\n.\t\t\t203341\tIN\tNS\ta.root-servers.net.\n.\t\t\t203341\tIN\tNS\tg.root-servers.net.\n.\t\t\t203341\tIN\tNS\tm.root-servers.net.\n.\t\t\t203341\tIN\tNS\tc.root-servers.net.\n.\t\t\t203341\tIN\tNS\tl.root-servers.net.\n.\t\t\t203341\tIN\tNS\tf.root-servers.net.\n.\t\t\t203341\tIN\tNS\te.root-servers.net.\n.\t\t\t203341\tIN\tNS\td.root-servers.net.\n\n;; Query time: 36 msec\n;; SERVER: 127.0.0.53#53(127.0.0.53)\n;; WHEN: 四 4月 15 08:12:52 CST 2021\n;; MSG SIZE  rcvd: 239\n```\n\n\n\n查询 getiot.tech 域名的信息\n\n```bash\n$ dig getiot.tech\n\n; <<>> DiG 9.16.1-Ubuntu <<>> getiot.tech\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 37046\n;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; udp: 65494\n;; QUESTION SECTION:\n;getiot.tech.\t\t\tIN\tA\n\n;; ANSWER SECTION:\ngetiot.tech.\t\t600\tIN\tA\t42.192.64.149\n\n;; Query time: 340 msec\n;; SERVER: 127.0.0.53#53(127.0.0.53)\n;; WHEN: 四 4月 15 08:11:33 CST 2021\n;; MSG SIZE  rcvd: 56\n```\n\n\n\n查询 getiot.tech 域名的信息，进行简短输出\n\n```bash\n$ dig getiot.tech +short\n42.192.64.149\n```\n\n\n\n跟踪域名解析过程\n\n```bash\n$ dig getiot.tech +trace\n\n; <<>> DiG 9.16.1-Ubuntu <<>> getiot.tech +trace\n;; global options: +cmd\n.\t\t\t6919\tIN\tNS\td.root-servers.net.\n.\t\t\t6919\tIN\tNS\te.root-servers.net.\n.\t\t\t6919\tIN\tNS\tf.root-servers.net.\n.\t\t\t6919\tIN\tNS\tl.root-servers.net.\n.\t\t\t6919\tIN\tNS\tc.root-servers.net.\n.\t\t\t6919\tIN\tNS\tm.root-servers.net.\n.\t\t\t6919\tIN\tNS\tg.root-servers.net.\n.\t\t\t6919\tIN\tNS\ta.root-servers.net.\n.\t\t\t6919\tIN\tNS\tk.root-servers.net.\n.\t\t\t6919\tIN\tNS\th.root-servers.net.\n.\t\t\t6919\tIN\tNS\ti.root-servers.net.\n.\t\t\t6919\tIN\tNS\tb.root-servers.net.\n.\t\t\t6919\tIN\tNS\tj.root-servers.net.\n;; Received 262 bytes from 127.0.0.53#53(127.0.0.53) in 0 ms\n......\n```\n\n\n\n\n\n# Linux iperf 命令 - 网络带宽测试工具\n\n## 介绍\n\n**iperf** 是一个 Linux 网络性能测试命令行工具。可用于测试 TCP 和 UDP 带宽质量，例如最大 TCP 带宽等多种参数特性，报告带宽、延迟抖动和数据包丢失。因此，我们常常利用 iperf 工具来来测试一些网络设备的性能，如路由器、防火墙、交换机等。\n\nLinux 系统通常默认不安装 iperf 工具，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install iperf\n```\n\n\n\n另外还有一个 iperf3 工具，和 iperf 的区别是它不支持双工模式测试。\n\n**语法**：\n\n```bash\niperf [-s|-c host] [options]\niperf [-h|--help] [-v|--version]\n```\n\n\n\n**选项**：\n\n- `-f`, `--format [abkmgBKMG]`：格式化带宽数输出。每个字母分别对应：adaptive、bits、Bytes、Kbits、Mbits、Gbits、KBytes、MBytes、GBytes，默认参数是 a，即自适应。值得注意的是，在计算字节 byte 时，Kilo = 1024，Mega = 1024^2，Giga = 1024^3。通常在网络中，Kilo = 1000，Mega = 1000^2，Giga = 1000^3，所以 iperf 也按此来计算比特（位）。如果这些困扰了你，那么请使用 `-f b` 参数，然后亲自计算一下。\n- `-i`, `--interval`：设置每次报告之间的时间间隔，单位为秒。如果设置为非零值，就会按照此时间间隔输出测试报告。默认值为零。\n- `-l`, `--len n[kmKM]`：设置读写缓冲区的长度。TCP 方式默认为 8KB，UDP 方式默认为 1470 字节。\n- `-m`, `--print_mss`：输出 TCP 的 MSS 值（MSS 全称是 maximum segment size，通过 `TCP_MAXSEG` 支持）。通常情况下，MSS 值比 MTU 值小 40 字节。\n- `-p`, `--port`：设置端口，与服务器端的监听端口一致。默认使用 5001 端口。\n- `-u`, `--udp`：使用 UDP 方式而不是 TCP 方式。\n- `-w`, `--window n[kmKM]`：设置套接字缓冲区为指定大小。对于 TCP 方式，此设置为 TCP 窗口大小。对于 UDP 方式，此设置为接受 UDP 数据包的缓冲区大小，限制可以接受数据包的最大值。\n- `-B`, `--bind host`：绑定到主机的多个地址中的一个。对于客户端来说，这个参数设置了出栈接口。对于服务器端来说，这个参数设置入栈接口。这个参数只用于具有多网络接口的主机。在 iperf 的 UDP 模式下，此参数用于绑定和加入一个多播组。使用范围在 224.0.0.0 至 239.255.255.255 的多播地址。\n- `-C`, `--compatibility`：与低版本的 iperf 使用时，可以使用兼容模式。不需要两端同时使用兼容模式，但是强烈推荐两端同时使用兼容模式。某些情况下，使用某些数据流可以引起1.7版本的服务器端崩溃或引起非预期的连接尝试。\n- `-M`, `--mss`：ip 头减去 40 字节。在以太网中，MSS 值为 1460 字节（MTU 值为 1500 字节）。\n- `-N`, `--nodelay`：设置 TCP 无延迟选项，禁用 Nagle's 运算法则。通常情况此选项对于交互程序，例如 telnet，是禁用的。\n- `-V`, `--ipv6_domain`：绑定一个 IPv6 地址。 注意，在 1.6.3 或更高版本中，指定 IPv6 地址不需要使用 `-B` 参数绑定，在 1.6 之前的版本则需要。在大多数操作系统中，将响应 IPv4 客户端映射的 IPv4 地址。\n- `-h`, `--help`：显示命令行参考并退出。\n- `-v`, `--version`：显示版本信息和编译信息并退出。\n\n**服务器端专用选项**：\n\n- `-s`, `--server`：iperf 服务器模式 。\n- `-D`：Unix 平台下 iperf 作为后台守护进程运行。在 Win32 平台下，iperf 将作为服务运行。\n- `-R`：卸载 iperf 服务（如果它在运行），仅用于 Windows 系统。\n- `-o`：重定向输出到指定文件，仅用于 Windows 系统。\n- `-c`, `--client host`：如果 iperf 运行在服务器模式，并且用 `-c` 参数指定一个主机，那么 `iperf` 将只接受指定主机的连接。此参数不能工作于 UDP 模式。\n- `-P`, `--parallel`：服务器关闭之前保持的连接数。默认是 0，这意味着永远接受连接。\n\n**客户端专用选项**：\n\n- `-b`, `--bandwidth n[kmgKMG]`：UDP 模式使用的带宽，单位 bits/sec。此选项与 -u 选项相关。默认值是 1 Mbit/sec。\n- `-c`, `--client host`：运行 iperf 的客户端模式，连接到指定的 iperf 服务器端。\n- `-d`, `--dualtest`：运行双测试模式。这将使服务器端反向连接到客户端，使用 `-L` 参数中指定的端口（或默认使用客户端连接到服务器端的端口）。如果你想要一个交互的测试，请尝试 `-r` 参数。\n- `-n`, `--num n[kmKM]`：传送的缓冲器数量。通常情况，iperf 按照 10 秒钟发送数据。`-n` 参数跨越此限制，按照指定次数发送指定长度的数据，而不论该操作耗费多少时间。参考 `-l` 与 `-t` 选项。\n- `-r`, `--tradeoff`：往复测试模式。当客户端到服务器端的测试结束时，服务器端通过 `-l` 选项指定的端口（或默认为客户端连接到服务器端的端口），反向连接至客户端。当客户端连接终止时，反向连接随即开始。如果需要同时进行双向测试，请尝试 `-d` 参数。\n- `-t`, `--time`：设置传输的总时间。iperf 在指定的时间内，重复的发送指定长度的数据包。默认是 10 秒钟。参考 `-l` 与 `-n` 选项。\n- `-L`, `--listenport`：指定服务端反向连接到客户端时使用的端口。默认使用客户端连接至服务端的端口。\n- `-P`, `--parallel`：指定客户端与服务端之间使用的线程数，默认是 1 线程。需要客户端与服务器端同时使用此参数。\n- `-S`, `--tos`：出栈数据包的服务类型，不过许多路由器都忽略 TOS 字段。你可以指定这个值，使用以 \"0x\" 开始的 16 进制数，或以 \"0\" 开始的 8 进制数或 10 进制数。例如，十六进制 '0x10' = 八进制 '020' = 十进制 '16'。\n- `-T`, `--ttl`：出栈多播数据包的 TTL 值。这本质上就是数据通过路由器的跳数。默认是 1，链接本地。\n- `-F`：使用特定的数据流测量带宽，例如指定的文件。\n\n## 示例\n\n### UDP 模式\n\n启动 UDP 服务器端\n\n```bash\niperf -u -s\n```\n\n\n\n启动 UDP 客户端，以 100Mbps 为数据发送速率，测试时间为 60 秒。\n\n```bash\niperf -u -c 192.168.0.1 -b 100M -t 60\n```\n\n\n\n在 UDP 模式下，以 100M 为数据发送速率，进行上下行带宽测试。\n\n```bash\niperf -u -c 192.168.0.1 -b 100M -d -t 60\n```\n\n\n\n在 UDP 模式下，客户端同时向服务器端发起 30 个连接线程，以 5Mbps 为数据发送速率。\n\n```bash\niperf -u -c 192.168.0.1 -b 5M -P 30 -t 60\n```\n\n\n\n### TCP 模式\n\n启动 TCP 服务器端\n\n```bash\niperf -s\n```\n\n\n\n启动 TCP 客户端，连接到 192.168.0.1 服务器，进行上传带宽测试，测试时间为 60 秒。\n\n```bash\niperf -c 192.168.0.1 -t 60\n```\n\n\n\n在 TCP 模式下，进行上下行带宽测试。\n\n```bash\niperf -c 192.168.0.1 -d -t 60\n```\n\n\n\n在 TCP 模式下，客户端同时向服务器端发起 30 个连接线程。\n\n```bash\niperf -c 192.168.0.1 -P 30 -t 60\n```\n\n\n\n\n\n# Linux speedtest 命令 - 网络速度测试工具\n\n## 介绍\n\n**speedtest** 是一个测试网络速度的命令行工具，可在本地测量 Internet 连接性能指标，例如下载、上传、延迟和数据包丢失等，无需依赖 Web 浏览器。\n\nspeedtest 命令由 [speedtest-cli](https://github.com/sivel/speedtest-cli) 软件包提供，使用 Python 语言编写，因此你可以使用 pip 进行安装，在 Debian/Ubuntu 系统上也可以使用 apt 进行安装。\n\n- Ubuntu\n- Python\n\n```bash\nsudo apt install speedtest-cli\n```\n\n\n\n**语法**：\n\n```bash\nspeedtest [OPTION]\n```\n\n\n\n**选项**：\n\n- `--no-download`：不进行下载测试。\n- `--no-upload`：不执行上传测试。\n- `--single`：仅使用单个连接而不是多个连接（模拟了典型的文件传输）。\n- `--bytes`：以字节而不是位显示值。不影响 `--share` 生成的图像，也不影响 `--json` 或 `--csv` 的输出。\n- `--share`：在 speedtest.net 网站上生成网速测试结果的图片并提供 URL，使用 `--csv` 选项时不显示。\n- `--simple`：抑制详细输出，仅显示基本信息。\n- `--csv`：抑制详细输出，仅以 CSV 格式显示基本信息。速度以位/秒为单位列出，不受 `--bytes` 影响。\n- `--csv-delimiter CSV_DELIMITER`：在 CSV 输出中使用的单字符分隔符。 默认是逗号 “,”。\n- `--csv-header`：打印 CSV 标题。\n- `--json`：抑制详细输出，仅以 JSON 格式显示基本信息。速度以位/秒为单位列出，不受 `--bytes` 影响。\n- `--list`：根据距离排序显示 speedtest.net 的测试服务器列表。\n- `--server SERVER`：指定列表中的服务器 ID 作为测试服务器。\n- `--exclude EXCLUDE`：从选择中排除服务器。\n- `--mini MINI`：Speedtest Mini 服务器的 URL。\n- `--source SOURCE`：绑定的源 IP 地址。\n- `--timeout TIMEOUT`：HTTP 超时（以秒为单位），默认为 10 秒。\n- `--secure`：与 speedtest.net 运营的服务器通信时，使用 HTTPS 而不是 HTTP。\n- `--no-pre-allocate`：不要预先分配上传数据，默认情况下启用预分配以提高上传性能。如果要支持内存不足的系统，请使用此选项以避免 MemoryError。\n- `--version`：显示版本信息并退出。\n- `-h, --help`：显示帮助信息并退出。\n\n## 示例\n\n直接执行 **`speedtest`** 命令使用默认参数测试，稍等片刻即可看到结果：\n\n```bash\n$ speedtest\nRetrieving speedtest.net configuration...\nTesting from China Telecom (61.144.49.139)...\nRetrieving speedtest.net server list...\nSelecting best server based on ping...\nHosted by HKBN (Hong Kong) [134.49 km]: 76.016 ms\nTesting download speed................................................................................\nDownload: 11.15 Mbit/s\nTesting upload speed......................................................................................................\nUpload: 109.55 Mbit/s\n```\n\n\n\n列出所有测试服务器：\n\n```bash\n$ speedtest --list\nRetrieving speedtest.net configuration...\n33250) CTM Broadband (Macau, Macau) [106.48 km]\n37639) CMHK Broadband (Hong Kong, Hong Kong) [129.25 km]\n28912) fdcservers.net (Hong Kong, Hong Kong) [134.49 km]\n59303) HKBN (Hong Kong, Hong Kong) [134.49 km]\n60177) Club SIM by HKT (Hong Kong, Hong Kong) [134.49 km]\n61296) HKIX (Hong Kong, Hong Kong) [134.49 km]\n11711) Taiwan Mobile (Tainan, Taiwan) [709.09 km]\n40728) SEEDNET (Tainan, Taiwan) [709.09 km]\n32319) TNIC (Tainan, Taiwan) [713.48 km]\n18458) Chunghwa Mobile (Kaohsiung, Taiwan) [720.41 km]\n```\n\n\n\n指定测试服务器 ID（37639），并生成网速测试结果的图片：\n\n```bash\n$ speedtest-cli --server=37639 --share\nRetrieving speedtest.net configuration...\nTesting from China Telecom (61.144.49.139)...\nRetrieving speedtest.net server list...\nRetrieving information for the selected server...\nHosted by CMHK Broadband (Hong Kong) [129.25 km]: 308.478 ms\nTesting download speed................................................................................\nDownload: 1.46 Mbit/s\nTesting upload speed......................................................................................................\nUpload: 2.77 Mbit/s\nShare results: http://www.speedtest.net/result/15645788944.png\n```\n\n\n\n网速测试结果图片如下：\n\n![img](./Image/Linux命令大全.assets/speedtest-20231218.png)\n\n\n\n# Linux traceroute 命令 - 路由追踪显示路径\n\n## 介绍\n\n**traceroute** 命令用于跟踪、显示 IP 信息包至某个网络主机的路由。\n\n也就是说，通过 traceroute 命令就可以知道信息（数据包）从你的计算机到互联网另一端的主机是走的什么路径。当然，每次数据包由某一同样的出发点（source）到达某一同样的目的地（destination）走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。\n\ntraceroute 的工作原理是通过发送一系列的 ICMP（Internet Control Message Protocol）或 UDP（User Datagram Protocol）数据包，默认发送的数据包大小是40字节，然后观察每个数据包在网络中的传输情况，从而确定路径和测量每一跳的延迟。\n\n一条路径上的每个设备 traceroute 要测 3 次，输出结果中包括每次测试的时间（ms）和设备的名称（如有的话）及其 IP 地址。如果探测的回答来自不同的网关，那么命令会显示各个响应系统的地址。如果在 3 秒的超时时间间隔内没有来自探测的应答，那么将对该探测输出 *（星号）。\n\n注：\n\n**traceroute** 命令可以用来做网络测试、测量和管理。它应主要用于手动故障隔离。由于 traceroute 命令增加了网络负载，因此不应该在正常操作期间或从自动化脚本中使用此命令。\n\n**语法**：\n\n```bash\ntraceroute [-46dFITUnreAV] [-f first_ttl] [-g gate,...]\n           [-i device] [-m max_ttl] [-p port] [-s src_addr]\n           [-q nqueries] [-N squeries] [-t tos]\n           [-l flow_label] [-w waittimes] [-z sendwait] [-UL] [-D]\n           [-P proto] [--sport=port] [-M method] [-O mod_options]\n           [--mtu] [--back]\n           host [packet_len]\n```\n\n\n\n**选项**：\n\n- `-m <max_ttl>`：设置用于输出探测信息包的最大存活时间（最大的跳跃数）。缺省值为 30 个跳跃（TCP 连接也使用相同的缺省值）。\n- `-f <first_ttl>`：设置第一个检测数据包的存活数值 TTL 的大小。\n- `-g <gate,...>`：设置来源路由网关，最多可设置 8 个。\n- `-i <device>`：使用指定的网络接口送出数据包。\n- `-p <port>`：设置用于探测的基本 UDP 端口号，缺省值为 33434。\n- `-s <src_addr>`：设置本地主机送出数据包的 IP 地址。\n- `-r`：忽略普通的 Routing Table，直接将数据包送到远端主机上。\n- `-t <tos>`：设置检测数据包的 TOS（服务类型）数值。\n- `-w <waittimes>`：设置等待远端主机回报的时间。\n- `-n`：直接使用 IP 地址而非主机名称。\n- `-v`：详细显示指令的执行过程。\n\n## 示例\n\n显示到主机 **getiot.tech** 的路由：\n\n```bash\n$ traceroute -i eth0 -m 10 getiot.tech\ntraceroute to getiot.tech (42.192.64.149), 10 hops max, 60 byte packets\n 1  _gateway (192.168.1.1)  11.565 ms  11.502 ms  11.487 ms\n 2  172.16.0.1 (172.16.0.1)  17.092 ms  17.371 ms  17.357 ms\n 3  221.179.83.37 (221.179.83.37)  18.690 ms *  18.954 ms\n 4  120.196.243.21 (120.196.243.21)  20.673 ms 120.196.243.1 (120.196.243.1)  20.989 ms 120.196.243.21 (120.196.243.21)  19.925 ms\n 5  120.196.199.130 (120.196.199.130)  24.335 ms 120.196.199.114 (120.196.199.114)  24.569 ms 120.196.199.122 (120.196.199.122)  23.758 ms\n 6  120.241.50.2 (120.241.50.2)  24.762 ms 120.241.50.6 (120.241.50.6)  13.892 ms  12.839 ms\n 7  * * *\n 8  * * *\n 9  * * *\n10  * * *\n```\n\n\n\n\n\n# Linux trippy 命令 - 网络调试分析工具\n\n## 介绍\n\n**trippy** 是一个命令行工具（别名 **trip**），支持 Linux、Windows、macOS 等平台，可以代替 [traceroute](https://getiot.tech/linux-command/traceroute/) 查看互联网通信的路径，分析网络状况。\n\ntrippy 使用 Rust 语言实现，使用前需要安装，安装方法如下：\n\n- Cargo\n- Snap\n- Homebrew\n- WinGet\n- Scoop\n- Pacman\n\n```bash\ncargo install trippy\n```\n\n\n\n**语法**：\n\n```bash\ntrip [OPTIONS] [TARGETS]...\n```\n\n\n\n注：trip 是 trippy 的软链接，因此可以用 trip 代替 trippy。\n\n## 示例\n\n具有默认参数的基本用法：\n\n```bash\ntrip example.com\n```\n\n\n\n注意：在 Linux 运行需要使用 sudo 提权。输出结果如下：\n\n![img](./Image/Linux命令大全.assets/trippy-getiot-20231217.png)\n\n不需要提升特权的跟踪：\n\n```bash\ntrip example.com --unprivileged\n```\n\n\n\n使用 udp（或 tcp 或 icmp）协议：\n\n```bash\ntrip example.com -p udp\n```\n\n\n\n指定追踪的最低轮转时间为 250 毫秒，宽限期为 50 毫秒：\n\n```bash\ntrip example.com -i 250ms -g 50ms\n```\n\n\n\n使用自定义的第一个 TTL 和最大 TTL 值：\n\n```bash\ntrip example.com --first-ttl 2 --max-ttl 10\n```\n\n\n\n使用自定义目标端口443进行 tcp 跟踪：\n\n```bash\ntrip example.com -p tcp -P 443\n```\n\n\n\n使用自定义源端口 5000 跟踪 udp：\n\n```bash\ntrip example.com -p udp -S 5000\n```\n\n\n\n\n\n# Linux mtr 命令 - 网络诊断路由跟踪\n\n## 介绍\n\n**mtr**（英文全拼：my traceroute）是一个用于网络诊断和网络性能测量的命令行工具，它在单个网络诊断工具中结合了 [traceroute](https://getiot.tech/linux-command/traceroute/) 和 [ping](https://getiot.tech/linux-command/ping/) 程序的功能，提供了更全面的网络路径跟踪和性能统计。\n\n`mtr` 命令的主要应用场景包括：\n\n- 在网络上跟踪数据包的路径，类似于 `traceroute`。\n- 连续地测量目标主机的网络性能，类似于 `ping`。\n- 提供目标主机到每个中间节点的网络延迟、丢包率等信息。\n\n当 mtr 启动时，它会通过发送故意设置低 TTL 的数据包来调查运行 mtr 的主机与 HOSTNAME 之间的网络连接。它继续发送低 TTL 的数据包，并记录中间路由器的响应时间。这允许 mtr 打印到 HOSTNAME 的互联网路由的响应百分比和响应时间。数据包丢失或响应时间突然增加通常表明链接不良（或只是过载）。\n\n**语法**：\n\n```bash\nmtr [options] HOSTNAME\n```\n\n\n\n**选项**：\n\n- `-r`：已报告模式显示。\n- `-c`：发送多少个数据包。\n- `-n`：不用主机解释。\n- `--report`：结果显示，并不动态显示。\n- `-s`：用来指定 ping 数据包的大小。\n\n## 示例\n\n使用报告模式显示：\n\n```bash\nmtr -r getiot.tech\n```\n\n\n\n设置每秒发送数据包数量：\n\n```bash\nmtr -r -c 30 getiot.tech\n```\n\n\n\n数指定 ping 数据包的大小：\n\n```bash\nmtr -r -c 30 -s getiot.tech\n```\n\n\n\n\n\n# Linux nload 命令 - 实时监控网络流量\n\n## 介绍\n\n**nload** 是一个用于监测网络流量的命令行工具，它以图形化的方式显示实时的网络使用情况。使用该命令，可在命令行界面通过图形化方式实时显示网络流量，包括上传和下载速率、总流量等数据。\n\n使用前请确保你的系统上已经安装 nload 工具，在 Debian/Ubuntu 系统上可使用如下命令进行安装：\n\n```bash\n$ sudo apt install nload\n```\n\n\n\n**语法**：\n\n```bash\nnload [options] [devices]\n```\n\n\n\n**选项**：\n\n- `-a`：这个好像是全部数据的刷新时间周期，单位是秒，默认是 300。\n\n- `-i <网络接口>`：进入网卡的流量图的显示比例最大值设置，默认 10240 kBit/s。\n\n- `-m`：不显示流量图，只显示统计数据。\n\n- `-o`：出去网卡的流量图的显示比例最大值设置，默认 10240 kBit/s。\n\n- `-t <刷新时间>`：显示数据的刷新时间间隔，单位是毫秒，默认 500。\n\n- `-K <速率因子>`： 设置速率的因子，用于调整显示的速率。\n\n- ```\n  -u <速率单位>\n  ```\n\n  ：设置右边 Curr、Avg、Min、Max 的数据单位，默认是自动变的。注意大小写单位不同！\n\n  - `h|b|k|m|g` —— h: auto，b: Bit/s，k: kBit/s，m: MBit/s 等；\n  - `H|B|K|M|G` —— H: auto，B: Byte/s，K: kByte/s，M: MByte/s 等。\n\n- `-U`：设置右边 TTL 的数据单位，默认是自动变的。注意大小写单位不同（与 `-u` 相同）！\n\n**参数**：\n\n- `devices`：自定义监控的网卡，默认是全部监控的，使用左右键切换。\n\n## 示例\n\n实时监测默认网络接口：\n\n```bash\nnload\n```\n\n\n\n注意：默认情况下，`nload` 会实时监测第一个找到的网络接口的上传和下载速率。\n\n监测指定的网络接口：\n\n```bash\nnload -i eth0\n```\n\n\n\n设置速率的显示单位（以 `Kbps` 为单位）：\n\n```bash\nnload -u Kbps\n```\n\n\n\n调整速率的因子：\n\n```bash\nnload -K 1024\n```\n\n\n\n设置每隔2秒更新一次显示：\n\n```bash\nnload -t 2\n```\n\n\n\n\n\n# Linux ifstat 命令 - 网络接口流量监控\n\n## 介绍\n\n**ifstat**（英文全拼：network interfaces status）是一个统计网络接口活动状态的工具。\n\n通常 ifstat 工具系统中并不默认安装，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install ifstat\n```\n\n\n\n类似命令：[iostat](https://getiot.tech/linux-command/iostat/)、[vmstat](https://getiot.tech/linux-command/vmstat/)\n\n**语法**：\n\n```bash\nifstat [选项]\n```\n\n\n\n**选项**：\n\n- `-l` ：监测环路网络接口（lo）。缺省情况下，ifstat 监测活动的所有非环路网络接口。\n- `-a` ：监测能检测到的所有网络接口的状态信息。\n- `-z` ：隐藏流量是无的接口，例如那些接口虽然启动了但是未用的。\n- `-i` ：指定要监测的接口。\n- `-s` ：等于加 `-d snmp:[comm@][#]host[/nn]]` 参数，通过 SNMP 查询一个远程主机。\n- `-d` ：指定一个驱动来收集状态信息。\n- `-n` ：关闭显示周期性出现的头部信息。\n- `-t` ：在每一行的开头加一个时间戳。\n- `-T` ：报告所有监测接口的全部带宽。\n- `-w` ：用指定的列宽，而不是为了适应接口名称的长度而去自动放大列宽。\n- `-W` ：如果内容比终端窗口的宽度还要宽就自动换行。\n- `-S` ：在同一行保持状态更新（不滚动不换行）注：如果不喜欢屏幕滚动则此项非常方便，与 bmon 的显示方式类似。\n- `-b` ：用 kbits/s 显示带宽而不是 kbytes/s。\n- `-q` ：安静模式，不打印警告信息。\n- `-h` ：显示帮助信息。\n- `-v` ：显示版本信息。\n\n## 示例\n\n监测所有网络接口的全部带宽，并添加时间戳\n\n```bash\n$ ifstat -tT\n  Time         enp0s25              Total\nHH:MM:SS   KB/s in  KB/s out   KB/s in  KB/s out\n13:09:19     16.72      8.26     16.72      8.26\n13:09:20     38.55     15.45     38.55     15.45\n13:09:21     72.30     16.30     72.30     16.30\n13:09:22     23.47      3.16     23.47      3.16\n13:09:23      1.09      0.20      1.09      0.20\n13:09:24      0.62      0.12      0.62      0.12\n```\n\n\n\n\n\n# Linux iftop 命令 - 实时流量监控工具\n\n## 介绍\n\n**iftop** 是一个能够提供网络带宽实时监控的工具（类似于 [top](https://getiot.tech/linux-command/top/) 命令实时监测进程状态）。\n\niftop 通过测量每个连接进入和进出的数据包的大小从而达到监控网络的目的。即它通过捕获网卡进入和进出的流量，然后对其求和从而得到正确的网络带宽数据。iftop 必须使用超级管理员权限运行，因为需要监控所有网络流量。如果没有指定接口，iftop 将监听在外部接口（使用 libcap 和 libncurses）的第一个接口上。\n\n通常，iftop 工具系统中并不默认安装，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install iftop\n```\n\n\n\n**语法**：\n\n```bash\niftop [选项]\n```\n\n\n\n**选项**：\n\n- `-i <interface>` ：设定监测的网卡。\n- `-B` ：以 bytes/sec 为单位显示流量（默认是 bits/sec）。\n- `-n` ：使 host 信息默认直接都显示 IP 地址。\n- `-N` ：使端口信息默认直接都显示端口号。\n- `-F <net/mask>` ：显示特定网段的进出流量。\n- `-p` ：以混杂模式运行。\n- `-P` ：启用端口显示。\n- `-b` ：不以流量图形条显示。\n- `-f <filter> <code>` ：过滤 IP 包。\n- `-m <limit>` ：设置界面最上边的刻度的最大值（刻度分五个大段显示）。\n- `-h` ：显示帮助信息。\n\n## 示例\n\n不带任何选项，直接运行 iftop\n\n```bash\n$ sudo iftop\n```\n\n\n\n![img](./Image/Linux命令大全.assets/iftop_snapshot.png)\n\n窗口说明：\n\n- 默认使用第一个网络接口（比如 eth0）；\n- 默认显示 rates 的三列数据分别表示：最近2秒、10秒和40秒的平均流量；\n- peak 指网络速率的尖峰值（最大）；\n- cum 表示累积流量 cumulative，在交互界面时按下 `T` 键就可以看到“主机对”之间累计的网络数据流量。\n\n网络监测时不进行 DNS 反解析，直接显示 IP，从而可以节省一定的带宽\n\n```bash\n$ sudo iftop -n\n```\n\n\n\n监测指定网卡\n\n```bash\n$ sudo iftop -i eth0\n```\n\n\n\n设置显示刻度最大值为 100M\n\n```bash\n$ sudo iftop -m 100M\n```\n\n\n\n显示特定网段的进出流量\n\n```bash\n$ sudo iftop -F 10.10.1.0/24\n$ sudo iftop -F 10.10.1.0/255.255.255.0\n```\n\n\n\n\n\n# Linux ntop 命令 - 网络流量分析工具\n\n## 介绍\n\n**ntop** 是一个网络流量监控工具，用于实时显示网络流量和连接信息。它提供了一个基于 Web 的用户界面，可以通过浏览器查看网络统计数据。\n\n提示\n\nntop 目前已被 **[ntopng](https://getiot.tech/linux-command/ntopng/)** 取代，可在其官网 [https://www.ntop.org](https://www.ntop.org/) 了解更多信息。\n\n**语法**：\n\n```bash\nntop [options]\n```\n\n\n\n**选项**：\n\n- `-h <主机>`： 指定 `ntop` 监听的主机地址。\n- `-p <端口>`： 指定 `ntop` 使用的端口号。\n- `-u <用户名>`： 指定 Web 界面的用户名。\n- `-P <密码>`： 指定 Web 界面的密码。\n- `-i <网络接口>`： 指定要监控的网络接口。\n\n## 示例\n\n启动 ntop 监听默认端口（3000），启动后可通过 [http://localhost:3000](http://localhost:3000/) 访问 Web 界面：\n\n```bash\nntop\n```\n\n\n\n指定监听的主机和端口：\n\n```bash\nntop -h 192.168.1.2 -p 8080\n```\n\n\n\n启动 ntop 并设置 Web 界面的用户名和密码：\n\n```bash\nntop -u myuser -P mypassword\n```\n\n\n\n指定要监控的网络接口（例如 `eth0`）：\n\n```bash\nntop -i eth0\n```\n\n\n\n\n\n# Linux ntopng 命令 - 网络流量监控分析\n\n## 介绍\n\n**ntopng** 是 [ntop](https://getiot.tech/linux-command/ntop/) 的下一代版本，它是一个用于监控网络流量的工具。相较于 ntop，ntopng 提供了一个更现代化和交互式的 Web 界面，以及支持更多的功能和详细的统计信息，包括网络流量、协议使用情况、主机信息等。\n\n使用前请确保你的系统上已经安装 ntopng 工具，在 Debian/Ubuntu 系统上可通过 apt 进行安装：\n\n```bash\n$ sudo apt install ntopng\n```\n\n\n\nntopng 是一个开源软件，你可以在 [GitHub](https://github.com/ntop/ntopng) 找到它。\n\n**语法**：\n\n```bash\nntopng [filename]\nntopng [options]\n```\n\n\n\n**选项**：\n\n- `-n, --dns-mode <mode>`：设置 DNS 地址解析模式。\n\n- `-i, --interface <interface|pcap>`：设置输入接口名称（通过数字或符号）、视图或 pcap 文件路径。\n\n- `-d, --data-dir <path>`：指定数据目录（该目录必须是可写的），默认为 /var/lib/ntopng。\n\n- `-t, --install-dir <path>`：指定安装目录，应在自定义目录下安装 ntopng 时需要设置。\n\n- `-e, --daemon`：以守护进程方式运行。\n\n- `-1, --httpdocs-dir <path>`：HTTP 文件根目录，默认为 httpdocs。\n\n- `-2, --scripts-dir <path>`：脚本目录，默认为 scripts。\n\n- `-3, --callbacks-dir <path>`：回调目录，默认为 scripts/callbacks。\n\n- `-4, --prefs-dir <path>`：用于序列化和反序列化包含运行时首选项的文件的 Preferences 目录，默认为 /var/lib/ntopng。\n\n- `-5, --pcap-dir <path>`：用于以 PCAP 格式进行连续流量记录的存储目录，默认为 /var/lib/ntopng。\n\n- `-u, --no-promisc`：不要将接口设置为混杂模式。\n\n- `-w, --http-port <[addr:]port>`：设置 HTTP 服务地址和端口，设置为 0 表示禁用 http 服务器。地址可以是 IPv4（例如 192.168.1.1）或 IPv6（例如 `[3ffe:2a00:100:7031::1]`）。注意，需要用方括号将 IPv6 地址括起来。然后在环回地址上的侦听端口之前添加一个不带 addr 的 `:`，默认端口为 3000。\n\n  例如，下面几种表示方法都是合法的：\n\n  ```bash\n  -w :3000\n  -w 192.168.1.1:3001\n  -w [3ffe:2a00:100:7031::1]:3002\n  ```\n\n  \n\n- `-W, --https-port <[:]https_port>`：设置 HTTPS 端口，类似于 `-w` 选项。\n\n- `-m, --local-networks <local nets>`：本地网络列表，默认为 192.168.1.0/24。\n\n- `-p, --ndpi-protocols <file>.protos`：指定 nDPI 协议文件，例如 protos.txt。\n\n- `-r, --redis <fmt>`：连接 Redis 数据库，`<fmt>` 格式为 `[h[:port[:pwd]]][@db-id]`。其中 `h` 表示主机地址，`port` 表示端口号（默认为 6379），`pwd` 表示登录密码，`db-id` 表示数据库 ID（默认为 0）。另外，在 Linux 系统中，`<fmt>` 还可以是 Redis 的 socket 文件路径。\n\n  例如，下面几种表示方法都是合法的：\n\n  ```bash\n  -r @2\n  -r 129.168.1.3\n  -r 129.168.1.3:6379@3\n  -r 129.168.1.3:6379:nt0pngPwD@0\n  -r /var/run/redis/redis.sock\n  -r /var/run/redis/redis.sock@2\n  ```\n\n  \n\n- `-g, --core-affinity <cpu core ids>`：将捕获/处理线程绑定到特定的 CPU 核心（指定为逗号分隔列表）。\n\n- `-U, --user <sys user>`：使用指定用户（而不是 ntopng 用户）运行 `ntopng`。\n\n- `-N, --instance-name <name>`：为该 ntopng 实例分配一个名称。\n\n- `-v, --verbose <level>`：详细信息等级 `[0 (min).. 6 (debug)]`。\n\n- `-V, --version`：显示版本信息。\n\n- `--print-ndpi-protocols`：打印 nDPI 协议列表。\n\n- `--ignore-vlans`：忽略流量中的 VLAN 标记。\n\n- `--simulate-vlans`：模拟 VLAN 流量（仅限调试）。\n\n- `-h, --help`：显示帮助信息。\n\n## 示例\n\n以默认方式启动 ntopng：\n\n```bash\n$ sudo ntopng\n```\n\n\n\n启动后可通过 [http://localhost:3000](http://localhost:3000/) 访问 Web 界面：\n\n![img](./Image/Linux命令大全.assets/ntopng-web.png)\n\n指定端口启动 ntopng：\n\n```bash\n$ sudo ntopng -w 3001\n```\n\n\n\n执行 `ntopng -h` 会在末尾列出接口设备及编号，例如：\n\n```bash\n$ ntopng -h\n...\nAvailable interfaces (-i <interface index>):\n   1. wlp0s20f3\n   2. lo\n   3. any\n   4. enp44s0\n   5. docker0\n   6. bluetooth-monitor\n   7. nflog\n   8. nfqueue\n   9. bluetooth0\n```\n\n\n\n只监控第一个网卡设备的流量（即 wlp0s20f3）：\n\n```bash\n$ sudo ntopng -i 1\n```\n\n\n\n以 pcap 文件作为输入：\n\n```bash\n$ sudo ntopng -i traffic.pcap\n```\n\n\n\n或者通过管道输入：\n\n```bash\ncat ~/traffic.pcap | sudo ntopng -i -\n```\n\n\n\n\n\n# Linux nmap 命令 - 网络扫描探测工具\n\n## 介绍\n\n**nmap**（英文全拼：Network Mapper）是一个开源的网络探测工具和安全/端口扫描器，由 Fyodor 编写并维护。它的设计目标是快速地扫描大型网络，当然用它扫描单个主机也没有问题。由于品质卓越、使用灵活，nmap 已经成为渗透测试人员必备的工具之一。\n\n在实现原理方面，nmap 以新颖的方式使用原始 IP 报文来发现网络上有哪些主机，这些主机提供什么服务（应用程序名和版本），这些服务运行在什么操作系统（包括版本信息），它们使用什么类型的报文过滤器/防火墙，以及一堆其它功能。\n\n虽然 nmap 通常用于安全审核，但许多系统管理员和网络管理员也用它来做一些日常的工作，比如查看整个网络的信息、管理服务升级计划，以及监视主机和服务的运行。\n\nnmap 输出的是扫描目标的列表（端口号、协议、服务名称和状态。），以及每个目标的补充信息，至于是哪些信息则依赖于所使用的选项。其中，状态可能是 open、filtered、closed 或者 unfiltered 中的一种或两种组合。\n\n- open（开放的）意味着目标机器上的应用程序正在该端口监听连接/报文。\n- filtered（被过滤的）意味着防火墙、过滤器或者其它网络障碍阻止了该端口被访问，nmap 无法得知它是 open 还是 closed 的。\n- closed（关闭的）端口没有应用程序在它上面监听，但是他们随时可能开放。\n- 当端口对 nmap 的探测做出响应，但是 nmap 无法确定它们是关闭还是开放时，这些端口就被认为是 unfiltered（未被过滤的）。\n\n如果 nmap 报告状态组合 open|filtered 和 closed|filtered 时，那说明 nmap 无法确定该端口处于两个状态中的哪一个状态。\n\n**语法**：\n\n```bash\nnmap [Scan Type(s)] [Options] {target specification}\nnmap [扫描类型...] [选项] {扫描目标说明}\n```\n\n\n\n其中 Target（扫描目标）可以传入主机名称、IP 地址或网络。\n\n**选项**：\n\n- `-sS`：TCP SYN 扫描（又称半开放或隐身扫描）。\n- `-P0`：允许你关闭 ICMP pings。\n- `-sV`：打开系统版本检测。\n- `-O`：尝试识别远程操作系统。\n- `-A`：同时打开操作系统指纹和版本检测。\n- `-v`：详细输出扫描情况。\n\n## 示例\n\n扫描出指定 IP（域名）其对外开放的服务\n\n```bash\n$ nmap getiot.tech\nStarting Nmap 7.80 ( https://nmap.org ) at 2022-10-30 23:13 CST\nNmap scan report for getiot.tech (42.192.64.149)\nHost is up (0.058s latency).\nNot shown: 997 filtered ports\nPORT    STATE SERVICE\n80/tcp  open  http\n443/tcp open  https\n\nNmap done: 1 IP address (1 host up) scanned in 6.72 seconds\n```\n\n\n\n判断目标 IP（域名）是否开放指定端口\n\n```bash\nnmap -p 80 getiot.tech\n```\n\n\n\n扫描指定网络中的所有在线主机\n\n```bash\nnmap -sP 192.168.3.*\nnmap -sP 192.168.3.0/24\n```\n\n\n\n扫描指定网络中的所有在线主机的指定端口\n\n```bash\nnmap -p 22,80,443 192.168.3.0/24\n```\n\n\n\n扫描指定网段中在线主机的指定端口\n\n```bash\nnmap -p 22,80,443 192.168.3.30-100\n```\n\n\n\n扫描指定网段，但是排除某个 IP 地址\n\n```bash\nnmap 192.168.3.30-100 --exclude 192.168.3.30.66\n```\n\n\n\n扫描多个地址时排除文件里的 IP 地址\n\n```bash\ncat ex.txt \n192.168.3.30.66\n192.168.3.30.88\n\nnmap 172.17.120.11-14 --excludefile ex.txt\n```\n\n\n\n在某段子网上查找未占用的 IP\n\n```bash\nnmap -T4 -sP 192.168.3.0/24 && egrep “00:00:00:00:00:00″ /proc/net/arp\n```\n\n\n\n服务版本识别（-sV），nmap 可以在进行端口扫描的时候检测服务端软件的版本信息\n\n```bash\nnmap -sV 192.168.3.66 -p 80\n```\n\n\n\n操作系统检测（-O），nmap 还能识别目标主机的操作系统\n\n```bash\nnmap -O 192.168.3.66\n```\n\n\n\n找到目标主机开放了哪些 UDP 端口。为提高扫描速度，我们仅扫描 53 端口（DNS）和 161 端口（SNMP）\n\n```bash\nnmap -sU 192.168.3.66 -p 53,161\n```\n\n\n\n启用 nmap 的 -6 选项即可扫描 IPv6 的目标主机\n\n```bash\nnmap -6 fe80::a00:27ff:fe43:1518\n```\n\n\n\n在局域网上扫找 Conficker 蠕虫病毒\n\n```bash\nnmap -PN -T4 -p139,445 -n -v –script=smb-check-vulns –script-args safe=1 192.168.3.1-254\n```\n\n\n\n扫描网络上的恶意接入点（rogue APs）\n\n```bash\nnmap -A -p1-85,113,443,8080-8100 -T4 –min-hostgroup 50 –max-rtt-timeout 2000 –initial-rtt timeout 300 –max-retries 3 –host-timeout 20m –max-scan-delay 1000 -oA wapscan 192.168.3.0/24\n```\n\n\n\n使用诱饵扫描方法来扫描主机端口\n\n```bash\nnmap -sS 192.168.3.12 -D 192.168.3.20\n```\n\n\n\n显示网络上共有多少台 Linux 及 Win 设备\n\n```bash\nnmap -F -O 192.168.3.0-255 | grep \"Running: \" > /tmp/os; echo \"$(cat /tmp/os | grep Linux \\| wc -l) Linux device(s)\"; echo \"$(cat /tmp/os | grep Windows | wc -l) Window(s) device\"\n```\n\n\n\n\n\n# Linux netcat 命令 - 多功能网络工具\n\n## 介绍\n\n**`netcat`**（别名：**`nc`**）是 Linux 下的一个多功能的网络工具，可用于与 TCP 或 UDP 相关的各种任务，例如创建连接和侦听、执行端口扫描，以及处理 IPv4 和 IPv6 等。与 [telnet](https://getiot.tech/linux-command/telnet/) 不同，netcat 可以精细地编写脚本，并将错误消息分隔到标准错误中，而不是将错误消息发送到标准输出。\n\nnetcat 命令通常用于以下任务：\n\n- 简单 TCP 代理\n- 基于 HTTP 客户机和服务器的 shell 脚本\n- 网络守护进程测试\n- 适用于 [ssh](https://getiot.tech/linux-command/ssh/) 的 SOCKS 或 HTTP `ProxyCommand`\n\nnetcat/nc 命令由 netcat 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install netcat\n```\n\n\n\n**语法**：\n\n```bash\nnc [-46bCDdFhklNnrStUuvZz] [-I length] [-i interval] [-M ttl] [-m minttl] [-O length] [-P proxy_username]\n        [-p source_port] [-q seconds] [-s source] [-T keyword] [-V rtable] [-W recvlimit] [-w timeout] [-X proxy_protocol]\n        [-x proxy_address[:port]] [destination] [port]\n```\n\n\n\n**选项**：\n\n- `-4`：强制 `nc` 仅使用 IPv4 地址。\n- `-6`：强制 `nc` 仅使用 IPv6 地址。\n- `-b bufsize`：为读取操作指定缓冲区大小。缺省值为 `1024` 字节。\n- `-D`：启用对套接字的调试。\n- `-d`：不尝试从 `stdin` 进行读取。\n- `-E`：使用独占绑定来侦听 TCP 或 UDP 套接字。在没有 `-l` 选项的情况下单独使用此选项是错误的。此选项与 `-U` 选项结合使用时，不会产生任何影响。\n- `-e program`：接受连接或建立连接之后执行外部程序。在执行之前，`stdin`, `stdout`, `stderr` 会重定向到网络描述符。仅有一个端口可供该选项使用。此选项与 `-R`、`-k` 或 `-i` 选项结合使用是错误的。\n- `-F`：在 `stdin` 上看到 `EOF` 后，不要关闭网络套接字以进行写入。\n- `-h`：输出 `nc` 帮助。\n- `-I bufsize`：设置接收（输入）套接字缓冲区大小。此选项与 `-U` 选项结合使用时，不会产生任何影响。\n- `-i interval`：指定发送和接收的文本行之间的延迟时间 interval。以秒为单位指定时间间隔，可能包含小数。此选项还会导致与多个端口的连接之间产生延迟时间，因而也会影响端口扫描模式。\n- `-k`：强制 `nc` 在其当前连接关闭后侦听另一连接。在没有 `-l` 选项的情况下单独使用此选项是错误的。此选项与 `-e` 选项结合使用是错误的。\n- `-L timeout`：在关闭时逗留（Linger on close）－在网络描述符关闭后直到指定的超时时间（以秒为单位），等待消息发送。\n- `-l`：侦听传入连接，而不是启动到远程主机的连接。此选项与 `-s` 或 `-z` 选项结合使用是错误的。如果 `-l` 选项与通配符套接字（未指定任何 IP 地址或主机名）一起使用，但不与 `-4/-6` 选项一起使用，则既可接受 IPv4 连接也可接受 IPv6 连接。\n- `-m byte_count`：接收至少 `byte_count` 字节后退出。当与 `-l` 选项结合使用时，`byte_count` 会与从客户机接收的字节数进行比较。`byte_count` 必须大于 `0`，而小于 `INT_MAX`。\n- `-N file`：在 UDP 端口扫描模式下指定文件。此文件的内容用作每个发出的 UDP 包的有效载荷。在没有 `-u` 和 `-z` 选项的情况下单独使用此选项是错误的。\n- `-n`：不对任何地址、主机名或端口执行任何命名或服务查找操作。使用此选项意味着 hostname 和 port 参数被限制为数字值。除了对参数施加限制外，与 `-v` 选项一起使用时，所有地址和端口都将以数字形式输出。此选项与 `-U` 选项结合使用时，不会产生任何影响。\n- `-O bufsize`：设置发送（输出）套接字缓冲区大小。此选项与 `-U` 选项结合使用时，不会产生任何影响。\n- `-P proxy_username`：指定提供给要求验证的代理服务器的一个用户名（proxy_username）。如果未指定 proxy_username，则不会尝试进行验证。目前仅 `HTTP CONNECT` 代理支持代理验证。此选项与 `-l` 选项结合使用是错误的。\n- `-p port`：未与 `-l` 选项结合使用时，根据特权限制和可用性指定 `nc` 应使用的源端口。与 `-l` 选项结合使用时，设置侦听端口。仅当未指定全局端口参数时，此选项可与 `-l` 选项结合使用。\n- `-q timeout`：在 `stdin` 上接收到 `EOF` 后，等待指定的秒数，然后退出。\n- `-R addr/port[/proto]`：对指定的 host 和 port 执行端口重定向。接受连接后，`nc` 会连接到远程 host/port，并在客户机与远程主机之间传递所有数据。重定向规范的 proto（协议）部分可以是 `tcp` 或 `udp`。如果未指定 proto，`redirector` 将使用与服务器相同的协议。此选项与 `-z` 选项结合使用是错误的。\n- `-r`：在由 port_list 参数指定的所有端口中随机（而非按顺序）选择目标端口。此选项与 `-l` 选项结合使用是错误的。\n- `-s source_ip_address`：指定用于发送数据包的接口的 IP。此选项与 `-l` 选项结合使用是错误的。\n- `-S sla-prop`：指定为套接字创建的 MAC 流的属性。sla-prop 以属性的 'name=value' 逗号分隔列表的形式提供。当前支持的属性名称为 `maxbw`、`priority` 和 `inherit`。`maxbw` 和 `priority` 来自 flowadm(1M) 中定义的属性，表示流的最大带宽和优先级。`maxbw` 的允许值为整数加上可选的后缀（缺省为 Mega）。`priority` 的值可以为 'high'、'medium' 和 'low'。在创建流时，必须至少指定 `maxbw` 和 `priority` 之一。`inherit` 的值可以为 'on' 和 'off'，缺省值为 'off'。缺省情况下，接受的/新的套接字（由 accept 返回）不会继承侦听器套接字的属性。当将其设置为 'on' 时，新的套接字将继承侦听器套接字的属性。当需要对新套接字实施属性时，这对于 `-l` 选项很有用。此选项需要 `SYS_FLOW_CONFIG` 特权。此选项还要求指定 IP 地址或主机名。\n- `-T dscp`：为连接指定区分服务代码点。对于 IPv4，此选项指定 IP 服务类型（Type of Service, ToS）IP 标题字段，参数的有效值为字符串标记 `lowdelay`、`throughput`、`reliability` 或前面带有 `0x` 的 8 位十六进制值。对于 IPv6（通信流量类），只能使用十六进制值。\n- `-t`：使 `nc` 将 *RFC 854* `DON'T` 和 `WON'T` 响应发送到 *RFC 854* `DO` 及 `WILL` 请求。这样就可以使用 `nc` 编写 `telnet` 会话脚本。\n- `-U`：指定使用 Unix 域套接字。如果不与 `-l`、`nc` 一起指定此选项，则它将变成 `AF_UNIX` 客户机。如果与 `-l` 选项一起指定此选项，则会创建 `AF_UNIX` 服务器。使用此选项要求必须向 `nc` 提供单个有效的 Unix 域路径参数，而不是提供主机名或端口。\n- `-u`：使用 UDP，而不是缺省选项 TCP。\n- `-v`：指定详细输出。\n- `-w timeout`：如果连接和 `stdin` 空闲超过了 timeout 秒，则无提示地关闭连接。缺省设置是没有超时。此选项对客户机模式下的连接建立阶段或服务器模式下的等待连接过程没有任何影响。\n- `-X proxy_protocol`：与代理服务器通信时，使用该指定协议。受支持的协议为 `4`（SOCKS v.4）、`5`（SOCKS v.5）和 `connect`（HTTP 代理）。如果未指定协议，则使用 SOCKS v. 5。此选项与 `-l` 选项结合使用是错误的。\n- `-x proxy_address[:port]`：使用 proxy_address 和 port 上的代理请求到 hostname 的连接。如果未指定 port，则使用代理协议的已知端口（SOCKS 为 1080，HTTP 为 3128）。此选项与 `-l` 选项结合使用是错误的。此选项不适用于 IPv6 地址的数字表示形式。\n- `-Z`：在侦听模式下，使用 `SO_ALLZONES` 套接字选项绑定到所有区域中的地址/端口。此选项需要 `SYS_NET_CONFIG` 特权。\n- `-z`：执行端口扫描。对于 TCP 端口（缺省），尝试在不发送数据的情况下执行连接扫描（完整三路信号握手）。对于 UDP（`-u`），缺省情况下会发送空 UDP 包。要指定 UDP 有效载荷，可以使用 `-N` 选项。UDP 扫描模式具有估计能力，如果它没有接收到否定响应（\"ICMP Destination Port Unreachable\"（无法访问 ICMP 目标端口）消息），它会考虑打开一个端口。对于这种模式，使用 `-w` 选项设置的超时时间将用来等待来自远程节点的 ICMP 消息或数据。通过 `-v`，接收到的任何数据都会作为十六进制字节转储到 `stderr`。由于大多数操作系统会限制发送 ICMP 消息（以响应输入包）的速率，所以有必要在执行 UDP 扫描时使用 `-i`，否则结果会不可靠。此选项与 `-l` 选项结合使用是错误的。\n\n**参数**：\n\n- `hostname` 指定主机名。\n\n  hostname 可以是数字 IP 地址或者符号主机名（除非已指定 `-n` 选项）。通常，除非已指定 `-l` 选项或者使用了 `-U`（在此情况下，参数是一个路径），否则必须指定 hostname。如果随 `-l` 选项指定了 hostname 参数，则还必须给定 port 参数，并且 `nc` 会尝试绑定到该地址和端口。如果没有随 `-l` 选项指定 hostname 参数，则 `nc` 会尝试在给定 port 的通配符套接字上侦听。\n\n- `path` 指定路径名。\n\n- `port <port_list>` 指定端口。\n\n  `port_list` 可以指定为单个整数、范围或两者的组合。请以 `nn-mm` 形式指定范围。`port_list` 至少必须有一个成员，但可以有多个以逗号分隔的端口/范围。\n\n  通常，除非已指定 `-U` 选项（在此情况下，必须指定 Unix 域套接字路径，而不指定 hostname），否则必须指定目标端口。\n\n  将包含多个端口的端口列表与 `-e` 选项结合使用是错误的。\n\n## 示例\n\n打开到 `host.example.com` 的端口 42 的 TCP 连接，使用端口 3141 作为源端口，超时为 5 秒：\n\n```bash\nnc -p 3141 -w 5 host.example.com 42\n```\n\n\n\n打开到 `host.example.com` 的端口 7777 的 TCP 连接，对套接字设置最大 50Mbps 的带宽：\n\n```bash\nnc -M maxbw=50M host.example.com 7777\n```\n\n\n\n打开到 `host.example.com` 的端口 53 的 UDP 连接：\n\n```bash\nnc -u host.example.com 53\n```\n\n\n\n打开到 `host.example.com` 的端口 42 的 TCP 连接，使用 `10.1.2.3` 作为连接的本地端的 IP：\n\n```bash\nnc -s 10.1.2.3 host.example.com 42\n```\n\n\n\n将一个包含端口和端口范围的列表用于针对各种端口的端口扫描：\n\n```bash\nnc -z host.example.com 21-25,53,80,110-120,443\n```\n\n\n\n在某个 Unix 域套接字上创建连接并侦听：\n\n```bash\nnc -lU /var/tmp/dsocket\n```\n\n\n\n在关联端口为 8888 的 UDP 套接字上创建连接并侦听：\n\n```bash\nnc -u -l -p 8888\n```\n\n\n\n这等效于：\n\n```bash\nnc -u -l 8888\n```\n\n\n\n在关联端口为 2222 的 TCP 套接字上创建连接并侦听，并且只绑定到地址 `127.0.0.1`：\n\n```bash\nnc -l 127.0.0.1 2222\n```\n\n\n\n在关联端口 2222 上创建 TCP 套接字并进行侦听，并在侦听器和连接的套接字上创建高优先级的 MAC 流：\n\n```bash\nnc -l -M priority=high,inherit=on host.example.com 2222\n```\n\n\n\n\n\n# Linux nc 命令 - netcat 的别名\n\n**`nc`** 命令是 **`netcat`** 的别名，它是 Linux 下的一个多功能的网络工具，详细用法见 [netcat 命令](https://getiot.tech/linux-command/netcat/)。\n\n\n\n# Linux nethogs 命令 - 按进程监控网络流量\n\n## 介绍\n\n**NetHogs** 是一个开源的小型 net top 工具，它可以按进程实时监控网络带宽使用率。\n\n和其他按协议或按子网分解流量的工具不同，NetHogs 是按进程对带宽进行分组的，并且不依赖于加载的特殊内核模块。因此，如果突然出现大量网络流量，你可以启动 NetHogs 并立即查看是哪个 PID 导致了这种情况，如果是某种旋转进程（spinning process），就可以将其终止。\n\n使用前请确保你的系统上已经安装 nethogs 工具，在 Debian/Ubuntu 系统上可通过 apt 进行安装：\n\n```bash\nsudo apt install nethogs\n```\n\n\n\n**语法**：\n\n```bash\nnethogs [options] [devices]\n```\n\n\n\n**选项**：\n\n- `-V`：打印版本信息。\n- `-h`：打印帮助信息。\n- `-d`：延迟更新刷新率（以秒为单位），用于控制界面的更新速度。默认值为 1。\n- `-v`：设置显示模式（0 = KB/s，1 = total KB，2 = total B，3 = total MB）。默认值为 0。\n- `-c`：限制刷新次数，默认为 0（无限制）。\n- `-t`：追踪模式（tracemode）。\n- `-p`：混杂模式的嗅探器（不推荐）。\n- `-s`：按照发送的流量排序。\n\n**参数**：\n\n- `devices`：要监控的网络设备。默认使用 `eth0`。\n\n**交互命令**：\n\n当 nethogs 运行时，还可以通过键盘快捷键进行交互。\n\n- `m`：在 kb/s, kb, b, mb 几种显示模式之间循环切换。\n- `r`：按 received 接收流量排序。\n- `s`：按 sent 发送流量排序。\n- `q`：退出。\n\n## 示例\n\n以默认方式启动 nethogs 程序：\n\n```bash\n$ sudo nethogs\n```\n\n\n\n设置每 5 秒刷新一次：\n\n```bash\n$ sudo nethogs -d 5 \n```\n\n\n\n指定要监视的网络设备（例如 `eth0`）：\n\n```bash\n$ sudo nethogs eth0\n```\n\n\n\n同时监视两个网络设备：\n\n```bash\n$ sudo nethogs eth0 eth1\n```\n\n\n\n使用追踪模式：\n\n```bash\n$ sudo nethogs -t \n```\n\n\n\n提示\n\n在基于 Debian 的系统（例如 Ubuntu）下要执行 nethogs 需要 root 权限，因此 `sudo` 是必须的。而基于 RedHat 系统则不需要。\n\n\n\n# Linux tcptrack 命令 - TCP连接跟踪工具\n\n## 介绍\n\n**tcptrack** 是一个用于实时监视 TCP 连接的命令行工具。它可用于实时监视系统中活动的 TCP 连接，显示源和目标 IP 地址、端口以及连接的状态，并以图形化的方式显示每个连接的实时流量统计信息。\n\n**语法**：\n\n```bash\ntcptrack [ -dfhvp ] [ -r seconds ] -i interface [ filter expression ]\n```\n\n\n\n**选项**：\n\n- `-d`：仅跟踪 tcptrack 启动后启动的连接，不要尝试检测已有连接。\n- `-f`：启用快速平均重新计算。TCPTrack 将使用运行平均值来计算连接的平均速度，这将使用更多内存和 CPU 时间，但结果更接近实时情况。在快速模式下每秒重新计算平均值的次数是编译时设置，默认为每秒 10 次。\n- `-i [interface]`：嗅探来自指定网络接口的数据包。\n- `-T [pcap file]`：从指定 pcap 文件中读取数据包，而不是从网络中嗅探。这个选项对于测试很有用。\n- `-p`：不要将被嗅探的接口置于混杂模式。\n- `-r [seconds]`：等待 seconds 秒后从显示屏上删除关闭的连接，默认为 2 秒。\n- `-h`：显示帮助信息。\n- `-v`：显示版本信息。\n\n**交互命令**：\n\n当 tcptrack 运行时，还可以通过键盘快捷键进行交互。\n\n- `p`：暂停/取消暂停显示。不会将新连接添加到显示屏中，并且所有当前显示的连接将保留在显示屏中。\n- `s`：循环切换排序选项，包括：未排序（unsorted）、按速率排序（sorted by rate）、按总字节排序（sorted by total bytes）。\n- `q`：退出 tcptrack 程序。\n\n**过滤表达式**：\n\ntcptrack 还可以将 pcap 过滤器表达式作为参数。过滤器表达式的格式与 [tcpdump](https://getiot.tech/linux-command/tcpdump/) 和其他基于 libpcap 的嗅探器的格式相同。\n\n## 示例\n\n监视 eth0 网络接口的 TCP 连接：\n\n```bash\n$ sudo tcptrack -i eth0\n```\n\n\n\n使用 pcap 过滤器表达式，仅显示来自主机 10.45.165.2 的连接：\n\n```bash\n$ sudo tcptrack -i eth0 src or dst 10.45.165.2\n```\n\n\n\n仅显示 Web 流量（指定 80 端口）：\n\n```bash\n$ sudo tcptrack -i eth0 port 80\n```\n\n\n\n\n\n# Linux tcpdump 命令 - 数据包捕获分析工具\n\n## 介绍\n\n**tcpdump** 命令是 Linux 系统中的一个网络数据包截获分析工具，支持针对网络层、协议、主机、网络或端口的过滤，并提供 and、or、not 等逻辑语句帮助过滤无用的信息。\n\ntcpdump 命令通常默认不安装，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install tcpdump\n```\n\n\n\n**语法**：\n\n```bash\ntcpdump [-adeflnNOpqStvx]\n        [-c <count>] [-dd] [-ddd] [-F <file>]\n        [-i <interface>] [-r <file>]\n        [-s <snaplen>] [-tt] [-T <type>]\n        [-vv] [-w <file>]\n```\n\n\n\n**选项**：\n\n- `-a` ：尝试将网络和广播地址转换成名称。\n- `-c <数据包数目>` ：收到指定的数据包数目后，就停止进行倾倒操作。\n- `-d` ：把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出。\n- `-dd` ：把编译过的数据包编码转换成 C 语言的格式，并倾倒到标准输出。\n- `-ddd` ：把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出。\n- `-e` ：在每列倾倒资料上显示连接层级的文件头。\n- `-f` ：用数字显示网际网络地址。\n- `-F <表达文件>` ：指定内含表达方式的文件。\n- `-i <网络界面>` ：使用指定的网络截面送出数据包。\n- `-l` ：使用标准输出列的缓冲区。\n- `-n` ：不把主机的网络地址转换成名字。\n- `-N` ：不列出域名。\n- `-O` ：不将数据包编码最佳化。\n- `-p` ：不让网络界面进入混杂模式。\n- `-q` ：快速输出，仅列出少数的传输协议信息。\n- `-r <数据包文件>` ：从指定的文件读取数据包数据。\n- `-s <数据包大小>` ：设置每个数据包的大小。\n- `-S` ：用绝对而非相对数值列出 TCP 关联数。\n- `-t` ：在每列倾倒资料上不显示时间戳记。\n- `-tt` ：在每列倾倒资料上显示未经格式化的时间戳记。\n- `-T <数据包类型>` ：强制将表达方式所指定的数据包转译成设置的数据包类型。\n- `-v` ：详细显示指令执行过程。\n- `-vv` ：更详细显示指令执行过程。\n- `-x` ：用十六进制字码列出数据包资料。\n- `-w <数据包文件>` ：把数据包数据写入指定的文件。\n\n## 示例\n\n提示：运行 tcpdump 需要超级用户（root）权限，普通用户执行下列命令时需要加上 sudo 提权，否则会收到一条错误消息：“You don’t have permission to capture on that device”。\n\n显示所有网络数据包信息\n\n```bash\ntcpdump\n```\n\n\n\n打印 tcpdump 所有可用网络接口（包括以太网口、Wi-Fi、蓝牙等）\n\n```bash\ntcpdump -D\n```\n\n\n\n捕获来自所有接口的所有数据包（`any` 表示捕获所有活动的接口）\n\n```bash\ntcpdump -i any\n```\n\n\n\n默认情况下，tcpdump 会对 IP 地址执行反向 DNS 解析，并将端口号转换为名称。使用 `-n` 选项可禁用翻译：\n\n```bash\ntcpdump -n\n```\n\n\n\n提示：跳过 DNS 查找可避免生成 DNS 流量，并使输出更具可读性。建议每次调用 tcpdump 时都使用 `-n` 选项。\n\n捕获 10 个数据包\n\n```bash\ntcpdump -c 10\n```\n\n\n\n以精简模式显示 10 个数据包信息\n\n```bash\ntcpdump -c 10 -q\n```\n\n\n\n以详细模式显示 10 个数据包信息\n\n```bash\ntcpdump -c 10 -vv\n```\n\n\n\n仅捕获 UDP 数据包（将该协议指定为过滤器）\n\n```bash\ntcpdump -n udp\n```\n\n\n\n仅捕获指定端口（如 51180）的数据包（使用 `port` 限定符）\n\n```bash\ntcpdump -n port 51180\n```\n\n\n\n仅捕获指定主机相关的数据包（使用 `host` 限定符）\n\n```bash\ntcpdump -n host 192.168.1.100\n```\n\n\n\n提示：使用 `net` 限定符可以过滤指定的 IP 范围\n\n仅捕获来自 192.168.1.100 的主机的传入数据包（使用 `src` 指定源地址，`dst` 指定目的地址）\n\n```bash\ntcpdump -n src host 192.168.1.100\n```\n\n\n\n捕获所有发送到 80 端口的数据包\n\n```bash\ntcpdump -n dst port 80\n```\n\n\n\n对于复杂的过滤条件，可以使用 `and`（`&&`）、`or`（`||`）和 `not`（`!`）运算符进行组合。\n\n例如：捕获来自某个源IP地址 192.168.1.100 的所有 HTTP 通信\n\n```bash\ntcpdump -n src 192.168.1.100 and tcp port 80\n```\n\n\n\n以及 HTTPS 通信\n\n```bash\ntcpdump -n 'host 192.168.1.100 and (tcp port 80 or tcp port 443)'\n```\n\n\n\n提示：为避免使用特殊字符时解析错误，可将过滤器括在单引号内。\n\n捕获源 IP 地址 192.168.1.100 除 SSH 以外的所有流量\n\n```bash\ntcpdump -n src 192.168.1.100 and not dst port 22\n```\n\n\n\n将捕获的网络数据包信息保存到文件中（使用重定向操作符 `>` 和 `>>` 将其重定向到文件）\n\n```bash\ntcpdump -n -i any > file.out\n```\n\n\n\n如果你想在保存到文件的同时在终端观看数据，可以借助 [tee](https://getiot.tech/linux-command/tee/) 命令\n\n```bash\ntcpdump -n -l | tee file.out\n```\n\n\n\n注意：上面命令中的 `-l` 选项告诉 tcpdump 缓冲输出。如果不使用此选项时，那么在生成新行时，输出将不会显示在屏幕上。\n\n将捕获的网络数据包导出到文件（使用 `-w` 选项）\n\n```bash\ntcpdump -n -w data.pcap\n```\n\n\n\n提示：你可以根据需要命名文件，但是使用 `.pcap` 扩展名（数据包捕获）是一种常见的约定。\n\n注意：使用 `-w` 选项时，tcpdump 的输出不显示在屏幕上，并将原始数据包写入到一个二进制文件，而非文本文件，这一点和重定向保存到文件不同。\n\n如果想要查看 pcap 文件的内容，请使用 `-r` 选项，例如：\n\n```bash\ntcpdump -r data.pcap\n```\n\n\n\n如果想要捕获一段时间内的数据包，可以与 [timeout](https://getiot.tech/linux-command/timeout/) 命令配合使用。例如捕获 5 分钟的网络数据：\n\n```bash\ntimeout 300 tcpdump -n -w data.pcap\n```\n\n\n\n\n\n# Linux tcpreplay 命令 - 重放网络数据包工具\n\n## 介绍\n\n**tcpreplay** 是一个用于在网络中重放和编辑 pcap 文件的命令行工具。它可以用来测试网络设备的性能、网络分析、入侵检测系统（IDS）的测试和验证等。tcpreplay 工具允许用户将先前捕获的网络流量重放到网络中，以模拟真实的流量。通过组合不同的选项参数，可以灵活地模拟各种网络条件和负载。\n\ntcpreplay 命令由 [tcpreplay](https://tcpreplay.appneta.com/) 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install tcpreplay\n```\n\n\n\n安装完成后，系统会增加 `tcpreplay`、`tcprewrite`、`tcpreplay-edit`、`tcpprep`、`tcpbridge`、`tcpliveplay`、`tcpcapinfo` 等几个命令。\n\n**语法**：\n\n```bash\ntcpreplay [ -<flag> [<val>] | --<name>[{=| }<val>] ]... <pcap_file(s)>\n```\n\n\n\n**选项**：\n\n- `-i, --intf1=str`：指定回放流量的网络接口（多网卡系统必须指定）。\n- `-I, --intf2=str`：辅助流量输出接口（可选）。\n- `-T, --timer=str`：选择数据包计时模式。可以是 `select`、`ioport`、`gtod` 或 `nano`。\n- `--maxsleep=num`：数据包之间休眠时间不超过 `num` 毫秒。\n- `-v, --verbose`：通过 tcpdump 将解码后的数据包打印到标准输出 `STDOUT`。\n- `-A, --decode=str`：传递给 tcpdump 解码器的参数（需要 `-v` 选项）。\n- `-K, --preload-pcap`：发送前将数据包预加载到 RAM 中。\n- `-l, --loop=num`：指定回放流量的次数。默认是 1 次。\n- `-L, --limit=num`：指定回放数据包的数量（需要大于 1）。\n- `-x, --multiplier=str`：将回放速度修改为指定倍数。\n- `-p, --pps=str`：以指定的 packets/sec 速度（每秒包数）回放数据包。\n- `-M, --mbps=str`：以指定的 Mbps 速度（带宽）回放数据包。\n- `-t, --topspeed`：尽可能快地回放数据包。\n- `-o, --oneatatime`：根据每个用户输入，一次重放一个数据包。\n\n## 示例\n\n将 example.pcap 文件中的流量重放到 `eth0` 接口上：\n\n```bash\ntcpreplay -i eth0 example.pcap\n```\n\n\n\n将 example.pcap 文件中的流量在 `eth0` 接口上重放 5 次：\n\n```bash\ntcpreplay -i eth0 -l 5 example.pcap\n```\n\n\n\n根据 pcap 文件中的时间戳来重放流量：\n\n```bash\ntcpreplay -i eth0 -t example.pcap\n```\n\n\n\n以 10 Mbps 的速度重放流量：\n\n```bash\ntcpreplay -i eth0 --mbps=10 example.pcap\n```\n\n\n\n以每秒 1000 包的速度重放流量：\n\n```bash\ntcpreplay -i eth0 --pps=1000 example.pcap\n```\n\n\n\n只重放前 100 个包：\n\n```bash\ntcpreplay -i eth0 -L 100 example.pcap\n```\n\n\n\n## 资源链接\n\n- [tcpreplay 代码仓库](https://github.com/appneta/tcpreplay)\n- [tcpreplay 项目主页](https://tcpreplay.appneta.com/)\n\n\n\n# Linux ethr 命令 - 网络性能测试工具\n\n## 介绍\n\n**Ethr** 是一个用 golang 编写的跨平台网络性能测量工具。该项目的目标是提供本机工具，用于跨多种协议（如 TCP、UDP、HTTP、HTTPS 和跨多个平台）对带宽、连接、数据包、延迟、丢失进行全面的网络性能测量。\n\nEthr 从现有的开源网络性能工具中获取灵感，并以这些想法为基础。对于带宽测量，它类似于 iPerf3，用于 TCP 和 UDP 流量。iPerf3 有更多选项可用于执行限制测试，更丰富的功能集，而 Ethr 支持多线程，允许它扩展到 1024 甚至更高数量的连接，多个客户端与单个服务器通信等。用于延迟测量，它类似于 Windows 上的 latte 或 Linux 上的 sockperf。\n\nGitHub 地址：https://github.com/Microsoft/Ethr\n\n**安装**：\n\n有多种方式安装 ethr 工具\n\n- 直接下载安装\n\n  ```bash\n  wget https://github.com/microsoft/ethr/releases/latest/download/ethr_linux.zip\n  unzip ethr_linux.zip\n  ```\n\n  \n\n  解压缩后将 ethr 放到 `$PATH` 中任一路径即可，比如 /usr/local/bin/ 目录。\n\n- 源码编译安装\n\n  ```bash\n  git clone https://github.com/Microsoft/ethr.git\n  cd ethr\n  go build\n  ```\n\n  \n\n- Docker 镜像安装\n\n  ```bash\n  docker build -t microsoft/ethr .\n  docker run -e GOOS=linux -v $(pwd):/out microsoft/ethr make build-docker\n  ```\n\n  \n\n- go get 安装\n\n  ```bash\n  go get github.com/Microsoft/ethr\n  ```\n\n  \n\n## 示例\n\n查看帮助\n\n```bash\nethr -h\n```\n\n\n\n启动服务器\n\n```bash\nethr -s\n```\n\n\n\n启动带文本 UI 的服务器\n\n```bash\nethr -s -ui\n```\n\n\n\n启动客户端\n\n```bash\nethr -c <server ip>\n```\n\n\n\n更多示例\n\n```bash\n# Start server\nethr -s\n\n# Start client for default (bandwidth) test measurement using 1 thread\nethr -c localhost\n\n# Start bandwidth test using 8 threads\nethr -c localhost -n 8\n\n# Start connections/s test using 64 threads to server 10.1.0.11\nethr -c 10.1.0.11 -t c -n 64\n\n# Run Ethr server on port 9999\nethr -s -port 9999\n\n# Measure TCP connection setup latency to ethr server on port 9999\n# Assuming Ethr server is running on server with IP address: 10.1.1.100\nethr -c 10.1.1.100 -p tcp -t pi -d 0 -4 -port 9999\n\n# Measure TCP connection setup latency to www.github.com at port 443\nethr -x www.github.com:443 -p tcp -t pi -d 0 -4\n\n# Measure TCP connection setup latency to www.github.com at port 443\n# Note: Here port 443 is driven automatically from https\nethr -x https://www.github.com -p tcp -t pi -d 0 -4\n\n# Measure ICMP ping latency to www.github.com\nsudo ethr -x www.github.com -p icmp -t pi -d 0 -4\n\n# Run measurement similar to mtr on Linux\nsudo ethr -x www.github.com -p icmp -t mtr -d 0 -4\n\n# Measure packets/s over UDP by sending small 1-byte packets\nethr -c 172.28.192.1 -p udp -t p -d 0\n```\n\n\n\n\n\n# Linux iptables 命令 - 配置 Linux 防火墙\n\n## 介绍\n\n**iptables** 是 Linux 系统常用的防火墙软件，是 netfilter 项目的一部分。可以直接配置，也可以通过许多前端和图形界面配置。实际上，iptables 只是一个应用层的网络配置工具，它需要内核的支持才能正常工作。\n\n### 语法\n\n```bash\niptables -t 表名 <-A/I/D/R> 规则链名 [规则号] <-i/o 网卡名> \n         -p 协议名 <-s 源IP/源子网> \n         --sport 源端口 <-d 目标IP/目标子网> \n         --dport 目标端口 \n         -j 动作\n```\n\n\n\n### 工作机制\n\n规则链名包括(也被称为五个钩子函数（hook functions）)：\n\n- **`INPUT` 链** ：处理输入数据包。\n- **`OUTPUT` 链** ：处理输出数据包。\n- **`FORWARD` 链** ：处理转发数据包。\n- **`PREROUTING` 链** ：用于目标地址转换（DNAT）。\n- **`POSTOUTING` 链** ：用于源地址转换（SNAT）。\n\n### 防火墙的策略\n\n防火墙策略一般分为两种，一种叫“通”策略，一种叫“堵”策略，通策略，默认门是关着的，必须要定义谁能进。堵策略则是，大门是洞开的，但是你必须有身份认证，否则不能进。所以我们要定义，让进来的进来，让出去的出去，所以通，是要全通，而堵，则是要选择。当我们定义的策略的时候，要分别定义多条功能，其中：定义数据包中允许或者不允许的策略，filter 过滤的功能，而定义地址转换的功能的则是 nat 选项。为了让这些功能交替工作，我们制定出了“表”这个定义，来定义、区分各种不同的工作功能和处理方式。\n\n我们现在用的比较多个功能有 3 个：\n\n1. filter 定义允许或者不允许的，只能做在 3 个链上：`INPUT`、`FORWARD`、`OUTPUT`。\n2. nat 定义地址转换的，也只能做在 3 个链上：`PREROUTING`、`OUTPUT`、`POSTROUTING`。\n3. mangle 功能用于修改报文原数据，是 5 个链都可以做：`PREROUTING`、`INPUT`、`FORWARD`、`OUTPUT`、`POSTROUTING`。\n\n我们修改报文原数据就是来修改 TTL 的。能够实现将数据包的元数据拆开，在里面做标记/修改内容的。而防火墙标记，其实就是靠 mangle 来实现的。\n\niptables/netfilter（这款软件）是工作在用户空间的，它可以让规则进行生效的，本身不是一种服务，而且规则是立即生效的。而我们 iptables 现在被做成了一个服务，可以进行启动、停止的。启动，则将规则直接生效，停止，则将规则撤销。\n\niptables 还支持自己定义链。但是自己定义的链，必须是跟某种特定的链关联起来的。在一个关卡设定，指定当有数据的时候专门去找某个特定的链来处理，当那个链处理完之后，再返回。接着在特定的链中继续检查。\n\n注意：规则的次序非常关键，**谁的规则越严格，应该放的越靠前**，而检查规则的时候，是按照从上往下的方式进行检查的。\n\n表名包括：\n\n- **raw** ：高级功能，如：网址过滤。\n- **mangle** ：数据包修改（QOS），用于实现服务质量。\n- **nat** ：地址转换，用于网关路由器。\n- **filter** ：包过滤，用于防火墙规则。\n\n动作包括：\n\n- **ACCEPT** ：接收数据包。\n- **DROP** ：丢弃数据包。\n- **REDIRECT** ：重定向、映射、透明代理。\n- **SNAT** ：源地址转换。\n- **DNAT** ：目标地址转换。\n- **MASQUERADE** ：IP伪装（NAT），用于ADSL。\n- **LOG** ：日志记录。\n- **SEMARK** : 添加SEMARK标记以供网域内强制访问控制（MAC）\n\n## 示例\n\n**1、使用命令 iptables -L 测试**\n\n```bash\n$ sudo iptables -L\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination         \n\nChain FORWARD (policy ACCEPT)\ntarget     prot opt source               destination         \n\nChain OUTPUT (policy ACCEPT)\ntarget     prot opt source               destination\n```\n\n\n\n**2、对 NAT 表做转发设定**\n\n实际上，网关使用 iptables 的一个很重要的目的就是为了实现私网穿透，因此，需要设置 DNAT 和 SNAT 规则。DNAT（Destination Network Address Translation，目的地址转换）通常被叫做目的映射，而 SNAT（Source Network Address Translation，源地址转换）通常被称为源映射。\n\n```bash\n$ sudo iptables -t nat -A POSTROUTING -s 192.168.3.1 -o eth0 -j SNAT --to-source 6.24.34.22\n$ sudo iptables -t nat -A PREROUTING -i eth0 -d 6.24.34.22 -p udp --dport 8507 -j DNAT --to-destination 192.168.3.1:10012\n```\n\n\n\n设置 NAT 转发规则后，可以通过如下命令查看规则：\n\n```bash\n$ sudo iptables -L -n -t nat\nChain PREROUTING (policy ACCEPT)\ntarget     prot opt source               destination         \nDNAT       udp  --  0.0.0.0/0            6.24.34.22           udp dpt:8507 to:192.168.3.1:10012\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination         \nChain OUTPUT (policy ACCEPT)\ntarget     prot opt source               destination         \nChain POSTROUTING (policy ACCEPT)\ntarget     prot opt source               destination         \nSNAT       all  --  192.168.3.1          0.0.0.0/0            to:6.24.34.22\n```\n\n\n\n\n\n# Linux ufw 命令 - 防火墙配置管理工具\n\n## 介绍\n\n**ufw**（英文全拼：Uncomplicated Firewall）命令用于管理 Linux 系统防火墙服务。由于 Linux 系统早期使用的 [iptables](https://getiot.tech/linux-command/iptables/) 防火墙完全基于命令行工作，操作参数及配置方法特别复杂，因此 Ubuntu 系统率先发布了这款基于 iptables 之上的全新、简单防火墙服务管理工具。ufw 支持图形化界面操作，弥补了 iptables 防火墙只支持命令行配置的缺点，使用起来简单很多。\n\n**语法**：\n\n```bash\nufw <COMMAND>\n```\n\n\n\n**命令**：\n\n- `enable`：启动防火墙。\n- `disable`：关闭防火墙。\n- `default ARG`：设置默认策略。\n- `logging LEVEL`：设置日志等级为 `LEVEL`。\n- `allow ARGS`：添加允许通过规则。\n- `deny ARGS`：添加禁止通过规则。\n- `reject ARGS`：添加拒绝规则。\n- `limit ARGS`：添加限制规则。\n- `delete RULE|NUM`：删除规则。\n- `insert NUM RULE`：在 `NUM` 处插入规则。\n- `route RULE`：添加路由规则。\n- `route delete RULE|NUM`：删除路由规则。\n- `route insert NUM RULE`：在 `NUM` 处插入路由规则。\n- `reload`：重新加载防火墙配置。\n- `reset`：重置配置防火墙。\n- `status`：查看防火墙状态。\n- `status numbered`：将防火墙状态显示为规则编号列表。\n- `status verbose`：显示详细的防火墙状态。\n- `show ARG`：显示防火墙报告。\n- `version`：显示版本信息。\n\nApplication profile 命令：\n\n- `app list`：列出应用程序配置文件（application profiles）。\n- `app info PROFILE`：显示 `PROFILE` 的信息。\n- `app update PROFILE`：更新 `PROFILE`。\n- `app default ARG`：设置默认的应用程序策略（application policy）。\n\n## 示例\n\n查看防火墙状态及所有规则（需要 root 权限）：\n\n```bash\nsudo ufw status\n```\n\n\n\n查看防火墙状态、规则及其编号：\n\n```bash\nsudo ufw status numbered\n```\n\n\n\n启动 UFW 防火墙管理工具：\n\n```bash\nsudo ufw enable\n```\n\n\n\n禁用 UFW 防火墙管理工具：\n\n```bash\nsudo ufw disable\n```\n\n\n\n开放 UDP 端口 1234、开放 TCP 端口 1234（可同时开放）：\n\n```bash\nsudo ufw allow 1234/udp\nsudo ufw allow 1234/tcp\n```\n\n\n\n删除上面设置的规则：\n\n```bash\nsudo ufw delete allow 1234/udp\nsudo ufw delete allow 1234/tcp\n```\n\n\n\n通过编号（例如 2）删除特定规则：\n\n```bash\nsudo ufw delete 2\n```\n\n\n\n重启 UFW 防火墙管理工具（更新规则后可能需要执行）：\n\n```bash\nsudo ufw reload\n```\n\n\n\n重置 UFW 防火墙策略：\n\n```bash\nsudo ufw reset\n```\n\n\n\n显示 UFW 防火墙的报告信息：\n\n```bash\nsudo ufw show raw\n```\n\n\n\n\n\n# Linux nfsstat 命令 - 显示 NFS 统计信息\n\n## 介绍\n\n**nfsstat**（英文全拼：NFS statistics）命令用于显示关于 NFS 客户机和服务器活动的统计信息。\n\n**语法**：\n\n```bash\nnfsstat [OPTION]...\n```\n\n\n\n**选项**：\n\n- `-s` ：仅列出 NFS 服务器端状态。\n- `-c` ：仅列出 NFS 客户端状态。\n- `-n` ：仅列出 NFS 状态，默认显示 nfs 客户端和服务器的状态。\n- `-m` ：打印以加载的 nfs 文件系统状态。\n- `-r` ：仅打印 rpc 状态。\n\n## 示例\n\n显示关于客户机发送和拒绝的 RPC 和 NFS 调用数目的信息\n\n```bash\nnfsstat -c\n```\n\n\n\n显示和打印与客户机 NFS 调用相关的信息\n\n```bash\nnfsstat -cn\n```\n\n\n\n显示和打印客户机和服务器的与 RPC 调用相关的信息\n\n```bash\nnfsstat -r\n```\n\n\n\n显示关于服务器接收和拒绝的 RPC 和 NFS 调用数目的信息\n\n```bash\nnfsstat -s\n```\n\n\n\n\n\n# Linux pppd 命令 - 点对点协议守护进程\n\n## 介绍\n\n**pppd**（英文全拼：Point-to-Point Protocol Daemon）是 Linux 系统中用于建立和管理 PPP（点对点协议）连接的守护进程。pppd 支持多种身份验证方法，包括 PAP 和 CHAP 等。\n\n提示\n\nPPP 是一种用于在两个计算机之间建立点对点连接的协议，通常用于拨号连接、DSL 连接和串行线路连接。\n\n**语法**：\n\n```bash\npppd [ options ]\n```\n\n\n\n**选项**：\n\n- `<device>` ：通过指定的设备进行通信。\n- `<speed>` ：将波特率设置为 `speed`（一个十进制数字）。\n- `<loc>:<rem>` ：设置本地和/或远程接口 IP 地址。两者都可以省略，但冒号是必需的。IP 地址可以通过主机名来指定，也可以通过十进制点记法来指定，例如 `:10.1.2.3`。缺省本地地址是系统的第一个 IP 地址，除非提供了 `noipdefault` 选项。\n- `asyncmap <n>` ：将 async 字符映射设置为 `n`（十六进制）。映射描述了哪些控制字符无法通过串行线路成功接收。\n- `auth` ：在允许发送或接收网络数据包之前要求对等方证明自己的身份。\n- `call <name>`：从文件 `/etc/ppp/peers/name` 中读取额外的选项。即使 pppd 不是由 root 运行，这个文件也可以包含诸如 `noauth` 之类的特权选项。注意，`name` 字符串不能以 `/` 开头，也不能包含 `..`。\n- `connect <script>` ：使用由 `script` 指定的可执行文件或 shell 命令来设置串行线路。\n- `crtscts` ：使用硬件流量控制（即 RTS/CTS）来控制串行端口上的数据流。\n- `defaultroute` ：当 IPCP 协商成功完成时，向系统路由表添加一个缺省路由（使用对等方作为网关）。当 PPP 连接断开时，将删除此条目。如果指定了 `nodefaultroute` 选项，则此选项为特权选项。\n- `file <name>` ：从文件 `name` 读取选项。如果此选项在命令行上或 `$HOME/.ppprc` 中使用，则该文件必须能够由调用 `pppd` 的用户读取。\n- `modem` ：使用调制解调器控制线路。此选项为缺省选项。\n- `mru <n>` ：将最大接收单元（Maximum Receive Unit, MRU）值设置为 `n`。pppd 要求对等方发送的包不要超过 n 个字节。最小 MRU 值为 128。缺省 MRU 值为 1500。对于慢速链路，建议使用值 296（40 字节的 TCP/IP 标头 + 256 字节的数据）。对于 IPv6，MRU 必须至少为 1280。\n- `mtu <n>` ：将最大传输单元（Maximum Transmit Unit, MTU）值设置为 `n`。除非对等方通过 MRU 协商请求一个较小的值，否则，pppd 将要求内核联网代码通过 PPP 网络接口发送的数据包不要超过 n 个字节。对于 IPv6，MTU 必须至少为 1280。\n\n## 示例\n\n使用名为 provider 的配置文件来建立拨号连接（配置文件通常存储在 `/etc/ppp/peers` 目录中）：\n\n```bash\npppd call provider\n```\n\n\n\n建立连接时显示详细调试信息：\n\n```bash\npppd call provider debug\n```\n\n\n\n建立连接时提供用户名和密码进行认证：\n\n```bash\npppd call provider user your_username password your_password\n```\n\n\n\n指定串行端口和波特率来建立 PPP 连接：\n\n```bash\npppd /dev/ttyS0 115200\n```\n\n\n\n使用 CHAP 认证方式建立连接（配置信息通常存储在 `/etc/ppp/chap-secrets` 文件）：\n\n```bash\npppd call provider chap-secrets\n```\n\n\n\n使用 PAP 认证方式建立连接（配置信息通常存储在 `/etc/ppp/pap-secrets` 文件）：\n\n```bash\npppd call provider pap-secrets\n```\n\n\n\n\n\n# Linux nm-connection-editor 命令 - 图形界面网络设置\n\n## 介绍\n\n**nm-connection-editor**（英文全拼：network connection editor for NetworkManager）是一个基于 GTK 的应用程序，可用来添加、删除和修改 NetworkManager 存储的网络连接。\n\n注意，运行 nm-connection-editor 的前提是 NetworkManager 必须正在运行。\n\n## 示例\n\n启动 nm-connection-editor 图形配置工具：\n\n```bash\n$ nm-connection-editor\n```\n\n\n\n这将打开类似如下窗口：\n\n![img](./Image/Linux命令大全.assets/nm-connection-editor.png)\n\n相关命令：[nmcli](https://getiot.tech/linux-command/nmcli/)、[nmtui](https://getiot.tech/linux-command/nmtui/)。\n\n\n\n# Linux nmcli 命令 - 网络管理配置工具\n\n## 介绍\n\n**nmcli** 是 NetworkManager 网络管理客户端附带的一个命令行工具。使用 nmcli 命令，可以完成网络设备上的所有配置，并写入配置文件中。\n\n**语法**：\n\n```bash\nnmcli [OPTIONS] OBJECT { COMMAND | help }\n```\n\n\n\n**选项**：\n\n- `-a, --ask`：询问缺少的参数。\n- `-c, --colors auto|yes|no`：是否在输出中使用颜色。\n- `-e, --escape yes|no`：转义值中的列分隔符。\n- `-f, --fields <字段,...>|all|common`：指定要输出的字段。\n- `-g, --get-values <字段,...>|all|common`：组合选项 `-m tabular -t -f` 的快捷方式。\n- `-h, --help`：显示帮助信息。\n- `-m, --mode tabular|multiline`：输出模式。\n- `-o, --overview`：概览模式。\n- `-p, --pretty`：以美化模式输出。\n- `-s, --show-secrets`：允许显示密码。\n- `-t, --terse`：以简洁模式输出。\n- `-v, --version`：显示版本信息。\n- `-w, --wait <秒数>`：设定操作完成的等待超时。\n\n**对象**：\n\n- `g[eneral]`：NetworkManager 的常规状态和操作。\n- `n[etworking]`：整体网络控制。\n- `r[adio]`：NetworkManager 切换开关。\n- `c[onnection]`：NetworkManager 的连接。\n- `d[evice]`：NetworkManager 管理的设备。\n- `a[gent]`：NetworkManager 的私密代理或 polkit 代理。\n- `m[onitor]`：监视 NetworkManager 更改。\n\n提示\n\n对象名可以是单个字母的缩写，也可以是任意字母的组合。例如 `connection` 对象，写成 `c`、`con`、`connection` 是等效的。\n\n## 示例\n\n### 查看连接\n\n显示连接列表及其名称、UUID、类型和支持设备：\n\n```bash\n$ nmcli connection show\n```\n\n\n\n显示活动的连接：\n\n```bash\n$ nmcli connection show -active\n```\n\n\n\n显示指定一个网络连接配置：\n\n```bash\n$ nmcli connection show \"lan eth0\"\n```\n\n\n\n### 查看和操作设备\n\n显示所有网络设备及其状态：\n\n```bash\n$ nmcli device\n```\n\n\n\n等效于：\n\n```bash\n$ nmcli device status\n```\n\n\n\n查看所有网络设备的详细信息：\n\n```bash\n$ nmcli device show\n```\n\n\n\n查看指定网络设备的详细信息：\n\n```bash\n$ nmcli device show \"eth0\"\n```\n\n\n\n断开网络接口上的连接：\n\n```bash\n$ nmcli device disconnect ifname eth0\n```\n\n\n\n### 创建、配置和删除连接\n\n定义一个名字为 default 的新连接，它将使用 DHCP 通过 `eth0` 设备的以太网自动连接 ：\n\n```bash\n$ nmcli connection add con-name \"default\" type ethernet ifname eth0\n```\n\n\n\n关闭自动连接：\n\n```bash\n$ nmcli connection modify \"default\" connection.autoconnect no\n```\n\n\n\n添加 DNS：\n\n```bash\n$ nmcli connection modify \"default\" ipv4.dns 8.8.8.8\n```\n\n\n\n启用 default 连接配置（激活连接）：\n\n```bash\n$ nmcli connection up \"default\"\n```\n\n\n\n删除 default 连接：\n\n```bash\n$ nmcli connection delete \"default\"\n```\n\n\n\n重启服务：\n\n```bash\n$ nmcli connection reload\n```\n\n\n\n### Wi-Fi 操作\n\n显示附近的 Wi-Fi 网络：\n\n```bash\n$ nmcli device wifi list\n```\n\n\n\n连接到 Wi-Fi 网络：\n\n```bash\n$ nmcli device wifi connect <SSID_或_BSSID> password <密码>\n```\n\n\n\n连接到隐藏的 Wi-Fi 网络：\n\n```bash\n$ nmcli device wifi connect <SSID_或_BSSID> password <密码> hidden yes\n```\n\n\n\n连接到 `wlan1` 网络接口上的 Wi-Fi：\n\n```bash\n$ nmcli device wifi connect <SSID_或_BSSID> password <密码> ifname wlan1 <profile_name>\n```\n\n\n\n关闭 Wi-Fi：\n\n```bash\n$ nmcli radio wifi off\n```\n\n\n\n### 查看帮助\n\nnmcli 命令有很多子命令，可通过如下方式查看命令及其子命令的帮助信息：\n\n```bash\n$ nmcli help\n$ nmcli connection help\n$ nmcli connection add help\n```\n\n\n\n\n\n# Linux nmtui 命令 - 文本界面网络设置\n\n## 介绍\n\n**nmtui** 是 NetworkManager 网络管理客户端附带的一个命令行工具。它是一个基于 Curses 的 TUI（Text User Interface）应用程序，用于与 NetworkManager 交互。启动 nmtui 时，系统会提示用户选择要执行的活动，除非将其指定为第一个参数。\n\n**语法**：\n\n```bash\nnmtui [OPTIONS]\n```\n\n\n\n**选项**：\n\n- `-h, --help`：显示帮助信息。\n\nnmtui 支持以下三种活动：\n\n- `edit`：显示连接编辑器，支持添加、修改、查看和删除连接。它提供与 [`nm-connection-editor`](https://getiot.tech/linux-command/nm-connection-editor/) 类似的功能。\n- `connect`：显示可用连接的列表，以及激活或停用它们的选项。它提供与 `nm-applet` 类似的功能。\n- `hostname`：设置系统主机名。\n\n与上述活动相对应，`nmtui` 还附带了名为 `nmtui-edit`、`nmtui-connect` 和 `nmtui-hostname` 的二进制文件，用于跳过活动的选择。\n\n```bash\nnmtui-edit     等效于  nmtui edit  {name | id}\nnmtui-connect  等效于  nmtui connect  {name | uuid | device | SSID}\nnmtui-hostname 等效于  nmtui hostname\n```\n\n\n\n## 示例\n\n通过命令行启动 nmtui 程序：\n\n```bash\n$ nmtui\n```\n\n\n\n可以看到如下字符窗口，你可以根据提示通过键盘操作。\n\n![img](./Image/Linux命令大全.assets/nmtui-screenshot.png)\n\n\n\n# Linux socat 命令 - 双向数据传输工具\n\n## 介绍\n\n**socat**（英文全拼：Socket CAT）是 Linux 下的一个多功能的网络工具，其功能与有瑞士军刀之称的 [Netcat](https://getiot.tech/linux-command/netcat/) 类似，可以看作是 Netcat 的加强版。socat 的主要特点就是在两个数据流之间建立通道，这些数据通道包含文件、管道、设备（终端或调制解调器等）、Socket、SSL、SOCKS4 客户端或代理 CONNECT。\n\nsocat 支持众多协议和链接方式，如 IP、TCP、 UDP、IPv6、PIPE、EXEC、System、Open、Proxy、Openssl、Socket 等。支持广播和多播、抽象 Unix sockets、Linux tun/tap、GNU readline 和 PTY，并提供了分叉、记录和进程间通信的不同模式。\n\n项目网址：http://www.dest-unreach.org/socat/\n\nsocat 命令由 socat 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install socat\n```\n\n\n\n**语法**：\n\n```bash\nsocat [options] <address> <address>\n```\n\n\n\n**选项**：\n\n- `-V` ：显示版本信息及特性。\n- `-h|-?` ：显示帮助信息，包括选项（options）和地址（addresses）。\n- `-hh` ：与 -h 类似，但会列出所有通用的地址选项名称。\n- `-hhh` ：与 -hh 类似，但会列出所有可用的地址选项名称。\n- `-d[ddd]` ：增加详细程度（最多使用 4 次，建议使用 2 次）。\n- `-D` ：在循环之前分析文件描述符。\n- `-ly[facility]` ：将日志输出到 syslog 系统日志（默认使用守护进程）。\n- `-lf<logfile>` ：将日志输出到文件。\n- `-ls` ：将日志输出到标准错误 stderr（如果没有指定其他日志，则默认使用 stderr）。\n- `-lm[facility]` ：混合日志模式（初始化期间使用标准错误 stderr，之后使用系统日志 syslog）。\n- `-lp<progname>` ：设置用于日志记录的程序名称。\n- `-lu` ：使用微秒记录日志时间戳。\n- `-lh` ：在日志信息中添加主机名称。\n- `-v` ：详细的数据流量，文本格式。\n- `-x` ：详细数据流量，十六进制格式。\n- `-b<size_t>` ：设置数据缓冲区大小（默认 8192）。\n- `-s` ：马虎模式（出错时继续执行）。\n- `-t<timeout>` ：在关闭第二个频道之前等待几秒钟。\n- `-T<timeout>` ：总的不活动（inactivity ）超时时间（以秒为单位）。\n- `-u` ：单向模式（从左到右）。\n- `-U` ：单向模式（从右到左）。\n- `-g` ：不检查选项组。\n- `-L <lockfile>` ：尝试获取锁，否则失败。\n- `-W <lockfile>` ：尝试获取锁，否则等待。\n- `-4` ：如果未明确指定版本，则首选 IPv4。prefer IPv4 if version is not explicitly specified\n- `-6` ：如果未明确指定版本，则首选 IPv6。prefer IPv6 if version is not explicitly specified\n\n**参数**：address 参数用于提供数据通道的必要信息，不同类型的数据通道有不同的地址参数。下列列出几种模式：\n\n- `-` `STDIN` `STDOUT` ：表示标准输入输出，可以就用一个横杠代替。\n- `/var/log/syslog` ：也可以是任意路径，如果是相对路径要使用 `./`，打开一个文件作为数据流。\n- `TCP:127.0.0.1:1080` ：建立一个 TCP 连接作为数据流，TCP 也可以替换为 UDP。\n- `TCP-LISTEN:12345` ：建立 TCP 监听端口，TCP 也可以替换为 UDP。\n- `EXEC:/bin/bash` ：执行一个程序作为数据流。\n\n## 示例\n\n### 文件操作\n\n通过 socat 读取一个本地的文件，并在终端显示\n\n```bash\nsocat - /etc/sysctl.conf\n```\n\n\n\n通过 socat 将一段文本写入一个本地文件\n\n```bash\necho \"Hello GetIoT.tech\" | socat - /tmp/hello.txt\n```\n\n\n\n### 虚拟串口\n\n创建两个可以相互通信的 Linux 虚拟串口\n\n```bash\n$ socat -d -d PTY PTY\n2026/07/15 05:29:51 socat[1533] N PTY is /dev/pts/0\n2026/07/15 05:29:51 socat[1533] N PTY is /dev/pts/1\n2026/07/15 05:29:51 socat[1533] N starting data transfer loop with FDs [5,5] and [7,7]\n```\n\n\n\n当前产生的虚拟串口为 `/dev/pts/0` 和 `/dev/pts/1`，如果想要虚拟的串口一直有效，必须使 socat 一直运行。\n\n可以给 address 字段添加额外参数\n\n```bash\nsocat -d -d pty,raw,echo=0 pty,raw,echo=0\n```\n\n\n\n接着就可以使用 minicom 打开串口终端进行测试\n\n```bash\nminicom -D /dev/pts/0 -b 9600    # 打开一个串口终端\nminicom -D /dev/pts/1 -b 9600    # 打开另一个串口终端\n```\n\n\n\n在 minicom 命令中输入指令，在另一个 minicom 终端就能接收到了。\n\n### TCP 通信\n\n创建服务器端，侦听 2222 端口\n\n```bash\nsocat – tcp4-listen:2222\n```\n\n\n\n查看 2222 端口是否打开\n\n```bash\nnetstat -pantu | grep :2222\n```\n\n\n\n客户端连接到服务器端\n\n```bash\nsocat tcp:192.168.1.110:2222\n```\n\n\n\n服务端和客户端就能相互通信了\n\n### 网络管理\n\n连接远程端口\n\n```bash\nsocat - TCP:192.168.1.252:3306\n```\n\n\n\n监听一个新端口\n\n```bash\nsocat TCP-LISTEN:7000 -\n```\n\n\n\n### 端口转发\n\n在实际生产中我们经常会遇到到一个场景就是，用一台机器作为转发服务器，连接 AB 两个网段，将转发服务器的某个端口上的流量转发到 B 网段的某台机器的某个端口，这样 A 网段的服务器就可以通过访问转发服务器上的端口访问到 B 网段的服务器端口。\n\n这样的场景一般在和客户建立专线的连接时候经常用到，一般也可以采用 iptables 做转发，但是比较复杂。socat 可以很轻松的完成这个功能，但是 socat 不支持端口段转发，只适用于单端口或者少量端口。\n\n#### 转发 TCP\n\n监听 192.168.1.252 网卡的 15672 端口，并将请求转发至 172.17.0.15 的 15672 端口。\n\n```bash\nsocat -d -d -lf /var/log/socat.log TCP4-LISTEN:15672,bind=192.168.1.252,reuseaddr,fork TCP4:172.17.0.15:15672\n```\n\n\n\n参数说明：\n\n- 前面两个连续的 `-d` `-d` 代表调试信息的输出级别。\n- `-lf /var/log/socat.log` 指定输出信息的文件保存位置。\n- `TCP4-LISTEN:15672` 在本地建立一个 TCP IPv4 协议的监听端口，也就是转发端口。这里是 15672，请根据实际情况改成你自己需要转发的端口。\n- `bind` 指定监听绑定的 IP 地址。\n- `reuseaddr` 设置本地端口可重复使用。\n- `fork TCP4:172.17.0.15:15672` 指的是要转发到的服务器 IP 和端口，这里是 172.17.0.15 的 15672 端口。\n\n#### 转发 UDP\n\n转发 UDP 和 TCP 类似，只要把 TCP4 改成 UDP4 就行了。\n\n```bash\nsocat -d -d -lf /var/log/socat.log UDP4-LISTEN:123,bind=192.168.1.252,reuseaddr,fork UDP4:172.17.0.15:123\n```\n\n\n\n#### NAT 映射\n\n在一个 NAT 网络环境中，也是可以通过 socat 将内部机器端口映射到公网上的。\n\n在外部公网机器上执行\n\n```bash\nsocat tcp-listen:1234 tcp-listen:3389\n```\n\n\n\n在内部私网机器上执行\n\n```bash\nsocat tcp:outerhost:1234 tcp:192.168.1.34:3389\n```\n\n\n\n这样，外部机器上的 3389 就映射在内网 192.168.1.34 的 3389 端口上，实现私网穿透。\n\n### 文件传递\n\n#### 文件传送\n\n将文件 demo.tar.gz 使用 2000 端口从 192.168.1.252 传到 192.168.1.253，文件传输完毕后会自动退出。\n\n在 192.168.1.252 上执行\n\n```bash\nsocat -u open:demo.tar.gz tcp-listen:2000,reuseaddr\n```\n\n\n\n在 192.168.1.253 上执行\n\n```bash\nsocat -u tcp:192.168.1.252:2000 open:demo.tar.gz,create\n```\n\n\n\n#### 读写分流功能\n\nsocat 具有一个独特的读写分流功能，比如：可以实现一个假的 Web Server，客户端连过来之后就把 read.html 里面的内容传过去，同时把客户端的数据保存到 write.txt 里面。\n\n```bash\nsocat open:read.html\\!\\!open:write.txt,create,append tcp-listen:8000,reuseaddr,fork\n```\n\n\n\n注意：!! 符号用于合并读写流，前面的用于读，后面的用于写。由于 ! 在 Shell 中是特殊字符，所以这里在命令行中使用 \\ 对其进行了转义。\n\n### 本地域套接字\n\n监听一个 Unix Socket\n\n```bash\nsocat unix-listen:/tmp/unix.socket -\n```\n\n\n\n向本地 Unix Socket 发送数据\n\n```bash\necho \"test\" | socat - unix-connect:/tmp/unix.sock\n```\n\n\n\n监听本地 Unix Datagram Socket\n\n```bash\nsocat unix-recvfrom:/tmp/unix.dg.sock -\n```\n\n\n\n向本地 Unix Datagram Socket 发送数据\n\n```bash\necho \"test\" | socat - unix-sendto:/tmp/unix.dg.sock\n```\n\n\n\n### 其它功能\n\n在目标机上弄一个 shell 代理\n\n```bash\nsocat TCP-LISTEN:12345 EXEC:/bin/bash\n```\n\n\n\n将本地的 UNIX 域套接字转成 TCP socket 供局域网内的机器使用（当有多个 TCP 连上来那就 fork 一个去连接 UNIX 域套接字）\n\n```bash\nsocat TCP-LISTEN:12345,reuseaddr,fork UNIX-CONNECT:/data/deCOREIDPS/unix.domain\n```\n\n\n\n将本地的 80 端口转到远程服务器的 80 端口\n\n```bash\nsocat TCP-LISTEN:80,fork TCP:www.getiot.tech:80\n```\n\n\n\n\n\n# Linux wvdial 命令 - PPP 拨号工具\n\n## 介绍\n\n**wvdial** 是一个智能的 PPP 拨号工具，这意味着它会拨打调制解调器并启动 PPP 连接到互联网。wvdial 类似于 chat 程序，不同之处在于它使用启发式方法来猜测如何拨号和登录您的服务器，而不是强迫您编写登录脚本。这里 PPP 的作用是与拨入方协商传输数据的方法并维持该连接。\n\nwvdial 命令由 wvdial 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install wvdial\n```\n\n\n\n当 wvdial 启动时，它首先从 /etc/wvdial.conf 和 ~/.wvdialrc 加载其配置，其中包含有关调制解调器端口、速度和初始化字符串等基本信息，以及有关 Internet 服务提供商 (ISP) 的信息，例如：电话号码、您的用户名和密码。然后它会初始化您的调制解调器并拨打服务器并等待连接（来自调制解调器的 CONNECT 字符串）。它理解并响应典型的连接问题（如忙和无拨号）。\n\n连接后的任何时候，如果 wvdial 看到来自服务器的 PPP 序列，它就会启动 PPP。 否则，它会尝试通过执行以下操作来说服服务器启动 PPP：\n\n- 响应它看到的任何登录名/密码提示；\n- 解释“选择以下之一”风格的菜单；\n- 最终，发送单词“ppp”（一个常见的终端服务器命令）。\n\n如果这些尝试都失败了，wvdial 只会运行 pppd 命令，并希望一切顺利。它将启动连接，然后耐心等待您按 Ctrl + C 删除链接。\n\n**语法**：\n\n```bash\nwvdial [ OPTIONS ] [ SECTION ] ...\n```\n\n\n\n**选项**：\n\n- `-c`, `--chat` ：在 pppd 中运行 wvdial 作为聊天替换，而不是让 wvdial 协商连接然后调用 pppd 的更正常的方法。\n- `-C`, `--config=CONFIGFILE` ：使用 `CONFIGFILE` 作为配置文件运行 wvdial，而不是 /etc/wvdial.conf。该选项主要用在当您希望为每个用户单独添加配置，或者想避免在系统范围的配置文件中包含拨号信息（用户名、密码、电话卡号码等）的时候。\n- `-n`, `--no-syslog` ：不要将调试信息输出到 syslog 守护进程（仅与 --chat 一起使用时有效）。\n- `--help` ：显示帮助信息。\n- `--version` ：显示版本信息。\n\n**参数**：\n\n参数 `SECTION` 是配置文件（类似 windows 里的 ini 文件）中的某一段，一个 wvdial.conf 配置文件可以有好多个 section，每一个 section 由一些变量组成，可以使用 [wvdialconf](https://getiot.tech/linux-command/wvdialconf/) 命令自动生成配置文件。\n\nwvdial 通常在没有命令行选项的情况下运行，在这种情况下，它从 /etc/wvdial.conf 的 `[Dialer Defaults]` 部分读取其配置。关于配置文件的详细说明，可以通过 `man wvdial.conf` 命令获取。下面是一个 wvdial.conf 配置文件的示例：\n\n```ini\n[Dialer Defaults]\nModem = /dev/ttyS2\nBaud = 57600\nInit = ATZ\nInit2 = AT S11=50\nPhone = 555-4242\nUsername = apenwarr\nPassword = my-password\n\n[Dialer phone2]\nPhone = 555-4243\n\n[Dialer shh]\nInit3 = ATM0\n\n[Dialer pulse]\nDial Command = ATDP\n```\n\n\n\n## 示例\n\n从 /etc/wvdial.conf 配置文件中读取 `[Dialer phone2]` 的选项参数进行拨号：\n\n```bash\nwvdial phone2\n```\n\n\n\n提示：该命令将首先读取 `[Dialer Defaults]` 部分的默认选项（如果有），然后再从 `[Dialer phone2]` 部分中找到的覆盖默认选项的所有选项。可以在命令行中指定 /etc/wvdial.conf 的一个或多个 SECTION。如果指定了多个部分，则将按照给定的顺序处理它们，每个部分将覆盖它之前的所有部分。\n\n例如，下面命令将先从 `[Dialer Defaults]` 部分读取默认选项，然后使用在 `[Dialer phone2]` 部分中找到的选项覆盖任何或所有选项，然后是 `[Dialer pulse]` 部分，最后是 `[Dialer shh]` 部分。\n\n```bash\nwvdial phone2 pulse shh\n```\n\n\n\n使用这种方法，就可以轻松地配置 wvdial 以在不同的 Internet 提供商、调制解调器初始化字符串、帐户名称等之间切换，而无需一遍又一遍地指定相同的配置信息。\n\n\n\n# Linux wvdialconf 命令 - 配置调制解调器\n\n## 介绍\n\n**wvdialconf** 命令用于为 [wvdial](https://getiot.tech/linux-command/wvdial/) 生成一个配置文件，默认为 /etc/wvdial.conf。通常在首次安装 wvdial 工具，还没有配置文件时使用。\n\nwvdialconf 会检测 Linux 系统当前接入的调制解调器，获取最大波特率和初始化字符串信息，并根据这些信息生成或更新 wvdial 配置文件。\n\n注意：wvdialconf 是完全非交互式的。意味着您仍然需要编辑 /etc/wvdial.conf 以指定 Internet 帐户的电话号码、登录名和密码，才能让 wvdial 正常工作。\n\n## 示例\n\n插入 modem，执行下面命令生成 wvdial 配置文件\n\n```bash\nsudo wvdialconf\n```\n\n\n\n或者指定文件名\n\n```bash\nsudo wvdialconf /etc/wvdial.conf\n```\n\n\n\n执行完成后，会生成 `/etc/wvdial.conf` 文件，内容如下：\n\n```ini\n[Dialer Defaults]\nInit2 = ATQ0 V1 E1 S0=0 &C1 &D2 +FCLASS=0\nModem Type = Analog Modem\n; Phone = <Target Phone Number>\nISDN = 0\n; Username = <Your Login Name>\nInit1 = ATZ\n; Password = <Your Password>\nModem = /dev/ttyUSB2\nBaud = 9600\n```\n\n\n\n\n\n# Linux networkctl 命令 - 查询控制网络状态\n\n## 介绍\n\n**networkctl**（英文全拼：network control）用于查询和控制 Linux 网络子系统，比如查看网络设备及其连接状态的摘要。\n\nnetworkctl 是新版本 systemd 命令集中的命令之一，对应 systemd-networkd 服务。\n\n**语法**：\n\n```bash\nnetworkctl [OPTIONS...] COMMAND [LINK...]\n```\n\n\n\n**命令**：\n\n- `list [PATTERN...]` ：列出存在的连接及其状态。若未指定连接(LINK)则显示所有连接， 否则仅显示指定的连接。\n- `status [PATTERN...]` ：显示连接的各种信息，包括类型、状态、内核模块、MAC 地址、IP 地址、DNS 服务器等等。\n- `lldp [PATTERN...]` ：显示已发现的 LLDP（Link Layer Discovery Protocol）邻居。若未指定连接，则显示所有连接上发现的邻居，否则仅显示指定连接上发现的邻居。\n- `label` ：显示以数字形式表示的地址标签，可用于地址选择。\n- `delete DEVICES...` ：删除虚拟网卡设备。\n- `renew DEVICES...` ：更新动态配置。\n- `reconfigure DEVICES...` ：重新配置接口。\n- `reload` ：重新加载 .network 和 .netdev 文件。\n\n**选项**：\n\n- `--no-pager` ：不将程序的输出内容（通过 pipe）给分页程序。\n- `--no-legend` ：不输出列标题，也就是不在输出列表的头部和尾部显示字段的名称。\n- `-a`, `--all` ：显示所有连接的状态。\n- `-s`, `--stats` ：显示详细的链接统计信息。\n- `-l`, `--full` ：不要省略输出。\n- `-n`, `--lines=INTEGER` ：要显示的日记数目。\n- `-h`, `--help` ：显示帮助信息。\n- `--version` ：显示 systemd 软件包的版本信息。\n\n## 示例\n\n列出所有连接及其状态，相当于 `networkctl list` 或 `networkctl -a`\n\n```bash\n$ networkctl\nIDX LINK TYPE     OPERATIONAL SETUP\n  1 lo   loopback carrier     unmanaged\n  2 eth0 ether    routable    unmanaged\n  3 eth1 ether    no-carrier  unmanaged\n  4 ppp0 ppp      routable    unmanaged\n\n4 links listed.\n```\n\n\n\n显示连接的状态信息\n\n```bash\n$ networkctl status\n*   State: routable\n  Address: 192.168.31.223 on eth0\n           10.106.236.134 on ppp0\n           fe80::a897:4bff:fe16:c0a6 on eth0\n  Gateway: 192.168.30.1 on eth0\n```\n\n\n\n显示网络接口 eth0 的各种信息\n\n```bash\n$ networkctl status eth0\n* 2: eth0\n             Link File: n/a\n          Network File: n/a\n                  Type: ether\n                 State: routable (unmanaged)\n                  Path: platform-30be0000.ethernet\n                Driver: fec\n            HW Address: aa:97:4b:16:c0:a6\n                   MTU: 1500 (min: 68, max: 1500)\n  Queue Length (Tx/Rx): 3/3\n      Auto negotiation: yes\n                 Speed: 100Mbps\n                Duplex: full\n                  Port: mii\n               Address: 192.168.31.223\n                        fe80::a897:4bff:fe16:c0a6\n               Gateway: 192.168.30.1\n```\n\n\n\n\n\n# Linux ss 命令 - 显示套接字统计信息\n\n## 介绍\n\n**ss**（英文全拼：socket statistics）命令用于获取 socket 统计信息，其输出的结果类似于 netstat 输出的内容，但能显示更多、更详细的 TCP 连接状态的信息，而且比 netstat 更快速高效。\n\n**语法**：\n\n```shell\nss [options] [ FILTER ]\n```\n\n\n\n**选项**：\n\n- `-h`, `--help` ：显示帮助信息。\n- `-V`, `--version` ：显示版本信息。\n- `-n`, `--numeric` ：不解析服务名称。\n- `-r`, `--resolve` ：解析主机名。\n- `-a`, `--all` ：显示所有套接字（sockets）。\n- `-l`, `--listening` ：显示监听状态的套接字。\n- `-o`, `--options` ：显示计时器信息。\n- `-e`, `--extended` ：显示详细的套接字信息。\n- `-m`, `--memory` ：显示套接字的内存使用情况。\n- `-p`, `--processes` ：显示使用套接字的进程。\n- `-i`, `--info` ：显示 TCP 内部信息。\n- `-s`, `--summary` ：显示套接字使用概况。\n- `-4`, `--ipv4` ：仅显示 IPv4 的套接字。\n- `-6`, `--ipv6` ：仅显示 IPv6 的套接字。\n- `-0`, `--packet` ：显示 PACKET 套接字。\n- `-t`, `--tcp` ：仅显示 TCP 套接字。\n- `-u`, `--udp` ：仅显示 UCP 套接字。\n- `-d`, `--dccp` ：仅显示 DCCP 套接字。\n- `-w`, `--raw` ：仅显示 RAW 套接字。\n- `-x`, `--unix` ：仅显示 UNIX 套接字。\n- `-f`, `--family=FAMILY` ：显示 FAMILY 类型的套接字，FAMILY 可选 unix、inet、inet6、link、netlink、vsock、xdp。\n- `-A`, `--query=QUERY`, `--socket=QUERY` ：QUERY 可选 all、inet、tcp、udp、raw、unix、packet、netlink 等。\n- `-D`, `--diag=FILE` ：将原始 TCP 套接字信息转储到文件 FILE。\n- `-F`, `--filter=FILE` ：从文件 FILE 中读取过滤器信息。\n\n**参数**：`FILTER`（可选），过滤器表达式。\n\n## 示例\n\n显示所有 TCP 套接字\n\n```shell\nss -t -a\n```\n\n\n\n显示所有带有进程 SELinux 安全上下文的 TCP 套接字\n\n```shell\nss -t -a -Z\n```\n\n\n\n显示所有 UDP 套接字\n\n```shell\nss -u -a\n```\n\n\n\n显示所有已建立的 ssh 连接\n\n```shell\nss -o state established '( dport = :ssh or sport = :ssh )'\n```\n\n\n\n查找所有连接到 X 服务器的本地进程\n\n```shell\nss -x src /tmp/.X11-unix/*\n```\n\n\n\n列出我们的 apache 到网络 193.233.7/24 的状态为 FIN-WAIT-1 的所有 tcp 套接字并查看它们的计时器\n\n```shell\nss -o state fin-wait-1 '( sport = :http or sport = :https )' dst 193.233.7/24\n```\n\n\n\n列出所有套接字表中所有状态的套接字（但 TCP 除外）\n\n```shell\nss -a -A 'all,!tcp'\n```\n\n\n\n\n\n# Linux lsusb 命令 - 列出 USB 设备信息\n\n## 介绍\n\n**lsusb** 命令用于显示当前主机的 USB 设备列表，以及 USB 设备的详细信息。\n\nlsusb 命令由 usbutils 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\n$ sudo apt install usbutils\n```\n\n\n\nlsusb 命令是一个学习 USB 驱动开发，认识 USB 设备的助手，推荐大家使用！\n\n**语法**：\n\n```bash\nlsusb [ options ]\n```\n\n\n\n**选项**：\n\n- `-v` ：显示 USB 设备的详细信息。\n- `-s [[bus]:][devnum]` ：仅显示指定的总线和（或）设备号的设备。\n- `-d [vendor]:[product]` ：仅显示指定厂商和产品编号的设备。\n- `-D device` ：显示指定 device 的信息，而不使用预设的 /dev/bus/usb 目录。\n- `-t` ：以树状结构显示物理 USB 设备的层次，可与 `v` 选项一起使用以显示详细信息。\n- `-V` ：显示命令的版本信息。\n\n## 示例\n\n插入 usb 鼠标后执行 lsusb 查看当前设备列表\n\n```bash\n$ lsusb\nBus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub\nBus 003 Device 005: ID 0424:2840 Standard Microsystems Corp.\nBus 003 Device 004: ID 10c4:ea71 Cygnal Integrated Products, Inc.\nBus 003 Device 002: ID 0424:2806 Standard Microsystems Corp. USB2806 Smart Hub\nBus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\nBus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub\nBus 001 Device 006: ID 1c4f:0034 SiGma Micro Usb Mouse\nBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\n```\n\n\n\n说明：\n\n- **Bus 004** 表示第四个 usb 主控制器（机器上总共有四个 usb 主控制器，可以通过命令 `lspci | grep USB` 查看）。\n- **Device 006** 表示系统给 usb 鼠标分配的设备号（devnum），同时也可以看到该鼠标是插入到了第一个 usb 主控制器。\n- **ID 1c4f:0034** 表示 usb 设备的 ID（这个 ID 由芯片制造商设置，可以唯一表示该设备）。可在 `/sys/devices/pci0000:00/0000:[<bus>]:][<slot>][.[<func>]/usbx/x-x/` 目录下查看 devnum、idVendor、idProduct 等信息。\n\n以树状形式查看 USB 设备列表\n\n```bash\n$ lsusb -t\n/:  Bus 04.Port 1: Dev 1, Class=root_hub, Driver=xhci-hcd/1p, 5000M\n/:  Bus 03.Port 1: Dev 1, Class=root_hub, Driver=xhci-hcd/1p, 480M\n    |__ Port 1: Dev 2, If 0, Class=Hub, Driver=hub/7p, 480M\n        |__ Port 5: Dev 4, If 1, Class=Vendor Specific Class, Driver=cp210x, 12M\n        |__ Port 5: Dev 4, If 2, Class=Vendor Specific Class, Driver=cp210x, 12M\n        |__ Port 5: Dev 4, If 0, Class=Vendor Specific Class, Driver=cp210x, 12M\n        |__ Port 5: Dev 4, If 3, Class=Vendor Specific Class, Driver=cp210x, 12M\n        |__ Port 7: Dev 5, If 0, Class=Vendor Specific Class, Driver=, 480M\n/:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=xhci-hcd/1p, 5000M\n/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=xhci-hcd/1p, 480M\n    |__ Port 1: Dev 7, If 0, Class=Human Interface Device, Driver=usbhid, 1.5M\n```\n\n\n\n每一行末尾的数字表示 USB 类型的传输速率，例如：\n\n- 12M 意味着 USB 1.0/1.1 的速率是 12Mbit/s\n- 480M 意味着 USB 2.0 的速率是 480Mbit/s\n- 5000M 意味着 USB 3.0 的速率是 5Gbit/s\n\n\n\n# Linux lspci 命令 - 列出 PCI 设备信息\n\n## 介绍\n\n**lspci** 命令用于显示当前主机的所有 PCI 总线信息，以及所有已连接的 PCI 设备信息。\n\nlspci 命令由 pciutils 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\n$ sudo apt install pciutils\n```\n\n\n\n**语法**：\n\n```bash\nlspci [options]\n```\n\n\n\n**选项**：\n\n- `-n` ：以数字方式显示 PCI 生产厂商和设备代码。\n\n- `-t` ：以树状结构显示 PCI 设备的层次关系，包括所有的总线、桥、设备以及它们之间的联接。\n\n- `-b` ：以总线为中心的视图。显示所有 IRQ 号和记忆体地址，就像 PCI 总线上的卡看到的一样，而不是系统内核看到的内容。\n\n- `-d [<vendor>]:[<device>]` ：仅显示给定厂商和设备的信息。这两个 ID 都以十六进制表示，可以忽略或者以「`*`」代替（意味著所有值）。\n\n- ```\n  -s [[<bus>]:][<slot>][.[<func>]]\n  ```\n\n   \n\n  ：仅显示指定总线、插槽上的设备和设备上的功能块信息。设备地址的任何部分都可以忽略，或以「\n\n  ```\n  *\n  ```\n\n  」代替（意味著所有值）。所有数字都是十六进制，例如：\n\n  - 「`0:`」指的是在0号总线上的所有设备；\n  - 「`0`」指的是在任意总线上0号设备的所有功能块；\n  - 「`0.3`」选择 了所有总线上0号设备的第三个功能块；\n  - 「`.4`」则是只列出每一设备上的第四个功能块。\n\n- `-i <file>` ：指定 PCI 编号列表文件，而不使用默认的文件。\n\n- `-p <dir>` ：指定包含 PCI 总线信息的目录，而不使用预设的目录 /proc/bus/pci。\n\n- `-m` ：以机器可读方式显示 PCI 设备信息。\n\n- `-M` ：使用总线映射模式，这种模式对总线进行全面地扫描以查明总线上的所有设备，包括配置错误的桥之后的设备。请注意，此操作只应在调试时使用，并可能造成系统崩溃（只在设备有错误的时候，但是不幸的是它们存在），此命令只有 root 可以使用。同时，在不直接接触硬件的 PCI 访问模式中使用 `-M` 参数没有意义，因为显示的结果（排除 lspci 中的 bug 的影响）与普通的列表模式相同。\n\n- `-x` ：以十六进制显示 PCI 配置空间（configuration space）的前64个字节映像（标准头部信息）。此参数对调试驱动和 lspci 本身很有用。\n\n- `-v` ：使得 lspci 以冗余模式显示所有设备的详细信息。\n\n- `-vv` ：使得 lspci 以过冗余模式显示更详细的信息（事实上是 PCI 设备能给出的所有东西）。这些数据的确切意义没有在此手册页中解释，如果你想知道更多，请参照 /usr/include/linux/pci.h 或者 PCI 规范。\n\n## 示例\n\n不必添加任何选项，就能够显示出目前的硬件配备\n\n```bash\n$ lspci\n00:00.0 Host bridge: Intel Corporation Haswell-ULT DRAM Controller (rev 0b)\n00:02.0 VGA compatible controller: Intel Corporation Haswell-ULT Integrated Graphics Controller (rev 0b)\n00:03.0 Audio device: Intel Corporation Haswell-ULT HD Audio Controller (rev 0b)\n00:14.0 USB controller: Intel Corporation 8 Series USB xHCI HC (rev 04)\n00:16.0 Communication controller: Intel Corporation 8 Series HECI #0 (rev 04)\n00:19.0 Ethernet controller: Intel Corporation Ethernet Connection I218-V (rev 04)\n......\n```\n\n\n\n查看一般详细信息\n\n```bash\n$ lspci -v\n00:00.0 Host bridge: Intel Corporation Haswell-ULT DRAM Controller (rev 0b)\n        Subsystem: Lenovo Haswell-ULT DRAM Controller\n        Flags: bus master, fast devsel, latency 0\n        Capabilities: <access denied>\n        Kernel driver in use: hsw_uncore\n\n00:02.0 VGA compatible controller: Intel Corporation Haswell-ULT Integrated Graphics Controller (rev 0b) (prog-if 00 [VGA controller])\n        Subsystem: Lenovo Haswell-ULT Integrated Graphics Controller\n        Flags: bus master, fast devsel, latency 0, IRQ 49\n        Memory at d0000000 (64-bit, non-prefetchable) [size=4M]\n        Memory at c0000000 (64-bit, prefetchable) [size=256M]\n        I/O ports at 5000 [size=64]\n        Expansion ROM at 000c0000 [virtual] [disabled] [size=128K]\n        Capabilities: <access denied>\n        Kernel driver in use: i915\n        Kernel modules: i915\n......\n```\n\n\n\n查看网卡详细信息（-s 后面接的是每个设备的总线、插槽与相关函数功能）\n\n```bash\n$ lspci -s 00:19.0 -vv\n00:19.0 Ethernet controller: Intel Corporation Ethernet Connection I218-V (rev 04)\n        Subsystem: Lenovo Ethernet Connection I218-V\n        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx+\n        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR- INTx-\n        Latency: 0\n        Interrupt: pin A routed to IRQ 44\n        Region 0: Memory at d0700000 (32-bit, non-prefetchable) [size=128K]\n        Region 1: Memory at d073e000 (32-bit, non-prefetchable) [size=4K]\n        Region 2: I/O ports at 5080 [size=32]\n        Capabilities: <access denied>\n        Kernel driver in use: e1000e\n        Kernel modules: e1000e\n```\n\n\n\n查看网卡的厂商和设备代码\n\n```bash\n$ lspci -nn | grep Eth\n00:19.0 Ethernet controller [0200]: Intel Corporation Ethernet Connection I218-V [8086:1559] (rev 04)\n```\n\n\n\n\n\n# Linux lshw 命令 - 列出硬件配置详细信息\n\n## 介绍\n\n**lshw**（英文全拼：list hardware）命令用于检查硬件组件及其核心配置。它能为我们提供内存配置、固件版本、主板配置信息、CPU 版本和速度、cache 信息、总线速度等硬件信息。\n\nlshw 不仅是一个可以查看硬件信息的工具，它还可以用来做一些硬件的 benchmark，用于评估计算机硬件的性能特征。lshw 工具其实就是读取 /proc 里面的一些文件来显示相关的信息，比如：\n\n```bash\n/proc/cpuinfo  # 显示CPU信息\n/proc/bus/pci  # 显示pci信息\n/proc/scsi     # 显示scsi信息\n/proc/net/dev  # 显示网络设备信息\n/proc/kcore    # 从内存映像读取相关信息\n/proc/ide      # 显示IDE设备信息\n/proc/devices\n/proc/mounts\n/proc/fstab\n```\n\n\n\nlshw 工具适用于所有 Linux 发行版，包括 Redhat、Centos、Ubuntu、Debian、Arch Linux 等。如果您的系统没有 lshw 命令，例如在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\n$ sudo apt install lshw\n```\n\n\n\n**语法**：\n\n```bash\nlshw [-format] [-options ...]\n```\n\n\n\n**格式**：\n\n- `-html` ：将硬件设备树输出为 HTML 格式\n- `-xml` ：将硬件设备树输出为 XML 格式\n- `-json` ：将硬件设备树输出为 JSON 格式\n- `-short` ：输出硬件路径\n- `-businfo` ：输出显示总线信息的设备列表，详细说明 SCSI、USB、IDE 和 PCI 地址\n\n**选项**：\n\n- `-c | -C | -class CLASS` ：仅显示给定的硬件类别信息，可以使用 `lshw -short` 或 `lshw -businfo` 找到 class。\n- `-enable TEST` ：启动一个测试（如 pci、isapnp、cpuid 等）\n- `-disable TEST` ：关闭一个测试（如 pci、isapnp、cpuid 等）\n- `-quiet` ：不显示状态\n- `-sanitize` ：清理输出（删除敏感信息，如序列号等）\n- `-numeric` ：输出数字 ID（适用于 PCI 和 USB 等）\n- `-notime` ：从输出中排除经常改变的属性（如时间戳）\n\n## 示例\n\n显示硬件设备列表，输出包括设备路径（path）、类别（class）以及简单描述：\n\n```bash\ndebian@npi:~$ sudo lshw -short\nH/W path  Device  Class      Description\n========================================\n                  system     Seeed NPi STM32MP157C Board\n/0                bus        Motherboard\n/0/0              processor  cpu\n/0/1              processor  cpu\n/0/2              memory     429MiB System memory\n/1        usb1    bus        EHCI Host Controller\n/2        usb2    bus        Generic Platform OHCI controller\n/3        usb0    network    Ethernet interface\n/4        eth0    network    Ethernet interface\n/5        wlan0   network    Ethernet interface\n```\n\n\n\n显示硬件设备列表，输出包括总线信息、SCSI、USB、IDE、PCI 地址以及简单描述：\n\n```bash\ndebian@npi:~$ sudo lshw -businfo\nBus info  Device  Class      Description\n========================================\n                  system     Seeed NPi STM32MP157C Board\n                  bus        Motherboard\ncpu@0             processor  cpu\ncpu@1             processor  cpu\n                  memory     429MiB System memory\nusb@1     usb1    bus        EHCI Host Controller\nusb@2     usb2    bus        Generic Platform OHCI controller\n          usb0    network    Ethernet interface\n          eth0    network    Ethernet interface\n          wlan0   network    Ethernet interface\n```\n\n\n\n显示内存相关硬件信息：\n\n```bash\ndebian@npi:~$ sudo lshw -C memory\n[10404.990958] [dhd-wlan0] wl_run_escan : LEGACY_SCAN sync ID: 51, bssidx: 0\n  *-memory\n       description: System memory\n       physical id: 2\n       size: 429MiB\n```\n\n\n\n显示网卡相关硬件信息，并删除敏感信息：\n\n```bash\ndebian@npi:~$ sudo lshw -c network -sanitize\n  *-network:0\n       description: Ethernet interface\n       physical id: 3\n       logical name: usb0\n       serial: [REMOVED]\n       capabilities: ethernet physical\n       configuration: broadcast=yes driver=g_ether driverversion=29-May-2008 firmware=49000000.usb-otg ip=[REMOVED] link=no multicast=yes\n  *-network:1\n       description: Ethernet interface\n       physical id: 4\n       logical name: eth0\n       serial: [REMOVED]\n       size: 10Mbit/s\n       capacity: 1Gbit/s\n       capabilities: ethernet physical tp mii 10bt 10bt-fd 100bt 100bt-fd 1000bt 1000bt-fd autonegotiation\n       configuration: autonegotiation=on broadcast=yes driver=st_gmac driverversion=Jan_2016 duplex=half link=no multicast=yes port=MII speed=10Mbit/s\n  *-network:2\n       description: Ethernet interface\n       physical id: 5\n       logical name: wlan0\n       serial: [REMOVED]\n       capabilities: ethernet physical\n       configuration: broadcast=yes driver=wl driverversion=0 ip=[REMOVED] multicast=yes\n```\n\n\n\n\n\n# Linux spi-config 命令 - 配置 SPI 接口\n\n## 介绍\n\n**spi-config** 命令用于在用户空间查询或设置 SPI 总线配置。\n\nspi-config 命令由 spi-tools 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install spi-tools\n```\n\n\n\n**语法**：\n\n```bash\nspi-config [options...]\n```\n\n\n\n**选项**：\n\n- `-d`, `--device=DEVICE` ：使用指定的 spidev 字符设备\n- `-q`, `--query` ：打印当前的配置\n- `-m`, `--mode=[0-3]` ：设置 SPI 模式\n- `-l`, `--lsb={0,1}` ：设置数据传输方式为 LSB first (1) 或者 MSB first (0)\n- `-b`, `--bits=[7...]` ：设置每个字（word）的位数\n- `-s`, `--speed=FREQUENCY` ：设置时钟频率（单位 Hz）\n- `-r`, `--spirdy={0,1}` ：设置 SPI READY 模式标志\n- `-s`, `--wait` ：阻塞，保持文件描述符打开\n- `-h`, `--help` ：查看帮助并退出\n- `-v`, `--version` ：查看版本信息并退出\n\n**SPI 模式**：\n\n| 模式   | 描述                                       |\n| ------ | ------------------------------------------ |\n| mode 0 | low iddle level, sample on leading edge.   |\n| mode 1 | low iddle level, sample on trailing edge.  |\n| mode 2 | high iddle level, sample on leading edge.  |\n| mode 3 | high iddle level, sample on trailing edge. |\n\n相关命令：[spi-pipe](https://getiot.tech/linux-command/spi-pipe/)\n\n## 示例\n\n查询 /dev/spidev0.0 设备当前配置\n\n```bash\nspi-config --device=/dev/spidev0.0 -q\n```\n\n\n\n修改时钟频率为1MHz\n\n```bash\nspi-config --device=/dev/spidev0.0 --speed=1000000\n```\n\n\n\n设置配置并保持设备开启\n\n```bash\nspi-config --wait -d /dev/spidev0.0 -s 1000000 & PID=$!\n```\n\n\n\n注：`$!` 是 Shell 最后运行的后台进程的 PID\n\n关闭之前打开的设备\n\n```bash\nkill $PID\n```\n\n\n\n\n\n# Linux spi-pipe 命令 - SPI 数据传输工具\n\n## 介绍\n\n**spi-pipe** 命令用于在用户空间进行全双工 SPI 通讯测试。\n\nspi-pipe 命令由 spi-tools 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install spi-tools\n```\n\n\n\n**语法**：\n\n```bash\nspi-pipe [options...]\n```\n\n\n\n**选项**：\n\n- `-d`, `--device=DEVICE` ：使用指定的 spidev 字符设备\n- `-s`, `--speed=<int>` ：设置目标 SPI 传输速度\n- `-b`, `--blocksize=<int>` ：设置要传输的块大小（单位字节）\n- `-n`, `--number=<int>` ：设置要传输的块数（-1表示连续传输）\n- `-h`, `--help` ：查看帮助并退出\n- `-v`, `--version` ：查看版本信息并退出\n\n相关命令：[spi-config](https://getiot.tech/linux-command/spi-config/)\n\n## 示例\n\n同时发送和接收\n\n```bash\ncommand-1 | spi-pipe --device=/dev/spidev0.0 | command-2\n```\n\n\n\n注意：*command-1*, *command-2* 和 **spi-pipe** 需要在三个不同的进程中同时运行。\n\n将数据发送到 SPI 连接\n\n```bash\ncommand-1 | spi-pipe --device=/dev/spidev0.0\n```\n\n\n\n从 SPI 连接中接收数据\n\n```bash\nspi-pipe --device=/dev/spidev0.0 < /dev/zero | command-2\n```\n\n\n\n提示：使用 `command-2 < /dev/spidev0.0` 命令也可以接收数据（数据始终为 0），但是使用 **spi-pipe** 可以控制发送到设备的内容。\n\n从 SPI 连接读取 40 个 4 字节的块\n\n```bash\nspi-pipe --device=/dev/spidev0.0 -b 4 -n 40 < /dev/zero | command-2\n```\n\n\n\n\n\n# Linux i2cdetect 命令 - 扫描 I2C 设备地址\n\n## 介绍\n\n**i2cdetect** 命令用于在 Linux 系统用户空间扫描 I2C 总线上的设备。\n\ni2cdetect 命令由 i2c-tools 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\n$ sudo apt install i2c-tools\n```\n\n\n\n**语法**：\n\n```bash\ni2cdetect [-y] [-a] [-q|-r] I2CBUS [first last]\ni2cdetect -F I2CBUS\ni2cdetect -V\ni2cdetect -l\n```\n\n\n\n**选项**：\n\n- `-y`：关闭交互模式\n- `-a`：强制扫描非常规地址（不推荐）\n- `-q`：使用 SMBus 的 \"quick write\" 命令进行探测（不推荐）\n- `-r`：使用 SMBus 的 \"receive byte\" 命令进行探测（不推荐）\n- `-F`：显示适配器实现的功能列表并退出\n- `-V`：显示版本信息并退出\n- `-l`：输出已安装 I2C 总线的列表\n\n**参数**：\n\n- `I2CBUS`：I2C 总线数字序号，对应于 `i2cdetect -l` 扫描的序号。\n\n相关命令：[i2cdump](https://getiot.tech/linux-command/i2cdump/)、[i2cget](https://getiot.tech/linux-command/i2cget/)、[i2cset](https://getiot.tech/linux-command/i2cset/)、[i2ctransfer](https://getiot.tech/linux-command/i2ctransfer/)、sensors-detect、i2c-stub-from-dump\n\n## 示例\n\n查看系统已安装的 I2C 总线列表：\n\n```bash\nroot@npi:~# i2cdetect -l\ni2c-1   i2c         STM32F7 I2C(0x5c002000)         I2C adapter\ni2c-2   i2c         STM32F7 I2C(0x40012000)         I2C adapter\ni2c-0   i2c         STM32F7 I2C(0x40013000)         I2C adapter\n```\n\n\n\n查看 i2c-0 实现的功能列表：\n\n```bash\nroot@npi:~# i2cdetect -F 0\nFunctionalities implemented by /dev/i2c-0:\nI2C                              yes\nSMBus Quick Command              yes\nSMBus Send Byte                  yes\nSMBus Receive Byte               yes\nSMBus Write Byte                 yes\nSMBus Read Byte                  yes\nSMBus Write Word                 yes\nSMBus Read Word                  yes\nSMBus Process Call               yes\nSMBus Block Write                yes\nSMBus Block Read                 yes\nSMBus Block Process Call         yes\nSMBus PEC                        yes\nI2C Block Write                  yes\nI2C Block Read                   yes\n```\n\n\n\n\n\n# Linux i2cdump 命令 - 显示 I2C 设备的寄存器内容\n\n## 介绍\n\n**i2cdump** 命令用于在 Linux 系统用户空间读取连接到系统的 I2C 设备的数据，并以可读的格式显示 I2C 设备的寄存器内容。I2C（Inter-Integrated Circuit）是一种串行通信协议，常用于连接各种外设和传感器。`i2cdump` 命令支持对不同类型的 I2C 设备进行读取。\n\ni2cdump 命令由 i2c-tools 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\n$ sudo apt install i2c-tools\n```\n\n\n\n**语法**：\n\n```bash\ni2cdump [-f] [-r first-last] [-y] [-a] I2CBUS ADDRESS [MODE [BANK [BANKREG]]]\ni2cdump -V\n```\n\n\n\n**选项**：\n\n- `-f`：即使设备繁忙，也强制访问该设备。默认情况下，i2cdump 将拒绝访问已在内核驱动程序控制下的设备。注意，使用此标志是危险的，因为它可能会严重混淆相关的内核驱动程序，还可能导致 i2cdump 返回无效结果。因此，只有在你知道自己在做什么的情况下才可以使用，风险自负。\n- `-r first-last`：限制正在访问的寄存器的范围。此选项仅适用于模式 b、w、c 和 W。对于模式 W，第一个必须是偶数，最后一个必须是奇数。\n- `-y`：禁用交互模式。默认情况下，i2cdump 将等待用户的确认，然后再访问 I2C 总线。当使用该标志时，将直接执行操作，这主要是为了在脚本中使用。\n- `-a`：允许使用 0x00 - 0x02 和 0x78 - 0x7f 之间的地址。一般不建议使用。\n- `-V`：显示版本信息并退出。\n\n**参数**：\n\n- `I2CBUS`：I2C 总线数字序号，对应于 `i2cdetect -l` 扫描的序号。\n\n- `ADDRESS`：是一个整数，范围 0x03 - 0x77，或 0x00 - 0x7f（如果使用 `-a` 选项）。\n\n- ```\n  MODE\n  ```\n\n  ：模式支持以下任意一种：\n\n  - `b`（byte，默认）\n  - `w`（word）\n  - `W`（word on even register addresses）\n  - `s`（SMBus block）\n  - `i`（I2C block）\n  - `c`（consecutive byte）\n\n另外，还可以将 `p` 附加到模式参数（`i` 和 `W` 除外）以启用 PEC。如果省略 `MODE` 参数，i2cdump 默认使用不带 PEC 的字节访问。\n\n相关命令：[i2cdetect](https://getiot.tech/linux-command/i2cdetect/)、[i2cget](https://getiot.tech/linux-command/i2cget/)、[i2cset](https://getiot.tech/linux-command/i2cset/)、[i2ctransfer](https://getiot.tech/linux-command/i2ctransfer/)、sensors-detect、i2c-stub-from-dump\n\n## 示例\n\n1、使用默认读取方法（字节模式），将 I2C 总线 9（i2c-9）上地址 0x50 设备的全部内容倾倒出来（需要用户确认）：\n\n```bash\ni2cdump 9 0x50\n```\n\n\n\n2、使用 I2C 块读取模式，将 I2C 总线 9（i2c-9）上地址 0x50 设备的全部内容倾倒出来（无需用户确认）：\n\n```bash\ni2cdump -y 9 0x50 i\n```\n\n\n\n如果设备是 EEPROM，那么输出通常与前面示例的输出相同。\n\n3、使用默认读取方法（字节模式），将 I2C 总线 1（i2c-1）上地址 0x2d 设备的寄存器 0x00 至 0x3f 的内容倾倒出来（需要用户确认）：\n\n```bash\ni2cdump -r 0x00-0x3f 1 0x2d\n```\n\n\n\n4、使用启用了错误检查的 SMBus 块读取模式，将 I2C 总线 0（i2c-0）上地址 0x69 的 SMBus 设备的寄存器的内容倾倒出来（需要用户确认）：\n\n```bash\ni2cdump 0 0x69 sp\n```\n\n\n\n\n\n# Linux i2cget 命令 - 从 I2C 设备读取数据\n\n## 介绍\n\n**i2cget** 是 Linux 系统中的一个命令行工具，用于从 I2C 设备中读取数据。\n\nI2C（Inter-Integrated Circuit）是一种串行通信协议，常用于连接各种外设和传感器。`i2cget` 允许用户以不同的格式从指定的 I2C 设备和寄存器地址中读取数据，支持读取不同类型的数据，如字节、字、块等；并提供不同的输出格式，包括字节、字和其他格式。\n\ni2cget 命令由 i2c-tools 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\n$ sudo apt install i2c-tools\n```\n\n\n\n**语法**：\n\n```bash\ni2cget [-f] [-y] [-a] i2cbus chip-address [data-address [mode]]\ni2cget -V\n```\n\n\n\n**选项**：\n\n- `-f`：即使设备繁忙，也强制访问该设备。注意这是危险操作，只有在你知道自己在做什么的情况下才可以使用，风险自负。\n- `-y`：关闭交互模式。\n- `-a`：允许使用非常规地址（0x00 - 0x02 和 0x78 - 0x7f 之间的地址），一般不建议使用。\n- `-V`：显示版本信息并退出。\n\n**参数**：\n\n- `i2cbus`：I2C 总线数字序号，对应于 `i2cdetect -l` 扫描的序号。\n\n- `chip-address`：指定 I2C 设备的地址，默认是 0x08 到 0x77 之间的整数。\n\n- `data-address`：指定要读取的设备上的寄存器地址，是 0x00 到 0xFF 之间的整数。如果省略，则将读取当前活动的寄存器（如果所用芯片支持）。\n\n- ```\n  mode\n  ```\n\n  ：模式支持以下任意一种：\n\n  - `b`（byte，默认）\n  - `w`（word）\n  - `c`（consecutive byte）\n\n相关命令：[i2cdetect](https://getiot.tech/linux-command/i2cdetect/)、[i2cdump](https://getiot.tech/linux-command/i2cdump/)、[i2cset](https://getiot.tech/linux-command/i2cset/)、[i2ctransfer](https://getiot.tech/linux-command/i2ctransfer/)、sensors-detect、i2c-stub-from-dump\n\n## 示例\n\n获取 I2C 总线 1（i2c-1）上地址 0x2d 设备的寄存器 0x11 的值（需要用户确认）：\n\n```bash\ni2cget 1 0x2d 0x11\n```\n\n\n\n获取 I2C 总线 1（i2c-1）上地址 0x48 设备的 16 位寄存器 0x00 的值（需要用户确认）：\n\n```bash\ni2cget 1 0x48 0x00 w\n```\n\n\n\n\n\n# Linux i2cset 命令 - 向 I2C 设备写入数据\n\n## 介绍\n\n**i2cset** 是 Linux 系统中的一个命令行工具，用于向 I2C 设备写入数据。\n\nI2C（Inter-Integrated Circuit）是一种串行通信协议，常用于连接各种外设和传感器。`i2cset` 允许用户以不同的格式向指定的 I2C 设备和寄存器地址中写入数据，支持多种输入格式，包括字节、字和其他格式。\n\ni2cset 命令由 i2c-tools 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\n$ sudo apt install i2c-tools\n```\n\n\n\n**语法**：\n\n```bash\ni2cset [-f] [-y] [-m mask] [-r] [-a] i2cbus chip-address data-address [value] ...  [mode]\ni2cset -V\n```\n\n\n\n**选项**：\n\n- `-f`：即使设备繁忙，也强制访问该设备。注意这是危险操作，只有在你知道自己在做什么的情况下才可以使用，风险自负。\n- `-y`：关闭交互模式。\n- `-m mask`：掩码参数 mask（如果指定）描述了哪些位值将实际写入数据地址。掩码中设置为 1 的位是从值中获取的，而设置为 0 的位将从数据地址中读取，从而由操作保留。\n- `-r`：写入后立即读回，并将结果与写入的值进行比较。这曾经是默认行为。\n- `-a`：允许使用非常规地址（0x00 - 0x02 和 0x78 - 0x7f 之间的地址），一般不建议使用。\n- `-V`：显示版本信息并退出。\n\n**参数**：\n\n- `i2cbus`：I2C 总线数字序号，对应于 `i2cdetect -l` 扫描的序号。\n\n- `chip-address`：指定 I2C 设备的地址，默认是 0x08 到 0x77 之间的整数。\n\n- `data-address`：指定要读取的设备上的寄存器地址，是 0x00 到 0xFF 之间的整数。如果省略，则将读取当前活动的寄存器（如果所用芯片支持）。\n\n- `value`： 要写入芯片上该位置的值。如果省略此参数，则发出短写入（short write）。\n\n- ```\n  mode\n  ```\n\n  ：模式支持以下任意一种：\n\n  - `b`（byte，默认）\n  - `w`（word）\n  - `c`（consecutive byte）\n\n相关命令：[i2cdetect](https://getiot.tech/linux-command/i2cdetect/)、[i2cdump](https://getiot.tech/linux-command/i2cdump/)、[i2cget](https://getiot.tech/linux-command/i2cget/)、[i2ctransfer](https://getiot.tech/linux-command/i2ctransfer/)、sensors-detect、i2c-stub-from-dump\n\n## 示例\n\n将值 0x42 写入总线 1（i2c-1）上地址为 0x2d 的 I2C 设备的 8 位寄存器 0x11 中（需要用户确认）：\n\n```bash\ni2cset 1 0x2d 0x11 0x42\n```\n\n\n\n立即清除总线 1（i2c-1）上地址为 0x2d 的 I2C 设备的 8 位寄存器 0x11 的 3 个最低有效位（无需用户确认）：\n\n```bash\ni2cset -y -m 0x07 1 0x2d 0x11 0x00\n```\n\n\n\n将值 0x5000 写入总线 1（i2c-1）上地址为 0x48 的 I2C 设备的 16 位寄存器 0x02 中（需要用户确认）：\n\n```bash\ni2cset 1 0x48 0x02 0x5000 w\n```\n\n\n\n\n\n# Linux i2ctransfer 命令 - 执行 I2C 数据传输操作\n\n## 介绍\n\n**i2ctransfer** 是 Linux 系统中的一个命令行工具，用于创建 I2C 消息并将它们作为一次传输合并发送到 I2C 总线。同时，`i2ctransfer` 也可以用于读取消息，将接收到的缓冲区的内容将打印到标准输出，每条读取消息打印一行。\n\ni2ctransfer 命令由 i2c-tools 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\n$ sudo apt install i2c-tools\n```\n\n\n\n**语法**：\n\n```bash\ni2ctransfer [-f] [-y] [-v] [-a] i2cbus desc [data] [desc [data]] ...\ni2ctransfer -V\n```\n\n\n\n**选项**：\n\n- `-f`：即使设备繁忙，也强制访问该设备。注意这是危险操作，只有在你知道自己在做什么的情况下才可以使用，风险自负。\n- `-y`：关闭交互模式。\n- `-v`：开启详细输出模式。\n- `-a`：允许使用非常规地址（0x00 - 0x02 和 0x78 - 0x7f 之间的地址），一般不建议使用。\n- `-V`：显示版本信息并退出。\n\n**参数**：\n\n- `i2cbus`：I2C 总线数字序号，对应于 `i2cdetect -l` 扫描的序号。\n\n- `desc`：一个或多个 desc 块，用于描述读写属性、消息大小以及设备地址等信息。块的数量受到 Linux 内核的限制，并由 `I2C_RDWR_IOCTL_MAX_MSGS` 定义（从内核 v4.10 开始为 42）。\n\n  desc 块的组成如下：\n\n  ```bash\n  {r|w}<length_of_message>[@address]\n  ```\n\n  \n\n- `data`：要传输的数据。\n\n相关命令：[i2cdetect](https://getiot.tech/linux-command/i2cdetect/)、[i2cdump](https://getiot.tech/linux-command/i2cdump/)、[i2cget](https://getiot.tech/linux-command/i2cget/)、[i2cset](https://getiot.tech/linux-command/i2cset/)、sensors-detect、i2c-stub-from-dump\n\n## 示例\n\n在总线 0 上，访问地址 0x50 的 EEPROM 设备，从偏移量 0x64 读取 8 个字节（第一个消息写入一个字节以将内存指针设置为 0x64，第二个消息从同一芯片读取数据）：\n\n```bash\ni2ctransfer 0 w1@0x50 0x64 r8\n```\n\n\n\n对于同一个 EEPROM，在偏移量 0x42 处写入 0xff 0xfe ... 0xf0（一条写入消息；第一个字节将内存指针设置为 0x42，0xff 是第一个数据字节，所有后续数据字节减一）：\n\n```bash\ni2ctransfer 0 w17@0x50 0x42 0xff-\n```\n\n\n\n\n\n# Linux stty 命令 - 配置终端行属性\n\n## 介绍\n\n**stty**（英文全拼：set tty）命令用于显示和修改终端命令行（terminal line）的相关设置。\n\n**语法**：\n\n```bash\nstty [选项] [参数]\n```\n\n\n\n**选项**：\n\n- `-a` ：以容易阅读的方式打印当前的所有配置。\n- `-g` ：以 stty 可读方式打印当前的所有配置。\n- `-F`, `--file=<DEVICE>` ：打开并使用指定的文件，而不是使用标准输入。\n- `--help` ：显示帮助信息并退出。\n- `--version` ：输出版本信息并退出。\n\n## 示例\n\n查看当前注册终端的设置情况\n\n```bash\nstty -a\n```\n\n\n\n在命令行下禁止输出大写\n\n```bash\nstty iuclc     # 开启\nstty -iuclc    # 恢复\n```\n\n\n\n在命令行下禁止输出小写\n\n```bash\nstty olcuc     # 开启\nstty -olcuc    # 恢复\n```\n\n\n\n屏蔽显示\n\n```bash\nstty -echo   # 禁止回显\nstty echo    # 打开回显\n```\n\n\n\n忽略回车符\n\n```bash\nstty igncr     # 开启\nstty -igncr    # 恢复\n```\n\n\n\n打印出终端的行数和列数\n\n```bash\nstty size\n```\n\n\n\n修改文件结束符\n\n```bash\nstty eof 'c'\n```\n\n\n\n系统默认是 Ctrl+D 来表示文件的结束，通过上述命令，将改变为使用字符 c\n\n另外，stty 命令也常用于串口调试，比如查看串口设备参数\n\n```bash\nstty -F \"/dev/ttymxc1\" -a\n```\n\n\n\n设置串口设备波特率为 115200\n\n```bash\nstty -F \"/dev/ttymxc1\" 115200\n```\n\n\n\n在使用串口时，我们通常会关心如下一些参数：\n\n- speed：波特率\n- cs8：8位数据位\n- parenb：偶校验\n- parodd：奇校验\n- cstopb：2位停止位\n- crtscts：硬件流控\n\n如果上述参数前面有 `-` 号，则表示未设置状态，比如设置硬件流控\n\n```bash\nstty -F \"/dev/ttymxc1\" -crtscts  # 去掉流控\nstty -F \"/dev/ttymxc1\" crtscts   # 增加流控\n```\n\n\n\n禁止 XOFF 信号（相当于 Ctrl + S，对应 ASCII 码 0x13）\n\n```bash\nstty -ixon\n```\n\n\n\n\n\n# Linux minicom 命令 - 串口调试工具\n\n## 介绍\n\n**Minicom** 是 Linux 下一款常用的命令行串口调试工具。其功能与 Windows 下的超级终端相似，可以通过串口控制外部的硬件设备，通常用于对嵌入式设备进行管理。\n\nLinux 发行版通常不预装 minicom 工具，用户可自行安装，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\n$ sudo apt install minicom\n```\n\n\n\n**语法**：\n\n```bash\nminicom [options] [configuration]\n```\n\n\n\n**选项**：\n\n- `-b`, `--baudrate` ：设置波特率（忽略 config 中的值）\n- `-D`, `--device` ：指定串口设备（忽略 config 中的值）\n- `-s`, `--setup` ：进入设置模式\n- `-o`, `--noinit` ：启动时不要初始化 modem 和 lockfiles\n- `-w`, `--wrap` ：打开换行显示\n- `-H`, `--displayhex` ：以十六进制显示输出\n- `-z`, `--statline` ：尝试使用终端的状态栏\n- `-7`, `--7bit` ：强制使用7位模式\n- `-8`, `--8bit` ：强制使用8位模式\n- `-c`, `--color=on/off` ：开启或关闭 ANSI 风格颜色用法\n- `-a`, `--attrib=on/off` ：开启或关闭高亮属性\n- `-t`, `--term=TERM` ：覆盖 TERM 环境变量\n- `-S`, `--script=SCRIPT` ：启动时运行脚本\n- `-p`, `--ptty=TTYP` ：连接到伪终端（pseudo terminal）\n- `-C`, `--capturefile=FILE` ：捕获终端并保存到文件\n- configuration ：指定 minicom 配置文件启动\n\n## 示例\n\n打开指定的串口终端\n\n```bash\n$ sudo minicom -D /dev/ttyUSB0\n```\n\n\n\n打开指定的串口终端，并以 ANSI 颜色风格显示\n\n```bash\n$ sudo minicom -D /dev/ttyUSB0 -c on\n```\n\n\n\n打开指定的串口终端，并将内容保存到文件\n\n```bash\n$ sudo minicom -D /dev/ttyUSB0 -C output.txt\n```\n\n\n\n设置串口终端参数\n\n```bash\n$ sudo minicom -s\n```\n\n\n\n配置完成后，选“Save setup as..”将该配置保存为指定名称，例如“stm32”\n\n![img](./Image/Linux命令大全.assets/minicom_configuration.png)\n\n保存，在 /etc/minicom 目录下将会生成 minirc.stm32 文件。\n\n之后我们就可以通过配置文件启动串口终端了\n\n```bash\n$ sudo minicom stm32\n```\n\n\n\n在 minicom 终端中，按 CTRL+A，再按 Z 将会打开配置窗口，按 X 可退出该串口终端。\n\n![img](./Image/Linux命令大全.assets/minicom_command_summary.png)\n\n提示：minicom 使用前缀按键 Ctrl-A，即执行特殊操作时，都需要先按 Ctrl+A，再按某个按键使用对应的功能。比如：\n\n- 按 Z 键查看帮助；\n- 按 X 或 Q 键退出窗口；\n- 按 W 键打开或关闭换行功能；\n- 按 N 键打开或关闭时间戳显示；\n\n如果串口有输出，但无法输入，通常是由于开启了硬件流控导致的。按 CTRL-A Z 进入设置页，按 O 键选择 “cOnfigure Minicom” 项，再选择 “Serial port setup” 项，按 F 键关闭 Hardware Flow Control。\n\n有时候窗口打印数据较多，我们需要暂停输出，以便于查看。按 Ctrl+A 即可暂停输出。Ctrl+A 是 mimicom 的特殊功能前缀按键，但还有另一个很实用的作用，就是暂停屏幕输出。\n\n如果设备端支持的话，按下 Ctrl+A，再按 S，即可向设备端发送文件；按 Ctrl+A，再按 R，可接收文件。\n\n\n\n# Linux microcom 命令 - 串口通信工具\n\n## 介绍\n\n**microcom** 是一个用于与串行调制解调器通信的命令。\n\n我们可以把 microcom 理解为是一个在终端命令行运行的串口调试助手，在调试串口时非常有用，例如调试 AT 指令。\n\n如果您的设备使用 Busybox，可以在 busybox/miscutils/microcom.c 中找到源代码，编译添加到文件系统中，就可以使用 microcom 命令了。如果您使用 Linux 发行版，比如 Debian/Ubuntu 可以使用如下命令进行安装：\n\n```bash\nsudo apt install microcom\n```\n\n\n\n**语法**：\n\n```bash\nmicrocom [-d DELAY] [-t TIMEOUT] [-s SPEED] [-X] TTY\n```\n\n\n\n**选项**：\n\n- `-d <DELAY>` ：表示延时时间。\n- `-t <TIMEOUT>` ：表示超时时间，超多少时间就自动退出（单位为 ms）。\n- `-s <SPEED>` ：表示传输速度，波特率的意思，这个根据自己的情况而定。\n- `-X` ：从 stdin 禁用 `NUL` 和 `Ctrl-X` 的特殊含义。\n\n**参数**：指定串口设备 TTY（如 /dev/ttyS0）。\n\n## 示例\n\n将要测试串口与 PC 端连接，在 PC 端开启串口调试工具，波特率设置为 115200。\n\n接着在设备端运行如下命令，打开 /dev/ttymxc1 串口设备：\n\n```bash\nmicrocom -s 115200 /dev/ttymxc1\n```\n\n\n\n此时，在设备终端中输入的字符，将在 PC 端的窗口中显示；反过来，在 PC 端输入的字符，也会在设备端的 microcom 中显示。通过该方法，可以验证串口设备是否正常工作。\n\n如果您通过串口连接了支持 AT 指令的模块，就可以用 microcom 工具向模块发送 AT 指令。不过，直接在键盘输入 AT 指令有些麻烦，我们可以将 AT 指令写在文件中，再重定向到 microcom，比如：\n\n```bash\nmicrocom -s 115200 /dev/ttymxc1 < at.txt\n```\n\n\n\n```bash\ncat at.txt | microcom -s 115200 /dev/ttymxc1\n```\n\n\n\n```bash\ntail -f at.txt | microcom -s 115200 /dev/ttymxc1\n```\n\n\n\n按 Ctrl + X 退出。\n\n\n\n# Linux xrandr 命令 - 管理显示输出设置\n\n## 介绍\n\n**xrandr** 是用于与 X RandR 扩展进行交互的命令行工具。它允许对 X server 进行实时配置（即无需重新启动即可使配置生效），xrandr 提供了显示模式（如分辨率、刷新率等）的自动检测，以及动态配置输出（如调整大小、旋转、移动屏幕等）的功能。\n\n**语法**：\n\n```bash\nxrandr [options]\n```\n\n\n\n**选项**：\n\n- `-q`, `--query` ：查询\n- `-s <size>/<width>x<height>` ：设置分辨率\n- `-r <rate>` ：设置刷新率\n- `-o`, `--output <output>` ：指定输出模式\n\n## 示例\n\n显示系统支持的所有分辨率\n\n```bash\n$ xrandr\nScreen 0: minimum 0 x 0, current 1920 x 1080, maximum 32768 x 32768\ndefault connected primary 1920x1080+0+0 507mm x 285mm\n   1920x1080      0.00*\n```\n\n\n\n将屏幕恢复到原来的分辨率\n\n```bash\nxrandr -s 0\n```\n\n\n\n设置具体分辨率\n\n```bash\nxrandr -s 1024x768\n```\n\n\n\n旋转屏幕\n\n```bash\nxrandr -o left     # 向左旋转90度\nxrandr -o right    # 向右旋转90度\nxrandr -o inverted # 上下翻转\nxrandr -o normal   # 回到正常角度\n```\n\n\n\n由于出错的硬件或驱动，xrandr 可能未能检测出显示器所有有效的分辨率。那么我们可以在 xrandr 里为显示器添加所需的分辨率。\n\n首先，新建一种 xrandr 模式\n\n```bash\nxrandr --newmode '1024x768_60' 65.00 1024 1048 1184 1344 768 771 777 806 -hsync -vsync\n```\n\n\n\n然后，把这个模式添加到当前的输出设备（假设为 DisplayPort-1）\n\n```bash\nxrandr --addmode DisplayPort-1 1024x768_60\n```\n\n\n\n最后，把 DisplayPort-1 的分辨率指定为刚刚添加的新模式\n\n```bash\nxrandr --output  DisplayPort-1 --mode 1024x768_60\n```\n\n\n\n删除 xrandr 模式\n\n```bash\nxrandr --rmmode 1024x768_60\n```\n\n\n\n\n\n# Linux mmc 命令 - 管理 MMC/SD 卡\n\n## 介绍\n\n在 Linux 系统中，**`mmc`** 命令通常用于处理嵌入式系统中的存储设备，如 SD 卡或 eMMC（嵌入式多媒体卡）。通常用于与嵌入式存储设备进行交互，进行初始化、分区、读写操作等。\n\nmmc 命令由 mmc-utils 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```shell\n$ sudo apt install mmc-utils\n```\n\n\n\n信息\n\nmmc-utils 是一个用于管理 MMC（MultiMediaCard）和 eMMC（embedded MultiMediaCard）设备的工具包。其中，mmc 命令是 mmc-utils 工具包中的一部分，用于执行与 MMC 设备相关的操作。\n\n**语法**：\n\n```bash\nmmc [<command> [<args>]] [--help]\nmmc [<command>] --help\n```\n\n\n\n## 示例\n\n显示 `/dev/mmcblk0` 存储设备的 Extended CSD 寄存器信息：\n\n```bash\nmmc extcsd read /dev/mmcblk0\n```\n\n\n\n擦除整个 `/dev/mmcblk0` 存储设备的数据块：\n\n```bash\nmmc erase /dev/mmcblk0\n```\n\n\n\n启用 `/dev/mmcblk0` 存储设备的引导分区：\n\n```bash\nmmc bootpart enable 1 /dev/mmcblk0\n```\n\n\n\n从 `/dev/mmcblk0` 存储设备的地址 `0x1000` 处读取 `0x800` 字节的数据：\n\n```bash\nmmc read /dev/mmcblk0 0x1000 0x800\n```\n\n\n\n从 rpmb 设备读取 2 个 256 字节的块到 `/tmp/block` 文件：\n\n```bash\nmmc rpmb read-block /dev/mmcblk0rpmb 0x02 2 /tmp/block\n```\n\n\n\n\n\n# Linux gpiodetect 命令 - 检测 GPIO 控制器\n\n## 介绍\n\n**gpiodetect** 命令用于列出系统上存在的所有 gpiochip，以及它们的名称、标签和 GPIO lines。\n\ngpiodetect 命令由 [libgpiod](https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/) 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install gpiod\n```\n\n\n\n实际上，从 Linux 4.8 开始，不再推荐使用 sysfs 接口（/sys/class/gpio）操作 GPIO，而是建议在用户空间使用字符设备进行操作，libgpiod 就是一个用于操作 GPIO 字符设备的库，同时提供了一些工具，方便开发者进行调试。\n\nlibgpiod 包含一系列命令，除了 gpiodetect，还有 [gpioinfo](https://getiot.tech/linux-command/gpioinfo/)、[gpioget](https://getiot.tech/linux-command/gpioget/)、[gpioset](https://getiot.tech/linux-command/gpioset/)、[gpiofind](https://getiot.tech/linux-command/gpiofind/) 和 [gpiomon](https://getiot.tech/linux-command/gpiomon/) 命令。\n\n**语法**：\n\n```bash\ngpiodetect [OPTIONS]\n```\n\n\n\n**选项**：\n\n- `-h`, `--help` ：查看帮助并退出\n- `-v`, `--version` ：查看版本信息并退出\n\n## 示例\n\n查看树莓派 4B 系统上的 gpiochip 信息（非 root 用户需添加 sudo）\n\n```bash\npi@raspberry:~$ sudo gpiodetect\ngpiochip0 [pinctrl-bcm2711] (58 lines)\ngpiochip1 [raspberrypi-exp-gpio] (8 lines)\n```\n\n\n\n三列数据分别是 gpiochip 的名称（name）、标签（label）和行数（lines）。\n\n\n\n# Linux gpiofind 命令 - 查找指定名称的 GPIO 引脚\n\n## 介绍\n\n**gpiofind** 命令用于通过名称找到对应的 gpiochip 及行内偏移量。\n\ngpiofind 命令由 [libgpiod](https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/) 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install gpiod\n```\n\n\n\n实际上，从 Linux 4.8 开始，不再推荐使用 sysfs 接口（/sys/class/gpio）操作 GPIO，而是建议在用户空间使用字符设备进行操作，libgpiod 就是一个用于操作 GPIO 字符设备的库，同时提供了一些工具，方便开发者进行调试。\n\nlibgpiod 包含一系列命令，除了 gpiofind，还有 [gpiodetect](https://getiot.tech/linux-command/gpiodetect/)、[gpioinfo](https://getiot.tech/linux-command/gpioinfo/)、[gpioget](https://getiot.tech/linux-command/gpioget/)、[gpioset](https://getiot.tech/linux-command/gpioset/) 和 [gpiomon](https://getiot.tech/linux-command/gpiomon/) 命令。\n\n**语法**：\n\n```bash\ngpiofind [OPTIONS] <name>\n```\n\n\n\n**选项**：\n\n- `-h`, `--help` ：查看帮助并退出\n- `-v`, `--version` ：查看版本信息并退出\n\n**参数**：GPIO line 的名称 name\n\n## 示例\n\n查找树莓派 4B 系统上名为 \"BT_ON\" 的 GPIO line（非 root 用户需添加 sudo）\n\n```bash\npi@raspberry:~$ sudo gpiofind \"BT_ON\"\ngpiochip1 0\n```\n\n\n\n输出的 gpiochip 及行内偏移量可作为 gpioget 和 gpioset 的输入，例如：\n\n```bash\ngpiofind \"BT_ON\" | xargs gpioget\n```\n\n\n\n或\n\n```bash\ngpioget `gpiofind \"BT_ON\"`\n```\n\n\n\n\n\n# Linux gpioget 命令 - 获取 GPIO 引脚的当前值\n\n## 介绍\n\n**gpioget** 命令用于读取指定 GPIO line 的值。\n\ngpioget 命令由 [libgpiod](https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/) 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install gpiod\n```\n\n\n\n实际上，从 Linux 4.8 开始，不再推荐使用 sysfs 接口（/sys/class/gpio）操作 GPIO，而是建议在用户空间使用字符设备进行操作，libgpiod 就是一个用于操作 GPIO 字符设备的库，同时提供了一些工具，方便开发者进行调试。\n\nlibgpiod 包含一系列命令，除了 gpioget，还有 [gpioset](https://getiot.tech/linux-command/gpioset/)、[gpiodetect](https://getiot.tech/linux-command/gpiodetect/)、[gpioinfo](https://getiot.tech/linux-command/gpioinfo/)、[gpiofind](https://getiot.tech/linux-command/gpiofind/) 和 [gpiomon](https://getiot.tech/linux-command/gpiomon/) 命令。\n\n**语法**：\n\n```bash\ngpioget [OPTIONS] <chip name/number> <offset 1> <offset 2> ...\n```\n\n\n\n**选项**：\n\n- `-l`, `--active-low` ：设置低电平为有效电平\n- `-B`, `--bias=[as-is|disable|pull-down|pull-up]` ：设置 bias（默认使用 `as-is`）\n- `-h`, `--help` ：查看帮助并退出\n- `-v`, `--version` ：查看版本信息并退出\n\n**参数**：指定 gpiochip 和 offset（行内偏移量），可同时指定多个 line。\n\n## 示例\n\n查看树莓派 4B 系统上 gpiochip1 的 line 信息（非 root 用户需添加 sudo）\n\n```bash\npi@raspberry:~$ sudo gpioinfo gpiochip1\ngpiochip1 - 8 lines:\n        line   0:      \"BT_ON\"       unused   input  active-high\n        line   1:      \"WL_ON\"       unused   input  active-high\n        line   2: \"PWR_LED_OFF\" \"led1\" output active-low [used]\n        line   3: \"GLOBAL_RESET\" unused output active-high\n        line   4: \"VDD_SD_IO_SEL\" \"vdd-sd-io\" output active-high [used]\n        line   5:   \"CAM_GPIO\"       unused  output  active-high\n        line   6:  \"SD_PWR_ON\" \"sd_vcc_reg\"  output  active-high [used]\n        line   7:    \"SD_OC_N\"       unused   input  active-high\n```\n\n\n\n读取 gpiochip1 的 line 0（也就是 BT_ON）的值\n\n```bash\npi@raspberry:~$ sudo gpioget gpiochip1 0\n1\n```\n\n\n\n注意：只能读取 unused 状态的 line 值。\n\n\n\n# Linux gpioinfo 命令 - 显示 GPIO 控制器和引脚信息\n\n## 介绍\n\n**gpioinfo** 命令用于列出指定 gpiochip 的所有 line，以及它们的名称、使用者、方向、活动状态和其他标志。\n\ngpioinfo 命令由 [libgpiod](https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/) 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install gpiod\n```\n\n\n\n实际上，从 Linux 4.8 开始，不再推荐使用 sysfs 接口（/sys/class/gpio）操作 GPIO，而是建议在用户空间使用字符设备进行操作，libgpiod 就是一个用于操作 GPIO 字符设备的库，同时提供了一些工具，方便开发者进行调试。\n\nlibgpiod 包含一系列命令，除了 gpioinfo，还有 [gpiodetect](https://getiot.tech/linux-command/gpiodetect/)、[gpioget](https://getiot.tech/linux-command/gpioget/)、[gpioset](https://getiot.tech/linux-command/gpioset/)、[gpiofind](https://getiot.tech/linux-command/gpiofind/) 和 [gpiomon](https://getiot.tech/linux-command/gpiomon/) 命令。\n\n**语法**：\n\n```bash\ngpioinfo [OPTIONS] <gpiochip> ...\n```\n\n\n\n**选项**：\n\n- `-h`, `--help` ：查看帮助并退出\n- `-v`, `--version` ：查看版本信息并退出\n\n**参数**：指定 gpiochip，如 gpiochip0、gpiochip1，可同时输入多个参数。如果没有参数，则查询所有 gpiochip 的所有 line 的信息。\n\n## 示例\n\n查看树莓派 4B 系统上所有 gpiochip 的所有 line 的信息（非 root 用户需添加 sudo）\n\n```bash\npi@raspberry:~$ sudo gpioinfo\ngpiochip0 - 58 lines:\n        line   0:     \"ID_SDA\"       unused   input  active-high\n        line   1:     \"ID_SCL\"       unused   input  active-high\n        line   2:       \"SDA1\"       unused   input  active-high\n        line   3:       \"SCL1\"       unused   input  active-high\n        ......\ngpiochip1 - 8 lines:\n        line   0:      \"BT_ON\"       unused  output  active-high\n        line   1:      \"WL_ON\"       unused  output  active-high\n        ......\n```\n\n\n\n只查看树莓派 4B 系统上 gpiochip1 的 line 信息\n\n```bash\npi@raspberry:~$ sudo gpioinfo gpiochip1\ngpiochip1 - 8 lines:\n        line   0:      \"BT_ON\"       unused  output  active-high\n        line   1:      \"WL_ON\"       unused  output  active-high\n        line   2: \"PWR_LED_OFF\" \"led1\" output active-low [used]\n        line   3: \"GLOBAL_RESET\" unused output active-high\n        line   4: \"VDD_SD_IO_SEL\" \"vdd-sd-io\" output active-high [used]\n        line   5:   \"CAM_GPIO\"       unused  output  active-high\n        line   6:  \"SD_PWR_ON\" \"sd_vcc_reg\"  output  active-high [used]\n        line   7:    \"SD_OC_N\"       unused   input  active-high\n```\n\n\n\n每个 line 所列出的四列数据分别表示 line 的名称（如果没有设定则显示 unnamed）、使用情况（如果未被使用则显示 unused）、方向（input 或者 output）和有效电平（active-low 或者 active-high）。\n\n\n\n# Linux gpiomon 命令 - 监控 GPIO 引脚的状态变化\n\n## 介绍\n\n**gpiomon** 命令用于等待指定 GPIO line 上的事件，或指定要监视的事件。\n\ngpiomon 命令由 [libgpiod](https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/) 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install gpiod\n```\n\n\n\n实际上，从 Linux 4.8 开始，不再推荐使用 sysfs 接口（/sys/class/gpio）操作 GPIO，而是建议在用户空间使用字符设备进行操作，libgpiod 就是一个用于操作 GPIO 字符设备的库，同时提供了一些工具，方便开发者进行调试。\n\nlibgpiod 包含一系列命令，除了 gpiomon，还有 [gpiodetect](https://getiot.tech/linux-command/gpiodetect/)、[gpioinfo](https://getiot.tech/linux-command/gpioinfo/)、[gpioget](https://getiot.tech/linux-command/gpioget/)、[gpioset](https://getiot.tech/linux-command/gpioset/) 和 [gpiofind](https://getiot.tech/linux-command/gpiofind/) 命令。\n\n**语法**：\n\n```bash\ngpiomon [OPTIONS] <chip name/number> <offset 1> <offset 2> ...\n```\n\n\n\n**选项**：\n\n- `-l`, `--active-low` ：设置低电平为有效电平\n- `-B`, `--bias=[as-is|disable|pull-down|pull-up]` ：设置 bias（默认使用 `as-is`）\n- `-n`, `--num-events=NUM` ：处理完 `NUM` 个事件后退出\n- `-s`, `--silent` ：不打印事件信息\n- `-r`, `--rising-edge` ：只处理上升沿事件\n- `-f`, `--falling-edge` ：只处理下降沿事件\n- `-b`, `--line-buffered` ：将标准输出设置为行缓冲\n- `-F`, `--format=FMT` ：指定输出格式（`%o` 为 GPIO 行内偏移量，`%e` 为事件类型，`%s` 为事件时间戳秒数部分，`%n` 为事件时间戳纳秒部分）\n- `-h`, `--help` ：查看帮助并退出\n- `-v`, `--version` ：查看版本信息并退出\n\n## 示例\n\n等待三次 GPIO（gpiochip0 line1）的上升沿事件，然后退出（非 root 用户需添加 sudo）\n\n```bash\n$ sudo gpiomon --num-events=3 --rising-edge gpiochip0 1\nevent:  RISING EDGE offset: 3 timestamp: [    1151.814356387]\nevent:  RISING EDGE offset: 3 timestamp: [    1151.815449803]\nevent:  RISING EDGE offset: 3 timestamp: [    1152.091556803]\n```\n\n\n\n等待单次下降沿事件，并按指定格式输出\n\n```bash\n$ sudo gpiomon --format=\"%e %o %s %n\" --falling-edge gpiochip0 1\n0 1 1156 615459801\n```\n\n\n\n同时等待多个 line 上的事件，并在处理完第一个事件后退出\n\n```bash\n$ sudo gpiomon --silent --num-events=1 gpiochip0 2 3 5\n```\n\n\n\n\n\n# Linux gpioset 命令 - 设置 GPIO 引脚的值\n\n## 介绍\n\n**gpioset** 命令用于设置指定的 GPIO line 的值。\n\ngpioset 命令由 [libgpiod](https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/) 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```shell\nsudo apt install gpiod\n```\n\n\n\n实际上，从 Linux 4.8 开始，不再推荐使用 sysfs 接口（/sys/class/gpio）操作 GPIO，而是建议在用户空间使用字符设备进行操作，libgpiod 就是一个用于操作 GPIO 字符设备的库，同时提供了一些工具，方便开发者进行调试。\n\nlibgpiod 包含一系列命令，除了 gpioset，还有 [gpioget](https://getiot.tech/linux-command/gpioget/)、[gpiodetect](https://getiot.tech/linux-command/gpiodetect/)、[gpioinfo](https://getiot.tech/linux-command/gpioinfo/)、[gpiofind](https://getiot.tech/linux-command/gpiofind/) 和 [gpiomon](https://getiot.tech/linux-command/gpiomon/) 命令。\n\n**语法**：\n\n```shell\ngpioset [OPTIONS] <chip name/number> <offset1>=<value1> <offset2>=<value2> ...\n```\n\n\n\n**选项**：\n\n- `-l`, `--active-low` ：设置低电平为有效电平\n- `-B`, `--bias=[as-is|disable|pull-down|pull-up]` ：设置 bias（默认使用 `as-is`）\n- `-D`, `--drive=[push-pull|open-drain|open-source]` ：设置驱动模式（默认使用 `push-pull`）\n- `-m`, `--mode=[exit|wait|time|signal]` ：设置完成后的动作模式\n- `-s`, `--sec=SEC` ：当使用 `--mode=time` 选项时，指定等到的时间（单位：秒）\n- `-u`, `--usec=USEC` ：当使用 `--mode=time` 选项时，指定等到的时间（单位：微秒）\n- `-b`, `--background` ：设置完成后与控制终端分离\n- `-h`, `--help` ：查看帮助并退出\n- `-v`, `--version` ：查看版本信息并退出\n\n**参数**：指定 gpiochip 和 offset（行内偏移量），以及对应的 value，可同时指定多个 line。\n\n## 示例\n\n查看树莓派 4B 系统上 gpiochip1 的 line 信息（非 root 用户需添加 sudo）\n\n```shell\npi@raspberry:~$ sudo gpioinfo gpiochip1\ngpiochip1 - 8 lines:\n        line   0:      \"BT_ON\"       unused   input  active-high\n        line   1:      \"WL_ON\"       unused   input  active-high\n        line   2: \"PWR_LED_OFF\" \"led1\" output active-low [used]\n        line   3: \"GLOBAL_RESET\" unused output active-high\n        line   4: \"VDD_SD_IO_SEL\" \"vdd-sd-io\" output active-high [used]\n        line   5:   \"CAM_GPIO\"       unused  output  active-high\n        line   6:  \"SD_PWR_ON\" \"sd_vcc_reg\"  output  active-high [used]\n        line   7:    \"SD_OC_N\"       unused   input  active-high\n```\n\n\n\n读取 gpiochip1 的 line 0（也就是 BT_ON）的值\n\n```shell\npi@raspberry:~$ sudo gpioget gpiochip1 0\n1\n```\n\n\n\n设置 gpiochip1 的 line 0 的值为 0（低电平）\n\n```shell\npi@raspberry:~$ sudo gpioset gpiochip1 0=0\n```\n\n\n\n再次读取 gpiochip1 的 line 0 的值\n\n```shell\npi@raspberry:~$ sudo gpioget gpiochip1 0\n0\n```\n\n\n\n\n\n# Linux udevadm 命令 - 管理设备事件和属性\n\n## 介绍\n\n**udevadm**（英文全拼：udev administrator）是一个 udev 管理工具，可用于查询 udev 数据库中的设备信息，也可以从 sysfs 文件系统中查询到设备的属性以辅助创建 udev 规则。\n\nudevadm 后接一个子命令和命令指定选项，以控制 udev 运行的行为、处理内核事件、控制事件队列，并且提供简单的调试机制。\n\n**语法**：\n\n```bash\nudevadm [--debug] [--version] [--help]\nudevadm info [options] [devpath]\nudevadm trigger [options] [devpath]\nudevadm settle [options]\nudevadm control option\nudevadm monitor [options]\nudevadm test [options] devpath\nudevadm test-builtin [options] command devpath\n```\n\n\n\n**选项**：\n\n- `--debug` ：显示调试信息。\n\n- `--version` ：显示版本信息。\n\n- `--help` ：显示帮助信息。\n\n- info\n\n   \n\n  子命令 —— 查询 udev 数据库中的设备信息。\n\n  - `-q`, `--query=TYPE` ：从数据库中查询指定类型的设备，需要使用 `--path` 和 `--name` 选项指定设备。合法的 TYPE 类型包括：设备名（name），链接（symlink），路径（path），属性（property）。\n  - `-p`, `--path=DEVPATH` ：指定设备的路径。\n  - `-n`, `--name=FILE` ：指定设备节点或者链接。\n  - `-a`, `--attribute-walk` ：打印指定设备的所有 sysfs 记录的属性，以用 udev 规则来匹配特殊的设备。该选项打印链上的所有设备信息，最大可能到 sys 目录。\n  - `-d`, `--device-id-of-file=FILE` ：打印主/从设备号。\n  - `-e`, `--export-db` ：输出 udev 数据库中的内容。\n\n- trigger\n\n   \n\n  子命令 —— 接收内核发送来的设备事件，主要用于重放 coldplug 事件信息。\n\n  - `-v`, `--verbose` ：输出将要被触发的设备列表。\n  - `-n`, `--dry-run` ：不真的触发事件。\n  - `-t`, `--type=TYPE` ：触发一个特殊的设备，合法的类型有 devices 和 subsystem，默认为 devices。\n  - `-c`, `--action=ACTION` ：被触发的事件，默认是 change。\n  - `-s`, `--subsystem-match=SUBSYSTEM` ：触发匹配子系统的设备事件，这个选项可以被多次指定，并且支持 shell 模式匹配。\n  - `-a`, `--attr-match=ATTRIBUTE=VALUE` ：触发匹配 sysfs 属性的设备事件，如果属性值和属性一起指定，属性的值可以使用 shell 模式匹配；如果没有指定值，会重新确认现有属性。（这个选项可以被多次指定）\n  - `-A`, `--attr-nomatch=ATTRIBUTE=VALUE` ：不要触发匹配属性的设备事件，如果可以使用模式匹配，也可以多次指定。\n  - `-p`, `--property-match=PROPERTY=VALUE` ：匹配与属性吻合的设备，可以多次指定支持模式匹配。\n  - `-g`, `--tag-match=PROPERTY` ：匹配与标签吻合的设备，可以多次指定。\n  - `-y`, `--sysname-match=NAME` ：匹配与 sys 设备名相同的设备，可以多次指定支持模式匹配。\n\n- settle\n\n   \n\n  子命令 —— 查看 udev 事件队列，如果所有事件全部处理完就退出。\n\n  - `-t`, `--timeout=SECONDS` ：等待事件队列变空的最大等待时间，默认是120 秒，如果为 0 则立即退出。\n  - `-E`, `--exit-if-exists=FILE` ：如果文件存在就退出。\n\n- monitor\n\n   \n\n  子命令 —— 监听内核事件和 udev 发送的 events 事件，可以通过比较内核或者 udev 事件的时间戳来分析事件时序。\n\n  - `-k`, `--kernel` ：输出内核事件。\n  - `-u`, `--udev` ：输出 udev 规则执行时的 udev 事件。\n  - `-p`, `--property` ：输出事件的属性。\n  - `-s`, `--subsystem-match=string[/string]` ：通过子系统或者设备类型过滤事件，只有匹配了子系统值的 udev 设备事件通过。\n  - `-t`, `--tag-match=string` ：通过属性过滤事件，只有匹配了标签的 udev 事件通过。\n\n- **test** 子命令 —— 模拟一个 udev 事件，打印出 debug 信息。\n\n提示：内核在启动时已经检测到了系统的硬件设备，并把硬件设备信息通过 sysfs 内核虚拟文件系统导出。udev 扫描 sysfs 文件系统，根据硬件设备信息生成热插拔（hotplug）事件，udev 再读取这些事件，生成对应的硬件设备文件。由于没有实际的硬件插拔动作，所以这一过程被称为 coldplug。\n\n## 示例\n\n查询块设备 /dev/sdc1 的路径信息\n\n```bash\n$ udevadm info -q path -n /dev/sdc1\n/devices/pci0000:00/0000:00:14.0/usb2/2-1/2-1:1.0/host4/target4:0:0/4:0:0:0/block/sdc/sdc1\n```\n\n\n\n查询 RTC 设备的所有信息\n\n```bash\n$ udevadm info --query=all --name=/dev/rtc\nP: /devices/platform/i2c@4/i2c-4/4-006f/rtc/rtc0\nN: rtc0\nL: -100\nS: rtc\nE: DEVPATH=/devices/platform/i2c@4/i2c-4/4-006f/rtc/rtc0\nE: DEVNAME=/dev/rtc0\nE: MAJOR=252\nE: MINOR=0\nE: SUBSYSTEM=rtc\nE: USEC_INITIALIZED=5168933\nE: DEVLINKS=/dev/rtc\n```\n\n\n\n不重启设备直接 reload udev 规则\n\n```bash\nudevadm control --reload-rules && udevadm trigger\n```\n\n\n\n\n\n# Linux modpoll 命令 - Modbus 测试工具\n\n## 介绍\n\n**modpoll** 是一个基于 libmodbus 库的 Modbus 主站仿真工具，支持基于串行链路的 Modbus RTU、Modbus ASCII 和基于以太网的 Modbus TCP 协议。\n\n如果您的系统没有 modpoll 命令，可以通过如下命令下载获得。\n\n```bash\nwget https://www.modbusdriver.com/downloads/modpoll.tgz\n```\n\n\n\n**语法**：\n\n```bash\nmodpoll [OPTIONS] SERIALPORT|HOST [WRITEVALUES...]\n```\n\n\n\n**选项**：\n\n- `-m ascii` ：Modbus ASCII 协议。\n- `-m rtu` ：Modbus RTU 协议（如果 SERIALPORT 参数包含 / 则默认为该模式）。\n- `-m tcp` ：MODBUS TCP 协议（如果 SERIALPORT 参数不包含 / 则默认为该模式）。\n- `-m udp` ：MODBUS UDP 协议。\n- `-m enc` ：基于 TCP 的封装 Modbus RTU（Encapsulated Modbus RTU over TCP）。\n- `-a #` ：从站地址（串行链路取值范围 1-247，TCP 取值范围 0-255，默认值为 1）。\n- `-r #` ：起始地址（取值范围 1-65536，默认为 100）。\n- `-c #` ：要读取的值的数量（1-125，默认值为 1），写入可选（使用 -c 1 强制 FC5 或 FC6）。\n- `-t 0` ：离散输出（线圈）数据类型。\n- `-t 1` ：离散输入数据类型。\n- `-t 3` ：16 位输入寄存器数据类型。\n- `-t 3:hex` ：16 位输入寄存器数据类型（以十六进制显示）。\n- `-t 3:int` ：输入寄存器表中的 32 位整数数据类型。\n- `-t 3:mod` ：输入寄存器表中的 32 位模块 10000 数据类型。\n- `-t 3:float` ：输入寄存器表中的 32 位浮点数据类型。\n- `-t 4` ：16 位输出（保持）寄存器数据类型（默认）。\n- `-t 4:hex` ：16 位输出（保持）寄存器数据类型（以十六进制显示）。\n- `-t 4:int` ：输出（保持）寄存器表中的 32 位整数数据类型。\n- `-t 4:mod` ：输出（保持）寄存器表中的 32 位模块 10000 类型。\n- `-t 4:float` ：输出（保持）寄存器表中的 32 位浮点数据类型。\n- `-i` ：从站设备以大端字节序操作 32 位整数。\n- `-f` ：从站设备以大端字节序操作 32 位浮点数。\n- `-e` ：使用 Daniel/Enron 单寄存器 32 位模式（暗示 -i 和 -f）。\n- `-0` ：第一个引用（起始地址）是 0（PDU 寻址）而不是 1。\n- `-1` ：只轮询一次，否则以设定的轮询间隔循环执行。\n- `-l #` ：以毫秒为单位的轮询时间（默认为 1000）。\n- `-o #` ：以秒为单位的超时（0.01 - 10.0，默认为 1.0 秒）。\n- `-h` ：显示帮助信息。\n\n以下选项仅适用 MODBUS/TCP, UDP 和 RTU over TCP：\n\n- `-p #` ：IP 协议端口号（默认为 502）\n\n以下选项仅适用 Modbus ASCII 和 Modbus RTU：\n\n- `-b #` ：波特率（例如 9600, 19200, ...），默认为 19200。\n- `-d #` ：数据位（ASCII 协议为 7 或 8，RTU 协议为 8)。\n- `-s #` ：停止位（1 或 2，默认为 1）。\n- `-p none` ：无校验。\n- `-p even` ：偶校验（默认）。\n- `-p odd` ：奇校验。\n- `-4 #` ：RS-485 模式，传输时开启 RTS，之后还有 # 毫秒。\n\n**参数**：\n\n- `SERIALPORT` ：串口设备，在 Windows 下如 COM1、COM2 等，在 Linux 下如 /dev/ttyS0、/dev/ttyS1 等。\n- `HOST` ：主机名或 IP 地址。\n- `WRITEVALUES` ：对于 Modbus 写入命令，需要在此依次填入数据域的数据，以空格分隔。\n\n## 示例\n\n通过 Modbus RTU 从 ID 为 3 的从站设备中读取 500 地址开始的连续 10 个保持寄存器的值。（串口 COM1，波特率 9600，无奇偶校验）\n\n```bash\nmodpoll -b 9600 -p none -m rtu -a 3 -r 500 -c 10 COM1\n```\n\n\n\n通过 Modbus TCP 从 10.0.0.100 设备读取 100 地址开始的连续 5 个浮点数值。\n\n```bash\nmodpoll -t4:float -r 100 -c 5 -1 10.0.0.100\n```\n\n\n\n通过 Modbus TCP 往 10.0.0.100 设备 1201 地址写保持寄存器，值为 1234。（使用 FC 16 功能码）\n\n```bash\nmodpoll -r 1201 10.0.0.100 1234\n```\n\n\n\n通过 Modbus TCP 往 10.0.0.100 设备 1201 地址写保持寄存器，值为 1234。（使用 FC 6 功能码）\n\n```bash\nmodpoll -r 1201 -c 1 10.0.0.100 1234\n```\n\n\n\n通过 Modbus RTU 执行一次「写单个线圈」命令，开启 1 号继电器。\n\n```bash\nmodpoll -m rtu -1 -a 1 -r 1 -c 1 -b 9600 -p none -t 0 /dev/ttyUSB1 1\n```\n\n\n\n通过 Modbus RTU 执行一次「写单个线圈」命令，关闭 1 号继电器。\n\n```bash\nmodpoll -m rtu -1 -a 1 -r 1 -c 1 -b 9600 -p none -t 0 /dev/ttyUSB1 0\n```\n\n\n\n通过 Modbus RTU 循环执行「读线圈状态」命令，读取 1 号继电器状态。\n\n```bash\nmodpoll -m rtu -a 1 -r 1 -c 1 -b 9600 -p none -t 0 /dev/ttyUSB1\n```\n\n\n\n\n\n# Linux usb_modeswitch 命令 - 切换 USB 设备模式\n\n## 介绍\n\n**usb_modeswitch** 命令用于控制“多状态” USB 设备的模式，它基于 libusb1/libusbx 库开发。\n\n**语法**：\n\n```bash\nusb_modeswitch [<params>] [-c filename]\n```\n\n\n\n**选项**：\n\n- `-h`, `--help`：显示帮助信息。\n- `-e`, `--version`：打印版本信息并退出。\n- `-j`, `--find-mbim`：返回带 MBIM 接口的配置号（config no.）。\n- `-v`, `--default-vendor NUM`：原始模式的供应商 ID（必填）。\n- `-p`, `--default-product NUM`：原始模式的产品 ID（必填）。\n- `-V`, `--target-vendor NUM`：目标模式供应商 ID（可选）。\n- `-P`, `--target-product NUM`：目标模式产品 ID（可选）。\n- `-C`, `--target-class NUM`：目标模式设备类（可选）。\n- `-b`, `--bus-num NUM`：设备的系统总线号（用于硬 ID）。\n- `-g`, `--device-num NUM`：系统设备号（用于硬 ID）。\n- `-m`, `--message-endpoint NUM`：将消息传输定向到那里（可选）。\n- `-M`, `--message-content <msg>`：要发送的消息（十六进制数字作为字符串）。\n- `-2`, `--message-content2 <msg>`：要发送的附加消息（推荐 -n）。\n- `-3`, `--message-content3 <msg>`：要发送的附加消息（推荐 -n）。\n- `-w`, `--release-delay NUM`：在释放接口之前等待 NUM 毫秒。\n- `-n`, `--need-response`：已过时，无效（始终开启）。\n- `-r`, `--response-endpoint NUM`：从那里读取响应（可选）。\n- `-K`, `--std-eject`：发送标准 EJECT 序列。\n- `-d`, `--detach-only`：分离活动驱动程序，无进一步操作。\n- `-H`, `--huawei-mode`：应用一个特殊的程序。\n- `-J`, `--huawei-new-mode`：应用一个特殊的程序。\n- `-X`, `--huawei-alt-mode`：应用一个特殊的程序。\n- `-S`, `--sierra-mode`：应用一个特殊的程序。\n- `-O`, `--sony-mode`：应用一个特殊的程序。\n- `-G`, `--gct-mode`：应用一个特殊的程序。\n- `-N`, `--sequans-mode`：应用一个特殊的程序。\n- `-A`, `--mobileaction-mode`：应用一个特殊的程序。\n- `-T`, `--kobil-mode`：应用一个特殊的程序。\n- `-L`, `--cisco-mode`：应用一个特殊的程序。\n- `-B`, `--qisda-mode`：应用一个特殊的程序。\n- `-E`, `--quanta-mode`：应用一个特殊的程序。\n- `-F`, `--pantech-mode NUM`：应用一个特殊的程序，需要传入 NUM 参数。\n- `-Z`, `--blackberry-mode`：应用一个特殊的程序。\n- `-U`, `--option-mode`：应用一个特殊的程序。\n- `-R`, `--reset-usb`：在所有其他操作后重置设备。\n- `-Q`, `--quiet`：不显示进度或错误消息。\n- `-W`, `--verbose`：打印所有设置和调试输出。\n- `-D`, `--sysmode`：具体结果和系统日志消息。\n- `-s`, `--check-success <seconds>`：带超时的切换结果检查。\n- `-I`, `--inquire`：已过时，没有影响。\n- `-c`, `--config-file <filename>`：从文件加载长配置。\n- `-t`, `--stdinput`：从标准输入读取长配置。\n- `-f`, `--long-config <text>`：从字符串中获取长配置。\n- `-i`, `--interface NUM`：选择初始 USB 接口（默认 0）。\n- `-u`, `--configuration NUM`：选择 USB 配置。\n- `-a`, `--altsetting NUM`：选择备用 USB 接口设置。\n\n## 示例\n\n执行 `lsusb` 扫描 USB 设备，查看目标设备的信息，如：\n\n```bash\nBus 003 Device 006: ID 0bda:1a2b Realtek Semiconductor Corp. DISK\n```\n\n\n\n操作设备：\n\n```bash\nsudo usb_modeswitch -KW -v 0bda -p 1a2b\n```\n\n\n\n\n\n# Linux ppsctl 命令 - 管理 PPS 信号\n\n## 介绍\n\n**ppsctl** 命令是 pps-tools 软件包中的一部分，用于管理和配置 PPS 信号。它提供对 PPS 信号进行测试和调试的功能，允许用户查看和调整与 PPS 相关的参数。\n\n提示\n\npps-tools 软件包提供了与 PPS（Pulse-Per-Second，脉冲每秒）信号相关的工具，该软件包提供了 ppscheck、ppsctl、ppsfind、ppsldisc、ppstest、ppswatch 等命令。\n\n关于 LinuxPPS 命令和 API 接口的详细介绍可查阅 [http://linuxpps.org](http://linuxpps.org/) 上的 Wiki 文档。\n\n**安装**：\n\n```bash\n$ sudo apt install pps-tools\n```\n\n\n\n**语法**：\n\n```bash\nppsctl [-bBfFac] <ppsdev>\n```\n\n\n\n**选项**：\n\n- `-b`：绑定内核 PPS 消费者。\n- `-B`：解除绑定内核 PPS 消费者。\n- `-f`：设置内核 NTP PPS 标志。\n- `-F`：取消设置内核 NTP PPS 标志。\n- `-a`：使用 assert edge。\n- `-c`：使用 clear edge（默认）。\n\n## 示例\n\n启动 PPS 输入设备进行时间同步：\n\n```bash\nppsctl /dev/pps0\n```\n\n\n\n检查同步状态：\n\n```bash\nppstest /dev/pps0\n```\n\n\n\n\n\n# Linux hexdump 命令 - 查看二进制文件\n\n## 介绍\n\n**hexdump** 命令通常用于查看二进制文件，可以将二进制文件转换为 ASCII、八进制、十进制、十六进制格式进行查看。\n\n注：hexdump 有一个缩写命令 hd，下面所有命令中都可以用 hd 替换 hexdump。\n\n**语法**：\n\n```bash\nhexdump [OPTIONS...] [FILES...]\n```\n\n\n\n**选项**\n\n- `-b` ：每个字节显示为八进制。一行共16个字节，一行开始以十六进制显示偏移值。\n- `-c` ：每个字节显示为 ASCII 字符。\n- `-C` ：每个字节显示为十六进制和相应的 ASCII 字符。标准十六进制 + ascii 码显示，十六进制显示偏移量，每行16个字符，每字符两位显示，不足补0，结尾显示当前16位数据的 ascii 码值，以 `|` 框住。\n- `-d` ：双字节十进制显示，十六进制显示偏移量，每行8组（16字节）每组5位，不足补零，列间以空格分隔，以无符号十进制数值显示。\n- `-e <format_string>` ：指定格式字符串，格式字符串包含在一对单引号中。\n- `-f <format_file>` ：根据 format_file 中的格式进行输出，忽略 format_file 中空行及以 `#` 开始的行会。\n- `-n <length>` ：只显示前面 length 个字节的数据。\n- `-o` ：双字节八进制显示。十六进制显示偏移量，每行8组数据，每数据占两字节，6列，不足补零，以空格分隔。\n- `-s <offset>` ：跳过从开始的 offset 个字节，默认输入十进制，以 0x 或 0X 开始按16进制处理，否则如以 0 开始按八进制处理，如果以 b/k/m 结尾，则原数值乘以 512/1024/1048576。\n- `-v` ：显示所有数据，如果不包含这一选项，对于同上一行完全相同的数据，hexdump 会以 * 代替显示。\n- `-x` ：两位十六进制显示，十六进制显示偏移量，每行8组数据，每数据占两字节，4列，不足补零，以空格分隔。\n\n**格式**：\n\n-e 选项指定格式字符串，格式字符串包含在一对单引号中，格式字符串形如：\n\n```bash\n'a/b \"format1\" \"format2\"'\n```\n\n\n\n每个格式字符串由三部分组成，每个由空格分隔，第一个形如 a/b，b 表示对每 b 个输入字节应用 format1 格式，a 表示对每 a 个输入字节应用 format2 格式，一般 a>b，且 b 只能为 1、2、4，另外 a 可以省略，省略则 a=1。format1 和 format2 中可以使用类似 printf 的格式字符串，如：\n\n- `%02d` ：两位十进制\n- `%03x` ：三位十六进制\n- `%02o` ：两位八进制\n- `%c` ：单个字符等\n\n还有一些特殊的用法：\n\n- `%_ad` ：标记下一个输出字节的序号，用十进制表示\n- `%_ax` ：标记下一个输出字节的序号，用十六进制表示\n- `%_ao` ：标记下一个输出字节的序号，用八进制表示\n- `%_p` ：对不能以常规字符显示的用 `.` 代替\n\n同一行如果要显示多个格式字符串，则可以跟多个 -e 选项。\n\n## 示例\n\n假设有文件 test.txt，内容如下：\n\n```bash\n$ cat test.txt \nABCDEFG\nHIJKLMN\n1234567\n```\n\n\n\n以八进制显示文件里面的字符：\n\n```bash\n$ hexdump -b test.txt \n0000000 101 102 103 104 105 106 107 012 110 111 112 113 114 115 116 012\n0000010 061 062 063 064 065 066 067 012                                \n0000018\n```\n\n\n\n第一列是十六进制表示的偏移值，最后一个 0x18 即表示 test.txt 文件共 24 个字节。每一行显示16个字节，每行后面有一个换行符 `\\n`（八进制为 012）。\n\n再以 ASCII 码显示，这样更清晰：\n\n```bash\n$ hexdump -c test.txt \n0000000   A   B   C   D   E   F   G  \\n   H   I   J   K   L   M   N  \\n\n0000010   1   2   3   4   5   6   7  \\n                                \n0000018\n```\n\n\n\n显示十六进制和相应的 ASCII 字符：\n\n```bash\n$ hexdump -C test.txt \n00000000  41 42 43 44 45 46 47 0a  48 49 4a 4b 4c 4d 4e 0a  |ABCDEFG.HIJKLMN.|\n00000010  31 32 33 34 35 36 37 0a                           |1234567.|\n00000018\n```\n\n\n\n只查看前3个字节内容：\n\n```bash\n$ hexdump -C -n 3 test.txt \n00000000  41 42 43                                          |ABC|\n00000003\n```\n\n\n\n查看偏移16个字节后的3个字节内容：\n\n```bash\n$ hexdump -C -n 3 -s 16 test.txt \n00000010  31 32 33                                          |123|\n00000013\n```\n\n\n\n在嵌入式开发中，hexdump 命令也很有用，比如查看 eeprom 中的数据：\n\n```bash\nhexdump -C /sys/bus/i2c/devices/3-0054/eeprom\n```\n\n\n\n或者查看设备树节点的信息：\n\n```bash\nhexdump -C /proc/device-tree/soc@0/compatible\n```\n\n\n\n\n\n# Linux memtester 命令 - 测试内存稳定性和完整性\n\n## 介绍\n\n**memtester**（英文全拼：memory tester）是 Linux 下的一款内存测试工具，可用于内存压力测试及查找内存子系统故障。\n\nmemtester 运行在用户空间下，是一款用于**测试内存正确性**的命令行实用工具，适用于大多数平台。可以在 32 位或 64 位的类 Unix 操作系统编译和运行（当然也包括 macOS）。这款工具主要面向硬件开发人员，从 4.1.0 版本开始，memtester 可以指定起始物理内存地址进行测试。\n\nmemtester 工具主要是捕获内存错误和一直处于很高或者很低的坏位，其测试的主要项目有随机值、异或比较、减法、乘法、除法、与或运算等等。通过给定测试内存的大小和次数，可以对系统现有的内存进行上面项目的测试。通过指定物理地址，memtester 还可以用于测试内存映射 I/O 设备和类似设备。需要注意的是，内存区域在测试过程中会被覆盖，因此要特别小心，如果指定为系统或其他应用程序分配的内存，将可能导致它们崩溃。\n\n如果你的系统没有 memtester 工具，请先安装，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install memtester\n```\n\n\n\n项目官网：[http://pyropus.ca/software/memtester](http://pyropus.ca/software/memtester/)\n\n**语法**：\n\n```bash\nmemtester [-p PHYSADDR [-d DEVICE]] <MEMORY> [ITERATIONS]\n```\n\n\n\n**选项**：\n\n- `-p PHYSADDR` ：测试从给定的物理地址 PHYSADDR 起始的特定内存区域（以十六进制表示），通过映射 -d 选项指定的设备。\n- `-d DEVICE` ：指定设备，默认为 /dev/mem 设备。\n\n**参数**：\n\n- `MEMORY` ：需要分配和测试的内存大小，默认以兆字节为单位，可以通过后缀 B、K、M 或 G 分别表示字节、千字节、兆字节或千兆字节。\n- `ITERATIONS` ：循环测试次数（默认为无限次）。\n\n## 示例\n\n提示：因为系统运行和本工具运行都需要内存，所以不能把所有的内存都测试到，可以先用 free 命令查看系统剩余多少内存空间再测试。\n\n测试 300M 内存 10 次\n\n```bash\nmemtester 300M 10\n```\n\n\n\n测试结果\n\n```bash\nmemtester version 4.3.0 (64-bit)\nCopyright (C) 2001-2012 Charles Cazabon.\nLicensed under the GNU General Public License version 2 (only).\n\npagesize is 4096\npagesizemask is 0xfffffffffffff000\nwant 300MB (314572800 bytes)\ngot  300MB (314572800 bytes), trying mlock ...locked.\nLoop 1/10:\n  Stuck Address       : ok\n  Random Value        : ok\n  Compare XOR         : ok\n  Compare SUB         : ok\n  Compare MUL         : ok\n  Compare DIV         : ok\n  Compare OR          : ok\n  Compare AND         : ok\n  Sequential Increment: ok\n  Solid Bits          : ok\n  Block Sequential    : ok\n  Checkerboard        : ok\n  Bit Spread          : ok\n  Bit Flip            : ok\n  Walking Ones        : ok\n  Walking Zeroes      : ok\n\nLoop 2/10:\n  ......\n  \nLoop 10/10:\n  Stuck Address       : ok         \n  Random Value        : ok\n  Compare XOR         : ok\n  Compare SUB         : ok\n  Compare MUL         : ok\n  Compare DIV         : ok\n  Compare OR          : ok\n  Compare AND         : ok\n  Sequential Increment: ok\n  Solid Bits          : ok         \n  Block Sequential    : ok         \n  Checkerboard        : ok         \n  Bit Spread          : ok         \n  Bit Flip            : ok         \n  Walking Ones        : ok         \n  Walking Zeroes      : ok         \n  8-bit Writes        : ok\n  16-bit Writes       : ok\n\nDone.\n```\n\n\n\n结果全部为 ok 则说明内存工作正常。\n\n\n\n# Linux seq 命令 - 生成数字序列\n\n## 介绍\n\n**seq**（英文全拼：sequence）命令用于产生一串序列化的数字，即从某个数到另外一个数之间的所有整数。\n\n**语法**：\n\n```bash\nseq [OPTION]... LAST\nseq [OPTION]... FIRST LAST\nseq [OPTION]... FIRST INCREMENT LAST\n```\n\n\n\n**选项**：\n\n- `-f`, `--format=FORMAT` ：使用 printf 样式的浮点格式。\n- `-s`, `--separator=STRING` ：使用指定字符串分隔数字（默认使用：`\\n`）。\n- `-w`, `--equal-width` ：在列前添加 0 使得宽度相同。\n- `--help` ：显示帮助信息并退出。\n- `--version` ：输出版本信息并退出。\n\n**参数**：`FIRST` 为首数，`INCREMENT` 为增量，`LAST` 为尾数。\n\n## 示例\n\n指定格式输出 9-11 的整数\n\n```bash\n$ seq -f\"%3g\" 9 11\n  9\n 10\n 11\n```\n\n\n\n指定输出等宽数字\n\n```bash\n$ seq -w 98 2 102\n098\n100\n102\n```\n\n\n\n\n\n# Linux cyclictest 命令 - 测试 CPU 负载和响应时间\n\n## 介绍\n\n**cyclictest** 是一个用于测试 Linux 内核实时性的命令行程序，是 rt-tests 下的一个测试工具，也是 rt-tests 下使用最广泛的测试工具，一般用来测试 Linux 内核的延迟。\n\ncyclictest 命令由 rt-tests 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install rt-tests\n```\n\n\n\n代码仓库：https://git.kernel.org/pub/scm/utils/rt-tests/rt-tests\n\n**语法**：\n\n```bash\ncyclictest <options>\n```\n\n\n\n**选项**：\n\n- `-a`, `--affinity[=PROC-SET]`：指示 CPU 亲和性，即在处理器 N 上运行线程，例如 `-a 0,1,2`、`-a 0-2`、`-a 0-2,4` 都可以，`!` 表示否定，如 `-a !2-4` 表示绑定在 2-4 以外的所有 CPU 核上。\n- `-A`, `--align=USEC`：以微秒为单位将测量线程唤醒与特定偏移量对齐。\n- `-b`, `--breaktrace=USEC`：调试选项，用于控制实施抢占补丁中的延迟跟踪器。当延时大于 USEC 指定的值时，发送停止跟踪。USEC 单位为 μs。\n- `-c`, `--clock=CLOCK`：选择时钟。0 为线性增长时钟，1 为墙上时间时钟。当设置 `-s` 选项时，该选项失效。\n- `-C`, `--context`：上下文切换。调试相关，和 `-b` 选项一起用的。\n- `-d`, `--distance=DIST`：当多个线程时，设置间隔（睡眠时间）的增量 distance。interval (线程n) = interval (线程n-1) + DIST。当该选项设置为 0 时，即 DIST=0 时，所有线程都会在同一时间醒来，不过这违背了cyclictest 的初衷，它是想测试每时每刻系统响应速度，而不是一瞬间把系统爆掉。\n- `-E`, `--event`：调试相关，和 `-b` 选项联合使用。\n- `-f`, `--ftrace`：调试相关，和 `-b` 选项联合使用。\n- `-h`, `--histogram=US`：输出直方图到 stdout。指定要跟踪的最大的延迟数值。\n- `--histfile=<path>`：输出直方图到文件。\n- `-H`：同 `-h` 选项，同时该选项还会输出多一列数据在最右边，表示求和，当只有一个线程时，`-H` 等价于 `-h`。\n- `-i`, `--interval=INTV`：设置第一个线程的间隔（睡眠时间），默认 1000us。\n- `-l`, `--loops=LOOPS`：默认为 0，表示无止境测下去。\n- `-m`, `--mlockall`：锁定当前和未来的内存分配以阻止被 page out（页调出）。\n- `-M`, `--refresh_on_max`：延迟更新屏幕直到达到新的最大延迟（对于在低带宽连接上运行循环测试很有用）。\n- `-n`, `--nanosleep`：使用 clock_nanosleep 代替 posix interval timer。\n- `-N`, `--nsecs`：用纳秒为单位显示结果，而不是默认的微秒。\n- `-o`, `--oscope=RED`：示波器模式。\n- `-O`, `--traceopt=TRACING_OPTION`：跟踪选项相关。\n- `-p`, `--prio=PRIO`：设置第一个线程的优先级。Priority(n) = max (Priority(n-1)-1, 0)\n- `-q`, `--quiet`：静默模式，只输出概述信息。适用于自动化测试的时候，在脚本中使用这个选项。\n- `-r`, `--relative`：使用相对时间。默认绝对时间。官方手册不建议使用。\n- `-s`, `--system`：使用 sys_nanosleep 和 sys_setitimer 取代 posix timer。但是 `-s` 选项只应该在一个线程时使用，因为 itimer 每个进程只有一个，而不是每个线程都有。该选项可以结合 `-n` 选项一起使用，这样就不会受限于只对一个线程使用了。\n- `-S`, `--smp`：为 SMP 系统上的标准测试设置选项。等效于使用选项 `-t -a -n` 以及在所有线程中保持任何指定的优先级相等。\n- `-t`, `--threads[=NUM]`：该选项用来指定线程数。没有指定该选项时，默认 1 个线程。指定了该选项但又没有指定数字时，会开启 CPU 核心个数个线程。\n- `-T`, `--tracer=TRACEFUNC`：跟踪器相关。\n- `-v`, `--verbose`：输出统计信息。结合 `-l` 使用。\n- `-D`, `--duration=TIME`：运行时间，默认单位 s，可以使用 “m h d” 代表分钟、小时、天。\n- `-w`, `--wakeup`：唤醒追踪，配合 `-b` 选项。\n- `-W`, `--wakeuprt`：实时线程唤醒追踪，配合 `-b` 选项。\n- `-y`, `--policy=NAME`：设置调度策略。可选 other、normal、batch、idle、fifo、rr 策略。\n\n## 示例\n\n运行 5 个线程，线程优先级 80，无限循环\n\n```bash\ncyclictest -t 5 -p 80 -n\n```\n\n\n\n运行 1 个线程（使用 clock_nanosleep），线程优先级 80，间隔 10000 微秒，10000 次循环，无负载\n\n```bash\ncyclictest -t1 -p 80 -n -i 10000 -l 10000\n```\n\n\n\n运行 1 个线程（使用 posix interval timer）线程优先级 80，间隔 10000 微秒，10000 次循环，无负载\n\n```bash\ncyclictest -t1 -p 80 -i 10000 -l 10000\n```\n\n\n\n## 输出格式\n\n下面是 cyclictest 测试示例运行时的打印信息：\n\n```bash\n$ sudo cyclictest -t 5 -p 80\n# /dev/cpu_dma_latency set to 0us\npolicy: fifo: loadavg: 1.85 1.89 3.04 1/2760 1556268           \n\nT: 0 (1556027) P:80 I:1000 C:  14957 Min:      1 Act:    2 Avg:    2 Max:     258\nT: 1 (1556028) P:80 I:1500 C:   9971 Min:      1 Act:    2 Avg:    2 Max:     365\nT: 2 (1556029) P:80 I:2000 C:   7478 Min:      1 Act:    7 Avg:    3 Max:     388\nT: 3 (1556030) P:80 I:2500 C:   5982 Min:      1 Act:    4 Avg:    2 Max:      39\nT: 4 (1556031) P:80 I:3000 C:   4985 Min:      1 Act:    3 Avg:    3 Max:     224\n```\n\n\n\n输出字段说明如下表所示：\n\n| 字段  | 描述                                           |\n| ----- | ---------------------------------------------- |\n| `T`   | 线程序号，括号里面是 PID                       |\n| `P`   | 线程优先级                                     |\n| `C`   | 计数器（线程的时间间隔每达到一次，计数器加 1） |\n| `I`   | 时间间隔，单位是微秒（us）                     |\n| `Min` | 最小延时，单位是微秒（us）                     |\n| `Act` | 最近一次的延时，单位是微秒（us）               |\n| `Avg` | 平均延时，单位是微秒（us）                     |\n| `Max` | 最大延时，单位是微秒（us）                     |\n\n\n\n# Linux strace 命令 - 跟踪系统调用和信号\n\n## 介绍\n\n**strace**（英文全拼：system trace）是 Linux 系统中一个功能强大的调试、分析、诊断工具，可以对系统调用和信号传递的跟踪结果进行分析，从而解决问题。在调试应用程序时，strace 是一个很好的工具，并且经常被工程师用来检查操作系统及其程序中可能出现的某些问题。\n\nLinux 系统中进程不能直接访问硬件设备，当进程需要读取磁盘文件或接收网络数据时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。而 strace 命令则可以跟踪到一个进程产生的系统调用数据 —— 包括参数，返回值，执行消耗时间等信息。\n\n**语法**：\n\n```bash\nstrace [ -dffhiqrtttTvxx ] [ -a column ] [ -e expr ] ... [ -o file ] [ -p pid ] ... [ -s strsize ] [ -u username ] [ command [ args ... ] ]\nstrace -c [ -e expr ] ... [ -O overhead ] [ -S sortby ] [ command [ args ... ] ]\n```\n\n\n\n**选项**：\n\n- `-c`：统计每一系统调用的所执行的时间，次数和出错的次数等。\n- `-d`：输出 strace 关于标准错误的调试信息。\n- `-f`：跟踪由 fork 调用所产生的子进程。\n- `-ff`：如果提供 `-o filename`，则所有进程的跟踪结果输出到相应的 filename.pid 中，pid 是各进程的进程号。\n- `-F`：尝试跟踪 vfork 调用。在 `-f` 时，vfork 不被跟踪。\n- `-h`：输出简要的帮助信息。\n- `-i`：输出系统调用的入口指针。\n- `-q`：禁止输出关于脱离的消息。\n- `-r`：打印出每一个系统调用的相对时间。\n- `-t`：在输出中的每一行前加上时间信息。\n- `-tt`：在输出中的每一行前加上时间信息，微秒级。\n- `-ttt`：微秒级输出，以秒了表示时间。\n- `-T`：显示每一调用所耗的时间。\n- `-v`：输出所有的系统调用。一些调用关于环境变量、状态、输入输出等调用由于使用频繁，默认不输出。\n- `-V`：输出 strace 的版本信息。\n- `-x`：以十六进制形式输出非标准字符串。\n- `-xx`：所有字符串以十六进制形式输出。\n- `-a column`：设置返回值的输出位置，默认为 40。\n- `-e expr`：指定一个表达式，用来控制如何跟踪。格式为 `[qualifier=][!]value1[,value2]...`，qualifier 只能是 trace、abbrev、verbose、raw、signal、read、write 其中之一，value 是用来限定的符号或数字，默认的 qualifier 是 trace。感叹号是否定符号，例如 `-eopen` 等价于 `-e trace=open`，表示只跟踪 open 调用，而 `-etrace!=open` 表示跟踪除了 open 以外的其他调用，有两个特殊的符号 all 和 none。\n- `-e trace=set`：只跟踪指定的系统调用。例如 -e trace=open,close,rean,write 表示只跟踪这四个系统调用，默认的为 set=all。\n- `-e trace=file`：只跟踪有关文件操作的系统调用。\n- `-e trace=process`：只跟踪有关进程控制的系统调用。\n- `-e trace=network`：跟踪与网络有关的所有系统调用。\n- `-e strace=signal`：跟踪所有与系统信号有关的系统调用。\n- `-e trace=ipc`：跟踪所有与进程通讯有关的系统调用。\n- `-e abbrev=set`：设定 strace 输出的系统调用的结果集。-v 等与 abbrev=none，默认为 abbrev=all。\n- `-e raw=set`：将指定的系统调用的参数以十六进制显示。\n- `-e signal=set`：指定跟踪的系统信号，默认为 all。如 signal=!SIGIO（或者 signal=!io），表示不跟踪 SIGIO 信号。\n- `-e read=set`：输出从指定文件中读出的数据，例如 `-e read=3,5`。\n- `-e write=set`：输出写入到指定文件中的数据。\n- `-o filename`：将 strace 的输出写入文件 filename。\n- `-p pid`：跟踪指定的进程 pid。\n- `-s strsize`：指定输出的字符串的最大长度，默认为 32。文件名一直全部输出。\n- `-u username`：以 username 的 UID 和 GID 执行被跟踪的命令。\n\n## 示例\n\n跟踪 46725 进程的所有系统调用（`-e trace=all`），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在 output.txt 文件里面：\n\n```bash\n$ strace -o output.txt -T -tt -e trace=all -p 46725\n```\n\n\n\n启动和调试 hello 程序，同时跟踪其 fork 和 vfork 出来的进程，并将记录结果存在 hello-strace.txt 文件：\n\n```bash\n$ strace -f -F -o hello-strace.txt ./hello\n```\n\n\n\nhello-strace.txt 文件的内容如下：\n\n```bash\nexecve(\"/usr/bin/hello\", [\"hello\"], 0x7ffd2d9b6ff0 /* 72 vars */) = 0\nbrk(NULL)                               = 0x557a46673000\narch_prctl(0x3001 /* ARCH_??? */, 0x7ffd1d54a690) = -1 EINVAL (无效的参数)\nmmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe67e2b7000\naccess(\"/etc/ld.so.preload\", R_OK)      = -1 ENOENT (没有那个文件或目录)\n......\n```\n\n\n\n查看在 configure 脚本里面执行的程序（需要监视的系统调用是 execve），只记录 execve 的调用：\n\n```bash\n$ strace -f -o configure-strace.txt -e execve ./configure\n```\n\n\n\n\n\n# Linux ltrace 命令 - 跟踪程序的库调用\n\n## 介绍\n\n**ltrace**（英文全拼：library call tracer）是一个用于跟踪进程调用库函数的命令行工具。它可以显示应用程序运行时调用的共享库函数，并输出它们的参数和返回值。以帮助调试应用程序，了解其运行时行为。\n\nltrace 基于 ptrace 实现，而 ptrace 能够用来跟踪系统调用，ltrace 打开 elf 文件时会对其进行分析。由于在 elf 文件中，出于动态连接的需要，需要在 elf 文件中保存函数的符号以供连接器使用，因此 ltrace 就能跟踪到库函数的调用。\n\n**语法**：\n\n```bash\nltrace [option ...] [command [arg ...]]\n```\n\n\n\n**选项**：\n\n- `-a, --align <column>`：对齐具体某个列的返回值。\n- `-c`：统计每个库函数的调用次数和时间，并在程序退出时打印摘要。\n- `-D, --debug <mask>`：打印调试信息。\n- `-e <filter>`：指定要跟踪的事件，例如特定函数。\n- `-f`：跟踪子进程。\n- `-l, --library <library_pattern>`：只打印某个库中的调用。\n- `-o, --output <filename>`：将输出保存到指定的文件中。\n- `-p <pid>`：指定要跟踪的进程 ID。\n- `-s <size>`：限制参数和返回值的显示大小。\n- `-S`：显示系统调用（system calls）以及库调用（library calls）。\n- `-T`：显示每个函数调用的耗时。\n\n## 示例\n\n最基本应用，不带任何参数：\n\n```bash\n$ ltrace ./a.out \n```\n\n\n\n输出调用时间开销：\n\n```bash\n$ ltrace -T ./a.out \n```\n\n\n\n显示系统调用：\n\n```bash\n$ ltrace -S ./a.out \n```\n\n\n\n计算时间和调用，并在程序退出时打印摘要：\n\n```bash\n$ ltrace -c ./a.out \n```\n\n\n\n只跟踪 `malloc` 和 `free` 函数的调用：\n\n```bash\n$ ltrace -e malloc,free ./a.out\n```\n\n\n\n\n\n# Linux timeout 命令 - 限制命令执行时间\n\n## 介绍\n\n**timeout** 是一个 Linux 系统中的命令，用于在指定时间内运行命令，并在超时时终止该命令的执行。对于需要控制命令执行时间的情况非常有用，特别是在 Shell 脚本或批处理任务中。\n\n**语法**：\n\n```bash\ntimeout [选项] 停留时间 命令 [参数]...\n```\n\n\n\n停留时间的后缀 s 代表秒（默认值），m 代表分，h 代表小时，d 代表天。如果不添加任何单位，默认是秒。如果持续时间为 0，则禁用关联的超时。\n\n**选项**：\n\n- `--preserve-status`：退出时返回值与所运行命令的返回值保持相同，即使命令超时也这样设置。\n- `--foreground`：当 timeout 不是直接从 shell 命令行开始运行时，允许所运行的命令从 TTY 读取输入并获取 TTY 信号；在此模式下，所运行的命令的子进程不会受超时的影响。。\n- `-k, --kill-after=持续时间`：如果所运行命令在初始信号发出后再经过所指定持续时间以后仍然在运行，则对其发送 KILL 信号。\n- `-s, --signal=信号`：指定超时发生时要发送的信号；所指定的信号可以是如“HUP”这样的名称，或是一个数字；请参见“kill -l”以获取可用信号列表。\n- `-v, --verbose`：对任何超时后发送的信号，向标准错误输出诊断信息。\n- `--help`：显示此帮助信息并退出。\n- `--version`：显示版本信息并退出。\n\n## 示例\n\n运行 `command_to_run` 命令，并在 5 秒后终止它的执行：\n\n```bash\ntimeout 5s command_to_run\n```\n\n\n\n运行命令一分钟，如果命令没有结束，将在10秒后终止命令：\n\n```bash\ntimeout -k 10s 1m command_to_run\n```\n\n\n\n\n\n# Linux declare 命令 - 声明变量和属性\n\n## 介绍\n\n在 Linux 中，**`declare`** 命令主要用于声明变量的属性，尤其是在 Shell 脚本编程中。它有几个用途，包括声明变量的类型、属性和设置变量的值。declare 命令若不带任何参数选项，则会显示所有 Shell 变量及其值。\n\n需要注意的是，`declare` 命令在交互式 shell 中可能不如在脚本中常见，因为它通常用于在脚本中显式声明变量的属性。在交互式 shell 中，通常直接使用简单的变量赋值语句。\n\n**语法**：\n\n```bash\ndeclare [-aAfFgilnrtux] [-p] [名称[=值] ...]\n```\n\n\n\n**选项**：\n\n- `-f`：限制动作或显示为仅函数名称和定义。\n- `-F`：限制仅显示函数名称（以及调试时显示行号和源文件名）。\n- `-g`：当用于 shell 函数内时创建全局变量，否则忽略。\n- `-p`：显示每个 NAME 变量的属性和值。\n\n设定属性的选项：\n\n- `-a`：使 NAME 成为下标数组（如果支持）。\n- `-A`：使 NAME 成为关联数组（如果支持）\n- `-i`：使 NAME 带有 `integer`（整数）属性。\n- `-l`：将 NAME 在赋值时转为小写。\n- `-n`：使 NAME 成为指向一个以其值为名称的变量的引用。\n- `-r`：将 NAME 变为只读。\n- `-t`：使 NAME 带有 `trace`（追踪）属性。\n- `-u`：将每个 NAME 在赋值时转为大写。\n- `-x`：将 NAME 导出。\n\n## 示例\n\n声明一个普通的变量，并给它赋予一个初始值：\n\n```bash\ndeclare variable_name=value\n```\n\n\n\n声明一个只读变量（一旦设置，该变量的值将不能被修改）：\n\n```bash\ndeclare -r readonly_variable=value\n```\n\n\n\n声明一个整数变量（`declare` 会尝试将变量的值作为整数处理）：\n\n```bash\ndeclare -i integer_variable=value\n```\n\n\n\n声明一个数组变量，并初始化数组元素：\n\n```bash\ndeclare -a array_variable=(value1 value2 value3)\n```\n\n\n\n声明一个关联数组（Associative Array），关联数组使用字符串作为索引：\n\n```bash\ndeclare -A associative_array_variable\n```\n\n\n\n声明一个函数，显示函数的定义：\n\n```bash\ndeclare -f function_name\n```\n\n\n\n显示变量或函数的属性，包括类型、值等信息：\n\n```bash\ndeclare -p variable_name\ndeclare -f function_name\n```\n\n\n\n取消变量的某些属性，比如取消只读属性：\n\n```bash\ndeclare +属性 variable_name\n```\n\n\n\n\n\n# Linux ps 命令 - 显示当前运行的进程\n\n## 介绍\n\n**ps**（英文全拼：process status）是 Linux 系统中非常常用的一个命令，用于查看当前运行的进程状态，类似于 Windows 的任务管理器。通过 ps 命令，我们可以获取进程的 ID、父进程 ID、优先级、执行时间、CPU 使用情况等关键信息。\n\n### 命令语法\n\n```bash\nps [选项]\n```\n\n\n\n### 选项参数\n\nps 命令的选项参数非常多，可以分为 simple、list、output、threads、misc 五大类，可以通过如下命令查看详细说明。\n\n```bash\nps --help <simple|list|output|threads|misc|all>\n# 或者\nps --help <s|l|o|t|m|a>\n```\n\n\n\n下面列出比较常用的一些选项参数：\n\n**简单的进程选择（simple）**\n\n- `-A`：列出所有的进程。\n- `-e`：此选项的效果和指定\"A\"选项相同。\n- `-a`：选择由终端（tty）启动的所有进程。\n- `r`：只选择运行中的进程。\n- `T`：只选择当前终端启动的进程。\n- `x`：脱离终端控制的进程。\n\n**通过列表选择进程（list）**\n\n- `-C <cmdlist>`：cmdlist 可以是一个或多个进程名称，中间使用逗号分隔。\n- `-G, --Group <GID>`：通过组 ID 或组名称选择进程。\n- `-p, p, --pid <PID>`：根据进程 ID 选择进程。\n- `--ppid <PID>`：根据父进程 ID 选择进程。\n- `-u, U, --user <UID>`：根据用户 ID 或用户名称选择进程。\n\n**输出格式控制（output）**\n\n- `-f`：显示 UID、PPIP、C 与 STIME 栏目，f 代表 full format。\n- `-o, o, --format <format>`：用户定义的格式，format 是列名，可以输出多个列，中间使用逗号分隔。\n\n**多线程进程（threads）**\n\n- `H`：显示进程层次结构。\n- `-L`：可能使用 LWP 和 NLWP 色谱柱。\n- `-T`：可能带有 SPID 列。\n\n**其他（misc）**\n\n- `-w`：显示加宽可以显示较多信息\n\nps 命令有两种展示风格：\n\n|          | `ps -ef` 命令        | `ps aux` 命令     |\n| -------- | -------------------- | ----------------- |\n| 展示风格 | System V 风格        | BSD 风格          |\n| 指令名称 | 显示带全路径的进程名 | 会截断 command 列 |\n\n## 示例\n\n### 查看进程（System V 风格）\n\n```bash\n$ ps -ef | head\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot         1     0  0 09:19 ?        00:00:03 /sbin/init splash\nroot         2     0  0 09:19 ?        00:00:00 [kthreadd]\nroot         4     2  0 09:19 ?        00:00:00 [kworker/0:0H]\nroot         6     2  0 09:19 ?        00:00:00 [mm_percpu_wq]\nroot         7     2  0 09:19 ?        00:00:00 [ksoftirqd/0]\nroot         8     2  0 09:19 ?        00:00:40 [rcu_sched]\nroot         9     2  0 09:19 ?        00:00:00 [rcu_bh]\nroot        10     2  0 09:19 ?        00:00:00 [migration/0]\nroot        11     2  0 09:19 ?        00:00:00 [watchdog/0]\n```\n\n\n\n列表含义：\n\n- `UID` ：程序被该 UID 所拥有\n- `PID` ：就是这个程序的进程 ID\n- `PPID` ：是其上级父进程的 ID\n- `C` ：表示 CPU 使用的资源百分比\n- `STIME` ：表示进程启动时间\n- `TTY` ：登入者的终端机位置\n- `TIME` ：使用掉的 CPU 时间\n- `CMD` ：所下达的指令为何\n\n### 查看进程（BSD 风格）\n\n`ps aux` 表示显示所有包含其他使用者的行程。\n\n```bash\n$ ps aux | head\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot         1  0.0  0.0 185576  6164 ?        Ss   09:19   0:03 /sbin/init splash\nroot         2  0.0  0.0      0     0 ?        S    09:19   0:00 [kthreadd]\nroot         4  0.0  0.0      0     0 ?        I<   09:19   0:00 [kworker/0:0H]\nroot         6  0.0  0.0      0     0 ?        I<   09:19   0:00 [mm_percpu_wq]\nroot         7  0.0  0.0      0     0 ?        S    09:19   0:00 [ksoftirqd/0]\nroot         8  0.1  0.0      0     0 ?        I    09:19   0:41 [rcu_sched]\nroot         9  0.0  0.0      0     0 ?        I    09:19   0:00 [rcu_bh]\nroot        10  0.0  0.0      0     0 ?        S    09:19   0:00 [migration/0]\nroot        11  0.0  0.0      0     0 ?        S    09:19   0:00 [watchdog/0]\n```\n\n\n\n列表含义：\n\n- `USER` ：进程拥有者。\n\n- `PID` ：进程 ID。\n\n- `%CPU` ：进程占用的 CPU 使用率。\n\n- `%MEM` ：进程占用的内存使用率。\n\n- `VSZ` ：进程占用的虚拟内存大小（Virtual Memory Size）。注意：VSZ 表示进程占用的全部地址空间，共享库、预分配内存、交换分区等都包含在里面，因此 VSZ 远远大于实际的占用的内存空间。\n\n- `RSS` ：进程占用的物理内存大小（Resident Set Size）。注意：RSS 表示进程实际占用的物理内存，它包含共享库，但不包含在交换分区的空间。随着程序的运行，RSS 也会跟着增长，VSZ 将是它的上限。\n\n- `TTY` ：终端的次要装置号码（minor device number of tty）。`?` 是表示这些进程是由系统启动的，不属于任何 TTY；tty1-tty6 是本机登录用户启动的程序，pts/0 之类的则表示为由网络连接进主机的程序。\n\n- ```\n  STAT\n  ```\n\n   \n\n  ：进程的状态，Linux 的进程有以下 5 种状态：\n\n  - `D` ：不可中断 uninterruptible sleep（usually IO）\n  - `R` ：运行 runnable（on run queue）\n  - `S` ：中断 sleeping\n  - `T` ：停止 traced or stopped\n  - `Z` ：僵死 a defunct (\"zombie\") process\n  - 注：其他状态还包括 `W`（无驻留页），`<`（高优先级进程），`N`（低优先级进程），`L`（内存锁页）。\n\n- `START` ：进程开始时间。\n\n- `TIME` ：进程执行时间，统计该进程消耗 CPU 的时间。\n\n- `COMMAND` ：启动进程的命令。\n\n### 显示指定用户信息\n\n例如显示由 root 用户创建的所有进程：\n\n```bash\n$ ps -u root\n```\n\n\n\n### 列出一个进程创建的所有线程\n\n下面列出了由进程号为 pid 的进程创建的所有线程：\n\n```bash\n$ ps -T -p <pid>\n```\n\n\n\n输出信息可能如下：\n\n```bash\n    PID    SPID TTY          TIME CMD\n3057403 3057403 ?        00:06:01 chrome\n3057403 3057478 ?        00:00:00 chrome:disk$0\n3057403 3057495 ?        00:00:01 chrome:gdrv0\n3057403 3057556 ?        00:00:00 GpuWatchdog\n3057403 3057557 ?        00:00:00 ThreadPoolServi\n3057403 3057558 ?        00:00:13 ThreadPoolForeg\n3057403 3057559 ?        00:05:35 Chrome_ChildIOT\n3057403 3057562 ?        00:14:22 VizCompositorTh\n3057403 3057571 ?        00:00:00 chrome:disk$0\n3057403 3075540 ?        00:00:00 MemoryInfra\n3057403 3103487 ?        00:00:00 ThreadPoolSingl\n3057403 3103488 ?        00:00:00 ThreadPoolSingl\n3057403 3822403 ?        00:00:00 ThreadPoolForeg\n```\n\n\n\n其中，字段 `SPID` 为线程 ID，`CMD` 为线程名称。\n\n### 根据进程名查找进程号\n\n例如查找 mysqld 的进程号（PID）：\n\n```bash\nps -C mysqld\n```\n\n\n\n此时输出如下：\n\n```bash\n    PID TTY          TIME CMD\n   1834 ?        00:00:28 mysqld\n```\n\n\n\nPID 列为进程号，如果只想输出 PID，可以加上 `-o` 选项：\n\n```bash\nps -C mysqld -o pid=\n```\n\n\n\n### 根据进程号查找进程名\n\n例如查找 PID 为 1834 的进程名：\n\n```bash\nps -p 1834\n```\n\n\n\n此时输出如下：\n\n```bash\n    PID TTY          TIME CMD\n   1834 ?        00:00:28 mysqld\n```\n\n\n\nCMD 列为进程名称，如果只想输出进程名，可以加上 `-o` 选项：\n\n```bash\n$ ps -p 1834 -o cmd=\n/usr/sbin/mysqld\n$ ps -p 1834 -o comm=\nmysqld\n```\n\n\n\n\n\n# Linux top 命令 - 实时显示进程和系统状态\n\n## 介绍\n\n**top** 命令用于动态实时显示 Linux 进程的状态。\n\n**语法**：\n\n```bash\ntop -hv|-bcEHiOSs1 -d secs -n max -u|U user -p pid -o fld -w [cols]\n```\n\n\n\n**选项**：\n\n- `-b` ：以批处理模式操作\n- `-c` ：显示完整的治命令\n- `-d` ：屏幕刷新间隔时间\n- `-I` ：忽略失效过程\n- `-s` ：保密模式\n- `-S` ：累积模式\n- `-i <secs>` ：设置间隔时间\n- `-u <user>` ：指定用户名\n- `-p <pid>` ：指定进程\n- `-n <max>` ：循环显示的次数\n\n**输出说明**：\n\n执行 top 命令后，会在终端输出系统进程状态信息，头部信息大致如下：\n\n```bash\ntop - 18:34:11 up  9:14,  2 users,  load average: 0.93, 0.87, 0.72\nTasks: 322 total,   1 running, 264 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  3.4 us,  1.1 sy,  0.0 ni, 95.3 id,  0.1 wa,  0.0 hi,  0.1 si,  0.0 st\nKiB Mem :  8029784 total,   130760 free,  4012508 used,  3886516 buff/cache\nKiB Swap:  7931900 total,  7923452 free,     8448 used.  3191432 avail Mem \n```\n\n\n\n对于服务器来说，重点关注：\n\n- `load average` ：平均负载，后面3个值分别为当前1分钟、5分钟、15分钟的平均负载，最大值等于 CPU 核心数。\n- `KiB Mem` ：该行数据显示内存总大小、空闲内存、已使用内存，以及用于缓存的内存大小。\n- `KiB Swap` ：该行数据显示交换分区的情况。\n\n接着输出一个进程列表，表头栏目如下：\n\n```shell\nPID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND\n```\n\n\n\n每列的含义如下：\n\n- `PID` ：进程 ID\n- `USER` ：进程所有者\n- `PR` ：进程优先级\n- `NI` ：nice 值（负值表示高优先级，正值表示低优先级）\n- `VIRT` ：进程使用的虚拟内存总量（同 VSZ），单位 kb。VIRT = SWAP + RES\n- `RES` ：进程使用的、未被换出的物理内存大小（同 RSS），单位 kb。RES = CODE + DATA\n- `SHR` ：共享内存大小，单位 kb\n- `S` ：进程状态。D = 不可终端的睡眠状态，R = 运行，S = 睡眠，T = 跟踪/停止，Z = 僵尸进程\n- `%CPU` ：上次更新到现在的 CPU 时间占用百分比\n- `%MEM` ：进程使用的物理内存百分比\n- `TIME+` ：进程使用的 CPU 时间总计，单位 1/100 秒\n- `COMMAND` ：进程名称（命令名/命令行）\n\n**交互子命令**：\n\n另外，top 还支持交互子命令，在 top 运行窗口按下面按键，会调整显示效果。\n\n- `M` ：根据驻留内存大小进行排序\n- `P` ：根据CPU使用百分比大小进行排序\n- `T` ：根据时间/累计时间进行排序\n- `H` ：将线程查看模式切换为开或关\n- `1` ：显示每个逻辑 CPU 的状况\n- `h` ：显示帮助画面，给出一些简短的命令总结说明\n- `k` ：终止一个进程\n- `i` ：忽略闲置和僵死进程，这是一个开关式命令\n- `r` ：重新安排一个进程的优先级别\n- `S` ：切换到累计模式\n- `s` ：改变两次刷新之间的延迟时间（单位为 s），如果有小数，就换算成 ms（输入 0 值则系统将不断刷新，默认值是 5s）\n- `f` 或者 `F` ：从当前显示中添加或者删除项目\n- `o` 或者 `O` ：改变显示项目的顺序\n- `l` ：切换显示平均负载和启动时间信息\n- `m` ：切换显示内存信息\n- `t` ：切换显示进程和 CPU 状态信息\n- `c` ：切换显示命令名称和完整命令行\n- `w` ：将当前设置写入 ~/.toprc 文件中\n\n最后，按 `q` 或 `CTRL+C` 可退出程序。\n\n## 示例\n\n显示进程信息：\n\n```bash\ntop\n```\n\n\n\n显示完整命令：\n\n```bash\ntop -c\n```\n\n\n\n以批处理模式显示程序信息：\n\n```bash\ntop -b\n```\n\n\n\n以累积模式显示程序信息：\n\n```bash\ntop -S\n```\n\n\n\n设置信息更新次数（更新十次后退出）：\n\n```bash\ntop -n 10\n```\n\n\n\n设置信息更新时间（更新周期为3秒）：\n\n```bash\ntop -d 3\n```\n\n\n\n显示指定的进程信息（显示进程号为 pid 的进程信息，CPU、内存占用率等）：\n\n```bash\ntop -p <pid>\n```\n\n\n\n实时显示 Linux 系统各个线程运行情况（你也可以在 top 运行时按“H”键将线程查看模式切换为开或关）：\n\n```bash\ntop -H\n```\n\n\n\n列出进程号为 PID 的进程创建的所有线程（也可以使用 `ps -T -p <pid>` 命令查看）：\n\n```bash\ntop -H -p <pid>\n```\n\n\n\n通过进程名（而不是 PID）列出该进程创建的所有线程：\n\n```bash\ntop -Hp $(pgrep -f <process_name>)\n```\n\n\n\n\n\n# Linux htop 命令 - 交互式进程查看器\n\n## 介绍\n\n**htop** 是 Linux 系统中的一个互动的进程查看器，可动态实时显示 Linux 进程的状态，依赖于 ncurses 库。\n\nhtop 的功能类似于 top 命令，但它更加人性化，允许用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。\n\n**安装**：\n\nhtop 命令由 htop 软件包提供，在 Debian/Ubuntu 系统上可以使用如下命令进行安装。\n\n```bash\nsudo apt install htop\n```\n\n\n\n**语法**：\n\n```bash\ntop -hv|-bcEHiOSs1 -d secs -n max -u|U user -p pid -o fld -w [cols]\n```\n\n\n\n**选项**：\n\n- `-C`, `--no-color`：使用单色配色方案。\n- `-d`, `--delay=DELAY`：设置更新之间的延迟，以十分之一秒为单位。\n- `-h`, `--help`：显示帮助信息。\n- `-s`, `--sort-key=COLUMN`：按 COLUMN 排序（尝试 --sort-key=help 列表）。\n- `-t`, `--tree`：默认显示树视图。\n- `-u`, `--user=USERNAME`：仅显示指定用户的进程。\n- `-p`, `--pid=PID,[,PID,PID...]`：仅显示给定的 PID。\n- `-v`, `--version`：打印版本信息。\n\n## 示例\n\n显示进程信息\n\n```bash\nhtop\n```\n\n\n\n交互界面如下：\n\n![img](./Image/Linux命令大全.assets/linux-htop-command.png)\n\n在上图中将输出的界面划分成了四个区域，其中：\n\n- 上左区：显示了 CPU、物理内存和交换分区的信息；\n- 上右区：显示了任务数量、平均负载和连接运行时间等信息；\n- 进程区域：显示出当前系统中的所有进程；\n- 操作提示区：显示了当前界面中 F1-F10 功能键中定义的快捷功能。\n\n**功能键说明**\n\n- `F1`：显示帮助信息；\n- `F2`：配置界面中的显示信息；\n- `F3`：进程搜索；\n- `F4`：进程过滤器；\n- `F5`：显示进程树；\n- `F6`：排序；\n- `F7`：减小 nice 值；\n- `F8`：增加 nice 值；\n- `F9`：杀掉指定进程；\n- `F10`：退出 htop。\n\n除了 F1-F10，htop 中还有很多有用的功能键：\n\n- 空格键：用于标记选中的进程，用于实现对多个进程同时操作；\n- `U`：取消所有选中的进程；\n- `s`：显示光标所在进程执行的系统调用；\n- `l`：显示光标所在进程的文件列表;\n- `I`：对排序的结果进行反转显示；\n- `a`：绑定进程到指定的 CPU；\n- `u`：显示指定用户的进程；\n- `M`：按照内存使用百分比排序，对应 MEM% 列；\n- `P`：按照 CPU 使用百分比排序，对应 CPU% 列；\n- `T`：按照进程运行的时间排序，对应 TIME+ 列；\n- `K`：隐藏内核线程；\n- `H`：隐藏用户线程；\n- `#`：快速定位光标到 PID 所指定的进程上。\n\n\n\n# Linux kill 命令 - 终止进程\n\n## 介绍\n\n**kill** 命令用于删除执行中的程序或任务。\n\nkill 的工作原理是将指定的信息发送至指定程序，预设的信息为 `SIGTERM(15)`，可将指定程序终止。若仍无法终止该程序，可使用 `SIGKILL(9)` 信息尝试强制删除程序。程序或任务的编号（PID）可利用 [ps](https://getiot.tech/linux-command/ps/) 或 [jobs](https://getiot.tech/linux-command/jobs/) 命令查看。\n\n**语法**：\n\n```bash\nkill [options] <pid> [...]\n```\n\n\n\n**选项**：\n\n- `-a`：当处理当前进程时，不限制命令名和进程号的对应关系。\n- `-l [signal]`：列出信号名称（若不加 `[signal]` 选项，则 `-l` 参数会列出全部的信号名称）。\n- `-p`：指定 kill 命令只打印相关进程的进程号，而不发送任何信号。\n- `-s <signal>`：指定要送出的信号（亦可采用 `-<signal>` 写法）。\n- `-u`：指定用户。\n\n**参数**：程序的 PID 或是 PGID，也可以是工作编号。\n\n## 示例\n\n列出所有可用信号：\n\n```bash\n$ kill -l\n 1) SIGHUP\t 2) SIGINT\t 3) SIGQUIT\t 4) SIGILL\t 5) SIGTRAP\n 6) SIGABRT\t 7) SIGBUS\t 8) SIGFPE\t 9) SIGKILL\t10) SIGUSR1\n11) SIGSEGV\t12) SIGUSR2\t13) SIGPIPE\t14) SIGALRM\t15) SIGTERM\n16) SIGSTKFLT\t17) SIGCHLD\t18) SIGCONT\t19) SIGSTOP\t20) SIGTSTP\n21) SIGTTIN\t22) SIGTTOU\t23) SIGURG\t24) SIGXCPU\t25) SIGXFSZ\n26) SIGVTALRM\t27) SIGPROF\t28) SIGWINCH\t29) SIGIO\t30) SIGPWR\n31) SIGSYS\t34) SIGRTMIN\t35) SIGRTMIN+1\t36) SIGRTMIN+2\t37) SIGRTMIN+3\n38) SIGRTMIN+4\t39) SIGRTMIN+5\t40) SIGRTMIN+6\t41) SIGRTMIN+7\t42) SIGRTMIN+8\n43) SIGRTMIN+9\t44) SIGRTMIN+10\t45) SIGRTMIN+11\t46) SIGRTMIN+12\t47) SIGRTMIN+13\n48) SIGRTMIN+14\t49) SIGRTMIN+15\t50) SIGRTMAX-14\t51) SIGRTMAX-13\t52) SIGRTMAX-12\n53) SIGRTMAX-11\t54) SIGRTMAX-10\t55) SIGRTMAX-9\t56) SIGRTMAX-8\t57) SIGRTMAX-7\n58) SIGRTMAX-6\t59) SIGRTMAX-5\t60) SIGRTMAX-4\t61) SIGRTMAX-3\t62) SIGRTMAX-2\n63) SIGRTMAX-1\t64) SIGRTMAX\n```\n\n\n\n常用的信号有：\n\n- 1 (HUP)：重新加载进程\n- 9 (KILL)：杀死一个进程\n- 15 (TERM)：正常停止一个进程\n\n杀死 PID 为 12345 的进程：\n\n```bash\n$ kill 12345\n```\n\n\n\n强制杀死 PID 为 12345 进程：\n\n```bash\n$ kill -KILL 12345\n```\n\n\n\n信号的指定可以使用 `-9`、`-SIGKILL` 或 `-KILL`，三种方式是等效的。\n\n杀死指定用户所有进程：\n\n```bash\n$ kill -9 $(ps -ef | grep guest) # 方法1：过滤出 guest 用户进程\n$ kill -u guest                  # 方法2\n```\n\n\n\n\n\n# Linux pkill 命令 - 根据名称终止进程\n\n## 介绍\n\n**pkill** 用于杀死一个进程，类似于 [killall](https://getiot.tech/linux-command/killall/) 命令。\n\n**语法**：\n\n```bash\n  pkill [选项]  name\n```\n\n\n\n**选项**：\n\n- `-o` 仅向找到的最小（起始）进程号发送信号\n- `-n` 仅向找到的最大（结束）进程号发送信号\n- `-P` 指定父进程号发送信号\n- `-g` 指定进程组\n- `-t` 指定开启进程的终端\n\n**参数**：进程名 name\n\n## 示例\n\n结束 php-fpm 进程：\n\n```bash\n$ pkill -9 php-fpm\n```\n\n\n\n\n\n# Linux killall 命令 - 终止指定名称的所有进程\n\n## 介绍\n\n**killall** 命令用于杀死指定名字的所有进程。与 [kill](https://getiot.tech/linux-command/kill/) 命令不同，killall 不需要事先查找进程 PID，直接对进程对名字进行操作，更加方便。\n\n**语法**：\n\n```bash\n  killall [选项]  name\n```\n\n\n\n**选项**：\n\n- `-e | --exact`：进程需要和名字完全相符\n- `-I | --ignore-case`：忽略大小写\n- `-g | --process-group`：结束进程组\n- `-i | --interactive`：结束之前询问\n- `-l | --list`：列出所有的信号名称\n- `-q | --quite`：进程没有结束时，不输出任何信息\n- `-r | --regexp`：将进程名模式解释为扩展的正则表达式。\n- `-s | --signal`：发送指定信号\n- `-u | --user`：结束指定用户的进程\n- `-v | --verbose`：显示详细执行过程\n- `-w | --wait`：等待所有的进程都结束\n- `-V |--version`：显示版本信息\n- `--help`：显示帮助信息\n\n**参数**：进程名 name\n\n## 示例\n\n结束所有的 php-fpm 进程：\n\n```bash\n$ killall -9 php-fpm\n```\n\n\n\n\n\n# Linux ipcs 命令 - 显示系统 IPC 资源信息\n\n## 介绍\n\n**ipcs** 命令用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。\n\n**语法**：\n\n```bash\n ipcs [resource ...] [output-format]\n ipcs [resource] -i <id>\n```\n\n\n\n**选项**：\n\n```bash\n -i, --id <id>  打印由 id 标识的资源的详细信息\n -h, --help     显示此帮助并退出\n -V, --version  输出版本信息并退出\n```\n\n\n\n**资源选项**：\n\n```bash\n -m, --shmems      共享内存段\n -q, --queues      消息队列\n -s, --semaphores  信号量\n -a, --all         全部(默认)\n```\n\n\n\n**输出格式**：\n\n```bash\n -t, --time        显示附加、脱离和更改时间\n -p, --pid         显示 PID 的创建者和最后操作\n -c, --creator     显示创建者和拥有者\n -l, --limits      显示资源限制\n -u, --summary     显示状态摘要\n     --human       以易读格式显示大小\n -b, --bytes       以字节数显示大小\n```\n\n\n\n## 示例\n\n显示所有的 IPC 设施：\n\n```bash\nipcs -a\n```\n\n\n\n显示所有的消息队列（Message Queue）：\n\n```bash\nipcs -q\n```\n\n\n\n显示所有的信号量：\n\n```bash\nipcs -s\n```\n\n\n\n显示所有的共享内存：\n\n```bash\nipcs -m\n```\n\n\n\n显示 IPC 设施的详细信息：\n\n```bash\nipcs -q -i <id>\n```\n\n\n\n提示\n\nid 对应 shmid、semid、msgid 等。`-q` 对应设施的类型（队列），查看信号量详细情况使用 `-s`，查看共享内存使用 `-m`。\n\n显示 IPC 设施（共享内存）的限制大小：\n\n```bash\nipcs -m -l\nipcs -s -l\nipcs -q -l\n```\n\n\n\n显示 IPC 设施的权限关系：\n\n```bash\nipcs -c\nipcs -m -c\nipcs -q -c\nipcs -s -c\n```\n\n\n\n显示最近访问过 IPC 设施的进程 ID：\n\n```bash\nipcs -p\nipcs -m -p\nipcs -q -p\n```\n\n\n\n显示 IPC 设施的最后操作时间：\n\n```bash\nipcs -t\nipcs -q -t\nipcs -m -t\nipcs -s -t\n```\n\n\n\n显示 IPC 设施的当前状态：\n\n```bash\nipcs -u \n```\n\n\n\n\n\n# Linux jobs 命令 - 列出当前作业\n\n## 介绍\n\n**jobs** 命令用于查看当前终端（tty）的任务列表及任务状态，包括后台运行的任务。\n\n该命令可以显示任务号及其对应的进程号。其中，任务号是以普通用户的角度进行的，而进程号则是从系统管理员的角度来看的。一个任务可以对应于一个或者多个进程号。\n\n在 Linux 系统中执行某些操作时候，有时需要将当前任务暂停调至后台（CTRL+Z），或有时需要将后台暂停的任务重启开启并调至前台，这一系列的操作将会使用到 [jobs](https://getiot.tech/linux-command/jobs/)、[bg](https://getiot.tech/linux-command/bg/) 和 [fg](https://getiot.tech/linux-command/fg/) 三个命令以及快捷键来完成。\n\n**语法**：\n\n```bash\njobs [选项] [参数]\n```\n\n\n\n**选项**：\n\n- `-l`：显示进程号\n- `-p`：仅任务对应的显示进程号\n- `-n`：显示任务状态的变化\n- `-r`：仅输出运行状态（running）的任务\n- `-s`：仅输出停止状态（stoped）的任务\n\n**参数**：指定要显示的任务识别号\n\n## 示例\n\n打开终端，此时任务列表为空，执行 jobs 不会有任何输出。假设当前目录下有一张 GetIoT.png 图片，执行如下命令将其打开，以创建一个任务。\n\n```bash\n$ eog GetIoT.png\n```\n\n\n\n该任务将占用当前终端，按 CTRL+Z 键暂停任务，查看当前任务列表：\n\n```bash\n$ jobs\n[1]+  已停止               eog GetIoT.png\n```\n\n\n\n加 `-l` 显示进程号：\n\n```bash\n$ jobs -l\n[1]+ 22702 停止                  eog GetIoT.png\n```\n\n\n\n输出信息的第1列表示任务编号，第2列表示任务所对应的进程号，第3列表示任务的运行状态，第4列表示启动任务的命令。\n\n此时任务进入处于停止状态，执行 bg 将任务从后台启动：\n\n```bash\n$ bg\n[1]+ eog GetIoT.png &\n```\n\n\n\n再次查看任务列表：\n\n```bash\n$ jobs -l\n[1]+ 22702 运行中               eog GetIoT.png &\n```\n\n\n\n执行 fg 将任务调到前台：\n\n```bash\n$ fg\neog GetIoT.png\n```\n\n\n\n按 CTRL+C 终止程序。\n\n\n\n# Linux bg 命令 - 将作业置于后台运行\n\n## 介绍\n\n**bg** 命令用于将作业放到后台运行，使前台可以执行其他任务。该命令的运行效果与在指令后面添加符号 `&` 的效果是相同的，都是将其放到系统后台执行。与 [fg](https://getiot.tech/linux-command/fg/) 命令一样，若任务列表中只有一个，则使用该命令时，可以省略任务号。\n\n提示：程序正在前台运行，可以使用 `Ctrl + Z` 把程序暂停，`Ctrl + C` 终止程序。\n\n## 示例\n\n参考 [jobs 使用示例](https://getiot.tech/linux-command/jobs/)\n\n\n\n# Linux fg 命令 - 将作业置于前台运行\n\n## 介绍\n\n**fg** 命令用于将后台任务（在后台运行的或者在后台挂起的任务）放到前台终端运行。与 [bg](https://getiot.tech/linux-command/bg/) 命令一样，若后台任务中只有一个，则使用该命令时，可以省略任务号。\n\n提示：程序正在前台运行，可以使用 `Ctrl + Z` 把程序暂停，`Ctrl + C` 终止程序。\n\n## 示例\n\n参考 [jobs 使用示例](https://getiot.tech/linux-command/jobs/)\n\n\n\n# Linux nohup 命令 - 后台运行程序\n\n## 介绍\n\n**nohup**（英文全拼：no hang up）命令用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。\n\n在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录的 nohup.out 文件不可写，输出重定向到 `$HOME/nohup.out` 文件中。\n\n**语法**：\n\n```bash\nnohup COMMAND [ARG]...\n```\n\n\n\n**参数**：\n\n- `COMMAND`：要执行的命令。\n- `Arg`：一些参数，可以指定输出文件。\n\n## 示例\n\n假设当前目录下有 getiot.sh 脚本文件，内容如下：\n\n```bash\n#!/bin/bash\n\nwhile [ 1 ]\ndo\n    echo \"getiot.tech\"\n    sleep 1\ndone\n\nexit 0\n```\n\n\n\n在后台执行当前目录下的 getiot.sh 脚本：\n\n```bash\n$ nohup ./getiot.sh &\n```\n\n\n\n在终端如果看到以下输出说明运行成功：\n\n```bash\nappending output to nohup.out\n```\n\n\n\n此时，会在当前目录看到生成了 nohup.out 文件，每隔一秒会输出一行 \"getiot.tech\" 到 nohup.out 文件。\n\n在后台执行当前目录下的 getiot.sh 脚本，并重定向输入到 getiot.log 文件：\n\n```bash\nnohup ./getiot.sh > getiot.log 2>&1 &\n```\n\n\n\n**2>&1** 解释：将标准错误 2 重定向到标准输出 &1 ，标准输出 &1 再被重定向输入到 getiot.log 文件中。\n\n在 Linux 系统中，执行一个 shell 命令行时通常会自动打开三个标准文件：\n\n- 0 – stdin（standard input，标准输入）\n- 1 – stdout（standard output，标准输出）\n- 2 – stderr（standard error，标准错误输出）\n\n如果需要终止运行程序，可以使用 [ps](https://getiot.tech/linux-command/ps/) 或 [jobs](https://getiot.tech/linux-command/jobs/) 命令查找到 nohup 运行命令的 PID，然后使用 [kill](https://getiot.tech/linux-command/kill/) 命令来删除即可。\n\n\n\n# Linux lsof 命令 - 列出打开的文件和进程\n\n## 介绍\n\n**lsof**（英文全拼：list open files）命令用于查看进程开打的文件、打开文件的进程、进程打开的端口（TCP、UDP），甚至可用于找回/恢复删除的文件。\n\nlsof 是十分方便的系统监视工具，因为 lsof 命令需要访问核心内存和各种文件，所以需要 root 权限才能使用所有功能。\n\n在 Linux 环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议（TCP）和用户数据报协议（UDP）套接字等，系统在后台都为其分配了一个文件描述符，该文件描述符为应用程序与操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过 lsof 工具能够查看这个列表，对系统监测以及排错有很大帮助。\n\n**语法**：\n\n```bash\nlsof [options] [names]\n```\n\n\n\n**选项**：\n\n- `-a` ：列出打开文件存在的进程。\n- `-c <进程名>` ：列出指定进程所打开的文件。\n- `-g` ：列出 GID 号进程详情。\n- `-d <文件号>` ：列出占用该文件号的进程。\n- `+d <目录>` ：列出目录下被打开的文件。\n- `+D <目录>` ：递归列出目录下被打开的文件。\n- `-n <目录>` ：列出使用 NFS 的文件。\n- `-i <条件>` ：列出符合条件的进程。\n- `-p <进程号>` ：列出指定进程号所打开的文件。\n- `-u` ：列出 UID 号进程详情。\n- `-h` ：显示帮助信息。\n- `-v` ：显示版本信息。\n\n## 示例\n\n直接输入 lsof 查看文件的进程信息\n\n```bash\nlsof\n```\n\n\n\n列出 GID 号进程详情\n\n```bash\nlsof -g\n```\n\n\n\n列出目录下被打开的文件\n\n```bash\nlsof +d /root\n```\n\n\n\n递归列出目录下被打开的文件\n\n```bash\nlsof +D /home/getiot\n```\n\n\n\n列出使用 NFS 的文件\n\n```bash\nlsof -n /srv/nfs/\n```\n\n\n\n\n\n# Linux nice 命令 - 设置进程优先级\n\n## 介绍\n\n**nice** 命令用于指定 Linux 系统进程的调度优先级，即以更改过的优先序来执行程序。如果未指定程序，则会印出目前的排程优先序。nice 值的范围是 [-20, 19]，其中 -20 是最高优先级，19 是最低优先级。Linux 进程的默认 nice 值为 0。\n\n优先级（priority）是操作系统用来决定 CPU 调度的一个重要参数，Linux 使用 Round-Robin 算法来处理 CPU 调度，优先级越高，所可能获得的 CPU 时间就越多。\n\n相关命令：[renice](https://getiot.tech/linux-command/renice/), [chrt](https://getiot.tech/linux-command/chrt/)\n\n**语法**：\n\n```bash\nnice [OPTION] [COMMAND [ARG]...]\n```\n\n\n\n**选项**：\n\n- `-n`, `--adjustment=N`：在优先级数值上加上数字 N（默认为 10）。\n- `--help`：显示此帮助信息并退出。\n- `--version`：显示版本信息并退出。\n\n## 示例\n\n以指定进程优先级启动 vim 程序\n\n```bash\nnice -n 19 vim\n```\n\n\n\n通过 ps 命令查看 vim 进程的 nice 值\n\n```bash\n$ ps -efl\nF S UID          PID    PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD\n...\n0 S rudy     2768147 1831616  0  99  19 -  6985 do_sel 17:20 pts/14   00:00:00 vim\n```\n\n\n\n字段说明：\n\n- `NI` 是优先值，是用户层面的概念；\n- `PR` 是进程的实际优先级，是给内核（kernel）看（用）的。\n\n\n\n# Linux renice 命令 - 改变运行中进程的优先级\n\n## 介绍\n\n**renice** 命令用于修改 Linux 系统中正在运行的进程的调度优先级。该命令默认是以进程 PID 指定程序调整其优先权，你也可以指定程序群组或用户名称调整优先权等级，并修改所有隶属于该程序群组或用户的程序的优先级。\n\n注意：只有系统管理员可以改变其他用户程序的优先权，也仅有系统管理员可以设置负数等级。\n\n相关命令：[nice](https://getiot.tech/linux-command/nice/), [chrt](https://getiot.tech/linux-command/chrt/)\n\n**语法**：\n\n```bash\nrenice [-n] priority [-g|-p|-u] identifier...\n```\n\n\n\n**选项**：\n\n- `-n`, `--priority <数字>`：指定 nice 增量。\n- `-p`, `--pid <id>`：将参数解释为进程 ID（默认）。\n- `-g`, `--pgrp <id>`：将参数解释为进程组 ID。\n- `-u`, `--user <name>|<id>`：将参数解释为 用户名 或 用户 ID。\n- `-h`, `--help`：显示此帮助信息并退出。\n- `-V`, `--version`：显示版本信息并退出。\n\n## 示例\n\n修改指定进程（使用 PID 号）的调度优先级为 5\n\n```bash\nrenice 5 -p <PID>\n```\n\n\n\n将指定进程（使用 PID 号）的调度优先级加 1\n\n```bash\nrenice +1 -p <PID>\n```\n\n\n\n\n\n# Linux chrt 命令 - 查看或设置进程的调度策略\n\n## 介绍\n\n**chrt**（英文全拼：change real-time）是 Linux 系统中操作进程/线程实时属性的命令，可用于查看和设置进程/线程的调度策略。\n\nLinux 内核有三种常见调度策略：\n\n- `SCHED_OTHER` 分时调度策略（默认调度策略）；\n- `SCHED_FIFO` 实时调度策略，先到先服务；\n- `SCHED_RR` 实时调度策略，时间片轮转（RR 是 round-robin 的缩写）。\n\n在 Linux 系统中，所有优先级值在 0-99 范围内的，都是实时进程。因此，0-99 优先级也被称为实时进程优先级，而 100-139 范围内的则是非实时进程。\n\n相关命令：[nice](https://getiot.tech/linux-command/nice/), [renice](https://getiot.tech/linux-command/renice/)\n\n**语法**：\n\n```bash\nchrt [options] [prio] [pid | command [arg]...]\n```\n\n\n\n**选项**：\n\n- `-a`, `--all-tasks`：设置或检索给定 PID 的所有任务（线程）的调度属性。\n- `-m`, `--max`：显示最小和最大有效优先级，然后退出。\n- `-p`, `--pid`：操作一个已存在的 PID，不启动一个新的任务。\n- `-v`, `--verbose`：显示详细状态信息。\n- `-h`, `--help`：显示帮助信息。\n- `-V`, `--version`：打印版本信息。\n\n**调度策略**：\n\n- `-o`, `--other`：设置策略调度策略为 `SCHED_OTHER`。\n- `-f`, `--fifo`：设置调度策略为 `SCHED_FIFO`。\n- `-r`, `--rr`：设置调度策略为 `SCHED_RR`（当未指定策略时，默认设置为该策略）。\n- `-b`, `--batch`：设置调度策略为 `SCHED_BATCH`（自 2.6.16 起支持），优先级参数必须设置为零。\n- `-i`, `--idle`：设置调度策略为 `SCHED_IDLE`（自 2.6.23 起支持），优先级参数必须设置为零。\n- `-d`, `--deadline`：设置调度策略为 `SCHED_DEADLINE`（自 3.14 起支持），优先级参数必须设置为零。\n\n**调度选项**：\n\n- `-T`, `--sched-runtime <nanoseconds>`：指定 `SCHED_DEADLINE` 策略的运行时参数。\n- `-P`, `--sched-period <nanoseconds>`：指定 `SCHED_DEADLINE` 策略的周期参数。\n- `-D`, `--sched-deadline <nanoseconds>`：指定 `SCHED_DEADLINE` 策略的截止时间参数。\n- `-R`, `--reset-on-fork`：将 `SCHED_RESET_ON_FORK` 标志添加到 `SCHED_FIFO` 或 `SCHED_RR` 调度策略（自 2.6.31 起支持）。\n\n## 示例\n\n查看 Linux 系统最小和最大的优先级：\n\n```bash\n$ chrt -m\nSCHED_OTHER 最小/最大优先级\t: 0/0\nSCHED_FIFO 最小/最大优先级\t: 1/99\nSCHED_RR 最小/最大优先级\t: 1/99\nSCHED_BATCH 最小/最大优先级\t: 0/0\nSCHED_IDLE 最小/最大优先级\t: 0/0\nSCHED_DEADLINE 最小/最大优先级\t: 0/0\n```\n\n\n\n查看 PID 为 137619 的进程调度信息：\n\n```bash\n$ chrt -p 137619\npid 137619 当前的调度策略︰ SCHED_OTHER\npid 137619 的当前调度优先级：0\n```\n\n\n\n将 PID 为 137619 的进程设置为 `SCHED_RR` 实时调度，且优先级为 30：\n\n```bash\n$ chrt -r -p 30 137619\n```\n\n\n\n将 PID 为 137619 的进程设置为默认的 `SCHED_OTHER` 调度策略：\n\n```bash\n$ chrt -o -p 0 137619\n```\n\n\n\n借助 [`pidof`](https://getiot.tech/linux-command/pidof/) 和 [`xargs`](https://getiot.tech/linux-command/xargs/) 命令可以直接使用进程名称查询 PID，并传递给 chrt 命令。例如将 rviz2 进程优先级设置为 10：\n\n```bash\n$ pidof rviz2 | sudo xargs chrt -r -p 10\n```\n\n\n\n\n\n# Linux taskset 命令 - 设置进程的 CPU 亲和性\n\n## 介绍\n\n**taskset**（英文全拼：task set）命令用于绑定 Linux 进程与 CPU 核心。一般情况下，一个程序启动后，其进程会在 CPU 核心之间切换执行，在系统的调度下，每个进程平均公平地分配到一定量的计算资源。有时候，运维人员想将某个进程与指定 CPU 核心进行绑定操作，以提高性能，这就需要用到 taskset 命令。\n\n**语法**：\n\n```bash\ntaskset [options] mask command [argument...]\ntaskset [options] -p [mask] pid\n```\n\n\n\n**选项**：\n\n- `-a`, `--all-tasks`：设置或检索给定 PID 的所有任务（线程）的 CPU 关联性。\n- `-c`, `--cpu-list`：将掩码解释为处理器的数字列表而不是位掩码。数字以逗号分隔，并且可能包含范围。例如：0,5,8-11。\n- `-p`, `--pid`：对现有 PID 进行操作并且不启动新任务。\n- `-V`, `--version`：显示版本信息并退出。\n- `-h`, `--help`：显示帮助信息并退出。\n\n## 示例\n\n查询进程 7589 当前使用的 CPU 核心信息：\n\n```bash\n$ taskset -pc 7589\npid 7589's current affinity list: 0-7\n```\n\n\n\n设置进程 7589 只可运行在编号为 7 的 CPU 核心之上：\n\n```bash\n$ taskset -pc 7 7589 \npid 7589's current affinity list: 0-7\npid 7589's new affinity list: 7\n```\n\n\n\n设置进程 7589 只可运行在编号为 6 和 7 的 CPU 核心之上：\n\n```bash\n$ taskset -pc 6-7 7589 \npid 7589's current affinity list: 0-7\npid 7589's new affinity list: 6,7\n```\n\n\n\n启动 simple_viewer 程序并限定其只能在 CPU 核心 0、1、2、3 上运行：\n\n```bash\ntaskset -c 0-3 ./simple_viewer -type A1 -pcap test.pcap\n```\n\n\n\n启动后可借助 [pgrep](https://getiot.tech/linux-command/pgrep/) 命令查看该进程 ID，查询当前使用的 CPU 核心信息：\n\n```bash\ntaskset -pc $(pgrep simple_viewer)\n```\n\n\n\n\n\n# Linux pidof 命令 - 获取进程的 PID\n\n## 介绍\n\n**pidof** 命令用于查找 Linux 系统中指定名称的进程的进程号（PID），功能类似 [pgrep](https://getiot.tech/linux-command/pgrep/) 和 [ps](https://getiot.tech/linux-command/ps/)。\n\n**语法**：\n\n```bash\npidof [options] <program-name>\n```\n\n\n\n**选项**：\n\n- `-c`：仅显示具有相同“root”目录的进程号。\n- `-d <sep>`：使用提供的字符作为输出分隔符。\n- `-n`：避免在网络共享上使用 stat 系统函数。\n- `-o <pid>`：指定不显示的进程号。\n- `-q`：安静模式，不显示输出。\n- `-s`：仅返回一个进程号。\n- `-x`：显示由脚本开启的进程。\n- `-z`：列出僵尸进程和 I/O 等待进程。可能会导致 pidof 挂起。\n- `-h`：显示帮助信息。\n\n**参数**：\n\n- `program-name`：指定要查找的进程名称。\n\n## 示例\n\n查询 apache2 进程的 PID：\n\n```bash\n$ pidof apache2 \n232746 232745 232744 232743 232742 2157\n```\n\n\n\n以逗号分隔：\n\n```bash\n$ pidof -d ','  apache2 \n232746,232745,232744,232743,232742,2157\n```\n\n\n\n只返回一个进程号：\n\n```bash\n$ pidof -s apache2 \n232746\n```\n\n\n\n\n\n# Linux pgrep 命令 - 根据名称查找进程 ID\n\n## 介绍\n\n**pgrep**（英文全拼：process global regular expression print）是 Linux 系统中用于检索进程 PID 的命令。与 [pidof](https://getiot.tech/linux-command/pidof/) 命令必须准确输入服务名称不同，pgrep 命令通过正则表达式进行检索，因此用户只需要输入服务名称中的一部分即可进行搜索操作，对于不记得全名的服务程序特别好用。\n\npgrep 常用于通过进程名快速定位正在运行的进程，尤其在脚本或命令行中很有用。\n\n**语法**：\n\n```bash\npgrep [options] <pattern>\n```\n\n\n\n说明：*pattern* 指定用于匹配进程名称或命令行的扩展正则表达式。简单地，你可以把它当作进程名。\n\n**选项**：\n\n- `-d, --delimiter <string>`：指定输出分隔符。\n- `-l, --list-name`：显示 PID 和进程名。\n- `-a, --list-full`：显示 PID 和完整的命令行信息。\n- `-v, --inverse`：反向匹配。\n- `-w, --lightweight`：显示所有线程的 TID。\n- `-c, --count`：显示匹配进程的数量。\n- `-f, --full`：使用完整的进程名称来匹配。\n- `-g, --pgroup <PGID,...>`：匹配列出的进程组 ID。\n- `-G, --group <GID,...>`：匹配真实的组 ID。\n- `-i, --ignore-case`：不区分大小写匹配。\n- `-n, --newest`：仅显示最新的匹配进程。\n- `-o, --oldest`：仅显示最老的匹配进程。\n- `-P, --parent <PPID,...>`：仅匹配给定父进程的子进程。\n- `-s, --session <SID,...>`：匹配会话 ID。\n- `-t, --terminal <tty,...>`：通过控制终端进行匹配。\n- `-u, --euid <ID,...>`：通过有效 ID（EUID）进行匹配，即仅显示指定用户运行的进程。\n- `-U, --uid <ID,...>`：根据真实 ID（UID）进行匹配。\n- `-x, --exact`：与命令名称完全匹配。\n- `-F, --pidfile <file>`：从文件中读取 PID。\n- `-L, --logpidfile`：如果 PID 文件未锁定则失败。\n- `-r, --runstates <state>`：匹配运行状态 [D,S,Z,...]。\n- `--ns <PID>`：匹配与 `<pid>` 属于同一命名空间的进程。\n- `--nslist <ns,...>`：列出 `--ns` 选项将考虑哪些命名空间，可用命名空间包括 ipc、mnt、net、pid、user、uts。\n- `-h, --help`：显示帮助信息。\n- `-V, --version`：显示程序版本。\n\n## 示例\n\n显示所有包含 `firefox` 进程名的进程 PID：\n\n```bash\npgrep firefox\n```\n\n\n\n显示所有包含 `firefox` 进程名的进程 PID 和进程名：\n\n```bash\npgrep -l firefox\n```\n\n\n\n显示所有包含 `firefox` 进程名的进程 PID 和完整的命令行：\n\n```bash\npgrep -a firefox\n```\n\n\n\n仅显示指定用户运行的包含 `firefox` 进程名的进程 PID：\n\n```bash\npgrep -u rudy firefox\n```\n\n\n\n\n\n# Linux xargs 命令 - 构建并执行命令行参数\n\n## 介绍\n\n**xargs**（英文全拼： eXtended ARGuments）是 Linux 系统给命令传递参数的一个过滤器，也是组合多个命令的一个工具，一般是和管道一起使用。\n\n简单来说，使用 xargs 命令能够捕获一个命令的输出，然后传递给另外一个命令。因此，通过它就可以将多个命令串联起来，这在 Linux 命令行中非常重要，有着独特的作用。\n\n在输入方面，xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。\n\n**语法**：\n\n```bash\nxargs [options] [command [initial-arguments]]\nsomecommand | xargs [options] [command [initial-arguments]]\n```\n\n\n\n**选项**：\n\n- `-a file`：从文件中读入，而不是从标准输入（stdin）读入。\n- `-e eof-str`：注意有的时候可能会是 `-E`，`eof-str` 必须是一个以空格分隔的标志，当 xargs 分析到含有 `eof-str` 这个标志的时候就停止。\n- `-p, --interactive`：当每次执行的时候都要询问用户，输入 y 或 Y 后才执行。\n- `-n max-args`：每个命令行最多使用 `max-args` 个参数。\n- `-t, --verbose`：表示先打印命令，然后再执行。\n- `-I replace-str`：将初始参数中出现的 `replace-str` 替换为从标准输入读取的名称。\n- `-i`：同 `-I`。\n- `-r, --no-run-if-empty`：当 xargs 的输入为空的时候则停止 xargs，不用再去执行了。\n- `-s max-chars`：命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。\n- `-L max-lines`：从标准输入一次读取 `max-lines` 行送给 command 命令。\n- `-l`：同 `-L`。\n- `-d delim`：分隔符，默认的 xargs 分隔符是回车，argument 的分隔符是空格，这里修改的是 xargs 的分隔符。\n- `-x, --exit`：如果超出大小（请参阅 `-s` 选项），则退出。\n- `-P max-procs`：一次最多运行 `max-procs` 个进程； 默认值为 1。如果设为 0，xargs 将一次运行尽可能多的进程。\n\n## 示例\n\n大多数时候，xargs 命令都是和管道一起使用的。但是，它也可以单独使用。例如：\n\n```bash\n$ xargs\nhello (Ctrl + D)\nhello\n```\n\n\n\n由于 xargs 后面的命令默认是 [`echo`](https://getiot.tech/linux-command/echo/)，因此当输入 xargs 按下回车以后，命令行就会等待用户输入，作为标准输入。你可以输入任意内容，然后按下 `Ctrl + D` 键结束，此时 echo 命令就会把前面的输入打印出来。\n\n当然，单独使用时 xargs 后面可以带上其他命令，例如：\n\n```bash\n$ xargs find -name\n*.md\n```\n\n\n\n当输入命令 `xargs find -name` 以后，命令行会等待用户输入所要搜索的文件。此时输入 `*.md`，表示搜索当前目录下的所有 Markdown 文件，然后按下 `Ctrl + D` 键结束输入。此时会输出所有 .md 文件，该命令相当执行 `find -name *.md`。\n\n下面再看使用 xargs 和管道打印 Hello World（将管道左侧的标准输入，转为命令行参数，传递给 echo 命令）：\n\n```bash\necho \"hello world\" | xargs echo\n```\n\n\n\n使用 xargs 和管道创建目录（等效于 `mkdir one two three`）：\n\n```bash\necho \"one two three\" | xargs mkdir\n```\n\n\n\n\n\n# Linux aplay 命令 - 播放音频文件\n\n## 介绍\n\n**aplay** 是 Linux 系统中用于播放音频文件的命令行工具。它是 ALSA（Advanced Linux Sound Architecture）项目的一部分，用于与音频设备进行交互。\n\naplay 支持大多数音频文件格式，如 WAV、MP3、OGG 等。理论上，只要有相应的 ALSA 插件支持就可以播放。\n\n**语法**：\n\n```bash\naplay [options] [filename [filename]] ...\n```\n\n\n\n**选项**：\n\n- `-l, --list-devices`：列出所有声卡和数字音频设备。\n- `-L, --list-pcms`：列出所有 PCM 设备名称。\n- `-D, --device=NAME`：按名称选择 PCM 设备。\n- `-q, --quiet`：安静模式。\n- `-t, --file-type TYPE`：指定文件类型（如 voc、wav、raw 或 au）。\n- `-c, --channels=#`：指定音频文件的通道数。\n- `-f, --format=FORMAT`：指定音频文件的采样格式（不区分大小写）。\n- `-r, --rate=#`：指定音频文件的采样率。\n- `-d, --duration=#`：`#` 秒后中断。\n- `-s, --samples=#`：每个通道采样 `#` 次后中断。\n- `-v, --verbose`：显示 PCM 结构和设置（累计）。\n- `-i, --interactive`：允许来自 stdin 的交互操作。\n- `-h, --help`：显示帮助信息。\n- `--version`： 显示版本信息。\n\n备注\n\n支持的采样格式有：`S8` `U8` `S16_LE` `S16_BE` `U16_LE` `U16_BE` `S24_LE` `S24_BE` `U24_LE` `U24_BE` `S32_LE` `S32_BE` `U32_LE` `U32_BE` `FLOAT_LE` `FLOAT_BE` `FLOAT64_LE` `FLOAT64_BE` `IEC958_SUBFRAME_LE` `IEC958_SUBFRAME_BE` `MU_LAW` `A_LAW` `IMA_ADPCM` `MPEG` `GSM` `SPECIAL` `S24_3LE` `S24_3BE` `U24_3LE` `U24_3BE` `S20_3LE` `S20_3BE` `U20_3LE` `U20_3BE` `S18_3LE` `S18_3BE` `U18_3LE`。\n\n需要注意的是，并非所有硬件都完全支持这些格式。\n\n此外，一些常用的格式有快捷方式：\n\n- `-f cd`（16 bit little endian, 44100, stereo）等效于 `-f S16_LE -c2 -r44100`\n- `-f cdr`（16 bit big endian, 44100, stereo）等效于 `-f S16_BE -c2 -f44100`\n- `-f dat`（16 bit little endian, 48000, stereo）等效于 `-f S16_LE -c2 -r48000`\n\n如果没有指定采样格式，默认使用 `U8`。\n\n## 示例\n\n播放名为 sample.wav 的音频文件：\n\n```bash\naplay sample.wav\n```\n\n\n\n指定使用硬件设备 `hw:0,0` 进行播放：\n\n```bash\naplay -D hw:0,0 sample.wav\n```\n\n\n\n指定音频文件的格式为 CD 质量（16位，立体声），通道数为 2，采样率为 44100 Hz：\n\n```bash\naplay -f cd -c 2 -r 44100 sample.wav\n```\n\n\n\n使用原始文件类型进行播放，并指定采样率、通道数和数据格式：\n\n```bash\naplay -t raw -r 44100 -c 2 -f S16_LE sample.raw\n```\n\n\n\n从标准输入读取数据进行播放：\n\n```bash\ncat sample.wav | aplay -\n```\n\n\n\n\n\n# Linux arecord 命令 - 录制音频文件\n\n## 介绍\n\n**arecord** 是 Linux 系统中用于录制音频文件的命令行工具，它可以通过 ALSA 驱动从音频输入设备录制音频，并保存为音频文件。arecord 是 ALSA（Advanced Linux Sound Architecture）项目的一部分。\n\narecord 支持大多数音频文件格式，如 WAV、MP3、OGG 等，录制完成后可以将录音保存为相应格式。arecord 还支持基本的录音效果，如混响等。\n\n**语法**：\n\n```bash\narecord [options] [filename]\n```\n\n\n\n**选项**：\n\n- `-l, --list-devices`：列出所有声卡和数字音频设备。\n- `-L, --list-pcms`：列出所有 PCM 设备名称。\n- `-D, --device=NAME`：按名称选择 PCM 设备。\n- `-q, --quiet`：安静模式。\n- `-t, --file-type TYPE`：指定文件类型（如 voc、wav、raw 或 au）。\n- `-c, --channels=#`：指定音频文件的通道数。\n- `-f, --format=FORMAT`：指定音频文件的采样格式（不区分大小写）。\n- `-r, --rate=#`：指定音频文件的采样率。\n- `-d, --duration=#`：`#` 秒后中断。\n- `-s, --samples=#`：每个通道采样 `#` 次后中断。\n- `-v, --verbose`：显示 PCM 结构和设置（累计）。\n- `-i, --interactive`：允许来自 stdin 的交互操作。\n- `-h, --help`：显示帮助信息。\n- `--version`： 显示版本信息。\n\n## 示例\n\n录制 wav 格式音频，输入设备为 `hw:0.0`，录制时间为 5 秒，采样率为 44100Hz（CD 音质），保存为 sample.wav：\n\n```bash\narecord -D hw:0.0 -d 5 -r 44100 -f cd sample.wav\n```\n\n\n\n\n\n# Linux amixer 命令 - ALSA 音频控制\n\n## 介绍\n\n**amixer** 是 Linux 系统中的一个命令行工具，用于调整音频设置，包括音量、音频输入和输出设备等。它是 ALSA（Advanced Linux Sound Architecture）项目的一部分。\n\n**语法**：\n\n```bash\namixer [-option] [cmd]\n```\n\n\n\n**选项**：\n\n- `-c`, `--card N` ：选择声卡卡号。\n- `-D`, `--device N` ：选择声卡设备，默认为 'default'。\n- `-d`, `--debug` ：调试模式。\n- `-n`, `--nocheck` ：不执行范围检查。\n- `-q`, `--quiet` ：安静模式。\n- `-i`, `--inactive` ：也显示不活动的控件。\n- `-a`, `--abstract L` ：选择抽象级别（none 或 basic）。\n- `-s`, `--stdin` ：从标准输入顺序读取和执行命令。\n- `-h`, `--help` ：显示帮助信息。\n- `-v`, `--version` ：打印版本信息。\n\n**命令**：\n\n- `scontrols` ：显示所有混音器简单控件。\n- `scontents` ：显示所有混音器简单控件的内容（默认命令）。\n- `sset sID P` ：为一个混音器简单控件设置内容。\n- `sget sID` ：获取一个混音器简单控件的内容。\n- `controls` ：显示指定声卡的所有控件。\n- `contents` ：显示指定声卡的所有控件的内容。\n- `cset cID P` ：为一个控件设置控件内容。set control contents for one control\n- `cget cID` ：获取一个控件的控件内容。\n\n## 示例\n\n列出可用的音频控制元素：\n\n```bash\namixer controls\n```\n\n\n\n获取 `Master` 通道的音量信息（显示当前音量）：\n\n```bash\namixer sget Master\n```\n\n\n\n将 `Master` 通道的音量设置为最大值：\n\n```bash\namixer sset Master 100%\n```\n\n\n\n调整 PCM 通道的音量（设置为 80%）：\n\n```bash\namixer sset PCM 80%\n```\n\n\n\n获取 PCM 通道的音量：\n\n```bash\namixer sget PCM\n```\n\n\n\n切换 `Master` 通道的静音状态（静音/取消静音）：\n\n```bash\namixer sset Master toggle\n```\n\n\n\n设置 PCM 通道的控制参数（设置 `numid` 为 3 的控制参数为 2）：\n\n```bash\namixer cset numid=3 2\n```\n\n\n\n获取 PCM 通道的控制参数（获取 `numid` 为 3 的控制参数）：\n\n```bash\namixer cget numid=3\n```\n\n\n\n指定音频卡设备为 `hw:0`，并将 `Master` 通道的音量设置为 50%：\n\n```bash\namixer -D hw:0 sset Master 50%\n```\n\n\n\n\n\n# Linux alsamixer 命令 - ALSA 混音器控制\n\n## 介绍\n\n**alsamixer** 是 Linux 系统中的一个命令行工具，用于调整 ALSA（Advanced Linux Sound Architecture）音频设置，例如调整音频设备的音量、通道、输入输出等参数。和 [amixer](https://getiot.tech/linux-command/amixer/) 不同，alsamixer 提供一个交互式的文本界面。\n\n**语法**：\n\n```bash\nalsamixer [options]\n```\n\n\n\n**选项**：\n\n- `-h`, `--help` ：显示帮助信息。\n- `-c, --card <card number or identification>`：如果你有多个声卡，请选择要使用的声卡。声卡编号从 0（默认）开始。\n- `-D, --device <device identification>`：选择要控制的混音器设备（mixer device）。\n- `-V, --view <mode>`：选择起始视图模式，播放（playback）、捕捉（capture）或全部（all）。\n- `-g, --no-color`：切换颜色的使用。\n\n**交互操作**：\n\n- 左右箭头键：选择不同的控制元素。\n- 上下箭头键：调整所选控制元素的值。\n- M 键：静音/取消静音。\n- Esc 键：退出 alsamixer。\n\n## 示例\n\n启动 alsamixer 程序：\n\n```bash\nalsamixer\n```\n\n\n\n可以看到类似如下界面：\n\n![img](./Image/Linux命令大全.assets/alsamixer-screenshot.png)\n\n","tags":["protected","Linux"],"categories":["Linux"]},{"title":"windows环境下使用dhcpsrv实现dhcp服务器","url":"/2025/05/04/windows环境下使用dhcpsrv实现dhcp服务器/","content":"\n起因是一个很奇葩的需求：乙方要远程升级仪器，用TeamViewer远程控制并ssh到仪器，但仪器内部IP地址没有写死，靠DHCP服务器获取。那么就要在PC建立DHCP服务器，用网线连接仪器，然后才能看到仪器分配的IP，从而进行连接。\n网上搜了一下dhcpsrv是一个很好的帮助建立DHCP服务的软件。官网：\n\n```bash\nhttp://www.dhcpserver.de/cms/\n```\n\n最新版本需要donate才能下载，下载以前的版本即可。\n首先右键“我的电脑”，选择“管理”，左边选择“服务”，查看DHCP Server并未运行。\n\n![img](./Image/windows环境下使用dhcpsrv实现dhcp服务器.assets/1750227-20191018144939807-1390641097.gif)\n\n运行dhcpwiz.exe，下一步。\n\n![img](./Image/windows环境下使用dhcpsrv实现dhcp服务器.assets/1750227-20191018145146803-506389991.gif)\n\n选择你需要连接的以太网口，把其IP作为DHCP服务器的IP，下一步。\n\n![img](./Image/windows环境下使用dhcpsrv实现dhcp服务器.assets/1750227-20191018145552335-1641190559.gif)\n\n我们只是把PC当作DHCP服务器，并不要设置DNS，什么都不做，下一步。\n\n![img](./Image/windows环境下使用dhcpsrv实现dhcp服务器.assets/1750227-20191018145804625-2095407898.gif)\n\n选择可分配的IP池，为了更容易ping到仪器（一开始不知道分配的IP可查- -），我们选择在本机网段内只分配2个IP给仪器（101和102）。其它不需要设置，下一步。\n\n![img](./Image/windows环境下使用dhcpsrv实现dhcp服务器.assets/1750227-20191018150136868-398680594.jpg)\n\n打勾并把我们前面的配置写到ini\n\n![img](./Image/windows环境下使用dhcpsrv实现dhcp服务器.assets/1750227-20191018151104390-137974539.jpg)\n\n查看解压文件夹里面的dhcpsrv.ini，下一步。\n\n![img](./Image/windows环境下使用dhcpsrv实现dhcp服务器.assets/1750227-20191018151454507-1215037343.jpg)\n\n这里打开和在系统服务里打开是一样的，主要是生成的ini文件很重要！我们直接点击“完成”。\n\n![img](./Image/windows环境下使用dhcpsrv实现dhcp服务器.assets/1750227-20191018151704630-2098944234.jpg)\n\n在服务管理里面，右键启动DHCP服务。看到服务正在运行。\n\n![img](./Image/windows环境下使用dhcpsrv实现dhcp服务器.assets/1750227-20191018152251148-703649340.jpg)\n\n用网线插上仪器。查看dhcpsrv.ini，此时在最下方会多出几行表明IP分配成功，并会显示已分配的IP。如果这里不成功，请看最后！\n\n![img](./Image/windows环境下使用dhcpsrv实现dhcp服务器.assets/1750227-20191018152841889-1593944219.jpg)\n\nwim+R+cmd打开终端，可以ping通仪器。\n\n![img](./Image/windows环境下使用dhcpsrv实现dhcp服务器.assets/1750227-20191018153228342-924918446.jpg)\n\n好了，到这里对方就可以远程访问仪器了~\n\n遇到的问题：\n一开始在启动DHCP服务后，我们一直无法ping通仪器，最后发现要关闭主机上的防火墙\n\n![img](./Image/windows环境下使用dhcpsrv实现dhcp服务器.assets/1750227-20191018153444863-1676561888.jpg)\n\n![img](./Image/windows环境下使用dhcpsrv实现dhcp服务器.assets/1750227-20191018153455934-1836440117.jpg)\n\n如果连接的也是windows电脑，对方的防火墙也要关闭！","tags":["protected","Windows","DHCP"],"categories":["教程"]},{"title":"Armbian系统使用RNDIS协议进行上网","url":"/2025/05/04/Armbian系统使用RNDIS协议进行上网/","content":"\n 在 Armbian 上通过 RNDIS 协议上网，通常是通过将一个支持 RNDIS 的设备（例如手机或其他设备）连接到树莓派或其他 ARM 设备上，使用 USB 网络共享功能。这是通过 USB 数据线将设备与 Armbian 系统连接，并通过 RNDIS (Remote Network Driver Interface Specification) 协议来实现网络共享。下面是设置的步骤：\n\n### 1. 确保 Armbian 系统已经支持 RNDIS 协议\n\n大多数 Armbian 系统都已经包含了 RNDIS 支持，但如果没有，您可能需要手动加载相关的模块。首先，可以检查是否加载了 `cdc_ether` 模块，它是支持 RNDIS 协议的驱动模块。\n\n可以运行以下命令来检查是否加载了模块：\n\n```\nlsmod | grep cdc_ether\n```\n\n如果没有找到，您可以通过以下命令加载该模块：\n\n```\nsudo modprobe cdc_ether\n```\n\n### 2. 连接设备并启用 USB 网络共享\n\n如果你想通过手机共享网络，首先要确保手机开启了 USB 网络共享（USB tethering）。不同手机的设置可能会有所不同，通常在 Android 设置里可以找到 `网络与互联网 > 热点与网络共享 > USB 网络共享`。\n\n### 3. 配置网络接口\n\n连接手机后，Armbian 系统应该会自动识别 RNDIS 网络接口，通常会显示为 `usb0` 或类似名称。你可以运行以下命令来查看是否识别到了新的网络接口：\n\n```\nifconfig\n```\n\n你应该会看到类似 `usb0` 的接口。接下来，您可以使用 DHCP 获取网络配置（IP 地址等）。可以使用 `dhclient` 命令来为该接口获取 IP 地址：\n\n```\nsudo dhclient usb0\n```\n\n### 4. 测试网络连接\n\n一旦配置了网络接口，您可以尝试 ping 一个外部地址，例如：\n\n```\nping 8.8.8.8\n```\n\n如果能够成功 ping 通，说明已经通过 RNDIS 成功上网。\n\n### 5. （可选）设置静态 IP（如果需要）\n\n如果您不想使用 DHCP，而是希望配置静态 IP 地址，可以编辑 `/etc/network/interfaces` 文件来手动设置网络配置。例如：\n\n```\nsudo nano /etc/network/interfaces\n```\n\n然后添加如下配置（假设 `usb0` 接口）：\n\n```\niface usb0 inet static\naddress 192.168.42.100\nnetmask 255.255.255.0\ngateway 192.168.42.1\n```\n\n保存并退出后，重启网络服务：\n\n```\nsudo systemctl restart networking\n```\n\n这样就完成了通过 RNDIS 协议上网的配置。\n\n","tags":["AI","protected","Linux"],"categories":["Linux"]},{"title":"UnRaid使用指南","url":"/2024/10/04/UnRaid使用指南/","content":"\n# 设置中文\n\n1. 切换到 `TOOLS` 选项卡中，找到`Language`，点击进入后，输入如下URL： `https://gitee.com/wsh-feiyu/language-templates/raw/master/limetech/lang-zh_CN.xml`，然后点击`INSTALL`。\n   - ![image-20241004113324119](/Image/unraid使用指南.assets/image-20241004113324119.png)\n   - ![image-20241004113334527](/Image/unraid使用指南.assets/image-20241004113334527.png)\n   - 输入这个项目的汉化插件：`https://github.com/seanzhang98/unraid_zh_CN_Beta`\n   - 由于github访问困难，可以对这个文件做镜像，比如使用gitee：`https://gitee.com/wsh-feiyu/language-templates/raw/master/limetech/lang-zh_CN.xml`\n2. 点击完成`INSTALL`按钮之后，页面可能没有反应，可以按下F5刷新一下。当出现 `简体中文`后，语言包安装成功。\n   1. ![image-20241004113502829](/Image/unraid使用指南.assets/image-20241004113502829.png)\n3. 进入 `SETTINGS`设置页面，找到 `Display Settings`，点进去。\n   1. ![image-20241004113621219](/Image/unraid使用指南.assets/image-20241004113621219.png)\n4. 修改显示语言为 `简体中文`\n   1. ![image-20241004113722233](/Image/unraid使用指南.assets/image-20241004113722233.png)\n   2. ![image-20241004113742433](/Image/unraid使用指南.assets/image-20241004113742433.png)\n5. 然后下拉页面，点击`APPLY`更改，然后再次下拉点击`完成`按钮。\n   1. ![image-20241004113843004](/Image/unraid使用指南.assets/image-20241004113843004.png)\n6. 至此，中文设置完成。\n   1. ![image-20241004113912423](/Image/unraid使用指南.assets/image-20241004113912423.png)\n\n\n\n# 安装应用商店\n\n## 配置网络代理（需要借助clash）\n\n1. 使用ssh或web界面的终端打开命令窗口\n\n2. 编辑`/root/.wgetrc`这个文件（这个文件可能不存在）\n\n3. 在其中写入如下代码：（建议使用ssh客户端进行）\n\n   1. ```\n      use_proxy=yes\n      http_proxy=http://[你的clash设备IP]:[端口默认7890]\n      https_proxy=http://[你的clash设备IP]:[端口默认7890]\n      wait=10\n      \n      如：\n      \n      use_proxy=yes\n      http_proxy=http://192.168.172.216:7897\n      https_proxy=http://192.168.172.216:7897\n      wait=10\n      ```\n\n   2. > 这段的含义就是，让unraid的wget走代理，因为下载安装是用的wget服务（根据我搜索了大量的文章，看了很多大佬的解决方法，最终确认，这个是管用的，我是6.11.5版本。**其他的修改profile的，直接在/usr/local/sbin/emhttp &加proxy的，都不管用**）\n\n4. 编辑完保存，**不需要重启**，现在去APPS下点击install，已经可以安装市场了。\n\n5. 如果安装还是失败,测试指定的代理能否正常工作:\n\n   1. 先使用 `curl -x http://192.168.172.216:7897 www.google.com `测试代理是否正常`-x` 选项指定要使用的代理服务器，后面跟的是代理的URL（包括地址和端口）。例如，`-x http://192.168.172.216:7897` 表示通过指定的代理访问后面的URL。\n\n6. 此时,应用商店就能正常访问了.\n\n   1. ![image-20241004125236849](/Image/unraid使用指南.assets/image-20241004125236849.png)\n\n   \n\n\n   ## 设置开机启动\n\n   因为unraid是从U盘启动的，重启后刚刚编辑的root/.wgetrc这个文件就没了，所以要编辑/boot/config/go这个文件，写入以下代码即可\n\n   ```text\n   echo \"use_proxy=yes\" >> /root/.wgetrc\n   echo \"http_proxy=http://[你的clash设备IP]:[端口默认7890]\" >> /root/.wgetrc\n   echo \"https_proxy=http://[你的clash设备IP]:[端口默认7890]\" >> /root/.wgetrc\n   echo \"wait=10\" >> /root/.wgetrc\n   ```\n\n   这段的含义就是U盘引导开机的时候，在root里面写入一个.wgetrc的文件，就是把上面的代码开机的时候新建写入一遍。\n\n   \n\nFatal error during checkPluginlnProgress SweetAlert:Unexpected 2nd argument (function (isConfirm) {if (isConfirm) {hidePluginPending(pluginURL);\nif($(\".selectedMenu\").data(\"category\")== \"action centre\"){var postFunction =\"actionCentre\"} else {\nvar postFunction=\"OpenSidebarAndRefreshDisplay\"\n\n\n\n```\nport=7897\ntunnel=1\nproxy=http://192.168.172.216\n```\n\n\n\n\n\n# 主界面中硬盘顺序\n\n![image-20241004184102106](/Image/unraid使用指南.assets/image-20241004184102106.png)\n\n似乎：\n\n- sda为U盘（系统）\n- sdb为距离开机按键最远的一块硬盘\n- sdc、sdd依次\n\n\n\n能正确读取到硬盘SN码，换完硬盘需要手动保存硬盘序列号和盘位关系。\n\n","tags":["protected","UnRaid","NAS"],"categories":["技术"]},{"title":"泉盛UVk5对讲机简易使用指南","url":"/2024/06/24/泉盛UVk5对讲机简易使用指南/","content":"\n# 简易使用说明\n\n## 一键对频\n\n### 功能\n\n在不借助写频软件的前提下，使用这个方法同步其他对讲机当前通道的频率。\n\n### 操作步骤\n\n1. 设备开机。\n2. 按下 `F` 键、`4`键进入频率计模式。\n3. 发射机按动`PTT`键（发送键），此时UVK5会显示出发射机的频率和哑音频（CTC）。\n4. 此时，按`MEMU`键（M）可以进行保存操作。\n   1. 当扫描完成后（屏幕第三栏显示`扫描结束`，同时能显示出频率和CTC参数的值），按下MEMU按键，此时UVK5会发出“存储信道”的声音，屏幕的第三栏会显示`SAVE:信道号`。通过按动⬆和⬇可以切换要保存到的信道。（信道号的表现形式为：CH-xxx，xxx表示具体的信道，例如5信道显示为：CH-005）\n   2. 当选择完信道之后，再次按下MEMU按键，UVK5会提示是否进行保存（第三栏显示为`SAVE?`）。\n   3. 如果需要保存，再次按下MEMU按键进行确认，此时UVK5会发出“确定”的声音。此时，系统就会将当前信道参数保存到对应的信道里面。\n   4. 如果需要重新扫描，可以按下 `*`键，UVK5会重新对能接收到的频段进行扫描。\n\n\n\n\n\n\n\n## 解锁特殊频段的发射\n\n### 功能说明\n\n解锁特殊频段的发射限制。\n\n### 操作步骤\n\n1. 设备关机。\n2. 按下`PTT`键（发射键）和`PTT`键下方的按键（同时按下）的同时，设备开机。\n3. 开机后会自动进入设置菜单，此时会出现隐藏的设置选项。","tags":["protected","知识杂谈","对讲机"],"categories":["对讲机","使用说明"]},{"title":"对讲机的常用功能术语","url":"/2024/06/24/对讲机的常用功能术语/","content":"\n## **监听**（MONITOR）\n\n为接受弱小信号而采用的一种收听方式。通过按专用键强制接通接收信号通道，操作者用耳朵辨别扬声器中的微弱声音，达到收听的目的。\n\n监听键一般是听对方的信号不清楚或是有断续的时候，按住这个键接听，效果会好一点。一般会有2到3个按键。第一个为PTT发射键就不说了。在有两个按键情况下第二个按键一般为静噪键〔在接收信号不好的时候使用〕，在一些叫高档的机子中次键还可以支持编程功能。如，身份码发射，报警，1750中继触发等。如果为三个按键，第二个键就为功能键〔功能设置或者作为组合键使用〕或者可编程键〔同上〕，第三个按键就为静噪键了。\n\n## **扫描**（SCAN）\n\n为了听到所有信道的通话，而采用的一种收听方式。\n\n通过按专用键，使接收电路按一定顺序逐个信道接收一段时间，以收听到信道中的信号。若每个信道接收时间为100ms，则每秒可扫描过十个信道，即扫描速度为10ch/s 。\n\n## **优先信道扫描功能**(PriorityChannel Scan)\n\n在扫描过程中优先扫描所设定的优先信道。\n\n## **删除/添加扫描信道**(Delete/Add Scan Channel)\n\n将某一信道从扫描列表中删除或添加到扫描列表中。\n\n## **声控**（VOX）\n\n当该功能被激活后，不必按PTT键，可直接通过语音启动发射操作。\n\nVOX，Voice operated exchange，直译成中文就是「声音触发转换」。一般使用对讲机，我们需要按下对讲机的通话键再进行通话。但如果开启了 VOX，不用按下通话键，只要对讲机的麦克风检测到说话声就会自动开启发射，实现「声控」通话。当麦克风听不到声音时则会关闭：VOX 最大的意义就在于，可以让你彻底的解放双手，轻松通话。\n\n## **发射限时功能**(TOT: TimeOut Timer)\n\n发射限时功能此功能是防止任何呼叫方占用信道时间过长，计时器限制对讲机每次的发射时间，限制用户超时发射。\n\n该功能用于限制用户在一信道上超时间发射，同时也避免对讲机因长时间发射而造成损坏。\n\n## **省电功能**(BatterySave)\n\n对讲机除了具有操作简单、通话成本低、应用范围广等特点外，还具有省电功能，能够使设备的待机时间更长，对讲机都具有省电功能，当对讲设备在一定时间内没有发射接受和按键操作时，对讲机将自动采取一段时间关机，一段时间开机的方式工作，也就是省电模式，省电功能的开关机时间长度比大约为1：4，当收到信号或有按键操作时，便立即进入正常的工作状态\n\n## **照明功能**(Backlight)\n\n用于在夜间或昏暗的情况下操作，可看清楚LCD显示和按键。\n\n## **复制功能**(Cloning)\n\n该功能允许将一台对讲机中的数据复制到型号相同的其他对讲机中。\n\n## **静噪级数**(SquelchLevel)\n\n接收信号中噪声的强弱与信号的强弱呈对应关系，信号越强噪声越弱。把最大噪声和最小噪声之间分成若干档，每一档称为一级。分成的档数叫静噪级数。用户可根据实际情况进行选择。\n\n## **载波**\n\n话音、数字信号、信令等有用信号的载体，易于传输的高频电磁波。\n\n## **2-TONE/DTMF选呼功能**\n\n利用2-TONE或DTMF信令选择呼叫相应的对讲机。\n\n## **倒频功能**(ReverseFrequency)\n\n即是将对讲机的发射频率和接收频率将互换，并且所设定的信令也进行互换。\n\n在有中继的时候一方不使用中继或者是中继突然不工作时候，而是把中继的使用的两个收发频率倒过来使用的一种通连方式。倒频通连具有信号直接（没有通过中继）、不改变对方使用中继的方式，因此适合在对方不知不觉的情况下进行直接通连测试。\n\n## **脱网功能**(Talk Around)\n\n使用脱网功能时，对讲机的发射频率变得与接收频率相同；发射信令也转成与接收信令相同。\n\n## **自动应答功能**(Auto-Transpond)\n\n当对讲机收到一个正确编码呼叫时，向呼叫方发出一个信号以响应呼叫。\n\n## **紧急报警**(EmergencyAlarm)\n\n按下报警专用键，对讲机以最大声音发出报警声或发出预定报警码给其他的手持机或基台。\n\n## **巡逻登记**(PatrolRecord)\n\n巡逻人员到达巡逻点时，对讲机将收到巡逻登记器发出的查询信号，然后自动启动登记操作，把自身的身份码等信息发给巡逻登记器予以登记，表明某巡逻人员已到达该地。\n\n## **锁键功能**(Keylock)\n\n使用该功能可以防止键的误操作。对讲机键盘锁可以锁定和解锁，这个功能主要就是为了防止误触碰按键，把正在使用的方式给调乱了。对讲机的键盘锁按键一般是标记着#号的键，上面还会有一个小钥匙符号。\n\n调制\n\n用调制信号的某一种或某几种参数控制载波的参数的改变，按照控制参数的不同，调制又可分为调幅、调频和调相。\n\n## **高低功率选择功能**(High/Lowpower)\n\n该功能可让用户根据实际情况选择高功率或低功率。\n\n## **禁发功能**(BusyChannel Lockout)\n\n当使用该功能时，用户禁止在繁忙信道上发射信号。\n\n## **信道和信道间隔（Channel Spacing）**\n\n信道指发射接收时占用的频率值。信道间隔（Channel Spacing）指对讲机设置的两个相邻信道的频率差。规定的信道间隔有25KHz(宽带)、20KHz、12.5KHz(窄带)等。\n\n## **CTCSS**\n\nCTCSS(Continuous Tone Controlled Squelch System) , 连续语音控制静噪系统，俗称亚音频，是一种将低于音频频率的频率（67Hz-250.3Hz）附加在音频信号中一起传输的技术。因其频率范围在标准音频以下，故称为亚音频。当对讲机对接收信号进行中频解调后，亚音频信号经过滤波、整形，输入到CPU中，与本机设定的CTCSS频率进行比较，从而决定是否开启静音。\n\n## **CDCSS**\n\nCDCSS(Continuous Digital Controlled Squelch System)，连续数字控制静噪系统，其作用与CTCSS相同，区别在于它是以数字编码方式来作为静音是否开启的条件。\n\n## **DTMF**\n\nDTMF（Dual Tone Multi Frequency），双音多频，由高频群和低频群组成，高低频群各包含4个频率。一个高频信号和一个低频信号叠加组成一个组合信号，代表一个数字。DTMF信令有16个编码。利用DTMF信令可选择呼叫相应的对讲机。","tags":["protected","知识杂谈","对讲机"],"categories":["对讲机","知识杂谈"]},{"title":"使用 CloudFlare Worker 搭建 Docker 加速镜像","url":"/2024/06/23/使用 CloudFlare Worker 搭建 Docker 加速镜像/","content":"\n# 所需资源\n\n1. cloudflare账号\n2. 域名（自带的域名或被墙）\n\n\n\n\n\n# 步骤\n\n1. 在面板左侧找到 **Workers 和 Pages**，然后点击右侧的 **创建应用程序**、**创建 Worker**，修改一个好记的名字，**部署**\n\n   1. ![image-20240615111123379](.\\Image\\使用CloudFlareWorker搭建Docker加速镜像.assets\\image-20240615111123379.png)\n   2. ![image-20240615111223611](.\\Image\\使用CloudFlareWorker搭建Docker加速镜像.assets\\image-20240615111223611.png)\n   3. ![image-20240615111257298](.\\Image\\使用CloudFlareWorker搭建Docker加速镜像.assets\\image-20240615111257298.png)\n\n2. 接下来编辑代码，将 worker.js 的内容替换为下面内容：\n\n   1. ```js\n      Vxxxxxxxxxx132 1// import HTML from './docker.html';23const HTML = `4<!DOCTYPE html>5<html>6    <head>7        <meta charset=\"utf-8\" />8        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />9        <title>Mirror Usage</title>10        <style>11        html {12        height: 100%;13        }14        body {15        font-family: \"Roboto\", \"Helvetica\", \"Arial\", sans-serif;16        font-size: 16px;17        color: #333;18        margin: 0;19        padding: 0;20        height: 100%;21        display: flex;22        flex-direction: column;23        justify-content: space-between;2425        }26        .container {27            margin: 0 auto;28            max-width: 600px;29        }3031        .header {32            background-color: #438cf8;33            color: white;34            padding: 10px;35            display: flex;36            align-items: center;37        }3839        h1 {40            font-size: 24px;41            margin: 0;42            padding: 0;43        }4445        .content {46            padding: 32px;47        }4849        .footer {50            background-color: #f2f2f2;51            padding: 10px;52            text-align: center;53            font-size: 14px;54        }55        </style>56    </head>57    <body>58        <div class=\"header\">59        <h1>Mirror Usage</h1>60        </div>61        <div class=\"container\">62        <div class=\"content\">63            <p>镜像加速说明</p>64            <p>65            为了加速镜像拉取,你可以使用以下命令设置registery mirror:66            </p>67            <pre>68            sudo tee /etc/docker/daemon.json &lt;&lt;EOF69            {70                \"registry-mirrors\": [\"https://{{host}}\"]71            }72            EOF73            </pre>74            </br>75            <p>76            为了避免 Worker 用量耗尽,你可以手动 pull 镜像然后 re-tag 之后 push 至本地镜像仓库:77            </p>78            <pre>79            docker pull {{host}}/library/alpine:latest # 拉取 library 镜像80            docker pull {{host}}/coredns/coredns:latest # 拉取 library 镜像81            </pre>82        </div>83        </div>84        <div class=\"footer\">85        <p>Powered by Cloudflare Workers</p>86        </div>87    </body>88</html>89`;9091export default {92    async fetch(request) {93        const url = new URL(request.url);94        const path = url.pathname;95        const originalHost = request.headers.get(\"host\");96        const registryHost = \"registry-1.docker.io\";9798        if (path.startsWith(\"/v2/\")) {99        const headers = new Headers(request.headers);100        headers.set(\"host\", registryHost);101102        const registryUrl = `https://${registryHost}${path}`;103        const registryRequest = new Request(registryUrl, {104            method: request.method,105            headers: headers,106            body: request.body,107            // redirect: \"manual\",108            redirect: \"follow\",109        });110111        const registryResponse = await fetch(registryRequest);112113        console.log(registryResponse.status);114115        const responseHeaders = new Headers(registryResponse.headers);116        responseHeaders.set(\"access-control-allow-origin\", originalHost);117        responseHeaders.set(\"access-control-allow-headers\", \"Authorization\");118        return new Response(registryResponse.body, {119            status: registryResponse.status,120            statusText: registryResponse.statusText,121            headers: responseHeaders,122        });123        } else {124        return new Response(HTML.replace(/{{host}}/g, originalHost), {125            status: 200,126            headers: {127            \"content-type\": \"text/html\"128            }129        });130        }131    }132}\n      ```\n\n      \n\n3. 接下来，点击右上角的 **部署**，稍等片刻\n\n4. 最后，返回面板，在 **设置**，**触发器** 处设置一个自己的域名，一切就大功告成了\n   *不建议使用自带的 workers.dev 的域名，被墙了*V","tags":["protected","CloudFlare","docker"],"categories":["CloudFlare"]},{"title":"联想ThinkCentreM710q恢复第2个M.2接口功能的方法","url":"/2024/06/14/联想ThinkCentre M710q恢复第2个M.2接口功能/","content":"\n# 板子图片\n\n## 正面\n\n![img1](./Image/联想ThinkCentreM710q恢复第2个M.2接口功能.assets/230224z9duyjt4tt5nuyur.jpg)\n\n## 背面\n\n![img2](./Image/联想ThinkCentreM710q恢复第2个M.2接口功能.assets/230225r0j0hzl00ll0id5f.jpg)\n\n\n\n# 需改动的地方\n\n![img3](./Image/联想ThinkCentreM710q恢复第2个M.2接口功能.assets/230226xjeetmorzmr7c07p.jpg)\n\n![img4](./Image/联想ThinkCentreM710q恢复第2个M.2接口功能.assets/230229twtt2bwctfc26qww.jpg)\n\n![img](./Image/联想ThinkCentreM710q恢复第2个M.2接口功能.assets/230229oneen6r6r7r0jc2s.jpg)\n\n![img](./Image/联想ThinkCentreM710q恢复第2个M.2接口功能.assets/230227x38hh83wh1q6csr1.jpg)\n\n![img](./Image/联想ThinkCentreM710q恢复第2个M.2接口功能.assets/230217xu55melk3eu1z3lk.jpg)\n\n\n\n# 主要的注意事项如下\n\n![img](./Image/联想ThinkCentreM710q恢复第2个M.2接口功能.assets/230217xu55melk3eu1z3lk-1718353663119-15.jpg)\n\n焊接m2插槽时，最好一个引脚一个引脚的焊接，尽量不要拖焊。同时焊完注意测量是否存在短路问题。旁边的电容阻碍了焊接，先行移除\n\n![img](./Image/联想ThinkCentreM710q恢复第2个M.2接口功能.assets/230218si22moh8j2xtqx8i.jpg)\n\n![img](./Image/联想ThinkCentreM710q恢复第2个M.2接口功能.assets/230221dr4o1vc6rfrfmumv.jpg)\n\n![img](./Image/联想ThinkCentreM710q恢复第2个M.2接口功能.assets/230220uxvagvas3v5wxsxw.jpg)\n\n![img](./Image/联想ThinkCentreM710q恢复第2个M.2接口功能.assets/230222tcv9yo9yy1o6bbfc.jpg)\n\n焊接完插槽后，用热风枪恢复电容（当然也可以用烙铁）。\n\n![img](./Image/联想ThinkCentreM710q恢复第2个M.2接口功能.assets/230223djuww5uruu5cucux.jpg)\n\n\n\n经过以上处理，主板就可以恢复M.2功能了，注意：这个M.2只支持SATA模式。\n\n![img](./Image/联想ThinkCentreM710q恢复第2个M.2接口功能.assets/230223jsmxkklsxxhwhxss.jpg)\n\n另外，M710q除了可以恢复M.2以外，也可以恢复PCIE X8的功能，也就是说可以升级到M910q，我也成功改过一台并装上显卡使用中。问题是很复杂，需要补很多零件，20V转PCIE供电部分的所有零件也需要补齐，介于难度较大我就暂时不“害”大家了","tags":["protected","魔改","捡垃圾"],"categories":["搞事情"]},{"title":"Office操作指南","url":"/2024/04/22/Office操作指南/","content":"\n\n# 快捷操作\n\nf4：重做上一次的动作\n\n\n\n\n\n\n\n# 截取指定的文本\n\n## 从绝对地址中截取文件名\n\n在Excel中，你可以使用函数`MID`和`FIND`来从绝对地址中截取文件名。假设你的绝对地址保存在单元格A1中，下面是截取文件名的公式：\n\n```vbnet\n复制代码=MID(A1, FIND(\"*\", SUBSTITUTE(A1, \"\\\", \"*\", LEN(A1)-LEN(SUBSTITUTE(A1, \"\\\", \"\")))) + 1, LEN(A1) - FIND(\"*\", SUBSTITUTE(A1, \"\\\", \"*\", LEN(A1)-LEN(SUBSTITUTE(A1, \"\\\", \"\")))))\n```\n\n通过上述公式，你就可以从绝对地址中提取文件名了。请确保在使用时将单元格引用替换为实际的绝对地址。\n\n\n\n\n\n# 后续有多少数据，都显示标题（首行或首列）\n\n1. 打开你的Excel表格。\n2. 滚动到你想保持可视的第一行标题行的正下方。\n3. 点击菜单栏中的“视图”选项卡。\n4. 在“窗口”组中，点击“冻结窗格”按钮，然后选择“冻结首行”。\n\n这样设置后，当你向下滚动查看数据时，第一行标题会始终停留在屏幕顶部。\n\n另外，如果你希望在打印时每页都显示这些标题行，你需要进行以下操作：\n\n1. 转到“页面布局”标签页。\n2. 点击“页面设置”组中的“打印标题”按钮，这将打开“页面设置”对话框。\n3. 在“页面设置”对话框中，找到“工作表”选项卡。\n4. 在“顶端标题行”输入框旁的按钮上点击，然后在工作表中选择你想要作为顶端标题重复出现的那一行（通常是第一行）。\n5. 点击“确定”保存设置。\n\n通过以上步骤，无论是编辑状态下滚动查看还是打印输出时，第一行标题都会保持可见。\n\n\n\n# 限制某一列只能输入某几个值\n\n1. 选择你想要设置限制的列。如果你只想限制一列中的某些单元格，也可以直接选择这些单元格。\n2. 转到“数据”选项卡。\n3. 在“数据工具”组中，点击“数据验证”按钮（可能显示为“数据验证”或“数据有效性”取决于你的Excel版本）。\n4. 在弹出的“数据验证”对话框中，首先确保“设置”选项卡是激活状态。\n5. 在“允许”下拉列表中，选择“序列”。\n6. 在“来源”框中，输入你允许填写的值，各值之间用逗号隔开。例如，如果你希望该列只能输入“是”或“否”，则输入“是,否”（不带引号）。\n7. 如果需要，你可以在“输入信息”或“出错警告”标签页中设置提示信息，当用户尝试输入数据时，这些信息会显示为帮助或警告。比如，你可以在“输入信息”中写“请输入'是'或'否'”以指导用户正确输入。\n8. 点击“确定”完成设置。\n\n现在，当你或他人尝试在该列输入除指定值之外的内容时，Excel会显示警告，并阻止输入，除非更改成允许的值之一。\n\n\n\n\n\n# 限制某一列不允许重复\n\n在Excel中，要限制某一列输入的值不能重复，即实现唯一性验证，可以通过数据验证功能来完成。以下是具体的操作步骤：\n\n1. 选择你想要防止出现重复值的整列或特定单元格范围。\n\n2. 转到“数据”选项卡。\n\n3. 在“数据工具”组中，点击“数据验证”按钮（可能显示为“数据验证”或“数据有效性”取决于你的Excel版本）。\n\n4. 在弹出的“数据验证”对话框中，确保当前选中的是“设置”选项卡。\n\n5. 在“允许”下拉菜单中，选择“自定义”。\n\n6. 在“公式”框中，输入以下公式（假设你选择的是A列，要根据实际情况调整列字母）:\n\n   Code\n\n   ```code\n   1=COUNTIF($A:$A,A1)<2\n   ```\n\n   这个公式的意思是检查当前单元格（如A1）的值在整个A列中是否出现少于2次，也就是保证了唯一性。\n\n7. 点击“确定”应用设置。\n\n完成上述设置后，如果有人尝试在该列输入一个已经存在的值，Excel会显示错误警告，阻止输入重复值。\n\n请注意，这种设置是在数据输入时进行验证，对于已经存在于列中的重复值不会自动删除或标记。如果需要检查并处理已有的重复数据，你可能需要使用“条件格式”突出显示重复项，或者使用“数据”选项卡下的“删除重复项”功能来清理数据。\n\n\n\n\n\n\n\n# 标记某一列中重复的数据\n\n在Excel中，若想将重复的单元格设置为特定的样式以便于识别，可以使用“条件格式”功能。以下是设置步骤：\n\n1. **选择范围**：首先，选择你想要检查重复值并设置样式的单元格区域。如果你希望对整个列应用此格式，可以点击列标题（如A列就点击A），或者拖拽选择整个列。\n2. **应用条件格式**：\n   - 转到“开始”选项卡，在“样式”组中点击“条件格式”按钮。\n   - 在下拉菜单中，选择“突出显示单元格规则”。\n   - 接着，从子菜单中选择“重复值”。\n3. **设置格式**：\n   - 会出现一个对话框，询问你如何标记重复值。在这里，你可以选择预设的格式样式，比如浅红填充色深红色文本、绿色填充色等。\n   - 如果你不满意预设样式，可以点击“自定义格式…”按钮来自定义填充颜色、字体颜色、边框等。\n   - 选择好格式后，点击“确定”。\n\n完成以上步骤后，Excel会自动将选定范围内所有重复的单元格按照你设定的格式进行高亮显示，便于你快速识别和处理这些重复数据。\n\n\n\n\n\n# 假设每一行数据由第1列第二列联合起来做主键，请问如何在这个基础上保证数据不会重复？\n\n在Excel中，虽然没有直接建立联合主键的功能像数据库那样，但你可以通过数据验证的自定义公式来间接实现基于两列数据联合的唯一性检查。以下是一个示例步骤，假设你要确保A列和B列的组合值是唯一的：\n\n1. **选择范围**：选择你想要应用数据验证的起始单元格，以及你想要这个规则应用到的所有相应单元格。例如，如果你想从第二行开始应用规则，可以选择A2:B最后一行。\n\n2. **应用数据验证**：\n\n   - 转到“数据”选项卡，在“数据工具”组中点击“数据验证”按钮。\n   - 在弹出的“数据验证”对话框中，选择“设置”标签页。\n   - 在“允许”下拉菜单中选择“自定义”。\n\n3. **输入自定义公式**：\n\n   - 在“公式”框中输入以下自定义公式（这里以A列和B列为例，根据你的实际列调整）:\n\n     Code\n\n     ```code\n     1=AND(COUNTIFS(A:A,A2,B:B,B2)=1,COUNTIFS(B:B,B2,A:A,A2)=1)\n     ```\n\n     这个公式会检查当前行的A列和B列组合是否在A列和B列的其他任何地方出现过。\n\n4. **完成设置**：\n\n   - 点击“确定”应用数据验证规则。\n\n请注意，这个方法适用于手动数据输入时的即时验证。如果你的数据集很大或者经常需要批量导入数据，这种方法可能不够高效，因为Excel不会主动去检查整个数据集的唯一性，而是在用户尝试输入数据时才进行验证。对于这种情况，你可能需要先使用Excel的“删除重复项”功能检查并处理已有的重复数据，或者在数据输入前通过编程手段（如VBA宏）来实现更复杂的校验逻辑。\n\n\n\n\n\n","tags":["protected","Office"],"categories":["Office"]},{"title":"linux中的标准错误、标准输出以及标准输入","url":"/2024/04/11/linux中的标准错误、标准输出以及标准输入/","content":"\n## 概述\n\n在Linux和其他类Unix系统中，有三个预定义的标准文件描述符（File Descriptors, FDs），它们分别对应于程序的三种基本输入/输出流：\n\n1. 标准输入（Standard Input, stdin）：\n\n   - 文件描述符：0\n   - 作用：提供程序所需的数据输入。默认情况下，它连接到键盘，允许用户或脚本通过键盘向程序输入文本或其他数据。\n2. 标准输出（Standard Output, stdout）：\n   - 文件描述符：1\n   - 作用：用于程序的常规输出，如打印信息、结果显示等。默认情况下，标准输出的内容会被显示在终端屏幕上。程序可以通过标准输出流来传达其执行过程中的信息、计算结果等。\n3. 标准错误（Standard Error, stderr）：\n   - 文件描述符：2\n   - 作用：专门用于输出错误信息、警告和诊断消息。与标准输出分离，其目的是即使标准输出被重定向到文件或其他位置，错误信息仍然能独立显示在终端上，确保用户能够及时注意到程序运行过程中可能出现的问题，而不会因为重定向操作而丢失这些重要信息。\n\n\n\n**区别与作用**：\n\n- 标准输入使得程序可以从外部接收数据，例如从键盘、管道、文件或其他进程。\n- 标准输出用于程序的正常输出，通常包含程序的主要结果或执行状态信息。\n- 标准错误则专用于报告问题和异常情况，与标准输出分开处理，确保无论标准输出如何重定向，错误信息都能直达用户，有助于调试和问题定位。\n\n\n\n## 应用解决方案\n\n### 重定向标准错误到标准输出中\n\n有时候我只需要匹配其中部分的字符，由于标准错误与标准输出是分开的，**无论如何重定向错误信息都能直达用户**,为了只输出所需要的值，可以将标准错误强制输出到标准输出中。`2>&1`\n\n**`2>&1` 命令的作用**： `2>&1` 是一种重定向操作，用来将标准错误（FD 2）输出重定向到与标准输出（FD 1）相同的位置。具体来说：\n\n- `>` 是重定向运算符，用于将一个流（如标准输出或标准错误）的内容发送到另一个位置，如文件或另一个文件描述符。\n- **`2>`**：如果单独使用 `2>`，后面通常会跟一个文件路径，表示将标准错误输出重定向到指定的文件。例如，`command 2> error.log` 会将 `command` 执行过程中的错误信息写入 `error.log` 文件。\n- **`&1`**：这里的 `&1` 并不是指代一个具体的文件路径，而是表示标准输出（FD 1）的当前指向。实际上，`&` 后面跟一个数字（如 `1` 或 `2`）代表对相应文件描述符的引用。在 `2>&1` 中，`&1` 意味着“当前标准输出的位置”。\n- **`2>&1`**：结合起来，`2>&1` 就表示“将标准错误输出重定向到标准输出的位置”。由于标准输出通常默认指向终端，所以 `2>&1` 的效果通常是将标准错误输出合并到标准输出中，两者都会显示在终端上。如果标准输出已经被重定向到文件，那么标准错误输出也会被写入同一文件。\n\n组合起来，`2>&1` 的含义是：将标准错误输出“连接”到标准输出所在的位置。当这个重定向操作应用于命令行时，会产生以下效果：\n\n- 如果标准输出已经被重定向到一个文件（如 `command > output.txt`），那么 `2>&1` 会使标准错误也同样被写入到 `output.txt` 文件，使得错误信息和正常输出混在一起记录在同一文件中。\n- 如果标准输出直接显示在终端（默认情况），那么 `2>&1` 会让标准错误信息也显示在终端上，与标准输出混排，看起来就像所有的输出都是从同一个源头产生的。\n\n\n\n使用 `2>&1` 的常见场景包括：\n\n- **合并输出**：当您希望将命令的所有输出（正常输出和错误输出）合并在一起显示或保存时，可以使用 `2>&1`。例如，`command 2>&1 > output.log` 会将 `command` 的所有输出（包括错误信息）保存到 `output.log` 文件。\n- **过滤错误信息**：当您想通过管道 (`|`) 将命令的错误信息与其他命令（如 `grep`、`sed` 等）一起处理时，可以使用 `2>&1`。如您之前的问题中，`upsc tgbox850@localhost 2>&1 | sed '/^Init SSL/d'` 就是将标准错误与标准输出合并，以便 `sed` 命令能够处理所有输出。\n\n总之，`2>&1` 的主要作用是合并标准错误和标准输出，使得它们可以被一起处理（如重定向到同一文件、管道传递给其他命令等）。这在需要集中查看或分析一个命令或脚本的所有输出（包括错误信息）时非常有用，或者在自动化脚本中确保所有输出都被一致地处理。\n\n\n\n\n\n### 将调试信息输出到标准错误中\n\n在编写Shell脚本时，要将调试（debug）信息输出到标准错误（stderr）中，您可以使用特殊的文件描述符 `2` 或者相关的重定向符号，以确保这些信息与正常的程序输出（stdout）分离，并且即使在标准输出被重定向的情况下也能在终端上显示。以下是一些方法：\n\n**方法一：使用 `>&2` 重定向**\n\n在Shell脚本中，您可以在echo、printf等命令前加上 `>&2`，将输出定向到标准错误：\n\n```bash\n#!/bin/bash\n\n# Debug message example\necho \"Debug: This is a debug message.\" >&2\n```\n\n在这个例子中，`echo` 命令原本会将字符串输出到标准输出（FD 1），但加上 `>&2` 后，其输出被重定向到了标准错误（FD 2）。\n\n**方法二：使用 `echo` 或 `printf` 的 `-e` 和 `stderr` 参数（如果支持）**\n\n某些版本的 `echo` 或 `printf` 可能支持直接指定输出到标准错误。例如，使用 `printf` 的 `-v` 参数（如果您的Shell版本支持）：\n\n```bash\n#!/bin/bash\n\n# Debug message example using printf and -v stderr\nprintf \"%s\\n\" \"Debug: This is a debug message.\" -v stderr >&2\n```\n\n**方法三：使用 `exec` 命令**\n\n如果您希望脚本中所有的调试信息都自动发送到标准错误，可以使用 `exec` 命令在脚本开头重新定义 `echo` 或 `printf` 函数，使其默认输出到标准错误：\n\n```bash\n#!/bin/bash\n\n# Redefine echo to always output to stderr\nexec echo () { builtin echo \"$@\" >&2; }\n\n# Now use echo as usual; debug messages will go to stderr\necho \"Debug: This is a debug message.\"\n```\n\n请注意，这种方法可能会影响脚本中所有后续的 `echo` 命令，除非您特意恢复其原始行为。\n\n**方法四：使用自定义函数或变量**\n\n为了更清晰地管理调试信息，可以创建一个专用函数或使用一个特殊的变量来封装调试输出逻辑：\n\n```bash\n#!/bin/bash\n\n# Define a debug function\ndebug() {\n  echo \"Debug: $*\" >&2\n}\n\n# Use the debug function throughout your script\ndebug \"This is a debug message.\"\n```\n\n或者使用变量：\n\n```bash\n#!/bin/bash\n\n# Set debug mode\nDEBUG=true\n\n# Use the DEBUG variable to conditionally output debug messages\nif [ \"$DEBUG\" = true ]; then\n  echo \"Debug: This is a debug message.\" >&2\nfi\n```\n\n以上就是在Shell脚本中将调试信息输出到标准错误的几种常见方法。选择适合您需求的方式，确保调试信息能够清晰地与标准输出区分，并在需要时方便地查看或过滤。","tags":["AI","protected","Linux"],"categories":["Linux"]},{"title":"WiFiDuck_修改成为连接到指定的WiFi","url":"/2024/03/29/WiFiDuck_修改成为连接到指定的WiFi/","content":"# 需求\n\n- 原始项目为创建一个AP热点，需修改成连接现有WiFi的模式，然后其他设备访问这个设备的ip的形式使用。\n- 由于esp8266的异步库不支持ipv6，因此需要通过nginx来对现有设备的进行代理，以实现在外部通过ipv6的形式进行访问\n\n\n\n\n\n# 修改步骤\n\n## 修改网页文件并编译\n\n1. 注释掉原有的创建热点的代码：位于`webserver.cpp`中的 `void begin()`方法中\n\n   - ```c++\n     WiFi.softAP(settings::getSSID(), settings::getPassword(), settings::getChannelNum());\n     debugf(\"Started Access Point \\\"%s\\\":\\\"%s\\\"\\n\", settings::getSSID(), settings::getPassword());\n     ```\n\n2. 在注释掉的位置新增连接到指定WiFi的代码：\n\n   - ```\n     WiFi.begin(\"SSID\", \"PASSWORD\");\n     ```\n\n     - `SSID`需要修改成要连接的WiFi的名称\n     - `PASSWORD`需要修改成指定WiFi的密码\n\n3. 修改 `script.js`文件（需要去官方下载web源码）\n\n   1. 注释掉其中的这个代码\n\n      - ```js\n        ws = new WebSocket(\"ws://192.168.4.1/ws\");\n        ```\n\n   2. 新增如下代码\n\n      - ```\n        ws = new WebSocket(\"ws://IP+端口/ws\");\n        ```\n\n        - `IP+端口`的值为nginx服务器的地址，或者为设备本身的ip地址\n\n4. 使用 `python webconverter.py`命令将网页文件转换为所需的字节数组\n\n5. 将生成的字节数组替换到项目中对应位置，然后重新编译项目并上传\n\n\n\n## 创建nginx配置块\n\n```\nserver {\n        listen 9898;\n\n        location / {\n            proxy_pass 设备实际ip+端口;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n        }\n        \n        location /ws {\n\t\t\t# 开启 WebSocket 代理支持\n\t\t\tproxy_set_header Upgrade $http_upgrade;\n\t\t\tproxy_set_header Connection \"upgrade\";\n\n\t\t\t# 设置 WebSocket 代理目标\n\t\t\tproxy_pass http://设备实际IP+端口/ws;\n\n\t\t\t# 其他可能需要的代理设置\n\t\t\tproxy_redirect off;\n\t\t\tproxy_set_header Host $host;\n\t\t\tproxy_set_header X-Real-IP $remote_addr;\n\t\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\t\t\t\n\t\t\t# 需要增加以下配置 不然websocker会短时间就断连\n\t\t\tproxy_read_timeout 3600s;  # 增加读取超时时间\n\t\t\tproxy_send_timeout 3600s;  # 增加发送超时时间\n\t\t\tproxy_http_version 1.1;    # 必须使用HTTP/1.1或以上版本，以支持WebSocket\n\t\t\tkeepalive_timeout 3600s;  # 保持连接活跃超时时间，防止空闲连接被关闭\n\n\t\t}\n    }\n```\n\n","tags":["protected","ESP8266","WiFiDuck","单片机"],"categories":["ESP8266"]},{"title":"HTML常用标签","url":"/2024/03/12/HTML常用标签/","content":"\n1. 加入连接：\n\n   ```\n   <a href=\"所要连接的相关地址\">写上你想写的字</a>\n   ```\n\n2. 在新窗口打开连接：\n\n   ```\n   <a href=\"相关地址\" target=\"_blank\">写上要写的字</a>\n   ```\n\n3. ~~移动字体(走马灯)：~~\n\n   ~~已被废弃~~\n\n   ```\n   <marquee>写上你想写的字</marquee>\n   ```\n\n4. ~~背景音乐：~~\n\n   不是标准标签\n\n   ```\n   <bgsound=\"背景音乐地址\" loop=infinite>\n   ```\n\n5. 字体加粗：\n\n   ```\n   <b>写上你想写的字</b>\n   ```\n\n6. 字体斜体：\n\n   ```\n   <i>写上你想写的字</i>\n   ```\n\n7. 字体下划线:\n\n   ```\n    <u>写上你想写的字</u>\n   ```\n\n8. 字体删除线:\n\n   ```\n   <s>写上你想写的字</s>\n   ```\n\n9. 字体加大:\n\n   ```\n    <big>写上你想写的字</big>\n   ```\n\n10. 字体控制大小：\n\n    ```\n    <h1>写上你想写的字</h1>\n    ```\n\n    (其中字体大小可从h1-h5,h1最大，h5最小)11)\n\n11. 更改字体颜色：\n\n    ```\n    <font color=\"#value\">写上你想写的字</font>\n    ```\n\n    (其中value值在000000与ffffff(16位进制)之间\n\n12. 消除连接的下划线：\n\n    ```\n    <a href=\"相关地址\" >写上你想写的字</a>\n    ```\n\n13. 贴音乐：\n\n    ```\n    <embed src=\"音乐地址\" width=\"宽度\" height=\"高度\" autostart=false>\n    ```\n\n14. 贴flash:\n\n    ```\n     <embed src=\"flash地址\" width=\"宽度\" height=\"高度\">\n    ```\n\n15. 贴影视文件：\n\n    ```\n    <img dynsrc=\"文件地址\" width=\"宽度\" height=\"高度\" start=mouseover>\n    ```\n\n16. 换行：\n\n    ```\n    <br>\n    ```\n\n17. 段落：\n\n    ```\n    <p>段落</p>\n    ```\n\n18. 原始文字样式：\n\n    ```\n    <pre>正文</pre>\n    ```\n\n19. 背景：\n\n    ```\n    <body background=\"背景图片地址\">\n    ```\n\n20. HTML视频代码\n\n    ```\n    <video src=\"视频地址\" width=\"100%\" height=\"100%\" controls=\"controls\" autoplay=\"\" x5nativepanel=\"\"></video>\n    ```","tags":["protected","HTML"],"categories":["HTML"]},{"title":"消除B站广告屏蔽插件的提示信息","url":"/2024/03/12/消除B站广告屏蔽插件的提示信息/","content":"\n由于chrome用了某些插件, 所以在访问b站的时候出现了如下某些提示：\n\n```\n检测到您的页面展示可能受到浏览器插件影响，建议您将当前页面加入插件白名单，以保障您的浏览体验～\n```\n\n解决办法：\n\n其一：去掉广告屏蔽器\n\n其二：干掉这个横幅\n\n- 在广告屏蔽插件中新建一个规则，内容为：\n\n- ```\n  www.bilibili.com##.adblock-tips \n  ```\n\n  \n\n","tags":["protected","广告屏蔽","小技巧"],"categories":["广告屏蔽"]},{"title":"Java基础教程","url":"/2024/02/29/Java基础教程/","content":"# Java概述\n\n## Java技术体系平台\n\n### Java SE（Java Standard Edition）：标准版\n\n```\n支持面向桌面级应用的Java平台，提供了完整的Java核心\n```\n\n\n### Java EE（Java Enterprise Edition）：企业版\n\n```\n为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet、Jsp等，主要针对于Web应用程序开发。版本以前称为J2EE\n```\n\n\n### Java ME（Java Micro Edition）：小型版\n\n```\n支持Java程序运行在移动终端(手机、PDA) 上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME\n```\n\n\n## Java 重要特点\n\n1. Java 语言是面向对象的(oop)。\n2. Java 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证。\n3. Java 语言是跨平台性的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]\n4. Java 语言是解释型的[了解]\n\n   解释性语言：javascript,PHP, java 编译性语言: c / c++\n\n   区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行, 编译性语言, 编译后的代码, 可以直接被机器执行。\n5. Java内置了多线程的支持。\n6. Java是动态的。基本组成单元是类，类是在运行的时候动态装载的，可以在环境中动态的维护程序和类库。（在面向对象时就区分了编译类型和运行类型）\n\n## Java的运行机制及运行过程\n\n### JVM Java虚拟机 Java virtual machine\n\n1. JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在 JDK 中。\n2. 对于不同的平台，有不同的虚拟机。\n3. Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”。（即运行环境相等）\n\n### JDK Java开发工具包 Java Development Kit\n\n```\nJDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。\n```\n\n\n### JRE Java运行环境 Java Runtime Environment\n\n```\n包括 Java 虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序， 计算机中只需要安装 JRE 即可。\n```\n\n\n### JDK、JRE 和 JVM 的包含关系\n\n1. JDK = JRE + 开发工具集（例如 Javac,java 编译工具等)\n2. JRE = JVM + Java SE 标准类库（java 核心类库）\n3. 如果只想运行开发好的 .class 文件 只需要 JRE\n\n### Java 开发注意事项和细节\n\n1. Java源文件以.java为扩展名。源文件的基本组成部分是类(class) 。\n2. Java应用程序的执行入口是main()方法。它有固定的书写格式:public static void main(String[] args) {..}\n3. Java语言对大小写敏感。\n4. Java方法由一条条语句构成，每个语句以”；“结束。\n5. 大括号都是成对出现的，缺一不可。 [习惯，先写{}再写代码]\n6. 一个源文件中**最多只能有一个public类**。 其它类的个数不限。\n7. 如果源文件包含一个public类，则文件名**必须按该类名命名**!\n8. 一个源文件中最多只能有一个public类。其它类的个数不限，也可以将main方法写在非public类中，然后指定运行非public类，这样入口方法就是非public的main方法\n\n### Java中常用的转义字符\n\n* \\t ：一个制表位，实现对齐的功能\n* \\n ：换行符\n* \\\\\\ ：一个\\\n* \\\\\" :一个\"\n* \\\\' ：一个'\n* \\r :一个回车 （光标回到当前行的第一个字符）\n\n### Java注释（comment）\n\n#### Java 中的注释类型\n\n1) 单行注释 //\n2) 多行注释 /* */\n3) 文档注释 /** */\n\n#### 使用细节\n\n1. 被注释的文字，不会被 JVM（java 虚拟机）解释执行\n2. 多行注释里面不允许有多行注释嵌\n\n#### 文档注释\n\n```\n注释内容可以被JDK提供的工具Javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。一般写在类。\n```\n\n\n##### 生成文档注释\n\n```java\njavadoc -d 文件名 -xx -yy zzz.java //文件名指存放的位置，xx、yy指参数，可以通过javadoc -help进行查看，\n```\n\n### Java 代码规范\n\n1. 类、方法的注释，要以Javadoc的方式来写。\n2. 非Java Doc的注释，往往是给代码的维护者看的，着重告述读者为什么这样写，如何修改，注意什么问题等\n3. 使用tab操作， 实现缩进,默认整体向右边移动，时候用shift+ tab整体向左移\n4. 运算符和=两边习惯性各加一个空格。比如:2 + 4 * 5 + 345 - 89\n5. 源文件使用utf-8编码\n6. 行宽度不要超过80字符\n7. 代码编写**次行风格**和**行尾风格**。\n\n### 路径\n\n#### 相对路径\n\n从当前目录开始定位，形成一个路径，含义是相对于现在这个目录，我指定的在哪里。在不同目录下该路径的含义不同。如：\n\n```\n..\\abc2\t\t\t\t//指向上一个文件夹中的abc2文件。\t..表示返回上一级\n```\n\n#### 绝对路径\n\n从根目录开始定位，只要是在这个计算机内就能保证路径指向的唯一性。如：\n\n```\nD;\\hurr\\test\n```\n\n### Windows下简单的DOS命令\n\n1. 查看当前目录是有什么内容\n\n   ```\n   dir D:\\hurriedlu\\test\n   ```\n2. 切换到其他目录下\n\n   ```\n   cd D:\\Programs\n   ```\n3. 切换到上一级目录 (使用相对路径)\n\n   ```\n   cd ..\n   ```\n4. 切换到根目录\n\n   ```\n   cd \\\n   ```\n5. 查看指定的目录下所有的子级目录\n\n   ```\n   tree\n   ```\n6. 清屏\n\n   ```\n   cls\n   ```\n7. 退出 DOS\n\n   ```\n   exit\n   ```\n\n   ---\n\n# Java中的变量\n\n```\n同c、c++一样，每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间(字节)。\n```\n\n\n```\n在Java中，整个数据类型可分为两大类：\n```\n\n**基本数据类型**和**引用数据类型**。\n\n## 基本数据类型\n\n\n| 数据类型 | 标识符 |    默认值    | 存储大小(字节) | 数据范围                                                   |\n| :------: | :-----: | :-----------: | :------------: | :--------------------------------------------------------- |\n|   整型   |  byte  |       0       |       1       | -128~127                                                   |\n|   整型   |  short  |       0       |       2       | -32768~32767                                               |\n|   整型   |   int   |       0       |       4       | -2147483648~2147483647                                     |\n|   整型   |  long  |     0L/0l     |       8       | -2^63~2^63-1                                               |\n|   实型   |  float  |   0.0F/0.0f   |       4       | 32位IEEEE 754单精度范围                                    |\n|   实型   | double | 0.0/0.0D/0.0d |       8       | 64位IEEEE 754双精度范围                                    |\n|   逻辑   | boolean |     false     |      1bit      | true或false                                                |\n|   字符   |  char  |      空      |       2       | Unicode的字符范围: '\\u0000' (即为0)到'\\uffff' (即为65,535) |\n\n同c、c++有些许不同，虽然要求任何变量在使用前必须初始化，但变量在定义的时候已经有初值了。（c中只有全局变量才有初值）\n\n### 使用细节\n\n1. Java中各整数类型都有固定的范围和字段长度，不受操作系统的影响，保证了可移植性。\n2. 整形变量默认为int型，声明long型需要在后面加上l或者L。\n3. 同c、c++有些许不同，虽然要求任何变量在使用前必须初始化，但变量在定义的时候已经有初值了。（c中只有全局变量才有初值）\n4. 注意数据范围，小心溢出。\n5. 对于浮点型而言，其中的数值不是准确的，存储的仅是近似值。因此，在比较浮点型数据中，一般的方法是将两个数相减，如果差值小于精度的要求，就认为是相等的。如下：\n\n   ```java\n   double num1 = 2.7;\n   double num2 = 8.1/3;\n   if(Math.abs(num1-num2)<0.00001)\n       System.out.println(\"两个数相等\");\n   ```\n6. 字符常量是用单引号括起来的单个字符，因为使用的是Unicode编码，因此可以存储汉字，且占用空间是2个字节。\n7. 在Java中char是可以进行运算的，和c相同，当成一个整数。\n\n### 类型转换\n\n#### 自动类型转换\n\n```\nJava在赋值和运算时，精度小的类型会自动转换为精度大的数据类型，这就是自动类型转换。\n```\n\n\n```\n```\n\n**char -> int -> long -> float -> double**\n\n```\n```\n\n**byte -> short -> int -> long -> float -> double**\n\n##### 自动类型转换中需要注意的细节\n\n1. 有多种类型的数据混合运算时，系统首先自动将所有数据转换成（精度）容量最大的那种数据类型，然后再进行计算。\n2. 当我们把精度(容量)大的数据类型赋值给精度(容量)小的数据类型时，就会报错，反之就会进行自动类型转换。\n3. (byte, short)和char之间不会相互自动转换。\n4. byte, short, char 他们三者可以计算，在计算时首先转换为int类型（自动）。\n5. boolean不参与转换。\n6. 自动提升原则：表达式结果的类型自动提升为操作数中最大的类型。\n\n#### 强制类型转换\n\n```\n自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符 ( )，但可能造成\n```\n\n**精度降低或溢出**，格外要注意。\n\n##### 强制类型转换细节\n\n1. 当需要对精度（容量）大的转换为小的的时候，就需要使用到强制转换。\n2. 强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级。\n\n   ```java\n   int x = (int)10 * 3.5 + 5 * 1.5;\t\t//42.5\n   int y = (int)(10 * 3.5 + 5 * 1.5); \t\t//42\n   ```\n3. char类型可以保存int的常量值，但不能保存int的变量值，需要强转。（即以字符形式存储整型值）\n\n   ```java\n   char c1 = 100; //ok\n   int m = 100; //ok\n   char c2 = m; //错误\n   char c3 = (char)m; //ok\n   System.out.println(c3);//100对应的字符\n   ```\n4. byte和short，char类型在进行运算时，当做int类型处理。\n\n## 引用类型\n\n```\n每种编程语言都有自己操作内存中元素的方式，例如在 C 和 C++ 里是通过指针，而在 Java 中则是通过“引用”。\n```\n\n\n```\n在 Java 中一切都被视为了对象，但是我们操作的标识符实际上是对象的一个引用（reference）。\n```\n\n\n```\n通过将这个叫“引用”的标识符指向某个对象，之后便可以通过这个引用来实现操作对象了。\n```\n\n\n```\n最常用的引用类型就是String，它可以很方便的存储字符串。\n```\n\n\n对于引用在后面面向对象的时候会详细的讲，这里只需要直到引用类型不能直接==来判断值是否相同。\n\n## 基本数据类型与String类型的转换\n\n### 基本数据类型转String\n\n```java\n基本类型+\"\";\t//基本类型加上一个空串就行\n```\n\n### String转基本类型\n\n通过基本类型的包装类调用parseXX方法即可。\n\n```java\nInteger.parseInt(\"123\");\nDouble.parseDouble(\"123.1\" );\nFloat.parseFloat(\"123.45\") ;\nShort.parseShort(\"12\" ); \nLong.parseLong(\"12345\" );\nBoolean.parseBoolean(\"true\");\nByte.parseByte(\"12\");\n\n```\n\n#### 注意事项\n\n1. 在将 String 类型转成基本数据类型时，比如我们可以把 \"123\" , 转成一 个整数，但是不能把 \"hello\"转换成整数。\n2. 对于格式不正确的转换，会直接**抛出异常，程序停止**。\n3. 不同于c，会从头开始转换，直到不能转换为止，如123abc可以转换成整数123，但这在Java中是不可以的。\n\n## Java中常用编码简介\n\n### ASCII码\n\n```\n最通用的单字节编码系统，等同于国际标准ISO/IEC 646 。\n```\n\n\n```\n传统ASCII码规定了128个字符，只占用了一个字节中的后七位\n```\n\n\n```\n扩展ASCII码扩展了128给，即一个字节八个位全都有使用。扩展ASCII码允许将每个字符的第8 位用于确定附加的128 个特殊符号字符、外来语字母和图形符号。\n```\n\n\n### Unicode 编码\n\n* Unicode的好处: 每一个符号都给予一 个独一无二的编码，使用Unicode没有乱码的问题。\n* Unicode的缺点:一个英文字母和一个汉字都占用2个字节，这对于存储空间来说是浪费。\n* 2的16次方是65536，所以最多编码是65536个字符。\n* Unicode码兼容ASCII码。编码0- 127的字符是与ASCII的编码一样，比如'a' 在ASCII码是0x61，在Unicode码是0x0061,都对应97。\n\n### UTF-8编码\n\n1. UTF-8是在互联网上使用最广的一种Unicode的实现方式(改进)。\n2. UTF-8 是一种**变长的编码**方式。它可以使用1-6个字节表示一个符号， 根据不同的符号而变化字节长度。\n3. 使用大小可变的编码字母占1个字节，汉字占3个字节。\n## Java中的加号\n\n```\n整个表达式从左往右进行运算，当运算符两边是数值时进行数值上的相加，当读到有非数值的时候，从此刻开始直到整个表达式结束，+号的作用变成了连接。如下：\n```\n\n```java\nSystem.out.println(100 + 98); //198\nSystem.out.println(\"100\" + 98)//10098\nSystem.out.println(100 + 3 + \"hello\");//103hello\nSystem.out.println(\"hello\" + 100 +3); //hello1003\n\n```\n# 运算符\n\n与C++中的运算符类似，此处不再详细笔记。如有不同则会在后期添加\n\n> 赋值运算符：=\n>\n> 算数运算符：+ - * / %\n>\n> 关系运算符：> < >= <= != ==\n>\n> 逻辑运算符（短路符，即一旦确定值后直接结束）： && ||\n>\n> ```\n> （非短路，会全部运算完）& | !\n> ```\n>\n> 自增自减符：++ --\n>\n> 三元运算符： 条件表达式?表达式1：表达式2；\n>\n> 下标运算符：[]\n>\n> 类型转换：（）\n>\n> 其他运算符：new instanceof 位运算符 访问成员运算符\n\n## instanceof\n\n```\n用于检查是否是类的对象。常用于后面的多态的向下转型。先判断这个对象引用的运行类型是否属于某个子类，是的话就可以进行向下转型。\n```\n\n## 标识符的命名\n\n### 标识符概念\n\n1. Java 对各种变量、方法和类等命名时使用的字符序列称为标识符\n2. 凡是自己可以起名字的地方都叫标识符int num1 = 90;\n\n### 标识符的命名规则(必须遵守)与c++相同\n\n1. 由26个英文字母大小写，0-9，_或$组成。汉字也行，但不推荐。\n2. 数字不可以开头。\n3. 不可以使用关键字和保留字，但能包含关键字和保留字。\n4. Java中严格区分大小写， 长度无限制。\n5. 标识符不能包含空格。\n\n### 标识符命名规范\n\n1. 包名：多单词组成时所有字母都小写：aaa.bbb.ccc\n2. 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰]\n3. 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小驼峰， 简称 驼峰法]\n4. 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ\n\n后面我们学习到 类，包，接口，等时，我们的命名规范要这样遵守,更加详细的看文档。\n\n## Java中的位运算\n\n### &\n\n```\n按位与：对应的两位全为1，结果为1\n```\n\n### |\n\n```\n按位或：对应位有1为1\n```\n\n### ^\n\n```\n按位异或：对应位相异为一\n```\n\n### ~\n\n```\n按位取反\n```\n\n### >>\n\n```\n算术右移 ：低位溢出，符号位不变，并用符号位补溢出的高位。\n```\n\n### <<\n\n```\n算术左移 ：符号位不变,低位补 0\n```\n\n### >>>\n\n```\n逻辑右移：也叫无符号右移，运算规则是: 低位溢出，高位补 0\n```\n\n### 注意，没有逻辑左移！！！\n\n## 关键字\n\n关键字的定义和特点 (不用背) 定义：被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词） 特点：关键字中所有字母都为小写。\n\n### 用于定义数据类型的关键字：\n\n* class\n* interface\n* enum\n* byte\n* short\n* int \n* long\n* float\n* double\n* char\n* boolean\n* void\n### 用于定义数据类型值的关键字\n\n* true\n* false\n* null\n\n### 用于定义流程控制的关键字\n\n* if\n* else\n* switch\n* case\n* default\n* while\n* do\n* for\n* break\n* continue\n* return\n\n### 用于定义访问权限修饰符的关键字\n\n* private\n* protected\n* public\n\n### 定义类、函数、变量修饰符的关键字\n\n* abstract\n* final\n* static\n* synchronized\n\n### 定义类与类之间关系的关键字\n\n* extends\n* implements\n\n### 用于建立实例及引用实例、判断实例的关键字\n\n* new\n* this\n* super\n* instanceof\n\n### 用于异常处理的关键字\n\n* try\n* catch\n* finally\n* throw\n* throws\n\n### 用于包的关键字\n\n* package\n* import\n\n### 其他修饰符关键字\n\n* native\n* strictfp\n* transient\n* volatile\n* assert\n\n## 保留字\n\n```\n现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留 字 byValue、cast、future、 generic、 inner、 operator、 outer、 rest、 var 、 goto 、const。\n```\n\n## 键盘输入语句\n\n1. 导入该类的所在包,  java.util.Scanner。\n2. 创建该类对象（声明变量）。\n3. 调用里面的功能。\n\n常用的语句如下：\n\n```java\nScanner scanner = new Scanner(System.in);\t//定义方法\nint num = scanner.nextInt();\t\t\t\t//读取int类型\ndouble d = scanner.nextDouble();\t\t\t//读取浮点型\nString s = scanner.next();\t\t\t\t\t//读取字符串\n```\n# 数组、排序和查找\n\n## 数组的定义\n\n### 一维数组\n\n#### 声明\n\n```java\n数组的元素类型 [] 数组名;\n\n数组的元素类型  数组名 [];\n```\n#### 分配元素\n\n```java\n数组名 = new 数组元素的类型[个数];\n```\n#### 同时进行声明和分配元素\n\n```java\nint num[] = new [10];//定义了一个int类型的一维数组，有10个元素，下标范围0-9\n```\n### 二维数组\n\n#### 声明\n\n```java\n数组的元素类型 [][] 数组名;\n数组的元素类型 数组名[][];\n```\n#### 分配元素\n\n```java\n数组名 = new 数组元素的类型[个数][个数];\n```\n#### 同时进行声明和分配元素\n\n```java\nint num[][] = new [10][12];//定义了一个int类型的一维数组，有10个元素，下标范围0-9\n```\n## 数组的遍历\n\n### 一维数组\n\n#### 不利用方法\n\n```java\nint num[] = new int[10];\nfor (int i = 0; i < num.length; i++) {\n    System.out.println(num[i] + ' ');\n}\n```\n#### 利用方法\n\n```java\nint num[] = new int[10];\nSystem.out.println(Arrays.toString(num));//利用数组类里面的toString方法，直接将整个数组转换成字符串的形式\n```\n### 二维数组\n\n#### 不利用方法\n\n```java\nint arr[][] = new int[10][10];\nfor (int i = 0; i < arr.length; i++) {\n    for (int j = 0; j < arr[i].length; j++) {\n        System.out.print(arr[i][j] + \" \");\n    }\n}\n```\n#### 利用方法\n\n```java\nint arr[][] = new int[10][10];\nfor (int i = 0; i < arr.length; i++) {\n    System.out.println(Arrays.toString(arr[i]));\n}\n```\n### 与c的不同之处\n\n* 首先就是定义的方法不同。\n* 其次就是，在二维数组中，在c里面可以以一维的方式进行访问（即第二行第一列等于第一行+1），但在java中不行。\n* java中的二维数组相当于：我定义了一个一维数组，里面存放了指向一个一维数组的地址。\n* 因此，在Java中，二维数组可以不再是矩形的了，每一行的空间都可以单独的定义。比如这样：\n\n```java\nint arr[][] = new int[10][];\narr[2]=new int[112];\narr[1]=new int[10];\narr[2]=new int[13];\n```\n* 因为可以Java的特性，导致了数组的列数可能不统一，且每一行都能获取到当前行有多少列\n* 有一点和C是一样的，就是数组一旦分配了就不能在更改长度，只能对该一维数组重新定义，然后把老的数组里面的值复制到新数组。\n* 有一点和新版本的C是相似的，就是允许在运行的过程中分配空间，而不是在编译的时候就需要确定好。（c98以前的标准不允许）\n\n# 程序控制结构\n\n在Java中，也分为三大流程控制：顺序控制 分支控制 循环控制。对应的语句和c也一样，此处不在进行笔记，不同的地方后期补足。\n\n## 增强for循环\n\n### 语法\n\n```java\nfor(暂存变量:数组名){\n    System.out.println(暂存变量);\n}\n//需要注意暂存变量的类型需要与数组中元素的类型相同。在每次循环中会自动的将数组中的元素一次赋值给 \n```\n使用样例如下：\n\n```java\nint nums[] = {1,3,9};\nfor(int i:nums){\n  System.out.print(i+\" \");\n}\n\nString s[] = {\"a\",\"b\",\"c\"};\nfor(String t:s){\n  System.out.print(t+\" \");\n}\n\n//运行结果：1 3 9 a b c \n```\n# 面向对象：\n\n## 类与对象的关系\n\n> 把需要的属性和方法抽象出来就形成了类，将类实例化后形成对象，形成对象后可以为其个性化。\n\n1. 类是抽象的，概念的，代表一类事物,比如人类,猫类.., 即它是数据类型。\n2. 对象是具体的，实际的，代表一个具体事物, 即 是实例\n3. 类是对象的模板，对象是类的一个个体，对应一个实\n\n## 属性、成员变量（字段）\n\n### 基本介绍\n\n从概念或叫法上看： 成员变量 = 属性 = field(字段) （即 成员变量是用来表示属性的)。\n\n属性是类的一个组成部分，可以是是基本数据类型,也可是引用类型(对象，数组)。\n\n### 注意事项\n\n1. 属性的定义语法同变量\n2. 属性的定义类型可以为任意类型，包含基本类型或引用类型\n3. 属性如果不赋值，有默认值，规则和数组、变量一致。\n\n## 对象\n\n### 创建对象\n\n1. 先声明再创建\n\n```java\n1. Cat cat ; //声明对象 cat \n2. cat = new Cat();\n```\n2. 直接创建\n\n```java\nCat cat = new Cat();\n```\n### 访问对象的属性\n\n```java\ncat.name;\t//对象名.属性名;\n```\n### 对象的细节\n\n#### 类和对象的内存分配机制\n\n##### Java 内存的结构分析\n\n1. 栈： 一般存放基本数据类型(局部变量)。\n2. 堆： 存放对象(Cat cat , 数组等)。\n3. 方法区：常量池(常量，比如字符串)， 类加载信息\n\n##### Java 创建对象流程的简单分析\n\n1. 先加载 Person 类信息(属性和方法信息, 只会加载一次。\n2. 在堆中分配空间（地址），进行默认初始化(看规则)\n3. 把地址赋给一个引用类型的变量，就指向对象\n4. 进行指定初始化， 比如 p.name =”jack”\n##### 对象在内存中存在形式\n\n1. 程序运行时，会将整个类加载到”方法区“（只加载一次）。\n2. 当将类实例化成对象的时候，会按照方法区的类在堆中开辟一个空间，如果其中引用了字符串之类的，会将位于常量池的字符串的地址写入堆中对应的位置，如果是普通类型，会分配空间并使空间清零。\n3. 在栈中创建一个对象的引用变量，并将堆中的地址写入栈中。\n\n## 成员方法\n\n### 基本介绍\n\n```\n在某些情况下，我们要需要定义成员方法(简称方法)。比如人类:除了有一些属性外( 年龄，姓名..),我们人类还有一 些行为比如:可以说话、跑步..,通过学习，还可以做算术题。这时就要用成员方法才能完成。\n```\n\n```\n方法，也称为函数。\n```\n\n### 方法的调用机制原理\n\n1. 当程序执行到方法的时候，就会开辟一个独立空间。\n2. 当方法执行完毕，或者执行到return语句时，就会返回到调用方法的地方继续执行（类似于中断）。\n3. 当整个main方法（栈）执行完毕，整个程序退出。\n\n> 和C++一样，每个函数的空间独立，其中的局部变量的生存期和作用域都不会超出这个函数的空间\n\n### 成员方法的意义\n\n1. 提高代码的复用性。\n2. 可以将实现的细节封装起来，然后供其他用户来调用\n\n### 成员方法的定义：\n\n```java\n访问修饰符 返回数据类型 方法名（形参列表..） {//方法体\n语句;\nreturn 返回值;\n}\n```\n1. 形参列表：表示成员方法输入 cal(int n) ， getSum(int num1, int num2)。\n2. 返回数据类型：表示成员方法输出, void 表示没有返回值。\n3. 方法主体：表示为了实现某一功能代码块。\n4. return：返回一定的值，如在方法中计算得到的值，或者状态。该语句不是必须的 。\n\n### 方法的细节\n\n1. 一个方法最多有一个返回值，如需返回多个可以借助数组或者类。\n2. 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象)。\n3. 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值; 而且要求返回值类型必须和 return 的 值类型一致或兼容。\n4. 如果方法是 void，则方法体中可以没有 return 语句，或者 只写 return ;\n5. 方法名遵循驼峰命名法，最好见名知义，表达出该功能的意思即可。\n6. 一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开，比如getSum(int n1,int n2)。\n7. 参数类型可以为任意类型，包含基本类型或引用类型，比如printArr(int[][] map[] [] )。\n8. 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数! [getSum]\n9. 方法定义时的参数称为形式参数，简称形参;方法调用时的传入参数称为实际参数，简称实参，实参和形参的类型要一致或兼容、 个数、顺序必须致! \n10. 方法体里面写完成功能的具体的语包，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法!即:**方法不能嵌套定义**。[演示]\n11. 传入方法的并不是原来的元素，而是其中的值。对于普通类型来说，因为传进去的是直接的值，相当于拷贝一份进去，因此不会影响到原来变量的地址；但对引用类型来说，传入的是一个地址，针对地址的修改会直接影响到原来的值。（好像与C++中有些不太一样，String是引用类型，但如果传到函数中并对其进行修改，回到main中再输出还是修改之前值）。\n12. 当方法是static的时候，表示这是一个静态的方法，可以不用实例化成对象，直接通过类名.方法名进行调用。具体细节后面说。\n## 可变参数\n\n### 基本概念\n\n```\njava 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。 就可以通过可变参数实现。\n```\n\n```\n简单的说就是当成一个不定长的数组，传入的一瞬间为这堆数开辟一个空间放进去，并把首地址传入。\n```\n\n### 基本语法\n\n```java\n访问修饰符 返回类型 方法名(数据类型... 形参名) { }\n\npublic int fun(int ... nums)\n{\n  int sum=0;\n  for(int i=0;i<nums.length;i++)\n  {\n    sum+=nums[i];\n  }\n  return sum;\n}\n```\n## 作用域\n\n### 基本使用\n\n```\n面向对象中，变量作用域是非常重要的。\n```\n\n1. 在java编程中，主要的变量就是属性(成员变量)和局部变量。\n2. 我们说的局部变量-般是指在成员方法中定义的变量。 [举例Cat类: cry]\n3. java中作用域的分类\n   全局变量:也就是属性，作用域为整个类体；\n   局部变量:也就是除了属性之外的其他变量，作用域为定义它的**代码块**中!\n4. 全局变量(属性)可以不赋值，直接使用，因为有默认值，**局部变量必须赋值后，才能使用**，因为没有默认值。\n\n#### 注意事项和细节\n\n1. 属性和局部变量可以重名，访问时遵循就近原则。\n2. 在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名。\n3. 属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而销毁。即在一次方法调用过程中。\n4. 作用域范围不同\n   全局变量/属性:可以被本类使用，或其他类使用(通过对象调用)\n   局部变量:只能在本类中对应的方法中使用\n5. 修饰符不同\n   全局变量/属性可以加修饰符\n   局部变量不可以加修饰符\n\n## 构造方法/构造器\n\n### 基本介绍\n\n```\n构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。\n```\n\n### 特点：\n\n1. 方法名和类名相同。\n2. 没有返回值。\n3. 在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。  \n### 基本语法\n\n```java\n[修饰符] 方法名(形参列表){ 方法体; } \n```\n### 具体说明\n\n1. 构造器的修饰符可以默认， 也可以是 public protected private\n2. 构造器没有返回值。\n3. 方法名 和类名字必须一样。\n4. 参数列表 和 成员方法一样的规则。\n5. 构造器的调用, 由系统完成。\n6. 一个类可以定义多个不同的构造器，即构造器重载\n7. 构造器是完成对象的初始化，并不是创建对象\n8. 在创建对象时,系统自动的调用该类的构造方法\n9. 如果程序员没有定义构造器，系统会自动给类生成一 个默认无参构造器(也叫默认构造器)，比如Dog (){}, 可以使用javap指令反编译查看到\n10. 一旦定义了自己的构造器,默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下,即: Dog( ){ }\n\n## this\n\n### 什么是this\n\n```\njava虚拟机会给每个对象分配this，代表当前对象。\n```\n\n```\n简单的说，this存储的当前对象的地址，哪个对象调用this，this就代表哪个对象\n```\n\n### this 的注意事项和使用细节\n\n1. this 关键字可以用来访问本类的属性、方法、构造器。\n2. this 用于区分当前类的属性和局部变量。\n3. 访问成员方法的语法：this.方法名(参数列表); 。\n4. 访问构造器语法：this(参数列表); 注意只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一 条语句)。\n5. this 不能在类定义的外部使用，只能在类定义的方法中使用。\n\n## 包\n\n### 包的作用\n\n1. 区分相同名称的类\n2. 当类较多的时候，可以很好的管理类。\n3. 控制访问范围。\n\n```\n包的存在类似于电脑的文件夹，采用树状结构存放其中的文件。同一个包中的类不能重名，但不同包之间可以有重名的类。\n```\n\n### 基本语法\n\n#### 声明存在位置\n\n```\npackage 包名；\n```\n\n```java\npackage net.hurr.test;\n```\n#### 包的引入\n\n```\nimport 包名；\n```\n\n```java\n       improt 包名;\n```\n##### 作用\n\n```\n使用该包下面的类，可以使用通配符*。如导入Scanner类：\n```\n\n```java\nimport java.util.Scanner;\n\nimport java.util.*;\n```\n```\n建议使用前者，用哪个导哪个。\n```\n\n```\n部分IDE如Idea回自动导，不需手写。\n```\n\n## 访问修饰符(访问权限)\n\n\n| 访问级别     | 访问控制修饰符 | 同类 | 同包 | 子类 | 不同包 |\n| ------------ | -------------- | ---- | ---- | ---- | ------ |\n| 公开         | public         | √   | √   | √   | √     |\n| 保护         | protected      | √   | √   | √   | ×     |\n| 默认（不写） |                | √   | √   | ×   | ×     |\n| 私有         | private        | √   | ×   | ×   | ×     |\n\n* public：对外公开，均可访问\n* protested：对子类和同一个包中的其他类公开\n* 默认：仅对同一个包中的类公开\n* private：只有本类成员可以访问，不对外公开。\n\n## 面向对象三大特征：封装、继承、多态。\n\n\t将共有的属性抽象出来，封装成一个个小单元，如果需要的新的功能与之前的有些区别，可以通过继承的方式增加属于自己的功能。有些功能可能之前写过了，但不太符合需求，可以通过重写的方式更新对应方法，或者做出来的可能会有好几种的用途，根据用途不同可以重载一下。重载和重写就是多态的具体实现方式。\n## 封装\n\n```\n将抽象出来的数据（属性）和对数据的操作（方法）打包封装在一起，数据就会被保护在内部（私有化），想要使用只能通过对应的暴露在外面的方法进行操作，这样可以检查操作的合法性。\n```\n\n### 封装的好处\n\n1. 隐藏实现的细节。\n2. 可以对数据进行验证，保证安全合法\n\n## 继承\n\n* 继承很好的解决了代码复用的问题。类似于函数但比函数功能更加丰富。\n* 对于两个相似的类，可以抽出其中共有的属性和方法，将其封装成父类，然后通过继承的方式继承父类即可，对于有差异的地方可以在继承后的子类中添加。\n\n  #### 语法\n\n```java\nclass 子类名 extends 父类名{}\n```\n#### 继承的好处\n\n1. 提高了代码的复用性\n2. 提高了代码的扩展性和维护性\n\n### 继承的细节\n\n1. 子类继承了所有的属性和方法，非私有的属性可以在子类中直接访问，私有的属性和方法只能通过父类提供的公共方法来访问使用。\n2. 子类没有继承父类的构造器，所以必须调用父类的构造器，以完成父类的初始化。\n3. 创建子类对象时，不管使用了子类的哪个构造器，默认情况下都会去调用父类的无参构造器完成父类的初始化。如果父类没有预留无参构造器，则在子类中必须手动选择父类的有参构造器，否则编译器会报错。\n4. 如果需要指定调用父类的某个构造器，需要显示的调用一下：super(参数列表)\n5. super()在使用的时候，必须放在构造器的第一行（super() 只能在构造器中使用）\n6. super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器中。\n7. java的所有类都是Object类的子类，Object是所有类的基类。\n8. 父类的构造器的调用不限于直接父类，可以一直往上追溯到Object类。\n9. 子类最多继承一个父类，因为Java是单继承的，因此不存在c++中的二义性的问题。如果一个类需要继承多个类，可以将这几个类串联在一起。\n10. 不能滥用继承，子类和父类之间必须满足 is – a的逻辑关系。\n\n### 继承的本质\n\n```\n当子类对象创建成功后，建立的查找关系。当创建了一个子类的时候，所有的属性（包括父类中的）全部都在对象内，但由于访问权限的不同不一定都可以访问。\n```\n\n```\n查找属性和方法时，先从子类（最低级）开始寻找，一直找到最高类Object类。这其中如果有父类存在这个方法或者属性但权限是私有不允许访问的，则就不会继续向上查找，并报private的异常。\n```\n\n#### super\n\n* super代表父类的引用，用于访问父类的属性、方法、构造器。\n* super只能在类内使用，即只能在子类中通过super直接访问上一级中的属性。如果在main中将子类实例化后，不能在main中通过super访问父类。\n* 要注意的是，super不能串联使用。他只能穿透一层。即有重名的属性的化，只能访问离自己最近的那个重名的。\n* super类似于一个指针（虽然java中没有指针的功能），存储了父类的地址。\n\n##### 基本语法\n\n* 访问父类的属性（不能访问父类的private的属性）\n\n        ```java\n        super.属性名;\n        ```\n\n  * 访问父类的方法（同样不能访问private）\n\n     ```java\n     super.方法名;\n     ```\n\n    * 访问父类的构造器：只能在**第一行**\n\n           ```java\n           super(参数列表);\n           ```\n    ##### super带来的便利\n\n    1. 调用父类的构造器。\n    2. 当子类与父类中的成员重名的时候，为了访问父类的成员，可以通过super访问。但仅限于访问被直接掩盖的。\n    3. super的访问不限于直接父类，如果爷爷类和本类中有共同的成员，也可以访问到爷爷类的成员。如果多个基类都有同名的成员，使用super访问遵循就近原则。（即只能穿透一层）\n\n    ##### super和this的比较\n\n\n    | 区别点         | this                                   | super                                  |\n    | -------------- | -------------------------------------- | -------------------------------------- |\n    | 访问属性、方法 | 优先在本类中进行查找，                 | 越过本类，直接在父类中进行查找         |\n    | 调用构造器     | 调用本类的构造器，必须放在构造器的首行 | 调用父类的构造器，必须放在构造器的首行 |\n    | 特殊           | 表示当前对象                           | 子类访问父类的对象                     |\n\n    换句话数，this和super类似，一个存储了本类的地址，另一个存储了父类的地址。可以通过这个“地址”来控制访问\n\n    ### 方法重写/覆盖：\n\n    ```\n    简单的说，重写（覆盖）就是子类的一个方法，和父类的某个方法的名称、参数均一样，我们就说子类的这个方法覆盖了父类的方法。（类似于重载）\n    ```\n\n    #### 方法覆盖的注意事项和使用细节\n\n    1. 子类的方法的形参列表、方法名，要和父类的对应的方法完全一致。\n    2. 子类的方法的返回值需要和父类中被覆盖的方法保持一样，或者是父类返回类型的子类。如父类返回是Object，子类的返回类型是String，要保证子类的返回值可以向上转型为父类。\n    3. 被覆盖的方法不能是private，否则只是在其子类中新定义了一个方法，并没有对其覆盖。\n    4. 子类的方法不能缩小父类方法的访问权限，如父类是protected，子类可以是public、protected，但不能是private。\n\n    #### 方法的重写和重载的对比\n\n\n    | 名称             | 发生范围 | 方法名   | 形参列表                           | 返回类型                                                   | 修饰符                               |\n    | :--------------- | -------- | -------- | ---------------------------------- | ---------------------------------------------------------- | ------------------------------------ |\n    | 重载  (overload) | 本类     | 必须一样 | 类型，个数或者顺序至少有一个不同。 | 无要求                                                     | 无要求                               |\n    | 重写  (override) | 父子类   | 必须一样 | 相同                               | 子类重写的方法，返回类型和父类返回的类型一致，或者是其子类 | 子类方法不能缩小父类方法的访问范围。 |\n\n    ## 多态\n\n    ### 基本介绍\n\n    * 方法或对象具有多种形态。\n    * 多态是面向对象的第三大特征。\n    * 多态是建立在封装和继承的基础上的。\n\n    ### 多态的具体体现\n\n    1.方法的多态\n\n    - 重写和重载。\n\n    2、 对象的多态\n\n    - 一个对象的编译类型和运行类型可以不一致。\n    - 编译类型在定义对象时，就已经确定了，不能更改。\n    - 运行类型是可以变化的（向上转型、向下转型）\n    - 编译类型看=左边，运行类型看=右边。\n\n    ### 多态的注意事项\n\n    1. 多态的前提：两个对象（类）存在继承关系。\n    2. 多态的向上转型：\n\n    ### 多态的向下转型\n\n    ##### 本质\n\n    ```\n    将向上转型后的父类重新指回子类。\n    ```\n\n    ##### 语法\n\n    ```java\n    子类类型 引用名 = （子类类型）父类类型;\n    ```\n    ##### 特点\n\n    1. 只能强转父类的引用，不能强转父类的对象。即对象是子类的，但是被父类引用了。\n    2. 要求父类的引用必须指向的是当前目标类型的对象。\n    3. 向下转型后，可以调用子类类型中所有的成员。\n\n    ### 属性没有重写之说\n\n    ```\n    需要注意，如果出现一个父类的引用指向了子类出现了向上转型的情况，当通过父类调用子类方法的时候，是可以正常调用的；但如果通过父类调用属性，则调用的会是父类自身的属性。如下代码可见：\n    ```\n\n    ```\n    简单的说就是，属性没有重写之说，属性的值看编译类型。\n    ```\n\n    ```\n    对于向上转型后的引用来说，只有方法是转型成功的，属性只能看引用的类。如果非要访问可以通过向下转型进行访问。\n    ```\n\n    ```java\n    package net.hurr.test;\n\n    public class Test {\n        public static void main(String[] args) {\n    //属性没有重写之说！属性的值看编译类型\n            Base base = new Sub();//向上转型\n            System.out.println(base.count);// ？ 看编译类型 10\n            base.f();\n            Sub sub = new Sub();\n            System.out.println(sub.count);//? 20\n            sub.f();\n        }\n    }\n\n    class Base { //父类\n        int count = 10;//属性\n        public void f()\n        {\n            System.out.println(\"Base\");\n        }\n    }\n\n    class Sub extends Base {//子类\n        int count = 20;//属性\n        public void f()\n        {\n            System.out.println(\"Sub\");\n        }\n    }\n    ```\n    如果确实需要在向上转型的同时访问子类的属性，可以手动的向下转型一下，如下代码：\n\n    ```java\n    package net.hurr.test;\n\n    public class Test {\n        public static void main(String[] args) {\n    //属性没有重写之说！属性的值看编译类型\n            Base base = new Sub();//向上转型\n            System.out.println(base.count);// ？ 看编译类型 10\n            base.f();\n            Sub sub = new Sub();\n            System.out.println(sub.count);//? 20\n            sub.f();\n\n            System.out.println(\"=================================\");\n            System.out.println(((Sub)base).count);// 20\n            System.out.println(sub.count);//? 20\n\n        }\n    }\n\n    class Base { //父类\n        int count = 10;//属性\n        public void f()\n        {\n            System.out.println(\"Base\");\n        }\n    }\n\n    class Sub extends Base {//子类\n        int count = 20;//属性\n        public void f()\n        {\n            System.out.println(\"Sub\");\n        }\n    }\n    ```\n    ## **Java的动态绑定机制**\n\n    1. 当调用**对象方法**的时候，**该方法会和该对象的内存地址/运行类型绑定**。\n    2. 当调用**对象属性**的时候，**没有动态绑定机制**，哪里声明，就在那里使用。\n\n    ## 多态的应用\n\n    ### 多态数组\n\n    ```\n    将数组的定义类型定义为父类，里面保存的实际元素类型为子类对象。（利用向上转型的规则）\n    ```\n\n    ### 多态参数\n\n    ```\n    在某个方法中，传入的参数可以是父类的形参，在方法中通过instanceof进行类型判断，如果属于类型A，就执行类型A对应的语句，否则就执行另一种预设的语句。\n    ```\n\n    ```\n    常用于面对不同身份进行不同的操作。不需要对方法进行重载就能完成。\n    ```\n\n    ## Object类详解（equals方法）\n\n    ### equals与==的区别：\n\n    ==：\n\n    1. ==既可以判断基本类型，也可以贩毒案引用类型。\n    2. 如果判断的是基本类型，判断的是值是否相等。\n    3. 如果判断的是引用类型如String，则判断是否是同一个对象。（引用类型的本质是指针，==只能简单的判断两个值是否相等\n\n    equals：\n\n    1. equals是Object类中的方法，只能判断引用类型。\n    1. 默认判断的是地址是否相同，但在子类中常常重写这个方法。如在String中就重写了，可以判断字符串的值是否相等。\n    # 面向对象 中级部分\n\n    ## 类变量和类方法\n\n    ### 类变量\n\n    #### 类变量介绍\n\n    ```\n    如果一个类创建的所有对象都需要一个变量（如进行计数），就可以将这个变量设置在类内，并设置成静态变量。\n    ```\n\n    ```\n    类变量也叫静态变量/静态属性，是该类的所有对象共享的变量,任何一个该类的对象去访问它时,取到的都是相同的值，同样任何一个该类的对象去修改它时修改的也是同一个变量。而且，在类没有实例化成对象的情况下，也可以使用\n    ```\n\n    #### 类变量的定义（基本语法）\n\n    ```java\n    访问修饰符 static 数据类型 变量名;\n\n    class A{\n      public static int n = 10;//这个就是类变量，他的关键字是static。\n    }\n\n    public class Test {\n        public static void main(String[] args) {\n            System.out.println(A.n);//虽然没有实例化，但还是一样可以访问。并且在访问的一瞬间，就会完成类的加载（只会加载一次）\n        }\n    }\n    ```\n    #### 类变量的访问\n\n    ```java\n    类名.类变量名\n    ```\n    #### 类变量使用时的注意事项和细节\n\n    1. 什么时候需要用类变量：\n       当我们需要让某个类的所有对象都共享一个变量时， 就可以考虑使用类变量(静态变量):比如:定义学生类，统计所有学生共交多少钱。\n    2. 类变量与实例变量(普通属性)区别：\n       类变量是该类的所有对象共享的，而实例变量是每个对象独享的。\n    3. 加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量 。\n    4. 类变量可以通过类名.类变量名或者对象名.类变量名来访问，但java设计者推荐我们使用类名.类变量名方式访问。[前提是 **满足访问修饰符的访问权限和范围**]。\n    5. 实例变量不能通过类名类变量名方式访问。\n    6. 类变量是在类加载时就初始化了,也就是说，即使你没有创建对象，只要类加载了，就可以使用类变量了。（在使用的一瞬间就会加载）\n    7. 类变量的生命周期是随类的加载开始，随着类消亡而销毁。\n\n    #### *类变量的内存布局*\n\n    ```\n    ```\n    *在JDK7以前，类变量存储在方法区；在JDK8以后，则就存储在了堆中*\n\n    ### 类方法\n\n    #### 基本介绍\n\n    ```\n    类方法也叫静态方法，具体细节和上方的类变量类似\n    ```\n\n    #### 基本语法\n\n    ```java\n    访问修饰符 static 数据返回类型 方法名(){\n      //语句体\n    }\n\n    class A{\n      public static void f(){//静态方法\n        System.out.println(\"类A中的静态方法f()已被调用\");\n      }\n    }\n\n    public class Test {\n        public static void main(String[] args) {\n          A.f();//调用了\n        }\n    }\n    ```\n    #### 类方法的经典使用场景\n\n    ```\n    当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法提高开发效率。\n    ```\n\n    #### 类方法使用注意事项和细节\n\n    1. 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区:\n\n       **类方法中无this的参数**\n       **普通方法中隐含着this的参数**\n    2. 类方法可以通过类名调用，也可以通过对象名调用。\n    3. 普通方法和对象有关，需要通过对象名调用，比如对象名.方法名(参数)，不能通过类名调用。\n    4. 类方法中不允许使用和对象有关的关键字，比如this和super。 普通方法(成员方法)可以。\n    5. 类方法(静态方法)中只能访问静态变量或静态方法.\n    6. 普通成员方法，既可以访问非静态成员，也可以访问静态成员。\n\n    小结:静态方法， 只能访问静态的成员,非静态的方法，可以访问静态成员和非静态成员(必须遵守访问权限)\n\n    ## main方法语法\n\n    ```\n    main方法的形式: public static void main(String[] args){}\n    ```\n\n    1. main方法时虚拟机调用\n    2. java虚拟机需要调用类的main() 方法，所以该方法的访问权限必须是public\n    3. java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static\n    4. 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数\n    5. java 执行的程序参数1参数2参数3 [举例说明:]\n\n    ```\n    java 运行的类名 第一个参数 第二个参数 第三个参数 ...\n    ```\n\n    ```\n    对应到args数组中：第一个元素，第二个元素，第三个元素...\n    ```\n\n    ### 注意事项\n\n    1. 在 main()方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性。\n    2. 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。比如：\n\n    ```java\n    package net.hurr.test;\n\n    public class MAIN {\n        //静态的变量/属性\n        private static String name = \"Hello\";\n        //非静态的变量/属性\n        private int n1 = 10000;\n\n        //静态方法\n        public static void hi() {\n            System.out.println(\"MAIN 的 hi 方法\");\n        }\n\n        //非静态方法\n        public void cry() {\n            System.out.println(\"MAIN 的 cry 方法\");\n        }\n\n        public static void main(String[] args) {\n    //可以直接使用 name\n    //1. 静态方法 main 可以访问本类的静态成员\n            System.out.println(\"name=\" + name);\n            hi();\n    //2. 静态方法 main 不可以访问本类的非静态成员\n    //System.out.println(\"n1=\" + n1);//错误\n    //cry();\n    //3. 静态方法 main 要访问本类的非静态成员，需要先创建对象 , 再调用即可\n            MAIN MAIN = new MAIN();\n            System.out.println(MAIN.n1);//ok\n            MAIN.cry();\n        }\n    }\n\n\n\n    /*\n    运行结果：\n\n    name=Hello\n    MAIN 的 hi 方法\n    10000\n    MAIN 的 cry 方法\n\n    */\n\n    ```\n    ## 代码块\n\n    ### 基本介绍\n\n    ```\n    代码化块又称为初始化块属于类中的成员[即是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。\n    ```\n\n    ```\n    但和方法不同，没有方法名，没有返回，没有叁数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。\n    ```\n\n    ### 基本语法\n\n    ```java\n    [修饰符]{\n      //语句组；\n    }[;]\n    ```\n    #### 注意事项\n\n    1. 修饰符可选，且只能是static\n    2. 代码块可分为两大类，一是加上修饰符的静态代码块，二是没加修饰符的普通代码块/非静态代码块\n    3. 逻辑语句可以为任何逻辑语句，包括但不限于输入、输出、方法调用、循环、判断等\n    4. 结尾的分号可以缺省\n\n    ### 代码块的作用、注意事项、细节\n\n    1. 相当于另一种形式的构造器（对原有构造器的补充），可以进行初始化操作\n    2. 使用的场景：如果多个构造器中都有重复的语句，就可以将这些重复的语句抽取到块中，提高代码的复用性。\n    3. static代码块也叫静态代码块，作用是对类进行初始化。**它随着类的加载而执行，并且只会执行一次**。如果是普通代码块，则在创建（实例化）出一个对象的时候，就执行一次。\n    4. 类什么时候会被加载：\n\n       1. 创建对象实例的时候（new）\n       2. 创建子类对象实例时，父类也会被加载\n       3. 使用类的静态成员时\n    5. 普通的代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次。如果只是使用类的静态成员时，普通代码块并不会执行。\n    6. 创建一个对象时，在一个类的调用顺序是：\n\n       1. 调用静态代码块和静态属性初始化（注意，静态代码块和静态属性初始化调用的优先级相等，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）。\n       2. 调用普通代码块和普通属性的初始化（注意普通代码块和普通属性初始化调用的优先级相等，如果有多个普通代码块和多个普通变量初始化，则按他们定义的顺序调用）。\n       3. 最后调用构造方法。（构造方法的优先级最低）\n    7. 构造器的最前面隐藏了super()和调用普通代码块的语句。（先super后普通）。\n    8. 创建一个子类对象时（继承关系），他们的静态代码块、静态属性初始化、普通代码块、普通属性初始化、构造方法的调用顺序如下：\n\n       1. 父类的静态代码块和静态属性（按定义的顺序执行）；\n       2. 子类的静态代码块和静态属性（按定义的顺序执行）；\n       3. 父类的普通代码块和普通属性初始化；\n       4. 父类的构造方法；\n       5. 子类的普通代码块和普通属性初始化；\n       6. 子类的构造方法；\n\n          > 个人理解：\n          >\n          > 将子类实例化的过程：\n          >\n          > 首先调用了子类的构造方法，因为构造方法第一条语句是super，因此会去调用父类的构造方法，父类的构造方法里也有一个super，有去寻找直接父类的父类直到Object为止。到达Object后，运行Object的静态代码块（因为加载类了），然后加载下一级的静态代码，一直到被实例化的子类为止。将子类加载完后，然后依次将各个类都进行实例化，此时首先运行Object类的普通代码块和构造方法（因为创建对象了），然后按照普通代码块和属性、构造方法的顺序，直到子类完成。（算是递归的思想？好像不太对，因为调用的不是自身）\n          >\n\n    小结:\n\n    1. static代码块是类加载时执行，只会执行一次。（因为类只会执行一次）\n    2. 普通代码块是在创建对象时调用的，创建一次，调用一次。（每个对象各调用一次）\n    3. 类加载的3种情况， 需要记住。（上面第四条）\n\n    #### 样例\n\n    ##### 样例1：无继承，两次调用类的静态属性，再实例化对象\n\n    ```java\n    public class Test {\n        public static void main(String[] args) {\n\n            System.out.println(\"···············\");\n            System.out.println(\"第一次调用静态属性\");\n            System.out.println(A.n1);\n\n            System.out.println(\"···············\");\n            System.out.println(\"第二次调用静态属性\");\n            System.out.println(A.n1);\n\n            System.out.println(\"···············\");\n            System.out.println(\"第一次实例化对象\");\n            A a = new A();\n        }\n    }\n    class A{\n        public static int n1 = 100;//静态属性\n        public int n2 = 200;//普通属性\n        {\n            System.out.println(\"普通代码块被执行\");//普通代码块\n        }\n        static{\n            System.out.println(\"静态代码块被执行\");//静态代码块\n        }\n    }\n    ```\n    > 运行结果如下：\n    >\n    > ···············\n    > 第一次调用静态属性\n    > 静态代码块被执行\n    > 100\n    > ···············\n    > 第二次调用静态属性\n    > 100\n    > ···············\n    > 第一次实例化对象\n    > 普通代码块被执行\n    >\n\n    ##### 样例2 有继承，连续调用两次子类的静态属性，调用一次继承得到的父类的属性，然后将子类实例化成对象\n\n    ```java\n    public class Test {\n        public static void main(String[] args) {\n\n            System.out.println(\"···············\");\n            System.out.println(\"第一次调用子类的静态属性\");\n            System.out.println(B.n3);\n\n            System.out.println(\"···············\");\n            System.out.println(\"第二次调用子类静态属性\");\n            System.out.println(B.n3);\n\n            System.out.println(\"···············\");\n            System.out.println(\"第一次调用父类静态属性\");\n            System.out.println(B.n1);\n\n            System.out.println(\"···············\");\n            System.out.println(\"第一次实例化对象\");\n            B b = new B();\n\n        }\n    }\n    class A{\n        public A(){\n            System.out.println(\"类A的构造方法被调用\");\n        }\n        public static int n1 = 100;//静态属性\n\n        public int n2 = 200;//普通属性\n\n        {\n            System.out.println(\"类A:普通代码块被执行\");//普通代码块\n        }\n\n        static{\n            System.out.println(\"类A:静态代码块被执行\");//静态代码块\n        }\n\n\n    }\n    class B extends A{\n        public static int n3 = 300;\n\n        {\n            System.out.println(\"类B:普通代码块被执行\");//普通代码块\n        }\n\n        static{\n            System.out.println(\"类B:静态代码块被执行\");//静态代码块\n        }\n\n        public B (){\n            System.out.println(\"类B的构造方法被调用\");\n        }\n    }\n    ```\n    > 运行结果：\n    >\n    > ···············\n    > 第一次调用子类的静态属性\n    > 类A:静态代码块被执行\n    > 类B:静态代码块被执行\n    > 300\n    > ···············\n    > 第二次调用子类静态属性\n    > 300\n    > ···············\n    > 第一次调用父类静态属性\n    > 100\n    > ···············\n    > 第一次实例化对象\n    > 类A:普通代码块被执行\n    > 类A的构造方法被调用\n    > 类B:普通代码块被执行\n    > 类B的构造方法被调用\n    >\n\n    ##### 样例3 三次继承继承，直接对子类进行实例化操作\n\n    ```java\n    package net.hurr.test;\n\n    public class Test {\n        public static void main(String[] args) {\n\n            C c = new C();\n\n        }\n    }\n    class A{\n        public A(){\n            System.out.println(\"类A的构造方法被调用\");\n        }\n        public static int n1 = 100;//静态属性\n\n        public int n2 = 200;//普通属性\n\n        {\n            System.out.println(\"类A:普通代码块被执行\");//普通代码块\n        }\n\n        static{\n            System.out.println(\"类A:静态代码块被执行\");//静态代码块\n        }\n\n\n    }\n    class B extends A{\n        public static int n3 = 300;\n\n        {\n            System.out.println(\"类B:普通代码块被执行\");//普通代码块\n        }\n\n        static{\n            System.out.println(\"类B:静态代码块被执行\");//静态代码块\n        }\n\n        public B (){\n            System.out.println(\"类B的构造方法被调用\");\n        }\n    }\n\n    class C extends B{\n        public static int n4 = 400;\n\n        {\n            System.out.println(\"类C:普通代码块被执行\");//普通代码块\n        }\n\n        static{\n            System.out.println(\"类C:静态代码块被执行\");//静态代码块\n        }\n\n        public C (){\n            System.out.println(\"类C的构造方法被调用\");\n        }\n    }\n    ```\n    > 运行结果：\n    >\n    > 类A:静态代码块被执行\n    > 类B:静态代码块被执行\n    > 类C:静态代码块被执行\n    > 类A:普通代码块被执行\n    > 类A的构造方法被调用\n    > 类B:普通代码块被执行\n    > 类B的构造方法被调用\n    > 类C:普通代码块被执行\n    > 类C的构造方法被调用\n    >\n\n    ## 单例设计模式\n\n    ### 什么是设计模式\n\n    1. 静态方法和属性的使用。\n    2. 设计模式是在大量的事件中总结和理论化之后优选的代码结构、编程风格以及解决问题的思考方式。设计模式类似于数学的公式，免得我们自己再思考和摸索。\n\n    ### 单例模式\n\n    ```\n    单例，就是指单个实例。所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对于某个类只能存在一个对象实例，并且该类只提供一个获取其对象实例的方法。\n    ```\n\n    ```\n    单例模式有两种实现方式，一是饿汉式，二是懒汉式。具体特点在后面。\n    ```\n\n    ```\n    大致的实现步骤如下：\n    ```\n\n    \t\t\t1. 构造器私有化，防止直接new。\n    \t\t\t2. 在类的内部创建一个对象\n    \t\t\t3. 向外暴露一个静态的方法，以获取其创建的对象\n    #### 饿汉式\n\n    ```java\n    package net.hurr.test;\n\n    public class Test {\n        public static void main(String[] args) {\n\n            System.out.println(\"获取类A的对象\");\n            //A a = new A();//不再能通过new的方式进行新建\n            A a = A.getA();//只能通过暴露的接口获取到对象。在获取的一瞬间对象就会被创建出来。\n            System.out.println(a);\n\n            A b = A.getA();\n            System.out.println(a == b);//不管怎么获取，获取到的都是同一个对象。\n        }\n    }\n\n    class A {\n        private String name;\n        private String ID;\n\n        private static A a = new A();//饿汉式的特点：直接创建对象，不管是否有需求。为了能在静态方法中返回，需要设置成静态\n\n        private A() {//私有化构造函数防止被new，除此之外和普通的构造函数一样。\n            System.out.println(\"类A的构造器被调用\");\n            name = \"nono\";\n            ID = \"00001\";\n        }\n\n        public static A getA() {\n            return a;\n        }\n\n        @Override\n        public String toString() {\n            return \"name:\" + name + \"  ID:\" + ID;\n        }\n    }\n\n    ```\n    > 运行结果：\n    >\n    > 获取类A的对象\n    > 类A的构造器被调用\n    > name:nono  ID:00001\n    > true\n    >\n\n    #### 懒汉式\n\n    ```java\n    package net.hurr.test;\n\n    public class Test {\n        public static void main(String[] args) {\n\n            System.out.println(\"获取类A的对象\");\n            //A a = new A();//不再能通过new的方式进行新建\n            A a = A.getInstanceA();//只能通过暴露的接口获取到对象。在获取的一瞬间对象才会被创建出来。\n            System.out.println(a);\n\n            A b = A.getInstanceA();\n            System.out.println(a == b);//同样，不管怎么获取，获取到的都是同一个对象。\n        }\n    }\n\n    class A {\n        private String name;\n        private String ID;\n\n        private static A a;//懒汉式特点：类加载的时候不会自动创建对象，只有在调用的时候才会创建\n\n        private A() {//构造函数仍然是私有化的，防止被new，除此之外和普通的构造函数一样。\n            System.out.println(\"类A的构造器被调用\");\n            name = \"nono\";\n            ID = \"00001\";\n        }\n\n        public static A getInstanceA() {//只有调用这个方法的时候，对象才会被创建出来，节省空间，但有可能会造成线程异常。比如在多线程访问时，多个线程都进来了但对象还没创建好，这时就会造成重复创建的问题。只会保留最后一个创建的对象\n            if(a == null) {//如果还没有创建对象，就创建\n                a = new A();\n            }\n            return a;\n        }\n\n        @Override\n        public String toString() {\n            return \"name:\" + name + \"  ID:\" + ID;\n        }\n    }\n\n    ```\n    > 运行结果：\n    >\n    > 获取类A的对象\n    > 类A的构造器被调用\n    > name:nono  ID:00001\n    > true\n    >\n\n    #### 饿汉式和懒汉式的区别\n\n    1. 二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建。\n    2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题。\n    3. 饿汉式存在浪费资源的可能。因为如果一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。\n    4. 在我们javaSE标准类中，java.lang.Runtime就是经典的单例模式。\n\n    ## final关键字\n\n    ### 基本介绍\n\n    ```\n    final中文意思:最后的，最终的。\n    ```\n\n    ```\n    final可以修饰类、属性、方法和局部变量。\n    ```\n\n    ```\n    在某些情况下，可能有以下需求，就会使用到final：\n    ```\n\n    \t\t1. 当不希望类被继承时，可以用final修饰；\n    \t\t2. 当不希望父类的某个方法被子类覆盖/重写(override)时，可以用final关键字修饰；\n    \t\t3. 当不希望类的的某个属性的值被修改，可以用final修饰；\n    \t\t4. 当不希望某个局部变量被修改，可以使用final修饰；\n    > 简单的说，只要经过final修饰，只要本质还是原来的，就不允许修改。\n    >\n\n    ### 使用方法(样例)：\n\n    #### 样例1 要求某一个类不能被其他类继承\n\n    ```java\n    //如果要求下面的类A不能被其他类所继承，可以在前面加上final修饰\n    final class A{\n        public int a = 100;\n    }\n\n    /*//此时就会报错\n    class B extends A{ }*/\n    ```\n    #### 样例2 要求类中的某个方法不能被子类修改（重写/覆盖）\n\n    ```java\n    class A{\n        public int a = 100;\n        //如果希望某个类中的某个方法不被改写或覆盖，同样也可以用final修饰一下\n        public final void fun(){\n            System.out.println(\"这是类A独有的方法，不允许被重写\");\n        }   \n    }\n\n    class B extends A{\n        /*\n        此时如果想要重写父类中的被final修饰了的方法是不可以的\n        public final void fun(){\n            System.out.println(\"对类A的方法进行重写\");\n        }*/\n    }\n    ```\n    #### 样例3 要求类中的某个属性不能被修改（即设置成常量）\n\n    ```java\n    class A {\n        //如果希望某个类中的某个属性不被改写或覆盖，同样也可以用final修饰一下\n        //被final修饰的属性必须赋初值。赋初值的地方可以有三种。一是在定义时如a1，二是利用构造方法，三是利用代码块。\n        //需要注意的是，初始化的地方只能在三个里面选一个。\n        public final int a1 = 100;\n        public final int a2;\n        public final int a3;\n\n        {\n            a3 = 300;\n        }\n        /*\n        public void fun(){//如果试图修改这个属性，就会报错。\n            a=1;\n        }*/\n        public A(){\n            a2 = 200;\n        }\n    }\n\n    class B extends A {\n        int a = 200;//但子类可以对这个继承下来的属性进行重写\n        /*\n        public void fun() {//如果不重写就试图修改这个属性，就会报错。\n            super.a = 1;\n        }*/\n    }\n    ```\n    #### 样例4  要求类中的某个属性不能被修改，且这个属性是静态的\n\n    ```java\n    class A {\n        static final public int n1 = 100;//可以直接赋初值\n        static final public int n2 ;\n        //static final public int n3 ;//但不可以在普通代码块或者构造方法中初始化。因为这个两个的根本是对象，而静态是属于类的。\n        static {\n            n2 = 200;//也可以在静态代码块中赋初值\n        }\n        /*\n        {\n            n3 = 300;\n        }\n      \n        public A(){\n            n3 = 300;\n        }*/\n    }\n    ```\n    ### final使用注意事项和细节\n\n    1. final修饰的属性又叫常量，一般用XX_XX_XX来命名；//即全大写，类似于c中define的标准\n    2. **final修饰的属性在定义时必须赋初值，并且以后不能再修改，赋值可以在如下位置之一 [选择一个位置赋初值即可，只能选择一个] **;\n       ①定义时:如public final double TAX RATE=0.08\n       ②在构造器中\n       ③在代码块中。\n    3. 如果final修饰的属性是静态的，则初始化的位置只能是\n       ①定义时\n       ②在静态代码块不能在构造器中赋值。\n    4. final类不能继承，但是可以实例化对象。\n    5. 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。\n    6. 一般来说，如果一个类已经是final类了，就没必要再将方法修饰成final方法。（修饰成final方法的目的在于防止子类的重写，但final类就已经不允许有子类，不可能会在子类中对方法进行重写）\n    7. final不能修饰构造方法（构造器）。（因为子类不会继承父类的构造器）\n    8. final和static往往都会搭配使用，效率更高，不会导致类加载。因为底层的编译器对此做了优化。\n\n       我们知道，在类加载的时候会同时加载静态代码块，可以利用静态代码块来检查类是否被加载了。\n\n       比如以下代码，会在调用类A的静态属性之前，先将类进行加载，因为在输出100之前，会先输出 类A被加载了 ;\n\n       ```java\n       public class Test {\n           public static void main(String[] args) {\n               System.out.println(A.n1);\n           }\n       }\n       class A {\n           public static int n1 = 100;\n           static {\n               System.out.println(\"类A被加载了\");\n           }\n       }\n       ```\n       如果改成下方的样子,在属性前面加上一个final，类A就就不会被加载，会直接输出100；\n\n       ```java\n       public class Test {\n           public static void main(String[] args) {\n               System.out.println(A.n1);\n           }\n       }\n       class A {\n           public final static int n1 = 100;\n           static {//此时调用n1的值的时候，类就不会加载了。\n               System.out.println(\"类A被加载了\");\n           }\n       }\n       ```\n    9. 各种包装类如Integer,Double,Float,Boolean,String等都是final类。\n\n    ## 抽象类\n\n    ```\n    当父类的某些方法需要声明但又不确定如何实现时，就可以将其声明为抽象方法，那么这个类就是抽象类。\n    ```\n\n    ```\n    当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰的类就是抽象类。\n    ```\n\n    ### 抽象类的介绍\n\n    1. 用abstract关键字类修饰一个类时，这个类就叫做抽象类。**一旦类是抽象类，那么这个类就不能实例化**，因为对编译器来说这个类并没有完成全部的功能。\n\n       ```java\n       访问修饰符 abstract 类名{\n\n       }\n       ```\n    2. 用abstract关键字来修饰一个方法时，这个方法就是抽象方法。需要注意的是，**抽象方法只有声明，没有方法体**。**如果需要定义抽象方法，则该对象所处的类一定要是抽象类**。\n\n       ```java\n       访问修饰符 abstract 类名{\n         访问修饰符 abstract 返回类型 方法名(参数列表);\n       }\n       ```\n    3. 抽象类的价值更多作用时在于设计，是设计者设计好后，让子类继承并实现抽象类。\n    4. 抽象类在框架和设计模式中使用的比较多。\n\n    ### 抽象类的使用样例\n\n    #### 样例1 abstract类，但没有抽象方法\n\n    ```java\n    public class Test {\n        public static void main(String[] args) {\n            //A a = new A();//虽然其中没有任何成员，但依然不能实例化成对象。报错信息：'A' 为 abstract；无法实例化。\n        }\n    }\n    abstract class A {//如果仅是抽象类没有抽象方法，可以不需要继承实现\n    }\n    ```\n    #### 样例2 abstract方法\n\n    ```java\n    public class Test {\n        public static void main(String[] args) {\n            //A a = new A();//抽象类不能实例化成对象报错信息：'A' 为 abstract；无法实例化。\n            B b = new B();\n            System.out.println(b.sum(1, 2, 3));\n        }\n    }\n\n    abstract class A {\n        public abstract int sum(int... num);//如果类中含有抽象方法，则类必须也是抽象类（加上abstract修饰符）\n    }\n\n    class B extends A {\n        public int sum(int... num) {//抽象类中必须要有一个子类实现父类的抽象方法，不然会报错。如果没有抽象方法，可以不用继承\n            int sum = 0;\n            for (int i = 0; i < num.length; i++) {\n                sum += num[i];\n            }\n            return sum;\n        }\n    }\n    ```\n    ### 抽象类使用的注意事项和细节\n\n    1. 抽象类不能被实例化。\n    2. 抽象类不一定包含抽象方法。\n    3. 一旦类包含了abstract方法则这个类必须声明为abstract。\n    4. abstract只能修饰类和方法，不能修饰属性和其它的。\n    5. 抽象类可以有任意成员[抽象类本质还是类] ,比如:非抽象方法、构造器、静态属性等等。\n    6. 抽象方法不能有主体，即不能实现。\n    7. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类。\n\n    8) 抽象方法不能使用private、 final和static来修饰， 因为这些关键字都是和重写相违背的。\n\n    ### 抽象类最佳实践-模板设计模式\n\n    #### 基本介绍\n\n    ```\n    抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。\n    ```\n\n    #### 模板设计模式能解决的问题\n\n    1. 当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。\n    2. 编写一个抽象父类， 父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，就是一种模板模式。\n\n    #### 案例：求 求和 过程中的时间，可以是求1+2+n的值，也可以是求1x2xn的值\n\n    ```java\n    package net.hurr.test;\n\n    public class Test {\n        public static void main(String[] args) {\n            A a = new A();\n            a.fun(1000000000);\n            System.out.println(\".................................\");\n            B b = new B();\n            b.fun(1000000000);\n        }\n    }\n\n    abstract class Template {\n        public void fun(long n) {\n            long strat = System.currentTimeMillis();//获取现在的时间，（精确到毫秒）\n            job(n);//大体的公式放在这，具体的实现细节由子类完成\n            long end = System.currentTimeMillis();//获取现在的时间，（精确到毫秒）\n            System.out.println(\"消耗的时间为 \" + (end - strat));\n        }\n\n        public abstract void job(long n);//中间需要进行一些运算，但目前还不知道运算的过程，所以设置成抽象类，由子类进行计算\n    }\n\n    class A extends Template {\n        public void job(long n) {//子类完成具体的实现过程\n            long sum = 0;\n            for (long i = 1; i <= n; i++) {\n                sum += i;\n            }\n        }\n    }\n\n    class B extends Template {\n        public void job(long n) {//而且可以个性化\n            long sum = 1;\n            for (long i = 1; i <= n; i++) {\n                sum *= i;\n            }\n        }\n    }\n\n    ```\n    > 运行结果：\n    >\n    > 消耗的时间为 316\n    > .................................\n    > 消耗的时间为 719\n    >\n\n    ## 接口\n\n    ### 基本介绍\n\n    ```\n    接口就是给出一些没有实现的方法,封装到一 起，到某个类要使用的时候，在根据具体情况把这些方法写出来。\n    ```\n\n    ### 语法\n\n    ```java\n    //定义接口 \n    访问修饰符 interface 接口名 {\n       //接口内的方法，修饰符默认带有public 和 abstract （对于方法）。不可以是别的\n       void start();\n       void stop();\n    }\n\n    //将接口应用到某个类某个类\n    class 类名 implements 接口 [,接口2 ,接口3...]{\n    \t自己属性:\n    \t自己方法;\n      //类似于继承了抽象类，必须实现接口中定义的所有方法\n    }\n\n    //某个类通过接口调用其他的类\n    class 类名 {\n        public void work(UsbInterface usbInterface){//方法名正常，就是形参变成了定义的接口。编译器会自动调用类的对应实现的方法。如下方样例所示。类似于抽象类和向上转型的集合？系统会自动调用，不需要自己声明了\n            usbInterface.start();//\n            usbInterface.stop();\n        }\n    }\n    ```\n    #### 样例1 接口入门\n\n    ```java\n    package net.hurr.Interface_;\n\n    public class Test {\n        public static void main(String[] args) {\n            Computer computer = new Computer();\n            Phone phone = new Phone();\n            Camera camera = new Camera();\n\n            computer.work(phone);\n            computer.work(camera);\n\n        }\n    }\n\n    interface UsbInterface {//定义了一个接口，使用该接口的类必须实现其中定义的方法\n\n        void start();//默认自带了abstractb和public关键字，所以自己加不加都行。\n\n        void stop();\n    }\n\n\n    class Phone implements UsbInterface {//被接口规范了的类\n\n        @Override\n        public void start() {//按照接口中定义的声明，实现具体的方法\n            System.out.println(\"手机开始工作\");\n        }\n\n        @Override\n        public void stop() {\n            System.out.println(\"手机停止工作\");\n        }\n\n    }\n\n    class Camera implements UsbInterface {\n        @Override\n        public void start() {\n            System.out.println(\"相机开始工作\");\n        }\n\n        @Override\n        public void stop() {\n            System.out.println(\"相机停止工作\");\n        }\n    }\n\n    class Computer {\n        public void work(UsbInterface usbInterface) {//调用被 UsbInterface 接口所规范的类\n            usbInterface.start();\n            usbInterface.stop();\n        }\n    }\n    ```\n    > 运行结果\n    >\n    > 手机开始工作\n    > 手机停止工作\n    > 相机开始工作\n    > 相机停止工作\n    >\n\n    #### 样例2 一个方法实现多个接口（被多个接口所约束）\n\n    ```java\n    package net.hurr.Interface_;\n\n    public class Test {\n        public static void main(String[] args) {\n            A a = new A();\n            InterfacrTest1 interfacrTest1 = new InterfacrTest1();//用于接口测试的类1\n            InterfacrTest2 interfacrTest2 = new InterfacrTest2();//用于接口测试的类2\n\n            interfacrTest1.work1(a);\n            System.out.println(\"...........\");\n            interfacrTest2.work2(a);\n        }\n    }\n\n    interface MyInterface1 {//定义了一个接口，使用该接口的类必须实现其中定义的方法\n        void fun();//默认自带了abstractb和public关键字，所以自己加不加都行。\n        void t();\n\n    }\n\n    interface MyInterface2 {\n        void fun();\n        void fun(String s);\n    }\n\n    class A implements MyInterface1, MyInterface2 {\n        public void fun() {\n            System.out.println(\"重名的fun被执行\");\n        }\n        public void fun(String s) {\n            System.out.println(\"参数名不同的fun被执行，内容是：\" + s);\n        }\n        public void t(){\n            System.out.println(\"未重名的t被执行\");\n        }\n    }\n    class InterfacrTest1 {\n        public void work1(MyInterface1 myInterface1) {\n            myInterface1.fun();\n            myInterface1.t();\n        }\n    }\n    class InterfacrTest2 {\n        public void work2(MyInterface2 myInterface2) {\n            myInterface2.fun();\n            myInterface2.fun(\"参数不同的fun在测试\");\n            //myInterface2.t();//虽然一个类能被多个接口所规范，但每个接口只能调用该接口自己声明的内容\n        }\n    }\n    ```\n    > 运行结果\n    >\n    > 重名的fun被执行\n    > 未重名的t被执行\n    > ...........\n    > 重名的fun被执行\n    > 参数名不同的fun被执行，内容是：参数不同的fun在测试\n    >\n\n    #### 样例3 接口的继承\n\n    ```java\n    package net.hurr.Interface_;\n\n    public class Test {\n        public static void main(String[] args) {\n            A a = new A();\n            InterfacrTest1 interfacrTest1 = new InterfacrTest1();//用于接口测试的类1\n            InterfacrTest2 interfacrTest2 = new InterfacrTest2();//用于接口测试的类2\n\n            interfacrTest1.work1(a);\n            System.out.println(\"...................\");\n            interfacrTest2.work2(a);\n        }\n    }\n\n    interface MyInterface1 {//定义了一个接口，使用该接口的类必须实现其中定义的方法\n        void t();\n\n    }\n\n    interface MyInterface2 extends MyInterface1{\n\n        void fun();\n    }\n\n    class A implements MyInterface2 {\n        public void fun() {\n            System.out.println(\"fun被执行\");\n        }\n\n        public void t(){\n            System.out.println(\"t被执行\");\n        }\n    }\n\n    class InterfacrTest1 {\n        public void work1(MyInterface1 myInterface1) {\n            //myInterface1.fun();//因为在接口1中，并没有这个方法\n            myInterface1.t();\n        }\n    }\n    class InterfacrTest2 {\n        public void work2(MyInterface2 myInterface2) {\n            myInterface2.fun();\n            myInterface2.t();//接口的子类一样可以调用父类的方法\n        }\n    }\n    ```\n    > 运行结果：\n    >\n    > t被执行\n    > ...................\n    > fun被执行\n    > t被执行\n    >\n\n    #### 样例4 带属性和方法体的接口\n\n    ```java\n    package net.hurr.Interface_;\n\n    public class Test {\n        public static void main(String[] args) {\n            A a = new A();\n            InterfaceTest interfaceTest = new InterfaceTest();//实例化用户测试的函数\n            System.out.println(\"通过接口调用的..............................\");\n            interfaceTest.work1(a);\n            System.out.println(\"通过对象调用的..............................\");\n            interfaceTest.work2(a);\n        }\n    }\n\n    interface MyInterface1 {//定义了一个接口，使用该接口的类必须实现其中定义的方法\n        void t();\n        default void fun() {//可以理解为switch里面的default？可以被重写，如果没被重写就实现这个方法\n            System.out.println(\"接口中可以带有语句\");\n        }\n\n        //也可以带有属性。属性好像自带了public static final关键字？\n        // 在idea中如果写上这个三个关键字会变成灰色，鼠标移上去会提示  修饰符 'final/static/public' 对于接口字段是冗余的\n        // 可以通过接口名直接调用,但不能修改\n        int n1 = 100;\n        //protected int n2 = 200;会报错 此处不允许使用修饰符 'protected'。\n    }\n\n    class A implements MyInterface1{\n        public void t(){\n            System.out.println(\"接口中的t()的实现\");\n        }\n        public void test(){//被接口规范的方法可以含有接口中没被声明的方法\n            System.out.println(MyInterface1.n1);\n            //MyInterface1.n1++;//不能修改，会提示  无法将值赋给 final 变量 'n1'\n        }\n    }\n\n    class InterfaceTest{\n        void work1(MyInterface1 myInterface1){\n            myInterface1.t();//接口中声明的\n            myInterface1.fun();//接口中带有方法体的\n            //myInterface1.test();//接口中没有声明的类是不可以被接口调用的\n        }\n        void work2(A a){\n            a.t();//接口中被声明的方法也可以通过对象名的方式进行调用\n            a.test();//单独的方法自然也是可以被调用的\n        }\n    }\n\n    ```\n    > 运行结果：\n    >\n    > 通过接口调用的..............................\n    > 接口中的t()的实现\n    > 接口中可以带有语句\n    > 通过对象调用的..............................\n    > 接口中的t()的实现\n    > 100\n    >\n\n    ```java\n    package net.hurr.Interface_;\n    public class Test {\n        public static void main(String[] args) {\n            Computer computer = new Computer();\n            Phone phone = new Phone();\n            Camera camera = new Camera();\n            A a = new A();\n            computer.work(phone);\n            computer.work(camera);\n          \n            //new UsbInterface();//与抽象类类似，接口也不允许被实例化。'UsbInterface' 为 abstract；无法实例化\n            System.out.println(\"在main()中调用接口中的属性\" + UsbInterface.n);//通过接口名直接调用接口里面的属性\n            //UsbInterface.n = 200;接口里面的属性自带了static和final关键字\n\n            computer.test2(phone);\n            computer.test1(a);\n        }\n    }\n\n    interface UsbInterface {//定义了一个接口，使用该接口的类必须实现其中定义的方法\n\n        void start();//默认自带了abstractb和public关键字，所以自己加不加都行。\n\n        void stop();\n\n        default void fun() {//可以理解为switch里面的default？可以被重写，如果没被重写就实现这个方法\n            System.out.println(\"接口中带有语句\");\n        }\n\n        public int n = 100;//也可以带有属性。属性好像自带了static和final关键字？可以通过接口名直接调用\n\n    }\n\n    interface T extends UsbInterface {//同时接口好像还可以被继承？\n\n        void test();\n    }\n\n    class Phone implements UsbInterface {//被接口规范了的类\n        @Override\n        public void start() {//按照接口中定义的声明，实现具体的方法\n            System.out.println(\"手机开始工作...\");\n        }\n\n        @Override\n        public void stop() {\n            System.out.println(\"手机停止工作\");\n        }\n\n        @Override\n        public void fun() {\n            System.out.println(\"Phone:接口中的类可以被重写\");\n        }\n    }\n\n    class Camera implements UsbInterface {\n        @Override\n        public void start() {\n            System.out.println(\"相机开始工作\");\n        }\n\n        @Override\n        public void stop() {\n            System.out.println(\"相机停止工作\");\n        }\n    }\n\n    class Computer {\n        public void work(UsbInterface usbInterface) {\n            usbInterface.start();\n            usbInterface.stop();\n        }\n\n        public void test1(T t) {\n            t.test();\n        }\n\n        /*\n        public void test2(T t) {//同样也符合继承的规范：子类继承了所有的父类\n            t.fun();\n        }*/\n        public void test2(UsbInterface usbInterface) {//但运行被调用的类也必须得是由子类规范过的类，不兼容父类规范的类\n            usbInterface.fun();\n        }\n    }\n\n    class A implements T {\n        @Override\n        public void start() {\n\n        }\n\n        @Override\n        public void stop() {\n\n        }\n\n        @Override\n        public void test() {\n            System.out.println(\"类A:通过被继承的接口来规定一个类\");\n        }\n    }\n    ```\n    > 运行结果：\n    >\n    > 手机开始工作...\n    > 手机停止工作\n    > 相机开始工作\n    > 相机停止工作\n    > 在main()中调用接口中的属性100\n    > Phone:重写接口中已有的类\n    > 类A:通过被继承的接口来规定一个类\n    >\n\n    ```\n    接口是更加抽象的抽象的类，抽象类里的方法可以有方法体，接口里的所有方法都没有方法体[jdk7.0] 。接口体现了程序设计的多态和高内聚低偶合的设计思想。\n    ```\n\n    ```\n    特别说明: Jdk8.0后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现。\n    ```\n\n    ```\n    与抽象类类似，接口也不允许被实例化。\n    ```\n\n    ### 注意事项和细节\n\n    1. 接口不能被实例化。\n    2. 接口中所有的方法都是 public 方法, 接口中抽象方法，可以不用 abstract 修饰。\n    3. 一个普通类实现接口,就**必须将该接口的所有方法都实现**,可以使用 alt+enter 来解决。\n    4. 抽象类去实现接口时，可以不实现接口的抽象方法。\n    5. 一个类同时可以实现多个接口。\n    6. 接口中的属性只能是final的，而且是public static final修饰符。比如:int a=1;实际上是public static final int a=1; (必须初始化)。\n    7. 接口中属性的访问形式:接口名.属性名。\n    8. 接口不能继承其它的类，但是可以继承多个别的接口。\n    9. 接口的修饰符只能是public和默认，这点和类的修饰符是一样的。（默认的在接口中会被看作是public？）\n\n    ### 接口与继承类的区别\n\n    ```\n    当子类继承了父类，就自动的拥有了父类的所有功能；如果子类需要扩展功能，可以通过 实现接口 的方式扩展。\n    ```\n\n    ```\n    可以把 实现接口 理解为对java单继承机制的一种补充。\n    ```\n\n    ```\n    继承的价值主要在于解决了代码的复用性和可维护性；\n    \t\t接口的价值注意在于设计，设计好各种规范（方法），让其他类去实现这些方法。\n    ```\n\n    ```\n    接口比继承更加灵活，继承满足是是某个（is a），而接口只需要满足像一个...(like a)的关系。\n    ```\n\n    ```\n    接口在一定的程度上实现了代码的解耦（接口规范性+动态绑定）\n    ```\n\n    ### 接口的多态性\n\n    ```\n    接口类型的变量 可以指向 实现了该接口的对象实例。（如在上方的样例1 中，类computer就可以接收实现了UsbInterface usbInterface接口的类，并通过该接口调用在接口中声明的所有方法与属性）。\n    ```\n\n    ```\n    利用接口的多态可以实现一个接口的数组。比如：\n    ```\n\n    ```java\n    package net.hurr.Interface_;\n\n    public class Test {\n        public static void main(String[] args) {\n            I[] i = new I[2];//定义了一个接口数组i\n            i[0] = new A();//数组的第一个位置指向了一个A类的对象\n            i[1] = new B();//数组的第一个位置指向了一个B类的对象\n            i[0].f();//并且可以通过接口调用在接口中声明了的方法或属性\n            //i[1].t();//但不能调用类中私有的属性\n            ((A)i[0]).t();//如果要调用类中私有的方法或属性，也可以使用向下转型的套路。不过需要多一重括号？\n        }\n    }\n\n    interface I {\n        void f();\n    }\n\n    class A implements I {\n        public void f() {\n        }\n\n        public void t() {\n        }\n    }//定义了一个类A，并实现了接口I的方法\n\n    class B implements I {\n        public void f() {\n        }\n    }//定义了一个类B，并实现了接口I的方法\n\n    ```\n    ```\n    同时接口的多态还具有传递性，可以相互继承。如语法样例1中的接口的继承。\n    ```\n\n    #### 接口多态中的二义性\n\n    ```\n    因为一个类可以同时进行继承和实现接口的功能，因此就会出现“二义性”\n    ```\n\n    ```java\n    interface I {\n        int x = 1;//等价于public static final int x = 1;\n    }\n    class T{\n        int x = 2;//普通属性\n    }\n    class A extends T implements I {\n       void f(){\n           //System.out.println(x);//此时就会报错，因为编译器不知道是要哪个里面的x。报错信息：对 'x' 的引用不明确，'T.x' 和 'I.x' 均匹配\n           System.out.println(I.x);//因为接口里面的属性是静态的，所以可以通过接口名.属性名进行访问\n           System.out.println(super.x);//或者使用super关键字指定访问父类的x\n       }\n    }\n    ```\n    ## 内部类\n\n    ### 基本介绍\n\n    ```\n    一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class)，嵌套其他类的类称为外部类(outer class)。\n    ```\n\n    ```\n    内部类是我们类的第五大成员[属性、方法、构造器、代码块、内部类]，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。\n    ```\n\n    ```\n    类的组成：\n    ```\n\n    ```java\n    class Outer {//外部类\n        //属性\n        private int n1 = 100;\n        //方法\n        public void m1() {\n            System.out.println(\"m1()\");\n        }\n        //构造器\n        public Outer(int n1) {\n            this.n1 = n1;\n        }\n        public Outer() {\n        }\n        //代码块\n        {\n            System.out.println(\"代码块\");\n        }\n        //内部类\n        class Inner {\n        }\n    }\n    ```\n    ### 内部类的分类\n\n    ```\n    定义在外部类的局部位置上（比如方法内）：局部内部类（有类名）、\n    ```\n    **匿名内部类（无类名）**；\n\n    ```\n    定义在外部类的成员位置上：成员内部类（非static）、静态内部类（static）；\n    ```\n\n    #### 局部内部类\n\n    ```\n    局部内部类是定义在外部类的局部位置，比如方法中或块中，并且有类名。\n    ```\n\n    ##### 演示代码\n\n    ```java\n    package net.hurr.innerclass_;\n\n    public class InnerClass01 {\n        public static void main(String[] args) {\n            Outer outer = new Outer(100);\n            outer.m1();\n        }\n    }\n\n    class Outer {\n        //属性\n        private int n1 = 100;\n        private int n3 = 300;\n        private void m2(){}\n        //方法\n        public void m1() {\n            //局部内部类是定义在外部类的局部位置， 比如方法中，并且有类名。\n            class Inter{//局部内部类，本质还是一个类，里面也可以有五大类\n                private int n2 = 200;\n                private int n1 = 1;\n                public void f1(){\n                    System.out.println(\"Outer:n3 = \"+n3);//可以直接访问外部类的所有成员， 包含私有的。\n                    m2();//同样也可以访问到外部的方法\n                }\n                public void f2(){\n                    System.out.println(\"Inter:n1 = \"+n1);//当重名发生时，遵守就近原则。\n                  //外部类.this的含义：因为外部类不一定是静态的，因此直接可能不能访问到，加上this表示找的时这个类的对象。\n                    System.out.println(\"Inter:Outer:n1 = \"+Outer.this.n1);//如果需要访问外部类的成员,可以同外部类名.this.成员名 的方式进行访问\n                }\n            }\n\n            //public class InnerTest{}//作为方法的一个成员，是不可以有访问权限的管理。但可以用final进行只读保护，就像其他方法成员一样\n            class InnerTest extends Inter{}//内部类也是可以被继承的（如果能访问到）\n\n            Inter inter = new Inter();//在作用域内内部类也可以实例化成对象\n            System.out.println(\"Inter n2:\"+inter.n2);//并通过对象访问其中的属性\n            inter.f1();//内部类的方法也可以通过对象调用\n            inter.f2();\n        }\n\n\n\n        //构造器\n        public Outer(int n1) {\n            this.n1 = n1;\n        }\n\n    }\n    ```\n    > 运行结果：\n    >\n    > Inter n2:200\n    > Outer:n3 = 300\n    > Inter:n1 = 1\n    > Inter:Outer:n1 = 100\n    >\n\n    #### 匿名内部类\n\n    ```\n    匿名内部类时定义在外部类的局部位置，比如方法中或代码块中，且没有类名.\n    ```\n\n    ```\n    匿名内部类的本质还是类，而且是一个内部的类，他没有名字（有名字但不是开发者命名，是由系统自动生成）\n    ```\n\n    ##### 基本语法\n\n    ```java\n    new 类或接口(参数列表){\n      类体;\n    }\n    ```\n    ##### 基于接口的匿名类 演示\n\n    ```\n    需求：使用接口来定义一个类，并用这个类创建一个对象\n    ```\n\n    ```\n    传统的方法是将新建一个类，但由于只需要使用一次，后面不会再用到，因此可以使用匿名内部类来简化以下编写的流程。\n    ```\n\n    ```\n    比如这样：\n    ```\n\n    ```java\n    I tiger = new I(){\n                @Override\n                public void cry() {\n                    System.out.println(\"老虎在叫....\");\n                }\n            };\n    ```\n    在上方的片段中，tiger的编译类型是I，运行类型是匿名类。匿名类的命名规范为外部类名$编号\n\n    这个匿名的内部类一旦实例化成tiger后，就会直接抛弃，而对象名tiger，可以在生存期内无限次被使用。\n\n    具体实现代码\n\n    ```java\n    package net.hurr.innerclass_;\n    //匿名内部类的使用\n    public class InnerClass01 {\n        public static void main(String[] args) {\n            Outer outer = new Outer();\n            outer.method();\n        }\n    }\n\n    class Outer{\n        private int n1 = 100;\n        public void method(){\n            //基于接口的匿名内部类\n            //使用接口I，并创建一个对象。传统方式：写一个类，实现该接口，并创建对象。但由于这个类只会使用一次，且一会不会再使用。可以使用内部类来简化。如下所示\n            //此时tiger的编译类型是I；运行类型是匿名的内部类。\n            /*\n            下方这个匿名内部类约等于以下语句\n                class XXXX implements I{\n                    public void cry() {\n                        System.out.println(\"老虎在叫\");\n                    }\n                }\n                而其中的XXXX就是系统分配的一个类名。具体的名字是:外部类名$编号。比如这里就是Other$01.\n\n             */\n            I tiger = new I(){\n                @Override\n                public void cry() {\n                    System.out.println(\"老虎在叫....\");\n                }\n            };\n            tiger.cry();//通过将匿名对象实例化后的变量访问其中的方法\n            System.out.println(\"tiger的类名为 \"+tiger.getClass());\n\n        }\n    }\n\n    interface I{//接口\n        void cry();\n    }\n\n    class A{\n        public A() {\n        }\n        public void test(){\n\n        }\n\n    }\n    ```\n    ##### 基于类的匿名类\n\n    ###### 基本构成：\n\n    ```java\n    class Outer {\n        public void method() {\n            A a = new A(\"jack\") {//这就完成了一个基于类的匿名内部类。括号内的值会传给父类A的构造函数.相当于继承了A这个类，但没有重写任何方法。\n              \t//内部匿名类的语句组;\n            };\n        }\n    }\n    class A {\n        public A(String s) {\n            System.out.println(\"传入的值为：\" + s);\n        }\n    }\n    ```\n    匿名类中不允许存在构造函数（因为创建完就丢弃，没有构造的意义）\n\n    匿名内部类的调用方式：\n\n    对象名.内部类的参数；\n\n    也可以不创建对象名直接调用，比如：\n\n    ```java\n    new A(\"Tom\") {\n        public void test() {\n          System.out.println(\"不创建对象名直接调用\");\n        }\n    }.test();//new出来直接调用\n\n    class A {\n        public A(String s) {\n          System.out.println(\"传入的值为：\" + s);\n        }\n    }\n    ```\n    ---\n\n    匿名内部类通常会当作实参直接传递。如：\n\n    ```java\n    public class InnerClass01 {\n        public static void main(String[] args) {\n            fun(new I(){//直接把创造出来的基于接口的匿名内部类的对象作为实参传入到定义好的方法中\n                public void show(){//在匿名类中完成接口所定义的功能\n                    System.out.println(\"这是一幅名画\");\n                }\n            });     \n          \n        }\n        public static void fun(I i){//定义一个方法，可以使用符合这个接口的对象\n            i.show();\n        }\n    }\n\n    interface I{//定义一个接口\n        void show();\n    } \n    ```\n    更改为传统的写法如下（硬编码）：\n\n    ```java\n    public class InnerClass01 {\n        public static void main(String[] args) {\n            fun(new C());\n\n        }\n        public static void fun(I i){//定义一个方法，可以使用符合这个接口的对象\n            i.show();\n        }\n    }\n    interface I{//定义一个接口\n        void show();\n    }\n    class C implements I{\n        public void show(){\n            System.out.println(\"这是一幅名画\");\n        }\n    }\n    ```\n    > ```\n    > 两者在功能上一模一样，都是输出一句\"这是一幅名画\"，但在写法上，传统的方法需要先定义一个类，而这个类很有可能只会被使用一次之后就不会再被使用，占地方，而且看代码的时候比较啰嗦。\n    > ```\n    >\n    > ```\n    > 前者适合只用一次的场景，后者更适合需要复用的场景。\n    > ```\n    >\n\n    全部实验样例如下：\n\n    ```java\n    package net.hurr.innerclass_;\n\n\n    //匿名内部类的使用\n    public class InnerClass01 {\n        public static void main(String[] args) {\n            Outer outer = new Outer();\n            outer.method();\n            outer.fun();\n        }\n    }\n\n    class Outer {\n        private int n1 = 100;\n\n        //基于类的匿名内部类\n        public void method() {\n            //a的编译类型：A;a的运行类型：匿名\n            //相当于继承了A这个类，但没有重写任何方法。\n            A a = new A(\"jack\") {\n                @Override\n                public void test() {\n                    System.out.println(\"匿名内部类重写了test方法\");\n                }\n\n                public int n = 20;\n\n                public void fun1() {\n                    System.out.println(\"在匿名内部类中的n被打印：\" + n);\n                }\n            };\n            a.test();//运行时会动态绑定，根据实际的对象调用对应的方法\n            System.out.println(a.n);//但属性同样不参与动态绑定，只能按照编译类型调用\n            a.fun1();//但参与动态绑定的内部类回去找自身的变量而非找编译类型变量\n\n            new A(\"Tom\") {\n                public void test() {\n                    System.out.println(\"不创建对象名直接调用\");\n                }\n            }.test();\n        }\n\n\n        //基于抽象类的匿名类\n        public void fun() {\n            Anima anima = new Anima() {\n                public void eat() {\n                    System.out.println(\"在基于抽象类的匿名内部类中的eat（）\");\n                    return;\n                }\n            };\n            anima.eat();\n        }\n    }\n\n    class A {\n        public A(String s) {\n            System.out.println(\"传入的值为：\" + s);\n        }\n\n        public void test() {\n            System.out.println(\"类A中的test（）\");\n        }\n\n        public int n = 10;\n\n        public void fun1() {\n            System.out.println(\"在普通外部类中的n被打印：\" + n);\n        }\n    }\n\n    abstract class Anima {\n        abstract void eat();\n    }\n    ```\n    ---\n\n    #### 内部类的细节\n\n    1. 匿名内部类的语法比较奇特，请大家注意，因为匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征，对前面代码分析可以看出这个特点，因此可以调用匿名内部类方法。\n    2. 可以直接访问外部类的所有成员， 包含私有的。(私有的访问权限在于类内，而内部类就在类中，因此可以方法私有)\n    3. 不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final 修饰，因为局部变量也可以使用final。\n    4. 作用域:仅仅在定义它的方法或代码块中。（类似于网络中的内部网络。内部网络可以访问外网的资源，但外网不能主动联系内网从的成员，因为找不到，除非借助端口转发？）\n    5. 局部内部类 的成员访向 外部类 的成员：当作自己的成员一样直接访问。\n    6. 外部类 访向 局部内部类的成员：需要实例化一个内部类的变量，通过对象的名字去找他。前提是能找到（在作用域范围内）\n    7. 外部其他类 不能直接访问到 局部内部类(因为局部内部类地位是一个局部变量)\n    8. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员) 去访问。\n\n    > 1. 局部内部类定义在方法中/代码块\n    > 2. 作用域在方法体或者代码块中\n    > 3. 本质仍然是一个类\n    >\n\n    ### 外部类\n\n    #### 成员内部类\n\n    ##### 语法\n\n    ```java\n    class Outer {\n        class Inter {\n        \t\tpublic void say() {\n                System.out.println(\"内部类的一个方法\");\n            }\n        }\n    }\n    ```\n    ##### 细节讨论\n\n    * 成员内部类就是一个成员，因此它的作用域和外部类的其他成员一样，为整个类体。\n    * 定义在外部类的成员位置。不能有static修饰。\n    * 它可以直接访问外部类的所有成员（包括私有的）。但如果反过来外部类的成员（和内部类平级的）想要访问内部类内的数据，需要先创建对象。（或者加static，和普通类一样）\n    * 它也可以添加访问修饰符，因为他的地位就是一个成员。\n    * 成员内部类的方法不能加static修饰,除非这个内部类已经是static的了。或者java版本升级到16以上。\n    * 如果想在类A中访问外部类B中的内部类C，可以有一下三种方式。（ABC三者的关系：A、B平级，B、C内部外部）如下代码所示。或者在外部类B中创建对应的方法，通过方法调用内部类实例化后的对象。\n\n      ```java\n      //1、靠实例化后的对象来创建一个内部类的对象\n      class A{\n          B b = new B();\n          B.C c = b.new C();//相当于把new C()当作是b的一个成员\n\n          B b1 = new B();\n          B.C c2 = b1.new C();\n\n          public void fun(){\n              System.out.println(\"c=\"+c.hashCode());\n              System.out.println(\"c2=\"+c2.hashCode());\n          }\n      }\n\n      class B {\n          static private int n1 = 100;\n          static protected String name = \"张三\";\n\n          class C {\n              public void say() {\n                  System.out.println(\"位于内部类的say()被执行，外部类的成员 n1 = \" + n1 + \" name = \" + name);\n              }\n          }\n      }\n\n      //2、在外部类中，编写一个方法，返回内部类的对象\n      class B {\n          static private int n1 = 100;\n          static protected String name = \"张三\";\n\n          class C {\n              public void say() {\n                  System.out.println(\"位于内部类的say()被执行，外部类的成员 n1 = \" + n1 + \" name = \" + name);\n              }\n          }\n\n          public C getInterC(){//在外部类中实例化并返回，同样需要借助外部类的对象\n              return new C();\n          }\n      }\n\n      //3、或者用静态的方法：\n      ```\n\n    ```java\n    package net.hurr.Interface_;\n\n    public class Test {\n        public static void main(String[] args) {\n            Outer outer = new Outer();\n            Outer.inter01.say();\n        }\n    }\n\n    class Outer {\n        static private int n1 = 100;\n        static protected String name = \"张三\";\n\n        static class Inter01 {\n            static public void say() {//需要注意的是，此处的成员内部类的方法不能加static修饰,除非这个内部类已经是static的了。或者java版本升级到16以上\n                //内部类可以访问外部类中所有的成员，包括私有的。\n                System.out.println(\"位于内部类的say()被执行，外部类的成员 n1 = \" + n1 + \" name = \" + name);\n            }\n        }\n\n        //需要注意，内部类不能被外面的类（不是外部类）直接实例化，因为找不到这个类。\n        static Inter01 inter = new Inter01();\n\n        class Inter02 {\n            public void t() {\n                System.out.println(\"t()\");\n            }\n        }\n      \n        Inter02 inter02 = new Inter02();\n        public void t(){//创建一个跳板，其他类可以通过这个方法访问到内部类的数据\n            inter02.t();\n        }\n    }\n    ```\n    * 如果外部类和内部类的成员重名时，会遵循就近原则，会访问到重名的内部类的成员。如果内部类想要访问重名了的外部类的成员，需要使用“外部类名.this.成员”的语法进行访问。\n\n    ```java\n    class A{\n        private int n = 100;\n        class B{\n            private int n = 200;\n            public void fun(){\n                System.out.println(\"直接访问n会访问到内部类的n，会输出200.：\"+n);\n                System.out.println(\"如果需要访问外部类的n，需要特殊处理，比如这样就能访问到外部的值：\"+A.this.n);\n            }\n        }\n    }\n    ```\n    #### 静态内部类\n\n    ```\n    静态内部类是定义在外部类的成员位置，并有static修饰。\n    ```\n\n    ##### 特点\n\n    1. 可以直接访问外部类的所有静态成员，包括私有，**但不能访问非静态的成员**。\n    2. 可以添加任意的修饰符，因为地位就是一个成员。\n    3. 作用域：和成员一样，为整个类体。\n\n    ```java\n    package net.hurr.Interface_;\n\n    public class Test {\n        public static void main(String[] args) {\n            A a = new A();\n            a.fun();\n        }\n    }\n\n    class A {\n        private int n1 = 100;\n        private static int n2 = 200;\n\n        static class B {//静态内部类有static修饰\n            private int n3 = 300;\n\n            public void say() {\n                System.out.println(\"可以直接访问静态成员（类外）或者类内的所有成员 n2 = \" + n2 + \"  n3 = \" + n3);\n                //System.out.println(n1);//但不能访问类外的非静态成员\n            }\n            public static void t(){\n                System.out.println(\"外部类可以直接访问静态内部类中的静态成员而不需要实例化\");\n            }\n        }\n\n        public void fun(){\n            new B().say();//作用域在整个类中，因为可以在类外访问内部类的成员。\n            // 需要注意的是虽然是静态的内部类，但还需要实例化之后才能访问。因为里面的方法不是静态的，只有类是静态的\n            B.t();//可以直接访问内部类的静态成员\n        }\n    }\n\n    ```\n    4. 静态内部类可以直接访问所有外部类的成员；但外部类想要访问内部类的成员则需要先实例化成对象。或者内部类的成员也是静态的。\n    5. 外部其他类想要使用静态内部类的方式为：\n\n    ```java\n    public class Test {\n       public static void main(String[] args) {\n           //1、外部类名.\n           new A.B().fun();//对于静态内部类的非静态成员需要先实例化成对象\n           A.B.t();//如果成员也是静态的，就可以直接访问\n       }\n    }\n\n    class A {\n       static class B {\n           void fun(){\n               System.out.println(\"在其他类中访问了静态内部类中的普通变量\");\n           }\n           public static void  t(){\n               System.out.println(\"在其他类中访问了静态内部类中的静态变量\");\n           }\n       }\n    }\n    ```\n    6. 同样如果外部类和静态内部类重名时，仍然遵守就近原则。如果想访问外部对象，可以使用 外部类名.成员 的方式进行访问。\n\n       ```java\n       package net.hurr.Interface_;\n\n       public class Test {\n           public static void main(String[] args) {\n               A a = new A();\n               A.B b = new A.B();\n               b.t();\n           }\n       }\n\n       class A {\n           private static int n = 100;\n           static class B {\n               int n = 200;\n               public void t() {\n                   System.out.println(\"就近原则，访问到内部类的成员\" + n);\n                   System.out.println(\"访问外部则需要类名.成员名\" + A.n);//需要注意的是，外部的成员需要是静态的。\n               }\n           }\n       }\n\n       ```\n\n    ### 小结\n\n    ```\n    内部类共有四种，局部内部类、匿名内部类、成员内部类、静态内部类。前两者是在成员内部，后两者的存在地位就是普通类的一个成员（本质）。（重点是匿名内部类）\n    ```\n\n\n    # 枚举和注解\n\n    ## 自定义枚举\n\n    ### 实现方法\n\n    1. 将构造器私有化，防止被直接的new；\n    2. 去掉set相关的方法，防止属性被修改；\n    3. 在类的内部直接创建固定的对象；\n    4. 在第三步的语句前加入final防止被修改；\n\n    ```java\n    class Season {\n        private String name;\n        private String desc;\n\n        private Season(String name, String desc) {\n            this.name = name;\n            this.desc = desc;\n        }\n        //3、在类的内部直接创建固定的对象\n        public static final Season SPRING = new Season(\"春天\",\"温暖\");\n        public static final Season SUMMER = new Season(\"夏天\",\"炎热\");\n        public static final Season AUTUMN = new Season(\"秋天\",\"凉爽\");\n        public static final Season WINTER = new Season(\"冬天\",\"寒冷\");\n    }\n    ```\n    ### 自定义枚举的注意事项\n\n    1. 样式类似于单例模式中的饿汉式；\n    2. 不需要提供set方法，因为对象值通常都是只读的；\n    3. 对枚举的对象或属性一般都使用final+static共同修饰，实现优化；（在使用的时候不会加载类，java8+）\n    4. 枚举对象根据需要，可以有多个属性；（如上方的样例）\n\n    ### 小结\n\n    1. 构造器私有化；\n    2. 本类内部创建一组对象；\n    3. 对外暴露对象（通过为对象添加 public final static 修饰符） ；\n    4. 可以提供 get 方法，但是不要提供 set；\n\n    ## enum关键字的枚举\n\n    ### 实现方法：\n\n    1. 使用关键字 enum 替代 class；\n    2. public static final Season SPRING = new Season(\"春天\", \"温暖\") 直接使用SPRING(\"春天\", \"温暖\") ；（常量名(实参列表)）\n    3. 如果有多个常量(对象)， 使用 ,号间隔即可；（可能编译器只认一条语句？）\n    4. 如果使用 enum 来实现枚举，要求将定义常量对象，写在最前面（与this或super的地位相同）；\n    5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 ()；\n\n    ```java\n    package net.hurr.chapter.enum_;\n\n    public class Test {\n        public static void main(String[] args) {\n            System.out.println(Season.SPRING);\n            System.out.println(Season.SUMMER);\n            System.out.println(Season.AUTUMN);\n            System.out.println(Season.WINTER);\n            System.out.println(Season.OTHER);\n        }\n    }\n\n\n    enum Season {\n        //不再定义对象，直接使用常量名（实参列表）的方式进行说明）\n        SPRING(\"春天\",\"温暖\"),\n        SUMMER(\"夏天\",\"炎热\"),\n        AUTUMN(\"秋天\",\"凉爽\"),\n        WINTER(\"冬天\",\"寒冷\"),\n        OTHER;//若使用无参构造器，则可以不用加括号。\n        private String name;\n        private String desc;\n\n        private Season(String name, String desc) {\n            this.name = name;\n            this.desc = desc;\n        }\n\n        Season() {\n        }\n\n        @Override\n        public String toString() {\n            return \"Season{\" +\n                    \"name='\" + name + '\\'' +\n                    \", desc='\" + desc + '\\'' +\n                    '}';\n        }\n    }\n    ```\n    > 运行结果：\n    >\n    > Season{name='春天', desc='温暖'}\n    > Season{name='夏天', desc='炎热'}\n    > Season{name='秋天', desc='凉爽'}\n    > Season{name='冬天', desc='寒冷'}\n    > Season{name='null', desc='null'}\n    >\n\n    ### enum枚举的注意事项\n\n    1. 当使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类, 而且是一个 final 类；（具体见javap反编译出的内容）\n\n       > 反编译结果：\n       >\n       > Compiled from \"Test.java\"\n       > final class net.hurr.chapter.enum_.Season extends java.lang.Enum<net.hurr.chapter.enum_.Season> {\n       > public static final net.hurr.chapter.enum_.Season SPRING;\n       > public static final net.hurr.chapter.enum_.Season SUMMER;\n       > public static final net.hurr.chapter.enum_.Season AUTUMN;\n       > public static final net.hurr.chapter.enum_.Season WINTER;\n       > public static final net.hurr.chapter.enum_.Season OTHER;\n       > public static net.hurr.chapter.enum_.Season[] values();\n       > public static net.hurr.chapter.enum_.Season valueOf(java.lang.String);\n       > public java.lang.String toString();\n       > static {};\n       > }\n       >\n       > 具体代码：\n       >\n       > enum Season {\n       > SPRING(\"春天\",\"温暖\"),\n       > SUMMER(\"夏天\",\"炎热\"),\n       > AUTUMN(\"秋天\",\"凉爽\"),\n       > WINTER(\"冬天\",\"寒冷\"),\n       > OTHER;//若使用无参构造器，则可以不用加括号。\n       > private String name;\n       > private String desc;\n       >\n       > private Season(String name, String desc) {\n       > this.name = name;\n       > this.desc = desc;\n       > }\n       > Season() {\n       > }\n       > @Override\n       > public String toString() {\n       > return \"Season{\" +\n       > \"name='\" + name + '\\'' +\n       > \", desc='\" + desc + '\\'' +\n       > '}';\n       > }\n       > }\n       >\n    2. 传统的 public static final Season2 SPRING = new Season2(\"春天\", \"温暖\"); 简化成 SPRING(\"春天\", \"温暖\")；（调用了有参构造器，由实参判断）\n    3. 如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略；\n    4. 当有多个枚举对象时，使用逗号间隔，最后有一个分号结尾；\n    5. 枚举对象必须放在枚举类的行首；\n    6. 如果直接输出toString（没有重写的情况下会继承父类的），则会输出常量名。如：\n\n       ```java\n       public class Test {\n           public static void main(String[] args) {\n               Gender a = Gender.BOY;\n               Gender b = Gender.BOY;\n               Gender c = Gender.GIRL;\n               System.out.println(a + \"  \" + b + \"  \" + c);\n             \tSystem.out.println(a == b);\n           }\n       }\n       enum Gender {\n           BOY, GIRL;\n       }\n\n       /*\n       运行结果：\n       BOY  BOY  GIRL\n       true\n       */\n       ```\n    7. 枚举类型只要常量名相同就是同一个。见上方代码，不管BOY被分给了几次，他们都是同一个。具体原理看自定义的枚举的实现方法，在枚举类每个名字不同的常量只有一个实例，调用不过是将这个实例的地址传给不同的对象。\n    8.\n\n    ## enum的常用方法\n\n    ```\n    使用enum关键字的时候，会隐式的继承Enum类，这样我们就可以使用 Enum 类相关的方法。\n    ```\n\n\n    | 方法名           | 详细描述                                                                                                                                                                    |\n    | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n    | valueOf          | 将给定的字符串转换成枚举类型（或者说返回与字符串相同的枚举类型）。如果枚举类内没有匹配的字符串，会抛异常。语法：Season autumn = Season.valueOf(\"AUTUMN\");                   |\n    | values           | 隐藏方法，在源码中无法查看。返回一个数组，数组的内容是当前枚举类中的所有常量。数组类型为对应的枚举类                                                                        |\n    | toString         | 得到当前枚举常量的名称。你可以通过重写这个方法未使得到的结果更易读。                                                                                                        |\n    | equals           | 在枚举类型中可以直接使用”==“来比较两个枚举常量是否相等。Enum提供的这个equals0方法，也是直接使用”等于“实现的。                                                           |\n    | hashCode         | Enum实现了hashCode()来和equals())保持一致。 它也是不可变的。                                                                                                                |\n    | getDeclanngClass | 得到枚举常量所属枚举类型的Class对象。可以用它来判断两个枚举常量是否属千同-一个枚举类型。                                                                                    |\n    | name             | 得到当前枚举常量的名称。toString如果没有重写则同样输出当前常量的名字。                                                                                                      |\n    | ordinal          | 得到当前枚举常量的次序。（从0开始编号，编号的顺序为当前常量在枚举类中的位置）                                                                                               |\n    | compareTo        | 比较两个枚举常量的大小(按照声明的顺序排列，即通过ordinal得到的数) 。返回当前枚举类型减去传入的类型之间相差的个数。等于0时表示两个枚举类型相176                    56 80等。 |\n    | clonee           | 枚举类型不能被Clone。为了防止子类实现克隆方法，Enum实现了一个仅抛出CloneNotSupprtedException异常的不变Clone()                                                               |\n\n    ### enum的注意事项\n\n    1. 使用enum关键字后，就不能再继承其他类了，因为enum会隐式的继承Enum类，而Java中只有单继承，不支持多继承。、\n    2. 除了不能继承其他的类外，enum类也不能被其他类继承\n    3. enum实现的枚举类的本质仍然还是一个类，因此是可以实现接口的，可以被接口所规范。使用时可以通过枚举出的对象.方法名。如下：\n\n       ```java\n       package net.hurr.chapter.enum_;\n       public class Test {\n           public static void main(String[] args) {\n               E.TEST.play();\n           }\n       }\n\n       enum E implements I {\n           TEST;\n           public void play(){\n               System.out.println(\"播放音乐\");\n           }\n       }\n\n       interface I{\n           void play();\n       }\n       ```\n\n    # 注解（Annotation）\n\n    ```\n    注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。\n    ```\n\n    ```\n    在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置等。\n    ```\n\n    ## 基本介绍\n\n    ```\n    使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素。\n    ```\n\n    ## 三个基本的 Annotation\n\n    1. @Override: 限定某个方法，是重写父类方法, 该注解只能用于方法；\n    2. @Deprecated: 用于表示某个程序元素(类, 方法等)已过时；\n    3. @SuppressWarnings: 抑制编译器警告\n\n    ## 基本的 Annotation 应用案例\n\n    ### @Override 注解的案例\n\n    ```java\n    class A{\n        private String s = \"AAA\";\n\n        @Override//放在方法前\n        public String toString() {\n            return s;\n        }\n    }\n    ```\n    ```\n    @Override  放在方法的上一行，表示下面的方法重写了父类的方法。如果不加照样是重写的，但加上的话编译器就会去检查该方法是否真的重写了父类的方法，如果重写了，则编译通过；如果没有重写，则会编译报错。\n    ```\n\n    ```\n    它的价值就在于语法校验。\n    ```\n\n    ```\n    在源码中为：\n    ```\n\n    ```java\n    @Target(ElementType.METHOD)\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface Override {\n    }\n    ```\n    ```\n    上方代码中的@interface 就表明了这是一个注解类。（注意这不是接口！！！）\n    ```\n\n    #### @Override的使用说明\n\n    1. @Override表示指定重写父类的方法(从编译层面验证)， 如果父类没有对应方法，则会报错\n    2. 如果不写@Override注解，而父类仍有public void fly00，仍然构成重写；\n    3. @Override只能修饰方法，不能修饰其它类，包，属性等等；\n    4. 查看@Override注解源码为@ Target(ElementType.METHOD)说明只能修饰方法；\n    5. @Target是**修饰注解的注解，称为元注解**， 记住这个概念；\n\n    ### @Deprecated 注解的案例\n\n    ```\n    用于表示某个程序的元素（比如类、方法）已经过时。\n    ```\n\n    ```\n    只要在类前面加上这个注解，编译器在自动联想搜索的时候，就不会优先选中这个。但这并不代表不能用，还是可以选中的，只是不在第一位了，或者说不推荐使用了。而且选中之后会在使用该类的地方加上删除线。\n    ```\n\n    ```\n    他可以修饰构造器、字段（属性）、局部变量、方法、包、参数、类型。\n    ```\n\n    ```\n    他的用处就是做一个过渡，在版本升级的时候提示某些正在使用的东西在后期是会被淘汰的。\n    ```\n\n    ```\n    源码：\n    ```\n\n    ```java\n    @Documented\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE})\n    public @interface Deprecated {\n        String since() default \"\";\n        boolean forRemoval() default false;\n    }\n    ```\n    ### @SuppressWarnings 注解的案例\n\n    * 当我们不希望看到这些警告的时候，可以使用 SuppressWarnings 注解来抑制警告信息\n    * 在{\"\"} 中，可以写入你希望抑制(不显示)警告信息\n    * 作用的范围与放置的位置有关。他只会作用于下方第一个对象。\n\n    ```\n    可以指定的警告类型有：\n    ```\n\n\n    | 关键字                   | 用途                                                   |\n    | ------------------------ | ------------------------------------------------------ |\n    | all                      | 抑制所有警告                                           |\n    | boxing                   | 抑制与封装/拆装作业相关的警告                          |\n    | cast                     | 抑制与强制转型作业相关的警告                           |\n    | dep-ann                  | 抑制与淘汰注释相关的警告                               |\n    | deprecation              | 抑制与淘汰的相关警告                                   |\n    | fallthrough              | 抑制与switch陈述式中遗漏break相关的警告                |\n    | finally                  | 抑制与未传回finally区块相关的警告                      |\n    | hiding                   | 抑制与隐藏变数的区域变数相关的警告                     |\n    | incomplete-switch        | 抑制与switch陈述式(enum case)中遗漏项目相关的警告      |\n    | javadoc                  | 抑制与javadoc相关的警告                                |\n    | nls                      | 抑制与非nls字串文字相关的警告                          |\n    | null                     | 抑制与空值分析相关的警告                               |\n    | rawtypes                 | 抑制与使用raw类型相关的警告                            |\n    | resource                 | 抑制与使用Closeable类型的资源相关的警告                |\n    | restriction              | 抑制与使用不建议或禁止参照相关的警告                   |\n    | serial                   | 抑制与可序列化的类别遗漏serialVersionUID栏位相关的警告 |\n    | static-access            | 抑制与静态存取不正确相关的警告                         |\n    | static-method            | 抑制与可能宣告为static的方法相关的警告                 |\n    | super                    | 抑制与置换方法相关但不含super呼叫的警告                |\n    | synthetic-access         | 抑制与内部类别的存取未最佳化相关的警告                 |\n    | sync-override            | 抑制因为置换同步方法而遗漏同步化的警告                 |\n    | unchecked                | 抑制与未检查的作业相关的警告                           |\n    | unqualified-field-access | 抑制与栏位存取不合格相关的警告                         |\n    | unused                   | 抑制与未用的程式码及停用的程式码相关的警告             |\n\n    #### 用法：\n\n    ```\n    在想要使用的对象的上一行，写上：\n    ```\n\n    ```java\n    @SuppressWarnings(\"关键字\")\n    ```\n    如：让编译器忽略下方的类中所有的因未被使用所造成的警告：\n\n    ```java\n    @SuppressWarnings(\"unused\")\n    class A{\n        public int n1 = 10;\n        private int i;\n        public void hi(){\n        }\n    }\n    ```\n    ## JDK的元注解\n\n    ```\n    简单的说就是修饰注解的注解。\n    ```\n\n\n    ### 元注解的种类\n\n\n    | 注解类型   | 用途                                         |\n    | ---------- | -------------------------------------------- |\n    | Retention  | 指定注解的作用范围，三种 SOURCE,CLASS,RUNTIM |\n    | Target     | 指定注解可以在哪些地方使用                   |\n    | Documented | 指定该注解是否会在 javadoc中体现             |\n    | Inherited  | 子类会继承父类的注解                         |\n\n    #### Retention注解\n\n    ```\n    只能用于修饰一个 Annotation （注解）定义, 用于指定该 Annotation 可以保留多长时间（或者说保留范围）, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值:\n    ```\n\n    1. RetentionPolicy.SOURCE: 编译器使用后，直接丢弃这种策略的注释。简单的说就是只在源码阶段是生效的，往后的.class文件不保留；\n    2. RetentionPolicy.CLASS: 编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 不会保留注解。 这是默认值。简单的说就是上一个的扩展版，将注解保留至class文件1中；\n    3. RetentionPolicy.RUNTIME:编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注解. 程序可以 通过反射获取该注解。这是所有注解中保留范围最长的，当程序在运行的时候，jvm虚拟机仍然会去读取该注解，并作出相应的处理。\n\n    ```\n    例如下方的Deprecated注解的源码，就有这个注解的存在\n    ```\n\n    ```java\n    @Documented\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE})\n    public @interface Deprecated {\n        String since() default \"\";\n        boolean forRemoval() default false;\n    }\n    ```\n    其中的Retention的值为RetentionPolicy.RUNTIME，因此在javac编译的时候，就会提示一下信息：\n\n    > 注: Test.java使用或覆盖了已过时的 API。\n    > 注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。\n    >\n\n    #### Target注解\n\n    ```\n    用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素。\n    ```\n\n    ```\n    @Target也包含一个名为value的成员变量。\n    ```\n\n    ```\n    比如下方的一个SupperssWarnings注解的一个源码\n    ```\n\n    ```java\n    @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE})\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface SuppressWarnings {\n        String[] value();\n    }\n    ```\n    ```\n    可以看到其中就有Target注解的存在，正因为他的存在，所以这个SupperssWarnings注解就可以用于修饰TYPE（类型）, FIELD（字段/属性）, METHOD（方法）, PARAMETER（参数）, CONSTRUCTOR（构造器）, LOCAL_VARIABLE, MODULE这些类型。\n    ```\n\n    #### Documented注解\n\n    ```\n    用于指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档。\n    ```\n\n    ```\n    即在生成文档时，可以看到该注解。\n    ```\n\n    ```\n    例如如下的Deprecated注解的源码，就有这个注解的存在\n    ```\n\n    ```java\n    @Documented\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE})\n    public @interface Deprecated {\n        String since() default \"\";\n        boolean forRemoval() default false;\n    }\n\n    ```\n    # 异常\n\n    ## 基本概念\n\n    将程序执行中发生的不正常的情况称为异常。\n\n    **根据异常的发生情况可以分成两大类：运行时异常和编译时异常。**\n\n    ```\n    运行异常是指在运行阶段会触发的异常，比如数组越界、空间不足等情况。运行时异常编译器检查不出来。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。\n    ```\n    **对于运行时异常，可以不作处理**，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。\n\n    ```\n    而\n    ```\n    **编译异常是必须要处理**的，不然通过不了编译。比如打开文件但文件不存在等情况\n\n    **执行过程中所发生的异常事件可分为两大类：ERROR（错误）和Exception。**\n\n    ```\n    ERROR： Java虚拟机无法解决的严重问题。如: JVM系统内部错误、资源耗尽等严重情况。比如: StackOverflowError[栈溢出]和OOM(out of memory)，Error 是严重错误，程序会崩溃。\n    ```\n\n    ```\n    Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等，Exception 分为两大类:运行时异常[程序运行时，发生的异常]和编译时异常[编程时，编译器检查出的异常]。\n    ```\n\n    ## 异常处理\n\n    当异常发生时，对异常的处理方式。\n\n    * try - catch - finally\n      * 将捕获到的异常自行处理。\n    * throws\n      * 发生异常后不处理，直接抛出，谁调用谁接收。\n\n    ## try - catch异常处理\n\n    ```\n    Java提供try和catch块来处理异常。try块用于包含可能出错的代码。catch块用于处理try块中发生的异常。可以根据需要在程序中有多个try...catch块。\n    ```\n\n\n    ### 基本语法\n\n    ```java\n    try{\n      //可能会出异常的代码\n    }catch(异常){\n      //出异常后会执行的代码。\n      //catch块可以有多个，\n    }finally{\n      //不管异常是否发生，此处的代码都会被执行。如关闭连接、释放资源等。此块可以缺省不写。\n    }\n    ```\n    #### 样例\n\n    ```java\n    try {\n                String str = \"aaa\";\n                int n = Integer.parseInt(str);\n                System.out.println(n);\n            }\n            catch (Exception e) {\n                System.out.println(\"异常信息为：\" + e.getMessage());\n            }\n            System.out.println(\"程序继续执行\");\n    ```\n    > 运行结果：\n    >\n    > 异常信息为：For input string: \"aaa\"\n    > 程序继续执行\n    >\n\n    ### try - catch的细节\n\n    1. 如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块；如果存在finally块，还会执行finally块中的语句。\n    2. 如果异常没有发生，则顺序执行try的代码块，不会进入到catch。如果存在finally块，还会执行finally块中的语句。\n    3. 如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)则使用finally {}。需要注意的是，一旦有这个finally，哪怕 try或catch里面有return，也不会退出，而是执行finally语句块。虽然return暂时不会执行，但return后面的语句照样会被执行。如：\n\n       ```java\n       static int fun(){\n         int i = 0;\n         try {\n           int n1=2,n2=0;\n           int res = n1/n2;//出现异常\n           return i;\n         }\n         catch (Exception e) {\n           return ++i;//注意，此处的++i执行了，但并没有返回，因为下面的finally有返回了。\n         }\n         finally {\n           return ++i;//执行了并且返回了。\n         }\n       }\n\n       public static void main(String[] args) {\n         System.out.println(fun());\n       }\n\n       /*\n       执行结果：2\n       */\n       ```\n       如果finally中没有return退出语句，则还是会回到catch中执行对应的return。如：\n\n       ```java\n        static int fun(){\n               int i = 1;\n               try {\n                   i++;\n                   int n1=2,n2=0;\n                   int res = n1/n2;//制造异常\n               }\n               catch (Exception e) {\n                   ++i;\n                   return i;//执行到此i会被暂时保存，直到执行完finally为止。如果finally中没有结束程序，再回头将保存的给返回回去。\n               }\n               finally {\n                   i++;\n                   System.out.println(\"i = \" + i);\n               }\n               return 0;\n           }\n\n           public static void main(String[] args) {\n               System.out.println(fun());\n           }\n\n       //执行结果：\n       //i = 4\n       //3\n\n       ```\n    4. 可以有多个catch语句捕获不同的异常(进行不同的业务处理)，要求**父类异常在后，子类异常在前**，比如(Exception 在后，NullPointerException 在前）。如果发生异常，只会匹配一个catch。\n\n    ```\n    如：\n    ```\n\n    ```java\n    public class Test {\n        public static void main(String[] args) {\n            try {\n                Person person = new Person();\n                person = null;//空指针异常，NullPointerException\n                System.out.println(person.getName());\n                int n1 = 10, n2 = 0;\n                int res = n1 / n2;//算数异常，\n            }\n            catch (NullPointerException e) {\n                System.out.println(\"空指针异常：\" + e);\n            }\n            catch (ArithmeticException e) {\n                System.out.println(\"算术异常：\" + e);\n            }\n            catch (Exception e) {\n                System.out.println(\"其他异常\" + e);\n            }\n        }\n    }\n    class Person {\n        private String name = \"Jack\";\n\n        public String getName() {\n            return name;\n        }\n    }\n\n    ```\n    5. 可以省略catch，直接进行try-finally配合使用，这种用法**相当于没有捕获异常**，因此程序会直接崩掉/退出。比如发生异常后不进行处理，只负责关闭一些连接然后崩溃。因为没有处理异常，所以会被默认的throws抛出，层层上抛，直到JJVM机，然后JVM将异常信息打出来，并结束程序。\n\n    ### 案例：利用try - catch使的用户输入的必须是整数，不是就重输\n\n    ```java\n    Scanner scanner = new Scanner(System.in);\n            int num;\n            while (true){\n                try {\n                    num = Integer.parseInt(scanner.next());//如果输入的字符串不是纯整数，就会抛异常；\n                    break;//只要抛异常就不会执行退出\n                }\n                catch (NumberFormatException e) {\n                    System.out.println(\"输入有误，请重新输入\");//检测到异常后输出提示信息让用户重新输入。\n                }\n            }\n    ```\n    ## throws\n\n    ### 基本介绍和使用细节\n\n    1. 如果个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。\n    2. 在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。\n    3. 对于**编译异常**，程序中必须处理，比如 try - catch 或者throws。\n\n       ```java\n       public void f2() throws Exception {//针对编译异常必须要有对应的异常处理才能通过。可以抛出对应的FileNotFoundException异常或者对应异常的父类异常Exception\n               FileInputStream fileInputStream = new FileInputStream(\"D://test.txt\");//这里创建了一个文件流，但因为不存在文件所以会报异常（编译异常）\n           }\n       ```\n    4. 对于**运行异常**，程序中如果没有处理，默认就是throws的方式处理。知道throws到JVM虚拟机为止。JVM处理异常的功能就是，将异常打印出来，并中断运行。\n    5. 子类重写父类的方法时，所抛出的异常类型要么和父类抛出的异常一致， 要么为父类抛出的异常的类型的子类型。或者说子类不能扩大父类的异常范围，也不能和父类没有关系。如：\n\n       ```java\n       class A{\n           public void f() throws ArithmeticException{\n           }\n       }\n       class B extends A{\n           @Override\n           public void f() throws ArithmeticException {//只能是父类类A中原函数抛出异常的子类或者他自己，不能比父类大，如Exception\n           }\n       }\n       ```\n    6. 在throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必throws。\n    7. 如果一个方法调用了另一个存在编译异常且直接throws抛出的方法，则在调用该方法的时候必须明确的处理。\n\n       哪怕只是抛出但并没有真正的触发\n\n       ```java\n       public void f1(){\n               f2();//哪怕只是抛出但并没有真正的触发也得处理\n           }  \n           public void f2() throws FileNotFoundException {    }\n       ```\n       ```java\n       public void f1(){\n               try {\n                   f2();//对于调用的方法如果存在编译异常，则必须对这个异常进行显示(明确)的处理，再次throws抛出或者try\n               }\n               catch (FileNotFoundException e) {\n                   throw new RuntimeException(e);//也可以捕获了再抛出\n               }\n           }\n           public void f2() throws FileNotFoundException {//此处不做处理 直接抛出\n               //创建一个编译异常\n               FileInputStream fileInputStream = new FileInputStream(\"D://test.txt\");\n           }\n       ```\n       或者在方法内就try - catch处理掉，或者捕获后再抛出：\n\n       ```java\n       public void f(){\n               f2();//可以不处理\n           }\n           public void f1(){\n               try {\n                   f2();//也可以处理\n               }\n               catch (Exception e) {\n                   System.out.println(e);\n               }\n           }\n           public void f2() {//此处不做处理 直接抛出\n               //创建一个编译异常\n               try {\n                   FileInputStream fileInputStream = new FileInputStream(\"D://test.txt\");\n               }\n               catch (FileNotFoundException e) {\n                   throw new RuntimeException(e);//如果这样抛，也可以调用者也可以不用处理。\n               }\n           }\n       ```\n    8. 对于**运行异常调用者可以不进行处理。因为存在默认的处理机制**\n\n       ```java\n       public void f(){\n               f2();//可以不处理，因为有默认的处理机制\n           }\n           public void f1(){\n               try {\n                   f2();//也可以处理一下\n               }\n               catch (ArithmeticException e) {\n                   System.out.println(e);\n               }\n           }\n           public void f2() throws ArithmeticException{//此处不做处理 直接抛出\n               int res = 10/0;\n           }\n       ```\n\n    ## 自定义异常\n\n    ```\n    当程序中出现了某些\"错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息。\n    ```\n\n    ### 自定义异常的步骤\n\n    1. 定义类自定义异常类名(程序员自己写)继承Exception或RuntimeException；\n    2. 如果继承Exception，属于编译异常；\n    3. 如果继承RuntimeException，属于运行异常（一般来说，继承RuntimeException，因为可以使用默认的异常处理机制）；\n\n    #### 样例：要求：当我们接收Person对象年龄时，要求范围在18 - 120之间，否则抛出一个自定义异常(要求继承RuntimeException)并给出提示信息\n\n    ```java\n    public class Test {\n        public static void main(String[] args) {\n            int age1 = 16;\n            if (!(age1 >= 18 && age1 <= 120)) {//设定一个范围\n                throw new AgeException(\"年龄需要在18-120之间\");//通过构造器设置异常的信息\n            }\n            System.out.println(\"年龄范围正常\");\n        }\n    }\n\n    class AgeException extends RuntimeException {//自定义一个异常类，因为要求是运行时异常，所以继承RuntimeException\n        public AgeException(String message) {//类的构造函数\n            super(message);\n        }\n    }\n    ```\n    > 运行结果：\n    >\n    > Exception in thread \"main\" net.hurr.exception_.AgeException: 年龄需要在18-120之间\n    > at net.hurr.exception_.Test.main(Test.java:10)\n    >\n\n    ### throw和throws的区别\n\n\n    | 名字   | 意义                 | 位置         | 后面跟的东西 |\n    | ------ | -------------------- | ------------ | ------------ |\n    | throws | 异常处理的一种方式   | 方法的声明处 | 异常类型     |\n    | throw  | 手动生成异常的关键字 | 方法体中     | 异常对象     |\n\n    # 常用类\n\n    ## 包装类\n\n    ```\n    针对八种基本定义相应的引用类型——包装类。\n    ```\n\n    ```\n    有了类的特点，就可以调用类中的方法。\n    ```\n\n\n    | 基本数据类型 | 包装类    | 父类   |\n    | ------------ | --------- | ------ |\n    | boolean      | Boolean   |        |\n    | char         | Character |        |\n    | byte         | Byte      | Number |\n    | short        | Short     | Number |\n    | int          | Integer   | Number |\n    | long         | Long      | Number |\n    | float        | Float     | Number |\n    | double       | Double    | Number |\n\n    ### 包装类与基本数据类型的转换\n\n    * jdk5前的手动装箱和拆箱方式，装箱:基本类型->包装类型，反之，就是拆箱\n\n    - jdk5以后(含jdk5)的自动装箱和拆箱方式\n      - 自动装箱底层调用的是valueOf方法，比如Integer.valueOf()\n\n    ### 装箱和拆箱的演示\n\n    ```java\n    //int <---> Integer\n    //手动装箱\n    int n1 = 100;\n    Integer integer = new Integer(n1);\n    Integer integer1 = Integer.valueOf(n1);//或者这样\n    //手动装箱\n    int i = integer.intValue();\n\n\n    //jdk5（包括5）以后的自动装箱拆箱\n    int n2 = 200;\n    Integer integer2 = n2;//底层依然是Integer.valueOf(),本质仍然是手动装箱\n    int n3 = integer2;//同样，底层也还是手动拆箱的intValue()\n\n    //同理，其他的数据类型也可以这么玩\n    char c = 'A';\n    Character C = c;\n    double d = new Double(20.2);\n    ```\n    ### 包装类型与String类型的相互转换\n\n    ```java\n            //包装类 -> String\n            Integer n = 100;\n            //方式1：相当于生成一个新的串赋值给s1，而i的值不会变\n            String s1 = n+\"\";\n            //方式2：比较传统，几乎所有包装类都有这个方法\n            String s2 = n.toString();      \n            String s3 = new Character('a').toString();\n            //方式3 相当于转换了两次，i变成了obj，obj再到string\n            String s4 = String.valueOf(n);\n\n            //String -> 包装类\n            String str = \"12345\";\n            Integer i1 = Integer.parseInt(str);\n            Double d = Double.parseDouble(str);\n            Integer i2 = new Integer(str);//利用Integer的构造方法\n    ```\n    需要注意的是，当包装类与基本类型相比较的时候，比较的是值而非类型或地址。如：\n\n    ```java\n    int n1 = 100;\n    Integer n2 = new Integer(100);\n    System.out.println(n1 == n2);\n    ```\n    执行之后会显示true。但Sting没有基本类型，所以如果这么比较，会是false\n\n    ```java\n    String s1 = \"A\";\n            String s2 = new String(\"A\");\n            System.out.println(s1 == s2);\n    ```\n    ## String\n\n    ### 介绍\n\n    1. String对象用于保存字符串，也就是一组字符序列。\n    2. 字符串常量对象是用双引号括起的字符序列。例如: \"你好\"、 \"12.97\"、 \"boy\"等。\n    3. 字符串的字符使用Unicode字符编码，一个字符(不区分字母还是汉字)占两个字节。\n    4. String类较常用构造器(其它看手册):\n\n    ```java\n    String s1 = new String();\n    String s2 = new String(String original);\n    String s3 = new String(char[] a);\n    String s4 = new String(char[] a,int startIndex,int count)//从字符数组中初始化，从第几位开始，获取几个\n    ```\n    ### 创建 String对象的方式\n\n    - 方式一:直接赋值String s1 = \"hurriedlu\";\n    - 方式二:调用构造器String s2 = new String(\"hurriedlu\");\n\n    #### 两种创建 String对象的区别\n\n    ```\n    方式一：先从常量池查看是否有对应字符串的数据空间，如果有，直接指向;如果没有则重新创建，然后指向。\n    ```\n    **s1最终指向的是常量池的空间地址**。\n    \t\t方式二：先在堆中创建空间，里面维护了value属性，指向常量池的对应字符串的空间。如果常量池没有\"hsp\",重新创建，如果有，直接通过value指向。 s2最终指向的是堆中的空间地址。\n\n    ```\n    简单的说，方式一的直接赋值相当于直接指向对应的空间，方式二通过构造函数的方式赋值相当于先创建一个对象，再由对象指向对应的空间。\n    ```\n\n    ### String的父类和接口\n\n    接口：Serializable（实现了这个接口说明这个类可以串行化，以便在网络中传输），Comparable（实现了这个接口说明这个类可以相互比较），CharSequence。\n\n    ### String的特性\n\n    1) String是一个final类， 代表不可变的字符序列，也就是说不能被其他类所继承并改写。\n    2) 字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的。\n    3) String的底层还是数组，在String类中维护了一个可变长度的finial类型的value数组，字符串就存储在这个数组中。value一旦指向了某块地址，就不能再指向其他的地址（空间）了。但这块地址的值还是可以随便修改的。\n\n    ### 常见的误区\n\n    ```java\n    public class Test {\n        public static void main(String[] args) {\n            System.out.println(\"========================================\");\n            System.out.println(\"1：\");\n            //1、求输出结果\n            String s1 = \"abc\";\n            String s2 = \"abc\";\n            System.out.println(s1.equals(s2));//T，因为equals函数是值比较\n            System.out.println(s1 == s2);//T,因为指向的是同一个常量池中的地址。\n\n            System.out.println(\"========================================\");\n            System.out.println(\"2：\");\n            //2、求输出结果\n            String s3 = \"hurr\";\n            String s4 = new String(\"hurr\");\n            System.out.println(s3.equals(s4));//T,因为是值比较\n            System.out.println(s3 == s4);//F,s3是直接指向常量池中的字符串，s4是指向堆中的一个对象，所以地址不同\n            System.out.println(s3 == s4.intern());//T,因为intern方法是返回常量池的地址，而s3也是常量池中的一个地址\n            System.out.println(s4 == s3.intern());//F,因为intern方法是返回常量池的地址，而s4是堆中一个对象的地址\n\n            System.out.println(\"========================================\");\n            //3、问：以下语句创建了几个对象？\n            String s5 = \"hello\";\n            s5 = \"World\";\n            //一共创建了两个对象。字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的。\n            //因此，原来的仍然会保留，只是又新建了一个World的字符串，然后将s5指向了这个字符串。\n\n            //4、问：以下语句创建了几个对象？\n            String s6 = \"Hello\" + \"World\";\n            //注意，只创建了一个。因为编译器在底层有一个优化，避免了两个字符串没有使用却要占地方，因此等价于String s6 = \"HelloWorld\";\n\n            //5、问：以下语句创建了几个对象？\n            String s7 = \"Hello\";\n            String s8 = \"World\";\n            String s9 = s7 + s8;\n            //一共创建了三个。具体流程如下：\n            //1. 首先新建一个s9的对象；2. 在常量池中创建一个Hello；3. 在第二步创建的常量后面追加World；4. 将s9中的value指针指向第二步创建的常量。\n\n            System.out.println(\"========================================\");\n            System.out.println(\"6：\");\n            //6、问：以下语句的输出情况\n            String s10 = \"Hello\";\n            String s11 = \"World\";\n            String s12 = (s7 + s8).intern();\n            String s13 = \"HelloWorld\";\n            System.out.println(s12 == s13);//T\n            System.out.println(s12.equals(s13));//T\n        }\n    }\n    ```\n    ### String 常用的方法\n\n    ```\n    String类是保存字符串常量的。每次更新都需要重新开辟空间，效率较低，因此java设计者还提供了StringBuilder和StringBuffer来增强String的功能，并提高效率。\n    ```\n\n\n    | 方法名           | 作用                                                                                                                                                                                                      |\n    | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n    | equals           | 比较两个字符串（String对象）的值是否相等。s1.equal(s2);                                                                                                                                                   |\n    | equalsIgnoreCase | 比较两个字符串是否相等（忽略大小写）。s1.equalsIgnoreCase(s2);                                                                                                                                            |\n    | length           | 返回字符串的长度。s1.length();                                                                                                                                                                            |\n    |                  |                                                                                                                                                                                                           |\n    |                  |                                                                                                                                                                                                           |\n    |                  |                                                                                                                                                                                                           |\n    | intern()         | 如果常量池已经包含一个等于此String的对象，就返回池中的字符串；否则将此String添加到池中，并返回此String对象的引用<br />简单的说就是，返回常量池对应的字符串的地址，相当于返回用方式1新建出来的String对象。 |\n\n    equals //区分大小写，判断内容是否相等\n    equalslgnoreCase //忽略大小写的判断内容是否相等\n    length /获取字符的个数，宇符串的长度\n    indexOf //获取字符在字符串中第1次出现的索引,索引从开始，如果找不到，返回-1\n    lastIndexOf //获取字符在字符串中最后1次出现的索引,索引从开始，如找不到，返回-1\n    substring //截取指定范围的子串\n    trim //去前后空格\n    charAt:获取某索引处的字符，注意不能使用Str[index]这种方式\n\n    toUpperCase\n    toLowerCase\n    concat\n    replace替换字符串中的字符\n    split分割字符串，对于某些分割字符，我们需要转义比如| l\\等\n    案例: String poem = \"锄禾日当午,汗滴禾下土，谁知盘中餐,粒粒皆辛苦\":和文\n    件路径.\n    compareTo //比较两个字符串的大小\n    toCharArray //转换成字符数组\n    format //格式字符串，%s宇符串%c字符%d整型%.2f浮点型\n    案例，将一个人的信息格式化输出\n\n    ### StringBuffer\n\n    * java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删。\n    * 很多方法与String相同，但StringBuffer是可变长度的。\n    * StringBuffer是一个容器。\n\n    #### StringBuffer的特性\n\n    1. StringBuffer 的直接父类 是 AbstractStringBuilder；\n    2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化；\n    3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final，因此该 value 数组存放在堆中而不是常量池；\n    4. StringBuffer 是一个 final 类，不能被继承 ；\n    5. 因为 StringBuffer 字符内容是存在 char[] value, 所有的变化(增加/删除) 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String\n\n    #### String 和 StringBuffer的区别\n\n    1) String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址， 效率较低//private final char value[];\n    2) StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次更新地址（只有在空间不够的时候才会更新，即不支持动态调整空间），效率较高\n       //char[] value; /这个放在堆.\n\n    #### StringBuffer的构造器\n\n    StringBuffer()\n    构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符。\n    简单的说就是，创建一个大小为 16 的char[]，用于存放字符内容。\n\n    StringBuffer(CharSequence seq)\n    public java.lang StringBuilder(CharSequence seq)构造-一个字符串缓冲区，它包含与指定的CharSequence相同的字符。\n\n    StringBuffer(int capacity) //capacity [容量]\n    构造一个不带字符，但具有指定初始容量的字符串缓冲区。即对char[]大小进行指定\n    和第一个构造器类似，简单的说就是可以指定初始空间的大小。\n\n    StringBuffer(String str)\n    构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容。\n    简单的说就是用已有的str对象创建一个StringBuffer对象，其空间大小为str字符串的长度+16.\n    需要注意的是，如果str是一个空串，则会抛出空指针异常。因为在源码中需要先计算。如下代码所示\n\n    ```java\n    String str = null;\n    StringBuffer s = new StringBuffer(str);\n    ```\n    ```\n    会抛出空指针异常。（java.lang.NullPointerException）因为在底层会先获取str的长度，而空串是没有长度的。\n    ```\n\n    需要注意的是，如果用于初始化的数组\n\n    #### String 和 StringBuffer相互转换\n\n    ##### String 转 StringBuffer\n\n    ```\n    简单的说就是利用上方第四个构造器，创建一个StringBuffer对象；\n    ```\n\n    ```java\n    String str = \"hurriedlu\";\n    StringBuffer stringBuffer = new StringBuffer(str);//注意，返回的只是一个利用str的值创建StringBuffer的对象，对他本身没有影响。\n    ```\n    ```\n    同样也可以利用追加的方式\n    ```\n\n    ```java\n    StringBuffer stringBuffer1 = new StringBuffer();\n    stringBuffer1 = stringBuffer1. append(str);//将str的值追加到新创的append里面。\n    ```\n    ##### StringBuffer 转 String\n\n    同样也可以利于构造器进行转换\n\n    ```java\n    StringBuffer stringBuffer = new StringBuffer(\"Hurriedlu\");\n    String s1 = new String(stringBuffer);\n    ```\n    利用StringBuffer的toString方法：\n\n    ```java\n    StringBuffer stringBuffer3 = new StringBuffer(\"Hurriedlu\");\n    String str = stringBuffer3.toString();\n    ```\n    #### StringBuffer的常用方法\n\n    1. 追加（增）\n\n       ```java\n       StringBuffer s = new StringBuffer(\"hello\");\n       s.append(',');\n       s.append(\"worle\");\n       s.append(\"!\").append(100).append(true).append(10.5);//append可以连，且返回值都是StringBuffer的类型。\n       System.out.println(s);//hello,worle!100true10.5\n       /*\n       需要注意的是，如果追加的字符串是空，是null，则将null转换成字符串的“null”追加到后面。\n       */\n       ```\n    2. 删\n\n       ```java\n       StringBuffer s = new StringBuffer(\"helloworld\");\n       s.delete(5,10);//删除字符串序列中大于等于start,小于end的字符，小于10的字符。（序号从0起，左闭右开，类似于c++里面的迭代器）\n       System.out.println(s);//hello\n       ```\n    3. （替换）改\n\n       ```java\n       StringBuffer s = new StringBuffer(\"hello123world\");\n       s.replace(5,8,\",\");//同上面的删除功能，左闭右开，从0起，将区间内的文字替换成第三个参数\n       System.out.println(s);//hello,world\n       ```\n    4. 查\n\n       ```java\n       StringBuffer s = new StringBuffer(\"123123123\");\n       int index = s.indexOf(\"2\");//返回第一次出现实参数据的位置，此处返回1.因为序列是从0起\n       System.out.println(index);\n       ```\n    5. 插\n\n       ```java\n       StringBuffer s = new StringBuffer(\"Hello,!\");\n       s.insert(6,\"World\");//从0起，在第6个的位置插入参数2的数据,原来在参数1及后面的位置的数据自动后移\n       System.out.println(s);//Hello,World!\n       ```\n    6. 长度\n\n       ```java\n       StringBuffer s = new StringBuffer(\"Hello\");\n       int len = s.length();//返回字符串的长度\n       System.out.println(len);//5\n       ```\n\n    ### StringBuilder\n\n    ```\n    StringBuilder一个可变的字符序列。此类提供一个与StringBuffer兼容的APl,但不保证同步(换句话说就是StringBuilder不是线程安全的)。该类被设计用作StringBuffer的一个简易替换，\n    ```\n    **用在字符串缓冲区被单个线程使用的时候**。如果可能，建议优先采用该类！因为在大多数实现中，它比StringBuffer要快。\n    \t\t在StringBuilder上的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据。\n\n    #### StringBuilder 常用方法\n\n    ```\n    StringBuilder和StringBuffer均代表可变的字符序列，方法是一样的，所以使用和StringBuffer一样。\n    ```\n\n    #### StringBuilder的特点\n\n    1. StringBuilder 继承 AbstractStringBuilder 类；\n    2. 实现了 Serializable ,说明 StringBuilder 对象是可以串行化(可以串行话说明对象可以网络传输，也可以保存到文件)\n    3. StringBuilder 是 final 类, 不能被继承；\n    4. StringBuilder 对象字符序列仍然是存放在其父类 AbstractStringBuilder 的 char[] value，因此，字符序列是存放在堆中的；\n    5. StringBuilder 的方法没有做互斥的处理,即没有 synchronized 关键字,因此最好**只在单线程的情况下使用**。\n\n    ### String、StringBuffer 和 StringBuilder的比较\n\n    1) StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样；\n    2) String:不可变字符序列，效率低，但是**复用率高**（因为字符串只会出现一次，后续的都会指向常量池中这唯一的一个）；\n    3) StringBuffer:可变字符序列、效率较高(增删)、线程安全；\n    4) StringBuilder: 可变字符序列、**效率最高**、**线程不安全**；\n    5) String使用注意说明:\n       string s=\"a\"; //创建了一个字符串\n       S += \"b\"; //实际上原来的\"a\"字符串对象已经丢弃了（但还存在），现在又产生了一个字符串s+\"b\" (也就是\" ab\")。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。结论:如果我们对String做大量修改，不要使用String\n\n    ### String、StringBuffer 和 StringBuilder 的应用场景\n\n    1. 如果字符串存在大量的修改操作，-般使用StringBuffer或StringBuilder\n    2. 如果字符事存在大量的修改操作，并在单线程的情况，使用StringBuilder\n    3. 如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer\n    4. 如果我们字符串很少修改，被多个对象引用，使用String,比如配置信息等\n\n    ## Math类\n\n    Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。\n\n    ### Math常用的方法（均为静态方法）\n\n    #### abs  求绝对值\n\n    ```java\n    int n1 = Math.abs(-2);\n    double n2 = Math.abs(-9.8);\n    System.out.println(\"n1 = \" + n1 + \"   n2 = \" + n2);//n1 = 2   n2 = 9.8\n    ```\n    #### pow 求幂（返回值为double）\n\n    ```java\n    double s = Math.pow(2,3);//8.0，2的3次方\n    ```\n    #### ceil 向上取整（返回大于等于该参数的最小整数，返回值依然是double）\n\n    ```java\n    double s = Math.ceil(2.8);//3.0\n    ```\n    #### floor 向下取整（返回小于等于该参数的最小整数，返回值依然是double）\n\n    ```java\n    double s = Math.floor(2.8);//2.0\n    ```\n    #### round 四舍五入（返回值为long，约等于Math.floor(该参数+0.5)？）\n\n    ```java\n    long s = Math.round(2.8);//3\n    ```\n    #### sqrt 求算数平方根（要求参数为大于等于0的非负数）\n\n    ```java\n    double sqrt = Math.sqrt(9);//3.0\n    ```\n    #### random 求随机数（返回一个大于等于0并且小于1之间的一个小数）\n\n    ```java\n    double rand = Math.random()\n    ```\n    扩展：求一个给定的范围之间的随机数（大于等于a , 小于等于b）\n\n    ```java\n    int n = (int)(a + Math.random() * (b - a + 1));\n    ```\n    #### max , min 返回最大值和最小值\n\n    ```java\n    int maxx = Math.max(2,3);//3\n    int minn = Math.max(2,3);//2\n    ```\n    ## Arrays\n\n    该类的主要作用就是用于管理和操作数组（如排序、搜索等）\n\n    ### Arrays的常用方法\n\n    #### toString\t以字符串形式返回数组中的元素\n\n    ```java\n    int arr[] = {1,3,7,5};\n    System.out.println(Arrays.toString(arr));//[1, 3, 7, 5]\n    ```\n    #### sort排序（同c++一样，默认从小到大，也支持自定义）\n\n    ```java\n    int arr[] = {1, 3, 7, 5, -1};\n    Arrays.sort(arr);\n    System.out.println(Arrays.toString(arr));//[-1, 1, 3, 5, 7]\n    ```\n    支持的数组类型：int,long,short,char,byte,float,double等。\n\n    同时，在Java中也支持sort的排序规则自定义（利用实现了Comparable接口的一个匿名内部类，要求实现 compare方法）。（ sort(T[] a , Comparator <? super T> c ) ）\n\n    ```java\n    Integer arr[] = {1, 3, 7, 5, -1};//注意这里一定要是Integer,不能是int数组\n    Arrays.sort(arr,new Comparator(){\n      public int compare(Object o1,Object o2){\n        Integer i1 = (Integer) o1;\n        Integer i2 = (Integer) o2;\n        return i2-i1;\n      }\n    });\n    System.out.println(Arrays.toString(arr));//[7, 5, 3, 1, -1]\n    ```\n    #### binarySearch\t通过二分搜索法进行查找，要求必须排好序\n\n    ```java\n    Integer arr[] = {1, 3, 7, 5, -1};//注意这里一定要是Integer,不能是int数组\n    Arrays.sort(arr);//因为查找是基于二分的，所以要求序列有序.[-1, 1, 3, 5, 7]\n    int index;\n    //index = Arrays.binarySearch(arr, 5);//3\n    index = Arrays.binarySearch(arr, 0);//-2\n    //这个方法的一个特点就是，如果找不到，就返回这个数应该在的位置，并置为负数。简单的说就是返回左右指针相等的那个值的负数\n    ```\n    #### copyOf\t数组元素复制\n\n    ```java\n    Integer arr[] = {1, 3, 7, 5, -1};//注意这里一定要是Integer,不能是int数组\n    Integer num[] = Arrays.copyOf(arr,arr.length);//从arr数组复制，复制arr.length个元素\n    System.out.println(arr == num);//F，这是两个除了值一样其余完全不相干的数组\n    System.out.println(Arrays.equals(arr,num));//T\n    ```\n    #### fill 数组元素填充\n\n    ```java\n    Integer arr[] = {1, 3, 7, 5, -1};//注意这里一定要是Integer,不能是int数组\n    Arrays.fill(arr,0);//全部填充\n    System.out.println(Arrays.toString(arr));//[0, 0, 0, 0, 0]\n    Arrays.fill(arr,1,3,2);//将数组arr中从下标1（包含）到3（不包含）的元素的值填充为2.\n    System.out.println(Arrays.toString(arr));//[0, 2, 2, 0, 0]\n    ```\n    #### equals 比较两个数组元素的内容是否完全一 致\n\n    ```java\n    int arr1[] = {1,2,3};\n    int arr2[] = {1,2,3};\n    System.out.println(Arrays.equals(arr1,arr2));//T\n    //需要注意两个数组的类型必须一样，哪怕一个是int一个是Integer都不行\n    ```\n    #### asList 将一组值，转换成list\n\n    1. asList 方法，会将数组中的数据转成一个 List 集合\n    2. 返回的 asList 编译类型 List（是接口）\n    3. asList 运行类型 java.util.Arrays#ArrayList, 是 Arrays 类的一个静态内部类 private static class ArrayList extends AbstractList implements RandomAccess, java.io.Serializable\n\n    ### Arrays项目：将自定义类型用sort的形式进行排序\n\n    ```java\n    package net.hurr.annotation_;\n\n    import java.util.Arrays;\n    import java.util.Comparator;\n\n    public class Test {\n\n        public static void main(String[] args) {\n            Book books[] = new Book[4];\n            books[0] = new Book();\n            books[0].setName(\"红楼梦\");\n            books[0].setPricr(100.0);\n            books[1] = new Book();\n            books[1].setName(\"知音漫客\");\n            books[1].setPricr(90.0);\n            books[2] = new Book();\n            books[2].setName(\"青年文摘\");\n            books[2].setPricr(5.0);\n            books[3] = new Book();\n            books[3].setName(\"Java 从入门到入土\");\n            books[3].setPricr(900.0);\n\n            Arrays.sort(books, new Comparator<Book>() {\n                @Override\n                public int compare(Book o1, Book o2) {\n                    if (o2.getPricr() > o1.getPricr()) {\n                        return 1;\n                    }\n                    else if (o2.getPricr() == o1.getPricr()) {\n                        return 0;\n                    }\n                    else {\n                        return -1;\n                    }\n                }\n            });\n            System.out.println(Arrays.toString(books));\n        }\n    }\n\n    class Book {\n        private String name;\n        private Double pricr;\n\n        public Book(String name, Double pricr) {\n            this.name = name;\n            this.pricr = pricr;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public Double getPricr() {\n            return pricr;\n        }\n\n        public void setPricr(Double pricr) {\n            this.pricr = pricr;\n        }\n\n        public Book() {\n        }\n\n        @Override\n        public String toString() {\n            return \"Book{\" +\n                    \"name='\" + name + '\\'' +\n                    \", pricr=\" + pricr +\n                    '}';\n        }\n    }\n\n\n\n\n    //[Book{name='Java 从入门到入土', pricr=900.0}, Book{name='红楼梦', pricr=100.0}, Book{name='知音漫客', pricr=90.0}, Book{name='青年文摘', pricr=5.0}]\n\n\n    ```\n    ## System\n\n    ### System常用的方法\n\n    #### exit\t退出当前程序\n\n    ```java\n    System.exit(-1);//括号中的参数代表一个状态，一般来说都写0，代表正常退出。反映在“进程已结束,退出代码0”\n    ```\n    #### arraycopy :复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成数组的复制。\n\n    > 该方法的五个参数如下所示\n    >\n    > @param\tsrc\tthe source array . \t源数组的地址\n    > @param\tsrcPos\tstarting position in the source array .\t\t从源数组的第几个位置开始拷贝\n    > @param\tdest\tthe destination array。\t目标数组的地址\n    > @param\tdestPos\tstarting position in the destination data.\t拷贝到目标数组的哪个位置\n    > @param\tLength \tthe number of array elements to be copied。\t从源数组拷贝多少个元素到目标数组。不能超过源数组长度\n    >\n\n    ```java\n    int num[] = {1, 2, 3};\n    int arr[] = new int[5];\n    System.arraycopy(num, 0, arr, 0, 3);\n    System.out.println(Arrays.toString(arr));//[1, 2, 3, 0, 0]\n    ```\n    #### currentTimeMillens\t返回当前时间距离1970-1-1的毫秒数\n\n    ```java\n    System.out.println(System.currentTimeMillis());\n    ```\n    #### gc\t运行垃圾回收机制\n\n    ```java\n    System.gc();\n    ```\n    ## BigInteger 和 BigDecimal 类\n\n    应用场景:\n\n    1) 如果一个数非常大，大到长整型都装不下的时候，就可以利用 BigInteger 或 BigDecimald进行处理存储\n    2) BigInteger适合保存比较大的整型\n    3) BigDecimal适合保存精度更高的浮点型(小数)\n    4) 在对大数进行加减乘除的时候，需要使用其对应的的方法处理，不能直接相加。\n\n    ### BigInteger 和 BigDecimald的常用方法\n\n    #### add\t加\n\n    ```java\n    BigInteger bigInteger1 = new BigInteger(\"12312312312312312312312123123123\");\n    BigInteger bigInteger2 = new BigInteger(\"12312312312312312312312123123123\");\n    System.out.println(bigInteger1);\n    bigInteger1 = bigInteger1.add(bigInteger2);\n    System.out.println(bigInteger1);\n\n    /*\n    12312312312312312312312123123123\n    24624624624624624624624246246246\n    */\n    ```\n    #### subtract\t减\n\n    ```java\n    BigInteger bigInteger1 = new BigInteger(\"24624624624624624624624246246246\");\n    BigInteger bigInteger2 = new BigInteger(\"12312312312312312312312123123123\");\n    System.out.println(bigInteger1);\n    bigInteger1 = bigInteger1.subtract(bigInteger2);\n    System.out.println(bigInteger1);\n\n    /*\n    24624624624624624624624246246246\n    12312312312312312312312123123123\n    */\n    ```\n    #### multiply\t乘\n\n    ```java\n    BigInteger bigInteger1 = new BigInteger(\"12312312312312312312312123123123\");\n    BigInteger bigInteger2 = new BigInteger(\"12312312312312312312312123123123\");\n    System.out.println(bigInteger1);\n    bigInteger1 = bigInteger1.multiply(bigInteger2);\n    System.out.println(bigInteger1);\n\n    /*\n    12312312312312312312312123123123\n    151593034475917358800237024411796154713271830424740055417273129\n    */\n    ```\n    #### divide\t除\n\n    ```java\n    BigInteger bigInteger1 = new BigInteger(\"151593034475917358800237024411796154713271830424740055417273129\");\n    BigInteger bigInteger2 = new BigInteger(\"12312312312312312312312123123123\");\n    System.out.println(bigInteger1);\n    bigInteger1 = bigInteger1.divide(bigInteger2);\n    System.out.println(bigInteger1);\n\n    /*\n    151593034475917358800237024411796154713271830424740055417273129\n    12312312312312312312312123123123\n    */\n    ```\n    ## 日期类\n\n    ### 第一代日期类 Date (java.util.Date)\n\n    ```\n    精确到毫秒，代表特定的瞬间\n    ```\n\n    ```java\n    Date d1 = new Date(); //获取当前系统时间，即从1970年1月1日到现在经过了多少毫秒\n    System.out.println(\"当前日期=\" + d1);//默认输出的日期格式为英文状态的星期 月份 天 时间 年份。即Sat May 28 17:21:19 CST 2022\n    Date d2 = new Date(9234567); //通过指定毫秒数得到时间\n    System.out.println(\"d2=\" + d2); //显示通过毫秒数创建的日期\n    ```\n    #### SimpleDateFormat 格式化和解析日期\n\n    ```java\n    Date d1 = new Date(); //获取当前系统时间\n    System.out.println(d1);//因为默认的格式不便于读写，可以通过SimpleDateForma类对Date对象进行格式化\n\n    //创建一个SimpleDateFormat对象，可以指定相应的格式。如年月日时分秒星期。\n    SimpleDateFormat SDF = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss E a\");\n    System.out.println(SDF.format(d1));//格式化后输出当前的日期，2022年05月28日 18:03:01 周六 下午\n\n    //2022年05月28日 05:30:02 周六\n    ```\n\n    | 字母 | 日期或时间元素        | 表示              | 示例                                  |\n    | ---- | --------------------- | ----------------- | ------------------------------------- |\n    | G    | Era标志符             | Text              | AD                                    |\n    | y    | 年                    | Year              | 1996；96（四位/两位）                 |\n    | M    | 月                    | Month             | July；Jul；07                         |\n    | w    | 一年中的第几周        | Number            | 27                                    |\n    | W    | 一个月中的第几周      | Number            | 2                                     |\n    | D    | 一年中的第几天        | Number            | 189                                   |\n    | d    | 一个月中的第几天      | Number            | 10                                    |\n    | F    | 一个月中的第几个星期  | Number            | 2                                     |\n    | E    | 星期几                | Text              | 周六                                  |\n    | a    | am/pm标记             | Text              | PM；下午                              |\n    | H    | 小时（0-23）          | Number            | 0                                     |\n    | k    | 小时（1-24）          | Number            | 24                                    |\n    | K    | am/pm中的小时（0-11） | Number            | 0                                     |\n    | h    | am/pm中的小时（1-12） | Number            | 12                                    |\n    | m    | 分钟                  | Number            | 30                                    |\n    | s    | 秒                    | Number            | 55                                    |\n    | S    | 毫秒                  | Number            | 998                                   |\n    | z    | 时区                  | Genera1 time zone | Pacific Standard Time; PST; GMT-08:00 |\n    | Z    | 时区                  | RFC 822 time zone | -0800                                 |\n\n    ### 第二代日期类，主要就是Calendar类(日历)。\n\n    ```\n    Calendar类是一个抽象类，它为特定瞬间与组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。\n    ```\n\n    #### Calendar的说明\n\n    1. Calendar 是一个抽象类， 并且构造器是 private，如果需要创建对象，需要通过 getInstance() 来获取实例；\n\n       ```java\n       Calendar c = Calendar.getInstance();\n       ```\n    2. 提供大量的方法和字段，如果需要获取某个字段，可以参照如下格式；\n\n       ```java\n       c.get(Calendar.字段名);\n       ```\n    3. Calendar 没有提供对应的格式化的类，因此需要自己组合来输出（灵活）；\n\n       ```java\n       Calendar c = Calendar.getInstance();\n       System.out.println(\"年：\"+c.get(Calendar.YEAR));\n       System.out.println(\"月：\"+(c.get(Calendar.MONTH)+1));//因为月是从0开始编号的\n       System.out.println(\"日：\"+c.get(Calendar.DAY_OF_MONTH));\n       System.out.println(\"时：\"+c.get(Calendar.HOUR));\n       System.out.println(\"分：\"+c.get(Calendar.MINUTE));\n       System.out.println(\"秒：\"+c.get(Calendar.SECOND));\n\n       /*\n       年：2022\n       月：5\n       日：28\n       时：7\n       分：57\n       秒：43\n       */\n       ```\n    4. 如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR ==改成=> Calendar.HOUR_OF_DAY\n\n    ### 第三代日期类\n\n    ```\n    JDK 1.0中包含了一个java.util.Date类,但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar也存在问题是:\n    ```\n\n    1. 可变性:像日期和时间这样的类应该是不可变的。\n    2. 偏移性: Date中的年份是从1900开始的， 而月份都从0开始。\n    3. 格式化:格式化只对Date有用，Calendar则不行。\n    4. 此外，它们也不是线程安全的;不能处理闰秒等(每隔2天，多出1s)。\n\n\n    因此，在**JDK8**引入了新的类：\n\n    LocalDate(日期/年月日)、LocalTime(时间/时分秒)、LocalDateTime(日期时间/年月日时分秒)\n\n    LocalDate只包含日期，可以获取日期字段\n    LocalTime只包含时间，可以获取时间字段\n    LocalDateTime包含日期+时间，可以获取日期和时间字段\n\n    #### LocalDateTime的常用方法以及通过DateTimeFormatter格式化输出\n\n    ```java\n    //1、使用now返回当前的日期时间，返回值是一个LocalDateTime的对象\n    LocalDateTime ldt = LocalDateTime.now();//LocalDate和LocalTime也有now方法，可以分别获取当前的日期和时间\n    System.out.println(ldt);//2022-05-28T20:11:25.378881600\n    //2、单独提取现在的年月日时分秒\n    System.out.println(\"年：\"+ldt.getYear());\n    System.out.println(\"月：\"+ldt.getMonth());\n    System.out.println(\"日：\"+ldt.getDayOfMonth());\n    System.out.println(\"时：\"+ldt.getHour());\n    System.out.println(\"分：\"+ldt.getMinute());\n    System.out.println(\"秒：\"+ldt.getSecond());\n    //3、格式化显示：依靠DateTimeFormatter。整个过程类似于SimpleDateFormat,但还有更多的功能。具体见手册中DateTimeFormatter部分\n    DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 HH:mm:ss\");\n    System.out.println(dtf.format(LocalDateTime.now()));\n    ```\n    #### Instant 时间戳\n\n    类似于Date，提供了一系列和Date类转换的方式：\n\n    ##### 获取当前的时间戳\n\n    ```java\n    Instant now = Instant.now();//利用Instant类的now方法（静态）获取当前的时间戳\n    System.out.println(now);//2022-05-28T12:32:09.611215Z\n    ```\n    ##### Instant 转 Date\n\n    ```java\n    Date date = Date.from(instant);\n    ```\n    ##### Date 转 Instant:\n\n    ```java\n    Instant instant = date.tolnstant();\n    ```\n    案例演示:\n    Instant now = Instant. now0;\n    System. out.println(now);\n    Date date = Date. from(now);\n    Instant instant = date.tolnstant();\n\n    #### 常用的LocalDateTime方法\n\n    plus  过多少\n\n    # 集合\n\n    集合解决了数组的一些局限性，比如：\n\n    1. 长度开始时必须指定，而且一旦指定，不能更改；\n    2. 保存的必须为同类型的元素；\n    3. 使用数组进行增加/删除元素比较麻烦；\n\n    ## 集合的特点\n\n    1. 可以动态保存任意多个对象（不限类型），使用比较方便；\n    2. 提供了一系列方便的操作对象的方法: add、remove. set. get（增删改查）等；\n    3. 使用集合添加,删除新元素简洁明了；\n\n    ## 集合的框架体系\n\n    集合主要分为两组，根据实现的接口不同分别是单列集合和双列集合，他们分别存储了一个元素或一个具有两个元素的键值对。\n\n    其中的单列集合Collection接口继承了Iterator类\n\n    ![image-20220606164037696](./Image/Other/image-20220606164037696.png)\n\n    ![image-20220606164150235](./Image/Other/image-20220606164150235.png)\n\n    ## 实现了Collection 接口（单列）的子类的特点\n\n    1) collection实现子类可以存放多个元素，每个元素可以是0bject；\n    2) 有些Collection的实现类，可以存放重复的元素，有些不可以；\n    3) 有些Collection的实现类，有些是有序的(List，即存入的顺序和读取的顺序一致),有些不是有序(Set，即存入顺序和读出的顺序并不相同)；\n    4) Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的；\n\n    ### Collection 接口的常用方法(以ArrayList进行演示)\n\n    0. 创建集合\n\n       ```java\n       List list = new ArrayList();//创建一个ArrayList集合，用List接口进行接收，本段演示均基于这个集合\n       ```\n    1. add:添加单个元素\n\n       ```java\n       list.add(\"Hello\");//只要是基于Object的对象都可以放入，换句话说就是可以放入所有的对象\n       list.add(10);//放入基本数据类型会自动装箱成为一个对应包装类的对象\n       list.add(true);\n       System.out.println(\"list = \" + list);//list = [Hello, 10, true]\n       ```\n    2. remove:删除指定元素\n\n       ```java\n       String s = (String)list.remove(0);//可以删除指定第几个（从0起），如果使用索引删除则返回被删除的对象\n       System.out.println(s);//Hello\n       boolean b = list.remove(new Integer(10));//如果删除的是指定的对象的话，返回的就是是否删除成功\n       System.out.println(b);//true\n       b = list.remove(new Integer(11));//删除一个不存在的对象\n       System.out.println(b);//false\n       System.out.println(\"list = \" + list);//list = [true]\n       ```\n    3. contains:查找元素是否存在\n\n       ```java\n               if (list.contains(true)) {//查找list里面是否存在一个true的对象，返回值为布尔型\n                   System.out.println(\"存在\");\n               }else{\n                   System.out.println(\"不存在\");\n               }\n               if (list.contains(false)) {//查找list里面是否存在一个true的对象，返回值为布尔型\n                   System.out.println(\"存在\");\n               }else{\n                   System.out.println(\"不存在\");\n               }\n               //执行结果：\n               //存在\n               //不存在\n       ```\n    4. size:获取元素个数\n\n       ```java\n       System.out.println(list.size());//获取当前list的个数，并输出出来，结果是1\n       ```\n    5. isEmpty:判断是否为空\n\n       ```java\n       System.out.println(\"list集合是空的吗 \" + list.isEmpty());//判断集合是否为空//list集合是空的吗 false\n       ```\n    6. clear:清空\n\n       ```java\n       list.clear();//清空整个集合的元素\n       System.out.println(\"list集合是空的吗 \" + list.isEmpty());//然后再判断一下集合是否为空//list集合是空的吗 true\n       ```\n    7. addAll:添加多个元素\n\n       ```java\n       ArrayList arrayList = new ArrayList();//临时创建一个集合并存入一些元素\n       arrayList.add(\"hello\");\n       arrayList.add(\"hurriedlu\");\n       arrayList.add(100);\n\n       list.addAll(arrayList);//只要是实现了Collection接口的对象都可以被添加进来。\n       System.out.println(\"list = \" + list);//list = [hello, hurriedlu, 100]\n       ```\n    8. containsAll:查找(判断)多个元素是否都存在，只要有一个元素不存在就返回false\n\n       ```java\n       //判断arrayList中所有的元素是否都存在，这个arrayList可以是任何实现了Collection接口的对象。\n       System.out.println(list.containsAll(arrayList));//true\n       list.remove(new Integer(100));//删除掉一个元素再判断\n       System.out.println(list.containsAll(arrayList));//false\n       ```\n    9. removeAll：删除多个元素。只要有一个被删掉就返回true\n\n       ```java\n       list.add(\"hurriedlu\");//添加一个存在的\n       list.add(\"hurr\");//添加一个之前不存在的\n       // 删除和arrayList有关的元素，并输出一下结果.\n       System.out.println(list.removeAll(arrayList));//true\n       //看一下剩余的对象\n       System.out.println(\"list = \" + list);//list = [hurr]\n       ```\n","tags":["protected","基础教程","Java"],"categories":["Java"]},{"title":"HTTP 状态码列表","url":"/2024/02/28/HTTP 状态码列表/","content":"\n\n\n# HTTP 状态码列表\n\n| 分类                 | 代码 | 名称                                               | 说明                                                         | 常见场景举例                                                 |\n| -------------------- | ---- | -------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **1xx (临时响应)**   | 100  | Continue (继续)                                    | 请求者应当继续提出请求。服务器已收到请求的第一部分，正在等待其余部分。 | 客户端在发送大型请求体之前，询问服务器是否愿意接受请求。     |\n|                      | 101  | Switching Protocols (切换协议)                     | 请求者已要求服务器切换协议，服务器已确认并准备切换。         | WebSockets连接建立。                                         |\n|                      | 102  | Processing (处理中)                                | WebDAV协议扩展，表示服务器已接收并正在处理请求，但尚未有响应可用。 | WebDAV操作，如耗时较长的文件复制。                           |\n| **2xx (成功)**       | 200  | OK (成功)                                          | 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 | 网页加载、API请求成功。                                      |\n|                      | 201  | Created (已创建)                                   | 请求成功并且服务器创建了新的资源。                           | 用户注册、创建新文章。                                       |\n|                      | 202  | Accepted (已接受)                                  | 服务器已接受请求，但尚未处理。                               | 异步任务处理（如发送邮件、生成报告）。                       |\n|                      | 203  | Non-Authoritative Information (非授权信息)         | 服务器已成功处理了请求，但返回的信息可能来自另一来源（如缓存）。 | 代理服务器返回缓存数据。                                     |\n|                      | 204  | No Content (无内容)                                | 服务器成功处理了请求，但没有返回任何内容。                   | 删除资源、成功更新但无需返回数据。                           |\n|                      | 205  | Reset Content (重置内容)                           | 服务器成功处理了请求，但没有返回任何内容。要求用户代理（浏览器）重置文档视图。 | 提交表单后清空表单内容。                                     |\n|                      | 206  | Partial Content (部分内容)                         | 服务器成功处理了部分 GET 请求。                              | 视频流播放、文件断点续传。                                   |\n|                      | 207  | Multi-Status (多状态)                              | WebDAV协议扩展，在响应体中包含多个响应代码。                 | WebDAV批量操作。                                             |\n|                      | 208  | Already Reported (已报告)                          | WebDAV协议扩展，在一个DAV集合中，已经报告过内部成员的状态，避免重复报告。 | WebDAV深度查询。                                             |\n| **3xx (重定向)**     | 300  | Multiple Choices (多种选择)                        | 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 | 提供不同格式的资源选择。                                     |\n|                      | 301  | Moved Permanently (永久移动)                       | 请求的网页已永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。 | 网站域名更改、URL结构调整。                                  |\n|                      | 302  | Found (临时移动)                                   | 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 | 临时页面重定向、负载均衡。                                   |\n|                      | 303  | See Other (查看其他位置)                           | 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 | POST请求成功后，重定向到结果页面。                           |\n|                      | 304  | Not Modified (未修改)                              | 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 | 客户端使用缓存，通过If-Modified-Since或If-None-Match验证资源未修改。 |\n|                      | 305  | Use Proxy (使用代理)                               | 请求者只能使用代理访问请求的网页。                           | 较少使用，存在安全隐患。                                     |\n|                      | 307  | Temporary Redirect (临时重定向)                    | 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。与302类似，但强制客户端使用相同的HTTP方法。 | 临时维护页面重定向。                                         |\n|                      | 308  | Permanent Redirect (永久重定向)                    | 请求的网页已永久移动到新位置。与301类似，但强制客户端使用相同的HTTP方法。 | 域名迁移、API版本升级。                                      |\n| **4xx (客户端错误)** | 400  | Bad Request (错误请求)                             | 服务器不理解请求的语法。                                     | 请求参数错误、请求体格式不正确。                             |\n|                      | 401  | Unauthorized (未授权)                              | 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。 | 访问受保护资源未提供或提供了错误的认证信息。                 |\n|                      | 403  | Forbidden (禁止)                                   | 服务器拒绝请求。客户端没有访问权限。                         | 尝试访问无权访问的目录或文件。                               |\n|                      | 404  | Not Found (未找到)                                 | 服务器找不到请求的网页。                                     | 访问不存在的URL。                                            |\n|                      | 405  | Method Not Allowed (方法禁用)                      | 禁用请求中指定的方法。                                       | 对不支持GET的API接口使用了POST请求。                         |\n|                      | 406  | Not Acceptable (不接受)                            | 无法使用请求的内容特性响应请求的网页。服务器根据请求的Accept头部无法生成客户端可接受的响应。 | 客户端只接受JSON，但服务器只能提供XML。                      |\n|                      | 407  | Proxy Authentication Required (需要代理授权)       | 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 | 在需要代理认证的环境中。                                     |\n|                      | 408  | Request Timeout (请求超时)                         | 服务器等候请求时发生超时。                                   | 客户端在服务器设定的时间内未发送完整请求。                   |\n|                      | 409  | Conflict (冲突)                                    | 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。 | 并发修改同一资源、资源已存在。                               |\n|                      | 410  | Gone (已删除)                                      | 如果请求的资源已永久删除，服务器就会返回此响应。             | 资源已下线且不会再恢复。                                     |\n|                      | 411  | Length Required (需要有效长度)                     | 服务器不接受不含有效内容长度标头字段的请求。                 | POST或PUT请求缺少Content-Length头部。                        |\n|                      | 412  | Precondition Failed (未满足前提条件)               | 服务器未满足请求者在请求中设置的其中一个前提条件。           | 乐观锁并发控制，If-Match条件失败。                           |\n|                      | 413  | Payload Too Large (请求实体过大)                   | 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 | 上传文件超出服务器配置的最大大小。                           |\n|                      | 414  | URI Too Long (请求的 URI 过长)                     | 请求的 URI（通常为网址）过长，服务器无法处理。               | 包含过多查询参数的URL。                                      |\n|                      | 415  | Unsupported Media Type (不支持的媒体类型)          | 请求的格式不受请求页面的支持。                               | POST请求的Content-Type与服务器期望的不符。                   |\n|                      | 416  | Range Not Satisfiable (请求范围不符合要求)         | 如果页面无法提供请求的范围，则服务器会返回此状态代码。       | 请求文件范围超出实际文件大小。                               |\n|                      | 417  | Expectation Failed (未满足期望值)                  | 服务器未满足\"期望\"请求标头字段的要求。                       | Expect头部指示的期望条件未被满足。                           |\n|                      | 421  | Misdirected Request (请求被错误重定向)             | 请求被定向到无法产生响应的服务器。                           | HTTP/2中，客户端向错误的服务器发送请求。                     |\n|                      | 422  | Unprocessable Entity (不可处理的实体)              | 请求格式正确，但由于语义错误而无法遵循。                     | API表单验证失败。                                            |\n|                      | 423  | Locked (已锁定)                                    | 资源的访问被锁定。                                           | WebDAV中，尝试修改被锁定的资源。                             |\n|                      | 424  | Failed Dependency (失败的依赖)                     | WebDAV协议扩展，表示由于前一个请求失败，此请求无法执行。     | 依赖于另一个失败的操作。                                     |\n|                      | 426  | Upgrade Required (需要升级)                        | 客户端应该切换到TLS/1.0等协议。                              | 服务器要求客户端升级连接协议。                               |\n|                      | 428  | Precondition Required (需要前提条件)               | 服务器要求在请求中包含条件头部（如If-Match或If-Unmodified-Since）。 | 强制客户端在更新资源时提供Etag。                             |\n|                      | 429  | Too Many Requests (请求过多)                       | 用户在给定时间内发送了太多请求（频率限制）。                 | API限流。                                                    |\n|                      | 431  | Request Header Fields Too Large (请求头字段过大)   | 服务器不接受请求，因为一个或多个头部字段过大。               | 请求头部包含过多的Cookie或自定义头部。                       |\n|                      | 451  | Unavailable For Legal Reasons (因法律原因不可用)   | 服务器拒绝访问该资源，因为该资源因法律原因被审查。           | 受政府审查的网站内容。                                       |\n| **5xx (服务器错误)** | 500  | Internal Server Error (服务器内部错误)             | 服务器遇到错误，无法完成请求。                               | 服务器代码异常、未捕获的错误。                               |\n|                      | 501  | Not Implemented (尚未实施)                         | 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 | 访问了尚未实现的API端点。                                    |\n|                      | 502  | Bad Gateway (错误网关)                             | 服务器作为网关或代理，从上游服务器收到无效响应。             | 反向代理（如Nginx）与后端服务通信失败。                      |\n|                      | 503  | Service Unavailable (服务不可用)                   | 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 | 服务器过载、维护模式。                                       |\n|                      | 504  | Gateway Timeout (网关超时)                         | 服务器作为网关或代理，但是没有及时从上游服务器收到请求。     | 反向代理等待后端服务响应超时。                               |\n|                      | 505  | HTTP Version Not Supported (HTTP 版本不受支持)     | 服务器不支持请求中所用的 HTTP 协议版本。                     | 客户端使用了过时或不支持的HTTP版本。                         |\n|                      | 506  | Variant Also Negotiates (变体也协商)               | 服务器存在内部配置错误：它用于透明内容协商的透明代理本身被配置为参与协商。 | 较少见的服务器配置错误。                                     |\n|                      | 507  | Insufficient Storage (存储空间不足)                | WebDAV协议扩展，表示服务器无法存储完成请求所需的表示。       | 服务器磁盘空间不足。                                         |\n|                      | 508  | Loop Detected (检测到循环)                         | WebDAV协议扩展，服务器在处理请求时检测到无限循环。           | 某些WebDAV操作中检测到循环依赖。                             |\n|                      | 510  | Not Extended (未扩展)                              | 请求需要对服务器进行进一步的扩展才能实现。                   | 客户端未能满足服务器的某个强制扩展。                         |\n|                      | 511  | Network Authentication Required (需要网络身份验证) | 客户端需要进行网络身份验证才能获得访问权限。                 | 公共Wi-Fi登录页面重定向。                                    |","tags":["AI","protected","HTTP"],"categories":["HTTP","技术文档"]},{"title":"基础算法与数据结构","url":"/2024/02/28/基础算法与数据结构/","content":"# 基础算法\n\n## 排序\n\n### 快速排序\n\n#### 思想：基于分治。\n\n1. 确定分界点。在数组中随便找一个值，以划分出左右两堆数；\n\n   > 常见方法\n   >\n   > 1. 直接取左边界，即q[ l ]；（边界不能是i）\n   > 2. 直接取中间值，即q[ ( l + r ) / 2 ]；\n   > 3. 直接取右边界，即q[ r ]；（边界不能是j）\n   > 4. 也可以直接随机一个值\n\n2. **调整区间。使得第一步确定的分界点x左边的区间全部 ≤ x，右边区间全部 ≥ x；**\n\n   > 1. 方法1，思想简单但需要额外空间。比较暴力，需要两个额外空间，但时间复杂度还好，是线性的\n   > 2. 需要两个额外的数组 a[ ] , b[ ]；\n   > 3. 扫描整个数组q[ l ~ r ]，若 q[ i ] <= x ，则将q [ i ] 存入a [] 数组，否则存入b[ ]数组；\n   > 4. 先将数组a[ ]中的所有数据存取q[ ]，然后将数组b[ ]中的所有数据存入q[ ]；\n   > 5. 方法2，时间复杂度空间复杂度都很好\n   > 6. 需要两个额外的数组指针，设这两个指针为 i ， j，并将指针 i 指向数组的最左边，指针 j 指向数组的最右边。\n   > 7. 判断指针 i 是否大于 x ，如果不大于，指针后移，直到找到第一个大于 x 的地方；\n   > 8. 同理判断指针 j 是否小于 x ，如果小于，指针前移，直到找到第一个小于 x 的地方；\n   > 9. 交换指针 i 和 j 指向空间的数据；\n   > 10. 重复2 - 4步，直到指针 i j 相遇为止\n   >\n3. 递归处理左右两端，使得左右区间全部有序\n\n#### 实现代码：对数组进行排序\n\n##### 模板\n\n```c\nvoid qsort(int nums[], int l, int r) {\n    if (l >= r)\n        return;\n    int x = nums[(l + r) / 2];\n    int i = l - 1;\n    int j = r + 1;\n\n    while (i < j) {\n        do {\n            i++;\n        } while (nums[i] < x);\n\n        do {\n            j--;\n        } while (nums[j] > x);\n\n        if (i < j)\n            swap(nums[i], nums[j]);\n    }\n    qsort(nums, l, j);\n    qsort(nums, j + 1, r);\n}\n```\n\n##### C/C++：\n\n```c++\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 1e6 + 10;\nint n, nums[N];\n\n/// <summary>\n/// 快速排序，范围要求是左开右闭\n/// </summary>\n/// <param name=\"nums\">要排序的数组</param>\n/// <param name=\"l\">左边界（开始迭代器）</param>\n/// <param name=\"r\">右边界（结束迭代器）</param>\nvoid qsort(int nums[], int l, int r) {\n    if (l >= r)//如果当左右边界相等的时候，证明已经递归到当前区域只有一个元素，也就表示当前区域已经有序了，可以直接退出\n        return;\n\n    int x = nums[(l + r) / 2];//随便选一个数当作分界点\n    int i = l - 1;//生成本轮循环的左边界（要求各多算一个）\n    int j = r + 1;//生成本轮循环的右边界（要求各多算一个）\n\n    while (i < j) {//开始本轮循环 要求左右边界不能碰面\n        do {//必须要do while,先++后判断\n            i++;\n        } while (nums[i] < x);\n\n        do {//同理 先--后判断\n            j--;\n        } while (nums[j] > x);\n\n        if (i < j)//可能会有越界的行为，因此在交换前需要先判断\n            swap(nums[i], nums[j]);\n    }\n    qsort(nums, l, j);//递归循环左边界，分界点一定要是j而不能是i\n    qsort(nums, j + 1, r);//递归循环右边界\n}\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &nums[i]);\n    }\n\n    qsort(nums, 0, n - 1);\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", nums[i]);\n    }\n\n    return 0;\n}\n```\n\n##### Java\n\n```java\npackage sort;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    private static final int N = 100000;\n    public static int n;\n    public static int num[] = new int[N];\n\n    public static void qsort(int nums[],int l,int r){\n        if (l >= r)//如果当左右边界相等的时候，证明已经递归到当前区域只有一个元素，也就表示当前区域已经有序了，可以直接退出\n            return;\n\n        int x = nums[(l + r) / 2];//随便选一个数当作分界点\n        int i = l - 1;//生成本轮循环的左边界（要求各多算一个）\n        int j = r + 1;//生成本轮循环的右边界（要求各多算一个）\n\n        while (i < j) {//开始本轮循环 要求左右边界不能碰面\n            do {//必须要do while,先++后判断\n                i++;\n            } while (nums[i] < x);\n\n            do {//同理 先--后判断\n                j--;\n            } while (nums[j] > x);\n\n            if (i < j)//可能会有越界的行为，因此在交换前需要先判断\n            {\n                int t = nums[i];\n                nums[i] = nums[j];\n                nums[j] = t;\n            }\n        }\n        qsort(nums, l, j);//递归循环左边界，分界点一定要是j而不能是i\n        qsort(nums, j + 1, r);//递归循环右边界\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        n = scanner.nextInt();\n\n        for (int i = 0;i < n;i++){\n            num[i] = scanner.nextInt();\n        }\n\n        qsort(num, 0, n - 1);\n\n        //System.out.println(Arrays.toString(num));\n\n        for (int i = 0;i < n;i++){\n            System.out.print(num[i] + \" \");\n        }\n    }\n}\n```\n\n### 归并排序\n\n#### 思想：依然是分治\n\n但具体实现的方式与快排不相同\n\n1. 确定in数。\n2. 递归排序左右两边\n3. 归并。把两个有序的数组合并成一个数组\n\n#### 实现代码：对数组进行排序\n\n##### 模板\n\n```c\nvoid merge_sort(int q[], int l, int r)\n{\n    if (l >= r) return;\n\n    int mid = l + r >> 1;\n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r);\n\n    int k = 0, i = l, j = mid + 1;\n    while (i <= mid && j <= r)\n        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];\n        else tmp[k ++ ] = q[j ++ ];\n\n    while (i <= mid) tmp[k ++ ] = q[i ++ ];\n    while (j <= r) tmp[k ++ ] = q[j ++ ];\n\n    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];\n}\n\n```\n\n##### C/C++\n\n```c++\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 1e6 + 10;\nint n, nums[N], tmp[N];//数据长度，数据，辅助数组\n\n/// <summary>\n/// 归并排序\n/// </summary>\n/// <param name=\"nums\">要排序的数组</param>\n/// <param name=\"l\">左边界</param>\n/// <param name=\"r\">右边界</param>\nvoid mergeSort(int nums[], int l, int r) {\n    if (l >= r)//当当前区域只有一个甚至一个元素都没有的时候，这个区域就有序了，可以退出了\n        return;\n\n    int mid = l + r >> 1;//算出整个数据的中间位置\n\n    //开始递归排序左右两边      \n    mergeSort(nums, l, mid);\n    mergeSort(nums, mid + 1, r);\n\n    //开始归并到辅助数组\n    int k = 0;//存储当前进度\n    int i = l, j = mid + 1;//两个区域的首地址\n    while (i <= mid && j <= r) {\n        if (nums[i] < nums[j])\n            tmp[k++] = nums[i++];\n        else\n            tmp[k++] = nums[j++];\n\n    }\n\n    //进行扫尾，将剩余元素全部直接接到辅助数组的末尾\n    while (i <= mid)\n        tmp[k++] = nums[i++];\n    while (j <= r)\n        tmp[k++] = nums[j++];\n\n    //将辅助数组中的数据复制到原始数组中\n    for (int i = l, j = 0; i <= r; i++, j++) {\n        nums[i] = tmp[j];\n    }\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &nums[i]);\n    }\n\n    mergeSort(nums, 0, n - 1);\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", nums[i]);\n    }\n\n    return 0;\n}\n\n```\n\n### 应用\n\n#### 第K个数/第K小的数（快排+二分）\n\n> #### 第k个数\n>\n> 给定一个长度为 n 的整数数列，以及一个整数 k，请用快速选择算法求出数列从小到大排序后的第 k 个数。\n>\n> #### 输入格式\n>\n> 第一行包含两个整数 n 和 k。\n>\n> 第二行包含 n 个整数（所有整数均在 1∼10^9^ 范围内），表示整数数列。\n>\n> #### 输出格式\n>\n> 输出一个整数，表示数列的第 k 小数。\n>\n> #### 数据范围\n>\n> 1≤n≤100000\n> 1≤k≤n\n>\n> #### 输入样例：\n>\n> ```\n> 5 3\n> 2 4 1 5 3\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 3\n> ```\n\n#### 思路\n\n- 首先这个数是否存在比较好判断（如果k大于n，直接报错即可），并且此题目保证了k ≤ n\n- 在快排的时候，每次快排完成都可以使key左边的都比key小，右边的都比key大。因此，key的位置x就是整个序列中第x小的数。\n- 快排完事之后递归之前，计算一下key的位置，看是否大于de\n\n#### 实现代码\n\n```c++\n#include <iostream>\nusing namespace std;\n\nconst int N = 1e5 + 10;\nint n, k, num[N];\n\nint findKth(int num[], int l, int r, int k)\n{\n    //基础的快排部分\n    if (l >= r)\n        return num[l];\n\n    int key = num[l + r >> 1];\n    int i = l - 1;\n    int j = r + 1;\n    while (i < j)\n    {\n        do i++; while (num[i] < key);\n        do j--; while (num[j] > key);\n        if (i < j) swap(num[i], num[j]);\n    }\n    //快排之后得出一个序列，key左边的都比key小，右边的都比key大。此时，key这个数的位置，就是key在序列中的位置\n\n    int lcnt = j - l + 1;//计算出key的位置。位置等于k的位置减去左边界\n    if (k <= lcnt)//如果要找到数在key的位置的前面，或者就是key\n        return findKth(num, l, j, k);//递归查找左边界到key这段距离\n    else//否则答案的位置就在key的右侧（不包括key）。递归查找key下一个位置到右边界的区间\n        return findKth(num, j + 1, r, k - lcnt);//假设要查找第7小的数，已经找到第5小的了，只需要在第六小开始的位置找出第2小的就行\n\n}\n\n\nint main()\n{\n    scanf_s(\"%d%d\", &n, &k);\n    for (int i = 0; i < n; i++) scanf_s(\"%d\", &num[i]);\n    cout << findKth(num, 0, n - 1, k) << endl;\n    return 0;\n}\n```\n\n## 小结\n\n1. 虽然快排和归并都是nlgn级别的复杂度，但这是在宏观上的量级，在使用的时候，一般来说快排比归并快了两到三倍。\n\n## 二分\n\n### 整数二分\n\n#### 思想：本质是找边界\n\n```\n给定一个区间，在这个区间上定义了某种性质，使得这个性质在整个范围的右半边是满足的，在左半边是不满足的；（即利用这个性质可以将整个范围一分为二）\n```\n\n\n```\n```\n\n![image-20220628124834662](./Image/Other/image-20220628124834662.png)\n\n查找边界1：\n\n1. 首先还是计算出mid的值，mid = (l+r) / 2;\n2. 检查获取到的mid的值 if ( check( mid )  ) 看是否成立\n   1. 若为true，则表示mid的位置可能是答案，因此范围缩小至 [ mid , r ]；因此更新方式为  l = mid ;\n   2. 若为false，则表示在答案在 l 到 mid - 1 （因为是整数二分，数是离散的）; 因此更新方式为 r = mid -1;\n\n查找边界2：\n\n1. 首先还是计算出mid的值，mid = (l+r) / 2;\n2. 检查获取到的mid的值 if ( check( mid )  ) 看是否成立\n   1. 若为true，则表示mid的位置可能是答案，因此范围缩小至 [ l , mid ]；因此更新方式为  r = mid ;\n   2. 若为false，则表示在答案在 [ mid+1 , r ]  ; 因此更新方式为 l = mid + 1;\n\n简单的说就是根据查找边界的不同，mid的更新是下取整还是上取整。\n\n#### 模板\n\n```c\n整数二分算法模板 —— 模板题 AcWing 789. 数的范围\nbool check(int x) {/* ... */} // 检查x是否满足某种性质\n\n//前边界\n// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\nint bsearch_1(int l, int r)\n{\n    while (l < r)\n    {\n        int mid = l + r >> 1;\n        if (check(mid)) r = mid;    // check()判断mid是否满足性质\n        else l = mid + 1;\n    }\n    return l;//如果保证必然有解，可以输出，否则需要判断一下当前的l的位置是否是要找的数\n}\n\n//后边界\n// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\nint bsearch_2(int l, int r)\n{\n    while (l < r)\n    {\n        int mid = l + r + 1 >> 1;//对mid进行上取整\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    }\n    return l;\n}\n\n\n```\n\n##### 模板的使用说明\n\n1. 如果说要查找的数是唯一的，或者随便一个等值的，则两个模板随便一个就行。\n2. 如果需要查找的数（或者相关的数据）是这些个等值的数列的第一个，则需要用第一个模板（mid下取整），反之需要用第二个模板。\n\n#### 例题\n\n> #### 数的范围\n>\n> 给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。\n>\n> 对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。\n>\n> 如果数组中不存在该元素，则返回 `-1`。\n>\n> #### 输入格式\n>\n> 第一行包含整数 n 和 q，表示数组长度和询问个数。\n>\n> 第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。\n>\n> 接下来 q 行，每行包含一个整数 k，表示一个询问元素。\n>\n> #### 输出格式\n>\n> 共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。\n>\n> 如果数组中不存在该元素，则返回 `-1`。\n>\n> #### 数据范围\n>\n> 1≤n≤100000\n> 1≤q≤10000\n> 1≤k≤10000\n>\n> #### 输入样例：\n>\n> ```\n> 6 3\n> 1 2 2 3 3 4\n> 3\n> 4\n> 5\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 3 4\n> 5 5\n> -1 -1\n> ```\n\n##### 实现代码\n\n```c++\n#include <iostream>\nusing namespace std;\n\nconst int N = 1e5 + 10;//数据量\nint n, m, x, num[N];//升序排序序列的长度，询问次数，询问的元素的值，存储序列的数组\n\n/// <summary>\n/// 基于循环的二分查找，用于查找这个区间的左边界。\n/// </summary>\n/// <param name=\"l\">要查找的序列的起始位置</param>\n/// <param name=\"r\">要查找的序列的结束位置（长度）</param>\n/// <param name=\"x\">要查找的值</param>\n/// <returns>查找到的下标</returns>\nint find1(int l, int r, int x)\n{\n    while (l < r)//只要左边界与右边界不相等，就证明这个范围内的数不止一个，可以继续循环\n    {\n        int mid = l + r >> 1;//计算mid，下取整\n        if (num[mid] >= x)//如果mid的值大于等于查找的值，就证明答案可能在左边界到mid的位置\n            r = mid;//缩小右边界，因为mid的位置可能是答案，所以r = mid\n        else//如果不满足条件，就证明答案在mid的右边，并且mid的位置不会是答案\n            l = mid + 1;//因此缩小左边界，到全部都是可能是答案的新的左边界\n    }\n    if (num[l] == x)//循环完事，检查一下找到的数据是否满足要求\n        return l;//满足，就输出要求的下标\n    else\n        return -1;//不满足，证明没有找到，直接输出-1.\n}\n/// <summary>\n/// 基于递归的二分查找，用于查找这个区间的左边界\n/// <param name=\"l\">要查找的序列的起始位置</param>\n/// <param name=\"r\">要查找的序列的结束位置（长度）</param>\n/// <param name=\"x\">要查找的值</param>\n/// <returns>查找到的下标</returns>\nint find3(int l, int r, int x)\n{\n    if (l == r)\n        if (num[l] == x)\n            return l;\n        else\n            return -1;\n\n    int mid = l + r >> 1;\n\n    if (num[mid] >= x)\n        find3(l, mid, x);\n    else\n        find3(mid + 1, r, x);\n}\n\n/// <summary>\n/// 基于循环的二分查找，用于查找这个区间的右边界。\n/// </summary>\n/// <param name=\"l\">要查找的序列的起始位置</param>\n/// <param name=\"r\">要查找的序列的结束位置（长度）</param>\n/// <param name=\"x\">要查找的值</param>\n/// <returns>查找到的下标</returns>\nint find2(int l, int r, int x)\n{\n    while (l < r)\n    {\n        int mid = l + r + 1 >> 1;//查找右边界的时候需要上取整\n        if (num[mid] <= x)//查找右边界，如果说答案大于等于mid的位置，就收缩左边界到mid\n            l = mid;\n        else\n            r = mid - 1;//否则就证明答案在小于mid的位置，收缩右边界\n    }\n    if (num[l] == x)\n        return l;\n    else\n        return -1;\n}\n/// <summary>\n/// 基于循环的循环查找，用于查找这个区间的右边界。\n/// </summary>\n/// <param name=\"l\">要查找的序列的起始位置</param>\n/// <param name=\"r\">要查找的序列的结束位置（长度）</param>\n/// <param name=\"x\">要查找的值</param>\n/// <returns>查找到的下标</returns>\nint find4(int l, int r, int x)\n{\n    if (l == r)\n        if (num[l] == x)\n            return l;\n        else\n            return -1;\n\n    int mid = l + r + 1 >> 1;\n    if (num[mid] <= x)\n        find4(mid, r, x);\n    else\n        find4(l, mid - 1, x);\n}\n\nint main()\n{\n    scanf_s(\"%d%d\", &n, &m);//获取序列的长度和询问的次数\n    for (int i = 0; i < n; i++)//读入序列\n    {\n        scanf_s(\"%d\", &num[i]);\n    }\n\n    while (m--)//开始询问\n    {\n        scanf_s(\"%d\", &x);//读入询问的数值\n        cout << find3(0, n - 1, x) << \" \" << find4(0, n - 1, x) << endl;//调用函数运算并直接输出\n    }\n\n    return 0;\n}\n```\n\n### 浮点二分\n\n同上面的整数二分类似，而且更加简单，因为不用考虑边界问题。如下例题：利用二分的方法求出一个数的三次方根。\n\n为什么可行：\n\n- 首先一个数的三次方根是必然存在的\n- 其次三次方是具有单调性的（偶数次方也可以二分，二分的左边界是0）\n\n> #### 数的三次方根\n>\n> 给定一个浮点数 n，求它的三次方根。\n>\n> #### 输入格式\n>\n> 共一行，包含一个浮点数 n。\n>\n> #### 输出格式\n>\n> 共一行，包含一个浮点数，表示问题的解。\n>\n> 注意，结果保留 6 位小数。\n>\n> #### 数据范围\n>\n> −10000 ≤ n ≤ 10000\n>\n> #### 输入样例：\n>\n> ```\n> 1000.00\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 10.000000\n> ```\n\n```c\n#include <iostream>\n#include <cmath>\nusing namespace std;\ndouble n;\n\n/// <summary>\n/// 利用二分查找找出一个数的三次方根\n/// </summary>\n/// <param name=\"n\"></param>\n/// <returns></returns>\ndouble binarySearch(double n)\n{\n    double l = -10000, r = 10000;//设置左右边界\n    while (fabs(l - r) >= 0.0000001)//算出的精度要比要求的精度多至少1位，因为存在四舍五入。\n    {\n        double mid = (l + r) / 2;//获取mid的值\n        if (mid * mid * mid >= n)//判断计算出来的值是大了还是小了\n            r = mid;//如果大了，就证明答案在mid左边，收缩右边界\n        else\n            l = mid;//否则就在mid的右边，收缩左边界\n    }\n    //因为浮点数不是精确的数，不存在绝对边界，因此不需要边界判断\n    return l;//因为必然有解，所以可以直接返回\n}\nint main()\n{\n    scanf(\"%lf\", &n);//读入\n    printf(\"%.6lf\", binarySearch(n));//计算并输出\n\n    return 0;\n}\n```\n\n#### 用二分法求算数根的好处：\n\n1. 精度可以做到非常高，而用pow()函数进行求解的话最高精度只能做到小数点后六位。\n2. 效率高，二分的时间复杂度是logn\n\n## 高精度\n\n大整数：一个长度在10^6^的数；\n\n普通数：数值小于10^9^的一个数；\n\n大整数的实现（存储）：把大整数的每一位都存入到数组中，利用数组进行逐位存储 。\n\n整个大整数的运算是一种模拟的体现，通过模拟我们手动运算的方法实现的。\n\n### 两个大整数相加\n\n#### 具体实现思想：\n\n1. 将两个大数均以倒序的形式存储到数组中，以便实现运算过程的进位问题。\n   如一个数是“123456789“，则在存储的时候，下标为0的位置存储的是”9“，下标为1的位置存储的是”8“，下标为8的位置存储的是”1“\n2. 设一个临时遍历 t，并置初值为0，用于存储每一位相加后的值。\n3. 从下标0到数组长度-1开始，逐位读取并相加两个数组的当前位置（如果有）\n4. 将两个数相加完成后的值模除10（对10取余）后存入到答案数组，然后t除以10去掉已经存入答案的值后，剩余的值进入下轮循环继续参与运算\n\n#### 实现代码\n\n模板\n\n```c\n//高精度加法 —— 模板题 AcWing 791. 高精度加法\n// C = A + B, A >= 0, B >= 0\nvector<int> add(vector<int>& A, vector<int>& B) {\n    vector<int>C;\n\n    int t = 0;\n    for (int i = 0; i < A.size() || i < B.size(); i++) {\n        if (i < A.size()) t += A[i];\n        if (i < B.size()) t += B[i];\n\n        C.push_back(t % 10);\n        t = t / 10;\n    }\n\n    if (t != 0 )\n        C.push_back(t);\n\n    return C;\n}\n\n```\n\n##### 使用stl库\n\n```c\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> add(vector<int>& A, vector<int>& B) {//之所以用引用是因为引用传入的是一个地址，如果不加引用符号则需要把A、B全部复制一遍\n    vector<int>C;\n\n    int t = 0;//进位辅助的临时变量，只需要在开始置0即可\n    for (int i = 0; i < A.size() || i < B.size(); i++) {\n        if (i < A.size()) t += A[i];//要是没超过A的位置，或者说是当运行和到这一位的时候，A数组中仍然有值，就加上A[i]；\n        if (i < B.size()) t += B[i];//同理\n\n        C.push_back(t % 10);//将临时变量模除10后存入答案数组，因为是10进制运算所以这个地方要模除10\n        t = t / 10;//将存入的值删除后，剩余的值继续参与下轮循环\n    }\n\n    if (t != 0 )//要是t不空 证明还有进位没有存入到答案数组\n        C.push_back(t);\n\n    return C;\n}\n\nint main() {\n    string a, b;//利用string实现大数的一个读入\n    vector<int>A, B;//之所以用vector容器，是因为vector有一个size属性比较方便，且没有位数的限制\n    cin >> a >> b;//读入a,b\n\n    //逆序存入\n    for (int i = a.size() - 1; i >= 0; i--)\n        A.push_back(a[i] - '0');//逆序存入到vector数组\n    for (int i = b.size() - 1; i >= 0; i--)\n        B.push_back(b[i] - '0');//逆序存入到vector数组\n\n    auto C = add(A, B);//c++11的新东西，auto。\n\n    for (int i = C.size() - 1; i >= 0; i--)//因为是倒序存入，因此在读出的时候也需要倒序\n        printf(\"%d\", C[i]);\n\n    return 0;\n}\n```\n\n##### 使用普通的char数组完成\n\n```c\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 1e6 + 10;\nchar A[N], B[N], C[N];\nchar * add(char A[], char B[],int lenA,int lenB) {\n  \n    int k = 0;\n    int t = 0;//辅助的临时变量，只需要在开始置0即可\n    //const int lenA = sizeof(A) / sizeof(char);//存储A数组的长度，后面用的时候可以不用在计算了。因为不涉及到修改，就设置成const属性\n   // const int lenB = sizeof(B) / sizeof(char);//同理\n    for (int i = 0; i < lenA || i < lenB; i++) {\n        if (i < lenA) t = t + A[i];//要是没超过A的位置，或者说是当运行和到这一位的时候，A数组中仍然有值，就加上A[i]。、\n        if (i < lenB) t = t + B[i];//同理\n\n        C[i] = t % 10;\n        k++;\n        t = t / 10;//将存入的值删除后，剩余的值继续参与下轮循环\n    }\n\n    if (t != 0)//要是t不空 证明还有进位没有存入到答案数组\n        C[k++] = t;//因为最多就有1位的进位\n\n    return C;\n}\n\nint main() {\n    string a, b;//利用string实现大数的一个读入\n    cin >> a >> b;//读入a,b\n\n    int k = 0;//倒序存储时记录长度的辅助变量\n    //逆序存入\n    for (int i = a.size() - 1; i >= 0; i--)\n        A[k++] = a[i] - '0';//之间将字符转成值存入，后续就可以不用再转换了\n    k = 0;//辅助变量置0以便下次使用\n    for (int i = b.size() - 1; i >= 0; i--)\n        B[k++] = b[i] - '0';\n\n    add(A, B,a.size(),b.size());//c++11的新东西，auto。\n\n    bool flag = false;//一个标志位，用于去除先导的0\n    for (int i = sizeof(C) / sizeof(char) - 1; i >= 0; i--)//因为是倒序存入，因此在读出的时候也需要倒序\n    {\n        if (flag || C[i] != 0) {\n            printf(\"%d\", C[i]);\n            flag = true;\n        }\n    }\n\n    return 0;\n}\n```\n\n### 两个大整数相减\n\n#### 具体实现思想\n\n1. 同大整数加法类似，都是逆序输入两个数；不同之处在于进行减法运算的时候最好进行一下判断，可以避免很大的麻烦。因为题目已经声明两个数都是正整数，因此不需要判断是否存在负数的情况。如果需要的话在输入输出阶段判断一下即可。因为任意的两个数相减都可以转换成两个数 绝对值的相加或相减；\n2. 如果大数A 小于 大数B 的话，A - B 可以转换成 （A - B) * -1;\n3. 在减法函数中，需要一个辅助标志位 t ，表示上一位数在运算过程中是否发生进位的行为，并且临时存储当前位的运算结果\n4. 将t进行修正后存入答案数组。修正方法：若 t >= 0，则直接存入，否则将t + 10 存入答案（因为是十进制）\n5. 判断t是否小于0（上一步只是相加但并未改变t） ，如果是，将 t 置 1 表示发生了进位，否则置0。\n6. 循环4，5步直到算出答案。此时答案可能存在前导0，因此需要删除。此时存在一个例外的情况就是，如果答案只有1位，哪怕这位是0也不能删除。因此条件为：如果答案位数大于1，且答案的最高位为0，就可以删除最高位。\n7. 倒序输出答案。根据第2步的判断，要不要在输出前加一个负号。\n\n#### 实现代码\n\n##### 使用stl库\n\n```c\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n//C = A - B\nvector<int> sub(vector<int>& A, vector<int>& B) {//之所以用引用是因为引用传入的是一个地址，如果不加引用符号则需要把A、B全部复制一遍\n    vector<int>C;\n    int t = 0;//减法运算过程的借位标识符。有借位值为1，否则为0.\n    for (int i = 0; i < A.size(); i++)//在进入这个函数的时候已经确保了A一定是大于等于B的，因此长度上以A为准即可\n    {\n        t = A[i] - t;//获取被减数。如果有借位先将借位偿还\n        if (i < B.size())//判断一下B是否有这一位，只有存在这一位的情况才需减去\n            t = t - B[i];//算出 被减数 减去 减数 后的值\n\n        /*if(t >= 0)//如果够减,直接将答案存入\n        {\n            C.push_back(t);\n            t = 0;\n        }\n        else\n        {\n            C.push_back(t+10);\n            t = 1;\n        }\n        */\n        //判断是否需要进位的语句也可以写成如下样式\n        C.push_back((t + 10) % 10);\n        if (t < 0)\n            t = 1;\n        else\n            t = 0;\n    }\n\n    //减法运算后的结果可能存在前导0的情况，需要去除前导0\n    while (C.size() > 1 && C.back() == 0)//如果答案只有一位，哪怕这位是0也需要保留。如果位数大于1位，并且最高位为0，则最高位需要弹出\n    {\n        C.pop_back();\n    }\n\n    return C;\n}\n\n//比较两个大整数的大小 ， 是否存在 A >= B\nbool cmp(vector<int>& A, vector<int>& B) {\n    if (A.size() != B.size())//如果位数不同，可以根据位数进行判断\n        return A.size() > B.size();\n    else//如果位数相同，则从最高位依次与下一位相比较\n        for (int i = A.size() - 1; i >= 0; i--)//因为是逆序存储，因此判断的时候也需要逆序判断\n            if (A[i] != B[i])\n                return A[i] > B[i];\n\n    //如果全部判断完都没有判断出大小，则证明两个数相等。\n    return true;\n}\n\nint main() {\n    //注意：题目声明了a b 两个数均为正整数，不存在负数的情况。如果没有声明，则需要在读入后进行一次判断，判断两个数的首位是否存在负号。如果存在则需要加一个标记。\n    //任意两个数相减都可以转换为两个数的绝对值相加或相减，因此如果存在负数只需要在输入输出的时候特判一下即可\n    string a, b;//利用string实现大数的一个读入\n    vector<int>A, B;//之所以用vector容器，是因为vector有一个size属性比较方便，且没有位数的限制\n    cin >> a >> b;//读入a,b\n\n    //逆序存入\n    for (int i = a.size() - 1; i >= 0; i--)\n        A.push_back(a[i] - '0');//逆序存入到vector数组\n    for (int i = b.size() - 1; i >= 0; i--)\n        B.push_back(b[i] - '0');//逆序存入到vector数组\n\n    //因为题目中有“计算结果可能为负数”，即表示，A可能小于B,因此需要判断一下\n    //3 - 5 可以转换为 (5 - 3) * -1 。\n    if (cmp(A, B))\n    {\n        auto C = sub(A, B);//c++11的新东西，auto。\n        for (int i = C.size() - 1; i >= 0; i--)//因为是倒序存入，因此在读出的时候也需要倒序\n            printf(\"%d\", C[i]);\n    }\n    else\n    {\n        auto C = sub(B, A);\n        printf(\"-\");//如果A小于B，则证明结果是负数，需要提前打出负号，并将运算改为B-A\n        for (int i = C.size() - 1; i >= 0; i--)//因为是倒序存入，因此在读出的时候也需要倒序\n            printf(\"%d\", C[i]);\n    }\n    return 0;\n}\n```\n\n### 一个大整数与一个普通整数相乘\n\n#### 具体实现思想\n\n```\n同大整数相加的原理类似，但实现想法相比实际笔算有些许的不同。设大数A有5位，依次是A[0]，A[1]，...，A[4]；小整数为b，答案C[0] = A[0] x b，C[1] = A[1] x b；因为是十进制的相乘，每一位数最大值是9，因此需要一个进位辅助 t ，将每一位中大于9的部分进行暂存，并在下一位运算的过程中继续参与运算，直到t空为止。\n```\n\n\n1. 首先逆序读入；\n2. 特判一下b是否等于0，如果等于0则直接结束运算并输出一个0；\n3. 大整数的每一位依次乘上小整数，并将结果存入辅助进位的变量t，将t模除10后写入对应的答案位；\n4. t除以10去除写入答案的值，然后继续第3步直到大整数A的每一位都运算完成；\n5. 继续将t写入答案，然后除以10，直到t = 0为止；\n6. 逆序输出答案；\n\n#### 实现代码\n\n##### 模板\n\n```c\nvector<int> mul(vector<int> A, int b) {\n    vector<int> C;\n    int t = 0;//存储进位的辅助变量\n\n    //如果大数A没有循环完，则每次都将大数A与小数b进行相乘\n    //当大数循环完，但t中还有数没有写到答案中，则依然继续循环，但不再进行大数与小数的相乘\n    //当大数循环完，t也被清空了，就结束循环\n    //根据之前的程序设计，是否在此处进行前导零的删除\n    for (int i = 0; i < A.size() || t != 0; i++) {\n        if(i < A.size())\n            t += A[i] * b;\n        C.push_back(t % 10);\n        t /= 10;\n    }\n  \n  \t//如果没有进行特判，则在退出之前需要删除多余的前导0.（当其中小数是0时就会出现多余的前导0）\n\t  return C;\n}\n```\n\n##### 使用stl库\n\n```c\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> mul(vector<int> A, int b) {\n    vector<int> C;\n    int t = 0;//存储进位的辅助变量\n    for (int i = 0; i < A.size(); i++) {\n        t += A[i] * b;\n        C.push_back(t % 10);\n        t /= 10;\n    }\n    while (t) {//把剩余进位继续写入\n        C.push_back(t % 10);\n        t /= 10;\n    }\n\n    //注意 可能存在前导0的情况，需要处理掉,或者检测到b = 0 的时候，直接输出一个0.\n\n    return C;\n}\n\nint main() {\n\n    string a;\n    int b;\n\n    cin >> a >> b;\n\n    //这里做了下特判，因为出现多余的0的情况只在b是0的时候，当我们检测到其中一个除数是0的时候，可以直接输出0。\n    if (b == 0) {\n        printf(\"0\");\n        return 0;\n    }\n\n    vector<int>A;\n    for (int i = a.size() - 1; i >= 0; i--) {//逆序读入\n        A.push_back(a[i] - '0');\n    }\n\n    vector<int> C = mul(A, b);\n\n    for (int i = C.size() - 1; i >= 0; i--)//再次逆序输出\n        printf(\"%d\", C[i]);\n\n    return 0;\n}\n\n```\n\n### 一个大整数与一个普通整数相除\n\n#### 具体实现思想\n\n```\n除法比较特殊，是从最高位开始算的， 整个过程模拟笔算，\n```\n\n\n1. 把前一位的余数*10+这一位的余数，然后除以除数，把能除的部分写入到商（答案）中，\n2. 接着把上一步得到的数模除一下除数，留下本次的余数，并参与到下次的运算。\n3. 运算结束可以根据需求反转一下\n4. 去除前导0，结束运算\n\n#### 实现代码\n\n##### 模板\n\n```c\n//大数A，小数b，余数r\nvector<int> div(vector<int> &A, int b, int &r) {\n    vector<int> C;//商\n    r = 0;//余数 引用传回\n  \n    for(int i = A.size()-1; i >= 0; i--){\n        r = r * 10 + A[i];\n        C.push_back(r / b);\n        r %= b;\n    }\n   \n    reverse(C.begin(),C.end());\n  \n    //去除前导0\n    while(C.size()>1 && C.back() == 0)\n        C.pop_back();\n  \n    return C;\n}\n```\n\n##### 使用stl库\n\n```c\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n//大数A，小数b，余数r\nvector<int> div(vector<int> &A, int b, int &r) {\n    vector<int> C;//商\n    r = 0;//余数 引用传回\n  \n    /*\n    除法比较特殊，是从最高位开始算的\n    整个过程模拟笔算\n    把前一位的余数*10+这一位的余数，然后除以除数，把能除的部分写入到商（答案）中\n    然后把上一步得到的数模除一下除数，留下本次的余数，并参与到下次的运算。\n    */\n    for(int i = A.size()-1; i >= 0; i--){\n        r = r * 10 + A[i];\n        C.push_back(r / b);\n        r %= b;\n    }\n  \n  \n    //因为除法相比于其他的运算是反过来的，是从最高位开始运算的，这里需要反转一下\n    //否则就是输出的时候反过来输出。但这带来了一个新的问题：先导0很难去除\n    //所以还是反转一下比较好，这样好去除先导0，并且输出可以不用另外更改\n    reverse(C.begin(),C.end());//  \n  \n    //去除前导0\n    while(C.size()>1 && C.back() == 0)\n        C.pop_back();\n  \n    return C;\n}\n\nint main() {\n\n    string a;\n    int b;\n\n    cin >> a >> b;\n\n    vector<int>A;\n    for (int i = a.size() - 1; i >= 0; i--) {//逆序读入\n        A.push_back(a[i] - '0');\n    }\n  \n    int r;\n    vector<int> C = div(A, b, r);\n\n    for (int i = C.size() - 1; i >= 0; i--)//再次逆序输出\n        printf(\"%d\", C[i]);\n\n    cout << endl << r <<endl;\n    return 0;\n}\n```\n\n## 前缀和与差分\n\n### 前缀和（一维）\n\n#### 简介\n\n有一个长度为n的数组a，为：a[1]，a[2]，a[3]，...，a[n]；\n\n对应的前缀和数组为：s[1]，s[2]，...，s[n]；s[ i ] = a[ 1 ] + a[ 2 ] + ... + a[ i ]\n\n#### 作用\n\n```\n快速的求出数组中一段数的和。\n```\n\n\n```\n使用前缀和进行计算可以将时间复杂度由原来的 O( n ) 降低到 O( 1 )；\n```\n\n\n#### 计算方法\n\n##### 前缀和预处理\n\n```\ns[ i ] = s[ i - 1 ] + a[ i ];\n```\n\n\n##### 使用前缀和\n\n```\na[ l ] ~ a[ r ]的和 = S[r] - S[ l - 1 ]\n```\n\n\n#### 时间复杂度\n\n前缀和数组在预处理阶段是 O(n)，在使用的时候是 O(1)\n\n#### 注意事项\n\n1. 在使用前缀和的时候，一般使得数组下标从1起，空出开头的一个，方便计算。\n\n#### 模板\n\n```c\nS[i] = a[1] + a[2] + ... a[i]\na[l] + ... + a[r] = S[r] - S[l - 1]\n```\n\n#### 例题：795.前缀和\n\n> 输入一个长度为 n 的整数序列。\n>\n> 接下来再输入 m 个询问，每个询问输入一对 l,r。\n>\n> 对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。\n>\n> #### 输入格式\n>\n> 第一行包含两个整数 n 和 m。\n>\n> 第二行包含 n 个整数，表示整数数列。\n>\n> 接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。\n>\n> #### 输出格式\n>\n> 共 m 行，每行输出一个询问的结果。\n>\n> #### 数据范围\n>\n> 1 ≤ l ≤ r ≤ n\n> 1 ≤ n,m ≤ 100000\n> −1000 ≤ 数列中元素的值 ≤ 1000\n>\n> #### 输入样例：\n>\n> ```\n> 5 3\n> 2 1 3 6 4\n> 1 2\n> 1 3\n> 2 4\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 3\n> 6\n> 10\n> ```\n\n```c\n#include <iostream>\nusing namespace std;\nconst int N = 1e6+10;\n\nint n,m,l,r;\nint nums[N],s[N];//输入的数组，对应的前缀和数组\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i ++ ){\n        scanf(\"%d\", &nums[i]);\n        s[i] = s[i - 1] + nums[i];//输入的同时对前缀和进行一个初始化\n    }\n    while(m--){\n        scanf(\"%d%d\", &l, &r);\n        printf(\"%d\\n\",s[r] - s[l - 1]);//利用前缀和公式直接求出指定区间的和,区间和的计算  \n    }\n  \n    return 0;\n}\n\n\n```\n\n### 前缀和（二维）\n\n用于快速的求出一个子矩阵内的和。\n\n原理和一维的前缀和相同，这里不再赘述。\n\n#### 前缀和矩阵的预处理公式\n\n```\ns[ i, j ] = s[ i - 1, j ] + s[ i , j - 1 ] - s[ i - 1 , j - 1 ] + a[ i , j ]\n```\n\n\n#### 区间和的计算\n\n```\ns[x2,y2]  - s[x2,y1-1] - s[x1-1,y2-1 ] + s[x1-1,y1-1]\n```\n\n\n![image-20220630154949763](./Image/Other/image-20220630154949763.png)\n\n#### 模板\n\n```c\nS[i, j] = 第i行j列格子左上部分所有元素的和\n以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：\nS[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\n```\n\n#### 例题：796. 子矩阵的和\n\n> 输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。\n>\n> 对于每个询问输出子矩阵中所有数的和。\n>\n> #### 输入格式\n>\n> 第一行包含三个整数 n，m，q。\n>\n> 接下来 n 行，每行包含 m 个整数，表示整数矩阵。\n>\n> 接下来 q 行，每行包含四个整数 x1,y1,x2,y2，表示一组询问。\n>\n> #### 输出格式\n>\n> 共 qq 行，每行输出一个询问的结果。\n>\n> #### 数据范围\n>\n> 1 ≤ n, m ≤ 1000\n> 1 ≤ q ≤ 200000\n> 1 ≤ x1 ≤ x2 ≤n\n> 1 ≤ y1 ≤ y2 ≤m\n> −1000 ≤ 矩阵内元素的值 ≤ 1000\n>\n> #### 输入样例：\n>\n> ```\n> 3 4 3\n> 1 7 2 4\n> 3 6 2 8\n> 2 1 2 3\n> 1 1 2 2\n> 2 1 3 4\n> 1 3 3 4\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 17\n> 27\n> 21\n> ```\n\n```c\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 1010;\n\nint nums[N][N], s[N][N];\nint n, m, q;\n\nint main()\n{\n    scanf(\"%d%d%d\", &n, &m, &q);\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            scanf(\"%d\", &nums[i][j]);\n            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + nums[i][j];\n        }\n    }\n\n    while (q--) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        cout << s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1] << endl;\n    }\n\n    return 0;\n}\n```\n\n### 差分（前缀和的逆运算）\n\n差分就是给你一个前缀和数组，让你根据数组还原出原来的数组\n\n对于一维数据来说，就是设给定一个前缀和数组s[n]，然后假想一个数组b，使得s数组是b数组的前缀和，此时，b就成为s的差分，s是b的前缀和；\n\n对于二维数据，也是类似的，给定一个原数组a[i,j]，构造一个b矩阵b[i,j]，使得a数组是b数组的前缀和。\n\n对于差分算法来说，都可以不用考虑构造的问题，假定初始数组都是0即可，对于原有的数据视为插入即可。\n\n#### 差分的作用\n\n```\n对于一维数据来说，给定一个数组，要求在数组中指定的区域（l，r）中每个数都加上一个指定的数c。如果次数较多，可以使用 差分 算法实现。差分算法的实现要求是首先用O(n)的时间构造出一个辅助数组（不是必须的），之后的所有操作就可以在O(1)内完成，最后在用O(n)的时间算出全部。\n```\n\n\n#### 一维差分\n\n##### 思路\n\n1. 假定原数组a[n]全部是0，此时辅助的差分数组b内也全部都是0。\n2. 将输入的数据视为插入。就是说，可以看作进行了n次的插入操作。\n   如a[1]是2的话，可以看作进行了如下的操作：原数组的[1,1] + a[1] ； 原数组的[n,n] + a[n]。\n   此时，就规避了构造的问题。\n3. 此时，就可以总结出一个规律：想对一个区间全部加上一个数，就可以进行b[l] + c ; b[r + 1] - c;实现。\n4. 按照1到3的思路来说，原数组a[i]就没有存在的需要，只需要一个差分数组b[i]即可。输入原数组的时候，可以视为进行了插入操作，即b[i] += c , b[i + 1] -= c;\n   在全部输入完成后，只需要对着辅助数组求一遍前缀和即可还原为原数组的数据。如b[i] += b[i-1]；\n\n##### 模板\n\n```c\n给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c\n```\n\n##### 例题 ：797. 差分\n\n> 输入一个长度为 n 的整数序列。\n>\n> 接下来输入 m 个操作，每个操作包含三个整数 l,r,c 表示将序列中 [l,r] 之间的每个数加上 c。\n>\n> 请你输出进行完所有操作后的序列。\n>\n> #### 输入格式\n>\n> 第一行包含两个整数 n 和 m。\n>\n> 第二行包含 n 个整数，表示整数序列。\n>\n> 接下来 m 行，每行包含三个整数 l，r，c 表示一个操作。\n>\n> #### 输出格式\n>\n> 共一行，包含 n 个整数，表示最终序列。\n>\n> #### 数据范围\n>\n> 1 ≤ n,m ≤ 100000\n> 1 ≤ l ≤ r ≤ n\n> −1000 ≤ c≤1000\n> −1000 ≤ 整数序列中元素的值 ≤ 1000\n>\n> #### 输入样例：\n>\n> ```\n> 6 3\n> 1 2 2 1 2 1\n> 1 3 1\n> 3 5 1\n> 1 6 1\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 3 4 5 3 4 2\n> ```\n\n```c\n#include <iostream>\nusing namespace std;\n\nconst int N = 1e6+10;\nint b[N];//差分数组\nint n,m;\n\nvoid insert(int l,int r,int c){\n    b[l] += c;\n    b[r+1] -= c;\n}\n\nint main(){\n    int c;\n  \n    scanf(\"%d%d\", &n, &m);\n  \n    for (int i = 1; i <= n; i ++ ){\n        scanf(\"%d\", &c);\n        insert(i,i,c);//把原数组视为逐个插入\n    }\n  \n    //多轮插入\n    while (m -- ){\n        int l,r;\n        scanf(\"%d%d%d\", &l, &r, &c);//读入每轮的范围及数值\n        insert(l,r,c);//插入\n    }\n  \n    //整合并输出\n    for (int i = 1; i <= n; i ++ )\n    {\n        b[i] += b[i-1];\n        printf(\"%d \",b[i]);\n    }\n  \n    return 0;\n}\n```\n\n#### 二维差分\n\n```\n对于一维差分来说，是给一段距离加上一个值；\n```\n\n\n```\n而对于二维差分来说，是给一个子矩阵加上一个值；\n```\n\n\n```\n操作的时间复杂度来说，由原先的整个子矩阵变成了四个点，由O(n) 下降到 O(1)\n```\n\n\n##### 思路\n\n1. 不考虑构造，假定初始a[i,j]都是0，同样b[i,j]也就都为0了。对于a[i，j]中原有的数据，依次遍历插入即可；\n2. 对于插入方法来说，\n   1. 一维插入方法是：b[l] += c; b[r+1] -= c;\n   2. 二维的插入方法是：（设要插入的子矩阵的左上角坐标为：x1,y1，右下角的坐标为：x2,y2）\n      1. b[x1 , y1] += c; //先将从子矩阵左上角到整个大矩阵的右下角所有的值都加上c\n      2. b[x2 + 1 , y1] -= c;  //然后将子矩阵左下角到整个大矩阵右下角所有的值减去c\n      3. b[x1 , y2 + 1] -= c;  //接着将子矩阵右上角到整个大矩阵右下角所有的值减去c\n      4. b[x2+1 , y2+1] += c;  //因为第2、3步的操作导致了子矩阵右下角到整个大矩阵右下角所有的值减去两遍c，因此需要补回一个。\n3. 最后输出的时候求一下b数组的前缀和就可以了。\n\n##### 模板\n\n```c\n给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：\nS[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c\n位运算 —— 模板题 AcWing 801. 二进制中1的个数\n求n的第k位数字: n >> k & 1\n返回n的最后一位1：lowbit(n) = n & -n\n```\n\n##### 例题\n\n> 输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c 其中 (x1,y1)和 (x2,y2)表示一个子矩阵的左上角坐标和右下角坐标。\n>\n> 每个操作都要将选中的子矩阵中的每个元素的值加上 c。\n>\n> 请你将进行完所有操作后的矩阵输出。\n>\n> #### 输入格式\n>\n> 第一行包含整数 n,m,q。\n>\n> 接下来 n 行，每行包含 m 个整数，表示整数矩阵。\n>\n> 接下来 q 行，每行包含 5 个整数 x1,y1,x2,y2,c 表示一个操作。\n>\n> #### 输出格式\n>\n> 共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。\n>\n> #### 数据范围\n>\n> 1 ≤ n,m ≤ 1000\n> 1 ≤ q ≤ 100000\n> 1 ≤ x1 ≤ x2 ≤ n\n> 1 ≤ y1 ≤ y2 ≤ m\n> −1000 ≤ c ≤ 1000\n> −1000 ≤ 矩阵内元素的值 ≤ 1000\n>\n> #### 输入样例：\n>\n> ```\n> 3 4 3\n> 1 2 2 1\n> 3 2 2 1\n> 1 1 1 1\n> 1 1 2 2 1\n> 1 3 2 3 2\n> 3 1 3 4 1\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 2 3 4 1\n> 4 3 4 1\n> 2 2 2 2\n> ```\n>\n> ```c\n> #include <iostream>\n>\n> using namespace std;\n>\n> const int N = 1010;\n> int b[N][N];\n> int n,m,q;\n>\n> //二维差分的核心\n> void insert(int x1,int y1,int x2,int y2,int c){\n>  b[x1][y1] += c;\n>  b[x1][y2+1] -= c;\n>  b[x2+1][y1] -= c;\n>  b[x2+1][y2+1] += c;\n> }\n>\n> int main(){\n>  int c,x1,x2,y1,y2;\n>\n>  scanf(\"%d%d%d\",&n ,&m ,&q);\n>\n>  //将原数组的数据视为插入，依次进行读取处理\n>  for(int i = 1; i <= n; i++){\n>      for(int j = 1; j <= m; j++){\n>          scanf(\"%d\",&c);\n>          insert(i,j,i,j,c);\n>      }\n>  }\n>\n>  //开始多轮修改\n>  while(q--){\n>      scanf(\"%d%d%d%d%d\",&x1, &y1, &x2, &y2, &c);\n>      insert(x1,y1,x2,y2,c);\n>  }\n>\n>  //修改完成后，根据差分数组b进行一次前缀和的运算，并且输出出来\n>  for(int i = 1; i <= n; i++){\n>      for(int j = 1; j<= m; j++){\n>          b[i][j] = b[i][j] + b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];\n>          printf(\"%d \", b[i][j]);//直接输出\n>      }\n>      printf(\"\\n\");\n>  }\n>\n>  return 0;\n> }\n> ```\n\n## 双指针算法\n\n### 介绍\n\n简单的说双指针算法就是有两个指针来进行操作的算法。\n\n两个指针可以指向不同的序列，可以指向相同序列中不同的位置 。\n\n双指针算法的应用范围非常广，有时甚至都意识不到。比如常见的快排、归并排序都应用到了双指针的思想。\n\n### 模板\n\n一般的写法就一种情况：\n\n```c\nfor(int i = 0, j = 0; i < n; i++)\n{\n  \twhile(j < i && check(i,j))\n    {\n      \tj++;\n    }\n  \n  \t//每个题目的具体逻辑\n}\n```\n\n简单的说 双指针算法的核心思想就是，将原始的双重循环O( n ^ n  )的算法，通过某种性质优化到一重循环O(n)\n\n### 样例1：给定一个字符串 将其转换成一个个单词输出\n\n> 给定一个字符串 将其转换成一个个单词输出。保证字符串首字符不是空格，且单词之间的分隔符是空格\n>\n> 如：abc def ghi\n>\n> 输出：\n>\n> ```\n> abc\n> \tdef\n> \tghi\n> ```\n>\n>\n> ```c\n> #include <iostream>\n> #include <stdio.h>\n> #include <string.h>\n>\n> using namespace std;\n>\n> int main(){\n>  char str[1000];\n>  gets(str);\n>\n>  int n = strlen(str);\n>\n>  //利用双指针算法算出当前单词的结束位置\n>  for(int i = 0; str[i]; i++){\n>      int j = i;\n>      while(j < n && str[j] != ' ')//只要j没到终点，且当前j是非空格（分界符）\n>          j++;//直到j指向分界符\n>\n>      //往下就是这道题的具体逻辑\n>      for(; i < j; i++){\n>          cout << str[i];\n>      }\n>      cout << endl ;\n>\n>  }\n>\n>  return 0; \n>\n> }\n> ```\n\n### 样例2：799. 最长连续不重复子序列\n\n#### 实现思路\n\n1. 有两个指针i，j，j 在前 i 在后。i每次后移增加新的数据\n2. 每次增加完，检查 j 到 i 之间有没有重复数据，如果有，则 j 指针后移（j指针只能后移，因为序列是有序的，不可能存在前一个区间内有重复数字，新加入一个数后区间内重复数字消失了，只有一种情况就是新增加的数导致了区间内有重复的数据），直到整个区间内没有重复数字位置。（具体操作见后面）\n3. 计算已有的记录和当前区间的长度，如果当前的更长就更新记录\n4. 检查方法：类似于哈希，哈希公式就是数值本身。即f( x ) = x ;\n\n#### 具体题目及代码\n\n> 给定一个长度为 nn 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。\n>\n> #### 输入格式\n>\n> 第一行包含整数 n。\n>\n> 第二行包含 n 个整数（均在 0∼105 范围内），表示整数序列。\n>\n> #### 输出格式\n>\n> 共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。\n>\n> #### 数据范围\n>\n> 1 ≤ n ≤ 105\n>\n> #### 输入样例：\n>\n> ```\n> 5\n> 1 2 2 3 5\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 3\n> ```\n>\n> ```c\n> #include <iostream>\n>\n> using namespace std;\n>\n> const int N = 1e6+10;\n>\n> int a[N];//读入的数据\n> int s[N];//当前i到j之间，每一个数出现的次数\n> int n;\n>\n> int main()\n> {\n>  cin>>n;\n>  for (int i = 0; i < n; i ++ )\n>      scanf(\"%d\", &a[i]);\n>\n>  int res;//答案，或者说是最长的记录\n>\n>  for(int i = 0, j = 0; i < n; i++){\n>      s[a[i]]++;//i指针后移后，将新的数对应的地方++，表示多了这一个数\n>\n>      //条件1：j<=i可以不用写，因为当j > i的时候，区间里就没有数了，此时一定满足没有重复数的要求。\n>      //条件2：新加入的数是a[i]，因此判断当前是否有不止一个的数。\n>      //如果i指针当前指向的数不止一个，即表明j到i之间的数存在重复，且重复的位置是新入的i指针指向的位置。（因为在上一次循环已经排除了重复，最坏的可能就是上一轮中 i 和 j 都指向他自己\n>      //假定重复的值是j指向的位置，只需要将s中j指向的个数--，然后j指针后移，直到j到i的区间内不存在重复即可\n>      while(j <= i && s[a[i]]>1)\n>      {\n>          s[a[j]] -- ;//\n>          j ++ ;\n>      }\n>      res = max(res,i - j + 1);//此时计算一下j到i之间有多少个数，并将这个数与已有的记录进行比较，如果大于就更新一下。\n>  }\n>\n>  cout << res << endl;\n>  return 0;\n> }\n> ```\n\n#### 他人题解\n\n> AcWing 799. 最长连续不重复子序列-从暴力到双指针的详细过程    原题链接    简单\n> 作者：    bbk ,  2020-10-27 20:55:03 ,  所有人可见 ,  阅读 1836\n>\n> 给定一个长度为n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。\n> 输入格式:\n> 第一行包含整数n。\n> 第二行包含n个整数（均在0~100000范围内），表示整数序列。\n> 输出格式:\n> 共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。数据范围:\n> 1≤n≤1000001≤n≤100000\n> 输入样例:：\n>\n> 5\n> 1 2 2 3 5\n>\n> 输出样例：\n>\n> 3\n>\n> 思路：\n> 暴力法：\n> 当然可以用暴力法：对每个 i 和 j 都遍历一遍，对每个 i 和 j 都check一下中间的数据是否满足给定的条件。这样的时间复杂度是O(n^2)；数据稍微大点就会超时。\n> 代码如下：\n>\n> ```c\n> for (int i = 0; i < n; i++)\n> for (int j = 0; j <= i; j++)\n>   if (check(v1,j, i) == 0)//检查 i 和 j 之间是否有重复的数字\n>       res = max(res, i - j + 1);\n>\n> //check函数\n> int check(vector<int>& v1, int l, int r)\n> {\n> for (int i = l+1; i <=r ; i++)\n>   for (int j = l; j < i; j++)\n>       if (v1[i] == v1[j])\n>           return 1;\n> return 0;\n> }\n> ```\n>\n> 双指针法一：\n> 仔细考虑暴力法就会发现，暴力法在解题时有很多地方是重复计算了 ( i 指针在 j 指针的后面，i是遍历的整个数组的，j 是遍历 0 到 i 的)：\n>\n> 比如 j = 0，i = 5，此时发现 i，j 是满足题解条件的；那么后面的 j = 1到5，i = 5 就不用计算了，肯定是满足条件的。\n>\n> 所以引出了双指针法：还是上面的例子，双指针法就是说，既然发现 j = 0，i = 5满足题解条件，那就不用计算 j = 1到5，i = 5了，直接计算 j = 1，i = 6，如果不满足条件，那就计算 j = 2，i = 6，然后接着计算。\n>\n> 这样就是 i 和 j 指针都是从前移到后，也就是计算2n次。时间复杂度是O(2n)。\n>\n> 核心代码如下：（但是还会超时）。\n>\n> for (int i = 0, j = 0; i < n; i++)\n> {\n> while (j <= i)\n> {\n> if (check(v1, j, i) == 0)\n> {\n> res = max(res, i - j + 1);\n> break;\n> }\n> else\n> j++;\n> }\n> }\n>\n> //找得到重复的数返回1\n> int check(vector<int>& v1, int l, int r)\n> {\n> for (int i = l + 1; i <= r; i++)\n> for (int j = l; j < i; j++)\n> {\n> if (v1[i] == v1[j])\n> return 1;\n> }\n> return 0;\n> }\n>\n> 双指针法二（最终版）：\n> 但是上面代码还是超时，为什么呢？因为check函数写的不好，循环太多，直接是暴力计算找重复数字的，显然不好。\n>\n> 所以引出一个新的check方法：对于寻找是否有重复数字，一般用hash，没人用暴力。所以用hash就可以计算。\n>\n> 但是这道题还有一种计算方法：\n>\n> 用一个辅助数组S保存原数组V1每个元素存在的次数，和hash类似。\n> 比如说 V1 = {1,2, 2, 3, 5 }。那 S就是 {0,1,2,1,0,1 }。S[V1[i]]表示的是V1[i]的个数。\n> 此处我们用S数组只保存 j 和 i 指针之间的数的个数。\n>\n> 算法思路： 如果j = 0，i = 5，此时检查S数组元素都是 <=1的。那下一步的情况就是 i 。i之后将S数组更新，只需要检查S[v1[i]]元素是不是比1大即可，因为随着 i 的递增，S数组中变化的只有S[v1[i]]元素。\n> 如果检查S[v1[i]]元素发现该元素比 1 大。那说明 j 指针和 i 指针之间有某个元素出现了两次。所以 i 指针保持不动， j 指针往后移动( j 指针不可能往前移动的，上次j指针往后移动就是因为 j 和 i之间有重复元素，这一往前移动肯定有重复元素)。j 指针往后移动之前需要先更新S数组，即进行 S[v1[j]]– 操作。然后 j 指针再往后移动。移动之后只需要检查 i 指针对应的S[v1[i]]元素是否大于1即可。（因为 j 指针移动之后只有两种情况，1.重复元素刚好没了，则S[v1[i]]肯定==1；2.重复元素还在，那S[v1[i]]==2，需要 j 继续往后移动 )。等S[v1[i]]==1 时，说明 j 和 i 之间已经没有重复元素了，可以更新res值，然后 i++。\n>\n> 核心代码：\n>\n> ```c\n> for (int i = 0,j = 0; i < n; i++)\n> {\n> S[v1[i]]++;\n> while ( S[v1[i]] > 1) --S[v1[j++]];\n> res = max(res, i - j + 1);\n> }\n> ```\n>\n> 代码实现：\n>\n> ```c\n> #include<iostream>\n> #include <vector>\n> #include <algorithm>\n> #define N  100010\n> using namespace std;\n>\n> int main()\n> {\n> int n;\n> cin >> n;\n> vector<int> v1(n,0);\n> for (int i = 0; i < n; i++)\n>   cin >> v1[i];\n>\n> vector<int> S(N,0);\n>\n> int res = 0;\n> for (int i = 0,j = 0; i < n; i++)\n> {\n>   S[v1[i]]++;\n>   while ( S[v1[i]] > 1) --S[v1[j++]];\n>   res = max(res, i - j + 1);\n> }\n>\n> cout << res;\n>\n> return 0;\n> }\n> ```\n>\n> 作者：bbk\n> 链接：https://www.acwing.com/solution/content/23474/\n> 来源：AcWing\n> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n### 样例3：800. 数组元素的目标和\n\n> 给定两个升序排序的有序数组 AA 和 BB，以及一个目标值 xx。\n>\n> 数组下标从 00 开始。\n>\n> 请你求出满足 A[i]+B[j]=xA[i]+B[j]=x 的数对 (i,j)(i,j)。\n>\n> 数据保证有唯一解。\n>\n> #### 输入格式\n>\n> 第一行包含三个整数 n,m,xn,m,x，分别表示 AA 的长度，BB 的长度以及目标值 xx。\n>\n> 第二行包含 nn 个整数，表示数组 AA。\n>\n> 第三行包含 mm 个整数，表示数组 BB。\n>\n> #### 输出格式\n>\n> 共一行，包含两个整数 ii 和 jj。\n>\n> #### 数据范围\n>\n> 数组长度不超过 105105。\n> 同一数组内元素各不相同。\n> 1≤数组元素≤1091≤数组元素≤109\n>\n> #### 输入样例：\n>\n> ```\n> 4 5 6\n> 1 2 4 7\n> 3 4 6 8 9\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 1 1\n> ```\n\n#### 实现思路\n\n首先，因为两个数组的解是唯一的，不存在多种配对的问题。\n* 首先让i指针指向a数组开头（即a数组中最小的数）\n* 然后让j指针指向b数组的结尾（即b数组中最大的数）\n* 此时可以发现，i不动，j前移；i与j指针指向的数相加的结果必然是从大到小的。\n* 因此，利用这个性质，使得j不停的前移，直到两个指针指向的数的和小于等于要求的值\n* 此时，j停止移动，判断i与j指向的数是否相等，相等就输出，不等就进入下轮循环，i指针后移，j指针不动，直到匹配为止\n\n#### 代码\n\n```c\n#include <iostream>\nusing namespace std;\n\nconst int N = 1e5 + 10;\nint n, m, x;\nint a[N], b[N];\n\nint main()\n{\n    //读入数据\n    scanf(\"%d%d%d\", &n, &m, &x);\n    for (int i = 0; i < n; i++)\n        scanf(\"%d\", &a[i]);\n    for (int i = 0; i < m; i++)\n        scanf(\"%d\", &b[i]);\n\n    /*\n    *利用双指针开始配对\n    * 首先让i指针指向a数组开头（即a数组中最小的数）\n    * 然后让j指针指向b数组的结尾（即b数组中最大的数）\n    * 此时可以发现，i不动，j前移；i与j指针指向的数相加的结果必然是从大到小的。\n    * 因此，利用这个性质，使得j不停的前移，直到两个指针指向的数的和小于等于要求的值\n    * 此时，j停止移动，判断i与j指向的数是否相等，相等就输出，不等就进入下轮循环，i指针后移，j指针不动，直到匹配为止\n    */\n    for (int i = 0, j = m - 1; i < n; i++) {\n        while (j >= 0 && b[j] + a[i] > x)\n            j--;\n        if (a[i] + sb[j] == x) {\n            printf(\"%d %d\\n\", i, j);\n            break;\n        }\n    }\n    return 0;\n}\n```\n\n### 样例4：2816. 判断子序列\n\n> 给定一个长度为 n 的整数序列 a1,a2,…,an 以及一个长度为 m 的整数序列 b1,b2,…,bm。\n>\n> 请你判断 a 序列是否为 b 序列的子序列。\n>\n> 子序列指序列的一部分项按**原有次序排列**而得的序列，例如序列 {a1,a3,a5} 是序列 {a1,a2,a3,a4,a5} 的一个子序列。\n>\n> #### 输入格式\n>\n> 第一行包含两个整数 n,m。\n>\n> 第二行包含 n 个整数，表示 a1,a2,…,an。\n>\n> 第三行包含 m 个整数，表示 b1,b2,…,bm。\n>\n> #### 输出格式\n>\n> 如果 a 序列是 b 序列的子序列，输出一行 `Yes`。\n>\n> 否则，输出 `No`。\n>\n> #### 数据范围\n>\n> 1≤n≤m≤10^5^\n> −10^9^ ≤ ai , bi ≤ 10^9^\n>\n> #### 输入样例：\n>\n> ```\n> 3 5\n> 1 3 5\n> 1 2 3 4 5\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> Yes\n> ```\n\n#### 实现思路\n\n```\n读入序列后，设两个指针分别指向两个序列的起始位置，若两指针指向的值相等，则两个序列的指针都后移一个；若不等，则子序列的不移动，长序列的继续后移，进行判断，直到两个序列中任意一个到达终点为止。此时判断子序列有没有走完，如果走完了说明就是子序列，否则就不是子序列。\n```\n\n\n#### 实现代码\n\n```c\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 1e5+10;\n\nint a[N],b[N];\nint n,m;\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 0; i < n; i ++ )\n        scanf(\"%d\", &a[i]);\n    for (int i = 0; i < m; i ++ )\n        scanf(\"%d\", &b[i]);\n      \n    int i = 0, j = 0;\n  \n    while(i < n  && j < m){//指针不能到头\n        if(a[i] == b[j])//如果匹配的话子序列的指针后移\n            i++;\n        j++;//不管是否匹配长序列都回后移，\n    }//直到子序列到头达成匹配或者长序列到头匹配失败退出\n  \n    if(i == n)//此时判断子序列的指针有没有到头，以判断是否是子序列\n        cout<<\"Yes\"<<endl;\n    else\n        cout<<\"No\"<<endl;\n    return 0;\n}\n```\n\n## 位运算\n\n### lowbit( x )：返回x的最后一位1\n\neg:\n\n```\nx = 1010B\t\tlowbit( x ) = 10B;\n```\n\n\n```\nx = 101000B\tlowbit( x ) = 1000B;\n```\n\n\n#### 实现方法\n\n```\nx & -x\n```\n\n\n```c\nint lowbit(int x){\n   return x & -x; \n}\n```\n\n#### 实现原理\n\n```\n数在c中是以补码的形式存在的，而负数的补码是正数取反+1。\n```\n\n\n设x的二进制数是：\t\t\t1010 . . . 100 . . . 0\n\n则x取反后的二进制是：\t0101 . . . 011 . . . 1\n\n取反后+1的结果等于：\t  0101 . . . 100 . . . 0\n\n因此，在c中将一个数取反+1后再和这个数相与的结果就是，0101 . . . 100 . . . 0 ，前面因为取反和原数不一样，因此在与的过程中全部变0，后面因为一样就全部保留了。\n\n#### 常用地方\n\n```\n求一个数的二进制中1的个数(奇偶校验？)\n```\n\n\n##### 例题：801. 二进制中1的个数\n\n> 给定一个长度为 n 的数列，请你求出数列中每个数的二进制表示中 1 的个数。\n>\n> #### 输入格式\n>\n> 第一行包含整数 n。\n>\n> 第二行包含 n 个整数，表示整个数列。\n>\n> #### 输出格式\n>\n> 共一行，包含 n 个整数，其中的第 ii 个数表示数列中的第 i 个数的二进制表示中 1 的个数。\n>\n> #### 数据范围\n>\n> 1 ≤ n ≤ 100000,\n> 0 ≤ 数列中元素的值 ≤ 10^9^\n>\n> #### 输入样例：\n>\n> ```\n> 5\n> 1 2 3 4 5\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 1 1 2 1 2\n> ```\n>\n> #### 代码\n>\n> ```c\n> #include <iostream>\n> using namespace std;\n>\n> int lowbit(int x){\n> return x & -x; \n> }\n>\n> int main()\n> {\n>  int n, x, res = 0;\n>  scanf(\"%d\", &n);\n>  while (n -- ){\n>      scanf(\"%d\", &x);\n>      while(x){\n>          x -= lowbit(x);//每次减去最后一个1\n>          res++;//减一个计数器+1\n>      }\n>      printf(\"%d \",res);\n>      res = 0;\n>  }\n>\n>  return 0;\n> }\n> ```\n\n## 离散化（特指整数的有序的离散化）\n\n暂时回避\n\n## 区间合并\n\n> 给定 n 个区间 [li,ri][li,ri]，要求合并所有有交集的区间。\n>\n> 注意如果在端点处相交，也算有交集。\n>\n> 输出合并完成后的区间个数。\n>\n> 例如：[1,3][1,3] 和 [2,6][2,6] 可以合并为一个区间 [1,6][1,6]。\n>\n> #### 输入格式\n>\n> 第一行包含整数 n。\n>\n> 接下来 n 行，每行包含两个整数 l 和 r。\n>\n> #### 输出格式\n>\n> 共一行，包含一个整数，表示合并区间完成后的区间个数。\n>\n> #### 数据范围\n>\n> 1 ≤ n ≤ 100000\n> −10^9^ ≤ li ≤ ri ≤ 10^9^\n>\n> #### 输入样例：\n>\n> ```\n> 5\n> 1 2\n> 2 4\n> 5 6\n> 7 8\n> 7 9\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 3\n> ```\n\n### 解题思路\n\n1. 我们知道区间的开头和结尾，可以开一个数组存下来\n2. 将所有区间进行排序，排序规则为左端点降序\n3. 依次检查每个区间的右端点，如果左端点超过已有记录，就证明是一个新的区间，res++;\n4. 如果右区间超过但左区间小于等于记录，就证明区间是连续的，刷新一下右端点即可\n5. 输出res\n\n### 代码\n\n```c\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 100010;\n\ntypedef pair<int, int> PII;\n\nint n, l, r;\nvector<PII> nums;//利用vector数组进行存储所有区间的左右端点，方便后续的排序\n\n//sort的仿函数可写可不写，因为默认就是根据pair的键值（第一个值，左端点）进行升序排序的\nbool MyCom(PII x, PII y) {\n    if (x.first < y.first)\n        return true;\n    else\n        return false;\n}\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d%d\", &l, &r);\n        nums.push_back({ l,r });//依次读入区间\n    }\n\n    //进行排序，要求左端点升序排序\n    //sort(nums.begin(),nums.end(),MyCom);\n    sort(nums.begin(), nums.end());\n\n    //给记录设置一个区间，要求这个区间比题目要求的所有的区间都要小\n    l = r = -1e9 - 10;\n    int res = 0;//区间个数，初始化成0\n\n    for (int i = 0; i < n; i++) {\n\n        //如果区间左端点大于已有区间的右端点，证明两个区间不连续，区间数++，刷新区间\n        if (r < nums[i].first) {\n            l = nums[i].first;\n            r = nums[i].second;\n            res++;\n        }\n        //能到这里就证明，当前区间的左端点一定是小于等于记录的右端点，证明是连续的，只需要更新右端点即可\n        else if (r < nums[i].second)\n        {\n            r = nums[i].second;\n        }\n\n    }\n\n    cout << res << endl;//输出答案\n\n    return 0;\n\n}\n```\n\n# 数据结构\n\n## 链表与邻接表：树与图的存储\n\n使用数组来模拟链表的存在，虽然会造成内存泄漏，但可以大幅提高速度。\n\n因为c++中的new是非常耗时间的，因此在竞赛或者笔试的时候，不要使用传统的结构体链表。(一般的数据范围都在10^5以上，如果new的话必定会超时)\n\n### 单链表\n\n#### 例题\n\n> 实现一个单链表，链表初始为空，支持三种操作：\n>\n> 1. 向链表头插入一个数；\n> 2. 删除第 k 个插入的数后面的数；\n> 3. 在第 k 个插入的数后插入一个数。\n>\n> 现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。\n>\n> **注意**:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。\n>\n> #### 输入格式\n>\n> 第一行包含整数 M，表示操作次数。\n>\n> 接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：\n>\n> 1. `H x`，表示向链表头插入一个数 x。\n> 2. `D k`，表示删除第 kk 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。\n> 3. `I k x`，表示在第 kk 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。\n>\n> #### 输出格式\n>\n> 共一行，将整个链表从头到尾输出。\n>\n> #### 数据范围\n>\n> 1≤M≤100000\n> **所有操作保证合法。**\n>\n> #### 输入样例：\n>\n> ```\n> 10\n> H 9\n> I 1 1\n> D 1\n> D 0\n> H 6\n> I 3 6\n> I 4 5\n> I 4 5\n> I 3 4\n> D 6\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 6 4 6 5\n> ```\n\n#### 思路\n\n类似于传统的结构体链表，不过改成用数组来模拟（变成静态链表）\n\n分别开辟一个数组e，存储每个节点的数据；ne，存储每个节点的加一个节点的地址。e与ne数组的联系在于下标，换句话说就是，e[i] 与 ne[i] 是一组的。以及变量head，存储头节点的位置；idx，存储使用了多少个节点（idx始终指向第一个未被使用的节点）\n\n当程序运行的时候需要进行初始化，将head置为-1，idx置为0。\n\n对于头节点的插入操作，只需要简单的：\n\n```c\nvoid insert_head(int x)\n{\n  \te[idx] = x;//将数据读入到节点\n\t\tne[idx] = head;//将下一个节点的指针置为头指针指向的位置\n\t\thead = idx ++;//将头指针指向新插入的节点，并且数量++\n}\n```\n\n对于指定位置的插入，也很简单，可以在O(1)的时间内完成\n\n```c\nvoid insert(int k,int x)\n{\n\t\te[idx] = x;//同样读入到节点\n\t\tne[idx] = ne[k];//将新节点的next指针指向第k个位置原本指向的位置\n\t\tne[k] = idx ++;//将第k个位置的指针指向新加入的节点，同时idx++便于下一步操作\n}\n```\n\n对于删除来说，就不需要再考虑空间的事了，可以直接的进行p->next = p->next->next的操作\n\n```c\nvoid del(int k)\n{\n\t\tne[k] = ne[ne[k]];\n}\n```\n\n但需要注意的是，如果要删除的节点是头节点，则需要这么做\n\n```c\nvoid del_head()\n{\n\t\thead = ne[head];\n}\n```\n\n对于模拟链表的遍历，和传统链表也很相似：\n\n```c\nvoid display()\n{\n  \t//i从头节点开始，直到遇到-1（head的初始化值）为止，i的下一位是ne[i]\n\t\tfor(int i = head; i != -1 ; i = ne[i])\n        printf(\"%d \",e[i]);\n}\n```\n\n#### 实现代码\n\n需要注意的是，k需要-1.因为题是从1起，而数组是从0起\n\n```c\n#include <iostream>\nusing namespace std;\n\nconst int N = 100010;\n\n//head 头节点的下标\n//e[i] 节点i的值\n//ne[i] 节点i的next指针是多少\n//idx  存储当前已经用了多少\nint head, e[N], ne[N], idx;\n\n//初始化\nvoid init()\n{\n    head = -1;//-1表示空\n    idx = 0;\n}\n\n//将x插入到头节点\nvoid add_to_head(int x){\n    //idx存储了最新的节点可用的下标是什么\n    e[idx] = x;//将x输入到e中新的节点\n    ne[idx] = head;//将新的节点的指针指向head；\n    head = idx;//将head的指针指向到新插入的头节点的位置\n    idx++;//将idx的值++，方便下次使用\n}\n\n//将x插入到下标为k的节点的后面\nvoid add(int k,int x)\n{\n    e[idx] = x;\n    ne[idx] = ne[k];\n    ne[k] = idx;\n    idx++;\n}\n\n//将下标是k的点的后一个点删掉\nvoid remove(int k)\n{\n    ne[k] = ne[ne[k]];\n}\n\nint main()\n{\n    int m;\n    scanf(\"%d\", &m);\n    init();\n    while(m--){\n        char op;\n        int k,x;\n        //scanf(\"%c\",&op);\n        cin>>op;\n        if(op == 'H')\n        {\n            //scanf(\"%d\",&x);\n            cin>>x;\n            add_to_head(x);\n        }\n        else if(op == 'D')\n        {\n            //scanf(\"%d\", &k);\n            cin>>k;\n            if(k == 0)//特判一下删除头节点的情况\n                head = ne[head];\n            else\n                remove(k - 1);\n        }\n        else\n        {\n            //scanf(\"%d%d\", &k, &x);\n            cin>>k>>x;\n            add(k - 1,x);\n        }\n      \n    }\n    for(int i = head; i != -1 ; i = ne[i])\n        printf(\"%d \",e[i]);\n  \n    return 0;\n}\n```\n\n### 双链表\n\n与单链表类似，只不过多了一个指针\n\n#### 例题\n\n> 实现一个双链表，双链表初始为空，支持 55 种操作：\n>\n> 1. 在最左侧插入一个数；\n> 2. 在最右侧插入一个数；\n> 3. 将第 k 个插入的数删除；\n> 4. 在第 k 个插入的数左侧插入一个数；\n> 5. 在第 k 个插入的数右侧插入一个数\n>\n> 现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。\n>\n> **注意**:题目中第 k 个插入的数并不是指当前链表的第 kk 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。\n>\n> #### 输入格式\n>\n> 第一行包含整数 M，表示操作次数。\n>\n> 接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：\n>\n> 1. `L x`，表示在链表的最左端插入数 x。\n> 2. `R x`，表示在链表的最右端插入数 x。\n> 3. `D k`，表示将第 k 个插入的数删除。\n> 4. `IL k x`，表示在第 k 个插入的数左侧插入一个数。\n> 5. `IR k x`，表示在第 k 个插入的数右侧插入一个数。\n>\n> #### 输出格式\n>\n> 共一行，将整个链表从左到右输出。\n>\n> #### 数据范围\n>\n> 1≤M≤100000\n> 所有操作保证合法。\n>\n> #### 输入样例：\n>\n> ```\n> 10\n> R 7\n> D 1\n> L 3\n> IL 2 10\n> D 3\n> IL 2 7\n> L 8\n> R 9\n> IL 4 7\n> IR 2 2\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 8 7 7 3 2 9\n> ```\n\n#### 思路\n\n和单链表类似，一个存储数据的数组e[N]，一个存储当前节点的左侧的数组l[N]，当前节点的右侧的数组r[N]，和下一个节点的地址idx。\n\n首先对数组进行初始化：一共有两个节点，下标分别是0和1，链表的最右边节点的下标是1，即 `r[0] = 1`；然后将最左边的节点设为0，即`l[1] = 0`\n\n对于插入到节点右侧的数据，可以进行如下操作：\n\n- ```\n  将数据写入到新的节点\n  ```\n\n  - e[idx] = x;\n- 将新创建的节点入队\n  - l[idx] = k , r[idx] = r[k];\n- 然后使得前后节点接受新插入的节点\n  - l[r[k]] = idx  , r[k] = idx;\n- 最后，idx++，为下次插入做准备\n\n对于插入到节点左侧的数据，可以视为对指定节点的前一个节点进行尾插操作，可以对上方教程进行复用\n\n- insert(l[k],x);\n\n对于删除指定节点，可以直接修改前后指针即可。\n\n- //第k个节点右边的左侧不再是k，而是k之前的节点\n  - ```\n    l[r[k]] = l[k];\n    ```\n- ```\n  //同理，第k个节点左边的右侧不再是k，而是k右边的节点。\n  ```\n\n  - ```\n    r[l[k]] = r[k];\n    ```\n\n#### 实现代码\n\n```c\n/*\n注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。\n*/\n#include <iostream>\nusing namespace std;\n\nconst int N = 1e5+10;\nint e[N],l[N],r[N],idx;\n\n//初始化\nvoid init()\n{\n    r[0] = 1;//链表的最右边是1\n    l[1] = 0;//最左边是0\n    idx = 2;//起始节点\n}\n\n//在第k个节点的右边插入一个元素\nvoid insert(int k,int x)\n{\n    //将数据写入新的节点\n    e[idx] = x;\n    //将新的节点连入链接\n    l[idx] = k;//新节点的左边是指定的位置\n    r[idx] = r[k];//新节点的右边是指定位置的右边\n    //将原链接指向新的节点\n    l[r[k]] = idx;//第k个节点后一个节点的左边变成新插入的节点\n    r[k] = idx;//第k个节点的右边变成新插入的节点\n    idx ++;\n}\n\n//在第k个节点的左边插入一个节点\nvoid insert_front(int k,int x)\n{\n    //第k个节点的左边，可以视作 l[k] ，因此可以写作：\n    insert(l[k],x);\n}\n\n//删除第k个节点\nvoid remove(int k)\n{\n    //第k个节点右边的左侧不再是k，而是k之前的节点\n    l[r[k]] = l[k];\n    //同理，第k个节点左边的右侧不再是k，而是k右边的节点。\n    r[l[k]] = r[k];\n}\n\nint main()\n{\n    init();\n  \n    int m;\n    cin>>m;\n    string op;\n    int k,x;\n    while(m--)\n    {\n        cin >> op;//读入每行的开头\n        //一次根据开头判断要干的事\n        if(op == \"L\")//最左端插入，相当于在头节点的右侧插入\n        {\n            cin >> x;\n            insert(0, x);\n        }\n        else if(op == \"R\")//最右端插入，相当于在尾节点的左侧插入\n        {\n            cin >> x;\n            insert_front(1, x );\n        }\n        else if(op == \"D\")\n        {\n            cin >> k;\n            remove(k + 1);\n        }\n        else if(op == \"IL\")\n        {\n            cin >> k >> x;\n            insert_f(k + 1, x);\n        }\n        else if(op == \"IR\")\n        {\n            cin >> k >> x;\n            insert(k + 1,x);\n        }\n          \n    }\n    for(int i = r[0]; i != 1; i = r[i])\n        printf(\"%d \",e[i]);\n  \n    return 0;\n}\n\n```\n\n## 栈与队列：单调队列、单调栈\n\n### 模拟栈\n\n#### 例题\n\n> 实现一个栈，栈初始为空，支持四种操作：\n>\n> 1. `push x` – 向栈顶插入一个数 x；\n> 2. `pop` – 从栈顶弹出一个数；\n> 3. `empty` – 判断栈是否为空；\n> 4. `query` – 查询栈顶元素。\n>\n> 现在要对栈进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。\n>\n> #### 输入格式\n>\n> 第一行包含整数 M，表示操作次数。\n>\n> 接下来 M 行，每行包含一个操作命令，操作命令为 `push x`，`pop`，`empty`，`query` 中的一种。\n>\n> #### 输出格式\n>\n> 对于每个 `empty` 和 `query` 操作都要输出一个查询结果，每个结果占一行。\n>\n> 其中，`empty` 操作的查询结果为 `YES` 或 `NO`，`query` 操作的查询结果为一个整数，表示栈顶元素的值。\n>\n> #### 数据范围\n>\n> 1≤M≤100000\n> 1≤x≤10^9^\n> 所有操作保证合法。\n>\n> #### 输入样例：\n>\n> ```\n> 10\n> push 5\n> query\n> push 6\n> pop\n> query\n> pop\n> empty\n> push 4\n> query\n> empty\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> 5\n> 5\n> YES\n> 4\n> NO\n> ```\n\n#### 思路\n\n首先用数组模拟一个栈，对栈的所有操作都可以转换成如下的操作：\n\n- 入栈：stk[++ tt] = x;\n- 出栈：tt --;\n- 判断是否为空：if(tt > 0) 不空 else 空\n- 栈顶元素stk[tt]\n\n其中：stk数组就是模拟栈的数组，tt为栈顶元素的指针\n\n#### 实现代码\n\n```c\n#include <iostream>\nusing namespace std;\n\nconst int N = 1e5+10;\n\n//模拟栈的数组，栈顶指针（栈顶下标）\nint stk[N], tt = 0;\n\n//入栈\nvoid push(int x)\n{\n    stk[++ tt] = x;\n}\n\n//出栈（弹出）\nint pop()\n{\n    tt --;\n    return stk[tt];\n}\n\n//判断栈是否为空，空为真\nbool empty()\n{\n    if(tt > 0)\n        return false;\n    else \n        return true;\n}\n\n//查看栈顶元素\nint query()\n{\n    return stk[tt];\n}\n\nint main()\n{\n    int m, x;\n    string op;\n    cin >> m;\n    while(m--)\n    {\n        cin >> op;\n        if(op == \"push\")\n        {\n            cin >> x;\n            push(x);\n        }\n        else if(op == \"pop\")\n        {\n            pop();\n        }\n        else if(op == \"empty\")\n        {\n            if(empty())\n                cout << \"YES\" << endl;\n            else\n                cout << \"NO\" << endl;\n        }\n        else if(op == \"query\")\n        {\n            cout << query() <<endl;\n        }\n      \n    }\n  \n    return 0;\n}\n```\n\n### 模拟队列\n\n#### 例题\n\n> 实现一个队列，队列初始为空，支持四种操作：\n>\n> 1. `push x` – 向队尾插入一个数 x；\n> 2. `pop` – 从队头弹出一个数；\n> 3. `empty` – 判断队列是否为空；\n> 4. `query` – 查询队头元素。\n>\n> 现在要对队列进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。\n>\n> #### 输入格式\n>\n> 第一行包含整数 M，表示操作次数。\n>\n> 接下来 M 行，每行包含一个操作命令，操作命令为 `push x`，`pop`，`empty`，`query` 中的一种。\n>\n> #### 输出格式\n>\n> 对于每个 `empty` 和 `query` 操作都要输出一个查询结果，每个结果占一行。\n>\n> 其中，`empty` 操作的查询结果为 `YES` 或 `NO`，`query` 操作的查询结果为一个整数，表示队头元素的值。\n>\n> #### 数据范围\n>\n> 1≤M≤100000\n> 1≤x≤10^9^\n> 所有操作保证合法。\n>\n> #### 输入样例：\n>\n> ```\n> 10\n> push 6\n> empty\n> query\n> pop\n> empty\n> push 3\n> push 4\n> pop\n> query\n> push 6\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> NO\n> 6\n> YES\n> 4\n> ```\n\n#### 思路\n\n和模拟栈类似，相比模拟栈多了一个队头指针，出队的时候用队头指针的后移实现；判断队空是由队头指针是否大于队尾指针实现。\n\n#### 实现代码\n\n```c\n#include <iostream>\nusing namespace std;\n\nconst int N = 1e5+10;\n\n//模拟队列的数组，队头，队尾\nint q[N], hh = 1, tt = 0;\n//需要注意的是，下标为0的地方是闲置不用的，模拟栈不需要考虑这点，但队列需要。\n//因此，队列在空的情况下队头指针是大于队尾指针的（）\n\n//入队\nvoid push(int x)\n{\n    q[++ tt] = x;//先后移队尾指针，然后再将数据写入到队尾指针指向的位置\n}\n\n//出队\nvoid pop()\n{\n    hh ++;//队头指针后移\n}\n\n//判断队列是否为空\nbool empty()\n{\n    if(hh > tt)//只要出现队头大于队尾的情况，就是空的。队头等于队尾的时候表示还有一个元素\n        return true;\n    else\n        return false;\n}\n\n//查看队头元素\nint query()\n{\n    return q[hh];\n}\n\nint main()\n{\n    int m, x;\n    string op;\n    cin >> m;\n    while(m --)\n    {\n        cin >> op;\n        if(op == \"push\")\n        {\n            cin >> x;\n            push(x);\n        }\n        else if(op == \"pop\")\n        {\n            pop();\n        }\n        else if(op == \"empty\")\n        {\n            if(empty())\n                cout << \"YES\" <<endl;\n            else\n                cout << \"NO\" << endl;\n        }\n        else if(op == \"query\")\n        {\n            cout << query() << endl;\n        }\n      \n    }\n  \n  \n    return 0;\n}\n```\n\n### 单调栈\n\n#### 例题\n\n> 给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。\n>\n> #### 输入格式\n>\n> 第一行包含整数 N，表示数列长度。\n>\n> 第二行包含 N 个整数，表示整数数列。\n>\n> #### 输出格式\n>\n> 共一行，包含N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。\n>\n> #### 数据范围\n>\n> 1≤N≤10^5^\n> 1≤数列中元素≤10^9^\n>\n> #### 输入样例：\n>\n> ```\n> 5\n> 3 4 2 7 5\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> -1 3 -1 2 2\n> ```\n\n#### 思路\n\n要求是左边第一个小的数（也可以是左/右边 第一个 最大/小的数），可以利用栈的特性实现。\n\n1. 判断当前栈是否为空，如果不为空判断栈顶元素是否比输入的数小（或者大），不满足就出栈，直到栈空。\n2. 再次判断栈是否为空，如果不是空的，那么栈顶元素就是需要的了。如果栈空了，就证明没匹配到，输出-1\n3. 不管上面如何，将输入的数入栈，供下个数使用。\n\n#### 实现代码\n\n```c\n#include <iostream>\nusing namespace std;\n\nconst int N = 1e5+10;\nint n, stk[N], tt;\n\nint main()\n{\n    cin >> n;\n  \n    for(int i = 0; i < n; i++)\n    {\n        int x;\n        cin >> x;\n        while(tt != 0 && stk[tt] >= x)//如果栈不为空，同时栈顶元素大于等于当前的元素，那么栈顶元素就不会用到了，可以出栈了\n            tt --;\n        if(tt != 0)//如果栈仍然不为空，那么当前的栈顶的元素就是需要的数，直接输出\n            cout << stk[tt] << \" \";\n        else\n            cout << -1 << \" \";\n          \n        stk[++ tt] = x;//把元素入栈\n    }\n  \n    return 0;\n}\n```\n\n### 单调队列（滑动窗口）\n\n#### 例题\n\n> 给定一个大小为 n≤10^6^ 的数组。\n>\n> 有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。\n>\n> 你只能在窗口中看到 k 个数字。\n>\n> 每次滑动窗口向右移动一个位置。\n>\n> 以下是一个例子：\n>\n> 该数组为 `[1 3 -1 -3 5 3 6 7]`，kk 为 33。\n>\n>\n> | 窗口位置            | 最小值 | 最大值 |\n> | :------------------ | :----- | :----- |\n> | [1 3 -1] -3 5 3 6 7 | -1     | 3      |\n> | 1 [3 -1 -3] 5 3 6 7 | -3     | 3      |\n> | 1 3 [-1 -3 5] 3 6 7 | -3     | 5      |\n> | 1 3 -1 [-3 5 3] 6 7 | -3     | 5      |\n> | 1 3 -1 -3 [5 3 6] 7 | 3      | 6      |\n> | 1 3 -1 -3 5 [3 6 7] | 3      | 7      |\n>\n> 你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。\n>\n> #### 输入格式\n>\n> 输入包含两行。\n>\n> 第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。\n>\n> 第二行有 n 个整数，代表数组的具体数值。\n>\n> 同行数据之间用空格隔开。\n>\n> #### 输出格式\n>\n> 输出包含两个。\n>\n> 第一行输出，从左至右，每个位置滑动窗口中的最小值。\n>\n> 第二行输出，从左至右，每个位置滑动窗口中的最大值。\n>\n> #### 输入样例：\n>\n> ```\n> 8 3\n> 1 3 -1 -3 5 3 6 7\n> ```\n>\n> #### 输出样例：\n>\n> ```\n> -1 -3 -3 -3 3 3\n> 3 3 5 5 6 7\n> ```\n\n#### 实现代码\n\n```c\n#include <iostream>\nusing namespace std;\n\nconst int N = 1e6+10;\n\n//原始数据，单调队列\nint a[N],q[N];\n\n\nint main()\n{\n    int n, k;\n    scanf(\"%d%d\", &n, &k);\n  \n    for(int i = 0; i < n; i ++)\n        scanf(\"%d\",&a[i]);\n  \n    int hh = 0, tt = -1;\n    for(int i = 0; i < n; i++)\n    {\n        //判断队头是否已经滑出窗口\n        //因为窗口只会后移一位，因此不需要循环\n        if(hh <= tt && i - k + 1 > q[hh])\n            hh ++;\n      \n        while(hh <= tt && a[q[tt]] >= a[i])\n            tt --;\n      \n        q[++ tt] = i;\n      \n        if(i >= k - 1)\n            printf(\"%d \", a[q[hh]]);\n          \n    }\n  \n    puts(\"\");\n  \n  \n    hh = 0, tt = -1;\n    for(int i = 0; i < n; i++)\n    {\n        //判断队头是否已经滑出窗口\n        //因为窗口只会后移一位，因此不需要循环\n        if(hh <= tt && i - k + 1 > q[hh])\n            hh ++;\n      \n        while(hh <= tt && a[q[tt]] <= a[i])\n            tt --;\n      \n        q[++ tt] = i;\n      \n        if(i >= k - 1)\n            printf(\"%d \", a[q[hh]]);\n          \n    }\n  \n    puts(\"\");\n  \n  \n    return 0;\n}\n```\n\n#### 他人题解1\n\n> 解题思路（以最大值为例）：\n>\n> 由于我们需要求出的是滑动窗口的最大值。\n>\n> 如果当前的滑动窗口中有两个下标 i 和 j ，其中i在j的左侧（i<j），并且i对应的元素不大于j对应的元素（nums[i]≤nums[j]），则：\n>\n> 当滑动窗口向右移动时，只要 i 还在窗口中，那么 j 一定也还在窗口中。这是由于 i 在 j 的左侧所保证的。\n>\n> 因此，由于 nums[j] 的存在，nums[i] 一定不会是滑动窗口中的最大值了，我们可以将nums[i]永久地移除。\n>\n> 因此我们可以使用一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组nums中对应的值是严格单调递减的。\n>\n> 当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。\n>\n> 为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果新元素大于等于队尾元素，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。\n>\n> 由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。\n>\n> 窗口向右移动的时候。因此我们还需要不断从队首弹出元素保证队列中的所有元素都是窗口中的，因此当队头元素在窗口的左边的时候，弹出队头。\n>\n> ```\n> #include <iostream>\n> #include <cstring>\n> #include <algorithm>\n> #include <deque>\n> using namespace std;\n>\n> const int N = 1000010;\n> int a[N];\n> int main()\n> {\n>  int n, k;\n>  cin >> n >> k;\n>  for (int i = 1; i <= n; i ++ ) cin >> a[i];//读入数据\n>  deque<int> q;\n>  for(int i = 1; i <= n; i++)\n>  {\n>      while(q.size() && q.back() > a[i]) //新进入窗口的值小于队尾元素，则队尾出队列\n>          q.pop_back();\n>      q.push_back(a[i]);//将新进入的元素入队\n>      if(i - k >= 1 && q.front() == a[i - k])//若队头是否滑出了窗口，队头出队 \n>          q.pop_front();\n>      if(i >= k)//当窗口形成，输出队头对应的值\n>          cout << q.front() <<\" \";\n>  }\n>  q.clear();\n>  cout << endl;\n>\n>  //最大值亦然\n>  for(int i = 1; i <= n; i++)\n>  {\n>      while(q.size() && q.back() < a[i]) q.pop_back();\n>      q.push_back(a[i]);\n>      if(i - k >= 1 && a[i - k] == q.front()) q.pop_front(); \n>      if(i >= k) cout << q.front() << \" \";\n>\n>  }\n> }\n>\n>\n> 作者：Hasity\n> 链接：https://www.acwing.com/solution/content/97229/\n> 来源：AcWing\n> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n> ```\n\n#### 他人题解2\n\n> 思路：\n>\n> 最小值和最大值分开来做，两个for循环完全类似，都做以下四步：\n>\n> 解决队首已经出窗口的问题;\n> 解决队尾与当前元素a[i]不满足单调性的问题;\n> 将当前元素下标加入队尾;\n> 如果满足条件则输出结果;\n> 需要注意的细节：\n>\n> 上面四个步骤中一定要先3后4，因为有可能输出的正是新加入的那个元素;\n> 队列中存的是原数组的下标，取值时要再套一层，a[q[]];\n> 算最大值前注意将hh和tt重置;\n> 此题用cout会超时，只能用printf;\n> hh从0开始，数组下标也要从0开始。\n>\n> ```c\n> # include <iostream>\n> using namespace std;\n> const int N = 1000010;\n> int a[N], q[N], hh, tt = -1;\n>\n> int main()\n> {\n>  int n, k;\n>  cin >> n >> k;\n>  for (int i = 0; i < n; ++ i)\n>  {\n>      scanf(\"%d\", &a[i]);\n>      if (i - k + 1 > q[hh]) ++ hh;                  // 若队首出窗口，hh加1\n>      while (hh <= tt && a[i] <= a[q[tt]]) -- tt;    // 若队尾不单调，tt减1\n>      q[++ tt] = i;                                  // 下标加到队尾\n>      if (i + 1 >= k) printf(\"%d \", a[q[hh]]);       // 输出结果\n>  }\n>  cout << endl;\n>  hh = 0; tt = -1;                                   // 重置！\n>  for (int i = 0; i < n; ++ i)\n>  {\n>      if (i - k + 1 > q[hh]) ++ hh;\n>      while (hh <= tt && a[i] >= a[q[tt]]) -- tt;\n>      q[++ tt] = i;\n>      if (i + 1 >= k) printf(\"%d \", a[q[hh]]);\n>  }\n>  return 0;\n> }\n>\n> ```\n\n## kmp\n\n## Trie\n\n## 并查集\n\n## 堆\n\n## Hash表\n\n[li,ri]:\n","tags":["protected","算法","基础算法","数据结构"],"categories":["算法","数据结构"]},{"title":"linux下通过CURL实现自动签到功能","url":"/2024/01/31/linux下通过CURL实现自动签到功能/","content":"\n本说明可以实现通过访问某一个链接就能实现签到网站。\n\n1. 获取链接\n   - 在点击签到之前打开开发者工具\n   - 点击链接\n   - 找到签到的网络活动\n     - ![image-20240131164756827](./Image/linux下通过CURL实现自动签到功能.assets/image-20240131164756827.png)\n2. 右击这个链接活动 -> 复制 -> 以cURL(bash)的格式复制\n   - ![image-20240131165048030](./Image/linux下通过CURL实现自动签到功能.assets/image-20240131165048030.png)\n3. 将复制的内容替换到模板中 `response=$(  )`的括号中。\n4. 找出页面中只有访问成功后一定出现字符串，如用户名、关键字等，将这个的值替换模板中 `SUCCESS_STRING=\"字符串\" ` 处的 `字符串`。注意，一定要确保设置的字符串是正确的，如果检测不到字符串，会在一定的时间后再次访问。\n5. 执行这个脚本，检查访问结果。\n\n\n\nshell脚本模板\n\n```shell\n#!/bin/bash\n\n#URL=\"http://www.51hei.com/bbs/\"  # 替换为你要访问的网站URL\nSUCCESS_STRING=\"字符串\"   # 替换为你要检测的成功字符串，识别到此字符串视为访问成功\n\n\n\nwhile true; do\n    #将复制的签到链接放置到括号里面。\n    response=$(  )  # 发送 GET 请求并将响应存储在变量中\n\n    if [[ $response == *\"$SUCCESS_STRING\"* ]]; then\n        echo \"访问成功！\"\n        echo \"\"\n        echo \"页面内容：\"\n        echo \"$response\"\n        break  # 如果成功，退出循环\n    else\n        echo \"访问未完成，等待10-20分钟后重试...\"\n        sleep $(( (RANDOM % 11) + 10 ))m  # 随机等待10-20分钟\n    fi\ndone\n```\n\n模板说明：\n\n- 当执行这shell脚本的时候，会一定的方式（如curl）命令来访问指定的链接。\n- 访问之后，检测返回的内容是否包含设定的关键字，如果检测到，则输出 `访问成功！` ，并在输出执行结果后退出。\n- 如果没有检测到指定的关键字，则输出 `访问未完成，等待10-20分钟后重试...` ，随机等待10-20分钟后（通过`sleep $(( (RANDOM % 11) + 10 ))m`实现），然后再次执行，知道检测到指定的关键字为止。","tags":["protected","Linux","curl","知识杂谈"],"categories":["知识杂谈"]},{"title":"玩客云部署java环境","url":"/2024/01/26/玩客云部署java环境/","content":"\n# jdk包\n\n- jdk-7u60-linux-arm-vfp-hflt.tar.gz\n- zulu8.74.0.17-ca-jdk8.0.392-linux_aarch32hf.tar.gz\n\n\n\n# 部署\n\n1. 将软件包上传到服务器上，然后移动到指定的位置。\n\n2. 解压\n\n   ```bash\n   # 假设您将JDK压缩包上传到了 /usr/local 并命名为 jdk-<version>-linux-x64.tar.gz\n   cd /usr/local\n   tar -zxvf jdk-<version>-linux-x64.tar.gz\n   # 解压后可以重命名目录以便管理，例如：\n   mv jdk-<version> java-oracle-jdk<version>\n   ```\n\n3. 配置环境变量\n\n   - 配置全局变量\n\n     - 编辑`/etc/profile`文件\n\n   - 配置当前用户的个人变量\n\n     - 特定用户的 家目录的`.bashrc` 或 `.bash_profile` 文件\n\n   - 增加如下配置：\n\n     ```bash\n     export JAVA_HOME=/usr/local/java-oracle-jdk<version> # 替换为实际路径，注意不要有尾斜杠\n     export PATH=$JAVA_HOME/bin:$PATH\n     export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n     ```\n\n4. 验证安装和切换：\n\n   - 执行 `java -version` 和 `javac -version` 来检查Java环境是否已经成功安装了java环境。\n\n","tags":["protected","玩客云","java"],"categories":["玩客云","Linux部署"]},{"title":"域名解析的类型","url":"/2024/01/26/域名解析的类型/","content":"\n\t在DNS（域名系统）中，当你添加DNS记录时，“类型”字段是指你想要创建的具体类型的资源记录（RR, Resource Record）。每种类型的记录都有其特定的目的和格式：\n\n1. **A记录** (Address)：将一个完全合格的域名（FQDN）映射到一个IPv4地址。例如，将`www.example.com`指向`192.0.2.1`。\n\n2. **AAAA记录**：类似于A记录，但用于映射域名到一个IPv6地址。\n\n3. **CAA记录** (Certificate Authority Authorization)： CAA记录允许域名所有者指定哪些证书颁发机构（CA）可以为其域名签发SSL/TLS证书。这有助于防止未经授权的CA错误或恶意地为您的域名发放证书。\n\n4. **CERT记录**： CERT记录用于存储X.509证书或者PKIX证书信息在DNS系统中。这种类型的记录较少使用，主要用于安全相关的应用，比如IPsec和TLS认证等。\n\n5. **CNAME记录** (Canonical Name)：别名记录，用于将一个域名指向另一个域名，实际解析会指向目标域名的A或AAAA记录。\n\n6. **DNSKEY记录**： DNSKEY记录是DNSSEC（DNS Security Extensions）的一部分，它包含了公钥数据，用于对区域传输和查询响应进行签名验证，以确保DNS数据的完整性和来源的真实性。\n\n7. **DS记录** (Delegation Signer)： DS记录也是DNSSEC的一部分，它存在于父域中，引用子域的DNSKEY记录，并提供一个散列值来验证子域的DNSSEC签名链。\n\n8. **LOC** (Location)： LOC记录 用于存储地理位置信息。它允许域名所有者将特定的地理坐标与一个域名关联起来。LOC记录包含了经纬度、海拔高度以及精度等信息，主要用于标识网络资源（如服务器或设备）在地球上的具体位置。这种类型的记录在一些特定的应用场景下有用，比如通过DNS查找设备的物理位置，但在日常网站访问和邮件服务等方面并不常见。LOC记录的内容遵循RFC1876的标准格式进行编码。\n\n9. **MX记录** (Mail Exchange)：指定处理该域电子邮件的邮件服务器及其优先级。例如，定义`example.com`的邮件服务器为`mail.example.com`。\n\n10. **NAPTR记录** (Naming Authority Pointer)： NAPTR记录用于支持更复杂的名称转换服务，常用于ENUM（电话号码映射到URI）和其他高级命名方案。\n\n11. **NS记录** (Name Server)：指定托管域名区域的DNS名称服务器。\n\n12. **PTR记录** (Pointer Record)： PTR记录主要应用于反向DNS解析，将IP地址转换回域名。通常在IPv4的IN-ADDR.ARPA域或IPv6的IP6.ARPA域内使用。\n\n13. **SMIMEA**：SMIMEA是DNS记录类型的一种，全称为S/MIME证书颁发者授权记录（S/MIME Authority Resource Record）。这种记录类型是在RFC8398中定义的，用于支持S/MIME（Secure/Multipurpose Internet Mail Extensions）邮件加密和签名服务。\n\n    在电子邮件安全领域，S/MIME是一种标准，用于加密、签名以及验证电子邮件的内容。SMIMEA记录允许域名所有者指定哪些证书颁发机构（CA）可以为其域内的电子邮件地址签发S/MIME证书，类似于CAA记录对TLS/SSL证书颁发机构的限制作用。\n\n    当邮件客户端或其他S/MIME处理软件需要验证来自某个域名的S/MIME证书时，它们可以通过查询该域名的SMIMEA记录来确定是否信任由特定CA颁发的证书。这有助于提高电子邮件通信的安全性并防止未经授权的CA为域名发放证书。\n\n14. **SRV记录** (Service Location Record)： SRV记录用来定义特定服务的位置（即哪个主机提供了该服务以及通过哪个端口），如XMPP聊天服务、SIP电话服务等。\n\n15. **SSHFP**：SSHFP（Secure Shell Fingerprint）是DNS记录类型的一种，它在RFC 4255中被定义。SSHFP记录用于存储SSH主机密钥的指纹信息，从而允许客户端验证远程SSH服务器的身份。\n\n    当SSH客户端连接到一个SSH服务器时，通常会通过SSHFP记录来验证服务器提供的公钥指纹是否与域名关联的DNS SSHFP记录相匹配。这样可以防止中间人攻击，并确保客户端连接的是预期且合法的SSH服务器。\n\n    SSHFP记录包含三个字段：资源记录类型（固定为SSHFP）、算法类型和指纹类型以及指纹值。其中，算法类型和指纹类型分别表示生成公钥所使用的加密算法和散列函数，而指纹值则是该公钥经过指定散列函数计算后得到的唯一标识符。\n\n16. **SVCB**：SVCB（Service Binding and Parameter Specification for DNS）是DNS记录类型的一种，它在RFC 8624中被定义。SVCB记录允许通过DNS提供服务相关的参数和协议绑定信息，以便客户端能够更高效、安全地连接到服务端点。\n\n    SVCB记录主要用于服务发现，它允许发布者指定服务使用的协议版本、端口号、ALPN标识符（Application-Layer Protocol Negotiation）和其他特定于服务的参数。例如，在HTTP/3或QUIC协议场景下，SVCB记录可以指示一个域名支持这些新协议，并提供相应的服务端点地址和配置信息。\n\n    这种记录类型对于实现网络服务的快速切换和优化具有重要意义，特别是在互联网基础设施演进的过程中，有助于推动新的传输层协议和技术的部署和使用。\n\n17. **TLSA**：TLSA (Transport Layer Security Authentication) 是DNS记录类型的一种，它在RFC 6698和RFC 7671中被定义。TLSA记录主要用于DNS-Based Authentication of Named Entities (DANE) 技术框架，以增强基于SSL/TLS协议的网络服务的安全性。\n\n    TLSA记录允许域名所有者通过DNS发布其服务（如HTTPS、SMTP等）所使用的TLS/SSL证书或公钥信息。当客户端连接到支持DANE验证的服务时，可以查询相应的TLSA记录来验证服务器提供的证书是否与DNS记录中的数据相匹配，从而减少对传统证书颁发机构（CA）的信任依赖，并防止中间人攻击。\n\n    一个典型的TLSA记录包含了以下四部分：\n\n    - 资源记录类型：固定为TLSA。\n    - 使用证书的位置：证书用途字段（Cert Usage），如端点身份验证（PKIX-TA）、信任锚证明（PKIX-EE）等。\n    - 匹配类型：指定如何从证书中提取要匹配的数据（完整证书、公共密钥、指纹等）。\n    - 匹配数据：证书的部分内容或指纹，用于与服务器提供的证书进行比对验证。\n\n18. **TXT记录**：文本记录，通常用于存储可读的文本信息，也可以用于验证域名所有权（如DKIM、SPF、DMARC记录）或其他服务的验证过程。\n\n19. **URI**：URI（Uniform Resource Identifier）统一资源标识符，并不是DNS记录类型，而是一种用于唯一标识互联网上资源的字符串格式标准。URI包括URL（Uniform Resource Locator）和URN（Uniform Resource Name）两种形式。\n\n    在DNS系统中，虽然没有直接称为“URI”的DNS记录类型，但通过结合其他DNS记录类型如CNAME或HTTPREDIRECT（某些DNS服务商提供的非标准扩展记录类型），可以间接实现将域名映射到特定URI的目的。\n\n    例如，当用户访问一个设置为CNAME或其他重定向类型的DNS记录指向的域名时，最终会被重定向到一个具体的URI地址。然而，在DNS层面上，它并不直接处理或存储URI信息，而是处理域名与IP地址或其他域名之间的映射关系。\n\n20. **SOA记录** (Start of Authority)： SOA记录标志着一个DNS区域的开始，包含了区域的基本管理信息，例如主名字服务器、电子邮件联系人、序列号、刷新时间等参数。\n\n21. **LOC记录** (Location Record)： LOC记录用于存储地理位置坐标信息，比如经纬度、海拔高度等，这样可以通过DNS查找设备或资源的实际位置。\n\n22. **SPF记录** (Sender Policy Framework)： SPF记录虽然现在推荐使用TXT记录进行配置，但本质上是用于指定发送邮件的合法IP地址范围，防止伪造邮件源地址。\n\n23. **HINFO记录** (Host Information): HINFO记录包含主机的CPU类型和操作系统信息，这个记录类型已不再广泛使用，因为它可能暴露了不必要的安全性信息。","tags":["protected","知识杂谈","域名解析"],"categories":["知识杂谈","域名","技术文档"]},{"title":"One-KVM使用指南","url":"/2024/01/14/项目说明_One-KVM使用指南/","content":"\n\n# One-KVM使用指南\n\n## 介绍\n\nOne-KVM是基于玩客云硬件和PiKVM软件的远控设备。通过移植PiKVM该软件至玩客云设备上，实现了极高的性价比，不到百元功能即可接近甚至超越部分昂贵的商业设备。\n\n该设备在于帮助用户通过得到控制设备的HDMI 画面和鼠标键盘，去远程管理服务器、工作站或个人PC等。 和基于软件的远程管理方式不同，你无需在被控电脑安装任何软件，做到无侵入式控制。\n\n当前您使用的PiKVM内部版本号为0.4，有中文界面，支持网页与VNC同时远控、BIOS级控制、USB键鼠模拟、远程挂载镜像（MSD）、网络远程唤醒（WOL）、网页终端，文本粘贴和中英文识别（OCR）等特性。\n\n| 功能               | One-KVM   | TinyPilot 社区版本 | PiKVMv3版本  |\n| ------------------ | --------- | ------------------ | ------------ |\n| HTML5界面          | 简体中文  | 英文               | 英文         |\n| BIOS级访问         | √         | √                  | √            |\n| 视频捕捉           | √         | √                  | √            |\n| 音频捕捉           | ×         | √                  | √            |\n| 鼠键捕获           | √         | √                  | √            |\n| 从剪贴板粘贴       | √         | √                  | √            |\n| OCR识别            | √         | ×                  | √            |\n| 基于密码的身份验证 | √         | 需升级Pro          | √            |\n| LAN唤醒            | √         | 需升级Pro          | √            |\n| 从WebUI更新        | ×         | √                  | ×            |\n| VNC支持            | √         | ×                  | √            |\n| 挂载虚拟驱动器     | √         | 需升级Pro          | √            |\n| ATX开关机          | √         | ×                  | √            |\n| WiFi               | ×         | √                  | √            |\n| 串行接口           | ×         | ×                  | √            |\n| 视频流格式         | MJPEG     | MJPEG, H.264       | MJPEG, H.264 |\n| 视频分辨率         | 1920x1080 | 1920x1080          | 1920x1080    |\n\n## 开始使用\n\n将HDMI转USB采集卡插入玩客云主机网口旁USB口，HDMI视频线插入采集卡HDMI端，USB双公线插入玩客云主机HDMI口旁USB口，插入网线，接入电源。\n\n被控机端，讲HDMI视频线和USB双公线接入对应接口即可。\n\n![img](./Image/One-KVM使用指南.assets/1705214133235-7-1760113321481-1.jpeg)\n\n提醒：玩客云USB设备插反会导致PiKVM所有远控功能无法使用。\n\n帮助：部分低功耗设备在未接通电源时可能通过USB双公线从玩客云取电并启动至异常状态，再接通电源也无法启动。要解决此问题，您可以 剥开USB双公线剪断红色5V细电线。\n\n玩客云主机前面板灯在系统极低负载时为红色，在系统启动和使用PiKVM时（有负载时）会不同颜色交替闪烁，这是正常的。\n\n玩客云主机默认上网方式为DCHP，启动后在浏览器访问网络新增IP即可。由于软件自签SSL证书不被信任，请无视风险继续访问。\n\n![img](./Image/One-KVM使用指南.assets/1705214133195-1-1760113321481-2.png)\n\n![img](./Image/One-KVM使用指南.assets/1705214133199-2-1760113321481-3.png)\n\n![img](./Image/One-KVM使用指南.assets/1705214133200-3-1760113321481-4.png)\n\n![img](./Image/One-KVM使用指南.assets/1705214133200-4-1760113321481-5.png)\n\n提示： 默认WEB和VNC账号密码都为admin且同步，root用户密码为1234，所有端口皆为服务默认端口。\n\n帮助：排障指南　　\n\n网页视频黑屏提示无No Singal，请检查硬件是否正确连接或松动；\n\n网页端黑屏无任何画面或彩色竖条，请检查是否有被控机HDMI信号输入；\n\n进系统画面显示正常，bios界面黑屏或渲染异常，请在BIOS界面开启CMS兼容模式；\n\n画面显示片刻黑屏，刷新网页重复此现象，请使用火狐浏览器或修改kvmd主配置文件使用yuyv格式。\n\n如果以上情况都不符合请尝试重启玩客云自动复位。\n\n如果要使用ATX控制物理开关机功能请连接好开机线（目前成品深色引出线接9pin中的开机负极，浅色引出线接开机针脚正极，如黑白、褐红，橙黄对应负极和正极），延长线不分颜色直接使用。\n\n![img](./Image/One-KVM使用指南.assets/1705214133201-5-1760113321481-6.png)\n\n![img](file:///C:/Users/hurri/Nutstore/1/%E6%96%87%E6%A1%A3/%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E/One_KVM/One-KVM%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.assets/1705214133201-6.jpeg?lastModify=1760111042)\n\n## 其他\n\n文档目录（可在此查阅其他文档）：https://p1b237lu9xm.feishu.cn/drive/folder/IsOifWmMKlzYpRdWfcocI7jdnQA\n\nGithub地址：https://github.com/mofeng-git/One-KVM （欢迎点个Star）\n\nQQ交流群：569514148 （One-KVM交流群）","tags":["protected","玩客云","KVM"],"categories":["玩客云"]},{"title":"One-KVM实现物理开关机控制功能","url":"/2024/01/14/项目说明_One-KVM实现物理开关机控制功能/","content":"\n## One-KVM实现物理开关机控制功能\n\n### 介绍\n\n这个教程是比较粗糙的版本，在新旧版玩客云上测试通过，操作无差别，适合DIY玩家参考。通过使用玩客云红外接口预留的GPIO接口连接主板9PIN中的开机针脚实现物理控制开机、关机和强制关机的功能。\n\n### 教程\n\n物理控制开关机只需要一个GPIO接口（两者都是3.3V），不能占用宝贵的WiFi模块引脚，led用处也不小，最后选择测试红外控制引脚（应该没人会同时使用PiKVM和红外遥控功能吧）。\n\n**硬件改动：**\n\n整个操作并不复杂，首先需要在玩客云主板的红外模块预留接口焊上两根引线（接在图中GPIO-420和GND位置），然后接驳开机线（GPIO接开机引脚正极，GND接开机引脚负极）。\n\n![img](./Image/One-KVM实现物理开关机控制功能.assets/1705214964294-6.jpeg)\n\n![img](./Image/One-KVM实现物理开关机控制功能.assets/1705214964292-1.jpeg)\n\n![img](./Image/One-KVM实现物理开关机控制功能.assets/1705214964293-2.jpeg)\n\n![img](./Image/One-KVM实现物理开关机控制功能.assets/1705214964293-3.png)\n\n### 软件改动\n\n**对于One-KVM V0.4用户**\n\n一键脚本已经配置好了，硬件连接好之后即可使用此功能。\n\n**对于One-KVM V0.3用户**\n\n请下载https://github.com/mofeng-git/One-KVM patch目录下的short_press_gpio420和long_press_gpio420两个shell脚本文件，然后上传至玩客云/usr/bin目录下。\n\n```Bash\n#给kvmd程序执行这两个脚本的权限\necho kvmd ALL=\\(ALL\\) NOPASSWD: /usr/bin/long_press_gpio420,/usr/bin/short_press_gpio420 >>  /etc/sudoers\n```\n\n然后编辑 /etc/kvmd/override.yaml 文件添加如下内容（注意缩进和格式，否则会报错）。\n\n```YAML\n    gpio:\n        drivers:\n            short_press:\n                type: cmd\n                cmd: [/usr/bin/sudo, short_press_gpio420]\n            long_press:\n                type: cmd\n                cmd: [/usr/bin/sudo, long_press_gpio420]\n        scheme:\n            short_button:\n                driver: short_press\n                pin: 0\n                mode: output\n                switch: false\n            long_button:\n                driver: long_press\n                pin: 0\n                mode: output\n                switch: false\n        view:\n            header:\n                title: ATX\n            table:                \n                - [\"#电源管理\"]\n                - []\n                - [\"#短按（开/关机）:\", short_button|按下]\n                - [\"#长按（强制关机）:\", long_button|按下]\n```\n\n![img](./Image/One-KVM实现物理开关机控制功能.assets/1705214964293-4.png)\n\n```Bash\n#最后重启kvmd服务就可以看到修改生效了。\nsystemctl restart kvmd \n```\n\n![img](./Image/One-KVM实现物理开关机控制功能.assets/1705214964294-5.png)\n\n> 提示：对于DIY玩家，您也可以使用尝试PiKVM自带的GPIO驱动方式进行控制（作者采用的调用bash脚本），作者使用的引脚对于系统位置是gpio-420，对于PiKVM位置是gpiochip1 pin7，PiKVM源代码默认为gpiochip0需要手动修改。","tags":["protected","玩客云","KVM"],"categories":["玩客云"]},{"title":"One-KVM启用MSD、WOL功能","url":"/2024/01/14/项目说明_One-KVM启用MSD、WOL功能/","content":"\n# One-KVM启用MSD、WOL功能\n\n## **启用MSD**\n\nMSD（Mass Storage Drive），即大容量储存设备，可以实现远程上传文件，挂载镜像等功能。\n\n### **分区**\n\n#### 使用玩客云EMMC空间\n\n作者在安装篇的网盘的链接中提供了包含此软件的系统镜像，刷入U盘后将U盘插到玩客云网口旁的USB口插电启动，连接ssh（root/1234）输入gparted即可启动磁盘分区软件。\n\n如果没有打开软件界面请检查你的ssh终端是否支持X11转发功能。\n\n在打开的Gparted界面右键 /dev/mmcblp1p2 选择 Resize/Move 来调整分区，在Free space following框中输入新建分区的大小（可输入4096），再将分出来的空闲空间格式化为ext4格式，最后点击主界面选项卡下的绿底√应用应用刚才的选择即可。\n\n![img](./Image/One-KVM启用MSD、WOL功能.assets/1705214727614-3.png)\n\n![img](./Image/One-KVM启用MSD、WOL功能.assets/1705214727594-1.png)\n\n**应用补丁**\n\n```Bash\n#拔掉U盘重启进入EMMC系统添加分区\nnano /etc/fstab\n#在文件末尾添加如下挂载\n/dev/mmcblk1p3 /var/lib/kvmd/msd  ext4  nodev,nosuid,noexec,ro,errors=remount-ro,data=journal,X-kvmd.otgmsd-root=/var/lib/kvmd/msd,X-kvmd.otgmsd-user=kvmd  0 0\n#如果使用的0.3版本（非一键脚本安装），请执行命令应用补丁 cd ~/fruity-pikvm && sudo ./msd-patch.sh\nmount /dev/mmcblk1p3\n\n#开启MSD功能，到/etc/kvmd/override.yaml修改msd选项为otg\nnano /etc/kvmd/override.yaml\nsystemctl restart kvmd-otg kvmd\n```\n\n#### 使用TF卡（SD卡）\n\n建议不要使用杂牌储存卡（部分杂牌储存卡反应为Windows正常、Linux能识别但无法访问和读写）。\n\n```Bash\n#查看TF卡位置\nfdisk -l\n#将其格式化为ext4文件格式（将sdx替换为你的设备地址）\nmkfs.ext4 /dev/sdx\n\nnano /etc/fstab\n#在文件末尾添加如下挂载（将sdx替换为你的设备地址）\n/dev/sdx  /var/lib/kvmd/msd  ext4  nodev,nosuid,noexec,ro,errors=remount-ro,data=journal,X-kvmd.otgmsd-root=/var/lib/kvmd/msd,X-kvmd.otgmsd-user=kvmd  0 0\n\n#如果使用的0.3版本（非一键脚本安装），请执行命令应用补丁 cd ~/fruity-pikvm && sudo ./msd-patch.sh\n#挂载分区（将sdx替换为你的设备地址），如失败报错请检查设备地址和挂载内容是否出错\nmount /dev/sdx\n\n#开启MSD功能，到/etc/kvmd/override.yaml修改msd选项为otg\nnano /etc/kvmd/override.yaml\nsystemctl restart kvmd-otg kvmd\n```\n\n## **启用WOL**\n\nWOL（Wake On LAN），即网络唤醒，在被控机支持的情况下（部分机器可能默认关闭，开启教程可参考[网络唤醒WOL（Wake On LAN） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/183704557)），可以通过网络唤醒设备开机，实现机器开停自由。更详细的介绍和配置可查阅官方教程。\n\n首先在获取被控机网卡的MAC地址记录下来（格式为linux小写），然后编辑 /etc/kvmd/override.yaml 添加如下内容，完成后重启服务 systemctl restart kvmd （请注意格式缩进，否则会导致服务启动失败）。\n\n```Bash\n    gpio:\n        drivers:\n            wol_server1:\n                type: wol\n                mac: 2c:56:dc:db:7c:1e\n        scheme:\n            wol_server1:\n                driver: wol_server1\n                pin: 0\n                mode: output\n                switch: false\n        view:\n            table:\n                - [\"#设备名称\", \"wol_server1|网络唤醒\"]\n```\n\n![img](./Image/One-KVM启用MSD、WOL功能.assets/1705214727595-2.png)","tags":["protected","玩客云","KVM"],"categories":["玩客云"]},{"title":"One-KVM安装完整教程","url":"/2024/01/14/项目说明_One-KVM安装完整教程/","content":"\n\n# One-KVM安装完整教程\n\n![img](./Image/One-KVM安装完整教程.assets/1705214374751-5.png)\n\n## 介绍\n\nOne-KVM是基于玩客云硬件和PiKVM软件的远控设备。KVM over IP可以远程管理服务器或工作站，无论操作系统或是否安装了操作系统。 相较于购买向日葵控控（￥7？？）或树莓派开发板，50多的矿渣玩客云 + HDMI转USB采集卡的组合（不包含其他工具）运行PiKVM同样可以实现很好的效果。\n\n| 功能               | One-KVM   | TinyPilot 社区版本 | PiKVMv3版本  |\n| ------------------ | --------- | ------------------ | ------------ |\n| HTML5界面          | 简体中文  | 英文               | 英文         |\n| BIOS级访问         | √         | √                  | √            |\n| 视频捕捉           | √         | √                  | √            |\n| 音频捕捉           | ×         | √                  | √            |\n| 鼠键捕获           | √         | √                  | √            |\n| 从剪贴板粘贴       | √         | √                  | √            |\n| OCR识别            | √         | ×                  | √            |\n| 基于密码的身份验证 | √         | 需升级Pro          | √            |\n| LAN唤醒            | √         | 需升级Pro          | √            |\n| 从WebUI更新        | ×         | √                  | ×            |\n| VNC支持            | √         | ×                  | √            |\n| 挂载虚拟驱动器     | √         | 需升级Pro          | √            |\n| ATX开关机          | √         | ×                  | √            |\n| WiFi               | ×         | √                  | √            |\n| 串行接口           | ×         | ×                  | √            |\n| 视频流格式         | MJPEG     | MJPEG, H.264       | MJPEG, H.264 |\n| 视频分辨率         | 1920x1080 | 1920x1080          | 1920x1080    |\n\n## 运行效果\n\n![img](./Image/One-KVM安装完整教程.assets/1705214374752-6.png)\n\n![img](./Image/One-KVM安装完整教程.assets/1705214374753-7.png)\n\n## 开始安装\n\n### 准备工具\n\n必备硬件：玩客云（含电源和USB刷机线），HDMI转USB采集卡（推荐MS2109型号），网线和HDMI线\n\n可选硬件：TF卡（扩展储存） TTL转USB适配器（调试工具）\n\n镜像工具文件链接：https://pan.baidu.com/s/166-2Y8PBF4SbHXFkGmFJYg?pwd=o9aj\n\n| **采集卡硬件****兼容性****列表** |             |               |               |              |\n| :------------------------------- | :---------- | ------------- | ------------- | ------------ |\n| **型号/方案**                    | **USB接口** | **Linux支持** | **PiKVM支持** | **使用情况** |\n| MS2109                           | USB2.0      | √             | √             | 推荐         |\n| MS2130                           | USB3.0      | √             | √             | 配置过剩     |\n| MS2131                           | USB3.0      | √             | √             | 配置过剩     |\n| 腾飞 TFDGK05                     | USB2.0      | √             | ×             | /            |\n| 迈拓矩阵 MT-UH02                 | USB2.0      | ×             | ×             | /            |\n\n### 仓库介绍\n\n先简单介绍一下One-KVM项目，目前有三个仓库：\n\n**One-KVM**：提供一键PiKVM安装脚本，目前只支持Armbian_22.11.0-trunk_Onecloud_jammy_legacy_5.10.149系统，后续会加入Build-Armbian分支基础镜像的完全支持；\n\n**One-KVM-docker**：提供PiKVM docker镜像，目前只有pikvm-ch9329_amd64容器，后续会加入常见架构容器支持；\n\n**Build-Armbian**：提供适用与PiKVM的基础系统镜像和One-KVM成品固件镜像，目前已经开始第一版镜像已完成，One-KVM_Armbian_20.12_Aml-s812_jammy_current_5.9.0-rc7_minimal_240110以开始内测，后续将完善细节。\n\n对应的，PiKVM有三种安装方式：脚本安装，直刷One-KVM镜像，docker镜像部署。\n\n### 方式一：**脚本安装**\n\n使用 https://github.com/hzyitc/armbian-onecloud/releases/download/ci-20221026-074131-UTC/Armbian_22.11.0-trunk_Onecloud_jammy_legacy_5.10.149.burn.img.xz 线刷镜像刷入玩客云EMMC，SSH登录配置好密码。\n\n玩客云刷机教程请自行百度，这里不再赘述。\n\n注意：作者只测试过此镜像可正常运行PiKVM，其他版本的镜像可能存在运行问题（不限于不包含UVC驱动，无所需Python版本，OTG拔插死机），不确定是否适用于此教程，如有问题请自行解决。\n\n提示：Amlogic USB Burning Tool建议使用 v2.1.3及以下版本，不要使用高版本软件（下图是反面教材）。\n\n刷机短接时不需要一直短接，在烧录软件识别到并加载到1%可以松手耐心等待刷机成功了。\n\n![img](./Image/One-KVM安装完整教程.assets/1705214374753-8.png)\n\n进入Armbian系统处理好设置密码等基础操作后就可以使用使用一键安装脚本安装PiKVM了。\n\n```Bash\ngit clone https://github.com/mofeng-git/One-KVM.git\ncd One-KVM  && bash ./install.sh\n\n#对于国内网络环境，可以尝试以下命令\nwget https://mirror.ghproxy.com/https://github.com/mofeng-git/One-KVM/archive/refs/heads/main.zip -o One-KVM-main.zip\nunzip One-KVM-main.zip\ncd One-KVM-main  && bash ./install.sh\n```\n\n![img](./Image/One-KVM安装完整教程.assets/1705214374754-9.png)\n\n### 方式二：直刷One-KVM镜像\n\n带burn后缀的为线刷镜像，可使用USB_Burning_Tool线刷至玩客云。不带burn后缀的为U盘/SD卡启动镜像，直接写入U盘/SD卡即可。镜像为开箱即用，刷好后启动设备就可以开始用One-KVM了。\n\n### 方式三：docker镜像部署\n\n目前支持仅有pikvm-ch9329_amd64，后续将支持更多控制方式和处理器架构。使用示例：\n\n```Bash\ndocker run -itd -p443:443 -p80:80 --name pikvm-docker --device=/dev/ttyUSB0:/dev/kvmd-hid --device=/dev/video0:/dev/kvmd-video pikvm-ch9329:0.61\n```\n\n## **开始使用**\n\n按图连接好设备（网口旁接USB采集卡，HDMI旁边的为OTG口接USB双公线，可以直接用刷机线），访问玩客云IP，默认账号密码 admin/admin，即可开始使用！\n\n至于如何MSD功能、VNC远控和ATX开关机控制请查看作者其他文章。\n\n![img](./Image/One-KVM安装完整教程.assets/1705214374754-10.jpeg)\n\n## **其他**\n\n**感谢名单：**\n\n[H_xiaoming](https://space.bilibili.com/19944325)测试适配OTG正常可用镜像、*[0蓝蓝0](https://space.bilibili.com/581894674)*提供开机卡线刷检测解决办法、[fairybl](https://space.bilibili.com/15440110)关于MSD和线刷检测的其他解决方案、[浩龙的电子嵌入式之路](https://space.bilibili.com/385107574)的充电，以及其他开源项目、各位大佬和网友的讨论交流。\n\n**更新日志：**\n\n当前One-KVM版本号：V0.5\n\nGithub地址：https://github.com/mofeng-git/One-KVM （欢迎点个Star）\n\nV0.5：通过锁定CPU频率修复ustreamer mjpeg视频流异常的问题；屏蔽主程序找不到温度传感器的报错；优化中文翻译；优化安装流程\n\nV0.4：实现了ATX开关机物理控制功能；初步建立了使用文档；优化了安装流程。\n\nV0.3：制作了简体中文补丁；实现了MSD功能在EMMC和TF卡上的使用；实现了WOL和中文OCR功能；优化了安装流程。\n\nV0.2：解决了OTG拔插死机问题；初步实现了MSD功能；解决了开机卡线刷检测；优化了安装流程。\n\nV0.1：PiKVM在玩客云上初步运行。\n\n**参考项目**\n\n1. [GitHub - pikvm/pikvm: Open and inexpensive DIY IP-KVM based on Raspberry Pi](https://github.com/pikvm/pikvm)\n2. [GitHub - hzyitc/armbian-onecloud: Armbian for onecloud. 玩客云用armbian](https://github.com/hzyitc/armbian-onecloud/)\n3. [GitHub - jacobbar/fruity-pikvm: Install Pi-KVM on debian SBCs such as Orange Pi, Banana Pi, Mango Pi debian SBCs such as Orange Pi, Banana Pi, Mango Pi, etc (github.com)](https://github.com/jacobbar/fruity-pikvm)\n","tags":["protected","玩客云","KVM"],"categories":["玩客云"]},{"title":"One-KVM Docker应用扩展","url":"/2024/01/14/项目说明_One-KVM Docker应用扩展/","content":"\n\n# One-KVM Docker应用扩展\n\n**总览：**\n\n安装OpenWRT（Docker版）\n\n安装Casaos\n\n## 安装Docker\n\n玩客云内部储存空间为8G，如果要使用Docker应用请注意储存空间使用情况。\n\n本文所写Docker应用无需额外设置都可以与PiKVM共存，不必为此修改PiKVM配置文件。\n\n```Bash\n#解决docker无法启动报错的问题，系统使用默认nftables代替了iptables，下面两行将iptables命令替换为原始版本的iptables\nsudo update-alternatives --set iptables /usr/sbin/iptables-legacy\nsudo update-alternatives --set ip6tables /usr/sbin/ip6tables-legacy\n\n#安装Docker\napt install docker.io\n```\n\n## 安装docker-compose\n\n```Shell\n#!/bin/bash\n\n# 定义安装函数\ninstall_docker_compose() {\n    # 获取系统类型和架构\n    OS_NAME=$(uname -s | tr '[:upper:]' '[:lower:]')\n    OS_ARCH=$(uname -m)\n\n    # 特定架构的处理\n    if [ \"$OS_ARCH\" == \"x86_64\" ]; then\n        OS_ARCH=\"amd64\"\n    elif [ \"$OS_ARCH\" == \"armv7l\" ]; then\n        OS_ARCH=\"armv7\"\n    elif [ \"$OS_ARCH\" == \"aarch64\" ]; then\n        OS_ARCH=\"arm64\"\n    else\n        echo \"不支持的架构: $OS_ARCH\"\n        exit 1\n    fi\n\n    # 构建下载 URL\n    DOWNLOAD_URL=\"https://mirror.ghproxy.com/https://github.com/docker/compose/releases/download/$(curl -s https://api.github.com/repos/docker/compose/releases/latest | jq '.tag_name' | tr -d '\"')/docker-compose-${OS_NAME}-${OS_ARCH}\"\n\n    # 下载并安装 Docker Compose\n    echo \"正在下载 Docker Compose...\"\n    sudo curl -L ${DOWNLOAD_URL} -o /usr/local/bin/docker-compose\n    \n    # 添加执行权限\n    sudo chmod +x /usr/local/bin/docker-compose\n\n    # 测试安装\n    echo \"Docker Compose 安装完成。版本信息：\"\n    docker-compose version\n}\n\n# 定义卸载函数\nuninstall_docker_compose() {\n    # 卸载 Docker Compose\n    echo \"正在卸载 Docker Compose...\"\n    sudo rm -f /usr/local/bin/docker-compose\n    echo \"Docker Compose 已卸载。\"\n}\n\n# 主逻辑\ncase \"$1\" in\n    install)\n        install_docker_compose\n        ;;\n    uninstall)\n        uninstall_docker_compose\n        ;;\n    *)\n        echo \"使用方法: $0 {install|uninstall}\"\n        ;;\nesac\n```\n\n添加执行权限：chmod +x docker_compose_manager.sh\n\n./docker_compose_manager.sh install\n\n./docker_compose_manager.sh uninstall\n\n## 玩客云安装OpenWRT（Docker版）\n\n系统环境：Armbian 22.11.0-trunk Jammy Linux onecloud 5.10.149-meson\n\nDocker版本：Docker version 24.0.5, build 24.0.5-0ubuntu1~22.04.1\n\nOpenWRT默认账号和密码：root/root\n\n### 效果演示\n\n![img](./Image/One-KVM Docker应用扩展.assets/1705214673188-6.png)\n\n![img](./Image/One-KVM Docker应用扩展.assets/1705214673170-1.png)\n\n### 安装命令\n\n```Bash\n#打开网卡混杂模式\nip link set eth0 promisc on\n\n#subnet为玩客云所在网段，gateway为主路由地址\ndocker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 -o parent=eth0 macnet\n\n#Docker换源\nnano /etc/docker/daemon.json\n{\n\"registry-mirrors\":[\n\"https://hub-mirror.c.163.com/\",\n\"https://docker.mirrors.ustc.edu.cn/\"\n]\n}\n\n#拉取OpenWRT的Docker镜像\ndocker pull dreamwsbg/openwrt:9.0\ndocker run -d --name=\"openwrt\" --restart unless-stopped --network macnet --privileged dreamwsbg/openwrt:9.0 /sbin/init\n\n#进入容器内部\ndocker exec -it openwrt bash\n\n#修改添加OpenWRT网络设置（括号记得删掉）\nnano /etc/config/network\noption ipaddr '192.168.1.5' （oenpwrt地址）\noption gateway '192.168.1.1' (网关)\noption broadcast '192.168.1.255'\noption dns '192.168.1.1' (dns)\n#使网络修改生效\n /etc/init.d/network restart \n```\n\n![img](./Image/One-KVM Docker应用扩展.assets/1705214673170-2.png)\n\n### 解决一些问题\n\nOpenWRT ttyd设置接口\"未指定\"即可使用网页终端\n\n![img](./Image/One-KVM Docker应用扩展.assets/1705214673170-3.png)\n\n## 安装Casaos\n\n### 效果演示\n\n![img](./Image/One-KVM Docker应用扩展.assets/1705214673171-4.png)\n\n![img](./Image/One-KVM Docker应用扩展.assets/1705214673171-5.png)\n\n### 安装命令\n\nCasaOS官网：[CasaOS - A simple, easy-to-use, elegant open-source personal cloud system](https://casaos.io/)\n\n建议先按照此文章开始部分提前安装好Docker，因为脚本自带的Docker安装程序没有修改iptables会导致Docker安装失败。\n\n```Bash\ncurl -fsSL https://get.casaos.io | sudo bash\n```\n\n## 参考资料\n\n[【2023.10.13】玩客云docker下刷openwrt-迅雷玩客云、京东云等各种云设备-恩山无线论坛](https://www.right.com.cn/forum/thread-8268325-1-1.html)\n\n[玩客云刷Armbian，安装docker+CasaOS+OpenWrt](https://zhuanlan.zhihu.com/p/603845854)","tags":["protected","玩客云","KVM"],"categories":["玩客云"]},{"title":"One-KVM FAQ和故障排除","url":"/2024/01/14/项目说明_One-KVM FAQ和故障排除/","content":"\n# One-KVM FAQ和故障排除\n\n## 说明\n\n如果你遇到任何问题，你可以检查这个页面，它会列出常见的错误。如果这仍然没有帮助你，欢迎你提出问题或加入我们的交流群寻求进一步的帮助。\n\nGithub地址：https://github.com/mofeng-git/One-KVM （欢迎点个Star）\n\nQQ交流群：569514148 （One-KVM交流群）\n\n## 常见问题\n\n### 玩客云上的PiKVM支持哪些功能？不支持哪些功能？\n\n| 功能               | One-KVM   | TinyPilot 社区版本 | PiKVMv3版本  |\n| ------------------ | --------- | ------------------ | ------------ |\n| HTML5界面          | 简体中文  | 英文               | 英文         |\n| BIOS级访问         | √         | √                  | √            |\n| 视频捕捉           | √         | √                  | √            |\n| 音频捕捉           | ×         | √                  | √            |\n| 鼠键捕获           | √         | √                  | √            |\n| 从剪贴板粘贴       | √         | √                  | √            |\n| OCR识别            | √         | ×                  | √            |\n| 基于密码的身份验证 | √         | 需升级Pro          | √            |\n| LAN唤醒            | √         | 需升级Pro          | √            |\n| 从WebUI更新        | ×         | √                  | ×            |\n| VNC支持            | √         | ×                  | √            |\n| 挂载虚拟驱动器     | √         | 需升级Pro          | √            |\n| ATX开关机          | √         | ×                  | √            |\n| WiFi               | ×         | √                  | √            |\n| 串行接口           | ×         | ×                  | √            |\n| 视频流格式         | MJPEG     | MJPEG, H.264       | MJPEG, H.264 |\n| 视频分辨率         | 1920x1080 | 1920x1080          | 1920x1080    |\n\n### **PiKVM官方的功能说明文档在哪？**\n\n 如果您需要对功能进行高级配置，非常建议查阅官方文档，官方项目文档的的FAQ和功能配置讲解非常详细，包含示例易于上手。官方文档（英文）：[PiKVM Handbook](https://docs.pikvm.org/)。\n\n### **能进去网页但网页黑屏如何解决？**\n\n    网页视频黑屏提示无No Singal，请检查采集卡硬件是否受支持、是否正确连接、是否松动；\n    \n    网页端黑屏无任何画面或是彩色竖条，请检查是否有被控机HDMI信号输入；\n    \n    进系统画面显示正常，BIOS界面黑屏或渲染异常，请在BIOS界面开启CMS兼容模式；\n    \n    网页画面显示片刻黑屏，刷新网页重复此现象，请使用火狐浏览器或修改kvmd主配置文件使用yuyv格式。\n    \n    如果以上情况都不符合请尝试重启玩客云自动复位。\n\n### **为什么网页视频感觉非常卡顿？**\n\n    视频流输出配置中采用了yuyv格式。mjpeg格式可以实现1080p30帧或720p60帧，但占用带宽非常大（峰值50mbps左右），yuyv格式更加稳定但帧率较低（1080p5fps或720p10fps、峰值10mbps左右）。在浏览器中使用mjpeg视频流非常容易黑屏，仅火狐浏览器使用mjpeg格式的视频流不会出现黑屏现象。\n    \n    **提示使用体验的方法**：使用mjpeg格式，选择火狐浏览器，使用720p60帧或1080p30帧，右上角sysytem调整至最大帧率。针对1080p屏幕1080p画质远控请全屏使用，720p请点击网页视频右上角的“•”自动缩放画面与原画面分辨率相同。演示图为3终端720p60fps演示效果：\n\n![img](./Image/One-KVM FAQ和故障排除.assets/1705214473639-4.png)\n\n### **如何在****公网****中访问局域网的One-KVM？**\n\n    如果您的路由器有公网IP地址，您可以直接使用端口映射转发443端口。在其他情况下，您可以使用内网穿透服务（如Tailscale），只需几个简单的命令即可在One-KVM上配置。\n\n### 如何修改软件端口和账户密码？\n\n    修改端口请编辑 /etc/kvmd/nginx/目录下的conf后缀文件将相关端口修改所需端口（443是网页运行的端口），然后运行systemctl restart kvmd kvmd-nginx 生效。\n    \n    修改账号密码示例：\n\n   ```Bash\n#添加用户 请将silentwind替换为你的用户名\nkvmd-htpasswd set silentwind\n#输入密码\n#删除用户\nkvmd-htpasswd del admin\n#列出所有用户\nkvmd-htpasswd list\n#重启服务，使修改立刻生效\nsystemctl restart kvmd kvmd-nginx\n   ```\n\n### **如何给One-KVM设置静态IP？**\n\n    使用终端图形化工具armbain-config。\n    \n    示例：armbain-config  Network-->IP-->eth0-->Static\n\n![img](./Image/One-KVM FAQ和故障排除.assets/1705214473631-1.png)\n\n### **我可以使用One-KVM进行游戏或是刷剧吗？**\n\n    不能，因HDMI-USB采集卡的视频帧率（最高1080p30fps）无法满足游戏要求，且没有音频。\n\n### **One-KVM可以传输4K视频吗？**\n\n    对于USB采集设备将原视频画面采样到更小的分辨率以满足USB 2.0带宽限制，因此源可能是4k，但网友视频流不会。4K的实时视频无论如何都不适合通过网络。\n\n### **光标/视频延迟来自哪里？**\n\n    这是将图像传输到浏览器或VNC客户端的过程：采集设备->压缩->网络->解压->渲染，延迟大概100-200ms。\n\n### **我可以在移动设备上使用One-KVM上吗？**\n\n    是的，但WEB界面可能无法正常操控，所以在移动设备上推荐使用VNC应用程序，请注意不要使用不兼容的RealVNC。\n\n### **如何添加自己的SSL证书？**\n\n    如果您有证书（制作证书超出了PiKVM的范围-请参考OpenSSL留档或使用Let's Encrypt），请替换 /etc/kvmd/nginx/ssl中的密钥，必要时编辑 /etc/kvmd/nginx/ssl.conf并重新启动kvmd-nginx服务。\n\n### **当我尝试访问 One-KVM 主页时，提示 500 错误?**\n\n    可能原因：错误的 YAML 语法或者硬件外设不满足。可执行systemctl status kvmd kvmd-otg或是kvmd --run查看详细报错信息。\n\n### **如何为多个 One-KVM 使用不同的主机名？**\n\n    使用 SSH 会话或 Web 终端，如果您不是 root，请使用命切换为 root 再执行命名`hostnamectl set-hostname onecloud`，然后重新启动 pikvm服务。\n\n![img](./Image/One-KVM FAQ和故障排除.assets/1705214473632-2.png)\n\n### 为什么我的机器不能再通过按下重置键的方式刷机了？\n\n    脚本通过覆盖分区的方式跳过了UBoot线刷检测，如需使用其他系统则需重新短接主板刷机或使用烧录好系统的U盘通过U盘启动。\n\n###  网页视频窗口提示”Janus WebSocket“连接失败如何解决？\n\n此事件发生概率为2%，为偶发性事件，难以复现，无法解决，建议重装软件。\n\n### 为什么网页视频会有无法消除的黑边且模糊无比？\n\n非硬件和软件原因，请检查你的被控机系统设置。\n\n![img](./Image/One-KVM FAQ和故障排除.assets/1705214473632-3.jpeg)","tags":["protected","玩客云","KVM"],"categories":["玩客云"]},{"title":"Linux系统查询设备的详细信息","url":"/2024/01/14/Linux系统查询设备的详细信息/","content":"\n1. **查看系统发行版及版本信息：**\n\n   - 使用 `lsb_release -a` 命令（适用于大多数主流Linux发行版）：\n\n     ```bash\n     lsb_release -a\n     ```\n\n   - 如果`lsb_release`不可用，可以查看 `/etc/os-release` 文件（这个文件在很多现代Linux系统中存在）：\n\n     ```bash\n     cat /etc/os-release\n     ```\n\n   - 对于某些不支持上述命令的老版本Linux系统，可以查看`/etc/issue`或`/etc/redhat-release`（针对Red Hat系）：\n\n     ```bash\n     cat /etc/issue\n     ```\n\n2. **查看内核版本：**\n\n   ```bash\n   uname -a\n   ```\n\n   这将显示包括内核名称、主机名、内核版本、节点名、系统时间、硬件平台以及操作系统的名称等详细信息。\n\n3. **检查CPU类型和架构：**\n\n   ```bash\n   cat /proc/cpuinfo\n   ```\n\n   该命令会列出所有CPU核心的信息，包括型号、频率、架构等。\n\n4. **查看内存信息：**\n\n   ```bash\n   free -h\n   ```\n\n   或者\n\n   ```bash\n   cat /proc/meminfo\n   ```\n\n   这些命令将提供关于系统内存总量、已使用量、空闲量等数据。\n\n5. **查询磁盘分区与容量：**\n\n   ```bash\n   df -hT\n   ```\n\n   此命令会展示各个磁盘分区及其挂载点、文件系统类型和可用空间情况。\n\n6. **查看网络配置：**\n\n   - 使用`ifconfig`（在一些较旧的Linux发行版中仍然可用）：\n\n     ```bash\n     ifconfig\n     ```\n\n   - 或者使用`ip add`（现代Linux系统普遍推荐）：\n\n     ```bash\n     ip addr show\n     ```\n\n   这两个命令都会显示所有网络接口及其IP地址、子网掩码、广播地址等详细信息。\n\n7. **查看进程列表：**\n\n   - 使用`ps`命令列出当前终端下的进程简略信息：\n\n     ```bash\n     ps aux\n     ```\n\n   - 使用`top`实时动态查看并排序系统中运行的所有进程信息：\n\n     ```bash\n     top\n     ```\n\n   - 若要查看特定进程的启动时间和运行时间，请使用`ps`配合`-o`参数：\n\n     ```bash\n     ps -eo pid,comm,lstart,etime | grep [process_name_or_pid]\n     ```\n\n8. **查看开机时间与系统运行时间：**\n\n   - 使用 `uptime` 命令获取系统已运行时间以及当前登录用户数、系统负载等信息：\n\n     ```bash\n     uptime\n     ```\n\n   - 要查看更详细的系统启动时间，可以结合读取`/proc/uptime`和`/var/log/wtmp`（或其变体）文件来获取确切的开机时间，但通常`who -b`或`last reboot`命令更为直接：\n\n     ```bash\n     who -b\n     ```\n\n     或\n\n     ```bash\n     last reboot\n     ```\n\n9. **查询已安装的应用或软件包**\n\n   1. 对于基于Debian和Ubuntu等使用`dpkg`作为包管理器的系统：\n\n      ```bash\n      dpkg -l\n      ```\n\n      这将列出所有已安装的软件包。如果只想查找特定软件包，可以配合`grep`命令过滤输出：\n\n      ```bash\n      dpkg -l | grep 软件名\n      ```\n\n   2. 对于基于RPM（如CentOS、Fedora）使用`rpm`包管理器的系统：\n\n      ```bash\n      rpm -qa\n      ```\n\n      同样，要查找特定软件包：\n\n      ```bash\n      rpm -qa | grep 软件名\n      ```\n\n   3. 对于使用`yum`作为软件包管理器的RHEL、CentOS系统（对于较新版本，请使用`dnf`替代`yum`）：\n\n      ```bash\n      yum list installed\n      # 或者对于使用DNF的系统\n      dnf list installed\n      ```\n\n   4. 对于使用`apt`作为软件包管理器的Debian及Ubuntu系统（包括它们的衍生版）：\n\n      ```bash\n      apt list --installed\n      ```\n\n   5. 对于使用`zypper`的SUSE Linux系统：\n\n      ```bash\n      zypper se --installed-only\n      ```\n\n10. 查看当前运行的软件进程和对应的执行文件的位置\n\n    1. 使用`ps`命令结合`-ef`或`-eo`选项来显示进程信息和执行文件路径：\n\n    ```bash\n    ps -ef | grep [process_name]\n    ```\n\n    或者更精确地只显示进程ID（PID）和其完整命令行（其中包括执行文件路径）：\n\n    ```bash\n    ps -eo pid,comm,args | grep [process_name]\n    ```\n\n    2. 利用`/proc`文件系统中的信息，直接获取特定进程的执行文件路径。假设您已知进程ID为`pid_number`，则可以这样做：\n\n    ```bash\n    readlink /proc/[pid_number]/exe\n    ```\n\n    例如：\n\n    ```bash\n    readlink /proc/1234/exe\n    ```\n\n    这将返回对应于进程ID 1234 的可执行程序的完整路径。\n\n    3. 如果想要获得更详细的进程列表，并且包含执行文件路径，可以使用`pgrep`配合`readlink`命令：\n\n    ```bash\n    pgrep [process_name] | xargs -I {} readlink /proc/{}/exe\n    ```\n\n    这样会先找到与`process_name`匹配的进程ID，然后逐一显示它们的执行文件路径。\n\n    通过这些命令，您可以快速定位到正在运行的进程所关联的执行文件的实际位置。\n\n11. 查询所有的网络连接和防火墙开放端口\n\n    1. 查看网络连接（TCP/UDP监听状态）：\n\n       ```bash\n       netstat -tuln\n       ```\n\n       这条命令会列出当前系统上所有正在监听的TCP（`-t`)和UDP (`-u`) 端口，以及它们所关联的程序。`-n` 参数表示不进行DNS解析，直接显示IP地址。\n\n    2. 查看防火墙规则以了解开放端口：\n\n       不同Linux发行版使用的防火墙管理工具可能不同，以下是几种常见防火墙的查看方式：\n\n    3. 使用iptables（传统Linux防火墙）：\n\n       查看已设置的iptables规则，其中包括对外开放的端口：\n\n       ```bash\n       sudo iptables -L -nv --line-numbers\n       ```\n\n       或者针对特定链（如INPUT链）查看：\n\n       ```bash\n       sudo iptables -L INPUT -nv\n       ```\n\n    4. 使用firewalld（Red Hat系常用）：\n\n       ```bash\n       sudo firewall-cmd --list-all-zones\n       ```\n\n       或者查看指定端口是否允许通过：\n\n       ```bash\n       sudo firewall-cmd --permanent --query-port=80/tcp\n       ```\n\n    5. 使用ufw（Ubuntu等Debian系常用）：\n\n       ```bash\n       sudo ufw status numbered\n       ```\n\n       这将显示一个带编号的防火墙规则列表，包括允许或拒绝的端口。\n\n12. 查询主机名\n\n    1. 使用`hostname`命令：\n\n       ```bash\n       hostname\n       ```\n\n       运行这个命令会直接显示当前主机的主机名。\n\n    2. 查看`/etc/hostname`文件：\n\n       ```bash\n       cat /etc/hostname\n       ```\n\n       主机名通常存储在这个文件中，运行该命令可以直接查看到主机名文本内容。\n\n    3. 如果你想获取完全限定域名（FQDN），可以使用：\n\n       ```bash\n       hostname -f\n       ```\n\n    4. 在某些情况下，如果你需要查看系统如何解析自己的主机名，可以执行DNS查找（实际上是本地回环查询）：\n\n       ```bash\n       nslookup `hostname`\n       ```\n\n    5. 对于临时更改主机名（重启后会恢复原主机名），可以在终端中输入：\n\n       ```bash\n       hostname [new_hostname]\n       ```\n\n       若要永久修改主机名，你需要编辑`/etc/hostname`文件，并可能需要同步更新`/etc/hosts`和其他相关配置文件。对于某些系统，可能还需要通过网络管理工具（如NetworkManager或systemd-resolved等）进行网络配置更新。\n\n\n\n","tags":["AI","protected","Linux"],"categories":["Linux"]},{"title":"项目思路_远程（WIFI）键盘","url":"/2023/12/11/项目思路_远程键盘/","content":"\n# 思想\n\n使用esp8266作为主控方案，将通过wifi + ipv6的形式实现远程输入。借助ch9328芯片，使其与主控通过ttl通信，并将串口传来的数据转换成usb键盘的键值传给计算机。\n\n\n\n# 应用场景\n\n借助WIFI实现远程控制主机。\n\n\n\n# 大致流程\n\n## 使用ddns的方式将获取到的ipv6地址绑定到域名，并监听指定的端口。\n\n## 当有其他应用访问这个端口的时候，解析访问的资源。访问格式如下： `域名:端口/访问方式（协议 明文，两个字母）/要传输的内容（base64编码）`。\n\n- 获取请求的地址：\n\n  - ```c++\n    String path = server.uri(); // 获取请求的路径\n    ```\n\n- 获取路径\n\n  - ```c++\n    String path = \"/jp/hello\"; // 假设这就是请求路径\n    int lastSlashIndex = path.lastIndexOf('/'); //获取最后一个/的位置\n    int secondLastSlashIndex = path.lastIndexOf('/', lastSlashIndex - 1); // 获取倒数第二个/的位置\n    String secondLastSegment = path.substring(secondLastSlashIndex + 1, lastSlashIndex); // 从倒数第二个斜杠后一位开始，一直截取到最后一个斜杠，将截取出的信息写入到secondLastSegment字符串中\n    String lastSegment = path.substring(lastSlashIndex + 1);//截取最后一个斜杠到最后的位置，\n    Serial.println(secondLastSegment); // 输出 jp\n    Serial.println(lastSegment); // 输出 hello\n    ```\n\n## 当获取到协议和编码后，将编码进行解码，获取其中的数据，按照协议的内容进行处理\n\n\n\n### 功能点\n\n- 当协议部分是jp的时候，内容中的部分可以直接输入到计算机\n- 当协议部分是passwd的时候，内容部分经过aes解密后设置成下次解密时的密钥。相当于设置密码。\n  - 注意，设置密码时解密的密钥为一个特定的值（写死）\n  - 当执行设置密码后，将解密后的值写入到指定的文件中（覆盖）\n- 每次运行的时候，都从指定位置读取密码文件.\n  - 若不存在，则使用默认的密码：123456\n  - 若存在，则使用文件中指定的密码。密码文件中的所有内容均为密码\n\n\n\n### 功能的部分代码\n\n- base64解码\n\n  - 要解码一个经过Base64编码的字符串，你可以使用Base64库或者函数来完成。以下是一个示例代码，使用Arduino ESP8266的base64库来解码字符串：\n\n    ```c++\n    #include <Base64.h>\n    \n    String encodedString = \"cnVub29iaQ==\";\n    String decodedString = base64::decode(encodedString);\n    Serial.println(decodedString);\n    \n    ```\n\n    在上面的示例中，我们使用了ESP8266的Base64库来解码字符串。首先，我们将经过Base64编码的字符串赋值给encodedString。然后，使用base64::decode()函数对字符串进行解码，并将解码后的结果赋值给decodedString。最后，使用Serial.println()函数将解码后的字符串打印出来。\n\n    请确保在你的Arduino开发环境中正确安装了ESP8266的Base64库。\n\n- AES解密\n\n  - 如果解密内容和解密密码随时会变化，你可以将解密密码作为一个变量，以便在需要时进行修改。你可以 在代码中定义一个变量来存储解密密码，并在每次解密之前更新它。\n\n    以下是一个示例代码，演示如何使用变量来存储解密密码：\n\n    ```c++\n    #include <AESLib.h>\n    \n    String encryptedString = \"U2FsdGVkX1+Td5IhADeOWSntJwhcWAwE/F35ZrmRCL0=\";\n    String decryptedString;\n    \n    AES aes;\n    String decryptionKey = \"1234\"; // 解密密码，可以随时修改\n    \n    void setup() {\n      Serial.begin(115200);\n    \n      byte iv[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F}; // 初始化向量\n    \n      byte key[decryptionKey.length() + 1]; // 创建解密密码字节数组\n      decryptionKey.getBytes(key, decryptionKey.length() + 1); // 将解密密码字符串转换为字节数组\n    \n      aes.set_key(key, decryptionKey.length()); // 设置解密密码\n      aes.set_iv(iv, sizeof(iv)); // 设置初始化向量\n    \n      decryptedString = aes.decrypt(encryptedString); // 解密字符串\n      Serial.println(decryptedString);\n    }\n    \n    void loop() {\n      // 你的其他代码\n    }\n    \n    ```\n\n    在上面的示例中，我们定义了一个变量`decryptionKey`来存储解密密码。你可以随时修改这个变量的值，以改变解密密码。在`setup()`函数中，我们将解密密码转换为字节数组，并使用`aes.set_key()`函数将 其设置为解密密钥。\n\n    关于初始化向量（IV），它是在AES加密中用于增加加密强度的参数。IV是一个固定长度的字节数组，必须与加密时使用的IV相匹配。在解密过程中，使用相同的IV可以确保正确解密数据。在示例代码中，我们使 用了一个固定的IV，你可以根据需要进行更改。\n\n    请注意，示例代码只是一个参考，具体的实现可能会因为你使用的库或平台而有所不同。确保根据你的需 求和使用的AES库的要求进行相应的修改。\n\n  \n\n## 将结果发送到ch9328\n\n- 参考wifi badusb中的keyboard.cpp：\n\n  - 以下是代码中的一些重要部分：\n\n    1. `makeReport` 函数：该函数用于创建键盘输入报告。它接受多个参数，包括修饰键和按键的值，并返回一个报告对象。\n\n    2. `begin` 函数：该函数用于初始化 ESP8266 的键盘控制。它设置了引脚模式、波特率等，并发送复位信号。\n\n    3. `setLocale` 函数：该函数用于设置键盘的区域设置。它接受一个 `hid_locale_t` 类型的指针作为参数，并将其赋值给 `locale`  变量。\n\n    4. `send` 函数：该函数用于发送键盘输入报告到串口。\n\n    5. `pressKey` 函数：该函数用于模拟按下一个按键。它接受按键的值和修饰键的值作为参数，并在先前的报告中找到一个空闲的位置来存储按键信息。\n\n    6. `pressModifier` 函数：该函数用于模拟按下修饰键。它接受修饰键的值作为参数，并在先前的报告中设置相应的修饰键位。\n\n    7. `press` 函数：该函数用于模拟按下一个字符。它接受一个字符指针作为参数，并根据当前的键盘区域设置转换字符为相应的键值和 修饰键，并调用 `pressKey` 函数发送按键信息。\n\n    8. `write` 函数：该函数用于模拟按下一个**字符串**。它接受一个字符串指针作为参数，并调用 `press` 函数模拟按下每个字符，并在最后释放按键。\n\n    这些函数和变量的组合可以用于控制 ESP8266 作为一个键盘设备，模拟按键操作。\n\n  - bito> 假设我要将字符a传输到计算机，这段代码应该怎么工作？\n\n    bito response>\n    根据您提供的代码，如果您想将字符 'a' 传输到计算机，可以按照以下步骤进行操作：\n\n    1. 调用 `begin()` 函数来初始化 ESP8266 的键盘控制。\n\n    2. 调用 `press()` 函数，并将字符 'a' 作为参数传入。该函数会根据当前的键盘区域设置将字符转换为相应的键值和修饰键，并模拟 按下该按键。\n\n    3. 如果需要，可以调用其他按键函数，例如 `pressModifier()` 来模拟按下修饰键。\n\n    4. 最后，调用 `release()` 函数来释放所有按键，确保没有按键被持续按下。\n\n    完整的示例代码如下：\n\n    ```cpp\n    #include \"keyboard.h\"\n    \n    void setup() {\n      keyboard::begin();\n    }\n    \n    void loop() {\n      // 模拟按下字符 'a'\n      keyboard::press('a');\n    \n      // 模拟释放所有按键\n      keyboard::release();\n    \n      // 延时一段时间，以便观察效果\n      delay(1000);\n    }\n    ```\n\n    在上述示例中，`setup()` 函数会在程序开始时调用一次，用于初始化键盘控制。然后，`loop()` 函数会不断循环执行，每次循环都会 模拟按下字符 'a' 并释放所有按键。之后会延时1秒，以便观察效果。\n\n  - bito> 假设我想传输 shift + ctrl + r到计算机，我应该如何调用？\n\n\n    bito response>\n    要模拟传输 Shift + Ctrl + R 到计算机，您可以按照以下步骤调用相关函数：\n    \n    ```cpp\n    #include \"keyboard.h\"\n    \n    void setup() {\n      keyboard::begin();\n    }\n    \n    void loop() {\n      // 模拟按下 Shift、Ctrl 和 R 键\n      keyboard::pressModifier(KEY_LEFT_SHIFT);\n      keyboard::pressModifier(KEY_LEFT_CTRL);\n      keyboard::press('r');\n    \n      // 模拟释放所有按键\n      keyboard::release();\n    \n      // 延时一段时间，以便观察效果\n      delay(1000);\n    }\n    ```\n    \n    在上述示例中，`setup()` 函数用于初始化键盘控制，而 `loop()` 函数则用于循环执行按键操作。\n    \n    首先，我们调用 `pressModifier()` 函数两次，分别传入 `KEY_LEFT_SHIFT` 和 `KEY_LEFT_CTRL` 作为参数，以模拟按下 Shift 和 Ctrl 键。\n    \n    然后，我们调用 `press()` 函数，并传入字符 'r' 作为参数，以模拟按下 R 键。\n    \n    最后，我们调用 `release()` 函数来释放所有按键，确保没有按键被持续按下。\n    \n    请注意，具体的修饰键值（如 `KEY_LEFT_SHIFT` 和 `KEY_LEFT_CTRL`）可能会根据您的键盘设置和操作系统有所不同。您可以根据需要进行调整。\n\n  - bito> 也就是说，如果我想按下ctrl、shift、alt、insert之类的功能键，我需要调用pressModifier()方法；如果我想按下英文字母、 空格、数字，我就调用press()方法；同时，在没有调用release()方法之前，每调用一次pressModifier()、press()方法，就相当与按下对应的键不松手，直到调用release()方法后，全部统一松手，对吗？\n\n    bito response>\n    是的，您的理解是正确的。\n\n    - 如果您想按下功能键（如Ctrl、Shift、Alt等），可以使用 `pressModifier()` 方法来模拟按下这些键。每次调用 `pressModifier()` 方法，都会将相应的修饰键添加到先前的报告中，表示按下该键。在调用 `release()` 方法之前，这些修饰键会一直保持按下状态。\n\n    - 如果您想按下英文字母、空格、数字等普通键，可以使用 `press()` 方法来模拟按下这些键。每次调用 `press()` 方法，都会将相应的键值添加到先前的报告中，表示按下该键。在调用 `release()` 方法之前，这些普通键会一直保持按下状态。\n\n    最后，当您调用 `release()` 方法时，所有之前按下的键（无论是修饰键还是普通键）都会被释放，相当于将所有键松开。\n\n    请注意，为了模拟按键操作的连续性，您可以在每次按下和释放之间添加适当的延时，以确保操作的顺序和持续时间符合预期。\n\n  - bito> 能不能告诉我，键盘上114个按键，我应该调用哪个按键才能实现分别按下？\n\n    bito response>\n    键盘上的114个按键可以使用不同的键值常量来表示。以下是一些常见的键值常量示例：\n\n    - 字母键：'a', 'b', 'c', ... 'z'\n    - 数字键：'0', '1', '2', ... '9'\n    - 功能键：KEY_F1, KEY_F2, KEY_F3, ... KEY_F12\n    - 修饰键：KEY_LEFT_CTRL, KEY_RIGHT_CTRL, KEY_LEFT_SHIFT, KEY_RIGHT_SHIFT, KEY_LEFT_ALT, KEY_RIGHT_ALT, KEY_LEFT_GUI, KEY_RIGHT_GUI\n    - 特殊键：KEY_ENTER, KEY_ESC, KEY_BACKSPACE, KEY_TAB, KEY_SPACE, KEY_INSERT, KEY_DELETE, KEY_HOME, KEY_END, KEY_PAGE_UP, KEY_PAGE_DOWN, KEY_ARROW_UP, KEY_ARROW_DOWN, KEY_ARROW_LEFT, KEY_ARROW_RIGHT\n\n    您可以根据需要调用相应的键值常量来模拟按下不同的按键。例如，要按下字母 'a'，您可以使用 `keyboard::press('a')`；要按下Shift键，您可以使用 `keyboard::pressModifier(KEY_LEFT_SHIFT)`。\n\n    请注意，具体的键值常量可能会根据您的键盘设置和操作系统有所不同。您可以参考键盘库的文档或查阅相关资料，以获取完整的键值常量列表，并根据您的需要进行调用。\n\n    \n\n  - bito> 功能键、修饰键、特殊键需要通过pressModifier()实现按下，其余的通过press()按下，对吗？\n\n    bito response>\n    是的，您的理解是正确的。\n\n    - 功能键（如F1、F2等）、修饰键（如Ctrl、Shift、Alt等）和特殊键（如Enter、Esc、Backspace等）需要使用 `pressModifier()` 方法来模拟按下。\n\n    - 其他普通键（如字母键、数字键、符号键等）可以使用 `press()` 方法来模拟按下。\n\n    通过调用适当的函数，您可以按照需求模拟按下不同类型的键。请确保在按下和释放键之间适当地调用 `release()` 方法，以便在完成 按键操作后将键释放。\n\n    请注意，键盘库中的函数和键值常量可能会根据库的实现和键盘设置有所不同。建议查阅相关文档或参考库的示例代码以了解准确的函数和键值常量。\n\n  - bito> 也就是说，我通过write(\"hello\", 5)的形式调用，相当于将hello分解成五个字母，然后逐个输入 到计算机是吗？\n\n    bito response>\n    是的，您的理解是正确的。通过调用 `write(\"hello\", 5)` 方法，将字符串 \"hello\" 分解为五个字母， 并逐个输入到计算机中。\n\n    在 `write(const char* str, size_t len)` 方法中的循环中，每次迭代都会调用 `write(&str[i])` 方 法，其中 `&str[i]` 表示字符串中的一个字母。这样，循环会逐个处理字符串中的每个字母，并将其模拟输入到计算机中。\n\n    因此，`write(\"hello\", 5)` 的效果等同于逐个按下字符 'h'、'e'、'l'、'l'、'o'，即将字符串 \"hello\" 分解为五个字母，并逐个输入到计算机中。\n\n\n\n\n\n\n\n1. 9238接收到数据后，转换成usb键值传给主机。","tags":["AI","protected","ESP8266","项目思路","CH9328"],"categories":["项目思路","ESP8266"]},{"title":"Docker基础教程","url":"/2023/12/01/Docker基础教程/","content":"\n# 01-Docker概述\n\n## Docker简介\n\nDocker是基于Go语言实现的云开源项目。\n\nDocker的主要目标是：`Build, Ship and Run Any App, Anywhere`，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP及其运行环境能做到**一次镜像,处处运行**。\n\n## 传统虚拟机和容器\n\n传统虚拟机（virtual machine）：\n传统虚拟机技术基于安装在主操作系统上的虚拟机管理系统（如VirtualBox、VMware等），创建虚拟机（虚拟出各种硬件），在虚拟机上安装从操作系统，在从操作系统中安装部署各种应用。\n缺点：资源占用多、冗余步骤多、启动慢\n\nLinux容器（Linux Container，简称LXC）：\nLinux容器是与系统其他部分分隔开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。\n\nLinux容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一的运行。\n\n![virtual-machine-vs-docker-container.jpg](./Image/Docker基础教程.assets/e65639829822db5a5f38428f73c80c73_MD5.jpg)\n\n对比：\n\n| 特性         | 容器               | 虚拟机     |\n| ------------ | ------------------ | ---------- |\n| 启动         | 秒级               | 分钟级     |\n| 大小         | 一般为Mb           | 一般为Gb   |\n| 速度         | 接近原生           | 比较慢     |\n| 系统支持数量 | 单机支持上千个容器 | 一般几十个 |\n\n\n## Docker运行速度快的原因\n\nDocker有比虚拟机更少的抽象层：\n由于Docker不需要Hypervisor（虚拟机）实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在CPU、内存利用率上docker有明显优势。\n\nDocker利用的是宿主机的内核，而不需要加载操作系统OS内核：\n当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较耗时耗资源的过程。当新建一个虚拟机时，虚拟机软件需要加载OS，返回新建过程是分钟级别的。而Docker由于直接利用宿主机的操作系统，则省略了返回过程，因此新建一个docker容器只需要几秒钟。\n\nDocker容器的本质就是一个进程。\n\n## Docker软件\n\nDocker并非一个通用的容器工具，它依赖于已经存在并运行的Linux内核环境。（在Windows上安装Docker时需要依赖WLS，也即Windows下的Linux子系统）。\n\nDocker实质上是在已经运行的Linux下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的Linux主机。\n\nDocker的基本组成部分：\n\n- 镜像（image）\n- 容器（container）\n- 仓库（repository）\n\n### Docker镜像\n\nDocker镜像就是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建多个容器。\n\n### Docker容器\n\nDocker利用容器独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。\n\n### Docker仓库\n\nDocker仓库是集中存放镜像文件的场所。\n仓库分为公开仓库和私有仓库两种。\n最大的公开仓库是Docker官方的Docker Hub：[https://hub.docker.com/](https://hub.docker.com/)\n\n## Docker架构\n\nDocker是一个 C/S（Client-Server） 结构的系统，后端是一个松耦合架构，众多模块各司其职。\n\nDocker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从容器接收命令并管理运行在主机上的容器。\n\n![architecture.svg](./Image/Docker基础教程.assets/4598b937828084e28b5af5a997aa6392_MD5.svg)\n\n\n\nDocker运行的基本流程为：\n\n1. 用户是使用Docker Client 与 Docker Daemon 建立通信，并发送请求给后者\n2. Docker Daemon 作为 Docker 架构的主体部分，首先提供 Docker Server 的功能使其可以接收 Docker Client 的请求\n3. Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式存在\n4. Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph Driver 将下载镜像以 Graph 的形式存储\n5. 当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境\n6. 当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Exec driver 来完成\n7. Libcontainer 是一项独立的容器管理包，Network driver 以及 Exec driver 都是通过 Libcontainer 来实现具体对容器进行的操作\n\n![flow.png](./Image/Docker基础教程.assets/bc1b1eae660b213c13c15366af481f8f_MD5.jpg)\n\n\n\n\n\n\n\n# 02-Docker安装与卸载\n\n## CentOS安装Docker\n\n参考官网：[https://docs.docker.com/engine/install/centos/](https://docs.docker.com/engine/install/centos/)\n\n## 卸载旧版本\n\n如果之前安装过Docker，需要先卸载旧版本：\n\n```shell\nsudo yum remove docker \\\n              docker-client \\\n              docker-client-latest \\\n              docker-common \\\n              docker-latest \\\n              docker-latest-logrotate \\\n              docker-logrotate \\\n              docker-engine\n```\n\n> 旧版本的Docker引擎包可能叫做：`docker`、`docker-engine`。\n\n> 新版本的Docker引擎包叫做：`docker-ce`\n\n\n## 配置yum资源库\n\n安装`yum-config-manager`：\n\n```shell\n# yum-util提供yum-config-manager功能 \nsudo yum install -y yum-utils\n```\n\n配置docker的资源库地址：\n\n官方地址：（比较慢，不推荐）\n\n```shell\n# 在yum资源库中添加docker资源库\nsudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n```\n\n阿里云镜像地址：\n\n```shell\nsudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n```\n\n> 阿里云官网提供了很多资源镜像，镜像地址：`https://mirrors.aliyun.com`，进入之后可以选择自己需要的资源进行配置\n\n\n创建缓存（可选）：\n\n```shell\nyum makecache fast\n```\n\n## 安装Docker引擎\n\n安装最新版本的Docker引擎、Docker客户端：\n\n```shell\n# docker-ce是Docker引擎，docker-ce-cli是客户端\nsudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin\n```\n\n此时，默认安装的docker引擎、客户端都是最新版本。\n\n如果要安装指定版本：\n\n```shell\n# 查询版本列表\nyum list docker-ce --showduplicates | sort -r\n\n# 指定版本安装17.09.0.ce版\n# sudo yum install docker-ce-<VERSION_STRING> docker-ce-cli-<VERSION_STRING> containerd.io docker-compose-plugin\nsudo yum install docker-ce-17.09.0.ce docker-ce-cli-17.09.0.ce containerd.io docker-compose-plugin\n```\n\n## 启动docker引擎\n\n如果没有启动Docker引擎，那么执行 `docker version`查看版本号时，只能看到 `Client: Docker Engine`（Docker引擎客户端）的版本号。\n\n启动Docker引擎：\n\n```shell\n# 新版本的Docker就是一个系统服务，可以直接使用启动系统服务方式启动\nsystemctl start docker\n\n# 此时查看docker版本，可以看到Server: Docker Engine（Docker引擎）版本号\ndocker version\n```\n\n## 卸载Docker\n\n卸载Docker步骤：\n\n1. 关闭服务\n\n```shell\nsystemctl stop docker\n```\n\n\n2. 使用`yum`删除docker引擎\n\n```shell\nsudo yum remove docker-ce docker-ce-cli containerd.io\n```\n\n\n3. 删除镜像、容器、卷、自定义配置等文件\n\n```shell\n sudo rm -rf /var/lib/docker\n sudo rm -rf /var/lib/containerd\n```\n\n\n\n## 运行HelloWorld测试\n\n运行HelloWorld：\n\n```shell\ndocker run hello-world\n```\n\n\n\n\n\n# 03-Docker下载加速\n\n## docker下载加速\n\n方式1：使用 网易数帆、阿里云等容器镜像仓库进行下载。\n\n例如，下载网易数帆镜像中的mysql。（网易数帆的地址为 `hub.c.163.com`，网易数帆对dockerhub官方的镜像命名空间为 `library`）。\n\n```shell\ndocker pull hub.c.163.com/library/mysql:latest\n```\n\n方式2：配置阿里云加速。\n\n登录阿里云，进入 `工作台` -> `容器镜像服务` -> `镜像工具` -> `镜像加速器`。\n\n里面提供了一个加速器地址：`https://xxxxx.mirror.aliyuncs.com`，将该地址配置到docker中：\n\n```shell\ncd /etc/docker\n\n## 初次进来时没有/etc/docker/daemon.json文件，直接创建该文件即可\nvi /etc/docker/daemon.json\n```\n\n在`daemon.json`中写入以下内容：（即加速器地址）\n\n```json\n{\n  \"registry-mirrors\": [\"https://xxxxx.mirror.aliyuncs.com\"]  \n}\n```\n\n然后刷新配置、重启docker即可：\n\n```shell\n## centos6 的命令\nsudo chkconfig daemon-reload\nsudo service docker restart\n\n## centos7 的命令\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n使用方式2可以直接下载官方的镜像，且镜像tag为官方tag，不需要加上云服务商的地址。\n\n例如：\n\n```shell\ndocker pull mysql:latest\n```\n\n\n\n\n\n# 04-Docker常用命令\n\n## 启动类命令\n\n启动docker：\n\n```shell\nsystemctl start docker\n```\n\n停止Docker：\n\n```shell\nsystemctl stop docker\n```\n\n重启Docker：\n\n```shell\nsystemctl restart docker\n```\n\n查看状态：\n\n```shell\nsystemctl status docker\n```\n\n设置开机自启：\n\n```shell\nsystemctl enable docker\n```\n\n## 帮助类命令\n\n查看Docker版本：\n\n```shell\ndocker version\n```\n\n查看Docker概要信息：\n\n```shell\ndocker info\n```\n\n查看Docker总体帮助文档：\n\n```shell\ndocker --help\n```\n\n查看docker具体命令帮助文档：\n\n```shell\ndocker 具体命令 --help\n```\n\n## 镜像命令\n\n### 列出本地主机上的镜像\n\n```shell\ndocker images\n```\n\n参数：\n\n- `-a`：列出所有镜像（含历史镜像）\n- `-q`：只显示镜像ID\n- `-f`：过滤\n\n\n\n样例：\n\n```bash\nroot@hurrubuntutest:~# docker images\nREPOSITORY                     TAG                            IMAGE ID       CREATED        SIZE\nrustdesk/rustdesk-server-s6    latest                         57bf2e51c27b   46 hours ago   39.3MB\nlouislam/uptime-kuma           1.23.8                         db1d2f3df02a   4 days ago     434MB\njgraph/drawio                  22.1.5                         c169fe2d8326   7 days ago     749MB\nmatrixdotorg/synapse           latest                         4c616e255858   8 days ago     439MB\nmatrixdotorg/synapse           v1.97.0                        8b677737da1f   8 days ago     439MB\ngotson/komga                   1.8.0                          e587682c2347   9 days ago     508MB\nsquidfunk/mkdocs-material      9.4.14                         e6ea3aaebf48   10 days ago    183MB\nlinuxserver/calibre-web        0.6.21                         afd08db699c8   11 days ago    744MB\nminio/minio                    RELEASE.2023-11-11T08-14-41Z   603e753a418c   3 weeks ago    147MB\ncorentinth/it-tools            2023.11.2-7d94e11              5d66a3cbe609   4 weeks ago    57.9MB\nmysql                          8.2.0                          a3b6608898d6   6 weeks ago    596MB\nrequarks/wiki                  2.5.300                        58e34147fec5   3 months ago   552MB\nhomeassistant/home-assistant   2023.8.0.dev20230723           a85caf565806   4 months ago   1.83GB\nzhaojun1998/zfile              4.1.5                          4be9b42156f9   6 months ago   348MB\nhello-world                    latest                         9c7a54a9a43c   7 months ago   13.3kB\ndeluan/navidrome               pr-2295                        3d6a1a800597   8 months ago   154MB\nfogforest/yesplaymusic         0.4.7                          6bcbc7a80953   9 months ago   101MB\n```\n\n\n\n说明：\n\n- REPOSITORY：镜像的仓库源\n- TAG：镜像的标签版本号\n- IMAGE ID：镜像ID\n- CREATED：镜像创建时间\n- SIZE：镜像大小\n\n同一个仓库源可以有多个TAG版本，代表这个仓库源的不同个版本，使用REPOSITORY：TAG来定义不同的镜像。\n\n如果不指定一个镜像的版本标签，例如使用ubuntu的时候，docker将默认使用ubuntu:latest镜像\n\n\n\n### 在远程仓库中搜索镜像\n\n（默认取docker hub中搜索）\n\n```shell\ndocker search 镜像名称\n```\n\n参数：\n\n- `-f`：过滤\n- `--limit 数量`：只展示前几项\n\n### 下载镜像\n\n```shell\ndocker pull 镜像名称[:tag]\n```\n\n不加 tag 时，默认下载最新的镜像（即tag为`latest`）。\n\n### 查看占据的空间\n\n查看镜像/容器/数据卷所占的空间：\n\n```shell\ndocker system df\n```\n\n### 删除镜像\n\n```shell\ndocker rmi 镜像名称/ID\n```\n\n可以使用空格分隔，删除多个镜像：\n\n```shell\ndocker rmi 镜像1 镜像2 镜像3\n```\n\n删除全部镜像：\n\n```shell\ndocker rmi -f $(docker images -qa)\n```\n\n## 虚悬镜像\n\n仓库名、标签都是`<none>`的镜像，俗称虚悬镜像（dangling image）。\n\n一般是构建的镜像的时候出了问题。\n\n\n\n## 命令自动补全\n\ndocker支持命令自动补全功能，当输入镜像名前几位时，可以按`tab`键自动补全镜像名称、tag等。\n\n```shell\n## 如果镜像中有ubuntu，查看输入ub按下tab是否可以补全\ndocker run ub\n```\n\n如果按下`tab`时没有自动补全，可以按以下步骤操作：\n\n1.  检查是否安装了`bash-completion`（命令补全增强包） \n\n```shell\n## 检查有 /usr/share/bash-completion/bash_completion 这个文件\nls /usr/share/bash-completion/bash_completion\n```\n\n\n2.  如果有`/usr/share/bash-completion`目录，但是没有`/usr/share/bash-completion/bash_completion`文件（centos6为`/etc/bash_completion`文件），则需要安装`bash-completion` \n\n```shell\nyum -y install bash-completion\n```\n\n\n3.  检查是否安装了docker的自动补全 \n\n```shell\n## 检查/usr/share/bash-completion/completions文件夹下是否有docker开头的自动补全\n## docker安装完后会在该文件夹下生成自动补全文件docker\n## 如果安装了docker-compose，则该文件夹下还会有 docker-compose文件\nll /usr/share/bash-completion/completions/docker*\n```\n\n\n4.  如果已经安装了docker自动补全，使用`source`命令使其生效 \n\n```shell\nsource /usr/share/bash-completion/completions/docker\n```\n\n\n5.  再次使用`tab`查看是否可以自动补全 \n\n```shell\n## 如果镜像中有ubuntu，查看输入ub按下tab是否可以补全\ndocker run ub\n```\n\n\n6.  如果有报错，且报错中提示`_get_comp_words_by_ref: command not found`。说明`bash-completion`的配置文件没有生效，需要`source`一下 \n\n```shell\n## 对于centos7，bash-completion安装的是2.x版本，配置文件为/usr/share/bash-completion/bash_completion\nsource /usr/share/bash-completion/bash_completion\n\n## 如果是centos6，自动安装的bash-completion最新版为1.x版本，配置文件为/etc/bash_completion\n## bash /etc/bash_completion\n```\n\n\n7.  再次使用`tab`查看是否可以自动补全 \n\n```shell\n## 如果镜像中有ubuntu，查看输入ub按下tab是否可以补全\ndocker run ub\n```\n\n\n\n\n\n# 05-容器命令\n\n## 新建启动容器\n\n```shell\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...]\n```\n\n常用的参数：\n\n- `--name`：为容器指定一个名称\n- `-d`：后台运行容器并返回容器ID，也即启动守护式容器\n- `-i`：以交互模式（interactive）运行容器，通常与`-t`同时使用\n- `-t`：为容器重新分配一个伪输入终端（tty），通常与`-i`同时使用。也即启动交互式容器（前台有伪终端，等待交互）\n- `-e`：为容器添加环境变量\n- `-P`：随机端口映射。将容器内暴露的所有端口映射到宿主机随机端口（大写P）\n- `-p`：指定端口映射（小写p）\n\n`-p`指定端口映射的几种不同形式：\n\n- `-p hostPort:containerPort`：端口映射，例如`-p 8080:80`\n- `-p ip:hostPort:containerPort`：配置监听地址，例如 `-p 10.0.0.1:8080:80`\n- `-p ip::containerPort`：随机分配端口，例如 `-p 10.0.0.1::80`\n- `-p hostPort1:containerPort1 -p hostPort2:containerPort2`：指定多个端口映射，例如`-p 8080:80 -p 8888:3306`\n\n### 启动交互式容器\n\n以交互方式启动ubuntu镜像\n\n```shell\n## -i 交互模式\n## -t 分配一个伪输入终端tty\n## ubuntu 镜像名称\n## /bin/bash（或者bash） shell交互的接口\ndocker run -it ubuntu /bin/bash\n```\n\n![image-20231207170845858](./Image/Docker基础教程.assets/image-20231207170845858.png)\n\n\n\n### 退出交互模式\n\n方式1：\n\n```shell\n## 在交互shell中exit即可退回宿主机\nexit;\n```\n\n方式2：使用快捷键`ctrl` + `P` + `Q`\n\n方式1 退出后，容器会停止；\n\n方式2 退出后容器依然正在运行。\n\n### 启动守护式容器\n\n大部分情况下，我们系统docker容器服务时在后台运行的，可以通过`-d`指定容器的后台运行模式：\n\n```shell\ndocker run -d 容器名\n```\n\n注意事项：\n\n如果使用`docker run -d ubuntu`尝试启动守护式的ubuntu，会发现容器启动后就自动退出了。\n\n因为Docker容器如果在后台运行，就必须要有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（例如`top`、`tail`），就会自动退出。\n\n## 列出正在运行的容器\n\n列出所有正在运行的容器：\n\n```shell\ndocker ps [OPTIONS]\n```\n\n常用参数：\n\n- `-a`：列出当前所有正在运行的容器+历史上运行过的容器\n- `-l`：显示最近创建的容器\n- `-n`：显示最近n个创建的容器\n- `-q`：静默模式，只显示容器编号\n\n## 容器其他启停操作\n\n### 启动已经停止的容器\n\n```shell\ndocker start 容器ID或容器名\n```\n\n### 重启容器\n\n```shell\ndocker restart 容器ID或容器名\n```\n\n### 停止容器\n\n```shell\ndocker stop 容器ID或容器名\n```\n\n### 强制停止容器\n\n```shell\ndocker kill 容器ID或容器名\n```\n\n## 删除容器\n\n删除已经停止的容器：\n\n```shell\ndocker rm 容器ID或容器名\n```\n\n> 删除容器是 `docker rm`，删除镜像是 `docker rmi`，注意区分。\n\n\n强制删除正在运行的容器：\n\n```shell\ndocker rm -f 容器ID或容器名\n```\n\n一次删除多个容器实例：\n\n```shell\ndocker rm -f ${docker ps -a -q}\n\n## 或者\ndocker ps -a -q | xargs docker rm\n```\n\n## 查看容器日志\n\n```shell\ndocker logs 容器ID或容器名\n```\n\n## 查看容器内运行的进程\n\n```shell\ndocker top 容器ID或容器名\n```\n\n## 查看容器内部细节\n\n```shell\ndocker inspect 容器ID或容器名\n```\n\n## 进入正在运行的容器\n\n进入正在运行的容器，并以命令行交互：\n\n```shell\ndocker exec -it 容器ID bashShell\n```\n\n重新进入：\n\n```shell\ndocker attach 容器ID\n```\n\n`docker exec` 和 `docker attach` 区别：\n\n- `attach`直接进入容器启动命令的终端，不会启动新的进程，用`exit`退出会导致容器的停止\n- `exec`是在容器中打开新的终端，并且可以启动新的进程，用`exit`退出不会导致容器的停止\n\n如果有多个终端，都对同一个容器执行了 `docker attach`，就会出现类似投屏显示的效果。一个终端中输入输出的内容，在其他终端上也会同步的显示。\n\n## 容器和宿主机文件拷贝\n\n容器内文件拷贝到宿主机：\n\n```shell\ndocker cp 容器ID:容器内路径 目的主机路径\n```\n\n宿主机文件拷贝到容器中：\n\n```shell\ndocker cp 主机路径 容器ID:容器内路径\n```\n\n## 导入和导出容器\n\n`export`：导出容器的内容流作为一个tar归档文件（对应`import`命令）；\n\n`import`：从tar包中的内容创建一个新的文件系统再导入为镜像（对应`export`命令）；\n\n示例：\n\n```shell\n## 导出\n## docker export 容器ID > tar文件名\ndocker export abc > aaa.tar\n\n## 导入\n## cat tar文件 | docker import - 自定义镜像用户/自定义镜像名:自定义镜像版本号\ncat aaa.tar | docker import - test/mytest:1.0.1\n```\n\n## 将容器生成新镜像\n\n`docker commit`提交容器副本使之成为一个新的镜像。\n\n> docker 启动一个镜像容器后， 可以在里面执行一些命令操作，然后使用`docker commit`将新的这个容器快照生成一个镜像。\n\n\n```shell\ndocker commit -m=\"提交的描述信息\" -a=\"作者\" 容器ID 要创建的目标镜像名:[tag]\n```\n\nDocker挂载主机目录，可能会出现报错：`cannot open directory .: Perission denied`。\n\n解决方案：在命令中加入参数 `--privileged=true`。\n\nCentOS7安全模块比之前系统版本加强，不安全的会先禁止，目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了。如果要开启，一般使用 `--privileged=true`，扩大容器的权限解决挂载没有权限的问题。也即使用该参数，容器内的root才拥有真正的root权限，否则容器内的root只是外部的一个普通用户权限。\n\n## 容器数据卷\n\n卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过UnionFS，提供一些用于持续存储或共享数据。\n\n特性：卷设计的目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。\n\n特点：\n\n- 数据卷可以在容器之间共享或重用数据\n- 卷中的更改可以直接实施生效\n- 数据卷中的更改不会包含在镜像的更新中\n- 数据卷的生命周期一直持续到没有容器使用它为止\n\n运行一个带有容器卷存储功能的容器实例：\n\n```shell\ndocker run -it --privileged=true -v 宿主机绝对路径目录:容器内目录[rw | ro] 镜像名\n```\n\n可以使用`docker inspect`查看容器绑定的数据卷。\n\n权限：\n\n-  `rw`：读写 \n-  `ro`：只读。如果宿主机写入内容，可以同步给容器内，容器内可以读取。 \n\n容器卷的继承：\n\n```shell\n## 启动一个容器\ndocker run -it --privileged=true /tmp/test:/tmp/docker --name u1 ubuntu /bin/bash\n\n## 使用 --volumes-from 继承 u1的容器卷映射配置\ndocker run -it --privileged=true --volumes-from u1 --name u2 ubuntu\n```\n\n## 所有命令示意图\n\n![Docker-Command-Diagram.png](./Image/Docker基础教程.assets/f9908e62e2ed328c90bb68a9cbfb75be_MD5.png)\n\n\n\n\n\n# **06-Docker镜像**\n\n## 镜像是什么\n\n镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好行程一个可交付的运行环境（包括代码、运行时需要的库、环境变量和配置文件等），这个打包好的运行环境就是image镜像文件。\n\n只有通过镜像才能生成Docker容器示例（只有通过类才可以生成一个对象，镜像就相当于类，容器示例就相当于对象）\n\n## 镜像的分层\n\n![image-20231212143203594](./Image/Docker基础教程.assets/image-20231212143203594-1702364442454-1-1702365176549-4.png)\n\n根据图片中拉去的流程，可以得出一个结论：镜像是分层的。\n\n\n\n## Docker 镜像加载原理\n\n### UnionFS - 联合文件系统\n\nDocker 中的文件存储驱动叫做 storage driver。\n\nDocker 最早支持的stotage driver是 AUFS，它实际上由一层一层的文件系统组成，这种层级的文件系统叫UnionFS。\n\n联合文件系统（UnionFS）：Union 文件系统，是一种分层、轻量级并且高性能的文件系统，它支持**对文件系统的修改作为一次提交来一层层的叠加**，同时可以将不同目录挂载到同一个虚拟文件系统下（unite serveral directories into a single virtual filesystem）。\n\nUnion文件系统是Docker镜像的基础。**镜像可以通过分层来进行继承**，基于基础镜像（没有父镜像，类似Object）可以制作具体的应用镜像。\n\n\n\n特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。\n\n后来出现的docker版本中，除了AUFS，还支持OverlayFS、Btrfs、Device Mapper、VFS、ZFS等storage driver。\n\n\n\n### bootfs和rootfs\n\ndocker的镜像实际上是由一层一层的文件系统组成，这种层级的文件系统构成UnionFS。UnionFS是一种文件系统技术，它允许将多个不同的文件系统以层级的方式组合在一起，形成一个统一的文件系统。这种层级 结构使得Docker的镜像具有轻量、可扩展和可共享的特性。\n\n\n\nbootfs（boot file system）主要包含 bootloader 和 kernel，bootloader主要是引导加载 kernel，Linux刚启动时会加载bootfs文件系统。\n\n在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已经由 bootfs 转交给内核，此时系统也会卸载 bootfs。\n\nrootfs（root file system），在bootfs之上，包含的就是典型Linux系统中的 `/dev`、`/proc`、`/bin`、`/etc`等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu、CentOS等。\n\ndocker镜像底层层次：\n\n![layer01.jpg](./Image/Docker基础教程.assets/f59e3878a0434a9c098692b3b4317617_MD5.jpg)\n\n对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接使用Host的Kernel，自己只需要提供rootfs就可以。所以，对于不同的Linux发行版，bootfs基本是一致的，rootfs会有差别，不同的发行版可以共用bootfs。\n\n有差别的rootfs：\n\n![layer02.jpg](./Image/Docker基础教程.assets/cac89fa57e1be4b8d59a60f7b4f679ac_MD5.jpg)\n\n### 镜像分层\n\nDocker支持扩展现有镜像，创建新的镜像。新镜像是从base镜像一层一层叠加生成的。(类似于继承后得到一个子类)\n\n例如：\n\n```dockerfile\n## Version: 0.0.1\nFROM debian  ## 直接在debain base镜像上构建\nMAINTAINER mylinux\nRUN apt-get update && apt-get install -y emacs ## 安装emacs\nRUN apt-get install -y apache2 ## 安装apache2\nCMD [\"/bin/bash\"] ## 容器启动时运行bash\n```\n\n镜像创建过程：\n\n![layer03.png](./Image/Docker基础教程.assets/64a4619367b625a913730eb49c17809f_MD5.png)\n\n## 镜像分层的优势\n\n**镜像分层的一个最大好处就是共享资源，方便复制迁移，方便复用。**\n\n## 容器层\n\n当容器启动时，一个新的**可写层**将被加载到镜像的顶部，这一层通常被称为`容器层`，容器层之下的都叫`镜像层`。\n\n所有对容器的改动，无论添加、删除、还是修改文件都只会发生在容器层中。\n\n只有容器层是可写的，容器层下面的所有镜像层都是只读的。\n\n如图：\n\n![layer04.jpg](./Image/Docker基础教程.assets/b999a3710f53d4e8243d1c7e49f33890_MD5.jpg)\n\n\n\n\n\n# **07-nexus搭建docker私仓**\n\n## 使用nexus创建docker私有仓库\n\nNexus的安装请参考该文档：[https://www.yuque.com/tmfl/pom/uumrx2](https://www.yuque.com/tmfl/pom/uumrx2)\n\n\nNexus配置Docker仓库步骤；\n\n1.  nexus默认docker是失效的，需要 在`security` --> `Realms`，将docker配置成`Active` \n2.  在 `Repository` 的 `Blob Store` 中创建一个用于存放docker镜像的存储。内网没有`S3`的话，把`Type`配置为`file`就行。 \n\n> S3：Simple Storage Service，简单对象存储服务，即云存储。\n\n \n\n3.  在 `Repository` 的 `Repositories` 中创建一个新的资源库，类型为 `docker-hosted`。 \n\n创建的 `docker-hosted`资源库的相关配置：\n\n1. `Name`：指定该资源库的名称，例如就叫 `docker-hosted`\n2. `Online`：默认勾选即可\n3. `HTTP`：与下面的HTTPS，至少需要勾选其中一个选择框，并配置一个和nexus不同的端口号，例如 `8881`。将来docker客户端向镜像中心上传镜像时，需要向该端口号进行上传。\n4. `HTTPS`：如果服务器可以开启https服务，则也可以勾选`HTTPS`，然后配置一个端口号，接收docker客户端上传上来的镜像。\n5. `Allow anonymous docker pull`：允许匿名上传，默认不勾选\n6. `Enable docker V1 API`：是否启用 docker早期`V1`版本的API，默认不勾选，即只启用`V2 API`：`http://xxx.xxx.xxx.xxx:8881/v2/`\n7. `Blob Store`：选择上面创建的docker镜像的存储\n8. `Deployment Policy`：是否允许重复上传同一个资源，默认允许\n\n配置好之后，修改防火墙设置，开启刚刚配置的`8881` 端口：\n\n```shell\nvim /etc/sysconfig/iptables\n```\n\n添加：\n\n```\n-A INPUT -p tcp -m tcp --dport 8881 -j ACCEPT\n```\n\n重启iptables：\n\n```shell\nservice iptables restart\n```\n\n## docker客户端的镜像导出和导入\n\n镜像下载和导出：\n\n```shell\n## 下载镜像\ndocker pull mysql:8.0.28\n## 将镜像导出成本地tar文件\ndocker save -o mysql-8.0.28.tar mysql:8.0.28\n```\n\n镜像的导入：\n\n```shell\n## 将本地文件导入到docker镜像中（docker会自动解析出文件中的tag，无需手动指定）\ndocker load < mysql-8.0.28.tar\n```\n\n## docker 客户端向私仓上传镜像\n\n### 配置docker允许接收`http`请求\n\ndocker默认只接收`https`请求，而我们的`nexus`私仓如果配置的是`HTTP`接口的话，docker直接连会报错：\n\n```\nserver gave HTTP response to HTTPS client\n```\n\n需要配置docker允许连接我们私仓的`http`。\n\n```shell\nvim /usr/lib/systemd/system/docker.service\n```\n\n在其中的`ExecStart` 选项后面，添加 `--insecure-registry {docker 私有镜像库 IP} --ipv6=false`。\n\n例如：\n\n```\n[Service]\n\n##  前面的-H参数可能不同，不需要管，只需在最后面加上我们的私仓地址即可：--insecure-registry 192.168.x.xxx:8881 --ipv6=false\n\nExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock --insecure-registry 192.168.x.xxx:8881 --ipv6=false\n```\n\n然后重启docker：\n\n```shell\n## centos6 的命令\nsudo chkconfig daemon-reload\nsudo service docker restart\n\n## centos7 的命令\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n也可以在`/etc/docker/daemon.json` 中进行配置：\n\n```json\n{\n    \"insecure-reigstries\":[\"192.168.xxx.xxx:8881\"]\n}\n```\n\n### 向私仓推送镜像\n\n1.  如果私仓不允许匿名上传镜像，则需要先进行登陆。（一般私仓都不允许匿名上传，`nexus`默认匿名上传也没有勾选） \n\n```shell\n## --username后面为nexus用户名，执行命令后会提示输入密码\ndocker login --username=admin http://192.168.xxx.xxx:8881\n## 登录之后，会在 $HOME/.docker/config.json 中记录下登录的用户信息，之后便不需要再进行登陆操作\n## 如果要取消登录，则只需执行以下命令\n## docker logout http://192.168.xxx.xxx:8881\n```\n\n\n2.  将要上传的镜像重新设置`Tag`。\n    docker按照镜像名称区分上传的资源库。\n    例如：\n    `mysql:8.0.28`会被上传到docker官方`dockerhub`；\n    `tengyer/helloworld:lasted`会被上传到dockerhub的`tengyer`命名空间中；\n    `registry.cn-hangzhou.aliyuncs.com/命名空间/镜像名称:[镜像版本号]` 会上传到阿里云指定命名空间中；\n    `ccr.ccs.tencentyun.com/命名空间/hello-world`：会上传到腾讯云指定命名空间中；\n    `hub.c.163.com/命名空间/hello-world`：会上传到网易数帆指定命名空间中；\n    所以，我们如果要上传到我们的私仓，需要将`Tag`修改为`xxx.xxx.xxx.xxx:8881/命名空间/mysql:5.0.27`格式： \n\n```shell\n## 将mysql:8.0.28复制出一个私仓格式的Tag\n## 该操作在 docker images中会多出一个复制出来的tag，但是ImageId和原始的相同\n## 加个official命名空间，方便区分这个镜像是从官方镜像下载下来的，不加命名空间也可以上传\ndocker tag [ImageId] xxx.xxx.xxx.xxx:8881/official/mysql:8.0.28\n```\n\n\n3.  将修改好`Tag`的镜像进行上传： \n\n```shell\ndocker push xxx.xxx.xxx.xxx:8881/official/mysql:8.0.28\n```\n\n\n\n\n\n# **08-Registry搭建docker私仓**\n\n## Docker Registry\n\nDocker Registry是官方提供的工具，用于构建私有镜像仓库。\n\n## 环境搭建\n\nDocker Registry也是Docker Hub提供的一个镜像，可以直接拉取运行。\n\n步骤：\n\n1.  拉取镜像 \n\n```shell\ndocker pull registry\n```\n\n\n2.  启动Docker Registry \n\n```shell\ndocker run -d -p 5000:5000 -v /app/myregistry/:/tmp/registry --privileged=true registry\n```\n\n\n3.  验证（查看私服中的所有镜像） \n\n```shell\ncurl http://192.168.xxx.xxx:5000/v2/_catalog\n```\n\nRegistry会返回json格式的所有镜像目录  \n\n## 向Registry私仓中上传镜像\n\n### 配置docker允许接收`http`请求\n\n（配置方式和上传到nexus私仓相同）。\n\n修改`/etc/docker/daemon.json`，添加`insecure-registries`允许http：\n\n```json\n{\n    \"registry-mirros\": [\"https://xxxx.mirror.aliyuncs.com\"],\n    \"insecure-registries\": [\"192.168.xxx.xxx:5000\"]\n}\n```\n\n然后重启docker：（新版本的docker会立即生效）\n\n```shell\n## centos6 的命令\nsudo chkconfig daemon-reload\nsudo service docker restart\n\n## centos7 的命令\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n### 推送到私仓\n\n步骤：\n\n1.  添加一个对应私仓地址的tag \n\n```shell\ndocker tag lee/myubuntu:1.0.1 192.168.xxx.xxx:5000/lee/myubuntu:1.0.1\n```\n\n\n2.  push到私仓 \n\n```shell\ndocker push 192.168.xxx.xxx:5000/lee/myubuntu:1.0.1\n```\n\n\n3.  查看私仓中镜像目录验证 \n\n```shell\ncurl http://192.168.xxx.xxx:5000/v2/_catalog\n```\n\n\n拉取验证：\n\n```shell\ndocker pull 192.169.xxx.xxx:5000/lee/myubuntu:1.0.1\n```\n\n\n\n\n\n# **09-Docker安装Mysql**\n\n## Docker 安装 Mysql\n\n以安装 Mysql 5.7为例：\n\n```shell\ndocker pull mysql:5.7\n```\n\n## Mysql 单机\n\n### 简单版 Mysql 5.7 安装\n\n简单的启动Mysql容器：\n\n```shell\n## 需要使用 -e 配置环境变量 MYSQL_ROOT_PASSWORD（mysql root用户的密码）\ndocker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7\n```\n\n简单版的Mysql会存在以下问题：\n\n- 中文乱码\n- 没有容器卷映射\n\n启动docker容器后，可以正常的连接、创建数据库，创建表，插入数据。但是插入中文则会报错。\n\n例如：\n\n```sql\n-- 创建db01数据库\ncreate database db01;\n-- 切换到db01;\nuse db01;\n-- 创建表\ncreate table t1(id int, name varchar(20));\n\n-- 插入英文可以正常插入\ninsert into t1 values(1, 'abc');\n\n-- 插入中文报错\ninsert into t1 values(2, '张三');\n```\n\n这是因为docker默认的字符集的问题，可以在mysql中使用以下命令查看数据库字符集：\n\n```sql\nshow variables like 'character%';\n```\n\n返回的字符集中，`character_set_database`、`character_set_server`等都为`latin1`字符集，所以会报错。\n\n而且因为启动容器时没有配置容器卷映射，当容器意外被删时，数据无法找回。\n\n### 实际应用版 Mysql 5.7安装\n\n启动 Mysql 容器，并配置容器卷映射：\n\n```shell\ndocker run -d -p 3306:3306 \\\n           --privileged=true \\\n           -v /app/mysql/log:/var/log/mysql \\\n           -v /app/mysql/data:/var/lib/mysql \\\n           -v /app/mysql/conf:/etc/mysql/conf.d \\\n           -e MYSQL_ROOT_PASSWORD=root \\\n           --name mysql \\\n           mysql:5.7\n```\n\n在`/app/mysql/conf`下新建 `my.cnf`，通过容器卷同步给mysql实例，解决中文乱码问题：\n\n```\n[client]\ndefault_character_set=utf8\n[mysqld]\ncollation_server = utf8_general_ci\ncharacter_set_server = utf8\n```\n\n重启mysql容器，使得容器重新加载配置文件：\n\n```shell\ndocker restart mysql\n```\n\n此时便解决了中文乱码（中文插入报错）问题。\n\n而且因为启动时将容器做了容器卷映射，将mysql的配置（映射到`/app/mysql/conf`）、数据（映射到`/app/mysql/data`）、日志（映射到`/app/mysql/log`）都映射到了宿主机实际目录，所以即使删除了容器，也不会产生太大影响。只需要再执行一下启动Mysql容器命令，容器卷还按相同位置进行映射，所有的数据便都可以正常恢复。\n\n## Mysql 主从复制安装\n\n安装主服务器容器实例（端口号3307）：\n\n1. 启动容器实例\n\n```shell\ndocker run -p 3307:3306 \\\n           --name mysql-master \\\n           --privileged=true \\\n           -v /app/mysql-master/log:/var/log/mysql \\\n           -v /app/mysql-master/data:/var/lib/mysql \\\n           -v /app/mysql-master/conf:/etc/mysql \\\n           -e MYSQL_ROOT_PASSWORD=root \\\n           -d mysql:5.7\n```\n\n\n2. 进入`/app/mysql-master/conf`，新建`my.cnf`配置文件：\n\n```\n[mysqld]\n### 设置server_id, 同一个局域网中需要唯一\nserver_id=101\n### 指定不需要同步的数据库名称\nbinlog-ignore-db=mysql\n### 开启二进制日志功能\nlog-bin=mall-mysql-bin\n### 设置二进制日志使用内存大小（事务）\nbinlog_cache_size=1M\n### 设置使用的二进制日志格式（mixed,statement,row）\nbinlog_format=mixed\n### 二进制日志过期清理时间。默认值为0，表示不自动清理\nexpire_logs_days=7\n### 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断\n### 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致\nslave_skip_errors=1062\n```\n\n\n3. 重启容器实例\n\n```shell\ndocker restart mysql-master\n```\n\n\n4. 进入容器实例内\n\n```shell\ndocker exec -it mysql-master /bin/bash\n```\n\n\n5. 登录mysql，创建数据同步用户\n\n```sql\n-- 首先使用 mysql -uroot -p 登录mysql\n-- 创建数据同步用户\ncreate user 'slave'@'%' identified by '123456';\n-- 授权\ngrant replication slave, replication client on *.* to 'slave'@'%';\nflush privileges;\n```\n\n\n\n安装从服务器容器实例（端口号3308）：\n\n1. 启动容器服务：\n\n```shell\ndocker run -p 3308:3306 \\\n           --name mysql-slave \\\n           --privileged=true \\\n           -v /app/mysql-slave/log:/var/log/mysql \\\n           -v /app/mysql-slave/data:/var/lib/mysql \\\n           -v /app/mysql-slave/conf:/etc/mysql \\\n           -e MYSQL_ROOT_PASSWORD=root \\\n           -d mysql:5.7\n```\n\n\n2. 进入`/app/mysql-slave/conf`目录，创建`my.cnf`配置文件：\n\n```\n[mysqld]\n### 设置server_id, 同一个局域网内需要唯一\nserver_id=102\n### 指定不需要同步的数据库名称\nbinlog-ignore-db=mysql\n### 开启二进制日志功能，以备slave作为其它数据库实例的Master时使用\nlog-bin=mall-mysql-slave1-bin\n### 设置二进制日志使用内存大小（事务）\nbinlog_cache_size=1M\n### 设置使用的二进制日志格式（mixed,statement,row）\nbinlog_format=mixed\n### 二进制日志过期清理时间。默认值为0，表示不自动清理\nexpire_logs_days=7\n### 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断\n### 如：1062错误是指一些主键重复，1032是因为主从数据库数据不一致\nslave_skip_errors=1062\n### relay_log配置中继日志\nrelay_log=mall-mysql-relay-bin\n### log_slave_updates表示slave将复制事件写进自己的二进制日志\nlog_slave_updates=1\n### slave设置只读（具有super权限的用户除外）\nread_only=1\n```\n\n\n3. 修改完配置需要重启slave容器实例\n\n```shell\ndocker restart mysql-slave\n```\n\n\n\n在主数据库中查看主从同步状态：\n\n1. 进入主数据库容器：\n\n```shell\ndocker exec -it mysql-master /bin/bash\n```\n\n\n2. 进入Mysql\n\n```shell\nmysql -uroot -p\n```\n\n\n3. 查看主从同步状态\n\n```sql\nshow master status;\n```\n\n\n主要查看返回结果的文件名`File`、当前位置`Position`\n\n\n进入从数据库容器，配置主从复制：\n\n1. 进入从数据库容器：\n\n```shell\ndocker exec -it mysql-slave /bin/bash\n```\n\n\n2. 进入数据库\n\n```shell\nmysql -uroot -p\n```\n\n\n3. 配置从数据库所属的主数据库：\n\n```sql\n-- 格式：\n-- change master to master_host='宿主机ip',master_user='主数据库配置的主从复制用户名',master_password='主数据库配置的主从复制用户密码',master_port=宿主机主数据库端口,master_log_file='主数据库主从同步状态的文件名File',master_log_pos=主数据库主从同步状态的Position,master_connect_retry=连接失败重试时间间隔（秒）;\n\nchange master to master_host='192.168.xxx.xxx',master_user='slave',master_password='123456',master_port=3307,master_log_file='mall-mysql-bin.000001',master_log_pos=769,master_connect_retry=30;\n```\n\n\n4. 查看主从同步状态：\n\n```sql\n## \\G 可以将横向的结果集表格转换成纵向展示。\n## slave status的字段比较多，纵向展示比友好\nshow slave status \\G;\n```\n\n\n除了展示刚刚配置的主数据库信息外，主要关注 `Slave_IO_Running`、`Slave_SQL_Running`。目前两个值应该都为 `No`，表示还没有开始。\n\n5. 开启主从同步：\n\n```sql\nstart slave;\n```\n\n\n6. 再次查看主从同步状态，`Slave_IO_Running`、`Slave_SQL_Running`都变为`Yes`。\n\n\n主从复制测试：\n\n1. 在主数据库上新建库、使用库、新建表、插入数据\n\n```sql\ncreate database db01;\nuse db01;\ncreate table t1 (id int, name varchar(20));\ninsert into t1 values (1, 'abc');\n```\n\n\n2. 在从数据库上使用库、查看记录\n\n```sql\nshow databases;\nuse db01;\nselect * from t1;\n```\n\n\n\n\n\n# **10-Docker安装Redis**\n\n## Docker安装Redis\n\n以 Redis 6.0.8 为例：\n\n```shell\ndocker pull redis:6.0.8\n```\n\n## 单机版安装\n\n### 简单版 Redis\n\n简单的启动Redis容器：\n\n```shell\ndocker run -p 6379:6379 -d redis:6.0.8\n```\n\n简单版没有配置容器卷映射，当容器被删除时数据无法恢复。\n\n### 实际应用版Redis\n\n配置文件、数据文件都和容器卷进行映射。\n\n步骤：\n\n1.  宿主机创建目录`/app/redis` \n2.  在`/app/redis`下创建文件`redis.conf`，主要修改以下几项配置 \n\n```\n## 开启密码验证（可选）\nrequirepass 123\n\n## 允许redis外地连接，需要注释掉绑定的IP\n## bind 127.0.0.1\n\n## 关闭保护模式（可选）\nprotected-mode no\n\n## 注释掉daemonize yes，或者配置成 daemonize no。因为该配置和 docker run中的 -d 参数冲突，会导致容器一直启动失败\ndaemonize no\n\n## 开启redis数据持久化， （可选）\nappendonly yes\n```\n\n即最后的配置文件为：  \n\n3.  启动docker容器：（因为要使用自定义的配置文件，所以需要指定容器运行的命令为`redis-server 容器内配置文件路径`） \n\n```shell\ndocker run -d -p 6379:6379 --name redis --privileged=true \\\n           -v /app/redis/redis.conf:/etc/redis/redis.conf \\\n           -v /app/redis/data:/data \\\n           redis:6.0.8 \\\n           redis-server /etc/redis/redis.conf\n```\n\n## 集群存储算法\n\n### 分布式存储算法\n\n分布式存储的常见算法：\n\n- 哈希取余算法分区\n- 一致性哈希算法分区\n- 哈希槽算法分区\n\n### 哈希取余算法\n\n算法描述：`hash(key) % N`（其中，`key`是要存入Redis的键名，`N`是Redis集群的机器台数）。用户每次读写操作，都是根据传入的键名经过哈希运算，对机器台数取余决定该键存储在哪台服务器上。\n\n优点：简单直接有效，只需要预估好数据规划好节点，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。\n\n缺点：原来规划好的节点，如果进行了扩容或者缩容，导致节点有变动，映射关系需要重新进行计算。在服务器个数固定不变时没问题，如果需要弹性扩容或者故障停机的情况下，原来取模公式中的 `N`就会发生变化，此时经过取模运算的结果就会发生很大变化，导致根据公式获取的服务器变得不可控。\n\n### 一致性哈希算法\n\n算法背景：一致性哈希算法是**为了解决哈希取余算法中的分布式缓存数据变动和映射问题**。当服务器个数发生变化时，尽量减少影响到客户端与服务器的映射关系。\n\n算法描述：\n一致性哈希算法必然有个hash函数并按照算法产生Hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个Hash区间`[0, 2^32 - 1]`，这是一个线性空间。但是在这个算法中，我们通过适当的逻辑控制将它首尾相连（`0 = 2^32`），这样让它逻辑上形成了一个环形空间。\n\n它也是按照使用取模的方式。前面的哈希取余算法是对节点个数进行取模，而一致性哈希算法是对 `2^32`取模。\n\n简单来说，一致性Hash算法将整个哈希值空间组成一个虚拟的圆环。如假设某个哈希函数`H`的值空间为 `0`到`2^32 - 1`（即哈希值是一个32位无符号整形），整个哈希环如下图：整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4.......直到`2^32 - 1`，也就是说0点左侧的第一个点代表 `2^32 - 1`。0 和 `2^32 - 1`在零点钟方向重合，我们把这个由 `2^32`个点组成的圆环称为Hash环。\n\n![hash01.jpg](./Image/Docker基础教程.assets/6d9d1667dacd9d1474b9041577405159_MD5.jpg)\n\n有了哈希环之后，还需要进行节点映射，将集群中各个IP节点映射到环上的某一个位置。\n\n将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希。这样每台机器就能确定其在哈希环上的位置。\n\n假如4个节点NodeA、B、C、D，经过IP地址的哈希函数计算（`hash(ip)`），使用IP地址哈希值后在环空间的位置如下：\n![hash02.jpg](./Image/Docker基础教程.assets/4cb40f06d3962ab8e64ce770b904e08a_MD5.jpg)\n\n`key`落到服务器的落键规则。当我们需要存储一个`key`键值对时，首先计算`key`的`hash`值（`hash(key)`），将这个`key`使用相同的函数hash，计算出哈希值并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储字该节点上。\n\n假如我们有ObjectA、B、C、D四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性hash算法，数据A会被定位到NodeA上，B被定位到NodeB上，C被定位到NodeC上，D被定位到NodeD上。\n\n![hash03.jpg](./Image/Docker基础教程.assets/745d9d002d0264ce3d830423edd30deb_MD5.jpg)\n\n假设NodeC宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重新定位到NodeD。\n\n一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间的数据，其他不会受到影响。\n\n即：假设NodeC宕机，只会影响到Hash定位到NodeB到NodeC之间的数据，并且这些数据会被转移到NodeD进行存储。\n\n![hash04.jpg](./Image/Docker基础教程.assets/be5dacf64616fd33f9db8337107cebd8_MD5.jpg)\n\n假如需要扩容增加一台节点NodeX，NodeX的`hash(ip)`位于NodeB和NodeC之间，那受到影响的就是NodeB 到 NodeX 之间的数据。重新将B到X的数据录入到X节点上即可，不会导致Hash取余全部数据重新洗牌的后果。\n\n![hash05.jpg](./Image/Docker基础教程.assets/624549a2e87add1ead4ba0d97f923f5a_MD5.jpg)\n\n但是Hash环会存在数据倾斜问题。\n\n一致性Hash算法在服务节点太少时，容易因为节点分布不均匀而造成数据倾斜（被缓存的对象都集中到某一台或某几台服务器）。\n\n![hash06.webp](./Image/Docker基础教程.assets/86556cf462f792e8b61d52aff7cf39d5_MD5.webp)\n为了解决数据倾斜问题，一致性哈希算法引入了虚拟节点机制。\n\n对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以先确定每个物理节点关联的虚拟节点数量，然后在IP或主机名后面加上编号。\n\n例如，可以对NodeA节点虚拟出 NodeA#1、NodeA#2、NodeA#3，对NodeB虚拟出NodeB#1、NodeB#2、NodeB#3的节点，形成六个虚拟节点。\n\n![hash07.jpg](./Image/Docker基础教程.assets/d3f0daeefc6dcf42a4b0c6de0e6fd292_MD5.jpg)\n\n优点：加入和删除节点时，只会影响哈希环中顺时针方向相邻节点，对其他节点无影响。\n\n缺点：数据的分布和节点的位置有关，因为这些节点不是均匀分布在哈希环上的，所以在数据进行存储时达不到均匀部分的效果。\n\n### 哈希槽分区\n\n哈希槽分区是为了解决一致性哈希算法的数据倾斜问题。\n\n哈希槽实质上就是一个数组，数组 `[0, 2^14 - 1]`形成的 hash slot空间。\n\n目的是为了解决均匀分配的问题。在数据和节点之间又加入了一层，把这层称之为槽（slot），用于管理数据和节点之间的关系。就相当于节点上放的是槽，槽里面放的是数据。\n\n![slot01.png](./Image/Docker基础教程.assets/23b7aa613d962a17a5526c2afd680493_MD5.png)\n\n槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。\n\n哈希解决的是映射问题，使用`key`的哈希值来计算所在的槽，便于数据分配。\n\n一个集群只能有 16394个槽，编号 0 - 16383（`2^14 - 1`）。这些槽会分配给集群中所有的主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点，集群会记录节点和槽的对应关系。\n\n解决了节点和槽的关系后，接下来就需要对`key`求哈希值，然后对16384取余，根据余数决定`key`落到哪个槽里。\n\n```\nslot = CRC16(key) % 16384\n```\n\n以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。\n\n### Redis集群存储策略\n\nRedis集群使用的就是哈希槽。Redis集群有16384个哈希槽，每个`key`通过`CRC16`校验后对16384取模来决定放置在哪个槽，集群的每个节点负责一部分hash槽。\n\n哈希槽数量16384（`2^14`）的决定原因：\n`CRC16`算法产生的hash值有 16bit，该算法可以产生 `2^16` = 65536个值。但是为了心跳方便和数据传输最大化，槽的数量只能有 `2^14`个。\n\n1.  如果槽位数量为65535个，那么发送心跳信息的消息头将达到 8k，发送的心跳包过于庞大。在消息头中最占空间的是 `myslots[CLUSTER_SLOTS/8]`。当槽位为65536时，这块的大小是 ： \n\n```\n65536 ÷ 8 ÷ 1024 = 8Kb\n```\n\n每秒中redis节点需要发送一定数量的ping消息作为心跳，如果槽位为65536，那么这个ping消息头就会太大浪费带宽。 \n\n2.  redis集群的主节点数量基本不可能超过1000个。集群节点越多，心跳包的消息体内携带的数据越多。如果节点超过1000个，也会导致网络拥堵。因此redis作者不建议redis cluster节点超过1000个。对于节点数在1000以内的redis cluster集群，16384个槽位足够了，没有必要扩展到65536个。 \n3.  槽位越小，节点少的情况下压缩比越高，容易传输。Redis主节点的配置信息中它锁负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中会对bitmap进行压缩，但是如果bitmap的填充率 `slots / N`（N为节点数）很高的话，bitmap的压缩率就很低。如果节点数很少，而哈希槽数很多的话，bitmap的压缩率就很低。 \n\n> 原文：\n> 正常的心跳数据包带有节点的完整配置，使得可以用幂等方式用旧的节点替换旧节点，以便更新旧的配置。这意味着它们包含原始节点的插槽配置，该节点使用 2k 的空间和 16k 的插槽，而不是使用 8k 的空间（使用65k的插槽）。\n> 同时，因为其他设计折衷，Redis集群的主节点不太可能扩展到1000个以上\n\n\nRedis集群中内置了16384个哈希槽，redis会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在Redis集群中放置一个`Key-Value`时，redis先对`key`使用 `CRC16` 算法算出一个结果，然后把结果对 16384 取余，这样每个`key`都会对应一个编号在0-16383之间的哈希槽，也就是映射到某个节点上。\n\n![slot02.png](./Image/Docker基础教程.assets/216c59ebf48ef8e2b1190f4fae0519b8_MD5.png)\n\n```java\n@Test\npublic void test() {\n    // import io.lettuce.core.cluster.SlotHash;\n    System.out.println(SlotHash.getSlot('A'));  // 计算结果6373，存入上图的Node2\n    System.out.println(SlotHash.getSlot('B'));  // 计算结果10374，存入上图的Node2\n    System.out.println(SlotHash.getSlot('C'));  // 计算结果14503，存入上图的Node3\n    System.out.println(SlotHash.getSlot('Hello'));  // 计算结果866，存入上图的Node1\n}\n```\n\n## 3主3从Redis集群\n\n### 搭建\n\n使用docker搭建3主3从的Redis集群，每台主机都对应一台从机。\n启动6台redis容器\n\n```shell\n## 启动第1台节点\n## --net host 使用宿主机的IP和端口，默认\n## --cluster-enabled yes 开启redis集群\n## --appendonly yes 开启redis持久化\n## --port 6381 配置redis端口号\ndocker run -d --name redis-node-1 --net host --privileged=true -v /app/redis-cluster/share/redis-node-1:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6381\n\n## 启动第2台节点\ndocker run -d --name redis-node-2 --net host --privileged=true -v /app/redis-cluster/share/redis-node-2:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6382\n\n## 启动第3台节点\ndocker run -d --name redis-node-3 --net host --privileged=true -v /app/redis-cluster/share/redis-node-3:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6383\n\n## 启动第4台节点\ndocker run -d --name redis-node-4 --net host --privileged=true -v /app/redis-cluster/share/redis-node-4:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6384\n\n## 启动第5台节点\ndocker run -d --name redis-node-5 --net host --privileged=true -v /app/redis-cluster/share/redis-node-5:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6385\n\n## 启动第6台节点\ndocker run -d --name redis-node-6 --net host --privileged=true -v /app/redis-cluster/share/redis-node-6:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6386\n```\n\n构建主从关系：\n\n1.  进入节点1（或其中任意一个节点）: \n\n```shell\ndocker exec -it redis-node-1 /bin/bash\n```\n\n\n2.  构建主从关系： \n\n```shell\n## 宿主机IP:端口\nredis-cli --cluster create 192.168.xxx.xxx:6381 192.168.xxx.xxx:6382 192.168.xxx.xxx:6383 192.168.xxx.xxx:6384 192.168.xxx.xxx:6385 192.168.xxx.xxx:6386 --cluster-replicas 1\n```\n\n\n3.  redis尝试自动进行主从节点分配 \n4.  因为我们的docker容器IP相同，所以会出现警告，可以直接忽略该警告 \n\n```\n[WARNING] Some slaves are in the same host as their master\n```\n\n\n5.  redis自动分配结果完成后，需要输入 `Yes` 确认配置信息： \n\n```\nM: f451eb48bbc0a7c31c7da022ffe80cc1696e0f37 192.168.xxx.xxx:6381\n   slots:[0-5460] (5461 slots) master\nM: 05984211b8c38222a73abeff1d4e459c0fe1efbc 192.168.xxx.xxx:6382\n   slots:[5461-10922] (5462 slots) master\nM: 1fc935c12b1d34a7df50aed643c195eb29bb3435 192.168.xxx.xxx:6383\n   slots:[10923-16383] (5461 slots) master\nS: f8d0de47114bf33438747acd713cce4e412ae721 192.168.xxx.xxx:6384\n   replicates 1fc935c12b1d34a7df50aed643c195eb29bb3435\nS: de0b393c17e452d856f6de2b348e9ca4e5aa4002 192.168.xxx.xxx:6385\n   replicates f451eb48bbc0a7c31c7da022ffe80cc1696e0f37\nS: 0c0767e13a09ee48541738d4163592cd9842c143 192.168.xxx.xxx:6386\n   replicates 05984211b8c38222a73abeff1d4e459c0fe1efbc\nCan I set the above configuration? (type 'yes' to accept):\n```\n\n\n6.  输入`Yes`确认后，redis会向其他节点发送信息加入集群，并分配哈希槽： \n\n```\n>>> Nodes configuration updated\n>>> Assign a different config epoch to each node\n>>> Sending CLUSTER MEET messages to join the cluster\nWaiting for the cluster to join\n.....\n>>> Performing Cluster Check (using node 192.168.xxx.xxx:6381)\nM: f451eb48bbc0a7c31c7da022ffe80cc1696e0f37 192.168.xxx.xxx:6381\n   slots:[0-5460] (5461 slots) master\n   1 additional replica(s)\nM: 1fc935c12b1d34a7df50aed643c195eb29bb3435 192.168.xxx.xxx:6383\n   slots:[10923-16383] (5461 slots) master\n   1 additional replica(s)\nM: 05984211b8c38222a73abeff1d4e459c0fe1efbc 192.168.xxx.xxx:6382\n   slots:[5461-10922] (5462 slots) master\n   1 additional replica(s)\nS: 0c0767e13a09ee48541738d4163592cd9842c143 192.168.xxx.xxx:6386\n   slots: (0 slots) slave\n   replicates 05984211b8c38222a73abeff1d4e459c0fe1efbc\nS: f8d0de47114bf33438747acd713cce4e412ae721 192.168.xxx.xxx:6384\n   slots: (0 slots) slave\n   replicates 1fc935c12b1d34a7df50aed643c195eb29bb3435\nS: de0b393c17e452d856f6de2b348e9ca4e5aa4002 192.168.xxx.xxx:6385\n   slots: (0 slots) slave\n   replicates f451eb48bbc0a7c31c7da022ffe80cc1696e0f37\n[OK] All nodes agree about slots configuration.\n>>> Check for open slots...\n>>> Check slots coverage...\n[OK] All 16384 slots covered.\n```\n\n\n查看集群状态：\n\n1.  进入容器节点1（或集群中其他节点）： \n\n```shell\ndocker exec -it redis-node-1 /bin/bash\n```\n\n\n2.  使用`redis-cli`连接到`6381`节点： \n\n```shell\nredis-cli -p 6381\n```\n\n\n3.  使用`redis`的相关命令查看集群状态： \n\n```shell\ncluster info\n```\n\n其中，分配的哈希槽数量 `cluster_slots_assigned`为16384，集群节点数量`cluster_known_nodes`为6 \n\n4.  查看集群节点信息 \n\n```shell\ncluster nodes\n```\n\n\n### Redis集群读写出错\n\n当使用 `redis-cli`连接redis集群时，需要添加 `-c`参数，否则可能会出现读写出错。\n\n示例：\n\n1.  进入容器节点1 \n\n```shell\ndocker exec -it redis-node-1 /bin/bash\n```\n\n\n2.  使用`redis-cli`连接，不加`-c`参数时 \n\n```shell\nredis-cli -p 6381\n```\n\n\n3.  此时向redis中添加键值对，可能会成功，也可能会失败 \n\n```shell\nset k1 v1\n```\n\n报错：`k1`经过计算得到的哈希槽为12706，但是当前连接的redis-server为`6381`（即节点1），它的哈希槽为：`[0,5460]`（在创建构建主从关系时redis有提示，也可以通过 `cluster nodes`查看），所以会因为存不进去而报错。 \n执行 `set k2 v2`可以成功，因为`k2`计算出的哈希槽在`[0-5460]`区间中。 \n\n4.  使用`-c`参数的`redis-cli`命令连接即可 \n\n```shell\nredis-cli -p 6381 -c\n```\n\n\n5.  此时可以正常的插入所有数据 \n\n```shell\nset k1 v1\n```\n\n会有提示信息，哈希槽为12706，重定向到`6383`（即节点3，哈希槽`[10923, 16383]`）：  \n\n### 集群信息检查\n\n检查查看集群信息：\n\n1.  进入容器节点1 \n\n```shell\ndocker exec -it redis-node-1 /bin/bash\n```\n\n\n2.  进行集群信息检查 \n\n```shell\n## 输入任意一台主节点地址都可以进行集群检查\nredis-cli --cluster check 192.168.xxx.xxx:6381\n```\n\n\n返回的检查结果：\n\n```\n当前集群中各个节点存储的key的数量\n192.168.xxx.xxx:6381 (f451eb48...) -> 0 keys | 5461 slots | 1 slaves.\n192.168.xxx.xxx:6383 (1fc935c1...) -> 1 keys | 5461 slots | 1 slaves.\n192.168.xxx.xxx:6382 (05984211...) -> 0 keys | 5462 slots | 1 slaves.\n[OK] 1 keys in 3 masters.  \n0.00 keys per slot on average.\n\n主从机器信息\n>>> Performing Cluster Check (using node 192.168.xxx.xxx:6381)\nM: f451eb48bbc0a7c31c7da022ffe80cc1696e0f37 192.168.xxx.xxx:6381\n   slots:[0-5460] (5461 slots) master\n   1 additional replica(s)\nM: 1fc935c12b1d34a7df50aed643c195eb29bb3435 192.168.xxx.xxx:6383\n   slots:[10923-16383] (5461 slots) master\n   1 additional replica(s)\nM: 05984211b8c38222a73abeff1d4e459c0fe1efbc 192.168.xxx.xxx:6382\n   slots:[5461-10922] (5462 slots) master\n   1 additional replica(s)\nS: 0c0767e13a09ee48541738d4163592cd9842c143 192.168.xxx.xxx:6386\n   slots: (0 slots) slave\n   replicates 05984211b8c38222a73abeff1d4e459c0fe1efbc\nS: f8d0de47114bf33438747acd713cce4e412ae721 192.168.xxx.xxx:6384\n   slots: (0 slots) slave\n   replicates 1fc935c12b1d34a7df50aed643c195eb29bb3435\nS: de0b393c17e452d856f6de2b348e9ca4e5aa4002 192.168.xxx.xxx:6385\n   slots: (0 slots) slave\n   replicates f451eb48bbc0a7c31c7da022ffe80cc1696e0f37\n[OK] All nodes agree about slots configuration.\n>>> Check for open slots...\n>>> Check slots coverage...\n[OK] All 16384 slots covered.\n```\n\n## 主从扩容缩容\n\n### 主从扩容\n\n假如因为业务量激增，需要向当前3主3从的集群中再加入1主1从两个节点。\n\n步骤：\n\n1.  启动2台新的容器节点 \n\n```shell\n## 启动第7台节点\ndocker run -d --name redis-node-7 --net host --privileged=true -v /app/redis-cluster/share/redis-node-7:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6387\n\n## 启动第8台节点\ndocker run -d --name redis-node-8 --net host --privileged=true -v /app/redis-cluster/share/redis-node-8:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6388\n```\n\n\n2.  进入6387（节点7）容器内部 \n\n```shell\ndocker exec -it redis-node-7 /bin/bash\n```\n\n\n3.  将6387作为master加入集群 \n\n```shell\n## redis-cli --cluster add-node 本节点地址 要加入的集群中的其中一个节点地址\nredis-cli --cluster add-node 192.168.xxx.xxx:6387 192.168.xxx.xxx:6381\n```\n\n\n4.  检查当前集群状态 \n\n```shell\nredis-cli --cluster check 192.168.xxx.xxx:6381\n```\n\n可以发现，6371节点已经作为master加入了集群，但是该节点没有被分配槽位。 \n\n5.  重新分配集群的槽位 \n\n```shell\nredis-cli --cluster reshard 192.168.xxx.xxx:6381\n```\n\nredis经过槽位检查后，会提示需要分配的槽位数量： \n例如，我们现在是4台master，我们想要给node7分配4096个槽位，这样每个节点都是4096个槽位。\n输入`4096`后，会让输入要接收这些哈希槽的节点ID，填入node7的节点ID即可。（就是节点信息中很长的一串十六进制串）。\n然后会提示，询问要从哪些节点中拨出一部分槽位凑足4096个分给Node7。一般选择 `all`，即将之前的3个主节点的槽位都均一些给Node7，这样可以使得每个节点的槽位数相等均衡。\n输入`all`之后，redis会列出一个计划，内容是自动从前面的3台master中拨出一部分槽位分给Node7的槽位，需要确认一下分配的计划。\n输入`yes`确认后，redis便会自动重新洗牌，给Node7分配槽位。 \n\n重新分配完成后，可以进行集群信息检查，查看分配结果：\n\n```shell\nredis-cli --cluster check 192.168.xxx.xxx:6381\n```\n\n可以发现重新洗牌后的槽位分配为：\n\n```\n节点1：[1365-5460]（供4096个槽位），，，分配前为[0-5460]（共5461个槽位）\n节点2：[6827-10922]（共4096个槽位），，，分配前为[5461-10922]（共5461个槽位）\n节点3：[12288-16383]（共4096个槽位），，，分配前为[10923-16383]（共5462个槽位）\n\n节点7：[0-1364],[5461-6826],[10923-12287]（共4096个槽位），从每个节点中匀出来了一部分给了节点7\n```\n\n因为可能有些槽位中已经存储了`key`，完全的重新洗牌重新分配的成本过高，所以redis选择从前3个节点中匀出来一部分给节点7\n\n为主节点6387分配从节点6388：\n\n```shell\nredis-cli --cluster add-node 192.168.xxx.xxx:6388 192.168.xxx.xxx:6381 --cluster-slave --cluster-master-id node7节点的十六进制编号字符串\n```\n\nredis便会向6388发送消息，使其加入集群并成为6387的从节点。\n\n检查集群当前状态\n\n```shell\nredis-cli --cluster check 192.168.xxx.xxx:6381\n```\n\n### 主从缩容\n\n假如业务高峰期过去，需要将4主4从重新缩容到3主3从。即从集群中移除node8和node7.\n\n首先删除从节点6388：\n\n1.  进入容器节点1 \n\n```shell\ndocker exec -it redis-node-1 /bin/bash\n```\n\n\n2.  检查容器状态，获取6388的节点编号 \n\n```shell\nredis-cli --cluster check 192.168.xxx.xxx:6381\n```\n\n\n3.  将6388从集群中移除 \n\n```shell\nredis-cli --cluster del-node 192.168.xxx.xxx:6388 6388节点编号\n```\n\n\n对node7重新分配哈希槽：\n\n1.  对集群重新分配哈希槽 \n\n```shell\nredis-cli --cluster reshard 192.168.xxx.xxx:6381\n```\n\n\n2.  redis经过槽位检查后，会提示需要分配的槽位数量： \n\n```\nHow many slots do you want to move (from 1 to 16384)?\n```\n\n如果我们想直接把node7的4096个哈希槽全部分给某个节点，可以直接输入4096。\n输入`4096`后，会让输入要接收这些哈希槽的节点ID。假如我们想把这4096个槽都分给Node1，直接输入node1节点的编号即可。\n然后会提示，询问要从哪些节点中拨出一部分槽位凑足4096个分给Node1。这里我们输入node7的节点编号，回车后输入`done`。 \n\nnode7上面没有了哈希槽，此时便可以将node7从集群中移除。（如果node7上面有哈希槽，直接从集群中移除会报错）\n\n```shell\nredis-cli --cluster del-node 192.168.xxx.xxx:6387 node7节点编号\n```\n\n\n\n\n\n# **11-Dockerfile**\n\n## Dockerfile\n\nDockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。\n\n构建步骤：\n\n1. 编写Dockerfile文件\n2. `docker build`命令构建镜像\n3. `docker run`依据镜像运行容器实例\n\n## 构建过程\n\nDockerfile编写：\n\n- 每条保留字指令都必须为大写字母，且后面要跟随至少一个参数\n- 指令按照从上到下顺序执行\n- `#`表示注释\n- 每条指令都会创建一个新的镜像层并对镜像进行提交\n\nDocker引擎执行Docker的大致流程：\n\n1. docker从基础镜像运行一个容器\n2. 执行一条指令并对容器做出修改\n3. 执行类似`docker commit`的操作提交一个新的镜像层\n4. docker再基于刚提交的镜像运行一个新容器\n5. 执行Dockerfile中的下一条指令，直到所有指令都执行完成\n\n## Dockerfile保留字\n\n### FROM\n\n基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板。Dockerfile第一条必须是`FROM`\n\n```dockerfile\n## FROM 镜像名\nFROM hub.c.163.com/library/tomcat\n```\n\n### MAINTAINER\n\n镜像维护者的姓名和邮箱地址\n\n```dockerfile\n## 非必须\nMAINTAINER ZhangSan zs@163.com\n```\n\n### RUN\n\n容器构建时需要运行的命令。\n\n有两种格式：\n\n- shell格式\n\n```dockerfile\n## 等同于在终端操作的shell命令\n## 格式：RUN <命令行命令>\nRUN yum -y install vim\n```\n\n\n- exec格式\n\n```dockerfile\n## 格式：RUN [\"可执行文件\" , \"参数1\", \"参数2\"]\nRUN [\"./test.php\", \"dev\", \"offline\"]  ## 等价于 RUN ./test.php dev offline\n```\n\n\n\n`RUN`是在`docker build`时运行\n\n### EXPOSE\n\n当前容器对外暴露出的端口。\n\n```dockerfile\n## EXPOSE 要暴露的端口\n## EXPOSE <port>[/<protocol] ....\nEXPOSE 3306 33060\n```\n\n### WORKDIR\n\n指定在创建容器后， 终端默认登录进来的工作目录。\n\n```dockerfile\nENV CATALINA_HOME /usr/local/tomcat\nWORKDIR $CATALINA_HOME\n```\n\n### USER\n\n指定该镜像以什么样的用户去执行，如果不指定，默认是`root`。（一般不修改该配置）\n\n```dockerfile\n## USER <user>[:<group>]\nUSER patrick\n```\n\n### ENV\n\n用来在构建镜像过程中设置环境变量。\n\n这个环境变量可以在后续的任何`RUN`指令或其他指令中使用\n\n```dockerfile\n## 格式 ENV 环境变量名 环境变量值\n## 或者 ENV 环境变量名=值\nENV MY_PATH /usr/mytest\n\n## 使用环境变量\nWORKDIR $MY_PATH\n```\n\n### VOLUME\n\n容器数据卷，用于数据保存和持久化工作。类似于 `docker run` 的`-v`参数。\n\n```dockerfile\n## VOLUME 挂载点\n## 挂载点可以是一个路径，也可以是数组（数组中的每一项必须用双引号）\nVOLUME /var/lib/mysql\n```\n\n### ADD\n\n将宿主机目录下（或远程文件）的文件拷贝进镜像，且会自动处理URL和解压tar压缩包。\n\n### COPY\n\n类似`ADD`，拷贝文件和目录到镜像中。\n\n将从构建上下文目录中`<源路径>`的文件目录复制到新的一层镜像内的`<目标路径>`位置。\n\n```dockerfile\nCOPY src dest\nCOPY [\"src\", \"dest\"]\n## <src源路径>：源文件或者源目录\n## <dest目标路径>：容器内的指定路径，该路径不用事先建好。如果不存在会自动创建\n```\n\n### CMD\n\n指定容器启动后要干的事情。\n\n有两种格式：\n\n- shell格式\n\n```dockerfile\n## CMD <命令>\nCMD echo \"hello world\"\n```\n\n\n- exec格式\n\n```dockerfile\n## CMD [\"可执行文件\", \"参数1\", \"参数2\" ...]\nCMD [\"catalina.sh\", \"run\"]\n```\n\n\n- 参数列表格式\n\n```dockerfile\n## CMD [\"参数1\", \"参数2\" ....]，与ENTRYPOINT指令配合使用\n```\n\n\n\nDockerfile中如果出现多个`CMD`指令，只有最后一个生效。`CMD`会被`docker run`之后的参数替换。\n\n例如，对于tomcat镜像，执行以下命令会有不同的效果：\n\n```shell\n## 因为tomcat的Dockerfile中指定了 CMD [\"catalina.sh\", \"run\"]\n## 所以直接docker run 时，容器启动后会自动执行 catalina.sh run\ndocker run -it -p 8080:8080 tomcat\n\n## 指定容器启动后执行 /bin/bash\n## 此时指定的/bin/bash会覆盖掉Dockerfile中指定的 CMD [\"catalina.sh\", \"run\"]\ndocker run -it -p 8080:8080 tomcat /bin/bash\n```\n\n`CMD`是在`docker run`时运行，而 `RUN`是在`docker build`时运行。\n\n### ENTRYPOINT\n\n用来指定一个容器启动时要运行的命令。\n\n类似于`CMD`命令，但是`ENTRYPOINT`不会被`docker run`后面的命令覆盖，这些命令参数会被当做参数送给`ENTRYPOINT`指令指定的程序。\n\n`ENTRYPOINT`可以和`CMD`一起用，一般是可变参数才会使用`CMD`，这里的`CMD`等于是在给`ENTRYPOINT`传参。\n\n当指定了`ENTRYPOINT`后，`CMD`的含义就发生了变化，不再是直接运行期命令，而是将`CMD`的内容作为参数传递给`ENTRYPOINT`指令，它们两个组合会变成 `<ENTRYPOINT> \"<CMD>\"`。\n\n例如：\n\n```dockerfile\nFROM nginx\n\nENTRYPOINT [\"nginx\", \"-c\"]  ## 定参\nCMD [\"/etc/nginx/nginx.conf\"] ## 变参\n```\n\n对于此Dockerfile，构建成镜像 `nginx:test`后，如果执行；\n\n- `docker run nginx test`，则容器启动后，会执行 `nginx -c /etc/nginx/nginx.conf`\n- `docker run nginx:test /app/nginx/new.conf`，则容器启动后，会执行 `nginx -c /app/nginx/new.conf`\n\n## 构建镜像\n\n创建名称为`Dockerfile`的文件，示例：\n\n```dockerfile\nFROM ubuntu\nMAINTAINER lee<lee@xxx.com>\n\nENV MYPATH /usr/local\nWORKDIR $MYPATH\n\nRUN apt-get update\nRUN apt-get install net-tools\n\nEXPOSE 80\n\nCMD echo $MYPATH\nCMD echo \"install ifconfig cmd into ubuntu success .....\"\nCMD /bin/bash\n```\n\n编写完成之后，将其构建成docker镜像。\n\n命令：\n\n```shell\n## 注意：定义的TAG后面有个空格，空格后面有个点\n## docker build -t 新镜像名字:TAG .\ndocker build -t ubuntu:1.0.1 .\n```\n\n## 虚悬镜像\n\n虚悬镜像：仓库名、标签名都是 `<none>`的镜像，称为 dangling images（虚悬镜像）。\n\n在构建或者删除镜像时可能由于一些错误导致出现虚悬镜像。\n\n例如：\n\n```shell\n## 构建时候没有镜像名、tag\ndocker build .\n```\n\n列出docker中的虚悬镜像：\n\n```shell\ndocker image ls -f dangling=true\n```\n\n虚悬镜像一般是因为一些错误而出现的，没有存在价值，可以删除：\n\n```shell\n## 删除所有的虚悬镜像\ndocker image prune\n```\n\n\n\n\n\n# **12-Docker发布微服务**\n\n## 搭建SpringBoot项目\n\n搭建一个简单的SpringBoot项目：\n\n1.  创建maven工程，pom为： \n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.6</version>\n    </parent>\n\n    <groupId>org.study</groupId>\n    <artifactId>test-docker</artifactId>\n    <packaging>pom</packaging>\n    <version>1.0-SNAPSHOT</version>\n    <modules>\n        <module>docker_boot</module>\n    </modules>\n\n    <properties>\n        <maven.compiler.source>8</maven.compiler.source>\n        <maven.compiler.target>8</maven.compiler.target>\n    </properties>\n\n</project>\n```\n\n\n2.  新建Module，pom为： \n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <parent>\n        <artifactId>test-docker</artifactId>\n        <groupId>org.study</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>docker_boot</artifactId>\n\n    <properties>\n        <maven.compiler.source>8</maven.compiler.source>\n        <maven.compiler.target>8</maven.compiler.target>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n\n3.  编写一个配置文件 \n\n```yaml\nserver:\n  port: 6001\n```\n\n\n4.  编写主启动类 \n\n```java\npackage com.study;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n/**\n * @author tengyer 2022/05/06 16:34\n */\n@SpringBootApplication\npublic class DockerBootApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(DockerBootApplication.class, args);\n    }\n}\n```\n\n\n5.  编写一个Controller \n\n```java\npackage com.study.controller;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.UUID;\n\n/**\n * @author tengyer 2022/05/06 16:35\n */\n@RestController\npublic class OrderController {\n    @Value(\"${server.port}\")\n    private String port;\n\n    @RequestMapping(\"/order/docker\")\n    public String helloDocker() {\n        return \"hello world \\t\" + port + \"\\t\" + UUID.randomUUID().toString();\n    }\n\n    @RequestMapping(value = \"/order/index\", method = RequestMethod.GET)\n    public String index() {\n        return \"服务端口号：\" + \"\\t\" + port + \"\\t\" + UUID.randomUUID().toString();\n    }\n}\n```\n\n\n在Idea中运行没有问题时，将其使用maven的`package`打成jar包。\n\n## 发布微服务项目到Docker容器\n\n1.  将项目jar包上传到服务器 \n2.  编写Dockerfile \n\n```dockerfile\nFROM openjdk:8-oracle\nMAINTAINER lee\n\n## 在主机 /var/lib/docker目录下创建一个临时文件，并链接到容器的 /tmp\nVOLUME /tmp\n\n## 将jar包添加到容器中，并命名为 springboot_docker.jar\nADD docker_boot-1.0-SNAPSHOT.jar /springboot_docker.jar\n## 运行jar包\nRUN bash -c 'touch /springboot_docker.jar'\nENTRYPOINT [\"java\", \"-jar\", \"/springboot_docker.jar\"]\n\n## SpringBoot项目配置的端口号为6001，需要将6001暴露出去\nEXPOSE 6001\n```\n\n\n3.  构建镜像 \n\n```shell\ndocker build -t springboot_docker:1.0 .\n```\n\n\n4.  启动容器： \n\n```shell\ndocker run -d -p 6001:6001 --name springboot springboot_docker:1.0\n```\n\n\n\n\n\n# **13-Docker网络**\n\n## Docker 网络\n\ndocker安装并启动服务后，会在宿主机中添加一个虚拟网卡。\n\n在Docker服务启动前，使用 `ifconfig` 或 `ip addr` 查看网卡信息：\n\n- `ens33`或`eth0`：本机网卡\n- `lo`：本机回环网络网卡\n- 可能有`virbr0`（CentOS安装时如果选择的有相关虚拟化服务，就会多一个以网桥连接的私网地址的`virbr0`网卡，作用是为连接虚拟网卡提供NAT访问外网的功能。如果要移除该服务，可以使用 `yum remove libvirt-libs.x86_64`）\n\n使用 `systemctl start docker`启动Docker服务后，会多出一个 `docker0` 网卡。\n\n作用：\n\n- 容器间的互联和通信以及端口映射\n- 容器IP变动时候可以通过服务名直接网络通信而不受到影响\n\nDocker容器的网络隔离，是通过Linux内核特性 `namespace`和 `cgroup` 实现的。\n\n## docker网络命令\n\n查看Docker网络模式：\n\n```shell\ndocker network ls\n```\n\n如果没有修改过docker network，则默认有3个网络模式：\n\n- `bridge`\n- `host`\n- `none`\n\n添加Docker网络：\n\n```shell\ndocker network add xxx\n```\n\n删除Docker网络：\n\n```shell\ndocker network rm xxx\n```\n\n查看网络元数据：\n\n```shell\ndocker network inspect xxx\n```\n\n删除所有无效的网络：\n\n```shell\ndocker network prune\n```\n\n## Docker 网络模式\n\nDocker 的网络模式：\n\n| 网络模式               | 简介                                                         | 使用方式                             |\n| ---------------------- | ------------------------------------------------------------ | ------------------------------------ |\n| bridge                 | 为每一个容器分配、设置IP等，并将容器连接到一个`docker0`      |                                      |\n| 虚拟网桥，默认为该模式 | `--network bridge`                                           |                                      |\n| host                   | 容器将不会虚拟出自己的网卡、配置自己的IP等，而是使用宿主机的IP和端口 | `--network host`                     |\n| none                   | 容器有独立的 Network namespace，但并没有对齐进行任何网络设置，如分配 `veth pari` |                                      |\n| 和 网桥连接、IP等      | `--network none`                                             |                                      |\n| container              | 新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP、端口范围等 | `--network container:NAME或者容器ID` |\n\n\n查看某个容器的网络模式：\n\n```shell\n## 通过inspect获取容器信息，最后20行即为容器的网络模式信息\ndocker inspect 容器ID | tail -n 20\n```\n\n## docker0\n\nDocker 服务默认会创建一个`docker0`网桥（其上有一个`docker0`内部接口），该桥接网络的名称为 `docker0`，它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。\n\nDocker默认指定了`docker0`接口的IP地址和子网掩码，让主机和容器之间可以通过网桥互相通信。\n\n查看`bridge`网络的详细信息，并通过`grep`获取名称：\n\n```shell\ndocker network inspect bridge | grep name\n```\n\n可以看到其名称为`docker0`。\n\n## bridge模式\n\nDocker使用Linux桥接，在宿主机虚拟一个`Docker`容器网桥（`docker0`），Docker启动一个容器时会根据`Docker`网桥的网段分配给容器一个IP地址，称为`Container-IP`，同时Docker网桥是每个容器的默认网关。因为在同一个宿主机内的容器接入同一个网桥，这样容器之间就能够通过容器的`Container-IP`直接通信。\n\n`docker run`的时候，没有指定`--network`的话，默认使用的网桥模式就是`bridge`，使用的就是`docker0`。在宿主机`ifconfig`就苦役看到`docker0`和自己`create`的`network`。\n\n网桥`docker0`创建一对对等虚拟设备接口，一个叫`veth`，另一个叫`eth0`，成对匹配：\n\n整个宿主机的网桥模式都是`docker0`，类似一个交换机有一堆接口，每个接口叫 `veth`，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫做 `veth pair`）。\n\n每个容器实例内部也有一块网卡，容器内的网卡接口叫做`eth0`。\n\n`docker0`上面的每个`veth`匹配某个容器实例内部的`eth0`，两两配对，一一匹配。\n\n![bridge.webp](./Image/Docker基础教程.assets/cd8f07d6ac544ce7835ae74bd9b80820_MD5.webp)\n\n例如：\n\n启动tomcat容器，进入tomcat容器后，执行 `ip addr`，可以看到其网卡信息：\n\n```\n1: lo ..................\n\n容器内的网卡为 eth0\n@符号后面就是宿主机上对应的veth网卡的编号28\n27: eth0@if28 ...............................\n```\n\n在宿主机执行 `ip addr` 查看宿主机网卡信息：\n\n```\n每个veth都有个编号：vethXXXXXX\n@符号后面对应就是容器内的eth0网卡编号27\n\n28: vethXXXXXX@if27  ................\n```\n\n## host模式\n\n直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行 NAT 转换。\n\n容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network space。\n\n容器将不会虚拟出自己的网卡，而是直接使用宿主机的 IP 和端口。\n\n![host.webp](./Image/Docker基础教程.assets/63f6262760caa29031ee1a797830f732_MD5.webp)\n\n如果在 `docker run` 命令中同时使用了 `--network host` 和 `-p`端口映射，例如：\n\n```shell\ndocker run -p 8082:8080 --network host tomcat\n```\n\n那么会出现一个警告：\n\n```\nWARNING: Published ports are discarded when using host network mode\n```\n\n因为此时已经使用了`host`模式，本身就是直接使用的宿主机的IP和端口，此时的`-p`端口映射就没有了意义，也不会生效，端口号还是会以主机端口号为主。\n\n正确做法是：不再进行`-p`端口映射，或者改用`bridge`模式\n\n## none模式\n\n禁用网络功能。\n\n在`none`模式下，并不为docker容器进行任何网络配置。进入容器内，使用 `ip addr`查看网卡信息，只能看到 `lo`（本地回环网络`127.0.0.1`网卡）。\n\n## container模式\n\n新建的容器和已经存在的一个容器共享网络IP配置，而不是和宿主机共享。\n\n新创建的容器不会创建自己的网卡、IP，而是和一个指定的容器共享IP、端口范围。两个容器除了网络共享，其他的如文件系统、进程列表依然是隔离的。\n\n![container.webp](./Image/Docker基础教程.assets/2658eab8f1c13fe0bc2cf4d5a4371ef2_MD5.webp)\n\n示例：\n\n```shell\ndocker run -it --name alpine1 alpine /bin/sh\n\n## 指定和 alpine1 容器共享网络\ndocker run -it --netrowk container:alpine1 --name alpine2 alpine /bin/sh\n```\n\n此时使用 `ip addr`查看两台容器的网络，会发现两台容器的`eth0`网卡内的IP等信息完全相同。\n\n如果关掉了`alpine1`容器，因为`alpine2`的网络使用的`alpine1`共享网络，所以关掉`alpin1`后，`alpine2`的`eth0`网卡也随之消失了。\n\n## 自定义网络\n\n容器间的互联和通信以及端口映射。\n\n容器 IP 变动时候可以通过服务名直接网络通信而不受影响。（类似Eureka，通过服务名直接互相通信，而不是写死IP地址）。\n\n> docker中还有一个 `--link` 进行容器网络互联，但是已经被标记为过时的，可能会在将来的版本中移除这个功能。推荐使用自定义网络替换link。\n\n\n自定义桥接网络（自定义网络默认使用的是桥接网络 `bridge`）：\n\n1.  新建自定义网络 \n\n```shell\ndocker network create tomcat_network\n```\n\n\n2.  查看网络列表 \n\n```shell\ndocker network ls\n```\n\n\n3.  创建容器时，指定加入我们自定义的网络中 \n\n```shell\ndocker run -d -p 8081:8080 --network tomcat_network --name tomcat1 tomcat:8.5-jdk8-corretto\n\ndocker run -d -p 8082:8080 --network tomcat_network --name tomcat2 tomcat:8.5-jdk8-corretto\n```\n\n\n4.  此时进入`tomcat1`中，使用`ping`命令测试连接`tomcat2`容器名，发现可以正常连通 \n\n```shell\n## 安装ifconfig命令\nyum install -y net-tools\n## 安装ip addr命令\nyum install -y iproute\n## 安装ping命令\nyum install -y iputils\n\n## 直接ping容器名，不需要ping IP地址\nping tomcat2\n```\n\n\n## link连接\n\n示例：\n\n```shell\n## 启动一台mysql容器\n## --name 为容器指定一个别名\ndocker run --name mysql-matomo -p 3308:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:8.0.28\n\n## 启动另一个容器，通过--link连接到mysql容器\n## --link 容器名称:本容器连接对方时的别名\ndocker run -d -p 8888:80 --link mysql-matomo:db --name matomo matomo:4.9.0\n\n## 此时，在matomo容器中，便可以通过 db 这个hostname连接到mysql-matomo容器，而无须再通过ip\n## 连接地址：db:3306\n```\n\n\n\n# **14-Docker-compose容器编排**\n\n## Docker-compose\n\n`Docker-Compose` 是 Docker 官方的开源项目，负责实现对Docker容器集群的快速编排。\n\n`Docker-Compose`可以管理多个Docker容器组成一个应用。需要定义一个yaml格式的配置文件 `docker-compose.yml`，配置好多个容器之间的调用关系，然后只需要一个命令就能同时启动/关闭这些容器。\n\nDocker建议我们每个容器中只运行一个服务，因为Docker容器本身占用资源极少，所以最好是将每个服务单独的分割开来。但是如果我们需要同时部署多个服务，每个服务单独构建镜像构建容器就会比较麻烦。所以 Docker 官方推出了 `docker-compose` 多服务部署的工具。\n\nCompose允许用户通过一个单独的 `docker-compose.yml` 模板文件来定义一组相关联的应用容器为一个项目（`project`）。可以很容易的用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。\n\n核心概念：\n\n- 服务（`service`）：一个个应用容器实例\n- 工程（`project`）：由一组关联的应用容器组成的一个完整业务单元，在`docker-compose.yml`中定义\n\nCompose使用的三个步骤：\n\n1. 编写 Dockerfile 定义各个应用容器，并构建出对应的镜像文件\n2. 编写 `docker-compose.yml`，定义一个完整的业务单元，安排好整体应用中的各个容器服务\n3. 执行 `docker-compose up` 命令，其创建并运行整个应用程序，完成一键部署上线\n\n## 安装Docker-Compose\n\n`Docker-Compose`的版本需要和Docker引擎版本对应，可以参照官网上的[对应关系](https://docs.docker.com/compose/compose-file/compose-file-v3/)。\n\n安装Compose：\n\n```shell\n## 例如从github下载 2.5.0版本的docker-compose\n## 下载下来的文件放到 /usr/local/bin目录下，命名为 docker-compose\ncurl -L https://github.com/docker/compose/releases/download/v2.5.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose\n\n## 添加权限\nchmod +x /usr/local/bin/docker-compose\n\n## 验证\ndocker-compose version\n```\n\n卸载Compose：直接删除 `usr/local/bin/docker-compose`文件即可\n\n## 常用命令\n\n执行命令时，需要在对应的`docker-compose.yml`文件所在目录下执行。\n\n查看帮助：\n\n```shell\ndocker-compose -h\n```\n\n创建并启动`docker-compose`服务：（类似 `docker run`）\n\n```shell\ndocker-compose up\n\n## 后台运行\ndocker-compose up -d\n```\n\n停止并删除容器、网络、卷、镜像：（类似 `docker stop` +  `docker rm`）\n\n```shell\ndocker-compose down\n```\n\n进入容器实例内部：\n\n```shell\ndocker-compose exec <yml里面的服务id> /bin/bash\n```\n\n展示当前`docker-compose`编排过的运行的所有容器：\n\n```shell\ndocker-compose ps\n```\n\n展示当前`docker-compose`编排过的容器进程：\n\n```shell\ndocker-compose top\n```\n\n查看容器输出日志：\n\n```shell\ndocker-compose log <yml里面的服务id>\n```\n\n检查配置：\n\n```shell\ndocker-compose config\n\n## 有问题才输出\ndocker-compose config -q\n```\n\n重启服务：\n\n```shell\ndocker-compose restart\n```\n\n启动服务：（类似 `docker start`）\n\n```shell\ndocker-compose start\n```\n\n停止服务：\n\n```shell\ndocker-compose stop\n```\n\n## compose编排实例\n\n示例：\n\n```yaml\n## docker-compose文件版本号\nversion: \"3\"\n\n## 配置各个容器服务\nservices:\n  microService:\n    image: springboot_docker:1.0\n    container_name: ms01  ## 容器名称，如果不指定，会生成一个服务名加上前缀的容器名\n    ports:\n      - \"6001:6001\"\n    volumes:\n      - /app/microService:/data\n    networks:\n      - springboot_network\n    depends_on:  ## 配置该容器服务所依赖的容器服务\n      - redis\n      - mysql\n\n  redis:\n    image: redis:6.0.8\n    ports:\n      - \"6379:6379\"\n    volumes:\n      - /app/redis/redis.conf:/etc/redis/redis.conf\n      - /app/redis/data:data\n    networks:\n      - springboot_network\n    command: redis-server /etc/redis/redis.conf\n\n  mysql:\n    image: mysql:5.7\n    environment:\n      MYSQL_ROOT_PASSWORD: '123456'\n      MYSQL_ALLOW_EMPTY_PASSWORD: 'no'\n      MYSQL_DATABASE: 'db_springboot'\n      MYSQL_USER: 'springboot'\n      MYSQL_PASSWORD: 'springboot'\n    ports:\n      - \"3306:3306\"\n    volumes:\n      - /app/mysql/db:/var/lib/mysql\n      - /app/mysql/conf/my.cnf:/etc/my.cnf\n      - /app/mysql/init:/docker-entrypoint-initdb.d\n    networks:\n      - springboot_network\n    command: --default-authentication-plugin=mysql_native_password ## 解决外部无法访问\n\nnetworks:\n  ## 创建 springboot_network 网桥网络\n  springboot_network:\n```\n\n编写完成`docker-compose.yml`后，进行语法检查：\n\n```shell\n## 进行语法检查\ndocker-compose config -q\n```\n\n如果语法检查没有任何问题，进行创建、启动：\n\n```shell\ndocker-compose up -d\n```\n\n\n\n# **15-Portainer轻量级图形化监控**\n\n## Portainer：Docker轻量级可视化工具\n\nPortainer是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。\n\nPortainer分为开源社区版（CE版）和商用版（BE版/EE版）。\n\n## 安装\n\nPortainer也是一个Docker镜像，可以直接使用Docker运行。\n\n```shell\n## 旧版镜像地址为portainer/portainer，从2022年1月标记为过期\n## 新版镜像地址为portainer/portainer-ce\n\n## --restart=always 如果Docker引擎重启了，那么这个容器实例也会在Docker引擎重启后重启，类似开机自启\ndocker run -d -p 8000:8000 -p 9000:9000 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.13.0-alpine\n```\n\n启动之后，便可以在浏览器中进行访问：[http://xxx.xxx.xxx.xxx:9000](http://xxx.xxx.xxx.xxx:9000)\n\n首次进来时，需要创建 admin 的用户名（默认`admin`）、密码（必须满足校验规则，例如`portainer.io123`）。\n\n选择 `local`管理本地docker，即可看到本地Docker的详细信息，包括其中的镜像（images）、容器（containers）、网络（networks）、容器卷（volumes）、compose编排（stacks）等等。\n\n\n\n# 16-CIG重量级监控\n\n  CIG\n\n通过`docker stats` 命令可以很方便的查看当前宿主机上所有容器的CPU、内存、网络流量等数据，可以满足一些小型应用。\n但是 `docker stats` 统计结果只能是当前宿主机的全部容器，数据资料是实时的，没有地方存储、没有健康指标过线预警等功能。\n\nCAdvisor（监控收集） + InfluxDB（存储数据） + Granfana（展示图表），合称 `CIG`。\n![CIG.png](./Image/Docker基础教程.assets/df1ac8b7415831139ff3487a4c3c47ea_MD5.png)\n\n### CAdvisor\n\nCAdvisor是一个容器资源监控工具，包括容器的内存、CPU、网络IO、磁盘IO等监控，同时提供了一个Web页面用于查看容器的实时运行状态。\n\nCAdvisor默认存储2分钟的数据，而且只是针对单物理机。不过CAdvisor提供了很多数据集成接口，支持 InfluxDB、Redis、Kafka、Elasticsearch等集成，可以加上对应配置将监控数据发往这些数据库存储起来。\n\nCAdvisor主要功能：\n\n- 展示Host和容器两个层次的监控数据\n- 展示历史变化数据\n\n### InfluxDB\n\nInfluxDB是用Go语言编写的一个开源分布式时序、事件和指标数据库，无需外部依赖。\n\nCAdvisor默认只在本机保存2分钟的数据，为了持久化存储数据和统一收集展示监控数据，需要将数据存储到InfluxDB中。InfluxDB是一个时序数据库，专门用于存储时序相关数据，很适合存储 CAdvisor 的数据。而且 CAdvisor本身已经提供了InfluxDB的集成方法，在启动容器时指定配置即可。\n\nInfluxDB主要功能：\n\n- 基于时间序列，支持与时间有关的相关函数（如最大、最小、求和等）\n- 可度量性，可以实时对大量数据进行计算\n- 基于事件，支持任意的事件数据\n\n### Granfana\n\nGrafana是一个开源的数据监控分析可视化平台，支持多种数据源配置（支持的数据源包括InfluxDB、MySQL、Elasticsearch、OpenTSDB、Graphite等）和丰富的插件及模板功能，支持图表权限控制和报警。\n\nGranfana主要功能：\n\n- 灵活丰富的图形化选项\n- 可以混合多种风格\n- 支持白天和夜间模式\n- 多个数据源\n\n## 安装部署\n\n1.  编写`docker-compose.yml`服务编排文件 \n\n```yaml\nversion: '3.1'\n\nvolumes:\n  grafana_data: {}\n\nservices:\n  influxdb:\n\t## tutum/influxdb 相比influxdb多了web可视化视图。但是该镜像已被标记为已过时\n    image: tutum/influxdb:0.9\n    restart: always\n    environment:\n      - PRE_CREATE_DB=cadvisor\n    ports:\n      - \"8083:8083\"         ## 数据库web可视化页面端口\n      - \"8086:8086\"         ## 数据库端口\n    volumes:\n      - ./data/influxdb:/data\n\n  cadvisor:\n    image: google/cadvisor:v0.32.0\n    links:\n      - influxdb:influxsrv\n    command:\n      - -storage_driver=influxdb\n      - -storage_driver_db=cadvisor\n      - -storage_driver_host=influxsrv:8086\n    restart: always\n    ports:\n      - \"8080:8080\"\n    volumes:\n      - /:/rootfs:ro\n      - /var/run:/var/run:rw\n      - /sys:/sys:ro\n      - /var/lib/docker/:/var/lib/docker:ro\n\n  grafana:\n    image: grafana/grafana:8.5.2\n    user: '104'\n    restart: always\n    links:\n      - influxdb:influxsrv\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - grafana_data:/var/lib/grafana\n    environment:\n      - HTTP_USER=admin\n      - HTTP_PASS=admin\n      - INFLUXDB_HOST=influxsrv\n      - INFLUXDB_PORT=8086\n```\n\n\n2.  检查语法 \n\n```shell\ndocker-compose config -q\n```\n\n\n3.  创建并启动容器 \n\n```shell\ndocker-compose up -d\n```\n\n\n容器启动之后：\n\n1.  在浏览器打开InfluxDB数据库的页面： http://xxx.xxx.xxx.xxx:8083，使用命令查看当前数据库中的数据库实例： \n\n```\nSHOW DATABASES\n```\n\n查看其中是否自动创建了我们在配置文件中配置的 `cadvisor` 数据库实例 \n\n2.  在浏览器打开CAdvisor页面：http://xxx.xxx.xxx.xxx8080/，查看当前docker中的cpu、内存、网络IO等统计信息 \n3.  在浏览器打开Grafana页面：http://xxx.xxx.xxx.xxx:3000/，默认用户名密码是：`admin`/`admin`。 \n\n## Grafana配置\n\n### 添加数据源\n\n在`Configuration`（小齿轮）选项卡中，选择`Data Sources`，添加一个InfluxDB数据源：\n\n- name：自定义一个数据源名称，例如`InfluxDB`\n- Query Language：查询语言，默认`InfluxQL`即可\n- URL：根据compose中的容器服务名连接，`http://influxdb:8086`\n- database：我们在InfluxDB中创建的数据库实例，`cadvisor`\n- User：InfluxDB的默认用户，`root`\n- Password：`root`\n\n保存并测试，可以连通即可\n\n### 添加工作台\n\n1.  在`Create`（加号）选项卡中，选择创建 `Dash Board`工作台。右上角配置中可以配置创建出来的工作台的标题、文件夹等信息。 \n2.  在创建出来的工作台中，选择`Add panel`中的`Add a new panel`添加一个新的面板。 \n    1. 在右上角`Time series`（时序图）位置可以切换展示的图表样式（柱状图、仪表盘、表格、饼图等等）\n    2. 右侧边栏为该图表配置相关信息：标题、描述\n    3. 图表下方可以配置该图表展示的数据的查询语句，例如： \n       - FROM：`cpu_usage_total`（Grafana会自动获取InfluxDB数据库中的元数据，可以直接选择对应表名）\n       - WHERE：添加一个条件，`container_name=cig-cadvisor-1`\n       - ALIAS：配置一个别名，`CPU使用情况汇总`%%  %%","tags":["protected","Docker","基础教程"],"categories":["Dockert"]},{"title":"MC010智能插座核心控制板引脚定义","url":"/2023/11/26/MC010智能插座核心控制板引脚定义/","content":"\n## 其中的模块\n\n### 电源板\n\n![image-20231126135731025](./Image/mc010.assets/image-20231126135731025.png)\n\n\n\n### 控制小板\n\n![image-20231126131408979](./Image/mc010.assets/image-20231126131408979.png)\n\n![image-20231126131706449](./Image/mc010.assets/image-20231126131706449.png)\n\n\n\n### 引脚定义\n\n| 引脚号（橙色数字） | 功能(参照esp12f)                                             |\n| ------------------ | ------------------------------------------------------------ |\n| 1                  | vcc（3.3v）                                                  |\n| 2                  | gnd                                                          |\n| 3                  | 空                                                           |\n| 4                  | 空                                                           |\n| 5                  | 空                                                           |\n| 6                  | txd                                                          |\n| 7                  | 串联了一个2k的电阻到达GPIO12，并且经过一个3.3k的电阻下拉到地。控制继电器吸合 |\n| 8                  | GPIO0                                                        |\n| 9                  | RST                                                          |\n| 10                 | RXD                                                          |\n| 11                 |                                                              |\n\n- 按键\n  - 一边接地，一边经过一个1k电阻连接到GPIO13，同时被一个100k的电阻上拉到vcc\n    - ![image-20231201195333951](./Image/mc010.assets/image-20231201195333951.png)\n- 四个指示灯P1 P2 W1 W2\n  - 四个灯有一端全部连接至vcc\n    - 四个箭头所指的位置均是vcc\n    - ![image-20231201195637404](./Image/mc010.assets/image-20231201195637404.png)\n  - W1、W2分别串联了一个510r的电阻连接到GPIO4\n    - ![image-20231201200331134](./Image/mc010.assets/image-20231201200331134.png)\n  - P1 P2分别串联了一个2K的电阻然后连接到GPIO5\n    - ![image-20231201200819364](./Image/mc010.assets/image-20231201200819364.png)\n- 7引脚\n  - 经过一个2k的电阻到达GPIO12，同时被3.3k的电阻下拉到地\n    - ![image-20231201201532606](./Image/mc010.assets/image-20231201201532606.png)\n  - 同时通过这个引脚控制外部继电器吸合。当此引脚为高电平时，继电器吸合，当此引脚为低电平的时候，继电器断开。\n\n\n\n\n\n98 CD AC 3D 10 39\n\npython esptool.py --baud 115200 --port COM6 read_flash 0x00000 0x100000 dump.bin\n\npython \n\n\n\nesptool --chip esp8266 --baud 115200 --port COM6 read_flash 0x00000 0x100000 dump_1M.bin\n\nesptool --chip esp8266 --baud 115200 --port COM6 read_flash 0x00000 0x200000 dump_2M.bin\n\nesptool --chip esp8266 --baud 115200 --port COM6 read_flash 0x00000 0x400000 dump_4M.bin\n\nesptool.py read_flash 0x0 0x1000 dump.bin","tags":["protected","ESP8266","智能插座","魔改","刷机"],"categories":["ESP8266","智能插座"]},{"title":"二手硬盘选购找坡指南","url":"/2023/11/17/二手硬盘选购找坡指南/","content":"\n# 二手硬盘选购找坡指南\n\n1. 以迈拓为代表的ide并口硬盘\n\n   - 概述\n     - 这种硬盘属于很古老的产品了, 还健在的话，使用时间已经是几万小时了, 盘片也存在老化的风险, 并且IDE并口已经基本找不到了。\n\n2. 西数假黑盘：500G - 1T\n\n   - 原因\n\n     - 这类硬盘往往在闲鱼上标注“全新”、“库存全新”等, 但是这些所谓的“全新”, 基本上都是维修盘或清零的, 清零自不用说，通电几万小时的硬盘, 清零后当全新出售, 而维修盘，则是原本其他型号的硬盘, 经过维修之后，抹掉原来的信息, 篡改硬盘型号，贴上假标签, 由于修改非常彻底, 在硬盘软件中只硬盘型号是看不出马脚的, 切勿在闲鱼贪小便宜吃大亏。\n\n   - 概述\n\n     - 闲鱼上标注为\"全新\"、\"库存全新\"的硬盘往往是维修盘或清零处理过的。维修盘是其他型号的硬盘经过维修后，抹掉原来的信息，篡改型号贴上假标签。这些修改非常彻底，只有通过硬盘软件才能发现。购买这些硬盘可能会导致质量问题，请谨慎选择。\n\n   - 盘体照片\n\n     - 不存在统一的盘体，全部都有可能。\n\n     - ![image-20231117181043480](./Image/二手硬盘选购找坡指南.assets/image-20231117181043480.png)\n\n       \n\n3. 西数的神奇幸运发发发硬盘\n\n   - 原因\n     - 即808.8G容量的绿盘, 这个硬盘因为本身的缺陷, 不能做成1T容量的, 被西数的营销部门一通骚操作, 直接就割国人的韭菜了, 本身这个买的人也不多, 但是我要劝喜欢把888和发发发联系起来的朋友, 这个88是拜拜的意思，不要会错意。\n   - 概述\n     - 从1t盘阉割而来，屏蔽坏道和转速后降为808.8G（标准931G）。\n     - 质量本身就不行。\n   - 盘体照片\n     - ![image-20231117181148379](./Image/二手硬盘选购找坡指南.assets/image-20231117181148379.png)\n\n4. 酷鱼09年固件门\n\n   - 原因\n     - 这是希捷2009年的大雷——固件门的受害者之一, 固件门包括的型号有, 酷鱼7200.11、酷鱼ES.2 SATA、SV35系列, 轻则硬盘卡顿坏道，重则直接死亡变砖, 这件事也让很多人对希捷这个品牌敬而远之, 但值得指出的是, 大家买东西应该要看具体型号而非只认品牌, 选择正确型号的盘，才是制胜之道。\n   - 概述\n     - 注意型号：酷鱼7200.11、酷鱼ES.2 SATA、SV35系列\n   - 盘体照片\n     - ![image-20231117181408311](./Image/二手硬盘选购找坡指南.assets/image-20231117181408311.png)\n\n5. 希捷酷鱼ST1000DM010\n\n   - 原因\n     - 希捷为了省钱，采用磁头内停泊设计, 故障率偏高，并且同时阉割了RV（震动传感器）, 曾经出过无数经典型号的Barracuda酷鱼系列, 现在为了省钱，只剩一副空空的骨架了。\n   - 概述\n     - 磁头设计缺陷\n     - 采用了内停泊，还阉割了震动传感器。\n   - 盘体照片\n     - ![image-20231117181733582](./Image/二手硬盘选购找坡指南.assets/image-20231117181733582.png)\n\n6. 希捷酷鱼DM001、DM008系列\n\n   - 原因\n     - **包括2T和3T的版本**（包括ST2000DM001、ST3000DM001）, 这个版本的酷鱼问题在于磁头架材料有缺陷, 磁头会将盘片的涂层直接划伤, 如果不幸划伤了固件区，硬盘甚至会无法识别, 后面上的DM008是DM001的小改款, 但是治标不治本，依然会划伤盘片, 导致出现唱片一样的划痕, 并且这几块硬盘全部阉割了震动传感器, 从三个阉割到了一个。\n   - 概述\n     - 磁头架材料缺陷，会将涂层划伤\n     - 阉割了震动传感器\n   - 盘体照片\n     - ![image-20231117182241392](./Image/二手硬盘选购找坡指南.assets/image-20231117182241392.png)\n     - ![image-20231117182303831](./Image/二手硬盘选购找坡指南.assets/image-20231117182303831.png)\n\n7. 日立3T/4T（日立的翻新盘，也是目前最流行的翻新盘）\n\n   - 原因\n     - 这个应该是目前3T和4T的假盘中最流行的了, 这些硬盘都由日立（Hitachi）, 或日立环球【昱科】（HGST）生产, 已停产很长时间，特点是宽额头，左下角有三个螺丝孔, 因极其容易被清零, 所以成为各类翻车视频的常客。这个家伙从自己山寨自己, 到山寨成自己老板公司WD家的紫盘, 再到山寨成对手家希捷的酷鹰, 不所不能无孔不入, 最简单的避坑方法就是你不要去买这个盘体下这两个容量的硬盘, 另外现在西数出售的HC310、HC320、HC330等硬盘, 是西数收购HGST后的产品, 盘体与上述类似，细节略有不同（比如左下角及标签）, 并非是翻新产品，可以放心购买。\n   - 概述\n     - 特别容易被清零，慎买这个盘体中3-4T的硬盘（不局限品牌，因为品牌可以作假）\n   - 盘体照片\n     - ![image-20231117182507540](./Image/二手硬盘选购找坡指南.assets/image-20231117182507540.png)\n\n8. 西数的老企业级——RE和SE两个系列。\n\n   - 原因\n     - 这两款盘固件老, 很容易被维修和清零, 虽然是企业级硬盘，但是年久失修，很容易翻车, 因为这两款盘是黄黑或蓝黑标签, 贩子最喜欢的就是将这两款盘造假成黑盘出售, 这个盘体很好认，就是正面有一圈黑色的铝, 如果在闲鱼看到这个盘体的硬盘，请尽量避免购买。\n   - 概述\n     - 固件老, 很容易被维修和清零。\n     - 容易造假成黑盘出售\n   - 盘体照片\n     - ![image-20231117183013481](./Image/二手硬盘选购找坡指南.assets/image-20231117183013481.png)\n\n9. 希捷的绿圈盘（返修盘）\n\n   - 原因\n     - 这个盘是希捷的返修盘, 俗称R盘，返修盘是指硬盘曾经损坏, 原厂通过返修，再次上市, 无论是官方返修还是奸商私修, 盘片和磁头都有不确定性，所以不再建议购买了。\n   - 概述\n     - 硬盘返修赌人品。\n   - 盘体照片\n     - ![image-20231117183634717](./Image/二手硬盘选购找坡指南.assets/image-20231117183634717.png)\n\n10. OS盘\n\n    - 原因\n      - 由于smart信息中型号显示为oos, 同时标签上没有希捷logo，只有“OS”字体, 所以才叫这个名字, 这种盘是通过返修之后，依然不达到出厂标准, 理应被回收处理的电子垃圾级产品, 不仅没有官方保修，质量上更是一落千丈, 这种os盘不被官方承认，暴毙的风险也很大, 一些商家将os盘贴上银河的标签虚假销售, 一定要坚决抵制。\n    - 概述\n      - 电子垃圾级别的质量。\n    - 盘体照片\n      - ![image-20231117183804160](./Image/二手硬盘选购找坡指南.assets/image-20231117183804160.png)\n\n11. 西数的元素盘（Elements）(西数桌面移动硬盘)\n\n    - 原因\n      - 以西数的元素盘（Elements）为首的一系列3.5英寸桌面移动硬盘, 也包括Mybook系列等, 这种盘主要在海外亚马逊出售, 内部是西数的“OS级”硬盘, 是7200转的不合格企业级产品, 降速到5400转并屏蔽坏块得来的, 内部硬盘盒缺乏散热手段, 很容易导致硬盘温度过高, 并且由于保修限制, 目前在国内大概率是没办法得到厂家质保的, \n    - 概述\n      - 质量一般，没有质保\n    - 盘体照片\n      - ![image-20231117183944525](./Image/二手硬盘选购找坡指南.assets/image-20231117183944525.png)\n\n    \n\n## 2.5寸\n\n1. 希捷几个2.5寸SMR硬盘系列\n   - 原因\n     - 型号分别是**LM007、LM008、LM015、LM048**, 这几个系列使用同一个7mm厚度的盘体, 该盘体最大的问题在于设计缺陷, 磁头很容易划伤盘片, 这种盘体的硬盘, 在希捷2t及以下移动硬盘或酷鱼系列被广泛使用。出于数据安全的考虑, 建议大家尽量避开这些型号。\n   - 概述\n     - 叠瓦盘\n     - 磁头容易划伤盘片\n   - 盘体照片\n     - ![image-20231117184347889](./Image/二手硬盘选购找坡指南.assets/image-20231117184347889.png)\n2. 东芝MQ03系列 \n   - 原因\n     - 尽管它是难得的CMR硬盘, 但MQ03的为了开出更大容量, 加热器在温度低时启动（如25摄氏度以下）很容易受损, 具体表现为严重掉速和曲线失常, 这个系列常见于16-18年东芝移动硬盘, 型号例如MQ03UBB300, 十块盘中，可能有九块加热器都出现了或多或少的问题, 翻车率很高，尽量避免购买, \n   - 概述\n     - 故障率高，容易翻车\n   - 盘体照片\n     - ![image-20231117184817658](./Image/二手硬盘选购找坡指南.assets/image-20231117184817658.png)\n3. 东芝MQ04系列\n   - 原因\n     - 这是MQ03的继任者, 很不幸，他是叠瓦盘（SMR）, 尽管这款型号的速度相比西数、希捷的同类产品有些许优势, 然而叠瓦的策略很糟糕, 很容易脏盘（即速度巨大波动且下降）甚至卡死。夸张一点说，东芝的叠瓦盘算是“集大成者”, 将西数和希捷的叠瓦缺点集合在了一起, 因为东芝近年以来的出货率远不如西数和希捷, 统计故障率的数据样本不够, 很多硬盘的稳定性仍是一个问号, 但必须要指出，近两年的P300，品控极差, 请勿购买，请勿购买，请勿购买！（重要的事情说三遍）。\n   - 概述\n     - 叠瓦盘\n     - 叠瓦策略容易脏盘卡死\n   - 盘体照片\n     - ![image-20231117185037657](./Image/二手硬盘选购找坡指南.assets/image-20231117185037657.png)\n\n\n\n简要的说，希捷酷鱼不要买；叠瓦不要买；东芝慎重考虑；号称全新的硬盘也不要买。除非你知道你在干什么。同条件下不要考虑希捷。\n\n\n\n来源\n\n- https://www.bilibili.com/video/BV1TS4y1f7VN/\n","tags":["protected","知识杂谈","硬盘"],"categories":["硬盘","知识杂谈"]},{"title":"HTTP content-type","url":"/2023/11/05/HTTP_content_type/","content":"\n# HTTP content-type\n\nContent-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些 PHP 网页点击的结果却是下载一个文件或一张图片的原因。\n\nContent-Type 标头告诉客户端实际返回的内容的内容类型。\n\n语法格式：\n\n```http\nContent-Type: text/html; charset=utf-8\nContent-Type: multipart/form-data; boundary=something\n```\n\n实例：\n\n![img](./Image/HTTP_content_type.assets/F7E193D6-3C08-4B97-BAF2-FF340DAA5C6E.jpg)\n\n常见的媒体格式类型如下：\n\n- text/html ： HTML格式\n- text/plain ：纯文本格式\n- text/xml ： XML格式\n- image/gif ：gif图片格式\n- image/jpeg ：jpg图片格式\n- image/png：png图片格式\n\n以application开头的媒体格式类型：\n\n- application/xhtml+xml ：XHTML格式\n- application/xml： XML数据格式\n- application/atom+xml ：Atom XML聚合格式\n- application/json： JSON数据格式\n- application/pdf：pdf格式\n- application/msword ： Word文档格式\n- application/octet-stream ： 二进制流数据（如常见的文件下载）\n- application/x-www-form-urlencoded ： \\<form encType=\"\"\\>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）\n\n另外一种常见的媒体格式是上传文件之时使用的：\n\n- multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式\n\n------\n\n## HTTP content-type 对照表\n\n| 文件扩展名                          | Content-Type(Mime-Type)                 | 文件扩展名 | Content-Type(Mime-Type)             |\n| :---------------------------------- | :-------------------------------------- | :--------- | :---------------------------------- |\n| .*（ 二进制流，不知道下载文件类型） | application/octet-stream                | .tif       | image/tiff                          |\n| .001                                | application/x-001                       | .301       | application/x-301                   |\n| .323                                | text/h323                               | .906       | application/x-906                   |\n| .907                                | drawing/907                             | .a11       | application/x-a11                   |\n| .acp                                | audio/x-mei-aac                         | .ai        | application/postscript              |\n| .aif                                | audio/aiff                              | .aifc      | audio/aiff                          |\n| .aiff                               | audio/aiff                              | .anv       | application/x-anv                   |\n| .asa                                | text/asa                                | .asf       | video/x-ms-asf                      |\n| .asp                                | text/asp                                | .asx       | video/x-ms-asf                      |\n| .au                                 | audio/basic                             | .avi       | video/avi                           |\n| .awf                                | application/vnd.adobe.workflow          | .biz       | text/xml                            |\n| .bmp                                | application/x-bmp                       | .bot       | application/x-bot                   |\n| .c4t                                | application/x-c4t                       | .c90       | application/x-c90                   |\n| .cal                                | application/x-cals                      | .cat       | application/vnd.ms-pki.seccat       |\n| .cdf                                | application/x-netcdf                    | .cdr       | application/x-cdr                   |\n| .cel                                | application/x-cel                       | .cer       | application/x-x509-ca-cert          |\n| .cg4                                | application/x-g4                        | .cgm       | application/x-cgm                   |\n| .cit                                | application/x-cit                       | .class     | java/*                              |\n| .cml                                | text/xml                                | .cmp       | application/x-cmp                   |\n| .cmx                                | application/x-cmx                       | .cot       | application/x-cot                   |\n| .crl                                | application/pkix-crl                    | .crt       | application/x-x509-ca-cert          |\n| .csi                                | application/x-csi                       | .css       | text/css                            |\n| .cut                                | application/x-cut                       | .dbf       | application/x-dbf                   |\n| .dbm                                | application/x-dbm                       | .dbx       | application/x-dbx                   |\n| .dcd                                | text/xml                                | .dcx       | application/x-dcx                   |\n| .der                                | application/x-x509-ca-cert              | .dgn       | application/x-dgn                   |\n| .dib                                | application/x-dib                       | .dll       | application/x-msdownload            |\n| .doc                                | application/msword                      | .dot       | application/msword                  |\n| .drw                                | application/x-drw                       | .dtd       | text/xml                            |\n| .dwf                                | Model/vnd.dwf                           | .dwf       | application/x-dwf                   |\n| .dwg                                | application/x-dwg                       | .dxb       | application/x-dxb                   |\n| .dxf                                | application/x-dxf                       | .edn       | application/vnd.adobe.edn           |\n| .emf                                | application/x-emf                       | .eml       | message/rfc822                      |\n| .ent                                | text/xml                                | .epi       | application/x-epi                   |\n| .eps                                | application/x-ps                        | .eps       | application/postscript              |\n| .etd                                | application/x-ebx                       | .exe       | application/x-msdownload            |\n| .fax                                | image/fax                               | .fdf       | application/vnd.fdf                 |\n| .fif                                | application/fractals                    | .fo        | text/xml                            |\n| .frm                                | application/x-frm                       | .g4        | application/x-g4                    |\n| .gbr                                | application/x-gbr                       | .          | application/x-                      |\n| .gif                                | image/gif                               | .gl2       | application/x-gl2                   |\n| .gp4                                | application/x-gp4                       | .hgl       | application/x-hgl                   |\n| .hmr                                | application/x-hmr                       | .hpg       | application/x-hpgl                  |\n| .hpl                                | application/x-hpl                       | .hqx       | application/mac-binhex40            |\n| .hrf                                | application/x-hrf                       | .hta       | application/hta                     |\n| .htc                                | text/x-component                        | .htm       | text/html                           |\n| .html                               | text/html                               | .htt       | text/webviewhtml                    |\n| .htx                                | text/html                               | .icb       | application/x-icb                   |\n| .ico                                | image/x-icon                            | .ico       | application/x-ico                   |\n| .iff                                | application/x-iff                       | .ig4       | application/x-g4                    |\n| .igs                                | application/x-igs                       | .iii       | application/x-iphone                |\n| .img                                | application/x-img                       | .ins       | application/x-internet-signup       |\n| .isp                                | application/x-internet-signup           | .IVF       | video/x-ivf                         |\n| .java                               | java/*                                  | .jfif      | image/jpeg                          |\n| .jpe                                | image/jpeg                              | .jpe       | application/x-jpe                   |\n| .jpeg                               | image/jpeg                              | .jpg       | image/jpeg                          |\n| .jpg                                | application/x-jpg                       | .js        | application/x-javascript            |\n| .jsp                                | text/html                               | .la1       | audio/x-liquid-file                 |\n| .lar                                | application/x-laplayer-reg              | .latex     | application/x-latex                 |\n| .lavs                               | audio/x-liquid-secure                   | .lbm       | application/x-lbm                   |\n| .lmsff                              | audio/x-la-lms                          | .ls        | application/x-javascript            |\n| .ltr                                | application/x-ltr                       | .m1v       | video/x-mpeg                        |\n| .m2v                                | video/x-mpeg                            | .m3u       | audio/mpegurl                       |\n| .m4e                                | video/mpeg4                             | .mac       | application/x-mac                   |\n| .man                                | application/x-troff-man                 | .math      | text/xml                            |\n| .mdb                                | application/msaccess                    | .mdb       | application/x-mdb                   |\n| .mfp                                | application/x-shockwave-flash           | .mht       | message/rfc822                      |\n| .mhtml                              | message/rfc822                          | .mi        | application/x-mi                    |\n| .mid                                | audio/mid                               | .midi      | audio/mid                           |\n| .mil                                | application/x-mil                       | .mml       | text/xml                            |\n| .mnd                                | audio/x-musicnet-download               | .mns       | audio/x-musicnet-stream             |\n| .mocha                              | application/x-javascript                | .movie     | video/x-sgi-movie                   |\n| .mp1                                | audio/mp1                               | .mp2       | audio/mp2                           |\n| .mp2v                               | video/mpeg                              | .mp3       | audio/mp3                           |\n| .mp4                                | video/mpeg4                             | .mpa       | video/x-mpg                         |\n| .mpd                                | application/vnd.ms-project              | .mpe       | video/x-mpeg                        |\n| .mpeg                               | video/mpg                               | .mpg       | video/mpg                           |\n| .mpga                               | audio/rn-mpeg                           | .mpp       | application/vnd.ms-project          |\n| .mps                                | video/x-mpeg                            | .mpt       | application/vnd.ms-project          |\n| .mpv                                | video/mpg                               | .mpv2      | video/mpeg                          |\n| .mpw                                | application/vnd.ms-project              | .mpx       | application/vnd.ms-project          |\n| .mtx                                | text/xml                                | .mxp       | application/x-mmxp                  |\n| .net                                | image/pnetvue                           | .nrf       | application/x-nrf                   |\n| .nws                                | message/rfc822                          | .odc       | text/x-ms-odc                       |\n| .out                                | application/x-out                       | .p10       | application/pkcs10                  |\n| .p12                                | application/x-pkcs12                    | .p7b       | application/x-pkcs7-certificates    |\n| .p7c                                | application/pkcs7-mime                  | .p7m       | application/pkcs7-mime              |\n| .p7r                                | application/x-pkcs7-certreqresp         | .p7s       | application/pkcs7-signature         |\n| .pc5                                | application/x-pc5                       | .pci       | application/x-pci                   |\n| .pcl                                | application/x-pcl                       | .pcx       | application/x-pcx                   |\n| .pdf                                | application/pdf                         | .pdf       | application/pdf                     |\n| .pdx                                | application/vnd.adobe.pdx               | .pfx       | application/x-pkcs12                |\n| .pgl                                | application/x-pgl                       | .pic       | application/x-pic                   |\n| .pko                                | application/vnd.ms-pki.pko              | .pl        | application/x-perl                  |\n| .plg                                | text/html                               | .pls       | audio/scpls                         |\n| .plt                                | application/x-plt                       | .png       | image/png                           |\n| .png                                | application/x-png                       | .pot       | application/vnd.ms-powerpoint       |\n| .ppa                                | application/vnd.ms-powerpoint           | .ppm       | application/x-ppm                   |\n| .pps                                | application/vnd.ms-powerpoint           | .ppt       | application/vnd.ms-powerpoint       |\n| .ppt                                | application/x-ppt                       | .pr        | application/x-pr                    |\n| .prf                                | application/pics-rules                  | .prn       | application/x-prn                   |\n| .prt                                | application/x-prt                       | .ps        | application/x-ps                    |\n| .ps                                 | application/postscript                  | .ptn       | application/x-ptn                   |\n| .pwz                                | application/vnd.ms-powerpoint           | .r3t       | text/vnd.rn-realtext3d              |\n| .ra                                 | audio/vnd.rn-realaudio                  | .ram       | audio/x-pn-realaudio                |\n| .ras                                | application/x-ras                       | .rat       | application/rat-file                |\n| .rdf                                | text/xml                                | .rec       | application/vnd.rn-recording        |\n| .red                                | application/x-red                       | .rgb       | application/x-rgb                   |\n| .rjs                                | application/vnd.rn-realsystem-rjs       | .rjt       | application/vnd.rn-realsystem-rjt   |\n| .rlc                                | application/x-rlc                       | .rle       | application/x-rle                   |\n| .rm                                 | application/vnd.rn-realmedia            | .rmf       | application/vnd.adobe.rmf           |\n| .rmi                                | audio/mid                               | .rmj       | application/vnd.rn-realsystem-rmj   |\n| .rmm                                | audio/x-pn-realaudio                    | .rmp       | application/vnd.rn-rn_music_package |\n| .rms                                | application/vnd.rn-realmedia-secure     | .rmvb      | application/vnd.rn-realmedia-vbr    |\n| .rmx                                | application/vnd.rn-realsystem-rmx       | .rnx       | application/vnd.rn-realplayer       |\n| .rp                                 | image/vnd.rn-realpix                    | .rpm       | audio/x-pn-realaudio-plugin         |\n| .rsml                               | application/vnd.rn-rsml                 | .rt        | text/vnd.rn-realtext                |\n| .rtf                                | application/msword                      | .rtf       | application/x-rtf                   |\n| .rv                                 | video/vnd.rn-realvideo                  | .sam       | application/x-sam                   |\n| .sat                                | application/x-sat                       | .sdp       | application/sdp                     |\n| .sdw                                | application/x-sdw                       | .sit       | application/x-stuffit               |\n| .slb                                | application/x-slb                       | .sld       | application/x-sld                   |\n| .slk                                | drawing/x-slk                           | .smi       | application/smil                    |\n| .smil                               | application/smil                        | .smk       | application/x-smk                   |\n| .snd                                | audio/basic                             | .sol       | text/plain                          |\n| .sor                                | text/plain                              | .spc       | application/x-pkcs7-certificates    |\n| .spl                                | application/futuresplash                | .spp       | text/xml                            |\n| .ssm                                | application/streamingmedia              | .sst       | application/vnd.ms-pki.certstore    |\n| .stl                                | application/vnd.ms-pki.stl              | .stm       | text/html                           |\n| .sty                                | application/x-sty                       | .svg       | text/xml                            |\n| .swf                                | application/x-shockwave-flash           | .tdf       | application/x-tdf                   |\n| .tg4                                | application/x-tg4                       | .tga       | application/x-tga                   |\n| .tif                                | image/tiff                              | .tif       | application/x-tif                   |\n| .tiff                               | image/tiff                              | .tld       | text/xml                            |\n| .top                                | drawing/x-top                           | .torrent   | application/x-bittorrent            |\n| .tsd                                | text/xml                                | .txt       | text/plain                          |\n| .uin                                | application/x-icq                       | .uls       | text/iuls                           |\n| .vcf                                | text/x-vcard                            | .vda       | application/x-vda                   |\n| .vdx                                | application/vnd.visio                   | .vml       | text/xml                            |\n| .vpg                                | application/x-vpeg005                   | .vsd       | application/vnd.visio               |\n| .vsd                                | application/x-vsd                       | .vss       | application/vnd.visio               |\n| .vst                                | application/vnd.visio                   | .vst       | application/x-vst                   |\n| .vsw                                | application/vnd.visio                   | .vsx       | application/vnd.visio               |\n| .vtx                                | application/vnd.visio                   | .vxml      | text/xml                            |\n| .wav                                | audio/wav                               | .wax       | audio/x-ms-wax                      |\n| .wb1                                | application/x-wb1                       | .wb2       | application/x-wb2                   |\n| .wb3                                | application/x-wb3                       | .wbmp      | image/vnd.wap.wbmp                  |\n| .wiz                                | application/msword                      | .wk3       | application/x-wk3                   |\n| .wk4                                | application/x-wk4                       | .wkq       | application/x-wkq                   |\n| .wks                                | application/x-wks                       | .wm        | video/x-ms-wm                       |\n| .wma                                | audio/x-ms-wma                          | .wmd       | application/x-ms-wmd                |\n| .wmf                                | application/x-wmf                       | .wml       | text/vnd.wap.wml                    |\n| .wmv                                | video/x-ms-wmv                          | .wmx       | video/x-ms-wmx                      |\n| .wmz                                | application/x-ms-wmz                    | .wp6       | application/x-wp6                   |\n| .wpd                                | application/x-wpd                       | .wpg       | application/x-wpg                   |\n| .wpl                                | application/vnd.ms-wpl                  | .wq1       | application/x-wq1                   |\n| .wr1                                | application/x-wr1                       | .wri       | application/x-wri                   |\n| .wrk                                | application/x-wrk                       | .ws        | application/x-ws                    |\n| .ws2                                | application/x-ws                        | .wsc       | text/scriptlet                      |\n| .wsdl                               | text/xml                                | .wvx       | video/x-ms-wvx                      |\n| .xdp                                | application/vnd.adobe.xdp               | .xdr       | text/xml                            |\n| .xfd                                | application/vnd.adobe.xfd               | .xfdf      | application/vnd.adobe.xfdf          |\n| .xhtml                              | text/html                               | .xls       | application/vnd.ms-excel            |\n| .xls                                | application/x-xls                       | .xlw       | application/x-xlw                   |\n| .xml                                | text/xml                                | .xpl       | audio/scpls                         |\n| .xq                                 | text/xml                                | .xql       | text/xml                            |\n| .xquery                             | text/xml                                | .xsd       | text/xml                            |\n| .xsl                                | text/xml                                | .xslt      | text/xml                            |\n| .xwd                                | application/x-xwd                       | .x_b       | application/x-x_b                   |\n| .sis                                | application/vnd.symbian.install         | .sisx      | application/vnd.symbian.install     |\n| .x_t                                | application/x-x_t                       | .ipa       | application/vnd.iphone              |\n| .apk                                | application/vnd.android.package-archive | .xap       | application/x-silverlight-app       |","tags":["protected","HTTP"],"categories":["HTTP"]},{"title":"HTTP2 特点","url":"/2023/11/05/HTTP2特点/","content":"\n# HTTP2\n\n![img](./Image/HTTP2特点.assets/http2.svg)\n\nHTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），简称为h2（基于TLS/1.2或以上版本的加密连接）或h2c（非加密连接）， HTTP/2 是 HTTP 协议的第二个主要版本，用于在 Web 服务器和客户端之间传输数据。\n\nHTTP/2 是 HTTP 协议自 1999 年 HTTP 1.1 的改进版 RFC 发布后的首个更新，主要基于 SPDY 协议。\n\n多数主流浏览器已经在 2015 年底支持了该协议。\n\nHTTP/2是一种网络协议，是HTTP/1.1的升级版，由IETF在2015年发布。HTTP/2旨在提高Web性能，减少延迟，增加安全性，使Web应用更加快速、高效和可靠。\n\n![img](./Image/HTTP2特点.assets/http-timeline.png)\n\n------\n\n## HTTP/2 特点\n\n下面是 HTTP/2 的一些特点和改进之处：\n\n- 多路复用：HTTP/2 允许同时发送多个请求和响应，而不是像 HTTP/1.1 一样只能一个一个地处理。这样可以减少延迟，提高效率，提高网络吞吐量。\n- 二进制传输：HTTP/2 使用二进制协议，与 HTTP/1.1 使用的文本协议不同。二进制协议可以更快地解析，更有效地传输数据，减少了传输过程中的开销和延迟。\n- 头部压缩：HTTP/2 使用 HPACK 算法对 HTTP 头部进行压缩，减少了头部传输的数据量，从而减少了网络延迟。\n- 服务器推送：HTTP/2 支持服务器推送，允许服务器在客户端请求之前推送资源，以提高性能。\n- 改进的安全性：HTTP/2 默认使用 TLS（Transport Layer Security）加密传输数据，提高了安全性。\n- 兼容 HTTP/1.1：HTTP/2 可以与 HTTP/1.1 共存，服务器可以同时支持 HTTP/1.1 和 HTTP/2。如果客户端不支持 HTTP/2，服务器可以回退到 HTTP/1.1。\n\n总的来说，HTTP/2在性能、安全性和可用性方面都有显著的改进，可以使 Web 应用更加快速、高效和可靠。\n\n对数据传输采用多路复用，让多个请求合并在同一 TCP 连接内，如下图所示：\n\n![img](./Image/HTTP2特点.assets/6149cbd7fd4bdd7c82f55cc6_http1-vs-http2.png)\n\nHTTP/2 减少网络延迟，提高浏览器的页面加载速度：\n\n![img](./Image/HTTP2特点.assets/6149cc3eca0fb2c370604259_http1-vs-http2-responce-time.png)\n\nHTTP/2 使用二进制格式来传输数据，而不是像 HTTP/1.1 一样使用文本格式。这提高了效率并降低了数据传输的延迟。\n\n![img](./Image/HTTP2特点.assets/http2-binaryprotocol_lyaaiq.png)\n\nHTTP/2 使用头部压缩来减少传输数据的大小。这有助于减少网络带宽的使用量，并提高页面加载速度。\n\n![img](./Image/HTTP2特点.assets/133_0.jpeg)\n\nHTTP/2 允许服务器在不被请求的情况下主动向客户端发送数据。这有助于减少请求延迟，并提高页面加载速度。\n\n![img](./Image/HTTP2特点.assets/http2-push.png)","tags":["protected","HTTP","HTTP2"],"categories":["HTTP"]},{"title":"MIME类型及对照表","url":"/2023/11/05/MIME类型及对照表/","content":"\n# MIME 类型\n\nMIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的标准，用来表示文档、文件或字节流的性质和格式。\n\nMIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。\n\n浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理URL，因此 We b服务器在响应头中添加正确的 MIME 类型非常重要。如果配置不正确，浏览器可能会无法解析文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。\n\n### 语法\n\nMIME 类型通用结构：\n\n```http\ntype/subtype\n```\n\nMIME 的组成结构非常简单，由类型与子类型两个字符串中间用 **/** 分隔而组成，不允许有空格。type 表示可以被分多个子类的独立类别，subtype 表示细分后的每个类型。\n\nMIME类型对大小写不敏感，但是传统写法都是小写。\n\n两种主要的 MIME 类型在默认类型中扮演了重要的角色：\n\n- **text/plain** 表示文本文件的默认值。\n- **application/octet-stream** 表示所有其他情况的默认值。\n\n### 常见的 MIME 类型\n\n- 超文本标记语言文本 **.html、.html**：**text/html**\n- 普通文本 **.txt**： **text/plain**\n- RTF 文本 **.rtf**： **application/rtf**\n- GIF 图形 **.gif**： **image/gif**\n- JPEG 图形 **.jpeg、.jpg**： **image/jpeg**\n- au 声音文件 **.au**： **audio/basic**\n- MIDI 音乐文件 **mid、.midi**： **audio/midi、audio/x-midi**\n- RealAudio 音乐文件 **.ra、.ram**： **audio/x-pn-realaudio**\n- MPEG 文件 **.mpg、.mpeg**： **video/mpeg**\n- AVI 文件 **.avi**： **video/x-msvideo**\n- GZIP 文件 **.gz**： **application/x-gzip**\n- TAR 文件 **.tar**： **application/x-tar**\n\n| 类型          | 描述                                                         | 典型示例                                                     |\n| :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| `text`        | 表明文件是普通文本，理论上是人类可读                         | `text/plain`, `text/html`, `text/css, text/javascript`       |\n| `image`       | 表明是某种图像。不包括视频，但是动态图（比如动态gif）也使用image类型 | `image/gif`, `image/png`, `image/jpeg`, `image/bmp`, `image/webp`, `image/x-icon`, `image/vnd.microsoft.icon` |\n| `audio`       | 表明是某种音频文件                                           | `audio/midi`, `audio/mpeg, audio/webm, audio/ogg, audio/wav` |\n| `video`       | 表明是某种视频文件                                           | `video/webm`, `video/ogg`                                    |\n| `application` | 表明是某种二进制数据                                         | `application/octet-stream`, `application/pkcs12`, `application/vnd.mspowerpoint`, `application/xhtml+xml`, `application/xml`, `application/pdf` |\n\n## MIME 对照表\n\n| 媒体类型                                                     | 文件扩展名             | 说明                                                         |\n| :----------------------------------------------------------- | :--------------------- | :----------------------------------------------------------- |\n| **application/msword**                                       | doc                    | 微软 Office Word 格式（Microsoft Word 97 - 2004 document）   |\n| **application/vnd.openxmlformats-officedocument.wordprocessingml.document** | docx                   | 微软 Office Word 文档格式                                    |\n| **application/vnd.ms-excel**                                 | xls                    | 微软 Office Excel 格式（Microsoft Excel 97 - 2004 Workbook   |\n| **application/vnd.openxmlformats-officedocument.spreadsheetml.sheet** | xlsx                   | 微软 Office Excel 文档格式                                   |\n| **application/vnd.ms-powerpoint**                            | ppt                    | 微软 Office PowerPoint 格式（Microsoft PowerPoint 97 - 2003 演示文稿） |\n| **application/vnd.openxmlformats-officedocument.presentationml.presentation** | pptx                   | 微软 Office PowerPoint 文稿格式                              |\n| **application/x-gzip**                                       | gz, gzip               | GZ 压缩文件格式                                              |\n| **application/zip**                                          | zip, 7zip              | ZIP 压缩文件格式                                             |\n| **application/rar**                                          | rar                    | RAR 压缩文件格式                                             |\n| **application/x-tar**                                        | tar, tgz               | TAR 压缩文件格式                                             |\n| **application/pdf**                                          | pdf                    | PDF 是 Portable Document Format 的简称，即便携式文档格式     |\n| **application/rtf**                                          | rtf                    | RTF 是指 Rich Text Format，即通常所说的富文本格式            |\n| **image/gif**                                                | gif                    | GIF 图像格式                                                 |\n| **image/jpeg**                                               | jpg, jpeg              | JPG(JPEG) 图像格式                                           |\n| **image/jp2**                                                | jpg2                   | JPG2 图像格式                                                |\n| **image/png**                                                | png                    | PNG 图像格式                                                 |\n| **image/tiff**                                               | tif, tiff              | TIF(TIFF) 图像格式                                           |\n| **image/bmp**                                                | bmp                    | BMP 图像格式（位图格式）                                     |\n| **image/svg+xml**                                            | svg, svgz              | SVG 图像格式                                                 |\n| **image/webp**                                               | webp                   | WebP 图像格式                                                |\n| **image/x-icon**                                             | ico                    | ico 图像格式，通常用于浏览器 Favicon 图标                    |\n| **application/kswps**                                        | wps                    | 金山 Office 文字排版文件格式                                 |\n| **application/kset**                                         | et                     | 金山 Office 表格文件格式                                     |\n| **application/ksdps**                                        | dps                    | 金山 Office 演示文稿格式                                     |\n| **application/x-photoshop**                                  | psd                    | Photoshop 源文件格式                                         |\n| **application/x-coreldraw**                                  | cdr                    | Coreldraw 源文件格式                                         |\n| **application/x-shockwave-flash**                            | swf                    | Adobe Flash 源文件格式                                       |\n| **text/plain**                                               | txt                    | 普通文本格式                                                 |\n| **application/x-javascript**                                 | js                     | Javascript 文件类型                                          |\n| **text/javascript**                                          | js                     | 表示 Javascript 脚本文件                                     |\n| **text/css**                                                 | css                    | 表示 CSS 样式表                                              |\n| **text/html**                                                | htm, html, shtml       | HTML 文件格式                                                |\n| **application/xhtml+xml**                                    | xht, xhtml             | XHTML 文件格式                                               |\n| **text/xml**                                                 | xml                    | XML 文件格式                                                 |\n| **text/x-vcard**                                             | vcf                    | VCF 文件格式                                                 |\n| **application/x-httpd-php**                                  | php, php3, php4, phtml | PHP 文件格式                                                 |\n| **application/java-archive**                                 | jar                    | Java 归档文件格式                                            |\n| **application/vnd.android.package-archive**                  | apk                    | Android 平台包文件格式                                       |\n| **application/octet-stream**                                 | exe                    | Windows 系统可执行文件格式                                   |\n| **application/x-x509-user-cert**                             | crt, pem               | PEM 文件格式                                                 |\n| **audio/mpeg**                                               | mp3                    | mpeg 音频格式                                                |\n| **audio/midi**                                               | mid, midi              | mid 音频格式                                                 |\n| **audio/x-wav**                                              | wav                    | wav 音频格式                                                 |\n| **audio/x-mpegurl**                                          | m3u                    | m3u 音频格式                                                 |\n| **audio/x-m4a**                                              | m4a                    | m4a 音频格式                                                 |\n| **audio/ogg**                                                | ogg                    | ogg 音频格式                                                 |\n| **audio/x-realaudio**                                        | ra                     | Real Audio 音频格式                                          |\n| **video/mp4**                                                | mp4                    | mp4 视频格式                                                 |\n| **video/mpeg**                                               | mpg, mpe, mpeg         | mpeg 视频格式                                                |\n| **video/quicktime**                                          | qt, mov                | QuickTime 视频格式                                           |\n| **video/x-m4v**                                              | m4v                    | m4v 视频格式                                                 |\n| **video/x-ms-wmv**                                           | wmv                    | wmv 视频格式（Windows 操作系统上的一种视频格式）             |\n| **video/x-msvideo**                                          | avi                    | avi 视频格式                                                 |\n| **video/webm**                                               | webm                   | webm 视频格式                                                |\n| **video/x-flv**                                              | flv                    | 一种基于 flash 技术的视频格式                                |\n\n### 按照内容类型排列的 MIME 类型列表\n\n| 类型/子类型                             | 扩展名  |\n| :-------------------------------------- | :------ |\n| application/envoy                       | evy     |\n| application/fractals                    | fif     |\n| application/futuresplash                | spl     |\n| application/hta                         | hta     |\n| application/internet-property-stream    | acx     |\n| application/mac-binhex40                | hqx     |\n| application/msword                      | doc     |\n| application/msword                      | dot     |\n| application/octet-stream                | *       |\n| application/octet-stream                | bin     |\n| application/octet-stream                | class   |\n| application/octet-stream                | dms     |\n| application/octet-stream                | exe     |\n| application/octet-stream                | lha     |\n| application/octet-stream                | lzh     |\n| application/oda                         | oda     |\n| application/olescript                   | axs     |\n| application/pdf                         | pdf     |\n| application/pics-rules                  | prf     |\n| application/pkcs10                      | p10     |\n| application/pkix-crl                    | crl     |\n| application/postscript                  | ai      |\n| application/postscript                  | eps     |\n| application/postscript                  | ps      |\n| application/rtf                         | rtf     |\n| application/set-payment-initiation      | setpay  |\n| application/set-registration-initiation | setreg  |\n| application/vnd.ms-excel                | xla     |\n| application/vnd.ms-excel                | xlc     |\n| application/vnd.ms-excel                | xlm     |\n| application/vnd.ms-excel                | xls     |\n| application/vnd.ms-excel                | xlt     |\n| application/vnd.ms-excel                | xlw     |\n| application/vnd.ms-outlook              | msg     |\n| application/vnd.ms-pkicertstore         | sst     |\n| application/vnd.ms-pkiseccat            | cat     |\n| application/vnd.ms-pkistl               | stl     |\n| application/vnd.ms-powerpoint           | pot     |\n| application/vnd.ms-powerpoint           | pps     |\n| application/vnd.ms-powerpoint           | ppt     |\n| application/vnd.ms-project              | mpp     |\n| application/vnd.ms-works                | wcm     |\n| application/vnd.ms-works                | wdb     |\n| application/vnd.ms-works                | wks     |\n| application/vnd.ms-works                | wps     |\n| application/winhlp                      | hlp     |\n| application/x-bcpio                     | bcpio   |\n| application/x-cdf                       | cdf     |\n| application/x-compress                  | z       |\n| application/x-compressed                | tgz     |\n| application/x-cpio                      | cpio    |\n| application/x-csh                       | csh     |\n| application/x-director                  | dcr     |\n| application/x-director                  | dir     |\n| application/x-director                  | dxr     |\n| application/x-dvi                       | dvi     |\n| application/x-gtar                      | gtar    |\n| application/x-gzip                      | gz      |\n| application/x-hdf                       | hdf     |\n| application/x-internet-signup           | ins     |\n| application/x-internet-signup           | isp     |\n| application/x-iphone                    | iii     |\n| application/x-javascript                | js      |\n| application/x-latex                     | latex   |\n| application/x-msaccess                  | mdb     |\n| application/x-mscardfile                | crd     |\n| application/x-msclip                    | clp     |\n| application/x-msdownload                | dll     |\n| application/x-msmediaview               | m13     |\n| application/x-msmediaview               | m14     |\n| application/x-msmediaview               | mvb     |\n| application/x-msmetafile                | wmf     |\n| application/x-msmoney                   | mny     |\n| application/x-mspublisher               | pub     |\n| application/x-msschedule                | scd     |\n| application/x-msterminal                | trm     |\n| application/x-mswrite                   | wri     |\n| application/x-netcdf                    | cdf     |\n| application/x-netcdf                    | nc      |\n| application/x-perfmon                   | pma     |\n| application/x-perfmon                   | pmc     |\n| application/x-perfmon                   | pml     |\n| application/x-perfmon                   | pmr     |\n| application/x-perfmon                   | pmw     |\n| application/x-pkcs12                    | p12     |\n| application/x-pkcs12                    | pfx     |\n| application/x-pkcs7-certificates        | p7b     |\n| application/x-pkcs7-certificates        | spc     |\n| application/x-pkcs7-certreqresp         | p7r     |\n| application/x-pkcs7-mime                | p7c     |\n| application/x-pkcs7-mime                | p7m     |\n| application/x-pkcs7-signature           | p7s     |\n| application/x-sh                        | sh      |\n| application/x-shar                      | shar    |\n| application/x-shockwave-flash           | swf     |\n| application/x-stuffit                   | sit     |\n| application/x-sv4cpio                   | sv4cpio |\n| application/x-sv4crc                    | sv4crc  |\n| application/x-tar                       | tar     |\n| application/x-tcl                       | tcl     |\n| application/x-tex                       | tex     |\n| application/x-texinfo                   | texi    |\n| application/x-texinfo                   | texinfo |\n| application/x-troff                     | roff    |\n| application/x-troff                     | t       |\n| application/x-troff                     | tr      |\n| application/x-troff-man                 | man     |\n| application/x-troff-me                  | me      |\n| application/x-troff-ms                  | ms      |\n| application/x-ustar                     | ustar   |\n| application/x-wais-source               | src     |\n| application/x-x509-ca-cert              | cer     |\n| application/x-x509-ca-cert              | crt     |\n| application/x-x509-ca-cert              | der     |\n| application/ynd.ms-pkipko               | pko     |\n| application/zip                         | zip     |\n| audio/basic                             | au      |\n| audio/basic                             | snd     |\n| audio/mid                               | mid     |\n| audio/mid                               | rmi     |\n| audio/mpeg                              | mp3     |\n| audio/x-aiff                            | aif     |\n| audio/x-aiff                            | aifc    |\n| audio/x-aiff                            | aiff    |\n| audio/x-mpegurl                         | m3u     |\n| audio/x-pn-realaudio                    | ra      |\n| audio/x-pn-realaudio                    | ram     |\n| audio/x-wav                             | wav     |\n| image/bmp                               | bmp     |\n| image/cis-cod                           | cod     |\n| image/gif                               | gif     |\n| image/ief                               | ief     |\n| image/jpeg                              | jpe     |\n| image/jpeg                              | jpeg    |\n| image/jpeg                              | jpg     |\n| image/pipeg                             | jfif    |\n| image/svg+xml                           | svg     |\n| image/tiff                              | tif     |\n| image/tiff                              | tiff    |\n| image/x-cmu-raster                      | ras     |\n| image/x-cmx                             | cmx     |\n| image/x-icon                            | ico     |\n| image/x-portable-anymap                 | pnm     |\n| image/x-portable-bitmap                 | pbm     |\n| image/x-portable-graymap                | pgm     |\n| image/x-portable-pixmap                 | ppm     |\n| image/x-rgb                             | rgb     |\n| image/x-xbitmap                         | xbm     |\n| image/x-xpixmap                         | xpm     |\n| image/x-xwindowdump                     | xwd     |\n| message/rfc822                          | mht     |\n| message/rfc822                          | mhtml   |\n| message/rfc822                          | nws     |\n| text/css                                | css     |\n| text/h323                               | 323     |\n| text/html                               | htm     |\n| text/html                               | html    |\n| text/html                               | stm     |\n| text/iuls                               | uls     |\n| text/plain                              | bas     |\n| text/plain                              | c       |\n| text/plain                              | h       |\n| text/plain                              | txt     |\n| text/richtext                           | rtx     |\n| text/scriptlet                          | sct     |\n| text/tab-separated-values               | tsv     |\n| text/webviewhtml                        | htt     |\n| text/x-component                        | htc     |\n| text/x-setext                           | etx     |\n| text/x-vcard                            | vcf     |\n| video/mpeg                              | mp2     |\n| video/mpeg                              | mpa     |\n| video/mpeg                              | mpe     |\n| video/mpeg                              | mpeg    |\n| video/mpeg                              | mpg     |\n| video/mpeg                              | mpv2    |\n| video/quicktime                         | mov     |\n| video/quicktime                         | qt      |\n| video/x-la-asf                          | lsf     |\n| video/x-la-asf                          | lsx     |\n| video/x-ms-asf                          | asf     |\n| video/x-ms-asf                          | asr     |\n| video/x-ms-asf                          | asx     |\n| video/x-msvideo                         | avi     |\n| video/x-sgi-movie                       | movie   |\n| x-world/x-vrml                          | flr     |\n| x-world/x-vrml                          | vrml    |\n| x-world/x-vrml                          | wrl     |\n| x-world/x-vrml                          | wrz     |\n| x-world/x-vrml                          | xaf     |\n| x-world/x-vrml                          | xof     |\n\n### 按照文件扩展名排列的 MIME 类型列表\n\n| 扩展名  | 类型/子类型                             |\n| :------ | :-------------------------------------- |\n|         | application/octet-stream                |\n| 323     | text/h323                               |\n| acx     | application/internet-property-stream    |\n| ai      | application/postscript                  |\n| aif     | audio/x-aiff                            |\n| aifc    | audio/x-aiff                            |\n| aiff    | audio/x-aiff                            |\n| asf     | video/x-ms-asf                          |\n| asr     | video/x-ms-asf                          |\n| asx     | video/x-ms-asf                          |\n| au      | audio/basic                             |\n| avi     | video/x-msvideo                         |\n| axs     | application/olescript                   |\n| bas     | text/plain                              |\n| bcpio   | application/x-bcpio                     |\n| bin     | application/octet-stream                |\n| bmp     | image/bmp                               |\n| c       | text/plain                              |\n| cat     | application/vnd.ms-pkiseccat            |\n| cdf     | application/x-cdf                       |\n| cer     | application/x-x509-ca-cert              |\n| class   | application/octet-stream                |\n| clp     | application/x-msclip                    |\n| cmx     | image/x-cmx                             |\n| cod     | image/cis-cod                           |\n| cpio    | application/x-cpio                      |\n| crd     | application/x-mscardfile                |\n| crl     | application/pkix-crl                    |\n| crt     | application/x-x509-ca-cert              |\n| csh     | application/x-csh                       |\n| css     | text/css                                |\n| dcr     | application/x-director                  |\n| der     | application/x-x509-ca-cert              |\n| dir     | application/x-director                  |\n| dll     | application/x-msdownload                |\n| dms     | application/octet-stream                |\n| doc     | application/msword                      |\n| dot     | application/msword                      |\n| dvi     | application/x-dvi                       |\n| dxr     | application/x-director                  |\n| eps     | application/postscript                  |\n| etx     | text/x-setext                           |\n| evy     | application/envoy                       |\n| exe     | application/octet-stream                |\n| fif     | application/fractals                    |\n| flr     | x-world/x-vrml                          |\n| gif     | image/gif                               |\n| gtar    | application/x-gtar                      |\n| gz      | application/x-gzip                      |\n| h       | text/plain                              |\n| hdf     | application/x-hdf                       |\n| hlp     | application/winhlp                      |\n| hqx     | application/mac-binhex40                |\n| hta     | application/hta                         |\n| htc     | text/x-component                        |\n| htm     | text/html                               |\n| html    | text/html                               |\n| htt     | text/webviewhtml                        |\n| ico     | image/x-icon                            |\n| ief     | image/ief                               |\n| iii     | application/x-iphone                    |\n| ins     | application/x-internet-signup           |\n| isp     | application/x-internet-signup           |\n| jfif    | image/pipeg                             |\n| jpe     | image/jpeg                              |\n| jpeg    | image/jpeg                              |\n| jpg     | image/jpeg                              |\n| js      | application/x-javascript                |\n| latex   | application/x-latex                     |\n| lha     | application/octet-stream                |\n| lsf     | video/x-la-asf                          |\n| lsx     | video/x-la-asf                          |\n| lzh     | application/octet-stream                |\n| m13     | application/x-msmediaview               |\n| m14     | application/x-msmediaview               |\n| m3u     | audio/x-mpegurl                         |\n| man     | application/x-troff-man                 |\n| mdb     | application/x-msaccess                  |\n| me      | application/x-troff-me                  |\n| mht     | message/rfc822                          |\n| mhtml   | message/rfc822                          |\n| mid     | audio/mid                               |\n| mny     | application/x-msmoney                   |\n| mov     | video/quicktime                         |\n| movie   | video/x-sgi-movie                       |\n| mp2     | video/mpeg                              |\n| mp3     | audio/mpeg                              |\n| mpa     | video/mpeg                              |\n| mpe     | video/mpeg                              |\n| mpeg    | video/mpeg                              |\n| mpg     | video/mpeg                              |\n| mpp     | application/vnd.ms-project              |\n| mpv2    | video/mpeg                              |\n| ms      | application/x-troff-ms                  |\n| mvb     | application/x-msmediaview               |\n| nws     | message/rfc822                          |\n| oda     | application/oda                         |\n| p10     | application/pkcs10                      |\n| p12     | application/x-pkcs12                    |\n| p7b     | application/x-pkcs7-certificates        |\n| p7c     | application/x-pkcs7-mime                |\n| p7m     | application/x-pkcs7-mime                |\n| p7r     | application/x-pkcs7-certreqresp         |\n| p7s     | application/x-pkcs7-signature           |\n| pbm     | image/x-portable-bitmap                 |\n| pdf     | application/pdf                         |\n| pfx     | application/x-pkcs12                    |\n| pgm     | image/x-portable-graymap                |\n| pko     | application/ynd.ms-pkipko               |\n| pma     | application/x-perfmon                   |\n| pmc     | application/x-perfmon                   |\n| pml     | application/x-perfmon                   |\n| pmr     | application/x-perfmon                   |\n| pmw     | application/x-perfmon                   |\n| pnm     | image/x-portable-anymap                 |\n| pot,    | application/vnd.ms-powerpoint           |\n| ppm     | image/x-portable-pixmap                 |\n| pps     | application/vnd.ms-powerpoint           |\n| ppt     | application/vnd.ms-powerpoint           |\n| prf     | application/pics-rules                  |\n| ps      | application/postscript                  |\n| pub     | application/x-mspublisher               |\n| qt      | video/quicktime                         |\n| ra      | audio/x-pn-realaudio                    |\n| ram     | audio/x-pn-realaudio                    |\n| ras     | image/x-cmu-raster                      |\n| rgb     | image/x-rgb                             |\n| rmi     | audio/mid                               |\n| roff    | application/x-troff                     |\n| rtf     | application/rtf                         |\n| rtx     | text/richtext                           |\n| scd     | application/x-msschedule                |\n| sct     | text/scriptlet                          |\n| setpay  | application/set-payment-initiation      |\n| setreg  | application/set-registration-initiation |\n| sh      | application/x-sh                        |\n| shar    | application/x-shar                      |\n| sit     | application/x-stuffit                   |\n| snd     | audio/basic                             |\n| spc     | application/x-pkcs7-certificates        |\n| spl     | application/futuresplash                |\n| src     | application/x-wais-source               |\n| sst     | application/vnd.ms-pkicertstore         |\n| stl     | application/vnd.ms-pkistl               |\n| stm     | text/html                               |\n| svg     | image/svg+xml                           |\n| sv4cpio | application/x-sv4cpio                   |\n| sv4crc  | application/x-sv4crc                    |\n| swf     | application/x-shockwave-flash           |\n| t       | application/x-troff                     |\n| tar     | application/x-tar                       |\n| tcl     | application/x-tcl                       |\n| tex     | application/x-tex                       |\n| texi    | application/x-texinfo                   |\n| texinfo | application/x-texinfo                   |\n| tgz     | application/x-compressed                |\n| tif     | image/tiff                              |\n| tiff    | image/tiff                              |\n| tr      | application/x-troff                     |\n| trm     | application/x-msterminal                |\n| tsv     | text/tab-separated-values               |\n| txt     | text/plain                              |\n| uls     | text/iuls                               |\n| ustar   | application/x-ustar                     |\n| vcf     | text/x-vcard                            |\n| vrml    | x-world/x-vrml                          |\n| wav     | audio/x-wav                             |\n| wcm     | application/vnd.ms-works                |\n| wdb     | application/vnd.ms-works                |\n| wks     | application/vnd.ms-works                |\n| wmf     | application/x-msmetafile                |\n| wps     | application/vnd.ms-works                |\n| wri     | application/x-mswrite                   |\n| wrl     | x-world/x-vrml                          |\n| wrz     | x-world/x-vrml                          |\n| xaf     | x-world/x-vrml                          |\n| xbm     | image/x-xbitmap                         |\n| xla     | application/vnd.ms-excel                |\n| xlc     | application/vnd.ms-excel                |\n| xlm     | application/vnd.ms-excel                |\n| xls     | application/vnd.ms-excel                |\n| xlt     | application/vnd.ms-excel                |\n| xlw     | application/vnd.ms-excel                |\n| xof     | x-world/x-vrml                          |\n| xpm     | image/x-xpixmap                         |\n| xwd     | image/x-xwindowdump                     |\n| z       | application/x-compress                  |\n| zip     | application/zip                         |","tags":["protected","MIME"],"categories":["MIME"]},{"title":"视频格式基础知识","url":"/2023/08/10/视频格式基础知识/","content":"\n# 视频格式的基础知识 \n\n## 封装格式(MP4/MKV…)  vs 媒体格式(H.264/FLAC/AAC…)\n\n### 概述\n\n​\tMP4+MKV是下载的视频文件最常见的种类。这些文件其实类似一个包裹，它的后缀则是包裹的包装方式。\n\n​\t这些包裹里面，包含了视频（只有图像），音频（只有声音），字幕等。当播放器在播放的时候，首先对这个包裹进行拆包（专业术语叫做分离/splitting）,把其中的视频、音频等拿出来，再进行播放。\n\n​\t既然它们只是一个包裹，就意味着这个**后缀不能保证里面的东西**是啥，也**不能保证到底有多少东西**。包裹里面的每一件物品，我们称之为`轨道`(track)，一般有这么些： \n\n- 视频(Video): 一般来说肯定都有，但是也有例外，比如`mka`格式的外挂音轨，其实就是没视频的mkv。注意我们说到视频的时候，是不包括声音的。\n\n- 音频(Audio)：一般来说也肯定有，但是有些情况是静音的，就没必要带了。\n\n- 章节(Chapter): 蓝光原盘中自带的分段信息。如果文件带上了，那么你可以在播放器中看到带章节的效果：\n\n  - .potplayer右键画面，选项-播放-在进度条上显示书签/章节标记\n\n\n  - .mpc-hc 右键画面，选项-调节-在进度条显示章节标记\n\n\n- 字幕(Subtitles)：有些时候文件自带字幕，并且字幕并非是直接整合于视频的硬字幕，那么就是一起被打包在封装容器中。\n\n- 其他可能还有附件等，不一一列举。每个类型也不一定只有一条轨道，比如经常见到带多音轨的MKV。 \n\n\n​\t每个轨道，都有自己的格式。比如大家常说的，视频是H.264，音频是AAC，这些就是每个轨道的格式。\n\n​\t视频的格式，常见的有H.264(可以细分为8bit/10bit)，H.265(当前也有8bit/10bit之分)，RealVideo(常见于早期rm/rmvb)，VC-1(微软主导的，常见于wmv)。基本上，`H.264=AVC=AVC1`, `H.265=HEVC`。\n\n​\t音频的格式，常见的有 FLAC/ALAC/TrueHD/DTS-HD MA这四种无损，和AAC/MP3/AC3/DTS(Core)这四种有损。但请注意，如Flac格式的音频，只是支持无损，并不代表全部都是无损。比如将aac格式的音频转成flac，虽然格式变了，但其中的音频还是原来的有损。\n\n> 这里插播一个小的知识点，有损压缩是不可逆的，当信息丢失后，除非有辅助手段，否则丢失的信息是找不回来的。马赛克就可以视为一种局部的手动丢失信息的措施，因此经过打码的图片or视频是无法还原的，但可以使用ai都手段，“脑补”出打码之前的原始形态。\n\n \n\n## MKV vs MP4的主要区别\n\n- MKV支持封装FLAC作为音频，MP4则不支持。但是MP4也可以封装无损音轨(比如说ALAC，虽然普遍认为ALAC的效率不如FLAC优秀)\n- MKV支持封装ASS/SSA格式的字幕，MP4则不支持。一般字幕组制作的字幕是ASS格式，所以内封字幕多见于MKV格式\n- MP4作为工业标准，在视频编辑软件和播放设备上的兼容性一般好于MKV。这也是vcb-s那些为移动设备优化的视频基本上选择MP4封装的原因。\n\n​\t除此之外，这两个格式很大程度上可以互相代替。比如它们都支持封装AVC和HEVC，包括8bit/10bit的精度。所以所谓的MP4画质不如MKV好，这种论断是非常无知的——它们完全可以封装一样的视频。\n\n​\t为什么会有这样的分歧，就是历史原因了。MKV是民间研发，为了代替古老的AVI，从而更好地支持H264，它开发和修改的灵活度使得它可以兼容flac/ass这类非工业标准的格式；而MP4则是出生豪门，作为工业标准，替代更古老的MPG，作为新一代视频/音频封装服务的。\n\n## 视频的基础参数：分辨率，帧率和码率。\n\n​\t视频是由连续的图像构成的。每一张图像，我们称为一帧(frame)。图像则是由像素(pixel)构成的。一张图像有多少像素，称为这个图像的分辨率。比如说1920×1080的图像，说明它是由横纵1920×1080个像素点构成。视频的分辨率就是每一帧图像的分辨率。 \n\n​\t一个视频，每一秒由多少图像构成，称为这个视频的帧率(frame-rate)。常见的帧率有24000/1001=23.976, 30000/1001=29.970, 60000/1001=59.940, 25.000, 50.000等等。这个数字是一秒钟内闪过的图像的数量。比如23.976，就是1001秒内，有24000张图像。视频的帧率是可以是恒定的(cfr, Const Frame-Rate)，也可以是变化的(vfr, Variable Frame-Rate) \n\n​\t码率的定义是视频文件体积除以时间。单位一般是Kbps(Kbit/s)或者Mbps(Mbit/s)。注意1B(Byte)=8b(bit)。所以一个24分钟，900MB的视频：\n\n- 体积：900MB = 900MByte = 7200Mbit\n\n- 时间：24min = 1440s\n\n- 码率：7200/1440  = 5000 Kbps = 5Mbps\n\n\n\n\n当视频文件的时间基本相同的时候（比如现在一集番大概是24分钟），码率和体积基本上是等价的，都是用来描述视频大小的参数。长度分辨率都相同的文件，体积不同，实际上就是码率不同。\n\n码率也可以解读为单位时间内，用来记录视频的数据总量。码率越高的视频，意味着用来记录视频的数据量越多，潜在的解读就是视频可以拥有更好的质量。（注意，仅仅是潜在，后文我们会分析为什么高码率不一定等于高画质）\n\n\n\n## 图像的表示方法：RGB模型 vs YUV模型\n\n光的三原色是红(Red)、绿(Green)、蓝(Blue)。现代的显示器技术就是通过组合不同强度的三原色，来达成几乎任何一种可见光的颜色。图像储存中，通过记录每个像素红绿蓝强度，来记录图像的方法，称为RGB模型 (RGB Model)\n\n常见的图片格式中，PNG和BMP这两种就是基于RGB模型的。\n\n比如说原图：\n\n<img src=\"./Image/视频格式基础知识.assets/1691572378724.jpg\" alt=\"1691572378724\" style=\"zoom:50%;\" />\n\n分别只显示R G B通道的强度，效果如下：\n\n<img src=\"./Image/视频格式基础知识.assets/1691572704713.jpg\" alt=\"1691572704713\" style=\"zoom:50%;\" />\n\n<img src=\"./Image/视频格式基础知识.assets/1691572726393.jpg\" alt=\"1691572726393\" style=\"zoom:50%;\" />\n\n<img src=\"./Image/视频格式基础知识.assets/1691572736325.jpg\" alt=\"1691572736325\" style=\"zoom:50%;\" />\n\n\n\n​\t三个通道下，信息量和细节程度不一定是均匀分布的。比如说可以注意南小鸟脸上的红晕，在3个平面上的区分程度就不同——红色平面下几乎无从区分，造成区别的主要是绿色和蓝色的平面。外围白色的脸颊，三色都近乎饱和；但是红晕部分，只有红色饱和，绿色和蓝色不饱和。这是造成红色凸显的原因。 \n\n​\t除了RGB模型，还有一种广泛采用的模型，称为YUV模型，又被称为亮度-色度模型（Luma-Chroma）。它是通过数学转换，将RGB三个通道，转换为一个代表亮度的通道(Y,又称为Luma)，和两个代表色度的通道(UV，并成为Chroma)。\n\n​\t举个形象点的例子：一家养殖场饲养猪和牛，一种记数方式是：（猪的数量，牛的数量）\n\n​\t但是也可以这么记录：（总数量=猪的数量+牛的数量，相差=猪的数量-牛的数量）。两种方法之间有数学公式可以互转。\n\n \n\nYUV模型干的是类似的事儿。通过对RGB数据的合理转换，得到另一种表示方式。YUV模型下，还有不同的实现方式。举个用的比较多的YCbCr模型：它把RGB转换成一个亮度(Y)，和 蓝色色度(Cb) 以及 红色色度(Cr)。转换背后复杂的公式大家不需要了解，只需要看看效果：\n\n只有亮度通道：\n\n![1691572880955](./Image/视频格式基础知识.assets/1691572880955.jpg)\n\n只有蓝色色度：\n\n![1691572905520(1)](./Image/视频格式基础知识.assets/1691572905520(1).jpg)\n\n只有红色色度：\n\n![1691572923217](./Image/视频格式基础知识.assets/1691572923217.jpg)\n\n在图像视频的加工与储存中，YUV格式一般更受欢迎，理由如下： \n\n1、人眼对亮度的敏感度远高于色度，因此人眼看到的有效信息主要来自于亮度。YUV模型可以将绝大多数的有效信息分配到Y通道。UV通道相对记录的信息少的多。相对于RGB模型较为平均的分配，YUV模型将多数有效信息集中在Y通道，不但减少了冗余信息量，还为压缩提供了便利\n\n2、保持了对黑白显示设备的向下兼容\n\n3、图像编辑中，调节亮度和颜色饱和度，在YUV模型下更方便。\n\n几乎所有的视频格式，以及广泛使用的JPEG图像格式，都是基于YCbCr模型的。播放的时候，播放器需要将YCbCr的信息，通过计算，转换为RGB。这个步骤称为渲染（Rendering）\n\n每个通道的记录，通常是用整数来表示。比如RGB24，就是RGB各8个bit，用0~255 (8bit的二进制数范围)来表示某个颜色的强弱。YUV模型也不例外，也是用整数来表示每个通道的高低。\n\n \n\n## 色深\n\n\n色深(bit-depth)，就是我们通常说的8bit和10bit，是指每个通道的精度。8bit就是每个通道用一个8bit整数(0\\~255)代表，10bit就是用10bit整数(0\\~1023)来显示。16bit则是0~65535\n\n(注意，上文的表述是不严谨的，视频在编码的时候，并非一定能用到0\\~255的所有范围，而是可能有所保留，只用到一部分，比如16~235。这我们就不详细展开了) \n\n你的显示器是8bit的，代表它能显示RGB每个通道0~255所有强度。但是视频的色深是YUV的色深，播放的时候，YUV需要通过计算转换到RGB。因此，10bit的高精度是间接的，它使得运算过程中精度增加，以让最后的颜色更细腻。 \n\n如何理解8bit显示器，播放10bit是有必要的呢：\n\n- 一个圆的半径是12.33m, 求它的面积，保留两位小数。\n\n- 半径的精度给定两位小数，结果也要求两位小数，那么圆周率精度需要给多高呢？也只要两位小数么？\n  取pi=3.14, 面积算出来是477.37平方米\n  取pi=3.1416，面积算出来是477.61平方米\n  取pi精度足够高，面积算出来是477.61平方米。所以取pi=3.1416是足够的，但是3.14就不够了。 \n\n​\t换言之，即便最终输出的精度要求较低，也不意味着参与运算的数字，以及运算过程，可以保持较低的精度。在最终输出是8bit RGB的前提下，10bit YUV比起8bit YUV依旧具有精度优势的原因就在这里。事实上，8bit YUV转换后，覆盖的精度大概相当于8bit RGB的26%，而10bit转换后的精度大约可以覆盖97%——你想让你家8bit显示器发挥97%的细腻度么？看10bit吧。\n\n \n\n8bit精度不足，主要表现在亮度较低的区域，容易形成色带：\n\n![1691574105747](./Image/视频格式基础知识.assets/1691574105747.jpg)\n\n注意这图右边那一圈圈跟波浪一样的效果。这就是颜色精度不足的表现。\n\n10bit的优势不只在于显示精度的提高，在提高视频压缩率，减少失真方面，相对8bit也有优势。这方面就不展开了。\n\n\n\n## 色度半采样\n\n \n\n​\t在YUV模型的应用中，Y和UV的重要性是不等同的。图像视频的实际储存和传输中，通常将Y以全分辨率记录，UV以减半甚至1/4的分辨率记录。这个手段被称为色度半采样(Chroma Sub-Sampling)。色度半采样可以有效减少传输带宽，和加大UV平面的压缩率，但是不可避免的会损失UV平面的有效信息。 \n\n​\t我们平常的视频，最常见的是420采样。配合YUV格式，常常被写作yuv420。这种采样是Y保留全部，UV只以(1/2) x (1/2)的分辨率记录。比如说1920×1080的视频，其实只有亮度平面是1920×1080。两个色度平面都只有960×540的分辨率。\n\n​\t当然了，你也可以选择不做缩减。这种称为444采样，或者yuv444。YUV三个平面全是满分辨率。 \n\n​\t在做YUV->RGB的时候，首先需要将缩水的UV分辨率拉升到Y的分辨率（madVR中允许自定义算法，在Chroma Upscaling当中），然后再转换到RGB。做RGB->YUV的转换，也是先转换到444（YUV的分辨率相同），再将UV分辨率降低。 \n\n​\t一般能拿到的片源，包括所有蓝光原盘，都是420采样的。所以成品一般也保留420采样。所以yuv420就表示这个视频是420采样的yuv格式。\n\n​\t将420做成444格式，需要自己手动将UV分辨率拉升2×2倍。在今天madVR等渲染器可以很好地拉升UV平面的情况下，这种做法无异于毫无必要的拉升DVD做成伪高清。\n\n​\t当然了，有时候也需要在444/RGB平面下做处理和修复，常见的比如视频本身RGB平面不重叠（比如摩卡少女樱），这种修复过程首先要将UV分辨率拉升，然后转RGB，做完修复再转回YUV。修复后的结果相当于全新构图，这种情况下保留444格式就是有理由，有必要的。 \n\n​\tH264格式编码444格式，需要High 4:4:4 Predictive Profile（简称Hi444pp）。所以看到Hi444pp/yuv444 之类的标示，你就需要去找压制者的陈述，为什么他要做这么个拉升。如果找不到有效的理由，你应该默认作者是在瞎做。\n\n \n\n## 空间上的低频与高频：平面，纹理和线条\n\n在视频处理中，空间(spatial)的概念指的是一帧图片以内（你可以认为就是一张图所呈现的二维空间/平面）。跟时间(temporal)相对；时间的概念就强调帧与帧之间的变换。 \n\n于是我们重新来看这张亮度的图：\n\n![1691579919014](./Image/视频格式基础知识.assets/1691579919014.jpg)\n\n亮度变化较快，变动幅度大的区域，我们称之为高频区域。否则，亮度变化缓慢且不明显的区域，我们称为低频区域。 \n\n- 图中的蓝圈就是一块典型的低频区域，或者就叫做平面（平坦的部分）。亮度几乎没有变化\n- 绿圈中，亮度呈现跳跃式的突变，这种高频区域我们称之为线条。\n- 红圈中，亮度频繁变化，幅度有高有低，这种高频区域我们称为纹理。 \n\n有时候，线条和纹理（高频区域）统称为线条，平面（低频区域）又叫做非线条。 \n\n​\t这是亮度平面。色度平面，高频低频，线条等概念也同样适用，就是描述色度变化的快慢轻重。一般我们所谓的“细节”，就是指图像中的高频信息。\n\n​\t一般来说，一张图的高频信息越多，意味着这张图信息量越大，所需要记录的数据量就越多，编码所需要的运算量也越大。如果一个视频包含的空间性高频信息很多（通俗点说就是每一帧内细节很多），意味着这个视频的空间复杂度很高。\n\n​\t记录一张图片，编码器需要决定给怎样的部分多少码率。码率在一张图内不同部分的分配，叫做码率的空间分配。分配较好的时候，往往整幅图目视观感比较统一；分配不好常见的后果，就是线条纹理尚可，背景平面区域出现大量色带色块（码率被过分的分配给线条）；或者背景颜色过渡自然，纹理模糊，线条烂掉（码率被过分的分配给非线条）。\n\n \n\n## 时间上的低频与高频：动态\n\n在视频处理中，时间(temporal)的概念强调帧与帧之间的变换。跟空间(spatial)相对。\n\n​\t动态的概念无需多解释；就是帧与帧之间图像变化的强弱，变化频率的高低。一段视频如果动态很高，变化剧烈，我们称为时间复杂度较高，时域上的高频信息多。否则如果视频本身舒缓多静态，我们称为时间复杂度低，时域上的低频信息多。 \n\n​\t一般来说，一段视频的时域高频信息多，动态的信息量就大，所需要记录的数据量就越多，编码所需要的运算量也越大。但是另一方面，人眼对高速变化的场景，敏感度不如静态的图片来的高（你没有时间去仔细观察细节），所以动态场景的优先度可以低于静态场景。如何权衡以上两点去分配码率，被称为码率的时间分配。分配较好的时候，看视频无论动态还是静态效果都较好；分配不好的时候往往是静态部分看着还行，动态部分糊烂掉；或者动态部分效果过分的好，浪费了大量码率，造成静态部分欠码，瑕疵明显。\n\n​\t很多人喜欢看静止的截图对比，来判断视频的画质。从观看的角度，这种做法其实并不完全科学——如果你觉得比较烂的一帧其实是取自高动态场景，那么这一帧稍微烂点无可厚非，反正观看的时候你注意不到，将码率省下来给静态部分会更好。\n\n \n\n## 清晰度与画质简述 \n\n我们经常讨论，一个视频清晰度如何，画质好不好。但是如何给这两个术语做定义呢？ \n\n​\t经常看到的说法：“这个视频清晰度是1080p的”。其实看过上文你就应该知道，1080p只是视频的分辨率，它不能直接代表清晰度——比如说，我可以把一个480p的dvd视频拉升到1080p，那又怎样呢？它的清晰度难道就提高了么？ \n\n​\t一个比较接近清晰度的概念，是上文所讲述的，空间高频信息量，就是一帧内的细节。一张图，一个视频的细节多，它的清晰度就高。分辨率决定了高频信息量的上限；就是它最清晰能到什么地步。1080p之所以比480p好，是因为它可以允许图像记录的高频信息多。这个说法看样子很靠谱，但是，有反例：\n\n![1691580180363](./Image/视频格式基础知识.assets/1691580180363.jpg)\n\n​\t右图的高频信息远比左图多——它的线条很锐利，有大量致密的噪点（注意**噪点完全符合高频信息的定义**；它使得图像变化的非常快）\n\n​\t但是你真的觉得右图清晰度高么？\n\n​\t事实上，右图完全是通过左图加工而来。通过过度锐化+强噪点，人为的增加无效的高频信息。\n\n​\t所以清晰度的定义我更倾向于这样一个说法：图像或视频中，原生、有效的高频信息。\n原生，强调这种清晰度是非人工添加的；有效；强调细节本身有意义，而不是毫无意义的噪点特效。 \n\n​\t值得一提的是，人为增加的高频信息不见得完全没有帮助。有的时候适度锐化的确能够起到不错的目视效果：\n\n![1691580264115](./Image/视频格式基础知识.assets/1691580264115.jpg)\n\n​\t这是一幅适度锐化后的效果。如果有人觉得右图更好，至少某些部分更好，相信我，你不是一个人。所以适度锐化依旧是视频和图像处理中，可以接受的一种主观调整的手段，一定的场合下，它确实有助于提高目视效果。 \n\n​\t以上是清晰度的概述。注意，清晰度只是空间方面（就是一帧以内）。如果再考虑到动态效果的优秀与否（视频是不是那种一动起来就糊成一团的，或者动起来感觉卡顿明显的，常见于早起RMVB），空间和时间上优秀的观看效果共同定义了画质。所以我们说madVR/svp那些倍帧效果有助于提高画质，实际上它们增强了时间上的观看效果。 \n\n​\t好的画质，是制作者和观众共同追求的。怎么样的视频会有好的画质呢？是不是码率越高的视频画质越好呢？真不见得。视频的画质，是由以下几点共同决定的： \n\n1、源的画质。\n俗话说的好，上梁不正下梁歪。如果源的画质本身很差，那么再如何折腾都别指望画质好到哪去。所以压制者往往会选择更好的源进行压制——举个栗子，BDRip一般都比TVRip来的好，哪怕是720p。蓝光也分销售地区，一般日本销售的日版，画质上比美版、台版、港版啥的都来得好，所以同样是BDRip，选取更好的源，就能做到画质上优先一步。 \n\n2、播放条件。\n观众是否用了足矣支持高画质播放的硬件和软件。这就是为啥我们在发布Rip的同时大力普及好的播放器；有时候一个好的播放器胜过多少在制作方面的精力投入。 \n\n3、码率投入vs编码复杂度。\n视频的时间和空间复杂度，并称为编码复杂度。编码复杂度高的视频，往往细节多，动态高（比如《魔法少女小圆剧场版 叛逆的物语》），这样的视频天生需要较高的码率去维持一个优秀的观看效果。\n相反，有些视频编码复杂度低（比如《请问今天要来点兔子么》，动态少，线条细节柔和），这种视频就是比较节省码率的。 \n\n4、码率分配的效率和合理度。\n同样多的码率，能起到怎样好的效果，被称为效率。比如H264就比之前的RealVideo效率高；10bit比8bit效率高；编码器先进，参数设置的比较合理，编码器各种高端参数全开（通常以编码时间作为代价），码率效率就高。\n合理度就是码率在时空分配方面合理与否，合理的分配，给观众的观看效果就比较统一协调。 码率分配的效率和合理度，是对制作者的要求，要求制作者对片源分析，参数设置有比较到位的理解。\n\n码率分配和合理度做的好，就常常能做出低码率高画质的良心作品。 \n\n这里再多提一句，至少在这个时间点，也就是此文发布的2014年年底，HEVC相对于AVC可以提高50%的效率，依旧是一个纸面上的理论值。实际操作中，因为HEVC编码器的成熟度远不及经过了十几年发展的AVC编码器，导致现在HEVC的潜力远没有能发挥出来，特别是高画质下甚至不如。\n\n对于目前主流的，定位收藏画质的BDRip，同样码率下x265的画质相对于x264没有优势；所以在近期，大家不用优先的去下载HEVC版作为收藏目的，更不必迷信什么“码率降低一半”。再强调一次，这个时间点；如果一年后以上陈述被不断进步的HEVC编码器推翻，我毫不惊讶。 \n\n5、编码前的预处理。预处理分三种：\n\n①，客观修复。强调修复片源固有的瑕疵，比如锯齿，色带，晕轮等等。\n②，主观调整，强调将片源调整的更适合人眼观看，比如适度的锐化，调色（有时候你是可以通过科学方法判定片源的颜色有问题，然后针对的做修复的）。\n③，移除无效高频信息，比如降噪，避免码率浪费在无效的噪点上\n\n​\t预处理做的好，往往能达到画质上超越片源，或是在几乎不牺牲清晰度的前提下，节省码率开销。\n\n​\t但是预处理是一把双刃剑，优化的同时，可能引入副效果。降噪、抗锯齿、去晕轮等操作会不可避免的损失一些有效细节（或多或少，取决于制作者水准）；主观调整很可能会引入副效果（比如过度锐化会导致锯齿和晕轮），或是变成了作者的自我满足，形成对观众的欺骗。 \n\n​\t综上，一个优秀的画质，是由片源、制作者、观看者共同决定的；码率高低也只是部分因素，并非决定性的效果。\n\n\n\n\n\n# 播放器背后的知识\n\n## 播放器的工作流程：分离，解码，渲染\n\n简单说就三个大步骤：分离、解码、渲染。\n\n​\t分离，指的是拿到媒体文件(MKV/MP4/MKA)等，先收集相关的文件（包括外挂音轨、字幕），然后将所有轨道拆开，拆分成单独的内容。视频流、音频流、字幕、章节信息，等等。负责执行分离的模块滤镜，叫做分离器(splitter/demuxer)。\n\n​\t当同样类型的轨道不止一条的时候（比如多音轨），分离器还负责挑选其中的一条。通常同类型多轨道，会有一条轨道被设定为“默认轨”（比如多音轨MKV一般以主音轨为默认），你想选择副音轨，你就需要在分离器中手动切换。很多播放器会在自己的界面中提供音轨/字幕切换的功能，其实也是间接利用分离器实现的。\n\n​\t分离器现在能用的基本上只有LAV/ffmpeg了（这俩几乎可以算一家），以前还有个Haali，然而停止更新已久，不能适应HEVC时代了。\n\n​\t分离器一般不耗费运算性能。因为它只是简单地收集、拆分和选择。\n\n \n\n​\t解码，指的是将分离器丢来的各种原生压缩格式，比如H264/H265的视频，FLAC/AAC的音频，解码为非压缩的格式，比如视频是YUV/RGB（相当于bmp），音频是PCM（相当于wav），然后丢给下游模块。负责解码的模块滤镜称为解码器(decoder)。常见的有LAV/ffmpeg, ffdshow(同样停止更新了)……\n\n​\t当解码器能完全解码一个轨道中所有有效信息的时候，我们成为完全解码（现在绝大多数情况是如此），否则称为不完全解码。比如说，早期一些显卡的硬解，不能完全处理H264视频流的所有，解码出的画质有折扣；又或者DTS-HD MA解码器开源之前，基于ffmpeg/lav等解码器只能解码出部分信息，导致音频是有损的。\n\n​\t解码出来的格式，都需要加上精度的度量。比如说10bit 视频完全解码后是YUV 10bit，8bit视频是YUV 8bit，16bit flac格式是PCM 16bit整数，aac是PCM 32bit浮点。麻烦在于，解码器下游的模块不见得能照单全收。比如说以前播放器就不支持10bit YUV丢给下游，解码器只好转为YUV 8bit（后来madVR之所以是一个极大的提升，就是因为madVR基本上全部通吃）。同理；很多声卡能支持24bit整数PCM已经是极限，所以32bit浮点的PCM需要转为24bit整数。\n\n​\t如果解码器可以将最原始的数据，或者更高精度（比如有时候为了方便，将10bit转为16bit）输出给下游，我们称为全精度输出；否则，解码器会试图降低精度输出，我们称为低精度输出。少数时候，我们会让解码器做一些转换（比如vcb-s新播放器教程中，让lav解码器做YUV->RGB的转换），我们称为转换输出。\n\n​\t解码器，特别是视频解码器，往往成为大量消耗运算资源的地方。这个问题在H264早期非常严重，那时候的主流CPU很难负担720p/1080p的高清解码，能耗巨大，移动平台尤其如此。所以才催生了各种硬件加速和硬件解码，并逐渐成为一个规范标准。\n\n \n\n​\t渲染，指的是将解码后的数据，在pc硬件上（显示器、扬声器）进行播放。负责渲染的模块我们称之为渲染器(Render)，视频渲染器主流有EVR（Enhanced Video Render, 微软送的）以及madVR(madshi Video Render)。\n\n​\t音频渲染器一般都是系统自带的（同样是微软送的），也有可以自定义的。比如MPC播放器有MPC Audio Render，可以支持类似wasapi输出等其他功能。\n\n​\t因为显示器是RGB显示，而解码后的视频多为YUV格式，渲染器一般也需要负责将YUV转换为RGB，并保证输出的图像大小跟播放窗口吻合。\n\n​\t多数播放器自带的滤镜（mpc/pot都有很多调色之类的功能），显卡的加成，以及SVP，都作用于解码器和渲染器中间。它们接过解码器解码的数据，对其进行处理，然后将处理后的数据送给渲染器。因为渲染器是需要借助显卡进行图形运算，YUV数据基本上需要先进入显存，所以显卡可以检测到丢来的YUV数据，对其进行“优化”。同样需要当心的是，这些滤镜和处理，往往入口精度低，处理精度也低。导致的后果就是解码器被迫低精度输出，给这些滤镜低精度处理，从而大幅降低视频精度，导致色带色块问题。\n\n​\t字幕的加载可能在渲染器前（将字幕信息整合进YUV/RGB数据给渲染器），也可能在渲染器后（播放器来将字幕整合入生成完毕的RGB图像）。\n\n多数解码包的配置界面，主要就是让你选择分离器、解码器和渲染器的：\n\n![1691582593887](./Image/视频格式基础知识.assets/1691582593887.jpg)\n\n如上图，上方就有让你选择视频渲染器，然后下方左右分别是针对不同文件格式的分离器，以及针对不同媒体格式的解码器。\n\n\n\n\n\n## 硬解的定义与分类\n\n​\t如上文所说，硬解是为了缓解高分辨率新编码面世初期，CPU不堪重负的解码压力，而诞生的技术。如果说软解的定义是：利用CPU通用运算能力，进行解码，那么硬解的定义可以这么说：不利用CPU通用运算能力，而是依赖其他集成电路，无论是否特制，来进行解码。\n\n​\t更古老的时候，有些显卡没办法进行完全解码，只是帮助计算部分解码过程中的运算，那么可以归为“`硬件加速`”。估计Intel下一代CPU“混合加速HEVC解码”也是一样的道理。\n\n硬解现在比较常见的是以下种类：\n\n- DXVA(DirectX Video Acceleration)，比较古老的方案了。Windows XP以及之前系统上流行的。上古ffdshow的硬解就是利用DXVA。DXVA规范下容易出现不完全解码，导致画质降低。Vista以后，渐渐地被抛弃。\n- DXVA2，目前主流的硬解方式。主要由GPU来实现，但是并非利用GPU的流处理器，INA三家都是使用了单独附在GPU芯片上的一块专职电路来完成。GPU硬解能力往往不与显卡游戏性能相关，而与搭载的专职电路先进与否相关。典型的就是GT610，它是NVIDIA第一款能硬解4K视频的GPU，同时代其他GTX650/GTX580什么面对4K视频只有傻眼的份儿，就因为它的GPU塞入的专职电路，是刚开发出最先进的一款（代号为VP5，其他同时代的都是VP4）。\n\n使用DXVA解码，都需要先将视频数据（压缩的格式）传输到显存中，然后再让GPU进行解码。\n\nDXVA2有两种实现方式：native和copy-back。区别是解码后的数据是否还要传回内存。\n\n​\tnative选择不传，直接丢给同样依赖GPU工作的渲染器，数据从头到尾都在显存中。而copy-back选择传，数据会传回内存，一番处理后再传回显存，让渲染器工作。native的输出必须为YUV 8bit，而copy-back则可以为10bit。\n\n​\t之所以需要有copy-back这么个传来传去的过程，就是因为有些滤镜，比如SVP，比如LAV的转格式，必须依赖CPU+内存进行工作。不传回来没办法继续处理。copy-back保证了硬解的流程类似软解，可以不漏下任何后处理。而代价是传来传去必定降低性能，增加能耗。需要注意的是，即便用native，也可能导致解码后的数据被“优化”，因为有些处理，包括播放器、显卡驱动带的那些，是可以完全作用在GPU环境中的。\n\n​\t除了DXVA2，还有两种特殊的硬解：Intel Quick Sync, 和NVIDIA CUVID。如同名称所示，它们是Intel和NV的专属。\n\n​\tIntel Quick Sync是集成在CPU中的逻辑电路承担的。注意的是这玩意并非隶属于Intel的集显，而是CPU的直属。它直接读写内存，运行表现和软解非常类似。Intel Quick Sync堪称速度快，能耗低。\n\n​\tNVIDIA CUVID，是基于NV自己的接口，写的一个类似DXVA2(copy-back)的升级版。\n\n硬解的模式可以在LAV Decoder的设置中选择：\n\n![1691583168565](./Image/视频格式基础知识.assets/1691583168565.jpg)\n\n红框的下拉框可选None(软解)，CUVID，QuickSync，DXVA2(native 和 copy back)。\n\n每选择一个模式（除了None），蓝框会显示一个单词：\n\n- Active：当前正在使用这种模式解码\n- Available：应该可以使用这种模式\n- Not Available：不支持使用这种模式\n\n绿框当中则是显示当前在使用哪个解码器。如果是软解，显示avcodec，否则显示类似dxva2cb, dxva2n等标示。\n\n碰到没办法开启硬解，比如设备不能正常工作，或者碰到10bit AVC这种不支持的，那么自动转为软解。\n\n\n\n\n\n\n\n## YUV->RGB转换过程中的细节\n\n​\t将解码器输出的YUV格式，转为RGB，并且缩放到播放窗口输出，是视频渲染器的职能。可以说，如果解码过程是完全解码，也不主动添加播放器调校和驱动增强，渲染的环节决定了最终成品的画质。造成画质区别的可以说就三点：缩放算法，运算精度，和抖动算法。任何试图优化渲染器效果的尝试，都应该从这三个方面着手。\n\n缩放算法造成的区别，比较好理解。例如原图(150*150)：\n\n![1691584415464(1)](./Image/视频格式基础知识.assets/1691584415464(1).jpg)\n\n用双线性算法（上，多数播放器默认算法）和nnedi3(下)放大到272 * 272像素：\n\n![1691584450747](./Image/视频格式基础知识.assets/1691584450747.jpg)\n\n![1691584459084](./Image/视频格式基础知识.assets/1691584459084.jpg)\n\n不同算法造成的效果肉眼可见。注意上图中随处可见的锯齿，以及细线的模糊。\n\n\n\n​\t精度，是指运算的过程中，参与运算的数，有效位数的高低。在计算机中表现为使用怎样的格式来进行，8bit/16bit/32bit整数，16bit/32bit浮点。精度不足的表现在上篇教程中已经有展示，不做赘述，然而还是提醒一句：千万不要以为显示器是8bit，就认为8bit 整数 的片源精度/处理精度是足够的。\n\n​\t另外，RGB处理相对YUV处理，精度要求相对较低；或者说，RGB处理相比较，精度稍低带来的影响不明显。（不幸的是多数时候处理的数据都是YUV，然后根据水桶原理……）播放过程中，应该尽量减少RGB-YUV互转的次数，每一次转换都要做一次计算与取整，都会导致实际精度降低。\n\n\n\n​\t抖动算法(Dithering Algorithm)，通常出现在高精度转低精度中。在数字图像高转低处理中，全部四舍五入不见得是好习惯。抖动算法通过科学的添加噪点，来掩盖精度的不足。比如说原图（RGB24，即RGB 8bit）：\n\n![1691585042305](./Image/视频格式基础知识.assets/1691585042305.jpg)\n\n分别用四舍五入（上） 和 Floyd–Steinberg 抖动算法（下），将此图转为RGB16(RGB分别为5bit，6bit和5bit，早期windows桌面的“16色”，区别于RGB24的“真彩色”)\n\n![1691585068677](./Image/视频格式基础知识.assets/1691585068677.jpg)\n\n![1691585080576](./Image/视频格式基础知识.assets/1691585080576.jpg)\n\n​\t可以看出，使用抖动算法的图片较好的掩盖了精度不足引起的色带和偏色问题。在YUV 和 RGB的运算过程中，如果出现高精度转低精度，是否使用抖动，使用的抖动算法如何，也会决定输出效果。\n\n \n\n现在，我们来模拟一下渲染器的工作流程，并用加粗标注出可能造成画质差别的地方：\n\n1、渲染器从解码器那里获取YUV数据。注意拿到的数据可能是全精度，**也可能是降精度**，取决于渲染器接口类型；\n\n2、播放器和显卡驱动可能会试图“**优化**”画面；\n\n3、如果不是YUV444格式的，**渲染器会先将UV平面放大到Y平面的大小**。这个步骤称为Chroma upscaling；\n\n4、将YUV444的数据，转为RGB。转换的过程势必需要浮点运算（YUV->RGB一些参与运算的常数是浮点数）；\n\n5、播放器或者渲染器**将RGB用特定的算法缩放到播放窗口大小**。这个步骤称为Image Upscaling(图像放大)/Downscaling(图像缩小)；\n\n6、因为4的步骤中，必须以浮点数运算，而输出结果一定是RGB 8bit整数，因此输出之前**必须有一个高转低的过程**。\n\n2~6每一步都涉及数字运算，**因此有运算精度的区别**。\n\n\n\n\n\n问：什么样的渲染器，什么样的输出画面是标准的、完美的？\n答：没有。因为运算精度总可以无限的高，缩放算法也永远有提升的空间，**所以视频播放不存在“标准、完美”一说**；只有相比较而言的好与差，以及在人眼识别程度内的“接近完美”\n\n问：有哪些渲染器能“接近完美”的处理以上**所有**情况？\n答：**只有**madVR。\n\n问：Windows~~充话费~~送的那个EVR，默认情况下有啥不好？\n答：1、接口精度低，强迫YUV 8bit/RGB 8bit的输入；2、缩放算法默认是平庸的双线性；3、运算精度较低，默认只有8bit整数和16bit浮点数；4、抖动算法有，较为单一和固定；5、如果输入的是YUV数据，EVR会任由播放器和驱动乱来。\n\n问：我们能怎么拯救EVR？\n答：1、因为RGB对精度要求不敏感，而且输入RGB后，驱动和播放器基本没办法插手，所以设法永远输入RGB 8bit，不让YUV数据经过低精度处理；2、让LAV解码器来做YUV->RGB。LAV可以以32bit浮点的高精度、双立方的UV放大算法、随机抖动算法，较高质量的完成转换；3、图像缩放算法手动设置为更高级的双立方。\n\n问：听上去不错，我们应该怎么操作？\n答：参见http://vcb-s.com/archives/4384或者http://vcb-s.com/archives/4407\n\n \n\n所以，如果你使用的是madVR渲染器，你应该允许LAV输出它默认设置的那些格式，YUV/RGB。LAV会以全精度输出YUV给madVR进行处理；如果你使用EVR渲染器，你应该永远只允许LAV输出RGB 8bit。\n\nRGB 8bit 包括RGB24和RGB32。RGB32多一个透明层通道，看似带了个没用的东西，但是因为计算机更喜欢2的次方，所以部分运算下RGB32比RGB24快。在视频播放中，这两个格式几乎完全等同；互转也人畜无害（加一个空的透明度通道 vs 去掉透明度通道）。\n\n之前基于EVR CP教程中，之所以pot推荐RGB24输出，而mpc推荐RGB32输出，是测试的结果。这样设置播放器不会再多一次转换（虽然就算转换了也没啥）。\n\n\n\n\n\n\n\n## 硬解的优劣与选择\n\n​\t绝大多数vcb-s的教程，都让大家不要开启硬解，就算开启，优先使用DXVA2(copy-back)，这里我们做一个详细的解释。\n\n​\t首先考虑一个问题：什么样的视频能被硬解？\n\n​\t8bit AVC可以被各种显卡硬解；然而8bit AVC格式的软解压力小的可怜，以vcb-s常发的24fps 1080p的视频算，现在CPU软解，占用率普遍不到5%。\n\n​\t10bit AVC没有能硬解的。（所以10bit版炮姐时代，试图硬解的洗洗睡吧。）软解，解码压力尚可，不是很可怕，24fps 1080p的视频，现在的cpu大约10%\n\n​\t8bit HEVC现在最新显卡普遍能硬解；然而因为8bit x265的缺陷（或者说8bit x264的优越性），我们发现这玩意表现多数还不及8bit AVC，所以vcb-s从来不用；相对而言，它的解码压力也不大，大致相当于10bit AVC。\n\n​\t10bit HEVC，目前只有NV的GTX950和GTX960支持硬解。它的软解压力算是比较大，现在主流的CPU占用在20%左右；对于上古CPU或者一些低端笔记本CPU，流畅解码会比较吃力，特别是60fps的特典。对于将来的4K 60fps，现在桌面4核心CPU基本上完全无力软解。\n\n​\t能硬解的视频必须是YUV420格式。\n\n分析完毕了，你觉得自己需要硬解么？\n\n如果你没有GTX960/GTX950，你也基本碰不到1080p 60fps乃至4K的8bit HEVC，那么你只能去硬解8bit AVC，省那么5%不到的CPU占用率——真有这个必要么？软解吃力的硬解解不了，硬解解得了的软解解的飞起，那我们为什么要冒着各种潜在风险去开硬解呢？\n\n好吧，就算你说我真有理由要开硬解：我有GTX960/950，我的CPU真的太烂……我们来分析下不同情况下，硬解应该怎么开。硬解设置跟你使用的渲染器有关：\n\n如果你使用madVR，通常是不建议你开硬解的。众所周知madVR会消耗大量显卡运算，因此没必要再去把大量数据塞进GPU和显存，跟madVR抢夺资源。让CPU分担解码，让GPU专心跑madVR，是比较推荐的做法；\n\n如果你使用GTX960/950硬解10bit HEVC，**请务必设置为DXVA2(copy-back)**，这是现在唯一可以开启10bit HEVC硬解的模式；(2020年更新：现在native/D3D11也行了，那就选这俩加加速吧）\n\n其他情况下，如果你真的非要开硬解搭配madVR，建议顺序（保证你硬件可用）： Intel QS, DXVA2(native), NV CUVID, DXVA2(copy-back)，其实用哪个都没有太多关系，主要的功耗消耗点在madVR。\n\n如果你使用EVR CP（调节过缩放算法），希望追求较高质量的播放，**你首先要排除的是DXVA2(Native)**。因为这种模式下，LAV会直接输出YUV 8bit给显卡，哪怕强制规定了输出只能是RGB。用DXVA2(copy-back)是可以的；这种模式下，解码后的数据将回传给CPU，继续做高质量转RGB的后续操作。\n\n一般情况下，建议顺序： Intel QS, NV CUVID, DXVA2(copy-back)\n\n所以不难理解为什么之前教程我说了，要开硬解请用DXVA2(copy-back)。**这种软解流程、硬解运算的泛用性模式，是最人畜无害的，哪怕这种模式折腾程度，导致在性能和功耗上大多是得不偿失。**\n\n追求最大性能的，特别是用来对付那些**能够被硬解**的高清病毒的，请使用EVR默认，搭配DXVA2(Native)播放。这样效率应该是最高的，各种专治8bit AVC 4K的高清病毒。只不过这种做法会损失画质，因此不建议日常使用。\n\n\n\n\n\n## 图像格式的标识与查看方法\n\n在播放器中，不同格式、不同精度的图像，有着规范的定义和标号。这一点可以在LAV的设置界面很清楚的看到：\n\n![1691585606340](./Image/视频格式基础知识.assets/1691585606340.jpg)\n\n其中蓝色部分标示的这些是最常见到的，主要是YUV 420的不同精度，以及RGB格式（注意16bit RGB，即RGB48，在现有播放器体系下还没有实装，所以现在播放器中的RGB基本就是RGB 8bit）\n\n使用DXVA2(Native)硬解的时候，输出是DXVA，也是YUV420 8bit。\n\nRGB格式除了上文所说的RGB32和RGB24，播放器中还有XRGB和ARGB的标示，也都是一回事儿。\n\nPotplayer中观察方法，可以用tab键显示：\n\n![1691585632014](./Image/视频格式基础知识.assets/1691585632014.jpg)\n\npotplayer会给出视频解码器（图中是LAV）\n\n解码器输入的格式是HVC1(HEVC)，输出是RGB给渲染器。YUV->RGB的过程完全是LAV处理。\n\n渲染器是EVR CP，渲染整个过程，格式都是RGB，没有转回YUV。需要注意的是你必须关闭pot自带的内置滤镜（按F5，进入”参数选项”设置。 2、点击“滤镜”，将右边的”内置图像处理滤镜设置”激活条件设置为：”不使用”），否则potplayer一定会自作主张转回YUV的。\n\n缩放算法是Lanczos 3。(注意如果你播放画面跟视频画面相同，比如你在1080p的显示器上全屏播放，缩放算法会显示临近采样，这是正常的)\n\n \n\nMPC-HC/MPC-BE中，按Ctrl+J可以调出类似的信息：(再按1~2次取消)\n\n![1691585666200](./Image/视频格式基础知识.assets/1691585666200.jpg)\n\n红框中勾选的，Formats表示渲染过程中格式变化，从始至终都是RGB；\n\nVideo Size给出了原始尺寸和播放尺寸，以及使用的缩放算法(双立方 A=-0.6)\n\nDecoder则是解码器；输出是RGB。\n\n通过这样的查看方法，你可以知道你的播放器工作流程，以及设置是否按照预期。\n\n\n\n\n\n## 动漫画面区别于常规录制视频的特殊性\n\n​\t一直以来都有这样的说法：“10bit, madVR这些东西都是那些压动漫的人弄出来的歪门邪道，我是看不出这些东西在电影上有个P用。”\n\n​\t其实吧，这还真不是这群人眼力不好或者装睡不醒。区别于录制视频，比如电影之类的，动漫、CG等有着自己的特殊性。总结起来就两点：1、**噪点少**，2、**线条非常突兀**。\n\n​\t视频拍摄，限制于器材水准，噪点是不可避免的，在后续制作等过程中也难以完全去除。而**动漫天生可以0噪点**，动漫中的噪点更多是数字图像处理中主动加上去的。噪点的一大作用就是极大地降低视频处理和压制，对于精度的需要。说的简单点：高噪点的视频不怕低精度，反之亦然。\n\n怎么理解这个概念呢？我们借助一个简化的图片来演示。假设我们有一条平滑、高精度的曲线(这是y=1/x在[10,30]上的图)：\n\n![1691585758663](./Image/视频格式基础知识.assets/1691585758663.jpg)\n\n现在，我们把所有函数值，四舍五入到小数点后三位数：\n\n![1691585773836](./Image/视频格式基础知识.assets/1691585773836.jpg)\n\n降低精度的效果很明显，我们现在的图看上去跟楼梯一样，出现了明显的”断层”。表现在视频中，这种断层就是色带。同时值得注意的是，越是平坦、变化小的地方（就是之前科普中的”平面”），色带表现越严重。\n\n现在，我们模仿给图像加噪点，来给这个函数加一个小幅度(约为1%)随机抖动：\n\n![1691585815666](./Image/视频格式基础知识.assets/1691585815666.jpg)\n\n然后我们也把它的精度限制为小数点后3位：\n\n![1691585839300](./Image/视频格式基础知识.assets/1691585839300.jpg)\n\n可见，这一次精度降低，图像似乎没有受到太多影响，精度降低造成的阶梯状效果也很不明显。表现在数字图像处理中，意味着噪点重的图片，在降低精度的时候收到的影响很小。\n\n这就是为什么那些致力于改善精度的提升，对于电影等视频几乎没有用——播放过程的精度低怎么了；能有什么视觉影响？\n\n类似的现象，噪点会使得人眼对图像锐利度等差异不敏感，或者说，缩放算法造成的区别，变得不太可见。以之前的图为例，假如为两幅图都加上强度相同的噪点：\n\n![1691585879464](./Image/视频格式基础知识.assets/1691585879464.jpg)\n\n![1691585886053](./Image/视频格式基础知识.assets/1691585886053.jpg)\n\n区别已然几乎不可见。注意噪点是如何帮忙掩盖拉升过程中的锯齿等瑕疵，并加入虚假的高频信息，让图像看上去细节很丰富。这还是应用在线条/平面非常分明的动漫；换作电影，这样的差异只会更不起眼。\n\n小结一下，当有噪点存在的时候，主打高精度、优秀缩放算法的播放器，优势将不再明显。**从另一个方面讲，面对较少噪点、较为突出线条的动漫，对播放器的精度和缩放算法提出的要求就很高**。编码器也是一样的道理，动漫非常需要10bit x264/x265这样原生高精度的编码器来提升画质。\n\n因此，再面对本节开头的说法，不需要反驳，那是很自然的（摊手）。\n\n \n\n问：既然加噪点可以有效避免精度降低，为什么在动漫压制中不用这个方法呢？\n\n答：噪点作为一种高频信息，需要浪费成倍的码率。在今天10bit编码可以不增加（甚至减少）码率完美解决问题的前提下，我们为什么要用10年前的理解呢？\n\nPS: 10年前只有8bit编码器的时候，主动加噪确实是很常见的防色带、去色带手段。在今天商业性蓝光编码器只有8bit精度的限制下，很多动漫蓝光后期也是通过加噪点解决的（Sony那高大上的“SBMV技术”的核心）。然而，蓝光可以不惜码率，Rip不行，除非你是Yousei。（所以Yousei的Devil-Jin至今用着这种手段）\n\n\n\n\n\n## 播放器软件的现状与分析\n\n​\t接上文分析。面对占绝对多数的电影观众，现有的播放器，pot/mpc默认，已然足够好了。再好的设置能带来的观感提升几乎没有，还不如在什么一键增强，左眼效果，以及在线字幕、弹幕上下功夫。\n\n​\t面对多数动漫党，稍微修改一下基于EVR CP+LAV的播放设置，也能达到很满意的效果，很平衡的兼顾画质、性能与稳定性。所以如果你不求折腾（还把这么长的教程看到这里，真是辛苦你了），建议使用vcb-s最新写的两篇64bit播放器教程。\n\n​\t如果你真的欲求不满，那么你就可以试着接触madVR，SVP这些东西。但是有一点需要提醒的是：这些纯粹由fans开发的东西，甚至包括mpc/pot这些软件，是高度不可靠的。哪怕所谓的“稳定版”，出bug的几率都很高。（更别提现在madVR一直都是“测试版”，版本号还在0.x）MadVR至今有个问题，就是它所在的目录路径不能有中文。这个问题存在几年了，作者压根不屑于，或者说，抽不出精力去修复它——你见过几个正儿八经的软件不支持安装目录有中文？！\n\n​\t更恐怖的是，高质量播放依赖的组件数量庞大，而彼此之间缺乏系统性的联系测试。开发者往往是各自测试各自的，没有组织、没有公司说作为一个整体来调试一套方案。当播放软件趋于复杂，组件数量增多，功能强化，出错的概率指数级上升。一个基于potplayer+madVR的播放方案，不考虑音频，涉及到以下可能出问题的地方：\n\n​\tpotplayer本体,  LAV分离器，LAV视频解码器，madVR渲染器，操作系统，显卡和显卡驱动。\n\n假设每一个组件出错的平均概率是3%，求问这一套方案正常运行不出错的概率是多少？1-0.97^6=83%。\n\n​\t也就是说，平均5个人里面，就有一个人用这套方案出错。出错的理由往往很难查到，每个人都有每个人的原因。\n\n> （举个我自己的例子，虽然我写的教程基于mpc-hc，但我自己在用mpc-be。因为对于mpc-hc，我设置让EVR渲染器使用双立方缩放，mpc-hc始终都使用的是最朴素的双线性，导致缩放效果很差（对我来说）。各种途径查错无功而返，最终换mpc-be问题解决。）\n\n所以以后请别问我为什么不写madVR+SVP+Reclock+XySubFilter这些高端货的教程，更别出了错问我错在哪里、怎么解决——臣妾做不到啊！\n\n\n\n\n\n## 其他常见播放器配件简介\n\n除了madVR，其他播放器折腾一般还有这些配件：\n\n​\tSVP(Smooth Video Project)比较众所周知了，它是一个插值平滑软件。本身依赖avisynth开发，通过ffdshow/ffdraw来加载，作用在解码器之后，渲染器之前。SVP只能支持YUV420 8bit输入输出。\n\n​\tSVP的性能消耗非常可观，特别是开启OpenCL之后，如果再开启madVR（接EVR CP容易导致精度问题，这时候可以手动在ffdshow/ffdraw中加噪点来缓解），对显卡的性能和驱动稳定性都是考验。尽管如此，SVP的插值平滑带来的观看提升也是非常可观的，强烈建议madVR的倍帧满足不了、同时又有很强配置的观众们爬文安装。\n\n \n\n​\tXySubFilter，是目前最先进的字幕插件，对高级字幕特效的支持，渲染的质量，性能的优化，对高精度播放以及madVR的配合都做得很到位。如果你患有字幕强迫症末期，建议去折腾一下这个插件。\n\n \n\n​\tReclock，一个致力于改善播放视频帧率不稳定的插件，不过多数人用它的目的可能还是为了它的wasapi输出。实际表现完全聊胜于无，特别是wasapi现在mpc自带的audio render就内置了，而且Reclock没有64bit版，因此不建议折腾。\n\n\n\n\n\n## 播放器配置学习的建议\n\n​\t对于想自学高级播放器设置的同学们，教程总是不缺的，网上一搜一大堆，各大论坛什么的置顶帖，万年冷冻库，等等。写的比vcb-s现有几篇教程更新、更详细、更高端的比比皆是，也都可以作为很不错的教程。然而我一直认为，这些教程只是授人以鲤，或者授人以鳊、鲢、鳙……，导致的结果就是来一只鲫，或者给你个渔网让你按照自己喜好捞一只，很多人一下子就傻眼了。\n\n​\t这也是我写这篇教程的初衷，讲述一下现在网上林林总总的教程，不会跟你说的很多细节与知识。有的人madVR设置玩出了花，结果不知道检查pot内置的ffmpeg解码器，会把YUV420 10bit 降低精度+瞎转换 为YUV422 8bit丢给madVR，然后又说自己看不出区别……这折腾的意义何在呢。\n\n学习播放器配置，有这么几条原则，是我希望分享给大家的：\n\n1、实事求是。不要盲目的去折腾，也不要为了心理安慰去折腾。一套更好的方案，只有你确实感觉到了提升，并且这个提升在你心理满意度上，足够抵消麻烦，才值得你去升级。比较的过程中，相信自己的眼睛，而不是相信别人的说教。比如说我真不推荐笔记本用户折腾任何顶级缩放算法——那么小个屏幕你能看出点啥？教程里说出花的放大算法跟你有几毛钱关系？\n\n2、循序渐进。先把一套简单基础的方案弄好弄懂，再去学习和尝试更好的方法。对于新的插件，你要尝试测试它们在你机器上的表现；对于别人的设置，设法了解他这么推荐的原因，以及这个原因是否适用于你。最典型的，很多人用着madVR问我，你在新教程里教我们LAV只勾选RGB，我要改么？看了这篇教程你应该知道要不要改与背后的原因了吧。\n\n3、量力而行。播放器越高级，组件越多，往往性能消耗越大，出错概率也越高，同时收益越少。学会放弃与妥协，毕竟，你看的是片子，不是播放器组件和参数。\n\n\n\n\n\n# 动漫视频常见的瑕疵/缺陷介绍\n\n## 前情提要\n\n​\t这篇科普教程本身有两个目的，第一个作为给观众们的科普，讲述一下动漫处理中常见的画面问题，帮助大家理解每次vcb-s发布帖当中那些技术描述；第二个作为vcb-s内部处理教程的基础部分，帮助组内组外所有入门压制的新手们了解所面对的“敌人”。\n\n​\t需要注意的是，下文列举的大多数瑕疵，大多数情况下，是无法修复/无法完全修复/无法不具备破坏力部分修复的。多数瑕疵可修复的程度，取决于问题的轻重，rippers水准，以及牺牲的有效细节多寡……\n\n​\t**阅读本教程前，强烈建议先理解 `视频格式的基础知识` 中的内容，并在大屏pc上观看（方便看图）**\n\n**本文中，如果图像看不明显，建议点击单独打开，并缩放到1:1观看**。放大版图片使用的是临近采样放大到2x倍，相当于一个像素放大到2×2倍大小，方便大家理解。\n\n**本教程中所有图例，除非有说明，否则均来自于动漫蓝光原盘截图。**\n\n\n\n\n\n\n\n## 色带(banding/color banding)\n\n​\t色带是出现频率最多的瑕疵，没有之一。色带产生的原因是精度不足。因为几乎100%的片源采用YUV 8bit编码，而这种编码是不足以达到可视范围精度的极限，所以编码本身的瓶颈，决定了从制作到放源，几乎一定会因为精度不足产生色带。\n\n![1691587268671](./Image/视频格式基础知识.assets/1691587268671.jpg)\n\n色带的表现大家应该看得多了，颜色在渐变区域表现为波浪状、环状的阶梯型。常见于暗场处。\n\n去色带一般被叫做deband/de-banding\n\n\n\n\n\n## 锯齿(aliasing)\n\n锯齿是最典型、最常见的线条部分瑕疵，通常是因为制作分辨率较低，且不规范拉升到更高分辨率造成的：\n\n![1691587312450](./Image/视频格式基础知识.assets/1691587312450.jpg)\n\n锯齿的处理方式叫做抗锯齿(anti-aliasing, aa)\n\n\n\n## 晕轮/振铃(ringing/haloing)\n\n严格来说这俩是不同的东西，但是表现非常相似，处理时候也通常不区分。它们也是较为典型的线条瑕疵，通常是因为制作分辨率较低，且不规范拉升到更高分辨率，且/或 过度锐化造成的：\n\n![1691587347729](./Image/视频格式基础知识.assets/1691587347729.jpg)\n\n瑕疵表现为线条周围似乎裹着一层明亮的光晕，如果上图看不出，下图放大版，仔细看线条两侧：\n\n![1691587379620](./Image/视频格式基础知识.assets/1691587379620.jpg)\n\nringing/haloing通常和aliasing是伴生的，这在upscale片源中尤其常见。\n\n播放器拉大、锐化等处理（包括madVR的功能），也很容易出现这两种瑕疵。\n\nringing/haloing的处理方法叫做去晕轮(dering/de-ringing,  dehalo/de-haloing)\n\n\n\n\n\n## MacroBlock/blocking(色块)\n\n色块一般是严重欠码，或者是视频损坏，导致的图像如网格状凸显，横平竖直:\n\n![1691587407292](./Image/视频格式基础知识.assets/1691587407292.jpg)\n\n更严重的大家自己去看各种在线视频就好。上图是LL的演唱会蓝光。\n\n色块一般跟色带共生。解决方法称为去色块(deblock/de-blocking)\n\n\n\n##  拉丝/横纹(combing)\n\n拉丝是指图像中相邻两行错位造成的视觉效果：\n\n![1691587430569](./Image/视频格式基础知识.assets/1691587430569.jpg)\n\n​\t拉丝的产生，一般是原生隔行扫描(interlaced)的片源，没有经过任何处理（或者部分片段漏了处理），然后在逐行扫描(progressive)的设备上（比如pc显示器）播放的结果。\n\n​\t隔行扫描和逐行扫描啥意思啥区别大家不用细究，你只要知道，前者是老技术，后者是新技术，两者之间需要一定步骤做转换，不转换就可能出这种问题。\n\n​\t这玩意是你在任何小白向的压制论坛，见到最多的提问：为啥我压制出来的东西播放有横纹？\n\n根据片源类型的不同，处理方式一般有以下几类：\n\n反交错(de-interlacing)/场匹配(field-matching)/反交卷过带(ivtc)\n\n \n\n### 缟缟(此名称有一定争议，但是vcb-s的发布页看到这个单词，你默认就是下图的效果)\n\n缟缟的效果兼具拉丝和锯齿的效果，有其特殊的线条特征：\n\n![1691587534546](./Image/视频格式基础知识.assets/1691587534546.jpg)\n\n缟缟的产生是隔行扫描的源，没有先转换为逐行扫描，而是在隔行状态下，用逐行扫描的算法放大的结果。\n\n缟缟按照具体表现及程度有不同的处理方法，统称去缟缟。\n\n \n\n## 鬼影（blending/ghosting）\n\n排除掉视频本身采用的特效，这里鬼影指的是非正常的帧融合，造成的动态瑕疵（图片自制，其实寒蝉的BD挺适合拿来展示，但是当初我下好准备做BDRip，看了一眼就shift+delete了）：\n\n![1691587586243](./Image/视频格式基础知识.assets/1691587586243.jpg)\n\nblending一般是不规范的反交错/交卷过带产生，且/或者是滥用不可靠的时域处理造成的。\n\n多数情况下无解（比如寒蝉那BDBOX）；少数有规律可循的，一定手段可以还原。一般称为de-blending/ghost-removal\n\n### \n\n## 颜色越界（overflow/underflow）\n\n数字图像处理中，数据如同道路上机动车的速度一样，在规章制度下有着严格的范围限定。而颜色溢出则是发生了数据在既定规范下上下溢出的问题。典型的如dal的OP：\n\n![1691587713634](./Image/视频格式基础知识.assets/1691587713634.jpg)\n\n黑咕隆咚的，看我变出点纹理细节来：\n\n![1691587730899](./Image/视频格式基础知识.assets/1691587730899.jpg)\n\n越界的调整一般需要对数字图像规范有着专业的了解，同时还得熟知中间的变换公式。记为fix overflow/underflow\n\n \n\n## 噪点；彩色噪点/色度噪点（Noise/Grain; chroma noise/grain）\n\n噪点不多介绍了；这里单独贴一下Chroma平面的噪点，往往表现为噪点本身花花绿绿的：\n\n![1691587766826](./Image/视频格式基础知识.assets/1691587766826.jpg)\n\n如果你表示看不出啥，加一张去掉上图中色度噪点的：\n\n![1691587778522](./Image/视频格式基础知识.assets/1691587778522.jpg)\n\n一般来说手段就是降噪(de-noise/de-grain)。\n\n \n\n不讨论特效噪点，就普通数字噪点，降噪本身应该与否，这是被讨论烂的问题。这里简单说一下我个人的一些看法，注意这是很主观的，完全不是什么“普世价值”：\n\n1、噪点的重要性低于有效细节，然而，噪点依旧是组成画面的重要部分，**在片源噪点明显时候，定位于中/高还原度的BDRip，噪点不应该被一刀切，导致源和成品画风突变**；\n\n2、噪点会消耗大量码率这是不争的事实；因此，**越是本身细节丰富动态高的视频，且低码率压制，那么降噪的意义越大**，因为可以把有限的码率省下来给真正需要的细节。\n\n3、**降噪会不可避免的损失有效细节**，特别是暗场处，因此，降噪时候，保留有效细节的多寡，是衡量一个ripper降噪水准的重要指标；\n\n4、**降噪应该引入视觉的心理学优化**，比如说Chroma noise对画风的影响基本是恼人的，应该尽可能去掉；亮处的噪点去掉了对画风影响教低，而暗处较高；降噪应该在人眼不注意的地方强力，在人眼容易注意的地方较轻，等等。\n\n \n\n## 烂边/蚊噪(DCT ringing/DCT noise)\n\n突出一个烂字。是指画面欠码的时候，线条和平面都出现了很脏的观感，似乎线条被一圈絮絮叨叨的脏东西裹着，而平面有噪点的地方，噪点烂的很不规律，伴随着色块很难看：\n\n![1691587833691](./Image/视频格式基础知识.assets/1691587833691.jpg)\n\n这种瑕疵是因为现在的视频都是基于DCT(Discrete Cosine Transform，离散余弦变换)的编码。在编码码率严重不足的时候，将一些频率一刀切，就会造成这样的后果。越是早期的视频编码格式越常见。处理一般要求搭配deband/deblock/denoise进行综合性的处理。\n\n \n\n## 色度色带(Chroma banding)\n\n色度色带，特别指色度平面的精度不足。专门把它拉出来说的原因是，随着SBMV技术普及，蓝光加噪带来的效果，就是亮度平面精度不足问题削弱，相比较而言，色度平面问题则凸显。色度色带在目视表现上，跟一般的色带略有区别（下图自制）：\n\n![1691587853960](./Image/视频格式基础知识.assets/1691587853960.jpg)\n\n通常来说，表面看不出画面有波浪状的断层，但是颜色过渡很不自然。只有单独拉出UV平面看才发现精度不足：\n\n![1691587871148](./Image/视频格式基础知识.assets/1691587871148.jpg)\n\nChroma banding的处理一般随着正常deband的处理，无非是强化UV平面的力度。\n\n \n\n## 色度锯齿(chroma aliasing)\n\n色度锯齿特指色度平面的锯齿，之所以单独说，是因为色度半采样的存在，导致色度平面经常需要被放大缩小（比如转为RGB处理，再转回去做视频），如果缩放不规范，就容易造成色度锯齿：\n\n![1691587898309](./Image/视频格式基础知识.assets/1691587898309.jpg)\n\n图放大到两倍：\n\n![1691587908321](./Image/视频格式基础知识.assets/1691587908321.jpg)\n\nchroma aliasing的处理方式一般是拆分UV平面的抗锯齿(chroma aa)\n\n \n\n## 色度偏移（chroma shift）\n\n色度偏移，指的是色度平面相对亮度平面的错位，通常在极红/蓝/绿/紫处（这四个地方分别是U/V极大值或者极小值），线条多了一些重影（下图自制）：\n\n![1691588013638](./Image/视频格式基础知识.assets/1691588013638.jpg)\n\n上图是故意将UV左移两个像素。实际蓝光中鲜有这么大尺度的偏移，最多偏移一个像素，效果非常不明显；一般人很难观察到。\n\nChroma shift一般发生在数字图像处理中，不正确处理Chroma placement(Chroma相对Luma的位移)，造成的后果。修复手段通常叫做fix chroma shift。\n\n\n\n## 色度溢出（chroma bleeding）\n\n色度溢出跟色度偏移很像，区别在于色度偏移是有方向的偏移，色度溢出是无方向的扩张（找不到更明显的图了；看不出来就算了吧）：\n\n![1691588058042](./Image/视频格式基础知识.assets/1691588058042.jpg)\n\n注意上图线条两侧，可以观察到颜色似乎跟周围饱和度不一致。这是轻度的溢出；失控的如下图（自制）：\n\n![1691588079501](./Image/视频格式基础知识.assets/1691588079501.jpg)\n\n\n\n整个图线条部分，颜色饱和度都不正常了。\n\n修复手段叫做fix chroma bleeding\n\n\n\n## 重复场（duplicate field）\n\n重复场表现为一张图，奇数行和偶数行相同。视觉效果如下（轻音少女横滨演唱会；部分动漫中也有，如K的剧场版）：\n\n![img](./Image/视频格式基础知识.assets/S2.png)\n\n通常和锯齿难以区分；但是如果把奇数行和偶数行拆开各自组成一幅图，把图像一分为二，两份图是一样的。\n\n解决方法就是丢掉奇数行或者偶数行，用剩下的缩放到原来高度。记为fix duplicate field。\n\n\n\n## revertible upscale（可还原拉升）\n\n指的是图像明显是放大而来，而放大的算法，可以被精确或者近似的判断出，然后设计逆向，把图像缩回去：\n\n![img](./Image/视频格式基础知识.assets/bicubic.png)\n\n比如这图（局部），线条有大量锯齿，且出现ringing/haloing，经验丰富的rippers大致可以判断图像是通过类似Bicubic(sharp=-1.0)的算法拉升到1080p的。那么压制之前就可以根据拉升算法本身数学性质，逆向回720p再处理压制。这样的处理比一般性降低到720p来的科学。\n\n一般你见到inverse-upscale/de-bilinear/de-bicubic之类的，就说明用了这样的手段。\n\n \n\n## Over Blurring(过度柔化)\n\n说简单点就是图像太模糊了。本身分辨率低，然后用柔和的算法给拉上来：\n\n![img](./Image/视频格式基础知识.assets/bilinear829cc.png)\n\n注意这种模糊是全局性的，不是个别镜头/个别位置。一般来说图像还没有锯齿/ringing之类的问题。\n\n处理手段可以是inverse-upscale，拉回低分辨率，也可以采用主动性锐化(active sharpening)。注意这样的操作属于主观调整。锐化本身是很考验设计的，如何调整强度，设计自适应(adaptive)和保护手段(protective)，来保证不出现过度锐化的瑕疵（比如锯齿，haloing等），都是学问。\n\n锐化一般分为四种：\n\n补偿性锐化（contra-sharp），**不属于主观调整**，目的是补偿一些修复操作中，损失的细节和锐利度，补偿性锐化后的图像看起来不会比源锐利。补偿性锐化更多作为一些修复操作的保护手段，保护细节纹理不受太多损失。\n\n可控性锐化（controlled sharp），属于主观调整，目的是补偿一些在非极高码率编码下，可能会损失的细节（我知道编码会损失细节，那么在编码之前，我先把容易损失的细节强化一点点，补偿编码的削减），以及在**不破坏原盘画风的前提下**，改善细节和纹理观感。往往看源和成品，第一眼看上去没啥区别，特别是线条部分；仔细看才发现，一些细微纹理，成品似乎比源还要清晰点。可控性锐化被中文区raw组不约而同地使用，强度不一。\n\n主动性锐化（active sharp），属于主观调整，目的是让成品清晰度明显的高于源，**同时几乎不引入过度锐化导致的瑕疵**。主动性锐化会破坏原盘本身画风，以此换来主观观感的极大提升。典型的比如date a live第二季度，vcb-s和TUC的合作版BDRip。\n\n过度锐化（over sharp），属于主观调整，相比主动性锐化，结果就是出现大量锯齿/ringing等瑕疵。常见于韩国raw组。\n\n \n\n这几种锐化我个人的态度：\n\n1、补偿性锐化是画面修复手段，不是主观调整，没有什么争议。\n\n2、过度锐化非常不可取，与其这样不如让观众自己在播放器里调整。\n\n3、可控性锐化和主动性锐化，是锐化强度，从量变到质变（是否引起画风明显改变）的过程。因人而异，也很难说到底什么强度算可控，什么强度算主动。\n\n4、实践证明，在中文区raw组和观众习惯的体积范围(~1GB/集)，可控性锐化利大于弊。强度太低，往往编码造成的损失肉眼可见，画面相比片源明显模糊；强度过高则画风改变明显，让多数观众厌恶。所以各组一般都选择一个适中的强度，最大程度的平衡观众满意度，也让BDRip的细节保留和画面观感，能与2GB/集的BDRip相媲美。这也是BDRip制作中的一种心理学优化。\n\n \n\n## 晃动(Global Motion/pan)\n\n通常是在老片翻新过程中，因为镜头/胶带位置不固定，导致录制的视频，似乎镜头在不断晃动一样，哪怕是应该静止的场景，都有不规律的、小幅晃动\n\n动态图就不找了。大家自己脑补自己拿着手机，边走边录像的效果。\n\n解决方法一般记为depan。\n\n \n\n## 彩虹（rainbow）\n\nRainbow多出现在早期真人视频中。表现为亮度快速变化的地方，UV似乎像彩虹一般红蓝交织（网上找的图）：\n\n![img](./Image/视频格式基础知识.assets/rainbow.jpg)\n\n看球拍部位。rainbow的产生是YUV数据作为电磁信号传输过程中，高频的Y信号，因为传输介质不理想，影响到了UV，而产生的后果。如果这时候进行进一步转录，就会把这个问题保留。\n\nB站放的《亮剑》，也有这个问题：战士们背着枪在雪地里走，黑色的枪和白色的雪构成了高频的亮度变化，结果枪身周围出现了红蓝光晕。弹幕一些人吐槽说这枪怎么还带魔法效果……\n然而我早已看穿了一切┑(￣Д ￣)┍\n\n修复手段一般称为de-rainbow\n\n \n\n## 点状斑纹(dot-crawl):\n\n点装斑纹也是传输YUV中，不正确处理导致的问题（wiki上的图）：\n\n![img](./Image/视频格式基础知识.assets/300px-Crawl.jpg)\n\nRainbow和Dot-Crawl在一些上古蓝光，甚至是上古TV源中还能发现它们的存在。高清数字时代之后，特别是动漫，几乎找不到了。\n\n解决方法一般记为 Dot-Crawl removal\n\n \n\n#### 最后，用两对问答来结束本章科普：\n\n问：作为一名ripper，你都干过哪些本末倒置的事情？\n答：为了看高清高画质，学习视频修复。\n\n问：作为一名收藏党，你都干过哪些本末倒置的事情？\n答：为了省硬盘，逛vcb-s.com。\n\n\n\n# WEBP\n\nWEBP 是一种衍生自 Google VP8 的图像格式，同时支持有损和无损编码。当使用有损模式，它在相同体积提供比 JPG 图像更好的质量；当使用无损模式，它提供比最佳压缩的 PNG 图像更小的体积。\n\n你可以通过如下方式浏览 WEBP 图像：\n\n1. 如果你使用 Windows XP SP3 或更高版本的 Windows 系统，可以通过安装 Google 官方的小插件实现系统自带图片浏览器与略缩图的原生支持：\n   [百度网盘](http://pan.baidu.com/s/1mi9zGMk) [备用链接](https://vcb-s.github.io/attach/WebpCodecSetup.7z) (请安装其中的 WebpCodecSetup.exe)\n2. 安装第三方图片浏览器，包括且不限于：\n   - [Xnview (Windows only)](https://www.xnview.com/en/xnview/)\n   - [Xnview MP (Win/Linux/Mac)](https://www.xnview.com/en/xnviewmp/)\n   - [Honeyview (Windows only)](https://www.bandisoft.com/honeyview/)\n   - [ACDSee (Windows only)](https://www.acdsee.com/)\n3. 通过 Google Chrome 浏览器直接打开 WEBP 图像。\n\n\n\n\n\n\n\n# 番剧相关\n\n## **什么是番剧？** \n\n- \"**番剧**\"是一个外来语词汇，意思为日本连载动画电视剧，属于二次元用户常用语。通常日本每年有四季动画剧，集中在1月、4月、7月、10月的某一个月份播出。因而类似美剧，番剧也是以季为单位，通常每周播出一集，一季12~13集(季番)或23-25集(半年番)居多。\n- **来源：**番剧一词来源于日语的\"番组\"，可以算是外来语演变而成。\"番组\"可以理解为电视节目，在日语中\"番组\"可以指电视剧，也可以指综艺节目，新闻节目，当然也包括动画。中文里的\"番剧\"可以理解为是番组电视剧，简称\"番剧\"，广义上来讲，应该可以理解成电视连续剧，包括了真人和动画的电视连续剧。\n\n![img](./Image/视频格式基础知识.assets/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp)\n\n\n\n## **番剧分类**\n\n- **番组:**电视节目，动画片电视连续剧。\n\n- **新番:**意指新番剧，每个季度在播中，或者将要播出的番组，都被称为新番。通常，1月新番，4月新番，7月新番，10月新番，分别指在1月、4月、7月、10月开播的新番。\n\n- **半年番:**播出持续半年(24话左右)的作品。\n\n- **季番:**播出持续一季度(12话左右)的作品。\n\n- **里番:**在日本评级为面向较为成年观众的R18+作品，一般不在电视台或深夜档播出。\n\n- **表番:**与\"里番\"相对，指代在日本评级为面向一般年龄观众的作品，内容及题材一般较为纯洁、健康向上。一般治愈番、致郁番和催泪番也属于这一范畴。除此之外，表番一般也指代评价较高，拥有较高人气的作品。\n\n  所谓\"表\"和\"里\"番都是相对概念。一般，用于定义\"表\"\"里\"的标准很大程度上取决于节目的人气，但并不绝对。\n\n- **泡面番:**一集时间很短的动画，通常在三分钟到六分钟左右不等，相当于泡一杯方便面的时间，等你把泡面泡好了， 动画也完了。\n\n- **番外、外番:**有别于主线连续剧的番外篇，有外传的意思，动画的OVA、OAD被归类到外番。\n\n- **追番:**在电视上首播一个番剧时，坚持看每一集的首播。\n\n- **补番:**看已经播出过的番剧。\n\n- **连番：**接连几次，连续多次看。\n\n![img](./Image/视频格式基础知识.assets/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp)\n\n## **什么是OV、OVA、OAD等？**\n\n- **OVA**（原创光盘动画，Original Video Animation简称），一般指通过DVD，蓝光光盘等以影碟发行的方式为主的剧集，也指一些相较原著篇幅较小且内容不一的动画剧集。\n\n- **OAD**全称Original Animation Disc或者Original Animation，DVD本质上与OVA（Original Video Anime）同义，在DVD等光碟储存媒体普及后的用语。一般在漫画中捆绑发售，媒介包括DVD及Blu-ray Disc。OAD的内容一般为原创，也有将TV版本再编辑后制作而成，看似和在大荧幕上映的剧场版动画一样，其实不一样。\n\n- **OVD**英文意思：光录像盘；视频光盘(Optical Video Disk)。OV、OVA、OAD总称。\n\n- **OV**非动画领域的光盘作品\n\n- **TV版**电视动画（Television animation）一般也叫动画剧，是指在电视频道上播映的动画作品。\n\n- **剧场版**是在影院公映的特摄与动漫作品，是日本特摄与动漫按传播方式分类的一种，在中国又被称为特摄与动画电影。通常片长为90分钟，制作成本一般高于OVA及TV动画。\n\n  不论在人物动作的流畅感，还是使用的分色数，甚至每秒的作画张数上，都比电视版动画和原创动画录影带有明显的提升。因此画面精度是三者（剧场版、TV版、OVA版）中最高的。\n\n- **网络(WEB)版**全称“Original Net Anime”，直译为“原创网络动画”又简称为ONA。指的是以通过互联网作为最初或主要发行渠道的动画作品。\n\n- **PV**英文名为Preview Video，即正式专辑或者影像发售之前，预先放松的预告。是MV(music video)在日专本的常见称呼属Promotion Video的略称。有时也被称为music clip或者video clip。其主要指流行音乐的乐曲发表的时候制作的，包含乐曲的影像作品。因为是以促销CD为目的，所以在日本一般被叫做プロモーション・ビデオ (promotion video) ，略称为promo 或者PV的情况也很多见。\n\n  「简单的说PV就是一种音乐发行时所制作的同步宣传影像，是一类多媒体作品，现多用于ACG领域。」目前Vocaloid音乐等网络音乐大多都是以PV的形式做专辑宣传。\n\n  它与其它音乐视频相比，PV作品使用素材多为原创，而其它视频创作素材使用广泛。一般原创或同人音乐社团包括作曲师、画师、歌姬/基、后期制作人员（即pv师），其中还能细分为比如，编曲&演奏&美工等。一部好的PV作品需要长时间精心制作和社团成员共同协助完成；主要目的还是突显音乐气氛和促销CD宣传。\n\n- **CM**一是Commercial Message的缩写\n\n  英文解释：a commercially sponsored ad on radio or television 中文解释：商业广播广告，日本的广告领域力，CM被当做广告简称，在其国内广泛应用。\n\n  二是Comic Market的缩写\n\n  Comiket是日本最大的同人志展会，全称Comic Market（コミックマーケット），是由Comic Market准备会举办的日本以至全球最大型的同人志即卖会。\n\n- **SP**(スッペシャルSpecial的简写)在日本动画中一般正传出完之后因为市场反应很热烈会为了赚钱而推出特别篇，也就是SP，意思就是两个小时左右的特别篇。通常是90分钟到两个小时不等。SP一般只讲一个完整的故事，类似于电影，但是没有电影的手法复杂．日剧是同期拍摄的，边拍边播．每一季接档的空闲时间就播放SP。大多数SP是以前热播剧的一个番外篇，也有的只是独立的小故事，也有的是系列篇。\n\n- **特典**是日文：とくてん的汉字写法，意思是优惠。引申义是特别版，游戏追加的相关周边产品都能算特典，不过一般是指数码内容的例如游戏的图片，声音，视频，也可能追加一些新剧情。再补充一些：就是一些无字幕的OP，ED，TV放映前的CV。一般是OVA里全剧结束后特别附赠的东西，主要有访谈、卡拉OK、原画设定、特别版动画之类。\n\n- **OP**（オープニングテーマ/ソング，Opening Theme/Song，简称OP）片头曲是电视剧或电视动画剧初播放的乐曲、歌曲（但日本动画和电视剧常在前情提要前或在播放部分正片后）。片头曲动画一般带有职员的文字。片头曲是一部番给人的第一印象，好的片头曲歌词内容紧扣主题，与OP动画节奏吻合，相辅相成，这样的片头曲也会为动画本身带来人气。\n\n![img](./Image/视频格式基础知识.assets/ab97e85ea89cf325b1a86459e8fdc80db490608b.png@1256w_708h_!web-article-pic.avif)sola OP视频截图\n\n- **ED**也被称为（Ending Theme或者Ending Song；日文：エンディングテーマ/ソング），是影视业术语，泛指在影视作品（如电视剧，动画片等）正片之后播出的带有人声甚至无人声的歌曲，某些情况下同时也是该部作品的主题曲。片尾曲常被人认为是正片故事的延续，是其风格的彰显，它已经成为影视作品的一个不可或缺的元素。很多动画都会在第一话把OP作为片尾曲播放。\n\n![img](./Image/视频格式基础知识.assets/4fe5bec6e29e09aedd8e0fc316b9589e98a25967.png@1256w_708h_!web-article-pic.avif)sola ED视频截图\n\n- **NCOP**（Non-Credit Opening，无制作人员字幕开头）发售BD等时则会去除。\n\n![img](./Image/视频格式基础知识.assets/168d59f32625b8ce43e22debd1f89918076883af.png@1256w_708h_!web-article-pic.avif)sola NCOP视频截图\n\n- **NCED**（Non-Credit Ending，无制作人员字幕结尾）\n\n![img](./Image/视频格式基础知识.assets/55aa5646885cfed7b97679b8e3c2f11465f48322.png@1256w_708h_!web-article-pic.avif)sola NCED视频截图\n\n- **IN** 指视频里的插曲\n- **OST**（Original Sound Track，简称Soundtrack或Sound Track，缩写OST）原声带是将一部电影或一部电视剧的主题曲（或片头片尾曲）和主要的插曲或配乐录一起，制作成一张完整的唱片，然后由唱片公司制成Caart,Dnb,CD或DAT/DCC发行。\n\n![img](./Image/视频格式基础知识.assets/7c076453ea0255301da02e5382fe495552b31b5b.jpg@1256w_1114h_!web-article-pic.webp)CLANNAD Original Sound Track CD封面\n\n\n\n![img](./Image/视频格式基础知识.assets/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp)\n\n## **扩展：Hi10p、BD、X264_flac等** \n\n- **Hi10p**指的是H.264编码使用10位深的色彩讯息。Hi10P 和10bit 是意思一样的。而10bit又特指一种回视频编码技术，能够提答供非常高的视频画质，能够在色彩的渐进和变化方面表现出非凡的细腻度，但是能播放10bit的配置要求非常高。\n\n  Hi10P编码的优点：\n\n  1．低码率（Low Bit Rate）：和MPEG2和MPEG4 ASP等压缩技术相比，在同等图像质量下，采用H.264技术压缩后的数据量只有MPEG2的1/8，MPEG4的1/3。 \n\n  2．高质量的图像：H.264能提供连续、流畅的高质量图像（DVD质量）。\n\n  3．容错能力强：H.264提供了解决在不稳定网络环境下容易发生的丢包等错误的必要工具。 \n\n  4．网络适应性强：H.264提供了网络抽象层（Network Abstraction Layer），使得H.264的文件能容易地在不同网络上传输（例如互联网，CDMA，GPRS，WCDMA，CDMA2000等）。\n\n- **BD**是指蓝光（Blu－ray）或称蓝光盘（Blu－ray Disc，缩写为BD），目前为止，蓝光是最先进应用最广泛的大容量光碟格式，网上下载的标有BD或者Blu－ray的高清影片，是指直接通过蓝光片源录制的，画面品质比HD和WEB-DL要好。\n\n  BDRIP（Blu-ray Disc Rip）即蓝光影碟转录，就是从蓝光光盘上把视频内容重新编码形成的视频文件。画质可能比原盘差一点点。\n\n- **X264_flac**\n\n  x264=压缩的视频编码方式。flac=音频的重编码方式。\n\n  附加：FLAC AC3x2=三条音频\n\n   1、FLAC音频\n\n   2、AC3音频\n\n   3、AC3音频\n\n![img](./Image/视频格式基础知识.assets/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp)\n\n## 扩展：.cue文件.tak文件.opus文件.ehviewer文件等\n\n- **.cue文件**\n\n![img](./Image/视频格式基础知识.assets/d5f8aab26d05646a35a3e05fe3a866b5c88be5b8.jpg@1256w_676h_!web-article-pic.webp)以CLANNAD Original Sound Track为例，用Notepad++打开其中的.cue文件\n\n\n\n- 实质：纯文本文件\n\n  百科：CUE(cuesheet)是指光盘映像(镜像)辅助文件或称标记文件，按照文本文件格式编制。它在刻录光盘映像文件时，起很重要的作用。它可以指挥刻录软件刻什么格式，刻录那些内容，从哪里开始，到哪里结束，附加什么信息等等、等等。有了cue文件，既可以减少刻录的准备工作以提高刻录效率，又可以保证刻录的准确性。更详细一点的可以看这篇文章https://b23.tv/nRRMYZs\n\n- **.tak文件**\n\n![img](./Image/视频格式基础知识.assets/74f457181db02000e0eb4928d052d6a42084a62e.jpg@1256w_680h_!web-article-pic.avif).tak文件及用VLC打开（专辑封面是用图片编辑软件加上去）\n\n\n\n- 实质：无损音频文件（编码格式）\n\n  百科：TAK是一种无损音频压缩格式，全称是Tom's Audio Kompressor，产于德国。类似于FLAC和APE，总体来说，压缩率类似APE而且解压缩速度类似FLAC，算是综合了两者的优点。但目前软件支持有限（有限？用VLC就可以打开）。\n\n- **.opus文件**\n\n![img](./Image/视频格式基础知识.assets/cb7b1b1f024b4ccd4243a33b408b608e80cb88c5.jpg@1256w_678h_!web-article-pic.webp).opus文件及用MusicPlayer2打开\n\n\n\n- 实质：有损声音编码音频文件（编码格式）\n\n  百科：Opus编码器 是一个有损声音编码的格式，由互联网工程任务组(IETF)近来开发Opus 格式是一个开放格式，使用上没有任何专利或限制。\n\n- **.ehviewer文件**\n\n![img](./Image/视频格式基础知识.assets/5b3eccfe59b5849e72736ba12cfeb9590cba726e.png@1256w_706h_!web-article-pic.avif)用Notepad++打开.ehviewer文件\n\n\n\n- 实质：纯文本文件\n\n  百科：（自己找吧）\n\n![img](./Image/视频格式基础知识.assets/4adb9255ada5b97061e610b682b8636764fe50ed.png@progressive.webp)\n\n## **来源链接（感谢以下优秀文章或视频）**\n\n**什么是番剧？、番剧分类**\n\n- - https://baike.so.com/doc/23736557-24292454.html\n  - 连番一词：[https://baike.baidu.com/item/%E7%95%AA%E5%89%A7/17528517](https://baike.baidu.com/item/番剧/17528517)\n\n- **什么是OV、OVA、OAD等？**\n\n- - OVA：https://baike.baidu.com/item/ova/9989\n  - OAD一词：https://zhidao.baidu.com/question/754018613605198244.html\n  - OVD、OV和其它部分内容：[BV177411m7ni](https://www.bilibili.com/video/BV177411m7ni?from=articleDetail)\n  - TV版、剧场版：https://zhidao.baidu.com/question/602632582.html\n  - 网络(WEB)版一词：[https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%8A%A8%E7%94%BB/6542913](https://baike.baidu.com/item/网络动画/6542913)\n  - PV一词：https://zhidao.baidu.com/question/360234748.html\n  - CM一词：https://zhidao.baidu.com/question/421364713.html\n  - SP一词：[https://baike.baidu.com/item/%E5%8A%A8%E6%BC%ABSP/15551866](https://baike.baidu.com/item/动漫SP/15551866)\n  - 特典一词：[https://baike.baidu.com/item/%E7%89%B9%E5%85%B8](https://baike.baidu.com/item/特典)\n  - OP、ED、NCOP：https://zhidao.baidu.com/question/360353977151434812.html\n  - NCED一词：https://zhidao.baidu.com/question/545257011.html\n  - OP、ED、NCOP、NCED图片：[BV1Gs411m7Dj](https://www.bilibili.com/video/BV1Gs411m7Dj?from=articleDetail)\n  - OST一词：[https://baike.baidu.com/item/%E5%8E%9F%E5%A3%B0%E5%B8%A6/1120682](https://baike.baidu.com/item/原声带/1120682)\n\n- **扩展：Hi10p、BD、X264_flac等**\n\n- - Hi10p一词：https://zhidao.baidu.com/question/2009347754951855908.html\n  - BD一词：https://zhidao.baidu.com/question/212528826.html\n  - BDRIP一词：https://baike.so.com/doc/5443852-5682205.html\n  - X264_flac和附加：https://tieba.baidu.com/p/7124754437\n\n**扩展：.cue文件.tak文件.opus文件.ehviewer文件等**\n\n- **.**cue文件一词：https://baike.so.com/doc/7161053-7385063.html\n- .tak文件一词：https://baike.so.com/doc/5504067-5739811.html\n- .opus文件一词：https://baike.so.com/doc/10912034-11438562.html\n- ehviewer：https://github.com/seven332/EhViewer/releases\n- MusicPlayer2：https://github.com/zhongyang219/MusicPlayer2/\n\n（文中图片除已标出出处外，均是来源于网络收集或本地运行截图储存于本地硬盘）\n\n（如有不完善的地方欢迎在评论区指出）\n\n（最后编辑时间:2022.6.04晚上0时）\n\n\n\n第一版：2021.2.26下午3时\n\n第二版：2022.6.04晚上0时\n\n\n\nhttps://vcb-s.com/archives/4738","tags":["protected","知识杂谈","视频格式"],"categories":["知识杂谈","格式"]},{"title":"第二代身份证号码的编码规则及校验","url":"/2023/06/25/身份证号码的编码规则及校验/","content":"\n# 身份证号码的编码规则及校验\n\n## 身份证号码的编码规则\n\n身份证号码共18位，由17位本体码和1位校验码组成。\n\n1. 前6位是地址码，表示登记户口时所在地的行政区划代码，依照《中华人民共和国行政区划代码》国家标准（GB/T2260）的规定执行；\n2. 7到14位是出生年月日，采用YYYYMMDD格式；\n3. 15到17位是顺序码，表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编订的顺序号，顺序码的奇数分配给男性，偶数分配给女性，即第17位奇数表示男性，偶数表示女性；\n4. 第18位是校验码，采用ISO 7064:1983, MOD 11-2校验字符系统，计算规则下一章节说明。\n\n\n\n一代身份证与二代身份证的区别在于：\n\n1. 一代身份证是15位，二代身份证是18位；\n2. 一代身份证出生年月日采用YYMMDD格式，二代身份证出生年月日采用YYYYMMDD格式；\n3. 一代身份证无校验码，二代身份证有校验码。\n\n## 校验码计算规则\n\n身份证号码中各个位置上的号码字符值应满足下列公式的校验：\n$$\n\\sum_{i=1}^{18}(a\\pmb{i} * W\\pmb{i})\\equiv(mod\\ 11)\n$$\n\n\n-  `i`表示号码字符`从右至左`包括校验码字符在内的位置序号；\n\n- `ai` 表示第i位置上的号码字符值， `a1` 是身份证号码第18位校验码；\n\n- `Wi`位置上的加权因子，加权因子计算公式：\n  $$\n  W\\pmb{i}=2^{i-1}(mod\\ 11)\n  $$\n\n## 样例\n\n以`370683198901117657`这个身份证号为例，根据上述公式进行校验\n\n| i       | 18   | 17   | 16   | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    |\n| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| `ai`    | 3    | 7    | 0    | 6    | 8    | 3    | 1    | 9    | 8    | 9    | 0    | 1    | 1    | 1    | 7    | 6    | 5    | 7    |\n| `Wi`    | 7    | 9    | 10   | 5    | 8    | 4    | 2    | 1    | 6    | 3    | 7    | 9    | 10   | 5    | 8    | 4    | 2    | 1    |\n| `ai*Wi` | 21   | 63   | 0    | 30   | 64   | 12   | 2    | 9    | 48   | 27   | 0    | 9    | 10   | 5    | 56   | 24   | 10   | 7    |\n\n将每一位的`ai*Wi`相加，得到和为`390`，\n\n将`390`模除11，得到余数5。根据下方对照表得到对应的数为7，与身份证最后一位相符，至此验证成功。\n\n| 余数   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |\n| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 对照值 | 1    | 0    | X    | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    |\n\n## 实际应用\n\n在金融行业软件系统中，对于身份证号码的采集、校验用途甚广。\n\n1. 身份证号码前6位，可采集客户户籍所在地，只需将国家标准GB/T 2260中定义的行政区划代码导入数据库，程序中进行映射即可；但需要注意的是，行政区划代码每隔几年会修订一次，从笔者手上的2007版来看，共经历了1982年、1984年、1986年、1988年、1991年、1995年、1999年、2002年、2007年九次修订，所以要预留更新机制；\n2. 身份证号码7到14位，可采集客户的出生日期、年龄、生日；\n3. 身份证号码17位，可采集客户的性别，奇数表示男性，偶数表示女性；\n4. 身份证号码的验证渠道，不管验证成功与否，往往都是收费的，比如银行渠道、公安部渠道，在发往这些渠道验证之前，先对其进行长度、正则表达式、校验码的验证，能够适当提高收费验证的成功率，节省成本支出；而且也可以提升用户体验，在用户输入错误时及时反馈而不必等待验证渠道结果的返回。\n\n下面，就以实际代码为例，说明身份证号码校验的方法。首先，给出身份证号码的正则表达式：\n\n```java\n/**\n * 18位二代身份证号码的正则表达式\n */\npublic static final String REGEX_ID_NO_18 = \"^\"\n        + \"\\\\d{6}\" // 6位地区码\n        + \"(18|19|([23]\\\\d))\\\\d{2}\" // 年YYYY\n        + \"((0[1-9])|(10|11|12))\" // 月MM\n        + \"(([0-2][1-9])|10|20|30|31)\" // 日DD\n        + \"\\\\d{3}\" // 3位顺序码\n        + \"[0-9Xx]\" // 校验码\n        + \"$\";\n\n/**\n * 15位一代身份证号码的正则表达式\n */\npublic static final String REGEX_ID_NO_15 = \"^\"\n        + \"\\\\d{6}\" // 6位地区码\n        + \"\\\\d{2}\" // 年YYYY\n        + \"((0[1-9])|(10|11|12))\" // 月MM\n        + \"(([0-2][1-9])|10|20|30|31)\" // 日DD\n        + \"\\\\d{3}\"// 3位顺序码\n        + \"$\";\n```\n\n校验身份证号码：\n\n```java\n/**\n * 校验身份证号码\n * \n * <p>\n * 适用于18位的二代身份证号码\n * </p>\n * \n * @param IDNo18 身份证号码\n * @return true - 校验通过<br>\n *         false - 校验不通过\n * @throws IllegalArgumentException \n *             如果身份证号码为空或长度不为18位或不满足身份证号码组成规则\n *             <i>6位地址码+\n *             出生年月日YYYYMMDD+3位顺序码\n *             +0~9或X(x)校验码</i>\n */\npublic static boolean checkIDNo(String IDNo18) {\n    // 校验身份证号码的长度\n    if (!checkStrLength(IDNo18, 18)) {\n        throw new IllegalArgumentException();\n    }\n    // 匹配身份证号码的正则表达式\n    if (!regexMatch(IDNo18, REGEX_ID_NO_18)) {\n        throw new IllegalArgumentException();\n    }\n    // 校验身份证号码的验证码\n    return validateCheckNumber(IDNo18);\n}\n\n/**\n * 校验字符串长度\n * \n * @param inputString 字符串\n * @param len 预期长度\n * @return true - 校验通过<br>\n *         false - 校验不通过\n */\nprivate static boolean checkStrLength(String inputString, int len) {\n    if (inputString == null || inputString.length() != len) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * 匹配正则表达式\n * \n * @param inputString 字符串\n * @param regex 正则表达式\n * @return true - 校验通过<br>\n *         false - 校验不通过\n */\nprivate static boolean regexMatch(String inputString, String regex) {\n    return inputString.matches(regex);\n}\n\n/**\n * 校验码校验\n * <p>\n * 适用于18位的二代身份证号码\n * </p>\n * \n * @param IDNo18 身份证号码\n * @return true - 校验通过<br>\n *         false - 校验不通过\n */\nprivate static boolean validateCheckNumber(String IDNo18) {\n    // 加权因子\n    int[] W = { 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 };\n    char[] IDNoArray = IDNo18.toCharArray();\n    int sum = 0;\n    for (int i = 0; i < W.length; i++) {\n        sum += Integer.parseInt(String.valueOf(IDNoArray[i])) * W[i];\n    }\n    // 校验位是X，则表示10\n    if (IDNoArray[17] == 'X' || IDNoArray[17] == 'x') {\n        sum += 10;\n    } else {\n        sum += Integer.parseInt(String.valueOf(IDNoArray[17]));\n    }\n    // 如果除11模1，则校验通过\n    return sum % 11 == 1;\n}\n```\n\n计算校验码\n\n```java\n/**\n * 计算身份证号码的校验码\n * <p>\n * 适用于18位的二代身份证号码，身份证号码由17位本体码和1位校验码组成\n * </p>\n * \n * @param masterNumber 本体码\n * @return 身份证号码\n * @throws IllegalArgumentException \n *             如果本体码为空或长度不为17位或不满足本体码组成规则\n *             <i>6位地址码+\n *             出生年月日YYYYMMDD+3位顺序码</i>\n */\npublic static String computeIDNoCheckNumber(String masterNumber) {\n    // 校验本体码的长度\n    if (!checkStrLength(masterNumber, 17)) {\n        throw new IllegalArgumentException();\n    }\n    // 匹配本体码的正则表达式\n    if (!regexMatch(masterNumber, REGEX_MASTER_NUMBER)) {\n        throw new IllegalArgumentException();\n    }\n    // 计算校验码\n    String checkNumber = computeCheckNumber(masterNumber);\n    // 返回本体码+校验码=完整的身份证号码\n    return masterNumber + checkNumber;\n}\n\n/**\n * 计算校验码\n * <p>\n * 适用于18位的二代身份证号码\n * </p>\n * \n * @param masterNumber 本体码\n * @return 校验码\n */\nprivate static String computeCheckNumber(String masterNumber) {\n    // 加权因子\n    int[] W = { 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 };\n    char[] masterNumberArray = masterNumber.toCharArray();\n    int sum = 0;\n    for (int i = 0; i < W.length; i++) {\n        sum += Integer.parseInt(String.valueOf(masterNumberArray[i])) * W[i];\n    }\n    // 根据同余定理得到的校验码数组\n    String[] checkNumberArray = { \"1\", \"0\", \"X\", \"9\", \"8\", \"7\", \"6\", \"5\", \"4\",\n            \"3\", \"2\" };\n    // 得到校验码\n    String checkNumber = checkNumberArray[sum % 11];\n    // 返回校验码\n    return checkNumber;\n}\n```\n\n虽然15位的一代身份证已经停用，但是难免有需要用到将15位的一代身份证升级为18位的二代身份证的情形，代码示例如下：\n\n```java\n/**\n * 15位一代身份证号码升级18位二代身份证号码\n * <p>\n * 为15位的一代身份证号码增加年份的前2位和最后1位校验码\n * </p>\n * \n * @param IDNo15 15位的一代身份证号码\n * @return 18位的二代身份证号码\n */\npublic static String updateIDNo15to18(String IDNo15) {\n    // 校验身份证号码的长度\n    if (!checkStrLength(IDNo15, 15)) {\n        throw new IllegalArgumentException();\n    }\n    // 匹配身份证号码的正则表达式\n    if (!regexMatch(IDNo15, REGEX_ID_NO_15)) {\n        throw new IllegalArgumentException();\n    }\n    // 得到本体码，因一代身份证皆为19XX年生人，年份中增加19，组成4位\n    String masterNumber = IDNo15.substring(0, 6) + \"19\" + IDNo15.substring(6);\n    // 计算校验码\n    String checkNumber = computeCheckNumber(masterNumber);\n    // 返回本体码+校验码=完整的身份证号码\n    return masterNumber + checkNumber;\n}\n```\n\n\n\n\n\n\n\n最后 来个合集\n\n```java\npackage com.godson.util;\n\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * ISO7064工具类\n * <p>\n * 使用ISO7064规范中定义的校验字符系统进行字符串的校验以及生成校验字符\n * </p>\n * \n */\npublic class ISO7064Util {\n\n    /**\n     * ISO7064规范中定义的校验字符系统\n     * <p>\n     * <li>ISO 7064, MOD 11-2使用 {@link #ISO_7064_MOD_11_2}表示\n     * </li>\n     * <li>ISO 7064, MOD 37-2使用{@link #ISO_7064_MOD_37_2}表示</li>\n     * <li>ISO 7064, MOD 97-10使用{@link #ISO_7064_MOD_97_10}\n     * 表示</li>\n     * <li>\n     * ISO 7064, MOD 661-26使用 {@link #ISO_7064_MOD_661_26}表示\n     * </li>\n     * <li>ISO 7064, MOD 1271-36使用\n     * {@link #ISO_7064_MOD_1271_36}表示</li>\n     * <li>ISO 7064, MOD 11,10使用\n     * {@link #ISO_7064_MOD_11_HYBRID_10}表示</li>\n     * <li>ISO 7064, MOD 27,26使用\n     * {@link #ISO_7064_MOD_27_HYBRID_26}表示</li>\n     * <li>ISO 7064, MOD 37,36使用\n     * {@link #ISO_7064_MOD_37_HYBRID_36}表示</li>\n     */\n    public enum Designation {\n        /** ISO 7064, MOD 11-2 */\n        ISO_7064_MOD_11_2,\n        /** ISO 7064, MOD 37-2 */\n        ISO_7064_MOD_37_2,\n        /** ISO 7064, MOD 97-10 */\n        ISO_7064_MOD_97_10,\n        /** ISO 7064, MOD 661-26 */\n        ISO_7064_MOD_661_26,\n        /** ISO 7064, MOD 1271-36 */\n        ISO_7064_MOD_1271_36,\n        /** ISO 7064, MOD 11,10 */\n        ISO_7064_MOD_11_HYBRID_10,\n        /** ISO 7064, MOD 27,26 */\n        ISO_7064_MOD_27_HYBRID_26,\n        /** ISO 7064, MOD 37,36 */\n        ISO_7064_MOD_37_HYBRID_36\n    }\n\n    /**\n     * 计算校验字符\n     * \n     * @param withoutCheckCharacterString 不含校验字符的字符串\n     * @param designation 校验字符系统\n     * @return 校验字符\n     * @throws IllegalArgumentException\n     *             如果字符串不匹配对应校验字符系统的正则表达式\n     */\n    public static String computeCheckCharacter(\n            String withoutCheckCharacterString, Designation designation) {\n        // 检查字符串是否匹配对应校验字符系统的正则表达式\n        if (!RegexMatcher.withoutCheckCharacterStringIsMatch(\n                withoutCheckCharacterString, designation)) {\n            throw new IllegalArgumentException();\n        }\n        // 计算校验字符\n        return CheckCharacterComputor.compute(withoutCheckCharacterString,\n                designation);\n    }\n\n    /**\n     * 校验字符串\n     * \n     * @param withCheckCharacterString 含校验字符的字符串\n     * @param designation 校验字符系统\n     * @return true - 校验通过<br>\n     *         false-校验不通过\n     * @throws IllegalArgumentException\n     *             如果字符串不匹配对应校验字符系统的正则表达式\n     */\n    public static boolean checkString(String withCheckCharacterString,\n            Designation designation) {\n        // 检查字符串是否匹配对应校验字符系统的正则表达式\n        if (!RegexMatcher.withCheckCharacterStringIsMatch(\n                withCheckCharacterString, designation)) {\n            throw new IllegalArgumentException();\n        }\n        // 校验字符串\n        return CheckCharacterSystemValidator.validate(withCheckCharacterString,\n                designation);\n    }\n\n    /**\n     * 正则表达式匹配器\n     * <p>\n     * 检查字符串是否匹配对应校验字符系统的正则表达式\n     * </p>\n     * <table border=\"1\">\n     * <tr>\n     * <th>系统名称</th>\n     * <th>适用范围</th>\n     * <th>校验码数目及类型</th>\n     * </tr>\n     * <tr>\n     * <td>ISO 7064, MOD 11-2</td>\n     * <td>数字</td>\n     * <td>1位数字或附加符X</td>\n     * </tr>\n     * <tr>\n     * <td>ISO 7064, MOD 37-2</td>\n     * <td>字母数字</td>\n     * <td>1位数字或字母或附加符*</td>\n     * </tr>\n     * <tr>\n     * <td>ISO 7064, MOD 97-10</td>\n     * <td>数字</td>\n     * <td>2位数字</td>\n     * </tr>\n     * <tr>\n     * <td>ISO 7064, MOD 661-26</td>\n     * <td>字母</td>\n     * <td>2位字母</td>\n     * </tr>\n     * <tr>\n     * <td>ISO 7064, MOD 1271-36</td>\n     * <td>字母数字</td>\n     * <td>2位数字或字母</td>\n     * </tr>\n     * <tr>\n     * <td>ISO 7064, MOD 11,10</td>\n     * <td>数字</td>\n     * <td>1位数字</td>\n     * </tr>\n     * <tr>\n     * <td>ISO 7064, MOD 27,26</td>\n     * <td>字母</td>\n     * <td>1位字母</td>\n     * </tr>\n     * <tr>\n     * <td>ISO 7064, MOD 37,36</td>\n     * <td>字母数字</td>\n     * <td>1位数字或字母</td>\n     * </tr>\n     * </table>\n     */\n    private static class RegexMatcher {\n\n        /**\n         * 检查不含校验字符的字符串是否匹配对应校验字符系统的正则表达式\n         * \n         * @param withoutCheckCharacterString 不含校验字符的字符串\n         * @param designation 校验字符系统\n         * @return true - 匹配<br>\n         *         false - 不匹配\n         */\n        static boolean withoutCheckCharacterStringIsMatch(\n                String withoutCheckCharacterString, Designation designation) {\n            return regexMatch(withoutCheckCharacterString,\n                    REGEX_MAPPING_WITHOUT_CHECK_CHARACTER_STRING\n                            .get(designation));\n        }\n\n        /**\n         * 检查有校验字符的字符串是否匹配对应校验字符系统的正则表达式\n         * \n         * @param withCheckCharacterString 含校验字符的字符串\n         * @param designation 校验字符系统\n         * @return true - 匹配<br>\n         *         false - 不匹配\n         */\n        static boolean withCheckCharacterStringIsMatch(\n                String withCheckCharacterString, Designation designation) {\n            return regexMatch(withCheckCharacterString,\n                    REGEX_MAPPING_WITH_CHECK_CHARACTER_STRING.get(designation));\n        }\n\n        /** 数字正则表达式 */\n        static final String REGEX_NUMBERIC_STRINGS = \"^[0-9]+$\";\n        /** 含补充校验字符X的数字正则表达式 */\n        static final String REGEX_NUMBERIC_STRINGS_WITH_SUPPLEMENTARY_CHECK_CHARACTER = \"^[0-9]+[0-9X]$\";\n        /** 字母正则表达式 */\n        static final String REGEX_ALPHABETIC_STRINGS = \"^[A-Z]+$\";\n        /** 字母数字正则表达式 */\n        static final String REGEX_ALPHANUMBERIC_STRINGS = \"^[0-9A-Z]+$\";\n        /** 含补充校验字符*的字母数字表达式 */\n        static final String REGEX_ALPHANUMBERIC_STRINGS_WITH_SUPPLEMENTARY_CHECK_CHARACTER = \"^[0-9A-Z]+[0-9A-Z*]$\";\n\n        /** 校验字符系统对应的正则表达式（不含校验字符） */\n        @SuppressWarnings(\"serial\")\n        static final Map<Designation, String> REGEX_MAPPING_WITHOUT_CHECK_CHARACTER_STRING = new HashMap<Designation, String>() {\n            {\n                put(Designation.ISO_7064_MOD_11_2, REGEX_NUMBERIC_STRINGS);\n                put(Designation.ISO_7064_MOD_37_2, REGEX_ALPHANUMBERIC_STRINGS);\n                put(Designation.ISO_7064_MOD_97_10, REGEX_NUMBERIC_STRINGS);\n                put(Designation.ISO_7064_MOD_661_26, REGEX_ALPHABETIC_STRINGS);\n                put(Designation.ISO_7064_MOD_1271_36,\n                        REGEX_ALPHANUMBERIC_STRINGS);\n                put(Designation.ISO_7064_MOD_11_HYBRID_10,\n                        REGEX_NUMBERIC_STRINGS);\n                put(Designation.ISO_7064_MOD_27_HYBRID_26,\n                        REGEX_ALPHABETIC_STRINGS);\n                put(Designation.ISO_7064_MOD_37_HYBRID_36,\n                        REGEX_ALPHANUMBERIC_STRINGS);\n            }\n        };\n\n        /** 校验字符系统对应的正则表达式（含校验字符） */\n        @SuppressWarnings(\"serial\")\n        static final Map<Designation, String> REGEX_MAPPING_WITH_CHECK_CHARACTER_STRING = new HashMap<Designation, String>() {\n            {\n                put(Designation.ISO_7064_MOD_11_2,\n                        REGEX_NUMBERIC_STRINGS_WITH_SUPPLEMENTARY_CHECK_CHARACTER);\n                put(Designation.ISO_7064_MOD_37_2,\n                        REGEX_ALPHANUMBERIC_STRINGS_WITH_SUPPLEMENTARY_CHECK_CHARACTER);\n                put(Designation.ISO_7064_MOD_97_10, REGEX_NUMBERIC_STRINGS);\n                put(Designation.ISO_7064_MOD_661_26, REGEX_ALPHABETIC_STRINGS);\n                put(Designation.ISO_7064_MOD_1271_36,\n                        REGEX_ALPHANUMBERIC_STRINGS);\n                put(Designation.ISO_7064_MOD_11_HYBRID_10,\n                        REGEX_NUMBERIC_STRINGS);\n                put(Designation.ISO_7064_MOD_27_HYBRID_26,\n                        REGEX_ALPHABETIC_STRINGS);\n                put(Designation.ISO_7064_MOD_37_HYBRID_36,\n                        REGEX_ALPHANUMBERIC_STRINGS);\n            }\n        };\n\n        static boolean regexMatch(String inputString, String regex) {\n            Pattern pattern = Pattern.compile(regex);\n            Matcher matcher = pattern.matcher(inputString);\n            return matcher.matches();\n        }\n    }\n\n    /** 适用于数字的校验字符系统的数值对应表 */\n    private static final String[] NUMBERIC_STRINGS = { \"0\", \"1\", \"2\", \"3\", \"4\",\n            \"5\", \"6\", \"7\", \"8\", \"9\", \"X\" };\n    /** 适用于字母的校验字符系统的数值对应表 */\n    private static final String[] ALPHABETIC_STRINGS = { \"A\", \"B\", \"C\", \"D\",\n            \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\",\n            \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\" };\n    /** 适用于字母数字的校验字符系统的数值对应表 */\n    private static final String[] ALPHANUMBERIC_STRINGS = { \"0\", \"1\", \"2\", \"3\",\n            \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\",\n            \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\",\n            \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"*\" };\n\n    /**\n     * 校验字符系统验证器\n     */\n    private static class CheckCharacterSystemValidator {\n        static boolean validate(String inputString, Designation designation) {\n            switch (designation) {\n                case ISO_7064_MOD_11_2:\n                case ISO_7064_MOD_37_2:\n                case ISO_7064_MOD_97_10:\n                case ISO_7064_MOD_661_26:\n                case ISO_7064_MOD_1271_36:\n                    return validatePureSystem(inputString, designation);\n                case ISO_7064_MOD_11_HYBRID_10:\n                case ISO_7064_MOD_27_HYBRID_26:\n                case ISO_7064_MOD_37_HYBRID_36:\n                    return validateHybridSystem(inputString, designation);\n                default:\n                    return false;\n            }\n        }\n\n        /**\n         * 纯系统校验\n         */\n        static boolean validatePureSystem(String inputString,\n                Designation designation) {\n            int M = 0; // 模数\n            int r = 0; // 基数\n            List<String> mapping = null;\n            switch (designation) {\n                case ISO_7064_MOD_11_2:\n                    M = 11;\n                    r = 2;\n                    mapping = Arrays.asList(NUMBERIC_STRINGS);\n                    break;\n                case ISO_7064_MOD_37_2:\n                    M = 37;\n                    r = 2;\n                    mapping = Arrays.asList(ALPHANUMBERIC_STRINGS);\n                    break;\n                case ISO_7064_MOD_97_10:\n                    M = 97;\n                    r = 10;\n                    mapping = Arrays.asList(NUMBERIC_STRINGS);\n                    break;\n                case ISO_7064_MOD_661_26:\n                    M = 661;\n                    r = 26;\n                    mapping = Arrays.asList(ALPHABETIC_STRINGS);\n                    break;\n                case ISO_7064_MOD_1271_36:\n                    M = 1271;\n                    r = 36;\n                    mapping = Arrays.asList(ALPHANUMBERIC_STRINGS);\n                    break;\n                default:\n                    return false;\n            }\n            char[] strArray = inputString.toCharArray();\n            int S = 0;\n            int n = strArray.length;\n            for (int i = 1; i <= n; i++) {\n                // 注意这里不要使用Math的pow方法\n                S += mapping.indexOf(String.valueOf(strArray[i - 1]))\n                        * BigInteger.valueOf(r).pow(n - i)\n                                .mod(BigInteger.valueOf(M)).intValue();\n            }\n            return S % M == 1;\n        }\n\n        /**\n         * 混合系统校验\n         */\n        static boolean validateHybridSystem(String inputString,\n                Designation designation) {\n            int M = 0; // 模数1\n            List<String> mapping = null;\n\n            switch (designation) {\n                case ISO_7064_MOD_11_HYBRID_10:\n                    M = 10;\n                    mapping = Arrays.asList(NUMBERIC_STRINGS);\n                    break;\n                case ISO_7064_MOD_27_HYBRID_26:\n                    M = 26;\n                    mapping = Arrays.asList(ALPHABETIC_STRINGS);\n                    break;\n                case ISO_7064_MOD_37_HYBRID_36:\n                    M = 36;\n                    mapping = Arrays.asList(ALPHANUMBERIC_STRINGS);\n                    break;\n                default:\n                    return false;\n            }\n            int Mplus1 = M + 1; // 模数2\n            char[] strArray = inputString.toCharArray();\n            int S = M + mapping.indexOf(String.valueOf(strArray[0]));\n            int P = 0;\n            for (int i = 1; i < strArray.length; i++) {\n                P = ((S % M == 0 ? M : S % M) * 2) % Mplus1;\n                S = P + mapping.indexOf(String.valueOf(strArray[i]));\n            }\n            return S % M == 1;\n        }\n    }\n\n    /**\n     * 校验字符生成器\n     */\n    private static class CheckCharacterComputor {\n        static String compute(String inputString, Designation designation) {\n            switch (designation) {\n                case ISO_7064_MOD_11_2:\n                case ISO_7064_MOD_37_2:\n                    return polynomialMethod4PureSystemWith1CheckChar(\n                            inputString, designation);\n                case ISO_7064_MOD_97_10:\n                case ISO_7064_MOD_661_26:\n                case ISO_7064_MOD_1271_36:\n                    return polynomialMethod4PureSystemWith2CheckChar(\n                            inputString, designation);\n                case ISO_7064_MOD_11_HYBRID_10:\n                case ISO_7064_MOD_27_HYBRID_26:\n                case ISO_7064_MOD_37_HYBRID_36:\n                    return recursiveMethod4HybridSystemWith1CheckChar(\n                            inputString, designation);\n                default:\n                    return null;\n            }\n        }\n\n        /**\n         * 通过多项式法计算纯系统一位校验字符\n         */\n        static String polynomialMethod4PureSystemWith1CheckChar(String str,\n                Designation designation) {\n            int M = 0; // 模数\n            int r = 0; // 基数\n            List<String> mapping = null;\n            switch (designation) {\n                case ISO_7064_MOD_11_2:\n                    M = 11;\n                    r = 2;\n                    mapping = Arrays.asList(NUMBERIC_STRINGS);\n                    break;\n                case ISO_7064_MOD_37_2:\n                    M = 37;\n                    r = 2;\n                    mapping = Arrays.asList(ALPHANUMBERIC_STRINGS);\n                    break;\n                default:\n                    break;\n            }\n            char[] strArray = str.toCharArray();\n            int S = 0;\n            int n = strArray.length + 1;\n            for (int i = n; i >= 2; i--) {\n                // 注意这里不要使用Math的pow方法\n                S += mapping.indexOf(String.valueOf(strArray[n - i]))\n                        * BigInteger.valueOf(r).pow(i - 1)\n                                .mod(BigInteger.valueOf(M)).intValue();\n            }\n            return mapping.get((M + 1 - S % M) % M);\n        }\n\n        /**\n         * 通过多项式法计算纯系统二位校验字符\n         */\n        static String polynomialMethod4PureSystemWith2CheckChar(String str,\n                Designation designation) {\n            int M = 0; // 模数\n            int r = 0; // 基数\n            List<String> mapping = null;\n            switch (designation) {\n                case ISO_7064_MOD_97_10:\n                    M = 97;\n                    r = 10;\n                    mapping = Arrays.asList(NUMBERIC_STRINGS);\n                    break;\n                case ISO_7064_MOD_661_26:\n                    M = 661;\n                    r = 26;\n                    mapping = Arrays.asList(ALPHABETIC_STRINGS);\n                    break;\n                case ISO_7064_MOD_1271_36:\n                    M = 1271;\n                    r = 36;\n                    mapping = Arrays.asList(ALPHANUMBERIC_STRINGS);\n                    break;\n                default:\n                    break;\n            }\n            char[] strArray = str.toCharArray();\n            int S = 0;\n            int n = strArray.length + 2;\n            for (int i = n; i >= 3; i--) {\n                // 注意这里不要使用Math的pow方法\n                S += mapping.indexOf(String.valueOf(strArray[n - i]))\n                        * BigInteger.valueOf(r).pow(i - 1)\n                                .mod(BigInteger.valueOf(M)).intValue();\n            }\n            return mapping.get(((M + 1 - S % M) % M) / r)\n                    + mapping.get(((M + 1 - S % M) % M) % r);\n        }\n\n        /**\n         * 通过递归法法计算混合系统一位校验字符\n         */\n        static String recursiveMethod4HybridSystemWith1CheckChar(\n                String inputString, Designation designation) {\n            int M = 0; // 模数1\n            List<String> mapping = null;\n            switch (designation) {\n                case ISO_7064_MOD_11_HYBRID_10:\n                    M = 10;\n                    mapping = Arrays.asList(NUMBERIC_STRINGS);\n                    break;\n                case ISO_7064_MOD_27_HYBRID_26:\n                    M = 26;\n                    mapping = Arrays.asList(ALPHABETIC_STRINGS);\n                    break;\n                case ISO_7064_MOD_37_HYBRID_36:\n                    M = 36;\n                    mapping = Arrays.asList(ALPHANUMBERIC_STRINGS);\n                    break;\n                default:\n                    break;\n            }\n            int Mplus1 = M + 1; // 模数2\n            char[] strArray = inputString.toCharArray();\n            int S = 0;\n            int P = M;\n            int n = strArray.length + 1;\n            for (int i = n; i >= 2; i--) {\n                S = P + mapping.indexOf(String.valueOf(strArray[n - i]));\n                P = ((S % M == 0 ? M : S % M) * 2) % Mplus1;\n            }\n            return mapping.get((M + 1 - P % M) % M);\n        }\n    }\n}\n```\n\n\n\n\n\n# 算法设想\n\n- 由一个字母作为开头，用于区分物品大类别。该字母区分大小写，对于字母的转换公式为：\n  - 如果这个字母是大写的，则分别对应1、2、3、...、26；\n  - 如果这个字母是大写的，则分别对应27、28、29、...、52。\n- 第二位是一个字母，与第一位一样，区分大小写，用于表明小类别。包括不限于：（具体对应规则待定）\n  - 单片机相关\n  - 芯片\n  - 贴片原件\n  - 电池\n  - 电路板\n- 第三位到第五位为纯数字。从001起，截止999。\n- 第六到第十位比较特殊：\n  - 对于收纳盒指示而言，这五位可以缺省。\n  - 对于物品来说，这五位不可缺省，范围是00001-99999。\n  - 对于第五位和第六位之间使用连字符`-`作为连接，但这一位只作为区分，不参与校验运算。\n- 第六位/第十一位为校验码，用于校验数据。\n\n\n\n## 样例\n\n- 对于外部收纳部分：`AA001X`\n- 对于物品部分：`AA001X-00001`\n\n\n\n\n\n# 校验方法\n\n与身份证校验类似，字母位要转换成对应的数字然后参与运算。\n\n\n\n","tags":["protected","编码规则","程序片段"],"categories":["程序片段"]},{"title":"高通410随身wifi刷机教程","url":"/2023/06/18/高通410随身wifi刷机教程/","content":"\n# 前言\n\n本教程适用于基于高通410的cpu随身wifi。\n\n## 基本样式\n\n![image-20230618201847745](./Image/随身WiFi刷机教程.assets/image-20230618201847745.png)\n\n如果需要刷openwrt和Debian，只有纸盒系和类纸盒的uz801、sp970，其它型号不能刷。（不确定 没尝试过）\n\n## 常见问题\n\n简单说几个常见问题: \n\n- SIM卡要插对；\n- 天线别弄掉了（弄掉了再插回去）；\n- 板子所处位置的信号不能太差，台式电脑建议用后面主板的USB口，有些电脑前置USB口容易供电不足；\n- 很多软件问题可以重启或者更换电脑就能解决；\n- 刷机前最好先备份；\n- 拿到板子后插卡确认能否识别sim卡以及数据wifi功能是否正常，然后撬开外壳确定自己的板子是什么型号。\n\n\n\n## 准备工作\n\n​\t工具文件可能被系统报毒删除，所以以win10为例，建议新建一个随身WiFi文件夹，然后在Windows安全中心一病毒和威胁防护一病毒威胁防护设置一管理设置一排除项一添加排除项，把文件夹添加进去，然后把刷机文件下载到这里，就不会被系统删除了，其它杀毒软件也可以类似这样设置。\n\n### 安装驱动\n\n需要提前安装高通的驱动：高通板子刷机需要安装`9008驱动`和`adb驱动`，打开并安装文件里的`9008driver`\n\n![image-20230618202325523](./Image/随身WiFi刷机教程.assets/image-20230618202325523.png)\n\n把板子插上电脑，等待板子完全开机后，输入命令: `adb devices`\n\n如果显示有设备连接就说明adb正常 (有些板子adb功能没有打开，可以在本版块搜索开启方法)（比如直接9008刷入其他刷完的包）\n\n### 进入9008的方法\n\n需要9008刷机时再开启此端口。\n\n#### adb命令进入\n\n```\nadb reboot edl\n```\n\n#### 通过按键进入\n\n按住板子的恢复键，插入电脑一两秒后听到叮咚一声再松手，在设备管理器里看到端口有9008就表示成功了。（不是所有按键都可以进入9008，进入不了参考下一条方法）\n\n#### 其他方法\n\n可以尝试短接usb数据针脚（d+ d-）插入电脑再松开。\n\n\n\n成功进入后可以在端口中找到9008字样的设备。\n\n![image-20230618202835177](./Image/随身WiFi刷机教程.assets/image-20230618202835177.png)\n\n\n\n\n\n# 备份\n\n这一步非常重要！不建议拿到板子后直接刷的rom包，应该先备份好当前的rom，之后再刷。只要硬件没坏都能救活。\n\n如果自己的板子系统是阉割版的，比如没有热点和网络共享等，可以刷一下别的设备的system包，其它情况不太需要刷别的文件。\n\n备份主要有三个过程：备份基带、Miko loader制作救砖包（全量备份）、\n\n\n\n\n\n## 备份固件-miko\n\n### 安装Miko\n\n找到miko文件夹，双击miko安装，直接默认就行了，记住安装路径，安装完成后把文件夹内的loader复制到miko的安装目录，替换掉原来的loader.exe。接着创建loader的快捷方式到桌面。\n\n### loader备份\n\n让板子进入9008模式，打开loader，按照图片数字顺序一步步来。\n\n![image-20230618203629046](./Image/随身WiFi刷机教程.assets/image-20230618203629046.png)\n\n1. 点read；\n2. 点partition backup；\n3. 双击下面double click to open save folder；\n4. 选好救砖包生成的路径：点load partition structure；\n5. 点击全选按钮选中所有的分区；\n6. 点read full image就能制作刷机救砖包，大概5分钟以内。\n\n\n\n**保存好这个名为.bin的单文件，后期救砖需要它**\n\n刷机/救砖方法图片也标注了顺序，分别点flash，emmc block0，flasher，double click....， flash!\n\n![image-20230618203939677](./Image/随身WiFi刷机教程.assets/image-20230618203939677.png)\n\n\n\n\n\n## 备份固件-QPT\n\n用Qualcomm Premium Tool（QPT）备份全部分区文件。\n\n### 激活QPT（只需要激活一次）\n\n打开它的文件夹，有个提示先注册的程序，**注意要把电脑音量调低**!。然后点开它后可能会提示安装一些东西，同意就行了，没有的话不用管，弹出窗口点击GenerateKey,生成的key放在你知道的文件夹内。\n\n![image-20230618204354428](./Image/随身WiFi刷机教程.assets/image-20230618204354428.png)\n\n打开Qualcomm Premium Tool程序，左上菜单栏找到help-active,选择刚才生成的key就能激活这个软件了。\n\n![image-20230618204511362](./Image/随身WiFi刷机教程.assets/image-20230618204511362.png)\n\n\n\n### 备份\n\n按照前面介绍的方法使板子进入9008模式，在Qualcomm Premium Tool按照图片数字一步一步进行。\n\n注意，如果前面Miko备份完，记得拔掉棒子再次进入9008后再进行备份。\n\n![image-20230618205206475](./Image/随身WiFi刷机教程.assets/image-20230618205206475.png)\n\n1. Qualcomm选项卡\n2. partition子选项卡\n3. scan单选按钮\n4. Do job按钮\n5. backup单选按钮\n6. backup ALL复选框\n7. Do job按钮\n\n**备份的文件保存好，后续可能有用**\n\n如果需要刷写某些分区，点击scan识别分区后，点write, 再选要刷如果需要刷写某些分区，点击扫描识别分区后，点写，再选要刷的分区，点Do job后选择分区文件，就能完成刷写该分区。的分区，点做好后选择分区文件，就能完成刷写该分区。\n\n\n\n## 备份基带（需要进行root操作）\n\n### 前提\n\n- 在设备管理器中的`端口（COM和LPT）`中可以看到9091或901D字样的设备\n  - ![image-20230618201209783](./Image/随身WiFi刷机教程.assets/image-20230618201209783.png)\n- `通用串行总线设备`中看到`ADB interface`字样的设备（或者在最开头的几个选项卡中）\n  - ![image-20230618201228226](./Image/随身WiFi刷机教程.assets/image-20230618201228226.png)\n\n### root\n\n备份qcn和root。需要先进行root,简单点的办法就是安装magisk,再刷一下修补过的boot文件就有root了。当然我更建议自\n己修补boot,不用等别人做好，出问题的概率也更小。\n\n下面是如何自己动手获得root权限:\n\n1. 首先安装ardc,这是一个投屏软件，解决板子没有屏幕无法操作的问题，它的操作逻辑是鼠标左键为点击功能，右键为返回。\n\n2. 安装完ardc后先别打开，检查一下任务管理器中，有adb或者android debug bridge程序在后台的话记得停掉，再把板子插到电脑上正常启动，打开ardc等待画面变化，成功后会停在深蓝色界面，然后把鼠标箭头移到此界面，右键点击两下，如果没有出现桌面，需要安装一个第三方桌面启动器，把我提供的apk文件里的launcher从电脑直接托到ardc界面就会自动给板子安装。\n\n   - ![image-20230618205724109](./Image/随身WiFi刷机教程.assets/image-20230618205724109-1687093045038-2.png)\n\n3. 等五秒后在主界面点一下鼠标右键，应该会出现选择主屏幕应用选择，点launcher和始终。\n\n   - ![image-20230618205818554](./Image/随身WiFi刷机教程.assets/image-20230618205818554.png)\n\n4. 然后就能看到板子的系统界面了，接着安装es文件管理器和magisk,也是直接拖到ardc界面自动安装，装好后点开文件管理\n   器，进入下载文件夹，把之前Qualcomm备份的boot文件直接托到这里，就会复制过来了(几秒钟，点下面的刷新就会显示出来) \n\n   - ![image-20230618205930680](./Image/随身WiFi刷机教程.assets/image-20230618205930680.png)\n   - ![image-20230618205941815](./Image/随身WiFi刷机教程.assets/image-20230618205941815.png)\n\n5. 退出es,点开magisk,找到图片提示的位置\n\n   - ![image-20230618210010973](./Image/随身WiFi刷机教程.assets/image-20230618210010973.png)\n\n6. 安装>下一步>选择并修补一个文件，选择刚才复制过来的boot,然后开始，等待它修补完成，退出并来到es文件管理器，进入下载，发现修补好的boot文件名太长了，长按后重命名为magiskboot.img。再点击ardc菜单最后一个>>;弹出的cmd这里(实际就是这个软件也集成了adb功能，这里直接使用它的)\n\n   - ![image-20230618210302473](./Image/随身WiFi刷机教程.assets/image-20230618210302473.png)\n\n7. 输入命令: \n\n   ```\n   adb pull /sdcard/Download/magiskboot.img D:/xxx\n   ```\n\n   这里D:/xxx换成你自己的路径(斜杠朝左还是朝右都可以)，接着按回车就会把magiskboot.img导出到你的电脑上的指定位置。\n\n8. 再输入命令: \n\n   ```\n   adb reboot bootloader\n   ```\n\n   板子会重启到fastboot模式，然后输入命令: \n\n   ```\n   fastboot flash boot \n   ```\n\n   后再按个空格键，接着把电脑上 上一步备份的boot文件`magiskboot.img`拖到这里，会自动生成文件路径名成文件路径名。\n\n   - ![image-20230618210626935](./Image/随身WiFi刷机教程.assets/image-20230618210626935.png)\n\n9. 再按回车等待几秒完成后输入命令:\n\n   ```\n   fastboot reboot\n   ```\n\n   板子重启后打开magisk (可能得多等会)，看到下面四个图标，第二个就是超级用户，那么root就完成了。\n\n   - ![image-20230618210724332](./Image/随身WiFi刷机教程.assets/image-20230618210724332.png)\n\n\n\n\n\n\n\n### 备份\n\n1. 下面是备份qcn的工作，依然在ARDC的>>这里的cmd后输入命令: \n\n   ```\n   adb shell su\n   ```\n\n   然后会显示shell申请权限，点永久就行了，接着在magisk的超级用户里看看shell授权成功与否。\n\n   - ![image-20230618213147447](./Image/随身WiFi刷机教程.assets/image-20230618213147447.png)\n\n2. 关掉ardc，同时在任务管理器里如果发现adb还在后台也要关掉，然后打开星海svip这个软件 (免安装)，如果打开时提示缺少库文件，安装我提供的微软软件包，装好后最好重启一下电脑就能打开星海了，以后如果操作没问题，这个软件还是报错的就重启电脑\n   选择高通，再点联机会出现设备信息，找到高通强开1（如果不行也可以试试强开2），点一键执行，在设备管理器上查看是否有端口901D（如果开启失败可以尝试手动开启，文件夹里有命令代码）\n\n   - ![image-20230618213321287](./Image/随身WiFi刷机教程.assets/image-20230618213321287.png)\n   - ![image-20230618213402181](./Image/随身WiFi刷机教程.assets/image-20230618213402181.png)\n\n3. 接着备份qcn，一键执行，选择qcn文件生成路径，正常情况就能备份qcn成功，如果不行就检查901d端口或者重启电脑，备份的qcn一般在500多k，远小于这个大小的应该是备份失败了，建议再来一次。\n\n   - ![image-20230618213444362](./Image/随身WiFi刷机教程.assets/image-20230618213444362.png)\n\n\n\n## 注意事项\n\n高通工具的备份和miko的备份的不同：\n\n- miko它是把所有的分区全部备份成一个单个的文件\n- 高通的这个备份它是把每一个分区备份成单独的文件\n\n两者两种方式备份出来的文件数量有区别，但本质上来说备份的是同一个东西。\n\n高通的这个工具备份出来的这个分区文件是可以用其他工具来打开并且提取里面的内容的\n\n而miko的呢不行。\n\n同样的在还原的时候，因为刷完Debian以后所有的分区都会被改动掉，所以用高通的工具去还原会发现对应不上分区。所以得用miko的工具来还原。\n\n\n\n# 刷机\n\n## android\n\nAndroid，一般情况刷回自己的包就用Miko loader这个软件，比较简单。刷单个分区，可以用Qualcomm工具，前面都已经介绍；\n\n或者进fastboot模式，用命令刷分区，比如刷system分区，命令就是fastboot flash system 加上分区路径 (和前面刷boot一样，直接\n拖到这里，如果失败，把文件放到adb目录下，把分区路径换成分区文件名system.img也能刷，效果更好)\n\n## Debian\n\n刷机过程作者网址有介绍，001b 001c sp970 uz801作者给了boot和firmware文件用来替换。如果刷后不识别手机卡，可以这样\n试试看：\n\t参考了酷友lkiuyu 的动态，刷回安卓，恢复出厂设置，再root后用星海擦写基带 (擦写基带在fastboot模式下)，接着写入自己的qcn (写入qcn也要开启901d端口)，才能装Debian，boot要替换成作者提供的001c的，别用自己的。firmware需要替换成自己备份的 (把Qualcomm工具备份的NON-HLS.bin用diskgenius的虚拟磁盘打开并提取出来，接着用winscp登录Debian后把它复制到/home/user下，再ssh登录Debian，sudo -i获得权限，再用命令cp -rf /home/user/你提取的基带文件/*/usr/lib/firmware/，完成替换，重启板子基带应该就能用了。\n\n\n\n项目地址：\n\n\n\n\n\n大致步骤如下：\n\n1. 重启到fastboot模式\n\n   - ```\n     //使用adb连接到设备\n     adb devices\n     \n     //重启到fastboot\n     adb reboot fastboot\n     ```\n\n   - 重启完事后可以在设备管理器中ADB相关的设备里面有个`Fastboot interface`字样的设备。出现这个设备的时候就证明设备已经重启到fastboot模式下了。\n\n2. 解压Debian文件夹中的 `base-generic.zip` 文件，进入解压出来的文件夹中\n\n   - ![image-20230618215120258](./Image/随身WiFi刷机教程.assets/image-20230618215120258.png)\n\n3. 点击地址栏，删除其中的内容，然后输入 `cmd` 打开cmd\n\n4. 在cmd的命令提示符中输入`flash.bat`，然后回车执行。\n\n   - ![image-20230618215310151](./Image/随身WiFi刷机教程.assets/image-20230618215310151.png)\n\n5. 中途会提示按任意键继续，根据提示按下任意一个键进行下一步。中途可能会听到设备弹出后再插入的提示音。继续按空格即可。\n\n6. 回到上一级，解压 `debian.zip` 文件，并进入解压出来的文件夹中\n\n   - ![image-20230618215517226](./Image/随身WiFi刷机教程.assets/image-20230618215517226.png)\n\n7. 再次清空地址栏，输入cmd，打开cmd窗口。\n\n8. 继续flash.bat，回车运行。\n\n   - ![image-20230618215614847](./Image/随身WiFi刷机教程.assets/image-20230618215614847.png)\n\n9. 继续按照提示按下任意按键。这回可能就需要一段时间了，因为正在推送系统到设备。\n\n   \n\n\n\n## OpenWrt\n\nOpenWrt刷机就简单多了，进入fastboot模式打开脚本自动刷原作者仍只提供了001b版本，其它型号直接在本版块搜索，有不少酷友编译。如果遇到问题可以到我另一个动态看看解决办法。最后说一下，Debian和openwrt都有adb功能，刷这些系统都可以进fastboot模式刷，不用回到安卓。\n\n\n\n\n\n\n\n\n\n\n\n# Linux相关\n\n\n\n## 刷完初次进入linux时的准备工作\n\n检查`网络适配器`中是否存在一个基于远程NDIS的Internet共享…\n\n如果不存在，且在`其他设备`中存在一个名叫 `RNDIS`的设备，则右键点击这个设备，选择`更新驱动程序`，选择`浏览我的电脑以查找驱动程序`，接着 `让我从计算机上的可用驱动程序列表中选取`，拉到最下面找到 `网络适配器`，在厂商一栏中找到 `MicroSoft`，右侧的型号栏目中选择 `基于远程NDIS的Internet共享设备`。\n\n\n\n## 基础的系统配置\n\n1. 登录系统：初始用户：`user`，初始密码`1`\n\n2. 连接WIFI\n\n   ```bash\n   sudo nmtui\n   ```\n\n   会显示一个蓝色背景的界面，使用上下光标键移动，选择 `Activate a connection`（回车），选择要连接的WiFi，回车，输入wifi密码，回车。\n\n   连上以后wifi名的左侧会多一个*号，同时右侧会有一个 `Deactivate`断开的选项。\n\n   按tab键将光标移动到back，回车，选择 `Quit`回车，回到ssh界面。\n\n   使用 `sudo ifconfig`命令就能看到一个连上WiFi以后得到的ip地址。\n\n   接下来就能使用这个ip地址进行登录。此时棒子就可以不插在电脑上，插在任意一个具有供电能力的设备上都能连接上了。\n\n   \n\n3. 配置root用户密码\n\n   ```BASH\n   sudo passwd root\n   ```\n\n   接下来要输入设置的密码。注意输入密码的时候是不可见的。\n\n   \n\n4. 切换到root用户\n\n   ```bash\n   sudo su\n   ```\n\n   \n\n5. 允许root用户远程登录，重启服务或系统后生效\n\n   ```bash\n   echo \"PermitRootLogin yes\" >> /etc/ssh/sshd_config\n   ```\n\n   \n\n6. 修复mobian源并安装基础软件（逐行复制并执行）\n\n   ```bash\n   apt update\n   \n   apt install curl -y\n   \n   echo \"deb http://repo.mobian-project.org/ bookworm main non-free\" > /etc/apt/sources.list.d/mobian.list\n   curl -s https://repo.mobian.org/mobian.gpg > /etc/apt/trusted.gpg.d/mobian.gpg\n   \n   apt update\n   \n   apt install vim wget git cron dnsutils unzip lrzsz fdisk gdisk exfat-fuse exfat-utils -y\n   ```\n\n   可能需要一段时间，耐心等待即可。\n\n   \n\n7. 配置系统时间\n\n   ```\n   dpkg-reconfigure tzdata\n   ```\n\n   选6 亚洲\n\n   然后选70 上海（亚洲 上海），需要按回车显示下一页，直到70 shanghai的选项出现，才能输入70.\n\n8. 配置ll命令\n\n   ```bash\n   echo \"alias ll='ls $LS_OPTIONS -alh'\" >> ~/.bashrc\n   ```\n\n   \n\n9. 修改vi配置\n\n   ```bash\n   echo -e \"if has('mouse')\\nset mouse-=a\\nendif\" > .vimrc\n   ```\n\n   \n\n10. 修改usb为主动模式\n\n    ```bash\n    vi /usr/sbin/mobian-usb-gadget\n    ```\n\n    把下面这行添加到[ `setup() {` ]的下一行\n\n    `echo host > /sys/kernel/debug/usb/ci_hdrc.0/role`\n\n    然后`:wq`保存退出\n\n    注意，此条命令一旦执行，棒子再插到电脑上就不会显示成设备了，而是作为一个独立的主机存在。\n\n    \n\n11. 重启设备\n\n    ```bash\n    reboot\n    ```\n\n\n\n## 挂载u盘、配置开启启动、安装软件\n\n由于后续所有操作都直接用root用户登陆后操作，删掉已经没用的自带用户user\n\n```bash\nuserdel -r user\n```\n\n\n\n### 挂载u盘\n\n1. 创建用于挂载的目录\n\n   ```\n   mkdir /udisk\n   ```\n\n   \n\n2. 插上U盘，查看是否已经识别到\n\n   ```\n   fdisk -l\n   ```\n\n   可以看到Disk开头的文本，默认是挂载在`/dev/sda`目录中。\n\n   也有可能是sdb，一定要区分好\n\n3. 清理磁盘分区并新建（如果是大于2T的移动硬盘，下一条命令中的fdisk换成gdisk）\n\n   ```\n   fdisk /dev/sda\n   ```\n\n   然后按下如下字母执行操作\n\n   - d   #删除分区\n\n     - 可以多按几下，直到出现 `No partition is defined yet`提示没有任何分区为止。\n\n   - n   #新建分区，一路回车\n\n     - 如果提示yes or no，输入y然后回车\n\n   - w   #保存更改\n\n     - 如果提示yes or no，输入y然后回车\n\n     \n\n     \n\n4. 再用 `fdisk -l`命令查看，可以发现插入的存储设备挂载的目录可能发生了变化。**记住这个目录，后面要用**.\n\n   比如 /dev/sda1\n\n   \n\n5. 格式化分区\n\n   ext4性能好安全性高但不兼容windows，exfat性能差安全性差但兼容windows\n\n   ```bash\n   mkfs.ext4 /dev/sda1\n   \n   或\n   \n   mkfs.exfat /dev/sda1\n   ```\n\n   二者选其一执行。推荐ext4格式。\n\n   注意，如果存储设备是金士顿的这类写入速度很慢的设备，则此过程可能会很久，甚至卡死。\n\n6. 挂载\n\n   ```bash\n   #挂载\n   mount /dev/sda1 /udisk\n   \n   #mount /dev/sdb1 /hdisk\n   \n   #授权\n   chmod 777 /udisk\n   ```\n\n   \n\n\n\n### 配置开机行为\n\n1. 创建启动脚本\n\n   ```bash\n   touch /etc/rc.local\n   \n   echo '#!/bin/sh -e' > /etc/rc.local\n   \n   echo \"exit 0\" >> /etc/rc.local\n   ```\n\n   \n\n2. 给权限\n\n   ```bash\n   chmod +x /etc/rc.local\n   ```\n\n   \n\n3. 重载systemd配置管理器\n\n   ```bash\n   systemctl daemon-reload\n   ```\n\n   \n\n4. 启动守护进程\n\n   ```bash\n   systemctl start rc-local\n   ```\n\n   \n\n5. 修改启动脚本\n\n   ```bash\n   vi /etc/rc.local\n   ```\n\n   将下方代码块中的内容复制到vi编辑器中。注意复制之前需要删除原有的数据。注意#开头的中文注释需要删除掉，因为可能会乱码\n\n   ```bash\n   #!/bin/sh -e\n   #等待2秒等待设备彻底启动完成\n   sleep 2\n   #开机自动挂载硬盘，可以修改成fstab？\n   mount /dev/sda1 /udisk &\n   #等待5秒等待挂载完毕\n   sleep 3\n   \n   #如果不安装接下来的miniDLNA，则这部分的内容不需要复制\n   #清空minidlna缓存\n   minidlnad -R\n   #等待3秒等待清空完成\n   sleep 2\n   #启动dlna\n   systemctl start minidlna &\n   \n   \n   #如果不安装接下来的aria2，则这部分的内容不需要复制\n   #启动aria2\n   aria2c -D --conf-path=/etc/aria2/aria2.conf &\n   \n   \n   \n   #可以试图把ddns的脚本粘贴到这里面\n   \n   \n   exit 0\n   ```\n\n   \n\n## 安装软件\n\n\n\n### samba共享\n\n1. 安装samba\n\n   ```bash\n   apt install samba samba-common-bin -y\n   ```\n\n   \n\n2. 修改配置文件\n\n   ```bash\n   vi /etc/samba/smb.conf\n   ```\n\n   将下方代码块中的内容复制到配置文件中。进入vi编辑器后要删除掉所有原来的数据。\n\n   ```bash\n   [global]\n      workgroup = WORKGROUP\n      log file = /var/log/samba/log.%m\n      max log size = 1000\n      panic action = /usr/share/samba/panic-action %d\n      passdb backend = tdbsam\n      obey pam restrictions = yes\n      unix password sync = yes\n      security = user\n      passwd program = /usr/bin/passwd %u\n      passwd chat = *Enter\\snew\\s*\\spassword:* %n\\n *Retype\\snew\\s*\\spassword:* %n\\n *password\\supdated\\ssuccessfully* .\n      pam password change = yes\n      map to guest = bad user\n      load printers = no\n   [samba]\n      browseable = yes\n      valid users = root\n      #samba共享的目录\n      path = /udisk\n      writable = yes\n      public = no\n      guest ok = no\n   ```\n\n   \n\n3. 配置samba用户，输入密码\n\n   ```bash\n   smbpasswd -a root\n   ```\n\n   \n\n4. 重启samba服务\n\n   ```bash\n   samba restart\n   ```\n\n   \n\n\n\n#### 注意事项与说明\n\n- samba用于局域网间共享文件\n- samba虽然也有端口号，也有协议，但没办法映射外网，是没有办法跨网段的，只能在当前网段中使用。\n\n\n\n### aria2下载器\n\n1. 新建下载目录并给权限\n\n   ```bash\n   #分配文件夹\n   mkdir /udisk/download\n   \n   #授权\n   chmod 777 /udisk/download\n   ```\n\n   \n\n2. 安装aria2\n\n   ```bash\n   apt install aria2 -y\n   ```\n\n   \n\n3. 创建aria2配置目录\n\n   ```bash\n   mkdir /etc/aria2\n   ```\n\n   \n\n4. 创建aria2会话文件\n\n   ```bash\n   touch /etc/aria2/aria2.session\n   ```\n\n   \n\n5. 创建aria2配置文件\n\n   ```bash\n   vi /etc/aria2/aria2.conf\n   ```\n\n   将下方代码块中的内容复制到vi编辑器中。注意配置信息不可以是别的，或者需要再修改一下，否则可能无法下载\n\n   ```ini\n   #下载地址\n   dir=/udisk/download\n   disk-cache=32M\n   continue=true\n   file-allocation=none\n   max-concurrent-downloads=5\n   max-connection-per-server=5\n   max-overall-download-limit=0\n   max-download-limit=0\n   max-overall-upload-limit=0\n   max-upload-limit=0\n   disable-ipv6=true\n   min-split-size=10M\n   split=10\n   input-file=/etc/aria2/aria2.session\n   save-session=/etc/aria2/aria2.session\n   save-session-interval=60\n   enable-rpc=true\n   rpc-allow-origin-all=true\n   rpc-listen-all=true\n   follow-torrent=true\n   #peer-id-prefix=-TR2770-\n   user-agent=Transmission/2.77\n   bt-seed-unverified=true\n   bt-save-metadata=true\n   bt-enable-lpd=true\n   bt-max-open-files=100\n   bt-max-peers=60\n   bt-min-crypto-level=plain\n   bt-require-crypto=true\n   listen-port=65298\n   dht-listen-port=65298\n   seed-ratio=1\n   seed-time=120\n   rpc-secret=test123\n   bt-tracker=udp://tracker.opentrackr.org:1337/announce,udp://9.rarbg.com:2810/announce,udp://tracker.openbittorrent.com:6969/announce,http://tracker.openbittorrent.com:80/announce,https://opentracker.i2p.rocks:443/announce,udp://tracker.torrent.eu.org:451/announce,udp://open.stealth.si:80/announce,udp://exodus.desync.com:6969/announce,udp://tracker2.dler.org:80/announce,udp://tracker.tiny-vps.com:6969/announce,udp://tracker.moeking.me:6969/announce,udp://tracker.dler.org:6969/announce,udp://tracker.0x.tf:6969/announce,udp://open.demonii.com:1337/announce,udp://movies.zsw.ca:6969/announce,udp://fe.dealclub.de:6969/announce,udp://explodie.org:6969/announce,udp://chouchou.top:8080/announce,udp://bt2.archive.org:6969/announce,udp://bt.oiyo.tk:6969/announce\n   ```\n\n\n\n#### 注意事项\n\n开机自启在之前已经配置过来，这里不需要再配置了。\n\n#####手动启动aria2\naria2c -D --conf-path=/etc/aria2/aria2.conf &\n\n##### 通过aria2.net调用，或者自建aria2 webui\n\nhttp://aria2.net/\n\n##### 使用端口\n\n6800\n\n\n\n\n\n\n\n### lamp环境与filerun 网页云盘\n\n注意，此教程只适合arrch64架构的设备，而且部分已经过时，需要注意\n\n1. 安装需要的软件\n\n   ```bash\n   apt install apache2 php mariadb-server php-mysql php-mbstring php-curl php-gd php-imagick ffmpeg -y\n   ```\n\n   \n\n2. 编辑虚拟站点配置\n\n   ```bash\n   vim /etc/apache2/sites-enabled/000-default.conf\n   ```\n\n   将下方代码块中的内容复制到配置文件中。进入vi编辑器后要删除掉所有原来的数据。\n\n   ```ini\n   <VirtualHost *:80>\n           DocumentRoot /var/www/html\n           ErrorLog ${APACHE_LOG_DIR}/error.log\n           CustomLog ${APACHE_LOG_DIR}/access.log combined\n   </VirtualHost>\n   ```\n\n   \n\n3. 修改数据库编码\n\n   ```bash\n   vi /etc/mysql/mariadb.conf.d/50-server.cnf\n   ```\n\n   在[mysqld]字段的添加或修改如下部分\n\n   ```ini\n   init_connect='SET collation_connection = utf8mb4_unicode_ci'\n   init_connect='SET NAMES utf8mb4'\n   character-set-server=utf8mb4\n   collation-server=utf8mb4_unicode_ci\n   skip-character-set-client-handshake\n   ```\n\n   \n\n   ```bash\n   vi /etc/mysql/mariadb.conf.d/50-client.cnf\n   ```\n\n   在[client]字段的修改如下部分\n\n   ```ini\n   default-character-set=utf8mb4\n   ```\n\n   \n\n   ```bash\n   vi /etc/mysql/mariadb.conf.d/50-mysql-clients.cnf\n   ```\n\n   在[mysql]字段下修改如下部分\n\n   ```ini\n   default-character-set=utf8mb4\n   ```\n\n   \n\n4. 重启数据库并初始化\n\n   ```bash\n   #重启数据库\n   systemctl restart mariadb\n   \n   #设置开机自启\n   systemctl enable mariadb\n   \n   #初始化\n   mysql_secure_installation\n   #会提示输入密码，当前没有密码，直接回车即可\n   #问是否切换到的时候输入n表示不切换\n   #询问是否修改密码还是n，不在这里修改\n   #是否移除匿名用户，输入y。Remove anonymous\n   #然后接下来的三个询问都输入y，直到退出\n   ```\n\n5. 进入数据库\t\n\n   ```bash\n   mysql -uroot -p\n   #由于没有密码直接回车就能进入\n   \n   USE mysql;\n   \n   #这里输入要设置的密码，替换到下方的test123\n   ALTER USER root@localhost IDENTIFIED VIA mysql_native_password USING PASSWORD('test123');\n   \n   FLUSH PRIVILEGES;\n   \n   #查看配置有没有生效，不打也可以\n   show variables like \"%character%\";show variables like \"%collation%\";\n   \n   EXIT;\n   \n   #重启数据库\n   systemctl restart mariadb\n   ```\n\n   \n\n6. 配置filerun运行环境：\n\n   注意不要cd切目录，保持再root用户登录后的初始目录中。\n\n7. 用pscp传输【loader-wizard.php】，【ioncube_loader_lin_7.4.so】，【00-ioncube.ini】，【FileRun_20220519_PHP73-74.zip】\n\n   在putty的目录中输入cmd，调出cmd命令框，然后在其中输入下方的几个命令，将文件传输到棒子\n\n   ```bash\n   pscp loader-wizard.php root@192.168.123.131:/root/\n   pscp ioncube_loader_lin_7.4.so root@192.168.123.131:/root/\n   pscp 00-ioncube.ini root@192.168.123.131:/root/\n   pscp FileRun_20220519_PHP73-74.zip root@192.168.123.131:/root/\n   ```\n\n   或者直接用其他方式将这些文件上传到棒子的`/root`目录下。\n\n   \n\n8. 将三个文件放到对应的目录下\n\n   ```bash\n   mv loader-wizard.php /var/www/html/loader-wizard.php\n   \n   mv ioncube_loader_lin_7.4.so /usr/lib/php/20210902/ioncube_loader_lin_7.4.so\n   \n   mv 00-ioncube.ini /etc/php/8.1/apache2/conf.d/00-ioncube.ini\n   \n   systemctl restart apache2\n   ```\n\n   \n\n9. 访问http://设备的IP/loader-wizard.php。如果看到绿色的框内容为：\n\n   ```bash\n   Loader Installed\n   The ionCube Loader version 11.0.1 for PHP 7.4 is already installed and encoded files should run without problems.\n   ```\n\n   ![image-20230619143037260](./Image/随身WiFi刷机教程.assets/image-20230619143037260.png)\n\n   如果是红色的框则证明之前的操作有问题\n\n   \n\n   那么运行环境就配置好了\n\n   \n\n10. 删掉无用的文件\n\n    ```bash\n    rm -rf /var/www/html/*\n    ```\n\n    \n\n11. 部署filerun文件包\n\n    ```bash\n    mkdir 11 && mv FileRun* 11 && unzip -d 11 11/FileRun* && rm 11/FileRun* && mv 11/* /var/www/html && rm -rf ~/11\n    \n    mkdir /var/www/html/userfile\n    ```\n\n    \n\n12. 设置filerun时区\n\n    ```bash\n    echo '<?php date_default_timezone_set(\"Asia/Shanghai\"); ?>' > /var/www/html/customizables/config.php\n    ```\n\n    \n\n13. 给权限，设置自启\n\n    ```bash\n    chmod -R 777 /var/www/html/\n    chmod -R 777 /udisk\n    \n    systemctl enable apache2\n    ```\n\n    \n\n14. 访问http://你的IP/，开始配置\n\n\n\n#### 配置Fire RUN\n\n![image-20230619143400943](./Image/随身WiFi刷机教程.assets/image-20230619143400943.png)\n\nnext下一步\n\n![image-20230619143426603](./Image/随身WiFi刷机教程.assets/image-20230619143426603.png)\n\n再next。应该都是绿色的OK字样。\n\n![image-20230619143748025](./Image/随身WiFi刷机教程.assets/image-20230619143748025.png)\n\n输入完对应信息，next。\n\n然后就会给一个初始用户。\n\n![image-20230619143853640](./Image/随身WiFi刷机教程.assets/image-20230619143853640.png)\n\n使用初始用户登录进去\n\n![image-20230619143933926](./Image/随身WiFi刷机教程.assets/image-20230619143933926.png)\n\n进入之后点击左侧下面的`Control panel`。\n\n![image-20230619144029671](./Image/随身WiFi刷机教程.assets/image-20230619144029671.png)\n\n修改密码\n\n![image-20230619144101984](./Image/随身WiFi刷机教程.assets/image-20230619144101984.png)\n\n输入主目录\n\n![image-20230619144315521](./Image/随身WiFi刷机教程.assets/image-20230619144315521.png)\n\n汉化\n\n![image-20230619144408545](./Image/随身WiFi刷机教程.assets/image-20230619144408545.png)\n\n退出再登录，就能看到中文的选项了\n\n![image-20230619144445412](./Image/随身WiFi刷机教程.assets/image-20230619144445412.png)\n\n![image-20230619144503674](./Image/随身WiFi刷机教程.assets/image-20230619144503674.png)\n\n此时汉化完成\n\n![image-20230619144532016](./Image/随身WiFi刷机教程.assets/image-20230619144532016.png)\n\n\n\n其他配置\n\n![image-20230619145748149](./Image/随身WiFi刷机教程.assets/image-20230619145748149.png)\n\n![image-20230619145849512](./Image/随身WiFi刷机教程.assets/image-20230619145849512.png)\n\n![image-20230619145949529](./Image/随身WiFi刷机教程.assets/image-20230619145949529.png)\n\n\n\n\n\n#### 注意事项\n\n可以使用FRP或者端口映射的形式进行外网访问。\n\n默认端口80，可以修改\n\n\n\n### miniDLNA\n\n1. 安装软件包\n\n   ```bash\n   apt install minidlna -y\n   ```\n\n   \n\n2. 修改配置文件\n\n   ```bash\n   echo 'media_dir=/udisk' > /etc/minidlna.conf\n   echo 'port=8200' >> /etc/minidlna.conf\n   echo 'friendly_name=WiFi-410' >> /etc/minidlna.conf \n   echo 'inotify=yes' >> /etc/minidlna.conf\n   ```\n\n   \n\n3. 禁用自启\n\n   ```bash\n   systemctl disable minidlna\n   ```\n\n   后期会在脚本中启动，防止磁盘挂载失败导致认不到视频文件\n\n   \n\n4. 启动minidlna\n\n   ```bash\n   systemctl start minidlna\n   ```\n\n      \n\n5. 如果dlna认不到新加入的视频，重启一下系统，拔掉棒子再插上就行了\n\n\n\n\n\n### 移动硬盘优化\n\n防止移动硬盘休眠\n\ncrontab -e\n*/3 * * * * echo \"1\" > /udisk/download/.no-hiberfil\n\n\n\n\n\n\n\n# 救砖（刷回原始包）\n\n## Miko\n\n![image-20230618203939677](./Image/随身WiFi刷机教程.assets/image-20230618203939677.png)\n\n\n\n\n\n\n\n# Debian项目WIKI\n\nhttps://www.kancloud.cn/handsomehacker/openstick/2636505\n\n## 概述\n\n### 关于 OpenStick\n\n针对于msm8916芯片的4G网卡的逆向工程和Mainline Linux移植。\n旨在实现一个廉价的带4G功能的ARM64单板电脑（性能其实和树莓派zero2、树莓派3b差不多）。\n提供完全可用的Debian发行版镜像和刷机方法。\n另外还会提供emcp扩容等高级玩法。\n支持电路板丝印为UFI001B、UFI001C、SP970、UZ801开头的4G无线网卡。\n本项目仅用于学习交流之用，请勿用于商业用途，本刷机包完全免费开源，欢迎举报倒卖的行为。\n\n**本教程的所有内容仅供参考，本人及文章作者不对任何刷机和改造设备的行为负责。也没有任何义务处理砖机。**\n\n### 设备具体配置\n\n虽然都在网上能查到，但是放在这里还是方便一点。\n\n- msm8916 主控 Cortex-A53 * 4 on 0.9GHZ\n- 512MB内存+4GB储存的拆机二手emcp\n- WCN3620 & WCN3680b\n- pm8916 PMIC\n\n### 各外设对应GPIO\n\n| 型号      | red led | green led    | blue led | 按键    |\n| :-------- | :------ | :----------- | :------- | :------ |\n| ufi001b/c | gpio22  | gpio21       | gpio20   | gpio37  |\n| sp970     | gpio9   | gpio10       | gpio28   | gpio107 |\n| uz801     | gpio7   | gpio8        | gpio6    | gpio23  |\n| UFI-16-V3 | gpio8   | (pmic) gpio4 | gpio32   | gpio49  |\n\n------\n\n### 设备支持情况\n\n这意味着主线内核(5.15 和 5.10)的对于设备的驱动程度\n\n| 功能             | 支持状况     |\n| :--------------- | :----------- |\n| arm64            | 支持         |\n| KVM 虚拟化       | 支持         |\n| PSCI             | 支持（v1.0） |\n| 自适应emcp空间   | 支持         |\n| WIFI (WCN3620)   | 支持         |\n| WIFI (WCN3680b)  | 支持         |\n| 蓝牙             | 支持         |\n| 4G 流量          | 支持         |\n| 短信             | 支持         |\n| USB HOST         | 支持         |\n| USB DEVICE       | 支持         |\n| Venus 视频解码器 | 支持         |\n| Venus 视频编码器 | 不支持       |\n| GPS              | 未验证       |\n| 通话             | 未验证       |\n\n- 注 : SP970与UZ801由于sim切卡gpio尚不明确，**暂不支持**与**modem**有关的功能（modem固件是正确的，如果你的机器是硬改实现切卡的可能modem能使用，**未测试**）。\n- SP970 V3 机型可能与SP970 V10的wifi芯片不太一样，**刷入可能会导致wifi不稳定**等问题。\n- UZ801在安卓下切卡后可能再刷机能使用modem，具体原因未知。\n- 不同批次的相同版型可能存在cpu后缀的差异，使用不了modem的朋友短期内的解决方案只有自行提取modem firmware，未来可以通过独立modem固件分区的方法来实现兼容不同后缀的soc(感谢酷安 @fanxueke)。\n- HandsomeMod与Debian固件中使用的modem firmware信息如下所示，缺失的机型会在短时间内补充。\n\n| 板型    | SOC后缀 |\n| :------ | :------ |\n| UFI001B | 0VV     |\n| UFI001C | 0VV     |\n| UFIW001 | 0VV     |\n\n### 投稿与奉献\n\n欢迎各位大佬将自己的玩法或建议以**markdown格式**\n发到邮箱**[handsomeyingyan@gmail.com](mailto:handsomeyingyan@gmail.com)**,或者私信（酷安、CSDN @handsomehacker）\n我们会尽快校对和更新文档，让更多的人看到：p\n\n### 奉献者\n\n感谢所有为项目发展而奉献的朋友，排名不分先后。\n\n- HandsomeHacker\n- fanxueke （酷安 @fanxueke ）\n- 魂梦九霄 （酷安 @魂梦九霄 ）\n- l305197437 (酷安 @l305197437 )\n- lilyok123 (酷安 @lilyok123 )\n- Zy143L (酷安 @Zy143L)\n\n### 项目相关链接\n\n维护项目不易，欢迎star与关注！！\n[HandsomeHacker的CSDN博客](https://blog.csdn.net/github_38345754)\n[OpenStick 项目主页(github)](https://github.com/OpenStick)\n[HandsomeMod 项目主页](https://github.com/HandsomeMod)\n\n### 赞助\n\n如果你觉得本项目对你有帮助，欢迎赞助，帮助我们的项目发展的更好！\n\n\n\n\n\n## 开始折腾\n\n首先你需要在[Openstick项目](https://github.com/OpenStick/OpenStick)的release中得到最新的Debian或HandsomeMod(可能会鸽)刷机包。然后准备好fastboot与adb工具,windows版本会在release中提供，linux直接使用包管理器中提供的版本即可。\n\n### Linux 下的刷机\n\n- 不同的Linux发行版可能存在差异，这里以2022年2月8日的ArchLinux为例。\n- 如果你的设备之前刷过base.zip，则可以将设备置于fastboot模式后从第4步开始。\n- ufi001b/c之外的版型请使用更为通用的base-generic.zip，然后使用本机型的boot.img替换debian.zip中的boot.img\n\n1. 解压base.zip压缩包。\n2. 将你的设备置于fastboot模式\n3. [执行其中的flash.sh](http://xn--flash-4n1hg0rkq3bd31brfzb.sh/)\n4. 当完成后解压<系统名称>.zip压缩包。\n5. [执行其中的flash.sh](http://xn--flash-4n1hg0rkq3bd31brfzb.sh/)\n6. enjoy!\n\n### Windows 下的刷机\n\n- 作者的windows环境变量里有adb和fastboot，可能需要根据实际情况对脚本进行适当调整。\n- 如果你的设备之前刷过base.zip，则可以将设备置于fastboot模式后从第4步开始。\n- ufi001b/c之外的版型请使用更为通用的base-generic.zip，然后使用本机型的boot.img替换debian.zip中的boot.img\n\n1. 解压base.zip压缩包。\n2. 将你的设备置于fastboot模式\n3. 执行其中的flash.bat\n4. 当完成后解压<系统名称>.zip压缩包。\n5. 执行其中的flash.bat\n6. enjoy!\n\n### Windows 下的常见驱动问题\n\n- [注] 部分翻译自postmarketOS wiki - [Windows FAQ](https://wiki.postmarketos.org/wiki/Windows_FAQ)\n\n#### 如果你的设备被识别为adb 设备\n\n如果在启动OpenStick后，只有adb可以连接而rndis在设备管理器中没有出现，则可以将这个设备的驱动更新为**Composite USB Device** 即可,(Windows 7 下为“**Android Composite USB Device**”)。\n\n#### 安装RNDIS驱动\n\n- Windows 10 下的驱动位置\n  - ![image-20230618220511663](./Image/随身WiFi刷机教程.assets/image-20230618220511663.png)\n  - ![image-20230618220520947](./Image/随身WiFi刷机教程.assets/image-20230618220520947.png)\n- Windows 7 下的驱动位置 （感谢酷安 @l305197437）\n  - ![image-20230618220540336](./Image/随身WiFi刷机教程.assets/image-20230618220540336.png)\n  - ![image-20230618220550488](./Image/随身WiFi刷机教程.assets/image-20230618220550488.png)\n\n## 基础使用\n\n这里记录一些基础使用的教程，仅供参考\n\n### Debian基础使用\n\n#### 基本信息\n\n- Debian 11 bulleye 稳定版\n- Linux Kernel 5.15 LTS\n- 装了一些bookworm的包（modemman ager）和mobian的fork，暂时不知道会给后续更新带来什么影响。\n- 开机默认启动rndis与adbd，可以通过adb与ssh连接（ip地址为192.168.68.1）\n- 默认配置了modem连接，插卡即有网。\n- 默认hostname为openstick\n- 默认用户名 user 密码 1\n- 内核支持挂无线网卡和uvc摄像头，docker与anbox。\n\n#### 连接到OpenStick\n\n支持使用任何支持openssh协议的工具以及adb来连接到OpenStick的shell。\n\n- 在windows下很多带颜色的字符会在adb下显示不出来，建议使用ssh进行连接。\n- adb fork自安卓4.4 不支持adb install 等涉及安卓图形界面或软件管理的指令。\n\n##### 使用adb\n\n```\n    # 进入bash\n    $ adb shell\n    # 也可以通过reboot bootloader进入到fastboot模式\n    $ adb reboot bootloader\n```\n\n##### 使用ssh\n\n```\n    $ ssh user@192.168.68.1\n```\n\n#### 开启wifi热点 (不依赖网桥的方法)\n\n- Debian 使用NetworkManager进行网络连接管理，这里使用nmtui进行设置。\n- 该方法不能同时使用rndis与wifi热点，如需要同时使用可以参考[rndis与wifi热点共存(debian)](https://www.kancloud.cn/handsomehacker/openstick/2684880)\n\n```\nsudo nmtui\n```\n\n##### 之后的界面如下所示：\n\n![image-20230618220826566](./Image/随身WiFi刷机教程.assets/image-20230618220826566.png)\n\n##### 创建一个连接\n\n![image-20230618220841279](./Image/随身WiFi刷机教程.assets/image-20230618220841279.png)\n\n![image-20230618220857245](./Image/随身WiFi刷机教程.assets/image-20230618220857245.png)\n\n##### 创建wifi类型的连接\n\n![image-20230618220926938](./Image/随身WiFi刷机教程.assets/image-20230618220926938.png)\n\n##### device输入wlan0，其他选项按照你的需求自行填写\n\n![image-20230618220941340](./Image/随身WiFi刷机教程.assets/image-20230618220941340.png)\n\n##### 设置ip地址,注意ip类型必须为shared，ip地址必须为192.168.68.1\n\n![image-20230618220949846](./Image/随身WiFi刷机教程.assets/image-20230618220949846.png)\n\n##### 输入以下指令激活这个连接，激活后usb rndis功能会失效。\n\n```\nsudo nmcli con up test\n```\n\n##### 要再次使用usb rndis，可以down掉这个连接\n\n```\nsudo nmcli con down test\n```\n\n#### 常见问题\n\n##### UFI001C/SP970/UZ801 刷入debian.zip后工作不正常\n\ndebian.zip仅适用于ufi001b，若需要支持其他版型需要同时更新设备树与固件。\n在github的release中下载boot-<机型>.img与firmware-<机型>.zip两个文件后，解压firmware.zip后,插入OpenStick，在你的电脑上键入以下指令。（uz801仅需更新boot.img)\n\n- 注：windows下的替换建议配合scp使用，windows下adb不支持通配符“ * ”\n\n```\n # 假设cmd&terminal的当前目录在firmware的解压文件夹下\n$ adb push ./* /lib/firmware\n$ adb reboot bootloader\n$ fastboot flash boot boot-<机型>.img\n$ fastboot reboot\n```\n\n##### 初次开机执行apt时报错\n\n```\n E: Release file for http://mirrors.163.com/debian/dists/bullseye/InRelease is not valid yet (invalid for another 157d 16h 4\n9min 2s). Updates for this repository will not be applied.\nE: Release file for http://security.debian.org/dists/bullseye-security/InRelease is not valid yet (invalid for another 209d\n 4h 12min 32s). Updates for this repository will not be applied.\nE: Release file for http://repo.mobian-project.org/dists/bullseye/InRelease is not valid yet (invalid for another 23d 19h 5\n3min 31s). Updates for this repository will not be applied.\n```\n\n这是ntp服务没有及时同步时间所导致的，重启即可。\n\n##### adb环境下用不了nmtui等带图形的应用\n\n例如执行nmtui时出现以下错误\n\n```\nroot@openstick:/# nmtui     \nTERM environment variable needs set.\n```\n\n设置TERM环境变量即可\n\n```\n$ export TERM=linux\n```\n\n##### root用户使用ssh登录不了\n\n- 感谢酷友@fanxueke的投稿。\n- 不要尝试在你有内网穿透或是在公网有ip的设备上使用root登录，这将会造成很大的安全隐患。\n- root的默认密码与user一致（都是1），可以通过`passwd root`修改\n\n###### 安装nano编辑器（需插入SIM卡或连接wifi）\n\n```\nsudo apt-get update`\n`sudo apt-get install nano\n```\n\n###### 编辑sshd_config\n\n```\nsudo nano /etc/ssh/sshd_config\n```\n\n将34行`#PermitRootLogin prohibit-password`改为`PermitRootLogin yes`\n将58行`#PasswordAuthentication yes`的`#`去掉\n\n#### 重启OpenStick\n\n```\nsudo reboot\n```\n\n\n\n\n\n\n\n### rndis与wifi热点共存(debian)\n\n解决debian rndis与wifi热点共存的问题\n\n- 感谢 lilyok123 (酷安 @lilyok123) 的投稿\n- 原理：创建一个网桥，配置ip地址，并且将usb网卡与无线网卡设备加入到网桥中即可\n- 注意事项：建议操作前将wifi连接到路由器上，操作时先将usb网络加入到网桥中，确保电脑能够正常 连接后，再将无线网卡加入到网桥中，万一操作失误还能从其它的网卡登录设备。否则估计得重新刷机了。\n\n#### 具体步骤\n\n第一步，输入命令nmtui，创建一个网桥\n\n![image-20230618221336262](./Image/随身WiFi刷机教程.assets/image-20230618221336262.png)\n\n第二步,配置ip地址为192.168.68.1/24（大佬默认是这个地址，如果更改网段需要修改dnsmsq.conf文件），配置名随意，设备名随意，这里都写br0\n\n![image-20230618221355326](./Image/随身WiFi刷机教程.assets/image-20230618221355326.png)\n\n第三步，为网桥添加一个ETHERNET设备\n\n![image-20230618221408744](./Image/随身WiFi刷机教程.assets/image-20230618221408744.png)\n\n第四步，ethernet设备需要填写为usb0（ifconfig命令看到的网卡名），配置名随意，这里起个名也是usb0\n\n![image-20230618221426543](./Image/随身WiFi刷机教程.assets/image-20230618221426543.png)\n\n第五步，此时usb0的设备添加成功，保存退出\n\n![image-20230618221441944](./Image/随身WiFi刷机教程.assets/image-20230618221441944.png)\n\n第六步，此时usb0配置文件如果没有生效，需要nmcli connection手动激活下，如无意外此时电脑能够正常访问随身wifi了。如果不成功通过另外的无线网卡登录看看配置是不是正确。\n\n![image-20230618221449911](./Image/随身WiFi刷机教程.assets/image-20230618221449911.png)\n\n第七步，在第六步usb0的网桥确保正常后，可以为网桥添加无线网卡了，输入nmtui命令，选择刚刚的br0配置文件，选择edit编辑。\n\n![image-20230618221506699](./Image/随身WiFi刷机教程.assets/image-20230618221506699.png)\n\n第八步，选择添加WLAN无线设备\n\n![image-20230618221517766](./Image/随身WiFi刷机教程.assets/image-20230618221517766.png)\n\n第九步，配置热点的名称，密码等参数，配置文件随意，device需要添加ifconfig中的无线网卡名称。\n\n![image-20230618221531711](./Image/随身WiFi刷机教程.assets/image-20230618221531711.png)\n\n第十步，保存配置，返回\n\n![image-20230618221540285](./Image/随身WiFi刷机教程.assets/image-20230618221540285.png)\n\n最后一步，此时wlan0的配置文件没有生效，需要手动nncli connection切换下。\n\n![image-20230618221551107](./Image/随身WiFi刷机教程.assets/image-20230618221551107.png)\n\n\n\n### 控制led行为\n\nOpenStick 存在三个led灯，默认blue表示wifi连接状态，red表示系统是否还处于正常运行状态。\n\n可以通过 **echo <行为> > /sys/class/led/<名字>/trigger** 来修改led行为。\n可用的行为如下\n\n```BASH\nroot@openstick:/sys/class/leds/green:internet# cat trigger \n[none] usb-gadget usb-host rfkill-any rfkill-none kbd-scrolllock kbd-numlock kbd-capslock kbd-kanalock kbd-shiftlock kbd-altgrlock kbd-ctrllock kbd-altlock kbd-shiftllock kbd-shiftrlock kbd-ctrlllock kbd-ctrlrlock timer heartbeat cpu cpu0 cpu1 cpu2 cpu3 default-on panic mmc0 bluetooth-power hci0-power rfkill0 phy0rx phy0tx phy0assoc phy0radio rfkill1\n```\n\n例如把green led的行为定义为usb device模式的活动状态\n\n```\nroot@openstick:/sys/class/leds/green:internet# echo usb-gadget > trigger\n```\n\n写入该字符串后led行为立刻生效，重启失效\n\n### 控制usb行为\n\nOpenStick 提供的所有系统都使用基于libusbgx的Gadget Controller (以下简称gc)来管理usb在device模式下的行为。\n\nDebian默认通过/usr/sbin/mobian-usb-network-config脚本启动rndis和adb两种usb复合设备，这也就意味着如果你的设备安装的是Debian，插入电脑默认会出现两个设备。\n\nHandsomeMod 通过uci来调用gc，用户可以通过luci来控制gc。\n\n在Debian中，rndis建立的usb0网络通过networkmanager进行管理，dnsmasq作为dhcp server分配ip地址。\n\n你也可以通过以下指令（例子）来加入更多的功能（同时运行不同功能的种类是有限的，受限于硬件）。\n\n**注意：在windows下rndis必须为第一个加入gadget中的功能，且windows不支持动态更新gadget，只能在脚本中一次添加完所有的gadget。**\n\n以下指令需要root权限,重启后失效。\n\n```\n    # 列出当前usb活动的device\n    gc -l\n    # 加入一个串口设备\n    # 有效的关键字为 serial ffs hid midi printer uvc mass rndis ecm acm\n    gc -a serial\n    # 删除指定串口设备 （X 为列表中的对应的config名称）\n    gc -r serial.X\n    # 清除所有的gadget\n    gc -c\n    # 关闭gadget\n    gc -d\n    # 开启gadget\n    gc -e\n```\n\n#### 切换USB工作模式\n\nOpenStick没有usb-id脚，只能手动将usb切换为主模式来插入u盘等设备，你可以将以下语句加入 **/usr/sbin/mobian-usb-gadget** setup()的最开头来实现开机切换，所有usb device功能将会失效。\n\n```\necho host > /sys/kernel/debug/usb/ci_hdrc.0/role\n```\n\n当然也可以通过把usb-typea头改为mircousb头，然后把vol up(fb)触点的gpio接到usb-id实现自动切换(需修改设备树)。\n\n#### 关于 Gadget Controller\n\nGadget Controller 的开发时间有点短，可能不够成熟。。。\n欢迎star、提出issue和pull request来帮助我完善它~\n\n\n\n\n\n### lk bootloader基本使用\n\n这里只记录和平常的lk不大一样的地方\n\n#### 获取日志\n\n```\nfastboot oem lk_log\nfastboot get_staged /dev/stdout\n```\n\n#### 提取分区内容\n\n```\nfastboot oem dump <分区名>\nfastboot get_staged <文件名>\n```\n\n#### 进入edl模式\n\n```\nfastboot oem reboot-edl\n```\n\n\n\n### emali短信转发\n\n转载至酷安@魂梦九霄\n调用modemmanager的get-sms指令，可以将收到的短信转发到指定邮箱\n[gitee源码](https://gitee.com/jiu-xiao/ufi-message)\n\n## 使用转发前请补全smtp.py开头的smtp信息\n\n```\npython3 msg.py add 861234567890 text\n```\n\n添加发送到1234567890的内容为text的短信到暂存区\n\n```\npython3 msg.py send\n```\n\n将所有暂存区的短信发送\n\n```\npython3 msg.py clean\n```\n\n清除本地所有短信（暂存，已发送，接收）\n\n```\npython3 msg.py forward\n```\n\n将所有接收到的短信通过smtp邮件转发\n\n\n\n\n\n## 高级玩法\n\n这里记录一些高级玩法，仅供参考。\n\n### emcp扩容\n\n这里只记录在linux下的扩容过程，windows应该类似，使用9008模式下的备份工具备份整个emcp上的内容即可（包含分区表）。高通的9008模式恢复时会将userdata分区自动扩充到所有可用的空间，所以理论上来说安卓系统也适合该方法备份（据部分用户反映安卓系统在扩容后的机器中无法使用）。\n\n- 注意：方法仅供参考，不代表百分之百在你的环境中可用。\n\n#### 硬件\n\n按照原机搭配的emcp，可以确定emcp必须满足以下条件。\n\n- 内置的内存必须是**lpddr2** （不敢确定 我的机器大部分搭配的是lpddr2 msm8916支持lpddr3但可能需要不同的电压来驱动，即使电压一样也许需要使用不同的loader来初始化内存）\n- bga封装必须是**bga162**\n- 符合规格的芯片会在焊接到位后上电进入9008(edl)模式，其他情况则会没有任何反应。\n\n经过测试以下的芯片可以兼容UFI001B/C机型\n\n- 08emcp08-nl2cv100 (bga162 lpddr2 1g + 8g emmc)\n- kmk8x000vm-b412 (bga162 lpddr2 1g + 16g emmc)\n\n#### 软件\n\n推荐使用linux下的edl工具,安装之前默认你的环境中有python3及yay。\n\n```\nyay -S edl-git\n```\n\n- 不是Arch-based的发行版建议直接按照[edl官方](https://github.com/bkerler/edl)的方法安装。\n\n之后长按机器上电，进入9008模式，输入以下指令备份emcp中的内容。\n\n```\nedl rl dumps --skip=userdata --genxml\n```\n\n- 如果长时间卡住，建议ctrl+c以后重试。\n- 如果你的edl报例如no suitable loader found一类的错误，则可以尝试其他的loader初始化内存，edl提供了很多loader这里以红米2的loader为例(loader路径 不同的linux环境可能会有差异，仅供参考)。\n\n```\n$ edl rl dumps --skip=userdata --genxml  \\\n--loader /usr/lib/python3.10/site-packages/edlclient-3.53-py3.10.egg/edlclient/../Loaders/xiaomi/007050e100000000_50838757eab7c632_fhprg_peek_wt88047.bin\n```\n\n换上新的emcp后，会出现9008设备，此时在备份文件夹里输入以下指令\n\n```\n$ edl qfil rawprogram0.xml patch0.xml\n```\n\n- 如果出错，同上，加入loader参数即可。\n\n重启机器，灯光亮起即代表扩容成功。\n\n```\n$ edl reset\n```\n\n#### 参考资料\n\n这里有些常见的emcp&emmc型号，仅供参考\n(感谢 酷安@Zy143L 的整理)\n\n![image-20230618222342224](./Image/随身WiFi刷机教程.assets/image-20230618222342224.png)\n\n![image-20230618222350516](./Image/随身WiFi刷机教程.assets/image-20230618222350516.png)\n\n\n\n\n\n### 编译内核（debian）\n\n这里介绍如何使用linux定制自己的内核，推荐的发行版是Ubuntu 20.04。\n\n#### 需要的软件包\n\n不同的发行版可能对软件包命名会有所不同，这里以Ubuntu 20.04的命名为例。\n\n- binfmt-support\n- qemu-user-static\n- gcc-10-aarch64-linux-gnu\n- kernel-package\n- fakeroot\n- simg2img\n- img2simg\n- mkbootimg\n- bison\n\n#### 生成内核debian软件包\n\n克隆linux内核,这里选择深度为1减少体积。\n\n```\n$ git clone https://github.com/OpenStick/linux --depth=1\n```\n\n开始编译\n\n```\n$ export CROSS_COMPILE=aarch64-linux-gnu-\n$ export ARCH=arm64\n$ make msm8916_defconfig\n$ make menuconfig\n$ make -j16\n```\n\n生成debian格式的软件包\n\n```\n$ fakeroot make-kpkg  --initrd --cross-compile aarch64-linux-gnu- --arch arm64  kernel_image kernel_headers\n```\n\n之后将生成的deb软件包(会在代码目录上层生成)，与`arch/arm64/boot/Image.gz`保留备用\n将rootfs.img转换成img格式并挂载\n\n```\n$ simg2img rootfs.img root.img\n$ sudo mount root.img /mnt\n```\n\n在chroot环境下，将前面生成的linux-image等deb安装包安装即可。注意要将安装完成后生成的`boot/initrd.img`取出备用（安装之前最好卸载原来的linux-image之类的软件包）。\n\n```\n$ sudo  mount --bind /proc /mnt/proc \n$ sudo  mount --bind /dev /mnt/dev\n$ sudo  mount --bind /dev/pts /mnt/dev/pts\n$ sudo  mount --bind /sys /mnt/sys\n$ sudo  chroot /mnt\n```\n\n安装完成后，解除所有挂载，将img再次转换为simg\n\n```\n$ img2simg root.img rootfs.img\n```\n\n#### 生成boot.img\n\n取前面文件系统安装新内核后`/boot/initrd.img**`文件与内核编译阶段生成的`Image.gz`和`arch/arm64/boot/dts/qcom/`下对应设备的`*.dtb`备用\n将devicetree(dtb)附在Image.gz之后\n\n```\ncat Image.gz dtb > kernel-dtb\n```\n\n生成boot.img\n\n```\n$ mkbootimg \\     \n        --base 0x80000000 \\\n        --kernel_offset 0x00080000 \\\n        --ramdisk_offset 0x02000000 \\\n        --tags_offset 0x01e00000 \\\n        --pagesize 2048 \\\n        --second_offset 0x00f00000 \\\n        --ramdisk initrd.img \\\n        --cmdline \"earlycon root=PARTUUID=a7ab80e8-e9d1-e8cd-f157-93f69b1d141e console=ttyMSM0,115200 no_framebuffer=true rw\"\\\n        --kernel kernel-dtb -o boot.img\n```\n\n之后将两个img文件分别刷入对应分区即可。\n\n### 编译lk bootloader\n\n这里不再介绍lk2nd的编译，只介绍lk1st的编译方法。\n原理其实很简单，交叉编译后得到aboot之后使用dragonboard提供的密匙签名即可。\n\n- 注意：不适用于开启secureboot的设备，如果你的设备不在支持列表之内，教程的有效性将得不到保证。\n- uz801和sp970由于某些原因在lk阶段点不亮led。\n- 目前最为完美的机型是UFI001B/C系列\n\n克隆lk2nd项目\n\n```\n$  git clone https://github.com/OpenStick/lk2nd.git\n```\n\n进入lk2nd目录使用以下指令开始编译\n\n```\nmake TOOLCHAIN_PREFIX=arm-none-eabi- lk1st-msm8916 -j8\n```\n\n之后会出现build-lk1st-msm8916目录，复制产物**emmc_appsboot.mbn**备用。\n\n克隆签名工具qtestsign\n\n```\n$ git clone https://github.com/msm8916-mainline/qtestsign\n```\n\n将前面的**emmc_appsboot.mbn**放入qtestsign目录，之后输入以下指令。\n\n```\n$ ./qtestsign.py aboot emmc_appsboot.mbn\n```\n\n之后会生成**emmc_appsboot-test-signed.mbn**,刷入即可。\n\n```\n$ fastboot flash aboot emmc_appsboot-test-signed.mbn\n```","tags":["protected","魔改","刷机","搞事情","随身WiFi"],"categories":["搞事情"]},{"title":"ESP8266相关案例笔记","url":"/2023/06/07/ESP8266相关案例笔记/","content":"\n\n\n\n# ESP8266 相关案例笔记\n\n## ESP8266的PWM(模拟输出)\n\nESP8266 GPIOs 可以设置为输出 0V 或 3.3V，但它们不能输出其他任何电压。但是，可以使用脉冲宽度调制 （PWM） 输出\"假\"中电平电压，通过这个\"假\"中电平电压，可以产生不同级别的LED亮度。\n\n如果 LED 的电压在\"高\"和\"低\"之间快速交替，则眼睛无法跟上 LED 开关的速度;你只会看到一些亮度的渐变。\n\n这基本上就是PWM的工作原理——通过产生在高频率和低之间变化的输出。\n\n50% 的占空比可产生 50% 的 LED 亮度，占空比为 0 表示 LED 完全关闭，占空比为 100 表示 LED 完全打开。改变占空比是产生不同亮度级别的方式。\n\n\n\n### 产生PWM信号\n\n`analogWrite(pin, value);`\n\n- **pin**：输出的针脚(引脚 0 到 16都可以)\n- **value**： 应在 0 到PWMRANGE，默认情况下为 1023。当值为 0 时，该引脚上禁用 PWM。值 1023 对应于 100% 占空比\n\n您可以通过调用以下功能更改PWMRANGE：\n\n```c\nanalogWriteRange(new_range);\n```\n\n\n\n默认情况下，ESP8266 PWM 频率为 1kHz。可以使用`analogWriteFreq()`函数来修改：\n\n```c\nanalogWriteFreq(new_frequency);\n```\n\n\n\n### 样例\n\n```c\nconst int ledPin = 2; //设置LED的管脚为GPIO2\n\nvoid setup() {\n  \n}\n\nvoid loop() {\n\n  //通过一个循环，改变指定引脚的PWM占空比，实现呼吸灯效果。\n  \n  // 增加LED亮度\n  for(int dutyCycle = 0; dutyCycle < 1023; dutyCycle++){   \n    // 通过PWM改变LED亮度\n    analogWrite(ledPin, dutyCycle);\n    delay(5);\n  }\n\n  // 降低LED亮度\n  for(int dutyCycle = 1023; dutyCycle > 0; dutyCycle--){\n    // 通过PWM改变LED亮度\n    analogWrite(ledPin, dutyCycle);\n    delay(5);\n  }\n}\n```\n\n\n\n\n\n## ESP8266 IPV6 DDNS \n\n### 所需库文件\n\n#### ddns24400.cpp\n\n```c++\n/**\n   名字：ddns24400.cpp\n   功能：esp8266获取ipv6地址，可以提交到每步科技,dnspod,阿里云\n   作者：QQ:1336621774\n   时间：2021.06.19\n*/\n#include <stdlib.h>\n#include <stdio.h>\n#include <string>\n#include <PolledTimeout.h>\n#include <Arduino.h>\n#include \"Arduino.h\"\n#include <lwip/dns.h>\n#include <AddrList.h>\n#include <String.h>\n#include \"ddns24400.h\"\n#include <ArduinoJson.h>\n\n#include <WiFiClient.h>\n#include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n#include <WiFiClientSecureBearSSL.h>\nWiFiClient afraidclient;\nHTTPClient afraidhttp;\nesp8266::polledTimeout::periodicMs showStatusOnSerialNow3(10000);\nesp8266::polledTimeout::periodicMs showStatusOnSerialNow4(10000);\nint IIPV6 = 0;\nString inIPV6 = \"0\";\nString insIPV6 = \"0\";\nint zipv6 = 0;\nDynamicJsonBuffer jsonBuffer;\nbool jiexi = false;\n\nvoid newIPV6() { //获取当前网卡的IPV6地址数量\n  delay(5000);//延迟5秒以便于加载网卡IPV6信息\n  int I = 0;\n  for (auto a : addrList) {\n    if (a.isV6() == 1 && a.isLocal() == 0) { //条件达成下，a.toString().c_str()获取的是公网ipv6\n      I++;\n    }\n  }\n  IIPV6 = I;\n}\n\n\nString getIPV6() {\n  int i = 0;\n  String aipv6;\n  String bipv6;\n  for (auto a : addrList) {\n    if (a.isV6() == 1 && a.isLocal() == 0) { //条件达成下，a.toString().c_str()获取的是公网ipv6\n      if (i == 0) {\n        aipv6 = a.toString().c_str();\n      }\n      else\n      {\n        bipv6 = a.toString().c_str();\n      }\n      i++;\n    }\n  }\n\n  if (i != IIPV6) {\n    return bipv6;\n  } else {\n    return aipv6;\n  }\n}\n\n\n\n\nString getcentersW(String str, String start, String finish) {\n  int locStart = str.indexOf(start);\n  if (locStart == -1) return \"\";\n  locStart += start.length();\n  int locFinish = str.indexOf(finish, locStart);\n  if (locFinish == -1) return \"\";\n  return str.substring(locStart, locFinish);\n}\n\nvoid freeafraid(String token) {\n  if (showStatusOnSerialNow4) {\n    String getipv6add = getIPV6();\n    getipv6add.trim();\n    if (getipv6add == \"\") {\n      Serial.println(\"未获取到IPv6，10秒后重新获取\");\n      zipv6++;\n      if (zipv6 > 6)\n      {\n        ESP.reset();\n      }\n      return;\n    }\n    if (insIPV6 != getipv6add) {\n      jiexi = false;\n      Serial.print(\"afraid开始解析\\n\");\n      String url = \"http://sync.afraid.org/u/\" + token + \"/update?myip=\" + getipv6add;\n      if (afraidhttp.begin(afraidclient, url)) {\n        int httpCode = afraidhttp.GET();\n        if (httpCode > 0) {\n          if (httpCode == HTTP_CODE_OK) {\n            if (afraidhttp.getString().startsWith(\"Updated \")) {\n              insIPV6 = getipv6add;\n              Serial.println(\"IPv6解析成功\");\n              jiexi = true;\n            } else if (afraidhttp.getString().startsWith(\"No IP\")) {\n              insIPV6 = getipv6add;\n              Serial.println(\"IPv6地址未变动，无需解析\");\n              jiexi = true;\n            } else if (afraidhttp.getString().startsWith(\"Error \")) {\n              Serial.println(\"Token错误，无法解析\");\n            } else {\n              Serial.println(afraidhttp.getString());\n            }\n          } else {\n            Serial.println(\"无法连接解析服务器，将在10秒后重试。\");\n          }\n        } else {\n          Serial.printf(\"[HTTP] GET... failed, error: %s\\n\", afraidhttp.errorToString(httpCode).c_str());\n        }\n        afraidhttp.end();\n        afraidclient.stop();\n      } else {\n        Serial.println(\"无法连接解析服务器，将在10秒后重试。\");\n      }\n      afraidhttp.end();\n      afraidclient.stop();\n    }\n  }\n}\n\n\n///////////////////////cloudflare\nvoid cf(String id, String key, String email, String domain, bool boo) {\n  if (showStatusOnSerialNow3) {\n    String getipv6add = getIPV6();\n    getipv6add.trim();\n    if (getipv6add == \"\") {\n      Serial.println(\"未获取到IPv6，10秒后重新获取\");\n      zipv6++;\n      if (zipv6 > 6)\n      {\n        ESP.reset();\n      }\n      return;\n    }\n    std::unique_ptr<BearSSL::WiFiClientSecure>client(new BearSSL::WiFiClientSecure);\n    HTTPClient https;\n    client->setInsecure();//setFingerprint(fingerprint)\n    String DATAS = \"\";\n    String YCAAAA = \"\";\n    String BDAAAA = \"\";\n    String CXWZDATA = \"\";\n    if (insIPV6 != getipv6add) {\n      jiexi = false;\n      if (https.begin(*client, \"https://api.cloudflare.com/client/v4/zones/\" + id + \"/dns_records?type=AAAA&name=\" + domain + \"&page=1&per_page=100&order=type&direction=desc&match=all\")) { // HTTPS\n        https.addHeader(\"X-Auth-Email\", email);\n        https.addHeader(\"X-Auth-Key\", key);\n        https.addHeader(\"Content-Type\", \"application/json\");\n        https.addHeader(\"Connection\", \"close \\r\\n\\r\\n\");\n        Serial.println(\"开始查询域名记录\");\n        int httpCode = https.GET();\n        if (httpCode > 0) {\n          if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) {\n            JsonObject& root = jsonBuffer.parseObject(https.getString());\n            String re_id = root[\"result\"][0][\"id\"];\n            String AAAA = root[\"result\"][0][\"content\"];\n            re_id.trim();\n            if (re_id == \"\") {\n              return;\n            }\n            YCAAAA = AAAA;\n            BDAAAA = getipv6add;\n            insIPV6 = getipv6add;\n            if (AAAA != getipv6add) {\n              DATAS = re_id;\n            }\n            else\n            {\n              DATAS = \"\";\n              Serial.println(\"IPv6地址未变动，无需解析\");\n              jiexi = true;\n            }\n          }\n        } else {\n          Serial.println(\"查询出错，错误代码：\" + String(httpCode) + \"：\" + CXWZDATA);\n        }\n        https.end();\n      } else {\n        Serial.printf(\"解析提交完成GET\");\n      }\n    }//判断ipv6\n    else {\n      DATAS = \"\";\n      return;\n    }\n    if (DATAS == \"\") {\n      return;\n    }\n    YCAAAA.trim();\n    if (YCAAAA == \"\") {\n      return;\n    }\n    Serial.println(\"域名IPv6：\" + YCAAAA);\n    Serial.println(\"本机IPv6：\" + BDAAAA);\n    delay(1000);\n    if (https.begin(*client, \"https://api.cloudflare.com/client/v4/zones/\" + id + \"/dns_records/\" + DATAS)) { // HTTPS\n      https.addHeader(\"X-Auth-Email\", email);\n      https.addHeader(\"X-Auth-Key\", key);\n      https.addHeader(\"Content-Type\", \"application/json\");\n      https.addHeader(\"Connection\", \"close \\r\\n\\r\\n\");\n      Serial.println(\"开始提交AAAA解析\");\n      int httpCode;\n      if (boo) {\n        httpCode = https.PUT(\"{\\\"type\\\":\\\"AAAA\\\",\\\"name\\\":\\\"\" + domain + \"\\\",\\\"content\\\":\\\"\" + BDAAAA + \"\\\",\\\"ttl\\\":120,\\\"proxied\\\":true}\");//true代理false不代理\n      } else {\n        httpCode = https.PUT(\"{\\\"type\\\":\\\"AAAA\\\",\\\"name\\\":\\\"\" + domain + \"\\\",\\\"content\\\":\\\"\" + BDAAAA + \"\\\",\\\"ttl\\\":120,\\\"proxied\\\":false}\");//true代理false不代理\n      }\n      CXWZDATA = \"\";\n      if (httpCode > 0) {\n        if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) {\n          JsonObject& root = jsonBuffer.parseObject(https.getString());\n          String sensor = root[\"success\"];\n          if (sensor == \"true\") {\n            Serial.println(\"域名AAAA解析成功！\");\n            jiexi = true;\n          } else\n          {\n            Serial.println(\"域名AAAA解析失败！\");\n          }\n        }\n      } else {\n        Serial.println(\"解析出错，错误代码：\" + String(httpCode) + \"：\" + CXWZDATA);\n      }\n      https.end();\n    } else {\n      //Serial.printf(\"解析提交完成POST\");\n    }\n  }\n}\n\n///////////////////////cloudflare\n\n\n\n\nvoid ddns24400::init()\n{\n  newIPV6();\n}\n\nString ddns24400::get()\n{\n  return getIPV6();\n}\n\nvoid ddns24400::afraid(std::string token)\n{\n  freeafraid(token.c_str());\n}\n\nbool ddns24400::isjiexi()\n{\n  return jiexi;\n}\n\nString ddns24400::getcenter(std::string str, std::string start, std::string finish) {\n  return getcentersW(str.c_str(), start.c_str(), finish.c_str());\n}\n\nvoid ddns24400::cloudflare(std::string id , std::string key , std::string email , std::string domain, bool boo)\n{\n  cf(id.c_str(), key.c_str(), email.c_str(), domain.c_str(), boo);\n}\n```\n\n\n\n#### ddns24400.h\n\n```cpp\n#include <string>\n#include <String.h>\n#ifndef ddns24400_h\n#define ddns24400_h\n#include \"Arduino.h\"\n\nclass ddns24400\n{\n  public:\n    void init();\n    String get();\n    bool isjiexi();\n    String getcenter(std::string str, std::string start, std::string finish);\n    void afraid(std::string token);\n    void cloudflare(std::string id , std::string key , std::string email , std::string domain, bool boo);\n  private:\n    int _pin;\n};\n#endif\n```\n\n\n\n### 使用方法\n\n1. 导入库\n\n   1. ```\n      #include \"ddns24400.h\"\n      ```\n\n      \n\n2. 实例化出ddns24400库的对象\n\n   1. ```c\n      ddns24400 ddns;\n      ```\n\n      \n\n3. 在setup函数里面初始化ddns的对象\n\n   1. ```c++\n      ddns.init();//初始化IPV6协议栈\n      Serial.println(ddns.get());//打印输出当前设备IPV6地址\n      ```\n\n      \n\n4. 在循环中不停调用ddns中的更新方法\n\n   1. ```c++\n      cloudflare(std::string id , std::string key , std::string email , std::string domain, bool boo);\n      ```\n\n   2. 参数说明：\n\n      - id：cf中域名对应的区域ID\n      - key：cf的api密钥\n      - email：cf的邮箱地址\n      - domain：参数为AAAA记录的域名\n      - boo：false是不启用CDN，true是启用CDN\n\n\n\n### 样例\n\n```c++\n#include <ESP8266WiFi.h>\n#include <WiFiClient.h>\n#include \"ddns24400.h\"\n\nconst char* ssid = \"lnunicom_708\";\nconst char* password = \"707708709\";\n\nddns24400 ddns;\n\nWiFiServer server(80);\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(10);\n\n  //初始化ddns24400对象\n  ddns.init();\n\n  // 连接WiFi\n  Serial.println();\n  Serial.print(\"连接到WiFi网络：\");\n  Serial.println(ssid);\n\n  WiFi.begin(ssid, password);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  Serial.println(\"\");\n  Serial.println(\"WiFi连接成功\");\n\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n\n  Serial.print(\"IPv6 address: \");\n  Serial.println(ddns.get());\n\n  \n  \n  // 启动Web服务器\n  server.on(\"/\", handleRoot);\n\n  server.begin();\n  Serial.println(\"HTTP server started\");\n\n}\n\nvoid loop() {\n  server.handleClient();\n  ddns.cloudflare(\"37b6f49c472df17cafcd2cb72fc5179e\",\"3d5d5b67195258bb65cfbcd7ec15048d13142\",\"hurrkn@163.com\",\"esp8266.198425.xyz\",true);\n  //前两个参数为域名对应的区域ID和API密钥\n  //第三个参数为cf的邮箱地址\n  //第四个参数为AAAA记录的域名\n  //第五个参数false是不启用CDN，true是启用CDN。\n}\n\nvoid handleRoot() {\n  String ipv6 = ddns.get();\n  String html = \"<html><body><h1>ESP8266 IPv6地址</h1><p>\";\n  html += \"当前的IPv6地址：\" + ipv6 + \"</p><p>hello world, hurr</p></body></html>\";\n  server.send(200, \"text/html\", html);\n}\n```\n\n\n\n### ddns24400库的一些方法\n\n#### void init();\n\n##### 作用\n\n初始化对象中的内容\n\n\n\n#### String get();\n\n##### 作用\n\n获取当前设备的ipv6公网地址。\n\n\n\n#### bool isjiexi();\n\n##### 作用\n\n判断是否解析成功。\n\n\n\n#### String getcenter(std::string str, std::string start, std::string finish);\n\n\n\n\n\n#### void afraid(std::string token);\n\n\n\n\n\n#### void cloudflare(std::string id , std::string key , std::string email , std::string domain, bool boo);\n\n##### 作用\n\n执行ddns\n\n \n\n\n\n\n\n\n\n# 样例\n\n## 连接WiFi\n\n注意 依赖于 `ESP8266WiFi.h` 库。\n\n```c\n#include <ESP8266WiFi.h>//导入库\n\nvoid setup() {\n  // put your setup code here, to run once:\n\n  InitSystem();//初始化设置\n\n  ConnectToWiFi();//连接WiFi\n  \n\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  \n}\n\n//连接WiFi\nvoid ConnectToWiFi()\n{\n  char ssid[] = \"01_0\";//WiFi的SSID\n  char password[] = \"zero0000\";//wifi的密码\n\n  WiFi.begin(ssid, password);//连接WiFi\n\n\n\n  //输出提示信息：只要没连上就通过串口发送.\n  while(WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);//等待500ms\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");//当连接成功后 串口输出一个换行，然后显示其他信息\n\n  Serial.println(\"Wifi connected\");//输出wifi连接成功的提示信息\n\n  Serial.println(WiFi.localIP());//输出连接后分配到的ip地址。\n\n}\n\n//初始化函数\nvoid InitSystem()\n{\n  Serial.begin(115200);//设置串口的波特率\n\n  Serial.println(\"\");//换行一下\n  Serial.println(\"\");//换行一下\n  Serial.println(\"\");//换行一下\n\n}\n```\n\n\n\n\n\n## 使用引脚\n\n说明：\n\n本样例基于ESP-01S模块。\n\n已知：\n\n- 板载LED的连接在`GPIO2(D4)`引脚上。\n- GPIO0(D3)引脚在启动后可以被作为输入使用。\n  - 如果此引脚在启动阶段被拉低，则表示进入烧录模式？\n\n使用函数：\n\n- pinMode()：用于设置引脚是输入还是输出使用\n- digitalRead()：用于在设置对应引脚为输入模式的前提下读取指定引脚的电平。\n  - 参数可以是像D4一样的Label标记，也可以是表示GPIO的整数。\n    - 样例：digitalRead(0);\t： 读取GPIO0引脚的电平，返回一个整形数。\n- digitalWrite()：用于在设置对应引脚为输出模式的前提下设置指定引脚的电平。\n  - 一共两个参数：\n  - 第一个参数用于设置要操作的GPIO引脚号\n  - 第二个参数是设置电平\n    - 可以是0 或 1，也可以是LOW 或 HIGH\n\n```c\n#include <ESP8266WiFi.h>//导入库\n\nvoid setup() {\n  pinMode(2, OUTPUT);//设置GPIO 2 脚为输出模式\n  pinMode(0, INPUT);//设置GPIO 0 为输入模式  \n}\nvoid loop() {\n  // put your main code here, to run repeatedly:\n\n  //读取引脚的电平，返回值是整形\n  //也可以是HIGH 或 LOW。可能是内部有宏定义之类的东西？\n  if(digitalRead(0) == LOW)           //如果读取到指定的引脚为低电平，视为按钮被按下\n  {        \n    digitalWrite(2, 0);           //引脚置低，点亮板载LED\n  }\n  else\n  {\n    //同理设置参数的时候可以是0或1，也可以是HIGH 或 LOW\n    digitalWrite(2, HIGH);           //否则就熄灭LED\n  }\n}\n```\n\n\n\n\n\n## 访问Web\n\n说明：\n\n访问百度的搜索引起\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 检查周围开启WiFi的设备的MAC地址\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiGeneric_AP_3\n程序目的/Purpose          : \n用于演示ESP8266WiFiGeneric库中onSoftAPModeProbeRequestReceived 函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \n#define ssid   \"TaichiMaker_WIFI\"  // 这里定义将要建立的WiFi名称。此处以\"TaichiMaker_WIFI\"为示例\n                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中\n#define password  \"12345678\"        // 这里定义将要建立的WiFi密码。此处以12345678为示例\n                                    // 您可以将自己想要使用的WiFi密码放入引号内\n                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息\n \nWiFiEventHandler probeRequestReceivedHandler;//实例化WIFI事件对象\n \nvoid onProbeRequestReceived(const WiFiEventSoftAPModeProbeRequestReceived& evt){//设备在接入点模式下收到无线终端的探针请求时的回调函数\n  Serial.print(\"请求终端的mac地址: \");\n  Serial.print(macToString(evt.mac));//调用macToString函数将mac转换成字符串\n  Serial.print(\"     请求终端的信号强度: \");\n  Serial.println(evt.rssi);//调用macToString函数将mac转换成字符串\n}\n \nvoid setup() {\n  Serial.begin(115200);\n  WiFi.softAP(ssid, password);  // 此语句是重点。WiFi.softAP用于启动NodeMCU的AP接入点模式。\n                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。\n                                // 这两个参数具体内容在setup函数之前的位置进行定义。\n  \n  Serial.println(\"\"); \n  Serial.print(\"Access Point: \");    // 通过串口监视器输出信息\n  Serial.println(ssid);              // 告知用户NodeMCU所建立的WiFi名\n  Serial.print(\"Password: \");        \n  Serial.println(password);          // 告知用户NodeMCU所建立的WiFi密码\n  Serial.print(\"IP address: \");      // 以及NodeMCU的IP地址\n  Serial.println(WiFi.softAPIP());   // 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址\n \n  // onSoftAPModeProbeRequestReceived函数的参数onProbeRequestReceived为事件处理回调函数。\n  // 也就是说，每当设备在接入点模式下收到无线终端的探针请求时，设备都会自动调用onStationConnected函数\n  probeRequestReceivedHandler = WiFi.onSoftAPModeProbeRequestReceived(onProbeRequestReceived);\n}\n \nvoid loop() {\n}\n    \nString macToString(const unsigned char* mac) {//字符串转换函数\n  char buf[20];\n  snprintf(buf, sizeof(buf), \"%02x:%02x:%02x:%02x:%02x:%02x\",mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n  return String(buf);\n}\n```\n\n\n\n## 获取连入设备的MAC地址\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiGeneric_AP_1\n程序目的/Purpose          : \n用于演示ESP8266WiFiGeneric库中onSoftAPModeStationConnected函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \n#define ssid   \"TaichiMaker_WIFI\"  // 这里定义将要建立的WiFi名称。此处以\"TaichiMaker_WIFI\"为示例\n                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中\n#define password  \"12345678\"        // 这里定义将要建立的WiFi密码。此处以12345678为示例\n                                    // 您可以将自己想要使用的WiFi密码放入引号内\n                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息\n \nWiFiEventHandler stationConnectedHandler;  //实例化WIFI事件对象\n \nvoid setup() { \n  Serial.begin(115200);         //打开串口\n  WiFi.softAP(ssid, password);  // 此语句是重点。WiFi.softAP用于启动NodeMCU的AP接入点模式。\n                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。\n                                // 这两个参数具体内容在setup函数之前的位置进行定义。\n  \n  Serial.println(\"\"); \n  Serial.print(\"Access Point: \");    // 通过串口监视器输出信息\n  Serial.println(ssid);              // 告知用户NodeMCU所建立的WiFi名\n  Serial.print(\"Password: \");        \n  Serial.println(password);          // 告知用户NodeMCU所建立的WiFi密码\n  Serial.print(\"IP address: \");      // 以及NodeMCU的IP地址\n  Serial.println(WiFi.softAPIP());   // 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址\n \n  // onSoftAPModeStationConnected函数的参数onStationConnected为事件处理回调函数。\n  // 也就是说，每当有新的无线终端连接到ESP8266设备建立的WiFi后，设备都会自动调用onStationConnected函数\n  stationConnectedHandler = WiFi.onSoftAPModeStationConnected(onStationConnected);\n \n}\n \nvoid loop(){\n}\n \nvoid onStationConnected(const WiFiEventSoftAPModeStationConnected& evt) {//接入点模式下有无线终端设备连接进来时的回调函数\n  Serial.print(\"无线终端设备的mac地址: \");\n  Serial.println(macToString(evt.mac));//调用macToString函数将mac转换成字符串\n  Serial.print(\"无线终端设备的序号: \");\n  Serial.println(evt.aid);  \n}\n \nString macToString(const unsigned char* mac) {  //字符串转换函数\n  char buf[20];\n  snprintf(buf, sizeof(buf), \"%02x:%02x:%02x:%02x:%02x:%02x\",mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n  return String(buf);\n}\n```\n\n\n\n\n\n## 获取连接后又断开的设备的MAC地址\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiGeneric_AP_2\n程序目的/Purpose          : \n用于演示ESP8266WiFiGeneric库中onSoftAPModeStationDisconnected函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \n#define ssid   \"TaichiMaker_WIFI\"   // 这里定义将要建立的WiFi名称。此处以\"TaichiMaker_WIFI\"为示例\n                                    // 您可以将自己想要建立的WiFi名称填写入此处的双引号中\n#define password  \"12345678\"        // 这里定义将要建立的WiFi密码。此处以12345678为示例\n                                    // 您可以将自己想要使用的WiFi密码放入引号内\n                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息\n \nWiFiEventHandler stationDisconnectedHandler;  //实例化WIFI事件对象\n \nvoid setup() { \n  Serial.begin(115200);\n  WiFi.softAP(ssid, password);  // 此语句是重点。WiFi.softAP用于启动NodeMCU的AP接入点模式。\n                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。\n                                // 这两个参数具体内容在setup函数之前的位置进行定义。\n  \n  Serial.println(\"\"); \n  Serial.print(\"Access Point: \");    // 通过串口监视器输出信息\n  Serial.println(ssid);              // 告知用户NodeMCU所建立的WiFi名\n  Serial.print(\"Password: \");        \n  Serial.println(password);          // 告知用户NodeMCU所建立的WiFi密码\n  Serial.print(\"IP address: \");      // 以及NodeMCU的IP地址\n  Serial.println(WiFi.softAPIP());   // 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址\n \n  // onSoftAPModeStationDisconnected函数的参数onStationDisconnected为事件处理回调函数。\n  // 也就是说，每当有无线终端从ESP8266设备建立的WiFi连接断开后，设备都会自动调用onStationDisconnected函数\n  stationDisconnectedHandler = WiFi.onSoftAPModeStationDisconnected(onStationDisconnected);\n}\n \nvoid loop(){\n}\n \nvoid onStationDisconnected(const WiFiEventSoftAPModeStationDisconnected& evt) {  //接入点模式下有无线终端设备断开连接时的回调函数\n  Serial.print(\"断开连接的无线终端是: \");\n  Serial.println(macToString(evt.mac));//调用macToString函数将mac转换成字符串\n}\n \nString macToString(const unsigned char* mac) {//字符串转换函数\n  char buf[20];\n  snprintf(buf, sizeof(buf), \"%02x:%02x:%02x:%02x:%02x:%02x\",mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n  return String(buf);\n}\n```\n\n\n\n## 读取系统供电电压\n\n```c\n//关键代码！！！\n//设置ADC模式为读取系统电压\nADC_MODE(ADC_VCC);\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200);//初始化串口\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  Serial.print(\"当前电压为：\");//打印电压信息到串口  \n  Serial.println(ESP.getVcc());\n  delay(1000);\n}\n\n```\n\n\n\n## 解决上电启动时输出乱码\n\n上电输出乱码是正常的，因为外部晶振选择是26M，请选择`74880`的波特率，`按下复位键或把RST引脚拉低再拉高`，可以看到启动信息。\n\n\n\n## 使用esp8266 驱动ws2812的灯珠\n\n需要 `Adafruit_NeoPixel` 库。\n\n```c\n#include <Adafruit_NeoPixel.h>\n\n#define PIN 5  // 定义连接ws2812灯带的引脚\n#define NUMPIXELS 16  // 定义灯带上的LED数量\n\nAdafruit_NeoPixel pixels = Adafruit_NeoPixel(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\n\nvoid setup() {\n  pixels.begin();  // 初始化ws2812灯带\n}\n\nvoid loop() {\n  for(int i=0; i<NUMPIXELS; i++) {\n    pixels.setPixelColor(i, pixels.Color(0,255,0));  // 设置每个LED的颜色\n    pixels.show();  // 更新灯带上的LED颜色\n    delay(50);\n  }\n}\n```\n\n\n\n\n\n## pwm驱动\n\n### 设置pwm频率以及占空比\n\n```c\nvoid setup() {\n    \n  analogWriteFreq(90000);  //设置频率为90khz\n  analogWriteRange(1024);  //设置占空比范围\n  analogWrite(2, 500);     //在io2引脚上，实现占空比为500/1024的pwm波形。\n\n}\n```\n\n\n\n### 使用pwm方式控制设备的工作。\n\n当按键按下时，指定的引脚会以0 20 40 60 80 100的占空比工作。\n\n```c\n#include <ESP8266WiFi.h>\n\n#define BUTTON_PIN 0  // 按键连接的引脚\n#define PWM_PIN 5     // PWM输出的引脚\n\nint dutyCycle[] = {0, 20, 40, 60, 80, 100};  // PWM的占空比\nint idx = 0;  \n\nvoid setup() {\n  pinMode(BUTTON_PIN, INPUT_PULLUP);  // 设置按键引脚为输入\n  pinMode(PWM_PIN, OUTPUT);           // 设置PWM引脚为输出\n}\n\nvoid loop() {\n  if (digitalRead(BUTTON_PIN) == LOW) {  //当按键按下\n    analogWrite(PWM_PIN, dutyCycle[idx]);  //设置指定的引脚的占空比\n    idx = (idx + 1) % 6; //循环dutyCycle数组\n    delay(500); // 延迟500ms\n  }\n    }\n  }\n}\n```\n\n\n\n\n\n\n\n## ESP8266接收红外信号\n\n前置：具有vs1838b红外接收管，并将接收管的数据极连接到esp8266\n\n\n\n### 样例程序\n\n```c++\n/**\n  作者: Raikay (raikay.com)\n  时间: 2021/01/17\n  说明: NodeMcu使用红外接收头接收红外信号\n  NodeMcu -   VS1838B\n  3v3     -    VCC\n  GND     -    GND\n  D5      -    OUT\n**/\n\n#include <Arduino.h>\n#include <IRrecv.h>\n#include <IRremoteESP8266.h>\n#include <IRac.h>\n//#include <IRtext.h>\n#include <IRutils.h>\n\n// 定义接收信号的引脚GPIO14，即NodeMcu的D5\nconst uint16_t kRecvPin = 5;\n\n//实例化IRrecv类的对象。\n// (接收引脚，接收信号大小，超时时间)\nIRrecv irrecv(kRecvPin, 1024, 50, true);\n\n// 存储结果\ndecode_results results;\n\nvoid setup() {\n\n  Serial.begin(115200);\n\n#if DECODE_HASH\n  // 过滤未知信号值\n  irrecv.setUnknownThreshold(12);\n#endif\n  irrecv.setTolerance(kTolerance);\n  // 启动接收器\n  irrecv.enableIRIn();\n}\n\nvoid loop() {\n  // 是否收到消息\n  if (irrecv.decode(&results)) {\n    \n    // 接收到的编码\n    Serial.print(\"输出编码：\");\n    serialPrintUint64(results.value, HEX);\n    Serial.println();\n    \n    // 协议和编码\n    Serial.println(\"输出协议和编码：\");\n    Serial.println(resultToHumanReadableBasic(&results));\n    yield();\n\n    // 说明\n    String description = IRAcUtils::resultAcToString(&results);\n    Serial.println(\"输出说明：\");\n    if (description.length())\n    {\n      Serial.println(\"Mesg Desc.: \" + description);\n    } else\n    {\n      Serial.println(\"Mesg Desc.: 无\");\n    }\n\n    // 原数据\n    Serial.println(\"输出原数据：\");\n    Serial.println(resultToSourceCode(&results));\n    Serial.println(\"------------------------分割线------------------------\");\n    yield();\n  }\n}\n```\n\n\n\n#### 程序输出样式\n\n```\n输出编码：FF9A65\n输出协议和编码：\nProtocol  : NEC\nCode      : 0xFF9A65 (32 Bits)\n\n输出说明：\nMesg Desc.: 无\n输出原数据：\nuint16_t rawData[71] = {8996, 4484,  578, 556,  554, 556,  576, 552,  578, 558,  552, 576,  556, 554,  576, 576,  532, 576,  556, 1686,  554, 1688,  578, 1666,  576, 1686,  576, 1664,  578, 1686,  558, 1686,  554, 1706,  558, 1686,  558, 572,  556, 576,  536, 1684,  578, 1688,  562, 566,  558, 1686,  556, 574,  556, 576,  534, 1686,  576, 1686,  558, 572,  556, 578,  532, 1704,  558, 578,  556, 1682,  558, 39922,  9016, 2242,  556};  // NEC FF9A65\nuint32_t address = 0x0;\nuint32_t command = 0x59;\nuint64_t data = 0xFF9A65;\n\n------------------------分割线------------------------\n```\n\n\n\n#### 要点说明\n\n- 实例化IRrecv类，之后的操作都需要这个类提供的方法\n\n  - IRrecv irrecv(kRecvPin, 1024, 50, true);\n\n- decode_results\n\n  - `decode_results` 是一个结构体，它用于存储红外接收器接收到的红外信号的解码结果。\n\n    使用 `decode_results` 结构体的目的是为了方便地存储和访问红外信号的解码结果。在使用 IRremoteESP8266 库进行红外信号接收时，我们需要创建一个 `decode_results` 对象，并将其作为参数传递给 `IRrecv` 对象的 `decode` 方法。当 `decode` 方法成功解码出一个红外信号时，它会将解码结果存储在 `decode_results` 对象中，我们可以通过访问该对象的不同字段来获取解码结果。\n\n    例如，在上面给出的示例代码中，我们创建了一个名为 `results` 的 `decode_results` 对象，并将其作为参数传递给了 `irrecv.decode` 方法。当该方法成功解码出一个红外信号时，它会将解码结果存储在 `results` 对象中。然后，我们可以通过访问 `results.value` 字段来获取解码出的红外命令数据，并将其打印到串口。\n\n  - 这个结构体包含了多个字段，用于存储不同类型的解码信息，例如红外信号的协议类型、命令数据、地址数据等。\n\n    下面是 `decode_results` 结构体中一些常用字段的说明：\n\n    - `decode_type`：红外信号的协议类型，例如 NEC、SONY、RC5 等。\n      - 类型：decode_type_t\n    - `value`：红外命令数据，通常是一个 32 位无符号整数。\n      - uint32_t\n    - `address`：红外地址数据，用于区分不同的设备。\n      - uint16_t\n    - `command`：红外命令数据，用于表示不同的命令。\n    - `repeat`：是否为重复信号。\n    - rawbuf：指向原始数据缓冲区的指针；\n    - rawlen：原始数据缓冲区中的数据位数（即元素个数）；\n\n    您可以通过访问这些字段来获取解码结果中的相关信息。例如，您可以使用 `results.decode_type` 来获取红外信号的协议类型，使用 `results.value` 来获取红外命令数据。\n\n- setup函数中的if...endif\n\n  - 这段代码是用来设置 IRrecv 对象的未知阈值的。`#if DECODE_HASH` 和 `#endif` 是预处理器指令，它们用来检查 `DECODE_HASH` 符号是否已定义。如果 `DECODE_HASH` 符号已定义，则 `irrecv.setUnknownThreshold(12)` 语句会被编译并执行；否则，该语句会被忽略。\n\n    `irrecv.setUnknownThreshold(12)` 语句用来设置 IRrecv 对象的未知阈值为 12。未知阈值用来指定接收到的红外信号中最少需要包含多少个脉冲才能被视为有效信号。如果接收到的红外信号中包含的脉冲数量小于未知阈值，则该信号会被忽略。\n\n- irrecv.setTolerance(kTolerance);\n\n  - `irrecv.setTolerance(kTolerance)` 是一个方法，它用于设置 IRrecv 对象的容差百分比。容差百分比用于指定红外接收器在解码红外信号时允许的最大误差范围。容差越大，红外接收器对红外信号的解码就越宽容，但也可能导致误解码的概率增加。\n\n    `kTolerance` 是一个常量，它定义了 IRrecv 对象的默认容差百分比。您可以在创建 IRrecv 对象时使用 `irrecv.setTolerance(kTolerance)` 方法来设置容差百分比。此外，您还可以在运行时使用 `irrecv.setTolerance()` 方法来动态更改容差百分比。\n\n    例如，如果您希望红外接收器对红外信号的解码更加严格，可以将容差百分比设置得更小；反之，如果您希望红外接收器对红外信号的解码更加宽容，可以将容差百分比设置得更大。\n\n  - kTolerance\n\n    - `kTolerance` 是一个常量，它定义了 IRrecv 对象的默认容差百分比。容差百分比用于指定红外接收器在解码红外信号时允许的最大误差范围。容差越大，红外接收器对红外信号的解码就越宽容，但也可能导致误解码的概率增加。\n\n      可以使用整型数来替换 `kTolerance`，以指定自定义的容差百分比。例如，您可以使用 `irrecv.setTolerance(50)` 来将容差百分比设置为 50%。\n\n      如果用整型数来替换，整型数的范围是0-100。表示容差百分比的取值范围为 0% 到 100%。\n\n    - ![image-20230814234612627](./Image/ESP8266.assets/image-20230814234612627.png)\n\n-  if (irrecv.decode(&results))\n\n   - `if (irrecv.decode(&results))` 是一个条件语句，它用于检查 `irrecv` 对象是否成功解码出一个红外信号。`irrecv.decode(&results)` 是一个方法调用，它调用了 `irrecv` 对象的 `decode` 方法，并将 `results` 对象的地址作为参数传递给该方法。\n\n     当 `decode` 方法成功解码出一个红外信号时，它会将解码结果存储在 `results` 对象中，并返回 `true`。因此，如果 `irrecv.decode(&results)` 返回 `true`，则表示成功解码出一个红外信号，此时可以在 `if` 语句的代码块中访问 `results` 对象来获取解码结果。\n\n","tags":["protected","ESP8266"],"categories":["ESP8266","案例笔记"]},{"title":"ESP8266引脚说明","url":"/2023/06/07/ESP8266引脚说明/","content":"\n# 引脚\n\n## 引脚图\n\n目前，ESP8266芯片的开发板种类繁多，在可访问的GPIOs数量、尺寸、外形规格等方面各不相同。\n\n使用最广泛的ESP8266板是ESP-01，ESP8266-12E节点MCU套件，和MINI D1。 有关这些板的比较。\n\n### ESP8266-12E、12F\n\n![image-20230524204924386](./Image/ESP8266.assets/image-20230524204924386.png)\n\n![image-20230531202710344](./Image/ESP8266.assets/image-20230531202710344.png)\n\n![image-20230531202843380](./Image/ESP8266.assets/image-20230531202843380-1685536124046-2.png)\n\n\n\n\n\n\n\n### ESP8266 12-E 套件\n\n![image-20230524205049580](./Image/ESP8266.assets/image-20230524205049580.png)\n\n### ESP8266-01/ESP8266-01S 引脚\n\n如果使用 ESP8266-01 板，可以使用以下 GPIO 关系图作为参考。\n\n![image-20230524205021242](./Image/ESP8266.assets/image-20230524205021242.png)\n\n### WeMos D1Mini\n\n![image-20230524205114673](./Image/ESP8266.assets/image-20230524205114673.png)\n\n\n\n\n\n## 各种不同版本的ESP8266对比\n\n\n\n|             | ESP01                          | ESP-01D  | ESP-01F      | ESP-01M                | ESP-01S  | ESP-07          | ESP-07S                | ESP-12E  | ESP-12F                                         | ESP-12S                        |\n| :---------- | :----------------------------- | :------- | :----------- | :--------------------- | :------- | :-------------- | :--------------------- | :------- | :---------------------------------------------- | :----------------------------- |\n| 通信协议    | 完整的802.11b/g/n WiFi Soc模块 |          |              |                        |          |                 |                        |          |                                                 |                                |\n| 工作频段    | 2400 - 2483.5MHZ               |          |              |                        |          |                 |                        |          |                                                 |                                |\n| 芯片方案    | ESP8266                        | ESP8285  | ESP8285      | ESP8285                | ESP8266  | ESP8266         | ESP8266                | ESP8266  | ESP8266                                         | ESP8266                        |\n| 天线形式    | 板载天线                       | 外接天线 | 外接天线     | 板载天线               | 板载天线 | IPEX座/陶瓷天线 | IPEX天线               | 板载天线 | 板载天线                                        | 板载天线                       |\n| 封装形式    | DIP-8                          | DIP-6    | SMD-18       | DIP-18                 | DIP-8    | SMD-16          | SMD-16                 | SMD-22   | SMD-22                                          | SMD-16                         |\n| 串口速率    | 4Mbps                          |          |              |                        |          |                 |                        |          |                                                 |                                |\n| 传输距离    | 50m                            | 40m      | 50m          | 40m                    | 50m      | 50m             | 100m                   | 80m      | 81m                                             | 82m                            |\n| 供电电压    | 3.0V-3.6V，典型值3.3V          |          |              |                        |          |                 |                        |          |                                                 |                                |\n| SPI Flash   | 8Mbit                          | 16Mbit   | 8Mbit/16Mbit | 8Mbit/17Mbit           | 8Mbit    | 8Mbit           | 32Mbit                 | 32Mbit   | 32Mbit                                          | 32Mbit                         |\n| io 口       | 2                              | 3        | 9            | 11                     | 2        | 9               | 9                      | 11       | 9                                               | 9                              |\n| 模组认证    | 暂无                           | 暂无     | FCC/CE       | FCC/CE/SRRC/REACH/ROHs | ROHs     | 暂无            | FCC/CE/SRRC/REACH/ROHs | 暂无     | FCC/CE/SRRC/IC/KCC/NCC/ REACH/TELEC/ANATEL/RoHS | FCC/CE/SRRC/ RoHs/阿里飞燕认证 |\n| Modem Sleep | 20mA                           | 20mA     | 20mA         | 20mA                   | 20mA     | 20mA            | 20mA                   | 15mA     | 20mA                                            | 20mA                           |\n| Light Sleep | 2mA                            | 2mA      | 2mA          | 2mA                    | 2mA      | 2mA             | 0.9mA                  | 2mA      | 2mA                                             | 2mA                            |\n| Deep Sleep  | 20uA                           | 20uA     | 20uA         | 20uA                   | 20uA     | 20uA            | 10uA                   | 20uA     | 20uA                                            | 20uA                           |\n\n![image-20230531202126896](./Image/ESP8266.assets/image-20230531202126896.png)\n\n\n\n\n\n\n\n## 使用引脚\n\n​\t关于 ESP8266，需要注意的一件重要的事情是 GPIO 编号与板载上的标识并不匹配。例如，D0 对应于 GPIO16，D1 对应于 GPIO5。\n\n​\t下表显示了板载标识和 GPIO 编号上的标签之间的对应关系，以及项目中最好使用的引脚，以及哪些引脚需要谨慎。\n\n​\t以**绿色**突出显示的引脚**可以使用**。以**下划线**突出显示的可以使用，但**需要注意**，因为它们可能有意外行为，主要在启动时。**不建议**将**带删除线**突出显示的引脚用作输入或输出。\n\n| **Label** | **GPIO**   | **Input** | **Output**         | **Notes**                                                    |\n| :-------- | :--------- | :-------- | :----------------- | :----------------------------------------------------------- |\n| **D0**    | **GPIO16** | 无中断    | 无 Pwm 或 I2c 支持 | HIGH at boot used to wake up from deep sleep                 |\n| **D1**    | **GPIO5**  | OK        | OK                 | 常用作SCL（I2C）                                             |\n| **D2**    | **GPIO4**  | OK        | OK                 | 常用作SDA（I2C）                                             |\n| **D3**    | **GPIO0**  | 上拉      | OK                 | connected to FLASH button, boot fails if pulled LOW          |\n| **D4**    | **GPIO2**  | 上拉      | OK                 | HIGH at boot connected to on-board LED, boot fails if pulled LOW |\n| **D5**    | **GPIO14** | OK        | OK                 | SPI (SCLK)                                                   |\n| **D6**    | **GPIO12** | OK        | OK                 | SPI (MISO)                                                   |\n| **D7**    | **GPIO13** | OK        | OK                 | SPI (MOSI)                                                   |\n| **D8**    | **GPIO15** | 下拉      | <u>OK</u>          | SPI (CS) Boot fails if pulled HIGH                           |\n| **RX**    | **GPIO3**  | <u>OK</u> | ~~RX~~             | HIGH at boot                                                 |\n| **TX**    | **GPIO1**  | ~~TX~~    | <u>OK</u>          | HIGH at boot debug output at boot, boot fails if pulled LOW  |\n| **A0**    | **ADC0**   | 模拟引脚  | ~~X~~              |                                                              |\n\n![image-20230524205842603](./Image/ESP8266.assets/image-20230524205842603.png)\n\n\n\n\n\n\n\n\n\n\n\n## 连接到闪存芯片的 GPIOS\n\nGPIO6 到 GPIO11 通常连接到 ESP8266 板中的闪存芯片。因此，不建议使用这些引脚。\n\n## 启动期间使用的引脚\n\n如果某些引脚被拉低或高，可以阻止 ESP8266 启动。以下列表显示了引导上的以下引脚的状态：\n\n- **GPIO16：**引脚在引导时高\n- **GPIO0：如果**拉低，启动失败\n- **GPIO2**： 引脚在引导时高， 启动失败， 如果拉低\n- **GPIO15**： 启动失败，如果拉高\n- **GPIO3**： 引脚在引导时高\n- **GPIO1**： 引脚在引导时高， 启动失败， 如果拉低\n- **GPIO10**： 引脚在引导时高\n- **GPIO9**： 引脚在引导时高\n\n## 引脚在启动时高\n\n当 ESP8266 启动时，某些引脚输出 3.3V 信号。如果您有继电器或其他外设连接到这些 GPIOs，这可能有问题。以下 GPIOs 在启动时输出高信号：\n\n- GPIO16\n- GPIO3\n- GPIO1\n- GPIO10\n- GPIO9\n\n此外，除 GPIO5 和 GPIO4 外，其他 GPIOs 可以在引导时输出低压信号，如果这些信号连接到晶体管或继电器，则可能会有问题。您可以[阅读本文，](http://rabbithole.wwwdotorg.org/2017/03/28/esp8266-gpio.html)其中调查每个 GPIO 在启动时的状态和行为。\n\n如果要操作继电器，GPIO4 和 GPIO5 是使用 GPIOs 最安全的方式。\n\n## 模拟输入\n\nESP8266 仅支持一个 GPIO 中的模拟读取。GPIO 称为**ADC0，**通常在丝网上标记为**A0**。\n\n如果使用 ESP8266 裸芯片，ADC0 引脚的最大输入电压为 0 到 1V。如果您使用的是 ESP8266 12-E NodeMCU 套件等开发板，则电压输入范围为 0 到 3.3V，因为这些板包含内部分压器。\n\n## 板载 LED\n\n大多数 ESP8266 开发板都具有内置 LED。此 LED 通常连接到 GPIO2(D4)。发送高信号以将其关闭，发送低信号以将其打开。\n\n## RST 引脚\n\n当 RST 引脚拉低时，ESP8266 将复位。这与按板载重置按钮相同。\n\n## GPIO0\n\n当 GPIO0 被拉低时，它会将 ESP8266 设置到引导加载器模式。这与按下板载闪存/引导按钮相同。\n\n## GPIO16\n\nGPIO16 可用于从深度睡眠中唤醒 ESP8266。要从深度睡眠中唤醒 ESP8266，GPIO16 应连接到 RST 引脚。\n\n## I2C\n\nESP8266没有硬件 I2C 引脚，但它可以在软件中实现。因此，您可以将任何 GPIOS 用作 I2C。通常，以下 GPIOS 用作 I2C 引脚：\n\n- **GPIO5**： SCL\n- **GPIO4**： SDA\n\n## Spi\n\nESP8266 中用作 SPI 的引脚包括：\n\n- **GPIO12**： MISO\n- **GPIO13**： MOSI\n- **GPIO14**： SCLK\n- **GPIO15**： CS\n\n## PWM 引脚\n\nESP8266 允许所有 I/O 引脚的软件 PWM。ESP8266 上的 PWM 信号具有 10 位分辨率。\n\n## 中断引脚\n\nESP8266 支持任何 GPIO 中的中断，GPIO16 除外。\n\n","tags":["protected","ESP8266"],"categories":["ESP8266"]},{"title":"ESP8266相关资料","url":"/2023/06/07/ESP8266相关资料/","content":"\n\n\n# 其他资料\n\n## ESP8266获取flash大小、ID、模式\n\nESP.getResetReason() —— 获取上次复位原因\nESP.getFreeHeap() —— 获取可用堆大小\nESP.getChipId() —— 获取芯片id\nESP.getCoreVersion() —— 获取核心库版本\nESP.getSdkVersion() —— 以字符形式返回SDK版本\nESP.getCpuFreqMHz() —— 获取cpu运行频率\nESP.getSketchSize() —— 获取当前固件大小\nESP.getFreeSketchSpace() —— 获取当前剩余可用固件空间\nESP.getSketchMD5() —— 返回当前固件的MD5的小写字符串\nESP.getFlashChipId() —— 获取闪存芯片id\nESP.getFlashChipSize() —— 获取sdk得到的闪存芯片大小\nESP.getFlashChipRealSize() —— 获取闪存芯片真正大小\nESP.getFlashChipSpeed() —— 获取闪存芯片运行频率\n\n系统软复位\nESP.restart() —— 软复位系统\n\n### ESP.cpp\n\n```c\n/*\n Esp.cpp - ESP8266-specific APIs\n Copyright (c) 2015 Ivan Grokhotkov. All rights reserved.\n This file is part of the esp8266 core for Arduino environment.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include \"Esp.h\"\n#include \"flash_utils.h\"\n#include \"eboot_command.h\"\n#include <memory>\n#include \"interrupts.h\"\n#include \"MD5Builder.h\"\n#include \"umm_malloc/umm_malloc.h\"\n#include \"cont.h\"\n#include \"flash_hal.h\"\n#include \"coredecls.h\"\n#include \"umm_malloc/umm_malloc.h\"\n#include <pgmspace.h>\n#include \"reboot_uart_dwnld.h\"\n\nextern \"C\" {\n#include \"user_interface.h\"\n\nextern struct rst_info resetInfo;\n}\n\n\n//#define DEBUG_SERIAL Serial\n\n#ifndef PUYA_SUPPORT\n  #define PUYA_SUPPORT 1\n#endif\n\n/**\n * User-defined Literals\n *  usage:\n *\n *   uint32_t = test = 10_MHz; // --> 10000000\n */\n\nunsigned long long operator\"\" _kHz(unsigned long long x) {\n    return x * 1000;\n}\n\nunsigned long long operator\"\" _MHz(unsigned long long x) {\n    return x * 1000 * 1000;\n}\n\nunsigned long long operator\"\" _GHz(unsigned long long x) {\n    return x * 1000 * 1000 * 1000;\n}\n\nunsigned long long operator\"\" _kBit(unsigned long long x) {\n    return x * 1024;\n}\n\nunsigned long long operator\"\" _MBit(unsigned long long x) {\n    return x * 1024 * 1024;\n}\n\nunsigned long long operator\"\" _GBit(unsigned long long x) {\n    return x * 1024 * 1024 * 1024;\n}\n\nunsigned long long operator\"\" _kB(unsigned long long x) {\n    return x * 1024;\n}\n\nunsigned long long operator\"\" _MB(unsigned long long x) {\n    return x * 1024 * 1024;\n}\n\nunsigned long long operator\"\" _GB(unsigned long long x) {\n    return x * 1024 * 1024 * 1024;\n}\n\n\nEspClass ESP;\n\nvoid EspClass::wdtEnable(uint32_t timeout_ms)\n{\n    (void) timeout_ms;\n    /// This API can only be called if software watchdog is stopped\n    system_soft_wdt_restart();\n}\n\nvoid EspClass::wdtEnable(WDTO_t timeout_ms)\n{\n    wdtEnable((uint32_t) timeout_ms);\n}\n\nvoid EspClass::wdtDisable(void)\n{\n    /// Please don't stop software watchdog too long (less than 6 seconds),\n    /// otherwise it will trigger hardware watchdog reset.\n    system_soft_wdt_stop();\n}\n\nvoid EspClass::wdtFeed(void)\n{\n    system_soft_wdt_feed();\n}\n\nvoid EspClass::deepSleep(uint64_t time_us, WakeMode mode)\n{\n    system_deep_sleep_set_option(static_cast<int>(mode));\n    system_deep_sleep(time_us);\n    esp_suspend();\n}\n\nvoid EspClass::deepSleepInstant(uint64_t time_us, WakeMode mode)\n{\n    system_deep_sleep_set_option(static_cast<int>(mode));\n    system_deep_sleep_instant(time_us);\n    esp_suspend();\n}\n\n//this calculation was taken verbatim from the SDK api reference for SDK 2.1.0.\n//Note: system_rtc_clock_cali_proc() returns a uint32_t, even though system_deep_sleep() takes a uint64_t.\nuint64_t EspClass::deepSleepMax()\n{\n  //cali*(2^31-1)/(2^12)\n  return (uint64_t)system_rtc_clock_cali_proc()*(0x80000000-1)/(0x1000);\n\n}\n\n/*\nLayout of RTC Memory is as follows:\nRef: Espressif doc 2C-ESP8266_Non_OS_SDK_API_Reference, section 3.3.23 (system_rtc_mem_write)\n\n|<------system data (256 bytes)------->|<-----------------user data (512 bytes)--------------->|\n\nSDK function signature:\nbool\tsystem_rtc_mem_read\t(\n        uint32\tdes_addr,\n        void\t*\tsrc_addr,\n        uint32\tsave_size\n)\n\nThe system data section can't be used by the user, so:\ndes_addr must be >=64 (i.e.: 256/4) and <192 (i.e.: 768/4)\nsrc_addr is a pointer to data\nsave_size is the number of bytes to write\n\nFor the method interface:\noffset is the user block number (block size is 4 bytes) must be >= 0 and <128\ndata is a pointer to data, 4-byte aligned\nsize is number of bytes in the block pointed to by data\n\nSame for write\n\nNote: If the Updater class is in play, e.g.: the application uses OTA, the eboot\ncommand will be stored into the first 128 bytes of user data, then it will be\nretrieved by eboot on boot. That means that user data present there will be lost.\nRef:\n- discussion in PR #5330.\n- https://github.com/esp8266/esp8266-wiki/wiki/Memory-Map#memmory-mapped-io-registers\n- Arduino/bootloaders/eboot/eboot_command.h RTC_MEM definition\n*/\n\nbool EspClass::rtcUserMemoryRead(uint32_t offset, uint32_t *data, size_t size)\n{\n    if (offset * 4 + size > 512 || size == 0) {\n        return false;\n    } else {\n        return system_rtc_mem_read(64 + offset, data, size);\n    }\n}\n\nbool EspClass::rtcUserMemoryWrite(uint32_t offset, uint32_t *data, size_t size)\n{\n    if (offset * 4 + size > 512 || size == 0) {\n        return false;\n    } else {\n        return system_rtc_mem_write(64 + offset, data, size);\n    }\n}\n\nvoid EspClass::reset(void)\n{\n    __real_system_restart_local();\n}\n\nvoid EspClass::restart(void)\n{\n    system_restart();\n    esp_suspend();\n}\n\n[[noreturn]] void EspClass::rebootIntoUartDownloadMode()\n{\n  wdtDisable();\n  /* disable hardware watchdog */\n  CLEAR_PERI_REG_MASK(PERIPHS_HW_WDT, 0x1);\n\n  esp8266RebootIntoUartDownloadMode();\n}\n\nuint16_t EspClass::getVcc(void)\n{\n    esp8266::InterruptLock lock;\n    (void)lock;\n    return system_get_vdd33();\n}\n\nuint32_t EspClass::getFreeHeap(void)\n{\n    return umm_free_heap_size_lw();\n}\n\n#if defined(UMM_INFO)\nuint32_t EspClass::getMaxFreeBlockSize(void)\n{\n    return umm_max_block_size();\n}\n#endif\n\nuint32_t EspClass::getFreeContStack()\n{\n    return cont_get_free_stack(g_pcont);\n}\n\nvoid EspClass::resetFreeContStack()\n{\n    cont_repaint_stack(g_pcont);\n}\n\nuint32_t EspClass::getChipId(void)\n{\n    return system_get_chip_id();\n}\n\nextern \"C\" uint32_t core_version;\nextern \"C\" const char* core_release;\n\nString EspClass::getCoreVersion()\n{\n    if (core_release != NULL) {\n        return String(core_release);\n    }\n    char buf[12];\n    snprintf(buf, sizeof(buf), \"%08x\", core_version);\n    return String(buf);\n}\n\nconst char * EspClass::getSdkVersion(void)\n{\n    return system_get_sdk_version();\n}\n\nuint8_t EspClass::getBootVersion(void)\n{\n    return system_get_boot_version();\n}\n\nuint8_t EspClass::getBootMode(void)\n{\n    return system_get_boot_mode();\n}\n\nuint32_t EspClass::getFlashChipId(void)\n{\n    static uint32_t flash_chip_id = 0;\n    if (flash_chip_id == 0) {\n        flash_chip_id = spi_flash_get_id();\n    }\n    return flash_chip_id;\n}\n\nuint8_t EspClass::getFlashChipVendorId(void)\n{\n    return (getFlashChipId() & 0x000000ff);\n}\n\nuint32_t EspClass::getFlashChipRealSize(void)\n{\n    return (1 << ((spi_flash_get_id() >> 16) & 0xFF));\n}\n\nuint32_t EspClass::getFlashChipSize(void)\n{\n#if FLASH_MAP_SUPPORT\n    return getFlashChipRealSize();\n#else\n    uint32_t data;\n    uint8_t * bytes = (uint8_t *) &data;\n    // read first 4 byte (magic byte + flash config)\n    if(spi_flash_read(0x0000, &data, 4) == SPI_FLASH_RESULT_OK) {\n        return magicFlashChipSize((bytes[3] & 0xf0) >> 4);\n    }\n    return 0;\n#endif\n}\n\nuint32_t EspClass::getFlashChipSpeed(void)\n{\n    uint32_t data;\n    uint8_t * bytes = (uint8_t *) &data;\n    // read first 4 byte (magic byte + flash config)\n    if(spi_flash_read(0x0000, &data, 4) == SPI_FLASH_RESULT_OK) {\n        return magicFlashChipSpeed(bytes[3] & 0x0F);\n    }\n    return 0;\n}\n\nFlashMode_t EspClass::getFlashChipMode(void)\n{\n    FlashMode_t mode = FM_UNKNOWN;\n    uint32_t data;\n    uint8_t * bytes = (uint8_t *) &data;\n    // read first 4 byte (magic byte + flash config)\n    if(spi_flash_read(0x0000, &data, 4) == SPI_FLASH_RESULT_OK) {\n        mode = magicFlashChipMode(bytes[2]);\n    }\n    return mode;\n}\n\n#if !FLASH_MAP_SUPPORT\nuint32_t EspClass::magicFlashChipSize(uint8_t byte) {\n    switch(byte & 0x0F) {\n        case 0x0: // 4 Mbit (512KB)\n            return (512_kB);\n        case 0x1: // 2 MBit (256KB)\n            return (256_kB);\n        case 0x2: // 8 MBit (1MB)\n            return (1_MB);\n        case 0x3: // 16 MBit (2MB)\n            return (2_MB);\n        case 0x4: // 32 MBit (4MB)\n            return (4_MB);\n        case 0x8: // 64 MBit (8MB)\n            return (8_MB);\n        case 0x9: // 128 MBit (16MB)\n            return (16_MB);\n        default: // fail?\n            return 0;\n    }\n}\n#endif\n\nuint32_t EspClass::magicFlashChipSpeed(uint8_t byte) {\n    switch(byte & 0x0F) {\n        case 0x0: // 40 MHz\n            return (40_MHz);\n        case 0x1: // 26 MHz\n            return (26_MHz);\n        case 0x2: // 20 MHz\n            return (20_MHz);\n        case 0xf: // 80 MHz\n            return (80_MHz);\n        default: // fail?\n            return 0;\n    }\n}\n\nFlashMode_t EspClass::magicFlashChipMode(uint8_t byte) {\n    FlashMode_t mode = (FlashMode_t) byte;\n    if(mode > FM_DOUT) {\n        mode = FM_UNKNOWN;\n    }\n    return mode;\n}\n\n/**\n * Infos from\n *  http://www.wlxmall.com/images/stock_item/att/A1010004.pdf\n *  http://www.gigadevice.com/product-series/5.html?locale=en_US\n *  http://www.elinux.org/images/f/f5/Winbond-w25q32.pdf\n */\nuint32_t EspClass::getFlashChipSizeByChipId(void) {\n    uint32_t chipId = getFlashChipId();\n    /**\n     * Chip ID\n     * 00 - always 00 (Chip ID use only 3 byte)\n     * 17 - ? looks like 2^xx is size in Byte ?     //todo: find docu to this\n     * 40 - ? may be Speed ?                        //todo: find docu to this\n     * C8 - manufacturer ID\n     */\n    switch(chipId) {\n\n        // GigaDevice\n        case 0x1740C8: // GD25Q64B\n            return (8_MB);\n        case 0x1640C8: // GD25Q32B\n            return (4_MB);\n        case 0x1540C8: // GD25Q16B\n            return (2_MB);\n        case 0x1440C8: // GD25Q80\n            return (1_MB);\n        case 0x1340C8: // GD25Q40\n            return (512_kB);\n        case 0x1240C8: // GD25Q20\n            return (256_kB);\n        case 0x1140C8: // GD25Q10\n            return (128_kB);\n        case 0x1040C8: // GD25Q12\n            return (64_kB);\n\n        // Winbond\n        case 0x1840EF: // W25Q128\n            return (16_MB);\n        case 0x1640EF: // W25Q32\n            return (4_MB);\n        case 0x1540EF: // W25Q16\n            return (2_MB);\n        case 0x1440EF: // W25Q80\n            return (1_MB);\n        case 0x1340EF: // W25Q40\n            return (512_kB);\n\n        // BergMicro\n        case 0x1640E0: // BG25Q32\n            return (4_MB);\n        case 0x1540E0: // BG25Q16\n            return (2_MB);\n        case 0x1440E0: // BG25Q80\n            return (1_MB);\n        case 0x1340E0: // BG25Q40\n            return (512_kB);\n\n        // XMC - Wuhan Xinxin Semiconductor Manufacturing Corp\n        case 0x164020: // XM25QH32B\n            return (4_MB);\n\n        default:\n            return 0;\n    }\n}\n\n/**\n * check the Flash settings from IDE against the Real flash size\n * @param needsEquals (return only true it equals)\n * @return ok or not\n */\nbool EspClass::checkFlashConfig(bool needsEquals) {\n    if(needsEquals) {\n        if(getFlashChipRealSize() == getFlashChipSize()) {\n            return true;\n        }\n    } else {\n        if(getFlashChipRealSize() >= getFlashChipSize()) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// These are defined in the linker script, and filled in by the elf2bin.py util\nextern \"C\" uint32_t __crc_len;\nextern \"C\" uint32_t __crc_val;\n\nbool EspClass::checkFlashCRC() {\n    // Dummy CRC fill\n    uint32_t z[2];\n    z[0] = z[1] = 0;\n\n    uint32_t firstPart = (uintptr_t)&__crc_len - 0x40200000; // How many bytes to check before the 1st CRC val\n\n    // Start the checksum\n    uint32_t crc = crc32((const void*)0x40200000, firstPart);\n    // Pretend the 2 words of crc/len are zero to be idempotent\n    crc = crc32(z, 8, crc);\n    // Finish the CRC calculation over the rest of flash\n    crc = crc32((const void*)(0x40200000 + firstPart + 8), __crc_len - (firstPart + 8), crc);\n    return crc == __crc_val;\n}\n\n\nString EspClass::getResetReason(void) {\n    const __FlashStringHelper* buff;\n\n    switch(resetInfo.reason) {\n        // normal startup by power on\n        case REASON_DEFAULT_RST:      buff = F(\"Power On\"); break;\n        // hardware watch dog reset\n        case REASON_WDT_RST:          buff = F(\"Hardware Watchdog\"); break;\n        // exception reset, GPIO status won’t change\n        case REASON_EXCEPTION_RST:    buff = F(\"Exception\"); break;\n        // software watch dog reset, GPIO status won’t change\n        case REASON_SOFT_WDT_RST:     buff = F(\"Software Watchdog\"); break;\n        // software restart ,system_restart , GPIO status won’t change\n        case REASON_SOFT_RESTART:     buff = F(\"Software/System restart\"); break;\n        // wake up from deep-sleep\n        case REASON_DEEP_SLEEP_AWAKE: buff = F(\"Deep-Sleep Wake\"); break;\n        // // external system reset\n        case REASON_EXT_SYS_RST:      buff = F(\"External System\"); break;\n        default:                      buff = F(\"Unknown\"); break;\n    }\n    return String(buff);\n}\n\nString EspClass::getResetInfo(void) {\n    if (resetInfo.reason >= REASON_WDT_RST && resetInfo.reason <= REASON_SOFT_WDT_RST) {\n        char buff[200];\n        sprintf_P(buff, PSTR(\"Fatal exception:%d flag:%d (%s) epc1:0x%08x epc2:0x%08x epc3:0x%08x excvaddr:0x%08x depc:0x%08x\"),\n            resetInfo.exccause, resetInfo.reason, getResetReason().c_str(),\n            resetInfo.epc1, resetInfo.epc2, resetInfo.epc3, resetInfo.excvaddr, resetInfo.depc);\n        return String(buff);\n    }\n    return getResetReason();\n}\n\nstruct rst_info * EspClass::getResetInfoPtr(void) {\n    return &resetInfo;\n}\n\nbool EspClass::eraseConfig(void) {\n    const size_t cfgSize = 0x4000;\n    size_t cfgAddr = ESP.getFlashChipSize() - cfgSize;\n\n    for (size_t offset = 0; offset < cfgSize; offset += SPI_FLASH_SEC_SIZE) {\n        if (!flashEraseSector((cfgAddr + offset) / SPI_FLASH_SEC_SIZE)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nuint8_t *EspClass::random(uint8_t *resultArray, const size_t outputSizeBytes)\n{\n  /**\n   * The ESP32 Technical Reference Manual v4.1 chapter 24 has the following to say about random number generation (no information found for ESP8266):\n   *\n   * \"When used correctly, every 32-bit value the system reads from the RNG_DATA_REG register of the random number generator is a true random number.\n   * These true random numbers are generated based on the noise in the Wi-Fi/BT RF system.\n   * When Wi-Fi and BT are disabled, the random number generator will give out pseudo-random numbers.\n   *\n   * When Wi-Fi or BT is enabled, the random number generator is fed two bits of entropy every APB clock cycle (normally 80 MHz).\n   * Thus, for the maximum amount of entropy, it is advisable to read the random register at a maximum rate of 5 MHz.\n   * A data sample of 2 GB, read from the random number generator with Wi-Fi enabled and the random register read at 5 MHz,\n   * has been tested using the Dieharder Random Number Testsuite (version 3.31.1).\n   * The sample passed all tests.\"\n   *\n   * Since ESP32 is the sequal to ESP8266 it is unlikely that the ESP8266 is able to generate random numbers more quickly than 5 MHz when run at a 80 MHz frequency.\n   * A maximum random number frequency of 0.5 MHz is used here to leave some margin for possibly inferior components in the ESP8266.\n   * It should be noted that the ESP8266 has no Bluetooth functionality, so turning the WiFi off is likely to cause RANDOM_REG32 to use pseudo-random numbers.\n   *\n   * It is possible that yield() must be called on the ESP8266 to properly feed the hardware random number generator new bits, since there is only one processor core available.\n   * However, no feeding requirements are mentioned in the ESP32 documentation, and using yield() could possibly cause extended delays during number generation.\n   * Thus only delayMicroseconds() is used below.\n   */\n\n  constexpr uint8_t cooldownMicros = 2;\n  static uint32_t lastCalledMicros = micros() - cooldownMicros;\n\n  uint32_t randomNumber = 0;\n\n  for(size_t byteIndex = 0; byteIndex < outputSizeBytes; ++byteIndex)\n  {\n    if(byteIndex % 4 == 0)\n    {\n      // Old random number has been used up (random number could be exactly 0, so we can't check for that)\n\n      uint32_t timeSinceLastCall = micros() - lastCalledMicros;\n      if(timeSinceLastCall < cooldownMicros)\n        delayMicroseconds(cooldownMicros - timeSinceLastCall);\n\n      randomNumber = RANDOM_REG32;\n      lastCalledMicros = micros();\n    }\n\n    resultArray[byteIndex] = randomNumber;\n    randomNumber >>= 8;\n  }\n\n  return resultArray;\n}\n\nuint32_t EspClass::random()\n{\n  union { uint32_t b32; uint8_t b8[4]; } result;\n  random(result.b8, 4);\n  return result.b32;\n}\n\nuint32_t EspClass::getSketchSize() {\n    static uint32_t result = 0;\n    if (result)\n        return result;\n\n    image_header_t image_header;\n    uint32_t pos = APP_START_OFFSET;\n    if (spi_flash_read(pos, (uint32_t*) &image_header, sizeof(image_header)) != SPI_FLASH_RESULT_OK) {\n        return 0;\n    }\n    pos += sizeof(image_header);\n#ifdef DEBUG_SERIAL\n    DEBUG_SERIAL.printf(\"num_segments=%u\\r\\n\", image_header.num_segments);\n#endif\n    for (uint32_t section_index = 0;\n        section_index < image_header.num_segments;\n        ++section_index)\n    {\n        section_header_t section_header = {0, 0};\n        if (spi_flash_read(pos, (uint32_t*) &section_header, sizeof(section_header)) != SPI_FLASH_RESULT_OK) {\n            return 0;\n        }\n        pos += sizeof(section_header);\n        pos += section_header.size;\n#ifdef DEBUG_SERIAL\n        DEBUG_SERIAL.printf(\"section=%u size=%u pos=%u\\r\\n\", section_index, section_header.size, pos);\n#endif\n    }\n    result = (pos + 16) & ~15;\n    return result;\n}\n\nuint32_t EspClass::getFreeSketchSpace() {\n\n    uint32_t usedSize = getSketchSize();\n    // round one sector up\n    uint32_t freeSpaceStart = (usedSize + FLASH_SECTOR_SIZE - 1) & (~(FLASH_SECTOR_SIZE - 1));\n    uint32_t freeSpaceEnd = (uint32_t)FS_start - 0x40200000;\n\n#ifdef DEBUG_SERIAL\n    DEBUG_SERIAL.printf(\"usedSize=%u freeSpaceStart=%u freeSpaceEnd=%u\\r\\n\", usedSize, freeSpaceStart, freeSpaceEnd);\n#endif\n    return freeSpaceEnd - freeSpaceStart;\n}\n\nbool EspClass::updateSketch(Stream& in, uint32_t size, bool restartOnFail, bool restartOnSuccess) {\n  if(!Update.begin(size)){\n#ifdef DEBUG_SERIAL\n    DEBUG_SERIAL.print(\"Update \");\n    Update.printError(DEBUG_SERIAL);\n#endif\n    if(restartOnFail) ESP.restart();\n    return false;\n  }\n\n  if(Update.writeStream(in) != size){\n#ifdef DEBUG_SERIAL\n    DEBUG_SERIAL.print(\"Update \");\n    Update.printError(DEBUG_SERIAL);\n#endif\n    if(restartOnFail) ESP.restart();\n    return false;\n  }\n\n  if(!Update.end()){\n#ifdef DEBUG_SERIAL\n    DEBUG_SERIAL.print(\"Update \");\n    Update.printError(DEBUG_SERIAL);\n#endif\n    if(restartOnFail) ESP.restart();\n    return false;\n  }\n\n#ifdef DEBUG_SERIAL\n    DEBUG_SERIAL.println(\"Update SUCCESS\");\n#endif\n    if(restartOnSuccess) ESP.restart();\n    return true;\n}\n\nstatic const int FLASH_INT_MASK = ((B10 << 8) | B00111010);\n\nbool EspClass::flashEraseSector(uint32_t sector) {\n    int rc = spi_flash_erase_sector(sector);\n    return rc == 0;\n}\n\n// Adapted from the old version of `flash_hal_write()` (before 3.0.0), which was used for SPIFFS to allow\n// writing from both unaligned u8 buffers and to an unaligned offset on flash.\n// Updated version re-uses some of the code from RTOS, replacing individual methods for block & page\n// writes with just a single one\n// https://github.com/espressif/ESP8266_RTOS_SDK/blob/master/components/spi_flash/src/spi_flash.c\n// (if necessary, we could follow the esp-idf code and introduce flash chip drivers controling more than just writing methods?)\n\n// This is a generic writer that does not cross page boundaries.\n// Offset, data address and size *must* be 4byte aligned.\nstatic SpiFlashOpResult spi_flash_write_page_break(uint32_t offset, uint32_t *data, size_t size) {\n    static constexpr uint32_t PageSize { FLASH_PAGE_SIZE };\n    size_t size_page_aligned = PageSize - (offset % PageSize);\n\n    // most common case, we don't cross a page and simply write the data\n    if (size < size_page_aligned) {\n        return spi_flash_write(offset, data, size);\n    }\n\n    // otherwise, write the initial part and continue writing breaking each page interval\n    SpiFlashOpResult result = SPI_FLASH_RESULT_ERR;\n    if ((result = spi_flash_write(offset, data, size_page_aligned)) != SPI_FLASH_RESULT_OK) {\n        return result;\n    }\n\n    const auto last_page = (size - size_page_aligned) / PageSize;\n    for (uint32_t page = 0; page < last_page; ++page) {\n        if ((result = spi_flash_write(offset + size_page_aligned, data + (size_page_aligned >> 2), PageSize)) != SPI_FLASH_RESULT_OK) {\n            return result;\n        }\n\n        size_page_aligned += PageSize;\n    }\n\n    // finally, the remaining data\n    return spi_flash_write(offset + size_page_aligned, data + (size_page_aligned >> 2), size - size_page_aligned);\n}\n\n#if PUYA_SUPPORT\n// Special wrapper for spi_flash_write *only for PUYA flash chips*\n// Already handles paging, could be used as a `spi_flash_write_page_break` replacement\nstatic SpiFlashOpResult spi_flash_write_puya(uint32_t offset, uint32_t *data, size_t size) {\n    if (data == nullptr) {\n      return SPI_FLASH_RESULT_ERR;\n    }\n    if (size % 4 != 0) {\n      return SPI_FLASH_RESULT_ERR;\n    }\n    // PUYA flash chips need to read existing data, update in memory and write modified data again.\n    static uint32_t *flash_write_puya_buf = nullptr;\n\n    if (flash_write_puya_buf == nullptr) {\n        flash_write_puya_buf = (uint32_t*) malloc(FLASH_PAGE_SIZE);\n        // No need to ever free this, since the flash chip will never change at runtime.\n        if (flash_write_puya_buf == nullptr) {\n            // Memory could not be allocated.\n            return SPI_FLASH_RESULT_ERR;\n        }\n    }\n\n    SpiFlashOpResult rc = SPI_FLASH_RESULT_OK;\n    uint32_t* ptr = data;\n    size_t bytesLeft = size;\n    uint32_t pos = offset;\n    while (bytesLeft > 0 && rc == SPI_FLASH_RESULT_OK) {\n        size_t bytesNow = bytesLeft;\n        if (bytesNow > FLASH_PAGE_SIZE) {\n            bytesNow = FLASH_PAGE_SIZE;\n            bytesLeft -= FLASH_PAGE_SIZE;\n        } else {\n            bytesLeft = 0;\n        }\n        rc = spi_flash_read(pos, flash_write_puya_buf, bytesNow);\n        if (rc != SPI_FLASH_RESULT_OK) {\n            return rc;\n        }\n        for (size_t i = 0; i < bytesNow / 4; ++i) {\n            flash_write_puya_buf[i] &= *ptr;\n            ++ptr;\n        }\n        rc = spi_flash_write(pos, flash_write_puya_buf, bytesNow);\n        pos += bytesNow;\n    }\n    return rc;\n}\n#endif\n\nstatic constexpr size_t Alignment { 4 };\n\ntemplate <typename T>\nstatic T aligned(T value) {\n    static constexpr auto Mask = Alignment - 1;\n    return (value + Mask) & ~Mask;\n}\n\ntemplate <typename T>\nstatic T alignBefore(T value) {\n    return aligned(value) - Alignment;\n}\n\nstatic bool isAlignedAddress(uint32_t address) {\n    return (address & (Alignment - 1)) == 0;\n}\n\nstatic bool isAlignedSize(size_t size) {\n    return (size & (Alignment - 1)) == 0;\n}\n\nstatic bool isAlignedPointer(const uint8_t *ptr) {\n    return isAlignedAddress(reinterpret_cast<uint32_t>(ptr));\n}\n\n\nsize_t EspClass::flashWriteUnalignedMemory(uint32_t address, const uint8_t *data, size_t size) {\n    auto flash_write = [](uint32_t address, uint8_t *data, size_t size) {\n        return spi_flash_write(address, reinterpret_cast<uint32_t *>(data), size) == SPI_FLASH_RESULT_OK;\n    };\n\n    auto flash_read = [](uint32_t address, uint8_t *data, size_t size) {\n        return spi_flash_read(address, reinterpret_cast<uint32_t *>(data), size) == SPI_FLASH_RESULT_OK;\n    };\n\n    constexpr size_t BufferSize { FLASH_PAGE_SIZE };\n    alignas(alignof(uint32_t)) uint8_t buf[BufferSize];\n\n    size_t written = 0;\n\n    if (!isAlignedAddress(address)) {\n        auto before_address = alignBefore(address);\n        auto offset = address - before_address;\n        auto wlen = std::min(Alignment - offset, size);\n\n        if (!flash_read(before_address, &buf[0], Alignment)) {\n            return 0;\n        }\n\n#if PUYA_SUPPORT\n        if (getFlashChipVendorId() == SPI_FLASH_VENDOR_PUYA) {\n            for (size_t i = 0; i < wlen ; ++i) {\n                buf[offset + i] &= data[i];\n            }\n        } else {\n#endif\n            memcpy(&buf[offset], data, wlen);\n#if PUYA_SUPPORT\n        }\n#endif\n\n        if (!flash_write(before_address, &buf[0], Alignment)) {\n            return 0;\n        }\n\n        address += wlen;\n        data += wlen;\n        written += wlen;\n        size -= wlen;\n    }\n\n    while (size > 0) {\n        auto len = std::min(size, BufferSize);\n        auto wlen = aligned(len);\n\n        if (wlen != len) {\n            auto partial = wlen - Alignment;\n            if (!flash_read(address + partial, &buf[partial], Alignment)) {\n                return written;\n            }\n        }\n\n        memcpy(&buf[0], data, len);\n        if (!flashWrite(address, reinterpret_cast<const uint32_t *>(&buf[0]), wlen)) {\n            return written;\n        }\n\n        address += len;\n        data += len;\n        written += len;\n        size -= len;\n    }\n\n    return written;\n}\n\nbool EspClass::flashWrite(uint32_t address, const uint32_t *data, size_t size) {\n    SpiFlashOpResult result;\n#if PUYA_SUPPORT\n    if (getFlashChipVendorId() == SPI_FLASH_VENDOR_PUYA) {\n        result = spi_flash_write_puya(address, const_cast<uint32_t *>(data), size);\n    }\n    else\n#endif\n    {\n        result = spi_flash_write_page_break(address, const_cast<uint32_t *>(data), size);\n    }\n    return result == SPI_FLASH_RESULT_OK;\n}\n\nbool EspClass::flashWrite(uint32_t address, const uint8_t *data, size_t size) {\n    if (data && size) {\n        if (!isAlignedAddress(address)\n         || !isAlignedPointer(data)\n         || !isAlignedSize(size))\n        {\n            return flashWriteUnalignedMemory(address, data, size) == size;\n        }\n\n        return flashWrite(address, reinterpret_cast<const uint32_t *>(data), size);\n    }\n\n    return false;\n}\n\nbool EspClass::flashRead(uint32_t address, uint8_t *data, size_t size) {\n    size_t sizeAligned = size & ~3;\n    size_t currentOffset = 0;\n\n    if ((uintptr_t)data % 4 != 0) {\n        constexpr size_t BufferSize { FLASH_PAGE_SIZE / sizeof(uint32_t) };\n        alignas(alignof(uint32_t)) uint32_t buf[BufferSize];\n        size_t sizeLeft = sizeAligned;\n\n        while (sizeLeft) {\n            size_t willCopy = std::min(sizeLeft, BufferSize);\n            // We read to our aligned buffer and then copy to data\n            if (!flashRead(address + currentOffset, &buf[0], willCopy))\n            {\n                return false;\n            }\n            memcpy(data + currentOffset, &buf[0], willCopy);\n            sizeLeft -= willCopy;\n            currentOffset += willCopy;\n        }\n    } else {\n        // Pointer is properly aligned, so use aligned read\n        if (!flashRead(address, reinterpret_cast<uint32_t *>(data), sizeAligned)) {\n            return false;\n        }\n        currentOffset = sizeAligned;\n    }\n\n    if (currentOffset < size) {\n        uint32_t tempData;\n        if (spi_flash_read(address + currentOffset, &tempData, sizeof(tempData)) != SPI_FLASH_RESULT_OK) {\n            return false;\n        }\n        memcpy(data + currentOffset, &tempData, size - currentOffset);\n    }\n\n    return true;\n}\n\nbool EspClass::flashRead(uint32_t address, uint32_t *data, size_t size) {\n    if ((uintptr_t)data % 4 != 0 || size % 4 != 0) {\n        return false;\n    }\n    return (spi_flash_read(address, data, size) == SPI_FLASH_RESULT_OK);\n}\n\nString EspClass::getSketchMD5()\n{\n    static String result;\n    if (result.length()) {\n        return result;\n    }\n    uint32_t lengthLeft = getSketchSize();\n    const size_t bufSize = 512;\n    std::unique_ptr<uint8_t[]> buf(new (std::nothrow) uint8_t[bufSize]);\n    uint32_t offset = 0;\n    if(!buf.get()) {\n        return emptyString;\n    }\n    MD5Builder md5;\n    md5.begin();\n    while( lengthLeft > 0) {\n        size_t readBytes = (lengthLeft < bufSize) ? lengthLeft : bufSize;\n        if (!flashRead(offset, reinterpret_cast<uint32_t *>(buf.get()), (readBytes + 3) & ~3)) {\n            return emptyString;\n        }\n        md5.add(buf.get(), readBytes);\n        lengthLeft -= readBytes;\n        offset += readBytes;\n    }\n    md5.calculate();\n    result = md5.toString();\n    return result;\n}\n\nvoid EspClass::setExternalHeap()\n{\n#ifdef UMM_HEAP_EXTERNAL\n    if (!umm_push_heap(UMM_HEAP_EXTERNAL)) {\n        panic();\n    }\n#endif\n}\n\nvoid EspClass::setIramHeap()\n{\n#ifdef UMM_HEAP_IRAM\n    if (!umm_push_heap(UMM_HEAP_IRAM)) {\n        panic();\n    }\n#endif\n}\n\nvoid EspClass::setDramHeap()\n{\n#if defined(UMM_HEAP_EXTERNAL) && !defined(UMM_HEAP_IRAM)\n    if (!umm_push_heap(UMM_HEAP_DRAM)) {\n        panic();\n    }\n#elif defined(UMM_HEAP_IRAM)\n    if (!umm_push_heap(UMM_HEAP_DRAM)) {\n        panic();\n    }\n#endif\n}\n\nvoid EspClass::resetHeap()\n{\n#if defined(UMM_HEAP_EXTERNAL) && !defined(UMM_HEAP_IRAM)\n    if (!umm_pop_heap()) {\n        panic();\n    }\n#elif defined(UMM_HEAP_IRAM)\n    if (!umm_pop_heap()) {\n        panic();\n    }\n#endif\n}\n```\n\n","tags":["protected","ESP8266"],"categories":["ESP8266","开发资料"]},{"title":"ESP8266开发参考资料","url":"/2023/06/07/ESP8266开发参考资料_第三方库使用说明/","content":"\n\n# 开发参考资料\n\n## ESP8266-Arduino库 总览\n\n![image-20230525094015023](./Image/ESP8266.assets/image-20230525094015023.png)\n\n\n\n### 网络功能\n\n物联网相关的ESP8266库。这些库主要用于控制ESP8266连接WiFi网络、设置工作模式以及利用通用的互联网协议（TCP/IP协议族）实现ESP8266物联网应用。\n\n#### 工作模式\n\nESP8266共有三种工作模式，分别是`无线接入点模式（AP）`、`无线终端模式（Wireless Station）`以及`混合模式（以上两种模式的混合）`。这一部分的库主要用于控制ESP8266的工作模式。\n\n- ESP8266WiFiAP库 – ESP8266 WiFi接入点工作模式应用库\n- ESP8266WiFiSTA库– ESP8266 WiFi终端工作模式应用库\n\n#### 联网\n\n- ESP8266WiFiGeneric库 – ESP8266基本功能库\n- ESP8266WiFiMulti库 – ESP8266记录多个WiFi网络信息并自动连接信号最强的WiFi网络\n- ESP8266WiFiScan库 – ESP8266扫描WiFi网络信号库\n\n\n\n#### 物联网通讯\n\n##### TCP协议\n\n- WiFiClient库 – TCP客户端库\n- WiFiServer库 – TCP服务器库\n\n\n\n##### HTTP协议\n\n- ESP8266HTTPClient库 – HTTP客户端库\n- ESP8266WebServer库 – HTTP服务器库\n\n\n\n##### HTTPS协议\n\n- WiFiClientSecure库 – HTTPS客户端库\n- WiFiServerSecure库 – HTTPS服务器库\n\n\n\n##### UDP协议\n\n- WiFiUDP库 – UDP通讯库\n\n\n\n##### DNS协议\n\n- DNSServer库 – DNS服务器应用库\n\n\n\n#### 其它部分\n\n由于本部分库相对应用较少，因此仅对它们进行简单介绍，而不像以上库内容具有较为详细介绍内容。\n\n- ESP8266mDNS库\n- ESP8266LLMNR库\n- Ethernet库\n- ESP8266NetBIOS库\n- ESP8266SSDP库\n\n\n\n#### ESP8266库网络功能其它部分各库简介\n\n由于本部分库中的内容较少被用户所使用。因此我们仅对这部分内容进行简单介绍。\n\n— **ESP8266mDNS库**\n通过本库，我们可以利用mDNS协议(multicast DNS协议)为ESP8266建立域名访问功能。也就是说，我们在通过WiFi访问ESP8266时，无需使用ESP8266的IP地址，而可以为ESP8266分配域名并实现访问。就像我们在访问某一个网址服务器一样。但由于安卓系统不支持mDNS协议，因此使用本库时要慎重。\n\n— **ESP8266LLMNR库**\n通过本库，我们可以利用LLMNR协议(Link-Local Multicast Name Resolution协议)为ESP8266建立域名访问功能。也就是说，我们在通过WiFi访问ESP8266时，无需使用ESP8266的IP地址，而可以为ESP8266分配域名并实现访问。就像我们在访问某一个网址服务器一样。但由于Linux和苹果电脑mac系统不支持LLMNR协议，因此使用本库时要慎重。\n\n— **Ethernet库**\n本库用于ESP8266的以太网通讯。该库是由[Arduino的Ethernet库](https://www.arduino.cc/en/Reference/Ethernet)修改而来，以使ESP8266模块具备以太网通讯功能。\n\n— **ESP8266NetBIOS库**\n本库用于ESP8266的NetBIOS应用。NetBIOS是Network Basic Input/Output System的缩写，其中文名称是网上基本输入输出系统。NetBIOS可用于局域网设备间传输数据信息。如需了解更多关于NetBIOS的基本介绍，可前往[百度百科的NETBIOS介绍页面](https://baike.baidu.com/item/NETBIOS)。\n\n— **ESP8266SSDP库**\n本库用于ESP8266的SSDP应用。SSDP是Simple Service Discovery Protocol的缩写，其中文名称是简单服务发现协议。SSDP协议提供了在网络里面发现设备的机制。控制点（也就是接受服务的客户端）可以通过使用SSDP协议，根据自己的需要查询网络里面提供服务的设备。设备（也就是提供服务的服务器端）也可以通过使用SSDP协议，向网络里的控制点宣告它的存在。\n\n\n\n### 非网络功能\n\n#### 时控部分\n\n- TICKER库 – 控制ESP8266定时执行任务。通过Ticker库，我们可以实现ESP8266的多任务处理功能。\n\n#### 哈希部分\n\n- HASH库 – 哈希算法库\n\n#### 数据储存部分\n\n- EEPROM库 – EEPROM数据储存库\n- SPIFFS库 – 闪存文件系统控制库\n- LittleFS库 – 闪存文件系统控制库\n- SD库 – SD文件储存库\n- ESP8266SdFat库 – Fat文件储存库\n\n\n\n#### 通讯部分\n\n##### SPI\n\n- SPI库 – SPI通讯库\n- SPISlave库 – SPI通讯库\n\n##### I2C\n\n- Wire库 – I2C通讯库\n\n##### 串行通讯\n\n- SoftwareSerial库 – 软件串口库\n\n##### 电机控制部分\n\n- Servo库 – 舵机控制库\n\n##### 显示屏控制部分\n\n- TFT_Touch_Shield_V2库 – TFT触摸屏控制库\n\n##### 其它部分\n\n- GDBStub库 – GDB调试支持\n\n------\n\n### OTA功能\n\n所谓OTA即Over The Air的英文缩写。该词对ESP8266来说指通过WiFi来向ESP8266上传控制程序或向ESP8266的闪存写入信息。如需了解以下各库的基本介绍，[请点击此处](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266-ota/)。\n\n- ArduinoOTA库 – 使用Arduino IDE通过WiFi为开发板上传控制程序\n- ESP8266HTTPUpdateServer库 – 使用WiFi通过HTTP协议为ESP8266上传程序或闪存文件（有服务器功能）\n- ESP8266httpUpdate库 – 使用WiFi通过HTTP协议为ESP8266上传程序或闪存文件\n- ArduinoAVRISP库 – 通过WiFi为与ESP8266相连的Arduino控制器上传程序\n\n\n\n## ESP8266WiFiAP库\n\nESP8266可以建立WiFi网络供其它设备连接。当ESP8266以此模式运行时，我们可以使用手机搜索ESP8266所建立的WiFi网络并进行连接。\n\n![image-20230525141729646](./Image/ESP8266.assets/image-20230525141729646.png)\n\n当ESP8266以上图所示的模式进行工作时，我们称ESP8266的工作模式是“接入点模式(AP模式)”。\n\nESP8266模块的工作模式一共有三种。分别是：1，接入点模式（AP）2，无线终端模式（Wireless Station）3，混合模式。\n\nESP8266WiFiAP库用于ESP8266的接入点工作模式启动和设置。以下为ESP8266WiFiAP库的整体结构图。在此图下方有ESP8266WiFiAP库的函数目录。您可以通过点击目录项目打开各个函数的说明页面。\n\n![image-20230525141521748](./Image/ESP8266.assets/image-20230525141521748.png)\n\n### 管理类型\n\n#### softAP\n\n##### 说明\n\nsoftAP函数可用于启动校验式wifi网络或开放式wifi网络。校验式网络就是需要我们输入密码的网络，开放网络也就是不需要密码，只需要知道网络的名字就可以链接的无密码网络。\n\n##### 语法\n\n`WiFi.softAP`()\n`WiFi.softAP(ssid, passphrase, channel, ssid_hidden, max_connection)`\n\n\n\n##### 参数\n\n- ssid: char型，WiFi网络名称\n\n- passphrase: int型，WiFi密码(对于WPA2加密类型最少8个字符，对于开放网络设置为NULL)\n\n  channel: int型，wifi信道。可选通道有1-13，不设置的情况下默认是1。\n\n  hidden: bool型，控制 WiFI是否隐藏的标志变量。设置为0不隐藏，设置为1隐藏。\n\n- \n\n- passphrase: int型，WiFi密码(对于WPA2加密类型最少8个字符，对于开放网络设置为NULL)\n\n  channel: int型，wifi信道。可选通道有1-13，不设置的情况下默认是1。\n\n  hidden: bool型，控制 WiFI是否隐藏的标志变量。设置为0不隐藏，设置为1隐藏。\n\n- max_connection: int型，最大的允许连接的无线终端数量。可选数值范围是1 – 4(ESP8266模块最多允许同时连接的无线终端设备数量是4个）。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将以下示例程序上传给ESP8266开发板后，ESP8266将会建立一个隐藏的WiFi网络。网络名称(SSID)为”TaichiMaker_WIFI”,网络密码为”12345678″ 。这些信息都是通过以下程序中的`WiFi.softAP(AP_ssid, password,3,1);`实现的。当然您也可以自行修改网络名称(SSID)和网络密码。\n\n值得注意的是，`WiFi.softAP(AP_ssid, password,3,1)`语句中的3意味着ESP8266所建立的WiFi网络使用信道3。最后一个参数1意味着此WiFi网络是隐藏网络。\n\n```c\n/****************************************************\n程序名称/Program name     : softAP()\n程序目的/Purpose          : \n此程序使用ESP8266WiFiAP库来演示softAP()函数的用法\nsoftAP()函数会开启一个校验式wifi。我们可以在代码中设置WiFi网络名称、\nWiFi密码、最大允许连接设备数量、信号通道编号、是否广播WiFi名称。\n-----------------------------------------------------****************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下接入点名字\n#define password  \"12345678\"         //这里改成你的设备当前环境下接入点密码\nvoid setup() {\n  // 启动串口通讯\n  Serial.begin(9600); \n  Serial.println();\n  //配置接入点信息\n  WiFi.mode(WIFI_AP);\n  //启动接入点模式，并设置账号和密码\n  Serial.print(\"设置接入点中 ... \");\n  //启动校验式网络（需要输入账号密码的网络）,通道为3，wifi隐藏，最大连接数=4\n  WiFi.softAP(AP_ssid, password,3,1);\n\n  Serial.println(\"\");              // 通过串口监视器输出信息\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"接入点名字:\");    \n  Serial.println(AP_ssid);         // 告知用户建立的接入点WiFi名\n  Serial.print(\"接入点密码:\");        \n  Serial.println(password);        // 告知用户建立的接入点WiFi密码\n}\n\nvoid loop() {\n\n}\n```\n\n#### softAPConfig\n\n##### 说明\n\nsoftAPConfig函数可用于配置ESP8266开发板所建立的接入点网络信息，如开发板IP地址，网关，子网掩码。\n\n假如您对IP地址、网关、以及子网掩码的概念不甚清楚，可通过以下百度百科内容来对它们进行初步了解。\n\n[百度百科-IP地址介绍页面](https://baike.baidu.com/item/IP地址)\n[百度百科-网关介绍页面](https://baike.baidu.com/item/网关)\n[百度百科-子网掩码介绍页面](https://baike.baidu.com/item/子网掩码)\n\n##### 语法\n\n`WiFi.softAPConfig()\nWiFi.softAPConfig (local_ip, gateway, subnet)`\n\n##### 参数\n\n- local_ip： 接入点的ip地址。(IPAddress型)\n- gateway： 网关IP地址。 (IPAddress型)\n- subnet： 子网掩码。(IPAddress型）\n\n##### 返回值\n\n返回设置结果。设置成功返回true，否则返回false。数据类型为bool型。\n\n##### 示例程序\n\n在以下示例程序中，我们使用了以下语句建立了三个IPAddress类型的变量。\n\n`IPAddress local_IP(192,168,4,22);//手动设置的开启的网络的ip地址 `\n\n`IPAddress gateway(192,168,4,9); //手动设置的网关IP地址`\n\n`IPAddress subnet(255,255,255,0); //手动设置的子网掩码`\n\n接下来我们使用以下语句，利用以上变量对ESP8266所建立的WiFi网络进行设置。\n\n`WiFi.softAPConfig(local_IP, gateway, subnet);`\n\n**注意：在不同的网络环境中，子网掩码，网关IP等信息各不相同，所以您在使用本示例程序时要根据您网络环境的网关IP、设备IP、子网掩码进行相应设置。请不要照搬示例程序中的IP地址，否则例程可能会无法正常运行。**\n\n```c\n/***************************************************\n程序名称/Program name     : softAPConfig()演示\n程序目的/Purpose          : \n此程序使用ESP8266WiFiAP库来演示softAPConfig()函数可用于配置网络信息.在wifi初始化\n时可配置接入点IP地址，网关IP地址，子网掩码和默认的IP地址.\n****************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下接入点名字\n#define password  \"12345678\"          //这里改成你的设备当前环境下接入点密码\n \nIPAddress local_IP(192,168,4,22);//手动设置的开启的网络的ip地址\nIPAddress gateway(192,168,4,9);  //手动设置的网关IP地址\nIPAddress subnet(255,255,255,0); //手动设置的子网掩码\n \nbool flag;\n \nvoid setup() {\n  // 启动串口通讯\n  Serial.begin(9600); \n  Serial.println();\n  \n  //设置为接入点模式\n  WiFi.mode(WIFI_AP);\n  \n  //配置接入点的IP，网关IP，子网掩码\n  WiFi.softAPConfig(local_IP, gateway, subnet);\n  \n  //启动AP，并设置账号和密码\n  Serial.printf(\"设置接入点中 ... \");\n  \n  //启动校验式网络（需要输入账号密码的网络）,通道为3，wifi隐藏，最大连接数=4\n  WiFi.softAP(AP_ssid, password,3,1);\n  \n  //监控状态变量result \n  flag = WiFi.softAP(AP_ssid, password); \n  if(flag){ \n  Serial.println(\"\");              // 通过串口监视器输出信息\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"接入点名字:\");    \n  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名\n  Serial.print(\"接入点密码:\");        \n  Serial.println(password);        // 告知用户建立的接入点WiFi密码   \n  Serial.println(\"网络IP\");\n  Serial.println(\"local_IP\");     //打印ip地址\n  Serial.println(\"网关IP\");\n  Serial.println(gateway);        //打印网关IP\n  Serial.println(\"子网掩码：\");\n  Serial.println(subnet);         //打印子网掩码\n  }else{\n    //若没有开启成功\n    Serial.println(\"开启失败\");\n  }\n  \n  Serial.println(\"初始化结束\");\n}\n \nvoid loop() {}\n```\n\n\n\n#### softAPDisconnect\n\n##### 说明\n\nsoftAPdisconnect函数可用于关闭ESP8266开发板的接入点模式，即关闭ESP8266所建立的WiFi网络。\n\n##### 语法\n\n- WiFi.softAPdisconnect()\n- WiFi.softAPdisconnect(val)\n\n##### 参数\n\n参数val类型为bool。如果将该参数设置为true，设备将直接关闭接入点模式。\n\n在不输入参数的情况下调用该函数，设备会将当前配置的网络名和密码设置为空值。\n\n##### 返回值\n\n返回设置是否成功的结果。设置成功返回true。数据类型为bool型。\n\n##### 示例程序\n\n```c\n/***************************************************\n  程序名称/Program name     : softAPdisconnect()函数演示\n  程序目的/Purpose          : \n  此程序使用ESP8266WiFiAP库来演示softAPdisconnect()可用，可关闭AP模式***************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下接入点名字\n#define password  \"12345678\"         //这里改成你的设备当前环境下接入点密码\n \nbool flag;\nbool wifioff = true;      // 接入点模式设置变量\n \nvoid setup() {\n  // 启动串口通讯\n  Serial.begin(9600);\n  Serial.println();\n  \n  //设置为接入点模式\n  WiFi.mode(WIFI_AP);\n  \n  //启动AP，并设置账号和密码\n  Serial.printf(\"设置接入点中 ... \");\n  \n  //启动校验式网络（需要输入账号密码的网络）,通道为3，wifi隐藏，最大连接数=4\n  WiFi.softAP(AP_ssid, password, 3, 1);\n  \n  //监控状态变量result\n  flag = WiFi.softAP(AP_ssid, password);\n  \n  if (flag) {\n    Serial.println(\"\");              // 通过串口监视器输出信息\n    Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n    Serial.println(WiFi.getMode());\n    Serial.print(\"接入点名字:\");\n    Serial.println(AP_ssid);         // 告知用户建立的接入点WiFi名\n    Serial.print(\"接入点密码:\");\n    Serial.println(password);        // 告知用户建立的接入点WiFi密码\n    Serial.println(\"接入点模式成功开启\");\n    Serial.println(\"15秒后关闭接入点\");\n    delay(5000);\n    delay(5000);\n    delay(5000); //延时15s检查接入点开启效果\n    Serial.println(\"即将关闭接入点\");\n    delay(1000);\n    WiFi.softAPdisconnect(wifioff);//关闭接入点\n    Serial.println(\"接入点已经关闭\");\n  } else {\n    //若没有开启成功\n    Serial.println(\"开启失败\");\n  }\n  \n  Serial.println(\"初始化结束\");\n}\n \nvoid loop() {}\n```\n\n\n\n### 信息类型\n\n#### softAPIP\n\n##### 说明\n\nESP8266开发板建立WiFi接入点后， 我们可以使用本函数获取ESP8266开发板的IP地址。\n\n##### 语法\n\n`wiFiAP.softAPIP()`\n\n`Serial.println(wiFiAP.softAPIP());`\n\n##### 参数\n\n无\n\n##### 返回值\n\n此函数的返回值是ESP8266开发板的IP地址。（类型：IPAddress）\n\n##### 示例程序\n\n当您将以下示例程序上传给ESP8266开发板后，ESP8266将会建立一个隐藏的WiFi网络。网络名称(SSID)为”TaichiMaker_WIFI”,网络密码为”12345678″ 。在开发板成功建立WiFi网络后，您也可以通过串口监视器看到ESP8266开发板的IP地址。该信息是由以下程序中的WiFi.softAPIP()所获取的。\n\n```c\n/**********************************************************************\n程序名称/Program name     : softAPIP获取接入点的IP地址\n程序目的/Purpose          : \n演示softAPIP()函数的用法，获取接入点的ip地址\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下接入点名字\n#define password  \"12345678\"         //这里改成你的设备当前环境下接入点密码\n \nbool flag;    \n \nvoid setup() {\n  // 启动串口通讯\n  Serial.begin(9600);\n  Serial.println();\n  \n  //设置为接入点模式\n  WiFi.mode(WIFI_AP);\n  \n  //启动AP，并设置账号和密码\n  Serial.printf(\"设置接入点中 ... \");\n  \n  //启动校验式网络（需要输入账号密码的网络）,通道为3，wifi隐藏，最大连接数=4\n  WiFi.softAP(AP_ssid, password, 3, 1);\n  \n  //监控状态变量result\n  flag = WiFi.softAP(AP_ssid, password);\n  if (flag) {\n    Serial.println(\"\");              // 通过串口监视器输出信息\n    Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n    Serial.println(WiFi.getMode());\n    \n    Serial.print(\"接入点名字:\");\n    Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名\n    \n    Serial.print(\"接入点密码:\");\n    Serial.println(password);        // 告知用户建立的接入点WiFi密码\n    Serial.print(\"接入点模式成功开启\");\n \n    Serial.print(\"当前接入点的IP地址为： \");\n    Serial.println(WiFi.softAPIP());     //串口打印当前AP点的IP地址\n  } else {\n    //若没有开启成功\n    Serial.println(\"开启失败\");\n  }\n  \n  Serial.println(\"初始化结束\");\n}\n \nvoid loop() {}\n```\n\n\n\n#### softAPmacAddress\n\n##### 说明\n\nESP8266开发板建立WiFi接入点后， 我们可以使用本函数获取ESP8266开发板的mac地址。\n\n##### 语法\n\n`WiFi.softAPmacAddress`()\n`WiFi.softAPmacAddress`(macAddr)\n\n##### 参数 / 返回值\n\na.如以下语句所示，如果不输入参数，函数的返回值为ESP8266开发板的mac地址（String类型）。\n\n```c\nSerial.printf(\"MAC地址为 %s\\n\", WiFi.softAPmacAddress().c_str());\n```\n\nb.如果输入参数macAddr。那么ESP8266开发板的mac地址将会存储在macAddr中。macAddr必须是一个uint8_t类型的数组，且该数组含有6个元素。如下简例所示：\n\n```c\nuint8_t macAddr[6];\nWiFi.softAPmacAddress(macAddr);\nSerial.printf(\"MAC地址为  %02x:%02x:%02x:%02x:%02x:%02x\\n\", macAddr[0], macAddr[1], macAddr[2], macAddr[3], macAddr[4], macAddr[5]);\n```\n\n\n\n\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将以下示例程序上传给ESP8266开发板后，ESP8266将会建立一个WiFi网络。网络名称(SSID)为”TaichiMaker_WIFI”,网络密码为”12345678″ 。在开发板成功建立WiFi网络后，您将通过串口监视器看到ESP8266模块的mac地址。在以下示例程序中，我们使用了两种macAddress函数调用方式来获取设备的IP地址。第一种是有参数的第二种是无参数的。这两种方式所获得的mac地址格式不同。有参数调用时，mac地址保存在数组macAddr中。无参数调用时，mac地址将以字符串形式返回。\n\n```c\n/**********************************************************************\n程序名称/Program name     : softAPIP获取接入点MAC地址\n程序目的/Purpose          : \n演示softAPIP()函数的用法，获取接入点的MAC地址\n***********************************************************************/\n#include <ESP8266WiFi.h>\n\n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下接入点名字\n#define password  \"12345678\"         //这里改成你的设备当前环境下接入点密码\n\nbool flag;\nuint8_t macAddr[6]; // 存储设备mac地址的数组\n\nvoid setup() {\n  // 启动串口通讯\n  Serial.begin(9600);\n  Serial.println();\n  \n  //设置为接入点模式\n  WiFi.mode(WIFI_AP);\n  \n  //启动AP，并设置账号和密码\n  Serial.printf(\"设置接入点中 ... \");\n  \n  //启动校验式网络（需要输入账号密码的网络）\n  WiFi.softAP(AP_ssid, password);\n  \n  //监控状态变量result\n  flag = WiFi.softAP(AP_ssid, password);\n  \n  if (flag) {\n    Serial.println(\"\");              // 通过串口监视器输出信息\n    Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n    Serial.println(WiFi.getMode());\n    Serial.print(\"接入点名字:\");\n    Serial.println(AP_ssid);         // 告知用户建立的接入点WiFi名\n    Serial.print(\"接入点密码:\");\n    Serial.println(password);        // 告知用户建立的接入点WiFi密码\n    Serial.println(\"接入点模式成功开启\");\n\n    //不输入参数获取MAC地址\n    Serial.printf(\"MAC地址为 %s\\n\", WiFi.softAPmacAddress().c_str());\n\n    //输入参数获取MAC地址\n    WiFi.softAPmacAddress(macAddr);                                  \n    Serial.printf(\"MAC地址为  %02x:%02x:%02x:%02x:%02x:%02x\\n\", macAddr[0], macAddr[1], macAddr[2], macAddr[3], macAddr[4], macAddr[5]);\n\n  } else {\n    //若没有开启成功\n    Serial.println(\"开启失败\");\n  }\n  Serial.println(\"初始化结束\");\n}\n\nvoid loop() {}\n```\n\n\n\n#### softAPSSID\n\n##### 说明\n\nESP8266开发板建立WiFi接入点后， 我们可以使用本函数获取WiFi名称。\n\n##### 语法\n\n`WiFi.softAPSSID()`\n\n##### 参数\n\n无\n\n##### 返回值\n\n返回接入点WiFi名称，数据类型为字符串型。\n\n##### 示例程序\n\n当您将以下示例程序上传给ESP8266开发板后，ESP8266将会建立一个WiFi网络。网络名称(SSID)为”TaichiMaker_WIFI”,网络密码为”12345678″ 。在开发板成功建立WiFi网络后，您也可以通过串口监视器看到ESP8266建立的WiFi名称。该信息是由以下程序中的WiFi.softAPSSID()所获取的。\n\n```c\n/**********************************************************************\n程序名称/Program name     : softAPSSID获取接入点SSID\n程序目的/Purpose          : \n演示softAPSSID()函数的用法，获取接入点的wifi名称\n-----------------------------------------------------------------------\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下接入点名字\n#define password  \"12345678\"          //这里改成你的设备当前环境下接入点密码\n \nbool flag;\n \n \nvoid setup() {\n  // 启动串口通讯\n  Serial.begin(9600);\n  Serial.println();\n  \n  //设置为接入点模式\n  WiFi.mode(WIFI_AP);\n \n  //启动AP，并设置账号和密码\n  Serial.printf(\"设置接入点中 ... \");\n  \n  //启动校验式网络（需要输入账号密码的网络）\n  WiFi.softAP(AP_ssid, password);\n  \n  //监控状态变量result\n  flag = WiFi.softAP(AP_ssid, password);\n  \n  if (flag) {\n    Serial.println(\"\");              // 通过串口监视器输出信息\n    Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n    Serial.println(WiFi.getMode());\n    \n    Serial.print(\"接入点名字:\");\n    Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名\n    \n    Serial.print(\"接入点密码:\");\n    Serial.println(password);        // 告知用户建立的接入点WiFi密码\n    \n    Serial.print(\"接入点模式成功开启\");\n \n    Serial.print(\"softAPSSID()获取接入点SSID为：\");\n    Serial.println(WiFi.softAPSSID()); //输出接入点的wifi名称\n  } else {\n    //若没有开启成功\n    Serial.println(\"开启失败\");\n  }\n  Serial.println(\"初始化结束\");\n}\n \nvoid loop() {}\n```\n\n\n\n\n\n\n\n#### softAPPSK\n\n##### 说明\n\nESP8266开发板建立WiFi接入点后， 我们可以使用本函数获取WiFi密码。\n\n##### 语法\n\n`wiFi.softAPPSK()`\n\n##### 参数\n\n无\n\n##### 返回值\n\n返回接入点WiFi密码，数据类型为字符串型\n\n##### 示例程序\n\n当您将以下示例程序上传给ESP8266开发板后，ESP8266将会建立一个WiFi网络。网络名称(SSID)为”TaichiMaker_WIFI”,网络密码为”12345678″ 。在开发板成功建立WiFi网络后，您也可以通过串口监视器看到ESP8266建立的WiFi名称。该信息是由以下程序中的WiFi.softAPPSK()所获取的。\n\n```c\n/**********************************************************************\n程序名称/Program name     : softAPPSK获取AP的psk\n程序目的/Purpose          : \n演示softAPSSID()函数的用法，获取接入点密码\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下接入点名字\n#define password  \"12345678\"          //这里改成你的设备当前环境下接入点密码\n \nbool flag;\n \n \nvoid setup() {\n  // 启动串口通讯\n  Serial.begin(9600);\n  Serial.println();\n  \n  //设置为接入点模式\n  WiFi.mode(WIFI_AP);\n \n  //启动AP，并设置账号和密码\n  Serial.printf(\"设置接入点中 ... \");\n  \n  //启动校验式网络（需要输入账号密码的网络）\n  WiFi.softAP(AP_ssid, password);\n  \n  //监控状态变量result\n  flag = WiFi.softAP(AP_ssid, password);\n  \n  if (flag) {\n    Serial.println(\"\");              // 通过串口监视器输出信息\n    Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n    Serial.println(WiFi.getMode());\n    \n    Serial.print(\"接入点名字:\");\n    Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名\n    \n    Serial.print(\"接入点密码:\");\n    Serial.println(password);        // 告知用户建立的接入点WiFi密码\n    \n    Serial.print(\"接入点模式成功开启\");\n \n    Serial.print(\"softAPPSK()获取接入点密码为：\");\n    Serial.println(WiFi.softAPPSK()); //输出接入点密码\n  } else {\n    //若没有开启成功\n    Serial.println(\"开启失败\");\n  }\n  Serial.println(\"初始化结束\");\n}\n \nvoid loop() {}\n```\n\n\n\n\n\n#### softAPGetStationNum\n\n##### 说明\n\nsoftAPgetStationNum函数可用于获取通过WiFi连接到ESP8266开发板接入点的无线终端数量。\n\n##### 语法\n\n`wiFi.softAPgetStationNum()`\n\n##### 参数\n\n无\n\n##### 返回值\n\n连接到ESP8266开发板接入点的无线终端数量，数据类型为int型。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将以下示例程序上传给ESP8266开发板后，ESP8266将会建立一个WiFi网络。网络名称(SSID)为”TaichiMaker_WIFI”,网络密码为”12345678″ 。在开发板成功建立WiFi网络后，您也可以通过串口监视器看到连接到该WiFi网络的终端数量。该信息是由以下程序中的WiFi.softAPgetStationNum()所获取的。\n\n```c\n/**********************************************************************\n程序名称/Program name     : 获取连接到接入点的无线终端数量\n程序目的/Purpose          : \n演示softAPSSID()函数的用法，获取连接到接入点的无线终端数量\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下接入点名字\n#define password  \"12345678\"          //这里改成你的设备当前环境下接入点密码\n \nbool flag;\nvoid setup() {\n  // 启动串口通讯\n  Serial.begin(9600);\n  Serial.println();\n  //设置为接入点模式\n  WiFi.mode(WIFI_AP);\n  \n  //启动AP，并设置账号和密码\n  Serial.printf(\"设置接入点中 ... \");\n  \n  //启动校验式网络（需要输入账号密码的网络）\n  WiFi.softAP(AP_ssid, password);\n  \n  //监控状态变量result\n  flag = WiFi.softAP(AP_ssid, password);\n  if (flag) {\n    Serial.println(\"\");              // 通过串口监视器输出信息\n    Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n    Serial.println(WiFi.getMode());\n    \n    Serial.print(\"接入点名字:\");\n    Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名\n    \n    Serial.print(\"接入点密码:\");  \n    Serial.println(password);        // 告知用户建立的接入点WiFi密码\n    Serial.print(\"接入点模式成功开启\");\n  } else {\n    //若没有开启成功\n    Serial.println(\"开启失败\");\n  }\n  Serial.println(\"初始化结束\");\n}\n \nvoid loop() {\n  //打印出当前连接到此接入点上的无线终端数目\n  Serial.printf(\"连接此接入点上的无线终端数目 = %d\\n\", WiFi.softAPgetStationNum());\n  delay(1000);\n}\n```\n\n\n\n## ESP8266WiFiSTA库\n\nESP8266WiFiSTA库用于ESP8266开发板的无线终端模式（Wireless Station）控制。\n\nESP8266模块的工作模式一共有三种。分别是：1，接入点端模式（AP）2，无线终端模式（Wireless Station）3，混合模式。\n\n在无线终端模式下，ESP8266开发板可通过WiFi连接无线路由器。这与用您的手机通过WiFi连接无线路由器的模式相同。\n\n![image-20230525151500136](./Image/ESP8266.assets/image-20230525151500136.png)\n\n\n\n以下为ESP8266WiFiSTA库的整体结构图。在此图下方有ESP8266WiFiSTA库的函数目录。\n\n![image-20230525151529405](./Image/ESP8266.assets/image-20230525151529405.png)\n\n### 管理类型\n\n#### begin – 连接WiFi\n\n##### 说明\n\n此函数用于启动ESP8266开发板的无线终端工作模式。\n\n在无线终端工作模式下，ESP8266可以通过局域网或者互联网收取物联网信息或者向其它物联网设备发送控制信号。\n\n注：如果ESP8266模块之前被设置为接入点模式(AP)，我们在直接切换为无线终端模式的时候，使用ESP8266WiFiSTA库 – begin函数有可能会切换为接入点+无线终端混合的模式，而不能成功切换为我们想要的无线终端模式。如果调用后不清楚当前的模式状况，或者网络出现异常，我们最好检测一下ESP8266模块当前处于什么模式。(具体请参阅ESP8266WiFiGeneric库中的[mode](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifigeneric/8286-2/)函数)\n\n##### 语法\n\n`WiFi.begin()`\na. 在不使用任何参数的情况下调用此函数，ESP8266模块将启用无线终端模式，并根据以前保存在闪存中的wifi配置连接到最近一次使用的接入点。\n\n`WiFi.begin(ssid, password, channel, bssid, connect)`\nb.我们也可以再调用begin函数的时候，为函数提供参数。这些参数的具体功能请见下面的“参数”部分介绍。\n\n\n\n##### 参数\n\n- ssid – 要连接的wifi接入点的名字，最多可以包含32个字符。(类型：char*)\n- password – 要连接的 wifi接入点密码，长度至少应为8个字符且不超过64个字符。(类型：char*)\n- channel – 要连接的wifi接入点信道。(类型：int32_t)\n- bssid – 要连接的wifi接入点的mac地址。(类型：const uint8_t*)\n- connect – 连接状态参数。如果connect参数为true，ESP8266开发板会使用闪存中储存的信息尝试连接WiFi。如果connect参数为false，ESP8266开发板不会尝试连接WiFi，而只会将WiFi连接信息保存在闪存中。(类型：bool)\n\n\n\n##### 返回值\n\n返回值数据类型为布尔型。如果ESP8266开发板成功启动无线终端模式，则返回true，否则返回false。\n\n\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的工作模式，即无线终端模式。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.begin()演示\n  程序目的/Purpose          :\n \n  此程序使用ESP8266WiFiSTA库来演示建立连接，ESP8266模块切换工作模式为无线终端模式。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxxx\"         //这里改成你的设备当前环境下要连接的接入点密码\n \nint i = 0;    //用来判定连接是否超时的累加量\n \nvoid setup() {\n  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600\n  Serial.println(\"开始连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  \n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户建立的接入点WiFi密码\n  Serial.print(\"无线终端模式成功开启，网络连接成功\");\n  Serial.println(\"初始化完成\");\n}\n \nvoid loop() {\n}\n```\n\n\n\n\n\n#### config – 配置网络（如,IP地址，网关IP等）\n\n##### 说明\n\nconfig函数可以用来设置ESP8266模块在无线终端模式下的IP配置，并将站接口的IP地址设置为用户定义的值。\n\n##### 语法\n\n`wiFi.config()`\n`wiFi.config(local_ip, gateway, subnet, dns1, dns2)`\n\n用法简例\n\n```c\nIPAddress staticIP(192,168,1,22);//ESP8266的IP地址\nIPAddress gateway(192,168,1,9); //网关IP地址\nIPAddress subnet(255,255,255,0);//子网掩码\n\nWiFi.config(staticIP, gateway, subnet);//进行设置\n```\n\n\n\n##### 参数\n\n- local_ip: 配置ESP8266的固定IP地址。(IPAdress型)\n- gateway: 网关IP地址。(IPAdress型)\n- subnet: 子网掩码。(IPAddress型)\n- dns1，dns2: 这两个参数是可选参数。它们可定义域名服务器（DNS）的ip地址，这些域名服务器会关联一个域名目录，并将它们翻译成ip地址 (IPAddress型)\n\n\n\n##### 返回值\n\n返回值会返回调用函数后是否有设置成功的结果。如果设置成功则返回true。数据类型为布尔型。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的网络配置信息。\n\n以下程序中，我们首先使用了以下语句建立用于配置ESP8266模块的IP地址信息。\n\n```c\nIPAddress staticIP(192, 168, 1, 22);\nIPAddress gateway(192, 168, 1, 9);\nIPAddress subnet(255, 255, 255, 0);\n```\n\n接下来，我们使用以下语句对开发板进行网络配置。\n\n```c\nWiFi.config(staticIP, gateway, subnet)\n```\n\n**在使用以下示例程序时请注意：**\n\n1. 设置了静态IP地址的无线终端在连接WiFi时速度会更快。下面附带的例子用了500ms左右就可以连接上。原因是跳过了获得动态IP配置这一步。在设置固定IP时，要注意不要出现设置的ESP8266开发板IP地址与其它网络设备的IP发生冲突。\n\n2. 由于不同路由所提供的WiFi网络配置是不同的,使用本例程时请根据网络环境设置自己的网关IP、设备IP和子网掩码，否则可能会造成例程无法正常运行\n\n\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.config()演示\n  程序目的/Purpose          :\n \n  此程序使用ESP8266WiFiSTA库来演示建立连接，ESP8266模块设置无线终端模式下的IP配置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxx\"          //这里改成你的设备当前环境下要连接的接入点密码\n \nint i = 0;//用来判定连接是否超时的累加量\n\n\nIPAddress staticIP(192, 168, 1, 22);//请按照自己的网络环境设置这三个参数\nIPAddress gateway(192, 168, 1, 9);\nIPAddress subnet(255, 255, 255, 0);\n \nvoid setup(void)\n{\n  Serial.begin(9600); // 启动串口通讯，波特率设置为9600\n  Serial.printf(\"正在配置网络\");\n  \n  //无线终端模式下配置IP，并将接口的IP配置设置为用户定义的值\n  //如果不设置 则表示使用DHCP下发的信息\n  WiFi.config(staticIP, gateway, subnet);\n  Serial.println(\"开始连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }  \n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户连接到的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户连接到的接入点WiFi密码\n  Serial.print(\"无线终端模式成功开启\");\n  Serial.print(\"当前无线终端静态IP地址： \");// 告知用户当前无线终端的IP地址(也就是我们设置的地址)\n  Serial.println(WiFi.localIP());\n  Serial.print(\"当前无线终端网关的IP地址： \");// 告知用户当前无线终端网关的IP地址\n  Serial.println(WiFi.gatewayIP());\n  Serial.print(\"当前无线终端： \");// 告知用户当前无线终端的子网掩码地址\n  Serial.println(WiFi.subnetMask());\n  Serial.println(\"初始化完成\");\n}\n \nvoid loop() {}\n```\n\n\n\n#### reconnect – 重新连接WiFi\n\n##### 说明\n\n调用reconnect函数可以让ESP8266模块断开再重新连接WiFi。\n\n##### 语法\n\n`wifi.reconnect()`\n注意：\n1.如果ESP8266模块没有接入任何WiFi或者不处于无线终端模式，则函数将返回false，且不执行任何操作\n2.如果函数返回true，则表示ESP8266已成功开始执行重新连接WiFi这一操作。但这里的返回值true并不代表ESP已经成功连接到了WiFi。\n\n##### 参数\n\n无\n\n##### 返回值\n\n数据类型为布尔型。\n返回false，则说明ESP8266不处于无线终端模式，或者说在此之前没有连结果任何接入点。返回true，说明已经成功重新启动WiFi连接。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，设备会保持连接状态等待10秒钟，然后设备将会使用以下程序中的`WiFi.reconnect();`语句来实现网络重新连接这一操作。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.reconnect()演示\n  程序目的/Purpose          :\n  此程序使用ESP8266WiFiSTA库来演示reconnect()重新连接网络\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxxx\"         //这里改成你的设备当前环境下要连接的接入点密码\n \nint i = 0;//用来判定连接是否超时的累加量\n \nvoid setup(void)\n{\n  Serial.begin(9600);\n  // 启动串口通讯，波特率设置为9600\n  Serial.begin(9600);\n  Serial.println(\"开始连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户连接到的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户连接到的接入点WiFi密码\n  Serial.println(\"无线终端模式成功开启，网络连接成功\");\n  delay(1000);\n  Serial.println(\"10秒后断开重连\");\n  delay(5000);\n  delay(5000);\n  Serial.println(\"即将重新连接\");\n  delay(1000);\n  \n  Serial.println(\"开始重新连接\");\n  WiFi.reconnect();//重新连接\n  \n  i = 0;//重新赋值i以便再次计数\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是重新连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  \n  Serial.println(\"重新连接成功！\");\n}\n \nvoid loop() {}\n```\n\n\n\n\n\n#### disconnect – 断开WiFi连接\n\n##### 说明\n\ndisconnect函数将当前配置给ESP8266模块的SSID和密码设置为空值，使ESP8266与断开WiFi连接。\n\n##### 语法\n\n`wiFi.disconnect()`\n\n`wiFi.disconnect(wifioff)`\n\n如果参数wifioff设置为false或者不填参数，SSID和密码将会被设置为空值，同时这一操作还会使ESP8266模块与接入点断开连接。需要注意的是，用这种方法仅仅会断开WiFi连接，ESP8266模块仍然会处于无线终端模式。\n\n`WiFi.disconnect();//断开连接，但仍然处于无线终端模式，只是清除了SSID和密码`\n\n当我们设置入参wifioff 为true，那么这样的操作会直接关闭无线终端模式。\n\n```c\nbool wifioff = true//设置关闭变量\nWiFi.disconnect(wifioff);//断开连接\n```\n\n\n\n\n\n##### 参数\n\nwifioff (可选参数)：此参数为bool型。设置为true，那么就会关闭无线终端模式。设置为false，则SSID和密码将会被设置为空值，同时还会使ESP8266模块与接入点断开连接。\n\n##### 返回值\n\n返回是否成功设置。成功设置则返回true，否则返回false。返回值数据类型为布尔型。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，设备会保持连接状态等待10秒钟，然后设备将会使用以下程序中的 `WiFi.disconnect(wifioff)` 语句来实现断开网络这一操作。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.disconnect(wifioff)演示\n  程序目的/Purpose          :\n  此程序使用ESP8266WiFiSTA库来演示建立连接，ESP8266模块关闭无线终端模式\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxxx\"         //这里改成你的设备当前环境下要连接的接入点密码\n \nint i = 0;//用来判定连接是否超时的累加量\n \nbool wifioff = true;//演示关闭连接所需的参数\n \nvoid setup(void)\n{\n  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600\n  Serial.println(\"开始连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户连接到的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户连接到的接入点WiFi密码\n  Serial.print(\"无线终端模式成功开启，网络连接成功\");\n  \n  Serial.println(\"10秒后断开连接\");\n  delay(5000);\n  delay(5000);\n  \n  Serial.println(\"即将断开连接\");\n  delay(500);\n  WiFi.disconnect(wifioff);//断开连接\n  \n  if (WiFi.status() != WL_CONNECTED) {\n    Serial.println(\"无线终端和接入点的连接已中断\");\n  }\n  else\n  {\n    Serial.println(\"未能成功断开连接！\");\n  }\n}\n \nvoid loop() {}\n```\n\n\n\n#### setAutoConnect – 设置是否自动连接WiFi\n\n##### 说明\n\nsetAutoConnect函数可以激活ESP8266模块的自动连接模式。模式激活后，ESP8266模块会在通电后自动连接到最近连接过的WiFi接入点。\n\n另外，我们也可以使用[getAutoConnect](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifista/getautoconnect/)函数来获取ESP8266开发板是否激活自动连接模式。\n\n##### 语法\n\n`wiFi.setAutoConnect()`\n\n`wiFi.setAutoConnect(autoConnect)`\n\n简例：\n\n```c\nbool autoConnect = ture;\n...\nWiFi.setAutoConnect(autoConnect); //启用自动连接模式\n```\n\n\n\n##### 参数\n\nautoConnect是一个可选的参数。如果设置为false，则将禁用自动连接功能。如果省略或设置为true，则将启用自动连接模式。（参数类型：布尔型）\n\n##### 返回值\n\n返回值的状态可以表明是否设置成功。设置自动连接成功则返回true，否则返回false。数据类型为布尔型。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，设备会保持连接状态等待10秒钟，然后设备将会使用以下程序中的 `WiFi.setAutoConnect(autoConnect)` 语句来实激活自动连接模式。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.setAutoConnect()演示\n  程序目的/Purpose          :\n  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下设置上电后自动连接\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxxx\"         //这里改成你的设备当前环境下要连接的接入点密码\n \nbool autoConnect = true;\n \nint i = 0;//用来判定连接是否超时的累加量\n \nvoid setup(void)\n{\n  // 启动串口通讯，波特率设置为9600\n  Serial.begin(9600);\n  Serial.printf(\"正在配置网络\");\n  \n  //设置自动连接\n  WiFi.setAutoConnect(autoConnect);//启用自动连接。\n  Serial.println(\"已设置自动连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  Serial.println(\"开始连接\");\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.println(\"\");              // 通过串口监视器输出信息\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户连接到的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户连接到的接入点WiFi密码\n  Serial.println(\"无线终端模式成功开启，网络连接成功\");\n}\n \nvoid loop(){}\n```\n\n\n\n#### setAutoReconnect – 设置是否自动重新连接WiFi\n\n##### 说明\n\nsetAutoReconnect函数可以用来设置是否要自动重新连接到最近连接过的接入点。设置后，一旦ESP8266模块出现断开网络连接的状况，ESP8266模块会反复尝试自动重连。\n\n##### 语法\n\n`wiFi.setAutoReconnect()`\n\n`wiFi.setAutoReconnect(autoReconnect)`\n\n\n\n##### 参数\n\n输入参数只要一个autoReconnect，如果参数autoReconnect设置为true，则模块将尝试重新建立与无线终端的丢失连接。如果设置为false则模块将保持断开连接状态。（参数类型：bool）\n\n##### 返回值\n\n返回值会返回设置是否成功。如果设置成功则返回true，数据类型为布尔型。\n\n注意：\n断开网络连接后再调用该函数进行设置是无效的，一定要在断开连接之前就设置好，最好就放在网络初始化的时候进行设置。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，设备会保持连接状态等待10秒钟，然后设备将会使用以下程序中的WiFi.setAutoReconnect(autoReconnect); 语句来设置ESP8266模块为自动重新连接网络模式。你可以在模块连接网络成功后，重启WiFi接入点，这时候您将会看到ESP8266模块在WiFi接入点重启后，重新尝试连接该WiFi接入点。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.setAutoReConnect()演示\n  程序目的/Purpose          :\n  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下设置自动重新连接\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxxx\"         //这里改成你的设备当前环境下要连接的接入点密码\n \nbool autoReconnect = true;\n \nint i = 0;//用来判定连接是否超时的累加量\n \nvoid setup(void)\n{\n  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600\n  Serial.printf(\"正在配置网络\");\n  \n  //设置自动连接\n  WiFi.setAutoReconnect(autoReconnect);//设置断开连接后重连\n  Serial.println(\"已设置自动重新连接\");\n  Serial.println(\"开始连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户连接到的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户连接到的接入点WiFi密码\n  Serial.print(\"无线终端模式成功开启，网络连接成功\");\n  Serial.println(\"此时可关闭接入点使网络连接断开，接入点再次打开后ESP8266模块可自动重连\");\n}\n \nvoid loop() {\n  if(WiFi.status() == WL_CONNECTED)\n  {\n    Serial.println(\"网络连接正常\");\n  }\n  else\n  {\n    Serial.println(\"网络连接断开，模块已设置自动重连，正在等待连接\");\n  }\n  delay(1000);\n}\n```\n\n\n\n\n\n\n\n#### waitForConnectResult – 等待WiFi连接\n\n##### 说明\n\nwaitForConnectResult用于在无线终端模式或无线终端+接入点混合模式下的ESP8266模块检测当前连接状态。\n\n##### 语法\n\n`wiFi.waitForConnectResult()`\n\n`wiFi.waitForConnectResult(timeoutLength)`\n\n简例：\n\n```c\nunsigned long timeoutLength = 5000;//设置5000毫秒后无响应就视为网络连接超时\n...\nWiFi.waitForConnectResult(timeoutLength);\t\t\n```\n\n##### 参数\n\nESP8266在尝试连接WiFi时，我们可以通过timeoutLength（毫秒）来设置等待连接的时间。如果ESP8266在timeoutLength设置的时间内仍未成功连接WiFi，则本函数会返回“超时错误”错误码：-1。\n\n关于ESP8266的错误码详情见下面的返回值部分（参数数据类型：unsigned long型）\n\n##### 返回值\n\n返回值类型为uint8_t。以下是返回值数值以及对应的信息：\n\n- 255： WL_NO_SHIELD – 返回值为255说明无扩展板。8266本来带有网络功能，不需要额外的扩展板（sheld），因此一般不会出现这个报错\n- 0：​ WL_IDLE_STATUS – 返回值为0说明正在尝试连接\n- 1​： WL_NO_SSID_AVAIL – 返回值为1说明没有找到设定的SSID的网络\n- 2​： WL_SCAN_COMPLETED – 返回值为2说明网络扫描完毕\n- 3：​ WL_CONNECTED – 返回值为3说明连接成功成功\n- 4： WL_CONNECT_FAILED – 返回值为4说明连接失败\n- 5： WL_CONNECTION_LOST – 返回值为5说明连接丢失\n- 6： WL_DISCONNECTED – 返回值为6说明未连接\n- -1： WiFi连接超时\n\n\n\n##### 示例程序\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.waitForConnectResult()演示\n  日期/Date（YYYYMMDD）     : 20200405\n  此程序使用ESP8266WiFiSTA库来演示在Station模式下返回当前网络连接状态。本实例仅展示成功连接状况的返回值\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxxx\"         //这里改成你的设备当前环境下要连接的接入点密码\n \nint i = 0;//用来判定连接是否超时的累加量\n \nvoid setup(void)\n{\n  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600\n  Serial.println(\"开始连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户连接到的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户连接到的接入点WiFi密码\n  Serial.print(\"无线终端模式成功开启，网络连接成功\");\n}\n \nvoid loop() {\n  //设置5000毫秒后无响应就视为网络连接超时  \n  unsigned long timeoutLength = 5000; \n  \n  //打印当前网络连接状态码\n  Serial.println(WiFi.waitForConnectResult(timeoutLength));\n  \n  delay(1000);\n}\n```\n\n\n\n### 信息类型\n\n#### status – 获取WiFi连接状态\n\n##### 说明\n\nstatus函数可以在无线终端模式下，获取当前的ESP8266模块网络连接状态。\n\n##### 语法\n\n`wifi.status()`\n\n简例：\n\n```c\nSerial.printf(\"当前连接状态: \");\nSerial.printf(WiFi.status());//打印当前连接状态\n```\n\n\n\n##### 参数\n\n无\n\n##### 返回值\n\n返回值类型为uint8_t。以下是返回值数值以及对应的信息：\n\n- 255： WL_NO_SHIELD – 返回值为255说明无扩展板。8266本来带有网络功能，不需要额外的扩展板（sheld），因此一般不会出现这个报错\n- 0：​ WL_IDLE_STATUS – 返回值为0说明正在尝试连接\n- 1​： WL_NO_SSID_AVAIL – 返回值为1说明没有找到设定的SSID的网络\n- 2​： WL_SCAN_COMPLETED – 返回值为2说明网络扫描完毕\n- 3：​ WL_CONNECTED – 返回值为3说明连接成功成功\n- 4： WL_CONNECT_FAILED – 返回值为4说明连接失败\n- 5： WL_CONNECTION_LOST – 返回值为5说明连接丢失\n- 6： WL_DISCONNECTED – 返回值为6说明未连接\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块的联网状态代码。在以下示例程序中，我们使用了`WiFi.status()`语句来获取联网状态。\n\n```c\n/**********************************************************************\n  项目名称/Project          : 零基础入门学用物联网\n  程序名称/Program name     : WiFi.status()演示\n  团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)\n  作者/Author              : 小黑\n  日期/Date（YYYYMMDD）     : 20200405\n  此程序使用ESP8266WiFiSTA库来演示在无线终端模式获取当前的网络连接状态\n  -----------------------------------------------------------------------\n  本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。\n  该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：\n  http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxxx\"         //这里改成你的设备当前环境下要连接的接入点密码\n \nint i = 0;//用来判定连接是否超时的累加量\n \nvoid setup(void)\n{\n  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600\n  Serial.println(\"开始连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户建立的接入点WiFi密码\n  Serial.print(\"无线终端模式成功开启，网络连接成功\");\n  Serial.print(\"此时关闭接入点，可以看到连接状态报告函数 WiFi.status()返回值变化\");\n}\n \nvoid loop() {\n  Serial.printf(\"\\n当前连接状态: %d\\n\", WiFi.status());\n  delay(1000);\n}\n```\n\n\n\n#### SSID – 获取SSID\n\n##### 说明\n\n利用SSID函数可以获取当前ESP8266模块所连接的网络SSID。\n\n##### 语法\n\n`wifi.SSID()`\n\n简例：\n\n```c\nSerial.printf(\"SSID:\");\nSerial.printf(WiFi.SSID()); //打印出当前8266模块所连接的网络的SSID\n```\n\n\n\n##### 参数\n\n无\n\n##### 返回值\n\n返回SSID，数据类型为string型。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块所连接WiFi的SSID。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.SSID()演示\n  程序目的/Purpose          :\n  此程序使用ESP8266WiFiSTA库来演示在无线终端模式获取当前网络的SSID\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxxx\"         //这里改成你的设备当前环境下要连接的接入点密码\n \nint i = 0;//用来判定连接是否超时的累加量\n \nvoid setup(void)\n{\n  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600\n  Serial.println(\"开始连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户建立的接入点WiFi密码\n  Serial.print(\"无线终端模式成功开启，网络连接成功\");\n \n  Serial.printf(\"SSID: %s\\n\", WiFi.SSID().c_str());//打印出当前8266模块所连接的网络的SSID.此处用.c_str()来确保打印正常\n}\nvoid loop() {\n  delay(1000);\n}\n```\n\n\n\n#### psk – 获取psk\n\n##### 说明\n\n无线终端模式下，调用psk()函数就可以获取ESP8266模块连接到当前网络的密码。\n\n##### 语法\n\n`wifi.psk()`\n\n##### 参数\n\n无\n\n##### 返回值\n\n返回当前连接的接入点的密码，数据类型为 string型\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块所连接WiFi的网络密码。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.psk();演示 程序目的/Purpose          :\n  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下打印当前接入点密码\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxxxxxx\" //这里改成你的设备当前环境下要连接的接入点密码\n \nint i = 0;//用来判定连接是否超时的累加量\n \nvoid setup(void)\n{\n  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600\n  Serial.println(\"开始连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户建立的接入点WiFi密码\n  Serial.print(\"无线终端模式成功开启，网络连接成功\");\n \n  Serial.printf(\"psk: %s\\n\", WiFi.psk().c_str());//打印出当前8266模块所连接网络的psk.此处用.c_str()来确保打印正常\n}\nvoid loop() {}\n```\n\n\n\n#### BSSIDstr – 获取WiFi接入点的mac地址\n\n##### 说明\n\n当ESP8266开发板处于无线终端模式下，BSSIDstr函数可用于获取wif接入点设备的MAC地址。\n\n##### 语法\n\n```c\nwifi.BSSIDstr()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\nwif接入点设备的MAC地址，返回值数据类型为string。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块所连接WiFi的接入点设备mac地址。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.BSSID();\n  程序目的/Purpose          :\n  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下打印当前wifi网络macaddress\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxxx\"         //这里改成你的设备当前环境下要连接的接入点密码\n \nint i = 0;//用来判定连接是否超时的累加量\n \nvoid setup(void)\n{\n  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600\n  Serial.println(\"开始连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户建立的接入点WiFi密码\n  Serial.print(\"无线终端模式成功开启，网络连接成功\");\n  \n  Serial.printf(\"BSSID为: \");\n  Serial.printf(WiFi.BSSIDstr().c_str());//获取wifi接入点的MAC地址，并打印出来\n}\n \nvoid loop() {}\n```\n\n\n\n#### localIP – 获取IP地址\n\n##### 说明\n\nlocalIP函数可在无线终端模式下获取当前SEP8266模块的IP地址。\n\n##### 语法\n\n```\nwifi.localIP()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n返回值为当前无线终端分配的IP地址，数据类型为IPAdress型。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块的IP地址。在以下示例程序中，我们使用了WiFi.localIP()语句来获取IP地址。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.localIP();演示\n  程序目的/Purpose          :\n  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下打印当前无线终端IP地址\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxxx\"         //这里改成你的设备当前环境下要连接的接入点密码\n \nint i = 0;//用来判定连接是否超时的累加量\n \nvoid setup(void)\n{\n  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600\n  Serial.println(\"开始连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户建立的接入点WiFi密码\n  Serial.print(\"无线终端模式成功开启，网络连接成功\");\n  \n  if (WiFi.status() == WL_CONNECTED)\n  {\n    Serial.print(\"无线终端IP地址为: \");\n    Serial.println(WiFi.localIP());\n  }\n}\n \nvoid loop() {}\n```\n\n\n\n#### subnetMask – 获取子网掩码\n\n\n\n##### 说明\n\n利用SSID函数可以获取当前ESP8266模块所连接网络的子网掩码。\n\n##### 语法\n\n```\nwifi.subnetMask()\n```\n\n简例：\n\n```c\nSerial.print(\"子网掩码: \");\nSerial.println(WiFi.subnetMask());//直接打因为字符串获取子网掩码\n```\n\n\n\n##### 参数\n\n无\n\n##### 返回值\n\n返回值为ESP8266设备的子网掩码，数据类型为IPAdress。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块的子网掩码。在以下示例程序中，我们使用了WiFi.subnetMask()语句来获取该信息。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.subnetMask()演示\n  程序目的/Purpose          :\n  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下打印子网掩码的IP地址\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxxx\"         //这里改成你的设备当前环境下要连接的接入点密码\n \nint i = 0;//用来判定连接是否超时的累加量\n \nvoid setup(void)\n{\n  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600\n  Serial.println(\"开始连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户建立的接入点WiFi密码\n  Serial.print(\"无线终端模式成功开启，网络连接成功\");\n  \n  Serial.print(\"子网掩码: \");\n  Serial.println(WiFi.subnetMask());//直接打因为字符串获取子网掩码\n}\nvoid loop() {}\n```\n\n\n\n\n\n#### gatewayIP – 获取网关地址\n\n##### 说明\n\n利用gatewayIP函数可以获取当前ESP8266模块所连接网络的网关IP。\n\n##### 语法\n\nwifi.gatewayIP()\n\n简例：\n\n```c\nSerial.printf(\"网关地址: \");\nSerial.printf(WiFi.gatewayIP());//把网关地址打印为字符串\n```\n\n\n\n##### 参数\n\n无\n\n##### 返回值\n\n返回值直接返回网关IP，数据类型为IPAdress型。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块的联网状态代码。在以下示例程序中，我们使用了WiFi.gatewayIP()语句来获取网关IP。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.gatewayIP();演示\n  程序目的/Purpose          :\n  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下获取网关IP地址\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxx\"          //这里改成你的设备当前环境下要连接的接入点密码\n \nint i = 0;//用来判定连接是否超时的累加量\n \nvoid setup(void)\n{\n  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600\n  Serial.println(\"开始连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户建立的接入点WiFi密码\n  Serial.print(\"无线终端模式成功开启，网络连接成功\");\n  \n  Serial.printf(\"网关地址: %s\\n\", WiFi.gatewayIP().toString().c_str());//打印网关地址。此处使用.toString()和.c_str()确保能够正常打印\n}\n \nvoid loop() {}\n```\n\n\n\n#### dnsIP – 获取DNS地址\n\n##### 说明\n\n利用dnsIP函数可以获取当前ESP8266模块的dns IP地址。\n\n##### 语法\n\n`WiFi.dnsIP()`\n\n`WiFi.dnsIP(dns_no)`\n\n简例：\n\n```c\nSerial.print(\"DNS #1IP为: \");//打印出获取的DNS地址\nSerial.print(WiFi.dnsIP());\nSerial.print(\" \");\nSerial.print(\"DNS #2 IP为: \");\nSerial.print(WiFi.dnsIP(1));\n```\n\n\n\n##### 参数\n\n参数dns_no为可选参数。通过输入参数dns_no，我们可以指定所需的域名服务器的IP。此参数允许的值是0或1。如果未提供任何参数或参数为0，函数会返回DNS＃1的IP。如果参数为1，则返回DNS#2的IP。参数数据类型uint8_t型。\n\n##### 返回值\n\nDNS服务的IP地址，返回DNS＃1或DNS＃2的IP，数据类型为IPAdress。\n\n##### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块的DNS IP地址。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.dnsIP();演示\n  程序目的/Purpose          :\n  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下获取dns地址\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxxx\"          //这里改成你的设备当前环境下要连接的接入点密码\n \nint i = 0;//用来判定连接是否超时的累加量\n \nvoid setup(void)\n{\n  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600\n  Serial.println(\"开始连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户建立的接入点WiFi密码\n  Serial.print(\"无线终端模式成功开启，网络连接成功\");\n  \n  //打印出当前网络下的DNSIP\n  Serial.print(\"DNS #1IP为: \");\n  Serial.print(WiFi.dnsIP());\n  Serial.print(\" \");\n  Serial.print(\"DNS #2 IP为: \");\n  Serial.print(WiFi.dnsIP(1));\n}\n \nvoid loop() {}\n```\n\n\n\n#### macAddress – 获取mac地址\n\n##### 说明\n\n利用gatewayIP函数可以获取ESP8266模块的mac地址\n\n##### 语法\n\n`WiFi.macAddress(macAddr)`\n\n`WiFi.macAddress()`\n\n简例：\n\na. 如果输入参数macAddr，那么ESP8266开发板的mac地址将会存储在macAddr中。macAddr必须是一个uint8_t类型的数组，这个数组含有6个元素。\n\n```c\nif (WiFi.status() == WL_CONNECTED)\n{\n  uint8_t macAddr[6];\n  WiFi.macAddress(macAddr);\n  Serial.printf(\"用转存到数组的方式获取MAC地址: %02x:%02x:%02x:%02x:%02x:%02x\\n\", macAddr[0], macAddr[1], macAddr[2], macAddr[3], macAddr[4], macAddr[5]);\n  //MAC地址会储存在这个数组里面\n}\n```\n\nb.如下示例所示，直接调用WiFi.macAddress()不输入参数，ESP8266的mac地址将以字符串类型返回。\n\n```c\nif (WiFi.status() == WL_CONNECTED)\n{\n  Serial.printf(\"字符串获取MAC地址: %s\\n\", WiFi.macAddress().c_str());\n //不输入参数直接调用可以直接打印出字符串\n}\n```\n\n\n\n##### 参数\n\nmacAddr：此参数为可选参数。该参数为uint8_t类型的数组，这个数组含有6个元素。ESP8266的mac地址将会储存在这个数组中。\n\n##### 返回值\n\n若输入参数则会返回储存了MAC地址的数组（uint8_t型）。若没有输入参数则会返回MAC地址字符串（string型）\n\n##### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块的mac地址。在以下示例程序中，我们使用了两种macAddress函数调用方式来获取设备的IP地址。第一种是有参数的第二种是无参数的。这两种方式所获得的mac地址格式不同。有参数调用时，mac地址保存在数组macAddr中。无参数调用时，mac地址将以字符串形式返回。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.macAddress()演示\n  程序目的/Purpose          :\n  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下打印当前无线终端MAC地址\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#define AP_ssid   \"TaichiMaker\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxxxxxx\" //这里改成你的设备当前环境下要连接的接入点密码\nint i = 0;//用来判定连接是否超时的累加量\nvoid setup(void)\n{\n  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600\n  Serial.println(\"开始连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户建立的接入点WiFi密码\n  Serial.print(\"无线终端模式成功开启，网络连接成功\");\n  \n  if (WiFi.status() == WL_CONNECTED)\n  {\n    uint8_t macAddr[6]; // 建立保存mac地址的数组。用于以下语句\n    WiFi.macAddress(macAddr);   \n    Serial.printf(\"通过转存数组获取MAC地址: %02x:%02x:%02x:%02x:%02x:%02x\\n\", macAddr[0], macAddr[1], macAddr[2], macAddr[3], macAddr[4], macAddr[5]);\n \n    // 无参数调用macAddress时，ESP8266的mac地址将以字符串形式返回\n    Serial.printf(\"字符串获取MAC地址: %s\\n\", WiFi.macAddress().c_str());\n  }\n}\n \nvoid loop() {}\n```\n\n\n\n#### hostname – 获取/设置主机名\n\n##### 说明\n\n利用hostname函数可以获取WiFi路由器分配给ESP8266模块的主机名，同时也可以输入参数手动给ESP8266模块设置hostname（主机名）。\n\n##### 语法\n\n`WiFi.hostname()`\n`WiFi.hostname(hostname)`\n\n简例：\n\n```c\nSerial.printf(\"当前的hostname: %s\\n\", WiFi.hostname().c_str());//读取当前的hostname并输出\nSerial.printf(\"即将修改hostname为Station_Taichi\");\nWiFi.hostname(\"Station_Taichi\");//设置新的hostname\nSerial.printf(\"当前hostname: %s\\n\", WiFi.hostname().c_str());\n```\n\n##### 参数\n\nhostname，数据类型可为String型。我们手动设置的主机名的最大长度为32个字符。可以使用大写字母（A-Z），小写字母（a-z），数字（0-9），符号（.）和符号（-）。大小写字母之间没有区别，不允许将空格或者空格字符作为hostname。这里只列举了一部分规则，详细说明请参阅此链接：https://github.com/esp8266/Arduino/blob/master/libraries/ESP8266WiFi/src/ESP8266WiFiSTA.cpp。一旦hostname超过32个字符的限制, 则无法完成主机名设置。\n\n##### 返回值\n\n输入参数的情况下，如果设置新的hostname成功，会返回true。如果超过了32个字符的限制，或者设置失败，则函数将返回false而不会分配新的主机名。返回值数据类型为布尔型。\n\n没有输入参数的情况下，会返回当前的hostname，数据类型为string型。\n\n##### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块的主机名称。我们是通过以下示例程序中的WiFi.hostname()来获取该主机名的。在程序的后续部分中，我们使用了WiFi.hostname(“Station_Taichi”)来将ESP8266模块的主机名改为Station_Taichi。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.hostname();演示\n  程序目的/Purpose          :\n  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下获取hostname并修改\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxxx\"         //这里改成你的设备当前环境下要连接的接入点密码\n \nint i = 0;//用来判定连接是否超时的累加量\n \nvoid setup(void)\n{\n  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600\n  Serial.println(\"开始连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户建立的接入点WiFi密码\n  Serial.print(\"无线终端模式成功开启，网络连接成功\");\n  delay(1000);\n  Serial.printf(\"当前的hostname: %s\\n\", WiFi.hostname().c_str());//读取当前的hostname并输出\n  Serial.printf(\"即将修改hostname为Station_Taichi\");\n  delay(1000);\n  WiFi.hostname(\"Station_Taichi\");//设置新的hostname\n  Serial.printf(\"当前hostname: %s\\n\", WiFi.hostname().c_str());\n}\n \nvoid loop() {\n  delay(1000);\n}\n```\n\n\n\n#### isConnected – 获取WiFi连接状态\n\n##### 说明\n\n利用isConnected函数可以获取当前ESP8266模块是否成功连接WiFi。\n\n##### 语法\n\n`WiFi.isConnected()`\n\n##### 参数\n\n无\n\n##### 返回值\n\n返回值返回是否连接上接入点。若连接上则返回true，没有连接上返回false。数据类型为布尔型。\n\n##### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块已经成功连接到WiFi。在以下程序中 ，我们是通过调用WiFi.isConnected()来获取当前ESP8266开发板的联网状态的。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.isConnected();演示\n  程序目的/Purpose          :\n  此程序使用ESP8266WiFiSTA库来演示在Station模式下判断当前是否连接上接入点\n***********************************************************************/\n#include <ESP8266WiFi.h>\n\n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxx\"          //这里改成你的设备当前环境下要连接的接入点密码\n\nint i = 0;//用来判定连接是否超时的累加量\n\nvoid setup(void)\n{\n  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600\n  Serial.println(\" \");\n  Serial.println(\"判断是否连接上接入点\");\n  if (WiFi.isConnected() == true) {\n    Serial.println(\"已连接上接入点\");\n  }\n  else{\n    Serial.println(\"未连接上接入点\");\n  }\n  \n  Serial.println(\"开始连接\");\n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  \n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);         // 告知用户建立的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户建立的接入点WiFi密码\n  Serial.print(\"无线终端模式成功开启，网络连接成功\");\n}\n\nvoid loop() {\n  if (WiFi.isConnected() == true) {\n    Serial.println(\"已连接上接入点\");\n  }\n  else\n    Serial.println(\"未连接上接入点\");\n  delay(1000);\n}\n```\n\n\n\n#### getAutoConnect – 获取自动连接WiFi设置\n\n##### 说明\n\n利用getAutoConnect函数可以获取当前ESP8266模块是否设置为自动连接上次使用的WiFi接入点。我们可以通过[setAutoConnect](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifista/setautoconnect/)函数来将ESP8266模块设置为自动连接WiFi。\n\n##### 语法\n\n```\nWiFi.getAutoConnect()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n如果ESP8266模块配置为在开机时自动连接到上次使用的WiFi接入点，它将返回true。如果禁用了自动连接功能，则会返回false。数据类型为布尔型。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.getAutoConnect();演示\n  程序目的/Purpose          :\n \n  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下判断当前是否有自动连接\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxx\"          //这里改成你的设备当前环境下要连接的接入点密码\n \nint i = 0;//用来判定连接是否超时的累加量\n \nbool autoConnect = true;//设置自动连接所需变量\n \nvoid setup(void)\n{\n  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600\n  Serial.println(\"开始连接\");\n  Serial.println(\"检查自动连接设置状态\");\n  \n  if (WiFi.getAutoConnect() == true) {\n    Serial.println(\"已设置自连接\");\n  }\n  else\n    Serial.println(\"未设置连接\");\n  \n  WiFi.setAutoConnect(autoConnect);//启用自动连接模式\n  delay(500);//启用自动连接后再检查一次，确定设置变化\n  \n  Serial.println(\"再次检查自动连接设置状态\");\n  if (WiFi.getAutoConnect() == true) {\n    Serial.println(\"已设置自连接\");\n  }\n  else\n    Serial.println(\"未设置连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户建立的接入点WiFi密码\n  Serial.print(\"无线终端模式成功开启，网络连接成功\");\n}\n \nvoid loop() {}\n```\n\n\n\n\n\n#### RSSI – 获取WiFi信号强度\n\n##### 说明\n\n获取当前ESP8266模块连接到接入点的WiFi信号强度,单位为dBm。\n\n##### 语法\n\n`WiFi.RSSI()`\n\n##### 参数\n\n无\n\n##### 返回值\n\n返回代表ESP8266模块连接的接入点信号强度。返回值数据类型为int32_t，通过串口输出时需要注意这一点。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WiFi.RSSI();演示\n  程序目的/Purpose          :\n \n  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下打印当前wifi信号强度\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n#define AP_ssid   \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下要连接的接入点名字\n#define password  \"xxxxxxx\"          //这里改成你的设备当前环境下要连接的接入点密码\n \nint i = 0;//用来判定连接是否超时的累加量\n \nvoid setup(void)\n{\n  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600\n  Serial.println(\"开始连接\");\n  \n  //调用 WiFi.begin()函数，开始连接接入点\n  WiFi.begin(AP_ssid, password);\n  Serial.print(\"正在连接到\");\n  Serial.print(AP_ssid);\n  \n  //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中\n  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时\n  while (WiFi.status() != WL_CONNECTED) {\n    i++;\n    delay(500);\n    Serial.print(\".\");\n    if (i > 120) { //60秒后如果还是连接不上，就判定为连接超时\n      Serial.print(\"连接超时！请检查网络环境\");\n      break;\n    }\n  }\n  Serial.println(\"网络连接成功\");\n  \n  //这一部分用来输出连接网络的基本信息\n  Serial.println(\"500\");              // 延时500毫秒\n  Serial.print(\"当前工作模式:\");     // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"连接到的接入点名字:\");\n  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名\n  Serial.print(\"连接到的接入点密码:\");\n  Serial.println(password);        // 告知用户建立的接入点WiFi密码\n  Serial.print(\"无线终端模式成功开启，网络连接成功\");\n}\n \nvoid loop() {\n  Serial.printf(\"RSSI: %d dBm\\n\", WiFi.RSSI());\n  delay(1000);\n}\n```\n\n\n\n\n\n\n\n\n\n## ESP8266 – ESP8266WiFiGeneric库\n\nESP8266WiFiGeneric库主要包含ESP8266的通用功能，如工作模式设置、WiFi时间类型设置等。\n\n以下为ESP8266WiFiGeneric库的整体结构图。在此图下方是库函数目录。![image-20230525200128705](./Image/ESP8266.assets/image-20230525200128705.png)\n\n\n\n\n\n### WiFi事件类型\n\n#### 接入点模式事件类型\n\n##### onSoftAPModeStationConnected – 有无线终端连接到接入点\n\n###### 说明\n\nESP8266在接入点模式下有无线终端连接到ESP8266所建立的WiFi网络时，ESP8266会自动调用事件处理回调函数。该事件处理回调函数由onSoftAPModeStationConnected的参数所定义。\n\n###### 语法\n\n```\nWiFi.onSoftAPModeStationConnected(onStationConnected);\n```\n\n###### 参数\n\nonStationConnected：回调函数名称\n\n###### 返回值\n\nWiFiEventHandler对象\n\n###### 示例代码\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\nonSoftAPModeStationConnected函数使用时有两个重点步骤:\n\n1. 通过语句`WiFiEventHandler stationConnectedHandler;`\n   建立WiFiEventHandler 实例对象，对象名称为stationConnectedHandler。\n\n2. 通过语句`stationConnectedHandler = WiFi.onSoftAPModeStationConnected(onStationConnected);`\n   对回调函数进行相应的设置。此处onSoftAPModeStationConnected函数的参数“onStationConnected”就是设置了回调函数的名称。\n\n\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiGeneric_AP_1\n程序目的/Purpose          : \n用于演示ESP8266WiFiGeneric库中onSoftAPModeStationConnected函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \n#define ssid   \"TaichiMaker_WIFI\"  // 这里定义将要建立的WiFi名称。此处以\"TaichiMaker_WIFI\"为示例\n                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中\n#define password  \"12345678\"        // 这里定义将要建立的WiFi密码。此处以12345678为示例\n                                    // 您可以将自己想要使用的WiFi密码放入引号内\n                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息\n \nWiFiEventHandler stationConnectedHandler;  //实例化WIFI事件对象\n \nvoid setup() { \n  Serial.begin(115200);         //打开串口\n  WiFi.softAP(ssid, password);  // 此语句是重点。WiFi.softAP用于启动NodeMCU的AP接入点模式。\n                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。\n                                // 这两个参数具体内容在setup函数之前的位置进行定义。\n  \n  Serial.println(\"\"); \n  Serial.print(\"Access Point: \");    // 通过串口监视器输出信息\n  Serial.println(ssid);              // 告知用户NodeMCU所建立的WiFi名\n  Serial.print(\"Password: \");        \n  Serial.println(password);          // 告知用户NodeMCU所建立的WiFi密码\n  Serial.print(\"IP address: \");      // 以及NodeMCU的IP地址\n  Serial.println(WiFi.softAPIP());   // 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址\n \n  // onSoftAPModeStationConnected函数的参数onStationConnected为事件处理回调函数。\n  // 也就是说，每当有新的无线终端连接到ESP8266设备建立的WiFi后，设备都会自动调用onStationConnected函数\n  stationConnectedHandler = WiFi.onSoftAPModeStationConnected(onStationConnected);\n \n}\n \nvoid loop(){\n}\n \nvoid onStationConnected(const WiFiEventSoftAPModeStationConnected& evt) {//接入点模式下有无线终端设备连接进来时的回调函数\n  Serial.print(\"无线终端设备的mac地址: \");\n  Serial.println(macToString(evt.mac));//调用macToString函数将mac转换成字符串\n  Serial.print(\"无线终端设备的序号: \");\n  Serial.println(evt.aid);  \n}\n \nString macToString(const unsigned char* mac) {  //字符串转换函数\n  char buf[20];\n  snprintf(buf, sizeof(buf), \"%02x:%02x:%02x:%02x:%02x:%02x\",mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n  return String(buf);\n}\n```\n\n\n\n##### onSoftAPModeStationDisconnected – 有无线终端断开与接入点的连接\n\n###### 说明\n\n设备在接入点模式下有无线终端从设备所建立的WiFi网络断开时，设备会自动调用事件处理回调函数。该事件处理回调函数由onSoftAPModeStationDisconnected的参数所定义。\n\n###### 语法\n\n```\nWiFi.onSoftAPModeStationDisconnected(onStationDisconnected)\n```\n\n###### 参数\n\nonStationDisconnected：回调函数\n\n###### 返回值\n\nWiFiEventHandler对象\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n**onSoftAPModeStationDisconnected函数使用时有两个重点步骤:**\n\n1. 通过语句`WiFiEventHandler stationDisconnectedHandler;`\n   建立WiFiEventHandler 实例对象，对象名称为stationDisconnectedHandler。\n2. 通过语句`stationDisconnectedHandler = WiFi.onSoftAPModeStationDisconnected(onStationDisconnected);`\n   对回调函数进行相应的设置。此处onSoftAPModeStationDisconnected函数的参数“onStationDisconnected”就是设置了回调函数的名称。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiGeneric_AP_2\n程序目的/Purpose          : \n用于演示ESP8266WiFiGeneric库中onSoftAPModeStationDisconnected函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \n#define ssid   \"TaichiMaker_WIFI\"   // 这里定义将要建立的WiFi名称。此处以\"TaichiMaker_WIFI\"为示例\n                                    // 您可以将自己想要建立的WiFi名称填写入此处的双引号中\n#define password  \"12345678\"        // 这里定义将要建立的WiFi密码。此处以12345678为示例\n                                    // 您可以将自己想要使用的WiFi密码放入引号内\n                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息\n \nWiFiEventHandler stationDisconnectedHandler;  //实例化WIFI事件对象\n \nvoid setup() { \n  Serial.begin(115200);\n  WiFi.softAP(ssid, password);  // 此语句是重点。WiFi.softAP用于启动NodeMCU的AP接入点模式。\n                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。\n                                // 这两个参数具体内容在setup函数之前的位置进行定义。\n  \n  Serial.println(\"\"); \n  Serial.print(\"Access Point: \");    // 通过串口监视器输出信息\n  Serial.println(ssid);              // 告知用户NodeMCU所建立的WiFi名\n  Serial.print(\"Password: \");        \n  Serial.println(password);          // 告知用户NodeMCU所建立的WiFi密码\n  Serial.print(\"IP address: \");      // 以及NodeMCU的IP地址\n  Serial.println(WiFi.softAPIP());   // 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址\n \n  // onSoftAPModeStationDisconnected函数的参数onStationDisconnected为事件处理回调函数。\n  // 也就是说，每当有无线终端从ESP8266设备建立的WiFi连接断开后，设备都会自动调用onStationDisconnected函数\n  stationDisconnectedHandler = WiFi.onSoftAPModeStationDisconnected(onStationDisconnected);\n}\n \nvoid loop(){\n}\n \nvoid onStationDisconnected(const WiFiEventSoftAPModeStationDisconnected& evt) {  //接入点模式下有无线终端设备断开连接时的回调函数\n  Serial.print(\"断开连接的无线终端是: \");\n  Serial.println(macToString(evt.mac));//调用macToString函数将mac转换成字符串\n}\n \nString macToString(const unsigned char* mac) {//字符串转换函数\n  char buf[20];\n  snprintf(buf, sizeof(buf), \"%02x:%02x:%02x:%02x:%02x:%02x\",mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n  return String(buf);\n}\n```\n\n\n\n##### onSoftAPModeProbeRequestReceived – 接入点模式下收到探针请求\n\n###### 说明\n\n设备在接入点模式下收到无线终端的探针请求时，设备会自动调用事件处理回调函数。该事件处理回调函数由onSoftAPModeProbeRequestReceived 的参数所定义。\n\n###### 语法\n\n```\nWiFi.onSoftAPModeProbeRequestReceived(onProbeRequestReceived)\n```\n\n###### 参数\n\nonProbeRequestReceived：回调函数\n\n###### 返回值\n\nWiFiEventHandler对象\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\nonSoftAPModeProbeRequestReceived函数使用时有两个重点步骤:\n\n1. 通过语句\n   `WiFiEventHandler probeRequestReceivedHandler`\n   建立WiFiEventHandler 实例对象，对象名称为probeRequestReceivedHandler。\n\n2. 通过语句\n   `probeRequestReceivedHandler = WiFi.onSoftAPModeProbeRequestReceived(onProbeRequestReceived);`\n   对回调函数进行相应的设置。此处onSoftAPModeProbeRequestReceived函数的参数“onProbeRequestReceived”就是设置了回调函数的名称。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiGeneric_AP_3\n程序目的/Purpose          : \n用于演示ESP8266WiFiGeneric库中onSoftAPModeProbeRequestReceived 函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \n#define ssid   \"TaichiMaker_WIFI\"  // 这里定义将要建立的WiFi名称。此处以\"TaichiMaker_WIFI\"为示例\n                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中\n#define password  \"12345678\"        // 这里定义将要建立的WiFi密码。此处以12345678为示例\n                                    // 您可以将自己想要使用的WiFi密码放入引号内\n                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息\n \nWiFiEventHandler probeRequestReceivedHandler;//实例化WIFI事件对象\n \nvoid onProbeRequestReceived(const WiFiEventSoftAPModeProbeRequestReceived& evt){//设备在接入点模式下收到无线终端的探针请求时的回调函数\n  Serial.print(\"请求终端的mac地址: \");\n  Serial.print(macToString(evt.mac));//调用macToString函数将mac转换成字符串\n  Serial.print(\"     请求终端的信号强度: \");\n  Serial.println(evt.rssi);//调用macToString函数将mac转换成字符串\n}\n \nvoid setup() {\n  Serial.begin(115200);\n  WiFi.softAP(ssid, password);  // 此语句是重点。WiFi.softAP用于启动NodeMCU的AP接入点模式。\n                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。\n                                // 这两个参数具体内容在setup函数之前的位置进行定义。\n  \n  Serial.println(\"\"); \n  Serial.print(\"Access Point: \");    // 通过串口监视器输出信息\n  Serial.println(ssid);              // 告知用户NodeMCU所建立的WiFi名\n  Serial.print(\"Password: \");        \n  Serial.println(password);          // 告知用户NodeMCU所建立的WiFi密码\n  Serial.print(\"IP address: \");      // 以及NodeMCU的IP地址\n  Serial.println(WiFi.softAPIP());   // 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址\n \n  // onSoftAPModeProbeRequestReceived函数的参数onProbeRequestReceived为事件处理回调函数。\n  // 也就是说，每当设备在接入点模式下收到无线终端的探针请求时，设备都会自动调用onStationConnected函数\n  probeRequestReceivedHandler = WiFi.onSoftAPModeProbeRequestReceived(onProbeRequestReceived);\n}\n \nvoid loop() {\n}\n    \nString macToString(const unsigned char* mac) {//字符串转换函数\n  char buf[20];\n  snprintf(buf, sizeof(buf), \"%02x:%02x:%02x:%02x:%02x:%02x\",mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n  return String(buf);\n}\n```\n\n\n\n#### 无线终端模式事件类型\n\n##### onStationModeConnected – 无线终端模式连上WiFi\n\n##### 说明\n\n无线终端模式下连接上WIFI时，设备会自动调用事件处理回调函数。该事件处理回调函数由onStationModeConnected的参数所定义。\n\n##### 语法\n\n```c\nWiFi.onStationModeConnected(ConnectedHandler)\n```\n\n##### 参数\n\nConnectedHandler：回调函数\n\n##### 返回值\n\nWiFiEventHandler对象\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n通过以下程序，当设备连接到WiFi网络后，将会通过串口监视器输出信息告知用户无线终端设备已经成功连接到网络。即ConnectedHandler函数所实现的程序内容。\n\n**onStationModeConnected函数使用时有两个重点步骤:**\n\n1. 通过语句\n   `WiFiEventHandler STAConnected;`\n   建立WiFiEventHandler 实例对象，对象名称为STAConnected。\n\n2. 通过语句\n   `STAConnected = WiFi.onStationModeConnected(ConnectedHandler);`\n   对回调函数进行相应的设置。此处onStationModeConnected函数的参数“ConnectedHandler”就是设置了回调函数的名称。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiGeneric_STA_1\n程序目的/Purpose          : \n用于演示ESP8266WiFiGeneric库中onStationModeConnected函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \n#define ssid   \"TaichiMaker_WIFI\"  // 这里定义将要连接的WiFi名称。此处以\"TaichiMaker_WIFI\"为示例\n                                   // 您可以将自己想要连接的WiFi名称填写入此处的双引号中\n#define password  \"12345678\"        // 这里定义将要连接的WiFi密码。此处以12345678为示例\n                                    // 您可以将自己想要使用的WiFi密码放入引号内\n                                    // 如果连接的WiFi不要密码，则在双引号内不要填入任何信息\n \nWiFiEventHandler STAConnected;      //实例化WIFI事件对象\n \nvoid setup()\n{\n  Serial.begin(115200);    //打开串口\n    \n  // onStationModeConnected函数的参数ConnectedHandler为事件处理回调函数。\n  // 也就是说，当无线终端连接到WiFi后，设备都会自动调用ConnectedHandler函数\n  STAConnected = WiFi.onStationModeConnected(ConnectedHandler);\n   \n  WiFi.begin(ssid, password);   // 此语句是重点。WiFi.begin用于启动NodeMCU的无线终端模式。\n                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。\n                                // 这两个参数具体内容在setup函数之前的位置进行定义。\n \n  Serial.println(\"\");              // 通过串口监视器输出信息\n  Serial.print(\"Access Point:\");    \n  Serial.println(ssid);            // 告知用户连接的WiFi名\n  Serial.print(\"Password:\");        \n  Serial.println(password);        // 告知用户连接的WiFi密码\n}\n \nvoid loop(){}\n \nvoid ConnectedHandler(const WiFiEventStationModeConnected &event)//无线终端模式下连接上WIFI时的回调函数\n{\n  Serial.println(\"无线终端连接到网络\");\n}\n```\n\n\n\n\n\n##### onStationModeDisconnected – 无线终端模式断开WiFi\n\n###### 说明\n\n无线终端模式下连接上的WIFI断开时，设备会自动调用事件处理回调函数。该事件处理回调函数由onStationModeDisconnected的参数所定义。\n\n###### 语法\n\n```\nWiFi.onStationModeDisconnected(DisconnectedHandler)\n```\n\n###### 参数\n\nDisconnectedHandler：回调函数\n\n###### 返回值\n\nWiFiEventHandler对象\n\n###### 示例程序\n\n通过本程序，当设备与WiFi网络断开连接后，将会通过串口监视器输出信息，告知用户无线终端设备已经断开到网络连接。即DisconnectedHandler函数所实现的程序内容。\n\n**onStationModeDisconnected函数使用时有两个重点步骤:**\n\n1. 通过语句\n   `WiFiEventHandler STADisconnected;`\n   建立WiFiEventHandler 实例对象，对象名称为STADisconnected。\n\n2. 通过语句\n   `STADisconnected = WiFi.onStationModeDisconnected(DisconnectedHandler);`\n   对回调函数进行相应的设置。此处onStationModeDisconnected函数的参数“DisconnectedHandler”就是设置了回调函数的名称。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiGeneric_STA_2\n程序目的/Purpose          : \n用于演示ESP8266WiFiGeneric库中onStationModeDisconnected函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \n#define ssid   \"TaichiMaker_WIFI\"  // 这里定义将要连接的WiFi名称。此处以\"TaichiMaker_WIFI\"为示例\n                                   // 您可以将自己想要连接的WiFi名称填写入此处的双引号中\n#define password  \"12345678\"        // 这里定义将要连接的WiFi密码。此处以12345678为示例\n                                    // 您可以将自己想要使用的WiFi密码放入引号内\n                                    // 如果连接的WiFi不要密码，则在双引号内不要填入任何信息\n \nWiFiEventHandler STADisconnected;  //实例化WIFI事件对象\n \nvoid setup()\n{\n  Serial.begin(115200);//打开串口\n    \n  // onStationModeDisconnected函数的参数DisconnectedHandler为事件处理回调函数。\n  // 也就是说，当无线终端从连接到的WiFi断开后，设备都会自动调用DisconnectedHandler函数\n  STADisconnected = WiFi.onStationModeDisconnected(DisconnectedHandler);\n   \n  WiFi.begin(ssid, password);   // 此语句是重点。WiFi.begin用于启动NodeMCU的无线终端模式。\n                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。\n                                // 这两个参数具体内容在setup函数之前的位置进行定义。\n    \n  Serial.println(\"\");              // 通过串口监视器输出信息\n  Serial.print(\"Access Point:\");    \n  Serial.println(ssid);            // 告知用户连接的WiFi名\n  Serial.print(\"Password:\");        \n  Serial.println(password);        // 告知用户连接的WiFi密码\n}\n \nvoid loop()\n{\n  delay(5000); //等待5秒\n  WiFi.disconnect(); //断开当前网络连接，以触发onStationModeDisconnected事件\n}\n \nvoid DisconnectedHandler(const WiFiEventStationModeDisconnected &event)//无线终端从连接到的WiFi断开后，设备都会自动调用\n{\n  Serial.println(\"无线终端从网络断开\");\n}\n```\n\n\n\n##### onStationModeAuthModeChanged – 无线终端模式下校验模式改变\n\n###### 说明\n\n无线终端模式下连接上WIFI并且校验模式改变时，设备会自动调用事件处理回调函数。该事件处理回调函数由onStationModeAuthModeChanged的参数所定义。\n\n###### 语法\n\n```\nWiFi.onStationModeAuthModeChanged(ChangedHandler)\n```\n\n###### 参数\n\nChangedHandler：回调函数\n\n###### 返回值\n\nWiFiEventHandler对象\n\n\n\n##### onStationModeGotIP – 无线终端模式下获取到IP地址\n\n###### 说明\n\n无线终端模式下连接上WIFI并且获得IP地址后，设备会自动调用事件处理回调函数。该事件处理回调函数由onStationModeGotIP的参数所定义。\n\n###### 语法\n\n```\nWiFi.onStationModeGotIP(GotIPHandler)\n```\n\n###### 参数\n\nGotIPHandler：回调函数\n\n###### 返回值\n\nWiFiEventHandler对象\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n通过本程序，当设备连接到WiFi并且获取到IP地址后，将会通过串口监视器输出设备的IP地址信息。串口输出设备IP地址信息是通过GotIPHandler函数所实现的。\n\n**onStationModeGotIP函数使用时有两个重点步骤:**\n\n1. 通过语句\n   `WiFiEventHandler STAGotIP;`\n   建立WiFiEventHandler 实例对象，对象名称为STAGotIP。\n\n2. 通过语句\n   `STAGotIP = WiFi.onStationModeGotIP(GotIPHandler);`\n   对回调函数进行相应的设置。此处onStationModeGotIP函数的参数“GotIPHandler”就是设置了回调函数的名称。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiGeneric_STA_4\n程序目的/Purpose          : \n用于演示ESP8266WiFiGeneric库中onStationModeGotIP函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \n#define ssid   \"TaichiMaker_WIFI\"  // 这里定义将要连接的WiFi名称。此处以\"TaichiMaker_WIFI\"为示例\n                                   // 您可以将自己想要连接的WiFi名称填写入此处的双引号中\n#define password  \"12345678\"        // 这里定义将要连接的WiFi密码。此处以12345678为示例\n                                    // 您可以将自己想要使用的WiFi密码放入引号内\n                                    // 如果连接的WiFi不要密码，则在双引号内不要填入任何信息\n \nWiFiEventHandler STAGotIP;   //实例化WIFI事件对象\n \nvoid setup()\n{\n  Serial.begin(115200);   //打开串口\n    \n  // onStationModeGotIP函数的参数GotIPHandler为事件处理回调函数。\n  // 也就是说，当无线终端连接到WiFi后，设备都会自动调用GotIPHandler函数\n  STAGotIP = WiFi.onStationModeGotIP(GotIPHandler);\n \n  WiFi.begin(ssid, password);   // 此语句是重点。WiFi.begin用于启动NodeMCU的无线终端模式。\n                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。\n                                // 这两个参数具体内容在setup函数之前的位置进行定义。\n    \n  Serial.println(\"\");              // 通过串口监视器输出信息\n  Serial.print(\"Access Point:\");    \n  Serial.println(ssid);            // 告知用户连接的WiFi名\n  Serial.print(\"Password:\");        \n  Serial.println(password);        // 告知用户连接的WiFi密码\n}\n \nvoid loop(){\n}\n \nvoid GotIPHandler(const WiFiEventStationModeGotIP &event)//当无线终端连接到WiFi后，设备都会自动调用\n{\n  Serial.println(\"模块获得IP：\");\n  Serial.print(WiFi.localIP());//输出NodeMCU的IP地址。这一功能是通过调用\n                               //WiFi.localIP()函数来实现的。该函数的返回值即NodeMCU的IP地址。\n}\n```\n\n\n\n##### onStationModeDHCPTimeout – 无线终端模式下动态分配IP超时\n\n###### 说明\n\n无线终端模式下连接上WIFI并且DHCP分配IP超时时，设备会自动调用事件处理回调函数。该事件处理回调函数由onStationModeDHCPTimeout的参数所定义。\n\n###### 语法\n\n```\nWiFi.onStationModeDHCPTimeout(DHCPTimeout)\n```\n\n###### 参数\n\nDHCPTimeout：回调函数\n\n###### 返回值\n\n无\n\n\n\n\n\n### 设置类型\n\n#### persistent – 是否保存WiFi连接信息在闪存中\n\n##### 说明\n\n此函数用于控制是否将WiFi配置信息保存到开发板的闪存中。默认情况下为true，也就是将WiFi配置信息保存到开发板的闪存中。当我们使用这个函数并设置参数为false时，开发板将不会把WiFi配置写入开发板的闪存中。\n\n##### 语法\n\n```\nWiFi.persistent(val)\n```\n\n##### 参数\n\nval：此参数值为true时，WiFi配置信息将保存到开发板的闪存中。\n参数值为false时，不WiFi配置信息不保存到开发板的闪存中。\n此参数类型为bool型。\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiGeneric_demo_1\n程序目的/Purpose          : \n用于演示ESP8266WiFiGeneric库中persistent函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \n#define ssid   \"TaichiMaker_WIFI\"  // 这里定义将要建立的WiFi名称。此处以\"TaichiMaker_WIFI\"为示例\n                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中\n#define password  \"12345678\"        // 这里定义将要建立的WiFi密码。此处以12345678为示例\n                                    // 您可以将自己想要使用的WiFi密码放入引号内\n                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息\n \nvoid setup() { \n  Serial.begin(115200);\n    \n  WiFi.persistent(false);       // 不保存wifi配置到开发板闪存中\n  \n  WiFi.begin(ssid, password);   // WiFi.begin用于启动NodeMCU的无线终端模式。\n                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。\n                                // 这两个参数具体内容在setup函数之前的位置进行定义。\n \n  Serial.println(\"\");              // 通过串口监视器输出信息\n  Serial.print(\"Current Mode:\");   // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"Access Point:\");    \n  Serial.println(ssid);            // 告知用户连接的WiFi名\n  Serial.print(\"Password:\");        \n  Serial.println(password);        // 告知用户连接的WiFi密码\n}\n \nvoid loop(){}\n```\n\n\n\n\n\n#### mode – 设置WiFi工作模式\n\n##### 说明\n\n此函数用于设置ESP8266开发板设备的WiFi网络工作模式。ESP8266开发板一共有三种工作模式。分别是：接入点模式（AP）、无线终端模式（Station）以及混合模式。\n\n##### 语法\n\n`WiFi.mode(val);`\n\n参数\n\nval：此参数允许使用以下值。\n\n- WIFI_OFF，（关闭WiFi）\n- WIFI_STA，（无线终端模式）\n- WIFI_AP, （接入点模式）\n- WIFI_AP_STA，（接入点-无线终端双模式）\n\n举例来说，如果我们使用`WiFi.mode(WIFI_STA)`，则意味着我们让ESP8266以无线终端模式进行工作。\n\n##### 返回值\n\n此函数的返回值为布尔型。当ESP8266成功设置为指定模式后，将会返回true，否则返回false。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。我们使用了`WiFi.mode(WIFI_STA);`将ESP8266设置为无线终端模式。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiGeneric_demo_2\n程序目的/Purpose          : \n用于演示ESP8266WiFiGeneric库中mode函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \n#define ssid   \"TaichiMaker_WIFI\"  // 这里定义将要建立的WiFi名称。此处以\"TaichiMaker_WIFI\"为示例\n                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中\n#define password  \"12345678\"        // 这里定义将要建立的WiFi密码。此处以12345678为示例\n                                    // 您可以将自己想要使用的WiFi密码放入引号内\n                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息\n \nvoid setup() { \n  Serial.begin(115200);         //打开串口\n  \n  WiFi.mode(WIFI_STA);          //设置设备的工作模式为无线终端模式\n    \n  WiFi.begin(ssid, password);   // 此语句是重点。WiFi.begin用于启动NodeMCU的无线终端模式。\n                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。\n                                // 这两个参数具体内容在setup函数之前的位置进行定义。\n    \n  while (WiFi.status() != WL_CONNECTED) {//等待WiFi连接\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.print(\"当前模式为： \");     // 通过串口监视器输出信息\n  Serial.println(WiFi.getMode());  // 告知用户设备当前工作模式\n \n  delay(5000);//延时便于查看效果\n  WiFi.mode(WIFI_OFF);             //设置设备的工作模式为关闭模式\n  Serial.print(\"当前模式为： \");       \n  Serial.println(WiFi.getMode());  // 告知用户设备当前工作模式\n}\n \nvoid loop(){}\n```\n\n\n\n#### enableSTA – 设置为终端模式\n\n##### 说明\n\n本函数用于设置ESP8266开发板的工作模式为无线终端模式。ESP8266开发板一共有三种工作模式。分别是：接入点模式（AP）、无线终端模式（Station）以及混合模式。\n\n##### 语法\n\nWiFi.enableSTA(val);\n\n##### 参数\n\nval：此参数用于控制ESP8266开发板启动或停止**无线终端模式**。\n参数值为true时，ESP8266开发板启动**无线终端模式**。\n参数值为false时，ESP8266开发板停止**无线终端模式**。\n此参数类型为bool型。\n\n##### 返回值\n\n返回值类型为布尔型。\n设备成功启动无线终端模式，返回值为true。否则返回值为false。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiGeneric_demo_4\n程序目的/Purpose          : \n用于演示ESP8266WiFiGeneric库中enableSTA函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \n#define ssid   \"TaichiMaker_WIFI\"  // 这里定义将要建立的WiFi名称。此处以\"TaichiMaker_WIFI\"为示例\n                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中\n#define password  \"12345678\"        // 这里定义将要建立的WiFi密码。此处以12345678为示例\n                                    // 您可以将自己想要使用的WiFi密码放入引号内\n                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息\n \nvoid setup() { \n  Serial.begin(115200);          //打开串口\n  \n  WiFi.enableSTA(true);          //设置设备的工作模式为无线终端模式。 \n \n  WiFi.begin(ssid, password);   // 此语句是重点。WiFi.begin用于启动NodeMCU的无线终端模式。\n                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。\n                                // 这两个参数具体内容在setup函数之前的位置进行定义。\n \n  Serial.println(\"\");              // 通过串口监视器输出信息\n  Serial.print(\"Current Mode:\");   // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"Access Point:\");    \n  Serial.println(ssid);            // 告知用户连接的WiFi名\n  Serial.print(\"Password:\");        \n  Serial.println(password);        // 告知用户连接的WiFi密码\n}\n \nvoid loop(){}\n```\n\n\n\n#### enableAP – 设置为接入点模式\n\n##### 说明\n\n本函数用于设置ESP8266开发板的工作模式为WiFi接入点模式。ESP8266开发板一共有三种工作模式。分别是：WiFi接入点模式（AP）、无线终端模式（Station）以及混合模式。\n\n##### 语法\n\n```c\nWiFi.enableAP(val)\n```\n\n##### 参数\n\nval：此参数用于控制ESP8266开发板启动或停止**无线接入点模式**。\n参数值为true时，ESP8266开发板启动**无线接入点模式**。\n参数值为false时，ESP8266开发板停止**无线接入点模式**。\n此参数类型为bool型。\n\n##### 返回值\n\n返回值类型为布尔型。\n设备成功启动无线接入点模式，返回值为true。否则返回值为false。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiGeneric_demo_5\n程序目的/Purpose          : \n用于演示ESP8266WiFiGeneric库中enableAP函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \n#define ssid   \"TaichiMaker_WIFI\"  // 这里定义将要建立的WiFi名称。此处以\"TaichiMaker_WIFI\"为示例\n                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中\n#define password  \"12345678\"        // 这里定义将要建立的WiFi密码。此处以12345678为示例\n                                    // 您可以将自己想要使用的WiFi密码放入引号内\n                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息\n \nvoid setup() { \n  Serial.begin(115200);          //打开串口\n    \n  WiFi.enableAP(true);           // 设置设备的工作模式为接入点模式。 \n    \n  WiFi.softAP(ssid, password);   // WiFi.softAP用于启动NodeMCU的AP模式。\n                                 // 括号中有两个参数，ssid是WiFi名。password是WiFi密码\n                                 // 这两个参数具体内容在setup函数之前的位置进行定义。\n  \n  Serial.println(\"\");              // 通过串口监视器输出信息\n  Serial.print(\"Current Mode:\");   // 告知用户设备当前工作模式\n  Serial.println(WiFi.getMode());\n  Serial.print(\"Access Point:\");    \n  Serial.println(ssid);            // 告知用户建立的WiFi名\n  Serial.print(\"Password:\");        \n  Serial.println(password);        // 告知用户建立的WiFi密码\n}\n \nvoid loop(){}\n```\n\n\n\n#### setSleepMode – 设置为休眠模式\n\n##### 说明\n\n设置ESP8266的睡眠模式,从而使ESP8266降低功耗,达到节能的目的。以下是ESP8266的三种睡眠模式介绍：\n\n**WIFI_NONE_SLEEP**\n– 此模式将打开ESP8266所有的功能并将长期处于此状态, 缺点也是不言而喻的增大功耗;\n– 但是对于ESP8266初学者,这里还是建议使用此模式进行调试和开发,因为在不进行产品开发的前提下,使用此模式不会给您带来丢包和重连等问题;\n\n**WIFI_MODEM_SLEEP**\n– 这是ESP8266的默认睡眠方式,但此模式仅在无线终端模式下正常运行,而且只有当您连接到WiFi的时候才生效;\n– 当您设置了WIFI_MODEM_SLEEP模式并且成功连接WiFi之后,它会在ESP8266与路由器传递消息的间隔内关闭WIFI连接电路来达到节能的目的。ESP8266可以在下一次通讯到来之前自动唤醒WIFI电路来确保其工作;\n– 如果您使用干电池或者是您的设备不能持久供电的情况下,可以考虑采用此模式\n\n**WIFI_LIGHT_SLEEP**\n– 此模式在WIFI_MODEM_SLEEP基础上还会暂停ESP8266的CPU、系统时钟等，从而达到比前者更加节能的目的。\n\n##### 语法\n\n```\nWiFi.setSleepMode(type, listenInterval)`\n`WiFi.setSleepMode(type)\n```\n\n##### 参数\n\ntype： 此参数用于设置睡眠模式。ESP8266开发板一共有以下几种睡眠模式。\nWIFI_NONE_SLEEP （非睡眠模式）\nWIFI_LIGHT_SLEEP （轻度睡眠）\nWIFI_MODEM_SLEEP （深度睡眠）\n\nlistenInterval：睡眠间隔时间, 单位毫秒。（参数类型： int）\n\n##### 返回值\n\n返回值类型为布尔型。\n设备成功进入指定睡眠模式，返回值为true。否则返回值为false。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会定时向www.example.com网站发送HTTP请求，并且将该网站服务器的响应信息显示在串口监视器中。\n\n请留意在以下示例程序中，我们使用了`WiFi.setSleepMode(WIFI_LIGHT_SLEEP); `对ESP8266的睡眠模式进行了设置。\n\n```c\n/**********************************************************************\n程序名称/Program name     : setSleepMode\n程序目的/Purpose          : \n此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求，\n并且将网站服务器响应的信息输出在屏幕中。程序中使用了setSleepMode函数来演示如何使用\n该函数将ESP8266设置为低功耗工作状态。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WiFiMulti.h>\n \nESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象\n \nconst char* host = \"www.example.com\"; // 网络服务器地址\nconst int httpPort = 80;              // http端口80\n \n// WiFi连接信息\nconst char*  WiFi_SSID = \"TaichiMaker\";\nconst char*  WiFi_Password = \"12345678\";\n \nvoid setup(){\n  Serial.begin(9600);          \n  Serial.println(\"\");\n \n  // 设置睡眠模式（可选参数：WIFI_NONE_SLEEP、WIFI_LIGHT_SLEEP、WIFI_MODEM_SLEEP ）\n  WiFi.setSleepMode(WIFI_LIGHT_SLEEP);  \n    \n  wifiMulti.addAP(WiFi_SSID, WiFi_Password); \n  Serial.println(\"Connecting ...\"); \n \n  // 尝试进行wifi连接。\n  int i = 0;  \n  while (wifiMulti.run() != WL_CONNECTED) { \n    delay(1000);\n    Serial.print(i++); Serial.print(' ');\n  }\n  \n  // WiFi连接成功后将通过串口监视器输出连接成功信息 \n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(WiFi.SSID());              // WiFi名称\n  Serial.print(\"IP address:\\t\");\n  Serial.println(WiFi.localIP());           // IP\n}\n \nvoid loop(){\n  // 发送HTTP请求\n  httpRequest();    \n  \n  delay(10000);\n}\n \n// 向服务器发送HTTP请求\nvoid httpRequest(){\n  // 建立WiFi客户端对象，对象名称client\n  WiFiClient client;    \n \n  // 建立字符串，用于HTTP请求\n  String httpRequest =  String(\"GET /\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  \n  // 通过串口输出连接服务器名称以便查阅连接服务器的网址                      \n  Serial.print(\"Connecting to \"); \n  Serial.print(host); \n \n  // 连接网络服务器，以下段落中的示例程序为本程序重点1\n  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n  if (client.connect(host, httpPort)){ \n    Serial.println(\" Success!\");        // 连接成功后串口输出“Success”信息\n    \n    client.print(httpRequest);          // 向服务器发送合同谈判请求\n    Serial.println(\"Sending request: \");// 通过串口输出HTTP请求信息内容以便查阅\n    Serial.println(httpRequest);     \n    \n    // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2\n    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n    Serial.println(\"Web Server Response:\");        \n    while (client.connected() || client.available()){ \n      if (client.available()){\n        String line = client.readStringUntil('\\n');\n        Serial.println(line);\n      }\n    }\n    \n    client.stop();                      // 断开与服务器的连接\n    Serial.print(\"Disconnected from \"); // 并且通过串口输出断开连接信息\n    Serial.print(host);\n    \n  } else{    // 如果连接不成功则通过串口输出“连接失败”信息\n    Serial.println(\" connection failed!\");\n    client.stop();\n  }  \n}\n```\n\n\n\n### 信息类型\n\n#### getMode – 获取WiFi工作模式\n\n##### 说明\n\n获取ESP8266开发板的工作模式。\n\nESP8266开发板一共有三种工作模式。分别是：接入点模式（AP）、无线终端模式（Station）以及混合模式。\n\n如需了解更多有关ESP8266开发板的工作模式详细内容，请参考本站的\n[ESP8266-物联网开发基础视频教程](http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-iot-basics/)。其中“[NodeMCU开发板的接入点模式](http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/ap/)”部分有更多关于接入点模式的讲解。\n\n##### 语法\n\n```\nWiFi.getMode()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n以下是此函数的返回值以及对应的工作模式说明：\n0：WiFi关闭模式\n1：无线终端模式\n2：接入点模式\n3：接入点-无线终端混合模式\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分，该语句通过`WiFi.getMode()`获取ESP8266开发板的工作模式并且通过串口监视器输出。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiGeneric_demo_3\n程序目的/Purpose          : \n用于演示ESP8266WiFiGeneric库中getMode函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \n#define ssid   \"TaichiMaker_WIFI\"  // 这里定义将要建立的WiFi名称。此处以\"TaichiMaker_WIFI\"为示例\n                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中\n#define password  \"12345678\"        // 这里定义将要建立的WiFi密码。此处以12345678为示例\n                                    // 您可以将自己想要使用的WiFi密码放入引号内\n                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息\n \nvoid setup() { \n  Serial.begin(115200);         //打开串口\n  \n  WiFi.mode(WIFI_STA);          //设置设备的工作模式为无线终端模式\n    \n  WiFi.begin(ssid, password);   // 此语句是重点。WiFi.begin用于启动NodeMCU的无线终端模式。\n                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。\n                                // 这两个参数具体内容在setup函数之前的位置进行定义。\n    \n  while (WiFi.status() != WL_CONNECTED) {//等待WiFi连接\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.print(\"当前模式为： \");     // 通过串口监视器输出信息\n  Serial.println(WiFi.getMode());  // 告知用户设备当前工作模式\n \n  delay(5000);//延时便于查看效果\n  WiFi.mode(WIFI_OFF);             //设置设备的工作模式为关闭模式\n  Serial.print(\"当前模式为： \");       \n  Serial.println(WiFi.getMode());  // 告知用户设备当前工作模式\n}\n \nvoid loop(){}\n```\n\n\n\n## ESP8266WiFiMulti库\n\n当我们需要使用ESP8266开发板存储多个WiFi网络连接信息时，可以使用ESP8266WiFiMulti库来实现。\n\n以下为ESP8266WiFiMulti库的整体结构图。\n\n![image-20230526114832611](./Image/ESP8266.assets/image-20230526114832611.png)\n\n### 设置类型\n\n#### addAp – 添加 WiFi连接信息\n\n##### 说明\n\n当我们需要使用ESP8266开发板存储多个WiFi网络连接信息时，可以使用addAp来添加多个联网信息。ESP8266开发板在使用[run](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifimulti/run/)函数尝试联网时，会检查当前WiFi网络环境中有无addAp函数所添加的网络信息。如果找到一个或多个已经添加的网络，则自动连接信号最强的WiFi网络。\n\n##### 语法\n\n`wiFiMulti.addAP(ssid, password)`\n\n##### 参数\n\n- ssid：需要添加的WiFi网络名称\n- password：需要添加的WiFi网络密码\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n为模块添加WiFi信息，只要可以连接的wifi出现在环境中，搜索addAP函数所存储的WiFi。将会连接信号最强的那一个WiFi信号。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiMulti_demo_1\n程序目的/Purpose          : \n用于演示ESP8266WiFiMulti库中addAP函数\n***********************************************************************/\n \n#include \"ESP8266WiFiMulti.h\"\n \nESP8266WiFiMulti WiFiMulti;//实例化ESP8266WiFiMulti对象\n \nvoid setup() {\n  Serial.begin(115200);\n  delay(100);\n \n  //通过addAp函数存储  WiFi名称       WiFi密码\n  WiFiMulti.addAP(\"taichi-maker\", \"12345678\");  \n  WiFiMulti.addAP(\"taichi-maker2\", \"87654321\"); \n  WiFiMulti.addAP(\"taichi-maker3\", \"13572468\"); \n  // 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。\n  // 这3个WiFi网络名称分别是taichi-maker, taichi-maker2, taichi-maker3。\n  // 这3个网络的密码分别是123456789，87654321，13572468。\n  // 此处WiFi信息只是示例，请在使用时将需要连接的WiFi信息填入相应位置。\n  // 另外这里只存储了3个WiFi信息，您可以存储更多的WiFi信息在此处。\n    \n  while(WiFiMulti.run() != WL_CONNECTED) {\n    Serial.print(\".\");\n    delay(500);\n  } \n  // 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前\n  // 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU\n  // 将会连接信号最强的那一个WiFi信号。\n  // 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是\n  // 此处while循环判断是否跳出循环的条件。\n \n  Serial.println('\\n');                     // WiFi连接成功后\n  Serial.print(\"Connected to \");            // NodeMCU将通过串口监视器输出。\n  Serial.println(WiFi.SSID());              // 连接的WiFI名称\n  Serial.print(\"IP address:\\t\");            // 以及\n  Serial.println(WiFi.localIP());           // NodeMCU的IP地址\n}\n \nvoid loop() {}\n```\n\n\n\n#### run – 连接WiFi\n\n##### 说明\n\n当我们使用addAP函数为ESP8266开发板存储多个WiFi网络连接信息以后，可以使用run函数尝试联网。在联网过程中，ESP8266开发板会检查当前WiFi网络环境中有无addAp函数所添加的网络信息。如果找到一个或多个已经添加的网络，则自动连接信号最强的WiFi网络。\n\n##### 语法\n\n`wiFiMulti.run()`\n\n##### 参数\n\n无\n\n##### 返回值\n\n返回值为整数型,以下是返回值说明。\n\n- 0 : WL_IDLE_STATUS – 当WiFi正在状态之间切换时\n- 1 : WL_NO_SSID_AVAIL – 无法访问配置的SSID\n- 3 : WL_CONNECTED – 成功建立连接\n- 4 : WL_CONNECT_FAILED – 密码不正确\n- 6 : WL_DISCONNECTED – 模块未配置为无线终端模式\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiMulti_demo_2\n程序目的/Purpose          : \n用于演示ESP8266WiFiMulti库中run函数\n***********************************************************************/\n#include \"ESP8266WiFiMulti.h\"\n \nESP8266WiFiMulti WiFiMulti;//实例化ESP8266WiFiMulti对象\n \nvoid setup() {\n  Serial.begin(115200);\n  delay(100);\n \n  //通过addAp函数存储  WiFi名称       WiFi密码\n  WiFiMulti.addAP(\"taichi-maker\", \"12345678\");  \n  WiFiMulti.addAP(\"taichi-maker2\", \"87654321\"); \n  WiFiMulti.addAP(\"taichi-maker3\", \"13572468\"); \n  // 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。\n  // 这3个WiFi网络名称分别是taichi-maker, taichi-maker2, taichi-maker3。\n  // 这3个网络的密码分别是123456789，87654321，13572468。\n  // 此处WiFi信息只是示例，请在使用时将需要连接的WiFi信息填入相应位置。\n  // 另外这里只存储了3个WiFi信息，您可以存储更多的WiFi信息在此处。\n \n  Serial.println();\n  Serial.print(\"Wait for WiFi... \");\n \n  // 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前\n  // 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU\n  // 将会连接信号最强的那一个WiFi信号。\n  // 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是\n  // 此处while循环判断是否跳出循环的条件。\n  while(WiFiMulti.run() != WL_CONNECTED) {\n    Serial.print(\".\");\n    delay(500);\n  }\n \n  Serial.println('\\n');                     // WiFi连接成功后\n  Serial.print(\"Connected to \");            // NodeMCU将通过串口监视器输出。\n  Serial.println(WiFi.SSID());              // 连接的WiFI名称\n  Serial.print(\"IP address:\\t\");            // 以及\n  Serial.println(WiFi.localIP());           // NodeMCU的IP地址\n}\n \nvoid loop() {}\n```\n\n\n\n\n\n#### cleanAPlist – 清除WiFi连接信息\n\n##### 说明\n\n此函数可以删除ESP8266开发板WiFi连接列表中的WiFi连接信息。\n\n##### 语法\n\n```c\nWiFiMulti.cleanAPlist()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiMulti_demo_3\n程序目的/Purpose          : \n用于演示ESP8266WiFiMulti库中cleanAPlist函数\n***********************************************************************/\n#include \"ESP8266WiFiMulti.h\"\n \nESP8266WiFiMulti WiFiMulti;//实例化ESP8266WiFiMulti对象\n \nvoid setup() {\n  Serial.begin(115200);\n  delay(100);\n \n  //通过addAp函数存储  WiFi名称       WiFi密码\n  WiFiMulti.addAP(\"taichi-maker\", \"12345678\");  \n  WiFiMulti.addAP(\"taichi-maker2\", \"87654321\"); \n  WiFiMulti.addAP(\"taichi-maker3\", \"13572468\"); \n  // 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。\n  // 这3个WiFi网络名称分别是taichi-maker, taichi-maker2, taichi-maker3。\n  // 这3个网络的密码分别是123456789，87654321，13572468。\n  // 此处WiFi信息只是示例，请在使用时将需要连接的WiFi信息填入相应位置。\n  // 另外这里只存储了3个WiFi信息，您可以存储更多的WiFi信息在此处。\n    \n  WiFiMulti.cleanAPlist();\n  Serial.println(\"AP列表已删除\");\n  \n  //查看该接入点是否在接入点列表中\n  if(WiFiMulti.existsAP(\"taichi-maker\", \"12345678\")){\n    Serial.println(\"taichi-maker在列表中\");\n  }else{Serial.println(\"taichi-maker不在列表中\");}\n  \n  if(WiFiMulti.existsAP(\"taichi-maker\", \"12345678\")){\n    Serial.println(\"taichi-maker2在列表中\");\n  }else{Serial.println(\"taichi-maker2不在列表中\");}\n  \n  if(WiFiMulti.existsAP(\"taichi-maker\", \"12345678\")){\n    Serial.println(\"taichi-maker3在列表中\");\n  }else{Serial.println(\"taichi-maker3不在列表中\");}\n}\n \nvoid loop() {}\n```\n\n##### 相关内容\n\n– addAp – 添加 WiFi连接信息\n– run – 连接WiFi\n\n\n\n### 信息类型\n\n#### existsAP – 检查WiFi连接信息内容\n\n##### 说明\n\n此函数用于确认某一个接入点信息是否已经通过addAP函数添加到ESP8266开发板的联网信息列表中了。\n\n##### 语法\n\n`wiFiMulti.existsAP(ssid, password)`\n\n##### 参数\n\n- ssid：需要确认的WiFi网络名称\n- password：需要确认的WiFi网络密码\n\n\n##### 返回值\n\n返回值类型为布尔型。\n如果某一个接入点信息已经通过addAP函数添加到ESP8266开发板的联网信息列表中了，则返回值为true，否则返回值为false。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiMulti_demo_1\n程序目的/Purpose          : \n用于演示ESP8266WiFiMulti库中existsAP函数\n***********************************************************************/\n \n#include \"ESP8266WiFiMulti.h\"\nESP8266WiFiMulti WiFiMulti;\n \nvoid setup() {\n  Serial.begin(115200);\n  delay(100);\n  Serial.println(\" \");\n \n  //通过addAp函数存储  WiFi名称       WiFi密码\n  WiFiMulti.addAP(\"taichi-maker\", \"12345678\");  \n  WiFiMulti.addAP(\"taichi-maker2\", \"87654321\"); \n  WiFiMulti.addAP(\"taichi-maker3\", \"13572468\");\n  Serial.println(\"AP列表添加完毕\");\n  // 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。\n  // 这3个WiFi网络名称分别是taichi-maker, taichi-maker2, taichi-maker3。\n  // 这3个网络的密码分别是123456789，87654321，13572468。\n  // 此处WiFi信息只是示例，请在使用时将需要连接的WiFi信息填入相应位置。\n  // 另外这里只存储了3个WiFi信息，您可以存储更多的WiFi信息在此处。\n    \n  // 确认接入点列表中有无\"taichi-maker\"\n  if(WiFiMulti.existsAP(\"taichi-maker\", \"12345678\")){\n      Serial.println(\"taichi-maker在列表中\");\n  }else{Serial.println(\"taichi-maker不在列表中\");}\n  \n  // 确认接入点列表中有无\"测试WiFi\"\n  if(WiFiMulti.existsAP(\"测试WiFi\", \"12345678\")){\n      Serial.println(\"测试WiFi 在列表中\");\n  }else{Serial.println(\"测试WiFi 不在列表中\");}\n}\n \nvoid loop() {}\n```\n\n##### 相关内容\n\n– addAp – 添加 WiFi连接信息\n– run – 连接WiFi\n– cleanAPlist – 清除WiFi连接信息\n\n\n\n## ESP8266 – ESP8266WiFiScan库\n\nESP8266WiFiScan库用于ESP8266开发板扫描WiFi网络以及分析扫描到的WiFi网络信息。\n\n以下为ESP8266WiFiScan库的整体结构图。\n\n![image-20230526130913344](./Image/ESP8266.assets/image-20230526130913344.png)\n\n### 设置类型\n\n#### scanNetworks – 同步扫描WiFi网络\n\n##### 说明\n\n该函数可以扫描到ESP8266开发板所在环境中的可用WIFI网络，并且将WiFi网络信息保存到内存中。通过调用[SSID](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifista/ssid/)、[RSSI](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifiscan/8747-2/)等函数，我们还可以得到这些扫描到的WIFI的更多信息。\n\n此函数在扫描WiFi网络时采用同步扫描模式。与其相对应的还有[scanNetworksAsync](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifiscan/scannetworksasync/)异步扫描WiFi。\n\n所谓同步扫描就是每一次调用本函数时，ESP8266开发板会一次性得到完整的WiFi列表，并且将WiFi列表保存在内存中。\n\n##### 语法\n\n```\nWiFi.scanNetworks()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n返回值为扫描到可用的网络数量，数据类型为int8_t型。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiScan_demo_1\n程序目的/Purpose          : \n用于演示ESP8266WiFiScan库中scanNetworks函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \nvoid setup() {\n  Serial.begin(115200);  //设置串口波特率，以便打印信息\n  delay(1000);           //延时\n  WiFi.mode(WIFI_STA);   //设置为无线终端模式\n  WiFi.disconnect();     //断开，不连接到任何一个接入点\n  delay(100);\n  Serial.println(\"STA建立完成\");\n}\n \nvoid loop() {\n  Serial.println(\"同步扫描开始\");\n  int n = WiFi.scanNetworks();    //开始同步扫描，将返回值\n  Serial.println(\"同步扫描结束\");   //存放在变量n中\n  if (n == 0){\n    Serial.println(\"找不到网络\");\n  }else{\n    Serial.println(\"发现网络\");\n    for (int i = 0; i < n; ++i){  //开始逐个打印扫描到的\n      Serial.print(i + 1);        //接入点信息\n      Serial.print(\": \");\n      //打印wifi账号\n      Serial.print(WiFi.SSID(i));\n      //打印该接入点信道\n      Serial.print(String(\",   WIFI信道:\")+WiFi.channel(i));\n      Serial.print(\",   是否隐藏：\");\n      //打印该接入点是否隐藏\n      Serial.print(WiFi.isHidden(i)?\"隐藏\":\"显示\");\n      Serial.print(\",   信号强度：\");\n      //打印wifi信号强度\n      Serial.print(WiFi.RSSI(i));\n      Serial.print(\"dBm\");\n      Serial.print(\",   是否加密：\");\n      //打印wifi加密方式\n      Serial.println((WiFi.encryptionType(i) == ENC_TYPE_NONE)?\"开放\":\"加密\");\n      delay(10);\n    }\n  }\n  Serial.println(\"\");\n  delay(5000);// 延时5s之后再次扫描\n}\n```\n\n\n\n##### 相关内容\n\n– scanDelete\n– scanNetworksAsync\n\n\n\n#### scanNetworksAsync – 异步扫描WiFi网络\n\n##### 说明\n\n该函数可以扫描到ESP8266开发板所在环境中的可用WIFI网络，并且将WiFi网络信息保存到内存中。通过调用[SSID](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifista/ssid/)、[RSSI](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifiscan/8747-2/)等函数，我们还可以得到这些扫描到的WIFI信息。\n\n此函数在扫描WiFi网络时采用异步扫描模式。与其相对应的还有[scanNetworks](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifiscan/scannetworks/)同步扫描WiFi。\n\n所谓异步扫描是与同步扫描相对应的。在异步扫描模式下，ESP8266开发板每一次扫描到一个WiFi网络，即将该网络信息保存到开发板内存中。\n\n调用本函数时，需要提供一个回调函数作为参数。当所有WiFi网络都扫描完成以后，ESP8266开发板将会调用此回调函数。另外，在调用回调函数时，ESP8266开发板所扫描到的WiFi网络数量还会作为参数传递给该回调函数。\n\n##### 语法\n\n```c\nwifi.scanNetworksAsync(onComplete)\nwifi.scanNetworksAsync(scanResult, showHidden)\n```\n\n##### 参数\n\n`onComplete`：WiFi扫描结束后的回调函数（WiFi扫描 结束后将会调用此回调函数）\n\nshowHidden：此参数用于控制扫描过程中是否扫描隐藏WiFi网络。设置为true时，ESP8266开发板会扫描隐藏WiFi。默认为false。（参数类型：bool）\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiScan_demo_3\n程序目的/Purpose          : \n用于演示ESP8266WiFiScan库中scanNetworksAsync 函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \nvoid setup() {\n  Serial.begin(115200);  //设置串口波特率，以便打印信息\n  delay(1000);           //延时1s\n  WiFi.mode(WIFI_STA);   //设置为无线终端模式\n  WiFi.disconnect();     //断开，不连接到任何一个接入点\n  delay(100);\n  Serial.println(\"STA建立完成\");\n  Serial.println(\"异步扫描开始 ... \");\n  WiFi.scanNetworksAsync(onComplete);\n}\n \nvoid loop() {}\n \n//回调函数\nvoid onComplete(int n){\n  Serial.printf(\"扫描完成，共发现%d个网络\\n\", n);\n  for (int i = 0; i < n; i++)\n  {\n    Serial.print(i + 1);        //接入点信息\n    Serial.print(\": \");\n    //打印wifi账号\n    Serial.print(WiFi.SSID(i));\n    //打印该接入点信道\n    Serial.print(String(\",   WIFI信道:\")+WiFi.channel(i));\n    Serial.print(\",   是否隐藏：\");\n    //打印该接入点是否隐藏\n    Serial.print(WiFi.isHidden(i)?\"隐藏\":\"显示\");\n    Serial.print(\",   信号强度：\");\n    //打印wifi信号强度\n    Serial.print(WiFi.RSSI(i));\n    Serial.print(\"dBm\");\n    Serial.print(\",   是否加密：\");\n    //打印wifi加密方式\n    Serial.println((WiFi.encryptionType(i) == ENC_TYPE_NONE)?\"开放\":\"加密\");\n  }\n}\n```\n\n##### 相关内容\n\n– scanDelete\n– scanNetworks\n\n\n\n#### scanDelete – 删除扫描结果\n\n##### 说明\n\n此函数将清除掉ESP8266开发板通过扫描后储存在内存中的WiFi扫描结果。\n\n##### 语法\n\nwiFi.scanDelete()\n\n##### 参数\n\n无\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiScan_demo_4\n程序目的/Purpose          : \n用于演示ESP8266WiFiScan库中scanDelete函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \nlong lastScanMillis;\n \nvoid setup() {\n  Serial.begin(115200);  //设置串口波特率，以便打印信息\n  delay(5000);           //延时5s\n  WiFi.mode(WIFI_STA);   //设置为无线终端模式\n  WiFi.disconnect();     //断开，不连接到任何一个接入点\n  delay(100);\n  Serial.println(\"STA建立完成\");\n}\n \nvoid loop() {\n  long currentMillis = millis();//调用millis函数，获取当前时钟\n  if (currentMillis - lastScanMillis > 5000){//5s扫描一次\n    WiFi.scanNetworks(true);//开始异步扫描\n    Serial.println(\"异步扫描开始 ... \");\n    lastScanMillis = currentMillis;//保存当前时钟，进入下一次扫描\n  }\n \n  //检查异步扫描的结果，将返回值存放在变量n中\n  int n = WiFi.scanComplete();\n  if(n >= 0){\n    Serial.printf(\"发现%d个网络\\n\", n);\n    for (int i = 0; i < n; i++){\n      Serial.print(i + 1);        //接入点信息\n      Serial.print(\": \");\n      //打印wifi账号\n      Serial.println(WiFi.SSID(i));\n    }\n    Serial.println(\"\");\n    WiFi.scanDelete();//删除内存中保存结果\n  }\n}\n```\n\n\n\n### 信息类型\n\n#### getNetworkInfo – 获取扫描到的WiFi网络信息(网络名称，信号强度等）\n\n##### 说明\n\n当ESP8266开发板使用[scanNetworks](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifiscan/scannetworks/)或者[scanNetworksAsync](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifiscan/scannetworksasync/)对所处环境的WiFi网络进行扫描后，ESP8266开发板会将扫描到的网络信息保存在内存中。\n\n通过此函数，我们可以获取扫描到的WiFi的网络名称、加密类型、信号强度、MAC地址、网络信道、网络是否隐藏等信息。\n\n注：如需单独获取以上列出的WiFi信息中的某一项，可参考[ESP8266WiFiScan](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifiscan/)库中信息类型的其它函数内容。\n\n##### 语法\n\n```\nwiFi.getNetworkInfo(i, ssid, encryptionType, RSSI, BSSID, channel, isHidden)\n```\n\n##### 参数\n\ngetNetworkInfo函数会将WiFi网络信息存入参数中。这些参数的具体功能如下。\n\n- i：扫描到的接入点网络列表的序号（uint8_t型）\n- ssid：扫描到的接入点网络的网络名称（String型）\n- encryptionType：扫描到的接入点网络的加密类型（uint8_t型）\n- RSSI：扫描到的接入点网络的网络信号强度（int32_t型）\n- BSSID：扫描到的接入点网络的MAC地址(大小为6个元素的uint8数组指针)\n- channel：扫描到的接入点网络的网络通道(int32_t型)\n- isHidden：扫描到的接入点网络是否是隐藏网络(bool型)\n\n##### 返回值\n\n如果成功获取WiFi信息，则返回true，否则返回false。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiScan_demo_5\n程序目的/Purpose          : \n用于演示ESP8266WiFiScan库中encryptionType函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \nvoid setup() {\n  Serial.begin(115200);  //设置串口波特率，以便打印信息\n  delay(5000);           //延时5s\n  WiFi.mode(WIFI_STA);   //设置为无线终端模式\n  WiFi.disconnect();     //断开，不连接到任何一个接入点\n  delay(100);\n  Serial.println(\"STA建立完成\");\n}\n \nvoid loop() {\n  Serial.println(\"同步扫描开始\");\n  int n = WiFi.scanNetworks();    //开始同步扫描，将返回值\n  Serial.println(\"同步扫描结束\");   //存放在变量n中\n  if (n == 0){\n    Serial.println(\"找不到网络\");\n  }else{\n    Serial.println(\"发现网络\");\n    \n    // 建立一系列变量，用于存储网络信息\n    String ssid;            // 网络名称\n    uint8_t encryptionType; // 网络加密类型\n    int32_t RSSI;           // 网络信号强度\n    uint8_t* BSSID;         // 网络接入点设备mac地址\n    int32_t channel;        // 网络信道\n    bool isHidden;          // 网络是否隐藏\n    for (int i = 0; i < n; i++) //逐个打印扫描到的接入点信息\n    {\n       //获取扫描到的接入点网络信息(网络名称，信号强度等）\n       WiFi.getNetworkInfo(i, ssid, encryptionType, RSSI, BSSID, channel, isHidden);\n       //打印扫描到的接入点网络信息(网络名称，信号强度等）\n       Serial.printf(\"%d: %s, Ch:%d, (%ddBm) %s %s\\n\", i + 1, ssid.c_str(), channel, RSSI, encryptionType == ENC_TYPE_NONE ? \"开放\" : \"加密\", isHidden ? \"隐藏\" : \"显示\");\n    }\n    \n    Serial.println(\"\");\n    delay(5000);// 延时5s之后再次扫描\n  }\n}\n```\n\n##### 相关内容\n\n– SSID – 获取扫描到的WiFi网络名称\n– RSSI – 获取扫描到的WiFi网络信号强度\n– encryptionType – 获取扫描到的WiFi网络加密类型\n– BSSID / BSSIDstr – 获取扫描到的WiFi网络mac地址\n– channel – 获取扫描到的WiFi网络信道号\n– isHidden – 检查扫描到的WiFi网络是否是隐藏网络\n– scanComplete – 获取异步扫描结果或状态\n\n\n\n\n\n#### SSID – 获取扫描到的WiFi网络名称\n\n##### 说明\n\n当ESP8266开发板使用[scanNetworks](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifiscan/scannetworks/)或者[scanNetworksAsync](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifiscan/scannetworksasync/)对所处环境的WiFi网络进行扫描后，ESP8266开发板会将扫描到的网络信息保存在内存中。\n\n通过此函数，我们可以获取扫描到的WiFi网络信息中的网络名称(SSID)信息。\n\n##### 语法\n\nwiFi.SSID(val)\n\n##### 参数\n\nval：扫描到的WiFi网络信息序号（类型：uint8_t ）\n\n##### 返回值\n\n扫描到的WiFi网络信息中的网络名称(SSID)信息(类型：String)\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiScan_demo_1\n程序目的/Purpose          : \n用于演示ESP8266WiFiScan库中SSID函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \nvoid setup() {\n  Serial.begin(115200);  //设置串口波特率，以便打印信息\n  delay(1000);           //延时1s\n  WiFi.mode(WIFI_STA);   //设置为无线终端模式\n  WiFi.disconnect();     //断开，不连接到任何一个接入点\n  delay(100);\n  Serial.println(\"STA建立完成\");\n}\n \nvoid loop() {\n  Serial.println(\"同步扫描开始\");\n  int n = WiFi.scanNetworks();    //开始同步扫描，将返回值\n  Serial.println(\"同步扫描结束\");   //存放在变量n中\n  if (n == 0){\n    Serial.println(\"找不到网络\");\n  }else{\n    Serial.println(\"发现网络\");\n    for (int i = 0; i < n; ++i){  //开始逐个打印扫描到的\n      Serial.print(i + 1);        //接入点信息\n      Serial.print(\": \");\n      //打印wifi账号\n      Serial.println(WiFi.SSID(i));\n      delay(10);\n    }\n  }\n  Serial.println(\"\");\n  delay(5000);// 延时5s之后再次扫描\n}\n```\n\n\n\n#### RSSI – 获取扫描到的WiFi网络信号强度\n\n##### 说明\n\n当ESP8266开发板使用scanNetworks或者scanNetworksAsync对所处环境的WiFi网络进行扫描后，ESP8266开发板会将扫描到的网络信息保存在内存中。\n\n通过此函数，我们可以获取扫描到的WiFi网络信息中的网络信号强度。\n\n##### 语法\n\n`wiFi.RSSI(val)`\n\n##### 参数\n\nval：扫描到的WiFi网络信息序号（类型：uint8_t）\n\n##### 返回值\n\n扫描到的WiFi网络信息中的网络信号长度(类型：int32_t)\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiScan_demo_2\n程序目的/Purpose          : \n用于演示ESP8266WiFiScan库中RSSI函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \nvoid setup() {\n  Serial.begin(115200);  //设置串口波特率，以便打印信息\n  delay(1000);           //延时1s\n  WiFi.mode(WIFI_STA);   //设置为无线终端模式\n  WiFi.disconnect();     //断开，不连接到任何一个接入点\n  delay(100);\n  Serial.println(\"STA建立完成\");\n}\n \nvoid loop() {\n  Serial.println(\"同步扫描开始\");\n  int n = WiFi.scanNetworks();    //开始同步扫描，将返回值\n  Serial.println(\"同步扫描结束\");   //存放在变量n中\n  if (n == 0){\n    Serial.println(\"找不到网络\");\n  }else{\n    Serial.println(\"发现网络\");\n    for (int i = 0; i < n; ++i){  //开始逐个打印扫描到的\n      Serial.print(i + 1);        //接入点信息\n      Serial.print(\": \");\n      //打印wifi账号\n      Serial.print(WiFi.SSID(i));\n      Serial.print(\",   信号强度：\");\n      //打印wifi信号强度\n      Serial.print(WiFi.RSSI(i));\n      Serial.println(\"dBm\");\n      delay(10);\n    }\n  }\n  Serial.println(\"\");\n  delay(5000);// 延时5s之后再次扫描\n}\n```\n\n##### 相关内容\n\n– getNetworkInfo – 获取扫描到的WiFi网络信息(网络名称，信号强度等）\n– SSID – 获取扫描到的WiFi网络名称\n– encryptionType – 获取扫描到的WiFi网络加密类型\n– BSSID / BSSIDstr – 获取扫描到的WiFi网络mac地址\n– channel – 获取扫描到的WiFi网络信道号\n– isHidden – 检查扫描到的WiFi网络是否是隐藏网络\n– scanComplete – 获取异步扫描结果或状态\n\n\n\n#### encryptionType – 获取扫描到的WiFi网络加密类型\n\n##### 说明\n\n当ESP8266开发板使用[scanNetworks](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifiscan/scannetworks/)或者[scanNetworksAsync](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifiscan/scannetworksasync/)对所处环境的WiFi网络进行扫描后，ESP8266开发板会将扫描到的网络信息保存在内存中。\n\n通过此函数，我们可以获取扫描到的WiFi网络信息中的网络加密类型。\n\n##### 语法\n\n```\nwiFi.encryptionType(val)\n```\n\n##### 参数\n\nval：扫描到的WiFi网络信息序号（类型：uint8_t）\n\n##### 返回值\n\n返回值类型为uint8_t，以下是返回值数值以及相应的说明信息。\n\n5：`ENC_TYPE_WEP`-WEP加密类型\n\n2：`ENC_TYPE_TKIP`-WPA/PSK加密类型\n\n4：`ENC_TYPE_CCMP`-WPA 2/PSK加密类型\n\n7：`ENC_TYPE_NONE`-开放网络\n\n8：`ENC_TYPE_AUTO`-WPA/WPA 2/PSK加密类型\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiScan_demo_3\n程序目的/Purpose          : \n用于演示ESP8266WiFiScan库中encryptionType函数\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \nvoid setup() {\n  Serial.begin(115200);  //设置串口波特率，以便打印信息\n  delay(1000);           //延时1s\n  WiFi.mode(WIFI_STA);   //设置为无线终端模式\n  WiFi.disconnect();     //断开，不连接到任何一个接入点\n  delay(100);\n  Serial.println(\"STA建立完成\");\n}\n \nvoid loop() {\n  Serial.println(\"同步扫描开始\");\n  int n = WiFi.scanNetworks();    //开始同步扫描，将返回值\n  Serial.println(\"同步扫描结束\");   //存放在变量n中\n  if (n == 0){\n    Serial.println(\"找不到网络\");\n  }else{\n    Serial.println(\"发现网络\");\n    for (int i = 0; i < n; ++i){  //开始逐个打印扫描到的\n      Serial.print(i + 1);        //接入点信息\n      Serial.print(\": \");\n      //打印wifi账号\n      Serial.print(WiFi.SSID(i));\n      Serial.print(\",   是否加密：\");\n      //打印wifi加密方式\n      Serial.println((WiFi.encryptionType(i) == ENC_TYPE_NONE)?\"开放\":\"加密\");\n      delay(10);\n    }\n  }\n  Serial.println(\"\");\n  delay(5000);// 延时5s之后再次扫描\n}\n```\n\n##### 相关内容\n\n– getNetworkInfo – 获取扫描到的WiFi网络信息(网络名称，信号强度等）\n– SSID – 获取扫描到的WiFi网络名称\n– RSSI – 获取扫描到的WiFi网络信号强度\n– BSSID / BSSIDstr – 获取扫描到的WiFi网络mac地址\n– channel – 获取扫描到的WiFi网络信道号\n– isHidden – 检查扫描到的WiFi网络是否是隐藏网络\n– scanComplete – 获取异步扫描结果或状态\n\n\n\n#### BSSID / BSSIDstr – 获取扫描到的WiFi网络mac地址\n\n##### 说明\n\n当ESP8266开发板使用[scanNetworks](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifiscan/scannetworks/)或者[scanNetworksAsync](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifiscan/scannetworksasync/)对所处环境的WiFi网络进行扫描后，ESP8266开发板会将扫描到的网络信息保存在内存中。\n\n通过BSSID函数和BSSIDstr函数，我们可以获取扫描到的WiFi网络接入点设备的mac地址。虽然这两个函数功能相同，但是它们的返回值类型是不同的。\n\nBSSIDstr函数以字符串形式将WiFi接入点设备mac地址返回。\n\nBSSID函数的返回值是存储WiFi接入点设备mac地址信息的内存位置，即一个大小为6个元素的uint8数组指针。\n\n##### 语法\n\n`WiFi.BSSID(val)`\n`WiFi.BSSIDstr(val)`\n\n##### 参数\n\nval：扫描到的WiFi网络信息序号（类型：uint8_t ）\n\n##### 返回值\n\nBSSIDstr函数以字符串形式将WiFi接入点设备mac地址返回。\n\nBSSID函数的返回值是存储WiFi接入点设备mac地址信息的内存位置，即一个大小为6个元素的uint8数组指针。\n\n##### 示例程序\n\n**BSSID函数示例**\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiScan_demo_4\n程序目的/Purpose          : \n用于演示ESP8266WiFiScan库中BSSID函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \nvoid setup() {\n  Serial.begin(115200);  //设置串口波特率，以便打印信息\n  delay(5000);           //延时5s\n  WiFi.mode(WIFI_STA);   //设置为无线终端模式\n  WiFi.disconnect();     //断开，不连接到任何一个接入点\n  delay(100);\n  Serial.println(\"STA建立完成\");\n}\n \nvoid loop() {\n  Serial.println(\"同步扫描开始\");\n  int n = WiFi.scanNetworks();    //开始同步扫描，将返回值\n  Serial.println(\"同步扫描结束\");   //存放在变量n中\n  if (n == 0){\n    Serial.println(\"找不到网络\");\n  }else{\n    Serial.println(\"发现网络\");\n    for (int i = 0; i < n; ++i){  //开始逐个打印扫描到的\n      Serial.print(i + 1);        //接入点信息\n      Serial.print(\": \");\n      //打印wifi账号\n      Serial.print(WiFi.SSID(i));\n      Serial.print(\",   mac地址：\");\n      Serial.printf(\"%p\",WiFi.BSSID(i));//BSSID返回网络的MAC地址。\n      Serial.println(\"\");\n    }\n  }\n  Serial.println(\"\");\n  delay(5000);//延时5s之后再次扫描\n}\n```\n\n\n\n**BSSIDstr**\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiScan_demo_4\n程序目的/Purpose          : \n用于演示ESP8266WiFiScan库中BSSIDstr函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \nvoid setup() {\n  Serial.begin(115200);  //设置串口波特率，以便打印信息\n  delay(5000);           //延时5s\n  WiFi.mode(WIFI_STA);   //设置为无线终端模式\n  WiFi.disconnect();     //断开，不连接到任何一个接入点\n  delay(100);\n  Serial.println(\"STA建立完成\");\n}\n \nvoid loop() {\n  Serial.println(\"同步扫描开始\");\n  int n = WiFi.scanNetworks();    //开始同步扫描，将返回值\n  Serial.println(\"同步扫描结束\");   //存放在变量n中\n  if (n == 0){\n    Serial.println(\"找不到网络\");\n  }else{\n    Serial.println(\"发现网络\");\n    for (int i = 0; i < n; ++i){  //开始逐个打印扫描到的\n      Serial.print(i + 1);        //接入点信息\n      Serial.print(\": \");\n      //打印wifi账号\n      Serial.print(WiFi.SSID(i));\n      Serial.print(\",   mac为：\");\n      Serial.println(WiFi.BSSIDstr(i));//BSSIDstr返回网络的MAC地址的字符串。\n    }\n  }\n  Serial.println(\"\");\n  delay(5000);//延时5s之后再次扫描\n}\n```\n\n\n\n##### 相关内容\n\n– getNetworkInfo – 获取扫描到的WiFi网络信息(网络名称，信号强度等）\n– SSID – 获取扫描到的WiFi网络名称\n– RSSI – 获取扫描到的WiFi网络信号强度\n– encryptionType – 获取扫描到的WiFi网络加密类型\n– channel – 获取扫描到的WiFi网络信道号\n– isHidden – 检查扫描到的WiFi网络是否是隐藏网络\n– scanComplete – 获取异步扫描结果或状态\n\n\n\n\n\n\n\n#### channel – 获取扫描到的WiFi网络信道号\n\n##### 说明\n\n当ESP8266开发板使用[scanNetworks](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifiscan/scannetworks/)或者[scanNetworksAsync](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifiscan/scannetworksasync/)对所处环境的WiFi网络进行扫描后，ESP8266开发板会将扫描到的网络信息保存在内存中。\n\n通过此函数，我们可以获取扫描到的WiFi网络信息中的WiFi网络信道号。\n\n##### 语法\n\nwiFi.channel(val)\n\n##### 参数\n\nval：扫描到的WiFi网络信息序号（类型：uint8_t ）\n\n##### 返回值\n\n扫描到的WiFi网络信息中的网络信道号(类型：uint8_t)\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiScan_demo_3\n程序目的/Purpose          : \n用于演示ESP8266WiFiScan库中encryptionType函数\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \nvoid setup() {\n  Serial.begin(115200);  //设置串口波特率，以便打印信息\n  delay(5000);           //延时5s\n  WiFi.mode(WIFI_STA);   //设置为无线终端模式\n  WiFi.disconnect();     //断开，不连接到任何一个接入点\n  delay(100);\n  Serial.println(\"STA建立完成\");\n}\n \nvoid loop() {\n  Serial.println(\"同步扫描开始\");\n  int n = WiFi.scanNetworks();    //开始同步扫描，将返回值\n  Serial.println(\"同步扫描结束\");   //存放在变量n中\n  if (n == 0){\n    Serial.println(\"找不到网络\");\n  }else{\n    Serial.println(\"发现网络\");\n    for (int i = 0; i < n; ++i){  //开始逐个打印扫描到的\n      Serial.print(i + 1);        //接入点信息\n      Serial.print(\": \");\n      //打印wifi账号\n      Serial.print(WiFi.SSID(i));\n      Serial.print(String(\",   WIFI信道:\")+WiFi.channel(i));\n    }\n  }\n  Serial.println(\"\");\n  delay(5000);// 延时5s之后再次扫描\n}\n```\n\n\n\n##### 相关内容\n\n– getNetworkInfo – 获取扫描到的WiFi网络信息(网络名称，信号强度等）\n– SSID – 获取扫描到的WiFi网络名称\n– RSSI – 获取扫描到的WiFi网络信号强度\n– encryptionType – 获取扫描到的WiFi网络加密类型\n– BSSID / BSSIDstr – 获取扫描到的WiFi网络mac地址\n– isHidden – 检查扫描到的WiFi网络是否是隐藏网络\n– scanComplete – 获取异步扫描结果或状态\n\n\n\n\n\n\n\n#### isHidden – 检查扫描到的WiFi网络是否是隐藏网络\n\n##### 说明\n\n当ESP8266开发板使用[scanNetworks](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifiscan/scannetworks/)或者[scanNetworksAsync](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifiscan/scannetworksasync/)对所处环境的WiFi网络进行扫描后，ESP8266开发板会将扫描到的网络信息保存在内存中。\n\n通过此函数，我们可以获取WiFi网络是否是隐藏WiFi这一状态信息。\n\n##### 语法\n\n```\nwiFi.isHidden(val)\n```\n\n##### 参数\n\nval：扫描到的WiFi网络信息序号（类型：uint8_t ）\n\n##### 返回值\n\n扫描到的WiFi网络是否为隐藏的这一状态信息(类型：bool)\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiScan_demo_7\n程序目的/Purpose          : \n用于演示ESP8266WiFiScan库中isHidden函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \nvoid setup() {\n  Serial.begin(115200);  //设置串口波特率，以便打印信息\n  delay(5000);           //延时5s\n  WiFi.mode(WIFI_STA);   //设置为无线终端模式\n  WiFi.disconnect();     //断开，不连接到任何一个接入点\n  delay(100);\n  Serial.println(\"STA建立完成\");\n}\n \nvoid loop() {\n  Serial.println(\"同步扫描开始\");\n  int n = WiFi.scanNetworks();    //开始同步扫描，将返回值\n  Serial.println(\"同步扫描结束\");   //存放在变量n中\n  if (n == 0){\n    Serial.println(\"找不到网络\");\n  }else{\n    Serial.println(\"发现网络\");\n    for (int i = 0; i < n; ++i){  //开始逐个打印扫描到的\n      Serial.print(i + 1);        //接入点信息\n      Serial.print(\": \");\n      //打印wifi账号\n      Serial.print(WiFi.SSID(i));\n      Serial.print(\",   是否隐藏：\");\n      Serial.println(WiFi.isHidden(i)?\"隐藏\":\"显示\");\n      delay(10);\n    }\n  }\n  Serial.println(\"\");\n  delay(5000);// 延时5s之后再次扫描\n}\n```\n\n\n\n#### scanComplete – 获取异步扫描结果或状态\n\n##### 说明\n\n此函数用于获取扫描中扫描到的WiFi网络数量。\n\n注：如需了解更多异步扫描信息，请参考[scanNetworksAsync](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266wifiscan/scannetworksasync/)函数\n\n##### 语法\n\n```\nwiFi.scanComplete()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n扫描到的网络数量（int8_t类型）\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiScan_demo_8\n程序目的/Purpose          : \n用于演示ESP8266WiFiScan库中scanComplete函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n \nlong lastScanMillis;\n \nvoid setup() {\n  Serial.begin(115200);  //设置串口波特率，以便打印信息\n  delay(5000);           //延时5s\n  WiFi.mode(WIFI_STA);   //设置为无线终端模式\n  WiFi.disconnect();     //断开，不连接到任何一个接入点\n  delay(100);\n  Serial.println(\"STA建立完成\");\n}\n \nvoid loop() {\n  long currentMillis = millis();//调用millis函数，获取当前时钟\n  if (currentMillis - lastScanMillis > 5000){//5s扫描一次\n    WiFi.scanNetworks(true);//开始异步扫描\n    Serial.println(\"异步扫描开始 ... \");\n    lastScanMillis = currentMillis;//保存当前时钟，进入下一次扫描\n  }\n \n  //检查异步扫描的结果，将返回值存放在变量n中\n  int n = WiFi.scanComplete();\n  if(n >= 0){\n    Serial.printf(\"发现%d个网络\\n\", n);\n    for (int i = 0; i < n; i++){\n      Serial.print(i + 1);\n      Serial.print(\": \");\n      //打印wifi账号\n      Serial.println(WiFi.SSID(i));\n    }\n    Serial.println(\"\");\n    WiFi.scanDelete();//打印完一次扫描结果之后，删除内存保存结果\n  }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n## ESP8266 – WiFiClient库\n\nWiFiClient库用于ESP8266的TCP协议物联网通讯。通过WiFiClient库，可以使用ESP8266利用互联网或局域网向网络服务器发送请求，从而获取网络信息，实现物联网应用。\n\nESP8266库中还有一个专门用于HTTP通讯的[ESP8266HTTPClient库 ](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266httpclient/)。HTTP协议是建立在TCP协议基础之上的，我们也可以使用ESP8266HTTPClient库来通过HTTP协议向网络服务器发送请求。WiFiClient库与[ESP8266HTTPClient库 ](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266httpclient/)在功能上形成了互补。\n\n以下为WiFiClient库的整体结构图。在此图下方有WiFiClient库的函数目录。\n\n![image-20230525093748647](./Image/ESP8266.assets/image-20230525093748647.png)\n\n**请留意，WiFiServer对象在处理或发送网络数据时，可以通过调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)中的函数来实现。因此在以下结构图中的“发送数据类型”以及“响应信息操作类型”中有“Stream类”作为这种类型函数的一部分。**\n\n\n\n### 连接服务器类型\n\n#### 设置类型\n\n##### connect – 连接服务器\n\n###### 说明\n\nconnect函数用于ESP8266开发板通过TCP协议连接网络服务器。\n\n###### 语法\n\n```c\nclient.connect(ip, port);\n```\n\n###### 参数\n\n- ip:所要连接的服务器地址。\n  注：在定义参数ip的时候可使用String、const char。如下所示：\n  `const char * ip = \"47.92.129.18\";`\n  `String ip = \"www.ranye-iot.com\";`\n- port:所要连接的服务器端口号,允许使用int类型。\n\n###### 返回值\n\n连接失败返回0，连接成功返回1。返回值数据类型是bool型。\n\n###### 示例代码\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266随即会尝试连接www.example.com网站服务器。以下程序使用了client.connect(host, port)来实现这一操作。如果服务器连接成功，则client.connect(host, port)语句将会返回true。\n\n```c\n/**********************************************************************\n程序名称/Program name     : TCP_Client_connect\n程序目的/Purpose          : \n用于演示WiFiClient库中connect函数\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WiFiMulti.h>\n \nESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象\n \nconst char* host = \"www.example.com\"; // 网络服务器地址\nconst int httpPort = 80;              // http端口80\n \n// WiFi连接信息\nconst char*  WiFi_SSID = \"TaichiMaker\";\nconst char*  WiFi_Password = \"12345678\";\n \nvoid setup(){\n  Serial.begin(9600);          \n  WiFi.mode(WIFI_STA);    // 设置ESP8266为无线终端模式\n  \n  wifiMulti.addAP(WiFi_SSID, WiFi_Password); \n  Serial.println(\"Connecting ...\"); \n \n  // 尝试进行wifi连接。\n  int i = 0;  \n  while (wifiMulti.run() != WL_CONNECTED) { \n    delay(1000);\n    Serial.print(i++); Serial.print(' ');\n  }\n  \n  // WiFi连接成功后将通过串口监视器输出连接成功信息 \n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(WiFi.SSID());              // WiFi名称\n  Serial.print(\"IP address:\\t\");\n  Serial.println(WiFi.localIP());           // IP\n}\n \nvoid loop(){\n  // 发送HTTP请求\n  httpRequest();    \n  \n  delay(10000);\n}\n \n// 向服务器发送HTTP请求\nvoid httpRequest(){\n  // 建立WiFi客户端对象，对象名称client\n  WiFiClient client;    \n \n  // 建立字符串，用于HTTP请求\n  String httpRequest =  String(\"GET /\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  \n  // 通过串口输出连接服务器名称以便查阅连接服务器的网址                      \n  Serial.print(\"Connecting to \"); \n  Serial.print(host); \n \n  // 连接网络服务器，以下段落中的示例程序为本程序重点1\n  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n  if (client.connect(host, httpPort)){ \n    Serial.println(\" Success!\");        // 连接成功后串口输出“Success”信息\n    \n    client.print(httpRequest);          // 向服务器发送合同谈判请求\n    Serial.println(\"Sending request: \");// 通过串口输出HTTP请求信息内容以便查阅\n    Serial.println(httpRequest);     \n    \n    // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2\n    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n    Serial.println(\"Web Server Response:\");        \n    while (client.connected() || client.available()){ \n      if (client.available()){\n        String line = client.readStringUntil('\\n');\n        Serial.println(line);\n      }\n    }\n    \n    client.stop();                      // 断开与服务器的连接\n    Serial.print(\"Disconnected from \"); // 并且通过串口输出断开连接信息\n    Serial.print(host);\n    \n  } else{    // 如果连接不成功则通过串口输出“连接失败”信息\n    Serial.println(\" connection failed!\");\n    client.stop();\n  }  \n}\n```\n\n\n\n##### stop – 停止客户端\n\n###### 说明\n\nstop函数用于停止ESP8266连接TCP服务器。\n\n###### 语法\n\n```\nclient.stop()\n```\n\n###### 参数\n\n无\n\n###### 示例代码\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266随即会尝试连接www.example.com网站服务器。如果服务器连接成功，\n\n```c\n/**********************************************************************\n项目名称/Project          : 零基础入门学用物联网\n程序名称/Program name     : TCP_Client_stop\n团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)\n作者/Author              : Dapenson\n日期/Date（YYYYMMDD）     : 20200317\n程序目的/Purpose          : \n用于演示WiFiClient库中connect函数\n-----------------------------------------------------------------------\n修订历史/Revision History  \n日期/Date    作者/Author      参考号/Ref    修订说明/Revision Description\n20200410      CYNO朔           001        将服务器响应信息输出过程使用stream类函数实现\n-----------------------------------------------------------------------\n本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。\n该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：\nhttp://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WiFiMulti.h>\n \nESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象\n \nconst char* host = \"www.example.com\"; // 网络服务器地址\nconst int httpPort = 80;              // http端口80\n \n// WiFi连接信息\nconst char*  WiFi_SSID = \"TaichiMaker\";\nconst char*  WiFi_Password = \"12345678\";\n \nvoid setup(){\n  Serial.begin(9600);          \n  WiFi.mode(WIFI_STA);    // 设置ESP8266为无线终端模式\n  \n  wifiMulti.addAP(WiFi_SSID, WiFi_Password); \n  Serial.println(\"Connecting ...\"); \n \n  // 尝试进行wifi连接。\n  int i = 0;  \n  while (wifiMulti.run() != WL_CONNECTED) { \n    delay(1000);\n    Serial.print(i++); Serial.print(' ');\n  }\n  \n  // WiFi连接成功后将通过串口监视器输出连接成功信息 \n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(WiFi.SSID());              // WiFi名称\n  Serial.print(\"IP address:\\t\");\n  Serial.println(WiFi.localIP());           // IP\n}\n \nvoid loop(){\n  // 发送HTTP请求\n  httpRequest();    \n  \n  delay(10000);\n}\n \n// 向服务器发送HTTP请求\nvoid httpRequest(){\n  // 建立WiFi客户端对象，对象名称client\n  WiFiClient client;    \n \n  // 建立字符串，用于HTTP请求\n  String httpRequest =  String(\"GET /\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  \n  // 通过串口输出连接服务器名称以便查阅连接服务器的网址                      \n  Serial.print(\"Connecting to \"); \n  Serial.print(host); \n \n  // 连接网络服务器，以下段落中的示例程序为本程序重点1\n  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n  if (client.connect(host, httpPort)){ \n    Serial.println(\" Success!\");        // 连接成功后串口输出“Success”信息\n    \n    client.print(httpRequest);          // 向服务器发送合同谈判请求\n    Serial.println(\"Sending request: \");// 通过串口输出HTTP请求信息内容以便查阅\n    Serial.println(httpRequest);     \n    \n    // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2\n    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n    Serial.println(\"Web Server Response:\");        \n    while (client.connected() || client.available()){ \n      if (client.available()){\n        String line = client.readStringUntil('\\n');\n        Serial.println(line);\n      }\n    }\n    \n    client.stop();                      // 断开与服务器的连接\n    Serial.print(\"Disconnected from \"); // 并且通过串口输出断开连接信息\n    Serial.print(host);\n    \n  } else{    // 如果连接不成功则通过串口输出“连接失败”信息\n    Serial.println(\" connection failed!\");\n    client.stop();\n  }  \n}\n```\n\n###### 相关内容\n\n— connect – 连接服务器\n— connected – 检查是否成功连接服务器\n\n\n\n##### setNoDelay- 停止小包合并发送\n\n###### 说明\n\nsetNoDelay()用于与TCP服务器通讯时 ，是否禁用 Nagle 算法。Nagle 算法的目的是通过合并一些小的发送消息，然后一次性发送所有的消息来减少通过网络发送的小数据包的tcp/ip流量。\n\n###### 语法\n\nclient.setNoDelay(true);\n\n###### 语法\n\n数据类型：bool\n\n```c\nserver.setNoDelay(true);//true 表示禁用 Nagle 算法，合并一些小的消息\nserver.setNoDelay(false);//false 表示启用 Nagle 算法，消息直接发送\n```\n\n\n\n#### 信息类型\n\n##### connected – 检查是否成功连接服务器\n\n###### 说明\n\nconnected 函数用于检查设备是否成功连接服务器。\n\n###### 语法\n\n`client.connected();`\n\n###### 返回值\n\n0:连接失败返回0\n1:连接成功返回1\n返回值数据类型：bool\n\n###### 示例代码\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : TCP_Client_connected\n程序目的/Purpose          : \n用于演示WiFiClient库中connect函数\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WiFiMulti.h>\n \nESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象\n \nconst char* host = \"www.example.com\"; // 网络服务器地址\nconst int httpPort = 80;              // http端口80\n \n// WiFi连接信息\nconst char*  WiFi_SSID = \"taichimaker\";\nconst char*  WiFi_Password = \"12345678\";\n \nvoid setup(){\n  Serial.begin(9600);          \n  WiFi.mode(WIFI_STA);    // 设置ESP8266为无线终端模式\n  \n  wifiMulti.addAP(WiFi_SSID, WiFi_Password); \n  Serial.println(\"Connecting ...\"); \n \n  // 尝试进行wifi连接。\n  int i = 0;  \n  while (wifiMulti.run() != WL_CONNECTED) { \n    delay(1000);\n    Serial.print(i++); Serial.print(' ');\n  }\n  \n  // WiFi连接成功后将通过串口监视器输出连接成功信息 \n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(WiFi.SSID());              // WiFi名称\n  Serial.print(\"IP address:\\t\");\n  Serial.println(WiFi.localIP());           // IP\n}\n \nvoid loop(){\n  // 发送HTTP请求\n  httpRequest();    \n  \n  delay(10000);\n}\n \n// 向服务器发送HTTP请求\nvoid httpRequest(){\n  // 建立WiFi客户端对象，对象名称client\n  WiFiClient client;    \n \n  // 建立字符串，用于HTTP请求\n  String httpRequest =  String(\"GET /\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  \n  // 通过串口输出连接服务器名称以便查阅连接服务器的网址                      \n  Serial.print(\"Connecting to \"); \n  Serial.print(host); \n \n  // 连接网络服务器，以下段落中的示例程序为本程序重点1\n  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n  if (client.connect(host, httpPort)){ \n    Serial.println(\" Success!\");        // 连接成功后串口输出“Success”信息\n    \n    client.print(httpRequest);          // 向服务器发送合同谈判请求\n    Serial.println(\"Sending request: \");// 通过串口输出HTTP请求信息内容以便查阅\n    Serial.println(httpRequest);     \n    \n    // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2\n    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n    Serial.println(\"Web Server Response:\");        \n    while (client.connected() || client.available()){ \n      if (client.available()){\n        String line = client.readStringUntil('\\n');\n        Serial.println(line);\n      }\n    }\n    \n    client.stop();                      // 断开与服务器的连接\n    Serial.print(\"Disconnected from \"); // 并且通过串口输出断开连接信息\n    Serial.print(host);\n    \n  } else{    // 如果连接不成功则通过串口输出“连接失败”信息\n    Serial.println(\" connection failed!\");\n    client.stop();\n  }  \n}\n```\n\n\n\n###### 相关内容\n\n— connect – 连接服务器\n— stop – 停止客户端\n\n\n\n##### status – 获取客户端运行状态\n\n###### 说明\n\nstatus函数用于获取设备与服务器的连接状态。\n\n###### 语法\n\n```\nclient.status();\n```\n\n###### 返回值\n\n- CLOSED = 0\n- LISTEN = 1\n- SYN_SENT = 2\n- SYN_RCVD = 3\n- ESTABLISHED = 4\n- FIN_WAIT_1 = 5\n- FIN_WAIT_2 = 6\n- CLOSE_WAIT = 7\n- CLOSING = 8\n- LAST_ACK = 9\n- TIME_WAIT = 10\n\n###### 示例代码\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```C\n/**********************************************************************\n项目名称/Project          : 零基础入门学用物联网\n程序名称/Program name     : TCP_Client_status\n团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)\n作者/Author              : Dapenson\n日期/Date（YYYYMMDD）     : 20200317\n程序目的/Purpose          : \n用于演示WiFiClient库中connect函数\n-----------------------------------------------------------------------\n修订历史/Revision History  \n日期/Date    作者/Author      参考号/Ref    修订说明/Revision Description\n20200410      CYNO朔           001        将服务器响应信息输出过程使用stream类函数实现\n-----------------------------------------------------------------------\n本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。\n该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：\nhttp://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WiFiMulti.h>\n \nESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象\n \nconst char* host = \"www.example.com\"; // 网络服务器地址\nconst int httpPort = 80;              // http端口80\n \n// WiFi连接信息\nconst char*  WiFi_SSID = \"taichimaker\";\nconst char*  WiFi_Password = \"12345678\";\n \nvoid setup(){\n  Serial.begin(9600);          \n  WiFi.mode(WIFI_STA);    // 设置ESP8266为无线终端模式\n  \n  wifiMulti.addAP(WiFi_SSID, WiFi_Password); \n  Serial.println(\"Connecting ...\"); \n \n  // 尝试进行wifi连接。\n  int i = 0;  \n  while (wifiMulti.run() != WL_CONNECTED) { \n    delay(1000);\n    Serial.print(i++); Serial.print(' ');\n  }\n  \n  // WiFi连接成功后将通过串口监视器输出连接成功信息 \n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(WiFi.SSID());              // WiFi名称\n  Serial.print(\"IP address:\\t\");\n  Serial.println(WiFi.localIP());           // IP\n}\n \nvoid loop(){\n  // 发送HTTP请求\n  httpRequest();    \n  \n  delay(10000);\n}\n \n// 向服务器发送HTTP请求\nvoid httpRequest(){\n  // 建立WiFi客户端对象，对象名称client\n  WiFiClient client;    \n \n  // 建立字符串，用于HTTP请求\n  String httpRequest =  String(\"GET /\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  \n  // 通过串口输出连接服务器名称以便查阅连接服务器的网址                      \n  Serial.print(\"Connecting to \"); \n  Serial.print(host); \n \n  // 连接网络服务器，以下段落中的示例程序为本程序重点1\n  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n  if (client.connect(host, httpPort)){ \n    Serial.println(\" Success!\");        // 连接成功后串口输出“Success”信息\n    \n    client.print(httpRequest);          // 向服务器发送合同谈判请求\n    Serial.println(\"Sending request: \");// 通过串口输出HTTP请求信息内容以便查阅\n    Serial.println(httpRequest);     \n    \n    // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2\n    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n    Serial.println(\"Web Server Response:\");        \n    while (client.connected() || client.available()){ \n      if (client.available()){\n        String line = client.readStringUntil('\\n');\n        Serial.println(line);\n      }\n    }\n    \n    Serial.print(\"Current Client Status: \");\n    Serial.println(client.status());    \n    \n    client.stop();                      // 断开与服务器的连接\n    Serial.print(\"Disconnected from \"); // 并且通过串口输出断开连接信息\n    Serial.print(host);\n    \n    Serial.println(\"\");\n \n    Serial.print(\"Current Client Status: \");\n    Serial.println(client.status());\n    \n  } else{    // 如果连接不成功则通过串口输出“连接失败”信息\n    Serial.println(\" connection failed!\");\n    client.stop();\n  }  \n}\n```\n\n###### 相关内容\n\n— connected – 检查是否成功连接服务器\n— connect – 连接服务器\n\n\n\n\n\n### 发送数据类型\n\n#### print – 发送信息（Stream类）\n\n##### 说明\n\nprint函数用于发送数据到已连接的服务器。print函数与[println](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wificlient/println/)函数功能十分相似。他们二者的区别是，println函数会在发送的数据结尾增加一个换行符（’\\n’），而print函数则不会。\n\n**请留意，WiFiClient库对象在处理或发送网络数据时，可以通过调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)中的函数来实现。本函数即是Stream类中的一员。**\n\n##### 语法\n\n```\nclient.print(val);\n```\n\n##### 参数\n\nval:所要发送的数据，可以是字符串、字符或者数值。\n\n##### 返回值\n\n无\n\n##### 示例代码\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```C\n/**********************************************************************\n程序名称/Program name     : TCP_Client_print\n程序目的/Purpose          : \n此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求。\n在发送HTTP请求时使用了print函数，从而演示该函数的使用方法。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WiFiMulti.h>\n \nESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象\n \nconst char* host = \"www.example.com\"; // 网络服务器地址\nconst int httpPort = 80;              // http端口80\n \n// WiFi连接信息\nconst char*  WiFi_SSID = \"TaichiMaker\";\nconst char*  WiFi_Password = \"12345678\";\n \nvoid setup(){\n  Serial.begin(9600);          \n  Serial.println(\"\");\n  \n  wifiMulti.addAP(WiFi_SSID, WiFi_Password); \n  Serial.println(\"Connecting ...\"); \n \n  // 尝试进行wifi连接。\n  int i = 0;  \n  while (wifiMulti.run() != WL_CONNECTED) { \n    delay(1000);\n    Serial.print(i++); Serial.print(' ');\n  }\n  \n  // WiFi连接成功后将通过串口监视器输出连接成功信息 \n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(WiFi.SSID());              // WiFi名称\n  Serial.print(\"IP address:\\t\");\n  Serial.println(WiFi.localIP());           // IP\n}\n \nvoid loop(){\n  // 发送HTTP请求\n  httpRequest();    \n  \n  delay(10000);\n}\n \n// 向服务器发送HTTP请求\nvoid httpRequest(){\n  // 建立WiFi客户端对象，对象名称client\n  WiFiClient client;    \n \n  // 建立字符串，用于HTTP请求\n  String httpRequest =  String(\"GET /\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  \n  // 通过串口输出连接服务器名称以便查阅连接服务器的网址                      \n  Serial.print(\"Connecting to \"); \n  Serial.print(host); \n \n  // 连接网络服务器，以下段落中的示例程序为本程序重点1\n  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n  if (client.connect(host, httpPort)){ \n    Serial.println(\" Success!\");        // 连接成功后串口输出“Success”信息\n    \n    client.print(httpRequest);          // 向服务器发送合同请求\n    Serial.println(\"Sending request: \");// 通过串口输出HTTP请求信息内容以便查阅\n    Serial.println(httpRequest);     \n    \n    // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2\n    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n    Serial.println(\"Web Server Response:\");        \n    while (client.connected() || client.available()){ \n      if (client.available()){\n        String line = client.readStringUntil('\\n');\n        Serial.println(line);\n      }\n    }\n    \n    client.stop();                      // 断开与服务器的连接\n    Serial.print(\"Disconnected from \"); // 并且通过串口输出断开连接信息\n    Serial.print(host);\n    \n  } else{    // 如果连接不成功则通过串口输出“连接失败”信息\n    Serial.println(\" connection failed!\");\n    client.stop();\n  }  \n}\n```\n\n\n\n##### 相关内容\n\n— println – 发送信息（Stream类）\n— write – 发送信息（Stream类）\n— Stream类\n\n\n\n#### println – 发送信息（Stream类）\n\n##### 说明\n\nprintln函数用于发送数据到已连接的服务器。println函数与[print](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wificlient/print/)函数功能十分相似。他们二者的区别是，println函数会在发送的数据结尾增加一个换行符（’\\n’），而print函数则不会。\n\n**请留意，WiFiClient对象在处理或发送网络数据时，可以通过调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)中的函数来实现。本函数即是Stream类中的一员。**\n\n##### 语法\n\n```\nclient.println(val);\n```\n\n##### 参数\n\nval:所要发送的数据，可以是字符串、字符或者数值。\n\n##### 返回值\n\n无\n\n##### 示例代码\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```C\n/**********************************************************************\n项目名称/Project          : 零基础入门学用物联网\n程序名称/Program name     : TCP_Client_print\n团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)\n作者/Author              : Dapenson\n日期/Date（YYYYMMDD）     : 20200317\n程序目的/Purpose          : \n此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求。\n在发送HTTP请求时使用了println函数，从而演示该函数的使用方法。\n-----------------------------------------------------------------------\n修订历史/Revision History  \n日期/Date    作者/Author      参考号/Ref    修订说明/Revision Description\n20200410      CYNO朔           001        将服务器响应信息输出过程使用stream类函数实现\n-----------------------------------------------------------------------\n本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。\n该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：\nhttp://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WiFiMulti.h>\n \nESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象\n \nconst char* host = \"www.example.com\"; // 网络服务器地址\nconst int httpPort = 80;              // http端口80\n \n// WiFi连接信息\nconst char*  WiFi_SSID = \"taichimaker\";\nconst char*  WiFi_Password = \"12345678\";\n \nvoid setup(){\n  Serial.begin(9600);          \n  Serial.println(\"\");\n  \n  wifiMulti.addAP(WiFi_SSID, WiFi_Password); \n  Serial.println(\"Connecting ...\"); \n \n  // 尝试进行wifi连接。\n  int i = 0;  \n  while (wifiMulti.run() != WL_CONNECTED) { \n    delay(1000);\n    Serial.print(i++); Serial.print(' ');\n  }\n  \n  // WiFi连接成功后将通过串口监视器输出连接成功信息 \n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(WiFi.SSID());              // WiFi名称\n  Serial.print(\"IP address:\\t\");\n  Serial.println(WiFi.localIP());           // IP\n}\n \nvoid loop(){\n  // 发送HTTP请求\n  httpRequest();    \n  \n  delay(10000);\n}\n \n// 向服务器发送HTTP请求\nvoid httpRequest(){\n  // 建立WiFi客户端对象，对象名称client\n  WiFiClient client;    \n \n  // 建立字符串，用于HTTP请求\n  String httpRequest =  String(\"GET /\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  \n  // 通过串口输出连接服务器名称以便查阅连接服务器的网址                      \n  Serial.print(\"Connecting to \"); \n  Serial.print(host); \n \n  // 连接网络服务器，以下段落中的示例程序为本程序重点1\n  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n  if (client.connect(host, httpPort)){ \n    Serial.println(\" Success!\");        // 连接成功后串口输出“Success”信息\n    \n    client.print(httpRequest);          // 向服务器发送合同请求\n    Serial.println(\"Sending request: \");// 通过串口输出HTTP请求信息内容以便查阅\n    Serial.println(httpRequest);     \n    \n    // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2\n    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n    Serial.println(\"Web Server Response:\");        \n    while (client.connected() || client.available()){ \n      if (client.available()){\n        String line = client.readStringUntil('\\n');\n        Serial.println(line);\n      }\n    }\n    \n    client.stop();                      // 断开与服务器的连接\n    Serial.print(\"Disconnected from \"); // 并且通过串口输出断开连接信息\n    Serial.print(host);\n    \n  } else{    // 如果连接不成功则通过串口输出“连接失败”信息\n    Serial.println(\" connection failed!\");\n    client.stop();\n  }  \n}\n```\n\n\n\n##### 相关内容\n\n— print – 发送信息（Stream类）\n— write – 发送信息（Stream类）\n— Stream类\n\n\n\n\n\n#### write – 发送信息（Stream类）\n\n##### 说明\n\nwrite函数可用于发送数据到已连接的服务器。你可以发送单个字节的信息也可以发送多字节的信息。\n\n##### 语法\n\n`WiFiClient.write(val);`\n`WiFiClient.write(str)`\n`WiFiClient.write(buf, len)`\n\n##### 参数\n\n- val: 要发送的单字符数据\n- str: 要发送的多字符数据\n- buf: 要发送的多字符数组\n- len: buf的字节长度\n\n##### 返回值\n\n写入发送缓存的字节数\n\n##### 相关内容\n\n\n\n— print – 发送信息（Stream类）\n— println – 发送信息（Stream类）\n— Stream类\n\n\n\n\n\n###### \n\n\n\n\n\n### 响应信息操作类型\n\n#### readString – 读取数据并保存为字符串 （Stream类）\n\n##### 说明\n\n本函数可用于从ESP8266接收到数据中读取数据信息。读取到的信息将以字符串格式返回。\n\n**请留意，WiFiClient对象在处理或发送网络数据时，可以通过调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)中的函数来实现。本函数即是Stream类中的一员。**\n\n##### 语法\n\n```\nclient.readString()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n接收到的数据，类型为字符串。\n\n##### 示例程序\n\n此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求，并且将网站服务器响应的信息通过readString函数获取并保存。\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```C\n/**********************************************************************\n程序名称/Program name     : 3_5_1_http_request_basic\n程序目的/Purpose          : \n此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求，\n并且将网站服务器响应的信息通过readString函数获取并保存。\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <ESP8266WiFiMulti.h>\n \nESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象\n \nconst char* host = \"www.example.com\"; // 网络服务器地址\nconst int httpPort = 80;              // http端口80\n \nvoid setup(){\n  Serial.begin(9600);          \n  Serial.println(\"\");\n    \n  wifiMulti.addAP(\"ssid_from_AP_1\", \"your_password_for_AP_1\"); // 将需要连接的一系列WiFi ID和密码输入这里\n  wifiMulti.addAP(\"ssid_from_AP_2\", \"your_password_for_AP_2\"); // ESP8266-NodeMCU再启动后会扫描当前网络\n  wifiMulti.addAP(\"ssid_from_AP_3\", \"your_password_for_AP_3\"); // 环境查找是否有这里列出的WiFi ID。如果有\n  Serial.println(\"Connecting ...\"); \n \n  // 尝试进行wifi连接。\n  int i = 0;  \n  while (wifiMulti.run() != WL_CONNECTED) { \n    delay(1000);\n    Serial.print(i++); Serial.print(' ');\n  }\n  \n  // WiFi连接成功后将通过串口监视器输出连接成功信息 \n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(WiFi.SSID());              // WiFi名称\n  Serial.print(\"IP address:\\t\");\n  Serial.println(WiFi.localIP());           // IP\n}\n \nvoid loop(){\n  // 发送HTTP请求\n  httpRequest();    \n  \n  delay(30000);\n}\n \n// 向服务器发送HTTP请求\nvoid httpRequest(){\n  // 建立WiFi客户端对象，对象名称client\n  WiFiClient client;    \n \n  // 建立字符串，用于HTTP请求\n  String httpRequest =  String(\"GET /\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  \n  // 通过串口输出连接服务器名称以便查阅连接服务器的网址                      \n  Serial.print(\"Connecting to \"); \n  Serial.print(host); \n \n  // 连接网络服务器，以下段落中的示例程序为本程序重点1\n  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n  if (client.connect(host, httpPort)){ \n    Serial.println(\" Success!\");        // 连接成功后串口输出“Success”信息\n    \n    client.print(httpRequest);          // 向服务器发送合同谈判请求\n    Serial.println(\"Sending request: \");// 通过串口输出HTTP请求信息内容以便查阅\n    Serial.println(httpRequest);     \n    \n    // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2\n    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n    Serial.println(\"Web Server Response:\");        \n    while (client.connected() || client.available()){ \n      if (client.available()){\n        String line = client.readString();\n        Serial.println(line);\n      }\n    }\n    \n    client.stop();                      // 断开与服务器的连接\n    Serial.print(\"Disconnected from \"); // 并且通过串口输出断开连接信息\n    Serial.print(host);\n    \n  } else{    // 如果连接不成功则通过串口输出“连接失败”信息\n    Serial.println(\" connection failed!\");\n    client.stop();\n  }  \n}\n```\n\n##### 相关内容\n\n— readString – 读取数据并保存为字符串 （Stream类）\n— readStringUntil – 读取数据直到指定字符并保存为字符串 （Stream类）\n— find – 在数据中寻找信息（Stream类）\n— parseInt – 解析数据中的整数（Stream类）\n\n\n\n\n\n\n\n#### readStringUntil – 读取数据直到指定字符并保存为字符串 （Stream类）\n\n##### 说明\n\nreadStringUntil函数可用于从设备接收到的数据中读取信息。读取到的数据信息将以字符串形式返回。该函数在满足以下任一条件后都会停止函数执行并返回。\n\n– 读取到指定终止字符\n– 达到设定时间（可使用[setTimeout](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/settimeout/)来设置）\n\n当函数读取到终止字符后，会立即停止函数执行。此时函数所返回的字符串为”终止字符”前的所有字符信息。\n\n**请留意，WiFiClient对象在处理或发送网络数据时，可以通过调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)中的函数来实现。本函数即是Stream类中的一员。**\n\n##### 语法\n\n```\nclient.readStringUntil(terminator)\n```\n\n##### 参数\n\nterminator: 终止字符。用于设置终止函数执行的字符信息。设备在读取数据时一旦读取到此终止字符，将会结束函数执行。允许使用char类型。\n\n##### 返回值\n\n接收到的数据，类型为字符串。\n\n##### 示例程序\n\n此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求，并且将网站服务器响应的信息通过readStringUntil函数获取并且输出在屏幕中。\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n\n\n```C\n/**********************************************************************\n程序名称/Program name     : 3_5_1_http_request_basic\n程序目的/Purpose          : \n此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求，并且将网站服务器响应的信息通过readStringUntil函数获取并且输出在屏幕中。\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <ESP8266WiFiMulti.h>\n \nESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象\n \nconst char* host = \"www.example.com\"; // 网络服务器地址\nconst int httpPort = 80;              // http端口80\n \nvoid setup(){\n  Serial.begin(9600);          \n  Serial.println(\"\");\n    \n  wifiMulti.addAP(\"ssid_from_AP_1\", \"your_password_for_AP_1\"); // 将需要连接的一系列WiFi ID和密码输入这里\n  wifiMulti.addAP(\"ssid_from_AP_2\", \"your_password_for_AP_2\"); // ESP8266-NodeMCU再启动后会扫描当前网络\n  wifiMulti.addAP(\"ssid_from_AP_3\", \"your_password_for_AP_3\"); // 环境查找是否有这里列出的WiFi ID。如果有\n  Serial.println(\"Connecting ...\"); \n \n  // 尝试进行wifi连接。\n  int i = 0;  \n  while (wifiMulti.run() != WL_CONNECTED) { \n    delay(1000);\n    Serial.print(i++); Serial.print(' ');\n  }\n  \n  // WiFi连接成功后将通过串口监视器输出连接成功信息 \n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(WiFi.SSID());              // WiFi名称\n  Serial.print(\"IP address:\\t\");\n  Serial.println(WiFi.localIP());           // IP\n}\n \nvoid loop(){\n  // 发送HTTP请求\n  httpRequest();    \n  \n  delay(30000);\n}\n \n// 向服务器发送HTTP请求\nvoid httpRequest(){\n  // 建立WiFi客户端对象，对象名称client\n  WiFiClient client;    \n \n  // 建立字符串，用于HTTP请求\n  String httpRequest =  String(\"GET /\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  \n  // 通过串口输出连接服务器名称以便查阅连接服务器的网址                      \n  Serial.print(\"Connecting to \"); \n  Serial.print(host); \n \n  // 连接网络服务器，以下段落中的示例程序为本程序重点1\n  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n  if (client.connect(host, httpPort)){ \n    Serial.println(\" Success!\");        // 连接成功后串口输出“Success”信息\n    \n    client.print(httpRequest);          // 向服务器发送合同谈判请求\n    Serial.println(\"Sending request: \");// 通过串口输出HTTP请求信息内容以便查阅\n    Serial.println(httpRequest);     \n    \n    // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2\n    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n    Serial.println(\"Web Server Response:\");        \n    while (client.connected() || client.available()){ \n      if (client.available()){\n        String line = client.readStringUntil('\\n');\n        Serial.println(line);\n      }\n    }\n    \n    client.stop();                      // 断开与服务器的连接\n    Serial.print(\"Disconnected from \"); // 并且通过串口输出断开连接信息\n    Serial.print(host);\n    \n  } else{    // 如果连接不成功则通过串口输出“连接失败”信息\n    Serial.println(\" connection failed!\");\n    client.stop();\n  }  \n}\n```\n\n\n\n##### 相关内容\n\n— readString – 读取数据并保存为字符串 （Stream类）\n— find – 在数据中寻找信息（Stream类）\n— parseInt – 解析数据中的整数（Stream类）\n\n\n\n#### find – 在数据中寻找信息（Stream类）\n\n##### 说明\n\nfind函数可用于从设备接收到的数据中寻找指定字符串信息。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。\n\n**请留意，WiFiClient对象在处理或发送网络数据时，可以通过调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)中的函数来实现。本函数即是Stream类中的一员。**\n\n##### 语法\n\n```\nclient.find(target)\n```\n\n##### 参数\n\ntarget: 被查找字符串。允许使用String或char类型。\n\n##### 返回值\n\n返回值类型为bool。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。\n\n##### 示例程序\n\n此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求，并且使用find函数在网站服务器响应的信息中寻找“Date”字符串。如果找到“Date”字符串，则通过串口监视器告知用户开发板已经找到了“Date”字符串。\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```C\n/**********************************************************************\n项目名称/Project          : 零基础入门学用物联网\n程序名称/Program name     : wifiClient_find\n团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)\n作者/Author              : CYNO朔\n日期/Date（YYYYMMDD）     : 20200210\n程序目的/Purpose          : \n此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求，\n并且使用find函数在网站服务器响应的信息中寻找“Date”字符串。如果找到“Date”字符串，则通过\n串口监视器告知用户开发板已经找到了“Date”字符串。\n-----------------------------------------------------------------------\n本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。\n该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：\nhttp://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <ESP8266WiFiMulti.h>\n \nESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象\n \nconst char* host = \"www.example.com\"; // 网络服务器地址\nconst int httpPort = 80;              // http端口80\n \nvoid setup(){\n  Serial.begin(9600);          \n  Serial.println(\"\");\n    \n  wifiMulti.addAP(\"ssid_from_AP_1\", \"your_password_for_AP_1\"); // 将需要连接的一系列WiFi ID和密码输入这里\n  wifiMulti.addAP(\"ssid_from_AP_2\", \"your_password_for_AP_2\"); // ESP8266-NodeMCU再启动后会扫描当前网络\n  wifiMulti.addAP(\"ssid_from_AP_3\", \"your_password_for_AP_3\"); // 环境查找是否有这里列出的WiFi ID。如果有\n  Serial.println(\"Connecting ...\"); \n \n  // 尝试进行wifi连接。\n  int i = 0;  \n  while (wifiMulti.run() != WL_CONNECTED) { \n    delay(1000);\n    Serial.print(i++); Serial.print(' ');\n  }\n  \n  // WiFi连接成功后将通过串口监视器输出连接成功信息 \n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(WiFi.SSID());              // WiFi名称\n  Serial.print(\"IP address:\\t\");\n  Serial.println(WiFi.localIP());           // IP\n}\n \nvoid loop(){\n  // 发送HTTP请求\n  httpRequest();    \n  \n  delay(30000);\n}\n \n// 向服务器发送HTTP请求\nvoid httpRequest(){\n  // 建立WiFi客户端对象，对象名称client\n  WiFiClient client;    \n \n  // 建立字符串，用于HTTP请求\n  String httpRequest =  String(\"GET /\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  \n  // 通过串口输出连接服务器名称以便查阅连接服务器的网址                      \n  Serial.print(\"Connecting to \"); \n  Serial.print(host); \n \n  // 连接网络服务器，以下段落中的示例程序为本程序重点1\n  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n  if (client.connect(host, httpPort)){ \n    Serial.println(\" Success!\");        // 连接成功后串口输出“Success”信息\n    \n    client.print(httpRequest);          // 向服务器发送合同谈判请求\n    Serial.println(\"Sending request: \");// 通过串口输出HTTP请求信息内容以便查阅\n    Serial.println(httpRequest);     \n    \n    // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2\n    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n    Serial.println(\"Web Server Response:\");        \n    while (client.connected() || client.available()){ \n      if (client.available()){\n        if (client.find(\"Date\")){\n          Serial.println(\"Found Date Info in Server Response.\");\n        }\n      }\n    }\n    \n    client.stop();                      // 断开与服务器的连接\n    Serial.print(\"Disconnected from \"); // 并且通过串口输出断开连接信息\n    Serial.print(host);\n    \n  } else{    // 如果连接不成功则通过串口输出“连接失败”信息\n    Serial.println(\" connection failed!\");\n    client.stop();\n  }  \n}\n```\n\n\n\n##### 相关内容\n\n— readString – 读取数据并保存为字符串 （Stream类）\n— readStringUntil – 读取数据直到指定字符并保存为字符串 （Stream类）\n— parseInt – 解析数据中的整数（Stream类）\n— Stream类\n\n\n\n#### parseInt – 解析数据中的整数（Stream类）\n\n##### 说明\n\nparseInt函数可用于从设备接收到的数据中寻找整数数值。\n\n**请留意，WiFiClient对象在处理或发送网络数据时，可以通过调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)中的函数来实现。本函数即是Stream类中的一员。**\n\n##### 语法\n\n`client.parseInt()`\n\n##### 参数\n\n无\n\n##### 返回值\n\n在输入信息中找到的整数数值。类型：long\n\n##### 示例程序\n\n此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求，并且使用find函数在网站服务器响应的信息中寻找“Date”字符串。如果找到“Date”字符串，则进一步使用parseInt函数来寻找“Date”字符串后面的第一个数字。由于标准服务器相应信息中“Date”字符串后面的第一个数字信息即是当前服务器的日期信息中的”日”数值。因parseInt函数寻找到的数字即是服务器的日期信息中的”日”数值。\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```C\n/**********************************************************************\n程序名称/Program name     : WiFiClient_parseInt\n程序目的/Purpose          : \n此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求，\n并且使用find函数在网站服务器响应的信息中寻找“Date”字符串。如果找到“Date”字符串，则进一步\n使用parseInt函数来寻找“Date”字符串后面的第一个数字。由于标准服务器相应信息中“Date”字符串\n后面的第一个数字信息即是当前服务器的日期信息中的\"日\"数值。因此parseInt函数寻找到的数字即是\n服务器的日期信息中的\"日\"数值。\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <ESP8266WiFiMulti.h>\n \nESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象\n \nconst char* host = \"www.example.com\"; // 网络服务器地址\nconst int httpPort = 80;              // http端口80\n \nvoid setup(){\n  Serial.begin(9600);          \n  Serial.println(\"\");\n    \n  wifiMulti.addAP(\"ssid_from_AP_1\", \"your_password_for_AP_1\"); // 将需要连接的一系列WiFi ID和密码输入这里\n  wifiMulti.addAP(\"ssid_from_AP_2\", \"your_password_for_AP_2\"); // ESP8266-NodeMCU再启动后会扫描当前网络\n  wifiMulti.addAP(\"ssid_from_AP_3\", \"your_password_for_AP_3\"); // 环境查找是否有这里列出的WiFi ID。如果有\n  Serial.println(\"Connecting ...\"); \n \n  // 尝试进行wifi连接。\n  int i = 0;  \n  while (wifiMulti.run() != WL_CONNECTED) { \n    delay(1000);\n    Serial.print(i++); Serial.print(' ');\n  }\n  \n  // WiFi连接成功后将通过串口监视器输出连接成功信息 \n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(WiFi.SSID());              // WiFi名称\n  Serial.print(\"IP address:\\t\");\n  Serial.println(WiFi.localIP());           // IP\n}\n \nvoid loop(){\n  // 发送HTTP请求\n  httpRequest();    \n  \n  delay(30000);\n}\n \n// 向服务器发送HTTP请求\nvoid httpRequest(){\n  // 建立WiFi客户端对象，对象名称client\n  WiFiClient client;    \n \n  // 建立字符串，用于HTTP请求\n  String httpRequest =  String(\"GET /\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  \n  // 通过串口输出连接服务器名称以便查阅连接服务器的网址                      \n  Serial.print(\"Connecting to \"); \n  Serial.print(host); \n \n  // 连接网络服务器，以下段落中的示例程序为本程序重点1\n  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n  if (client.connect(host, httpPort)){ \n    Serial.println(\" Success!\");        // 连接成功后串口输出“Success”信息\n    \n    client.print(httpRequest);          // 向服务器发送合同谈判请求\n    Serial.println(\"Sending request: \");// 通过串口输出HTTP请求信息内容以便查阅\n    Serial.println(httpRequest);     \n    \n    // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2\n    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：\n    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n    Serial.println(\"Web Server Response:\");        \n    while (client.connected() || client.available()){ \n      if (client.available()){\n        if (client.find(\"Date\")){\n          Serial.println(\"Found Date Info in Server Response.\");\n          int day = client.parseInt();       \n          Serial.print(\"day = \");Serial.println(day);\n        }\n      }\n    }\n    \n    client.stop();                      // 断开与服务器的连接\n    Serial.print(\"Disconnected from \"); // 并且通过串口输出断开连接信息\n    Serial.print(host);\n    \n  } else{    // 如果连接不成功则通过串口输出“连接失败”信息\n    Serial.println(\" connection failed!\");\n    client.stop();\n  }  \n}\n```\n\n\n\n##### 相关内容\n\n— readString – 读取数据并保存为字符串 （Stream类）\n— readStringUntil – 读取数据直到指定字符并保存为字符串 （Stream类）\n— find – 在数据中寻找信息（Stream类）\n— Stream类\n\n\n\n#### 备注:以上带有（Stream类）标注的函数说明该函数是Stream类函数。\n\n\n\n\n\n\n\n## Stream类\n\n### 说明\n\n当我们使用ESP8266开发板或者Arduino开发板来开发项目时，可以使用基于Stream类的库来处理Stream数据。以下列表中的库都是基于Stream类所建立的。\n\n| 库               | 类               |\n| ---------------- | ---------------- |\n| Serial           | Serial           |\n| SoftwareSerial   | SoftwareSerial   |\n| Ehternet         | EthernetClient   |\n| ESP8266FS        | File             |\n| SD               | File             |\n| Wire             | Wire             |\n| GSM              | GSMClient        |\n| WifiClient       | WiFiClient       |\n| WiFiServer       | WiFiServer       |\n| WiFiUDP          | WiFiUDP          |\n| WiFiClientSecure | WiFiClientSecure |\n\n### 函数\n\n#### available\n\n##### 说明\n\navailable() 函数可用于检查设备是否接收到数据。该函数将会返回等待读取的数据字节数。\n\navailable()函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。\n\n##### 语法\n\n`stream.available()`\n注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：\n`Serial.available()`\n`wifiClient.available()`\n\n##### 参数\n\n无\n\n##### 返回值\n\n等待读取的数据字节数。\n返回值数据类型：int\n\n##### 示例程序\n\n```C\n/**********************************************************************\n程序名称/Program name     : stream_readString\n程序目的/Purpose          : \nStream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。\n然而当我们使用基于Stream类的库时，都会调用Stream中的内容。\n \n以下Arduino库及相应库中的类都是基于Stream类所实现的。\n 库          类\nCore        Serial\nWifi        WiFiClient\nEhternet    EthernetClient\nESP8266FS   File\nSD          File\nWire        Wire\nGSM         GSMClient\nSoftwareSerial  SoftwareSerial\n \n此程序使用Serial库来演示Stream类中的available()以及\nreadString()函数的使用方法。\navailable() 函数可用于检查设备是否接收到数据。该函数将会返回等待读取的数据字节数。\nreadString() 函数将读取stream中的字符并存储到字符中。\n***********************************************************************/\n \nvoid setup() {\n  // 启动串口通讯\n  Serial.begin(9600); \n  Serial.println();\n}\n \nvoid loop() {\n  \n  if (Serial.available()){                      // 当串口接收到信息后\n    Serial.println(\"Serial Data Available...\"); // 通过串口监视器通知用户\n    \n    String serialData = Serial.readString();    // 将接收到的信息使用readString()存储于serialData变量\n    Serial.print(\"Received Serial Data: \");     // 然后通过串口监视器输出serialData变量内容\n    Serial.println(serialData);                 // 以便查看serialData变量的信息\n  }\n}\n```\n\n\n\n#### read\n\n##### 说明\n\nread() 函数可用于从设备接收到数据中读取一个字节的数据。\n\n本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。\n\n##### 语法\n\n`stream.read()`\n注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：\n`Serial.read()`\n`wifiClient.read()`\n\n##### 参数\n\n无\n\n##### 返回值\n\n设备没有接收到数据时，返回值为-1\n设备接收到数据时，返回值为接收到的数据流中的1个字符。\n\n##### 示例程序\n\n```C\n/**********************************************************************\n程序名称/Program name     : stream_read\n程序目的/Purpose          : \nStream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。\n然而当我们使用基于Stream类的库时，都会调用Stream中的内容。\n \n以下Arduino库及相应库中的类都是基于Stream类所实现的。\n 库          类\nCore        Serial\nWifi        WiFiClient\nEhternet    EthernetClient\nESP8266FS   File\nSD          File\nWire        Wire\nGSM         GSMClient\nSoftwareSerial  SoftwareSerial\n \n此程序使用Serial对象来演示Stream类中的read()\nread() 函数可用于从设备接收到数据中读取一个字节的数据。\n***********************************************************************/\n \nvoid setup() {\n  // 启动串口通讯\n  Serial.begin(9600); \n  Serial.println();\n}\n \nvoid loop() {\n  while (Serial.available()){           // 当串口接收到信息后 \n    char serialData = Serial.read();    // 将接收到的信息使用read读取\n    Serial.println((char)serialData);   // 然后通过串口监视器输出read函数读取的信息\n  }\n}\n```\n\n\n\n#### readBytes\n\n##### 说明\n\nreadBytes函数可用于从设备接收的数据中读取信息。读取到的数据信息将存放在缓存变量中。该函数在读取到指定字节数的信息或者达到设定时间后都会停止函数执行并返回。该设定时间可使用[setTimeout](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/settimeout/)来设置。\n\n本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。\n\n##### 语法\n\n`stream.readBytes(buffer, length)`\n注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：\n`Serial.readBytes(buffer, length)`\n`wifiClient.readBytes(buffer, length)`\n\n##### 参数\n\nbuffer: 缓存变量/数组。用于存储读取到的信息。允许使用char或者byte类型的变量或数组。\nlength: 读取字节数量。readBytes函数在读取到length所指定的字节数量后就会停止运行。允许使用int类型。\n\n##### 返回值\n\nbuffer(缓存变量)中存储的字节数。数据类型：size_t\n\n##### 示例程序\n\n```c\n/**********************************************************************\n程序名称/Program name     : stream_readBytes\n程序目的/Purpose          : \nStream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。\n然而当我们使用基于Stream类的库时，都会调用Stream中的内容。\n \n以下Arduino库及相应库中的类都是基于Stream类所实现的。\n 库          类\nCore        Serial\nWifi        WiFiClient\nEhternet    EthernetClient\nESP8266FS   File\nSD          File\nWire        Wire\nGSM         GSMClient\nSoftwareSerial  SoftwareSerial\n \n此程序使用Serial对象来演示Stream类中的readByte()函数使用方法\nreadByte()函数在读取到指定字节数的信息或者达到设定时间后都会停止执行。\n***********************************************************************/\nconst int bufferLength = 10;    // 定义缓存大小为10个字节\nchar serialBuffer[bufferLength];// 建立字符数组用于缓存\n \nvoid setup() {\n  // 启动串口通讯\n  Serial.begin(9600); \n  Serial.println();\n}\n \nvoid loop() {\n  \n  if (Serial.available()){             \t\t\t// 当串口接收到信息后  \n    Serial.println(\"Received Serial Data:\");  \n    Serial.readBytes(serialBuffer, bufferLength);// 将接收到的信息使用readBytes读取\n    for(int i=0; i<bufferLength; i++){  \t\t// 然后通过串口监视器输出readBytes\n      Serial.print(serialBuffer[i]);      \t\t// 函数所读取的信息\n    }\n    Serial.println(\"\");  \n    Serial.println(\"Finished Printing Recevied Data.\");\n      \n  }\n}\n```\n\n\n\n#### readBytesUntil\n\n##### 说明\n\nreadBytesUntil() 函数可用于从设备接收到数据中读取信息。读取到的数据信息将存放在缓存变量中。该函数在满足以下任一条件后都会停止函数执行并且返回。\n\n– 读取到指定终止字符\n– 读取到指定字节数的信息\n– 达到设定时间（可使用[setTimeout](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/settimeout/)来设置）\n\n当函数读取到终止字符后，会立即停止函数执行。此时buffer（缓存变量/数组）中所存储的信息为设备读取到终止字符前的字符内容。\n\n本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。\n\n##### 语法\n\n`stream.readBytesUntil(character, buffer, length)`\n注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：\n`Serial.readBytesUntil(character, buffer, length)`\n`wifiClient.readBytesUntil(character, buffer, length)`\n\n##### 参数\n\n- character: 终止字符。用于设置终止函数执行的字符信息。设备在读取数据时一旦读取到此终止字符，将会结束函数执行。允许使用char类型。\n- buffer: 缓存变量/数组。用于存储读取到的信息。允许使用char或者byte类型的变量或数组。\n- length: 读取字节数量。readBytes函数在读取到length所指定的字节数量后就会停止运行。允许使用int类型。`\n\n##### 返回值\n\nbuffer(缓存变量)中存储的字节数。数据类型：size_t\n\n##### 示例程序\n\n```c\n/**********************************************************************\n程序名称/Program name     : stream_readBytesUntil\n程序目的/Purpose          : \nStream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。\n然而当我们使用基于Stream类的库时，都会调用Stream中的内容。\n \n以下Arduino库及相应库中的类都是基于Stream类所实现的。\n 库          类\nCore        Serial\nWifi        WiFiClient\nEhternet    EthernetClient\nESP8266FS   File\nSD          File\nWire        Wire\nGSM         GSMClient\nSoftwareSerial  SoftwareSerial\n \n此程序使用Serial对象来演示Stream类中的readByteUntil()函数使用方法。\n***********************************************************************/\nchar terminateChar =  'T';      // 建立终止字符\nconst int bufferLength = 10;    // 定义缓存大小为10个字节\nchar serialBuffer[bufferLength];// 建立字符数组用于缓存  \n \nvoid setup() {\n  // 启动串口通讯\n  Serial.begin(9600); \n  Serial.println();\n}\n \nvoid loop() {\n  if (Serial.available()){             // 当串口接收到信息后  \n    Serial.readBytesUntil(terminateChar, serialBuffer, bufferLength);// 将接收到的信息使用read读取\n \n    for(int i=0; i<bufferLength; i++){  // 然后通过串口监视器输出readBytesUntil\n      Serial.print(serialBuffer[i]);    // 函数所读取的信息\n    }\n    \n    Serial.println(\"\");      \n  } \n}\n```\n\n\n\n#### readString\n\n##### 说明\n\nreadString() 函数可用于从设备接收到数据中读取数据信息。读取到的信息将以字符串格式返回。\n\n本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。\n\n##### 语法\n\n`stream.readString()`\n注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：\n`Serial.readString()`\n`wifiClient.readString()`\n\n##### 参数\n\n无\n\n##### 返回值\n\n接收到的数据，类型为字符串。\n\n##### 示例程序\n\n```c\n/**********************************************************************\n程序名称/Program name     : stream_readString\n程序目的/Purpose          : \nStream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。\n然而当我们使用基于Stream类的库时，都会调用Stream中的内容。\n \n以下Arduino库及相应库中的类都是基于Stream类所实现的。\n 库          类\nCore        Serial\nWifi        WiFiClient\nEhternet    EthernetClient\nESP8266FS   File\nSD          File\nWire        Wire\nGSM         GSMClient\nSoftwareSerial  SoftwareSerial\n \n此程序使用Serial库来演示Stream类中的available()以及\nreadString()函数的使用方法。\navailable() 函数将会返回开发板所接收到的stream中等待读取的字节数。\nreadString() 函数将读取stream中的字符并存储到字符中。\n***********************************************************************/\n \nvoid setup() {\n  // 启动串口通讯\n  Serial.begin(9600); \n  Serial.println();\n}\n \nvoid loop() {\n  \n  if (Serial.available()){                      // 当串口接收到信息后\n    Serial.println(\"Serial Data Available...\"); // 通过串口监视器通知用户\n    \n    String serialData = Serial.readString();    // 将接收到的信息使用readString()存储于serialData变量\n    Serial.print(\"Received Serial Data: \");     // 然后通过串口监视器输出serialData变量内容\n    Serial.println(serialData);                 // 以便查看serialData变量的信息\n  }\n}\n```\n\n##### 相关内容\n\n– available\n– readStringUntil\n\n\n\n#### readStringUntil\n\n##### 说明\n\nreadStringUntil函数可用于从设备接收到的数据中读取信息。读取到的数据信息将以字符串形式返回。该函数在满足以下任一条件后都会停止函数执行并返回。\n\n– 读取到指定终止字符\n– 达到设定时间（可使用[setTimeout](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/settimeout/)来设置）\n\n当函数读取到终止字符后，会立即停止函数执行。此时函数所返回的字符串为”终止字符”前的所有字符信息。\n\n本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。\n\n##### 语法\n\n`Stream.readStringUntil(terminator)`\n注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：\n`Serial.readStringUntil(terminator)`\n`wifiClient.readStringUntil(terminator)`\n\n##### 参数\n\nterminator: 终止字符。用于设置终止函数执行的字符信息。设备在读取数据时一旦读取到此终止字符，将会结束函数执行。允许使用char类型。\n\n##### 返回值\n\n接收到的数据，类型为字符串\n\n##### 示例程序\n\n```c\n/**********************************************************************\n程序名称/Program name     : stream_readStringUntil\n程序目的/Purpose          : \n此程序使用Serial来演示Stream类中的readString()函数的使用方法。\nreadStringUntil() 函数可用于从设备接收到数据中读取信息。读取到的数据信息将以字符串形式返回中。\n \nStream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。\n然而当我们使用基于Stream类的库时，都会调用Stream中的内容。\n \n以下Arduino库及相应库中的类都是基于Stream类所实现的。\n 库          类\nCore        Serial\nWifi        WiFiClient\nEhternet    EthernetClient\nESP8266FS   File\nSD          File\nWire        Wire\nGSM         GSMClient\nSoftwareSerial  SoftwareSerial\n***********************************************************************/\nchar terminatorChar = 'T';    // 定义终止字符为‘T’\n \nvoid setup() {\n  // 启动串口通讯\n  Serial.begin(9600); \n  Serial.println();\n}\n \nvoid loop() {\n  \n  if (Serial.available()){                      // 当串口接收到信息后\n    Serial.println(\"Serial Data Available...\"); // 通过串口监视器通知用户\n    \n    String serialData = Serial.readStringUntil(terminatorChar);    // 将接收到的信息使用readString()存储于serialData变量\n    Serial.print(\"Received Serial Data: \");     // 然后通过串口监视器输出serialData变量内容\n    Serial.println(serialData);                 // 以便查看serialData变量的信息\n  }\n}\n```\n\n\n\n#### find\n\n##### 说明\n\nfind函数可用于从设备接收到的数据中寻找指定字符串信息。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。\n\n本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。\n\n##### 语法\n\n`Stream.find(target)`\n注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：\n`Serial.find(target)`\n`wifiClient.find(target)`\n\n##### 参数\n\ntarget: 被查找字符串。允许使用String或char类型。\n\n##### 返回值\n\n返回值类型为bool。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。\n\n##### 示例程序\n\n```c\n/**********************************************************************\n程序名称/Program name     : find\n程序目的/Purpose          : \n此程序使用Serial来演示Stream类中的find函数使用方法。\nfind函数可用于从设备接收到数据中寻找指定信息。当该函数找到了指定信息\n后将会立即结束函数执行并且返回“真”。否则该函数将会返回“假”。\n \nStream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。\n然而当我们使用基于Stream类的库时，都会调用Stream中的内容。\n \n以下Arduino库及相应库中的类都是基于Stream类所实现的。\n 库          类\nCore        Serial\nWifi        WiFiClient\nEhternet    EthernetClient\nESP8266FS   File\nSD          File\nWire        Wire\nGSM         GSMClient\nSoftwareSerial  SoftwareSerial\n***********************************************************************/\n \nvoid setup() {\n  // 启动串口通讯\n  Serial.begin(9600); \n  Serial.println();\n}\n \nvoid loop() { \n  if (Serial.available()){                      // 当串口接收到信息后\n    Serial.println(\"Serial Data Available...\"); // 通过串口监视器通知\n                                                // 用户系统开始查找指定信息\n    Serial.print(\"system is trying to find \"); Serial.println(\"^_^\"); \n \n    // 执行查找并通过串口监视器输出查找结果\n    if(Serial.find(\"^_^\")) {\n      Serial.print(\"Great! System found \"); Serial.println(\"^_^\"); \n    } else {\n      Serial.print(\"Sorry System can't find \"); Serial.println(\"^_^\"); \n    }  \n    Serial.println(\"\");\n  }\n}\n```\n\n##### 相关内容\n\n– available\n– findUntil\n\n\n\n#### findUntil\n\n\n\n##### 说明\n\nfindUntil函数可用于从设备接收到的数据中寻找指定字符串信息。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。该函数在满足以下任一条件后都会停止函数执行\n\n– 读取到指定终止字符串\n– 找到了指定字符串信息\n– 达到设定时间（可使用[setTimeout](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/settimeout/)来设置）\n\n本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。\n\n##### 语法\n\n`Stream.findUntil(target, terminator)`\n注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：\n`Serial.findUntil(target, terminator)`\n`wifiClient.findUntil(target, terminator)`\n\n##### 参数\n\ntarget: 被查找字符串。允许使用String或char类型。\n\nterminator: 终止字符串。用于设置终止函数执行的字符串信息。设备在读取数据时一旦读取到此终止字符串，将会结束函数执行并返回。\n\n##### 返回值\n\n返回值类型为bool。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。\n\n##### 示例程序\n\n```c\n/**********************************************************************\n程序名称/Program name     : findUntil\n程序目的/Purpose          : \n此程序使用Serial来演示Stream类中的findUntil函数使用方法。\nfindUntil函数可用于从设备接收到数据中寻找指定字符串信息。当函数找到了\n指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。\n \nStream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。\n然而当我们使用基于Stream类的库时，都会调用Stream中的内容。\n \n以下Arduino库及相应库中的类都是基于Stream类所实现的。\n 库          类\nCore        Serial\nWifi        WiFiClient\nEhternet    EthernetClient\nESP8266FS   File\nSD          File\nWire        Wire\nGSM         GSMClient\nSoftwareSerial  SoftwareSerial\n***********************************************************************/\nvoid setup() {\n  // 启动串口通讯\n  Serial.begin(9600); \n  Serial.println();\n}\n \nvoid loop() { \n  if (Serial.available()){                      // 当串口接收到信息后\n    Serial.println(\"Serial Data Available...\"); // 通过串口监视器通知\n                                                // 用户系统开始查找指定信息\n    Serial.print(\"system is trying to find \"); Serial.println(\"^_^\"); \n \n    // 执行查找并通过串口监视器输出查找结果\n    if(Serial.findUntil(\"^_^\", \"STOP\")) {\n      Serial.print(\"Great! System found \"); Serial.println(\"^_^\"); \n    } else {\n      Serial.print(\"Sorry System can't find \"); Serial.println(\"^_^\"); \n    }  \n    Serial.println(\"\");\n  }\n}\n```\n\n相关内容\n– available\n– find\n\n\n\n\n\n#### peek\n\n##### 说明\n\npeek函数可用于从设备接收到的数据中读取一个字节的数据。但是与read函数不同的是，使用peek函数读取数据后，被读取的数据不会从数据流中消除。这就导致每一次调用peek函数，只能读取数据流中的第一个字符。然而每一次调用read函数读取数据时，被读取的数据都会从数据流中删除。\n\n本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。\n\n##### 语法\n\n`stream.peek()`\n注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：\n`Serial.peek()`\n`wifiClient.peek()`\n\n##### 参数\n\ntarget: 被查找字符串。允许使用String或char类型。\n\nterminator: 终止字符串。用于设置终止函数执行的字符串信息。设备在读取数据时一旦读取到此终止字符串，将会结束函数执行并返回。\n\n##### 返回值\n\n设备没有接收到数据时，返回值为-1\n\n设备接收到数据时，返回值为接收到的数据流中的第1个字符。\n\n##### 示例程序\n\n```c\n/**********************************************************************\n程序名称/Program name     : stream_peek\n程序目的/Purpose          : \n此程序使用Serial来演示Stream类中的peek()。\n \nStream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。\n然而当我们使用基于Stream类的库时，都会调用Stream中的内容。\n \n以下Arduino库及相应库中的类都是基于Stream类所实现的。\n 库          类\nCore        Serial\nWifi        WiFiClient\nEhternet    EthernetClient\nESP8266FS   File\nSD          File\nWire        Wire\nGSM         GSMClient\nSoftwareSerial  SoftwareSerial\n***********************************************************************/\n \nvoid setup() {\n  // 启动串口通讯\n  Serial.begin(9600); \n  Serial.println();\n}\n \nvoid loop() {\n  \n  while (Serial.available()){             // 当串口接收到信息后\n    \n    char serialData = Serial.peek();      // 将接收到的信息使用peek读取\n    Serial.println((char)serialData);     // 然后通过串口监视器输出peek函数所读取的信息\n  }\n}\n```\n\n\n\n#### flush\n\n##### 说明\n\nflush函数可让开发板在所有待发数据发送完毕前，保持等待状态。\n\n请注意：很多人误认为flush函数具有[清除开发板接收缓存区](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/clear-incoming-buffer/)的功能。事实上此函数是没有此功能的。如需了解如何清除开发板接收缓存区内信息的方法，请点击这里进入相应说明页面。\n\n本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。\n\n为了更好的理解flush函数的作用，我们在这里用Serial.flush()作为示例讲解。\n\n当我们通过Serial.print或Serial.println来发送数据时，被发送的字符数据将会存储于开发板的“发送缓存”中。这么做的原因是开发板串行通讯速率不是很高，如果发送数据较多，发送时间会比较长。\n\n在没有使用flush函数的情况下，开发板不会等待所有“发送缓存”中数据都发送完毕再执行后续的程序内容。也就是说，开发板是在后台发送缓存中的数据。程序运行不受影响。\n\n相反的，在使用了flush函数的情况下，开发板是会等待所有“发送缓存”中数据都发送完毕以后，再执行后续的程序内容。\n\n##### 语法\n\n`stream.flush()`\n注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：\n`Serial.flush()`\n`wifiClient.flush()`\n\n##### 参数\n\n无\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n为了演示flush函数工作效果，一共为您准备了两个示例程序。这两个程序一个使用了flush函数另外一个没有使用flush函数。\n\n通过这两个示例程序的运行结果比较，您可以看到flush函数的工作效果。\n\n示例1：没有使用flush函数的情况下，通过串口监视器显示开发板输出一大串字符的运行效果。\n\n```c\n/**********************************************************************\n程序名称/Program name     : stream_With_flush\n程序目的/Purpose          : \n此程序使用Serial来演示Stream类中的flush函数。\nflush函数可让开发板在所有发送数据全部发送完毕之前，保持等待状态。\n \n为了演示flush函数工作效果，一共为您准备了两个示例程序。这两个程序一个使用了flush函数\n另外一个没有使用flush函数。\n \n通过这两个示例程序的运行结果比较，您可以看到flush函数的工作效果。\n \n此程序为没有使用flush函数的情况下，通过串口监视器显示开发板在输出一大串字符的运行效果。\n***********************************************************************/\n \nvoid setup() {\n  Serial.begin(9600);\n \n  // 记录输出串口信息前的millis时间\n  unsigned long millisNoFlushStart = millis();\n  \n  // 通过串口输出信息\n  Serial.println(F(\"abcdefghijklmnopqrstuvwxyz\"));\n  \n  // 记录输出串口信息后的millis时间\n  unsigned long millisNoFlushStop = millis();\n \n  // 通过串口监视器输出没有使用flush函数情况下，输出信息前后的时间差。\n  Serial.print(F(\"NO flush: \"));\n  Serial.print( millisNoFlushStop - millisNoFlushStart);\n  Serial.println(F(\" milliseconds.\"));\n}\nvoid loop() {}\n \n/*\nStream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。\n然而当我们使用基于Stream类的库时，都会调用Stream中的内容。\n \n以下Arduino库及相应库中的类都是基于Stream类所实现的。\n 库          类\nCore        Serial\nWifi        WiFiClient\nEhternet    EthernetClient\nESP8266FS   File\nSD          File\nWire        Wire\nGSM         GSMClient\nSoftwareSerial  SoftwareSerial\n-----------------------------------------------------------------------\n*/\n```\n\n\n\n#### parseInt\n\n##### 说明\n\nparseInt函数可用于从设备接收到的数据中寻找整数数值。\n\n本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。\n\n##### 语法\n\n`stream.parseInt()`\n注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：\n`Serial.parseInt()`\n`wifiClient.parseInt()`\n\n##### 参数\n\n无\n\n##### 返回值\n\n在输入信息中找到的整数数值。类型：long\n\n##### 示例程序\n\n```c\n/**********************************************************************\n程序名称/Program name     : stream_parseInt\n程序目的/Purpose          : \n此程序使用Serial来演示Stream类中的parseInt。\nparseInt函数可用于从设备接收到的数据中寻找整数数值。\n \nStream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。\n然而当我们使用基于Stream类的库时，都会调用Stream中的内容。\n \n以下Arduino库及相应库中的类都是基于Stream类所实现的。\n 库          类\nCore        Serial\nWifi        WiFiClient\nEhternet    EthernetClient\nESP8266FS   File\nSD          File\nWire        Wire\nGSM         GSMClient\nSoftwareSerial  SoftwareSerial\n***********************************************************************/\n \nvoid setup() {\n  \n  // 启动串口通讯\n  Serial.begin(9600); \n  Serial.println();\n  \n}\n \nvoid loop() {\n  \n  if (Serial.available()){              // 当串口接收到信息后   \n    int serialData = Serial.parseInt(); // 使用parseInt查找接收到的信息中的整数\n    Serial.print(\"serialData = \");      // 然后通过串口监视器输出找到的数值\n    Serial.println(serialData);\n  }\n  \n}\n```\n\n##### 相关内容\n\n– available\n– parseFloat\n\n\n\n#### parseFloat\n\n##### 说明\n\nparseFloat函数可用于从设备接收到的数据中寻找浮点数值。\n\n本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。\n\n##### 语法\n\n`stream.parseFloat()`\n注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：\n`Serial.parseFloat()`\n`wifiClient.parseFloat()`\n\n##### 参数\n\n无\n\n##### 返回值\n\n在输入信息中找到浮点数值。类型：float\n\n##### 示例程序\n\n```c\n/**********************************************************************\n程序名称/Program name     : stream_parseFloat\n程序目的/Purpose          : \n此程序使用Serial来演示Stream类中的parseFloat。\nparseFloat函数可用于从设备接收到的数据中寻找整数数值。\n \nStream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。\n然而当我们使用基于Stream类的库时，都会调用Stream中的内容。\n \n以下Arduino库及相应库中的类都是基于Stream类所实现的。\n 库          类\nCore        Serial\nWifi        WiFiClient\nEhternet    EthernetClient\nESP8266FS   File\nSD          File\nWire        Wire\nGSM         GSMClient\nSoftwareSerial  SoftwareSerial\n***********************************************************************/\n \nvoid setup() {\n  \n  // 启动串口通讯\n  Serial.begin(9600); \n  Serial.println();\n  \n}\n \nvoid loop() {\n  \n  if (Serial.available()){              // 当串口接收到信息后   \n    float serialData = Serial.parseFloat(); // 使用parseFloat查找接收到的信息中的整数\n    Serial.print(\"serialData = \");      // 然后通过串口监视器输出找到的数值\n    Serial.println(serialData);\n  }  \n}\n```\n\n##### 相关内容\n\n– available\n– parseInt\n\n\n\n\n\n#### setTimeout\n\n##### 说明\n\nsetTimeout函数用于设置设备等待数据流的最大时间间隔。\n\n当设备在接收数据时，是以字符作为单位来逐个字符执行接收任务。由于设备无法预判即将接收到的信息包含有多少字符，因此设备会设置一个等待时间。默认情况下，该等待时间是1000毫秒。\n\n举例来说，假设我们要向设备发送一个字符串“ok”。那么设备在接收到第一个字符“o”以后，他会等待第二个字符的到达。假如在1000毫秒内，设备接收到第二个字符“k”，那么设备会重置等待时间，也就是再等待1000毫秒，看一看字符“k”后面还有没有字符到达。我们知道我们发给设备的字符串只有两个字符，后面没有更多字符了。但是设备并不知道这一情况。因此设备在接收到“k”以后，会等待1000毫秒。直到1000毫秒等待时间结束都没有再次接到字符。这时，设备才会很肯定地结束这一次接收工作。这里这个等待的1000毫秒时间就是通过setTimeout函数来设置的。\n\nsetTimeout函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。\n\n##### 语法\n\n`stream.setTimeout(time)`\n注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：\n`Serial.setTimeout(time)`\n`wifiClient.setTimeout(time)`\n\n##### 参数\n\ntime: 设置最大等待时间。单位：毫秒。允许类型：long\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n```c\n/**********************************************************************\n程序名称/Program name     : stream_setTimeout\n程序目的/Purpose          : \n此程序使用Serial来演示Stream类中的setTimeout。\nsetTimeout函数用于设置设备等待数据流的最大时间间隔。\n默认情况下，该等待时间是1000毫秒。 \n***********************************************************************/\n \nvoid setup() {\n  Serial.begin(9600);\n  Serial.setTimeout(5000);\n}\n \nvoid loop() {\n  if (Serial.available()) {\t\t\t\t\n    String s = Serial.readString();\n    Serial.println(s);\n  }\n}\n```\n\n##### 相关内容\n\n– available\n\n\n\n\n\n\n\n#### 清除接收缓存\n\n##### 说明\n\n此页面用于演示如何清除开发板的接收缓存。\n\n制作此说明页面是由于很多人误认为stream类中的[flush](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/flush/)函数具有清除缓存的功能。事实上此函数是没有清除缓存功能的。\n\n为了便于理解，我们在这里用Serial作为示例，演示如何清除串口接收缓存中的信息。\n\n##### 示例程序\n\n```c\n/**********************************************************************\n程序名称/Program name     : stream_clear_buffer\n团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)\n作者/Author              : CYNO朔\n日期/Date（YYYYMMDD）     : 20200318\n程序目的/Purpose          : \n \n-----------------------------------------------------------------------\n本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。\n该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：\nhttp://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/\n***********************************************************************/\nvoid setup() {\n  Serial.begin(9600);\n}\n \nvoid loop() {\n  // 以下while循环语句将会清除接收缓存内容。\n  // 具体工作原理是这样的。每当有数据输入接收缓存后，\n  // 我们可以使用Serial.read()来读取接收缓存中的内容。\n  // 这时，如果我们对Serial.read()函数的返回值不加以任何利用\n  // 那么读取到的数据，也就是Serial.read()函数的返回值将会在\n  // 下一次执行Serial.read时所抛弃。利用while循环语句，我们可以\n  // 保证在接收缓存中有数据的时候，反复将串口接收缓存中的信息读取并抛弃。\n  // 从而达到清除接收缓存的目的。\n  while(Serial.available()){\n    Serial.println(\"Clearing Serial Incoming Buffer.\");\n    Serial.read();\n  } \n \n  // 当接收缓存为空时，Serial.read返回值为“-1”\n  // 通过以下语句我们将看到无论我们是否通过串口监视器\n  // 输入信息，开发板的串口监视器会一直输出:\n  // \"Incoming Buffer is Clear.\"\n  // 这是因为接收缓存中的信息被以上while语句中的内容给清除掉了。\n  if (Serial.read() == -1){\n    Serial.println(\"Incoming Buffer is Clear.\");\n  }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n## ESP8266 – WiFiServer库\n\nWiFiServer库用于ESP8266的TCP协议物联网通讯。TCP协议又称传输控制协议是Transmission Control Protocol的简称。如需了解更多有关TCP协议介绍，请[点击这里查看TCP协议的百度百科介绍页](https://baike.baidu.com/item/TCP/33012)。\n\n通过WiFiServer库，我们可以使用ESP8266开发板建立网络服务器,从而允许其它网络设备以及物联网设备通过TCP协议访问并实现物联网信息交流。\n\nESP8266库中还有一个专门用于HTTP通讯的`ESP8266WebServer`库 。\n\n由于HTTP协议是建立在TCP协议基础之上的，我们也可以使用ESP8266WebServer库来实现HTTP通讯。在这一点上，WiFiServer库与ESP8266WebServer库 在功能上形成了互补。\n\n**请留意，WiFiServer对象在处理或发送网络数据时，可以通过调用`Stream类`中的函数来实现。因此在以下结构图中的“响应信息操作类型”中有“Stream类”作为这种类型函数的一部分。**\n\n以下为WiFiServer库的整体结构图。\n\n![image-20230526202509292](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230526202509292.png)\n\n### 服务器设置类型\n\n#### WiFiServer – 建立新的WiFiServer对象\n\n##### 说明\n\n此函数用于建立新的WiFiServer对象，以便利用此对象来控制ESP8266建立的物联网服务器。\n\n##### 语法\n\n```\nWiFiServer server(port)\n```\n\n##### 参数\n\n– port: 此参数用于设置服务端口号。(类型:int)\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。**WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址**。此时，ESP8266已经成功建立了网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。\n\n假设您的ESP8266开发板IP地址是192.168.0.110。那么接下来您可以通过浏览器输入该IP地址。\n\n当您在浏览器地址栏中输入Ip后并按下回车，这时您将看到浏览器中显示上图所示的网页页面。该页面即是通过ESP8266所建立的。在以下的示例程序中，我们使用了语句`WiFiServer server(80);`来建立了WiFiServer对象以便后续程序中对服务器进行相应的控制。\n\n```c\n/**********************************************************************\n程序名称/Program name     : WIFIServer_demo_1\n程序目的/Purpose          : \n此示例程序演示了如何使用WiFiServer库建立网络服务器。\n通过以下网址可以设置板载LED灯的状态\nhttp://server_ip/gpio/0将设置 LED_BUILTIN 引脚设置为低电平，\nhttp://server_ip/gpio/1将设置 LED_BUILTIN 引脚设置为高电平\n以上网址链接中的server_ip指的是ESP8266模块的IP地址。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n//此处设置您的wifi接入信息\n#ifndef STASSID\n#define STASSID \"Taichi-Maker\"\n#define STAPSK  \"12345678\"\n#endif\n \nconst char* ssid = STASSID;\nconst char* password = STAPSK;\n \n//创建TCP server对象,并将端口指定为80\nWiFiServer server(80);\n \nvoid setup() {\n  //打开串口\n  Serial.begin(115200);\n \n  //初始化板载LED\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, 0);\n \n  //连接WiFi\n  Serial.println();\n  Serial.println();\n  Serial.print(F(\"Connecting to \"));\n  Serial.println(ssid);\n \n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(F(\".\"));\n  }\n  Serial.println();\n  Serial.println(F(\"WiFi connected\"));\n \n  //启动TCP server服务器\n  server.begin();\n  Serial.println(F(\"Server started\"));\n \n  //打印IP地址\n  Serial.println(WiFi.localIP());\n}\n \nvoid loop() {\n  //检查客户端是否已连接\n  WiFiClient client = server.available();\n  if (!client) {\n    return;\n  }\n  Serial.println(F(\"new client\"));\n \n  client.setTimeout(5000); //默认为 1000\n \n  //读取客户端发起的TCP请求\n  String req = client.readStringUntil('\\r');\n  Serial.println(F(\"request: \"));\n  Serial.println(req);\n \n  //解析请求里是否含有以下指定内容\n  int val;\n  //检查发起的请求内容是否包含\"/gpio/0\"\n  if (req.indexOf(F(\"/gpio/0\")) != -1) {\n    val = 0;\n \n    //检查发起的请求内容是否包含\"/gpio/1\"\n  } else if (req.indexOf(F(\"/gpio/1\")) != -1) {\n    val = 1;\n  } else {\n    Serial.println(F(\"invalid request\"));\n    val = digitalRead(LED_BUILTIN);\n  }\n \n  //根据要求设置板载LED状态\n  digitalWrite(LED_BUILTIN, val);\n \n  //读取剩余的内容,用于清除缓存\n  while (client.available()) {\n    client.read();\n  }\n \n  //将响应体发送到客户端 注:若要使用中文则必须在其中添加<meta charset=\\\"utf-8\\\">声明编码\n  client.print(F(\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<!DOCTYPE HTML>\\r\\n<html>\\r\\n<meta charset=\\\"utf-8\\\">NodeMCU板载LED灯的状态 : \"));\n  client.print((val) ? F(\"关\") : F(\"开\"));\n  client.print(F(\"<br><br> <a href='http://\"));\n  client.print(WiFi.localIP());\n  client.print(F(\"/gpio/1'>  点击关灯  </a> , 或  <a href='http://\"));\n  client.print(WiFi.localIP());\n  client.print(F(\"/gpio/0'>  点击开灯  </a> </html>\"));\n \n  //通过浏览器点击按钮之后,TCP连接将会被重置,并且浏览器会发起新的TCP请求到我们的8266服务器,从而去控制LED灯\n  Serial.println(F(\"Disconnecting from client\"));\n}\n```\n\n\n\n\n\n##### 相关内容\n\n— begin – 服务器启动\n— stop – 停止服务器\n— close – 停止服务器\n\n\n\n\n\n\n\n\n\n#### begin – 服务器启动\n\n##### 说明\n\n本函数用于启动ESP8266开发板所建立的物联网网络服务器。\n\n##### 语法\n\n```\nserver.begin()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n```c\n/**********************************************************************\n程序名称/Program name     : WIFIServer_demo_1\n程序目的/Purpose          : \n此示例程序演示了如何使用WiFiServer库建立网络服务器。\n通过以下网址可以设置板载LED灯的状态\nhttp://server_ip/gpio/0将设置 LED_BUILTIN 引脚设置为低电平，\nhttp://server_ip/gpio/1将设置 LED_BUILTIN 引脚设置为高电平\n以上网址链接中的server_ip指的是ESP8266模块的IP地址。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n//此处设置您的wifi接入信息\n#ifndef STASSID\n#define STASSID \"Taichi-Maker\"\n#define STAPSK  \"12345678\"\n#endif\n \nconst char* ssid = STASSID;\nconst char* password = STAPSK;\n \n//创建TCP server对象,并将端口指定为80\nWiFiServer server(80);\n \nvoid setup() {\n  //打开串口\n  Serial.begin(115200);\n \n  //初始化板载LED\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, 0);\n \n  //连接WiFi\n  Serial.println();\n  Serial.println();\n  Serial.print(F(\"Connecting to \"));\n  Serial.println(ssid);\n \n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(F(\".\"));\n  }\n  Serial.println();\n  Serial.println(F(\"WiFi connected\"));\n \n  //启动TCP server服务器\n  server.begin();\n  Serial.println(F(\"Server started\"));\n \n  //打印IP地址\n  Serial.println(WiFi.localIP());\n}\n \nvoid loop() {\n  //检查客户端是否已连接\n  WiFiClient client = server.available();\n  if (!client) {\n    return;\n  }\n  Serial.println(F(\"new client\"));\n \n  client.setTimeout(5000); //默认为 1000\n \n  //读取客户端发起的TCP请求\n  String req = client.readStringUntil('\\r');\n  Serial.println(F(\"request: \"));\n  Serial.println(req);\n \n  //解析请求里是否含有以下指定内容\n  int val;\n  //检查发起的请求内容是否包含\"/gpio/0\"\n  if (req.indexOf(F(\"/gpio/0\")) != -1) {\n    val = 0;\n \n    //检查发起的请求内容是否包含\"/gpio/1\"\n  } else if (req.indexOf(F(\"/gpio/1\")) != -1) {\n    val = 1;\n  } else {\n    Serial.println(F(\"invalid request\"));\n    val = digitalRead(LED_BUILTIN);\n  }\n \n  //根据要求设置板载LED状态\n  digitalWrite(LED_BUILTIN, val);\n \n  //读取剩余的内容,用于清除缓存\n  while (client.available()) {\n    client.read();\n  }\n \n  //将响应体发送到客户端 注:若要使用中文则必须在其中添加<meta charset=\\\"utf-8\\\">声明编码\n  client.print(F(\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<!DOCTYPE HTML>\\r\\n<html>\\r\\n<meta charset=\\\"utf-8\\\">NodeMCU板载LED灯的状态 : \"));\n  client.print((val) ? F(\"关\") : F(\"开\"));\n  client.print(F(\"<br><br> <a href='http://\"));\n  client.print(WiFi.localIP());\n  client.print(F(\"/gpio/1'>  点击关灯  </a> , 或  <a href='http://\"));\n  client.print(WiFi.localIP());\n  client.print(F(\"/gpio/0'>  点击开灯  </a> </html>\"));\n \n  //通过浏览器点击按钮之后,TCP连接将会被重置,并且浏览器会发起新的TCP请求到我们的8266服务器,从而去控制LED灯\n  Serial.println(F(\"Disconnecting from client\"));\n}\n```\n\n\n\n\n\n\n\n\n\n#### setNoDelay – 停止小包合并发送\n\n##### 说明\n\n此函数用于设置ESP8266服务器是否使用Nagle算法来将发送的信息先拆分成小包再发送。\n\n使用Nagle算法来拆包发送的优点是可以将较大的数据信息拆分，从而让信息传输的网络利用率更加优化。但缺点是比起不拆包发送的模式来说，拆包发送的速度要慢一些。\n\n##### 语法\n\n```\nserver.setNoDelay(val)\n```\n\n##### 参数\n\nval: 此参数类型为bool。以下是参数功能说明。\n\n- – true: 不使用Nagle算法来将发送的信息先拆分成小包再发送。\n- – false: 使用Nagle算法来将发送的信息先拆分成小包再发送。\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n在以下的示例程序中，我们使用了语句`server.setNoDelay(true);`将发送的信息先拆分成小包再发送。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WIFIServer_demo_2\n  程序目的/Purpose          :\n  此示例程序演示了如何使用WiFiServer库建立网络服务器。\n  通过以下网址可以设置板载LED灯的状态\n  http://server_ip/gpio/0将设置 LED_BUILTIN 引脚设置为低电平，\n  http://server_ip/gpio/1将设置 LED_BUILTIN 引脚设置为高电平\n  以上网址链接中的server_ip指的是ESP8266模块的IP地址。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n//此处设置您的wifi接入信息\n#ifndef STASSID\n#define STASSID \"z\"\n#define STAPSK  \"18xxxxxx52\"\n#endif\n \nconst char* ssid = STASSID;\nconst char* password = STAPSK;\n \n//创建TCP server对象,并将端口指定为80\nWiFiServer server(80);\n \nvoid setup() {\n  //打开串口\n  Serial.begin(115200);\n \n  //初始化板载LED\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, 0);\n \n  //连接WiFi\n  Serial.println();\n  Serial.println();\n  Serial.print(F(\"Connecting to \"));\n  Serial.println(ssid);\n \n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(F(\".\"));\n  }\n  Serial.println();\n  Serial.println(F(\"WiFi connected\"));\n \n  //启动TCP server服务器\n  server.begin();\n  Serial.println(F(\"Server started\"));\n \n  //停止小包合并发送\n  server.setNoDelay(true);\n  \n  //打印TCP server状态码\n  Serial.print(F(\"server.status :\"));\n  Serial.println(server.status());\n \n \n  //打印IP地址\n  Serial.println(WiFi.localIP());\n}\n \nvoid loop() {\n  //检查客户端是否已连接\n  WiFiClient client = server.available();\n  if (!client) {\n    return;\n  }\n  Serial.println(F(\"new client\"));\n \n  client.setTimeout(5000); //默认为 1000\n \n  //打印TCP server状态码\n  Serial.print(F(\"server.status :\"));\n  Serial.println(server.status());\n \n \n  //读取客户端发起的TCP请求\n  String req = client.readStringUntil('\\r');\n  Serial.println(F(\"request: \"));\n  Serial.println(req);\n \n  //解析请求里是否含有以下指定内容\n  int val;\n  //检查发起的请求内容是否包含\"/gpio/0\"\n  if (req.indexOf(F(\"/gpio/0\")) != -1) {\n    val = 0;\n \n    //检查发起的请求内容是否包含\"/gpio/1\"\n  } else if (req.indexOf(F(\"/gpio/1\")) != -1) {\n    val = 1;\n  } else {\n    Serial.println(F(\"invalid request\"));\n    val = digitalRead(LED_BUILTIN);\n  }\n \n  //根据要求设置板载LED状态\n  digitalWrite(LED_BUILTIN, val);\n \n  //读取剩余的内容,用于清除缓存\n  while (client.available()) {\n    client.read();\n  }\n \n  //将响应体发送到客户端 注:若要使用中文则必须在其中添加<meta charset=\\\"utf-8\\\">声明编码\n  client.print(F(\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<!DOCTYPE HTML>\\r\\n<html>\\r\\n<meta charset=\\\"utf-8\\\">NodeMCU板载LED灯的状态 : \"));\n  client.print((val) ? F(\"关\") : F(\"开\"));\n  client.print(F(\"<br><br> <a href='http://\"));\n  client.print(WiFi.localIP());\n  client.print(F(\"/gpio/1'>  点击关灯  </a> , 或  <a href='http://\"));\n  client.print(WiFi.localIP());\n  client.print(F(\"/gpio/0'>  点击开灯  </a> </html>\"));\n \n  //通过浏览器点击按钮之后,TCP连接将会被重置,并且浏览器会发起新的TCP请求到我们的8266服务器,从而去控制LED灯\n  Serial.println(F(\"Disconnecting from client\"));\n \n}\n```\n\n\n\n\n\n\n\n#### stop – 停止服务器\n\n##### 说明\n\n本函数用于停止ESP8266开发板所建立的网络服务器。\n\n注: stop函数和[close](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiserver/close/)函数功能相同。\n\n##### 语法\n\n```\nserver.stop()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n```c\n/**********************************************************************\n程序名称/Program name     : WIFIServer_demo_3_stop\n程序目的/Purpose          : \n此示例程序演示了如何使用WiFiServer库建立网络服务器。服务器将根据浏览器请求设置板载LED灯的状态;\nhttp://server_ip/gpio/0将设置 LED_BUILTIN 拉低，http://server_ip/gpio/1将设置 LED_BUILTIN 拉高\n以上网址链接中的server_ip是ESP8266模块的IP地址，连接WiFi成功后将自动将ip打印在串口;\n在浏览器点击“关闭LED”3次之后关闭tcp server服务器。我们是通过以下程序中的server.stop()实现这一功能的。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n//设置您的wifi接入信息\n#ifndef STASSID\n#define STASSID \"taichimaker\"\n#define STAPSK  \"12345678\"\n#endif\n \nconst char* ssid = STASSID;\nconst char* password = STAPSK;\n \n//创建TCP server对象,并将端口指定为80\nWiFiServer server(80);\n \nint server_stop_switch = 0 ;\n \nvoid setup() {\n  //打开串口\n  Serial.begin(115200);\n \n  //初始化板载LED\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, 0);\n \n  //连接WiFi\n  Serial.println();\n  Serial.println();\n  Serial.print(F(\"Connecting to \"));\n  Serial.println(ssid);\n \n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(F(\".\"));\n  }\n  Serial.println();\n  Serial.println(F(\"WiFi connected\"));\n \n  //启动TCP server服务器\n  server.begin();\n  Serial.println(F(\"Server started\"));\n \n  //打印IP地址\n  Serial.println(WiFi.localIP());\n}\n \nvoid loop() {\n  //检查客户端是否已连接\n  WiFiClient client = server.available();\n  if (!client) {\n    return;\n  }\n  Serial.println(F(\"new client\"));\n \n  client.setTimeout(5000); //默认为 1000\n \n  //读取客户端发起的TCP请求\n  String req = client.readStringUntil('\\r');\n  Serial.println(F(\"request: \"));\n  Serial.println(req);\n \n  int val;\n  \n  //通过浏览器请求控制LED\n  if (req.indexOf(F(\"/gpio/0\")) != -1) {\n    val = 0;\n  } else if (req.indexOf(F(\"/gpio/1\")) != -1) {\n    val = 1;\n    server_stop_switch++;\n  } else {\n    Serial.println(F(\"invalid request\"));\n    val = digitalRead(LED_BUILTIN);\n  }\n \n  //根据要求设置板载LED状态\n  digitalWrite(LED_BUILTIN, val);\n \n  //读取剩余的内容,用于清除缓存\n  while (client.available()) {\n    client.read();\n  }\n \n  //将响应体发送到客户端 注:若要使用中文则必须在其中添加<meta charset=\\\"utf-8\\\">声明编码\n  client.print(F(\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<!DOCTYPE HTML>\\r\\n<html>\\r\\n<meta charset=\\\"utf-8\\\">NodeMCU板载LED灯的状态 : \"));\n  client.print((val) ? F(\"关\") : F(\"开\"));\n  client.print(F(\"<br><br> <a href='http://\"));\n  client.print(WiFi.localIP());\n  client.print(F(\"/gpio/1'>  点击关灯（关灯3次后将会关闭服务器）</a> , 或  <a href='http://\"));\n  client.print(WiFi.localIP());\n  client.print(F(\"/gpio/0'>  点击开灯 </a> </html>\"));\n \n  //通过浏览器点击按钮之后,TCP连接将会被重置,并且浏览器会发起新的TCP请求到我们的8266服务器,从而去控制LED灯\n  Serial.println(F(\"Disconnecting from client\"));\n \n  //  如果 server_stop_switch >= 3 时则关闭TCP server\n  if (server_stop_switch >= 3) {\n    Serial.println(F(\"TCP server turn off \"));\n    server.stop();\n  }\n}\n```\n\n\n\n#### close – 停止服务器\n\n##### 说明\n\n本函数用于停止ESP8266开发板所建立的网络服务器。\n\n注: close函数和[stop](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiserver/stop/)函数功能相同。\n\n##### 语法\n\n`server.close()`\n\n##### 参数\n\n无\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n```c\n/**********************************************************************\n程序名称/Program name     : WIFIServer_demo_3_close\n程序目的/Purpose          : \n此示例程序演示了如何使用WiFiServer库建立网络服务器。服务器将根据浏览器请求设置板载LED灯的状态;\nhttp://server_ip/gpio/0将设置 LED_BUILTIN 拉低，http://server_ip/gpio/1将设置 LED_BUILTIN 拉高\n以上网址链接中的server_ip是ESP8266模块的IP地址，连接WiFi成功后将自动将ip打印在串口;\n在浏览器点击“关闭LED”3次之后关闭tcp server服务器。我们是通过以下程序中的server.close()实现这一功能的。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n//设置您的wifi接入信息\n#ifndef STASSID\n#define STASSID \"taichimaker\"\n#define STAPSK  \"12345678\"\n#endif\n \nconst char* ssid = STASSID;\nconst char* password = STAPSK;\n \n//创建TCP server对象,并将端口指定为80\nWiFiServer server(80);\n \nint server_stop_switch = 0 ;\n \nvoid setup() {\n  //打开串口\n  Serial.begin(115200);\n \n  //初始化板载LED\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, 0);\n \n  //连接WiFi\n  Serial.println();\n  Serial.println();\n  Serial.print(F(\"Connecting to \"));\n  Serial.println(ssid);\n \n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(F(\".\"));\n  }\n  Serial.println();\n  Serial.println(F(\"WiFi connected\"));\n \n  //启动TCP server服务器\n  server.begin();\n  Serial.println(F(\"Server started\"));\n \n  //打印IP地址\n  Serial.println(WiFi.localIP());\n}\n \nvoid loop() {\n  //检查客户端是否已连接\n  WiFiClient client = server.available();\n  if (!client) {\n    return;\n  }\n  Serial.println(F(\"new client\"));\n \n  client.setTimeout(5000); //默认为 1000\n \n  //读取客户端发起的TCP请求\n  String req = client.readStringUntil('\\r');\n  Serial.println(F(\"request: \"));\n  Serial.println(req);\n \n  int val;\n  \n  //通过浏览器请求控制LED\n  if (req.indexOf(F(\"/gpio/0\")) != -1) {\n    val = 0;\n  } else if (req.indexOf(F(\"/gpio/1\")) != -1) {\n    val = 1;\n    server_stop_switch++;\n  } else {\n    Serial.println(F(\"invalid request\"));\n    val = digitalRead(LED_BUILTIN);\n  }\n \n  //根据要求设置板载LED状态\n  digitalWrite(LED_BUILTIN, val);\n \n  //读取剩余的内容,用于清除缓存\n  while (client.available()) {\n    client.read();\n  }\n \n  //将响应体发送到客户端 注:若要使用中文则必须在其中添加<meta charset=\\\"utf-8\\\">声明编码\n  client.print(F(\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<!DOCTYPE HTML>\\r\\n<html>\\r\\n<meta charset=\\\"utf-8\\\">NodeMCU板载LED灯的状态 : \"));\n  client.print((val) ? F(\"关\") : F(\"开\"));\n  client.print(F(\"<br><br> <a href='http://\"));\n  client.print(WiFi.localIP());\n  client.print(F(\"/gpio/1'>  点击关灯（关灯3次后将会关闭服务器）</a> , 或  <a href='http://\"));\n  client.print(WiFi.localIP());\n  client.print(F(\"/gpio/0'>  点击开灯 </a> </html>\"));\n \n  //通过浏览器点击按钮之后,TCP连接将会被重置,并且浏览器会发起新的TCP请求到我们的8266服务器,从而去控制LED灯\n  Serial.println(F(\"Disconnecting from client\"));\n \n  //  如果 server_stop_switch >= 3 时则关闭TCP server\n  if (server_stop_switch >= 3) {\n    Serial.println(F(\"TCP server turn off \"));\n    server.close();\n  }\n}\n```\n\n\n\n\n\n\n\n\n\n### 服务器信息类型\n\n#### status – 获取服务器运行状态\n\n##### 说明\n\n此函数用于获取ESP8266服务器的工作状态。工作状态信息将以”状态值”形式返回。\n\n如需了解具体状态信息内容，请参考本页面的返回值部分。\n\n##### 语法\n\n```\nserver.status()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n服务器状态值(类型：uint8_t)。以下是状态值所对应的数值说明。\n\n- CLOSED = 0 （关闭连接）\n- LISTEN = 1 （监听）\n- SYN_SENT = 2\n- SYN_RCVD = 3\n- ESTABLISHED = 4 （建立连接）\n- FIN_WAIT_1 = 5\n- FIN_WAIT_2 = 6\n- CLOSE_WAIT = 7 （关闭连接等待）\n- CLOSING = 8 （关闭连接中）\n- LAST_ACK = 9\n- TIME_WAIT = 10\n\n##### 示例程序\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WIFIServer_demo_4\n  程序目的/Purpose          :\n  此示例程序演示了如何使用WiFiServer库建立网络服务器。通过以下网址可以设置板载LED灯的状态\n  http://server_ip/gpio/0将设置 LED_BUILTIN 引脚设置为低电平，\n  http://server_ip/gpio/1将设置 LED_BUILTIN 引脚设置为高电平\n  以上网址链接中的server_ip指的是ESP8266模块的IP地址。\n  在程序运行中同时会将ESP8266的状态码通过串口监视器显示。我们使用了server.status来获取这一信息。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n//此处设置您的wifi接入信息\n#ifndef STASSID\n#define STASSID \"taichimaker\"\n#define STAPSK  \"12345678\"\n#endif\n \nconst char* ssid = STASSID;\nconst char* password = STAPSK;\n \n//创建TCP server对象,并将端口指定为80\nWiFiServer server(80);\n \nvoid setup() {\n  //打开串口\n  Serial.begin(115200);\n \n  //初始化板载LED\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, 0);\n \n  //连接WiFi\n  Serial.println();\n  Serial.println();\n  Serial.print(F(\"Connecting to \"));\n  Serial.println(ssid);\n \n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(F(\".\"));\n  }\n  Serial.println();\n  Serial.println(F(\"WiFi connected\"));\n \n  //启动TCP server服务器\n  server.begin();\n  Serial.println(F(\"Server started\"));\n \n  //打印TCP server状态码\n  Serial.print(F(\"server.status :\"));\n  Serial.println(server.status());\n \n  //打印IP地址\n  Serial.println(WiFi.localIP());\n}\n \nvoid loop() {\n  //检查客户端是否已连接\n  WiFiClient client = server.available();\n  if (!client) {\n    return;\n  }\n  Serial.println(F(\"new client\"));\n \n  client.setTimeout(5000); //默认为 1000\n \n  //打印TCP server状态码\n  Serial.print(F(\"server.status :\"));\n  Serial.println(server.status());\n \n  //读取客户端发起的TCP请求\n  String req = client.readStringUntil('\\r');\n  Serial.println(F(\"request: \"));\n  Serial.println(req);\n \n  //解析请求里是否含有以下指定内容\n  int val;\n  //检查发起的请求内容是否包含\"/gpio/0\"\n  if (req.indexOf(F(\"/gpio/0\")) != -1) {\n    val = 0;\n \n    //检查发起的请求内容是否包含\"/gpio/1\"\n  } else if (req.indexOf(F(\"/gpio/1\")) != -1) {\n    val = 1;\n  } else {\n    Serial.println(F(\"invalid request\"));\n    val = digitalRead(LED_BUILTIN);\n  }\n \n  //根据要求设置板载LED状态\n  digitalWrite(LED_BUILTIN, val);\n \n  //读取剩余的内容,用于清除缓存\n  while (client.available()) {\n    client.read();\n  }\n \n  //将响应体发送到客户端 注:若要使用中文则必须在其中添加<meta charset=\\\"utf-8\\\">声明编码\n  client.print(F(\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<!DOCTYPE HTML>\\r\\n<html>\\r\\n<meta charset=\\\"utf-8\\\">NodeMCU板载LED灯的状态 : \"));\n  client.print((val) ? F(\"关\") : F(\"开\"));\n  client.print(F(\"<br><br> <a href='http://\"));\n  client.print(WiFi.localIP());\n  client.print(F(\"/gpio/1'>  点击关灯  </a> , 或  <a href='http://\"));\n  client.print(WiFi.localIP());\n  client.print(F(\"/gpio/0'>  点击开灯  </a> </html>\"));\n \n  //通过浏览器点击按钮之后,TCP连接将会被重置,并且浏览器会发起新的TCP请求到我们的8266服务器,从而去控制LED灯\n  Serial.println(F(\"Disconnecting from client\"));\n}\n```\n\n\n\n#### hasClient – 判断是否有客户端访问\n\n##### 说明\n\n本函数用于检查是否有客户端访问ESP8266开发板所建立的网络服务器。\n\n##### 语法\n\n`server.hasClient()`\n\n##### 参数\n\n无\n\n##### 返回值\n\n返回值类型为bool。当检查到有客户端访问ESP8266开发板所建立的网络服务器，则返回true，否则返回false。\n\n##### 示例程序\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WIFIServer_demo_5\n  程序目的/Purpose          :\n  此示例程序演示了如何使用WiFiServer库建立网络服务器。通过以下网址可以设置板载LED灯的状态\n  http://server_ip/gpio/0将设置 LED_BUILTIN 引脚设置为低电平，\n  http://server_ip/gpio/1将设置 LED_BUILTIN 引脚设置为高电平\n  以上网址链接中的server_ip指的是ESP8266模块的IP地址。\n  本程序使用了server.hasClient函数来判断是否有客户端与服务器产生连接。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n \n//此处设置您的wifi接入信息\n#ifndef STASSID\n#define STASSID \"taichimaker\"\n#define STAPSK  \"12345678\"\n#endif\n \nconst char* ssid = STASSID;\nconst char* password = STAPSK;\n \n//创建TCP server对象,并将端口指定为80\nWiFiServer server(80);\n \nvoid setup() {\n  //打开串口\n  Serial.begin(115200);\n \n  //初始化板载LED\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, 0);\n \n  //连接WiFi\n  Serial.println();\n  Serial.println();\n  Serial.print(F(\"Connecting to \"));\n  Serial.println(ssid);\n \n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(F(\".\"));\n  }\n  Serial.println();\n  Serial.println(F(\"WiFi connected\"));\n \n  //启动TCP server服务器\n  server.begin();\n  Serial.println(F(\"Server started\"));\n \n  //停止小包合并发送,停止之后,消息会直接发送,不会延时\n  server.setNoDelay(true);\n \n  //打印TCP server状态码\n  Serial.print(F(\"server.status :\"));\n  Serial.println(server.status());\n \n \n  //打印IP地址\n  Serial.println(WiFi.localIP());\n}\n \nvoid loop() {\n  //使用server.hasClient()来确保有效的TCP连接\n  if (server.hasClient()) {\n    //检查客户端是否已连接\n    WiFiClient client = server.available();\n    if (!client) {\n      return;\n    }\n    Serial.println(F(\"new client\"));\n \n    client.setTimeout(5000); //默认为 1000\n \n    //打印TCP server状态码\n    Serial.print(F(\"server.status :\"));\n    Serial.println(server.status());\n \n \n    //读取客户端发起的TCP请求\n    String req = client.readStringUntil('\\r');\n    Serial.println(F(\"request: \"));\n    Serial.println(req);\n \n    //解析请求里是否含有以下指定内容\n    int val;\n    //检查发起的请求内容是否包含\"/gpio/0\"\n    if (req.indexOf(F(\"/gpio/0\")) != -1) {\n      val = 0;\n \n      //检查发起的请求内容是否包含\"/gpio/1\"\n    } else if (req.indexOf(F(\"/gpio/1\")) != -1) {\n      val = 1;\n    } else {\n      Serial.println(F(\"invalid request\"));\n      val = digitalRead(LED_BUILTIN);\n    }\n \n    //根据要求设置板载LED状态\n    digitalWrite(LED_BUILTIN, val);\n \n    //读取剩余的内容,用于清除缓存\n    while (client.available()) {\n      client.read();\n    }\n \n    //将响应体发送到客户端 注:若要使用中文则必须在其中添加<meta charset=\\\"utf-8\\\">声明编码\n    client.print(F(\"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n<!DOCTYPE HTML>\\r\\n<html>\\r\\n<meta charset=\\\"utf-8\\\">NodeMCU板载LED灯的状态 : \"));\n    client.print((val) ? F(\"关\") : F(\"开\"));\n    client.print(F(\"<br><br> <a href='http://\"));\n    client.print(WiFi.localIP());\n    client.print(F(\"/gpio/1'>  点击关灯  </a> , 或  <a href='http://\"));\n    client.print(WiFi.localIP());\n    client.print(F(\"/gpio/0'>  点击开灯  </a> </html>\"));\n \n    //通过浏览器点击按钮之后,TCP连接将会被重置,并且浏览器会发起新的TCP请求到我们的8266服务器,从而去控制LED灯\n    Serial.println(F(\"Disconnecting from client\"));\n  }\n}\n```\n\n\n\n\n\n## ESP8266 – ESP8266HTTPClient库\n\nESP8266HTTPClient库用于HTTP协议通讯。通过ESP8266HTTPClient库，我们可以使用ESP8266利用互联网或局域网向网络服务器发送HTTP请求，并且分析网络服务器返回的HTTP响应信息，从而实现物联网应用。\n\nESP8266库中还有一个专门用于TCP通讯的[WiFiClient库](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wificlient/)。由于HTTP协议是建立在TCP协议基础之上的，我们也可以使用WiFiClient库来实现HTTP通讯。在这一点上，ESP8266HTTPClient库与WiFiClient库在功能上形成了互补。\n\n以下为ESP8266HTTPClient库的整体结构图。\n\n![image-20230526215740740](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230526215740740.png)\n\n### 请求类型\n\n#### 请求信息类型\n\n##### begin – 设置请求URL\n\n###### 说明\n\n物联网应用中，我们经常使用ESP8266通过HTTP协议向网络服务器发送HTTP请求。本函数用于设置ESP8266发送HTTP请求的目标URL。\n\n###### 语法\n\n`httpClient.begin(url)`\n`httpClient.begin(url, port)`\n\n###### 参数\n\nurl: HTTP请求网址\nport: HTTP请求的网络服务器端口 (此参数为可选参数，默认为端口80)\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求并通过串口监视器将网站服务器响应信息通过串口监视器显示出来。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : HTTPClient_begin\n  程序目的/Purpose          :\n  此程序用于演示如何使用ESP8266来向www.example.com网站服务器发送HTTP请求并通过串口\n  监视器将网站服务器响应信息通过串口监视器显示出来。\n***********************************************************************/\n #include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n \n// 测试HTTP请求用的URL\n#define URL \"http://www.example.com\"\n \n// 设置wifi接入信息(请根据您的WiFi信息进行修改)\nconst char* ssid = \"taichimaker\";\nconst char* password = \"12345678\";\n \nvoid setup() {\n  //初始化串口设置\n  Serial.begin(9600);\n \n  //设置ESP8266工作模式为无线终端模式\n  WiFi.mode(WIFI_STA);\n \n  //开始连接wifi\n  WiFi.begin(ssid, password);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"WiFi Connected!\");\n}\n \nvoid loop() {\n  // 如果ESP8266连接WiFi则发送HTTP请求\n  if ((WiFi.status() == WL_CONNECTED)) {\n    esp8266Http();\n  }\n  \n  delay(5000);   // 短暂等待\n}\n \n// 发送HTTP请求并且将服务器响应通过串口输出\nvoid esp8266Http(){\n \n  //创建 HTTPClient 对象\n  HTTPClient httpClient;\n \n  //配置请求地址。此处也可以不使用端口号和PATH而单纯的\n  httpClient.begin(URL); \n  Serial.print(\"URL: \"); Serial.println(URL);\n \n  //启动连接并发送HTTP请求\n  int httpCode = httpClient.GET();\n  Serial.print(\"Send GET request to URL: \");\n  Serial.println(URL);\n  \n  //如果服务器响应OK则从服务器获取响应体信息并通过串口输出\n  //如果服务器不响应OK则将服务器响应状态码通过串口输出\n  if (httpCode == HTTP_CODE_OK) {\n    String responsePayload = httpClient.getString();\n    Serial.println(\"Server Response Payload: \");\n    Serial.println(responsePayload);\n  } else {\n    Serial.println(\"Server Respose Code：\");\n    Serial.println(httpCode);\n  }\n \n  //关闭ESP8266与服务器连接\n  httpClient.end();\n}\n```\n\n###### 相关内容\n\n— GET\n— end – 结束请求\n\n\n\n\n\n\n\n##### setReuse – 设置请求头中的keep-alive\n\n###### 说明\n\n此函数用于设置ESP8266开发板在通过HTTP发送请求时，请求头中的keep-alive是否为”true”。\n\nHTTP keep-alive 也称为 HTTP 长连接。它通过重用一个 TCP 连接来发送/接收多个 HTTP请求，来减少创建/关闭多个 TCP 连接的开销。\n\n如果设置 keep-alive为true，则服务端在返回 response 后不关闭 TCP 连接；同样的，在接收完响应报文后，客户端也不关闭连接，发送下一个 HTTP 请求时会重用该连接。\n\n###### 语法\n\n`httpClient.setReuse（true）`\n`httpClient.setReuse（false）`\n\n###### 参数\n\n返回值类型为布尔型。返回值的简要说明如下：\ntrue: 启用请求头中的keep-alive\nfalse: 禁用请求头中的keep-alive\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n您将以下示例程序的WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求并通过串口监视器将网站服务器响应信息通过串口监视器显示出来。\n\n以下是本程序控制下，ESP8266发送的HTTP请求信息：\n\n```c\n/**********************************************************************\n  程序名称/Program name     : HTTPClient_setReuse\n  程序目的/Purpose          :\n  此程序用于演示如何使用ESP8266来向www.example.com网站服务器发送HTTP请求并通过串口\n  监视器将网站服务器响应信息通过串口监视器显示出来。\n  程序使用了setReuse函数来设置请求头中的keep-alive。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n \n// 测试HTTP请求用的URL\n#define URL \"http://www.example.com\"\n \n// 设置wifi接入信息(请根据您的WiFi信息进行修改)\nconst char* ssid = \"taichimaker\";\nconst char* password = \"12345678\";\n \nvoid setup() {\n  //初始化串口设置\n  Serial.begin(9600);\n \n  //设置ESP8266工作模式为无线终端模式\n  WiFi.mode(WIFI_STA);\n \n  //开始连接wifi\n  WiFi.begin(ssid, password);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.println(\"WiFi Connected!\");\n}\n \nvoid loop() {\n  // 如果ESP8266连接WiFi则发送HTTP请求\n  if ((WiFi.status() == WL_CONNECTED)) {\n    esp8266Http();\n  }\n  \n  delay(5000);   // 短暂等待\n}\n \n// 发送HTTP请求并且将服务器响应通过串口输出\nvoid esp8266Http(){\n \n  //创建 HTTPClient 对象\n  HTTPClient httpClient;\n \n  //配置请求地址。此处也可以不使用端口号和PATH而单纯的\n  httpClient.begin(URL); \n  Serial.print(\"URL: \"); Serial.println(URL);\n \n  //设置请求头中的keep-alive\n  httpClient.setReuse(true);\n \n  //启动连接并发送HTTP请求\n  int httpCode = httpClient.GET();\n  Serial.print(\"Send GET request to URL: \");\n  Serial.println(URL);\n  \n  //如果服务器响应OK则从服务器获取响应体信息并通过串口输出\n  //如果服务器不响应OK则将服务器响应状态码通过串口输出\n  if (httpCode == HTTP_CODE_OK) {\n    String responsePayload = httpClient.getString();\n    Serial.println(\"Server Response Payload: \");\n    Serial.println(responsePayload);\n  } else {\n    Serial.println(\"Server Respose Code：\");\n    Serial.println(httpCode);\n  }\n \n  //关闭ESP8266与服务器连接\n  httpClient.end();\n}\n```\n\n###### 相关内容\n\n— begin – 设置请求URL\n— setUserAgent – 设置请求头中的User-Agent\n— setAuthorization – 设置请求头中的Authorization\n— addHeader – 请求头中添加自定义信息\n— useHTTP10 – 设置http协议版本\n\n\n\n\n\n\n\n##### setUserAgent – 设置请求头中的User-Agent\n\n###### 说明\n\nESP8266开发板在通过HTTP发送请求时，我们可以使用此函数设置请求头的User-Agent内容。\n\nUser Agent请求头的作用是让服务器能够识别客户端使用的操作系统及版本、客户端设备的CPU类型、浏览器名称和版本、浏览器所用的语言、浏览器所用的插件等。换句话说,就是告诉服务端现在是什么设备在访问服务器。\n\n###### 语法\n\n```\nhttpClient.setUserAgent（device_info）\n```\n\n###### 参数\n\n– device_info : 用户自定义的客户端标识\n– 参数类型: 字符串 或 const char *\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n您将以下示例程序的WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求并通过串口监视器将网站服务器响应信息通过串口监视器显示出来。\n\n以下是本程序控制下，ESP8266发送的HTTP请求信息：\n\n```\nGET / HTTP/1.1\nHost: 192.168.0.110\nUser-Agent: ESP8266\nConnection: keep-alive\nAccept-Encoding: identity;q=1,chunked;q=0.1,*;q=0\nContent-Length: 0\n```\n\n其中`User-Agent: ESP8266`部分即是通过以下程序中的`httpClient.setUserAgent(\"ESP8266\");`来实现的。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : HTTPClient_setReuse\n  程序目的/Purpose          :\n  此程序用于演示如何使用ESP8266来向www.example.com网站服务器发送HTTP请求并通过串口\n  监视器将网站服务器响应信息通过串口监视器显示出来。\n  程序使用了setUserAgent函数来设置请求头中的客户端信息。\n***********************************************************************/\n #include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n \n// 测试HTTP请求用的URL\n#define URL \"http://www.example.com\"\n \n// 设置wifi接入信息(请根据您的WiFi信息进行修改)\nconst char* ssid = \"taichimaker\";\nconst char* password = \"12345678\";\n \nvoid setup() {\n  //初始化串口设置\n  Serial.begin(9600);\n \n  //设置ESP8266工作模式为无线终端模式\n  WiFi.mode(WIFI_STA);\n \n  //开始连接wifi\n  WiFi.begin(ssid, password);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.println(\"WiFi Connected!\");\n}\n \nvoid loop() {\n  // 如果ESP8266连接WiFi则发送HTTP请求\n  if ((WiFi.status() == WL_CONNECTED)) {\n    esp8266Http();\n  }\n  \n  delay(5000);   // 短暂等待\n}\n \n// 发送HTTP请求并且将服务器响应通过串口输出\nvoid esp8266Http(){\n \n  //创建 HTTPClient 对象\n  HTTPClient httpClient;\n \n  //配置请求地址。此处也可以不使用端口号和PATH而单纯的\n  httpClient.begin(URL); \n  Serial.print(\"URL: \"); Serial.println(URL);\n \n  //设置请求头中的User-Agent\n  httpClient.setUserAgent(\"ESP8266\");\n \n  //启动连接并发送HTTP请求\n  int httpCode = httpClient.GET();\n  Serial.print(\"Send GET request to URL: \");\n  Serial.println(URL);\n  \n  //如果服务器响应OK则从服务器获取响应体信息并通过串口输出\n  //如果服务器不响应OK则将服务器响应状态码通过串口输出\n  if (httpCode == HTTP_CODE_OK) {\n    String responsePayload = httpClient.getString();\n    Serial.println(\"Server Response Payload: \");\n    Serial.println(responsePayload);\n  } else {\n    Serial.println(\"Server Respose Code：\");\n    Serial.println(httpCode);\n  }\n \n  //关闭ESP8266与服务器连接\n  httpClient.end();\n}\n```\n\n###### 相关内容\n\n— begin – 设置请求URL\n— setReuse – 设置请求头中的keep-alive\n— setAuthorization – 设置请求头中的Authorization\n— addHeader – 请求头中添加自定义信息\n— useHTTP10 – 设置http协议版本\n\n\n\n\n\n\n\n##### setAuthorization – 设置请求头中的Authorization\n\n###### 说明\n\n此函数用于设置ESP8266开发板在通过HTTP发送请求时，设置请求头中的Authorization部分。\n\n###### 语法\n\n```\nhttpClient.setAuthorization(user,password)\n```\n\n###### 参数\n\nuser: 设备进行访问的用户名请求头信息\n\npassword: 设备进行访问的密码请求头信息\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n您将以下示例程序的WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求并通过串口监视器将网站服务器响应信息通过串口监视器显示出来。\n\n以下是本程序控制下，ESP8266发送的HTTP请求信息：\n\n```\nGET / HTTP/1.1\nHost: www.example.com\nUser-Agent: ESP8266HTTPClient\nConnection: keep-alive\nAccept-Encoding: identity;q=1,chunked;q=0.1,*;q=0\nAuthorization: Basic VGFpY2hpTWFrZXI6MTIzNDU2Nzg=\nContent-Length: 0\n```\n\n其中`Authorization: Basic VGFpY2hpTWFrZXI6MTIzNDU2Nzg=`部分即是通过以下程序中的`httpClient.setUserAgent(“TaichiMaker”, \"12345678\");`来实现的。(www.example.com网站不需要认证即可访问，此示例程序仅仅是为了演示如何使用setUserAgent。)\n\n```c\n/**********************************************************************\n  程序名称/Program name     : HTTPClient_setReuse\n  程序目的/Purpose          :\n  此程序用于演示如何使用ESP8266来向www.example.com网站服务器发送HTTP请求并通过串口\n  监视器将网站服务器响应信息通过串口监视器显示出来。\n  程序使用了setUserAgent函数来将ESP8266发送的HTTP请求头中Authorization部分\n  的user信息设置为\"TaichiMaker\"，password部分设置为\"12345678\"。\n***********************************************************************/\n #include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n \n// 测试HTTP请求用的URL\n#define URL \"http://www.example.com\"\n \n// 设置wifi接入信息(请根据您的WiFi信息进行修改)\nconst char* ssid = \"taichimaker\";\nconst char* password = \"12345678\";\n \nvoid setup() {\n  //初始化串口设置\n  Serial.begin(9600);\n \n  //设置ESP8266工作模式为无线终端模式\n  WiFi.mode(WIFI_STA);\n \n  //开始连接wifi\n  WiFi.begin(ssid, password);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.println(\"WiFi Connected!\");\n}\n \nvoid loop() {\n  // 如果ESP8266连接WiFi则发送HTTP请求\n  if ((WiFi.status() == WL_CONNECTED)) {\n    esp8266Http();\n  }\n  \n  delay(5000);   // 短暂等待\n}\n \n// 发送HTTP请求并且将服务器响应通过串口输出\nvoid esp8266Http(){\n \n  //创建 HTTPClient 对象\n  HTTPClient httpClient;\n \n  //配置请求地址。此处也可以不使用端口号和PATH而单纯的\n  httpClient.begin(URL); \n  Serial.print(\"URL: \"); Serial.println(URL);\n \n  //设置请求头中的Authorization信息\n  httpClient.setAuthorization(\"TaichiMaker\", \"12345678\");\n \n  //启动连接并发送HTTP请求\n  int httpCode = httpClient.GET();\n  Serial.print(\"Send GET request to URL: \");\n  Serial.println(URL);\n  \n  //如果服务器响应OK则从服务器获取响应体信息并通过串口输出\n  //如果服务器不响应OK则将服务器响应状态码通过串口输出\n  if (httpCode == HTTP_CODE_OK) {\n    String responsePayload = httpClient.getString();\n    Serial.println(\"Server Response Payload: \");\n    Serial.println(responsePayload);\n  } else {\n    Serial.println(\"Server Respose Code：\");\n    Serial.println(httpCode);\n  }\n \n  //关闭ESP8266与服务器连接\n  httpClient.end();\n}\n```\n\n###### 相关内容\n\n— begin – 设置请求URL\n— setReuse – 设置请求头中的keep-alive\n— setUserAgent – 设置请求头中的User-Agent\n— addHeader – 请求头中添加自定义信息\n— useHTTP10 – 设置http协议版本\n\n\n\n##### addHeader – 请求头中添加自定义信息\n\n###### 说明\n\n使用此函数，我们可以ESP8266开发板发起HTTP请求的时候,添加自定义的请求头信息。\n\n###### 语法\n\n```\nhttp.addHeader(name,value)\n```\n\n###### 参数\n\nname: 自定义请求头名称 (类型：String 或 const char *)\nvalue: 自定义请求头参数值 (类型：String 或 const char *)\n\n**注：自定义请求头不能使用Connection、User-Agent、Host、Authorization等标准请求头名称。**\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n您将以下示例程序的WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求并通过串口监视器将网站服务器响应信息通过串口监视器显示出来。\n\n以下是本程序控制下，ESP8266发送的HTTP请求信息：\n\n```c\nGET / HTTP/1.1\nHost: www.example.com\nUser-Agent: ESP8266HTTPClient\nConnection: keep-alive\nAccept-Encoding: identity;q=1,chunked;q=0.1,*;q=0\nDevice: ESP8266\nContent-Length: 0\n```\n\n其中`Device: ESP8266`部分即是通过以下程序中的`httpClient.addHeader(\"Device\", \"ESP8266\");`来实现的。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : HTTPClient_addHeader\n  程序目的/Purpose          :\n  此程序用于演示如何使用ESP8266来向www.example.com网站服务器发送HTTP请求并通过串口\n  监视器将网站服务器响应信息通过串口监视器显示出来。\n  程序使用了addHeader函数来将ESP8266发送的HTTP请求头中假如自定义信息\n***********************************************************************/\n #include \n#include \n \n// 测试HTTP请求用的URL\n#define URL \"http://www.example.com\"\n \n// 设置wifi接入信息(请根据您的WiFi信息进行修改)\nconst char* ssid = \"taichimaker\";\nconst char* password = \"12345678\";\n \nvoid setup() {\n  //初始化串口设置\n  Serial.begin(9600);\n \n  //设置ESP8266工作模式为无线终端模式\n  WiFi.mode(WIFI_STA);\n \n  //开始连接wifi\n  WiFi.begin(ssid, password);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.println(\"WiFi Connected!\");\n}\n \nvoid loop() {\n  // 如果ESP8266连接WiFi则发送HTTP请求\n  if ((WiFi.status() == WL_CONNECTED)) {\n    esp8266Http();\n  }\n  \n  delay(5000);   // 短暂等待\n}\n \n// 发送HTTP请求并且将服务器响应通过串口输出\nvoid esp8266Http(){\n \n  //创建 HTTPClient 对象\n  HTTPClient httpClient;\n \n  //配置请求地址。此处也可以不使用端口号和PATH而单纯的\n  httpClient.begin(URL); \n  Serial.print(\"URL: \"); Serial.println(URL);\n \n  //设置请求头中自定义信息\n  httpClient.addHeader(\"Device\", \"ESP8266\");\n \n  //启动连接并发送HTTP请求\n  int httpCode = httpClient.GET();\n  Serial.print(\"Send GET request to URL: \");\n  Serial.println(URL);\n  \n  //如果服务器响应OK则从服务器获取响应体信息并通过串口输出\n  //如果服务器不响应OK则将服务器响应状态码通过串口输出\n  if (httpCode == HTTP_CODE_OK) {\n    String responsePayload = httpClient.getString();\n    Serial.println(\"Server Response Payload: \");\n    Serial.println(responsePayload);\n  } else {\n    Serial.println(\"Server Respose Code：\");\n    Serial.println(httpCode);\n  }\n \n  //关闭ESP8266与服务器连接\n  httpClient.end();\n}\n```\n\n###### 相关内容\n\n— begin – 设置请求URL\n— setReuse – 设置请求头中的keep-alive\n— setUserAgent – 设置请求头中的User-Agent\n— setAuthorization – 设置请求头中的Authorization\n— useHTTP10 – 设置http协议版本\n\n\n\n##### useHTTP10 – 设置http协议版本\n\n###### 说明\n\n此函数用于设置ESP8266开发板在通过HTTP发送请求时使用的HTTP协议版本。\n\n###### 语法\n\n`http.useHTTP10(val)`\n\n###### 参数\n\nval: 控制HTTTP版本。默认情况下，设备时使用HTTTP 1.1 版本。当此参数为true时，则使用HTTTP 1.0版本。false时，使用HTTTP 1.1版本。（参数类型：bool）\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n您将以下示例程序的WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求并通过串口监视器将网站服务器响应信息通过串口监视器显示出来。\n\n以下是本程序控制下，ESP8266发送的HTTP请求信息：\n\n```c\nGET / HTTP/1.0\nHost: www.example.com\nUser-Agent: ESP8266HTTPClient\nConnection: close\nContent-Length: 0\n```\n\n其中`GET / HTTP/1.0`部分即是通过以下程序中的`httpClient.useHTTP10(true);`来实现的。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : HTTPClient_http10\n  程序目的/Purpose          :\n  此程序用于演示如何使用ESP8266来向www.example.com网站服务器发送HTTP请求并通过串口\n  监视器将网站服务器响应信息通过串口监视器显示出来。\n  程序使用了useHTTP10函数来将ESP8266发送的HTTP请求版本设置为1.0版本\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n \n// 测试HTTP请求用的URL\n#define URL \"http://www.example.com\"\n \n// 设置wifi接入信息(请根据您的WiFi信息进行修改)\nconst char* ssid = \"taichimaker\";\nconst char* password = \"12345678\";\n \nvoid setup() {\n  //初始化串口设置\n  Serial.begin(9600);\n \n  //设置ESP8266工作模式为无线终端模式\n  WiFi.mode(WIFI_STA);\n \n  //开始连接wifi\n  WiFi.begin(ssid, password);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.println(\"WiFi Connected!\");\n}\n \nvoid loop() {\n  // 如果ESP8266连接WiFi则发送HTTP请求\n  if ((WiFi.status() == WL_CONNECTED)) {\n    esp8266Http();\n  }\n  \n  delay(5000);   // 短暂等待\n}\n \n// 发送HTTP请求并且将服务器响应通过串口输出\nvoid esp8266Http(){\n \n  //创建 HTTPClient 对象\n  HTTPClient httpClient;\n \n  //配置请求地址。此处也可以不使用端口号和PATH而单纯的\n  httpClient.begin(URL); \n  Serial.print(\"URL: \"); Serial.println(URL);\n \n  //使用http1.0\n  httpClient.useHTTP10(true);\n \n  //启动连接并发送HTTP请求\n  int httpCode = httpClient.GET();\n  Serial.print(\"Send GET request to URL: \");\n  Serial.println(URL);\n  \n  //如果服务器响应OK则从服务器获取响应体信息并通过串口输出\n  //如果服务器不响应OK则将服务器响应状态码通过串口输出\n  if (httpCode == HTTP_CODE_OK) {\n    String responsePayload = httpClient.getString();\n    Serial.println(\"Server Response Payload: \");\n    Serial.println(responsePayload);\n  } else {\n    Serial.println(\"Server Respose Code：\");\n    Serial.println(httpCode);\n  }\n \n  //关闭ESP8266与服务器连接\n  httpClient.end();\n}\n```\n\n\n\n#### 请求方法类型\n\n##### GET\n\n###### 说明\n\n此函数用于ESP8266使用HTTP协议通过网络向服务器发送GET请求。\n\n客户端与服务器通讯时最常被用到的方法是：GET 和 [POST](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266httpclient/post/)。\n– GET – 从指定的资源请求数据。\n– POST – 向指定的资源提交要被处理的数据\n\n###### 语法\n\n```\nhttp.GET()\n```\n\n###### 参数\n\n无\n\n###### 返回值\n\n服务器状态码（返回值类型：int类型）\n\n以下是常见的HTTP状态码（以下括号中内容为ESP8266HTTPClient库声明定义的HTTP状态码替代文字，具体内容可参考[ESP8266库ESP8266HTTPClient.h文件中相应内容](https://github.com/esp8266/Arduino/blob/master/libraries/ESP8266HTTPClient/src/ESP8266HTTPClient.h)）：\n– 200: 请求成功 （HTTP_CODE_OK）\n– 301: 资源（网页等）被永久转移到其它URL (HTTP_CODE_MOVED_PERMANENTLY)\n– 404: 请求的资源（网页等）不存在(HTTP_CODE_NOT_FOUND)\n– 500: 内部服务器错误(HTTP_CODE_INTERNAL_SERVER_ERROR)\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n您将以下示例程序的WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求并通过串口监视器将网站服务器响应信息通过串口监视器显示出来。\n\n以下是本程序控制下，ESP8266发送的HTTP请求信息：\n\n```c\nArduino\nGET / HTTP/1.1\nHost: www.example.com\nUser-Agent: ESP8266HTTPClient\nConnection: keep-alive\nAccept-Encoding: identity;q=1,chunked;q=0.1,*;q=0\nContent-Length: 0\n```\n\n其中HTTP请求方法GET即是通过以下程序中的`httpClient.GET();`来实现的。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : HTTPClient_begin\n  程序目的/Purpose          :\n  此程序用于演示如何使用ESP8266来向www.example.com网站服务器发送GET请求并通过串口\n  监视器将网站服务器响应信息通过串口监视器显示出来。\n***********************************************************************/\n #include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n \n// 测试HTTP请求用的URL\n#define URL \"http://www.example.com\"\n \n// 设置wifi接入信息(请根据您的WiFi信息进行修改)\nconst char* ssid = \"taichimaker\";\nconst char* password = \"12345678\";\n \nvoid setup() {\n  //初始化串口设置\n  Serial.begin(9600);\n \n  //设置ESP8266工作模式为无线终端模式\n  WiFi.mode(WIFI_STA);\n \n  //开始连接wifi\n  WiFi.begin(ssid, password);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"WiFi Connected!\");\n}\n \nvoid loop() {\n  // 如果ESP8266连接WiFi则发送HTTP请求\n  if ((WiFi.status() == WL_CONNECTED)) {\n    esp8266Http();\n  }\n  \n  delay(5000);   // 短暂等待\n}\n \n// 发送HTTP请求并且将服务器响应通过串口输出\nvoid esp8266Http(){\n \n  //创建 HTTPClient 对象\n  HTTPClient httpClient;\n \n  //配置请求地址。此处也可以不使用端口号和PATH而单纯的\n  httpClient.begin(URL); \n  Serial.print(\"URL: \"); Serial.println(URL);\n \n  //启动连接并发送HTTP请求\n  int httpCode = httpClient.GET();\n  Serial.print(\"Send GET request to URL: \");\n  Serial.println(URL);\n  \n  //如果服务器响应OK则从服务器获取响应体信息并通过串口输出\n  //如果服务器不响应OK则将服务器响应状态码通过串口输出\n  if (httpCode == HTTP_CODE_OK) {\n    String responsePayload = httpClient.getString();\n    Serial.println(\"Server Response Payload: \");\n    Serial.println(responsePayload);\n  } else {\n    Serial.println(\"Server Respose Code：\");\n    Serial.println(httpCode);\n  }\n \n  //关闭ESP8266与服务器连接\n  httpClient.end();\n}\n```\n\n###### 相关内容\n\n— POST\n\n\n\n##### POST\n\n###### 说明\n\n此函数用于ESP8266备使用HTTP协议通过网络向服务器发送POST请求。\n\n客户端与服务器通讯时最常被用到的方法是：GET 和 POST。\n– GET – 从指定的资源请求数据。\n– POST – 向指定的资源提交要被处理的数据\n\n###### 语法\n\n`http.POST(payload)`\n\n`http.POST(payload, size)`\n\n###### 参数\n\npayload: 通过POST请求所发送的数据信息（该信息置于请求体中被发送）。该参数可使用字符串类型。\nsize: 通过POST请求所发送的数据字节数(此参数为可选参数，类型：size_t )。\n\n###### 返回值\n\n服务器响应状态码（类型：int）\n\n以下是常见的HTTP状态码（以下括号中内容为ESP8266HTTPClient库声明定义的HTTP状态码替代文字，具体内容可参考ESP8266库ESP8266HTTPClient.h文件中相应内容）：\n\n- – 200: 请求成功 （HTTP_CODE_OK）\n- – 301: 资源（网页等）被永久转移到其它URL (HTTP_CODE_MOVED_PERMANENTLY)\n- – 404: 请求的资源（网页等）不存在(HTTP_CODE_NOT_FOUND)\n- – 500: 内部服务器错误(HTTP_CODE_INTERNAL_SERVER_ERROR)\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n您将以下示例程序的WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向http://quan.suning.com/getSysTime.do发送HTTP请求并通过串口监视器将响应信息通过串口监视器显示出来。\n\n以下是本程序控制下，ESP8266发送的HTTP请求信息：\n\n```\nPOST /getSysTime.do HTTP/1.1\nHost: quan.suning.com\nUser-Agent: ESP8266HTTPClient\nConnection: keep-alive\nAccept-Encoding: identity;q=1,chunked;q=0.1,*;q=0\nContent-Length: 9\n \ndate_test\n```\n\n其中HTTP请求方法POST即是通过以下程序中的`http.POST(\"date_test\")`语句来实现的。另外我们可以看到在以上的请求信息中，请求体部分包含有date_test。该信息即是通过`http.POST(\"date_test\")`语句的参数实现的。\n\n```c\n/**********************************************************************\n  项目名称/Project          : 零基础入门学用物联网\n  程序名称/Program name     : HTTPClient_demo_POST\n  团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)\n  作者/Author              : Dapenson\n  日期/Date（YYYYMMDD）     : 20200325\n  程序目的/Purpose          :\n  以苏宁易购的获取时间的公共api为例子,发起HTTP请求,并将获取到的数据信息打印到串口监视器中\n  具体HTTP请求可参考自定义函数http_POST()内容\n  -----------------------------------------------------------------------\n  本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。\n  该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：\n  http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n \n//以苏宁易购api为例子获取时间数据\n#define SERVER_IP \"http://quan.suning.com/getSysTime.do\"\n \n \n//设置你的wifi接入信息\n#ifndef STASSID\n#define STASSID \"taichimaker\"\n#define STAPSK  \"12345678\"\n#endif\n \nvoid setup() {\n \n  //初始化串口设置\n  Serial.begin(115200);\n  Serial.println();\n \n  //开始连接wifi\n  WiFi.begin(STASSID, STAPSK);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"Connected! IP address: \");\n  Serial.println(WiFi.localIP());\n \n}\n \nvoid loop() {\n  if ((WiFi.status() == WL_CONNECTED)) {\n    http_post();\n  }\n  delay(10000);\n}\n \nvoid http_post() {\n \n  //创建 WiFiClient 实例化对象\n  WiFiClient client;\n \n  //创建http对象\n  HTTPClient http;\n \n  //配置请求地址\n  http.begin(client, SERVER_IP); //HTTP请求\n  Serial.print(\"[HTTP] begin...\\n\");\n \n  //启动连接并发送HTTP报头和报文\n  int httpCode = http.POST(\" \");\n  Serial.print(\"[HTTP] POST...\\n\");\n \n  //连接失败时 httpCode时为负\n  if (httpCode > 0) {\n \n    //将服务器响应头打印到串口\n    Serial.printf(\"[HTTP] POST... code: %d\\n\", httpCode);\n \n    //将从服务器获取的数据打印到串口\n    if (httpCode == HTTP_CODE_OK) {\n      const String& payload = http.getString();\n      Serial.println(\"received payload:\\n<<\");\n      Serial.println(payload);\n      Serial.println(\">>\");\n    }\n  } else {\n    Serial.printf(\"[HTTP] POST... failed, error: %s\\n\", http.errorToString(httpCode).c_str());\n  }\n  //关闭http连接\n  http.end();\n}\n```\n\n###### 相关内容\n\n— GET\n\n\n\n\n\n##### PUT\n\n###### 说明\n\n此函数用于ESP8266使用HTTP协议通过网络向服务器发送PUT请求。\n\n###### 语法\n\n`http.PUT(payload)`\n`http.PUT(payload, size)`\n\n###### 参数\n\npayload:通过PUT请求所发送的数据信息（该信息置于请求体中被发送）。该参数可使用字符串类型。\nsize: 通过PUT请求所发送的数据字节数(此参数为可选参数，类型：size_t )。\n\n###### 返回值\n\n服务器状态码\n\n以下是常见的HTTP状态码（以下括号中内容为ESP8266HTTPClient库声明定义的HTTP状态码替代文字，具体内容可参考[ESP8266库ESP8266HTTPClient.h文件中相应内容](https://github.com/esp8266/Arduino/blob/master/libraries/ESP8266HTTPClient/src/ESP8266HTTPClient.h)）：\n\n- – 200: 请求成功 （HTTP_CODE_OK）\n- – 301: 资源（网页等）被永久转移到其它URL (HTTP_CODE_MOVED_PERMANENTLY)\n- – 404: 请求的资源（网页等）不存在(HTTP_CODE_NOT_FOUND)\n- – 500: 内部服务器错误(HTTP_CODE_INTERNAL_SERVER_ERROR)\n\n###### 相关内容\n\n— GET\n— POST\n\n\n\n\n\n##### PATCH\n\n###### 说明\n\n此函数用于ESP8266使用HTTP协议通过网络向服务器发送PATCH请求。\n\n###### 语法\n\n`http.PATCH(payload)`\n`http.PATCH(payload, size)`\n\n###### 参数\n\npayload:通过PATCH请求所发送的数据信息（该信息置于请求体中被发送）。该参数可使用字符串类型。\nsize: 通过PATCH请求所发送的数据字节数(此参数为可选参数，类型：size_t )。\n\n###### 返回值\n\n服务器响应状态码\n\n以下是常见的HTTP状态码（以下括号中内容为ESP8266HTTPClient库声明定义的HTTP状态码替代文字，具体内容可参考[ESP8266库ESP8266HTTPClient.h文件中相应内容](https://github.com/esp8266/Arduino/blob/master/libraries/ESP8266HTTPClient/src/ESP8266HTTPClient.h)）：\n\n- – 200: 请求成功 （HTTP_CODE_OK）\n- – 301: 资源（网页等）被永久转移到其它URL (HTTP_CODE_MOVED_PERMANENTLY)\n- – 404: 请求的资源（网页等）不存在(HTTP_CODE_NOT_FOUND)\n- – 500: 内部服务器错误(HTTP_CODE_INTERNAL_SERVER_ERROR)\n\n\n\n\n\n#### 发送请求类型\n\n##### sendRequest – 发送请求\n\n###### 说明\n\n此函数用于ESP8266使用HTTP协议通过网络向服务器发送请求。本函数可以自定义请求方法类型，如 GET、POST等。\n\n###### 语法\n\n`sendRequest(type, payload)`\n`sendRequest(type, payload, size)`\n`sendRequest(type, stream, size)`\n\n###### 参数\n\n- type: 发送请求的类型,可以是”GET”、”POST”等。参数类型: const char *\n- payload: 请求所发送的数据信息（该信息置于请求体中被发送）。该参数可使用字符串类型。（使用GET作为请求方法时，此参数可以省略）。\n\n- size: 请求所发送的数据字节数(此参数为可选参数，类型：size_t )。\n\n- stream: 数据流对象\n\n\n###### 返回值\n\n服务器状态码\n\n以下是常见的HTTP状态码：\n\n- – 200 – 请求成功\n- – 301 – 资源（网页等）被永久转移到其它URL\n- – 404 – 请求的资源（网页等）不存在\n- – 500 – 内部服务器错误\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n您将以下示例程序的WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向http://quan.suning.com/getSysTime.do发送HTTP请求并通过串口监视器将响应信息通过串口监视器显示出来。\n\n以下是本程序控制下，ESP8266发送的HTTP请求信息：\n\n```c\nPOST /getSysTime.do HTTP/1.1\nHost: quan.suning.com\nUser-Agent: ESP8266HTTPClient\nConnection: keep-alive\nAccept-Encoding: identity;q=1,chunked;q=0.1,*;q=0\nContent-Length: 9\n\ndate_test\n```\n\n其中HTTP请求方法POST即是通过以下程序中的`http.sendRequest(\"POST\", \"date_test\")`语句来实现的。该语句的第一个参数设置了HTTP请求方法为POST。另外我们可以看到在以上的请求信息中，请求体部分包含有date_test。该信息即是通过`http.sendRequest(\"POST\", \"date_test\")`语句的第二个参数实现的。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : HTTPClient_sendRequest\n  程序目的/Purpose          :\n  以苏宁易购的获取时间的公共api为例子,发起HTTP请求,并将获取到的数据信息打印到串口监视器中\n  具体HTTP请求可参考自定义函数http_POST内容\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n \n//以苏宁易购api为例子获取时间数据\n//#define URL \"http://quan.suning.com/getSysTime.do\"\n#define URL \"http://192.168.0.110\"\n \n//设置你的wifi接入信息\n#ifndef STASSID\n#define STASSID \"taichimaker\"\n#define STAPSK  \"12345678\"\n#endif\n \nvoid setup() { \n  //初始化串口设置\n  Serial.begin(115200);\n  Serial.println();\n \n  //开始连接wifi\n  WiFi.begin(STASSID, STAPSK);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"Connected! IP address: \");\n  Serial.println(WiFi.localIP());\n}\n \nvoid loop() {\n  if ((WiFi.status() == WL_CONNECTED)) {\n    http_post();\n  }\n  delay(10000);\n}\n \nvoid http_post() {\n \n  //创建http对象\n  HTTPClient http;\n \n  //配置请求地址\n  http.begin(URL); //HTTP请求\n  Serial.print(\"[HTTP] begin...\\n\");\n \n  //启动连接并发送HTTP请求。请求方法：POST。请求体信息：date_test\n  int httpCode = http.sendRequest(\"POST\", \"date_test\");\n  Serial.print(\"[HTTP] POST...\\n\");\n \n  //连接失败时 httpCode时为负\n  if (httpCode > 0) {\n \n    //将服务器响应头打印到串口\n    Serial.printf(\"[HTTP] POST... code: %d\\n\", httpCode);\n \n    //将从服务器获取的数据打印到串口\n    if (httpCode == HTTP_CODE_OK) {\n      const String& payload = http.getString();\n      Serial.println(\"received payload:\\n<<\");\n      Serial.println(payload);\n      Serial.println(\">>\");\n    }\n  } else {\n    Serial.printf(\"[HTTP] POST... failed, error: %s\\n\", http.errorToString(httpCode).c_str());\n  }\n  //关闭http连接\n  http.end();\n}\n```\n\n\n\n###### 相关内容\n\n— GET\n— POST\n\n\n\n\n\n\n\n\n\n##### end – 结束请求\n\n###### 说明\n\n当ESP8266发送HTTP请求结束后，我们应该调用此函数来清除ESP8266的接收缓存以便设备再次接收服务器发来的响应信息。\n\n###### 语法\n\n`http.end()`\n\n###### 参数\n\n无\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : HTTPClient_end\n  程序目的/Purpose          :\n  此程序用于演示如何使用ESP8266来向www.example.com网站服务器发送HTTP请求并通过串口\n  监视器将网站服务器响应信息通过串口监视器显示出来。\n***********************************************************************/\n #include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n \n// 测试HTTP请求用的URL\n#define URL \"http://www.example.com\"\n \n// 设置wifi接入信息(请根据您的WiFi信息进行修改)\nconst char* ssid = \"taichimaker\";\nconst char* password = \"12345678\";\n \nvoid setup() {\n  //初始化串口设置\n  Serial.begin(9600);\n \n  //设置ESP8266工作模式为无线终端模式\n  WiFi.mode(WIFI_STA);\n \n  //开始连接wifi\n  WiFi.begin(ssid, password);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"WiFi Connected!\");\n}\n \nvoid loop() {\n  // 如果ESP8266连接WiFi则发送HTTP请求\n  if ((WiFi.status() == WL_CONNECTED)) {\n    esp8266Http();\n  }\n  \n  delay(5000);   // 短暂等待\n}\n \n// 发送HTTP请求并且将服务器响应通过串口输出\nvoid esp8266Http(){\n \n  //创建 HTTPClient 对象\n  HTTPClient httpClient;\n \n  //配置请求地址。此处也可以不使用端口号和PATH而单纯的\n  httpClient.begin(URL); \n  Serial.print(\"URL: \"); Serial.println(URL);\n \n  //启动连接并发送HTTP请求\n  int httpCode = httpClient.GET();\n  Serial.print(\"Send GET request to URL: \");\n  Serial.println(URL);\n  \n  //如果服务器响应OK则从服务器获取响应体信息并通过串口输出\n  //如果服务器不响应OK则将服务器响应状态码通过串口输出\n  if (httpCode == HTTP_CODE_OK) {\n    String responsePayload = httpClient.getString();\n    Serial.println(\"Server Response Payload: \");\n    Serial.println(responsePayload);\n  } else {\n    Serial.println(\"Server Respose Code：\");\n    Serial.println(httpCode);\n  }\n \n  //关闭ESP8266与服务器连接\n  httpClient.end();\n}\n```\n\n\n\n### 响应类型\n\n#### 响应头类型\n\n##### collectHeaders – 设置收集响应头内容\n\n###### 说明\n\n在我们使用ESP8266HTTPClient库中的[header](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266httpclient/header/)、[headers](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266httpclient/headers/) 、[headerName](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266httpclient/headername/) 、[hasHeader](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266httpclient/hasheader/) 函数来处理网站服务器响应头以前，需要首先调用本函数来设置ESP8266具体收集哪些响应头信息。\n\n###### 语法\n\n```\nhttpClient.collectHeaders(headerKeys, headerKeysCount)\n```\n\n###### 参数\n\n– headerKeys: 响应头名数组。此数组中的元素即是需要ESP8266处理或收集的响应头信息。下面我们看一个headerKeys数组的例子：\n`const char *headerKeys[] = {\"Content-Length\", \"Date\"};`\n此数组共有两个元素，分别是”Content-Length”和”Date”。只有如此建立了数组后，接下来的程序里我们才可以使用其它ESP8266HTTPClient库函数来处理这两个响应头的信息内容。可以把这个数组看作是对ESP8266的提醒，即告诉ESP8266在后续的程序中，我们将要对数组中所包含的响应头信息进行处理。（具体操作方法，请见本函数的示例程序部分。）\n\n– headerKeysCount: 需要获取/处理的响应头个数（可选参数，类型：size_t）\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求，并且将服务器响应头中的”Content-Length”和”Date”信息通过串口监视器输出。（如下图所示）\n\n![image-20230526223548235](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230526223548235.png)\n\n我们通过以下示例程序的`const char *headerKeys[] = {\"Content-Length\", \"Date\"};`语句建立了headerKeys数组。该数组将被用于接下来程序中的`httpClient.collectHeaders(headerKeys, 2);`语句。以上操作的目的是为了告知ESP8266我们即将对服务器响应头中的”Content-Length”, “Date”信息进行处理。\n\n在后续的程序中，我们使用了一系列串口输出语句将服务器响应头中的”Content-Length”, “Date”信息通过串口监视器显示，也就是您所看到的上图内容。\n\n值得注意的是，在上图中红色标注的Connection响应头信息是空的。造成这个结果的原因是我们在建立headerKeys数组时，没有在该数组中加入Connection这一元素。那么ESP8266在后续的程序中自然就无法输出Connection信息了。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : HTTPClient_collectHeaders\n  程序目的/Purpose          :\n  此程序用于演示如何使用collectHeaders函数处理www.example.com网站服务器返回的响应信息。\n***********************************************************************/\n #include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n \n// 测试HTTP请求用的URL\n#define URL \"http://www.example.com\"\n \n// 设置wifi接入信息(请根据您的WiFi信息进行修改)\nconst char* ssid = \"taichimaker\";\nconst char* password = \"12345678\";\n \n//需要收集的响应头的信息\nconst char *headerKeys[] = {\"Content-Length\", \"Date\"};\n \nvoid setup() {\n  //初始化串口设置\n  Serial.begin(9600);\n \n  //设置ESP8266工作模式为无线终端模式\n  WiFi.mode(WIFI_STA);\n \n  //开始连接wifi\n  WiFi.begin(ssid, password);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"WiFi Connected!\");\n}\n \nvoid loop() {\n  // 如果ESP8266连接WiFi则发送HTTP请求\n  if ((WiFi.status() == WL_CONNECTED)) {\n    esp8266Http();\n  }\n  \n  delay(5000);   // 短暂等待\n}\n \n// 发送HTTP请求并且将服务器响应通过串口输出\nvoid esp8266Http(){\n \n  //创建 HTTPClient 对象\n  HTTPClient httpClient;\n \n  //配置请求地址。此处也可以不使用端口号和PATH而单纯的\n  httpClient.begin(URL); \n  Serial.print(\"URL: \"); Serial.println(URL);\n \n  //通过headerKeys数组设置即将处理的服务器响应头内容\n  httpClient.collectHeaders(headerKeys, 2);\n \n  //启动连接并发送HTTP请求\n  int httpCode = httpClient.GET();\n  Serial.print(\"Send GET request to URL: \");\n  Serial.println(URL);\n  \n  //如果服务器响应OK则从服务器获取响应体信息并通过串口输出\n  //如果服务器不响应OK则将服务器响应状态码通过串口输出\n  if (httpCode == HTTP_CODE_OK) {\n      Serial.println(\"==========================\");\n      Serial.println(\"Collected Server Headers: \");\n      \n      Serial.print(\"Content-Length = \"); \n      Serial.println(httpClient.header(\"Content-Length\"));\n     \n      Serial.print(\"Date = \"); \n      Serial.println(httpClient.header(\"Date\"));\n      \n      Serial.print(\"Connection = \"); \n      Serial.println(httpClient.header(\"Connection\"));\n      Serial.println(\"==========================\");\n  } else {\n    Serial.println(\"Server Respose Code：\");\n    Serial.println(httpCode);\n  }\n \n  //关闭ESP8266与服务器连接\n  httpClient.end();\n}\n```\n\n以上程序利用collectHeaders函数获取服务器响应头信息，并通过串口监视器将获取到的响应头信息输出，以便我们查阅程序运行结果。\n\n在以上程序中有2条语句很重要。\n\n1.  `const char *headerKeys[] = {\"Content-Length\", \"Date\"};`\n    这条语句建立了用于存储响应头信息的数组。\n\n2.  `httpClient.collectHeaders(headerKeys, 2);`\n    这条语句用于设置响应头收集。\n\n###### 相关内容\n\n— header – 获取指定响应头参数值\n— headers – 获取响应头数量\n— headerName – 获取指定的响应头名\n— hasHeader – 确认是否存在指定响应头\n\n\n\n\n\n\n\n##### header – 获取指定响应头参数值\n\n###### 说明\n\n通过此函数，ESP8266可以获取服务器响应头的参数值。\n\n**注：在使用此函数前，必须使用[collectHeaders](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266httpclient/collectheaders/)函数来设置响应头处理内容。**\n\n###### 语法\n\n`httpClient.header(name)`\n`httpClient.header(index)`\n\n###### 参数\n\nname: 响应头中指定项的参数名(参数类型: const char*)\nindex: 响应头中指定项的序号(参数类型: size_t)\n\n###### 返回值\n\n响应头中指定项的参数值 (返回值类型:String)\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求，并且将服务器响应头中的”Content-Length”和”Date”信息通过串口监视器输出。（如下图所示）\n\n ![image-20230526223548235](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230526223548235.png)\n\n我们通过以下示例程序的`const char *headerKeys[] = {\"Content-Length\", \"Date\"};`语句建立了headerKeys数组。该数组将被用于接下来程序中的`httpClient.collectHeaders(headerKeys, 2);`语句。以上操作的目的是为了告知ESP8266我们即将对服务器响应头中的”Content-Length”, “Date”信息进行处理。\n\n在后续的程序中，我们使用了一系列header函数来获取指定响应头的数值。并且将这些数值通过串口监视器显示，也就是您所看到的上图内容。\n\n值得注意的是，在上图中红色标注的Connection响应头信息是空的。造成这个结果的原因是我们在建立headerKeys数组时，没有在该数组中加入Connection这一元素。那么ESP8266在后续的程序中自然就无法输出Connection信息了。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : HTTPClient_header\n  程序目的/Purpose          :\n  此程序用于演示如何使用header函数处理www.example.com网站服务器返回的响应信息。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n \n// 测试HTTP请求用的URL\n#define URL \"http://www.example.com\"\n \n// 设置wifi接入信息(请根据您的WiFi信息进行修改)\nconst char* ssid = \"taichimaker\";\nconst char* password = \"12345678\";\n \n//需要收集的响应头的信息\nconst char *headerKeys[] = {\"Content-Length\", \"Date\"};\n \nvoid setup() {\n  //初始化串口设置\n  Serial.begin(9600);\n \n  //设置ESP8266工作模式为无线终端模式\n  WiFi.mode(WIFI_STA);\n \n  //开始连接wifi\n  WiFi.begin(ssid, password);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"WiFi Connected!\");\n}\n \nvoid loop() {\n  // 如果ESP8266连接WiFi则发送HTTP请求\n  if ((WiFi.status() == WL_CONNECTED)) {\n    esp8266Http();\n  }\n  \n  delay(5000);   // 短暂等待\n}\n \n// 发送HTTP请求并且将服务器响应通过串口输出\nvoid esp8266Http(){\n \n  //创建 HTTPClient 对象\n  HTTPClient httpClient;\n \n  //配置请求地址。此处也可以不使用端口号和PATH而单纯的\n  httpClient.begin(URL); \n  Serial.print(\"URL: \"); Serial.println(URL);\n \n  //通过headerKeys数组设置即将处理的服务器响应头内容\n  httpClient.collectHeaders(headerKeys, 2);\n \n  //启动连接并发送HTTP请求\n  int httpCode = httpClient.GET();\n  Serial.print(\"Send GET request to URL: \");\n  Serial.println(URL);\n  \n  //如果服务器响应OK则从服务器获取响应体信息并通过串口输出\n  //如果服务器不响应OK则将服务器响应状态码通过串口输出\n  if (httpCode == HTTP_CODE_OK) {\n      Serial.println(\"==========================\");\n      Serial.println(\"Collected Server Headers: \");\n      \n      Serial.print(\"Content-Length = \"); \n      Serial.println(httpClient.header(\"Content-Length\"));\n     \n      Serial.print(\"Date = \"); \n      Serial.println(httpClient.header(\"Date\"));\n      \n      Serial.print(\"Connection = \"); \n      Serial.println(httpClient.header(\"Connection\"));\n      Serial.println(\"==========================\");\n  } else {\n    Serial.println(\"Server Respose Code：\");\n    Serial.println(httpCode);\n  }\n \n  //关闭ESP8266与服务器连接\n  httpClient.end();\n}\n```\n\n###### 相关内容\n\n— collectHeaders – 设置收集响应头内容\n— header – 获取指定响应头参数值\n— headers – 获取响应头数量\n— headerName – 获取指定的响应头名\n— hasHeader – 确认是否存在指定响应头\n\n\n\n\n\n##### headers – 获取响应头数量\n\n###### 说明\n\n当ESP8266开发板通过HTTP协议向服务器发送请求后，服务器将会向ESP8266开发板发送HTTP响应信息。这个响应信息的响应头部分是多个键值对组成的。此函数用于ESP8266获取响应头中键值对的数量。\n\n**注：在使用此函数前，必须使用[collectHeaders](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266httpclient/collectheaders/)函数来设置响应头处理内容。另外此函数所获取的服务器响应头数量并不是服务器****的实际响应头数量，而是collectHeaders函数中设置的“`headerKeysCount`”参数数值。**\n\n###### 语法\n\n```\nhttpClient.headers()\n```\n\n###### 参数\n\n无\n\n###### 返回值\n\n获取的响应头数量（参数类型： int）\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求，并且将ESP8266获取的服务器响应头中数量通过串口监视器显示出来。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : HTTPClient_headers\n  程序目的/Purpose          :\n  此程序用于演示如何使用headers函数获取www.example.com网站服务器返回的响应头数量。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n \n// 测试HTTP请求用的URL\n#define URL \"http://www.example.com\"\n \n// 设置wifi接入信息(请根据您的WiFi信息进行修改)\nconst char* ssid = \"taichimaker\";\nconst char* password = \"12345678\";\n \n//需要收集的响应头的信息\nconst char *headerKeys[] = {\"Content-Length\", \"Date\"};\n \nvoid setup() {\n  //初始化串口设置\n  Serial.begin(9600);\n \n  //设置ESP8266工作模式为无线终端模式\n  WiFi.mode(WIFI_STA);\n \n  //开始连接wifi\n  WiFi.begin(ssid, password);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"WiFi Connected!\");\n}\n \nvoid loop() {\n  // 如果ESP8266连接WiFi则发送HTTP请求\n  if ((WiFi.status() == WL_CONNECTED)) {\n    esp8266Http();\n  }\n  \n  delay(5000);   // 短暂等待\n}\n \n// 发送HTTP请求并且将服务器响应通过串口输出\nvoid esp8266Http(){\n \n  //创建 HTTPClient 对象\n  HTTPClient httpClient;\n \n  //配置请求地址。此处也可以不使用端口号和PATH而单纯的\n  httpClient.begin(URL); \n  Serial.print(\"URL: \"); Serial.println(URL);\n \n  //通过headerKeys数组设置即将处理的服务器响应头内容\n  httpClient.collectHeaders(headerKeys, 3);\n \n  //启动连接并发送HTTP请求\n  int httpCode = httpClient.GET();\n  Serial.print(\"Send GET request to URL: \");\n  Serial.println(URL);\n  \n  //如果服务器响应OK则从服务器获取响应体信息并通过串口输出\n  //如果服务器不响应OK则将服务器响应状态码通过串口输出\n  if (httpCode == HTTP_CODE_OK) {\n \n      int headerQuantity = httpClient.headers();\n      Serial.println(\"==========================\");\n      Serial.print(\"Server Header Quantity: \");      \n      Serial.println(headerQuantity);\n      Serial.println(\"==========================\");\n  } else {\n    Serial.println(\"Server Respose Code：\");\n    Serial.println(httpCode);\n  }\n \n  //关闭ESP8266与服务器连接\n  httpClient.end();\n}\n```\n\n###### 相关内容\n\n— collectHeaders – 设置收集响应头内容\n— header – 获取指定响应头参数值\n— headerName – 获取指定的响应头名\n— hasHeader – 确认是否存在指定响应头\n\n\n\n\n\n##### headerName – 获取指定的响应头名\n\n###### 说明\n\n当ESP8266开发板通过HTTP协议向服务器发送请求后，服务器将会向ESP8266开发板发送HTTP响应信息。这个响应信息的响应头部分是多个键值对组成的。此函数用于获取响应头中指定序号的键名。\n\n**注:要使用此函数必须在发起请求之前使用[collectHeaders](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266httpclient/collectheaders/)函数来设置收集响应头内容。**\n\n###### 语法\n\n```\nhttpClient.headerName(index)\n```\n\n###### 参数\n\nindex: 要获取的响应头键名序号(类型：size_t)\n例：如需获取响应头中首个键的键名，可使用以下语句。\n`http.headerName(0)`\n\n###### 返回值\n\n要获取的响应头键名（类型：字符串）\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n您将WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求，并且将ESP8266获取的服务器响应中的第一个响应头名称通过串口监视器显示出来。我们是通过以下示例程序中的语句`httpClient.headerName(0);`来获取该信息的。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : HTTPClient_headerName\n  程序目的/Purpose          :\n  此程序用于演示如何使用headers函数获取www.example.com网站服务器返回的响应头数量。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n \n// 测试HTTP请求用的URL\n#define URL \"http://www.example.com\"\n \n// 设置wifi接入信息(请根据您的WiFi信息进行修改)\nconst char* ssid = \"taichimaker\";\nconst char* password = \"12345678\";\n \n//需要收集的响应头的信息\nconst char *headerKeys[] = {\"Content-Length\", \"Date\"};\n \nvoid setup() {\n  //初始化串口设置\n  Serial.begin(9600);\n \n  //设置ESP8266工作模式为无线终端模式\n  WiFi.mode(WIFI_STA);\n \n  //开始连接wifi\n  WiFi.begin(ssid, password);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"WiFi Connected!\");\n}\n \nvoid loop() {\n  // 如果ESP8266连接WiFi则发送HTTP请求\n  if ((WiFi.status() == WL_CONNECTED)) {\n    esp8266Http();\n  }\n  \n  delay(5000);   // 短暂等待\n}\n \n// 发送HTTP请求并且将服务器响应通过串口输出\nvoid esp8266Http(){\n \n  //创建 HTTPClient 对象\n  HTTPClient httpClient;\n \n  //配置请求地址。此处也可以不使用端口号和PATH而单纯的\n  httpClient.begin(URL); \n  Serial.print(\"URL: \"); Serial.println(URL);\n \n  //通过headerKeys数组设置即将处理的服务器响应头内容\n  httpClient.collectHeaders(headerKeys, 2);\n \n  //启动连接并发送HTTP请求\n  int httpCode = httpClient.GET();\n  Serial.print(\"Send GET request to URL: \");\n  Serial.println(URL);\n  \n  //如果服务器响应OK则从服务器获取响应体信息并通过串口输出\n  //如果服务器不响应OK则将服务器响应状态码通过串口输出\n  if (httpCode == HTTP_CODE_OK) {\n      String headerKey = httpClient.headerName(0);\n      Serial.println(\"==========================\");\n      Serial.print(\"Server Header1 Name: \");      \n      Serial.println(headerKey);\n      Serial.println(\"==========================\");\n  } else {\n    Serial.println(\"Server Respose Code：\");\n    Serial.println(httpCode);\n  }\n \n  //关闭ESP8266与服务器连接\n  httpClient.end();\n}\n```\n\n###### 相关内容\n\n— collectHeaders – 设置收集响应头内容\n— header – 获取指定响应头参数值\n— headers – 获取响应头数量\n— hasHeader – 确认是否存在指定响应头\n\n\n\n\n\n##### hasHeader – 确认是否存在指定响应头\n\n###### 说明\n\n此函数用于确认服务器HTTP响应头中是否含有指定响应头信息。\n\n**注:要使用此函数必须在发起请求之前使用[collectHeaders](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266httpclient/collectheaders/)函数来设置收集响应头内容。**\n\n###### 语法\n\n```\nhttpClient.hasHeader(name)\n```\n\n###### 参数\n\nname: 需要确认的响应头键名（类型：const char* ）\n\n###### 返回值\n\n返回值类型为bool。如果存在需要确认的响应头键名则返回true，否则返回false。\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n您将WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求，并且通过串口监视器输出服务器响应头中包含有”Date”信息。我们是通过以下示例程序中的语句`httpClient.hasHeader(\"Date\")`来获取该信息的。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : HTTPClient_hasHeader\n  程序目的/Purpose          :\n  此程序用于演示如何使用headers函数获取www.example.com网站服务器返回的响应头数量。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n \n// 测试HTTP请求用的URL\n#define URL \"http://www.example.com\"\n \n// 设置wifi接入信息(请根据您的WiFi信息进行修改)\nconst char* ssid = \"taichimaker\";\nconst char* password = \"12345678\";\n \n//需要收集的响应头的信息\nconst char *headerKeys[] = {\"Content-Length\", \"Date\"};\n \nvoid setup() {\n  //初始化串口设置\n  Serial.begin(9600);\n \n  //设置ESP8266工作模式为无线终端模式\n  WiFi.mode(WIFI_STA);\n \n  //开始连接wifi\n  WiFi.begin(ssid, password);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"WiFi Connected!\");\n}\n \nvoid loop() {\n  // 如果ESP8266连接WiFi则发送HTTP请求\n  if ((WiFi.status() == WL_CONNECTED)) {\n    esp8266Http();\n  }\n  \n  delay(5000);   // 短暂等待\n}\n \n// 发送HTTP请求并且将服务器响应通过串口输出\nvoid esp8266Http(){\n \n  //创建 HTTPClient 对象\n  HTTPClient httpClient;\n \n  //配置请求地址。此处也可以不使用端口号和PATH而单纯的\n  httpClient.begin(URL); \n  Serial.print(\"URL: \"); Serial.println(URL);\n \n  //通过headerKeys数组设置即将处理的服务器响应头内容\n  httpClient.collectHeaders(headerKeys, 2);\n \n  //启动连接并发送HTTP请求\n  int httpCode = httpClient.GET();\n  Serial.print(\"Send GET request to URL: \");\n  Serial.println(URL);\n  \n  //如果服务器响应OK则从服务器获取响应体信息并通过串口输出\n  //如果服务器不响应OK则将服务器响应状态码通过串口输出\n  if (httpCode == HTTP_CODE_OK) {\n      if(httpClient.hasHeader(\"Date\")){\n        Serial.println(\"==========================\");\n        Serial.println(\"Server Response has Date Header\");      \n        Serial.println(\"==========================\");\n      }\n  } else {\n    Serial.println(\"Server Respose Code：\");\n    Serial.println(httpCode);\n  }\n \n  //关闭ESP8266与服务器连接\n  httpClient.end();\n}\n```\n\n###### 相关内容\n\n— collectHeaders – 设置收集响应头内容\n— header – 获取指定响应头参数值\n— headers – 获取响应头数量\n— headerName – 获取指定的响应头名\n\n\n\n\n\n#### 响应体类型\n\n##### getString – 获取响应体数据并且以字符串形式返回\n\n###### 说明\n\n此函数可用于获取服务器响应中的响应体信息。响应体信息将以字符串的形式进行返回。\n\n###### 语法\n\nhttp.getString()\n\n###### 参数\n\n无\n\n###### 返回值\n\n服务器HTTP响应中的响应体数据。(返回值类型:String)\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求并通过串口监视器将网站服务器响应体信息通过串口监视器显示出来。我们是通过以下示例程序中的`httpClient.getString()`来获取该信息的。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : HTTPClient_demo_getString\n  程序目的/Purpose          :\n  此程序用于演示如何使用getString来获取www.example.com网站服务器返回的响应信息。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n \n// 测试HTTP请求用的URL\n#define URL \"http://www.example.com\"\n \n// 设置wifi接入信息(请根据您的WiFi信息进行修改)\nconst char* ssid = \"taichimaker\";\nconst char* password = \"12345678\";\n \nvoid setup() {\n  //初始化串口设置\n  Serial.begin(9600);\n \n  //设置ESP8266工作模式为无线终端模式\n  WiFi.mode(WIFI_STA);\n \n  //开始连接wifi\n  WiFi.begin(ssid, password);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"WiFi Connected!\");\n}\n \nvoid loop() {\n  // 如果ESP8266连接WiFi则发送HTTP请求\n  if ((WiFi.status() == WL_CONNECTED)) {\n    esp8266Http();\n  }\n  \n  delay(5000);   // 短暂等待\n}\n \n// 发送HTTP请求并且将服务器响应通过串口输出\nvoid esp8266Http(){\n \n  //创建 HTTPClient 对象\n  HTTPClient httpClient;\n \n  //配置请求地址。此处也可以不使用端口号和PATH而单纯的\n  httpClient.begin(URL); \n  Serial.print(\"URL: \"); Serial.println(URL);\n \n  //启动连接并发送HTTP请求\n  int httpCode = httpClient.GET();\n  Serial.print(\"Send GET request to URL: \");\n  Serial.println(URL);\n  \n  //如果服务器响应OK则从服务器获取响应体信息并通过串口输出\n  //如果服务器不响应OK则将服务器响应状态码通过串口输出\n  if (httpCode == HTTP_CODE_OK) {\n    String responsePayload = httpClient.getString();\n    Serial.println(\"Server Response Payload: \");\n    Serial.println(responsePayload);\n  } else {\n    Serial.println(\"Server Respose Code：\");\n    Serial.println(httpCode);\n  }\n \n  //关闭ESP8266与服务器连接\n  httpClient.end();\n}\n\n```\n\n##### 相关内容\n\n— getStream – 获取响应体数据并且以Stream形式返回\n— writeToStream – 获取响应体数据并且写入其它Stream对象\n— getSize – 获取响应体数据字节数\n— errorToString – 获取错误代码并且以字符串形式返回\n\n\n\n\n\n##### getStream – 获取响应体数据并且以Stream形式返回\n\n###### 说明\n\n此函数可用于获取服务器响应中的响应体信息。响应体信息将以[WiFiClient](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)对象返回。\n\n我们可以使用[WiFiClient库](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wificlient/)（ TCP客户端库）建立WiFiClient对象，继而使用该对象对本函数所返回的响应体信息进行分析处理。由于WiFiClient对象可以调用[Stream](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)类提里面的诸多功能强大的函数，如 [parseInt ](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wificlient/parseint/)、 [find ](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wificlient/find/)、 [readStringUntil](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wificlient/readStringuntil/)，使用本函数可以为分析服务器响应信息提供很多便利。\n\n为了更好的了解本函数的用法，建议您首先了解[WiFiClient库](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wificlient/)（ TCP客户端库）以及是该库中[Stream](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)类函数的具体使用方法。\n\n###### 语法\n\n```\nhttpClient.getStream()\n```\n\n###### 参数\n\n无\n\n###### 返回值\n\n以Stream形式返回响应体数据。\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求并通过串口监视器将网站服务器响应体信息通过串口监视器显示出来。\n\n在以下示例程序中，首先我们通过语句`WiFiClient wifiClient;`来创建 WiFiClient 对象。该对象用于处理getStream函数所获取的服务器响应体。\n\n接下来在84-87行程序中，我们利用WiFiClient 对象调用available和readStringUntil这两个[Stream](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)类函数，从而将服务器响应体信息先赋值给字符串，再通过监视器显示出来。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : HTTPClient_getStream\n  程序目的/Purpose          :\n  此程序用于演示如何使用getStream来处理www.example.com网站服务器返回的响应信息。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n \n// 测试HTTP请求用的URL\n#define URL \"http://www.example.com\"\n \n// 设置wifi接入信息(请根据您的WiFi信息进行修改)\nconst char* ssid = \"taichimaker\";\nconst char* password = \"12345678\";\n \nvoid setup() {\n  //初始化串口设置\n  Serial.begin(9600);\n \n  //设置ESP8266工作模式为无线终端模式\n  WiFi.mode(WIFI_STA);\n \n  //开始连接wifi\n  WiFi.begin(ssid, password);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"WiFi Connected!\");\n}\n \nvoid loop() {\n  // 如果ESP8266连接WiFi则发送HTTP请求\n  if ((WiFi.status() == WL_CONNECTED)) {\n    esp8266Http();\n  }\n  \n  delay(5000);   // 短暂等待\n}\n \n// 发送HTTP请求并且将服务器响应通过串口输出\nvoid esp8266Http(){\n  //创建 WiFiClient 对象。该对象用于处理getStream函数所获取的服务器响应体\n  WiFiClient wifiClient;\n   \n  //创建 HTTPClient 对象\n  HTTPClient httpClient;\n \n  //配置请求地址。此处也可以不使用端口号和PATH而单纯的\n  httpClient.begin(URL); \n  Serial.print(\"URL: \"); Serial.println(URL);\n \n  //启动连接并发送HTTP请求\n  int httpCode = httpClient.GET();\n  Serial.print(\"Send GET request to URL: \");\n  Serial.println(URL);\n  \n  //如果服务器响应OK则从服务器获取响应体信息并通过串口输出\n  //如果服务器不响应OK则将服务器响应状态码通过串口输出\n  if (httpCode == HTTP_CODE_OK) {\n    \n    // 获取服务器响应体Stream并传递给wifiClient\n    wifiClient = httpClient.getStream();\n    \n    Serial.println(\"Server Response: \");\n    // 以下部分使用了Stream类中的available函数以及readStringUntil函数\n    // 对服务器响应体信息进行分析处理。并且通过串口监视器将服务器响应体信息\n    // 输出到串口监视器中。\n    while (wifiClient.available()){\n      String resonseBodyLine = wifiClient.readStringUntil('\\n');\n      Serial.println(resonseBodyLine);\n    }\n  } else {\n    Serial.println(\"Server Respose Code：\");\n    Serial.println(httpCode);\n  }\n \n  //关闭ESP8266与服务器连接\n  httpClient.end();\n}\n```\n\n###### 相关内容\n\n— getString – 获取响应体数据并且以字符串形式返回\n— writeToStream – 获取响应体数据并且写入其它Stream对象\n— getSize – 获取响应体数据字节数\n— errorToString – 获取错误代码并且以字符串形式返回\n\n\n\n##### writeToStream – 获取响应体数据并且写入其它Stream对象\n\n###### 说明\n\n此函数用于将获取到的响应数据写入[Stream](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)数据流。\n\n###### 语法\n\n```\nhttpClient.writeToStream(stream)\n```\n\n###### 参数\n\nstream: stream类型指针\n\n###### 返回值\n\n返回值类型为int。\n如果返回值大于零，则返回值数值是写入对象的数据大小（单位：字节）。\n如果返回值小于零，说明函数执行出错。以下是错误代码说明：\n\n- -1： HTTPC_ERROR_CONNECTION_REFUSED\n- -2： HTTPC_ERROR_SEND_HEADER_FAILED\n- -3： HTTPC_ERROR_SEND_PAYLOAD_FAILED\n- -4： HTTPC_ERROR_NOT_CONNECTED\n- -5： HTTPC_ERROR_CONNECTION_LOST\n- -6： HTTPC_ERROR_NO_STREAM\n- -7： HTTPC_ERROR_NO_HTTP_SERVER\n- -8： HTTPC_ERROR_TOO_LESS_RAM\n- -9： HTTPC_ERROR_ENCODING\n- -10： HTTPC_ERROR_STREAM_WRITE\n- -11： HTTPC_ERROR_READ_TIMEOUT\n\n\n\n\n\n##### getSize – 获取响应体数据字节数\n\n###### 说明\n\n此函数可用于获取服务器响应中的响应体大小（单位：字节）。\n\n###### 语法\n\n```\nhttpClient.getSize()\n```\n\n###### 参数\n\n无\n\n###### 返回值\n\n返回值类型为int。\n服务器响应中的响应体大小（单位：字节）\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求，并且将ESP8266获取的服务器响应头大小通过串口监视器显示出来。我们使用了`httpClient.getSize()`来获取该信息。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : HTTPClient_getSize\n  程序目的/Purpose          :\n  此程序用于演示如何使用getSize函数来获取www.example.com网站服务器返回的响应信息大小。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n \n// 测试HTTP请求用的URL\n#define URL \"http://www.example.com\"\n \n// 设置wifi接入信息(请根据您的WiFi信息进行修改)\nconst char* ssid = \"taichimaker\";\nconst char* password = \"12345678\";\n \nvoid setup() {\n  //初始化串口设置\n  Serial.begin(9600);\n \n  //设置ESP8266工作模式为无线终端模式\n  WiFi.mode(WIFI_STA);\n \n  //开始连接wifi\n  WiFi.begin(ssid, password);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"WiFi Connected!\");\n}\n \nvoid loop() {\n  // 如果ESP8266连接WiFi则发送HTTP请求\n  if ((WiFi.status() == WL_CONNECTED)) {\n    esp8266Http();\n  }\n  \n  delay(5000);   // 短暂等待\n}\n \n// 发送HTTP请求并且将服务器响应通过串口输出\nvoid esp8266Http(){ \n  //创建 HTTPClient 对象\n  HTTPClient httpClient;\n \n  //配置请求地址。此处也可以不使用端口号和PATH而单纯的\n  httpClient.begin(URL); \n  Serial.print(\"URL: \"); Serial.println(URL);\n \n  //启动连接并发送HTTP请求\n  int httpCode = httpClient.GET();\n  Serial.print(\"Send GET request to URL: \");\n  Serial.println(URL);\n  \n  //如果服务器响应OK则从服务器获取响应体信息并通过串口输出\n  //如果服务器不响应OK则将服务器响应状态码通过串口输出\n  if (httpCode == HTTP_CODE_OK) {\n    \n    Serial.print(\"Response Body Size: \");\n    Serial.print(httpClient.getSize());\n    Serial.println(\" Bytes\");\n \n  } else {\n    Serial.println(\"Server Respose Code：\");\n    Serial.println(httpCode);\n  }\n \n  //关闭ESP8266与服务器连接\n  httpClient.end();\n}\n```\n\n###### 相关内容\n\n— getString – 获取响应体数据并且以字符串形式返回\n— getStream – 获取响应体数据并且以Stream形式返回\n— writeToStream – 获取响应体数据并且写入其它Stream对象\n— errorToString – 获取错误代码并且以字符串形式返回\n\n\n\n\n\n\n\n##### errorToString – 获取错误代码并且以字符串形式返回\n\n###### 说明\n\n此函数可用于将ESP8266的HTTP请求失败代码转换为字符串描述。\n\n###### 语法\n\n```\nhttpClient.errorToString(httpCode)\n```\n\n###### 参数\n\nhttpCode:服务器错误代码。\n注意，此错误代码非HTTP响应状态码，而是ESP8266库自定义的一系列错误代码。以下是错误代码数值以及该数值所对应的错误信息。\n\n- -1： HTTPC_ERROR_CONNECTION_REFUSED\n- -2： HTTPC_ERROR_SEND_HEADER_FAILED\n- -3： HTTPC_ERROR_SEND_PAYLOAD_FAILED\n- -4： HTTPC_ERROR_NOT_CONNECTED\n- -5： HTTPC_ERROR_CONNECTION_LOST\n- -6： HTTPC_ERROR_NO_STREAM\n- -7： HTTPC_ERROR_NO_HTTP_SERVER\n- -8： HTTPC_ERROR_TOO_LESS_RAM\n- -9： HTTPC_ERROR_ENCODING\n- -10： HTTPC_ERROR_STREAM_WRITE\n- -11： HTTPC_ERROR_READ_TIMEOUT\n\n###### 返回值\n\n服务器响应错误说明（类型：String）\n\n###### 示例程序\n\n```c\n/**********************************************************************\n  程序名称/Program name     : HTTPClient_errorToString\n  程序目的/Purpose          :\n  此程序用于演示如何使用errorToString函数来获取网站服务器请求错误代码。\n***********************************************************************/\n#include <ESP8266HTTPClient.h>\n \nvoid setup() {\n  Serial.begin(9600);\n  \n  //创建 HTTPClient 对象\n  HTTPClient httpClient;\n \n  for (int i = -11; i < 0; i++){\n    Serial.print(\"Response errorToString \");\n    Serial.print(i);Serial.print(\" - \");\n    Serial.println(httpClient.errorToString(i));  \n  }\n}\n \nvoid loop() {}\n```\n\n###### 相关内容\n\n— getString – 获取响应体数据并且以字符串形式返回\n— getStream – 获取响应体数据并且以Stream形式返回\n— writeToStream – 获取响应体数据并且写入其它Stream对象\n— getSize – 获取响应体数据字节数\n— errorToString – 获取错误代码并且以字符串形式返回\n\n\n\n\n\n\n\n## ESP8266 – ESP8266WebServer库\n\nESP8266WebServer库用于HTTP协议通讯。通过ESP8266WebServer库，我们可以使用ESP8266开发板建立网络服务器,从而允许其它网络设备以及物联网设备通过HTTP协议访问并实现物联网信息交流。\n\nESP8266库中还有一个专门用于TCP通讯的[WiFiServer](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiserver/)库 。\n\n由于HTTP协议是建立在TCP协议基础之上的，我们也可以使用WiFiServer库来实现HTTP通讯。在这一点上，WiFiServer库与ESP8266WebServer库 在功能上形成了互补。\n\n以下为ESP8266WebServer库的整体结构图。在此图下方有ESP8266WebServer库的函数目录。您可以通过点击目录项目打开各个函数的说明页面。\n\n![image-20230527113156373](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527113156373.png)\n\n### 服务器运行管理分类\n\n#### ESP8266WebServer – 建立新的ESP8266WebServer对象\n\n##### 说明\n\n此函数用于建立新的ESP8266WebServer对象，以便我们在程序中利用此对象来实现物联网网络服务器。\n\n##### 语法\n\n```\nESP8266WebServer server(port)\n```\n\n##### 参数\n\n– port: 此参数用于设置服务端口号。如不提供此参数，则默认为80端口。(类型:int)\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n在以下示例程序中，我们通过ESP8266WebServer语句建立了ESP8266WebServer对象，对象名称是server，端口号是server(80)中的数字80。接下来我们就可以通过对象server来实现对ESP8266开发板的物联网服务器的控制。\n\n当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。**WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址**。此时，ESP8266已经成功建立了网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。\n\n```C\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_server\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置您的WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \nESP8266WebServer server(80);\n \n//自定义主页访问处理函数\nvoid homepage() {\n  server.send(200, \"text/plain\", \"test homepage !\");\n  Serial.println(\"用户访问了主页\");\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.on(\"/\", homepage);\n  server.begin();\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n  }\n```\n\n\n\n\n\n#### begin – 服务器启动\n\n##### 说明\n\n本函数用于启动ESP8266开发板所建立的网络服务器。\n\n##### 语法\n\n```\nserver.begin()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n在以下示例程序中，我们通过ESP8266WebServer语句建立了ESP8266WebServer对象，对象名称是server，端口号是server(80)中的数字80。接下来我们就可以通过对象server来实现对ESP8266开发板的物联网服务器的控制。\n\n当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。**WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址**。此时，ESP8266已经成功建立了网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。\n\n当您在浏览器地址栏中输入IP后并按下回车，这时您将看到浏览器中显示上图所示的网页页面。该页面即是通过ESP8266所建立的。在以下示例程序中，我们使用了`server.begin();`来启动ESP8266服务器工作。\n\n```C\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_server\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置您的WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \nESP8266WebServer server(80);\n \n//自定义主页访问处理函数\nvoid homepage() {\n  server.send(200, \"text/plain\", \"test homepage !\");\n  Serial.println(\"用户访问了主页\");\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.on(\"/\", homepage);\n  server.begin();\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n```\n\n\n\n\n\n#### stop – 停止服务器\n\n##### 说明\n\n本函数用于停止ESP8266开发板所建立的网络服务器。\n\n注: stop函数和[close](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266httpclient/close/)函数功能相同。\n\n##### 语法\n\n```\nserver.stop()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。**WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址**。此时，ESP8266已经成功建立了网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。\n\n当您在浏览器地址栏中输入IP后并按下回车，这时您将看到浏览器中显示上图所示的网页页面。该页面即是通过ESP8266所建立的。当您刷新此页面三次后，ESP8266开发板将会执行server.stop()语句，随即停止物联网服务器功能。\n\n```C\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_stop\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n  且访问homepage三次之后关停服务器\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \nESP8266WebServer server(80);\n \n//设置访问次数变量\nint repeat = 0;\n \nvoid homepage() {\n  server.send(200, \"text/plain\", \"test homepage\");\n  Serial.println(\"用户访问了主页\");\n \n  //达到访问次数限制之后停止服务器运行\n  if (++repeat == 3) {\n    Serial.println(\"服务器停止运行);\n    server.stop();\n  }\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.on(\"/\", homepage);\n  server.begin()\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n```\n\n\n\n\n\n#### close – 停止服务器\n\n##### 说明\n\n本函数用于停止ESP8266开发板所建立的网络服务器。\n\n注: close函数和[stop](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/stop/)函数功能相同。\n\n##### 语法\n\nserver.close()\n\n##### 参数\n\n无\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。**WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址**。此时，ESP8266已经成功建立了网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。\n\n当您在浏览器地址栏中输入IP后并按下回车，这时您将看到浏览器中显示上图所示的网页页面。该页面即是通过ESP8266所建立的。当您刷新此页面三次后，ESP8266开发板将会执行server.close()语句，随即停止物联网服务器功能。\n\n```C\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_close\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n  且访问homepage三次之后关停服务器\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \nESP8266WebServer server(80);\n \n//设置访问次数变量\nint repeat = 0;\n \nvoid homepage() {\n  server.send(200, \"text/plain\", \"test homepage\");\n  Serial.println(\"用户访问了主页\");\n \n  //达到访问次数限制之后停止服务器运行\n  if (++repeat == 3) {\n    Serial.println(\"服务器停止运行);\n    server.close();\n  }\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.on(\"/\", homepage);\n  server.begin();\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n```\n\n\n\n\n\n### 处理客户端HTTP请求分类\n\n#### 客户端请求处理配置分类\n\n##### on – 可找到资源处理配置\n\n###### 说明\n\n当ESP8266开发板建立网络服务器以后，每当有客户端向服务器发送HTTP请求时，我们可以利用on函数来设置HTTP请求回调函数。\n\n通过HTTP请求回调函数，我们可以让ESP8266服务器生成响应信息并发送给HTTP请求客户端。\n\n###### 语法\n\n`server.on(uri, uri_handler);`\n`server.on(uri, method, uri_handler);`\n\n###### 参数\n\n– uri: HTTP请求客户端所请求的uri（参数类型:const String*）\n\n– uri_handler: HTTP请求回调函数（参数类型:THandlerFunction）\n\n– method: 此参数用于设置向客户端发送响应信息时所使用的HTTP方法。以下为可供选择的响应方法关键字。\n\n-    HTTP_ANY\n-    HTTP_GET\n-    HTTP_POST\n-    HTTP_PUT\n-    HTTP_PATCH\n-    HTTP_DELETE\n-    HTTP_OPTIONS\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n如需进一步了解本示例程序的详细使用方法，特别是on函数的功能，请参考《[零基础入门学用物联网](http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/)》免费视频教程中“[ESP8266-NodeMCU网络服务器](http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-server/)”部分内容。\n\n当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。**WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址**。此时，ESP8266已经成功建立了网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。\n\n当您在浏览器地址栏中输入IP后并按下回车，这时您将看到浏览器中显示上图所示的网页页面。该页面即是通过ESP8266所建立的。\n\n在以下示例程序中，我们使用了server.on(“/”, homepage);语句来设置浏览器访问网站首页时的回调函数“homepage”。\n\n```C\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_on\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n***********************************************************************/\n \n \n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置您的WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \nESP8266WebServer server(80);\n \nvoid homepage() {\n  server.send(200, \"text/plain\", \"test homepage !\");\n  Serial.println(\"用户访问了主页\");\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.on(\"/\", homepage);\n  server.begin();\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n```\n\n###### 相关内容\n\n– onNotFound – 未找到资源处理配置\n– onFileUpload – 文件上传处理配置\n– addHandler – 设置请求响应回调\n\n\n\n\n\n##### onNotFound – 未找到资源处理配置\n\n###### 说明\n\n当ESP8266开发板建立网络服务器以后，每当有客户端向服务器发送HTTP请求时，我们可以利用onNotFound函数来设置HTTP请求无效地址的回调函数。\n\n通过无效地址回调函数，我们可以让ESP8266服务器生成响应信息并在客户端请求无效地址时，将404页面信息发送给客户端。\n\n###### 语法\n\n```\nserver.onNotFound(function)\n```\n\n###### 参数\n\nfunction – 处理无效地址请求的回调函数(类型: THandlerFunction)\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。**WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址**。此时，ESP8266已经成功建立了网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。\n\n当您在浏览器地址栏中输入IP后并按下回车，这时您将看到浏览器中显示上图所示的网页页面。该页面即是通过ESP8266所建立的。\n\n在以下示例程序中，我们使用了server.onNotFound(handleNotFound);语句来设置浏览器访问无效地址的回调函数“handleNotFound”。\n\n```C\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_onNotFound\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n  当访问地址为主页之外的路劲时返回404页面\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置您的WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \nESP8266WebServer server(80);\n \n//设置主页\nvoid homepage() {\n  server.send(200, \"text/plain\", \"test homepage !\");\n  Serial.println(\"用户访问了主页\");\n}\n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound() {                                       // 当浏览器请求的网络资源无法在服务器找到时，\n  server.send(404, \"text/plain\", \"404: Not found\");   // NodeMCU将调用此函数。\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.on(\"/\", homepage);\n  server.onNotFound(handleNotFound);\n  server.begin();\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n```\n\n###### 相关内容\n\n– on – 可找到资源处理配置\n– onFileUpload – 文件上传处理配置\n– addHandler – 设置请求响应回调\n\n\n\n##### onFileUpload – 文件上传处理配置\n\n###### 说明\n\n当ESP8266建立的网络服务器收到了客户端的文件上传请求时，我们可以利用此函数来配置处理文件上传请求的回调函数。\n\n###### 语法\n\n```\nserver.onFileUpload(function)\n```\n\n###### 参数\n\nfunction\n\n– 处理文件上传请求的回调函数(类型: THandlerFunction)\n\n###### 返回值\n\n无\n\n###### 相关内容\n\n– on – 可找到资源处理配置\n– onNotFound – 未找到资源处理配置\n– onFileUpload – 文件上传处理配置\n– addHandler – 设置请求响应回调\n\n\n\n\n\n\n\n##### addHandler – 设置请求响应回调\n\n###### 说明\n\n该函数可自定义请求处理。\n\n###### 语法\n\n```\nserver.addHandler(requestHandler)\n```\n\n###### 参数\n\nrequestHandler: RequestHandler对象\n\n###### 返回值\n\n无\n\n\n\n\n\n\n\n#### 处理客户端请求分类\n\n##### handleClient – 处理客户端请求\n\n###### 说明\n\n此函数主要作用是检查有没有客户端设备通过网络向ESP8266网络服务器发送请求。每一次handleClient`函数被调用时，ESP8266网络服务器都会检查一下是否有客户端发送HTTP请求。因此建议将该函数放在loop函数中，从而确保它能经常被调用。\n\n假如loop函数里有类似delay一类的函数延迟程序运行，那么就一定要注意了。如果handleClient函数长时间得不到调用，ESP8266网络服务器会因为无法经常检查HTTP客户端请求而导致服务器响应变慢，严重的情况下，会导致服务器工作不稳定。\n\n###### 语法\n\n```\nserver.handleClient()\n```\n\n###### 参数\n\n无\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。**WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址**。此时，ESP8266已经成功建立了网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。\n\n当您在浏览器地址栏中输入IP后并按下回车，这时您将看到浏览器中显示上图所示的网页页面。该页面即是通过ESP8266所建立的。以下示例程序中，我们使用了esp8266_server.handleClient(); 语句来让ESP8266检查浏览器的请求。\n\n```C\n/**********************************************************************\n程序名称/Program name     : 3_2_1_First_Web_Server\n程序目的/Purpose          : 使用NodeMCU建立基本服务器。用户可通过浏览器使用8266的IP地址\n                           访问8266所建立的基本网页（Hello from ESP8266）\n***********************************************************************/\n#include <ESP8266WiFi.h>        // 本程序使用 ESP8266WiFi库\n#include <ESP8266WiFiMulti.h>   //  ESP8266WiFiMulti库\n#include <ESP8266WebServer.h>   //  ESP8266WebServer库\n \nESP8266WiFiMulti wifiMulti;     // 建立ESP8266WiFiMulti对象,对象名称是'wifiMulti'\n \nESP8266WebServer esp8266_server(80);// 建立ESP8266WebServer对象，对象名称为esp8266_server\n                                    // 括号中的数字是网路服务器响应http请求的端口号\n                                    // 网络服务器标准http端口号为80，因此这里使用80为端口号\n \nvoid setup(void){\n  Serial.begin(9600);          // 启动串口通讯\n \n  //通过addAp函数存储  WiFi名称       WiFi密码\n  wifiMulti.addAP(\"taichi-maker\", \"12345678\");  // 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。\n  wifiMulti.addAP(\"taichi-maker2\", \"87654321\"); // 这3个WiFi网络名称分别是taichi-maker, taichi-maker2, taichi-maker3。\n  wifiMulti.addAP(\"taichi-maker3\", \"13572468\"); // 这3个网络的密码分别是123456789，87654321，13572468。\n                                                // 此处WiFi信息只是示例，请在使用时将需要连接的WiFi信息填入相应位置。\n                                                // 另外这里只存储了3个WiFi信息，您可以存储更多的WiFi信息在此处。\n \n  int i = 0;                                 \n  while (wifiMulti.run() != WL_CONNECTED) {  // 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前\n    delay(1000);                             // 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU\n    Serial.print(i++); Serial.print(' ');    // 将会连接信号最强的那一个WiFi信号。\n  }                                          // 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是\n                                             // 此处while循环判断是否跳出循环的条件。\n \n  // WiFi连接成功后将通过串口监视器输出连接成功信息 \n  Serial.println('\\n');                     // WiFi连接成功后\n  Serial.print(\"Connected to \");            // NodeMCU将通过串口监视器输出。\n  Serial.println(WiFi.SSID());              // 连接的WiFI名称\n  Serial.print(\"IP address:\\t\");            // 以及\n  Serial.println(WiFi.localIP());           // NodeMCU的IP地址\n  \n//--------\"启动网络服务功能\"程序部分开始-------- //  此部分为程序为本示例程序重点1\n  esp8266_server.begin();                   //  详细讲解请参见太极创客网站《零基础入门学用物联网》\n  esp8266_server.on(\"/\", handleRoot);       //  第3章-第2节 ESP8266-NodeMCU网络服务器-1\n  esp8266_server.onNotFound(handleNotFound);        \n//--------\"启动网络服务功能\"程序部分结束--------\n  Serial.println(\"HTTP esp8266_server started\");//  告知用户ESP8266网络服务功能已经启动\n}\n \n/* 以下函数语句为本示例程序重点3\n详细讲解请参见太极创客网站《零基础入门学用物联网》\n第3章-第2节 3_2_1_First_Web_Server 的说明讲解*/  \nvoid loop(void){\n  esp8266_server.handleClient();     // 处理http服务器访问\n}\n \n/* 以下两个函数为本示例程序重点2\n详细讲解请参见太极创客网站《零基础入门学用物联网》\n第3章-第2节 3_2_1_First_Web_Server 的说明讲解*/                                                                            \nvoid handleRoot() {   //处理网站根目录“/”的访问请求 \n  esp8266_server.send(200, \"text/plain\", \"Hello from ESP8266\");   // NodeMCU将调用此函数。\n}\n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound(){                                        // 当浏览器请求的网络资源无法在服务器找到时，\n  esp8266_server.send(404, \"text/plain\", \"404: Not found\");   // NodeMCU将调用此函数。\n}\n```\n\n###### 相关内容\n\n– on – 可找到资源处理配置\n– onNotFound – 未找到资源处理配置\n– onFileUpload – 文件上传处理配置\n– addHandler – 设置请求响应回调\n\n\n\n\n\n#### 获取客户端请求信息分类\n\n**获取客户端请求行信息分类**\n\n##### uri – 获取请求路径\n\n###### 说明\n\n使用该函数可获取客户端发送的HTTP请求行中的请求资源路径信息。\n\n###### 语法\n\n```\nserver.uri()\n```\n\n###### 参数\n\n无\n\n###### 返回值\n\n客户端请求行中的请求资源路径信息。（类型：字符串）\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。\n\n浏览器请求发送之后，您就可以通过ESP8266开发板串口监视器看到浏览器发送的GET请求路径。我们在以下示例程序中使用了`Serial.println(server.uri());`语句来实现通过串口监视器输出浏览器请求资源路径。\n\n```C\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_uri\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \nESP8266WebServer server(80);\n \n//设置访问次数变量\nint repeat = 0;\n \n// 设置主页请求处理函数\nvoid homepage() {\n  server.send(200, \"text/plain\", \"test homepage\");\n  Serial.println(\"用户访问了主页\");\n  Serial.println(server.uri());\n  //达到访问次数限制之后停止服务器运行\n  if (++repeat == 50) {\n    Serial.println(\"Done\");\n    server.stop();\n  }\n}\n \n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound() {                                       // 当浏览器请求的网络资源无法在服务器找到时，\n  server.send(404, \"text/plain\", \"404: Not found\");           // NodeMCU将调用此函数。\n  Serial.print(\"当前请求路径 :\"); \n  Serial.print(WiFi.localIP()); \n  Serial.println(server.uri());  //串口输出当前客户端的请求路径\n  \n  Serial.print(\"当前请求方法 :\"); \n  Serial.println(server.method());  //串口输出当前客户端的请求方法\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.begin();\n  server.on(\"/\", homepage);\n  server.onNotFound(handleNotFound);\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n```\n\n###### 相关内容\n\n– uri – 获取请求路径\n– method – 获取请求方法\n\n\n\n\n\n\n\n##### method – 获取请求方法\n\n###### 说明\n\n此函数用于获取客户端的HTTP请求方法。\n\n###### 语法\n\n```\nserver.method()\n```\n\n###### 参数\n\n无\n\n###### 返回值\n\nHTTP请求方法代表值。（类型: HTTPMethod）\n\n以下为各请求方法及其所对应的代表值。\n\n- HTTP_ANY   1\n- HTTP_GET   1\n- HTTP_POST   3\n- HTTP_PUT   4\n- HTTP_PATCH   5\n- HTTP_DELETE   6\n- HTTP_OPTIONS   7\n\n###### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。\n\n浏览器请求发送之后，您就可以通过ESP8266开发板串口监视器看到浏览器发送的GET请求方法。\n\n```C\n/**********************************************************************\n  项目名称/Project          : 零基础入门学用物联网\n  程序名称/Program name     : WebServer_demo_uri\n  团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)\n  作者/Author              : Dapenson\n  日期/Date（YYYYMMDD）     : 20200320\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n  -----------------------------------------------------------------------\n  本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。\n  该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：\n  http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \nESP8266WebServer server(80);\n \n//设置访问次数变量\nint repeat = 0;\n \n// 设置主页请求处理函数\nvoid homepage() {\n  server.send(200, \"text/plain\", \"test homepage\");\n  Serial.println(\"用户访问了主页\");\n  Serial.println(server.method());  //串口输出当前客户端的请求方法\n  //达到访问次数限制之后停止服务器运行\n  if (++repeat == 50) {\n    Serial.println(\"Done\");\n    server.stop();\n  }\n}\n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound() {                                       // 当浏览器请求的网络资源无法在服务器找到时，\n  server.send(404, \"text/plain\", \"404: Not found\");           // NodeMCU将调用此函数。\n  \n  Serial.print(\"当前请求路径 :\"); \n  Serial.print(WiFi.localIP()); \n  Serial.println(server.uri());  //串口输出当前客户端的请求路径\n  \n  Serial.print(\"当前请求方法 :\"); \n  Serial.println(server.method());  //串口输出当前客户端的请求方法\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.begin();\n  server.on(\"/\", homepage);\n  server.onNotFound(handleNotFound);\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n```\n\n###### 相关内容\n\n– uri – 获取请求路径\n\n\n\n\n\n\n\n**获取客户端请求头信息分类**\n\n##### collectHeaders – 设置需要收集哪些请求头信息\n\n###### 说明\n\n使用ESP8266开发板实现的物联网服务器可以收集客户端发送的请求头信息。我们知道，HTTP客户端发送的请求信息中通常是包含多个HTTP请求头信息的。利用collectHeaders函数，我们可以设置需要获取的HTTP请求头信息，以便我们在后面的程序中加以处理使用。\n\n**请注意：在我们使用ESP8266WebServer库中的[headers](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/headers/)、[header](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/header/) 、[headerName](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/headername/)、[hasHeader](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/hasheader/) 函数来获取浏览器请求头以前，需要首先调用本函数来设置ESP8266具体收集哪些请求头信息。**\n\n###### 语法\n\n```\nserver.collectHeaders(headerKeys, headerKeysCount)\n```\n\n###### 参数\n\n– headerKeys: 请求头名数组。此数组中的元素即是需要ESP8266处理或收集的请求头信息。下面我们看一个headerKeys数组的例子：\nconst char *headerKeys[] = {“Content-Length”, “Date”};\n此数组共有两个元素，分别是”Content-Length”和”Date”。只有如此建立了数组后，接下来的程序里我们才可以使用其它ESP8266WebServer库函数来处理这两个请求头的信息内容。可以把这个数组看作是对ESP8266的提醒，即告诉ESP8266在后续的程序中，我们将要对数组中所包含的请求头信息进行处理。（具体操作方法，请见本函数的示例程序部分。）\n\n– headerKeysCount: 需要获取/处理的请求头个数（可选参数，类型：size_t）\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。\n\n浏览器请求发送之后，您就可以通过ESP8266开发板串口监视器看到浏览器发送的请求头信息中的connection以及HOST信息。（如下图所示）\n\n![image-20230527120439433](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527120439433.png)\n\n```C\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_collectHeaders\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n  访问主页将从串口反馈请求头的信息,具体内容请参考自定义函数 echo_headers()\n  注:本示例程序为获取客户端请求头信息分类函数中功能较全的版本\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \n//创建 ESP8266WebServer 对象\nESP8266WebServer server(80);\n \n//设置访问次数变量\nint repeat = 0;\n//设置需要收集的请求头信息\nconst char *headerKeys[] = {\"Content-Length\", \"Content-Type\", \"Connection\", \"Date\"};\n \n// 设置主页请求处理函数\nvoid homepage() {\n  server.send(200, \"text/plain\", \"test homepage\");\n  Serial.println(\"用户访问了主页\");\n  echo_headers();\n  //达到访问次数限制之后停止服务器运行\n  if (++repeat == 50) {\n    Serial.println(\"Done\");\n    server.stop();\n  }\n}\n \n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound() {                                       // 当浏览器请求的网络资源无法在服务器找到时，\n  server.send(404, \"text/plain\", \"404: Not found\");           // NodeMCU将调用此函数。\n  echo_headers();\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.begin();\n  server.on(\"/\", homepage);\n  server.onNotFound(handleNotFound);\n  Serial.println(\"HTTP server started\");\n  server.collectHeaders(headerKeys, sizeof(headerKeys) / sizeof(headerKeys[0]));\n \n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n \nvoid echo_headers() {\n \n  if (server.hasHeader(\"Connection\")) {//判断该请求头是否存在\n    //使用示例,打印当前收集的请求头的数量\n    Serial.print(\"当前请求所收集的请求头数量:\"); Serial.println(server.headers());\n \n    //打印当前请求中所收集的请求头指定项的值\n    Serial.print(\"当前请求所收集的请求头Connection:\"); Serial.println(server.header(\"Connection\"));\n \n    //打印当前请求中所收集的Host\n    Serial.print(\"当前请求所收集的请求头Host :\"); Serial.println(server.hostHeader());\n    //分隔空行\n    Serial.println(\"\\r\\n\");\n  }\n}\n```\n\n###### 相关内容\n\n– headers – 获得请求头数量\n– header – 获得指定请求头所对应的数值\n– headerName – 获取指定请求头的名称\n– hasHeader – 确定是否包含指定请求头\n\n\n\n\n\n##### headers – 获得请求头数量\n\n###### 说明\n\n使用本函数，我们可以获取客户端向ESP8266物联网服务器发送的请求头数量\n\n请注意，使用此函数前必须先使用[collectHeaders](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/collectheaders/)函数来设置具体收集的请求头内容。\n\n###### 语法\n\n```\nserver.headers()\n```\n\n###### 参数\n\n无\n\n###### 返回值\n\n获取的响应头的数量 （返回值类型:int）\n\n###### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。\n\n浏览器请求发送之后，您就可以通过串口监视器看到开发板的开发板收集的请求头数量。下图是程序运行结果。\n\n![image-20230527120604924](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527120604924.png)\n\n\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_headers\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n  访问主页将从串口反馈请求头的信息,具体内容请参考自定义函数 echo_headers()\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \n//创建 ESP8266WebServer 对象\nESP8266WebServer server(80);\n \n//设置访问次数变量\nint repeat = 0;\n//设置需要收集的请求头信息\nconst char *headerKeys[] = {\"Connection\"};\n \n// 设置主页请求处理函数\nvoid homepage() {\n  server.send(200, \"text/plain\", \"test homepage\");\n  Serial.println(\"用户访问了主页\");\n  echo_headers();\n}\n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound() {                                       // 当浏览器请求的网络资源无法在服务器找到时，\n  server.send(404, \"text/plain\", \"404: Not found\");           // NodeMCU将调用此函数。\n  echo_headers();\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.begin();\n  server.on(\"/\", homepage);\n  server.onNotFound(handleNotFound);\n  Serial.println(\"HTTP server started\");\n  server.collectHeaders(headerKeys, sizeof(headerKeys) / sizeof(headerKeys[0]));\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n \nvoid echo_headers() {\n    //使用示例,打印当前收集的请求头的数量\n    Serial.print(\"当前请求所收集的请求头数量:\"); Serial.println(server.headers());\n}\n```\n\n###### 相关内容\n\n– collectHeaders – 设置需要收集哪些请求头信息\n– header – 获得指定请求头所对应的数值\n– headerName – 获取指定请求头的名称\n– hasHeader – 确定是否包含指定请求头\n\n\n\n\n\n\n\n##### header – 获得指定请求头所对应的数值\n\n###### 说明\n\n使用本函数，我们可以获取客户端向ESP8266物联网服务器发送的请求头参数值。\n\n请注意，使用此函数前必须先使用[collectHeaders](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/collectheaders/)函数来设置具体收集的请求头内容。\n\n###### 语法\n\n`server.header(name)`\n`server.header(index)`\n\n###### 参数\n\n– name: 响应头名称(参数类型: String )\n– index: 响应头序号(参数类型: int)\n\n###### 返回值\n\n返回请求头中指定项的值。(类型: String )\n\n###### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。\n\n浏览器请求发送之后，您就可以通过串口监视器看到浏览器发送的“connection”请求头信息。\n\n具体实现这一功能是通过以下程序中高亮语句`server.header(\"Connection\")`实现的。该语句中header函数的参数”Connection”即是设置开发板要获取的是客户端请求头信息中的”Connection”参数值。\n\n![image-20230527120732250](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527120732250.png)\n\n```c\n/**********************************************************************=\n  程序名称/Program name     : WebServer_demo_header\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n  访问主页将从串口反馈请求头的信息,具体内容请参考自定义函数 echo_headers()\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \n//创建 ESP8266WebServer 对象\nESP8266WebServer server(80);\n \n//设置需要收集的请求头信息\nconst char *headerKeys[] = {\"Content-Length\", \"Content-Type\", \"Connection\", \"Date\"};\n \n// 设置主页请求处理函数\nvoid homepage() {\n  server.send(200, \"text/plain\", \"test homepage\");\n  Serial.println(\"用户访问了主页\");\n  echo_headers();\n}\n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound() {                                       // 当浏览器请求的网络资源无法在服务器找到时，\n  server.send(404, \"text/plain\", \"404: Not found\");           // NodeMCU将调用此函数。\n  echo_headers();\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.begin();\n  server.on(\"/\", homepage);\n  server.onNotFound(handleNotFound);\n  Serial.println(\"HTTP server started\");\n  server.collectHeaders(headerKeys, sizeof(headerKeys) / sizeof(headerKeys[0]));\n \n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n \nvoid echo_headers() {\n  //打印当前请求中所收集的请求头的值信息,请求头名称+请求头值\n  Serial.print(\"Header \\\"Connection\\\": \"); Serial.println(server.header(\"Connection\"));\n}\n```\n\n###### 相关内容\n\n– collectHeaders – 设置需要收集哪些请求头信息\n– headers – 获得请求头数量\n– headerName – 获取指定请求头的名称\n– hasHeader – 确定是否包含指定请求头\n\n\n\n\n\n##### headerName – 获取指定请求头的名称\n\n###### 说明\n\n使用本函数，我们可以获取客户端向ESP8266物联网服务器发送的请求头的名称。\n\n请注意，使用此函数前必须先使用[collectHeaders](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/collectheaders/)函数来设置具体收集的请求头内容。\n\n###### 语法\n\n```\nserver.headerName(index)\n```\n\n###### 参数\n\nindex: 请求头序号。（类型: int）\n\n###### 返回值\n\n指定请求头名称（类型: String）\n\n###### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。\n\n浏览器请求发送之后，您就可以通过串口监视器看到浏览器发送的请求头名称以及该请求头对应的数值。\n\n以下程序使用了`server.headerName(1)`获取序号为1的请求头名称，也就是”Connection”。下图是程序运行的结果。\n\n![image-20230527120930714](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527120930714.png)\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_headerName\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n  访问主页将从串口反馈请求头的信息,具体内容请参考自定义函数 echo_headers()\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \n//创建 ESP8266WebServer 对象\nESP8266WebServer server(80);\n \n//设置需要收集的请求头信息\nconst char *headerKeys[] = {\"Connection\"};\n \n// 设置主页请求处理函数\nvoid homepage() {\n  server.send(200, \"text/plain\", \"test homepage\");\n  Serial.println(\"用户访问了主页\");\n  echo_headers();\n}\n \n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound() {                                       // 当浏览器请求的网络资源无法在服务器找到时，\n  server.send(404, \"text/plain\", \"404: Not found\");           // NodeMCU将调用此函数。\n  echo_headers();\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.begin();\n  server.on(\"/\", homepage);\n  server.onNotFound(handleNotFound);\n  Serial.println(\"HTTP server started\");\n  server.collectHeaders(headerKeys, sizeof(headerKeys) / sizeof(headerKeys[0]));\n \n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n \nvoid echo_headers() {\n  //打印当前请求中所收集的请求头的值信息,请求头名称+请求头值\n  Serial.print(server.headerName(1)); \n  Serial.print(\" = \"); \n  Serial.println(server.header(1));\n}\n```\n\n###### 相关内容\n\n– collectHeaders – 设置需要收集哪些请求头信息\n– headers – 获得请求头数量\n– header – 获得指定请求头所对应的数值\n– hasHeader – 确定是否包含指定请求头\n\n\n\n\n\n\n\n##### hasHeader – 确定是否包含指定请求头\n\n###### 说明\n\n使用本函数，我们可以获取客户端向ESP8266物联网服务器发送的请求头中有无用户指定的请求头信息。\n\n请注意，使用此函数前必须先使用[collectHeaders](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/collectheaders/)函数来设置具体收集的请求头内容。\n\n###### 语法\n\n```\nserver.hasHeader(name)\n```\n\n###### 参数\n\nname\n需要确认客户端请求中是否存在的请求头信息名。(参数类型:String)\n\n###### 返回值\n\n检查请求头中是否存在指定请求头信息。如果存在则返回真,否则返回假。返回值类型: bool\n\n###### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。\n\n浏览器请求发送之后，您就可以通过串口监视器看到浏览器发送的请求头中是否存在“Connection”信息。\n\n以下示例程序使用了server.hasHeader(“Connection”)来判断浏览器发送的请求头中是否存在“Connection”信息。以下是该程序运行的结果演示。\n\n![image-20230527121227250](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527121227250.png)\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_hasHeader\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n  并从串口反馈请求头的信息,具体内容请参考自定义函数 echo_headers()\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \n//创建 ESP8266WebServer 实例化对象\nESP8266WebServer server(80);\n \n//设置需要收集的请求头信息\nconst char *headerKeys[] = { \"Connection\"};\n \n// 设置主页请求处理函数\nvoid homepage() {\n  server.send(200, \"text/plain\", \"test homepage\");\n  Serial.println(\"用户访问了主页\");\n  echo_headers();\n}\n \n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound() {                                       // 当浏览器请求的网络资源无法在服务器找到时，\n  server.send(404, \"text/plain\", \"404: Not found\");           // NodeMCU将调用此函数。\n  echo_headers();\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.begin();\n  server.on(\"/\", homepage);\n  server.onNotFound(handleNotFound);\n  Serial.println(\"HTTP server started\");\n  server.collectHeaders(headerKeys, sizeof(headerKeys) / sizeof(headerKeys[0]));\n \n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n \nvoid echo_headers() {\n \n  //判断该请求头是否存在Connection信息\n  if (server.hasHeader(\"Connection\")) {\n    Serial.println(\"请求信息包含Connection\"); \n  } else {\n    Serial.println(\"请求信息不包含Connection\"); \n  } \n}\n```\n\n###### 相关内容\n\n– collectHeaders – 设置需要收集哪些请求头信息\n– headers – 获得请求头数量\n– header – 获得指定请求头所对应的数值\n– headerName – 获取指定请求头的名称\n\n\n\n\n\n\n\n##### authenticate – 请求认证校验\n\n###### 说明\n\n我们在使用ESP8266开发板实现物联网服务器时，可以通过本函数建立加密网页。也就是说，用户必须正确输入访问用户名和密码方可访问物联网服务器所建立的页面内容。\n\n请注意，与此函数配套使用的是[requestAuthentication](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/requestauthentication/)函数。requestAuthentication函数用于向客户端发送认证请求，而authenticate函数用于设置与校验客户端请求信息中的用户名和密码。\n\n###### 语法\n\n```\nauthenticate(username, password)\n```\n\n###### 参数\n\nusername：客户端访问物联网服务器加密页面时的认证用户名（参数类型:const char*）\n\npassword：客户端访问物联网服务器加密页面时的认证密码（参数类型:const char*）\n\n返回值\n\n如果用户密码输入正确则返回真,输入错误则返回假。\n\n###### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。\n\n接下来浏览器将会弹出对话框，要求用户输入用户名:TaichiMaker和密码:123456。如下图所示。\n\n![image-20230527121515042](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527121515042.png)\n\n只有当用户正确输入了用户名和密码信息以后，方可打开ESP8266开发板建立的网站页面。（如下图所示）\n\n![image-20230527121534407](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527121534407.png)\n\n以下示例程序中的高亮语句`server.authenticate(\"TaichiMaker\", \"123456\")`设置了服务器的访问用户名和密码信息。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_authenticate\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n  在登录主页时使用认证方式登录,并从串口反馈请求头的信息\n***********************************************************************/\n \n \n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"XXXXXXXX\";\n \nESP8266WebServer server(80);\n \n//设置需要收集的请求头信息\nconst char *headerKeys[] = {\"Content-Length\", \"Content-Type\", \"Connection\", \"Date\"};\n \n// 设置主页请求处理函数\nvoid homepage() {\n \n  //校验用户登录账号和密码,(使用Basic方式),若输入错误则继续返回认证界面\n  if (!server.authenticate(\"TaichiMaker\", \"123456\")) return server.requestAuthentication();\n \n  server.send(200, \"text/plain\", \"test homepage\");\n  Serial.println(\"用户访问了主页\");\n  echo_headers();\n}\n \n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound() {                                       // 当浏览器请求的网络资源无法在服务器找到时，\n  server.send(404, \"text/plain\", \"404: Not found\");           // NodeMCU将调用此函数。\n  echo_headers();\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.begin();\n  //设置主页处理函数\n  server.on(\"/\", homepage);\n  //设置404页面\n  server.onNotFound(handleNotFound);\n  //串口输出服务器准备完成信息\n  Serial.println(\"HTTP server started\");\n  //设置需要收集的请求头信息\n  server.collectHeaders(headerKeys, sizeof(headerKeys) / sizeof(headerKeys[0]));\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n \nvoid echo_headers() {\n \n  if (server.hasHeader(\"Connection\")) {//判断该请求头是否存在\n \n    //打印当前请求中所收集的请求头指定项的值\n    Serial.print(\"当前请求所收集的请求头Connection:\"); Serial.println(server.header(\"Connection\"));\n \n    //打印当前请求中所收集的Host\n    Serial.print(\"当前请求所收集的请求头Host :\"); Serial.println(server.hostHeader());\n    //分隔空行\n    Serial.println(\"\\r\\n\");\n  }\n}\n```\n\n\n\n###### 相关内容\n\n– requestAuthentication\n\n\n\n\n\n\n\n\n\n**获取客户端请求参数信息分类**\n\n##### args – 请求包含的参数数量\n\n###### 说明\n\n使用本函数，我们可以获取客户端向ESP8266物联网服务器发送的请求体中的参数数量。\n\n###### 语法\n\n```\nserver.args()\n```\n\n###### 参数\n\n无\n\n###### 返回值\n\n返回获取的请求体中所包含的参数数量（返回值类型:int）\n\n###### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n假设您的开发板IP地址为192.168.0.106，那么接下来您可以通过浏览器输入以下地址信息。\n\nhttp://192.168.0.106/?a=1&b=2\n\n我们可以看到，以上信息中有两个参数，那么接下来您就可以通过串口监视器查看开发板所接收到的参数数量。如下图所示。\n\n![image-20230527125607379](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527125607379.png)\n\n在以下的示例程序中，我们通过使用server.args()来获取客户端请求信息中的参数数量。\n\n```c\n/**********************************************************************\n  项目名称/Project          : 零基础入门学用物联网\n  程序名称/Program name     : WebServer_demo_args\n  团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)\n  作者/Author              : Dapenson\n  日期/Date（YYYYMMDD）     : 20200320\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n  并在请求成功后返回请求体的参数数量,具体请参考自定义函数 echo_args()中的内容\n  -----------------------------------------------------------------------\n  本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。\n  该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：\n  http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"XXXXXXXX\";\n \n//创建ESP8266WebServer对象\nESP8266WebServer server(80);\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.begin();\n  //设置主页处理函数\n  server.on(\"/\", homepage);\n  //设置404页面\n  server.onNotFound(handleNotFound);\n  //串口输出服务器准备完成信息\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n \n//自定义返回请求体信息\nvoid echo_args() {\n  Serial.print(\"当前请求中请求体数量:\"); Serial.println(server.args());\n}\n \n// 设置主页请求处理函数\nvoid homepage() {\n  server.send(200, \"text/plain\", \"test homepage\");\n  Serial.println(\"用户访问了主页\");\n  echo_args();\n}\n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound() {                                       // 当浏览器请求的网络资源无法在服务器找到时，\n  server.send(404, \"text/plain\", \"404: Not found\");           // NodeMCU将调用此函数。\n  echo_args();\n}\n```\n\n###### 相关内容\n\n– arg – 请求中指定参数的数值\n– argName – 请求中参数名\n– hasArg – 判断请求中是否包含某个参数名\n\n\n\n##### arg – 请求中指定参数的数值\n\n###### 说明\n\n使用本函数，我们可以获取客户端向ESP8266物联网服务器发送的指定参数的数值。\n\n###### 语法\n\n`server.arg(Name)`\n`server.arg(index)`\n\n###### 参数\n\n– Name\n请求体中的参数名（参数类型: String）\n\n– index\n请求体中的参数序列号（参数类型: int）\n\n###### 返回值\n\n指定参数的数值（类型：String）\n\n###### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n假设您的开发板IP地址为192.168.0.106，那么接下来您可以通过浏览器输入以下地址信息。\n\nhttp://192.168.0.106/?a=1&b=2&c=3\n\n我们可以看到，以上信息中有三个参数，这些参数中，a的数值为1，序列号为2的参数数值为3（序列号0的参数为a, 序列号1的参数为b…）。\n\n在以下示例程序中，我们使用`server.arg(\"a\")`来获取参数a的数值。使用`server.arg(2)`来获取序列号为2的参数数值。以下是串口监视器显示的以上语句所获取的参数数值。 \n\n![image-20230527125824441](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527125824441.png)\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_arg\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n  并在请求成功后返回请求体的指定请求项的值,具体请参考自定义函数 echo_args()中的内容\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \n//创建ESP8266WebServer对象\nESP8266WebServer server(80);\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.begin();\n  //设置主页处理函数\n  server.on(\"/\", homepage);\n  //设置404页面\n  server.onNotFound(handleNotFound);\n  //串口输出服务器准备完成信息\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n \n//自定义返回请求体信息\nvoid echo_args() {\n  Serial.print(\"请求体参数a的值:\"); Serial.println(server.arg(\"a\"));\n  Serial.print(\"请求体第2个参数的值:\"); Serial.println(server.arg(2));\n}\n \n// 设置主页请求处理函数\nvoid homepage() {\n  server.send(200, \"text/plain\", \"test homepage\");\n  Serial.println(\"用户访问了主页\");\n  echo_args();\n}\n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound() {                                       // 当浏览器请求的网络资源无法在服务器找到时，\n  server.send(404, \"text/plain\", \"404: Not found\");           // NodeMCU将调用此函数。\n  echo_args();\n}\n```\n\n###### 相关内容\n\n– args – 请求包含的参数数量\n– argName – 请求中参数名\n– hasArg – 判断请求中是否包含某个参数名\n\n\n\n##### argName – 请求中参数名\n\n###### 说明\n\n使用本函数，我们可以获取客户端向ESP8266物联网服务器发送的指定参数名称。\n\n###### 语法\n\n```\nserver.argName(index)\n```\n\n###### 参数\n\n– index\n请求体中的参数序列号（参数类型: int）\n\n###### 返回值\n\n请求信息中指定参数的名称 (返回值类型: String)\n\n###### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n假设您的开发板IP地址为192.168.0.106，那么接下来您可以通过浏览器输入以下地址信息。\n\nhttp://192.168.0.106/?a=1&b=2&c=3\n\n在以下示例程序中，我们使用了`server.argName(2)`来获取序列号为2的参数名称，也就是c（序列号0的参数为a, 序列号1的参数为b…）。以下是串口监视器显示的以上语句所获取的参数名称。\n\n![image-20230527125909049](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527125909049.png)\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_argName\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n  并在请求成功后返回请求体的指定项名称,具体请参考自定义函数 echo_args()中的内容\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"12345678\";\n \n//创建ESP8266WebServer对象\nESP8266WebServer server(80);\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.begin();\n  //设置主页处理函数\n  server.on(\"/\", homepage);\n  //设置404页面\n  server.onNotFound(handleNotFound);\n  //串口输出服务器准备完成信息\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n \n//自定义返回请求体信息\nvoid echo_args() {\n  Serial.print(\"当前请求中请求体2的名称:\");\n  Serial.println(server.argName(2));\n}\n \n// 设置主页请求处理函数\nvoid homepage() {\n  server.send(200, \"text/plain\", \"test homepage\");\n  Serial.println(\"用户访问了主页\");\n  echo_args();\n}\n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound() {                                       // 当浏览器请求的网络资源无法在服务器找到时，\n  server.send(404, \"text/plain\", \"404: Not found\");           // NodeMCU将调用此函数。\n  echo_args();\n}\n```\n\n###### 相关内容\n\n– args – 请求包含的参数数量\n– arg – 请求中指定参数的数值\n– hasArg – 判断请求中是否包含某个参数名\n\n\n\n\n\n##### hasArg – 判断请求中是否包含某个参数名\n\n###### 说明\n\n使用本函数，我们可以获取客户端向ESP8266物联网服务器发送的请求信息中有无指定的参数。\n\n###### 语法\n\n`server.hasArg(name)`\n\n###### 参数\n\n– Name\n需要确认的请求体中的参数名（参数类型: String）\n\n###### 返回值\n\n返回是否存在指定参数（类型bool）\n\n###### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n假设您的开发板IP地址为192.168.0.106，那么接下来您可以通过浏览器输入以下地址信息。\n\nhttp://192.168.0.106/?token=abc\n\n在以下示例程序中，我们使用了`server.hasArg(\"token\")`来判断请求信息中是否有名称为”token”的参数。如果有此参数，则通过串口监视器输出参数数值。如下图示：\n\n![image-20230527130018293](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527130018293.png)\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_hasArg\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n  在请求成功后判断是否存在该请求体指定项并返回请求体的指定请求项的值\n  具体请参考自定义函数 echo_args()中的内容\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"12345678\";\n \n//创建ESP8266WebServer对象\nESP8266WebServer server(80);\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.begin();\n  //设置主页处理函数\n  server.on(\"/\", homepage);\n  //设置404页面\n  server.onNotFound(handleNotFound);\n  //串口输出服务器准备完成信息\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n \n//自定义返回请求体信息\nvoid echo_args() {\n  if (server.hasArg(\"token\")) {\n    Serial.print(\"请求中token参数的值:\"); \n    Serial.println(server.arg(\"token\"));\n  }\n  else {\n    Serial.println(\"当前请求中无法找到指定请求体内容\");\n  }\n}\n \n// 设置主页请求处理函数\nvoid homepage() {\n  server.send(200, \"text/plain\", \"test homepage\");\n  Serial.println(\"用户访问了主页\");\n  echo_args();\n}\n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound() {                                       // 当浏览器请求的网络资源无法在服务器找到时，\n  server.send(404, \"text/plain\", \"404: Not found\");           // NodeMCU将调用此函数。\n  echo_args();\n}\n```\n\n###### 相关内容\n\n– args – 请求包含的参数数量\n– arg – 请求中指定参数的数值\n– argName – 请求中参数名\n\n\n\n#### 响应客户端请求分类\n\n##### send – 发送响应信息\n\n###### 说明\n\n在ESP8266开发板所建立的物联网服务器在运行过程中，如果有客户端向ESP8266服务器发送HTTP请求，ESP8266服务器可使用本函数向客户端发送响应信息。\n\n###### 语法\n\n```\nsend(responseCode, contentType, responseContent)\n```\n\n###### 参数\n\n– responseCode: 响应状态码（类型：int）\n– contentType: 响应内容类型，本参数为可选参数，如不使用本参数则默认为空NULL（可使用字符串类型）\n– responseContent: 响应内容，本参数为可选参数，如不使用本参数则默认为空字符串（可使用字符串类型）\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。\n\n浏览器请求发送之后，您将会再浏览器中看到ESP8266物联网服务器发送的网页信息。也就是以下示例程序中`server.send(200, \"text/plain\", \"test homepage !\")`语句所实现的内容。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_send\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置您的WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"XXXXXXXX\";\n \nESP8266WebServer server(80);\n \n//自定义主页访问处理函数\nvoid homepage() {\n  server.send(200, \"text/plain\", \"test homepage !\");\n  Serial.println(\"用户访问了主页\");\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.on(\"/\", homepage);\n  server.begin();\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n```\n\n###### 相关内容\n\n– sendHeader – 发送响应头\n– sendContent – 发送响应体\n– sendContent_P – 发送响应信息\n– setContentLength – 设置响应体长度\n\n\n\n\n\n\n\n##### sendHeader – 发送响应头\n\n###### 说明\n\n在ESP8266开发板所建立的物联网服务器在运行过程中，如果有客户端向ESP8266服务器发送HTTP请求，ESP8266服务器将会对客户端发送响应信息。本函数可用于向响应头信息中添加自定义键值对。\n\n###### 语法\n\n```\nsendHeader(headerName, headerValue, first)\n```\n\n###### 参数\n\n– headerName\n自定义的响应头信息的名称，可使用字符串类型。\n\n– headerValue\n自定义的响应头值，可使用字符串类型。\n\n– first\n设置该响应头是否需要放在第一行，不填则默认为false。（参数类型: bool）\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n为了演示本实例程序的运行结果，我在这里使用基于[Chrome](https://www.google.cn/chrome/index.html)内核的[Microsoft Edge](https://www.microsoft.com/zh-cn/edge)浏览器来进行示例程序操作演示。\n\n如下图所示，首先请打开Microsoft Edge浏览器。并根据下图中的红色箭头知识一步步打开浏览器的“开发者工具”（Developer Tools）。该工具也可以使用快捷键”Ctrl+Shift+i”打开。\n\n![image-20230527130407594](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527130407594.png)\n\n假设您的ESP8266开发板IP地址为192.168.0.106，那么请将ESP8266的IP地址输入浏览器地址栏中。\n\n输入IP地址后，接下来请按下回车。如下图中箭头所示，请再点击“开发者工具”中的Network选项卡, 然后点击ESP8266的IP地址即可在右侧的响应信息中看到键值对”device: ESP8266″(下图星标所示)。此信息正是通过以下示例程序中的语句`server.sendHeader(\"device\", \"ESP-8266\")`实现的。\n\n![image-20230527130517231](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527130517231.png)\n\n这一实验说明ESP8266建立的物联网服务器向浏览器客户端发送的响应头中带有“device:ESP8266”信息。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_sendHeader\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n  自定义响应体信息并在客户端访问时返回\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \n//创建 ESP8266WebServer 实例对象\nESP8266WebServer server(80);\n \n// 设置主页请求处理函数\nvoid homepage() {\n  Serial.println(\"用户访问了主页\");\n  \n  //设置自定义响应头内容\n  server.sendHeader(\"device\", \"ESP-8266\");\n  \n  //发送响应信息\n  server.send(200, \"text/plain\", \"test homepage\");\n}\n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound() {                                       // 当浏览器请求的网络资源无法在服务器找到时，\n  server.send(404, \"text/plain\", \"404: Not found\");           // NodeMCU将调用此函数。\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.begin();\n  //设置主页处理函数\n  server.on(\"/\", homepage);\n  //设置404页面\n  server.onNotFound(handleNotFound);\n  //串口输出服务器准备完成信息\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n```\n\n###### 相关内容\n\n– send – 发送响应信息\n– sendHeader – 发送响应头\n– sendContent_P – 发送响应信息\n– setContentLength – 设置响应体长度\n\n\n\n\n\n##### sendContent – 发送响应体信息\n\n###### 说明\n\n在ESP8266开发板所建立的物联网服务器在运行过程中，如果有客户端向ESP8266服务器发送HTTP请求，ESP8266服务器将会对客户端发送响应信息。本函数可用于向ESP8266服务器响应体中添加自定义信息。\n\n请留意：可以实现此功能的函数共有三个。一个是[sendContent](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/sendcontent/)，一个是[sendContent_P](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/sendcontent_p/)，还有一个是[streamFile](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/streamfile/)。这三个函数虽然功能相同，但是他们所发送的信息存储位置有很大区别。\n\nsendContent: sendContent函数所发送的信息通常是程序中的一个字符串。该函数的优点是直接调用程序内字符串，这个操作比起两外两种方法来说更加简单直接。但是其缺点是，由于存储发送信息的字符串是在程序中的，这会占用开发板的动态内存空间。因此，使用sendContent函数时，发送信息的大小受到了限制。\n\nsendContent_P：当我们使用sendContent_P时，发送的响应信息必须存储在程序存储空间。这一特点大大优化了程序内存占用。因此sendContent_P对于我们在发送较大的响应信息时非常有帮助。但是sendContent_P的信息仍是写在程序中，如果发送的信息需要分为多个文件存储，使用sendContent_P函数是无法胜任的。\n\nstreamFile：使用streamFile函数来发送响应信息是最推荐的操作方法。因为streamFile利用了ESP8266开发板的闪存文件系统来存储发送的信息内容。可以说streamFile函数既可以节省程序内存空间，又允许我们将需要发送的信息分为多个文件进行保存。但是使用streamFile时需要我们使用Arduino IDE的闪存文件上传工具预先将文件上传到闪存中。这一操作可能有些朋友不甚了解。不过您可以通过《[零基础入门学用物联网](http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/)》免费视频教程中的“[闪存文件系统](http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/spiffs/)”部分，了解具体操作方法。\n\n###### 语法\n\n```\nsendContent(content)\n```\n\n###### 参数\n\ncontent – 响应体信息，可使用字符串格式。\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n为了演示本实例程序的运行结果，我在这里使用基于[Chrome](https://www.google.cn/chrome/index.html)内核的[Microsoft Edge](https://www.microsoft.com/zh-cn/edge)浏览器来进行示例程序操作演示。\n\n如下图所示，首先请打开Microsoft Edge浏览器。并根据下图中的红色箭头指示一步步打开浏览器的“开发者工具”（Developer Tools）。该工具也可以使用快捷键”Ctrl+Shift+i”打开。\n\n![image-20230527130407594](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527130407594.png)\n\n假设您的ESP8266开发板IP地址为192.168.0.106，那么请将ESP8266的IP地址输入浏览器地址栏中。\n\n输入IP地址后，接下来请按下回车。如下图中箭头所示，请点击“开发者工具”中的Network选项卡, 然后点击ESP8266的IP地址，再点击Response选项卡，即可在右侧的响应体信息中看到“sendContent_test_OK”(下图星标所示)。此信息正是通过以下示例程序中的语句`server.sendContent(\"sendContent_test_OK\")`实现的。\n\n![image-20230527130736209](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527130736209.png)\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_sendContent\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n  自定义响应体信息并在客户端访问时返回,使用浏览器访问主页即可查看响应体内容\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \n//创建 ESP8266WebServer 实例对象\nESP8266WebServer server(80);\n \n// 设置主页请求处理函数\nvoid homepage() {\n  Serial.println(\"用户访问了主页\");\n  \n  //设置响应体内容以及响应体长度\n  server.sendContent(\"sendContent_test_OK\");\n}\n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound() {                                       // 当浏览器请求的网络资源无法在服务器找到时，\n  server.send(404, \"text/plain\", \"404: Not found\");           // NodeMCU将调用此函数。\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.begin();\n  //设置主页处理函数\n  server.on(\"/\", homepage);\n  //设置404页面\n  server.onNotFound(handleNotFound);\n  //串口输出服务器准备完成信息\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n```\n\n###### 相关内容\n\n– send – 发送响应信息\n– sendHeader – 发送响应头\n– sendContent_P – 发送响应信息\n– setContentLength – 设置响应体长度\n– streamFile – 发送响应体信息\n\n\n\n\n\n##### sendContent_P – 发送响应体信息\n\n###### 说明\n\n在ESP8266开发板所建立的物联网服务器在运行过程中，如果有客户端向ESP8266服务器发送HTTP请求，ESP8266服务器将会对客户端发送响应信息。本函数可用于向服务器响应体中添加自定义信息。\n\n请留意：可以实现此功能的函数共有三个。一个是[sendContent](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/sendcontent/)，一个是[sendContent_P](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/sendcontent_p/)，还有一个是[streamFile](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/streamfile/)。这三个函数虽然功能相同，但是他们所发送的信息存储位置有很大区别。\n\nsendContent: sendContent函数所发送的信息通常是程序中的一个字符串。该函数的优点是直接调用程序内字符串，这个操作比起两外两种方法来说更加简单直接。但是其缺点是，由于存储发送信息的字符串是在程序中的，这会占用开发板的动态内存空间。因此，使用sendContent函数时，发送信息的大小受到了限制。\n\nsendContent_P：当我们使用sendContent_P时，发送的响应信息必须存储在程序存储空间。这一特点大大优化了程序内存占用。因此sendContent_P对于我们在发送较大的响应信息时非常有帮助。但是sendContent_P的信息仍是写在程序中，如果发送的信息需要分为多个文件存储，使用sendContent_P函数是无法胜任的。\n\nstreamFile：使用streamFile函数来发送响应信息是最推荐的操作方法。因为streamFile利用了ESP8266开发板的闪存文件系统来存储发送的信息内容。可以说streamFile函数既可以节省程序内存空间，又允许我们将需要发送的信息分为多个文件进行保存。但是使用streamFile时需要我们使用Arduino IDE的闪存文件上传工具预先将文件上传到闪存中。\n\n###### 语法\n\n```\nsendContent_P(responseContent)\n```\n\n###### 参数\n\nresponseContent: 响应体信息，该信息必须存储在程序存储空间的字符数组。\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n假设您的开发板IP地址为192.168.0.106，那么接下来您可以通过浏览器输入以下地址信息。\n\nhttp://192.168.0.106/\n\n如下图示，接下来您将看到浏览器中显示出一行文字信息。这行信息正是通过以下示例程序中的`server.sendContent_P(reponseContent)`实现的。其中reponseContent参数信息是通过以下语句建立的。我们可以看到，该语句中的数组是保存在ESP8266开发板的程序存储空间中的。\n\n```\nconst char reponseContent[] PROGMEM = \"HELLO FROM ESP8266\";\n```\n\n![image-20230527131239714](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527131239714.png)\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_sendContent\n  程序目的/Purpose          :\n  此程序用于演示如何使用ESP8266开发板所建立的物联网服务器向客户端响应\n  储存在程序存储空间中的字符数组信息。使用程序存储空间保存信息可大大节省\n  程序内存占用。\n \n  具体操作如下：\n  1. 储存在程序存储空间中的字符数组信息\n  2. 使用sendContent_P函数将数组信息作为响应返回给客户端。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \n//创建 ESP8266WebServer 实例对象\nESP8266WebServer server(80);\n \n// 建立保存在程序存储空间中的字符串\nconst char reponseContent[] PROGMEM = \"HELLO FROM ESP8266\";\n \n// 设置主页请求处理函数\nvoid homepage() {\n  Serial.println(\"用户访问了主页\");\n  \n  //设置响应体内容\n  server.sendContent_P(reponseContent);\n}\n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound() {                                       // 当浏览器请求的网络资源无法在服务器找到时，\n  server.send(404, \"text/plain\", \"404: Not found\");           // NodeMCU将调用此函数。\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.begin();\n  //设置主页处理函数\n  server.on(\"/\", homepage);\n  //设置404页面\n  server.onNotFound(handleNotFound);\n  //串口输出服务器准备完成信息\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n```\n\n###### 相关内容\n\n– send – 发送响应信息\n– sendHeader – 发送响应头\n– sendContent – 发送响应体\n– setContentLength – 设置响应体长度\n– streamFile – 发送响应体信息\n\n\n\n\n\n\n\n\n\n##### streamFile – 发送响应体信息\n\n###### 说明\n\n在ESP8266开发板所建立的物联网服务器在运行过程中，如果有客户端向服务器发送HTTP请求，服务器将会对客户端发送响应信息。本函数可用于向服务器响应体中添加自定义信息。\n\n请留意：可以实现此功能的函数共有三个。一个是[sendContent](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/sendcontent/)，一个是[sendContent_P](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/sendcontent_p/)，还有一个是[streamFile](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/streamfile/)。这三个函数虽然功能相同，但是他们所发送的信息存储位置有很大区别。\n\nsendContent: sendContent函数所发送的信息通常是程序中的一个字符串。该函数的优点是直接调用程序内字符串，这个操作比起两外两种方法来说更加简单直接。但是其缺点是，由于存储发送信息的字符串是在程序中的，这会占用开发板的动态内存空间。因此，使用sendContent函数时，发送信息的大小受到了限制。\n\nsendContent_P：当我们使用sendContent_P时，发送的响应信息必须存储在程序存储空间。这一特点大大优化了程序内存占用。因此sendContent_P对于我们在发送较大的响应信息时非常有帮助。但是sendContent_P的信息仍是写在程序中，如果发送的信息需要分为多个文件存储，使用sendContent_P函数是无法胜任的。\n\nstreamFile：使用streamFile函数来发送响应信息是最推荐的操作方法。因为streamFile利用了ESP8266开发板的闪存文件系统来存储发送的信息内容。可以说streamFile函数既可以节省程序内存空间，又允许我们将需要发送的信息分为多个文件进行保存。但是使用streamFile时需要我们使用Arduino IDE的闪存文件上传工具预先将文件上传到闪存中。\n\n###### 语法\n\nstreamFile(file, contentType)\n\n###### 参数\n\nfile – 存储有响应信息的闪存文件对象\ncontentType（可选参数） – 响应信息系类型 （const String& ）\n\n###### 语法\n\n发送的文件大小，类型：size_t\n\n###### 示例程序\n\n首先请将以下下载链接中的网页文件上传到ESP8266的闪存文件系统中。\n\n接下来请将示例程序中的WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n假设您的开发板IP地址为192.168.0.106，那么接下来您可以通过浏览器输入以下地址信息。\n\nhttp://192.168.0.106/\n\n接下来您将在浏览器中看到以下页面。此页面内容正是ESP8266开发板通过streamFile函数将闪存中的文件内容发送给浏览器的。\n\n```c\n/**********************************************************************\n程序名称/Program name     : 3_4_1_SPIFFS_File_server\n程序目的/Purpose          : \n当用户访问NodeMCU地址时，NodeMCU将会检查访问地址是否指向SPIFFS系统中的文件，并且\n将该文件显示于用户的浏览器中。如果访问地址所指向的文件无法在SPIFFS中找到，NodeMCU将会\n向用户发送404信息。\n***********************************************************************/\n\n#include <ESP8266WiFi.h>\n#include <ESP8266WiFiMulti.h>\n#include <ESP8266WebServer.h>\n#include <FS.h>  \n\nESP8266WiFiMulti wifiMulti;     // 建立ESP8266WiFiMulti对象\n\nESP8266WebServer esp8266_server(80);    // 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）\n\nvoid setup() {\n  Serial.begin(9600);          // 启动串口通讯\n  Serial.println(\"\");\n  \n  wifiMulti.addAP(\"ssid_from_AP_1\", \"your_password_for_AP_1\"); // 将需要连接的一系列WiFi ID和密码输入这里\n  wifiMulti.addAP(\"ssid_from_AP_2\", \"your_password_for_AP_2\"); // ESP8266-NodeMCU再启动后会扫描当前网络\n  wifiMulti.addAP(\"ssid_from_AP_3\", \"your_password_for_AP_3\"); // 环境查找是否有这里列出的WiFi ID。如果有\n  Serial.println(\"Connecting ...\");                            // 则尝试使用此处存储的密码进行连接。\n  \n  int i = 0;  \n  while (wifiMulti.run() != WL_CONNECTED) { // 尝试进行wifi连接。\n    delay(1000);\n    Serial.print(i++); Serial.print(' ');\n  }\n  \n  // WiFi连接成功后将通过串口监视器输出连接成功信息 \n  Serial.println('\\n');\n  Serial.print(\"Connected to \");\n  Serial.println(WiFi.SSID());              // 通过串口监视器输出连接的WiFi名称\n  Serial.print(\"IP address:\\t\");\n  Serial.println(WiFi.localIP());           // 通过串口监视器输出ESP8266-NodeMCU的IP\n\n  if(SPIFFS.begin()){                       // 启动闪存文件系统\n    Serial.println(\"SPIFFS Started.\");\n  } else {\n    Serial.println(\"SPIFFS Failed to Start.\");\n  }\n  \n  esp8266_server.onNotFound(handleUserRequet);      // 告知系统如何处理用户请求\n\n  esp8266_server.begin();                           // 启动网站服务\n  Serial.println(\"HTTP server started\");\n}\n\nvoid loop(void) {\n  esp8266_server.handleClient();                    // 处理用户请求\n}\n\n// 处理用户浏览器的HTTP访问\nvoid handleUserRequet() {         \n     \n  // 获取用户请求网址信息\n  String webAddress = esp8266_server.uri();\n  \n  // 通过handleFileRead函数处处理用户访问\n  bool fileReadOK = handleFileRead(webAddress);\n\n  // 如果在SPIFFS无法找到用户访问的资源，则回复404 (Not Found)\n  if (!fileReadOK){                                                 \n    esp8266_server.send(404, \"text/plain\", \"404 Not Found\"); \n  }\n}\n\nbool handleFileRead(String path) {            //处理浏览器HTTP访问\n\n  if (path.endsWith(\"/\")) {                   // 如果访问地址以\"/\"为结尾\n    path = \"/index.html\";                     // 则将访问地址修改为/index.html便于SPIFFS访问\n  } \n  \n  String contentType = getContentType(path);  // 获取文件类型\n  \n  if (SPIFFS.exists(path)) {                     // 如果访问的文件可以在SPIFFS中找到\n    File file = SPIFFS.open(path, \"r\");          // 则尝试打开该文件\n    esp8266_server.streamFile(file, contentType);// 并且将该文件返回给浏览器\n    file.close();                                // 并且关闭文件\n    return true;                                 // 返回true\n  }\n  return false;                                  // 如果文件未找到，则返回false\n}\n\n// 获取文件类型\nString getContentType(String filename){\n  if(filename.endsWith(\".htm\")) return \"text/html\";\n  else if(filename.endsWith(\".html\")) return \"text/html\";\n  else if(filename.endsWith(\".css\")) return \"text/css\";\n  else if(filename.endsWith(\".js\")) return \"application/javascript\";\n  else if(filename.endsWith(\".png\")) return \"image/png\";\n  else if(filename.endsWith(\".gif\")) return \"image/gif\";\n  else if(filename.endsWith(\".jpg\")) return \"image/jpeg\";\n  else if(filename.endsWith(\".ico\")) return \"image/x-icon\";\n  else if(filename.endsWith(\".xml\")) return \"text/xml\";\n  else if(filename.endsWith(\".pdf\")) return \"application/x-pdf\";\n  else if(filename.endsWith(\".zip\")) return \"application/x-zip\";\n  else if(filename.endsWith(\".gz\")) return \"application/x-gzip\";\n  return \"text/plain\";\n}\n```\n\n[ESP8266 – ESP8266WebServer库 – streamFile – 太极创客 (taichi-maker.com)](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/streamfile/)\n\n\n\n##### setContentLength – 设置响应体长度\n\n###### 说明\n\n在ESP8266开发板所建立的物联网服务器在运行过程中，如果有客户端向ESP8266服务器发送HTTP请求，ESP8266服务器将会对客户端发送响应信息。本函数可用于设置响应信息中的响应体长度。\n\n假如我们在开发时不确定响应体信息长度，则可以如下所示对setContentLength使用CONTENT_LENGTH_UNKNOWN关键词作为参数来调用。\n\n```\nserver.setContentLength(CONTENT_LENGTH_UNKNOWN)\n```\n\n###### 语法\n\n```\nsetContentLength(contentLength)\n```\n\n###### 参数\n\ncontentLength\n响应体的长度(参数类型 : const size_t）\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n假设您的ESP8266开发板IP地址为192.168.0.106，那么请将ESP8266的IP地址输入浏览器地址栏中。接下来您将看到浏览器将会显示ESP8266开发板返回的响应体信息。同时，以下程序中使用了`server.setContentLength(CONTENT_LENGTH_UNKNOWN)`来演示setContentLength的使用方法。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_sendHeader\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n  自定义响应体信息并在客户端访问时返回\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \n//创建 ESP8266WebServer 实例对象\nESP8266WebServer server(80);\n \n// 设置主页请求处理函数\nvoid homepage() {\n  Serial.println(\"用户访问了主页\");\n  server.sendContent(\"sendContent_test_OK\");\n  server.setContentLength(CONTENT_LENGTH_UNKNOWN);\n}\n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound() {                                       // 当浏览器请求的网络资源无法在服务器找到时，\n  server.send(404, \"text/plain\", \"404: Not found\");           // NodeMCU将调用此函数。\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.begin();\n  //设置主页处理函数\n  server.on(\"/\", homepage);\n  //设置404页面\n  server.onNotFound(handleNotFound);\n  //串口输出服务器准备完成信息\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n```\n\n###### 相关内容\n\n– send – 发送响应信息\n– sendHeader – 发送响应头\n– sendContent – 发送响应体\n– sendContent_P – 发送响应信息\n\n\n\n\n\n\n\n##### upload – 处理文件上传\n\n###### 语法\n\n此函数用于ESP8266开发板所建立的物联网服务器处理客户端的文件上传请求。\n\n###### 参数\n\n```\nserver.upload()\n```\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n```c\n/**********************************************************************\n程序名称/Program name     : 3_4_8_SPIFFS_File_Upload_Server\n程序目的/Purpose          : 建立网络服务器，允许用户通过网页将文件上传到SPIFFS\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <ESP8266WiFiMulti.h>\n#include <ESP8266WebServer.h>\n#include <FS.h>  \n \nESP8266WiFiMulti wifiMulti;     // 建立ESP8266WiFiMulti对象,对象名称是 'wifiMulti'\n \nESP8266WebServer esp8266_server(80);    // 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）      \n \nFile fsUploadFile;              // 建立文件对象用于闪存文件上传\n \nvoid setup() {\n  Serial.begin(9600);        \n  Serial.println(\"\");\n \n  wifiMulti.addAP(\"ssid_from_AP_1\", \"your_password_for_AP_1\"); // 将需要连接的一系列WiFi ID和密码输入这里\n  wifiMulti.addAP(\"ssid_from_AP_2\", \"your_password_for_AP_2\"); // ESP8266-NodeMCU再启动后会扫描当前网络\n  wifiMulti.addAP(\"ssid_from_AP_3\", \"your_password_for_AP_3\"); // 环境查找是否有这里列出的WiFi ID。如果有\n  Serial.println(\"Connecting ...\");                            // 则尝试使用此处存储的密码进行连接。\n \n  int i = 0;  \n  while (wifiMulti.run() != WL_CONNECTED) { // 尝试进行wifi连接。\n    delay(1000);\n    Serial.print(i++); Serial.print('.');\n  }\n  \n  // WiFi连接成功后将通过串口监视器输出连接成功信息 \n  Serial.println('\\n');\n  Serial.print(\"Connected to \");\n  Serial.println(WiFi.SSID());              // 通过串口监视器输出连接的WiFi名称\n  Serial.print(\"IP address:\\t\");\n  Serial.println(WiFi.localIP());           // 通过串口监视器输出ESP8266-NodeMCU的IP\n          \n  if(SPIFFS.begin()){                       // 启动闪存文件系统\n    Serial.println(\"SPIFFS Started.\");\n  } else {\n    Serial.println(\"SPIFFS Failed to Start.\");\n  }\n  \n  esp8266_server.on(\"/upload.html\",   // 如果客户端通过upload页面\n                    HTTP_POST,        // 向服务器发送文件(请求方法POST)\n                    respondOK,        // 则回复状态码 200 给客户端\n                    handleFileUpload);// 并且运行处理文件上传函数\n \n  esp8266_server.onNotFound(handleUserRequest);\n \n  esp8266_server.begin();                           // 启动网站服务\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop() {\n  esp8266_server.handleClient();\n}\n \n// 处理上传文件函数\nvoid handleFileUpload(){  \n  \n  HTTPUpload& upload = esp8266_server.upload();\n  \n  if(upload.status == UPLOAD_FILE_START){                     // 如果上传状态为UPLOAD_FILE_START\n    \n    String filename = upload.filename;                        // 建立字符串变量用于存放上传文件名\n    if(!filename.startsWith(\"/\")) filename = \"/\" + filename;  // 为上传文件名前加上\"/\"\n    Serial.println(\"File Name: \" + filename);                 // 通过串口监视器输出上传文件的名称\n \n    fsUploadFile = SPIFFS.open(filename, \"w\");            // 在SPIFFS中建立文件用于写入用户上传的文件数据\n    \n  } else if(upload.status == UPLOAD_FILE_WRITE){          // 如果上传状态为UPLOAD_FILE_WRITE      \n    \n    if(fsUploadFile)\n      fsUploadFile.write(upload.buf, upload.currentSize); // 向SPIFFS文件写入浏览器发来的文件数据\n      \n  } else if(upload.status == UPLOAD_FILE_END){            // 如果上传状态为UPLOAD_FILE_END \n    if(fsUploadFile) {                                    // 如果文件成功建立\n      fsUploadFile.close();                               // 将文件关闭\n      Serial.println(\" Size: \"+ upload.totalSize);        // 通过串口监视器输出文件大小\n      esp8266_server.sendHeader(\"Location\",\"/success.html\");  // 将浏览器跳转到/success.html（成功上传页面）\n      esp8266_server.send(303);                               // 发送相应代码303（重定向到新页面） \n    } else {                                              // 如果文件未能成功建立\n      Serial.println(\"File upload failed\");               // 通过串口监视器输出报错信息\n      esp8266_server.send(500, \"text/plain\", \"500: couldn't create file\"); // 向浏览器发送相应代码500（服务器错误）\n    }    \n  }\n}\n \n//回复状态码 200 给客户端\nvoid respondOK(){\n  esp8266_server.send(200);\n}\n \n// 处理用户浏览器的HTTP访问\nvoid handleUserRequest(){\n                              \n  // 获取用户请求网址信息\n  String webAddress = esp8266_server.uri();\n  \n  // 通过handleFileRead函数处处理用户访问\n  bool fileReadOK = handleFileRead(webAddress);\n \n  // 如果在SPIFFS无法找到用户访问的资源，则回复404 (Not Found)\n  if (!fileReadOK){                                                 \n    esp8266_server.send(404, \"text/plain\", \"404 Not Found\"); \n  }\n}\n \nbool handleFileRead(String path) {            //处理浏览器HTTP访问\n \n  if (path.endsWith(\"/\")) {                   // 如果访问地址以\"/\"为结尾\n    path = \"/index.html\";                     // 则将访问地址修改为/index.html便于SPIFFS访问\n  } \n  \n  String contentType = getContentType(path);  // 获取文件类型\n  \n  if (SPIFFS.exists(path)) {                     // 如果访问的文件可以在SPIFFS中找到\n    File file = SPIFFS.open(path, \"r\");          // 则尝试打开该文件\n    esp8266_server.streamFile(file, contentType);// 并且将该文件返回给浏览器\n    file.close();                                // 并且关闭文件\n    return true;                                 // 返回true\n  }\n  return false;                                  // 如果文件未找到，则返回false\n}\n \n// 获取文件类型\nString getContentType(String filename){\n  if(filename.endsWith(\".htm\")) return \"text/html\";\n  else if(filename.endsWith(\".html\")) return \"text/html\";\n  else if(filename.endsWith(\".css\")) return \"text/css\";\n  else if(filename.endsWith(\".js\")) return \"application/javascript\";\n  else if(filename.endsWith(\".png\")) return \"image/png\";\n  else if(filename.endsWith(\".gif\")) return \"image/gif\";\n  else if(filename.endsWith(\".jpg\")) return \"image/jpeg\";\n  else if(filename.endsWith(\".ico\")) return \"image/x-icon\";\n  else if(filename.endsWith(\".xml\")) return \"text/xml\";\n  else if(filename.endsWith(\".pdf\")) return \"application/x-pdf\";\n  else if(filename.endsWith(\".zip\")) return \"application/x-zip\";\n  else if(filename.endsWith(\".gz\")) return \"application/x-gzip\";\n  return \"text/plain\";\n}\n```\n\n\n\n##### requestAuthentication – 请求客户端认证\n\n###### 语法\n\n在ESP8266开发板所建立的物联网服务器在运行过程中，如果有客户端向服务器发送HTTP请求，服务器可使用本函数向客户端发送认证请求,从而建立需要用户名和密码认证的加密网页服务器。只有当客户端请求信息中包含正确的认证请求方可访问网页信息。\n\n请注意，与此函数配套使用的是[authenticate](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266webserver/authenticate/)函数。authenticate用于设置与校验客户端请求信息中的用户名和密码。而requestAuthentication用于向客户端发送认证请求。\n\n###### 语法\n\n```\nserver.requestAuthentication(mode, realm, authFailMsg)`\n`server.requestAuthentication()\n```\n\n###### 参数\n\nmode (可选参数)\n– HTTP验证方式\n– 可选关键词：BASIC_AUTH、 DIGEST_AUTH（不填则默认为BASIC_AUTH）\n\nrealm (可选参数)\n– 认证范围\n– 参数类型: const char\\* (不填则默认为空NULL)\n\nauthFailMsg (可选参数)\n– 认证失败提示消息\n– 参数类型: const String\n– 不填则默认为空字符串 String(“”)\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。\n\n接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。\n\n接下来浏览器将会弹出对话框，要求用户输入用户名:TaichiMaker和密码:123456。如下图所示。\n\n![ESP8266-authenticate-example-result1](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527121515042.png)\n\n只有当用户正确输入了用户名和密码信息以后，方可打开ESP8266开发板建立的网站页面。（如下图所示）\n\n![ESP8266-authenticate-example-result2](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527121534407.png)\n\n以下示例程序中的高亮语句`server.requestAuthentication()`要求客户端发送打开网页的用户名和密码。\n\n```c\n/**********************************************************************\n  程序名称/Program name     : WebServer_demo_requestAuthentication\n  程序目的/Purpose          :\n  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问\n  在登录主页时使用认证方式登录,登录账户密码分别为(TaichiMaker/123456)\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n \n//设置WiFi接入信息\nconst char* ssid = \"TaichiMaker\";\nconst char* password = \"xxxxxxxx\";\n \nESP8266WebServer server(80);\n \n//设置需要收集的请求头信息\nconst char *headerKeys[] = {\"Content-Length\", \"Content-Type\", \"Connection\", \"Date\"};\n \n// 设置主页请求处理函数\nvoid homepage() {\n \n  //校验用户登录账号和密码,(默认使用Basic方式),若输入错误则继续返回认证界面\n  if (!server.authenticate(\"TaichiMaker\", \"123456\")) \n  return server.requestAuthentication();\n \n  server.send(200, \"text/plain\", \"test homepage\");\n  Serial.println(\"用户访问了主页\");\n}\n \n// 设置处理404情况的函数'handleNotFound'\nvoid handleNotFound() {                                       // 当浏览器请求的网络资源无法在服务器找到时，\n  server.send(404, \"text/plain\", \"404: Not found\");           // NodeMCU将调用此函数。\n}\n \nvoid setup(void) {\n  //初始化串口\n  Serial.begin(115200);\n  Serial.println(\"\");\n \n  //初始化网络\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  //初始化WebServer\n  server.begin();\n  //设置主页处理函数\n  server.on(\"/\", homepage);\n  //设置404页面\n  server.onNotFound(handleNotFound);\n  //串口输出服务器准备完成信息\n  Serial.println(\"HTTP server started\");\n}\n \nvoid loop(void) {\n  //监听客户请求并处理\n  server.handleClient();\n}\n```\n\n###### 相关内容\n\n– authenticate\n– on\n– onNotFound\n\n\n\n\n\n## ESP8266 – WiFiClientSecure库\n\nWiFiClientSecure库用于HTTPS协议通讯。通过WiFiClientSecure库，我们可以使用ESP8266利用HTTPS协议向网络服务器发送请求，并且分析网络服务器返回的响应信息，从而实现更加安全的物联网应用。\n\nHTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的互联网协议。HTTPS协议在HTTP的基础上通过SSL或TLS来实现传输加密和身份认证，从而保证了传输过程的安全性。假如您需要进一步了解HTTPS协议的介绍关内容，请参考[百度百科HTTPS协议页面](https://baike.baidu.com/item/https/285356)。\n\n当然，如果您的物联网应用对安全性能并没有很高的要求，那么您也可以使用[ESP8266HTTPClient库](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/esp8266httpclient/)通过HTTP协议来实现ESP8266物联网应用。\n\n以下为WiFiClientSecure库的整体结构图。\n\n![image-20230527133200513](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527133200513.png)\n\n### ESP8266-HTTPS开发实用知识\n\n#### 查看网站证书指纹\n\n在我们用HTTPS协议开发物联网项目时，有时需要获取网站服务器的证书指纹信息。我们可以用电脑中的浏览器来获取该信息。\n\n为了演示本操作，我在这里使用基于[Chrome](https://www.google.cn/chrome/index.html)内核的[Microsoft Edge](https://www.microsoft.com/zh-cn/edge)浏览器来进行演示如何获取www.howsmyssl.com网站服务器的证书指纹。\n\n首先请在服务器地址栏中输入以下网址：\n\nhttps://www.howsmyssl.com/\n\n当浏览器成功打开以上网址的网页后，请如下图所示点击地址栏前面的“小锁”标志。然后在弹出的菜单中点击“证书”（如下图2号红色方框所标识的信息）。\n\n![image-20230527134256246](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527134256246.png)\n\n如下图所示，请在弹出的“证书”窗口中，点击“证书路径”标签(如下图中数字1所标识)，然后用鼠标选中”www.howsmyssl.com”（如下图中数字1所标识）。\n\n![image-20230527134314022](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527134314022.png)\n\n\n\n如下图所示，请在弹出的“证书”窗口中，点击“详细信息”，然后在窗口信息中找到“指纹”项目。当您用鼠标点击该项目后，即可在窗口下方看到一排英文字符（如下图红色标识）。这串红色标识的字符即是网站的证书指纹信息。\n\n![image-20230527134331830](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527134331830.png)\n\n**注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此您所看到的指纹信息可能与以上图片中显示的信息不同。同时，如果您将指纹信息写入程序中，要留意及时更新该信息。否则当网站更新指纹信息后，您的程序将无法用于通过HTTPS协议访问网站信息。**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 查看网站证书和公钥\n\n在我们用HTTPS协议开发物联网项目时，有时需要获取网站服务器的证书和公钥。我们可以用电脑中的浏览器来获取该信息。\n\n为了演示本操作，我在这里使用基于[Chrome](https://www.google.cn/chrome/index.html)内核的[Microsoft Edge](https://www.microsoft.com/zh-cn/edge)浏览器来进行演示如何获取必应网站(www.bing.com)服务器的证书和公钥。\n\n首先请在服务器地址栏中输入以下网址：\n\n[https://www.bing.com](https://www.bing.com/)\n\n当浏览器成功打开以上网址的网页后，请如下图所示点击地址栏前面的“小锁”标志。然后在弹出的菜单中点击“证书”（如下图红色箭头所标识的信息）。\n\n![image-20230527134515449](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527134515449.png)\n\n如下图所示，请在弹出的“证书”窗口中，点击下图数字1所示的“证书路径”，然后用鼠标选中下图数字2所示的“www.bing.com”。\n\n![image-20230527134544054](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527134544054.png)\n\n如下图所示，接下来请点击下图数字1所示的“详细信息”标签。此时窗口中显示的都是上一步选中的“www.bing.com”网站服务器证书的详细信息。然后您 就可以点击下图中数字2所示的“复制到文件”按钮。\n\n![image-20230527134611162](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527134611162.png)\n\n如下图所示，在弹出的“证书导出向导”中点击 “下一步”按钮。\n\n![image-20230527134629458](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527134629458.png)\n\n如下图所示，接下来您可以根据自己的需要选择证书格式。请选择Base64编码X.509(.CER)选项，然后点击下一步。\n\n![image-20230527134700599](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527134700599.png)\n\n如下图所示，在接下来的步骤里，点击浏览按钮，选择保存证书文件的路径。\n\n![image-20230527134718733](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527134718733.png)\n\n如下图所示，我们完成了网站服务器证书的导出工作。如果您需要从该证书中提取公钥信息，那么请继续看后续的讲解。\n\n![image-20230527134745341](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527134745341.png)\n\n在接下来的操作中，我们将需要使用OpenSSL工具。如果您使用的是Windows电脑，那么需要使用以下链接将OpenSSL工具下载并安装到电脑中。如果您的电脑中已经安装好git这类集成了OpenSSL的软件，那么您可以不必下载以下工具。简言之，无论您使用什么软件和方法，只要您可以在电脑中使用OpenSSL就可了。\n\n[Win64 OpenSSL v1.1.1g Light (蓝奏云下载，适用64位Windows)](https://lanzous.com/ibs5aod)\n\n[Win32 OpenSSL v1.1.1g Light (蓝奏云下载，适用64位Windows)](https://lanzous.com/ibs5ahg)\n\n[Shining Light Productions网站下载](https://slproweb.com/products/Win32OpenSSL.html)\n\n接下来请启动OpenSSL工具，并进入刚刚下载的证书存放路径，然后输入以下指令，即可从下载的证书中提取公钥信息。\n\n```\nopenssl x509 -pubkey -noout -in bing.cer\n```\n\n注意，以上指令中的“bing.cer”为下载的证书名称，务必确保这一部分内容是准确的。另外在输入以上指令时务必确保您当前的操作路径是证书存放路径。\n\n如下图所示，公钥信息将会显示在屏幕中供您复制粘贴到程序中使用。\n\n![image-20230527135034147](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527135034147.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 查看网站根证书\n\n在我们用HTTPS协议开发物联网项目时，有时需要获取根证书。我们可以用电脑中的浏览器来获取该信息。\n\n为了演示本操作，我在这里使用基于[Chrome](https://www.google.cn/chrome/index.html)内核的[Microsoft Edge](https://www.microsoft.com/zh-cn/edge)浏览器来进行演示如何获取www.howsmyssl.com网站服务器的证书指纹。\n\n1. 请在服务器地址栏中输入以下网址：\n\nhttps://www.howsmyssl.com/\n\n当浏览器成功打开以上网址的网页后，请如下图所示点击地址栏前面的“小锁”标志。然后在弹出的菜单中点击“证书”（如下图2号红色方框所标识的信息）。\n\n![image-20230527141018048](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527141018048.png)\n\n2. 如下图所示，请在弹出的“证书”窗口中，点击下图数字1所示的“证书路径”，然后用鼠标选中下图数字2所示的“DST Root CA X3”证书。\n\n![image-20230527141029424](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527141029424.png)\n\n3. 接下来请点击下图数字1所示的“详细信息”标签。此时窗口中显示的都是上一步选中的“DST Root CA X3”证书的详细信息。然后您 就可以点击下图中数字2所示的“复制到文件”按钮。\n\n![image-20230527141038975](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527141038975.png)\n\n4. 在弹出的“证书导出向导”中点击 “下一步”按钮。\n\n![image-20230527141047916](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527141047916.png)\n\n5. 接下来您可以根据自己的需要选择证书格式。\n\n假如您需要将本证书应用于本站的ESP8266物联网开发资料页中的示例程序，那么请选择Base64编码X.509(.CER)选项，然后点击下一步。\n\n![image-20230527141104115](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527141104115.png)\n\n\n\n6. 在接下来的步骤里，点击浏览按钮，选择保存证书文件的路径。\n\n![image-20230527141115249](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527141115249.png)\n\n7. 点击完成按钮，证书将会到出到您电脑中指定路径。\n\n![image-20230527141124524](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527141124524.png)\n\n8. 请使用Notepade++一类的文本编辑软件打开刚刚导出的证书文件，您就会得到网站证书的详细内容。\n\n   ![image-20230527141135767](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527141135767.png)\n\n\n\n\n\n\n\n\n\n### 连接认证类型\n\n#### 连接类型\n\n##### WiFiClientSecure – 建立WiFiClientSecure对象\n\n###### 说明\n\n通过WiFiClientSecure语句，我们可以建立WiFiClientSecure对象从而实现ESP8266的HTTPS协议物联网通讯。\n\n###### 语法\n\n`WiFiClientSecure httpsClient`\n注：请参考本页的示例程序部分获取更多应用说明信息。此函数在示例程序中被高亮标记以便您查阅。\n\n###### 参数\n\n无\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n**示例1：ESP8266实现HTTPS通讯（指纹认证）**\n\n以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。本程序使用了指纹认证方式。比起本页的“示例2：ESP8266实现HTTPS通讯（证书认证）”，示例1所采用的指纹认证不如证书认证安全性高。\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。\n\n![image-20230527141722780](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527141722780.png)\n\n\n\n**注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。如需了解如何执行这一操作，请参考“查看网站证书指纹”。**\n\n```c\n/**********************************************************************\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的WiFiClientSecure语句来建立\nWiFiClientSecure对象。该对象用于控制ESP8266的HTTPS协议通讯。\n \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。\n \n本程序使用了指纹认证方式。该方式没有证书认证方式安全。\n \n注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n并复制粘贴到程序中相应位置。如需了解如何执行这一操作，请参考“获取网站证书指纹”\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n#include <ESP8266WebServer.h>\n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"www.howsmyssl.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \n//注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n//并复制粘贴到此处。如需了解如何执行这一操作，请参考太极创客网站中\n//“获取网站证书指纹”页面(网址见下):\n//http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/http-client-secure/certificate-fingerprint/\nconst char fingerprint[] PROGMEM = \"c7c1f454fb33ef22191163c50c12dc7d4842694a\";\n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  // 实现HTTPS通讯\n  httpsCom();\n}\n \nvoid loop(){}\n \nvoid httpsCom(){\n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n \n  Serial.println(host);\n \n  Serial.printf(\"Using fingerprint '%s'\\n\", fingerprint);\n  httpsClient.setFingerprint(fingerprint);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器\n  // 告知用户当前ESP8266已经成功接收服务器响应头信息。\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  // 通过串口监视器输出服务器响应体信息（服务器报文）\n  Serial.println(\"==========\");\n  Serial.println(\"server response payload:\"); \n  String line;\n  while(httpsClient.available()){        \n    line = httpsClient.readStringUntil('\\n');  //Read Line by Line\n    Serial.println(line); //Print response\n  }\n  Serial.println(\"==========\");\n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n```\n\n\n\n**示例2：ESP8266实现HTTPS通讯（证书认证）**\n\n本实例所实现的功能与示例1相同。唯一区别是本示例中在ESP8266与服务器的HTTPS通信中，使用证书认证而不是指纹认证。使用本示例中的证书认证可以提高HTTPS通讯安全性。\n\n如需了解本示例程序的操作方法和运行结果，请参考示例1中的相应内容。\n\n**注意：出于安全原因，CA会定期更新根证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。如需了解如何执行这一操作，“查看网站根证书”。**\n\n```c\n/**********************************************************************\n程序名称/Program name     : WiFiClientSecure_2\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的WiFiClientSecure语句来建立\nWiFiClientSecure对象。该对象用于控制ESP8266的HTTPS协议通讯。\n \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。\n \n本程序使用了证书认证方式。该方式比指纹认证方式要更安全。\n \n注意：出于安全原因，CA会定期更新证书信息。因此本程序\n中的证书可能已经过期。请使用浏览器获取最新的网站根证书\n并复制粘贴到程序中相应位置。如需了解如何执行这一操作，请参考“获取网站根证书”\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n#include <ESP8266WebServer.h>\n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"www.howsmyssl.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  httpsCom(); // 实现https通讯\n}\n \nvoid loop() {}\n \n// 实现https通讯\nvoid httpsCom(){\n//注意：出于安全原因，CA会定期更新证书信息。因此本程序\n//中的证书可能已经过期。请使用浏览器获取最新的证书\n//并复制粘贴到此处。如需了解如何执行这一操作，请参考“获取网站证书”\n  static const char digicert[] PROGMEM = R\"EOF( // 证书信息\n-----BEGIN CERTIFICATE-----\nMIIDSjCCAjKgAwIBAgIQRK+wgNajJ7qJMDmGLvhAazANBgkqhkiG9w0BAQUFADA/\nMSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMT\nDkRTVCBSb290IENBIFgzMB4XDTAwMDkzMDIxMTIxOVoXDTIxMDkzMDE0MDExNVow\nPzEkMCIGA1UEChMbRGlnaXRhbCBTaWduYXR1cmUgVHJ1c3QgQ28uMRcwFQYDVQQD\nEw5EU1QgUm9vdCBDQSBYMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB\nAN+v6ZdQCINXtMxiZfaQguzH0yxrMMpb7NnDfcdAwRgUi+DoM3ZJKuM/IUmTrE4O\nrz5Iy2Xu/NMhD2XSKtkyj4zl93ewEnu1lcCJo6m67XMuegwGMoOifooUMM0RoOEq\nOLl5CjH9UL2AZd+3UWODyOKIYepLYYHsUmu5ouJLGiifSKOeDNoJjj4XLh7dIN9b\nxiqKqy69cK3FCxolkHRyxXtqqzTWMIn/5WgTe1QLyNau7Fqckh49ZLOMxt+/yUFw\n7BZy1SbsOFU5Q9D8/RhcQPGX69Wam40dutolucbY38EVAjqr2m7xPi71XAicPNaD\naeQQmxkqtilX4+U9m5/wAl0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNV\nHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFMSnsaR7LHH62+FLkHX/xBVghYkQMA0GCSqG\nSIb3DQEBBQUAA4IBAQCjGiybFwBcqR7uKGY3Or+Dxz9LwwmglSBd49lZRNI+DT69\nikugdB/OEIKcdBodfpga3csTS7MgROSR6cz8faXbauX+5v3gTt23ADq1cEmv8uXr\nAvHRAosZy5Q6XkjEGB5YGV8eAlrwDPGxrancWYaLbumR9YbK+rlmM6pZW87ipxZz\nR8srzJmwN0jP41ZL9c8PDHIyh8bwRLtTcm1D9SZImlJnt1ir/md2cXjbDaJWFBM5\nJDGFoqgCWjBH4d1QB7wCCZAA62RjYJsWvIjJEubSfZGL+T0yjWW06XyxV3bqxbYo\nOb8VZRzI9neWagqNdwvYkQsEjgfbKbYK7p2CNTUQ\n-----END CERTIFICATE-----\n)EOF\";\n  \n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n  BearSSL::X509List cert(digicert);\n  \n  // 设置时间\n  setClock();\n  \n  Serial.println(\"Using certificate\");\n  httpsClient.setTrustAnchors(&cert);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器\n  // 告知用户当前ESP8266已经成功接收服务器响应头信息。\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  // 通过串口监视器输出服务器响应体信息（服务器报文）\n  Serial.println(\"==========\");\n  Serial.println(\"server response payload:\"); \n  String line;\n  while(httpsClient.available()){        \n    line = httpsClient.readStringUntil('\\n');  //Read Line by Line\n    Serial.println(line); //Print response\n  }\n  Serial.println(\"==========\");\n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n \n// 获取网络时间，该时间信息用于证书认证\nvoid setClock() {\n  configTime(3 * 3600, 0, \"ntp.ntsc.ac.cn\",\"pool.ntp.org\", \"time.nist.gov\");\n  \n  // bool configTime(int timezone, int daylightOffset, char *server1, char *server2, char *server3, bool enable);\n  Serial.print(\"Waiting for NTP time sync: \");\n  time_t now = time(nullptr);\n  while (now < 8 * 3600 * 2) {\n    delay(500);\n    Serial.print(\".\");\n    now = time(nullptr);\n  }\n  Serial.println(\"\");\n  struct tm timeinfo;\n  gmtime_r(&now, &timeinfo);\n  Serial.print(\"Current time: \");\n  Serial.print(asctime(&timeinfo));\n}\n```\n\n\n\n##### connect – 连接服务器\n\n###### 说明\n\nconnect函数用于ESP8266开发板通过HTTPS协议连接网络服务器。\n\n###### 语法\n\n`httpsClient.connect(ip, port)`\n`httpsClient.connect(host, port)`\n注：请参考本页的示例程序部分获取更多应用说明信息。此函数在示例程序中被高亮标记以便您查阅。\n\n###### 参数\n\nip: 所要连接的服务器的IP地址。类型:IPAddress。\nhost：所要连接的服务器域名,可使用字符串类型。\nport:所要连接的服务器端口号,允许使用int类型。\n\n###### 返回值\n\n连接失败返回0，连接成功返回1。返回值数据类型是bool型。\n\n###### 示例程序\n\n**示例1：ESP8266实现HTTPS通讯（指纹认证）**\n\n以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。本程序使用了指纹认证方式。比起本页的“示例2：ESP8266实现HTTPS通讯（证书认证）”，示例1所采用的指纹认证不如证书认证安全性高。\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。\n\n![image-20230527142203319](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527142203319.png)\n\n此程序使用了语句**httpsClient.connect(host, httpsPort)**实现ESP8266与服务器连接。具体操作方法，请见以下示例程序的高亮部分。\n\n**注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。**\n\n```c\n/**********************************************************************\n程序名称/Program name     : connect_1\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的connect函数来控制ESP8266\n通过HTTPS协议连接服务器。\n \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。\n \n本程序使用了指纹认证方式。该方式没有证书认证方式安全。\n \n注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n并复制粘贴到程序中相应位置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n \n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"www.howsmyssl.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \n//注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\nconst char fingerprint[] PROGMEM = \"c7c1f454fb33ef22191163c50c12dc7d4842694a\";\n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  // 实现HTTPS通讯\n  httpsCom();\n}\n \nvoid loop(){}\n \nvoid httpsCom(){\n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n \n  Serial.println(host);\n \n  Serial.printf(\"Using fingerprint '%s'\\n\", fingerprint);\n  httpsClient.setFingerprint(fingerprint);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器\n  // 告知用户当前ESP8266已经成功接收服务器响应头信息。\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  // 通过串口监视器输出服务器响应体信息（服务器报文）\n  Serial.println(\"==========\");\n  Serial.println(\"server response payload:\"); \n  String line;\n  while(httpsClient.available()){        \n    line = httpsClient.readStringUntil('\\n');  //Read Line by Line\n    Serial.println(line); //Print response\n  }\n  Serial.println(\"==========\");\n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n```\n\n\n\n**示例2：ESP8266实现HTTPS通讯（证书认证）**\n\n本实例所实现的功能与示例1相同。唯一区别是本示例中在ESP8266与服务器的HTTPS通信中，使用证书认证而不是指纹认证。使用本示例中的证书认证可以提高HTTPS通讯安全性。\n\n如需了解本示例程序的操作方法和运行结果，请参考示例1中的相应内容。\n\n**注意：出于安全原因，CA会定期更新根证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。**\n\n```c\n/**********************************************************************\n程序名称/Program name     : connect_2\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的connect函数来控制ESP8266\n通过HTTPS协议连接服务器。\n \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。\n \n本程序使用了证书认证方式。该方式比指纹认证方式要更安全。\n \n注意：出于安全原因，CA会定期更新证书信息。因此本程序\n中的证书可能已经过期。请使用浏览器获取最新的网站根证书\n并复制粘贴到程序中相应位置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n \n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"www.howsmyssl.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  httpsCom(); // 实现https通讯\n}\n \nvoid loop() {}\n \n// 实现https通讯\nvoid httpsCom(){\n//注意：出于安全原因，CA会定期更新证书信息。因此本程序\n//中的证书可能已经过期。请使用浏览器获取最新的证书\n//http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/http-client-secure/certificate/\n  static const char digicert[] PROGMEM = R\"EOF( // 证书信息\n-----BEGIN CERTIFICATE-----\nMIIDSjCCAjKgAwIBAgIQRK+wgNajJ7qJMDmGLvhAazANBgkqhkiG9w0BAQUFADA/\nMSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMT\nDkRTVCBSb290IENBIFgzMB4XDTAwMDkzMDIxMTIxOVoXDTIxMDkzMDE0MDExNVow\nPzEkMCIGA1UEChMbRGlnaXRhbCBTaWduYXR1cmUgVHJ1c3QgQ28uMRcwFQYDVQQD\nEw5EU1QgUm9vdCBDQSBYMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB\nAN+v6ZdQCINXtMxiZfaQguzH0yxrMMpb7NnDfcdAwRgUi+DoM3ZJKuM/IUmTrE4O\nrz5Iy2Xu/NMhD2XSKtkyj4zl93ewEnu1lcCJo6m67XMuegwGMoOifooUMM0RoOEq\nOLl5CjH9UL2AZd+3UWODyOKIYepLYYHsUmu5ouJLGiifSKOeDNoJjj4XLh7dIN9b\nxiqKqy69cK3FCxolkHRyxXtqqzTWMIn/5WgTe1QLyNau7Fqckh49ZLOMxt+/yUFw\n7BZy1SbsOFU5Q9D8/RhcQPGX69Wam40dutolucbY38EVAjqr2m7xPi71XAicPNaD\naeQQmxkqtilX4+U9m5/wAl0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNV\nHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFMSnsaR7LHH62+FLkHX/xBVghYkQMA0GCSqG\nSIb3DQEBBQUAA4IBAQCjGiybFwBcqR7uKGY3Or+Dxz9LwwmglSBd49lZRNI+DT69\nikugdB/OEIKcdBodfpga3csTS7MgROSR6cz8faXbauX+5v3gTt23ADq1cEmv8uXr\nAvHRAosZy5Q6XkjEGB5YGV8eAlrwDPGxrancWYaLbumR9YbK+rlmM6pZW87ipxZz\nR8srzJmwN0jP41ZL9c8PDHIyh8bwRLtTcm1D9SZImlJnt1ir/md2cXjbDaJWFBM5\nJDGFoqgCWjBH4d1QB7wCCZAA62RjYJsWvIjJEubSfZGL+T0yjWW06XyxV3bqxbYo\nOb8VZRzI9neWagqNdwvYkQsEjgfbKbYK7p2CNTUQ\n-----END CERTIFICATE-----\n)EOF\";\n  \n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n  BearSSL::X509List cert(digicert);\n  \n  // 设置时间\n  setClock();\n  \n  Serial.println(\"Using certificate\");\n  httpsClient.setTrustAnchors(&cert);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器\n  // 告知用户当前ESP8266已经成功接收服务器响应头信息。\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  // 通过串口监视器输出服务器响应体信息（服务器报文）\n  Serial.println(\"==========\");\n  Serial.println(\"server response payload:\"); \n  String line;\n  while(httpsClient.available()){        \n    line = httpsClient.readStringUntil('\\n');  //Read Line by Line\n    Serial.println(line); //Print response\n  }\n  Serial.println(\"==========\");\n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n \n// 获取网络时间，该时间信息用于证书认证\nvoid setClock() {\n  configTime(3 * 3600, 0, \"ntp.ntsc.ac.cn\",\"pool.ntp.org\", \"time.nist.gov\");\n  \n  // bool configTime(int timezone, int daylightOffset, char *server1, char *server2, char *server3, bool enable);\n  Serial.print(\"Waiting for NTP time sync: \");\n  time_t now = time(nullptr);\n  while (now < 8 * 3600 * 2) {\n    delay(500);\n    Serial.print(\".\");\n    now = time(nullptr);\n  }\n  Serial.println(\"\");\n  struct tm timeinfo;\n  gmtime_r(&now, &timeinfo);\n  Serial.print(\"Current time: \");\n  Serial.print(asctime(&timeinfo));\n}\n```\n\n\n\n##### stop – 停止客户端\n\n###### 说明\n\nstop函数用于停止ESP8266连接TCP服务器。\n\n###### 语法\n\n`httpsClient.stop()`\n注：请参考本页的示例程序部分获取更多应用说明信息。此函数在示例程序中被高亮标记以便您查阅。\n\n###### 参数\n\n无\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n**示例1：ESP8266实现HTTPS通讯（指纹认证）**\n\n以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。本程序使用了指纹认证方式。比起本页的“示例2：ESP8266实现HTTPS通讯（证书认证）”，示例1所采用的指纹认证不如证书认证安全性高。\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。\n\n![image-20230527142930134](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527142930134.png)\n\n此程序使用了语句**httpsClient.stop()**实现ESP8266断开服务器连接。具体操作方法，请见以下示例程序的高亮部分。\n\n**注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。**\n\n```c\n/**********************************************************************\n项目名称/Project          : 零基础入门学用物联网\n程序名称/Program name     : ESP8266-WiFiClientSecure-Stop_1\n团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)\n作者/Author              : CYNO朔\n日期/Date（YYYYMMDD）     : 20200418\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的stop函数来控制ESP8266\n断开与服务器的连接。\n \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。\n \n本程序使用了指纹认证方式。该方式没有证书认证方式安全。\n \n注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n并复制粘贴到程序中相应位置。如需了解如何执行这一操作，请参考太极创客网站中\n“获取网站证书指纹”页面(网址见下):\nhttp://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/http-client-secure/certificate-fingerprint/\n-----------------------------------------------------------------------\n本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。\n该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：\nhttp://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n#include <ESP8266WebServer.h>\n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"www.howsmyssl.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \n//注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n//并复制粘贴到此处。如需了解如何执行这一操作，请参考太极创客网站中\n//“获取网站证书指纹”页面(网址见下):\n//http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/http-client-secure/certificate-fingerprint/\nconst char fingerprint[] PROGMEM = \"c7c1f454fb33ef22191163c50c12dc7d4842694a\";\n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  // 实现HTTPS通讯\n  httpsCom();\n}\n \nvoid loop(){}\n \nvoid httpsCom(){\n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n \n  Serial.println(host);\n \n  Serial.printf(\"Using fingerprint '%s'\\n\", fingerprint);\n  httpsClient.setFingerprint(fingerprint);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器\n  // 告知用户当前ESP8266已经成功接收服务器响应头信息。\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  // 通过串口监视器输出服务器响应体信息（服务器报文）\n  Serial.println(\"==========\");\n  Serial.println(\"server response payload:\"); \n  String line;\n  while(httpsClient.available()){        \n    line = httpsClient.readStringUntil('\\n');  //Read Line by Line\n    Serial.println(line); //Print response\n  }\n  Serial.println(\"==========\");\n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n```\n\n\n\n\n\n#### 认证类型\n\n##### setFingerprint – 设置校验指纹\n\n###### 说明\n\n在使用ESP8266实现HTTPS协议物联网通讯时，我们可以使用服务器证书指纹进行服务器身份认证。setFingerprint函数即是用于设置服务器证书指纹信息以便ESP8266在与服务器进行HTTPS协议物联网通讯时，进行服务器身份认证的。请注意，目前该函数仅支持SHA-1证书指纹。\n\n###### 语法\n\nhttps.setFingerprint(fingerprint)\n\n###### 参数\n\nfingerprint: 服务器证书指纹。可以使用const char*类型或者20个uint8_t元素的数组。\n\n###### 返回值\n\n成功设置指纹则返回true。否则返回false。\n\n###### 示例程序\n\n以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。\n\n![image-20230527145250946](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527145250946.png)\n\n此程序使用了语句 httpsClient.setFingerprint(fingerprint)来设置服务器证书指纹。具体操作方法，请见以下示例程序的高亮部分。\n\n**注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。**\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266-WiFiClientSecure-setFingerPrint\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的setFingerPrint函数来控制ESP8266\n验证服务器身份。\n \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。\n \n本程序使用了指纹认证方式。该方式没有证书认证方式安全。\n \n注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n并复制粘贴到程序中相应位置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n#include <ESP8266WebServer.h>\n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"www.howsmyssl.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \n//注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n//并复制粘贴到此处。\n//以下两行语句为两种不同方法建立fingerprint。他们的作用是相同的。\n//const char fingerprint[] PROGMEM = \"c7c1f454fb33ef22191163c50c12dc7d4842694a\";\nconst char *fingerprint = \"c7c1f454fb33ef22191163c50c12dc7d4842694a\";\n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  // 实现HTTPS通讯\n  httpsCom();\n}\n \nvoid loop(){}\n \nvoid httpsCom(){\n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n \n  Serial.println(host);\n \n  Serial.printf(\"Using fingerprint '%s'\\n\", fingerprint);\n  httpsClient.setFingerprint(fingerprint);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器\n  // 告知用户当前ESP8266已经成功接收服务器响应头信息。\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  // 通过串口监视器输出服务器响应体信息（服务器报文）\n  Serial.println(\"==========\");\n  Serial.println(\"server response payload:\"); \n  String line;\n  while(httpsClient.available()){        \n    line = httpsClient.readStringUntil('\\n');  //Read Line by Line\n    Serial.println(line); //Print response\n  }\n  Serial.println(\"==========\");\n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n```\n\n\n\n\n\n\n\n##### setTrustAnchors – 设置信任锚\n\n###### 说明\n\n在使用ESP8266实现HTTPS协议物联网通讯时，我们可以使用服务器根证书进行服务器身份认证。setTrustAnchors函数用于安装服务器根证书，以便ESP8266进行服务器身份认证。（根证书是CA认证中心给自己颁发的证书,是信任链的起始点。安装根证书意味着对这个证书信任。出于通讯安全考虑，请尽量安装使用知名权CA认证中心颁发的证书。）\n\n请注意：\n\n1. 目前该函数仅支持Base64编码X.509证书。\n2. 使用本函数前需要先建立X509List对象。并且将该对象作为setTrustAnchors的参数。\n   如需了解具体操作方法，请见本函数页面的示例程序部分。\n\n###### 语法\n\n`httpsClient.setTrustAnchors(cert)`\n\n###### 参数\n\ncert: X.509证书对象（类型：X509List* ）\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。\n\n![image-20230527145425429](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527145425429.png)\n\n在以下程序中，我们首先使用语句**X509List cert(digicert);**建立X509List对象。该对象将会作为参数应用于语句**httpsClient.setTrustAnchors(&cert);**来实现证书安装。具体操作方法，请见以下示例程序中的高亮部分。\n\n**注意：出于安全原因，CA会定期更新根证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。**\n\n\n\n```C\n/**********************************************************************\n程序名称/Program name     : ESP8266-WiFiClientSecure-setTrustAnchors\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的stop函数来控制ESP8266\n断开与服务器的连接。\n \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。\n \n本程序使用了证书认证方式。该方式比指纹认证方式要更安全。\n \n注意：出于安全原因，CA会定期更新证书信息。因此本程序\n中的证书可能已经过期。请使用浏览器获取最新的网站根证书\n并复制粘贴到程序中相应位置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n#include <ESP8266WebServer.h>\n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"www.howsmyssl.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  httpsCom(); // 实现https通讯\n}\n \nvoid loop() {}\n \n// 实现https通讯\nvoid httpsCom(){\n//注意：出于安全原因，CA会定期更新证书信息。因此本程序\n//中的证书可能已经过期。请使用浏览器获取最新的证书\n//并复制粘贴到此处。如需了解如何执行这一操作，请参考太极创客网站中\n//“获取网站证书”页面(网址见下):\n//http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/http-client-secure/certificate/\n  static const char digicert[] PROGMEM = R\"EOF( // 证书信息\n-----BEGIN CERTIFICATE-----\nMIIDSjCCAjKgAwIBAgIQRK+wgNajJ7qJMDmGLvhAazANBgkqhkiG9w0BAQUFADA/\nMSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMT\nDkRTVCBSb290IENBIFgzMB4XDTAwMDkzMDIxMTIxOVoXDTIxMDkzMDE0MDExNVow\nPzEkMCIGA1UEChMbRGlnaXRhbCBTaWduYXR1cmUgVHJ1c3QgQ28uMRcwFQYDVQQD\nEw5EU1QgUm9vdCBDQSBYMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB\nAN+v6ZdQCINXtMxiZfaQguzH0yxrMMpb7NnDfcdAwRgUi+DoM3ZJKuM/IUmTrE4O\nrz5Iy2Xu/NMhD2XSKtkyj4zl93ewEnu1lcCJo6m67XMuegwGMoOifooUMM0RoOEq\nOLl5CjH9UL2AZd+3UWODyOKIYepLYYHsUmu5ouJLGiifSKOeDNoJjj4XLh7dIN9b\nxiqKqy69cK3FCxolkHRyxXtqqzTWMIn/5WgTe1QLyNau7Fqckh49ZLOMxt+/yUFw\n7BZy1SbsOFU5Q9D8/RhcQPGX69Wam40dutolucbY38EVAjqr2m7xPi71XAicPNaD\naeQQmxkqtilX4+U9m5/wAl0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNV\nHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFMSnsaR7LHH62+FLkHX/xBVghYkQMA0GCSqG\nSIb3DQEBBQUAA4IBAQCjGiybFwBcqR7uKGY3Or+Dxz9LwwmglSBd49lZRNI+DT69\nikugdB/OEIKcdBodfpga3csTS7MgROSR6cz8faXbauX+5v3gTt23ADq1cEmv8uXr\nAvHRAosZy5Q6XkjEGB5YGV8eAlrwDPGxrancWYaLbumR9YbK+rlmM6pZW87ipxZz\nR8srzJmwN0jP41ZL9c8PDHIyh8bwRLtTcm1D9SZImlJnt1ir/md2cXjbDaJWFBM5\nJDGFoqgCWjBH4d1QB7wCCZAA62RjYJsWvIjJEubSfZGL+T0yjWW06XyxV3bqxbYo\nOb8VZRzI9neWagqNdwvYkQsEjgfbKbYK7p2CNTUQ\n-----END CERTIFICATE-----\n)EOF\";\n  \n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n  X509List cert(digicert);\n  \n  // 设置时间\n  setClock();\n  \n  Serial.println(\"Using certificate\");\n  httpsClient.setTrustAnchors(&cert);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器\n  // 告知用户当前ESP8266已经成功接收服务器响应头信息。\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  // 通过串口监视器输出服务器响应体信息（服务器报文）\n  Serial.println(\"==========\");\n  Serial.println(\"server response payload:\"); \n  String line;\n  while(httpsClient.available()){        \n    line = httpsClient.readStringUntil('\\n');  //Read Line by Line\n    Serial.println(line); //Print response\n  }\n  Serial.println(\"==========\");\n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n \n// 获取网络时间，该时间信息用于证书认证\nvoid setClock() {\n  configTime(3 * 3600, 0, \"ntp.ntsc.ac.cn\",\"pool.ntp.org\", \"time.nist.gov\");\n  \n  // bool configTime(int timezone, int daylightOffset, char *server1, char *server2, char *server3, bool enable);\n  Serial.print(\"Waiting for NTP time sync: \");\n  time_t now = time(nullptr);\n  while (now < 8 * 3600 * 2) {\n    delay(500);\n    Serial.print(\".\");\n    now = time(nullptr);\n  }\n  Serial.println(\"\");\n  struct tm timeinfo;\n  gmtime_r(&now, &timeinfo);\n  Serial.print(\"Current time: \");\n  Serial.print(asctime(&timeinfo));\n}\n```\n\n\n\n\n\n##### setX509Time – 设置时间以认证x.509数字证书\n\n###### 说明\n\nsetX509Time函数可用于设置ESP8266对服务器证书进行认证时，所使用的时间信息。\n\n###### 语法\n\nhttpsClient.setX509Time(timeInfo)\n\n###### 参数\n\ntimeInfo: 设置服务器证书认证所使用的时间信息（类型: time_t）\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。\n\n![image-20230527145542826](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527145542826.png)\n\n在以下程序中，我们首先使用语句**time_t timeSet = 1587218446;**建立time_t变量。该变量用于存储时间信息。接下来我们使用**httpsClient.setX509Time(timeSet)**对认证服务器证书所用的时间进行设置。具体操作方法，请见以下示例程序中的高亮部分。\n\n**注意：出于安全原因，CA会定期更新根证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。**\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266-WiFiClientSecure-setX509Time\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的setX509Time函数来设置服务器证书认证使用的\n时间。以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。\n \n本程序使用了证书认证方式。该方式比指纹认证方式要更安全。\n \n注意：出于安全原因，网站服务器会定期更新证书信息。因此本程序\n中的证书可能已经过期。请使用浏览器获取最新的服务器证书\n并复制粘贴到程序中相应位置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n#include <ESP8266WebServer.h>\n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"www.howsmyssl.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \n//建立WiFiClientSecure对象\nWiFiClientSecure httpsClient;   \n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  httpsCom(); // 实现https通讯\n}\n \nvoid loop() {}\n \n// 实现https通讯\nvoid httpsCom(){\n//注意：出于安全原因，网站服务器会定期更新证书信息。因此本程序\n//中的证书可能已经过期。请使用浏览器获取最新的服务器证书\n//并复制粘贴到此处。\n  static const char digicert[] PROGMEM = R\"EOF( // 证书信息\n-----BEGIN CERTIFICATE-----\nMIIDSjCCAjKgAwIBAgIQRK+wgNajJ7qJMDmGLvhAazANBgkqhkiG9w0BAQUFADA/\nMSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMT\nDkRTVCBSb290IENBIFgzMB4XDTAwMDkzMDIxMTIxOVoXDTIxMDkzMDE0MDExNVow\nPzEkMCIGA1UEChMbRGlnaXRhbCBTaWduYXR1cmUgVHJ1c3QgQ28uMRcwFQYDVQQD\nEw5EU1QgUm9vdCBDQSBYMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB\nAN+v6ZdQCINXtMxiZfaQguzH0yxrMMpb7NnDfcdAwRgUi+DoM3ZJKuM/IUmTrE4O\nrz5Iy2Xu/NMhD2XSKtkyj4zl93ewEnu1lcCJo6m67XMuegwGMoOifooUMM0RoOEq\nOLl5CjH9UL2AZd+3UWODyOKIYepLYYHsUmu5ouJLGiifSKOeDNoJjj4XLh7dIN9b\nxiqKqy69cK3FCxolkHRyxXtqqzTWMIn/5WgTe1QLyNau7Fqckh49ZLOMxt+/yUFw\n7BZy1SbsOFU5Q9D8/RhcQPGX69Wam40dutolucbY38EVAjqr2m7xPi71XAicPNaD\naeQQmxkqtilX4+U9m5/wAl0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNV\nHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFMSnsaR7LHH62+FLkHX/xBVghYkQMA0GCSqG\nSIb3DQEBBQUAA4IBAQCjGiybFwBcqR7uKGY3Or+Dxz9LwwmglSBd49lZRNI+DT69\nikugdB/OEIKcdBodfpga3csTS7MgROSR6cz8faXbauX+5v3gTt23ADq1cEmv8uXr\nAvHRAosZy5Q6XkjEGB5YGV8eAlrwDPGxrancWYaLbumR9YbK+rlmM6pZW87ipxZz\nR8srzJmwN0jP41ZL9c8PDHIyh8bwRLtTcm1D9SZImlJnt1ir/md2cXjbDaJWFBM5\nJDGFoqgCWjBH4d1QB7wCCZAA62RjYJsWvIjJEubSfZGL+T0yjWW06XyxV3bqxbYo\nOb8VZRzI9neWagqNdwvYkQsEjgfbKbYK7p2CNTUQ\n-----END CERTIFICATE-----\n)EOF\";\n  \n  X509List cert(digicert);\n  \n  // 设置时间\n  setClock();\n  \n  Serial.println(\"Using certificate\");\n  httpsClient.setTrustAnchors(&cert);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器\n  // 告知用户当前ESP8266已经成功接收服务器响应头信息。\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  // 通过串口监视器输出服务器响应体信息（服务器报文）\n  Serial.println(\"==========\");\n  Serial.println(\"server response payload:\"); \n  String line;\n  while(httpsClient.available()){        \n    line = httpsClient.readStringUntil('\\n');  //Read Line by Line\n    Serial.println(line); //Print response\n  }\n  Serial.println(\"==========\");\n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n \n// 设置时间信息用于证书认证\nvoid setClock() {\n  // 建立time_t变量用于存储时间信息\n  time_t timeSet = 1587218446;\n \n  // 对认证证书所用的时间进行设置\n  httpsClient.setX509Time(timeSet);\n  \n  // 通过串口监视器输出设置的时间信息以便我们查看\n  struct tm timeinfo;\n  gmtime_r(&timeSet, &timeinfo);\n  Serial.print(\"timeSet: \");\n  Serial.print(asctime(&timeinfo));\n}\n```\n\n\n\n##### setInsecure – 设置不进行身份校验\n\n###### 说明\n\n使用setInsecure将会让ESP8266不进行服务器身份认证，而直接与服务器进行通讯。**注意：此方法跳过了HTTPS协议中的安全加密措施，因此仅可用于测试使用，而不适合传输需要保密的信息。**\n\n###### 语法\n\nhttpsClient.setInsecure()\n\n###### 参数\n\n无\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯。\n\n由于在以下示例程序中使用了httpsClient.setInsecure()，ESP8266将不会进行任何服务器身份认证而直接与服务器进行通讯，所以此方法不适合传输需要保密的信息。\n\n```c\n/**********************************************************************\n程序名称/Program name     : WiFiClientSecure_setInsecure\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的setInsecure来控制ESP8266\n的HTTPS协议通讯。使用setInsecure将会让ESP8266不进行服务器身份认证，而直接\n与服务器进行通讯，这种方法非常不安全。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n#include <ESP8266WebServer.h>\n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"www.howsmyssl.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  // 实现HTTPS通讯\n  httpsCom();\n}\n \nvoid loop(){}\n \nvoid httpsCom(){\n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n \n  Serial.println(host);\n \n  Serial.println(\"Using Insecure\");\n  httpsClient.setInsecure();\n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"ESP8266 Connected to Server. Now Disconect...\");\n  }\n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n```\n\n\n\n\n\n\n\n##### allowSelfSignedCerts – 允许自签名证书\n\n###### 说明\n\n使用allowSelfSignedCerts将会允许ESP8266对使用自签名证书的服务器进行身份认证。\n\n服务器证书需要由权威证书颁发机构签名方可信赖。自签名证书不具安全效力，仅可用于测试使用。\n\n###### 语法\n\nhttpsClient.allowSelfSignedCerts()\n\n###### 参数\n\n无\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接WiFi并通过HTTPS协议与badssl.com网站服务器进行通讯。\n\n由于在以下示例程序中使用了httpsClient.allowSelfSignedCerts()，ESP8266对使用自签名证书的服务器进行身份认证，服务器证书需要由权威证书颁发机构签名方可信赖。自签名证书不具安全效力，仅可用于测试使用。所以此方法不适合传输需要保密的信息。\n\n```c\n/**********************************************************************\n程序名称/Program name     : WiFiClientSecure_allowSelfSignedCerts\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的allowSelfSignedCerts来控制ESP8266\n的HTTPS协议通讯。使用allowSelfSignedCerts将会让ESP8266允许使用自签名证书进行服务器认证。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h>\n \nconst char *ssid = \"taichimaker\";\nconst char *pass = \"12345678\";\n \n// 连接服务器\nvoid fetchURL(BearSSL::WiFiClientSecure *client, const char *host, const uint16_t port, const char *path) {\n  if (!path) {\n    path = \"/\";\n  }\n \n  Serial.printf(\"Trying: %s:443...\", host);\n  client->connect(host, port);\n  if (!client->connected()) {\n    Serial.printf(\"*** Can't connect. ***\\n-------\\n\");\n    return;\n  }\n  Serial.printf(\"Connected!\\n-------\\n\");\n  \n  // 向服务器发送请求\n  client->write(\"GET \");\n  client->write(path);\n  client->write(\" HTTP/1.0\\r\\nHost: \");\n  client->write(host);\n  client->write(\"\\r\\nUser-Agent: ESP8266\\r\\n\");\n  client->write(\"\\r\\n\");\n  uint32_t to = millis() + 5000;\n  if (client->connected()) {\n    do {\n      char tmp[32];\n      memset(tmp, 0, 32);\n      int rlen = client->read((uint8_t*)tmp, sizeof(tmp) - 1);\n      yield();\n      if (rlen < 0) {\n        break;\n      }\n      // 输出服务器响应状态信息\n      char *nl = strchr(tmp, '\\r');\n      if (nl) {\n        *nl = 0;\n        Serial.print(tmp);\n        break;\n      }\n      Serial.print(tmp);\n    } while (millis() < to);\n  }\n  client->stop();\n}\n \n// 通过允许自签名证书方式连接网站服务器\nvoid fetchSelfSigned() {\n  BearSSL::WiFiClientSecure client;\n  \n  // 现尝试不开启自签名认证连接服务器（服务器会拒绝连接）\n  Serial.printf(\"First, try and connect to a badssl.com self-signed website (will fail):\\n\");\n  \n  //设置允许自签名证书\n  fetchURL(&client, \"self-signed.badssl.com\", 443, \"/\");\n  \n  // 开启自签名认证连接服务器（可正常连接服务器）\n  Serial.printf(\"Now we'll enable self-signed certs (will pass)\\n\");\n  client.allowSelfSignedCerts();\n  fetchURL(&client, \"self-signed.badssl.com\", 443, \"/\");\n}\n \nvoid setup() {\n  Serial.begin(9600);\n  Serial.println();\n \n  // 连接WiFi\n  Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, pass);\n \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n \n  Serial.println(\"WiFi connected\");\n  Serial.println(\"IP address: \");\n  Serial.println(WiFi.localIP());\n \n  fetchSelfSigned(); \n}\n \nvoid loop() {}\n```\n\n\n\n\n\n\n\n##### setKnownKey – 设置服务器公钥\n\n###### 说明\n\n在使用ESP8266实现HTTPS协议物联网通讯时，我们可以使用服务器公钥进行服务器身份认证。setKnownKey函数用于安装服务器公钥，以便ESP8266进行服务器身份认证。（公钥是服务器认证的关键。请确保服务器公钥正确，否则您的物联网通讯可能受到安全威胁。）\n\n如需获取网站服务器公钥，可以先使用浏览器将服务器证书下载（注意这里下载的是服务器证书而不是根证书）。\n\n请注意：在使用本函数前需要先建立PublicKey对象。并且将该对象作为setKnownKey的参数。如需了解具体操作方法，请见本函数页面的示例程序部分。\n\n###### 语法\n\n`httpsClient.setKnownKey(key);`\n\n###### 参数\n\nkey: 公钥信息（类型：PublicKey*）\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应状态码以及响应头信息显示于串口监视器中。\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与必应网站服务器进行通讯。服务器响应状态码以及响应头信息显示于串口监视器中以便我们查阅。程序运行结果如下图所示。\n\n![image-20230527145946942](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527145946942.png)\n\n通过以上截屏，我们可以看到服务器响应状态码为200 OK。这一信息说明必应网站服务器已经成功地与ESP8266取得连接，另外服务器也已经成功的收到了ESP8266通过HTTPS协议发送的请求信息。\n\n在以下示例程序中，我们使用了语句`PublicKey key(pubkey)`建立了公钥对象，并且将该对象作为参数应用在 `httpsClient.setKnownKey(&key)`语句中。具体操作方法请见以下示例程序中高亮语句部分。\n\n**注：此程序中的公钥是服务器公钥，而不是CA公钥。如需获取该服务器公钥，可以先使用浏览器将服务器证书下载。假设此处下载的服务器证书名称为“bing.cer”，接下来可以使用OpenSSL工具软件通过以下指令从服务器证书中提取服务器公钥:\nopenssl x509 -pubkey -noout -in bing.cer。**\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266-WiFiClientSecure-setKnownKey_bing\n程序目的/Purpose          : \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。本程序使用了setKnownKey来利用服务器公钥实现服务器身份认证方式。\n注：此程序中的公钥是服务器公钥，而不是CA公钥。如需获取该公钥，可以先使用浏览器将服务器\n证书下载（假设此处下载的服务器证书名称为www-bing-com.pem）。然后使用openssl通过\n以下指令从服务器证书中提取服务器公钥:\nopenssl x509 -pubkey -noout -in www-bing-com.pem\n \n注意：出于安全原因，网站服务器会定期更新公钥信息。因此本程序\n中的公钥可能已经过期。请使用以上方法获取最新的服务器公钥\n并复制粘贴到程序中相应位置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n#include <ESP8266WebServer.h>\n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"cn.bing.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  httpsCom(); // 实现https通讯\n}\n \nvoid loop() {}\n \n// 实现https通讯\nvoid httpsCom(){\n \n \n// 使用openssl获取网站服务器公钥（具体方法详见程序头部说明信息）\n// 并将其复制粘贴到以下数组中。\nstatic const char pubkey[] PROGMEM = R\"KEY(\n-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4SJT29Ij+8UZlEnCuN0C\nOwov5b3zLploURQB3Bc4yAx7O+LKtAfs3vB1uT0ei1kXv3d8keXQvO4ELNKlxorc\n7D/b1iXKcCldu97ZZ1ohH4GcebbzQhXRzqqGKBy92vM3nfyZBkxHl7pBhF9E3gYA\no3FU4+akcSYY5VsbNwHAf6uH+L4t0BvNE20lNlDtJZL4b37O9wtY6ou2bKYmv2LD\nKnEOl/gDwGfuILio0K+at9rc49hRrSTumZmbjVfVsG99vPdVIcGdw9j6yHJwjZSE\nNfxWoeopu1XOu6jtsf/vq+4Duz7UfG8ghZxbjVFUMYUiJApI+hbz8XGHn6JNMCdF\nUQIDAQAB\n-----END PUBLIC KEY-----\n)KEY\";\n \n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n  PublicKey key(pubkey);\n    \n \n \n  \n  Serial.println(\"Using public key\");\n  httpsClient.setKnownKey(&key);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。通过串口监视器输出服务器状态码和响应头信息\n  // 从而确定ESP8266已经成功连接服务器\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    Serial.println(line);\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  Serial.println(\"Now disconect from the server...\"); \n \n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n```\n\n\n\n\n\n\n\n##### setCiphers – 设置加密方式(自定义)\n\n###### 说明\n\nsetCiphers可用来设置ESP8266的HTTPS通讯加密方式。与使用[setTrustAnchors](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/http-client-secure/settrustanchors/)函数来对服务器根证书认证比较，setCiphers安全性能要更低。但是此使用setCiphers可以降低ESP8266的运算工作。因此ESP8266的能耗也会相应降低。如果您的项目使用电池为ESP8266供电且需要降低ESP8266能耗，可以考虑采用此方法实现ESP8266的HTTPS通讯。如需了解更多加密方式，请参考ESP8266库源文件中[WiFiClientSecureBearSSL.cpp](https://github.com/esp8266/Arduino/blob/master/libraries/ESP8266WiFi/src/WiFiClientSecureBearSSL.cpp)中相关信息。\n\n###### 语法\n\nhttpsClient.setCiphers(cipherList)\n\n###### 参数\n\ncipherList: 加密方式\n\n###### 返回值\n\n成功设置加密方式，则返回true。否则返回false。返回值为布尔型。\n\n###### 示例程序\n\n以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应状态码以及响应头信息显示于串口监视器中。\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与必应网站服务器进行通讯。服务器响应状态码以及响应头信息显示于串口监视器中以便我们查阅。\n\n在以下示例程序中，我们在使用setCiphers前需要首先使用`httpsClient.setInsecure()`来设置ESP8266。接下来使用 httpsClient.setCiphers(myCustomList)来设置具体加密方式。具体操作方法，请见以下程序中高亮语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266-WiFiClientSecure-setCiphers\n程序目的/Purpose          : \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。本程序使用了setCiphers来设置通讯加密方式。此方法与使用\n服务器根证书认证方法比较，安全性能要更低。但是此方法可以降低ESP8266的运算工作。\n因此ESP8266的能耗也会相应降低。如果您的项目使用电池为ESP8266供电，且需要降低\nESP8266能耗，可以考虑采用此方法实现ESP8266的HTTPS通讯。如需了解更多加密方式，\n请参考ESP8266库源文件中WiFiClientSecureBearSSL.cpp中相关信息。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n#include <ESP8266WebServer.h>\n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"cn.bing.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  httpsCom(); // 实现https通讯\n}\n \nvoid loop() {}\n \n// 实现https通讯\nvoid httpsCom(){\n \n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n   \n  // 设置时间\n  setClock();\n  \n  Serial.println(\"set ciphers...\");\n  // 添加加密方式（如需了解更多加密方式，请参考ESP8266库源文件中WiFiClientSecureBearSSL.cpp中相关信息）\n  std::vector<uint16_t> myCustomList = { BR_TLS_RSA_WITH_AES_256_CBC_SHA256, BR_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, BR_TLS_RSA_WITH_3DES_EDE_CBC_SHA };\n  \n  // 使用setCiphers前需要首先使用setInsecure来设置ESP8266\n  httpsClient.setInsecure();\n \n  // 接下来使用setCiphers来设置具体加密方式\n  httpsClient.setCiphers(myCustomList);\n  \n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。通过串口监视器输出服务器状态码和响应头信息\n  // 从而确定ESP8266已经成功连接服务器\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    Serial.println(line);\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  Serial.println(\"Now disconect from the server...\"); \n \n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n \n// 获取网络时间，该时间信息用于证书认证\nvoid setClock() {\n  configTime(3 * 3600, 0, \"ntp.ntsc.ac.cn\",\"pool.ntp.org\", \"time.nist.gov\");\n  \n  // bool configTime(int timezone, int daylightOffset, char *server1, char *server2, char *server3, bool enable);\n  Serial.print(\"Waiting for NTP time sync: \");\n  time_t now = time(nullptr);\n  while (now < 8 * 3600 * 2) {\n    delay(500);\n    Serial.print(\".\");\n    now = time(nullptr);\n  }\n  Serial.println(\"\");\n  struct tm timeinfo;\n  gmtime_r(&now, &timeinfo);\n  Serial.print(\"Current time: \");\n  Serial.print(asctime(&timeinfo));\n}\n```\n\n\n\n\n\n##### setCiphersLessSecure– 设置加密方式(低级别)\n\n###### 说明\n\nsetCiphersLessSecure可用来设置ESP8266的HTTPS通讯加密方式。与使用[setTrustAnchors](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/http-client-secure/settrustanchors/)函数来对服务器根证书认证比较，setCiphersLessSecure安全性能要更低。但是使用setCiphersLessSecure可以降低ESP8266的运算工作。因此ESP8266的能耗也会相应降低。如果您的项目使用电池为ESP8266供电且需要降低ESP8266能耗，可以考虑采用此方法实现ESP8266的HTTPS通讯。\n\n语法\n\nhttpsClient.setCiphersLessSecure()\n\n###### 参数\n\n无\n\n###### 返回值\n\n成功设置加密方式，则返回true。否则返回false。返回值为布尔型。\n\n###### 示例程序\n\n以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应状态码以及响应头信息显示于串口监视器中。\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与必应网站服务器进行通讯。服务器响应状态码以及响应头信息显示于串口监视器中以便我们查阅。\n\n在以下示例程序中，我们在使用setCiphersLessSecure前需要首先使用`httpsClient.setInsecure()`来设置ESP8266。接下来使用 httpsClient.setCiphersLessSecure()来设置具体加密方式。具体操作方法，请见以下程序中高亮语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266-WiFiClientSecure-setCiphersLessSecure\n程序目的/Purpose          : \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。本程序使用了setCiphersLessSecure来设置通讯加密方式。此方法与使用\n服务器根证书认证方法比较，安全性能要更低。但是此方法可以降低ESP8266的运算工作。\n因此ESP8266的能耗也会相应降低。如果您的项目使用电池为ESP8266供电，且需要降低\nESP8266能耗，可以考虑采用此方法实现ESP8266的HTTPS通讯。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n#include <ESP8266WebServer.h>\n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"cn.bing.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  httpsCom(); // 实现https通讯\n}\n \nvoid loop() {}\n \n// 实现https通讯\nvoid httpsCom(){\n \n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n   \n  // 设置时间\n  setClock();\n  \n  Serial.println(\"set less secure ciphers ...\");\n \n  // 使用setCiphersLessSecure前需要首先使用setInsecure来设置ESP8266\n  httpsClient.setInsecure();\n \n  // 接下来使用setCiphersLessSecure来设置具体加密方式\n  httpsClient.setCiphersLessSecure();\n  \n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。通过串口监视器输出服务器状态码和响应头信息\n  // 从而确定ESP8266已经成功连接服务器\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    Serial.println(line);\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  Serial.println(\"Now disconect from the server...\"); \n \n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n \n// 获取网络时间，该时间信息用于证书认证\nvoid setClock() {\n  configTime(3 * 3600, 0, \"ntp.ntsc.ac.cn\",\"pool.ntp.org\", \"time.nist.gov\");\n  \n  // bool configTime(int timezone, int daylightOffset, char *server1, char *server2, char *server3, bool enable);\n  Serial.print(\"Waiting for NTP time sync: \");\n  time_t now = time(nullptr);\n  while (now < 8 * 3600 * 2) {\n    delay(500);\n    Serial.print(\".\");\n    now = time(nullptr);\n  }\n  Serial.println(\"\");\n  struct tm timeinfo;\n  gmtime_r(&now, &timeinfo);\n  Serial.print(\"Current time: \");\n  Serial.print(asctime(&timeinfo));\n}\n```\n\n\n\n\n\n\n\n##### setClientRSACert – 设置客户端RSA证书\n\n###### 说明\n\nsetClientRSACert函数可以用来设置客户端私钥以及客户端证书。\n\n注意：使用ESP8266通过HTTPS协议获取网站信息时，网站服务器无需ESP8266提供证书信息即可实现通信。但是在一些MQTT协议物联网应用中，服务器会需要ESP8266提供客户端证书以验证身份。\n\n###### 语法\n\nhttpsClient.setClientRSACert(clientCert, clientPrivateKey)\n\n###### 参数\n\nclientCert：客户端证书\nclientPrivateKey：客户端私钥\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应状态码以及响应头信息显示于串口监视器中。\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与必应网站服务器进行通讯。服务器响应状态码以及响应头信息显示于串口监视器中以便我们查阅。\n\n在以下示例程序中，我们在使用setClientRSACert前需要首先使用`X509List clientCert(digicert)`来设置ESP8266的客户端证书。接下来使用 `PrivateKey clientPrivateKey(key)`来设置客户端私钥。具体操作方法，请见以下程序中高亮语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266-WiFiClientSecure-setClientRSACert\n程序目的/Purpose          : \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。程序使用WiFiClientSecure库中的setClientRSACert函数来设置客户端\n私钥以及客户端证书。\n \n对于使用HTTPS协议访问网站信息，网站服务器无需客户端提供证书信息。此程序仅仅是为了向您演示\n如何来为ESP8266设置客户端私钥以及客户端证书。\n \n注意：此程序使用网站服务器证书指纹作为服务器身份认证。\n出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n并复制粘贴到程序中相应位置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n#include <ESP8266WebServer.h>\n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"cn.bing.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \n//注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n//并复制粘贴到此处。\n//以下两行语句为两种不同类型的fingerprint建立。\n//const char fingerprint[] PROGMEM = \"62914576dc0afac83c4804bcc2c1b700a61139fe\";\nconst char *fingerprint = \"62914576dc0afac83c4804bcc2c1b700a61139fe\";\n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  // 实现HTTPS通讯\n  httpsCom();\n}\n \nvoid loop(){}\n \nvoid httpsCom(){\n  // 客户端证书信息\n  static const char digicert[] PROGMEM = R\"EOF( \n-----BEGIN CERTIFICATE-----\nMIIDiDCCAnACAQEwDQYJKoZIhvcNAQELBQAwgYkxCzAJBgNVBAYTAkNOMRAwDgYD\nVQQIDAdCZWlqaW5nMRAwDgYDVQQHDAdCZWlqaW5nMRUwEwYDVQQKDAxUYWljaGkt\nTWFrZXIxDDAKBgNVBAsMA0lPVDENMAsGA1UEAwwEQ1lOTzEiMCAGCSqGSIb3DQEJ\nARYTdGFpY2hpbWFrZXJAMTYzLmNvbTAeFw0yMDA0MTkwNzU4NDlaFw0yMzAxMTMw\nNzU4NDlaMIGJMQswCQYDVQQGEwJDTjEQMA4GA1UECAwHQmVpamluZzEQMA4GA1UE\nBwwHQmVpamluZzEVMBMGA1UECgwMVGFpY2hpLU1ha2VyMQwwCgYDVQQLDANJT1Qx\nDTALBgNVBAMMBENZTk8xIjAgBgkqhkiG9w0BCQEWE3RhaWNoaW1ha2VyQDE2My5j\nb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDC+x7sS+0izluDQ6XJ\nmLv9Kxh9MYG9zRrgigsTQwyv085hDyDGxaKG58ZVZfa7X+srSQ5IssaKoJqK91qT\nau28rcYQihBFYkGngJc1gFOyMJujFU0VDPxmSuSBUWCPcXbGg0Z4sy/z1vt2pe19\nAuqyKVJCDHMCRkMeX/nWbYWHqJTPoAnOZ1CW91urCc2Kf1/eq6L5aFsgjbuuY119\n3KP7VdumeHhbsSr6JrDwW/URtun3UjB/LjdbjHoq5bMuY94vgCGO0ykSds25jkz5\nrz+32obSNAreNcR9Mz9IPX6mYEP1Yj6Fv7V6zoJYNxyNiO5UYRxC5w0g9ihhaqmQ\nVLofAgMBAAEwDQYJKoZIhvcNAQELBQADggEBAGqOfdH56LZt7WO18ymgcMRZZakH\n629BYu/fsX+t/mgdQ7coPQneGfHD7y2PDB76nIp+wqjlI0mAoVaGmCRny5wWOKpZ\nbbvW6Kwn42dVab3M+zerM4ExzP3jeG76tsHbXZSHz1fUxASNONjcNjyh/s0HZcQw\nTgnGkFhpmMKXDkE4kU5T4itxn5j1mkVZjYOwL3d+IS8o3vmzgLCvwa4/BSK70xF3\nidoY6tl9bdkzU8nH4HKU8q5vjr3dh2HqWg6H7wOLx840BipKnvj4kago6AJILQ5v\ngo3D93eEiK3NRq/jNXJET+7/NC8xPNeKtraxlYc1o+lbQl/AqsJTBojWifs=\n-----END CERTIFICATE-----\n)EOF\";\n \n  // 客户端私钥信息\n  static const char key[] PROGMEM = R\"KEY(\n-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4SJT29Ij+8UZlEnCuN0C\nOwov5b3zLploURQB3Bc4yAx7O+LKtAfs3vB1uT0ei1kXv3d8keXQvO4ELNKlxorc\n7D/b1iXKcCldu97ZZ1ohH4GcebbzQhXRzqqGKBy92vM3nfyZBkxHl7pBhF9E3gYA\no3FU4+akcSYY5VsbNwHAf6uH+L4t0BvNE20lNlDtJZL4b37O9wtY6ou2bKYmv2LD\nKnEOl/gDwGfuILio0K+at9rc49hRrSTumZmbjVfVsG99vPdVIcGdw9j6yHJwjZSE\nNfxWoeopu1XOu6jtsf/vq+4Duz7UfG8ghZxbjVFUMYUiJApI+hbz8XGHn6JNMCdF\nUQIDAQAB\n-----END PUBLIC KEY-----\n)KEY\";\n  \n  WiFiClientSecure httpsClient;     //建立WiFiClientSecure对象\n  X509List clientCert(digicert);    //建立X509List对象用于处理客户端证书\n  PrivateKey clientPrivateKey(key); //建立PrivateKey对象用于处理客户端私钥\n \n  // 设置客户端私钥以及客户端证书\n  httpsClient.setClientRSACert(&clientCert, &clientPrivateKey);\n  \n  Serial.println(host);\n  \n  Serial.printf(\"Using fingerprint '%s'\\n\", fingerprint);\n  httpsClient.setFingerprint(fingerprint);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n  \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。通过串口监视器输出服务器状态码和响应头信息\n  // 从而确定ESP8266已经成功连接服务器\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    Serial.println(line);\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  Serial.println(\"Now disconect from the server...\"); \n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n```\n\n\n\n\n\n\n\n##### setSession – 会话控制\n\n###### 说明\n\nESP8266通过HTTPS协议实现物联网通讯时，我们可以使用setSession函数将会话保存在设备内存中以便在有需要的时候恢复会话。\n\n###### 语法\n\nhttpsClient.setSession(session)\n\n###### 参数\n\nSession对象\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与必应网站服务器进行通讯。服务器响应状态码以及响应头信息显示于串口监视器中以便我们查阅。\n\n**注意：出于安全原因，CA会定期更新根证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。**\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266-WiFiClientSecure-setSessions\n程序目的/Purpose          : \n本程序改编自ESP8266库中BearSSL_Sessions示例程序。以下是原示例程序注释信息\nExample of using SSL sessions to speed up SSL connection initiation\n \nSeptember 2018 by Earle F. Philhower, III\nReleased to the public domain\n \n本程序将使用setSessions函数将HTTPS对话保存在ESP8266的内存中，以便恢复使用。\n \n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <time.h>\n \nconst char *ssid = \"taichimaker\";\nconst char *pass = \"12345678\";\n \nconst char *   host = \"cn.bing.com\";\nconst uint16_t port = 443;\nconst char *   path = \"/\";\n \nvoid setup() {\n  Serial.begin(9600);\n  Serial.println();\n  Serial.println();\n \n  Serial.printf(\"Connecting to %s\\n\", ssid);\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, pass);\n \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\\nConnected\");\n  Serial.println(\"IP Address: \");\n  Serial.println(WiFi.localIP());\n \n  // 设置时间\n  configTime(3 * 3600, 0, \"ntp.ntsc.ac.cn\",\"pool.ntp.org\", \"time.nist.gov\");\n \n  Serial.print(\"Waiting for NTP time sync: \");\n  time_t now = time(nullptr);\n  while (now < 8 * 3600 * 2) {\n    delay(500);\n    Serial.print(\".\");\n    now = time(nullptr);\n  }\n  Serial.println(\"\");\n  struct tm timeinfo;\n  gmtime_r(&now, &timeinfo);\n  Serial.print(\"Current time: \");\n  Serial.print(asctime(&timeinfo));\n}\n \n// 连接网站服务器，通过串口监视器输出服务器响应状态码\nvoid fetchURL(BearSSL::WiFiClientSecure *client, const char *host, const uint16_t port, const char *path) {\n  if (!path) {\n    path = \"/\";\n  }\n \n  Serial.printf(\"Trying: %s:443...\", host);\n  client->connect(host, port);\n  if (!client->connected()) {\n    Serial.printf(\"*** Can't connect. ***\\n-------\\n\");\n    return;\n  }\n  Serial.printf(\"Connected!\\n-------\\n\");\n  client->write(\"GET \");\n  client->write(path);\n  client->write(\" HTTP/1.0\\r\\nHost: \");\n  client->write(host);\n  client->write(\"\\r\\nUser-Agent: ESP8266\\r\\n\");\n  client->write(\"\\r\\n\");\n  uint32_t to = millis() + 5000;\n  if (client->connected()) {\n    do {\n      char tmp[32];\n      memset(tmp, 0, 32);\n      int rlen = client->read((uint8_t*)tmp, sizeof(tmp) - 1);\n      yield();\n      if (rlen < 0) {\n        break;\n      }\n      \n      char *nl = strchr(tmp, '\\r');\n      if (nl) {\n        *nl = 0;\n        Serial.print(tmp);\n        break;\n      }\n      Serial.print(tmp);\n    } while (millis() < to);\n  }\n  client->stop();\n  Serial.printf(\"\\n-------\\n\\n\");\n}\n \n \nvoid loop() {\n  static const char digicert[] PROGMEM = R\"EOF(\n-----BEGIN CERTIFICATE-----\nMIIDdzCCAl+gAwIBAgIEAgAAuTANBgkqhkiG9w0BAQUFADBaMQswCQYDVQQGEwJJ\nRTESMBAGA1UEChMJQmFsdGltb3JlMRMwEQYDVQQLEwpDeWJlclRydXN0MSIwIAYD\nVQQDExlCYWx0aW1vcmUgQ3liZXJUcnVzdCBSb290MB4XDTAwMDUxMjE4NDYwMFoX\nDTI1MDUxMjIzNTkwMFowWjELMAkGA1UEBhMCSUUxEjAQBgNVBAoTCUJhbHRpbW9y\nZTETMBEGA1UECxMKQ3liZXJUcnVzdDEiMCAGA1UEAxMZQmFsdGltb3JlIEN5YmVy\nVHJ1c3QgUm9vdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKMEuyKr\nmD1X6CZymrV51Cni4eiVgLGw41uOKymaZN+hXe2wCQVt2yguzmKiYv60iNoS6zjr\nIZ3AQSsBUnuId9Mcj8e6uYi1agnnc+gRQKfRzMpijS3ljwumUNKoUMMo6vWrJYeK\nmpYcqWe4PwzV9/lSEy/CG9VwcPCPwBLKBsua4dnKM3p31vjsufFoREJIE9LAwqSu\nXmD+tqYF/LTdB1kC1FkYmGP1pWPgkAx9XbIGevOF6uvUA65ehD5f/xXtabz5OTZy\ndc93Uk3zyZAsuT3lySNTPx8kmCFcB5kpvcY67Oduhjprl3RjM71oGDHweI12v/ye\njl0qhqdNkNwnGjkCAwEAAaNFMEMwHQYDVR0OBBYEFOWdWTCCR1jMrPoIVDaGezq1\nBE3wMBIGA1UdEwEB/wQIMAYBAf8CAQMwDgYDVR0PAQH/BAQDAgEGMA0GCSqGSIb3\nDQEBBQUAA4IBAQCFDF2O5G9RaEIFoN27TyclhAO992T9Ldcw46QQF+vaKSm2eT92\n9hkTI7gQCvlYpNRhcL0EYWoSihfVCr3FvDB81ukMJY2GQE/szKN+OMY3EU/t3Wgx\njkzSswF07r51XgdIGn9w/xZchMB5hbgF/X++ZRGjD8ACtPhSNzkE1akxehi/oCr0\nEpn3o0WC4zxe9Z2etciefC7IpJ5OCBRLbf1wbWsaY71k5h+3zvDyny67G7fyUIhz\nksLi4xaNmjICq44Y3ekQEe5+NauQrz4wlHrQMz2nZQ/1/I6eYs9HRCwBXbsdtTLS\nR9I4LtD+gdwyah617jzV/OeBHRnDJELqYzmp\n-----END CERTIFICATE-----\n)EOF\";\n  uint32_t start, finish;\n  BearSSL::WiFiClientSecure client;\n  BearSSL::X509List cert(digicert);\n \n  Serial.printf(\"Connecting without sessions...\");\n  start = millis();\n  client.setTrustAnchors(&cert);\n  fetchURL(&client, host, port, path);\n  finish = millis();\n  Serial.printf(\"Total time: %dms\\n\", finish - start);\n  \n  BearSSL::Session session;\n  client.setSession(&session);\n  Serial.printf(\"Connecting with an unitialized session...\");\n  start = millis();\n  client.setTrustAnchors(&cert);\n  fetchURL(&client, host, port, path);\n  finish = millis();\n  Serial.printf(\"Total time: %dms\\n\", finish - start);\n \n  Serial.printf(\"Connecting with the just initialized session...\");\n  start = millis();\n  client.setTrustAnchors(&cert);\n  fetchURL(&client, host, port, path);\n  finish = millis();\n  Serial.printf(\"Total time: %dms\\n\", finish - start);\n \n  Serial.printf(\"Connecting again with the initialized session...\");\n  start = millis();\n  client.setTrustAnchors(&cert);\n  fetchURL(&client, host, port, path);\n  finish = millis();\n  Serial.printf(\"Total time: %dms\\n\", finish - start);\n \n  delay(10000);\n}\n```\n\n\n\n\n\n\n\n\n\n##### setBufferSizes – 设置缓存大小\n\n###### 说明\n\nsetBufferSizes用于设置ESP8266在进行HTTPS协议的物联网通讯时，接收和发送缓存大小。\n\n###### 语法\n\nhttpsClient.setBufferSizes(recv, xmit);\n\n###### 参数\n\nrecv：接收缓存大小，该数值大小必须介于512和16384之间（单位字节，类型：int）\nxmit：发送缓存大小，该数值大小必须介于512和16384之间（单位字节，类型：int）\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n成功设置加密方式，则返回true。否则返回false。返回值为布尔型。\n\n###### 示例程序\n\n以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应状态码以及响应头信息显示于串口监视器中。\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与必应网站服务器进行通讯。服务器响应状态码以及响应头信息显示于串口监视器中以便我们查阅。\n\n在以下示例程序中，我们在使用setBufferSizes来设置接收和发送缓存大小。具体操作方法，请见以下程序中高亮语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266-WiFiClientSecure-setBufferSizes\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的stop函数来控制ESP8266\n断开与服务器的连接。\n \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。程序使用了setBufferSizes函数来设置ESP8266的收发信息缓存大小。\n \n注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n并复制粘贴到程序中相应位置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n#include <ESP8266WebServer.h>\n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"cn.bing.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \n//注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n//并复制粘贴到此处。\n//以下两行语句为两种不同类型的fingerprint建立。\n//const char fingerprint[] PROGMEM = \"62914576dc0afac83c4804bcc2c1b700a61139fe\";\nconst char *fingerprint = \"62914576dc0afac83c4804bcc2c1b700a61139fe\";\n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  // 实现HTTPS通讯\n  httpsCom();\n}\n \nvoid loop(){}\n \nvoid httpsCom(){\n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n  \n  Serial.println(host);\n  httpsClient.setBufferSizes(16000, 512); \n  \n  Serial.printf(\"Using fingerprint '%s'\\n\", fingerprint);\n  httpsClient.setFingerprint(fingerprint);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n  \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。通过串口监视器输出服务器状态码和响应头信息\n  // 从而确定ESP8266已经成功连接服务器\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    Serial.println(line);\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  Serial.println(\"Now disconect from the server...\"); \n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n```\n\n\n\n\n\n\n\n##### setCertStore – 设置证书储存\n\n###### 说明\n\nsetCertStore函数用于为ESP8266设置CertStore（证书集）。\n\n如果您知道ESP8266要连接哪些服务器，那么您就不需要CertStore。但是，如果您不知道ESP8266将要连接并验证哪些服务器身份， CertStore可以让您从几十个甚至上百个存储在SPIFFS或SD中的证书里选择证书从而进行服务器身份验证。这一过程很像是浏览器在验证网站服务器身份时所使用的方法。\n\n###### 语法\n\nhttpsClient.setCertStore(certStore)\n\n###### 参数\n\ncertStore：证书集对象\n\n###### 返回值\n\n无\n\n###### 示例程序\n\n以下示例程序\n\n在运行程序之前，请先下载[certs-from-mozilla.py](http://www.taichi-maker.com/wp-content/uploads/2020/04/certs-from-mozilla.zip)。然后使用certs-from-mozilla.py下载证书集，接下来请将生成的.AR文件上传到SPIFFS或SD。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266-WiFiClientSecure-setCertStore\n程序目的/Purpose          : \n本程序是ESP8266库中的BearSSL_CertStore示例程序。仅对程序注释信息做了翻译。\n以下是原程序头注释翻译。\n \n如果您知道ESP8266要连接哪些服务器，那么您就不需要CertStore。但是，如果您不知\n道ESP8266将要连接并验证哪些服务器身份， CertStore可以让您从几十个甚至上百个\n存储在SPIFFS或SD中的证书里选择证书从而进行服务器身份验证。这一过程很像是浏览器\n在验证网站服务器身份时所使用的方法。\n \n在运行程序之前，必须使用certs-from-mozilla.py下载证书集然后将生成的.AR文件\n上传到SPIFFS或SD。您不需要生成“ .IDX”文件，它是CertStore对象生成时自动生成\n并且由ESP8266创建并写入SD或SPIFFS。certs-from-mozilla.py可通过以下链接下载：\nhttp://www.taichi-maker.com/wp-content/uploads/2020/04/certs-from-mozilla.zip\n \ncerts-from-mozilla.py可以从互联网获取Mozilla.org的证书集。但是请不要以此\n为认可或要求：用户（您）可以自行决定将要用作信任基础的证书。\n2018年3月 作者：Earle F. Philhower, III\nReleased to the public domain\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <CertStoreBearSSL.h>\n#include <time.h>\n#include <FS.h>\n \n#ifndef STASSID\n#define STASSID \"your-ssid\"\n#define STAPSK  \"your-password\"\n#endif\n \nconst char *ssid = STASSID;\nconst char *pass = STAPSK;\n \n// 建立CertStore对象。\nBearSSL::CertStore certStore;\n \n// 通过互联网获取时间信息，该信息用于x.509证书验证\nvoid setClock() {\n  configTime(3 * 3600, 0, \"pool.ntp.org\", \"time.nist.gov\");\n \n  Serial.print(\"Waiting for NTP time sync: \");\n  time_t now = time(nullptr);\n  while (now < 8 * 3600 * 2) {\n    delay(500);\n    Serial.print(\".\");\n    now = time(nullptr);\n  }\n  Serial.println(\"\");\n  struct tm timeinfo;\n  gmtime_r(&now, &timeinfo);\n  Serial.print(\"Current time: \");\n  Serial.print(asctime(&timeinfo));\n}\n \n// 连接服务器\nvoid fetchURL(BearSSL::WiFiClientSecure *client, const char *host, const uint16_t port, const char *path) {\n  if (!path) {\n    path = \"/\";\n  }\n \n  Serial.printf(\"Trying: %s:443...\", host);\n  client->connect(host, port);\n  if (!client->connected()) {\n    Serial.printf(\"*** Can't connect. ***\\n-------\\n\");\n    return;\n  }\n  Serial.printf(\"Connected!\\n-------\\n\");\n  client->write(\"GET \");\n  client->write(path);\n  client->write(\" HTTP/1.0\\r\\nHost: \");\n  client->write(host);\n  client->write(\"\\r\\nUser-Agent: ESP8266\\r\\n\");\n  client->write(\"\\r\\n\");\n  uint32_t to = millis() + 5000;\n  if (client->connected()) {\n    do {\n      char tmp[32];\n      memset(tmp, 0, 32);\n      int rlen = client->read((uint8_t*)tmp, sizeof(tmp) - 1);\n      yield();\n      if (rlen < 0) {\n        break;\n      }\n      // 仅仅输出服务器响应状态码信息\n      char *nl = strchr(tmp, '\\r');\n      if (nl) {\n        *nl = 0;\n        Serial.print(tmp);\n        break;\n      }\n      Serial.print(tmp);\n    } while (millis() < to);\n  }\n  client->stop();\n  Serial.printf(\"\\n-------\\n\");\n}\n \nvoid setup() {\n  Serial.begin(115200);\n  Serial.println();\n  Serial.println();\n \n  SPIFFS.begin();\n  // 如果使用 SD 卡或者LittleFS库, 请使用::begin \n \n  // 连接WiFi\n  Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, pass);\n \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n \n  Serial.println(\"WiFi connected\");\n  Serial.println(\"IP address: \");\n  Serial.println(WiFi.localIP());\n \n  setClock(); // X.509 认证用对时\n \n  int numCerts = certStore.initCertStore(SPIFFS, PSTR(\"/certs.idx\"), PSTR(\"/certs.ar\"));\n  Serial.printf(\"Number of CA certs read: %d\\n\", numCerts);\n  if (numCerts == 0) {\n    Serial.printf(\"No certs found. Did you run certs-from-mozilla.py and upload the SPIFFS directory before running?\\n\");\n    return; // Can't connect to anything w/o certs!\n  }\n \n  BearSSL::WiFiClientSecure *bear = new BearSSL::WiFiClientSecure();\n  // 应用证书集（cert store）\n  bear->setCertStore(&certStore);\n  Serial.printf(\"Attempting to fetch https://www.github.com/...\\n\");\n  fetchURL(bear, \"www.github.com\", 443, \"/\");\n  delete bear;\n}\n \nvoid loop() {\n  Serial.printf(\"\\nPlease enter a website address (www.blah.com) to connect to: \");\n  String site;\n  do {\n    site = Serial.readString();\n  } while (site == \"\");\n  // Strip newline if present\n  site.replace(String(\"\\r\"), emptyString);\n  site.replace(String(\"\\n\"), emptyString);\n  Serial.printf(\"https://%s/\\n\", site.c_str());\n \n  BearSSL::WiFiClientSecure *bear = new BearSSL::WiFiClientSecure();\n  // Integrate the cert store with this connection\n  bear->setCertStore(&certStore);\n  fetchURL(bear, site.c_str(), 443, \"/\");\n  delete bear;\n}\n```\n\n\n\n\n\n\n\n#### 状态信息类型\n\n##### connected – 检查是否成功连接服务器\n\n###### 说明\n\nconnected函数可以用来检查ESP8266在使用HTTPS协议通讯时，ESP8266与服务器连接的状态。\n\n###### 语法\n\nhttpsClient.connected()\n\n###### 参数\n\n无\n\n###### 返回值\n\nESP8266与服务器连接则返回true，否则返回false。\n\n###### 示例程序\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。\n\n![image-20230527151919397](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527151919397.png)\n\n此程序使用了语句 httpsClient.connected()检查当前ESP8266是否与服务器连接。具体操作方法，请见以下示例程序的高亮部分。\n\n**注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。**\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266-WiFiClientSecure-connected\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的connected函数来检查ESP8266是否\n与服务器连接。\n \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。\n \n注意：本程序使用了指纹认证方式。出于安全原因，网站服务器会定期更新证书指纹信息。\n因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n并复制粘贴到程序中相应位置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n#include <ESP8266WebServer.h>\n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"www.howsmyssl.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \n//注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n//并复制粘贴到此处。\n//以下两行语句为两种不同类型的fingerprint建立。\n//const char fingerprint[] PROGMEM = \"c7c1f454fb33ef22191163c50c12dc7d4842694a\";\nconst char *fingerprint = \"c7c1f454fb33ef22191163c50c12dc7d4842694a\";\n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  // 实现HTTPS通讯\n  httpsCom();\n}\n \nvoid loop(){}\n \nvoid httpsCom(){\n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n \n  Serial.println(host);\n \n  Serial.printf(\"Using fingerprint '%s'\\n\", fingerprint);\n  httpsClient.setFingerprint(fingerprint);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器\n  // 告知用户当前ESP8266已经成功接收服务器响应头信息。\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  // 通过串口监视器输出服务器响应体信息（服务器报文）\n  Serial.println(\"==========\");\n  Serial.println(\"server response payload:\"); \n  String line;\n  while(httpsClient.available()){        \n    line = httpsClient.readStringUntil('\\n');  //Read Line by Line\n    Serial.println(line); //Print response\n  }\n  Serial.println(\"==========\");\n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n```\n\n\n\n##### getLastSSLError – 获取SSL错误信息\n\n###### 说明\n\nESP8266通过HTTPS协议进行物联网通讯时，我们可以使用getLastSSLError获取通讯报错信息。这些报错信息将以错误代码的形式通过getLastSSLError返回。\n\n如需了解报错代码的详细说明，您可以参考以下两个文件中相应部分。\n\n[bearssl_ssl.h](https://github.com/esp8266/Arduino/blob/master/tools/sdk/include/bearssl/bearssl_ssl.h)\n[bearssl_x509.h](https://github.com/esp8266/Arduino/blob/master/tools/sdk/include/bearssl/bearssl_x509.h)\n\n###### 语法\n\nhttpsClient.getLastSSLError()\n\n###### 参数\n\n无\n\n###### 返回值\n\n错误代码值，（类型： int）\n\n### 示例程序\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议尝试与必应网站服务器进行通讯。由于我们故意将服务器认证的指纹信息改为错误的，连接将会失败，同时程序中使用了`httpsClient.getLastSSLError()`来获取连接失败的报错信息。具体操作方法，请见以下 示例程序中的高亮代码部分。\n\n如需了解报错代码的详细说明，您可以参考以下两个文件中相应部分。\n\n[bearssl_ssl.h](https://github.com/esp8266/Arduino/blob/master/tools/sdk/include/bearssl/bearssl_ssl.h)\n[bearssl_x509.h](https://github.com/esp8266/Arduino/blob/master/tools/sdk/include/bearssl/bearssl_x509.h)\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266-WiFiClientSecure-getLastSSLError\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的getLastSSLError函数来获取\n连接出错信息。\n程序中故意将服务器指纹改为错误的。这么做是为了让getLastSSLError返回出错数据信息。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n#include <ESP8266WebServer.h>\n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"cn.bing.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \n//注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n//并复制粘贴到此处。\n \n//const char *fingerprint = \"62914576dc0afac83c4804bcc2c1b700a61139fe\"; // 正确指纹\nconst char *fingerprint = \"62914576dc0afac83c4804bcc2c1b700a69fe123\";// 错误指纹\n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  // 实现HTTPS通讯\n  httpsCom();\n}\n \nvoid loop(){}\n \nvoid httpsCom(){\n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n  \n  Serial.println(host);\n   \n  Serial.printf(\"Using fingerprint '%s'\\n\", fingerprint);\n  httpsClient.setFingerprint(fingerprint);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n     \n      Serial.print(\"httpsClient.getLastSSLError() = \");\n      Serial.println(httpsClient.getLastSSLError());\n      \n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n  \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n  \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。通过串口监视器输出服务器状态码和响应头信息\n  // 从而确定ESP8266已经成功连接服务器\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    //Serial.println(line);\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n  \n  Serial.println(\"Now disconect from the server...\"); \n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n```\n\n\n\n\n\n### 发送数据类型\n\n#### print – 发送信息（Stream类）\n\n##### 说明\n\nprint函数用于发送数据到已连接的服务器。print函数与[println](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/http-client-secure/println/)函数功能十分相似。他们二者的区别是，println函数会在发送的数据结尾增加一个换行符（’\\n’），而print函数则不会。\n\n**请留意，WiFiClientSecure库对象在处理或发送网络数据时，可以通过调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)中的函数来实现。本函数即是Stream类中的一员。**\n\n##### 语法\n\n```\nhttpsClient.print(val);\n```\n\n##### 参数\n\nval:所要发送的数据，可以是字符串、字符或者数值。\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n###### 示例1：ESP8266实现HTTPS通讯（指纹认证）\n\n以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。本程序使用了指纹认证方式。比起本页的“示例2：ESP8266实现HTTPS通讯（证书认证）”，示例1所采用的指纹认证不如证书认证安全性高。\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。\n\n![image-20230527152552542](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527152552542.png)\n\n在以下示例程序中，我们使用`httpsClient.print(request)`通过ESP8266向网站服务器发送请求。具体操作方法，请见以下示例程序的高亮部分。\n\n**注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。**\n\n```c\n/**********************************************************************\n程序名称/Program name     : WiFiClientSecurre_print_1\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的print函数来控制ESP8266\n通过HTTPS协议向接服务器发送请求。\n \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。\n \n本程序使用了指纹认证方式。该方式没有证书认证方式安全。\n \n注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n并复制粘贴到程序中相应位置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n \n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"www.howsmyssl.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \n//注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n//并复制粘贴到此处。\nconst char fingerprint[] PROGMEM = \"c7c1f454fb33ef22191163c50c12dc7d4842694a\";\n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  // 实现HTTPS通讯\n  httpsCom();\n}\n \nvoid loop(){}\n \nvoid httpsCom(){\n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n \n  Serial.println(host);\n \n  Serial.printf(\"Using fingerprint '%s'\\n\", fingerprint);\n  httpsClient.setFingerprint(fingerprint);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器\n  // 告知用户当前ESP8266已经成功接收服务器响应头信息。\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  // 通过串口监视器输出服务器响应体信息（服务器报文）\n  Serial.println(\"==========\");\n  Serial.println(\"server response payload:\"); \n  String line;\n  while(httpsClient.available()){        \n    line = httpsClient.readStringUntil('\\n');  //Read Line by Line\n    Serial.println(line); //Print response\n  }\n  Serial.println(\"==========\");\n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n```\n\n\n\n###### 示例2：ESP8266实现HTTPS通讯（证书认证）\n\n本示例所实现的功能与示例1相同。唯一区别是本示例在ESP8266与服务器的HTTPS通信中，使用证书认证而不是指纹认证。使用本示例中的证书认证可以提高HTTPS通讯安全性。\n\n如需了解本示例程序的操作方法和运行结果，请参考示例1中的相应内容。\n\n**注意：出于安全原因，CA会定期更新根证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。**\n\n```c\n/**********************************************************************\n程序名称/Program name     : WiFiClientSecurre_print_2\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的print函数来控制ESP8266\n通过HTTPS协议向接服务器发送请求。\n \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。\n \n本程序使用了证书认证方式。该方式比指纹认证方式要更安全。\n \n注意：出于安全原因，网站服务器会定期更新证书信息。因此本程序\n中的证书可能已经过期。请使用浏览器获取最新的服务器证书\n并复制粘贴到程序中相应位置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n \n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"www.howsmyssl.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  httpsCom(); // 实现https通讯\n}\n \nvoid loop() {}\n \n// 实现https通讯\nvoid httpsCom(){\n//注意：出于安全原因，网站服务器会定期更新证书信息。因此本程序\n//中的证书可能已经过期。请使用浏览器获取最新的服务器证书\n//并复制粘贴到此处。如需了解如何执行这一操作，请参考太极创客网站中\n//“获取网站证书”页面(网址见下):\n//http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/http-client-secure/certificate/\n  static const char digicert[] PROGMEM = R\"EOF( // 证书信息\n-----BEGIN CERTIFICATE-----\nMIIDSjCCAjKgAwIBAgIQRK+wgNajJ7qJMDmGLvhAazANBgkqhkiG9w0BAQUFADA/\nMSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMT\nDkRTVCBSb290IENBIFgzMB4XDTAwMDkzMDIxMTIxOVoXDTIxMDkzMDE0MDExNVow\nPzEkMCIGA1UEChMbRGlnaXRhbCBTaWduYXR1cmUgVHJ1c3QgQ28uMRcwFQYDVQQD\nEw5EU1QgUm9vdCBDQSBYMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB\nAN+v6ZdQCINXtMxiZfaQguzH0yxrMMpb7NnDfcdAwRgUi+DoM3ZJKuM/IUmTrE4O\nrz5Iy2Xu/NMhD2XSKtkyj4zl93ewEnu1lcCJo6m67XMuegwGMoOifooUMM0RoOEq\nOLl5CjH9UL2AZd+3UWODyOKIYepLYYHsUmu5ouJLGiifSKOeDNoJjj4XLh7dIN9b\nxiqKqy69cK3FCxolkHRyxXtqqzTWMIn/5WgTe1QLyNau7Fqckh49ZLOMxt+/yUFw\n7BZy1SbsOFU5Q9D8/RhcQPGX69Wam40dutolucbY38EVAjqr2m7xPi71XAicPNaD\naeQQmxkqtilX4+U9m5/wAl0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNV\nHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFMSnsaR7LHH62+FLkHX/xBVghYkQMA0GCSqG\nSIb3DQEBBQUAA4IBAQCjGiybFwBcqR7uKGY3Or+Dxz9LwwmglSBd49lZRNI+DT69\nikugdB/OEIKcdBodfpga3csTS7MgROSR6cz8faXbauX+5v3gTt23ADq1cEmv8uXr\nAvHRAosZy5Q6XkjEGB5YGV8eAlrwDPGxrancWYaLbumR9YbK+rlmM6pZW87ipxZz\nR8srzJmwN0jP41ZL9c8PDHIyh8bwRLtTcm1D9SZImlJnt1ir/md2cXjbDaJWFBM5\nJDGFoqgCWjBH4d1QB7wCCZAA62RjYJsWvIjJEubSfZGL+T0yjWW06XyxV3bqxbYo\nOb8VZRzI9neWagqNdwvYkQsEjgfbKbYK7p2CNTUQ\n-----END CERTIFICATE-----\n)EOF\";\n  \n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n  BearSSL::X509List cert(digicert);\n  \n  // 设置时间\n  setClock();\n  \n  Serial.println(\"Using certificate\");\n  httpsClient.setTrustAnchors(&cert);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器\n  // 告知用户当前ESP8266已经成功接收服务器响应头信息。\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  // 通过串口监视器输出服务器响应体信息（服务器报文）\n  Serial.println(\"==========\");\n  Serial.println(\"server response payload:\"); \n  String line;\n  while(httpsClient.available()){        \n    line = httpsClient.readStringUntil('\\n');  //Read Line by Line\n    Serial.println(line); //Print response\n  }\n  Serial.println(\"==========\");\n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n \n// 获取网络时间，该时间信息用于证书认证\nvoid setClock() {\n  configTime(3 * 3600, 0, \"ntp.ntsc.ac.cn\",\"pool.ntp.org\", \"time.nist.gov\");\n  \n  // bool configTime(int timezone, int daylightOffset, char *server1, char *server2, char *server3, bool enable);\n  Serial.print(\"Waiting for NTP time sync: \");\n  time_t now = time(nullptr);\n  while (now < 8 * 3600 * 2) {\n    delay(500);\n    Serial.print(\".\");\n    now = time(nullptr);\n  }\n  Serial.println(\"\");\n  struct tm timeinfo;\n  gmtime_r(&now, &timeinfo);\n  Serial.print(\"Current time: \");\n  Serial.print(asctime(&timeinfo));\n}\n```\n\n\n\n\n\n#### println – 发送信息（Stream类）\n\n##### 说明\n\nprintln函数用于发送数据到已连接的服务器。println函数与[print](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wificlient/print/)函数功能十分相似。他们二者的区别是，println函数会在发送的数据结尾增加一个换行符（’\\n’），而print函数则不会。\n\n**请留意，WiFiClient对象在处理或发送网络数据时，可以通过调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)中的函数来实现。本函数即是Stream类中的一员。**\n\n##### 语法\n\n```\nhttpsClient.println(val);\n```\n\n##### 参数\n\nval:所要发送的数据，可以是字符串、字符或者数值。\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n###### 示例1：ESP8266实现HTTPS通讯（指纹认证）\n\n以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。本程序使用了指纹认证方式。比起本页的“示例2：ESP8266实现HTTPS通讯（证书认证）”，示例1所采用的指纹认证不如证书认证安全性高。\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。\n\n![image-20230527152812150](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527152812150.png)\n\n在以下示例程序中，我们使用`httpsClient.println(request)`通过ESP8266向网站服务器发送请求。具体操作方法，请见以下示例程序的高亮部分。\n\n**注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。**\n\n```c\n/**********************************************************************\n程序名称/Program name     : WiFiClientSecurre_println_1\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的println函数来控制ESP8266\n通过HTTPS协议向接服务器发送请求。\n \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。\n \n本程序使用了指纹认证方式。该方式没有证书认证方式安全。\n \n注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n并复制粘贴到程序中相应位置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n \n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"www.howsmyssl.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \n//注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n//并复制粘贴到此处。\nconst char fingerprint[] PROGMEM = \"c7c1f454fb33ef22191163c50c12dc7d4842694a\";\n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  // 实现HTTPS通讯\n  httpsCom();\n}\n \nvoid loop(){}\n \nvoid httpsCom(){\n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n \n  Serial.println(host);\n \n  Serial.printf(\"Using fingerprint '%s'\\n\", fingerprint);\n  httpsClient.setFingerprint(fingerprint);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.println(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器\n  // 告知用户当前ESP8266已经成功接收服务器响应头信息。\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  // 通过串口监视器输出服务器响应体信息（服务器报文）\n  Serial.println(\"==========\");\n  Serial.println(\"server response payload:\"); \n  String line;\n  while(httpsClient.available()){        \n    line = httpsClient.readStringUntil('\\n');  //Read Line by Line\n    Serial.println(line); //Print response\n  }\n  Serial.println(\"==========\");\n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n```\n\n\n\n#### write – 发送信息（Stream类）\n\n##### 说明\n\nwrite函数可用于发送数据到已连接的服务器。你可以发送单个字节的信息也可以发送多字节的信息。\n\n##### 语法\n\n```\nhttpsClient.write(val);`\n`httpsClient.write(str)`\n`httpsClient.write(buf, len)\n```\n\n##### 参数\n\nval: 要发送的单字符数据\nstr: 要发送的多字符数据\nbuf: 要发送的多字符数组\nlen: buf的字节长度\n\n##### 返回值\n\n写入发送缓存的字节数\n\n\n\n\n\n### 响应信息类型\n\n#### readString – 读取数据并保存为字符串（Stream类）\n\n##### 说明\n\n本函数可用于从ESP8266接收到数据中读取数据信息。读取到的信息将以字符串格式返回。\n\n**请留意，WiFiClientSecure对象在处理或发送网络数据时，可以通过调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)中的函数来实现。本函数即是Stream类中的一员。**\n\n##### 语法\n\n```\nhttpsClient.readString()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n接收到的数据，类型为字符串。\n\n##### 示例程序\n\n###### 示例1：ESP8266实现HTTPS通讯（指纹认证）\n\n以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。本程序使用了指纹认证方式。比起本页的“示例2：ESP8266实现HTTPS通讯（证书认证）”，示例1所采用的指纹认证不如证书认证安全性高。\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。\n\n![image-20230527153304309](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527153304309.png)\n\n在以下示例程序中，我们使用`httpsClient.readString()`从ESP8266接收到数据中读取数据信息。读取到的信息将以字符串格式返回。具体操作方法，请见以下示例程序中的高亮语句部分。\n\n**注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。**\n\n```c\n/**********************************************************************\n程序名称/Program name     : WiFiClientSecurre_readString_1\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的readString函数来从ESP8266接收到数据中读取\n数据信息。读取到的信息将以字符串格式返回。\n \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。\n \n本程序使用了指纹认证方式。该方式没有证书认证方式安全。\n \n注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n并复制粘贴到程序中相应位置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n \n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"www.howsmyssl.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \n//注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n//并复制粘贴到此处。\nconst char fingerprint[] PROGMEM = \"c7c1f454fb33ef22191163c50c12dc7d4842694a\";\n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  // 实现HTTPS通讯\n  httpsCom();\n}\n \nvoid loop(){}\n \nvoid httpsCom(){\n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n \n  Serial.println(host);\n \n  Serial.printf(\"Using fingerprint '%s'\\n\", fingerprint);\n  httpsClient.setFingerprint(fingerprint);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.println(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器\n  // 告知用户当前ESP8266已经成功接收服务器响应头信息。\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  // 通过串口监视器输出服务器响应体信息（服务器报文）\n  Serial.println(\"==========\");\n  Serial.println(\"server response payload:\"); \n  String line;\n  while(httpsClient.available()){        \n    line = httpsClient.readString(); \n    Serial.println(line); \n  }\n  Serial.println(\"==========\");\n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n```\n\n###### 示例2：ESP8266实现HTTPS通讯（证书认证）\n\n本示例所实现的功能与示例1相同。唯一区别是本示例在ESP8266与服务器的HTTPS通信中，使用证书认证而不是指纹认证。使用本示例中的证书认证可以提高HTTPS通讯安全性。\n\n如需了解本示例程序的操作方法和运行结果，请参考示例1中的相应内容。\n\n**注意：出于安全原因，CA会定期更新根证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。**\n\n```c\n/**********************************************************************\n程序名称/Program name     : WiFiClientSecurre_readString_2\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的readString函数来从ESP8266接收到数据中读取\n数据信息。读取到的信息将以字符串格式返回。\n \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。\n \n本程序使用了证书认证方式。该方式比指纹认证方式要更安全。\n \n注意：出于安全原因，网站服务器会定期更新证书信息。因此本程序\n中的证书可能已经过期。请使用浏览器获取最新的服务器证书\n并复制粘贴到程序中相应位置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n \n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"www.howsmyssl.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  httpsCom(); // 实现https通讯\n}\n \nvoid loop() {}\n \n// 实现https通讯\nvoid httpsCom(){\n//注意：出于安全原因，网站服务器会定期更新证书信息。因此本程序\n//中的证书可能已经过期。请使用浏览器获取最新的服务器证书\n//并复制粘贴到此处。如需了解如何执行这一操作，请参考太极创客网站中\n//“获取网站证书”页面(网址见下):\n//http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/http-client-secure/certificate/\n  static const char digicert[] PROGMEM = R\"EOF( // 证书信息\n-----BEGIN CERTIFICATE-----\nMIIDSjCCAjKgAwIBAgIQRK+wgNajJ7qJMDmGLvhAazANBgkqhkiG9w0BAQUFADA/\nMSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMT\nDkRTVCBSb290IENBIFgzMB4XDTAwMDkzMDIxMTIxOVoXDTIxMDkzMDE0MDExNVow\nPzEkMCIGA1UEChMbRGlnaXRhbCBTaWduYXR1cmUgVHJ1c3QgQ28uMRcwFQYDVQQD\nEw5EU1QgUm9vdCBDQSBYMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB\nAN+v6ZdQCINXtMxiZfaQguzH0yxrMMpb7NnDfcdAwRgUi+DoM3ZJKuM/IUmTrE4O\nrz5Iy2Xu/NMhD2XSKtkyj4zl93ewEnu1lcCJo6m67XMuegwGMoOifooUMM0RoOEq\nOLl5CjH9UL2AZd+3UWODyOKIYepLYYHsUmu5ouJLGiifSKOeDNoJjj4XLh7dIN9b\nxiqKqy69cK3FCxolkHRyxXtqqzTWMIn/5WgTe1QLyNau7Fqckh49ZLOMxt+/yUFw\n7BZy1SbsOFU5Q9D8/RhcQPGX69Wam40dutolucbY38EVAjqr2m7xPi71XAicPNaD\naeQQmxkqtilX4+U9m5/wAl0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNV\nHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFMSnsaR7LHH62+FLkHX/xBVghYkQMA0GCSqG\nSIb3DQEBBQUAA4IBAQCjGiybFwBcqR7uKGY3Or+Dxz9LwwmglSBd49lZRNI+DT69\nikugdB/OEIKcdBodfpga3csTS7MgROSR6cz8faXbauX+5v3gTt23ADq1cEmv8uXr\nAvHRAosZy5Q6XkjEGB5YGV8eAlrwDPGxrancWYaLbumR9YbK+rlmM6pZW87ipxZz\nR8srzJmwN0jP41ZL9c8PDHIyh8bwRLtTcm1D9SZImlJnt1ir/md2cXjbDaJWFBM5\nJDGFoqgCWjBH4d1QB7wCCZAA62RjYJsWvIjJEubSfZGL+T0yjWW06XyxV3bqxbYo\nOb8VZRzI9neWagqNdwvYkQsEjgfbKbYK7p2CNTUQ\n-----END CERTIFICATE-----\n)EOF\";\n  \n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n  BearSSL::X509List cert(digicert);\n  \n  // 设置时间\n  setClock();\n  \n  Serial.println(\"Using certificate\");\n  httpsClient.setTrustAnchors(&cert);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.println(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器\n  // 告知用户当前ESP8266已经成功接收服务器响应头信息。\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  // 通过串口监视器输出服务器响应体信息（服务器报文）\n  Serial.println(\"==========\");\n  Serial.println(\"server response payload:\"); \n  String line;\n  while(httpsClient.available()){        \n    line = httpsClient.readString();  //Read Line by Line\n    Serial.println(line); //Print response\n  }\n  Serial.println(\"==========\");\n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n \n// 获取网络时间，该时间信息用于证书认证\nvoid setClock() {\n  configTime(3 * 3600, 0, \"ntp.ntsc.ac.cn\",\"pool.ntp.org\", \"time.nist.gov\");\n  \n  // bool configTime(int timezone, int daylightOffset, char *server1, char *server2, char *server3, bool enable);\n  Serial.print(\"Waiting for NTP time sync: \");\n  time_t now = time(nullptr);\n  while (now < 8 * 3600 * 2) {\n    delay(500);\n    Serial.print(\".\");\n    now = time(nullptr);\n  }\n  Serial.println(\"\");\n  struct tm timeinfo;\n  gmtime_r(&now, &timeinfo);\n  Serial.print(\"Current time: \");\n  Serial.print(asctime(&timeinfo));\n}\n```\n\n\n\n\n\n#### readStringUntil – 读取数据直到指定字符并保存为字符串（Stream类）\n\n##### 说明\n\nreadStringUntil函数可用于从设备接收到的数据中读取信息。读取到的数据信息将以字符串形式返回。该函数在满足以下任一条件后都会停止函数执行并返回。\n\n– 读取到指定终止字符\n– 达到设定时间（可使用[setTimeout](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/settimeout/)来设置）\n\n当函数读取到终止字符后，会立即停止函数执行。此时函数所返回的字符串为”终止字符”前的所有字符信息。\n\n**请留意，WiFiClientSecure对象在处理或发送网络数据时，可以通过调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)中的函数来实现。本函数即是Stream类中的一员。**\n\n##### 语法\n\n```\nhttpsClient.readStringUntil(terminator)\n```\n\n##### 参数\n\nterminator: 终止字符。用于设置终止函数执行的字符信息。设备在读取数据时一旦读取到此终止字符，将会结束函数执行。允许使用char类型。\n\n##### 返回值\n\n接收到的数据，类型为字符串。\n\n##### 示例程序\n\n###### 示例1：ESP8266实现HTTPS通讯（指纹认证）\n\n以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。本程序使用了指纹认证方式。比起本页的“示例2：ESP8266实现HTTPS通讯（证书认证）”，示例1所采用的指纹认证不如证书认证安全性高。\n\n请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。\n\n![image-20230527153459596](./C:/Users/hurri/AppData/Local/Temp/BNZ.6471b5b0e6f9d2./Image/ESP8266.assets/image-20230527153459596.png)\n\n在以下示例程序中，我们使用`httpsClient.readStringUntil()`从ESP8266接收到数据中读取数据信息。读取到的信息将以字符串格式返回。具体操作方法，请见以下示例程序中的高亮语句部分。\n\n**注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。**\n\n\n\n```c\n/**********************************************************************\n程序名称/Program name     : WiFiClientSecurre_readStringUntil_1\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的readStringUntil函数来从ESP8266接收到数据中读取\n数据信息。读取到的信息将以字符串格式返回。\n \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。\n \n本程序使用了指纹认证方式。该方式没有证书认证方式安全。\n \n注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n并复制粘贴到程序中相应位置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n \n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"www.howsmyssl.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \n//注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n//并复制粘贴到此处。\nconst char fingerprint[] PROGMEM = \"c7c1f454fb33ef22191163c50c12dc7d4842694a\";\n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  // 实现HTTPS通讯\n  httpsCom();\n}\n \nvoid loop(){}\n \nvoid httpsCom(){\n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n \n  Serial.println(host);\n \n  Serial.printf(\"Using fingerprint '%s'\\n\", fingerprint);\n  httpsClient.setFingerprint(fingerprint);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.println(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器\n  // 告知用户当前ESP8266已经成功接收服务器响应头信息。\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  // 通过串口监视器输出服务器响应体信息（服务器报文）\n  Serial.println(\"==========\");\n  Serial.println(\"server response payload:\"); \n  String line;\n  while(httpsClient.available()){        \n    line = httpsClient.readString(); \n    Serial.println(line); \n  }\n  Serial.println(\"==========\");\n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n```\n\n\n\n###### 示例2：ESP8266实现HTTPS通讯（证书认证）\n\n本示例所实现的功能与示例1相同。唯一区别是本示例在ESP8266与服务器的HTTPS通信中，使用证书认证而不是指纹认证。使用本示例中的证书认证可以提高HTTPS通讯安全性。\n\n如需了解本示例程序的操作方法和运行结果，请参考示例1中的相应内容。\n\n**注意：出于安全原因，CA会定期更新根证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。**\n\n```c\n/**********************************************************************\n程序名称/Program name     : WiFiClientSecurre_readStringUntil_2\n程序目的/Purpose          : \n此程序用于演示如何使用WiFiClientSecure库中的readStringUntil函数来从ESP8266接收到数据中读取\n数据信息。读取到的信息将以字符串格式返回。\n \n以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息\n显示于串口监视器中。\n \n本程序使用了证书认证方式。该方式比指纹认证方式要更安全。\n \n注意：出于安全原因，网站服务器会定期更新证书信息。因此本程序\n中的证书可能已经过期。请使用浏览器获取最新的服务器证书\n并复制粘贴到程序中相应位置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n \n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"www.howsmyssl.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  httpsCom(); // 实现https通讯\n}\n \nvoid loop() {}\n \n// 实现https通讯\nvoid httpsCom(){\n//注意：出于安全原因，网站服务器会定期更新证书信息。因此本程序\n//中的证书可能已经过期。请使用浏览器获取最新的服务器证书\n//并复制粘贴到此处。\n  static const char digicert[] PROGMEM = R\"EOF( // 证书信息\n-----BEGIN CERTIFICATE-----\nMIIDSjCCAjKgAwIBAgIQRK+wgNajJ7qJMDmGLvhAazANBgkqhkiG9w0BAQUFADA/\nMSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMT\nDkRTVCBSb290IENBIFgzMB4XDTAwMDkzMDIxMTIxOVoXDTIxMDkzMDE0MDExNVow\nPzEkMCIGA1UEChMbRGlnaXRhbCBTaWduYXR1cmUgVHJ1c3QgQ28uMRcwFQYDVQQD\nEw5EU1QgUm9vdCBDQSBYMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB\nAN+v6ZdQCINXtMxiZfaQguzH0yxrMMpb7NnDfcdAwRgUi+DoM3ZJKuM/IUmTrE4O\nrz5Iy2Xu/NMhD2XSKtkyj4zl93ewEnu1lcCJo6m67XMuegwGMoOifooUMM0RoOEq\nOLl5CjH9UL2AZd+3UWODyOKIYepLYYHsUmu5ouJLGiifSKOeDNoJjj4XLh7dIN9b\nxiqKqy69cK3FCxolkHRyxXtqqzTWMIn/5WgTe1QLyNau7Fqckh49ZLOMxt+/yUFw\n7BZy1SbsOFU5Q9D8/RhcQPGX69Wam40dutolucbY38EVAjqr2m7xPi71XAicPNaD\naeQQmxkqtilX4+U9m5/wAl0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNV\nHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFMSnsaR7LHH62+FLkHX/xBVghYkQMA0GCSqG\nSIb3DQEBBQUAA4IBAQCjGiybFwBcqR7uKGY3Or+Dxz9LwwmglSBd49lZRNI+DT69\nikugdB/OEIKcdBodfpga3csTS7MgROSR6cz8faXbauX+5v3gTt23ADq1cEmv8uXr\nAvHRAosZy5Q6XkjEGB5YGV8eAlrwDPGxrancWYaLbumR9YbK+rlmM6pZW87ipxZz\nR8srzJmwN0jP41ZL9c8PDHIyh8bwRLtTcm1D9SZImlJnt1ir/md2cXjbDaJWFBM5\nJDGFoqgCWjBH4d1QB7wCCZAA62RjYJsWvIjJEubSfZGL+T0yjWW06XyxV3bqxbYo\nOb8VZRzI9neWagqNdwvYkQsEjgfbKbYK7p2CNTUQ\n-----END CERTIFICATE-----\n)EOF\";\n  \n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n  BearSSL::X509List cert(digicert);\n  \n  // 设置时间\n  setClock();\n  \n  Serial.println(\"Using certificate\");\n  httpsClient.setTrustAnchors(&cert);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.println(request);\n \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器\n  // 告知用户当前ESP8266已经成功接收服务器响应头信息。\n  while (httpsClient.connected()) {\n    String line = httpsClient.readStringUntil('\\n');\n    if (line == \"\\r\") {\n      Serial.println(\"headers received\");\n      break;\n    }\n  }\n \n  // 通过串口监视器输出服务器响应体信息（服务器报文）\n  Serial.println(\"==========\");\n  Serial.println(\"server response payload:\"); \n  String line;\n  while(httpsClient.available()){        \n    line = httpsClient.readString();  //Read Line by Line\n    Serial.println(line); //Print response\n  }\n  Serial.println(\"==========\");\n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n \n// 获取网络时间，该时间信息用于证书认证\nvoid setClock() {\n  configTime(3 * 3600, 0, \"ntp.ntsc.ac.cn\",\"pool.ntp.org\", \"time.nist.gov\");\n  \n  // bool configTime(int timezone, int daylightOffset, char *server1, char *server2, char *server3, bool enable);\n  Serial.print(\"Waiting for NTP time sync: \");\n  time_t now = time(nullptr);\n  while (now < 8 * 3600 * 2) {\n    delay(500);\n    Serial.print(\".\");\n    now = time(nullptr);\n  }\n  Serial.println(\"\");\n  struct tm timeinfo;\n  gmtime_r(&now, &timeinfo);\n  Serial.print(\"Current time: \");\n  Serial.print(asctime(&timeinfo));\n}\n```\n\n\n\n\n\n\n\n#### find – 在数据中寻找信息（Stream类）\n\n##### 说明\n\nfind函数可用于从设备接收到的数据中寻找指定字符串信息。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。\n\n**请留意，WiFiClientSecure对象在处理或发送网络数据时，可以通过调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)中的函数来实现。本函数即是Stream类中的一员。**\n\n##### 语法\n\n```\nhttpsClient.find(target)\n```\n\n##### 参数\n\ntarget: 被查找字符串。允许使用String或char类型。\n\n##### 返回值\n\n返回值类型为bool。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。\n\n##### 示例程序\n\n此程序用于演示如何使用esp8266作为互联网客户端向网站服务器发送https请求，并且使用find函数在网站服务器响应的信息中寻找“Date”字符串。如果找到“Date”字符串，则通过串口监视器告知用户开发板已经找到了“Date”字符串。\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n**注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。**\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266-WiFiClientSecure-find\n程序目的/Purpose          : \n此程序用于演示如何使用esp8266作为互联网客户端向网站服务器发送https请求，\n并且使用find函数在网站服务器响应的信息中寻找“Date”字符串。如果找到“Date”字符串，则通过\n串口监视器告知用户开发板已经找到了“Date”字符串。\n \n注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n并复制粘贴到程序中相应位置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n#include <ESP8266WebServer.h>\n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"cn.bing.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \n//注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n//并复制粘贴到此处。\n//以下两行语句为两种不同类型的fingerprint建立。\n//const char fingerprint[] PROGMEM = \"62914576dc0afac83c4804bcc2c1b700a61139fe\";\nconst char *fingerprint = \"62914576dc0afac83c4804bcc2c1b700a61139fe\";\n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  // 实现HTTPS通讯\n  httpsCom();\n}\n \nvoid loop(){}\n \nvoid httpsCom(){\n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n  \n  Serial.println(host);\n  httpsClient.setBufferSizes(16000, 512); \n  \n  Serial.printf(\"Using fingerprint '%s'\\n\", fingerprint);\n  httpsClient.setFingerprint(fingerprint);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n  \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。通过串口监视器输出服务器状态码和响应头信息\n  // 从而确定ESP8266已经成功连接服务器\n  while (httpsClient.connected()) {\n    if (httpsClient.available()){\n      if (httpsClient.find(\"Date\")){\n        Serial.println(\"Found Date Info in Server Response.\");\n        break;\n      }\n    }\n  }\n \n  Serial.println(\"Now disconect from the server...\"); \n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n```\n\n\n\n#### parseInt – 解析数据中的整数（Stream类）\n\n##### 说明\n\nparseInt函数可用于从设备接收到的数据中寻找整数数值。\n\n**请留意，WiFiClientSecure对象在处理或发送网络数据时，可以通过调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)中的函数来实现。本函数即是Stream类中的一员。**\n\n##### 语法\n\nhttpsClient.parseInt()\n\n##### 参数\n\n无\n\n##### 返回值\n\n在输入信息中找到的整数数值。类型：long\n\n##### 示例程序\n\n此程序用于演示如何使用esp8266作为互联网客户端向网站服务器发送https请求，并且使用find函数在网站服务器响应的信息中寻找“Date”字符串。如果找到“Date”字符串，则进一步使用parseInt函数来寻找“Date”字符串后面的第一个数字。由于标准服务器相应信息中“Date”字符串后面的第一个数字信息即是当前服务器的日期信息中的”日”数值。因parseInt函数寻找到的数字即是服务器的日期信息中的”日”数值。\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266-WiFiClientSecure-parseInt\n程序目的/Purpose          : \n此程序用于演示如何使用esp8266作为互联网客户端向网站服务器发送https请求，\n并且使用find函数在网站服务器响应的信息中寻找“Date”字符串。如果找到“Date”字符串，则进一步\n使用parseInt函数来寻找“Date”字符串后面的第一个数字。由于标准服务器相应信息中“Date”字符串\n后面的第一个数字信息即是当前服务器的日期信息中的\"日\"数值。因此parseInt函数寻找到的数字即是\n服务器的日期信息中的\"日\"数值。\n \n注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n并复制粘贴到程序中相应位置。\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h> \n#include <ESP8266WebServer.h>\n \n//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）\n#define ssid \"taichimaker\"   //WiFi名称 \n#define password \"12345678\"  //WiFi密码\n \n//测试HTTPS通讯的网站\nconst char *host = \"cn.bing.com\"; \n \n//HTTPS端口443\nconst int httpsPort = 443;  \n \n//注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序\n//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹\n//并复制粘贴到此处。\n//以下两行语句为两种不同类型的fingerprint建立。\n//const char fingerprint[] PROGMEM = \"62914576dc0afac83c4804bcc2c1b700a61139fe\";\nconst char *fingerprint = \"62914576dc0afac83c4804bcc2c1b700a61139fe\";\n \nvoid setup() {\n  Serial.begin(9600);\n  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式\n  \n  WiFi.begin(ssid, password); //连接WiFi\n  Serial.println(\"\");\n \n  Serial.println(\"Connecting\"); Serial.println(\"\");\n  \n  // 等待连接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n \n  //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP()); \n \n  // 实现HTTPS通讯\n  httpsCom();\n}\n \nvoid loop(){}\n \nvoid httpsCom(){\n  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象\n  \n  Serial.println(host);\n  httpsClient.setBufferSizes(16000, 512); \n  \n  Serial.printf(\"Using fingerprint '%s'\\n\", fingerprint);\n  httpsClient.setFingerprint(fingerprint);\n  httpsClient.setTimeout(15000);  \n  delay(1000);\n  \n  Serial.println(\"HTTPS Connecting\");Serial.println(\"\");\n  int r=0;  // 尝试连接服务器并等待\n  while((!httpsClient.connect(host, httpsPort)) && (r < 30)){\n      delay(100);\n      Serial.print(\".\");\n      r++;\n  }\n  // 连接超时后输出\"连接失败\"信息并返回\n  if(r==30) { \n    Serial.println(\"Connection failed\");\n    return;\n  } else { // 连接成功则输出“连接成功”信息\n    Serial.println(\"Connected...\");\n  }\n \n  Serial.print(\"requesting: \");\n  Serial.println(host);\n  \n  // 建立HTTPS请求信息字符串\n  String request =  String(\"GET /a/check\") + \" HTTP/1.1\\r\\n\" +\n                        \"Host: \" + host + \"\\r\\n\" +\n                        \"Connection: close\\r\\n\" +\n                        \"\\r\\n\";\n  // 向服务器发送请求                   \n  httpsClient.print(request);\n  \n  Serial.println(\"request sent\");\n \n  // 检查服务器响应信息。通过串口监视器输出服务器状态码和响应头信息\n  // 从而确定ESP8266已经成功连接服务器\n  while (httpsClient.connected()) {\n    if (httpsClient.available()){\n      if (httpsClient.find(\"Date\")){\n        Serial.println(\"Found Date Info in Server Response.\");\n        int day = httpsClient.parseInt();       \n        Serial.print(\"day = \");Serial.println(day);        \n        break;\n      }\n    }\n  }\n \n  Serial.println(\"Now disconect from the server...\"); \n  \n  //操作结束，断开服务器连接 \n  httpsClient.stop();\n  Serial.println(\"closing connection\");  \n}\n```\n\n\n\n\n\n**备注:以上带有`Stream`标注的函数说明该函数是Stream类函数。**\n\n\n\n\n\n## ESP8266 – WiFiServerSecure库\n\nWiFiServerSecure库用于ESP8266的HTTPS协议物联网通讯。HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的互联网协议。HTTPS协议在HTTP的基础上通过SSL或TLS来实现传输加密和身份认证，从而保证了传输过程的安全性。假如您需要进一步了解HTTPS协议的介绍关内容，请参考[百度百科HTTPS协议页面](https://baike.baidu.com/item/https/285356)。\n\n通过WiFiServerSecure库，我们可以使用ESP8266开发板建立网络服务器,从而允许其它网络设备以及物联网设备通过HTTPS协议访问并实现物联网信息交流。\n\n\n\n### WiFiServerSecure – 建立WiFiServerSecure 对象\n\n#### 说明\n\n通过WiFiServerSecure语句，我们可以建立WiFiServerSecure对象从而使用ESP8266建立支持HTTPS协议的物联网服务器。\n\n#### 语法\n\nWiFiServerSecure server(port)\n\n#### 参数\n\n– port: 此参数用于设置服务端口号。(类型:uint16_t)\n\n#### 返回值\n\n无\n\n#### 示例程序\n\n为了演示本实例程序的运行结果，我在这里使用基于[Chrome](https://www.google.cn/chrome/index.html)内核的[Microsoft Edge](https://www.microsoft.com/zh-cn/edge)浏览器来进行示例程序操作演示。\n\n请务必注意：本示例程序所使用的证书和密钥只能用于测试使用。您在自己搭建ESP8266物联网项目时，需要自行建立 证书密钥而不要使用本示例中的证书和密钥。\n\n当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址。此时，ESP8266已经成功建立了支持HTTPS协议的网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。\n\n当您如上图所示输入完IP地址后，接下来 请按下回车键。您将在浏览器中看到如下警告信息 。这很正常，因为ESP8266的服务器证书不是CA颁布的证书，所以浏览器会警告我们，它无法确定ESP8266服务器的身份信息。请忽略这一警告信息，并按照下图所示，点击按钮。\n\n![image-20230527155303909](./Image/ESP8266.assets/image-20230527155303909.png)\n\n\n\n接下来您将看到如下图所示的信息。该信息正是详细说明为何无法验证ESP8266服务器身份的原因。我们需要继续忽略 这一警告信息，并按照下图所示，点击链接。\n\n![image-20230527155330160](./Image/ESP8266.assets/image-20230527155330160.png)\n\n如下图所示，您将看到浏览器中出现了“Hello from ESP8266”信息。这一信息是由ESP8266服务器发来的。说明我们的ESP8266服务器已经可以通过HTTPS协议进行数据通讯了。\n\n![image-20230527155350043](./Image/ESP8266.assets/image-20230527155350043.png)\n\n关于如何使用WiFiServerSecure来建立对象这一操作，请见以下程序中的高亮语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : WiFiServerSecure\n程序目的/Purpose          : \n此程序用于演示如何使用建立WiFiServerSecure对象从而使用ESP8266建立支持HTTPS协议的物联网\n服务器。\n \n本示例程序借鉴ESP8266库中BearSSL_Server示例程序，该程序作者Earle F. Philhower, III\n \n关于本程序的具体使用方法，请参考以下链接：\nhttp://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/web-server-secure/wifiserversecure/\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <time.h>\n \n// WiFi连接信息\nconst char *ssid = \"taichimaker\";// WiFi名称\nconst char *pass = \"12345678\";   // WiFi密码\n \n// 建立WiFiServerSecure对象\nWiFiServerSecure server(443);\n \n// 建立服务器响应信息\nstatic const char *HTTP_RES =\n        \"HTTP/1.0 200 OK\\r\\n\"\n        \"Connection: close\\r\\n\"\n        \"Content-Length: 62\\r\\n\"\n        \"Content-Type: text/html; charset=iso-8859-1\\r\\n\"\n        \"\\r\\n\"\n        \"<html>\\r\\n\"\n        \"<body>\\r\\n\"\n        \"<p>Hello from ESP8266!</p>\\r\\n\"\n        \"</body>\\r\\n\"\n        \"</html>\\r\\n\";\n \n//服务器私钥\nconst char server_private_key[] PROGMEM = R\"EOF(\n-----BEGIN PRIVATE KEY-----\nMIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQDhDf/pokuS+FQO\nMPxiDTPMDZEFQjFoy/uCwiN4MebPg+IcXMVx2o6MSn8x9ofAatwAOq/dYoExhev1\nHN2C3O4ZjjFACsryL6hYXaKG+qHiNEfvHgPTw0olWsDm9N01CcQs7lJqW2wmM5JM\nxXP8ZU0rcUU70qWCUUTR+rN8WE4QHTd7BjP6OTvqjN7Al4ibg8//7owXlSECnM1B\nSKIZQZ6g0QcWLf+rSn6hRrbHPGIkp5RZTIGZ7k9zgUfHQezKKYtRZXRtUhB5JW78\nZyGYaphaek5WlkgakL2pbM/Q/DgKew/2k0najKUjmkz+gxtof4vlmZAojSaN2647\nlabAbuydAgMBAAECggEAYHi806zDUpvqhC7RcUKRio3iNWvbfD28cZ/AzpwtgZTa\nDyhhZt22L0Mb5RH1vTDRX7PIgVDhapYqwGaAOcF0uzWtvPMjbc+qDT8OFWhIjou0\nrjaik1rqZLrTZ+1dCYhHNK9wWrEX2gRPWWNmxbGy88VZVTyFwCgQJSafW9UKmXLu\n4KUTILHcyGsEfVBxth8Vr9uWuNWa6nRW/tb/3uNwRn1ATKV6h+HFgBHxgfkSN11G\nwZfdSRzuov7Y09qGbIHZmeoBYG8iNJ/A4qOhaMJis1Qmt6mjpBzUJRxGriZIHh2E\nznoM85Uejc8cqSnWH8mA8PPT4xDwCbv2ueT9bT5HYQKBgQD25qFyjx+Bbzsbok2a\nlF7wQiN5WbzA5zdCusecTO+Fi2HkrKODFSQdaCHxl/kFKcy7NxYZjeIcNZzf6vnC\nB2Hyrm3B/eeCJ+WoTm/ajfS6dxgt2aO48An+wFAyb7qGdBBrPr+hvn3RG5hbupEM\nbGJnBhRfpcq0+9+JcqMfcAUkuQKBgQDpWUMtfuukR+hwkHhbs68FyXbGxnHMGYth\nsLRWmbmK6OVmSKWDU5kRPlMckztqUReJdE+x6fbvBDbW/cIi83mQa0+7KTxLajoj\nzoCV6CKZz4dATURlisTtfqVCjQP/wHJ4y6E270Ar80CM/0AT8gw+HrWGLeCa+MQN\nL0Qg/u5dBQKBgDAsUaXbfQcxH7RFl6SofFmeXfOIacatll+jt9ysOjOxPVlzwbeK\nwXAnaDAOOd0jCbohhmNYBp0AbOpXm4GbFSZXmDy4gJoplKqhGzvmZLCZGhOgGky0\nMQ8OkNc2a4teS/HQ3Wz+kOfi3XhQT4q//vcg/Yqn+4QSfMwBnQg+QBKpAoGAdUch\nljoV4Ikrb3eMpjoWmwf4JEsUYonsHXscB/JW6FPJB7E3TluzsJDsYI427GY5OCI2\n86otK0+o6EC9U6eez1C/z8cXwKdw9RISWkVDLp640T6EQ6yM8PgXwuzwt5dXcRKW\nwe9ZBz3IkZSv9dZPBOGWRgvEuN6SWjYJPbQixKkCgYA+plfKhE+f+ofA7wWkmfo3\n1cyJmyBCL9ROwfzRlo1ftttYy1XHOLxpe2ts+hh+pqrftGdura1X0TuY6v7d1mk1\nsnuyj7+E37PjIewk4nr45PU4OWwqW2Pqx4BZAYosU+ki1z12rh3ofZhudBH6B5nN\nTPhoHwGbAajgSzHYYG8koQ==\n-----END PRIVATE KEY-----\n)EOF\";\n \n// 服务器证书\nconst char server_cert[] PROGMEM = R\"EOF(\n-----BEGIN CERTIFICATE-----\nMIIEQzCCAyugAwIBAgIUCUSExaDX4tk9VoMXia7kABA2pewwDQYJKoZIhvcNAQEL\nBQAwgbAxCzAJBgNVBAYTAkNOMRAwDgYDVQQIDAdCZWlqaW5nMRAwDgYDVQQHDAdC\nZWlqaW5nMRUwEwYDVQQKDAxUYWljaGktTWFrZXIxDDAKBgNVBAsMA0lPVDEQMA4G\nA1UEAwwHRVNQODI2NjFGMEQGCSqGSIb3DQEJARY3dGFpY2hpYW1rZXJAG1tEG1tE\nG1tEGxtbQxsbW0MbW0MbW0MbdGFpY2hpbWFrZXJAMTYzLmNvbTAeFw0yMDA0MjAx\nMDQ3MjNaFw0zMTA3MDgxMDQ3MjNaMIGwMQswCQYDVQQGEwJDTjEQMA4GA1UECAwH\nQmVpamluZzEQMA4GA1UEBwwHQmVpamluZzEVMBMGA1UECgwMVGFpY2hpLU1ha2Vy\nMQwwCgYDVQQLDANJT1QxEDAOBgNVBAMMB0VTUDgyNjYxRjBEBgkqhkiG9w0BCQEW\nN3RhaWNoaWFta2VyQBtbRBtbRBtbRBsbW0MbG1tDG1tDG1tDG3RhaWNoaW1ha2Vy\nQDE2My5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDhDf/pokuS\n+FQOMPxiDTPMDZEFQjFoy/uCwiN4MebPg+IcXMVx2o6MSn8x9ofAatwAOq/dYoEx\nhev1HN2C3O4ZjjFACsryL6hYXaKG+qHiNEfvHgPTw0olWsDm9N01CcQs7lJqW2wm\nM5JMxXP8ZU0rcUU70qWCUUTR+rN8WE4QHTd7BjP6OTvqjN7Al4ibg8//7owXlSEC\nnM1BSKIZQZ6g0QcWLf+rSn6hRrbHPGIkp5RZTIGZ7k9zgUfHQezKKYtRZXRtUhB5\nJW78ZyGYaphaek5WlkgakL2pbM/Q/DgKew/2k0najKUjmkz+gxtof4vlmZAojSaN\n2647labAbuydAgMBAAGjUzBRMB0GA1UdDgQWBBTttMAlJ46XNA1ydxe5J0bVfWA3\nujAfBgNVHSMEGDAWgBTttMAlJ46XNA1ydxe5J0bVfWA3ujAPBgNVHRMBAf8EBTAD\nAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQCSQH9T7rWS11DHLvPXuwRx2F675y5bNZ7L\n4q0akgdQwH3T4RNRS0yQbcNPqOsiEwypsV45kEjzniBqNcHcfxld1Ik1zcv9wvvK\nZE9HfrZbaVRzIR7GPmIzjhdepBK8gPvQoqIHVLM6WTY5/2voGOUPB7NLjDtvVpFN\nGG3KpNjC6msfywWTCAAB3oNSHeQsy01DD6FSQHGjBZZiXo7P7MOFz/D5+z61OBy0\nUiCGi08UjVAodMTfTHNxGZW9D2yLzuKLfewbtcbeje2MACiXLDuIS+ed8YgXn7UH\n2SNfx1DhsSGueWgEMISsqJUMgU02IrTu3VViSE7eXoRQkLEdeiGI\n-----END CERTIFICATE-----\n)EOF\";\n \nvoid setup() {\n  Serial.begin(9600);\n  Serial.println();\n \n  // 连接 WiFi\n  Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, pass);\n \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n \n  Serial.println(\"WiFi connected\");\n  Serial.println(\"IP address: \");\n  Serial.println(WiFi.localIP());\n \n  // 建立X509List对象用于处理及储存服务器证书\n  X509List *serverCertList = new BearSSL::X509List(server_cert);\n  \n  // 建立PrivateKey对象用于处理及储存服务器私钥\n  PrivateKey *serverPrivKey = new BearSSL::PrivateKey(server_private_key);\n \n  // 设置服务器证书和服务器私钥\n  server.setRSACert(serverCertList, serverPrivKey);\n \n  // 启动服务器\n  server.begin();\n}\n \nvoid loop() {\n  static int cnt;\n  BearSSL::WiFiClientSecure incoming = server.available();\n  if (!incoming) {\n    return;\n  }\n  Serial.printf(\"Incoming connection...%d\\n\",cnt++);\n  \n  // 等待客户端发送请求\n  uint32_t timeout=millis() + 1000;\n  int lcwn = 0;\n  for (;;) {\n    unsigned char x=0;\n    if ((millis() > timeout) || (incoming.available() && incoming.read(&x, 1) < 0)) {\n      incoming.stop();\n      Serial.printf(\"Connection error, closed\\n\");\n      return;\n    } else if (!x) {\n      yield();\n      continue;\n    } else if (x == 0x0D) {\n      continue;\n    } else if (x == 0x0A) {\n      if (lcwn) {\n        break;\n      }\n      lcwn = 1;\n    } else\n      lcwn = 0;\n  }\n  // 发送响应信息\n  incoming.write((uint8_t*)HTTP_RES, strlen(HTTP_RES));\n  incoming.flush();\n  incoming.stop();\n  Serial.printf(\"Connection closed.\\n\");\n}\n```\n\n\n\n\n\n### setRSACert – 设置RSA证书\n\n#### 说明\n\n通过WiFiServerSecure语句，我们可以建立WiFiServerSecure对象从而使用ESP8266建立支持HTTPS协议的物联网服务器。\n\n#### 语法\n\nserver.setRSACert(cert, privateKey)\n\n#### 参数\n\n– cert: 服务器证书\n– privateKey:服务器私钥\n\n#### 返回值\n\n无\n\n#### 示例程序\n\n为了演示本实例程序的运行结果，我在这里使用基于[Chrome](https://www.google.cn/chrome/index.html)内核的[Microsoft Edge](https://www.microsoft.com/zh-cn/edge)浏览器来进行示例程序操作演示。\n\n请务必注意：本示例程序所使用的证书和密钥只能用于测试使用。您在自己搭建ESP8266物联网项目时，需要自行建立 证书密钥而不要使用本示例中的证书和密钥。\n\n当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址。此时，ESP8266已经成功建立了支持HTTPS协议的网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。\n\n假设您的ESP8266开发板IP地址是192.168.0.111。那么接下来您可以通过浏览器输入**https://192.168.0.111**。\n\n注意一定要在ESP8266的IP地址前面加上“https//”。这一操作将会让浏览器通过https协议访问ESP8266所建立的服务器。如果不输入这一信息，浏览器默认会使用http协议而不是https协议。也就达不到我们想要实现的效果。（如下图所示）\n\n![image-20230527163646482](./Image/ESP8266.assets/image-20230527163646482.png)\n\n当您如上图所示输入完IP地址后，接下来 请按下回车键。您将在浏览器中看到如下警告信息 。这很正常，因为ESP8266的服务器证书不是CA颁布的证书，所以浏览器会警告我们，它无法确定ESP8266服务器的身份信息。请忽略这一警告信息，并按照下图所示，点击按钮。\n\n![image-20230527163729688](./Image/ESP8266.assets/image-20230527163729688.png)\n\n接下来您将看到如下图所示的信息。该信息正是详细说明为何无法验证ESP8266服务器身份的原因。我们需要继续忽略 这一警告信息，并按照下图所示，点击链接。\n\n![image-20230527163750171](./Image/ESP8266.assets/image-20230527163750171.png)\n\n如下图所示，您将看到浏览器中出现了“Hello from ESP8266”信息。这一信息是由ESP8266服务器发来的。说明我们的ESP8266服务器已经可以通过HTTPS协议进行数据通讯了。\n\n![image-20230527163806556](./Image/ESP8266.assets/image-20230527163806556.png)\n\n以下示例程序中我们首先使用语句 `X509List *serverCertList = new BearSSL::X509List(server_cert);`建立X509List对象用于处理及储存服务器证书。接下来我们使用了语句`PrivateKey *serverPrivKey = new BearSSL::PrivateKey(server_private_key);`建立PrivateKey对象用于处理及储存服务器私钥。最后我们使用语句`server.setRSACert(serverCertList, serverPrivKey);`设置服务器证书和服务器私钥。具体使用方法，请见以下程序的高亮部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : WiFiServerSecure_setRSACert\n程序目的/Purpose          : \n此程序用于演示如何使用使用WiFiServerSecure库的setRSACert来为服务器设置证书和私钥。\n \n本示例程序借鉴ESP8266库中BearSSL_Server示例程序，该程序作者Earle F. Philhower, III\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <time.h>\n \n// WiFi连接信息\nconst char *ssid = \"taichimaker\";// WiFi名称\nconst char *pass = \"12345678\";   // WiFi密码\n \n// 建立WiFiServerSecure对象\nWiFiServerSecure server(443);\n \n// 建立服务器响应信息\nstatic const char *HTTP_RES =\n        \"HTTP/1.0 200 OK\\r\\n\"\n        \"Connection: close\\r\\n\"\n        \"Content-Length: 62\\r\\n\"\n        \"Content-Type: text/html; charset=iso-8859-1\\r\\n\"\n        \"\\r\\n\"\n        \"<html>\\r\\n\"\n        \"<body>\\r\\n\"\n        \"<p>Hello from ESP8266!</p>\\r\\n\"\n        \"</body>\\r\\n\"\n        \"</html>\\r\\n\";\n \n//服务器私钥\nconst char server_private_key[] PROGMEM = R\"EOF(\n-----BEGIN PRIVATE KEY-----\nMIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQDhDf/pokuS+FQO\nMPxiDTPMDZEFQjFoy/uCwiN4MebPg+IcXMVx2o6MSn8x9ofAatwAOq/dYoExhev1\nHN2C3O4ZjjFACsryL6hYXaKG+qHiNEfvHgPTw0olWsDm9N01CcQs7lJqW2wmM5JM\nxXP8ZU0rcUU70qWCUUTR+rN8WE4QHTd7BjP6OTvqjN7Al4ibg8//7owXlSECnM1B\nSKIZQZ6g0QcWLf+rSn6hRrbHPGIkp5RZTIGZ7k9zgUfHQezKKYtRZXRtUhB5JW78\nZyGYaphaek5WlkgakL2pbM/Q/DgKew/2k0najKUjmkz+gxtof4vlmZAojSaN2647\nlabAbuydAgMBAAECggEAYHi806zDUpvqhC7RcUKRio3iNWvbfD28cZ/AzpwtgZTa\nDyhhZt22L0Mb5RH1vTDRX7PIgVDhapYqwGaAOcF0uzWtvPMjbc+qDT8OFWhIjou0\nrjaik1rqZLrTZ+1dCYhHNK9wWrEX2gRPWWNmxbGy88VZVTyFwCgQJSafW9UKmXLu\n4KUTILHcyGsEfVBxth8Vr9uWuNWa6nRW/tb/3uNwRn1ATKV6h+HFgBHxgfkSN11G\nwZfdSRzuov7Y09qGbIHZmeoBYG8iNJ/A4qOhaMJis1Qmt6mjpBzUJRxGriZIHh2E\nznoM85Uejc8cqSnWH8mA8PPT4xDwCbv2ueT9bT5HYQKBgQD25qFyjx+Bbzsbok2a\nlF7wQiN5WbzA5zdCusecTO+Fi2HkrKODFSQdaCHxl/kFKcy7NxYZjeIcNZzf6vnC\nB2Hyrm3B/eeCJ+WoTm/ajfS6dxgt2aO48An+wFAyb7qGdBBrPr+hvn3RG5hbupEM\nbGJnBhRfpcq0+9+JcqMfcAUkuQKBgQDpWUMtfuukR+hwkHhbs68FyXbGxnHMGYth\nsLRWmbmK6OVmSKWDU5kRPlMckztqUReJdE+x6fbvBDbW/cIi83mQa0+7KTxLajoj\nzoCV6CKZz4dATURlisTtfqVCjQP/wHJ4y6E270Ar80CM/0AT8gw+HrWGLeCa+MQN\nL0Qg/u5dBQKBgDAsUaXbfQcxH7RFl6SofFmeXfOIacatll+jt9ysOjOxPVlzwbeK\nwXAnaDAOOd0jCbohhmNYBp0AbOpXm4GbFSZXmDy4gJoplKqhGzvmZLCZGhOgGky0\nMQ8OkNc2a4teS/HQ3Wz+kOfi3XhQT4q//vcg/Yqn+4QSfMwBnQg+QBKpAoGAdUch\nljoV4Ikrb3eMpjoWmwf4JEsUYonsHXscB/JW6FPJB7E3TluzsJDsYI427GY5OCI2\n86otK0+o6EC9U6eez1C/z8cXwKdw9RISWkVDLp640T6EQ6yM8PgXwuzwt5dXcRKW\nwe9ZBz3IkZSv9dZPBOGWRgvEuN6SWjYJPbQixKkCgYA+plfKhE+f+ofA7wWkmfo3\n1cyJmyBCL9ROwfzRlo1ftttYy1XHOLxpe2ts+hh+pqrftGdura1X0TuY6v7d1mk1\nsnuyj7+E37PjIewk4nr45PU4OWwqW2Pqx4BZAYosU+ki1z12rh3ofZhudBH6B5nN\nTPhoHwGbAajgSzHYYG8koQ==\n-----END PRIVATE KEY-----\n)EOF\";\n \n// 服务器证书\nconst char server_cert[] PROGMEM = R\"EOF(\n-----BEGIN CERTIFICATE-----\nMIIEQzCCAyugAwIBAgIUCUSExaDX4tk9VoMXia7kABA2pewwDQYJKoZIhvcNAQEL\nBQAwgbAxCzAJBgNVBAYTAkNOMRAwDgYDVQQIDAdCZWlqaW5nMRAwDgYDVQQHDAdC\nZWlqaW5nMRUwEwYDVQQKDAxUYWljaGktTWFrZXIxDDAKBgNVBAsMA0lPVDEQMA4G\nA1UEAwwHRVNQODI2NjFGMEQGCSqGSIb3DQEJARY3dGFpY2hpYW1rZXJAG1tEG1tE\nG1tEGxtbQxsbW0MbW0MbW0MbdGFpY2hpbWFrZXJAMTYzLmNvbTAeFw0yMDA0MjAx\nMDQ3MjNaFw0zMTA3MDgxMDQ3MjNaMIGwMQswCQYDVQQGEwJDTjEQMA4GA1UECAwH\nQmVpamluZzEQMA4GA1UEBwwHQmVpamluZzEVMBMGA1UECgwMVGFpY2hpLU1ha2Vy\nMQwwCgYDVQQLDANJT1QxEDAOBgNVBAMMB0VTUDgyNjYxRjBEBgkqhkiG9w0BCQEW\nN3RhaWNoaWFta2VyQBtbRBtbRBtbRBsbW0MbG1tDG1tDG1tDG3RhaWNoaW1ha2Vy\nQDE2My5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDhDf/pokuS\n+FQOMPxiDTPMDZEFQjFoy/uCwiN4MebPg+IcXMVx2o6MSn8x9ofAatwAOq/dYoEx\nhev1HN2C3O4ZjjFACsryL6hYXaKG+qHiNEfvHgPTw0olWsDm9N01CcQs7lJqW2wm\nM5JMxXP8ZU0rcUU70qWCUUTR+rN8WE4QHTd7BjP6OTvqjN7Al4ibg8//7owXlSEC\nnM1BSKIZQZ6g0QcWLf+rSn6hRrbHPGIkp5RZTIGZ7k9zgUfHQezKKYtRZXRtUhB5\nJW78ZyGYaphaek5WlkgakL2pbM/Q/DgKew/2k0najKUjmkz+gxtof4vlmZAojSaN\n2647labAbuydAgMBAAGjUzBRMB0GA1UdDgQWBBTttMAlJ46XNA1ydxe5J0bVfWA3\nujAfBgNVHSMEGDAWgBTttMAlJ46XNA1ydxe5J0bVfWA3ujAPBgNVHRMBAf8EBTAD\nAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQCSQH9T7rWS11DHLvPXuwRx2F675y5bNZ7L\n4q0akgdQwH3T4RNRS0yQbcNPqOsiEwypsV45kEjzniBqNcHcfxld1Ik1zcv9wvvK\nZE9HfrZbaVRzIR7GPmIzjhdepBK8gPvQoqIHVLM6WTY5/2voGOUPB7NLjDtvVpFN\nGG3KpNjC6msfywWTCAAB3oNSHeQsy01DD6FSQHGjBZZiXo7P7MOFz/D5+z61OBy0\nUiCGi08UjVAodMTfTHNxGZW9D2yLzuKLfewbtcbeje2MACiXLDuIS+ed8YgXn7UH\n2SNfx1DhsSGueWgEMISsqJUMgU02IrTu3VViSE7eXoRQkLEdeiGI\n-----END CERTIFICATE-----\n)EOF\";\n \nvoid setup() {\n  Serial.begin(9600);\n  Serial.println();\n \n  // 连接 WiFi\n  Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, pass);\n \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n \n  Serial.println(\"WiFi connected\");\n  Serial.println(\"IP address: \");\n  Serial.println(WiFi.localIP());\n \n  // 建立X509List对象用于处理及储存服务器证书\n  X509List *serverCertList = new BearSSL::X509List(server_cert);\n  \n  // 建立PrivateKey对象用于处理及储存服务器私钥\n  PrivateKey *serverPrivKey = new BearSSL::PrivateKey(server_private_key);\n \n  // 设置服务器证书和服务器私钥\n  server.setRSACert(serverCertList, serverPrivKey);\n \n  // 启动服务器\n  server.begin();\n}\n \nvoid loop() {\n  static int cnt;\n  BearSSL::WiFiClientSecure incoming = server.available();\n  if (!incoming) {\n    return;\n  }\n  Serial.printf(\"Incoming connection...%d\\n\",cnt++);\n  \n  // 等待客户端发送请求\n  uint32_t timeout=millis() + 1000;\n  int lcwn = 0;\n  for (;;) {\n    unsigned char x=0;\n    if ((millis() > timeout) || (incoming.available() && incoming.read(&x, 1) < 0)) {\n      incoming.stop();\n      Serial.printf(\"Connection error, closed\\n\");\n      return;\n    } else if (!x) {\n      yield();\n      continue;\n    } else if (x == 0x0D) {\n      continue;\n    } else if (x == 0x0A) {\n      if (lcwn) {\n        break;\n      }\n      lcwn = 1;\n    } else\n      lcwn = 0;\n  }\n  // 发送响应信息\n  incoming.write((uint8_t*)HTTP_RES, strlen(HTTP_RES));\n  incoming.flush();\n  incoming.stop();\n  Serial.printf(\"Connection closed.\\n\");\n}\n```\n\n\n\n\n\n\n\n\n\n### setClientTrustAnchor – 设置信任锚\n\n#### 说明\n\nESP8266建立的HTTPS服务器可以要求客户端提供证书以验证客户端身份。如果客户端无法提供证明身份的证书信息，ESP8266服务器会拒绝客户端访问。我们可以使用WiFiServerSecure库的setClientTrustAnchor函数来实现这一操作。\n\n#### 语法\n\n`server.setClientTrustAnchor(cert)`\n\n#### 参数\n\n– cert: CA证书\n\n#### 返回值\n\n无\n\n#### 示例程序\n\n请务必注意：本示例程序所使用的证书和密钥只能用于测试使用。您在自己搭建ESP8266物联网项目时，需要自行建立 证书密钥而不要使用本示例中的证书和密钥。\n\n测试使用本示例程序需要使用wget指令。建议您在测试本示例程序以前先准备好一台Linux系统电脑。\n\n接下来请点击以下链接，将用于客户端身份认证的证书和密钥文件下载并解压缩到您的Linux电脑中。\n\n[client_files](http://www.taichi-maker.com/wp-content/uploads/2020/04/client_files.zip)\n\n当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址。此时，ESP8266已经成功建立了支持HTTPS协议的网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。\n\n假设您的ESP8266开发板IP地址是192.168.0.111。接下来请使用Linux电脑的终端应用输入以下指令：\n\n**wget –no-check-certificate –certificate=client1_cer.pem –private-key=client1_key.pem https://192.168.0.111**\n\n以上指令中client1_cer.pem和client1_key.pem 分别是您刚下载的客户端证书文件以及客户端私钥文件。这两个文件分别是客户端证书以及客户端私钥。他们的作用是为ESP8266服务器提供身份验证。\n\n以下截屏是该指令的运行结果。我们可以看到，客户端成功的使用了下载的证书文件和私钥文件实现了与ESP8266服务器的网络通讯。\n\n![image-20230527163957003](./Image/ESP8266.assets/image-20230527163957003.png)\n\n另外，我们从串口监视器可以看到，ESP8266服务器成功的响应了客户端请求。\n\n![image-20230527164018600](./Image/ESP8266.assets/image-20230527164018600.png)\n\n以下示例程序中我们首先使用语句 BearSSL::X509List *serverTrustedCert = new BearSSL::X509List(ca_cert);建立X509List对象用于处理及储存受信CA证书。接下来我们使用了语句server.setClientTrustAnchor(serverTrustedCert);设置受信CA证书以验证客户端身份。\n\n```c\n/*\n  程序名称/Program name     : WiFiServerSecure_setClientTrustAnchor\n  程序目的/Purpose          : \n  本示例程序借鉴ESP8266库中BearSSL_ServerClientCert示例程序，该程序作者Earle F. Philhower, III。\n \n  ESP8266 建立的HTTPS服务器可以要求客户端提供证书以验证客户端身份。如果客户端无法提供CA签署的证书或者无法\n  提供自签名证书，ESP8266服务器会拒绝客户端访问。此示例程序即是演示如何使用WiFiServerSecure库的\n  setClientTrustAnchor函数来实现这一操作。\n  \n  如需了解如何使用本示例程序，请参考以下网址：\n  http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/web-server-secure/setclienttrustanchor/\n*/\n#include <ESP8266WiFi.h>\n#include <time.h>\n \n// WiFi连接信息\nconst char *ssid = \"taichimaker\";// WiFi名称\nconst char *pass = \"12345678\";   // WiFi密码\n \n// 建立WiFiServerSecure对象\nBearSSL::WiFiServerSecure server(443);\n \n// 建立服务器响应信息\nstatic const char *HTTP_RES =\n        \"HTTP/1.0 200 OK\\r\\n\"\n        \"Connection: close\\r\\n\"\n        \"Content-Length: 59\\r\\n\"\n        \"Content-Type: text/html; charset=iso-8859-1\\r\\n\"\n        \"\\r\\n\"\n        \"<html>\\r\\n\"\n        \"<body>\\r\\n\"\n        \"<p>Hello my friend!</p>\\r\\n\"\n        \"</body>\\r\\n\"\n        \"</html>\\r\\n\";\n \n// 受信任的CA证书\nconst char ca_cert[] PROGMEM = R\"EOF(\n-----BEGIN CERTIFICATE-----\nMIIC1TCCAb2gAwIBAgIJAMPt1Ms37+hLMA0GCSqGSIb3DQEBCwUAMCExCzAJBgNV\nBAYTAlVTMRIwEAYDVQQDDAkxMjcuMC4wLjMwHhcNMTgwMzE0MDQyMTU0WhcNMjkw\nNTMxMDQyMTU0WjAhMQswCQYDVQQGEwJVUzESMBAGA1UEAwwJMTI3LjAuMC4zMIIB\nIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxsa4qU/tlzN4YTcnn/I/ffsi\njOPc8QRcwClKzasIZNFEye4uThl+LGZWFIFb8X8Dc+xmmBaWlPJbqtphgFKStpar\nDdduHSW1ud6Y1FVKxljo3UwCMrYm76Q/jNzXJvGs6Z1MDNsVZzGJaoqit2H2Hkvk\ny+7kk3YbEDlcyVsLOw0zCKL4cd2DSNDyhIZxWo2a8Qn5IdjWAYtsTnW6MvLk/ya4\nabNeRfSZwi+r37rqi9CIs++NpL5ynqkKKEMrbeLactWgHbWrZeaMyLpuUEL2GF+w\nMRaAwaj7ERwT5gFJRqYwj6bbfIdx5PC7h7ucbyp272MbrDa6WNBCMwQO222t4wID\nAQABoxAwDjAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQCmXfrC42nW\nIpL3JDkB8YlB2QUvD9JdMp98xxo33+xE69Gov0e6984F1Gluao0p6sS7KF+q3YLS\n4hjnzuGzF9GJMimIB7NMQ20yXKfKpmKJ7YugMaKTDWDhHn5679mKVbLSQxHCUMEe\ntEnMT93/UaDbWBjV6zu876q5vjPMYgDHODqO295ySaA71UkijaCn6UwKUT49286T\nV9ZtzgabNGHXfklHgUPWoShyze+G3g29I1BR0qABoJI63zaNu8ua42v5g1RldxsW\nX8yKI14mFOGxuvcygG8L2xxysW7Zq+9g+O7gW0Pm6RDYnUQmIwY83h1KFCtYCJdS\n2PgozwkkUNyP\n-----END CERTIFICATE-----\n)EOF\";\n \n// 服务器私钥\nconst char server_private_key[] PROGMEM = R\"EOF(\n-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEAsRNVTvqP++YUh8NrbXwE83xVsDqcB3F76xcXNKFDERfVd2P/\nLvyDovCcoQtT0UCRgPcxRp894EuPH/Ru6Z2Lu85sV//i7ce27tc2WRFSfuhlRxHP\nLJWHxTl1CEfXp/owkECQ4MB3pw6Ekc16iTEPiezTG+T+mQ/BkiIwcIK6CMlpR9DI\neYUTqv0f9NrUfAjdBrqlEO2gpgFvLFrkDEU2ntAIc4aPOP7yDOym/xzfy6TiG8Wo\n7nlh6M97xTZGfbEPCH9rZDjo5istym1HzF5P+COq+OTSPscjFGXoi978o6hZwa7i\nzxorg4h5a5lGnshRu2Gl+Ybfa14OwnIrv/yCswIDAQABAoIBAHxwgbsHCriTcEoY\nYx6F0VTrQ6ydA5mXfuYvS/eIfIE+pp1IgMScYEXZobjrJPQg1CA1l0NyFSHS97oV\nJPy34sMQxcLx6KABgeVHCMJ/EeJtnv7a3SUP0GIhhsVS95Lsl8RIG4hWub+EzFVK\neZqAB9N9wr4Pp3wZPodbz37B38rb1QPyMFmQOLlHjKTOmoxsXhL2ot+R3+aLYSur\noPO1kQo7/d0UAZoy8h9OQN4a2EXvawh4O2EvFGbc5X/yXwAdEQ4NPp9VZhkNIRkV\n+XZ3FcIqEVOploKtRF/tVBTz3g61/lFz21L9PMmV5y8tvSafr2SpJugGVmp2rrVQ\nVNyGlIECgYEA10JSI5gmeCU3zK6kvOfBp54hY/5dDrSUpjKkMxpmm7WZQ6Il/k7A\nhMcLeMzHiriT7WhRIXF8AOr2MoEkHkH3DhVNN4ccieVZx2SE5P5mVkItZGLrrpfU\ndysR/ARAI1HYegGUiKacZtf9SrRavU0m7fOVOiYwbFRhjyX+MyuteYkCgYEA0pbz\n4ZosetScP68uZx1sGlTfkcqLl7i15DHk3gnj6jKlfhvC2MjeLMhNDtKeUAuY7rLQ\nguZ0CCghWAv0Glh5eYdfIiPhgqFfX4P5F3Om4zQHVPYj8xHfHG4ZP7dKQTndrO1Q\nfLdGDTQLVXabAUSp2YGrijC8J9idSW1pYClvF1sCgYEAjkDn41nzYkbGP1/Swnwu\nAEWCL4Czoro32jVxScxSrugt5wJLNWp508VukWBTJhugtq3Pn9hNaJXeKbYqVkyl\npgrxwpZph7+nuxt0r5hnrO2C7eppcjIoWLB/7BorAKxf8REGReBFT7nBTBMwPBW2\nel4U6h6+tXh2GJG1Eb/1nnECgYAydVb0THOx7rWNkNUGggc/++why61M6kYy6j2T\ncj05BW+f2tkCBoctpcTI83BZb53yO8g4RS2yMqNirGKN2XspwmTqEjzbhv0KLt4F\nX4GyWOoU0nFksXiLIFpOaQWSwWG7KJWrfGJ9kWXR0Xxsfl5QLoDCuNCsn3t4d43T\nK7phlwKBgHDzF+50+/Wez3YHCy2a/HgSbHCpLQjkknvgwkOh1z7YitYBUm72HP8Z\nGe6b4wEfNuBdlZll/y9BQQOZJLFvJTE5t51X9klrkGrOb+Ftwr7eI/H5xgcadI52\ntPYglR5fjuRF/wnt3oX9JlQ2RtSbs+3naXH8JoherHaqNn8UpH0t\n-----END RSA PRIVATE KEY-----\n)EOF\";\n \n// 服务器证书\nconst char server_cert[] PROGMEM = R\"EOF(\n-----BEGIN CERTIFICATE-----\nMIIDTzCCAjcCCQDPXvMRYOpeuDANBgkqhkiG9w0BAQsFADCBpjESMBAGA1UEAwwJ\nMTI3LjAuMC4xMQswCQYDVQQGEwJVUzElMCMGA1UECgwcTXkgT3duIENlcnRpZmlj\nYXRlIEF1dGhvcml0eTEUMBIGA1UECAwLQXJkdWlub0xhbmQxFTATBgNVBAcMDEFy\nZHVpbm9WaWxsZTEVMBMGA1UECgwMRVNQODI2NlVzZXJzMRgwFgYDVQQLDA9FU1A4\nMjY2LUFyZHVpbm8wHhcNMTgwMzE0MDQwMDAwWhcNMjkwMjI0MDQwMDAwWjAsMRYw\nFAYDVQQKDA1NeSBTZXJ2ZXIgT3JnMRIwEAYDVQQDDAkxMjcuMC4wLjMwggEiMA0G\nCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCxE1VO+o/75hSHw2ttfATzfFWwOpwH\ncXvrFxc0oUMRF9V3Y/8u/IOi8JyhC1PRQJGA9zFGnz3gS48f9G7pnYu7zmxX/+Lt\nx7bu1zZZEVJ+6GVHEc8slYfFOXUIR9en+jCQQJDgwHenDoSRzXqJMQ+J7NMb5P6Z\nD8GSIjBwgroIyWlH0Mh5hROq/R/02tR8CN0GuqUQ7aCmAW8sWuQMRTae0Ahzho84\n/vIM7Kb/HN/LpOIbxajueWHoz3vFNkZ9sQ8If2tkOOjmKy3KbUfMXk/4I6r45NI+\nxyMUZeiL3vyjqFnBruLPGiuDiHlrmUaeyFG7YaX5ht9rXg7Cciu//IKzAgMBAAEw\nDQYJKoZIhvcNAQELBQADggEBAEnG+FNyNCOkBvzHiUpHHpScxZqM2f+XDcewJgeS\nL6HkYEDIZZDNnd5gduSvkHpdJtWgsvJ7dJZL40w7Ba5sxpZHPIgKJGl9hzMkG+aA\nz5GMkjys9h2xpQZx9KL3q7G6A+C0bll7ODZlwBtY07CFMykT4Mp2oMRrQKRucMSV\nAB1mKujLAnMRKJ3NM89RQJH4GYiRps9y/HvM5lh7EIK/J0/nEZeJxY5hJngskPKb\noPPdmkR97kaQnll4KNsC3owVlHVU2fMftgYkgQLzyeWgzcNa39AF3B6JlcOzNyQY\nseoK24dHmt6tWmn/sbxX7Aa6TL/4mVlFoOgcaTJyVaY/BrY=\n-----END CERTIFICATE-----\n)EOF\";\n \n// 获取网络时间，该时间信息用于证书认证\nvoid setClock()\n{\n  configTime(8 * 3600, 0, \"ntp.ntsc.ac.cn\",\"pool.ntp.org\", \"time.nist.gov\");\n \n  Serial.print(\"Waiting for NTP time sync: \");\n  time_t now = time(nullptr);\n  while (now < 8 * 3600 * 2) {\n    delay(500);\n    Serial.print(\".\");\n    now = time(nullptr);\n  }\n  Serial.println(\"\");\n  struct tm timeinfo;\n  gmtime_r(&now, &timeinfo);\n  Serial.print(\"Current time: \");\n  Serial.print(asctime(&timeinfo));\n}\n \nvoid setup() {\n  Serial.begin(9600);\n  Serial.println();\n  Serial.println();\n \n  // 连接 WiFi\n  Serial.print(\"Connecting to \");\n  Serial.println(ssid);\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, pass);\n \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n \n  Serial.println(\"WiFi connected\");\n  Serial.println(\"IP address: \");\n  Serial.println(WiFi.localIP());\n \n  setClock(); // 获取网络时间，该时间信息用于证书认证\n \n // 建立X509List对象用于处理及储存服务器证书\n  BearSSL::X509List *serverCertList = new BearSSL::X509List(server_cert);\n \n  // 建立PrivateKey对象用于处理及储存服务器私钥  \n  BearSSL::PrivateKey *serverPrivKey = new BearSSL::PrivateKey(server_private_key);\n \n  // 设置服务器证书和服务器私钥  \n  server.setRSACert(serverCertList, serverPrivKey);\n \n  // 建立X509List对象用于处理及储存受信CA证书\n  BearSSL::X509List *serverTrustedCert = new BearSSL::X509List(ca_cert);\n \n  // 设置受信CA证书以验证客户端身份\n  server.setClientTrustAnchor(serverTrustedCert);\n \n  // 启动服务器\n  server.begin();\n}\n \nvoid loop() {\n  BearSSL::WiFiClientSecure incoming = server.available();\n  if (!incoming) {\n    return;\n  }\n  Serial.println(\"Incoming connection...\\n\");\n  \n  // 等待客户端发送请求\n  uint32_t timeout=millis() + 1000;\n  int lcwn = 0;\n  for (;;) {\n    unsigned char x=0;\n    if ((millis() > timeout) || (incoming.available() && incoming.read(&x, 1) < 0)) {\n      incoming.stop();\n      Serial.printf(\"Connection error, closed\\n\");\n      return;\n    } else if (!x) {\n      yield();\n      continue;\n    } else if (x == 0x0D) {\n      continue;\n    } else if (x == 0x0A) {\n      if (lcwn) {\n        break;\n      }\n      lcwn = 1;\n    } else\n      lcwn = 0;\n  }\n  // 发送响应信息  \n  incoming.write((uint8_t*)HTTP_RES, strlen(HTTP_RES));\n  incoming.flush();\n  incoming.stop();\n  Serial.printf(\"Connection closed.\\n\");\n}\n```\n\n\n\n## ESP8266 – WiFiUDP库\n\n\n\nUDP协议是User Datagram Protocol的简称，中文名是用户数据协议。UDP协议是一种无连接的传输层协议。\n\nWiFiUDP库用于ESP8266开发板的物联网通讯控制以及UDP协议数据包处理。以下为WiFiUDP库的整体结构图。在此图下方有WiFiUDP库的函数目录。您可以通过点击目录项目打开各个函数的说明页面。\n\n**请留意，WiFiUDP对象在处理或发送UDP数据时，可以通过调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)中的函数来实现。因此在以下结构图中的“接收/处理UDP数据类型”以及“发送UDP数据类型”中有“Stream类”作为这两种类型函数的一部分。**\n\n为了方便您更好的了解ESP8266的WiFiUdp库以及本站资料中WiFiUdp库函数的示例程序操作方法，我们制作了一个较为详细的图文教程。该图文教程说明了如何利用*TCP_UDP测试工具软件*来测试ESP8266开发板的UDP协议通讯功能。\n\n![image-20230527164244447](./Image/ESP8266.assets/image-20230527164244447.png)\n\n\n\n### UDP服务控制类型\n\n#### begin – 启动UDP服务\n\n##### 说明\n\n此函数用于初始化WiFiUDP库和网络设置。执行此函数后，ESP8266将开始监听指定端口以提供UDP协议物联网通讯服务。\n\n##### 语法\n\n```\nwiFiUDP.begin(port)\n```\n\n##### 参数\n\nport：为提供UDP物联网服务而监听的端口号（类型：uint16_t）\n\n##### 返回值\n\n返回值数据类型为uint8_t 型。以下是返回数值说明：\n1：ESP8266开发板启动UDP服务成功\n\n0：ESP8266开发板启动UDP服务失败\n\n##### 示例程序\n\n以下示例程序演示如何使用ESP8266监听指定端口以提供UDP协议物联网通讯服务。关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiUdp_1\n程序目的/Purpose          : \n用于演示ESP8266WiFiUdp库中begin函数。\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <WiFiUdp.h>\n \n#define ssid      \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下WIFI名字\n#define password  \"12345678\"         //这里改成你的设备当前环境下WIFI密码\n \nWiFiUDP Udp;                         //实例化WiFiUDP对象\nunsigned int localUdpPort = 1234;    //自定义本地监听端口\n \nvoid setup()\n{\n  Serial.begin(115200); //打开串口\n  Serial.println();\n \n  Serial.printf(\"正在连接 %s \", ssid);\n  WiFi.begin(ssid, password);//连接到wifi\n  while (WiFi.status() != WL_CONNECTED)//等待连接\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"连接成功\");\n  delay(2000);\n    \n  if(Udp.begin(localUdpPort)){  //启动Udp监听服务\n    Serial.println(\"监听成功\");\n    //打印本地的ip地址，在UDP工具中会使用到\n    //WiFi.localIP().toString().c_str()用于将获取的数据转化为字符串\n    Serial.printf(\"现在收听IP：%s, UDP端口：%d\\n\", WiFi.localIP().toString().c_str(), localUdpPort);\n  }\n}\n \nvoid loop(){}\n```\n\n为了方便您更好的了解ESP8266的WiFiUdp库以及本站资料中WiFiUdp库函数的示例程序操作方法，我们制作了一个较为详细的图文教程。该图文教程说明了如何利用*TCP_UDP测试工具软件*来测试ESP8266开发板的UDP协议通讯功能。\n\n##### 相关内容\n\n– stop – 停止UDP服务\n\n\n\n\n\n#### stop – 停止UDP服务\n\n##### 说明\n\n当我们使用WiFiUdp库的[begin](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiudp/begin/)函数启动ESP8266的UDP物联网通讯服务以后，我们可以使用stop函数来停止该服务。\n\n##### 语法\n\nwiFiUDP.stop()\n\n##### 参数\n\n无\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiUdp_2\n程序目的/Purpose          : \n用于演示ESP8266WiFiUdp库中stop函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <WiFiUdp.h>\n \n#define ssid      \"TaichiMaker_WIFI\" // 这里改成你的设备当前环境下WIFI名字\n#define password  \"12345678\"         // 这里改成你的设备当前环境下WIFI密码\n \nWiFiUDP Udp;                         // 实例化WiFiUDP对象\nunsigned int localUdpPort = 1234;    // 自定义本地监听端口\n \nvoid setup()\n{\n  Serial.begin(115200);//打开串口\n  Serial.println();\n \n  Serial.printf(\"正在连接 %s \", ssid);\n  WiFi.begin(ssid, password);//连接到wifi\n  while (WiFi.status() != WL_CONNECTED)//等待连接\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"连接成功\");\n  delay(2000);\n \n  if(Udp.begin(localUdpPort)){ //启动Udp监听服务\n    Serial.println(\"监听成功\");\n    //打印本地的ip地址，在UDP工具中会使用到\n    //WiFi.localIP().toString().c_str()用于将获取的数据转化为字符串\n    Serial.printf(\"现在收听IP：%s, UDP端口：%d\\n\", WiFi.localIP().toString().c_str(), localUdpPort);\n  }else{\n    Serial.println(\"监听失败\");\n  }\n  delay(3000);\n  Udp.stop();//关闭udp监听\n  Serial.println(\"停止监听\");\n}\n \nvoid loop(){}\n```\n\n\n\n### 接收/处理UDP数据类型\n\n#### parsePacket – 解析数据\n\n##### 说明\n\n本函数用于检查是否有UDP数据包传入ESP8266开发板。同时，如果我们需要使用[stream](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/)类中的函数(如[read](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiudp/read/)、[readString](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiudp/readstring/)、[parseInt](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiudp/parseint/)、[find](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiudp/find/)等)来处理UDP数据包的话，那么我们需要先使用parsePacket，然后才能使用stream类中的函数对传入ESP8266开发板的UDP数据包进行处理。\n\n##### 语法\n\n```\nwiFiUDP.parsePacket()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n返回值数据类型为整数型，以下是函数返回值含义说明：\nn：数据包的大小（以字节为单位）\n0：没有可用的数据包\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiUdp_6\n程序目的/Purpose          : \n用于演示ESP8266WiFiUdp库中parsePacket函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <WiFiUdp.h>\n \n#define ssid      \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下WIFI名字\n#define password  \"12345678\"          //这里改成你的设备当前环境下WIFI密码\n \nWiFiUDP Udp;//实例化WiFiUDP对象\nunsigned int localUdpPort = 1234;  // 自定义本地监听端口\nunsigned int remoteUdpPort = 4321;  // 自定义远程监听端口\nchar incomingPacket[255];  // 保存Udp工具发过来的消息\nchar  replyPacket[] = \"Hi, this is esp8266\\n\";  //发送的消息,仅支持英文\n \nvoid setup()\n{\n  Serial.begin(115200);//打开串口\n  Serial.println();\n \n  Serial.printf(\"正在连接 %s \", ssid);\n  WiFi.begin(ssid, password);//连接到wifi\n  while (WiFi.status() != WL_CONNECTED)//等待连接\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"连接成功\");\n \n  if(Udp.begin(localUdpPort)){//启动Udp监听服务\n    Serial.println(\"监听成功\");\n    //打印本地的ip地址，在UDP工具中会使用到\n    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串    \n    Serial.printf(\"现在收听IP：%s, UDP端口：%d\\n\", WiFi.localIP().toString().c_str(), localUdpPort);\n  }else{\n    Serial.println(\"监听失败\");\n  }\n}\n \nvoid loop()\n{\n  //解析Udp数据包\n  int packetSize = Udp.parsePacket();//获得解析包\n  if (packetSize)//解析包不为空\n  {\n    //收到Udp数据包\n    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串\n    Serial.printf(\"收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\\n\", Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);\n      \n    // 读取Udp数据包并存放在incomingPacket\n    int len = Udp.read(incomingPacket, 255);//返回数据包字节数\n    if (len > 0)\n    { \n      incomingPacket[len] = 0;//清空缓存\n    }\n    //向串口打印信息\n    Serial.printf(\"UDP数据包内容为: %s\\n\", incomingPacket);\n \n    //向udp工具发送消息\n    Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口\n    Udp.write(replyPacket);//把数据写入发送缓冲区\n    Udp.endPacket();//发送数据\n  }\n}\n```\n\n以下是该程序的运行结果。\n\n![image-20230527164725405](./Image/ESP8266.assets/image-20230527164725405.png)\n\n\n\n##### 相关内容\n\n– available(Stream类) – 检查是否有数据被接收\n– read(Stream类) – 读取UDP数据\n– readString(Stream类) – 读取UDP字符串\n– parseInt(Stream类) – 解析UDP数据中整数\n– find(Stream类) – 在UDP数据中查找信息\n– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。\n\n#### available(Stream类) – 检查是否有数据被接收\n\n##### 说明\n\n本函数可用于检查设备是否接收到数据。函数将会返回等待读取的数据字节数。**请注意，使用本函数以前需要先调用[parsePacket](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiudp/parsepacket/)函数。**\n\nWiFiUDP类对象可调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/available/)函数。available函数就是属于Stream类的。\n\n##### 语法\n\nwiFiUDP.available()\n\n##### 参数\n\n无\n\n##### 返回值\n\n等待读取的数据字节数。\n返回值数据类型：int\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiUdp_8\n程序目的/Purpose          : \n用于演示ESP8266WiFiUdp库中available函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <WiFiUdp.h>\n \n#define ssid      \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下WIFI名字\n#define password  \"12345678\"         //这里改成你的设备当前环境下WIFI密码\n \nWiFiUDP Udp;//实例化WiFiUDP对象\nunsigned int localUdpPort = 1234;  // 自定义本地监听端口\n \nvoid setup()\n{\n  Serial.begin(115200);//打开串口\n  Serial.println();\n \n  Serial.printf(\"正在连接 %s \", ssid);\n  WiFi.begin(ssid, password);//连接到wifi\n  while (WiFi.status() != WL_CONNECTED)//等待连接\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"连接成功\");\n \n  if(Udp.begin(localUdpPort)){//启动Udp监听服务\n    Serial.println(\"监听成功\");\n    //打印本地的ip地址，在UDP工具中会使用到\n    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串  \n    Serial.printf(\"现在收听IP：%s, UDP端口：%d\\n\", WiFi.localIP().toString().c_str(), localUdpPort);\n  }else{\n    Serial.println(\"监听失败\");\n  }\n}\n \nvoid loop()\n{\n  int packetSize = Udp.parsePacket();//获得解析包\n  Serial.printf(\"当前UDP解析包字节数: %d\\n\", packetSize);\n  int n = Udp.available();\n  Serial.printf(\"当前UDP缓冲区字节数: %d\\n\", n);\n  delay(3000);\n}\n```\n\n![image-20230527164817681](./Image/ESP8266.assets/image-20230527164817681.png)\n\n\n\n##### 相关内容\n\n接收/处理UDP数据类型\n– parsePacket – 解析数据\n– read(Stream类) – 读取UDP数据\n– readString(Stream类) – 读取UDP字符串\n– parseInt(Stream类) – 解析UDP数据中整数\n– find(Stream类) – 在UDP数据中查找信息\n– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。\n\n\n\n\n\n\n\n#### read(Stream类) – 读取UDP数据\n\n##### 说明\n\n本函数可用于从设备接收到数据中读取数据。函数将会返回等待读取的数据字节数。**请注意，使用本函数以前需要先调用[parsePacket](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiudp/parsepacket/)函数。**\n\nWiFiUDP类对象可调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/available/)函数。本函数就是属于Stream类的。\n\n##### 语法\n\nWiFiUDP.read()\nWiFiUDP.read(buffer, len)\n\n##### 参数\n\nbuffer：保存传入数据包的内存指针，数据类型为unsigned char*\nlen：传入数据包的大小（单位是字节），数据类型为size_t\n\n##### 返回值\n\n返回值类型为整数型。\n\n在没有使用任何参数的情况下调用此函数，函数的返回值情况如下所述:\n设备没有接收到数据时，返回值为-1\n设备接收到数据时，返回值为接收到的数据包中的第1个字符的[ASCII码数值](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/ascii-code-table/)。\n\n在使用了参数buffer和len调用此函数，函数的返回值情况如下所述:\n设备没有接收到数据时，返回值为-1\n设备接收到数据时，返回值为接收到的数据包的大小（单位是字节）。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiUdp_10\n程序目的/Purpose          : \n用于演示ESP8266WiFiUdp库中read函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <WiFiUdp.h>\n \n#define ssid      \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下WIFI名字\n#define password  \"xxxxxxx\"          //这里改成你的设备当前环境下WIFI密码\n \nWiFiUDP Udp;//实例化WiFiUDP对象\nunsigned int localUdpPort = 1234;  // 自定义本地监听端口\n \nvoid setup()\n{\n  Serial.begin(115200);//打开串口\n  Serial.println();\n \n  Serial.printf(\"正在连接 %s \", ssid);\n  WiFi.begin(ssid, password);//连接到wifi\n  while (WiFi.status() != WL_CONNECTED)//等待连接\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"连接成功\");\n \n  if(Udp.begin(localUdpPort)){//启动Udp监听服务\n    Serial.println(\"监听成功\");\n    //打印本地的ip地址，在UDP工具中会使用到\n    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串   \n    Serial.printf(\"现在收听IP：%s, UDP端口：%d\\n\", WiFi.localIP().toString().c_str(), localUdpPort);\n  }else{\n    Serial.println(\"监听失败\");\n  }\n}\n \nvoid loop()\n{\n  int packetSize = Udp.parsePacket();//获得解析包\n  Serial.printf(\"当前UDP解析包字节数: %d\\n\", packetSize);\n  if(Udp.available()){//判断是否有UDP数据包\n    char a = Udp.read();//连续调用read\n    Serial.printf(\"READ: %c\\n\", a);\n    a = Udp.read();\n    Serial.printf(\"READ: %c\\n\", a);\n    a = Udp.read();\n    Serial.printf(\"READ: %c\\n\", a);\n    a = Udp.read();\n    Serial.printf(\"READ: %c\\n\", a);\n    char incomingPacket[255];  // 存储Udp客户端发过来的数据\n    int len = Udp.read(incomingPacket, 255);\n    Serial.printf(\"READ: %s   len：%d\\n\", incomingPacket, len);\n  }\n  delay(3000);\n}\n```\n\n程序运行结果：\n\n![image-20230527165035499](./Image/ESP8266.assets/image-20230527165035499.png)\n\n##### 相关内容\n\n接收/处理UDP数据类型\n– parsePacket – 解析数据\n– available(Stream类) – 检查是否有数据被接收\n– readString(Stream类) – 读取UDP字符串\n– parseInt(Stream类) – 解析UDP数据中整数\n– find(Stream类) – 在UDP数据中查找信息\n– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。\n\n\n\n#### readString(Stream类) – 读取UDP字符串\n\n##### 说明\n\n本函数可用于从设备接收到数据中读取数据信息。读取到的信息将以字符串格式返回。**请注意，使用本函数以前需要先调用[parsePacket](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiudp/parsepacket/)函数。**\n\nWiFiUDP类对象可调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/available/)函数。本函数就是属于Stream类的。\n\n##### 语法\n\n```\nwiFiUDP.readString()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n接收到的数据，类型为字符串。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiUdp_10\n程序目的/Purpose          : \n用于演示ESP8266WiFiUdp库中readString函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <WiFiUdp.h>\n \n#define ssid      \"TaichiMaker_WIFI\" // 这里改成你的设备当前环境下WIFI名字\n#define password  \"12345678\"         // 这里改成你的设备当前环境下WIFI密码\n \nWiFiUDP Udp;//实例化WiFiUDP对象\nunsigned int localUdpPort = 1234;  // 自定义本地监听端口\nunsigned int remoteUdpPort = 4321;  // 自定义远程监听端口\nchar  replyPacket[] = \"Hi, this is esp8266\\n\";  //发送的消息,仅支持英文\n \nvoid setup()\n{\n  Serial.begin(115200);//打开串口\n  Serial.println();\n \n  Serial.printf(\"正在连接 %s \", ssid);\n  WiFi.begin(ssid, password);//连接到wifi\n  while (WiFi.status() != WL_CONNECTED)//等待连接\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"连接成功\");\n \n  if(Udp.begin(localUdpPort)){//启动Udp监听服务\n    Serial.println(\"监听成功\");\n    //打印本地的ip地址，在UDP工具中会使用到\n    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串   \n    Serial.printf(\"现在收听IP：%s, UDP端口：%d\\n\", WiFi.localIP().toString().c_str(), localUdpPort);\n  }else{\n    Serial.println(\"监听失败\");\n  }\n}\n \nvoid loop()\n{\n  //解析Udp数据包\n  int packetSize = Udp.parsePacket();//获得解析包\n  if (packetSize)//解析包不为空\n  {\n    //收到Udp数据包\n    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串\n    Serial.printf(\"收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\\n\", Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);\n      \n    // 解析UDP数据包中的所以数据，以字符串格式返回\n    String udpStringVal = Udp.readString(); \n    \n    // 然后向串口打印返回的字符串\n    Serial.print(\"开发板接收到UDP数据中的字符串 \"); Serial.println(udpStringVal);\n \n    //向udp工具发送消息\n    Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口\n    Udp.write(replyPacket);//把数据写入发送缓冲区\n    Udp.endPacket();//发送数据\n  }\n}\n```\n\n##### 相关内容\n\n接收/处理UDP数据类型\n– parsePacket – 解析数据\n– available(Stream类) – 检查是否有数据被接收\n– read(Stream类) – 读取UDP数据\n– parseInt(Stream类) – 解析UDP数据中整数\n– find(Stream类) – 在UDP数据中查找信息\n– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。\n\n\n\n\n\n\n\n#### parseInt(Stream类) – 解析UDP数据中整数\n\n##### 说明\n\n本函数可用于从设备接收到的数据中寻找整数数值。读取到的信息将以字符串格式返回。**请注意，使用本函数以前需要先调用[parsePacket](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiudp/parsepacket/)函数。**\n\nWiFiUDP类对象可调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/available/)函数。本函数就是属于Stream类的。\n\n##### 语法\n\n```\nWiFiUDP.parseInt()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n在接收信息中找到的整数数值。类型：long\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiUdp_10\n程序目的/Purpose          : \n用于演示ESP8266WiFiUdp库中parseInt函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <WiFiUdp.h>\n \n#define ssid      \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下WIFI名字\n#define password  \"xxxxxxx\"          //这里改成你的设备当前环境下WIFI密码\n \nWiFiUDP Udp;//实例化WiFiUDP对象\nunsigned int localUdpPort = 1234;  // 自定义本地监听端口\nunsigned int remoteUdpPort = 4321;  // 自定义远程监听端口\nchar  replyPacket[] = \"Hi, this is esp8266\\n\";  //发送的消息,仅支持英文\n \nvoid setup()\n{\n  Serial.begin(115200);//打开串口\n  Serial.println();\n \n  Serial.printf(\"正在连接 %s \", ssid);\n  WiFi.begin(ssid, password);//连接到wifi\n  while (WiFi.status() != WL_CONNECTED)//等待连接\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"连接成功\");\n \n  if(Udp.begin(localUdpPort)){//启动Udp监听服务\n    Serial.println(\"监听成功\");\n    //打印本地的ip地址，在UDP工具中会使用到\n    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串    \n    Serial.printf(\"现在收听IP：%s, UDP端口：%d\\n\", WiFi.localIP().toString().c_str(), localUdpPort);\n  }else{\n    Serial.println(\"监听失败\");\n  }\n}\n \nvoid loop()\n{\n  //解析Udp数据包\n  int packetSize = Udp.parsePacket();//获得解析包\n  if (packetSize)//解析包不为空\n  {\n    //收到Udp数据包\n    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串\n    Serial.printf(\"收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\\n\", Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);\n      \n    // 解析UDP数据包中的整数\n    int udpIntVal = Udp.parseInt(); \n    \n    // 然后向串口打印UDP数据包中的整数\n    Serial.print(\"开发板接收到UDP数据中的整数数值\"); Serial.println(udpIntVal);\n \n    //向udp工具发送消息\n    Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口\n    Udp.write(replyPacket);//把数据写入发送缓冲区\n    Udp.endPacket();//发送数据\n  }\n}\n```\n\n\n\n##### 相关内容\n\n接收/处理UDP数据类型\n– parsePacket – 解析数据\n– available(Stream类) – 检查是否有数据被接收\n– read(Stream类) – 读取UDP数据\n– readString(Stream类) – 读取UDP字符串\n– find(Stream类) – 在UDP数据中查找信息\n– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。\n\n\n\n#### find(Stream类) – 在UDP数据中查找信息\n\n##### 说明\n\n本函数可用于从设备接收到的数据中寻找指定字符串信息。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。**请注意，使用本函数以前需要先调用[parsePacket](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiudp/parsepacket/)函数。**\n\nWiFiUDP类对象可调用[Stream类](http://www.taichi-maker.com/homepage/reference-index/arduino-code-reference/stream/available/)函数。本函数就是属于Stream类的。\n\n##### 语法\n\n```\nwiFiUDP.find(target)\n```\n\n##### 参数\n\ntarget: 被查找字符串。允许使用String或char类型。\n\n##### 返回值\n\n返回值类型为bool。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n项目名称/Project          : 零基础入门学用物联网\n程序名称/Program name     : ESP8266WiFiUdp_10\n团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)\n作者/Author              : 小凯\n日期/Date（YYYYMMDD）     : 20200319\n程序目的/Purpose          : \n用于演示ESP8266WiFiUdp库中find函数\n-----------------------------------------------------------------------\n本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。\n该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：\nhttp://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <WiFiUdp.h>\n \n#define ssid      \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下WIFI名字\n#define password  \"12345678\"         //这里改成你的设备当前环境下WIFI密码\n \nWiFiUDP Udp;//实例化WiFiUDP对象\nunsigned int localUdpPort = 1234;  // 自定义本地监听端口\nunsigned int remoteUdpPort = 4321;  // 自定义远程监听端口\nchar  replyPacket[] = \"Hi, this is esp8266\\n\";  //发送的消息,仅支持英文\n \nvoid setup()\n{\n  Serial.begin(115200);//打开串口\n  Serial.println();\n \n  Serial.printf(\"正在连接 %s \", ssid);\n  WiFi.begin(ssid, password);//连接到wifi\n  while (WiFi.status() != WL_CONNECTED)//等待连接\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"连接成功\");\n \n  if(Udp.begin(localUdpPort)){//启动Udp监听服务\n    Serial.println(\"监听成功\");\n    //打印本地的ip地址，在UDP工具中会使用到\n    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串    \n    Serial.printf(\"现在收听IP：%s, UDP端口：%d\\n\", WiFi.localIP().toString().c_str(), localUdpPort);\n  }else{\n    Serial.println(\"监听失败\");\n  }\n}\n \nvoid loop()\n{\n  //解析Udp数据包\n  int packetSize = Udp.parsePacket();//获得解析包\n  if (packetSize)//解析包不为空\n  {\n    //收到Udp数据包\n    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串\n    Serial.printf(\"收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\\n\", Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);\n \n    // 使用find函数来查看用户输入信息中是否包含^_^\n    if(Udp.find(\"^_^\")) {\n      Serial.println(\"用户输入信息中含有 ^_^\"); \n    } else {\n      Serial.println(\"用户输入信息中不含有 ^_^\"); \n    }  \n    \n    //向udp工具发送消息\n    Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口\n    Udp.write(replyPacket);//把数据写入发送缓冲区\n    Udp.endPacket();//发送数据\n  }\n}\n```\n\n##### 相关内容\n\n接收/处理UDP数据类型\n– parsePacket – 解析数据\n– available(Stream类) – 检查是否有数据被接收\n– read(Stream类) – 读取UDP数据\n– readString(Stream类) – 读取UDP字符串\n– parseInt(Stream类) – 解析UDP数据中整数\n– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。\n\n\n\n\n\n\n\n### 发送UDP数据类型\n\n#### beginPacket – 配置UDP数据包接收设备的IP和端口\n\n##### 说明\n\n此函数用于ESP8266开发板的UDP数据发送准备。其具体功能是设置UDP数据接收设备的IP地址和端口号。\n\n##### 语法\n\n```\nwiFiUDP.beginPacket(ip,port)\n```\n\n##### 参数\n\nip：UDP数据接收设备的IP地址（IPAddress类型）\nport：UDP数据接收设备的IP地址监听端口号（uint16_t类型）\n\n##### 返回值\n\n返回值数据类型为整数型\n1：配置数据接收设备的IP地址和监听端口号成功\n0：配置数据接收设备的IP地址和监听端口号失败\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiUdp_6\n程序目的/Purpose          : \n用于演示ESP8266WiFiUdp库中beginPacket函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <WiFiUdp.h>\n \n#define ssid      \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下WIFI名字\n#define password  \"xxxxxxx\"          //这里改成你的设备当前环境下WIFI密码\n \nWiFiUDP Udp;//实例化WiFiUDP对象\nunsigned int localUdpPort = 1234;  // 自定义本地监听端口\nunsigned int remoteUdpPort = 4321;  // 自定义远程监听端口\nchar incomingPacket[255];  // 保存Udp工具发过来的消息\nchar  replyPacket[] = \"Hi, this is esp8266\\n\";  //发送的消息,仅支持英文\n \nvoid setup()\n{\n  Serial.begin(115200);//打开串口\n  Serial.println();\n \n  Serial.printf(\"正在连接 %s \", ssid);\n  WiFi.begin(ssid, password);//连接到wifi\n  while (WiFi.status() != WL_CONNECTED)//等待连接\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"连接成功\");\n \n  if(Udp.begin(localUdpPort)){//启动Udp监听服务\n    Serial.println(\"监听成功\");\n    //打印本地的ip地址，在UDP工具中会使用到\n    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串    \n    Serial.printf(\"现在收听IP：%s, UDP端口：%d\\n\", WiFi.localIP().toString().c_str(), localUdpPort);\n  }else{\n    Serial.println(\"监听失败\");\n  }\n}\n \nvoid loop()\n{\n  //解析Udp数据包\n  int packetSize = Udp.parsePacket();//获得解析包\n  if (packetSize)//解析包不为空\n  {\n    //收到Udp数据包\n    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串\n    Serial.printf(\"收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\\n\", Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);\n      \n    // 读取Udp数据包并存放在incomingPacket\n    int len = Udp.read(incomingPacket, 255);//返回数据包字节数\n    if (len > 0)\n    { \n      incomingPacket[len] = 0;//清空缓存\n    }\n    //向串口打印信息\n    Serial.printf(\"UDP数据包内容为: %s\\n\", incomingPacket);\n \n    //向udp工具发送消息\n    Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口\n    Udp.write(replyPacket);//把数据写入发送缓冲区\n    Udp.endPacket();//发送数据\n  }\n}\n```\n\n##### 相关内容\n\n– endPacket – 发送UDP数据包\n– write – 向UDP数据包写入信息\n– print / println (Stream类) – 发送UDP数据\n– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。\n\n\n\n\n\n#### endPacket – 发送UDP数据包\n\n##### 说明\n\n此函数用于发送UDP数据包。\n\n##### 语法\n\n```\nwiFiUDP.endPacket()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n返回值数据类型为整数型\n1：数据发送成功\n0：数据发送失败\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiUdp_6\n程序目的/Purpose          : \n用于演示ESP8266WiFiUdp库中endPacket函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <WiFiUdp.h>\n \n#define ssid      \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下WIFI名字\n#define password  \"xxxxxxx\"          //这里改成你的设备当前环境下WIFI密码\n \nWiFiUDP Udp;//实例化WiFiUDP对象\nunsigned int localUdpPort = 1234;  // 自定义本地监听端口\nunsigned int remoteUdpPort = 4321;  // 自定义远程监听端口\nchar incomingPacket[255];  // 保存Udp工具发过来的消息\nchar  replyPacket[] = \"Hi, this is esp8266\\n\";  //发送的消息,仅支持英文\n \nvoid setup()\n{\n  Serial.begin(115200);//打开串口\n  Serial.println();\n \n  Serial.printf(\"正在连接 %s \", ssid);\n  WiFi.begin(ssid, password);//连接到wifi\n  while (WiFi.status() != WL_CONNECTED)//等待连接\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"连接成功\");\n \n  if(Udp.begin(localUdpPort)){//启动Udp监听服务\n    Serial.println(\"监听成功\");\n    //打印本地的ip地址，在UDP工具中会使用到\n    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串    \n    Serial.printf(\"现在收听IP：%s, UDP端口：%d\\n\", WiFi.localIP().toString().c_str(), localUdpPort);\n  }else{\n    Serial.println(\"监听失败\");\n  }\n}\n \nvoid loop()\n{\n  //解析Udp数据包\n  int packetSize = Udp.parsePacket();//获得解析包\n  if (packetSize)//解析包不为空\n  {\n    //收到Udp数据包\n    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串\n    Serial.printf(\"收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\\n\", Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);\n      \n    // 读取Udp数据包并存放在incomingPacket\n    int len = Udp.read(incomingPacket, 255);//返回数据包字节数\n    if (len > 0)\n    { \n      incomingPacket[len] = 0;//清空缓存\n    }\n    //向串口打印信息\n    Serial.printf(\"UDP数据包内容为: %s\\n\", incomingPacket);\n \n    //向udp工具发送消息\n    Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口\n    Udp.write(replyPacket);//把数据写入发送缓冲区\n    Udp.endPacket();//发送数据\n  }\n}\n```\n\n##### 相关内容\n\n发送UDP数据类型\n– endPacket – 发送UDP数据包\n– write – 向UDP数据包写入信息\n– print / println (Stream类) – 发送UDP数据\n– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。\n\n\n\n#### write – 向UDP数据包写入信息\n\n##### 说明\n\n将即将通过UDP协议发送的数据写入发送缓冲区。此函数必须置于[beginPacket](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiudp/beginpacket/)和[endPacket](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiudp/endpacket/)之间。\n\n请注意：此函数仅仅将数据写入发送缓冲区，但是数据不会发送。实施数据发送的函数是[endPacket](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiudp/endpacket/)函数。\n\n##### 语法\n\n```\nwiFiUDP.write(udp_data)\n```\n\n##### 参数\n\nudp_data：此参数为写入发送缓冲区的数据，可使用字符串类型。\n\n##### 返回值\n\n写入发送缓冲区的数据大小（单位：字节）。\n返回值类型：size_t\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiUdp_6\n程序目的/Purpose          : \n用于演示ESP8266WiFiUdp库中write函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <WiFiUdp.h>\n \n#define ssid      \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下WIFI名字\n#define password  \"xxxxxxx\"          //这里改成你的设备当前环境下WIFI密码\n \nWiFiUDP Udp;//实例化WiFiUDP对象\nunsigned int localUdpPort = 1234;  // 自定义本地监听端口\nunsigned int remoteUdpPort = 4321;  // 自定义远程监听端口\nchar incomingPacket[255];  // 保存Udp工具发过来的消息\nchar  replyPacket[] = \"Hi, this is esp8266\\n\";  //发送的消息,仅支持英文\n \nvoid setup()\n{\n  Serial.begin(115200);//打开串口\n  Serial.println();\n \n  Serial.printf(\"正在连接 %s \", ssid);\n  WiFi.begin(ssid, password);//连接到wifi\n  while (WiFi.status() != WL_CONNECTED)//等待连接\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"连接成功\");\n \n  if(Udp.begin(localUdpPort)){//启动Udp监听服务\n    Serial.println(\"监听成功\");\n      \n    //打印本地的ip地址，在UDP工具中会使用到\n    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串   \n    Serial.printf(\"现在收听IP：%s, UDP端口：%d\\n\", WiFi.localIP().toString().c_str(), localUdpPort);\n  }else{\n    Serial.println(\"监听失败\");\n  }\n}\n \nvoid loop()\n{\n  //解析Udp数据包\n  int packetSize = Udp.parsePacket();//获得解析包\n  if (packetSize)//解析包不为空\n  {\n    //收到Udp数据包\n    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串\n    Serial.printf(\"收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\\n\", Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);\n      \n    // 读取Udp数据包并存放在incomingPacket\n    int len = Udp.read(incomingPacket, 255);//返回数据包字节数\n    if (len > 0)\n    { \n      incomingPacket[len] = 0;//清空缓存\n    }\n    //向串口打印信息\n    Serial.printf(\"UDP数据包内容为: %s\\n\", incomingPacket);\n \n    //向udp工具发送消息\n    Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口\n    Udp.write(replyPacket);//把数据写入发送缓冲区\n    Udp.endPacket();//发送数据\n  }\n}\n```\n\n##### 发送UDP数据类型\n\n– beginPacket – 配置UDP数据包接收设备的IP和端口\n– print / println (Stream类) – 发送UDP数据\n– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。\n\n\n\n#### print / println (Stream类) – 发送UDP数据\n\n##### 说明\n\nESP8266开发板通过UDP协议发送UDP数据时，可以采用 print 或者 println 函数将UDP数据写入发送缓冲区。\n\nprint与println的功能十分相近。他们的区别是println会在写入数据的末尾添加换行符。\n\n此函数必须置于[beginPacket](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiudp/beginpacket/)和[endPacket](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiudp/endpacket/)之间。\n\n请注意：此函数仅仅将数据写入发送缓冲区，但是数据不会发送。实施数据发送的函数是[endPacket](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiudp/endpacket/)函数。\n\n##### 语法\n\n`wiFiUDP.print(udp_data)`\n`wiFiUDP.println(udp_data)`\n\n##### 参数\n\nudp_data：此参数为写入发送缓冲区的数据，可使用字符串类型。\n\n##### 返回值\n\n无\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n\n\n###### print函数示例\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiUdp_12\n程序目的/Purpose          : \n用于演示ESP8266WiFiUdp库中print函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <WiFiUdp.h>\n \n#define ssid      \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下WIFI名字\n#define password  \"xxxxxxx\"          //这里改成你的设备当前环境下WIFI密码\n \nWiFiUDP Udp;//实例化WiFiUDP对象\nunsigned int localUdpPort = 1234;  // 自定义本地监听端口\nunsigned int remoteUdpPort = 4321;  // 自定义远程监听端口\nchar incomingPacket[255];  // 保存Udp工具发过来的消息\nchar  replyPacket[] = \"Hi, this is esp8266\\n\";  //发送的消息,仅支持英文\n \nvoid setup()\n{\n  Serial.begin(115200);//打开串口\n  Serial.println();\n \n  Serial.printf(\"正在连接 %s \", ssid);\n  WiFi.begin(ssid, password);//连接到wifi\n  while (WiFi.status() != WL_CONNECTED)//等待连接\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"连接成功\");\n \n  if(Udp.begin(localUdpPort)){//启动Udp监听服务\n    Serial.println(\"监听成功\");\n      \n    //打印本地的ip地址，在UDP工具中会使用到\n    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串   \n    Serial.printf(\"现在收听IP：%s, UDP端口：%d\\n\", WiFi.localIP().toString().c_str(), localUdpPort);\n  }else{\n    Serial.println(\"监听失败\");\n  }\n}\n \nvoid loop()\n{\n  //向udp工具发送消息\n  Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口\n  Udp.print(replyPacket);//把数据写入发送缓冲区\n  Udp.endPacket();//发送数据\n  Serial.println(\"UDP数据发送成功\");\n  delay(3000);//延时3秒\n}\n```\n\n###### println函数示例\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiUdp_13\n程序目的/Purpose          : \n用于演示ESP8266WiFiUdp库中println函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <WiFiUdp.h>\n \n#define ssid      \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下WIFI名字\n#define password  \"xxxxxxx\"          //这里改成你的设备当前环境下WIFI密码\n \nWiFiUDP Udp;//实例化WiFiUDP对象\nunsigned int localUdpPort = 1234;  // 自定义本地监听端口\nunsigned int remoteUdpPort = 4321;  // 自定义远程监听端口\nchar incomingPacket[255];  // 保存Udp工具发过来的消息\nchar  replyPacket[] = \"Hi, this is esp8266\\n\";  //发送的消息,仅支持英文\n \nvoid setup()\n{\n  Serial.begin(115200);//打开串口\n  Serial.println();\n \n  Serial.printf(\"正在连接 %s \", ssid);\n  WiFi.begin(ssid, password);//连接到wifi\n  while (WiFi.status() != WL_CONNECTED)//等待连接\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"连接成功\");\n \n  if(Udp.begin(localUdpPort)){//启动Udp监听服务\n    Serial.println(\"监听成功\");\n      \n    //打印本地的ip地址，在UDP工具中会使用到\n    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串   \n    Serial.printf(\"现在收听IP：%s, UDP端口：%d\\n\", WiFi.localIP().toString().c_str(), localUdpPort);\n  }else{\n    Serial.println(\"监听失败\");\n  }\n}\n \nvoid loop()\n{\n  //向udp工具发送消息\n  Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口\n  Udp.println(replyPacket);//把数据写入发送缓冲区\n  Udp.endPacket();//发送数据\n  Serial.println(\"UDP数据发送成功\");\n  delay(3000);//延时3秒\n}\n```\n\n##### 发送UDP数据类型\n\n– beginPacket – 配置UDP数据包接收设备的IP和端口\n– endPacket – 发送UDP数据包\n– write – 向UDP数据包写入信息\n– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。\n\n\n\n\n\n\n\n\n\n### 获取发送UDP数据设备信息类型\n\n#### remoteIP – 获取发送UDP数据包的设备IP\n\n##### 说明\n\n此函数用于获取向ESP8266开发板发送UDP数据包设备的IP地址。\n注：在调用 此函数前需要先调用[parsePacket](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiudp/parsepacket/)函数让ESP8266开发板对接收到的UDP数据进行初始检查。\n\n##### 语法\n\n```\nwiFiUDP.remoteIP()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n此函数的返回值是向ESP8266开发板发送UDP数据包设备的IP地址。数据类型是IPAddress。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```C\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiUdp_6\n程序目的/Purpose          : \n用于演示ESP8266WiFiUdp库中remoteIP函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <WiFiUdp.h>\n \n#define ssid      \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下WIFI名字\n#define password  \"12345678\"         //这里改成你的设备当前环境下WIFI密码\n \nWiFiUDP Udp;//实例化WiFiUDP对象\nunsigned int localUdpPort = 1234;  // 自定义本地监听端口\nunsigned int remoteUdpPort = 4321;  // 自定义远程监听端口\nchar incomingPacket[255];  // 保存Udp工具发过来的消息\nchar  replyPacket[] = \"Hi, this is esp8266\\n\";  //发送的消息,仅支持英文\n \nvoid setup()\n{\n  Serial.begin(115200);//打开串口\n  Serial.println();\n \n  Serial.printf(\"正在连接 %s \", ssid);\n  WiFi.begin(ssid, password);//连接到wifi\n  while (WiFi.status() != WL_CONNECTED)//等待连接\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"连接成功\");\n \n  if(Udp.begin(localUdpPort)){//启动Udp监听服务\n    Serial.println(\"监听成功\");\n    //打印本地的ip地址，在UDP工具中会使用到\n    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串    \n    Serial.printf(\"现在收听IP：%s, UDP端口：%d\\n\", WiFi.localIP().toString().c_str(), localUdpPort);\n  }else{\n    Serial.println(\"监听失败\");\n  }\n}\n \nvoid loop()\n{\n  //解析Udp数据包\n  int packetSize = Udp.parsePacket();//获得解析包\n  if (packetSize)//解析包不为空\n  {\n    //收到Udp数据包\n    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串\n    Serial.printf(\"收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\\n\", Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);\n      \n    // 读取Udp数据包并存放在incomingPacket\n    int len = Udp.read(incomingPacket, 255);//返回数据包字节数\n    if (len > 0)\n    { \n      incomingPacket[len] = 0;//清空缓存\n    }\n    //向串口打印信息\n    Serial.printf(\"UDP数据包内容为: %s\\n\", incomingPacket);\n \n    //向udp工具发送消息\n    Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口\n    Udp.write(replyPacket);//把数据写入发送缓冲区\n    Udp.endPacket();//发送数据\n  }\n}\n```\n\n\n\n\n\n#### remotePort – 获取发送UDP数据包的设备的端口\n\n##### 说明\n\n此函数用于获取向ESP8266开发板发送UDP数据包设备的端口。\n注：在调用 此函数前需要先调用[parsePacket](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/wifiudp/parsepacket/)函数让ESP8266开发板对接收到的UDP数据进行初始检查。\n\n##### 语法\n\n```\nwiFiUDP.remotePort()\n```\n\n##### 参数\n\n无\n\n##### 返回值\n\n此函数的返回值是向ESP8266开发板发送UDP数据包设备的端口。数据类型是uint16_t。\n\n##### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n```c\n/**********************************************************************\n程序名称/Program name     : ESP8266WiFiUdp_6\n程序目的/Purpose          : \n用于演示ESP8266WiFiUdp库中remotePort函数\n***********************************************************************/\n \n#include <ESP8266WiFi.h>\n#include <WiFiUdp.h>\n \n#define ssid      \"TaichiMaker_WIFI\" //这里改成你的设备当前环境下WIFI名字\n#define password  \"12345678\"         //这里改成你的设备当前环境下WIFI密码\n \nWiFiUDP Udp;//实例化WiFiUDP对象\nunsigned int localUdpPort = 1234;  // 自定义本地监听端口\nunsigned int remoteUdpPort = 4321;  // 自定义远程监听端口\nchar incomingPacket[255];  // 保存Udp工具发过来的消息\nchar  replyPacket[] = \"Hi, this is esp8266\\n\";  //发送的消息,仅支持英文\n \nvoid setup()\n{\n  Serial.begin(115200);//打开串口\n  Serial.println();\n \n  Serial.printf(\"正在连接 %s \", ssid);\n  WiFi.begin(ssid, password);//连接到wifi\n  while (WiFi.status() != WL_CONNECTED)//等待连接\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"连接成功\");\n \n  if(Udp.begin(localUdpPort)){//启动Udp监听服务\n    Serial.println(\"监听成功\");\n    //打印本地的ip地址，在UDP工具中会使用到\n    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串    \n    Serial.printf(\"现在收听IP：%s, UDP端口：%d\\n\", WiFi.localIP().toString().c_str(), localUdpPort);\n  }else{\n    Serial.println(\"监听失败\");\n  }\n}\n \nvoid loop()\n{\n  //解析Udp数据包\n  int packetSize = Udp.parsePacket();//获得解析包\n  if (packetSize)//解析包不为空\n  {\n    //收到Udp数据包\n    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串\n    Serial.printf(\"收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\\n\", Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);\n      \n    // 读取Udp数据包并存放在incomingPacket\n    int len = Udp.read(incomingPacket, 255);//返回数据包字节数\n    if (len > 0)\n    { \n      incomingPacket[len] = 0;//清空缓存\n    }\n    //向串口打印信息\n    Serial.printf(\"UDP数据包内容为: %s\\n\", incomingPacket);\n \n    //向udp工具发送消息\n    Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口\n    Udp.write(replyPacket);//把数据写入发送缓冲区\n    Udp.endPacket();//发送数据\n  }\n}\n```\n\n\n\n\n\n## ESP8266 – DNSServer库\n\nDNS（Domain Name Server，域名服务器）是进行域名（如[arduino-esp8266.readthedocs.io](https://arduino-esp8266.readthedocs.io/)）和与之相对应的IP地址转换的服务器。如需了解更多有关DNS服务器的信息，可前往百度百科的[域名服务器介绍页面](https://baike.baidu.com/item/域名服务器)获取更多介绍信息。\n\n通过DNSServer库，我们可以使用ESP8266模块建立简易版的域名服务器。以下为DNSServer库的整体结构图。在此图下方有DNSServer库的函数目录。您可以通过点击目录项目打开各个函数的说明页面。\n\n![image-20230527170327287](./Image/ESP8266.assets/image-20230527170327287.png)\n\n\n\n### start – 启动DNS服务\n\n#### 说明\n\n当ESP8266模块以无线终端模式工作时，调用本函数可以启动ESP8266模块的DNS服务。\n\n#### 语法\n\n```\ndnsServer.start(port, domainName, domainIp)\n```\n\n#### 参数\n\nport: DNS服务端口号。默认情况下设置为53（uint16_t型）\n\ndomainName: 映射的域名，也就是开启服务后可以直接访问的用于代替IP地址的域名（可使用字符串型）\n\ndomainIp: 映射的IP地址（IPAdress型）\n\n#### 返回值\n\n返回值为是否成功开启DNS服务，若开启则返回true。数据类型为布尔型\n\n#### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n##### **示例程序操作说明**\n\n当您将以下程序编译并且上传给ESP8266开发板以后，接下来您可以使用手机连接ESP8266开发板所建立的WiFi网络。该WiFi网络名称是DNSServer example（连接此网络无需密码）。\n\n请打开手机的浏览器，并且在浏览器地址栏中输入“www.example.com”。\n\n输入地址后，再按下确认键。浏览器将会打开下图所示的页面。该页面正是由ESP8266开发板所建立的。\n\n接下来，我将对此示例程序的基本工作流程给您做一个简单的介绍。请留意，在以下示例程序的控制下，ESP8266服务器将会扮演两个角色。第一个角色是DNS服务器，也就是本页面所要讲解的重点。第二个是网络服务器，也就是响应客户端的HTTP访问请求。\n\n在以下示例程序中，我们使用了`dnsServer.start(DNS_PORT, \"www.example.com\", apIP)`启动了DNS服务。当我们通过浏览器输入了www.example.com这一网址信息并按下确认键后，浏览器将会向ESP8266所建立的DNS服务器发送DNS服务请求。\n\nESP8266服务器在收到此请求后，将会通过服务器内的检索信息获取到www.example.com这一网址所对应的IP地址正是ESP8266服务器的IP地址。于是ESP8266DNS服务器将会把这一检索结果响应给浏览器。\n\n浏览器得到了DNS服务器响应，也就是www.example.com网址所对应的IP正是ESP8266服务器的IP，于是浏览器将会再次向ESP8266的IP地址发送HTTP请求。\n\n当ESP8266接收到浏览器客户端的HTTP访问请求后，ESP8266的网页服务器功能将会生成HTTP响应信息，并且返回给手机浏览器客户端。浏览器于是便显示出以下图片所显示的信息内容。\n\n![image-20230527202419055](./Image/ESP8266.assets/image-20230527202419055.png)\n\n```c\n/**********************************************************************\n程序名称/Program name     : dnsServer.processNextRequest()演示\n程序目的/Purpose          : \n \n此程序使用DNSServer库来演示持续处理DNS请求服务\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <DNSServer.h>\n#include <ESP8266WebServer.h>\n \nconst byte DNS_PORT = 53;//默认设置端口为53\n \nIPAddress apIP(192, 168, 1, 1);\nDNSServer dnsServer;\nESP8266WebServer webServer(80);\n \nvoid setup() {\n  WiFi.mode(WIFI_AP);\n  WiFi.softAPConfig(apIP, apIP, IPAddress(255, 255, 255, 0));\n  WiFi.softAP(\"DNSServer example\");\n \n  // 启动特定域名的DNS服务器\n  dnsServer.start(DNS_PORT, \"www.example.com\", apIP);\n \n  // 利用简单的HTTP服务器以查看DNS服务器是否正常运行\n  webServer.onNotFound([]() {\n    String message = \"Hello World!\\n\\n\";\n    message += \"URI: \";\n    message += webServer.uri();\n \n    webServer.send(200, \"text/plain\", message);\n  });\n  webServer.begin();\n}\n \nvoid loop() {\n  dnsServer.processNextRequest();//处理DNS请求服务\n  webServer.handleClient();\n}\n```\n\n#### 相关内容\n\n– stop – 停止DNS服务\n– processNextRequest – 处理DNS请求\n– setErrorReplyCode – 设置错误响应码\n– setTTL – 设置TTL\n\n\n\n### stop – 停止DNS服务\n\n#### 说明\n\n当ESP8266模块以无线终端模式工作时，调用本函数可以关闭ESP8266模块的DNS服务。\n\n#### 语法\n\n```\ndnsServer.stop()\n```\n\n#### 参数\n\n无\n\n#### 返回值\n\n返回是否成功关闭DNS服务。关闭成功返回true。返回值数据类型为布尔型\n\n#### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n##### 相关内容\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n**注意: 以下示例程序使用了softAPConfig函数对ESP8266模块进行网络配置。由于不同的WiFi路由设备的网络配置是不同的，请根据您的WiFi网络配置参数对以下示例程序中的local_IP、gateway、subnet配置进行相应修改。详情请查阅ESP8266WiFiAP库的softAPConfig页面**\n\n```c\n/**********************************************************************\n  程序名称/Program name     : dnsServer.stop();演示\n  程序目的/Purpose          :\n \n  此程序使用ESP8266DNSServer库来演示在接入点模式下关闭建立的DNS服务\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <DNSServer.h>\n#include <ESP8266WebServer.h>\n \nIPAddress local_IP(192, 168, 4, 1); //设置IP地址\nIPAddress gateway(192, 168, 4, 1); //设置网关地址\nIPAddress subnet(255, 255, 255, 0); //设置子网掩码\n \nconst byte DNS_PORT = 53; //DNS服务端口号，一般为53\n \nDNSServer dnsServer;\nESP8266WebServer webServer(80);\n \nvoid handleRoot() {\n  webServer.send(200, \"text/plain\", \"这是主页\");\n}\n \nvoid handleNext() {\n  webServer.send(200, \"text/plain\", \"这是另一个页面\");\n}\n \nvoid setup() {\n  //初始化串口\n  Serial.begin(9600);\n  Serial.println();\n  //初始化网络\n  WiFi.mode(WIFI_AP);\n  WiFi.softAPConfig(local_IP, gateway, subnet);\n  WiFi.softAP(\"DNSServer example\");\n \n  //初始化DNSServer\n  dnsServer.start(DNS_PORT, \"dnsexample\", local_IP);\n \n  //初始化WebServer\n  webServer.on(\"/\", handleRoot);\n  webServer.on(\"/next\", handleNext);\n  webServer.begin();\n  Serial.println(\"初始化测试完毕，20秒后关闭DNS服务\");\n  delay(5000);\n  delay(5000);\n  delay(5000);\n  Serial.println(\"即将关闭DNS服务\");\n  dnsServer.stop();\n  Serial.println(\"DNS服务已关闭！\");\n}\n \nvoid loop(){}\n```\n\n\n\n#### 相关内容\n\n– start – 启动DNS服务\n– processNextRequest – 处理DNS请求\n– setErrorReplyCode – 设置错误响应码\n– setTTL – 设置TTL\n\n\n\n### processNextRequest – 处理DNS请求\n\n#### 说明\n\nprocessNextRequest函数用于处理DNS请求。当ESP8266模块收到UDP请求后，它将判断该请求是否查找域名映射的IP地址。如果是，则返回IP地址。若有错误则会返回[setErrorReplyCode](http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/dnsserver/seterrorreplycode/)设定好的错误码。\n\n#### 语法\n\ndnsServer.processNextRequest()\n\n#### 参数\n\n无\n\n#### 返回值\n\n无\n\n#### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n**示例程序操作说明**\n当您将以下程序编译并且上传给ESP8266开发板以后，接下来您可以使用手机连接ESP8266开发板所建立的WiFi网络。该WiFi网络名称是DNSServer example（连接此网络无需密码）。\n\n请打开手机的浏览器，并且在浏览器地址栏中输入“www.example.com”。\n\n输入地址后，再按下确认键。浏览器将会打开下图所示的页面。该页面正是由ESP8266开发板所建立的。\n\n接下来，我将对此示例程序的基本工作流程给您做一个简单的介绍。请留意，在以下示例程序的控制下，ESP8266服务器将会扮演两个角色。第一个角色是DNS服务器，也就是本页面所要讲解的重点。第二个是网络服务器，也就是响应客户端的HTTP访问请求。\n\n在以下示例程序中，我们使用了`dnsServer.start(DNS_PORT, \"www.example.com\", apIP)`启动了DNS服务。当我们通过浏览器输入了www.example.com这一网址信息并按下确认键后，浏览器将会向ESP8266所建立的DNS服务器发送DNS服务请求。\n\nESP8266服务器在收到此请求后，将会通过服务器内的检索信息获取到www.example.com这一网址所对应的IP地址正是ESP8266服务器的IP地址。于是ESP8266DNS服务器将会把这一检索结果响应给浏览器。\n\n浏览器得到了DNS服务器响应，也就是www.example.com网址所对应的IP正是ESP8266服务器的IP，于是浏览器将会再次向ESP8266的IP地址发送HTTP请求。\n\n当ESP8266接收到浏览器客户端的HTTP访问请求后，ESP8266的网页服务器功能将会生成HTTP响应信息，并且返回给手机浏览器客户端。浏览器于是便显示出以下图片所显示的信息内容。\n\n\n\n![image-20230527202419055](./Image/ESP8266.assets/image-20230527202419055.png)\n\n```c\n/**********************************************************************\n程序名称/Program name     : dnsServer.processNextRequest()演示\n程序目的/Purpose          : \n \n此程序使用DNSServer库来演示持续处理DNS请求服务\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <DNSServer.h>\n#include <ESP8266WebServer.h>\n \nconst byte DNS_PORT = 53;//默认设置端口为53\n \nIPAddress apIP(192, 168, 1, 1);\nDNSServer dnsServer;\nESP8266WebServer webServer(80);\n \nvoid setup() {\n  WiFi.mode(WIFI_AP);\n  WiFi.softAPConfig(apIP, apIP, IPAddress(255, 255, 255, 0));\n  WiFi.softAP(\"DNSServer example\");\n \n  // 启动特定域名的DNS服务器\n  dnsServer.start(DNS_PORT, \"www.example.com\", apIP);\n \n  // 利用简单的HTTP服务器以查看DNS服务器是否正常运行\n  webServer.onNotFound([]() {\n    String message = \"Hello World!\\n\\n\";\n    message += \"URI: \";\n    message += webServer.uri();\n \n    webServer.send(200, \"text/plain\", message);\n  });\n  webServer.begin();\n}\n \nvoid loop() {\n  dnsServer.processNextRequest();//处理DNS请求服务\n  webServer.handleClient();\n}\n```\n\n#### 相关内容\n\n– stop – 停止DNS服务\n– processNextRequest – 处理DNS请求\n– setErrorReplyCode – 设置错误响应码\n– setTTL – 设置TTL\n\n\n\n### setErrorReplyCode – 设置错误响应码\n\n#### 说明\n\n当客户端发送的查询域名不在ESP8266模块建立的DNS服务器检索中，则返回setErrorReplyCode函数设置的错误代码。\n\n#### 语法\n\n```\ndnsServer.setErrorReplyCode(replyCode)\n```\n\n#### 参数\n\nreplyCode：此参数为DNS响应错误码。类型为DNSReplyCode。\n\nESP8266 – DNSServer库默认的DNS响应错误码如下\n\n-   NoError = 0,//DNS查询成功完成\n-   FormError = 1,//DNS查询格式错误\n-   ServerFailure = 2, //服务器无法完成DNS请求\n-   NonExistentDomain = 3,//域名不存在\n-   NotImplemented = 4,//未定义\n-   Refused = 5,//服务器拒绝回答查询\n-   YXDomain = 6,//名称不应该存在，但该名称确实存在\n-   YXRRSet = 7,//资源记录集不存在\n-   NXRRSet = 8//服务器对该区域无权\n\n\n\n### 返回值\n\n无\n\n### 示例程序\n\n**示例程序操作说明**\n当您将以下程序编译并且上传给ESP8266开发板以后，接下来您可以使用手机连接ESP8266开发板所建立的WiFi网络。该WiFi网络名称是DNSServer example（连接此网络无需密码）。\n\n请打开手机的浏览器，并且在浏览器地址栏中输入“www.example.com”。\n\n输入地址后，再按下确认键。浏览器将会打开下图所示的页面。该页面正是由ESP8266开发板所建立的。\n\n接下来，我将对此示例程序的基本工作流程给您做一个简单的介绍。请留意，在以下示例程序的控制下，ESP8266服务器将会扮演两个角色。第一个角色是DNS服务器，也就是本页面所要讲解的重点。第二个是网络服务器，也就是响应客户端的HTTP访问请求。\n\n在以下示例程序中，我们使用了`dnsServer.start(DNS_PORT, \"www.example.com\", apIP)`启动了DNS服务。当我们通过浏览器输入了www.example.com这一网址信息并按下确认键后，浏览器将会向ESP8266所建立的DNS服务器发送DNS服务请求。\n\nESP8266服务器在收到此请求后，将会通过服务器内的检索信息获取到www.example.com这一网址所对应的IP地址正是ESP8266服务器的IP地址。于是ESP8266DNS服务器将会把这一检索结果响应给浏览器。\n\n浏览器得到了DNS服务器响应，也就是www.example.com网址所对应的IP正是ESP8266服务器的IP，于是浏览器将会再次向ESP8266的IP地址发送HTTP请求。\n\n当ESP8266接收到浏览器客户端的HTTP访问请求后，ESP8266的网页服务器功能将会生成HTTP响应信息，并且返回给手机浏览器客户端。浏览器于是便显示出以下图片所显示的信息内容。\n\n![image-20230527202419055](./Image/ESP8266.assets/image-20230527202419055.png)\n\n**在以下示例程序中：当客户端发送的查询域名不在DNS服务器检索中，则返回以下语句所设置的错误代码。`dnsServer.setErrorReplyCode(DNSReplyCode::ServerFailure);`。**\n\n```c\n/**********************************************************************\n程序名称/Program name     : dnsServer.setErrorReplyCode();演示\n程序目的/Purpose          : \n \n此程序使用DNSServer库来演示设置错误响应码\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <DNSServer.h>\n#include <ESP8266WebServer.h>\n \nconst byte DNS_PORT = 53;//默认设置端口为53\nIPAddress apIP(192, 168, 1, 1);\nDNSServer dnsServer;\nESP8266WebServer webServer(80);\n \nvoid setup() {\n  WiFi.mode(WIFI_AP);\n  WiFi.softAPConfig(apIP, apIP, IPAddress(255, 255, 255, 0));\n  WiFi.softAP(\"DNSServer example\");\n \n  // 设置TTL值（单位：秒）\n  dnsServer.setTTL(300);\n  \n  //当客户端发送的查询域名不在DNS服务器检索中，则返回以下语句所设置的错误代码。\n  dnsServer.setErrorReplyCode(DNSReplyCode::ServerFailure);\n \n  // 启动特定域名的DNS服务器\n  dnsServer.start(DNS_PORT, \"www.example.com\", apIP);\n \n  // 利用简单的HTTP服务器以查看DNS服务器是否正常运行\n  webServer.onNotFound([]() {\n    String message = \"Hello World!\\n\\n\";\n    message += \"URI: \";\n    message += webServer.uri();\n \n    webServer.send(200, \"text/plain\", message);\n  });\n  webServer.begin();\n}\n \nvoid loop() {\n  dnsServer.processNextRequest();//持续监听\n  webServer.handleClient();\n}\n```\n\n#### 相关内容\n\n– start – 启动DNS服务\n– stop – 停止DNS服务\n– processNextRequest – 处理DNS请求\n– setTTL – 设置TTL\n\n\n\n\n\n### setTTL – 设置TTL\n\n#### 说明\n\n此函数用于设置ESP8266模块DNS服务的TTL值。\n\n通过增大TTL值，可以减少DNS递归查询过程，达到提升域名解析速度的效果。反之，通过缩小 TTL 值，以减少更换空间IP地址时造成的不可访问时间，减小空间IP地址造成的访问空窗期。根据不同应用场景和网络需求可以选择合适的TTL值达成更好的访问体验\n\n#### 语法\n\nsetTTL(TTLval)\n\n#### 参数\n\nTTLval: 设置TTL数值(单位：秒)\n\n#### 返回值\n\n无\n\n#### 示例程序\n\n关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。\n\n**示例程序操作说明**\n当您将以下程序编译并且上传给ESP8266开发板以后，接下来您可以使用手机连接ESP8266开发板所建立的WiFi网络。该WiFi网络名称是DNSServer example（连接此网络无需密码）。\n\n请打开手机的浏览器，并且在浏览器地址栏中输入“www.example.com”。\n\n输入地址后，再按下确认键。浏览器将会打开下图所示的页面。该页面正是由ESP8266开发板所建立的。\n\n接下来，我将对此示例程序的基本工作流程给您做一个简单的介绍。请留意，在以下示例程序的控制下，ESP8266服务器将会扮演两个角色。第一个角色是DNS服务器，也就是本页面所要讲解的重点。第二个是网络服务器，也就是响应客户端的HTTP访问请求。\n\n在以下示例程序中，我们使用了`dnsServer.start(DNS_PORT, \"www.example.com\", apIP)`启动了DNS服务。当我们通过浏览器输入了www.example.com这一网址信息并按下确认键后，浏览器将会向ESP8266所建立的DNS服务器发送DNS服务请求。\n\nESP8266服务器在收到此请求后，将会通过服务器内的检索信息获取到www.example.com这一网址所对应的IP地址正是ESP8266服务器的IP地址。于是ESP8266DNS服务器将会把这一检索结果响应给浏览器。\n\n浏览器得到了DNS服务器响应，也就是www.example.com网址所对应的IP正是ESP8266服务器的IP，于是浏览器将会再次向ESP8266的IP地址发送HTTP请求。\n\n当ESP8266接收到浏览器客户端的HTTP访问请求后，ESP8266的网页服务器功能将会生成HTTP响应信息，并且返回给手机浏览器客户端。浏览器于是便显示出以下图片所显示的信息内容。\n\n![image-20230527202419055](./Image/ESP8266.assets/image-20230527202419055.png)\n\n\n\n```c\n/**********************************************************************\n程序名称/Program name     : dnsServer.setErrorReplyCode();演示\n程序目的/Purpose          : \n \n此程序使用DNSServer库来演示设置错误响应码\n***********************************************************************/\n#include <ESP8266WiFi.h>\n#include <DNSServer.h>\n#include <ESP8266WebServer.h>\n \nconst byte DNS_PORT = 53;//默认设置端口为53\nIPAddress apIP(192, 168, 1, 1);\nDNSServer dnsServer;\nESP8266WebServer webServer(80);\n \nvoid setup() {\n  WiFi.mode(WIFI_AP);\n  WiFi.softAPConfig(apIP, apIP, IPAddress(255, 255, 255, 0));\n  WiFi.softAP(\"DNSServer example\");\n \n  // 设置DNS服务的TTL数值为300\n  dnsServer.setTTL(300);\n \n  // 启动特定域名的DNS服务器\n  dnsServer.start(DNS_PORT, \"www.example.com\", apIP);\n \n  // 利用简单的HTTP服务器以查看DNS服务器是否正常运行\n  webServer.onNotFound([]() {\n    String message = \"Hello World!\\n\\n\";\n    message += \"URI: \";\n    message += webServer.uri();\n \n    webServer.send(200, \"text/plain\", message);\n  });\n  webServer.begin();\n}\n \nvoid loop() {\n  dnsServer.processNextRequest();//持续监听\n  webServer.handleClient();\n}\n```\n\n#### 相关内容\n\n– start – 启动DNS服务\n– stop – 停止DNS服务\n– processNextRequest – 处理DNS请求\n– setErrorReplyCode – 设置错误响应码\n\n\n\n\n\n## ESP8266多任务处理 – Ticker库使用说明\n\nESP8266在运行过程中，只能一条线式的依次执行任务。但是我们在开发物联网项目时，可能需要ESP8266在执行某一任务的过程中，还能处理其它任务。比如，我们使用ESP8266来控制电机运行的同时，还需要定时检查某一个引脚上连接按钮有没有被用户按下。\n\n为了解决以上问题，我们可以使用Ticker库来解决这一问题。下面我们来通过一系列示例程序向您讲解Ticker库的使用方法。\n\n### 示例1. Ticker库基本操作\n\n利用Ticker库，我们可以让ESP8266定时调用某一个函数。通过以下示例程序我们可以看到，ESP8266将会每隔一秒钟通过串口监视器输出一次信息。我们是通过语句`ticker.attach(1, sayHi)`来实现这一操作的。\n\n该语句中的attach函数有两个参数。第一个参数可控制调用函数的时间间隔，单位是秒。这里的数字1说明ESP8266将会每隔一秒钟调用一次函数。那么具体调用哪一个函数呢？这个函数名称正是是通过第二个参数来限定的。也就是名称为sayHi的函数。该函数将会让ESP8266定时通过串口监视器输出一次信息。信息内容是“Hi”后面跟一个数值。这个数值是为了标注sayHi函数被调用了多少次。\n\n```c\n/**********************************************************************\n程序名称/Program name     : a_basic_tinker\n程序目的/Purpose          : \n本程序旨在演示如何使用Ticker库来定时执行操作。 \n***********************************************************************/\n#include <Ticker.h>\n \nTicker ticker;// 建立Ticker用于实现定时功能\nint count;    // 计数用变量\n \nvoid setup() {\n  Serial.begin(9600);\n  pinMode(LED_BUILTIN, OUTPUT);\n \n  // 每隔一秒钟调用sayHi函数一次，attach函数的第一个参数\n  // 是控制定时间隔的变量。该参数的单位为秒。第二个参数是\n  // 定时执行的函数名称。\n  ticker.attach(1, sayHi);\n}\n \nvoid loop() {\n  // 用LED呼吸灯效果来演示在Tinker对象控制下，ESP8266可以定时\n  // 执行其它任务\n  for (int fadeValue = 0 ; fadeValue <= 1023; fadeValue += 5) {\n    analogWrite(LED_BUILTIN, fadeValue);\n    delay(10);\n  }\n \n  for (int fadeValue = 1023 ; fadeValue >= 0; fadeValue -= 5) {\n    analogWrite(LED_BUILTIN, fadeValue);\n    delay(10);\n  }\n  delay(3000);\n}\n \n// 在Tinker对象控制下，此函数将会定时执行。\nvoid sayHi(){\n  count++;\n  Serial.print(\"Hi \");\n  Serial.println(count);\n}\n```\n\n### 示例2. 停止定时执行函数\n\n当Ticker定时调用某一函数执行到一定次数后，我们可以使用detach函数来停止定时调用函数。以下示例程序中的语句`ticker.detach()`将会让ticker对象停止调用函数。\n\n```c\n/**********************************************************************\n程序名称/Program name     : b_detach\n程序目的/Purpose          : \n本程序旨在演示如何停止Ticker库定时调用函数。\n***********************************************************************/\n#include <Ticker.h>\n \nTicker ticker;// 建立Ticker用于实现定时功能\nint count;    // 计数用变量\n \nvoid setup() {\n  Serial.begin(9600);\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  // 每隔一秒钟调用sayHi函数一次\n  ticker.attach(1, sayHi);\n}\n \nvoid loop() {\n  // 用LED呼吸灯效果来演示在Tinker对象控制下，ESP8266可以定时\n  // 执行其它任务  \n  for (int fadeValue = 0 ; fadeValue <= 1023; fadeValue += 5) {\n    analogWrite(LED_BUILTIN, fadeValue);\n    delay(10);\n  }\n \n  for (int fadeValue = 1023 ; fadeValue >= 0; fadeValue -= 5) {\n    analogWrite(LED_BUILTIN, fadeValue);\n    delay(10);\n  }\n  delay(3000);\n}\n \n// 在Tinker对象控制下，此函数将会定时执行。\nvoid sayHi(){\n  count++;\n  Serial.print(\"Hi \");\n  Serial.println(count);\n \n  // 当定时调用了6次后，停止定时调用函数\n  if (count >= 6) {\n    ticker.detach();  // 使用detach来停止ticker对象定时调用函数\n    Serial.print(\"ticker.detach()\");\n  }\n}\n```\n\n### 示例3. 向定时调用函数传递参数\n\n我们可以向Ticker库定时调用的函数来传递参数。不过要注意的是，传递参数的数量只能时一个。如下示例程序所示，语句`ticker.attach(1, sayHi, 8)`有3个参数。其中第三个参数就是向定时调用的sayHi函数所传递的参数。\n\n**请注意：attach函数所能传递的参数最多只有一个。另外该参数仅能是以下类型中的一种：char, short, int, float, void\\*, char\\*。**\n\n```c\n/**********************************************************************\n程序名称/Program name     : c_parameter\n程序目的/Purpose          : \n本程序旨在演示如何向Ticker库定时调用函数来传递参数。\n请注意：attach函数所能传递的参数最多只有一个。\n另外该参数仅能是这些类型中的一种：char, short, int, float, void*, char*\n***********************************************************************/\n#include <Ticker.h>\n \nTicker ticker;\n \nint count;\n \nvoid setup() {\n  Serial.begin(9600);\n  pinMode(LED_BUILTIN, OUTPUT);\n  \n  ticker.attach(1, sayHi, 8);\n}\n \nvoid loop() {\n  for (int fadeValue = 0 ; fadeValue <= 1023; fadeValue += 5) {\n    analogWrite(LED_BUILTIN, fadeValue);\n    delay(10);\n  }\n \n  for (int fadeValue = 1023 ; fadeValue >= 0; fadeValue -= 5) {\n    analogWrite(LED_BUILTIN, fadeValue);\n    delay(10);\n  }\n  delay(3000);\n}\n \nvoid sayHi(int hiTimes){\n  count++;\n  Serial.print(\"Hi \");\n  Serial.println(count);\n \n  if (count >= hiTimes) {\n    ticker.detach();\n    Serial.print(\"ticker.detach();\");\n  }\n}\n```\n\n\n\n### 示例4. 利用多个Ticker对象让ESP8266处理多任务\n\n我们可以建立多个Ticker对象。让多个Ticker对象来实现ESP8266的多任务处理。如下实例程序所示，我们通过语句`Ticker buttonTicker;`来建立第二个Ticker对象。\n\n接下来我们使用`buttonTicker.attach_ms(100, buttonCheck)`来实现第二个Ticker对象的任务处理。这里我们使用了attach_ms函数，该函数与attach函数功能相似，唯一区别是。attach函数的时间单位是秒，而attach_ms的时间单位是毫秒。也就是说，这条语句将会让ESP8266每隔100毫秒执行一次buttonCheck函数。\n\n```c\n/**********************************************************************\n程序名称/Program name     : d_multi_ms\n程序目的/Purpose          : \n本程序旨在演示如何使用多个Ticker对象来让ESP8266处理多个任务。\n \n***********************************************************************/\n#include <Ticker.h>\n \nTicker ticker;\nTicker buttonTicker;\n \nint count;\n \nvoid setup() {\n  Serial.begin(9600);\n  pinMode(LED_BUILTIN, OUTPUT);\n  pinMode(D3, INPUT_PULLUP);\n  \n  ticker.attach(1, sayHi, 60);\n  buttonTicker.attach_ms(100, buttonCheck);\n}\n \nvoid loop() {\n  for (int fadeValue = 0 ; fadeValue <= 1023; fadeValue += 5) {\n    analogWrite(LED_BUILTIN, fadeValue);\n    delay(10);\n  }\n \n  for (int fadeValue = 1023 ; fadeValue >= 0; fadeValue -= 5) {\n    analogWrite(LED_BUILTIN, fadeValue);\n    delay(10);\n  }\n  delay(3000);\n}\n \nvoid sayHi(int hiTimes){\n  count++;\n  Serial.print(\"Hi \");\n  Serial.println(count);\n \n  if (count >= hiTimes) {\n    ticker.detach();\n    Serial.print(\"ticker.detach();\");\n  }\n}\n \nvoid buttonCheck(){\n  if (digitalRead(D3) == LOW){\n    Serial.println(\"D3 Button Pushed...\");\n  }\n}\n```\n\n\n\n### 示例5. 使用”计数器”来控制ESP8266定时执行较复杂的函数\n\nTicker定时调用的函数必须要“短小精悍”。比如以上一系列的示例程序中，我们仅仅让Ticker定时调用函数执行简单的串口数据输出，以及很基本的运算。事实上，在使用Ticker库时，定时调用函数必须要很快的执行完毕。否则会产生难以预料的问题。\n\n这就产生了一个问题。假如我们需要ESP8266定时执行的操作较为复杂，这该如何是好呢？\n\n假设我们让ESP8266定时向example.com网站服务器发送一个http请求，并且将服务器响应通过串口监视器显示出来。（如您对这一操作尚不了解，[请参考《零基础入门学用物联网教程》第3-4-1节中的示例1](http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/)。）\n\n这个问题的答案就在以下示例程序中。在这段示例程序里，我们建立了一个计数变量count。在程序的第55到第59行中，Ticker定时调用的函数tickerCount仅仅对count变量进行自加。\n\n当计数变量count达到我们需要的数值后，则让ESP8266执行较为复杂的函数。这一点是通过程序的第49到52行逻辑判断语句所实现的。\n\n请注意，在每一次执行完操作后，我们都需要对count变量进行清零。否则程序将无法定时通过互联网向服务器发送请求。\n\n```c\n/**********************************************************************\n项目名称/Project          : 零基础入门学用物联网\n程序名称/Program name     : e_timer_http\n团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)\n作者/Author              : CYNO朔\n日期/Date（YYYYMMDD）     : 20200703\n程序目的/Purpose          : \n本程序旨在演示如何使用计数器来控制ESP8266定时执行较复杂的函数。Ticker定时调用的函数必须要“短小精悍”。\n而不能是复杂且占用时间较长的函数。对于较为复杂的函数，我们可以使用计数器的方法来实现。\n \n本程序将会定时让ESP8266向example网络服务器发送请求，并且将服务器响应信息显示在屏幕中。\n \n如需了解本程序的详细说明，请参考以下函数：\nhttp://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-tips/tinker/\n-----------------------------------------------------------------------\n其它说明 / Other Description：\n本程序为太极创客团队制作的免费视频教程《零基础入门学用物联网 》中一部分。该教程系统的\n向您讲述ESP8266的物联网应用相关的软件和硬件知识。以下是该教程目录页：\nhttp://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/                    \n***********************************************************************/\n#include <Ticker.h>\n#include <ESP8266WiFi.h>\n#include <ESP8266HTTPClient.h>\n \n#define URL \"http://www.example.com\"\n \n// 设置wifi接入信息(请根据您的WiFi信息进行修改)\nconst char* ssid = \"taichimaker\";\nconst char* password = \"12345678\";\n \nTicker ticker;\n \nint count;\n \nvoid setup() {\n  Serial.begin(9600);\n \n  //设置ESP8266工作模式为无线终端模式\n  WiFi.mode(WIFI_STA);\n  \n  //连接WiFi\n  connectWifi();\n \n  ticker.attach(1, tickerCount);\n}\n \nvoid loop() {  \n  if (count >= 5){   \n    httpRequest();\n    count = 0;\n  }\n}\n \nvoid tickerCount(){\n  count++;\n  Serial.print(\"count = \");\n  Serial.println(count);\n}\n \n// 发送HTTP请求并且将服务器响应通过串口输出\nvoid httpRequest(){\n  HTTPClient httpClient;\n \n  httpClient.begin(URL); \n  Serial.print(\"URL: \"); Serial.println(URL);\n \n  int httpCode = httpClient.GET();\n  Serial.print(\"Send GET request to URL: \");\n  Serial.println(URL);\n  \n  if (httpCode == HTTP_CODE_OK) {\n    // 使用getString函数获取服务器响应体内容\n    String responsePayload = httpClient.getString();\n    Serial.println(\"Server Response Payload: \");\n    Serial.println(responsePayload);\n  } else {\n    Serial.println(\"Server Respose Code：\");\n    Serial.println(httpCode);\n  }\n  httpClient.end();\n}\n \nvoid connectWifi(){\n//开始连接wifi\n  WiFi.begin(ssid, password);\n \n  //等待WiFi连接,连接成功打印IP\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(1000);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"WiFi Connected!\");   \n}\n```\n\n\n\n\n","tags":["protected","ESP8266"],"categories":["ESP8266","开发资料"]},{"title":"MySql基础笔记","url":"/2023/06/05/MySql基础笔记/","content":"\n# MySql杂项\n\n## 主要目录结构\n\n| MySQL的目录结构                             | 说明                                 |\n| ------------------------------------------- | ------------------------------------ |\n|                                             |                                      |\n| bin目录                                     | 所有MySQL的可执行文件。如: mysql.exe |\n| MySQLInstanceConfig.exe                     | 数据库的配置向导,在安装时出现的内容  |\n| data目录                                    | 系统数据库所在的目录                 |\n| my.ini文件                                  | MySQL的主要配置文件                  |\n| c:\\ProgramData\\MySQL\\MySQL Server 8.0\\data\\ | 用户创建的数据库所在的目录           |\n\n\n\n## MySql登录\n\n### 服务的启动与停止\n\nMySQL安装完毕之后，需要启动服务器进程，不然客户端无法连接数据库。 \n\n在前面的配置过程中，已经将MySQL安装为Windows服务，并且勾选当Windows启动、停止时，MySQL也 自动启动、停止。 \n\n#### 方式1：使用图形界面工具 \n\n步骤1：打开windows服务 \n\n1. 计算机（点击鼠标右键）→ 管理（点击）→ 服务和应用程序（点击）→ 服务（点 击） 方式\n2. 控制面板（点击）→ 系统和安全（点击）→ 管理工具（点击）→ 服务（点击）\n3. 任务栏（点击鼠标右键）→ 启动任务管理器（点击）→ 服务（点击）\n4. 单击【开始】菜单，在搜索框中输入“services.msc”，按Enter键确认 \n\n步骤2：找到MySQL80（点击鼠标右键）→ 启动或停止（点击）\n\n![image-20230531143855007](./Image/MySql基础笔记.assets/image-20230531143855007.png)\n\n\n\n#### 方式2：使用命令行工具\n\n```bash\n# 启动 MySQL 服务命令：\nnet start MySQL服务名\n# 停止 MySQL 服务命令：\nnet stop MySQL服务名\n```\n\n![image-20230531143948032](./Image/MySql基础笔记.assets/image-20230531143948032.png)\n\n\n\n说明： \n\n1. start和stop后面的服务名应与之前配置时指定的服务名一致。\n2. 如果当你输入命令后，提示“拒绝服务”，请以 系统管理员身份 打开命令提示符界面重新尝试。\n\n\n\n### 自带客户端的登录与退出\n\n当MySQL服务启动完成后，便可以通过客户端来登录MySQL数据库。注意：确认服务是开启的。\n\n登录方式1：MySQL自带客户端 \n\n`开始菜单 → 所有程序 → MySQL → MySQL 8.0 Command Line Client`\n\n说明：**说明：仅限于root用户**\n\n\n\n登录方式2：\n\nwindows命令行 \n\n- 格式： \n\n  - `mysql -h 主机名 -P 端口号 -u 用户名 -p密码`\n\n- 样例： \n\n  - `mysql -h localhost -P 3306 -u root -pabc123`\n  - 这里我设置的root用户的密码是abc123\n  - ![image-20230531144241013](./Image/MySql基础笔记.assets/image-20230531144241013.png)\n\n  \n\n  注意： \n\n  1. -p与密码之间不能有空格，其他参数名与参数值之间可以有空格也可以没有空格。如： \n\n     `mysql -hlocalhost -P3306 -uroot -pabc123`\n\n  2. 密码建议在下一行输入，保证安全 \n\n     `mysql -h localhost -P 3306 -u root -p `\n\n     `Enter password:****`\n\n  3. 客户端和服务器在同一台机器上，所以输入localhost或者IP地址127.0.0.1。同时，因为是连接本机： -h localhost就可以省略，如果端口号没有修改：-P 3306也可以省略\n\n     简写成：\n\n     `mysql -u root -p `\n\n     `Enter password:****`\n\n     \n\n  连接成功后，有关于MySQL Server服务版本的信息，还有第几次连接的id标识。 \n\n  也可以在命令行通过以下方式获取MySQL Server服务版本的信息： \n\n  `mysql -V`\n\n  `mysql --version`\n\n  或**登录**后，通过以下方式查看当前版本信息：\n\n  `mysql> select version();`\n\n   \n\n#### 退出登录\n\n`exit`或` quit`\n\n\n\n\n\n\n\n\n\n## 常见问题解决方案\n\n### root用户忘记密码\n\n1. 通过任务管理器或者服务管理，关掉mysqld(服务进程)\n2. 通过命令行+特殊参数开启mysqld\n   `mysqld --defaults-file=\"D:\\ProgramFiles\\mysql\\MySQL Server5.7Data\\my.ini\" --skip-grant-tables`\n3. 此时，mysqld服务进程已经打开。并且不需要权限检查\n4. mysql -uroot无密码登陆服务器。另启动一个客户端进行\n5. 修改权限表\n   (1) `use mysql;` \n   (2) `update user set authentication _string=password(新密码') where user='root' and Host='localhost';`\n   (3) `flush privileges;`\n6. 通过任务管理器，关掉mysqld服务进程。\n7. 再次通过服务管理，打开mysql服务。\n8. 即可用修改后的新密码登陆。\n\n### mysql命令报“不是内部或外部命令” \n\n如果输入mysql命令报“不是内部或外部命令”，把mysql安装目录的bin目录配置到环境变量path中。如 下：\n\n![image-20230531143138024](./Image/MySql基础笔记.assets/image-20230531143138024.png)\n\n### 错误ERROR ：没有选择数据库就操作表格和数据\n\nERROR 1046 (3D000): No database selected \n\n解决方案一：就是使用“USE 数据库名;”语句，这样接下来的语句就默认针对这个数据库进行操作。 \n\n解决方案二：就是所有的表对象前面都加上“数据库”。\n\n### 命令行客户端的字符集问题 \n\n```c\nmysql> INSERT INTO t_stu VALUES(1,'张三','男');\nERROR 1366 (HY000): Incorrect string value: '\\xD5\\xC5\\xC8\\xFD' for column 'sname' at row 1\n```\n\n原因：服务器端认为你的客户端的字符集是utf-8，而实际上你的客户端的字符集是GBK。\n\n![image-20230531143330709](./Image/MySql基础笔记.assets/image-20230531143330709.png)\n\n查看所有字符集：`SHOW VARIABLES LIKE 'character_set_%';`\n\n![image-20230531143358172](./Image/MySql基础笔记.assets/image-20230531143358172.png)\n\n解决方案，设置当前连接的客户端字符集 “SET NAMES GBK;”\n\n![image-20230531143417038](./Image/MySql基础笔记.assets/image-20230531143417038.png)\n\n\n\n### 修改数据库和表的字符编码 \n\n#### 修改编码\n\n1. 先停止服务\n2. 修改my.ini文件\n3. 重新启动服务 \n\n\n\n说明： 如果是在修改my.ini之前建的库和表，那么库和表的编码还是原来的Latin1，要么删了重建，要么使用 alter语句修改编码。\n\n```sql\nmysql> create database 0728db charset Latin1;\nQuery OK, 1 row affected (0.00 sec)\nmysql> use 0728db;\nDatabase changed\nmysql> create table student (id int , name varchar(20)) charset Latin1;\nQuery OK, 0 rows affected (0.02 sec)\nmysql> show create table student\\G\n*************************** 1. row ***************************\nTable: student\nCreate Table: CREATE TABLE `student` (\n`id` int(11) NOT NULL,\n`name` varchar(20) DEFAULT NULL,\nPRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1\n1 row in set (0.00 sec)\nmysql> alter table student charset utf8; #修改表字符编码为UTF8\nQuery OK, 0 rows affected (0.01 sec)\nRecords: 0 Duplicates: 0 Warnings: 0\nmysql> show create table student\\G\n*************************** 1. row ***************************\nTable: student\nCreate Table: CREATE TABLE `student` (\n`id` int(11) NOT NULL,\n`name` varchar(20) CHARACTER SET latin1 DEFAULT NULL, #字段仍然是latin1编码\nPRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n1 row in set (0.00 sec)\nmysql> alter table student modify name varchar(20) charset utf8; #修改字段字符编码为UTF8\nQuery OK, 0 rows affected (0.05 sec)\nRecords: 0 Duplicates: 0 Warnings: 0\nmysql> show create table student\\G\n*************************** 1. row ***************************\nTable: student\nCreate Table: CREATE TABLE `student` (\n`id` int(11) NOT NULL,\n`name` varchar(20) DEFAULT NULL,\nPRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n1 row in set (0.00 sec)\nmysql> show create database 0728db;;\n+--------+-----------------------------------------------------------------+\n|Database| Create Database |\n+------+-------------------------------------------------------------------+\n|0728db| CREATE DATABASE `0728db` /*!40100 DEFAULT CHARACTER SET latin1 */ |\n+------+-------------------------------------------------------------------+\n1 row in set (0.00 sec)\nmysql> alter database 0728db charset utf8; #修改数据库的字符编码为utf8\nQuery OK, 1 row affected (0.00 sec)\nmysql> show create database 0728db;\n+--------+-----------------------------------------------------------------+\n|Database| Create Database |\n+--------+-----------------------------------------------------------------+\n| 0728db | CREATE DATABASE `0728db` /*!40100 DEFAULT CHARACTER SET utf8 */ |\n+--------+-----------------------------------------------------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n# SQL概述\n\n## SQL 分类\n\nSQL语言在功能上主要分为如下3大类： \n\n- DDL（Data Definition Languages、数据定义语言），这些语句定义了不同的数据库、表、视图、索 引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。 \n  - 主要的语句关键字包括 CREATE 、 DROP 、 ALTER 等。 \n- DML（Data Manipulation Language、数据操作语言），用于添加、删除、更新和查询数据库记 录，并检查数据完整性。 \n  - 主要的语句关键字包括 INSERT 、 DELETE 、 UPDATE 、 SELECT 等。 SELECT是SQL语言的基础，最为重要。\n- DCL（Data Control Language、数据控制语言），用于定义数据库、表、字段、用户的访问权限和 安全级别。 \n  - 主要的语句关键字包括 GRANT 、 REVOKE 、 COMMIT 、 ROLLBACK 、 SAVEPOINT 等。\n\n> 因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。 还有单独将 COMMIT 、 ROLLBACK 取出来称为TCL （Transaction Control Language，事务控制语言）。\n\n\n\n## SQL语言的规则与规范\n\n### 基本规则 \n\n- SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进 \n\n- 每条命令以 ; 或 \\g 或 \\G 结束 \n\n- 关键字不能被缩写也不能分行 \n\n- 关于标点符号 \n\n  - 必须保证所有的()、单引号、双引号是成对结束的 \n  - 必须使用英文状态下的半角输入方式 字符串型和日期时间类型的数据可以使用单引号（' '）表示 \n  - 列的别名，尽量使用双引号（\" \"），而且不建议省略as \n\n  \n\n###  SQL大小写规范 （建议遵守）\n\n- MySQL 在 Windows 环境下是大小写不敏感的 \n- MySQL 在 Linux 环境下是大小写敏感的 \n  - 数据库名、表名、表的别名、变量名是严格区分大小写的 \n  - 关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。 \n- 推荐采用统一的书写规范： \n  - 数据库名、表名、表别名、字段名、字段别名等都小写 \n  - SQL 关键字、函数名、绑定变量等都大写 \n\n### 注 释 \n\n可以使用如下格式的注释结构 ：\n\n`单行注释：#注释文字(MySQL特有的方式) `\n\n`单行注释：-- 注释文字(--后面必须包含一个空格。) `\n\n`多行注释：/* 注释文字 */`\n\n\n\n### 命名规则\n\n- 数据库、表名不得超过30个字符，变量名限制为29个 \n- 必须只能包含 A–Z, a–z, 0–9, _共63个字符 \n- 数据库名、表名、字段名等对象名中间不要包含空格 \n- 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使 用`（着重号）引起来 \n- 保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据 类型在一个表里是整数，那在另一个表里不要变成字符型。\n\n\n\n### 样例\n\n```mysql\n#以下两句是一样的，不区分大小写\nshow databases;\nSHOW DATABASES;\n\n#创建表格\n#create table student info(...); #表名错误，因为表名有空格\ncreate table student_info(...);\n\n#其中order使用``飘号，因为order和系统关键字或系统函数名等预定义标识符重名了\nCREATE TABLE `order`(\n    id INT,\n    lname VARCHAR(20)\n);\nselect id as \"编号\", `name` as \"姓名\" from t_stu; #起别名时，as都可以省略\nselect id as 编号, `name` as 姓名 from t_stu; #如果字段别名中没有空格，那么可以省略\"\"\nselect id as 编 号, `name` as 姓 名 from t_stu; #错误，如果字段别名中有空格，那么不能省略\"\"\n\n```\n\n\n\n## 数据导入指令 \n\n在命令行客户端登录mysql，使用source指令导入\n\n```mysql\nmysql> source d:\\mysqldb.sql\nmysql> desc employees;\n+----------------+-------------+------+-----+---------+-------+\n| Field | Type | Null | Key | Default | Extra |\n+----------------+-------------+------+-----+---------+-------+\n| employee_id | int(6) | NO | PRI | 0 | |\n| first_name | varchar(20) | YES | | NULL | |\n| last_name | varchar(25) | NO | | NULL | |\n| email | varchar(25) | NO | UNI | NULL | |\n| phone_number | varchar(20) | YES | | NULL | |\n| hire_date | date | NO | | NULL | |\n| job_id | varchar(10) | NO | MUL | NULL | |\n| salary | double(8,2) | YES | | NULL | |\n| commission_pct | double(2,2) | YES | | NULL | |\n| manager_id | int(6) | YES | MUL | NULL | |\n| department_id | int(4) | YES | MUL | NULL | |\n+----------------+-------------+------+-----+---------+-------+\n11 rows in set (0.00 sec)\n```\n\n\n\n![image-20230603132720968](./Image/MySql基础笔记.assets/image-20230603132720968.png)\n\n\n\n# 基本的SELECT语句\n\n## SELECT\n\n没有任何其他的子句，只有一个Select + 表达式。如：\n\n```mysql\nSELECT 9 * 8;\n```\n\n直接显示出来，9 * 8作为列名，列中只有一个单元格，单元格中为表达式的答案72。\n\n\n\n## SELECT ... FROM \n\n### 基本语法\n\n```\nSELECT 标识选择哪些列 FROM 标识从哪个表中选择\n\nSELECT 字段1， 字段2，... FROM 表名;\n```\n\n### 功能\n\n查询指定的表中指定的字段的内容。\n\n### 说明\n\n- 如果需要查询所有列，可以使用通配符*。\n  - 如：`SELECT * FROM employees;`\n\n> 一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通 配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。 在生产环境下，不推荐你直接使用 SELECT * 进行查询。\n\n\n\n\n\n### 样例\n\n#### 查询所有的列\n\n```\nSELECT * FROM employees;\n```\n\n![image-20230603134129915](./Image/MySql基础笔记.assets/image-20230603134129915.png)\n\n#### 查询指定的列（只查询id、姓名和邮箱）\n\n```\nSELECT employee_id, first_name, last_name, email FROM employees;\n```\n\n![image-20230603134255074](./Image/MySql基础笔记.assets/image-20230603134255074.png)\n\n\n\n## 给查询到的列起别名  AS\n\n### 功能\n\n- 重命名一个列 便于计算 \n- 紧跟列名，也可以在列名和别名之间加入关键字AS，别名使用双引号，以便在别名中包含空格或特殊的字符并区分大小写。\n- AS 可以省略 \n- 建议别名简短，见名知意\n\n### 基本语法\n\n`SELECT 列名1 as 别名1 ... FROM 表名;`\n\n### 样例\n\n```\nSELECT employee_id AS id, first_name 名, last_name 姓, email AS 邮箱 FROM employees;\n```\n\n![image-20230603140037428](./Image/MySql基础笔记.assets/image-20230603140037428.png)\n\n### 注意事项\n\n**需要注意，列的别名只能在order by中使用，在where中使用会报错。**\n\n## 去除重复行 DISTINCT\n\n默认情况下，查询会返回全部行，包括重复行。\n\n### 基本语法\n\n`select DISTINCT 列名 from 表明`\n\n### 注意事项\n\n- DISTINCT 需要放到所有列名的前面，如果写成 `SELECT salary, DISTINCT department_id FROM employees` 会报错。 \n- DISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 74 条，因为这 74 个部 门id不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门（department_id），只需 要写 DISTINCT department_id 即可，后面不需要再加其他的列名了。\n\n### 样例\n\n```\nSELECT DISTINCT first_name AS 名 FROM employees;\n```\n\n![image-20230603141205086](./Image/MySql基础笔记.assets/image-20230603141205086.png)\n\n\n\n## 使 空值 参与运算\n\n所有运算符或列值遇到null值，运算的结果都为null。 \n\n### 样例\n\n#### 计算每个人每年能挣多少钱\n\n```\nSELECT employee_id,salary,commission_pct, \n12 * salary * (1 + commission_pct) \"annual_sal\"\nFROM employees;\n```\n\n![image-20230603144928266](./Image/MySql基础笔记.assets/image-20230603144928266.png)\n\n因为有人的奖金为null，如果直接计算则结果也为null\n\n解决方案：引入IFNULL。\n\n\n\n## 着重号\n\n我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在 SQL语句中使用一对``（着重号）引起来。\n\n\n\n### 样例\n\n要查询的Order表的表名与关键字冲突了，因此需要使用着重号进行标记。\n\n```\nSELECT * FROM `order`;\n```\n\n![image-20230603150001147](./Image/MySql基础笔记.assets/image-20230603150001147.png)\n\n\n\n\n\n## 查询结果中添加指定常数\n\nSELECT 查询还可以对常数进行查询，就是在 SELECT 查询结果中增加一列固定的常数列。这列的取值是手动指定的，而不是从数据表中动态取出的。\n\n如果想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。 比如说，我们想对 employees 数据表中的员工姓名进行查询，同时增加一列字段 corporation ，这个字段固定值为“尚硅谷”，可以这样写：\n\n```\nSELECT '尚硅谷' as corporation, last_name FROM employees;\n```\n\n\n\n## 筛选（过滤）数据 WHERE\n\n样例：筛选出employees表中姓King的人\n\n```\nSELECT * FROM employees WHERE last_name = 'King';\n```\n\n![image-20230603151825884](./Image/MySql基础笔记.assets/image-20230603151825884.png)\n\n### 注意事项\n\n**在sql中，等于的符号是单等号而不是双等号**\n\n**在sql中，等于的符号是单等号而不是双等号**\n\n**在sql中，等于的符号是单等号而不是双等号**\n\n\n\n**需要注意，列的别名只能在order by中使用，在where中使用会报错。**\n\n\n\n# 显示表结构\n\n使用DESCRIBE 或 DESC 命令，表示表结构。\n\n```mysql\nDESCRIBE employees;\n或\nDESC employees;\nmysql> desc employees;\n+----------------+-------------+------+-----+---------+-------+\n| Field | Type | Null | Key | Default | Extra |\n+----------------+-------------+------+-----+---------+-------+\n| employee_id | int(6) | NO | PRI | 0 | |\n| first_name | varchar(20) | YES | | NULL | |\n| last_name | varchar(25) | NO | | NULL | |\n| email | varchar(25) | NO | UNI | NULL | |\n| phone_number | varchar(20) | YES | | NULL | |\n| hire_date | date | NO | | NULL | |\n| job_id | varchar(10) | NO | MUL | NULL | |\n| salary | double(8,2) | YES | | NULL | |\n| commission_pct | double(2,2) | YES | | NULL | |\n| manager_id | int(6) | YES | MUL | NULL | |\n| department_id | int(4) | YES | MUL | NULL | |\n+----------------+-------------+------+-----+---------+-------+\n11 rows in set (0.00 sec)\n```\n\n![image-20230603150805928](./Image/MySql基础笔记.assets/image-20230603150805928.png)\n\n\n\n\n\n# 运算符\n\n## 算术运算符\n\n算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加 （+）、减（-）、乘（*）、除（/）和取模（%）运算。\n\n| 运算符 | 名称               | 作用                     | 样例                         |\n| ------ | ------------------ | ------------------------ | ---------------------------- |\n| +      | 加法运算符         | 计算两个值或表达式的和   | select a + b                 |\n| -      | 减法运算符         | 计算两个值或表达式的差   | select a - b                 |\n| *      | 乘法运算符         | 计算两个值或表达式的乘积 | select a * b                 |\n| /或DIV | 除法运算符         | 计算两个值或表达式的商   | select a / b或select a DIV b |\n| %或MOD | 求模（求余）运算符 | 计算两个值或表达式的余数 | select a % b或select a MOD b |\n\n\n\n### 加法与减法运算符\n\n```sql\nmysql> SELECT 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 -30, 100 + 35.5, 100 - 35.5\nFROM dual;\n+-----+---------+---------+----------+--------------+------------+------------+\n| 100 | 100 + 0 | 100 - 0 | 100 + 50 | 100 + 50 -30 | 100 + 35.5 | 100 - 35.5 |\n+-----+---------+---------+----------+--------------+------------+------------+\n| 100 | 100 | 100 | 150 | 120 | 135.5 | 64.5 |\n+-----+---------+---------+----------+--------------+------------+------------+\n1 row in set (0.00 sec)\n\n```\n\n由运算结果可以得出如下结论：\n\n- 一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；\n- 一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；\n- 加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的； \n- 在Java、C#中，+的左右两边如果有字符串，那么表示字符串的拼接。但是**在MySQL中+只表示数值相加**。如果遇到非数值类型，先尝试转成数值(隐式转换)，如果转失败，就按0计算。（补充：MySQL 中字符串拼接要使用字符串函数CONCAT()实现）\n\n#### 样例\n\n```\nmysql> select 1 + 2;\n+-------+\n| 1 + 2 |\n+-------+\n|     3 |\n+-------+\n1 row in set (0.00 sec)\n```\n\n```\nmysql> select 1 + 'a';\n+---------+\n| 1 + 'a' |\n+---------+\n|       1 |\n+---------+\n1 row in set, 1 warning (0.01 sec)\n```\n\n```\nmysql> select 1 + null;\n+----------+\n| 1 + null |\n+----------+\n|     NULL |\n+----------+\n1 row in set (0.00 sec)\n```\n\n\n\n### 乘法与除法运算符\n\n```mysql\nmysql> SELECT 100, 100 * 1, 100 * 1.0, 100 / 1.0, 100 / 2,100 + 2 * 5 / 2,100 /3, 100\nDIV 0 FROM dual;\n+-----+---------+-----------+-----------+---------+-----------------+---------+-------\n----+\n| 100 | 100 * 1 | 100 * 1.0 | 100 / 1.0 | 100 / 2 | 100 + 2 * 5 / 2 | 100 /3 | 100\nDIV 0 |\n+-----+---------+-----------+-----------+---------+-----------------+---------+-------\n----+\n| 100 | 100 | 100.0 | 100.0000 | 50.0000 | 105.0000 | 33.3333 |\nNULL |\n+-----+---------+-----------+-----------+---------+-----------------+---------+-------\n----+\n1 row in set (0.00 sec)\n```\n\n```mysql\n#计算出员工的年基本工资\nSELECT employee_id,salary,salary * 12 annual_sal FROM employees;\n```\n\n由运算结果可以得出如下结论：\n\n- 一个数乘以整数1和除以整数1后仍得原数； \n- 一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等；\n- 一个数除以整数后，不管是否能除尽，结果都为一个浮点数； \n- 一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位；\n- 乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。 \n- 在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。\n\n\n\n\n\n### 求模（求余）运算符\n\n```mysql\nmysql> SELECT 12 % 3, 12 MOD 5 FROM dual;\n+--------+----------+\n| 12 % 3 | 12 MOD 5 |\n+--------+----------+\n| 0 | 2 |\n+--------+----------+\n1 row in set (0.00 sec)\n```\n\n```mysql\n#筛选出employee_id是偶数的员工\nSELECT * FROM employees\nWHERE employee_id MOD 2 = 0;\n```\n\n可以看到，100对3求模后的结果为3，对5求模后的结果为0。\n\n\n\n## 比较运算符\n\n比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果 为假则返回0，其他情况则返回NULL。 比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。\n\n| 运算符    | 名称           | 作用                                                         | 样例                                                         |\n| --------- | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| =         | 等于运算符     | 判断两个值、字符串或表达式是否相等                           | select from table where a = b                                |\n| <=>       | 安全等于运算符 | 安全的判断两个值、字符串或表达式是否相等                     | select from table where a <=> b                              |\n| <> 或 ！= | 不等于运算符   | 判断两个值、字符串或表达式是否不相等                         | select from table where a <> b 或 select from table where a != b |\n| <         | 小于运算符     | 判断前面的值、字符串或表达式是否小于后面的值、字符串或表达式 | select from table where a < b                                |\n| <=        | 小于等于运算符 | 判断前面的值、字符串或表达式是否小于等于后面的值、字符串或表达式 | select from table where a <= b                               |\n| >         | 大于运算符     | 判断前面的值、字符串或表达式是否大于后面的值、字符串或表达式 | select from table where a > b                                |\n| >=        | 大于等于运算符 | 判断前面的值、字符串或表达式是否大于等于后面的值、字符串或表达式 | select from table where a >= b                               |\n\n\n\n### 等号运算符\n\n- 等号运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回 0。 \n- 在使用等号运算符时，遵循如下规则：\n  - 如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。 \n  - 如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。 \n  - 如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。 \n  - 如果等号两边的值、字符串或表达式中只要有一个为NULL，则比较结果为NULL。 \n    - 因此，在试图筛选出指定列的值为null的情况下，不能直接where 列名 = null。\n    - 但可以使用 列名 <=> null来实现\n- 对比：SQL中赋值符号使用 :=\n\n```mysql\nmysql> SELECT 1 = 1, 1 = '1', 1 = 0, 'a' = 'a', (5 + 3) = (2 + 6), '' = NULL , NULL =\nNULL;\n+-------+---------+-------+-----------+-------------------+-----------+-------------+\n| 1 = 1 | 1 = '1' | 1 = 0 | 'a' = 'a' | (5 + 3) = (2 + 6) | '' = NULL | NULL = NULL |\n+-------+---------+-------+-----------+-------------------+-----------+-------------+\n| 1 | 1 | 0 | 1 | 1 | NULL | NULL |\n+-------+---------+-------+-----------+-------------------+-----------+-------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT 1 = 2, 0 = 'abc', 1 = 'abc' FROM dual;\n+-------+-----------+-----------+\n| 1 = 2 | 0 = 'abc' | 1 = 'abc' |\n+-------+-----------+-----------+\n| 0 | 1 | 0 |\n+-------+-----------+-----------+\n1 row in set, 2 warnings (0.00 sec)\n```\n\n```mysql\n#查询salary=10000，注意在Java中比较是==\nSELECT employee_id,salary FROM employees WHERE salary = 10000;\n```\n\n### 安全等于运算符\n\n安全等于运算符（<=>）与等于运算符（=）的作用是相似的， 唯一的区别 是‘<=>’可 以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL 时，其返回值为0，而不为NULL。\n\n```mysql\nmysql> select 1 = '1', 1 = 'a', 0 = 'a';\n+---------+---------+---------+\n| 1 = '1' | 1 = 'a' | 0 = 'a' |\n+---------+---------+---------+\n|       1 |       0 |       1 |\n+---------+---------+---------+\n1 row in set, 2 warnings (0.01 sec)\n#字符串存在隐式类型转换。如果转换数值不成功，则视为0。\n```\n\n```mysql\nmysql> select 'a' = 'a' , 'a' = 'b';\n+-----------+-----------+\n| 'a' = 'a' | 'a' = 'b' |\n+-----------+-----------+\n|         1 |         0 |\n+-----------+-----------+\n1 row in set (0.00 sec)\n#对于两边都是字符串类型的值来说，并不会触发隐式类型转换\n```\n\n\n\n```mysql\nmysql> SELECT 1 <=> '1', 1 <=> 0, 'a' <=> 'a', (5 + 3) <=> (2 + 6), '' <=> NULL,NULL\n<=> NULL FROM dual;\n+-----------+---------+-------------+---------------------+-------------+-------------\n--+\n| 1 <=> '1' | 1 <=> 0 | 'a' <=> 'a' | (5 + 3) <=> (2 + 6) | '' <=> NULL | NULL <=>\nNULL |\n+-----------+---------+-------------+---------------------+-------------+-------------\n--+\n| 1 | 0 | 1 | 1 | 0 |\n1 |\n+-----------+---------+-------------+---------------------+-------------+-------------\n--+\n1 row in set (0.00 sec)\n```\n\n```mysql\n#查询commission_pct等于0.40\nSELECT employee_id,commission_pct FROM employees WHERE commission_pct = 0.40;\nSELECT employee_id,commission_pct FROM employees WHERE commission_pct <=> 0.40;\n#如果把0.40改成 NULL 呢？\n```\n\n\n\n可以看到，使用安全等于运算符时，两边的操作数的值都为NULL时，返回的结果为1而不是NULL，其他 返回结果与等于运算符相同。 \n\n### 不等于运算符\n\n 不等于运算符（<>和!=）用于判断两边的数字、字符串或者表达式的值是否不相等， 如果不相等则返回1，相等则返回0。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL， 或两边都为NULL，则结果为NULL。 SQL语句示例如下：\n\n```mysql\nmysql> SELECT 1 <> 1, 1 != 2, 'a' != 'b', (3+4) <> (2+6), 'a' != NULL, NULL <> NULL;\n+--------+--------+------------+----------------+-------------+--------------+\n| 1 <> 1 | 1 != 2 | 'a' != 'b' | (3+4) <> (2+6) | 'a' != NULL | NULL <> NULL |\n+--------+--------+------------+----------------+-------------+--------------+\n| 0 | 1 | 1 | 1 | NULL | NULL |\n+--------+--------+------------+----------------+-------------+--------------+\n1 row in set (0.00 sec)\n```\n\n此外，还有非符号类型的运算符:\n\n| 运算符      | 名称             | 作用                                   | 样例                                        |\n| ----------- | ---------------- | -------------------------------------- | ------------------------------------------- |\n| IS NULL     | 为空运算符       | 判断值、字符串或表达式是否为空         | SELECT B FROM TABLE WHERE A IS NULL         |\n| IS NOT NULL | 不为空运算符     | 判断值、字符串或表达式是否不为空       | SELECT B FROM TABLE WHERE A IS NOT NULL     |\n| LEAST       | 最小值运算符     | 在多个值中返回最小值                   | SELECT D FROM TABLE WHERE C LEAST(A,B)      |\n| GREATEST    | 最大值运算符     | 在多个值中返回最大值                   | SELECT D FROM TABLE WHERE C GREATEST(A,B)   |\n| BETWEEN AND | 两值之间运算符   | 判断一个值是否在指定的两个值之间       | SELECT D FROM TABLE WHERE C BETWEEN A AND B |\n| ISNULL      | 为空运算符       | 判断值、字符串或表达式是否为空         | SELECT B FROM TABLE WHERE ISNULL(A)         |\n| IN          | 属于运算符       | 判断一个值是否是为列表中的任意一个值   | SELECT B FROM TABLE WHERE C IN (A,B)        |\n| NOT IN      | 不属于运算符     | 判断一个值是否不是为列表中的任意一个值 | SELECT B FROM TABLE WHERE C NOT IN (A,B)    |\n| LIKE        | 模糊匹配运算符   | 判断一个值是否符合模糊匹配             | SELECT C FROM TABLE WHERE A LIKE B          |\n| REGEXP      | 正则表达式运算符 | 判断一个值是否符合正则表达式的规则     | SELECT C FROM TABLE WHERE A REGEXP B        |\n| RLIKE       | 正则表达式运算符 | 判断一个值是否符合正则表达式的规则     | SELECT C FROM TABLE WHERE A RLIKE B         |\n\n#### ISNULL()和is null区别\n\n##### 语法\n\n- is null\n\n```sql\nselect * from 表名 where  字段名  is null;\n```\n\n-  ISNULL()\n\n```sql\nselect * from 表名 where  ISNULL(字段名);\n```\n\n- 比较区别\n\n  - 执行sql\n\n  - ```sql\n    select * from fts_srv_dtr_f where  ISNULL(BRANCH_NAME);\n    \n    select * from fts_srv_dtr_f where  BRANCH_NAME is null;\n    ```\n\n  - 执行结果（is null比isnull()稍微快一点）\n\n  - ![image-20230604131602323](./Image/MySql基础笔记.assets/image-20230604131602323.png)\n\n\n\n\n\n### 空运算符\n\n 空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回1，否则返回 0。 SQL语句示例如下：\n\n```MYSQL\nmysql> SELECT NULL IS NULL, ISNULL(NULL), ISNULL('a'), 1 IS NULL;\n+--------------+--------------+-------------+-----------+\n| NULL IS NULL | ISNULL(NULL) | ISNULL('a') | 1 IS NULL |\n+--------------+--------------+-------------+-----------+\n| 1 | 1 | 0 | 0 |\n+--------------+--------------+-------------+-----------+\n1 row in set (0.00 sec)\n#查询commission_pct等于NULL。比较如下的四种写法\nSELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NULL;\nSELECT employee_id,commission_pct FROM employees WHERE commission_pct <=> NULL;\nSELECT employee_id,commission_pct FROM employees WHERE ISNULL(commission_pct);\nSELECT employee_id,commission_pct FROM employees WHERE commission_pct = NULL;\nSELECT last_name, manager_id\nFROM employees\nWHERE manager_id IS NULL;\n```\n\n\n\n### 非空运算符 \n\n非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回1，否则返 回0。 SQL语句示例如下：\n\n```mysql\nmysql> SELECT NULL IS NOT NULL, 'a' IS NOT NULL, 1 IS NOT NULL;\n+------------------+-----------------+---------------+\n| NULL IS NOT NULL | 'a' IS NOT NULL | 1 IS NOT NULL |\n+------------------+-----------------+---------------+\n| 0 | 1 | 1 |\n+------------------+-----------------+---------------+\n1 row in set (0.01 sec)\n```\n\n```mysql\n#查询commission_pct不等于NULL\nSELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NOT NULL;\nSELECT employee_id,commission_pct FROM employees WHERE NOT commission_pct <=> NULL;\nSELECT employee_id,commission_pct FROM employees WHERE NOT ISNULL(commission_pct);\n```\n\n\n\n\n\n### 最小值运算符 LEAST\n\n语法格式为:\n\nLEAST(值1，值2，...，值n)。其中，“值n”表示参数列表中有n个值。在有 两个或多个参数的情况下，返回最小值。\n\n```mysql\nmysql> SELECT LEAST (1,0,2), LEAST('b','a','c'), LEAST(1,NULL,2);\n+---------------+--------------------+-----------------+\n| LEAST (1,0,2) | LEAST('b','a','c') | LEAST(1,NULL,2) |\n+---------------+--------------------+-----------------+\n| 0 | a | NULL |\n+---------------+--------------------+-----------------+\n1 row in set (0.00 sec)\n```\n\n由结果可以看到，当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。 \n\n同时这个函数（或者说运算符？）对大小写不敏感，并且如果出现多个相等的最小值的时候，谁最先出现谁就是最小值。\n\n```mysql\nmysql> SELECT LEAST('a', 'b', 'A');\n+----------------------+\n| LEAST('a', 'b', 'A') |\n+----------------------+\n| a                    |\n+----------------------+\n1 row in set (0.01 sec)\n\nmysql> SELECT LEAST('A', 'b', 'a');\n+----------------------+\n| LEAST('A', 'b', 'a') |\n+----------------------+\n| A                    |\n+----------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n\n\n\n\n\n\n### 最大值运算符 GREATEST\n\n 语法格式为：GREATEST(值1，值2，...，值n)。其中，n表示参数列表中有n个值。当有 两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。\n\n```mysql\nmysql> SELECT GREATEST(1,0,2), GREATEST('b','a','c'), GREATEST(1,NULL,2);\n+-----------------+-----------------------+--------------------+\n| GREATEST(1,0,2) | GREATEST('b','a','c') | GREATEST(1,NULL,2) |\n+-----------------+-----------------------+--------------------+\n| 2 | c | NULL |\n+-----------------+-----------------------+--------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n由结果可以看到，当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时， 返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。 \n\n与上一个LEAST运算符一样，对大小写不敏感，谁在前谁就是最大值。（似乎是字符集utf-8 mb4-ci的锅？）\n\n```mysql\nmysql> SELECT GREATEST('B', 'b', 'a');\n+-------------------------+\n| GREATEST('B', 'b', 'a') |\n+-------------------------+\n| B                       |\n+-------------------------+\n1 row in set (0.00 sec)\n\nmysql> SELECT GREATEST('b', 'B', 'a');\n+-------------------------+\n| GREATEST('b', 'B', 'a') |\n+-------------------------+\n| b                       |\n+-------------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n\n\n### 关于LEAST和GREATEST比较时不区分大小写的问题\n\n可能是一下原因造成的。\n\n在 MySQL 中，`LEAST` 函数的比较是不区分大小写的。这是因为 MySQL 默认使用的字符集是不区分大小写的（如utf8generalci）。因此，对于 `LEAST` 函数的比较操作而言，这个默认的字符集规则同样适用。这也意味着在对字符串进行比较时，字符的大小写是被忽略的。\n\n但是，如果你需要区分大小写进行比较的话，可以使用 `BINARY` 关键字强制 MySQL 区分大小写。例如：\n\n```sql\n复制代码SELECT LEAST(BINARY 'A', BINARY 'a');\n```\n\n以上语句会返回 'A'，因为 'A' 的 ASCII 码值比 'a' 的小。\n\n需要注意的是，在实际编写 SQL 语句时，请根据具体的业务需求选择适当的字符集规则和比较方式。\n\n\n\n### BETWEEN AND运算符\n\nBETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND B，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0。\n\n```mysql\nmysql> SELECT 1 BETWEEN 0 AND 1, 10 BETWEEN 11 AND 12, 'b' BETWEEN 'a' AND 'c';\n+-------------------+----------------------+-------------------------+\n| 1 BETWEEN 0 AND 1 | 10 BETWEEN 11 AND 12 | 'b' BETWEEN 'a' AND 'c' |\n+-------------------+----------------------+-------------------------+\n| 1 | 0 | 1 |\n+-------------------+----------------------+-------------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n```mysql\nSELECT last_name, salary\nFROM employees\nWHERE salary BETWEEN 2500 AND 3500;\n```\n\n同时between...and运算符的区间是左闭右闭的区间。\n\n```mysql\nmysql> select 3 between 3 and 5;\n+-------------------+\n| 3 between 3 and 5 |\n+-------------------+\n|                 1 |\n+-------------------+\n1 row in set (0.00 sec)\n\nmysql> select 5 between 3 and 5;\n+-------------------+\n| 5 between 3 and 5 |\n+-------------------+\n|                 1 |\n+-------------------+\n1 row in set (0.00 sec)\n\nmysql> select 2 between 3 and 5;\n+-------------------+\n| 2 between 3 and 5 |\n+-------------------+\n|                 0 |\n+-------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n### IN运算符\n\nIN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给 定的值为NULL，或者IN列表中存在NULL，则结果为NULL。\n\n```mysql\nmysql> SELECT 'a' IN ('a','b','c'), 1 IN (2,3), NULL IN ('a','b'), 'a' IN ('a', NULL);\n+----------------------+------------+-------------------+--------------------+\n| 'a' IN ('a','b','c') | 1 IN (2,3) | NULL IN ('a','b') | 'a' IN ('a', NULL) |\n+----------------------+------------+-------------------+--------------------+\n| 1 | 0 | NULL | 1 |\n+----------------------+------------+-------------------+--------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nSELECT employee_id, last_name, salary, manager_id\nFROM employees\nWHERE manager_id IN (100, 101, 201);\n```\n\n\n\n### NOT IN运算符\n\nNOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一 个值，则返回1，否则返回0。\n\n```\nmysql> SELECT 'a' NOT IN ('a','b','c'), 1 NOT IN (2,3);\n+--------------------------+----------------+\n| 'a' NOT IN ('a','b','c') | 1 NOT IN (2,3) |\n+--------------------------+----------------+\n| 0 | 1 |\n+--------------------------+----------------+\n1 row in set (0.00 sec)\n```\n\n\n\n\n\n### LIKE运算符\n\nLIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回 0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。 LIKE运算符通常使用如下通配符：\n\n`“%”：匹配0个或多个字符。`\n\n` “_”：只能匹配一个字符。`\n\nSQL语句示例如下：\n\n```mysql\nmysql> SELECT NULL LIKE 'abc', 'abc' LIKE NULL;\n+-----------------+-----------------+\n| NULL LIKE 'abc' | 'abc' LIKE NULL |\n+-----------------+-----------------+\n| NULL | NULL |\n+-----------------+-----------------+\n1 row in set (0.00 sec)\n```\n\n\n\n```mysql\nSELECT first_name\nFROM employees\nWHERE first_name LIKE 'S%';\nSELECT last_name\nFROM employees\nWHERE last_name LIKE '_o%';\n```\n\n\n\n#### 转义字符'\\\\'\n\n- 回避特殊符号的：**使用转义符**。\n\n例如：将[%]转为[$%]、[]转为[$]，然后再加上[ESCAPE‘$’]即可。\n\n```mysql\nSELECT job_id\nFROM jobs\nWHERE job_id LIKE ‘IT\\_%‘\n```\n\n\n\n如果使用\\表示转义，要省略ESCAPE。如果不是\\，则要加上ESCAPE。\n\n```mysql\nSELECT job_id\nFROM jobs\nWHERE job_id LIKE ‘IT$_%‘ escape ‘$‘;\n```\n\n\n\n##### 样例\n\n查询出姓中第二个字符是下划线，同时第三个字符是a的数据（保证数据存在且仅有1个）。\n\n由于下划线是特殊字符，因此需要转义成普通的字符来处理。转义符号与其他语言中类似，都是反斜杠。\n\n```mysql\nSELECT last_name FROM employees WHERE last_name LIKE '_\\_a%'\n```\n\n![image-20230604184703473](./Image/MySql基础笔记.assets/image-20230604184703473.png)\n\n\n\n\n\n#### 自定义转义字符 ESCAPE\n\n如果想自定义转义字符的话，可以使用`ESCAPE`关键字。\n\n在 MySQL 中，`ESCAPE` 关键字是用在 `LIKE` 子句中的可选项，用于指定用于转义通配符的转义字符。当 `LIKE` 子句中需要匹配通配符本身时，需要使用转义字符对其进行转义。例如，在 `LIKE` 子句中使用 `%` 通配符，如果要匹配含有 `%` 的字符串，则需要在 `%` 前添加转义字符 `\\`。\n\n使用 `ESCAPE` 关键字可以指定一个字符作为转义字符，从而在 `LIKE` 子句中避免使用 `\\` 转义字符进行转义。该语法如下所示：\n\n```sql\nSELECT * FROM table_name WHERE column LIKE 'match_string' ESCAPE 'escape_character';\n```\n\n其中，`escape_character` 表示用于转义通配符的转义字符。在 `LIKE` 子句中，任何出现在 `escape_character` 后面的字符都被视为普通字符，而不是通配符。\n\n例如，以下查询语句使用 `ESCAPE` 关键字指定 `#` 字符作为转义字符，来匹配以 `#` 开头的字符串：\n\n```sql\n复制代码SELECT * FROM table_name WHERE column LIKE '#%%' ESCAPE '#';\n```\n\n这个查询将会匹配以 `#` 符号开头的任何字符串，包括 `#abc`、`#xyz%` 等。\n\n需要注意的是，默认情况下，MySQL 使用 `\\` 字符作为转义字符。如果未指定 `ESCAPE` 子句，则使用 `\\` 作为转义字符。\n\n##### 样例\n\n查询出姓中第二个字符是下划线，同时第三个字符是a的数据（保证数据存在且仅有1个要求使用小写的英文字母z作为转义字符。\n\n```mysql\nSELECT last_name FROM employees WHERE last_name LIKE '_z_a%' ESCAPE 'z'\n```\n\n![image-20230604184703473](./Image/MySql基础笔记.assets/image-20230604184703473.png)\n\n\n\n\n\n\n\n### REGEXP运算符\n\nREGEXP运算符用来匹配字符串，语法格式为： `expr REGEXP 匹配条件` 。\n\n如果expr满足匹配条件，返回 1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果为NULL。\n\nREGEXP运算符在进行匹配时，常用的有下面几种通配符：\n\n1. ‘^’匹配以该字符后面的字符开头的字符串。 \n2. ‘$’匹配以该字符前面的字符结尾的字符串。 \n3. ‘.’匹配任何一个单字符。\n4. “[...]”匹配在方括号内的任何字符。\n   - 例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一 个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。 \n5. ‘*’匹配零个或多个在它前面的字符。*\n   - *例如，“x*”匹配任何数量的‘x’字符，“[0-9]*”匹配任何数量的数字， 而“*”匹配任何数量的任何字符。\n\nSQL语句示例如下：\n\n```mysql\nmysql> SELECT 'shkstart' REGEXP '^s', 'shkstart' REGEXP 't$', 'shkstart' REGEXP 'hk';\n+------------------------+------------------------+-------------------------+\n| 'shkstart' REGEXP '^s' | 'shkstart' REGEXP 't$' | 'shkstart' REGEXP 'hk' |\n+------------------------+------------------------+-------------------------+\n| 1 | 1 | 1 |\n+------------------------+------------------------+-------------------------+\n1 row in set (0.01 sec)\n```\n\n```mysql\nmysql> SELECT 'atguigu' REGEXP 'gu.gu', 'atguigu' REGEXP '[ab]';\n+--------------------------+-------------------------+\n| 'atguigu' REGEXP 'gu.gu' | 'atguigu' REGEXP '[ab]' |\n+--------------------------+-------------------------+\n| 1 | 1 |\n+--------------------------+-------------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n\n\n\n\n## 逻辑运算符\n\n逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为1、0或者NULL。 MySQL中支持4种逻辑运算符如下：\n\n| 运算符     | 作用     | 样例                               |\n| ---------- | -------- | ---------------------------------- |\n| NOT 或 !   | 逻辑非   | SELECT NOT A                       |\n| AND 或 &&  | 逻辑与   | SELECT A AND B<br />SELECT A && B  |\n| OR 或 \\|\\| | 逻辑或   | SELECT A OR B<br />SELECT A \\|\\| B |\n| XOR        | 逻辑异或 | SELECT A XOR B                     |\n\n\n\n### 逻辑非运算符\n\n逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0； 当给定的值为NULL时，返回NULL。\n\n```mysql\nmysql> SELECT NOT 1, NOT 0, NOT(1+1), NOT !1, NOT NULL;\n+-------+-------+----------+--------+----------+\n| NOT 1 | NOT 0 | NOT(1+1) | NOT !1 | NOT NULL |\n+-------+-------+----------+--------+----------+\n| 0 | 1 | 0 | 1 | NULL |\n+-------+-------+----------+--------+----------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n```mysql\nSELECT last_name, job_id\nFROM employees\nWHERE job_id NOT IN ('IT_PROG', 'ST_CLERK', 'SA_REP');\n```\n\n\n\n\n\n### 逻辑与运算符\n\n逻辑与（AND或&&）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回 1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。\n\n```mysql\nmysql> SELECT 1 AND -1, 0 AND 1, 0 AND NULL, 1 AND NULL;\n+----------+---------+------------+------------+\n| 1 AND -1 | 0 AND 1 | 0 AND NULL | 1 AND NULL |\n+----------+---------+------------+------------+\n| 1 | 0 | 0 | NULL |\n+----------+---------+------------+------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nSELECT employee_id, last_name, job_id, salary\nFROM employees\nWHERE salary >=10000\nAND job_id LIKE '%MAN%';\n```\n\n\n\n### 逻辑或运算符\n\n逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返 回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为 NULL时，返回NULL。\n\n```mysql\nmysql> SELECT 1 OR -1, 1 OR 0, 1 OR NULL, 0 || NULL, NULL || NULL;\n+---------+--------+-----------+-----------+--------------+\n| 1 OR -1 | 1 OR 0 | 1 OR NULL | 0 || NULL | NULL || NULL |\n+---------+--------+-----------+-----------+--------------+\n| 1 | 1 | 1 | NULL | NULL |\n+---------+--------+-----------+-----------+--------------+\n1 row in set, 2 warnings (0.00 sec)\n```\n\n```mysql\n#查询基本薪资不在9000-12000之间的员工编号和基本薪资\nSELECT employee_id,salary FROM employees\nWHERE NOT (salary >= 9000 AND salary <= 12000);\n\nSELECT employee_id,salary FROM employees\nWHERE salary <9000 OR salary > 12000;\n\nSELECT employee_id,salary FROM employees\nWHERE salary NOT BETWEEN 9000 AND 12000;\n\nSELECT employee_id, last_name, job_id, salary\nFROM employees\nWHERE salary >= 10000\nOR job_id LIKE '%MAN%';\n```\n\n\n\n#### 注意：\n\nOR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合。 \n\n\n\n\n\n### 逻辑异或运算符\n\n逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果 两个非NULL的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1。\n\n```mysql\nmysql> SELECT 1 XOR -1, 1 XOR 0, 0 XOR 0, 1 XOR NULL, 1 XOR 1 XOR 1, 0 XOR 0 XOR 0;\n+----------+---------+---------+------------+---------------+---------------+\n| 1 XOR -1 | 1 XOR 0 | 0 XOR 0 | 1 XOR NULL | 1 XOR 1 XOR 1 | 0 XOR 0 XOR 0 |\n+----------+---------+---------+------------+---------------+---------------+\n| 0 | 1 | 0 | NULL | 1 | 0 |\n+----------+---------+---------+------------+---------------+---------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nselect last_name,department_id,salary\nfrom employees\nwhere department_id in (10,20) XOR salary > 8000;\n```\n\n\n\n\n\n## 位运算符\n\n位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算， 最后将计算结果从二进制变回十进制数。 \n\nMySQL支持的位运算符如下：\n\n| 运算符 | 作用     | 样例          |\n| ------ | -------- | ------------- |\n| &      | 按位与   | SELECT A & B  |\n| \\|     | 按位或   | SELECT A \\| B |\n| ^      | 按位异或 | SELECT A ^ B  |\n| ~      | 按位取反 | SELECT ~ A    |\n| >>     | 按位右移 | SELECT A >> 2 |\n| <<     | 按位左移 | SELECT A << 2 |\n\n### 按位与运算符\n\n按位与（&）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二 进制位的数值都为1时，则该位返回1，否则返回0。 \n\n```mysql\nmysql> SELECT 1 & 10, 20 & 30;\n+--------+---------+\n| 1 & 10 | 20 & 30 |\n+--------+---------+\n| 0 | 20 |\n+--------+---------+\n1 row in set (0.00 sec)\n```\n\n1的二进制数为0001，10的二进制数为1010，所以1 & 10的结果为0000，对应的十进制数为0。20的二进制 数为10100，30的二进制数为11110，所以20 & 30的结果为10100，对应的十进制数为20。\n\n### 按位或运算符\n\n按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的二进制位的数值有一个或两个为1时，则该位返回1，否则返回0。 \n\n```mysql\nmysql> SELECT 1 | 10, 20 | 30;\n+--------+---------+\n| 1 | 10 | 20 | 30 |\n+--------+---------+\n| 11 | 30 |\n+--------+---------+\n1 row in set (0.00 sec)\n```\n\n1的二进制数为0001，10的二进制数为1010，所以1 | 10的结果为1011，对应的十进制数为11。20的二进 制数为10100，30的二进制数为11110，所以20 | 30的结果为11110，对应的十进制数为30。\n\n\n\n### 按位异或运算符\n\n按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值 对应的二进制位的数值不同时，则该位返回1，否则返回0。 \n\n```mysql\nmysql> SELECT 1 ^ 10, 20 ^ 30;\n+--------+---------+\n| 1 ^ 10 | 20 ^ 30 |\n+--------+---------+\n| 11 | 10 |\n+--------+---------+\n1 row in set (0.00 sec)\n```\n\n1的二进制数为0001，10的二进制数为1010，所以1 ^ 10的结果为1011，对应的十进制数为11。20的二进 制数为10100，30的二进制数为11110，所以20 ^ 30的结果为01010，对应的十进制数为10。 \n\n再举例：\n\n```mysql\nmysql> SELECT 12 & 5, 12 | 5,12 ^ 5 FROM DUAL;\n+--------+--------+--------+\n| 12 & 5 | 12 | 5 | 12 ^ 5 |\n+--------+--------+--------+\n| 4 | 13 | 9 |\n+--------+--------+--------+\n1 row in set (0.00 sec)\n```\n\n\n\n\n\n### 按位取反运算符 \n\n按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将1变为0，将0变 为1。\n\n```mysql\nmysql> SELECT 10 & ~1;\n+---------+\n| 10 & ~1 |\n+---------+\n| 10 |\n+---------+\n1 row in set (0.00 sec)\n```\n\n由于按位取反（~）运算符的优先级高于按位与（&）运算符的优先级，所以10 & ~1，首先，对数字1进 行按位取反操作，结果除了最低位为0，其他位都为1，然后与10进行按位与操作，结果为10。\n\n\n\n### 按位右移运算符 \n\n按位右移（>>）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的 位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐。\n\n```mysql\nmysql> SELECT 1 >> 2, 4 >> 2;\n+--------+--------+\n| 1 >> 2 | 4 >> 2 |\n+--------+--------+\n| 0 | 1 |\n+--------+--------+\n1 row in set (0.00 sec)\n```\n\n1的二进制数为0000 0001，右移2位为0000 0000，对应的十进制数为0。4的二进制数为0000 0100，右移2 位为0000 0001，对应的十进制数为1。\n\n每右移一次，相当于除以2\n\n### 按位左移运算符 \n\n按位左移（<<）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的 位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐。\n\n```mysql\nmysql> SELECT 1 << 2, 4 << 2;\n+--------+--------+\n| 1 << 2 | 4 << 2 |\n+--------+--------+\n| 4 | 16 |\n+--------+--------+\n1 row in set (0.00 sec)\n```\n\n1的二进制数为0000 0001，左移两位为0000 0100，对应的十进制数为4。4的二进制数为0000 0100，左移 两位为0001 0000，对应的十进制数为16。 \n\n每左移一次，相当于乘以2\n\n\n\n\n\n\n\n## 运算符的优先级\n\n| 优先级 | 运算符                                                       |\n| ------ | ------------------------------------------------------------ |\n| 15     | :=、=（赋值）                                                |\n| 14     | \\|\\|、OR、XOR                                                |\n| 13     | &&、AND                                                      |\n| 12     | NOT                                                          |\n| 11     | BETWEEN、CASE、WHEN、THEN、ELSE                              |\n| 10     | =(比较运算符)、<=>、>=、>、<=、<、<>、!=、IS、LIKE、TEGEXP、IN |\n| 9      | \\|                                                           |\n| 8      | &                                                            |\n| 7      | <<、>>                                                       |\n| 6      | -、+                                                         |\n| 5      | *、/、DIV、%、MOD                                            |\n| 4      | ^                                                            |\n| 3      | -(负号)、~(按位取反)                                         |\n| 2      | !                                                            |\n| 1      | ()                                                           |\n\n数字编号越小，优先级越高，优先级高的运算符先进行计算。可以看到，赋值运算符的优先级最低，使 用“()”括起来的表达式的优先级最高。\n\n\n\n## 使用正则表达式查询\n\n正则表达式通常被用来检索或替换那些符合某个模式的文本内容，根据指定的匹配模式匹配文本中符合 要求的特殊字符串。例如，从一个文本文件中提取电话号码，查找一篇文章中重复的单词或者替换用户 输入的某些敏感词语等，这些地方都可以使用正则表达式。正则表达式强大而且灵活，可以应用于非常 复杂的查询。 \n\nMySQL中使用REGEXP关键字指定正则表达式的字符匹配模式。下表列出了REGEXP操作符中常用字符匹配 列表。\n\n| 选项        | 说明                                                         | 样例                                         | 匹配值样例                 |\n| ----------- | ------------------------------------------------------------ | -------------------------------------------- | -------------------------- |\n| ^           | 匹配文本的开始字符                                           | '^b'匹配以字母b开头的字符串                  | book,big,banana,bike       |\n| $           | 匹配文本的结束字符                                           | 'st$'匹配以st结尾的字符串                    | test,resist,persist        |\n| .           | 匹配任何单个字符                                             | 'b.t'匹配任何b和t之间有一个字符的字符串      | bit, bat, but, bite        |\n| *           | 匹配零个或多个在它前面的字符                                 | 'f*n'匹配字符n前面有任意个字符f的字符串      | fn, fan, faan, fabcn       |\n| +           | 匹配前面的字符1次或多次                                      | 'ba+ '匹配以b开头后面紧跟至少有一个a的字符串 | ba, bay, bare, battle      |\n| \\<字符集\\>  | 匹配包含指定的字符串的文本                                   | 'fa'匹配包含fa的字符串                       | fan, afa, faad             |\n| [字符集合]  | 匹配字符集合中的任何一个字符                                 | '[xz]'匹配包含x或者z的字符串                 | dizzy, zebra, x-ray, extra |\n| [^]         | 匹配不在括号中的任何字符                                     | '\\[^abc]'匹配任何不包含a、b或c的字符串       | desk, fox, f8ke            |\n| 字符串 {n}  | 匹配前面的字符串至少n次                                      | b{2}匹配2个或更多的b                         | bbb, bbbb, bbbbbb          |\n| 字符串{n,m} | 匹配前面的字符串至少n次，至多m次。如果n为0，此参数为可选参数 | b{2,4)匹配含最少2个、最多4个b的字符串        | bb, bbb,bbbb               |\n\n\n\n\n### 查询以特定字符或字符串开头的记录 \n\n字符‘^’匹配以特定字符或者字符串开头的文本。\n\n在fruits表中，查询f_name字段以字母‘b’开头的记录，SQL语句如下： \n\n```mysql\nmysql> SELECT * FROM fruits WHERE f_name REGEXP '^b'; \n```\n\n\n\n### 查询以特定字符或字符串结尾的记录 \n\n字符‘$’匹配以特定字符或者字符串结尾的文本。 \n\n在fruits表中，查询f_name字段以字母‘y’结尾的记录，SQL语句如下： \n\n```mysql\nmysql> SELECT * FROM fruits WHERE f_name REGEXP 'y$'; \n```\n\n\n\n### 用符号\".\"来替代字符串中的任意一个字符\n\n字符‘.’匹配任意一个字符。 \n\n在fruits表中，查询f_name字段值 包含字母‘a’与‘g’且两个字母之间只有一个字母的记录，\n\nSQL语句如下： \n\n```mysql\nmysql> SELECT * FROM fruits WHERE f_name REGEXP 'a.g'; \n```\n\n\n\n### 使用\"\\*\"和\"+\"来匹配多个字符\n\n星号‘\\*’匹配前面的字符任意多次，包括0次。加号‘+’匹配前面的字符至 少一次。\n\n 在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’的记录，SQL语句如下： \n\n```mysql\nmysql> SELECT * FROM fruits WHERE f_name REGEXP '^ba*';\n```\n\n在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’至少一次的记录，SQL语句如下： \n\n```mysql\nmysql> SELECT * FROM fruits WHERE f_name REGEXP '^ba+';\n```\n\n\n\n### 匹配指定字符串\n\n正则表达式可以匹配指定字符串，只要这个字符串在查询文本中即可，如要匹配多个字符串，多个字符串之间使用分隔符‘|’隔开。 \n\n在fruits表中，查询f_name字段值包含字符串“on”的记录，SQL语句如下： \n\n```mysql\nmysql> SELECT * FROM fruits WHERE f_name REGEXP 'on';\n```\n\n在fruits表中，查询f_name字段值包含字符串“on”或者“ap”的记录，SQL语句如下： \n\n```mysql\nmysql> SELECT * FROM fruits WHERE f_name REGEXP 'on|ap';\n```\n\n\n\n之前介绍过，LIKE运算符也可以匹配指定的字符串，但与REGEXP不同，LIKE匹配的字符串如果在文本中间出现，则找不到它，相应的行也不会返回。REGEXP在文本内进行匹配，如果被匹配的字符串在文本中出现，REGEXP将会找到它，相应的行也会被返回。对比结果如下所示。 \n\n在fruits表中，使用LIKE运算符查询f_name字段值为“on”的记录，SQL语句如下：\n\n```mysql\nmysql> SELECT * FROM fruits WHERE f_name like 'on';\nEmpty set(0.00 sec)\n```\n\n\n\n### 匹配指定字符中的任意一个\n\n方括号“[]”指定一个字符集合，只匹配其中任何一个字符，即为所查找的文本。 \n\n在fruits表中，查找f_name字段中包含字母‘o’或者‘t’的记录，SQL语句如下： \n\n```mysql\nmysql> SELECT * FROM fruits WHERE f_name REGEXP '[ot]';\n```\n\n在fruits表中，查询s_id字段中包含4、5或者6的记录，SQL语句如下：\n\n```mysql\nmysql> SELECT * FROM fruits WHERE s_id REGEXP '[456]';\n```\n\n\n\n\n\n### 匹配指定字符以外的字符\n\n “\\[^字符集合\\]” 匹配不在指定集合中的任何字符。 \n\n在fruits表中，查询f_id字段中包含字母a\\~e和数字1\\~2以外字符的记录，SQL语句如下： \n\n```mysql\nmysql> SELECT * FROM fruits WHERE f_id REGEXP '[^a-e1-2]';\n```\n\n\n\n### 使用{n,}或者{n,m}来指定字符串连续出现的次数 \n\n“字符串{n,}”表示至少匹配n次前面的字符；“字符串 {n,m}”表示匹配前面的字符串不少于n次，不多于m次。例如，a{2,}表示字母a连续出现至少2次，也可以 大于2次；a{2,4}表示字母a连续出现最少2次，最多不能超过4次。\n\n在fruits表中，查询f_name字段值出现字母‘x’至少2次的记录，SQL语句如下： \n\n```\nmysql> SELECT * FROM fruits WHERE f_name REGEXP 'x{2,}';\n```\n\n在fruits表中，查询f_name字段值出现字符串“ba”最少1次、最多3次的记录，SQL语句如下：\n\n```\nmysql> SELECT * FROM fruits WHERE f_name REGEXP 'ba{1,3}';\n```\n\n\n\n\n\n# 排序和分页\n\n## 排序数据 \n\n### 排序规则 \n\n- 使用 ORDER BY 子句排序 \n  - ASC（ascend）: 升序 （不写默认是升序）\n  - DESC（descend）:降序 \n- ORDER BY 子句在SELECT语句的结尾。 \n\n\n\n### 单列排序\n\n```mysql\nSELECT last_name, job_id, department_id, hire_date\nFROM employees\nORDER BY hire_date ;\n```\n\n![image-20230605151657006](./Image/MySql基础笔记.assets/image-20230605151657006.png)\n\n```mysql\nSELECT last_name, job_id, department_id, hire_date\nFROM employees\nORDER BY hire_date DESC ;\n```\n\n![image-20230605151718167](./Image/MySql基础笔记.assets/image-20230605151718167.png)\n\n\n\n### 多列排序\n\n```mysql\nSELECT last_name, department_id, salary\nFROM employees\nORDER BY department_id, salary DESC;\n```\n\n ![image-20230605151803939](./Image/MySql基础笔记.assets/image-20230605151803939.png)\n\n- 可以使用不在SELECT列表中的列排序。\n- 在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。 \n\n\n\n### 对 有别名的列进行排序\n\n```mysql\nmysql> select employee_id, salary, salary * 12 as annual_sal\n    -> from employees order by annual_sal desc;\n+-------------+----------+------------+\n| employee_id | salary   | annual_sal |\n+-------------+----------+------------+\n|         100 | 24000.00 |  288000.00 |\n|         101 | 17000.00 |  204000.00 |\n|         102 | 17000.00 |  204000.00 |\n|         145 | 14000.00 |  168000.00 |\n|         146 | 13500.00 |  162000.00 |\n|         201 | 13000.00 |  156000.00 |\n|         205 | 12000.00 |  144000.00 |\n|         108 | 12000.00 |  144000.00 |\n|         147 | 12000.00 |  144000.00 |\n|         168 | 11500.00 |  138000.00 |\n|         174 | 11000.00 |  132000.00 |\n|         148 | 11000.00 |  132000.00 |\n|         114 | 11000.00 |  132000.00 |\n|         149 | 10500.00 |  126000.00 |\n|         162 | 10500.00 |  126000.00 |\n|         169 | 10000.00 |  120000.00 |\n|         156 | 10000.00 |  120000.00 |\n|         150 | 10000.00 |  120000.00 |\n|         204 | 10000.00 |  120000.00 |\n|         170 |  9600.00 |  115200.00 |\n|         157 |  9500.00 |  114000.00 |\n|         151 |  9500.00 |  114000.00 |\n|         163 |  9500.00 |  114000.00 |\n|         103 |  9000.00 |  108000.00 |\n|         152 |  9000.00 |  108000.00 |\n|         109 |  9000.00 |  108000.00 |\n|         158 |  9000.00 |  108000.00 |\n|         175 |  8800.00 |  105600.00 |\n|         176 |  8600.00 |  103200.00 |\n|         177 |  8400.00 |  100800.00 |\n|         206 |  8300.00 |   99600.00 |\n|         121 |  8200.00 |   98400.00 |\n|         110 |  8200.00 |   98400.00 |\n|         153 |  8000.00 |   96000.00 |\n|         159 |  8000.00 |   96000.00 |\n|         120 |  8000.00 |   96000.00 |\n|         122 |  7900.00 |   94800.00 |\n|         112 |  7800.00 |   93600.00 |\n|         111 |  7700.00 |   92400.00 |\n|         160 |  7500.00 |   90000.00 |\n|         154 |  7500.00 |   90000.00 |\n|         171 |  7400.00 |   88800.00 |\n|         172 |  7300.00 |   87600.00 |\n|         164 |  7200.00 |   86400.00 |\n|         155 |  7000.00 |   84000.00 |\n|         161 |  7000.00 |   84000.00 |\n|         178 |  7000.00 |   84000.00 |\n|         113 |  6900.00 |   82800.00 |\n|         165 |  6800.00 |   81600.00 |\n|         203 |  6500.00 |   78000.00 |\n|         123 |  6500.00 |   78000.00 |\n|         166 |  6400.00 |   76800.00 |\n|         179 |  6200.00 |   74400.00 |\n|         167 |  6200.00 |   74400.00 |\n|         173 |  6100.00 |   73200.00 |\n|         104 |  6000.00 |   72000.00 |\n|         202 |  6000.00 |   72000.00 |\n|         124 |  5800.00 |   69600.00 |\n|         106 |  4800.00 |   57600.00 |\n|         105 |  4800.00 |   57600.00 |\n|         200 |  4400.00 |   52800.00 |\n|         107 |  4200.00 |   50400.00 |\n|         184 |  4200.00 |   50400.00 |\n|         185 |  4100.00 |   49200.00 |\n|         192 |  4000.00 |   48000.00 |\n|         193 |  3900.00 |   46800.00 |\n|         188 |  3800.00 |   45600.00 |\n|         189 |  3600.00 |   43200.00 |\n|         137 |  3600.00 |   43200.00 |\n|         141 |  3500.00 |   42000.00 |\n|         186 |  3400.00 |   40800.00 |\n|         129 |  3300.00 |   39600.00 |\n|         133 |  3300.00 |   39600.00 |\n|         194 |  3200.00 |   38400.00 |\n|         180 |  3200.00 |   38400.00 |\n|         138 |  3200.00 |   38400.00 |\n|         125 |  3200.00 |   38400.00 |\n|         196 |  3100.00 |   37200.00 |\n|         142 |  3100.00 |   37200.00 |\n|         181 |  3100.00 |   37200.00 |\n|         115 |  3100.00 |   37200.00 |\n|         197 |  3000.00 |   36000.00 |\n|         187 |  3000.00 |   36000.00 |\n|         116 |  2900.00 |   34800.00 |\n|         134 |  2900.00 |   34800.00 |\n|         190 |  2900.00 |   34800.00 |\n|         195 |  2800.00 |   33600.00 |\n|         130 |  2800.00 |   33600.00 |\n|         183 |  2800.00 |   33600.00 |\n|         117 |  2800.00 |   33600.00 |\n|         139 |  2700.00 |   32400.00 |\n|         126 |  2700.00 |   32400.00 |\n|         118 |  2600.00 |   31200.00 |\n|         199 |  2600.00 |   31200.00 |\n|         198 |  2600.00 |   31200.00 |\n|         143 |  2600.00 |   31200.00 |\n|         144 |  2500.00 |   30000.00 |\n|         119 |  2500.00 |   30000.00 |\n|         131 |  2500.00 |   30000.00 |\n|         191 |  2500.00 |   30000.00 |\n|         140 |  2500.00 |   30000.00 |\n|         182 |  2500.00 |   30000.00 |\n|         135 |  2400.00 |   28800.00 |\n|         127 |  2400.00 |   28800.00 |\n|         128 |  2200.00 |   26400.00 |\n|         136 |  2200.00 |   26400.00 |\n|         132 |  2100.00 |   25200.00 |\n+-------------+----------+------------+\n107 rows in set (0.00 sec)\n```\n\n**需要注意，列的别名只能在order by中使用，在where中使用会报错。**\n\n\n\n## 分页\n\n### 背景\n\n背景1：查询返回的记录太多了，查看起来很不方便，怎么样能够实现分页查询呢？ \n\n背景2：表里有 4 条数据，我们只想要显示第 2、3 条数据怎么办呢？ \n\n\n\n### 实现规则 \n\n#### 分页原理 \n\n所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。 \n\n### MySQL中使用 LIMIT 实现分页\n\n#### 格式\n\n```mysql\nLIMIT [位置偏移量,] 行数\n```\n\n- 第一个“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移 量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是 1，以此类推）\n\n- 第二个参数“行数”指示返回的记录条数。\n\n- 分页显式公式：（当前页数-1）*每页条数，每页条数\n\n  - ```mysql\n    SELECT * FROM table\n    LIMIT(PageNo - 1)*PageSize,PageSize;\n    ```\n\n- **注意：LIMIT 子句必须放在整个SELECT语句的最后！**\n\n\n\n#### 使用 LIMIT 的好处\n\n约束返回结果的数量可以 `减少数据表的网络传输量` ，也可以 `提升查询效率` 。如果我们知道返回结果只有 1 条，就可以使用 LIMIT 1 ，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需 要扫描完整的表，只需要检索到一条符合条件的记录即可返回。\n\n\n\n\n\n> MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第5条记录开始后面的3条记录，和“LIMIT 4,3;”返回的结果相同。\n\n#### 举例\n\n```mysql\n--前10条记录：\nSELECT * FROM 表名 LIMIT 0,10;\n或者\nSELECT * FROM 表名 LIMIT 10;\n--第11至20条记录：\nSELECT * FROM 表名 LIMIT 10,10;\n--第21至30条记录：\nSELECT * FROM 表名 LIMIT 20,10;\n```\n\n\n\n\n\n## 拓展\n\n在不同的 DBMS 中使用的关键字可能不同。\n\n在 MySQL、PostgreSQL、MariaDB 和 SQLite 中使用 LIMIT 关键字，而且需要放到 SELECT 语句的最后面。 \n\n- 如果是 SQL Server 和 Access，需要使用 `TOP` 关键字，比如： \n\n  - ```sql\n    SELECT TOP 5 name, hp_max FROM heros ORDER BY hp_max DESC\n    ```\n\n- 如果是 DB2，使用 FETCH FIRST 5 ROWS ONLY 这样的关键字： \n\n  - ```sql\n    SELECT name, hp_max FROM heros ORDER BY hp_max DESC FETCH FIRST 5 ROWS ONLY\n    ```\n\n- 如果是 Oracle，你需要基于 ROWNUM 来统计行数： \n\n  - ```mysql\n    SELECT rownum,last_name,salary FROM employees WHERE rownum < 5 ORDER BY salary DESC;\n    ```\n\n\n\n​\t需要说明的是，这条语句是先取出来前 5 条数据行，然后再按照 hp_max 从高到低的顺序进行排序。但这样产生的结果和上述方法的并不一样。在后面讲到子查询，你可以使用一下方法得到与上述方法一致的结果。\n\n```sql\nSELECT rownum, last_name,salary\nFROM (\nSELECT last_name,salary\nFROM employees\nORDER BY salary DESC)\nWHERE rownum < 10;\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 多表查询\n\n多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。 前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个 关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进 行关联。\n\n\n\n样例 查询员工Abel在哪里工作\n\n表结构\n\n![image-20230607113702720](./Image/MySql基础笔记.assets/image-20230607113702720.png)\n\n步骤\n\n1. 首先在员工表（employees）中找到这个员工\n\n   - ```mysql\n     select * from employees where last_name = 'Abel';\n     ```\n\n2. 然后根据部门id在部门表中查询所在部门的信息\n\n   - ```mysql\n     select * from departments where department_id = '80';\n     ```\n\n3. 在根据部门表（departments）中对应记录的位置id（locaton_id）在LOCATOINS表中找到具体信息。\n\n   - ```mysql\n     select * from locations where location_id = '2500';\n     ```\n\n最终找到所需的信息。\n\n\n\n实现使用多表查询的实现一条sql语句实现上述功能\n\n\n\n\n\n\n\n\n\n## 一个案例引发的多表连接 \n\n### 案例说明\n\n\n\n案例：查询员工的姓名及其部门名称 \n\n```mysql\nSELECT last_name, department_name FROM employees, departments;\n```\n\n查询结果\n\n \n\n```mysql\n+-----------+----------------------+\n| last_name | department_name |\n+-----------+----------------------+\n| King | Administration |\n| King | Marketing |\n| King | Purchasing |\n| King | Human Resources |\n| King | Shipping |\n| King | IT |\n| King | Public Relations |\n| King | Sales |\n| King | Executive |\n| King | Finance |\n| King | Accounting |\n| King | Treasury |\n...\n| Gietz | IT Support |\n| Gietz | NOC |\n| Gietz | IT Helpdesk |\n| Gietz | Government Sales |\n| Gietz | Retail Sales |\n| Gietz | Recruiting |\n| Gietz | Payroll |\n+-----------+----------------------+\n2889 rows in set (0.01 sec)\n```\n\n\n\n#### 分析错误情况：\n\n```mysql\nSELECT COUNT(employee_id) FROM employees;\n#输出107行\nSELECT COUNT(department_id)FROM departments;\n#输出27行\nSELECT 107*27 FROM dual\n```\n\n我们把上述多表查询中出现的问题称为：笛卡尔积的错误。\n\n\n\n\n\n### 笛卡尔积（或交叉连接）的理解\n\n笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素个数的乘积数。\n\n![image-20230605164149915](./Image/MySql基础笔记.assets/image-20230605164149915.png)\n\n\n\nSQL92中，笛卡尔积也称为 `交叉连接` ，英文是 `CROSS JOIN` 。在 SQL99 中也是使用 CROSS JOIN表示交叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。在MySQL中如下情况会出现笛卡尔积：\n\n```mysql\n#查询员工姓名和所在部门名称\nSELECT last_name,department_name FROM employees,departments;\nSELECT last_name,department_name FROM employees CROSS JOIN departments;\nSELECT last_name,department_name FROM employees INNER JOIN departments;\nSELECT last_name,department_name FROM employees JOIN departments;\n```\n\n\n\n### 案例分析与问题解决 \n\n- **笛卡尔积的错误会在下面条件下产生**： \n\n  - 省略多个表的连接条件（或关联条件） \n  - 连接条件（或关联条件）无效 \n  - 所有表中的所有行互相连接 \n\n- 为了避免笛卡尔积， 可以**在 WHERE 加入有效的连接条件**。 \n\n- 加入连接条件后，查询语法： \n\n  - ```mysql\n    SELECT table1.column, table2.column\n    FROM table1, table2\n    WHERE table1.column1 = table2.column2; #连接条件\n    ```\n\n  - 在 WHERE子句中写入连接条件。 \n\n- 正确写法： \n\n  - ```mysql\n    #案例：查询员工的姓名及其部门名称\n    SELECT last_name, department_name\n    FROM employees, departments\n    WHERE employees.department_id = departments.department_id;\n    ```\n\n- 在表中有相同列时，在列名之前加上表名前缀。\n\n  - 建议：在所有列名之前都加上表名。不光更清晰明了，而且还能优化运行速度。\n\n\n\n\n**多表查询的正确方式：需要有连接条件**\n\n\n\n\n\n## 注意事项\n\n- 如果需要进行多表查询，则需要有正确的连接条件\n\n- 如果查询语句中出现了多个表，都存在的字段，则必须指明此字段所在的表。\n\n  - 建议：在多表查询时，所有列名之前都加上表名。不光更清晰明了，而且还能优化运行速度。\n\n- 如果给表起了别名，一旦需要在SELECT或WHERE中使用表名的话，必须使用起的别名。（别名会覆盖表名？）\n\n  \n\n\n\n\n\n## 表查询分类\n\n### 分类1：等值连接 vs 非等值连接 \n\n#### 等值连接\n\n![image-20230605164643755](./Image/MySql基础笔记.assets/image-20230605164643755.png)\n\n```mysql\nSELECT employees.employee_id, employees.last_name,\n    employees.department_id, departments.department_id,\n    departments.location_id\nFROM employees, departments\nWHERE employees.department_id = departments.department_id;\n```\n\n![image-20230605164731253](./Image/MySql基础笔记.assets/image-20230605164731253.png)\n\n\n\n#### 非等值连接\n\n查询员工月工资的等级。等级划分存在与Job_Grades表中。\n\n![image-20230607141121293](./Image/MySql基础笔记.assets/image-20230607141121293.png)\n\n```mysql\nSELECT e.last_name, e.salary, j.grade_level\nFROM employees e, job_grades j\nWHERE e.salary BETWEEN j.lowest_sal AND j.highest_sal;\n```\n\n![image-20230607141151073](./Image/MySql基础笔记.assets/image-20230607141151073.png)\n\n\n\n\n\n\n\n\n\n\n\n##### 拓展1：多个连接条件与 AND 操作符 \n\n![image-20230605164826644](./Image/MySql基础笔记.assets/image-20230605164826644.png)\n\n##### 拓展2：区分重复的列名 \n\n- **多个表中有相同列时，必须在列名之前加上表名前缀。** \n- 在不同表中具有相同列名的列可以用 表名 加以区分。 \n\n```mysql\nSELECT employees.last_name, departments.department_name,employees.department_id\nFROM employees, departments\nWHERE employees.department_id = departments.department_id;\n```\n\n\n\n##### 拓展3：表的别名 \n\n- 使用别名可以简化查询。 \n- 列名前使用表名前缀可以提高查询效率。\n\n```mysql\nSELECT e.employee_id, e.last_name, e.department_id,\n\td.department_id, d.location_id\nFROM employees e , departments d\nWHERE e.department_id = d.department_id;\n```\n\n \n\n需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替， 不能使用原有的表名，否则就会报错。\n\n> 阿里开发规范 ： \n>\n> 【 强制 】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或 表名）进行限定。 \n>\n> 说明 ：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表 名），并且操作列在多个表中存在时，就会抛异常。 \n>\n> 正例 ：select t1.name from table_first as t1 , table_second as t2 where t1.id=t2.id; \n>\n> 反例 ：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在 某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出 1052 异常：Column 'name' in field list is ambiguous。 \n\n##### 拓展4：连接多个表 \n\n![image-20230605165243307](./Image/MySql基础笔记.assets/image-20230605165243307.png)\n\n**总结：连接 n个表,至少需要n-1个连接条件**。\n\n比如，连接三个表，至少需要两个连接条件。 \n\n\n\n\n\n##### 练习：查询出公司员工的 last_name,department_name, city\n\n```mysql\nSELECT e.last_name, e.salary, j.grade_level\nFROM employees e, job_grades j\nWHERE e.salary BETWEEN j.lowest_sal AND j.highest_sal;\n```\n\n\n\n###  分类2：自连接 vs 非自连接\n\n当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两个表再进行内连接，外连接等查询。\n\n\n\n#### 自连接\n\n简单的说就是自我引用？\n\n将自己虚拟成另外一个表，实现某些功能。\n\n\n\n##### 样例：查询employees表，获得所有员工的id、姓名、该员工的上级的id、上级的名字。\n\n因为员工的上级也属于员工，因此都可以在employees表中找到。为了便于查找可以将employees表虚拟成两个，然后自连接查找。\n\n```mysql\nselect w.employee_id, w.last_name, m.manager_id, m.last_name\nfrom employees w, employees m\nwhere w.manager_id = m.employee_id;\n```\n\n\n\n#### 非自连接\n\n就是普通的多表连接，这里不再叙述了。\n\n\n\n\n\n### 分类3：内连接 vs 外连接 \n\n**除了查询满足条件的记录以外，外连接还可以查询某一方不满足条件的记录。** \n\n![image-20230607150642156](./Image/MySql基础笔记.assets/image-20230607150642156.png)\n\n- 内连接: 合并具有同一列的两个以上的表的行, **结果集中不包含一个表与另一个表不匹配的行** \n- 外连接: 两个表在连接过程中除了返回满足连接条件的行以外还**返回左（或右）表中不满足条件的行 ，这种连接称为左（或右） 外连接**。没有匹配的行时, 结果表中相应的列为空(NULL)。 \n- 如果是左外连接，则连接条件中左边的表也称为 `主表` ，右边的表称为从表 。\n- 如果是右外连接，则连接条件中右边的表也称为 `主表` ，左边的表称为 从表 。 \n\n\n\n简单的说就是，如果两个表之间的连接条件的两边不存在null值，即都可以一一对应，则称为内连接；\n\n如果连接条件的一边的值为null，并且还想看到值为null的连接结果，即连接条件不满足的内容也查出来，就是外连接。可分为左外连接和右外连接。\n\n左外连接：除了内连接外，还把左边的表中不满足的数据也查出来了，就称为左外连接；\n\n右外连接和左外连接相反，除了能对应上的内连接的数据外，还包括左侧对应不上的记录。\n\n\n\n##### 内连接样例\n\n查询员工的员工号、名字以及所属部门的名称。\n\n```mysql\nSELECT e.employee_id, e.last_name, d.department_name\nFROM employees e, departments d\nWHERE e.department_id = d.department_id;\n```\n\n只查出了左表和右表当中满足连接条件的数据查询出来，其余不符合要求的的数据都忽略，这就是典型的内连接。\n\n  **注意！！！一定要看看是不是查询所有员工的，一旦涉及到所有，就需要考虑是否是外连接！！！**\n\n\n\n\n\n#### SQL92：使用(+)创建连接\n\n- 在 SQL92 中采用（+）代表从表所在的位置。即左或右外连接中，(+) 表示哪个是从表。 \n\n- Oracle 对 SQL92 支持较好，而 MySQL 则不支持 SQL92 的外连接。 \n\n  - ```mysql\n    #左外连接\n    SELECT last_name,department_name\n    FROM employees ,departments\n    WHERE employees.department_id = departments.department_id(+);\n    #右外连接\n    SELECT last_name,department_name\n    FROM employees ,departments\n    WHERE employees.department_id(+) = departments.department_id;\n    ```\n\n- 而且在 SQL92 中，只有左外连接和右外连接，没有满（或全）外连接。 \n\n\n\n## SQL99语法实现多表查询\n\n### 基本语法\n\n#### 使用JOIN...ON子句创建连接的语法结构\n\n```mysql\nSELECT table1.column, table2.column,table3.column\nFROM table1\n\tJOIN table2 ON table1 和 table2 的连接条件\n\t\tJOIN table3 ON table2 和 table3 的连接条件\n```\n\n它的嵌套逻辑类似我们使用的 FOR 循环： \n\n```python\nfor t1 in table1:\n\tfor t2 in table2:\n\t\tif condition1:\n\t\t\tfor t3 in table3:\n\t\t\t\tif condition2:\n\t\t\t\t\toutput t1 + t2 + t3\n```\n\nSQL99 采用的这种嵌套结构非常清爽、层次性更强、可读性更强，即使再多的表进行连接也都清晰可见。如果你采用 SQL92，可读性就会大打折扣。 \n\n#### 语法说明\n\n- **可以使用 ON 子句指定额外的连接条件。** \n- 这个连接条件是与其它条件分开的。 \n- **ON 子句使语句具有更高的易读性。** \n- 关键字 JOIN、INNER JOIN、CROSS JOIN 的含义是一样的，都表示内连接。\n\n\n\n### 内连接(INNER JOIN)的实现\n\n#### 语法\n\n```mysql\nSELECT 字段列表\nFROM A表 INNER JOIN B表\nON 关联条件\nWHERE 等其他子句;\n```\n\n\n\n#### 样例1\n\n```mysql\nSELECT e.employee_id, e.last_name, e.department_id,\n\td.department_id, d.location_id\nFROM employees e JOIN departments d\nON (e.department_id = d.department_id);\n```\n\n![image-20230605190153631](./Image/MySql基础笔记.assets/image-20230605190153631.png)\n\n#### 样例2\n\n```mysql \nSELECT employee_id, city, department_name\nFROM employees e\nJOIN departments d\nON d.department_id = e.department_id\nJOIN locations l\nON d.location_id = l.location_id;\n```\n\n![image-20230605190207365](./Image/MySql基础笔记.assets/image-20230605190207365.png)\n\n\n\n### 外连接(OUTER JOIN)的实现\n\n#### 左外连接(LEFT OUTER JOIN) \n\n##### 语法\n\n```mysql\n#实现查询结果是A\nSELECT 字段列表\nFROM A表 LEFT JOIN B表\nON 关联条件\nWHERE 等其他子句;\n```\n\n\n\n##### 样例\n\n```mysql\nSELECT e.last_name, e.department_id, d.department_name\nFROM employees e\nLEFT OUTER JOIN departments d\nON (e.department_id = d.department_id) ;\n```\n\n![image-20230605190335013](./Image/MySql基础笔记.assets/image-20230605190335013.png)\n\n\n\n#### 右外连接(RIGHT OUTER JOIN) \n\n##### 语法：\n\n```mysql\n#实现查询结果是B\nSELECT 字段列表\nFROM A表 RIGHT JOIN B表\nON 关联条件\nWHERE 等其他子句;\n```\n\n##### 样例\n\n```mysql\nSELECT e.last_name, e.department_id, d.department_name\nFROM employees e\nRIGHT OUTER JOIN departments d\nON (e.department_id = d.department_id) ;\n```\n\n![image-20230605190448478](./Image/MySql基础笔记.assets/image-20230605190448478.png)\n\n##### 注意事项\n\n需要注意的是，LEFT JOIN 和 RIGHT JOIN 只存在于 SQL99 及以后的标准中，在 SQL92 中不存在， 只能用 (+) 表示。\n\n\n\n#### 满外连接(FULL OUTER JOIN) \n\n- 满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。 \n- SQL99是支持满外连接的。使用FULL JOIN 或 FULL OUTER JOIN来实现。 \n- 需要注意的是，MySQL不支持FULL JOIN，但是可以用 LEFT JOIN **UNION** RIGHT join代替。 \n\n\n\n## UNION的使用\n\n### 合并查询结果\n\n利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNION ALL关键字分隔。 \n\n\n\n### 语法格式\n\n```mysql\nSELECT column,... FROM table1\nUNION [ALL]\nSELECT column,... FROM table2\n```\n\n\n\n### UNION操作符\n\n![image-20230606214037409](./Image/MySql基础笔记.assets/image-20230606214037409.png)\n\nUNION 操作符返回两个查询的结果集的并集，去除重复记录\n\n### UNION ALL操作符\n\n![image-20230606214057463](./Image/MySql基础笔记.assets/image-20230606214057463.png)\n\nUNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。\n\n\n\n\n\n### UNION和UNION ALL的区别\n\n![image-20230610185959293](./Image/MySql基础笔记.assets/image-20230610185959293.png)\n\n设集合A 与 集合B进行查询，得到的结果如上图所示：\n\n集合A与集合B内连接后得到的记录数量为106，其中左表有1条未匹配的记录，右表有16条没匹配的记录。\n\n因此左外连接后的数量就是106 + 1；右外连接的数量就是106 + 16。\n\n如果使用UNION关键字，得到的就是1 + 106 + 16条记录；\n\n如果使用UNION ALL关键字，则得到的就是1 + 106 + 106 + 16条记录。\n\n\n\n### 注意事项\n\n执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据 不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。\n\n\n\n### 样例\n\n#### 查询部门编号>90或邮箱包含a的员工信息\n\n```mysql\n#方式1\nSELECT * FROM employees WHERE email LIKE '%a%' OR department_id>90;\n```\n\n\n\n####  查询中国用户中男性的信息以及美国用户中年男性的用户信息\n\n```mysql\n#方式2\nSELECT * FROM employees WHERE email LIKE '%a%'\nUNION\nSELECT * FROM employees WHERE department_id>90;\n```\n\n\n\n## 7种SQL JOINS的实现 \n\n![image-20230606214310016](./Image/MySql基础笔记.assets/image-20230606214310016.png)\n\n### 代码实现\n\n```mysql\n#中图：内连接 A∩B\nSELECT employee_id,last_name,department_name\nFROM employees e JOIN departments d\nON e.`department_id` = d.`department_id`;\n\n#左上图：左外连接\nSELECT employee_id,last_name,department_name\nFROM employees e LEFT JOIN departments d\nON e.`department_id` = d.`department_id`;\n\n#右上图：右外连接\nSELECT employee_id,last_name,department_name\nFROM employees e RIGHT JOIN departments d\nON e.`department_id` = d.`department_id`;\n\n#左中图：A - A∩B\nSELECT employee_id,last_name,department_name\nFROM employees e LEFT JOIN departments d\nON e.`department_id` = d.`department_id`\nWHERE d.`department_id` IS NULL\n#就是在左上图的基础上修改了一下。左中图与左上图的共同点就是都拥有department_id = null的数据，因此可以通过对左上图的修改（筛选出之符合要求的记录），得到左中图。\n\n\n#右中图：B-A∩B\nSELECT employee_id,last_name,department_name\nFROM employees e RIGHT JOIN departments d\nON e.`department_id` = d.`department_id`\nWHERE e.`department_id` IS NULL\n\n#左下图：满外连接\n# 左中图 + 右上图 A∪B\nSELECT employee_id,last_name,department_name\nFROM employees e LEFT JOIN departments d\nON e.`department_id` = d.`department_id`\nWHERE d.`department_id` IS NULL\nUNION ALL #没有去重操作，效率高\nSELECT employee_id,last_name,department_name\nFROM employees e RIGHT JOIN departments d\nON e.`department_id` = d.`department_id`;\n\n#右下图\n#左中图 + 右中图 A ∪B- A∩B 或者 (A - A∩B) ∪ （B - A∩B）\nSELECT employee_id,last_name,department_name\nFROM employees e LEFT JOIN departments d\nON e.`department_id` = d.`department_id`\nWHERE d.`department_id` IS NULL\nUNION ALL\nSELECT employee_id,last_name,department_name\nFROM employees e RIGHT JOIN departments d\nON e.`department_id` = d.`department_id`\nWHERE e.`department_id` IS NULL\n```\n\n\n\n\n\n### 语法格式小结\n\n-  左中图 \n\n   - ```mysql\n     #实现A - A∩B\n     select 字段列表\n     from A表 left join B表\n     on 关联条件\n     where 从表关联字段 is null and 等其他子句;\n     ```\n\n     \n\n- 右中图 \n\n  - ```mysql\n    #实现B - A∩B\n    select 字段列表\n    from A表 right join B表\n    on 关联条件\n    where 从表关联字段 is null and 等其他子句;\n    ```\n\n    \n\n- 左下图\n\n  ```mysql\n  #实现查询结果是A∪B\n  #用左外的A，union 右外的B\n  select 字段列表\n  from A表 left join B表\n  on 关联条件\n  where 等其他子句\n  \n  union\n  \n  select 字段列表\n  from A表 right join B表\n  on 关联条件\n  where 等其他子句\n  ```\n\n- 右下图\n\n  - ```mysql\n    #实现A∪B - A∩B 或 (A - A∩B) ∪ （B - A∩B）\n    #使用左外的 (A - A∩B) union 右外的（B - A∩B）\n    select 字段列表\n    from A表 left join B表\n    on 关联条件\n    where 从表关联字段 is null and 等其他子句\n    \n    union\n    \n    select 字段列表\n    from A表 right join B表\n    on 关联条件\n    where 从表关联字段 is null and 等其他子句\n    ```\n\n    \n\n\n\n## SQL99语法新特性\n\n### 自然连接\n\nSQL99 在 SQL92 的基础上提供了一些特殊语法，比如 `NATURAL JOIN` 用来表示自然连接。我们可以把 自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中 `所有相同的字段` ，然后进行 `等值连接` 。\n\n 在SQL92标准中： \n\n```MYSQL\nSELECT employee_id,last_name,department_name\nFROM employees e JOIN departments d\nON e.`department_id` = d.`department_id`\nAND e.`manager_id` = d.`manager_id`;\n```\n\n在 SQL99 中你可以写成： \n\n```MYSQL\nSELECT employee_id,last_name,department_name\nFROM employees e NATURAL JOIN departments d;\n```\n\n\n\n### USING连接\n\n当我们进行连接的时候，SQL99还支持使用 USING 指定数据表里的 `同名字段` 进行等值连接。但是只能配合JOIN一起使用。比如： \n\n```mysql\nSELECT employee_id,last_name,department_name\nFROM employees e JOIN departments d\nUSING (department_id);\n```\n\n你能看出与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING 的括号 () 中填入要指定的同名字段。同时使用 JOIN...USING 可以简化 JOIN ON 的等值连接。它与下面的 SQL 查询结果是相同的： \n\n```mysql\nSELECT employee_id,last_name,department_name\nFROM employees e ,departments d\nWHERE e.department_id = d.department_id;\n```\n\n\n\n## 章节小结\n\n表连接的约束条件可以有三种方式：WHERE, ON, USING\n\n- WHERE：适用于所有关联查询 \n- ON ：只能和JOIN一起使用，只能写关联条件。虽然关联条件可以并到WHERE中和其他条件一起写，但分开写可读性更好。 \n- USING：只能和JOIN一起使用，而且要求两个关联字段在关联表中名称一致，而且只能表示关联字段值相等\n\n```mysql\n#关联条件\n#把关联条件写在where后面\nSELECT last_name,department_name\nFROM employees,departments\nWHERE employees.department_id = departments.department_id;\n\n\n#把关联条件写在on后面，只能和JOIN一起使用\nSELECT last_name,department_name\nFROM employees INNER JOIN departments\nON employees.department_id = departments.department_id;\n\nSELECT last_name,department_name\nFROM employees CROSS JOIN departments\nON employees.department_id = departments.department_id;\n\nSELECT last_name,department_name\nFROM employees JOIN departments\nON employees.department_id = departments.department_id;\n\n\n#把关联字段写在using()中，只能和JOIN一起使用\n#而且两个表中的关联字段必须名称相同，而且只能表示=\n#查询员工姓名与基本工资\nSELECT last_name,job_title\nFROM employees INNER JOIN jobs USING(job_id);\n\n\n#n张表关联，需要n-1个关联条件\n#查询员工姓名，基本工资，部门名称\nSELECT last_name,job_title,department_name FROM employees,departments,jobs\nWHERE employees.department_id = departments.department_id\nAND employees.job_id = jobs.job_id;\n\nSELECT last_name,job_title,department_name\nFROM employees INNER JOIN departments INNER JOIN jobs\nON employees.department_id = departments.department_id\nAND employees.job_id = jobs.job_id;\n```\n\n \n\n### 注意\n\n我们要`控制连接表的数量` 。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下降得很严重，因此不要连接不必要的表。在许多DBMS 中，也都会有最大连接表的限制。\n\n> 【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保证被关联的字段需要有索引。 \n>\n> 说明：即使双表 join 也要注意表索引、SQL 性能。 \n>\n> 来源：阿里巴巴《Java开发手册》\n\n\n\n\n\n# 函数\n\n对于不同的DBMS来说，各种函数各不相同，没有同一的规范。大部分 DBMS 会有自己特定的函数，这就意味着**采用 SQL 函数的代码可移植性是很差的**，因此在使用函数的时候需要特别注意。\n\n## MySQL的内置函数及分类\n\n MySQL提供了丰富的内置函数，这些函数使得数据的维护与管理更加方便，能够更好地提供数据的分析与统计功能，在一定程度上提高了开发人员进行数据分析与统计的效率。 \n\nMySQL提供的内置函数从 `实现的功能角度` 可以分为数值函数、字符串函数、日期和时间函数、流程控制 函数、加密与解密函数、获取MySQL信息函数、聚合函数等。这里，我将这些丰富的内置函数再分为两 类： `单行函数` 、 `聚合函数（或分组函数）` 。\n\n单行函数：\n\n- 操作数据对象 ；\n- 接受参数返回一个结果 ；\n- **只对一行进行变换** ；\n- **每行返回一个结果** ；\n- 可以嵌套 ；\n- 参数可以是**一列**或**一个**值。 \n\n\n\n聚合函数作用于**一组**数据，并对**一组数据返回一个值**。\n\n## 单行函数\n\n### 数值函数\n\n#### 基本函数\n\n| 函数                | 用法                                                         |\n| ------------------- | ------------------------------------------------------------ |\n| ABS(x)              | 返回x的绝对值                                                |\n| SIGN(X)             | 单元格                                                       |\n| PI()                | 返回圆周率的值                                               |\n| CEIL(x)，CEILING(x) | 返回大于或等于某个值的最小整数                               |\n| FLOOR(x)            | 返回小于或等于某个值的最大整数                               |\n| LEAST(e1,e2,e3…)    | 返回列表中的最小值                                           |\n| GREATEST(e1,e2,e3…) | 返回列表中的最大值                                           |\n| MOD(x,y)            | 返回X除以Y后的余数                                           |\n| RAND()              | 返回0~1的随机值                                              |\n| RAND(x)             | 返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机数 |\n| ROUND(x)            | 返回一个对x的值进行四舍五入后，最接近于X的整数               |\n| ROUND(x,y)          | 返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位 |\n| TRUNCATE(x,y)       | 返回数字x截   数的结果                                       |\n| SQRT(x)             | 返回x的平方根。当X的值为负数时，返回NULL                     |\n\n##### 样例\n\n```mysql\nmysql> SELECT\n    -> ABS(-123),ABS(32),SIGN(-23),SIGN(43),PI(),CEIL(32.32),CEILING(-43.23),FLOOR(32.32),\n    -> FLOOR(-43.23),MOD(12,5)\n    -> FROM DUAL;\n+-----------+---------+-----------+----------+----------+-------------+-----------------+--------------+---------------+-----------+\n| ABS(-123) | ABS(32) | SIGN(-23) | SIGN(43) | PI()     | CEIL(32.32) | CEILING(-43.23) | FLOOR(32.32) | FLOOR(-43.23) | MOD(12,5) |\n+-----------+---------+-----------+----------+----------+-------------+-----------------+--------------+---------------+-----------+\n|       123 |      32 |        -1 |        1 | 3.141593 |          33 |             -43 |           32 |           -44 |         2 |\n+-----------+---------+-----------+----------+----------+-------------+-----------------+--------------+---------------+-----------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT RAND(),RAND(),RAND(10),RAND(10),RAND(-1),RAND(-1)\n    -> FROM DUAL;\n+-------------------+--------------------+--------------------+--------------------+--------------------+--------------------+\n| RAND()            | RAND()             | RAND(10)           | RAND(10)           | RAND(-1)           | RAND(-1)           |\n+-------------------+--------------------+--------------------+--------------------+--------------------+--------------------+\n| 0.623679200768172 | 0.8901483592485528 | 0.6570515219653505 | 0.6570515219653505 | 0.9050373219931845 | 0.9050373219931845 |\n+-------------------+--------------------+--------------------+--------------------+--------------------+--------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT\n    -> ROUND(12.33),ROUND(12.343,2),ROUND(12.324,-1),TRUNCATE(12.66,1),TRUNCATE(12.66,-1)\n    -> FROM DUAL;\n+--------------+-----------------+------------------+-------------------+--------------------+\n| ROUND(12.33) | ROUND(12.343,2) | ROUND(12.324,-1) | TRUNCATE(12.66,1) | TRUNCATE(12.66,-1) |\n+--------------+-----------------+------------------+-------------------+--------------------+\n|           12 |           12.34 |               10 |              12.6 |                 10 |\n+--------------+-----------------+------------------+-------------------+--------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n\n\n#### 角度与弧度互换函数\n\n| 函数       | 用法                                  |\n| ---------- | ------------------------------------- |\n| RADIANS(x) | 将角度转化为弧度，其中，参数x为角度值 |\n| DEGREES(x) | 将弧度转化为角度，其中，参数x为弧度值 |\n\n##### 样例\n\n```mysql\nmysql> SELECT RADIANS(30),RADIANS(60),RADIANS(90),DEGREES(2*PI()),DEGREES(RADIANS(90))\n    -> FROM DUAL;\n+--------------------+--------------------+--------------------+-----------------+----------------------+\n| RADIANS(30)        | RADIANS(60)        | RADIANS(90)        | DEGREES(2*PI()) | DEGREES(RADIANS(90)) |\n+--------------------+--------------------+--------------------+-----------------+----------------------+\n| 0.5235987755982988 | 1.0471975511965976 | 1.5707963267948966 |             360 |                   90 |\n+--------------------+--------------------+--------------------+-----------------+----------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n#### 三角函数\n\n| 函数       | 用法                                                         |\n| ---------- | ------------------------------------------------------------ |\n| SIN(x)     | 将角度转化为弧度，其中，参数x为角度值                        |\n| ASIN(x)    | 将弧度转化为角度，其中，参数x为弧度值                        |\n| COS(x)     | 返回x的余弦值，其中，参数x为弧度值                           |\n| ACOS(x)    | 返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL |\n| TAN(x)     | 返回x的正切值，其中，参数x为弧度值                           |\n| ATAN(x)    | 返回x的反正切值，即返回正切值为x的值                         |\n| ATAN2(m,n) | 返回两个参数的反正切值                                       |\n| COT(x)     | 返回x的余切值，其中，X为弧度值                               |\n\n##### 样例\n\nATAN2(M,N)函数返回两个参数的反正切值。 与ATAN(X)函数相比，ATAN2(M,N)需要两个参数，例如有两个 点point(x1,y1)和point(x2,y2)，使用ATAN(X)函数计算反正切值为ATAN((y2-y1)/(x2-x1))，使用ATAN2(M,N)计 算反正切值则为ATAN2(y2-y1,x2-x1)。由使用方式可以看出，当x2-x1等于0时，ATAN(X)函数会报错，而 ATAN2(M,N)函数则仍然可以计算。\n\n ATAN2(M,N)函数的使用示例如下：\n\n```mysql\nmysql> SELECT\n    -> SIN(RADIANS(30)),DEGREES(ASIN(1)),TAN(RADIANS(45)),DEGREES(ATAN(1)),DEGREES(ATAN2(1,1)\n    -> )\n    -> FROM DUAL;\n+---------------------+------------------+--------------------+------------------+----------------------+\n| SIN(RADIANS(30))    | DEGREES(ASIN(1)) | TAN(RADIANS(45))   | DEGREES(ATAN(1)) | DEGREES(ATAN2(1,1)\n) |\n+---------------------+------------------+--------------------+------------------+----------------------+\n| 0.49999999999999994 |               90 | 0.9999999999999999 |               45 |                   45 |\n+---------------------+------------------+--------------------+------------------+----------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n\n\n#### 指数与对数函数\n\n| 函数                 | 用法                                                 |\n| -------------------- | ---------------------------------------------------- |\n| POW(x,y)，POWER(X,Y) | 返回x的y次方                                         |\n| EXP(X)               | 返回e的X次方，其中e是一个常数，2.718281828459045     |\n| LN(X)，LOG(X)        | 返回以e为底的X的对数，当X <= 0 时，返回的结果为NULL  |\n| LOG10(X)             | 返回以10为底的X的对数，当X <= 0 时，返回的结果为NULL |\n| LOG2(X)              | 返回以2为底的X的对数，当X <= 0 时，返回NULL          |\n\n##### 样例\n\n```mysql\nmysql> SELECT POW(2,5),POWER(2,4),EXP(2),LN(10),LOG10(10),LOG2(4)\n-> FROM DUAL;\n+----------+------------+------------------+-------------------+-----------+---------+\n| POW(2,5) | POWER(2,4) | EXP(2) | LN(10) | LOG10(10) | LOG2(4) |\n+----------+------------+------------------+-------------------+-----------+---------+\n| 32 | 16 | 7.38905609893065 | 2.302585092994046 | 1 | 2 |\n+----------+------------+------------------+-------------------+-----------+---------+\n1 row in set (0.00 sec)\n```\n\n\n\n#### 进制间的转换\n\n| 函数          | 用法                     |\n| ------------- | ------------------------ |\n| BIN(x)        | 返回x的二进制编码        |\n| HEX(x)        | 返回x的十六进制编码      |\n| OCT(x)        | 返回x的八进制编码        |\n| CONV(x,f1,f2) | 返回f1进制数变成f2进制数 |\n\n```mysql\nmysql> SELECT BIN(10),HEX(10),OCT(10),CONV(10,2,8)\n-> FROM DUAL;\n+---------+---------+---------+--------------+\n| BIN(10) | HEX(10) | OCT(10) | CONV(10,2,8) |\n+---------+---------+---------+--------------+\n| 1010 | A | 12 | 2 |\n+---------+---------+---------+--------------+\n1 row in set (0.00 sec)\n```\n\n\n\n\n\n\n\n### 字符串函数\n\n| 函数                              | 用法                                                         |\n| --------------------------------- | ------------------------------------------------------------ |\n| ASCII(S)                          | 返回字符串S中的第一个字符的ASCII码值                         |\n| CHAR_LENGTH(s)                    | 返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同           |\n| LENGTH(s)                         | 返回字符串s的字节   字符集有关                               |\n| CONCAT(s1,s2,......,sn)           | 连接s1,s2,......,sn为一个字符串                              |\n| CONCAT_WS(x, s1,s2,......,sn)     | 同CONCAT(s1,s2,...)函数，但是每个字符串之间要加上x           |\n| INSERT(str, idx, len, replacestr) | 将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr |\n| REPLACE(str, a, b)                | 用字符串b替换字符串str中所有出现的字符串a                    |\n| UPPER(s) 或 UCASE(s)              | 将字符串s的所有字母转成大写字母                              |\n| LOWER(s) 或LCASE(s)               | 将字符串s的所有字母转成小写字母                              |\n| LEFT(str,n)                       | 返回字符串str最左边的n个字符                                 |\n| RIGHT(str,n)                      | 返回字符串str最右边的n个字符                                 |\n| LPAD(str, len, pad)               | 用字符串pad对str最左边进行填充，直到str的长度为len个字符     |\n| RPAD(str ,len, pad)               | 用字符串pad对str最右边进行填充，直到str的长度为len个字符     |\n| LTRIM(s)                          | 去掉字符串s左侧的空格                                        |\n| RTRIM(s)                          | 去掉字符串s右侧的空格                                        |\n| TRIM(s)                           | 去掉字符串s开始与结尾的空格                                  |\n| TRIM(s1 FROM s)                   | 去掉字符串s开始与结尾的s1                                    |\n| TRIM(LEADING s1 FROM s)           | 去掉字符串s开始处的s1                                        |\n| TRIM(TRAILING s1 FROM s)          | 去掉字符串s结尾处的s1                                        |\n| REPEAT(str, n)                    | 返回str重复n次的结果                                         |\n| SPACE(n)                          | 返回n个空格                                                  |\n| STRCMP(s1,s2)                     | 比较字符串s1,s2的ASCII码值的大小                             |\n| SUBSTR(s,index,len)               | 返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、 MID(s,n,len)相同 |\n| LOCATE(substr,str)                | 返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN str)、INSTR(str,substr)相同。未找到，返回0 |\n| ELT(m,s1,s2,…,sn)                 | 返回指定位置的字符串，如果m=1，则返回s1，如果m=2，则返回s2，如果m=n，则返回sn |\n| FIELD(s,s1,s2,…,sn)               | 返回字符串s在字符串列表中第一次出现的位置                    |\n| FIND_IN_SET(s1,s2)                | 返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串 |\n| REVERSE(s)                        | 返回s反转后的字符串                                          |\n| NULLIF(value1,value2)             | 比较两个字符串，如果value1与value2相等，则返回NULL，否则返回 value1 |\n\n> 注意：MySQL中，字符串的位置是从1开始的。\n\n#### 样例\n\n```mysql\nmysql> SELECT FIELD('mm','hello','msm','amma'),FIND_IN_SET('mm','hello,mm,amma')\n-> FROM DUAL;\n+----------------------------------+-----------------------------------+\n| FIELD('mm','hello','msm','amma') | FIND_IN_SET('mm','hello,mm,amma') |\n+----------------------------------+-----------------------------------+\n| 0 | 2 |\n+----------------------------------+-----------------------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT NULLIF('mysql','mysql'),NULLIF('mysql', '');\n+-------------------------+---------------------+\n| NULLIF('mysql','mysql') | NULLIF('mysql', '') |\n+-------------------------+---------------------+\n| NULL | mysql |\n+-------------------------+---------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n###  日期和时间函数\n\n#### 获取日期、时间\n\n| 函数                                                         | 用法                            |\n| ------------------------------------------------------------ | ------------------------------- |\n| CURDATE() ，CURRENT_DATE()                                   | 返回当前日期，只包含年、 月、日 |\n| CURTIME() ， CURRENT_TIME()                                  | 返回当前时间，只包含时、 分、秒 |\n| NOW() / SYSDATE() / CURRENT_TIMESTAMP() / LOCALTIME() / LOCALTIMESTAMP() | 返回当前系统日期和时间          |\n| UTC_DATE()                                                   | 返回UTC（世界标准时间） 日期    |\n| UTC_TIME()                                                   | 返回UTC（世界标准时间） 时间    |\n\n##### 样例\n\n```mysql\nmysql> SELECT\n    -> CURDATE(),CURTIME(),NOW(),SYSDATE()+0,UTC_DATE(),UTC_DATE()+0,UTC_TIME(),UTC_TIME()+0\n    -> FROM DUAL;\n+------------+-----------+---------------------+----------------+------------+--------------+------------+--------------+\n| CURDATE()  | CURTIME() | NOW()               | SYSDATE()+0    | UTC_DATE() | UTC_DATE()+0 | UTC_TIME() | UTC_TIME()+0 |\n+------------+-----------+---------------------+----------------+------------+--------------+------------+--------------+\n| 2023-06-11 | 12:50:21  | 2023-06-11 12:50:21 | 20230611125021 | 2023-06-11 |     20230611 | 04:50:21   | 45021.000000 |\n+------------+-----------+---------------------+----------------+------------+--------------+------------+--------------+\n1 row in set (0.00 sec)\n```\n\n\n\n#### 日期与时间戳的转换\n\n| 函数                     | 用法                                                         |\n| ------------------------ | ------------------------------------------------------------ |\n| UNIX_TIMESTAMP()         | 以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP() - >1634348884 |\n| UNIX_TIMESTAMP(date)     | 将时间date以UNIX时间戳的形式返回。                           |\n| FROM_UNIXTIME(timestamp) | 将UNIX时间戳的时间转换为普通格式的时间                       |\n\n##### 样例\n\n```mysql\nmysql> SELECT UNIX_TIMESTAMP(now());\n+-----------------------+\n| UNIX_TIMESTAMP(now()) |\n+-----------------------+\n| 1576380910 |\n+-----------------------+\n1 row in set (0.01 sec)\n```\n\n```mysql\nmysql> SELECT UNIX_TIMESTAMP(CURDATE());\n+---------------------------+\n| UNIX_TIMESTAMP(CURDATE()) |\n+---------------------------+\n| 1576339200 |\n+---------------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT UNIX_TIMESTAMP(CURTIME());\n+---------------------------+\n| UNIX_TIMESTAMP(CURTIME()) |\n+---------------------------+\n| 1576380969 |\n+---------------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT UNIX_TIMESTAMP('2011-11-11 11:11:11')\n+---------------------------------------+\n| UNIX_TIMESTAMP('2011-11-11 11:11:11') |\n+---------------------------------------+\n| 1320981071 |\n+---------------------------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT FROM_UNIXTIME(1576380910);\n+---------------------------+\n| FROM_UNIXTIME(1576380910) |\n+---------------------------+\n| 2019-12-15 11:35:10 |\n+---------------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n#### 获取月份、星期、星期数、天数等函数\n\n| 函数                                     | 用法                                             |\n| ---------------------------------------- | ------------------------------------------------ |\n| YEAR(date) / MONTH(date) / DAY(date)     | 返回具体的日期值                                 |\n| HOUR(time) / MINUTE(time) / SECOND(time) | 返回具体的时间值                                 |\n| FROM_UNIXTIME(timestamp)                 | 将UNIX时间戳的时间转换为普通格式的时间           |\n| MONTHNAME(date)                          | 返回月份：January，...                           |\n| DAYNAME(date)                            | 返回星期几：MONDAY，TUESDAY.....SUNDAY           |\n| WEEKDAY(date)                            | 返回周几，注意，周1是0，周2是1，。。。周日是6    |\n| QUARTER(date)                            | 返回日期对应的季度，范围为1～4                   |\n| WEEK(date) ， WEEKOFYEAR(date)           | 返回一年中的第几周                               |\n| DAYOFYEAR(date)                          | 返回日期是一年中的第几天                         |\n| DAYOFMONTH(date)                         | 返回日期位于所在月份的第几天                     |\n| DAYOFWEEK(date)                          | 返回周几，注意：周日是1，周一是2，。。。周六是 7 |\n\n##### 样例\n\n```mysql\nmysql> SELECT YEAR(CURDATE()),MONTH(CURDATE()),DAY(CURDATE()),\n    -> HOUR(CURTIME()),MINUTE(NOW()),SECOND(SYSDATE())\n    -> FROM DUAL;\n+-----------------+------------------+----------------+-----------------+---------------+-------------------+\n| YEAR(CURDATE()) | MONTH(CURDATE()) | DAY(CURDATE()) | HOUR(CURTIME()) | MINUTE(NOW()) | SECOND(SYSDATE()) |\n+-----------------+------------------+----------------+-----------------+---------------+-------------------+\n|            2023 |                6 |             11 |              16 |             4 |                28 |\n+-----------------+------------------+----------------+-----------------+---------------+-------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT MONTHNAME('2021-10-26'),DAYNAME('2021-10-26'),WEEKDAY('2021-10-26'),\n    -> QUARTER(CURDATE()),WEEK(CURDATE()),DAYOFYEAR(NOW()),\n    -> DAYOFMONTH(NOW()),DAYOFWEEK(NOW())\n    -> FROM DUAL;\n+-------------------------+-----------------------+-----------------------+--------------------+-----------------+------------------+-------------------+------------------+\n| MONTHNAME('2021-10-26') | DAYNAME('2021-10-26') | WEEKDAY('2021-10-26') | QUARTER(CURDATE()) | WEEK(CURDATE()) | DAYOFYEAR(NOW()) | DAYOFMONTH(NOW()) | DAYOFWEEK(NOW()) |\n+-------------------------+-----------------------+-----------------------+--------------------+-----------------+------------------+-------------------+------------------+\n| October                 | Tuesday               |                     1 |                  2 |              24 |              162 |                11 |                1 |\n+-------------------------+-----------------------+-----------------------+--------------------+-----------------+------------------+-------------------+------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n#### 日期的操作函数\n\n| 函数                    | 用法                                       |\n| ----------------------- | ------------------------------------------ |\n| EXTRACT(type FROM date) | 返回指定日期中特定的部分，type指定返回的值 |\n\nEXTRACT(type FROM date)函数中type的取值与含义：\n\n![image-20220601162705975](./Image/MySql基础笔记.assets/image-20220601162705975.png)\n\n##### 样例\n\n```mysql\nmysql> SELECT EXTRACT(MINUTE FROM NOW()),EXTRACT( WEEK FROM NOW()),\n    -> EXTRACT( QUARTER FROM NOW()),EXTRACT( MINUTE_SECOND FROM NOW())\n    -> FROM DUAL;\n+----------------------------+---------------------------+------------------------------+------------------------------------+\n| EXTRACT(MINUTE FROM NOW()) | EXTRACT( WEEK FROM NOW()) | EXTRACT( QUARTER FROM NOW()) | EXTRACT( MINUTE_SECOND FROM NOW()) |\n+----------------------------+---------------------------+------------------------------+------------------------------------+\n|                          6 |                        24 |                            2 |                                640 |\n+----------------------------+---------------------------+------------------------------+------------------------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n#### 时间和秒钟转换的函数\n\n| 函数                 | 用法                                                         |\n| -------------------- | ------------------------------------------------------------ |\n| TIME_TO_SEC(time)    | 将 time 转化为秒并返回结果值。转化的公式为： 小时*3600+分钟 *60+秒 |\n| SEC_TO_TIME(seconds) | 将 seconds 描述转化为包含小时、分钟和秒的时间                |\n\n##### 样例\n\n```mysql\nmysql> SELECT TIME_TO_SEC(NOW());\n+--------------------+\n| TIME_TO_SEC(NOW()) |\n+--------------------+\n|              58322 |\n+--------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT SEC_TO_TIME(58322);\n+--------------------+\n| SEC_TO_TIME(58322) |\n+--------------------+\n| 16:12:02           |\n+--------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n#### 计算日期和时间的函数\n\n| 函数                                                         | 用法                                           |\n| ------------------------------------------------------------ | ---------------------------------------------- |\n| DATE_ADD(datetime, INTERVAL expr type)， ADDDATE(date,INTERVAL expr type) | 返回与给定日期时间相差INTERVAL时间段的日期时间 |\n| DATE_SUB(date,INTERVAL expr type)， SUBDATE(date,INTERVAL expr type) | 返回与date相差INTERVAL时间间隔的日期           |\n\n上述函数中type的取值：\n\n![image-20220601165055639](./Image/MySql基础笔记.assets/image-20220601165055639.png)\n\n\n\n##### 样例1\n\n```mysql\nmysql> SELECT DATE_ADD(NOW(), INTERVAL 1 DAY) AS col1,DATE_ADD('2021-10-21 23:32:12',INTERVAL\n    -> 1 SECOND) AS col2,\n    -> ADDDATE('2021-10-21 23:32:12',INTERVAL 1 SECOND) AS col3,\n    -> DATE_ADD('2021-10-21 23:32:12',INTERVAL '1_1' MINUTE_SECOND) AS col4, #1_1意为1分1秒，f\n    -> DATE_ADD(NOW(), INTERVAL -1 YEAR) AS col5, #可以是负数\n    -> DATE_ADD(NOW(), INTERVAL '1_1' YEAR_MONTH) AS col6 #需要单引号\n    -> FROM DUAL;\n+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+\n| col1                | col2                | col3                | col4                | col5                | col6                |\n+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+\n| 2023-06-12 16:13:49 | 2021-10-21 23:32:13 | 2021-10-21 23:32:13 | 2021-10-21 23:33:13 | 2022-06-11 16:13:49 | 2024-07-11 16:13:49 |\n+---------------------+---------------------+---------------------+---------------------+---------------------+---------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT DATE_SUB('2021-01-21',INTERVAL 31 DAY) AS col1,\n    -> SUBDATE('2021-01-21',INTERVAL 31 DAY) AS col2,\n    -> DATE_SUB('2021-01-21 02:01:01',INTERVAL '1 1' DAY_HOUR) AS col3\n    -> FROM DUAL;\n+------------+------------+---------------------+\n| col1       | col2       | col3                |\n+------------+------------+---------------------+\n| 2020-12-21 | 2020-12-21 | 2021-01-20 01:01:01 |\n+------------+------------+---------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n\n\n| 函数                         | 用法                                                         |\n| ---------------------------- | ------------------------------------------------------------ |\n| ADDTIME(time1,time2)         | 返回time1加上time2的时间。当time2为一个数字时，代表的是 秒 ，可以为负数 |\n| SUBTIME(time1,time2)         | 返回time1减去time2后的时间。当time2为一个数字时，代表的 是 秒 ，可以为负数 |\n| DATEDIFF(date1,date2)        | 返回date1 - date2的日期间隔天数                              |\n| TIMEDIFF(time1, time2)       | 返回time1 - time2的时间间隔                                  |\n| FROM_DAYS(N)                 | 返回从0000年1月1日起，N天以后的日期                          |\n| TO_DAYS(date)                | 返回日期date距离0000年1月1日的天数                           |\n| LAST_DAY(date)               | 返回date所在月份的最后一天的日期                             |\n| MAKEDATE(year,n)             | 针对给定年份与所在年份中的天数返回一个日期                   |\n| MAKETIME(hour,minute,second) | 将给定的小时、分钟和秒组合成时间并返回                       |\n| PERIOD_ADD(time,n)           | 返回time加上n后的时间                                        |\n\n\n\n##### 样例2\n\n```mysql\nmysql> SELECT\n    -> ADDTIME(NOW(),20),SUBTIME(NOW(),30),SUBTIME(NOW(),'1:1:3'),DATEDIFF(NOW(),'2021-10-\n    '> 01'),\n    -> TIMEDIFF(NOW(),'2021-10-25 22:10:10'),FROM_DAYS(366),TO_DAYS('0000-12-25'),\n    -> LAST_DAY(NOW()),MAKEDATE(YEAR(NOW()),12),MAKETIME(10,21,23),PERIOD_ADD(20200101010101,\n    -> 10)\n    -> FROM DUAL;\n+---------------------+---------------------+------------------------+-------------------------------+---------------------------------------+----------------+-----------------------+-----------------+--------------------------+--------------------+--------------------------------+\n| ADDTIME(NOW(),20)   | SUBTIME(NOW(),30)   | SUBTIME(NOW(),'1:1:3') | DATEDIFF(NOW(),'2021-10-\n01') | TIMEDIFF(NOW(),'2021-10-25 22:10:10') | FROM_DAYS(366) | TO_DAYS('0000-12-25') | LAST_DAY(NOW()) | MAKEDATE(YEAR(NOW()),12) | MAKETIME(10,21,23) | PERIOD_ADD(20200101010101,\n10) |\n+---------------------+---------------------+------------------------+-------------------------------+---------------------------------------+----------------+-----------------------+-----------------+--------------------------+--------------------+--------------------------------+\n| 2023-06-11 16:15:20 | 2023-06-11 16:14:30 | 2023-06-11 15:13:57    |                          NULL | 838:59:59                             | 0001-01-01     |                   359 | 2023-06-30      | 2023-01-12               | 10:21:23           |                      869817111 |\n+---------------------+---------------------+------------------------+-------------------------------+---------------------------------------+----------------+-----------------------+-----------------+--------------------------+--------------------+--------------------------------+\n1 row in set, 2 warnings (0.00 sec)\n```\n\n```mysql\nmysql> SELECT ADDTIME(NOW(), 50);\n+---------------------+\n| ADDTIME(NOW(), 50) |\n+---------------------+\n| 2019-12-15 22:17:47 |\n+---------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT ADDTIME(NOW(), '1:1:1');\n+-------------------------+\n| ADDTIME(NOW(), '1:1:1') |\n+-------------------------+\n| 2019-12-15 23:18:46 |\n+-------------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT SUBTIME(NOW(), '1:1:1');\n+-------------------------+\n| SUBTIME(NOW(), '1:1:1') |\n+-------------------------+\n| 2019-12-15 21:23:50 |\n+-------------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT SUBTIME(NOW(), '-1:-1:-1');\n+----------------------------+\n| SUBTIME(NOW(), '-1:-1:-1') |\n+----------------------------+\n| 2019-12-15 22:25:11 |\n+----------------------------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n```mysql\nmysql> SELECT FROM_DAYS(366);\n+----------------+\n| FROM_DAYS(366) |\n+----------------+\n| 0001-01-01 |\n+----------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT MAKEDATE(2020,1);\n+------------------+\n| MAKEDATE(2020,1) |\n+------------------+\n| 2020-01-01 |\n+------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT MAKEDATE(2020,32);\n+-------------------+\n| MAKEDATE(2020,32) |\n+-------------------+\n| 2020-02-01 |\n+-------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT MAKETIME(1,1,1);\n+-----------------+\n| MAKETIME(1,1,1) |\n+-----------------+\n| 01:01:01 |\n+-----------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT PERIOD_ADD(20200101010101,1);\n+------------------------------+\n| PERIOD_ADD(20200101010101,1) |\n+------------------------------+\n| 20200101010102 |\n+------------------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT TO_DAYS(NOW());\n+----------------+\n| TO_DAYS(NOW()) |\n+----------------+\n| 737773 |\n+----------------+\n1 row in set (0.00 sec)\n```\n\n\n\n#### 日期的格式化与解析\n\n| 函数                              | 用法                                       |\n| --------------------------------- | ------------------------------------------ |\n| DATE_FORMAT(date,fmt)             | 按照字符串fmt格式化日期date值              |\n| TIME_FORMAT(time,fmt)             | 按照字符串fmt格式化时间time值              |\n| GET_FORMAT(date_type,format_type) | 返回日期字符串的显示格式                   |\n| STR_TO_DATE(str, fmt)             | 按照字符串fmt对str进行解析，解析为一个日期 |\n\n上述 非GET_FORMAT 函数中fmt参数常用的格式符：\n\n| 格式符 | 说明                                                         | 格式符  | 说明                                                         |\n| ------ | ------------------------------------------------------------ | ------- | ------------------------------------------------------------ |\n| %Y     | 4位数字表示年份                                              | %y      | 表示两位数字表示年份                                         |\n| %M     | 月名表示月份（January,....）                                 | %m      | 两位数字表示月份 （01,02,03。。。）                          |\n| %b     | 缩写的月名（Jan.，Feb.，....）                               | %c      | 数字表示月份（1,2,3,...）                                    |\n| %D     | 英文后缀表示月中的天数 （1st,2nd,3rd,...）                   | %d      | 两位数字表示月中的天数(01,02...)                             |\n| %e     | 数字形式表示月中的天数 （1,2,3,4,5.....）                    |         |                                                              |\n| %H     | 两位数字表示小数，24小时制 （01,02..）                       | %h 和%I | 两位数字表示小时，12小时制 （01,02..）                       |\n| %k     | 数字形式的小时，24小时制(1,2,3)                              | %l      | 数字形式表示小时，12小时制 （1,2,3,4....）                   |\n| %i     | 两位数字表示分钟（00,01,02）                                 | %S 和%s | 两位数字表示秒(00,01,02...)                                  |\n| %W     | 一周中的星期名称（Sunday...）                                | %a      | 一周中的星期缩写（Sun.， Mon.,Tues.，..）                    |\n| %w     | 以数字表示周中的天数 (0=Sunday,1=Monday....)                 |         |                                                              |\n| %j     | 以3位数字表示年中的天数(001,002...)                          | %U      | 以数字表示年中的第几周， （1,2,3。。）其中Sunday为周中第一 天 |\n| %u     | 以数字表示年中的第几周， （1,2,3。。）其中Monday为周中第一 天 |         |                                                              |\n| %T     | 24小时制                                                     | %r      | 12小时制                                                     |\n| %p     | AM或PM                                                       | %%      | 表示%                                                        |\n\n\n\nGET_FORMAT函数中date_type和format_type参数取值如下：\n\n![image-20230611163252682](./Image/MySql基础笔记.assets/image-20230611163252682.png)\n\n##### 样例\n\n```mysql\nmysql> SELECT DATE_FORMAT(NOW(), '%H:%i:%s');\n+--------------------------------+\n| DATE_FORMAT(NOW(), '%H:%i:%s') |\n+--------------------------------+\n| 22:57:34 |\n+--------------------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT STR_TO_DATE('09/01/2009','%m/%d/%Y')\n    -> FROM DUAL;\n+--------------------------------------+\n| STR_TO_DATE('09/01/2009','%m/%d/%Y') |\n+--------------------------------------+\n| 2009-09-01                           |\n+--------------------------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT STR_TO_DATE('20140422154706','%Y%m%d%H%i%s')\n    -> FROM DUAL;\n+----------------------------------------------+\n| STR_TO_DATE('20140422154706','%Y%m%d%H%i%s') |\n+----------------------------------------------+\n| 2014-04-22 15:47:06                          |\n+----------------------------------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT STR_TO_DATE('2014-04-22 15:47:06','%Y-%m-%d %H:%i:%s')\n    -> FROM DUAL;\n+--------------------------------------------------------+\n| STR_TO_DATE('2014-04-22 15:47:06','%Y-%m-%d %H:%i:%s') |\n+--------------------------------------------------------+\n| 2014-04-22 15:47:06                                    |\n+--------------------------------------------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT GET_FORMAT(DATE, 'USA');\n+-------------------------+\n| GET_FORMAT(DATE, 'USA') |\n+-------------------------+\n| %m.%d.%Y |\n+-------------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT STR_TO_DATE('2020-01-01 00:00:00','%Y-%m-%d');\n+-----------------------------------------------+\n| STR_TO_DATE('2020-01-01 00:00:00','%Y-%m-%d') |\n+-----------------------------------------------+\n| 2020-01-01                                    |\n+-----------------------------------------------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n\n\n\n\n\n\n### 流程控制函数\n\n流程处理函数可以根据不同的条件，执行不同的处理流程，可以在SQL语句中实现不同的条件选择。 MySQL中的流程处理函数主要包括IF()、IFNULL()和CASE()函数。\n\n| 函数                                                         | 用法                                             |\n| ------------------------------------------------------------ | ------------------------------------------------ |\n| IF(value,value1,value2)                                      | 如果value的值为TRUE，返回value1， 否则返回value2 |\n| IFNULL(value1, value2)                                       | 如果value1不为NULL，返回value1，否则返回value2   |\n| CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 .... [ELSE resultn] END | 相当于Java的if...else if...else...               |\n| CASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 .... [ELSE 值n] END | 相当于Java的switch...case...                     |\n\n#### 样例\n\n```mysql\nSELECT IF(1 > 0,'正确','错误')\n->正确\n```\n\n```mysql\nSELECT IFNULL(null,'Hello Word')\n->Hello Word\n```\n\n```mysql\nSELECT CASE\n    WHEN 1 > 0\n    THEN '1 > 0'\n    WHEN 2 > 0\n    THEN '2 > 0'\n    ELSE '3 > 0'\n    END\n->1 > 0\n```\n\n```mysql\nSELECT CASE 1\nWHEN 1 THEN '我是1'\nWHEN 2 THEN '我是2'\nELSE '你是谁'\n```\n\n```mysql\nSELECT employee_id,salary, CASE WHEN salary>=15000 THEN '高薪'\nWHEN salary>=10000 THEN '潜力股'\nWHEN salary>=8000 THEN '屌丝'\nELSE '草根' END \"描述\"\nFROM employees;\n```\n\n```mysql\nSELECT oid,`status`, CASE `status` WHEN 1 THEN '未付款'\n                                WHEN 2 THEN '已付款'\n                                WHEN 3 THEN '已发货'\n                                WHEN 4 THEN '确认收货'\n                                ELSE '无效订单' END\nFROM t_order;\n```\n\n```MYSQL\nmysql> SELECT CASE WHEN 1 > 0 THEN 'yes' WHEN 1 <= 0 THEN 'no' ELSE 'unknown' END;\n+---------------------------------------------------------------------+\n| CASE WHEN 1 > 0 THEN 'yes' WHEN 1 <= 0 THEN 'no' ELSE 'unknown' END |\n+---------------------------------------------------------------------+\n| yes                                                                 |\n+---------------------------------------------------------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT CASE WHEN 1 < 0 THEN 'yes' WHEN 1 = 0 THEN 'no' ELSE 'unknown' END;\n+--------------------------------------------------------------------+\n| CASE WHEN 1 < 0 THEN 'yes' WHEN 1 = 0 THEN 'no' ELSE 'unknown' END |\n+--------------------------------------------------------------------+\n| unknown                                                            |\n+--------------------------------------------------------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT CASE 1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END;\n+------------------------------------------------+\n| CASE 1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END |\n+------------------------------------------------+\n|                                              1 |\n+------------------------------------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nSELECT CASE -1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END;\n+-------------------------------------------------+\n| CASE -1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END |\n+-------------------------------------------------+\n|                                              -1 |\n+-------------------------------------------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT employee_id,12 * salary * (1 + IFNULL(commission_pct,0))\n    -> FROM employees;\n+-------------+----------------------------------------------+\n| employee_id | 12 * salary * (1 + IFNULL(commission_pct,0)) |\n+-------------+----------------------------------------------+\n|         100 |                                    288000.00 |\n|         101 |                                    204000.00 |\n|         102 |                                    204000.00 |\n|         103 |                                    108000.00 |\n|         104 |                                     72000.00 |\n|         105 |                                     57600.00 |\n|         106 |                                     57600.00 |\n|         107 |                                     50400.00 |\n|         108 |                                    144000.00 |\n|         109 |                                    108000.00 |\n|         110 |                                     98400.00 |\n|         111 |                                     92400.00 |\n|         112 |                                     93600.00 |\n|         113 |                                     82800.00 |\n|         114 |                                    132000.00 |\n|         115 |                                     37200.00 |\n|         116 |                                     34800.00 |\n|         117 |                                     33600.00 |\n|         118 |                                     31200.00 |\n|         119 |                                     30000.00 |\n|         120 |                                     96000.00 |\n|         121 |                                     98400.00 |\n|         122 |                                     94800.00 |\n|         123 |                                     78000.00 |\n|         124 |                                     69600.00 |\n|         125 |                                     38400.00 |\n|         126 |                                     32400.00 |\n|         127 |                                     28800.00 |\n|         128 |                                     26400.00 |\n|         129 |                                     39600.00 |\n|         130 |                                     33600.00 |\n|         131 |                                     30000.00 |\n|         132 |                                     25200.00 |\n|         133 |                                     39600.00 |\n|         134 |                                     34800.00 |\n|         135 |                                     28800.00 |\n|         136 |                                     26400.00 |\n|         137 |                                     43200.00 |\n|         138 |                                     38400.00 |\n|         139 |                                     32400.00 |\n|         140 |                                     30000.00 |\n|         141 |                                     42000.00 |\n|         142 |                                     37200.00 |\n|         143 |                                     31200.00 |\n|         144 |                                     30000.00 |\n|         145 |                                    235200.00 |\n|         146 |                                    210600.00 |\n|         147 |                                    187200.00 |\n|         148 |                                    171600.00 |\n|         149 |                                    151200.00 |\n|         150 |                                    156000.00 |\n|         151 |                                    142500.00 |\n|         152 |                                    135000.00 |\n|         153 |                                    115200.00 |\n|         154 |                                    108000.00 |\n|         155 |                                     96600.00 |\n|         156 |                                    162000.00 |\n|         157 |                                    153900.00 |\n|         158 |                                    145800.00 |\n|         159 |                                    124800.00 |\n|         160 |                                    117000.00 |\n|         161 |                                    105000.00 |\n|         162 |                                    157500.00 |\n|         163 |                                    131100.00 |\n|         164 |                                     95040.00 |\n|         165 |                                     89760.00 |\n|         166 |                                     84480.00 |\n|         167 |                                     81840.00 |\n|         168 |                                    172500.00 |\n|         169 |                                    144000.00 |\n|         170 |                                    138240.00 |\n|         171 |                                    102120.00 |\n|         172 |                                    100740.00 |\n|         173 |                                     80520.00 |\n|         174 |                                    171600.00 |\n|         175 |                                    132000.00 |\n|         176 |                                    123840.00 |\n|         177 |                                    120960.00 |\n|         178 |                                     96600.00 |\n|         179 |                                     81840.00 |\n|         180 |                                     38400.00 |\n|         181 |                                     37200.00 |\n|         182 |                                     30000.00 |\n|         183 |                                     33600.00 |\n|         184 |                                     50400.00 |\n|         185 |                                     49200.00 |\n|         186 |                                     40800.00 |\n|         187 |                                     36000.00 |\n|         188 |                                     45600.00 |\n|         189 |                                     43200.00 |\n|         190 |                                     34800.00 |\n|         191 |                                     30000.00 |\n|         192 |                                     48000.00 |\n|         193 |                                     46800.00 |\n|         194 |                                     38400.00 |\n|         195 |                                     33600.00 |\n|         196 |                                     37200.00 |\n|         197 |                                     36000.00 |\n|         198 |                                     31200.00 |\n|         199 |                                     31200.00 |\n|         200 |                                     52800.00 |\n|         201 |                                    156000.00 |\n|         202 |                                     72000.00 |\n|         203 |                                     78000.00 |\n|         204 |                                    120000.00 |\n|         205 |                                    144000.00 |\n|         206 |                                     99600.00 |\n+-------------+----------------------------------------------+\n107 rows in set (0.02 sec)\n```\n\n```mysql\nmysql> SELECT last_name, job_id, salary,\n    -> CASE job_id WHEN 'IT_PROG' THEN 1.10*salary\n    -> WHEN 'ST_CLERK' THEN 1.15*salary\n    -> WHEN 'SA_REP' THEN 1.20*salary\n    -> ELSE salary END \"REVISED_SALARY\"\n    -> FROM employees;\n+-------------+------------+----------+----------------+\n| last_name   | job_id     | salary   | REVISED_SALARY |\n+-------------+------------+----------+----------------+\n| King        | AD_PRES    | 24000.00 |       24000.00 |\n| Kochhar     | AD_VP      | 17000.00 |       17000.00 |\n| De Haan     | AD_VP      | 17000.00 |       17000.00 |\n| Hunold      | IT_PROG    |  9000.00 |        9900.00 |\n| Ernst       | IT_PROG    |  6000.00 |        6600.00 |\n| Austin      | IT_PROG    |  4800.00 |        5280.00 |\n| Pataballa   | IT_PROG    |  4800.00 |        5280.00 |\n| Lorentz     | IT_PROG    |  4200.00 |        4620.00 |\n| Greenberg   | FI_MGR     | 12000.00 |       12000.00 |\n| Faviet      | FI_ACCOUNT |  9000.00 |        9000.00 |\n| Chen        | FI_ACCOUNT |  8200.00 |        8200.00 |\n| Sciarra     | FI_ACCOUNT |  7700.00 |        7700.00 |\n| Urman       | FI_ACCOUNT |  7800.00 |        7800.00 |\n| Popp        | FI_ACCOUNT |  6900.00 |        6900.00 |\n| Raphaely    | PU_MAN     | 11000.00 |       11000.00 |\n| Khoo        | PU_CLERK   |  3100.00 |        3100.00 |\n| Baida       | PU_CLERK   |  2900.00 |        2900.00 |\n| Tobias      | PU_CLERK   |  2800.00 |        2800.00 |\n| Himuro      | PU_CLERK   |  2600.00 |        2600.00 |\n| Colmenares  | PU_CLERK   |  2500.00 |        2500.00 |\n| Weiss       | ST_MAN     |  8000.00 |        8000.00 |\n| Fripp       | ST_MAN     |  8200.00 |        8200.00 |\n| Kaufling    | ST_MAN     |  7900.00 |        7900.00 |\n| Vollman     | ST_MAN     |  6500.00 |        6500.00 |\n| Mourgos     | ST_MAN     |  5800.00 |        5800.00 |\n| N_ayer      | ST_CLERK   |  3200.00 |        3680.00 |\n| Mikkilineni | ST_CLERK   |  2700.00 |        3105.00 |\n| Landry      | ST_CLERK   |  2400.00 |        2760.00 |\n| Markle      | ST_CLERK   |  2200.00 |        2530.00 |\n| Bissot      | ST_CLERK   |  3300.00 |        3795.00 |\n| Atkinson    | ST_CLERK   |  2800.00 |        3220.00 |\n| Marlow      | ST_CLERK   |  2500.00 |        2875.00 |\n| Olson       | ST_CLERK   |  2100.00 |        2415.00 |\n| Mallin      | ST_CLERK   |  3300.00 |        3795.00 |\n| Rogers      | ST_CLERK   |  2900.00 |        3335.00 |\n| Gee         | ST_CLERK   |  2400.00 |        2760.00 |\n| Philtanker  | ST_CLERK   |  2200.00 |        2530.00 |\n| Ladwig      | ST_CLERK   |  3600.00 |        4140.00 |\n| Stiles      | ST_CLERK   |  3200.00 |        3680.00 |\n| Seo         | ST_CLERK   |  2700.00 |        3105.00 |\n| Patel       | ST_CLERK   |  2500.00 |        2875.00 |\n| Rajs        | ST_CLERK   |  3500.00 |        4025.00 |\n| Davies      | ST_CLERK   |  3100.00 |        3565.00 |\n| Matos       | ST_CLERK   |  2600.00 |        2990.00 |\n| Vargas      | ST_CLERK   |  2500.00 |        2875.00 |\n| Russell     | SA_MAN     | 14000.00 |       14000.00 |\n| Partners    | SA_MAN     | 13500.00 |       13500.00 |\n| Errazuriz   | SA_MAN     | 12000.00 |       12000.00 |\n| Cambrault   | SA_MAN     | 11000.00 |       11000.00 |\n| Zlotkey     | SA_MAN     | 10500.00 |       10500.00 |\n| Tucker      | SA_REP     | 10000.00 |       12000.00 |\n| Bernstein   | SA_REP     |  9500.00 |       11400.00 |\n| Hall        | SA_REP     |  9000.00 |       10800.00 |\n| Olsen       | SA_REP     |  8000.00 |        9600.00 |\n| Cambrault   | SA_REP     |  7500.00 |        9000.00 |\n| Tuvault     | SA_REP     |  7000.00 |        8400.00 |\n| King        | SA_REP     | 10000.00 |       12000.00 |\n| Sully       | SA_REP     |  9500.00 |       11400.00 |\n| McEwen      | SA_REP     |  9000.00 |       10800.00 |\n| Smith       | SA_REP     |  8000.00 |        9600.00 |\n| Doran       | SA_REP     |  7500.00 |        9000.00 |\n| Sewall      | SA_REP     |  7000.00 |        8400.00 |\n| Vishney     | SA_REP     | 10500.00 |       12600.00 |\n| Greene      | SA_REP     |  9500.00 |       11400.00 |\n| Marvins     | SA_REP     |  7200.00 |        8640.00 |\n| Lee         | SA_REP     |  6800.00 |        8160.00 |\n| Ande        | SA_REP     |  6400.00 |        7680.00 |\n| Banda       | SA_REP     |  6200.00 |        7440.00 |\n| Ozer        | SA_REP     | 11500.00 |       13800.00 |\n| Bloom       | SA_REP     | 10000.00 |       12000.00 |\n| Fox         | SA_REP     |  9600.00 |       11520.00 |\n| Smith       | SA_REP     |  7400.00 |        8880.00 |\n| Bates       | SA_REP     |  7300.00 |        8760.00 |\n| Kumar       | SA_REP     |  6100.00 |        7320.00 |\n| Abel        | SA_REP     | 11000.00 |       13200.00 |\n| Hutton      | SA_REP     |  8800.00 |       10560.00 |\n| Taylor      | SA_REP     |  8600.00 |       10320.00 |\n| Livingston  | SA_REP     |  8400.00 |       10080.00 |\n| Grant       | SA_REP     |  7000.00 |        8400.00 |\n| Johnson     | SA_REP     |  6200.00 |        7440.00 |\n| Taylor      | SH_CLERK   |  3200.00 |        3200.00 |\n| Fleaur      | SH_CLERK   |  3100.00 |        3100.00 |\n| Sullivan    | SH_CLERK   |  2500.00 |        2500.00 |\n| Geoni       | SH_CLERK   |  2800.00 |        2800.00 |\n| Sarchand    | SH_CLERK   |  4200.00 |        4200.00 |\n| Bull        | SH_CLERK   |  4100.00 |        4100.00 |\n| Dellinger   | SH_CLERK   |  3400.00 |        3400.00 |\n| Cabrio      | SH_CLERK   |  3000.00 |        3000.00 |\n| Chung       | SH_CLERK   |  3800.00 |        3800.00 |\n| Dilly       | SH_CLERK   |  3600.00 |        3600.00 |\n| Gates       | SH_CLERK   |  2900.00 |        2900.00 |\n| Perkins     | SH_CLERK   |  2500.00 |        2500.00 |\n| Bell        | SH_CLERK   |  4000.00 |        4000.00 |\n| Everett     | SH_CLERK   |  3900.00 |        3900.00 |\n| McCain      | SH_CLERK   |  3200.00 |        3200.00 |\n| Jones       | SH_CLERK   |  2800.00 |        2800.00 |\n| Walsh       | SH_CLERK   |  3100.00 |        3100.00 |\n| Feeney      | SH_CLERK   |  3000.00 |        3000.00 |\n| OConnell    | SH_CLERK   |  2600.00 |        2600.00 |\n| Grant       | SH_CLERK   |  2600.00 |        2600.00 |\n| Whalen      | AD_ASST    |  4400.00 |        4400.00 |\n| Hartstein   | MK_MAN     | 13000.00 |       13000.00 |\n| Fay         | MK_REP     |  6000.00 |        6000.00 |\n| Mavris      | HR_REP     |  6500.00 |        6500.00 |\n| Baer        | PR_REP     | 10000.00 |       10000.00 |\n| Higgins     | AC_MGR     | 12000.00 |       12000.00 |\n| Gietz       | AC_ACCOUNT |  8300.00 |        8300.00 |\n+-------------+------------+----------+----------------+\n107 rows in set (0.00 sec)\n```\n\n\n\n### 加密与解密函数\n\n加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防止数据被他人窃取。这些函数在保证数据库安全时非常有用。\n\n| 函数                        | 用法                                                         |\n| --------------------------- | ------------------------------------------------------------ |\n| PASSWORD(str)               | 返回字符串str的加密版本，41位长的字符串。加密结果不可逆 ，常用于用户的密码加密 |\n| MD5(str)                    | 返回字符串str的md5加密后的值，也是一种加密方式。若参数为 NULL，则会返回NULL |\n| SHA(str)                    | 从原明文密码str计算并返回加密后的密码字符串，当参数为 NULL时，返回NULL。 SHA加密算法比MD5更加安全 。 |\n| ENCODE(value,password_seed) | 返回使用password_seed作为加密密码加密value                   |\n| DECODE(value,password_seed) | 返回使用password_seed作为加密密码解密value                   |\n\n#### 样例\n\n```mysql\nmysql> SELECT PASSWORD('mysql'), PASSWORD(NULL);\n+-------------------------------------------+----------------+\n| PASSWORD('mysql') | PASSWORD(NULL) |\n+-------------------------------------------+----------------+\n| *E74858DB86EBA20BC33D0AECAE8A8108C56B17FA | |\n+-------------------------------------------+----------------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n```mysql\nSELECT md5('123')\n->202cb962ac59075b964b07152d234b70\n```\n\n```mysql\nSELECT SHA('Tom123')\n->c7c506980abc31cc390a2438c90861d0f1216d50\n```\n\n```mysql\nmysql> SELECT ENCODE('mysql', 'mysql');\n+--------------------------+\n| ENCODE('mysql', 'mysql') |\n+--------------------------+\n| íg ¼ ìÉ |\n+--------------------------+\n1 row in set, 1 warning (0.01 sec)\n```\n\n```mysql\nmysql> SELECT DECODE(ENCODE('mysql','mysql'),'mysql');\n+-----------------------------------------+\n| DECODE(ENCODE('mysql','mysql'),'mysql') |\n+-----------------------------------------+\n| mysql |\n+-----------------------------------------+\n1 row in set, 2 warnings (0.00 sec)\n```\n\n\n\n### MySQL信息函数\n\nMySQL中内置了一些可以查询MySQL信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地对数据库进行维护工作。\n\n| 函数                                                   | 用法                                                      |\n| ------------------------------------------------------ | --------------------------------------------------------- |\n| VERSION()                                              | 返回当前MySQL的版本号                                     |\n| CONNECTION_ID()                                        | 返回当前MySQL服务器的连接数                               |\n| DATABASE()，SCHEMA()                                   | 返回MySQL命令行当前所在的数据库                           |\n| USER()，CURRENT_USER()、SYSTEM_USER()， SESSION_USER() | 返回当前连接MySQL的用户名，返回结果格式为 “主机名@用户名” |\n| CHARSET(value)                                         | 返回字符串value自变量的字符集                             |\n| COLLATION(value)                                       | 返回字符串value的比较规则                                 |\n\n#### 样例\n\n```mysql\nmysql> SELECT DATABASE();\n+------------+\n| DATABASE() |\n+------------+\n| test |\n+------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT DATABASE();\n+------------+\n| DATABASE() |\n+------------+\n| test |\n+------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT USER(), CURRENT_USER(), SYSTEM_USER(),SESSION_USER();\n+----------------+----------------+----------------+----------------+\n| USER() | CURRENT_USER() | SYSTEM_USER() | SESSION_USER() |\n+----------------+----------------+----------------+----------------+\n| root@localhost | root@localhost | root@localhost | root@localhost |\n+----------------+----------------+----------------+----------------+\n```\n\n```mysql\nmysql> SELECT CHARSET('ABC');\n+----------------+\n| CHARSET('ABC') |\n+----------------+\n| utf8mb4 |\n+----------------+\n1 row in set (0.00 sec)\n```\n\n```mysql\nmysql> SELECT COLLATION('ABC');\n+--------------------+\n| COLLATION('ABC') |\n+--------------------+\n| utf8mb4_general_ci |\n+--------------------+\n1 row in set (0.00 sec)\n```\n\n\n\n\n\nMySQL中有些函数无法对其进行具体的分类，但是这些函数在MySQL的开发和运维过程中也是不容忽视 的。\n\n| 函数                           | 用法                                                         |\n| ------------------------------ | ------------------------------------------------------------ |\n| FORMAT(value,n)                | 返回对数字value进行格式化后的结果数据。n表示 四舍五入 后保留 到小数点后n位 |\n| CONV(value,from,to)            | 将value的值进行不同进制之间的转换                            |\n| INET_ATON(ipvalue)             | 将以点分隔的IP地址转化为一个数字                             |\n| INET_NTOA(value)               | 将数字形式的IP地址转化为以点分隔的IP地址                     |\n| BENCHMARK(n,expr)              | 将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费 的时间 |\n| CONVERT(value USING char_code) | 将value所使用的字符编码修改为char_code                       |\n\n\n\n\n\n\n\n## 聚合函数（分组函数）\n\n\n\n您好于组长，不好意思打扰您了，我是2021年暑期在您这实习过的蒋潮棨，上次的实习让我在c#的Winform方面收获颇丰，感谢实习期间对我的一些帮助和指导。今年的可实习的时间为七月初左右到明年的五月底左右，希望有进一步的实习机会。\n\n现在正在寻找一份实习的工作，请问您这边还需要实习生吗？我在上次实习的基础上深入的学习了一些有关c#的一些知识和mysql数据库的一些基础，以及部分硬件相关的知识。如果有再次招聘实习生的计划，我希望能够再次加入团队。\n\n\n\n# 练习\n\n## select基础\n\n### 计算年基本工资\n\n`select salary * 12 as \"ANNUAL SALARY\" from employees;`\n\n### 查询employees表中去除重复的job_id以后的数据\n\n`select DISTINCT job_id  FROM employees;`\n\n### 查询工资大于12000的员工姓名和工资\n\n`select employee_id, first_name, last_name, salary FROM employees WHERE salary > 12000 ;`\n\n### 查询员工号为176的员工的姓名和工资\n\n`select employee_id, first_name, last_name, department_id from employees WHERE employee_id = 176;`\n\n### 显示表department的结构，并查询其中的全部数据\n\n`DESC departments;`\n\n`SELECT * FROM departments;`\n\n\n\n\n\n## 运算符相关\n\n### 选择工资不在5000到12000的员工的姓名和工资\n\n```mysql\nmysql> select last_name, salary from employees where salary < 5000 or salary > 12000;\n+-------------+----------+\n| last_name   | salary   |\n+-------------+----------+\n| King        | 24000.00 |\n| Kochhar     | 17000.00 |\n| De Haan     | 17000.00 |\n| Austin      |  4800.00 |\n| Pataballa   |  4800.00 |\n| Lorentz     |  4200.00 |\n| Khoo        |  3100.00 |\n| Baida       |  2900.00 |\n| Tobias      |  2800.00 |\n| Himuro      |  2600.00 |\n| Colmenares  |  2500.00 |\n| N_ayer      |  3200.00 |\n| Mikkilineni |  2700.00 |\n| Landry      |  2400.00 |\n| Markle      |  2200.00 |\n| Bissot      |  3300.00 |\n| Atkinson    |  2800.00 |\n| Marlow      |  2500.00 |\n| Olson       |  2100.00 |\n| Mallin      |  3300.00 |\n| Rogers      |  2900.00 |\n| Gee         |  2400.00 |\n| Philtanker  |  2200.00 |\n| Ladwig      |  3600.00 |\n| Stiles      |  3200.00 |\n| Seo         |  2700.00 |\n| Patel       |  2500.00 |\n| Rajs        |  3500.00 |\n| Davies      |  3100.00 |\n| Matos       |  2600.00 |\n| Vargas      |  2500.00 |\n| Russell     | 14000.00 |\n| Partners    | 13500.00 |\n| Taylor      |  3200.00 |\n| Fleaur      |  3100.00 |\n| Sullivan    |  2500.00 |\n| Geoni       |  2800.00 |\n| Sarchand    |  4200.00 |\n| Bull        |  4100.00 |\n| Dellinger   |  3400.00 |\n| Cabrio      |  3000.00 |\n| Chung       |  3800.00 |\n| Dilly       |  3600.00 |\n| Gates       |  2900.00 |\n| Perkins     |  2500.00 |\n| Bell        |  4000.00 |\n| Everett     |  3900.00 |\n| McCain      |  3200.00 |\n| Jones       |  2800.00 |\n| Walsh       |  3100.00 |\n| Feeney      |  3000.00 |\n| OConnell    |  2600.00 |\n| Grant       |  2600.00 |\n| Whalen      |  4400.00 |\n| Hartstein   | 13000.00 |\n+-------------+----------+\n55 rows in set (0.00 sec)\n```\n\n\n\n### 选择在20或50号部门工作的员工姓名和部门号\n\n```mysql\nmysql> select last_name, department_id from employees\n    -> where department_id <=> 20 or department_id <=> 50;\n+-------------+---------------+\n| last_name   | department_id |\n+-------------+---------------+\n| Weiss       |            50 |\n| Fripp       |            50 |\n| Kaufling    |            50 |\n| Vollman     |            50 |\n| Mourgos     |            50 |\n| N_ayer      |            50 |\n| Mikkilineni |            50 |\n| Landry      |            50 |\n| Markle      |            50 |\n| Bissot      |            50 |\n| Atkinson    |            50 |\n| Marlow      |            50 |\n| Olson       |            50 |\n| Mallin      |            50 |\n| Rogers      |            50 |\n| Gee         |            50 |\n| Philtanker  |            50 |\n| Ladwig      |            50 |\n| Stiles      |            50 |\n| Seo         |            50 |\n| Patel       |            50 |\n| Rajs        |            50 |\n| Davies      |            50 |\n| Matos       |            50 |\n| Vargas      |            50 |\n| Taylor      |            50 |\n| Fleaur      |            50 |\n| Sullivan    |            50 |\n| Geoni       |            50 |\n| Sarchand    |            50 |\n| Bull        |            50 |\n| Dellinger   |            50 |\n| Cabrio      |            50 |\n| Chung       |            50 |\n| Dilly       |            50 |\n| Gates       |            50 |\n| Perkins     |            50 |\n| Bell        |            50 |\n| Everett     |            50 |\n| McCain      |            50 |\n| Jones       |            50 |\n| Walsh       |            50 |\n| Feeney      |            50 |\n| OConnell    |            50 |\n| Grant       |            50 |\n| Hartstein   |            20 |\n| Fay         |            20 |\n+-------------+---------------+\n47 rows in set (0.00 sec)\n```\n\n\n\n### 选择公司中没有管理者的员工姓名及job_id\n\n```mysql\nmysql> select last_name, job_id from employees\n    -> where manager_id is null;\n+-----------+---------+\n| last_name | job_id  |\n+-----------+---------+\n| King      | AD_PRES |\n+-----------+---------+\n1 row in set (0.00 sec)\n```\n\n\n\n### 选择公司中有奖金的员工姓名，工资和奖金级别\n\n```mysql\nmysql> select last_name, salary, commission_pct from employees\n    -> where commission_pct is not null;\n+------------+----------+----------------+\n| last_name  | salary   | commission_pct |\n+------------+----------+----------------+\n| Russell    | 14000.00 |           0.40 |\n| Partners   | 13500.00 |           0.30 |\n| Errazuriz  | 12000.00 |           0.30 |\n| Cambrault  | 11000.00 |           0.30 |\n| Zlotkey    | 10500.00 |           0.20 |\n| Tucker     | 10000.00 |           0.30 |\n| Bernstein  |  9500.00 |           0.25 |\n| Hall       |  9000.00 |           0.25 |\n| Olsen      |  8000.00 |           0.20 |\n| Cambrault  |  7500.00 |           0.20 |\n| Tuvault    |  7000.00 |           0.15 |\n| King       | 10000.00 |           0.35 |\n| Sully      |  9500.00 |           0.35 |\n| McEwen     |  9000.00 |           0.35 |\n| Smith      |  8000.00 |           0.30 |\n| Doran      |  7500.00 |           0.30 |\n| Sewall     |  7000.00 |           0.25 |\n| Vishney    | 10500.00 |           0.25 |\n| Greene     |  9500.00 |           0.15 |\n| Marvins    |  7200.00 |           0.10 |\n| Lee        |  6800.00 |           0.10 |\n| Ande       |  6400.00 |           0.10 |\n| Banda      |  6200.00 |           0.10 |\n| Ozer       | 11500.00 |           0.25 |\n| Bloom      | 10000.00 |           0.20 |\n| Fox        |  9600.00 |           0.20 |\n| Smith      |  7400.00 |           0.15 |\n| Bates      |  7300.00 |           0.15 |\n| Kumar      |  6100.00 |           0.10 |\n| Abel       | 11000.00 |           0.30 |\n| Hutton     |  8800.00 |           0.25 |\n| Taylor     |  8600.00 |           0.20 |\n| Livingston |  8400.00 |           0.20 |\n| Grant      |  7000.00 |           0.15 |\n| Johnson    |  6200.00 |           0.10 |\n+------------+----------+----------------+\n35 rows in set (0.00 sec)\n```\n\n\n\n### 选择员工姓名的第三个字母是a的员工姓名\n\n```mysql\nmysql> select last_name from employees\n    -> where last_name like '__a%';\n+-----------+\n| last_name |\n+-----------+\n| N_ayer    |\n| Grant     |\n| Grant     |\n| Whalen    |\n+-----------+\n4 rows in set (0.00 sec)\n```\n\n\n\n### 选择姓名中有字母a和k的员工姓名\n\n```mysql\nmysql> select last_name from employees\n    -> where last_name like '%a%k%' or last_name like '%k%a%';\n+------------+\n| last_name  |\n+------------+\n| Kochhar    |\n| Kaufling   |\n| Markle     |\n| Atkinson   |\n| Philtanker |\n| Kumar      |\n+------------+\n6 rows in set (0.00 sec)\n```\n\n\n\n### 显示出表employees 表中first. name以'e' 结尾的员工信息\n\n```mysql\nmysql> select first_name from employees\n    -> where first_name like '%e';\n+------------+\n| first_name |\n+------------+\n| Bruce      |\n| Irene      |\n| Mozhe      |\n| Renske     |\n| Nanette    |\n| Janette    |\n| Louise     |\n| Danielle   |\n| Vance      |\n+------------+\n9 rows in set (0.00 sec)\n```\n\n\n\n### 显示出表employees部门编号在80-100 之间的姓名、工种\n\n\n\n```mysql\nmysql> select last_name, job_id from employees\n    -> where department_id >= 80 and department_id <= 100;\n+------------+------------+\n| last_name  | job_id     |\n+------------+------------+\n| King       | AD_PRES    |\n| Kochhar    | AD_VP      |\n| De Haan    | AD_VP      |\n| Greenberg  | FI_MGR     |\n| Faviet     | FI_ACCOUNT |\n| Chen       | FI_ACCOUNT |\n| Sciarra    | FI_ACCOUNT |\n| Urman      | FI_ACCOUNT |\n| Popp       | FI_ACCOUNT |\n| Russell    | SA_MAN     |\n| Partners   | SA_MAN     |\n| Errazuriz  | SA_MAN     |\n| Cambrault  | SA_MAN     |\n| Zlotkey    | SA_MAN     |\n| Tucker     | SA_REP     |\n| Bernstein  | SA_REP     |\n| Hall       | SA_REP     |\n| Olsen      | SA_REP     |\n| Cambrault  | SA_REP     |\n| Tuvault    | SA_REP     |\n| King       | SA_REP     |\n| Sully      | SA_REP     |\n| McEwen     | SA_REP     |\n| Smith      | SA_REP     |\n| Doran      | SA_REP     |\n| Sewall     | SA_REP     |\n| Vishney    | SA_REP     |\n| Greene     | SA_REP     |\n| Marvins    | SA_REP     |\n| Lee        | SA_REP     |\n| Ande       | SA_REP     |\n| Banda      | SA_REP     |\n| Ozer       | SA_REP     |\n| Bloom      | SA_REP     |\n| Fox        | SA_REP     |\n| Smith      | SA_REP     |\n| Bates      | SA_REP     |\n| Kumar      | SA_REP     |\n| Abel       | SA_REP     |\n| Hutton     | SA_REP     |\n| Taylor     | SA_REP     |\n| Livingston | SA_REP     |\n| Johnson    | SA_REP     |\n+------------+------------+\n43 rows in set (0.00 sec)\n```\n\n\n\n### 显示出表employees 的manager_id 是100,101,110 的员工姓名、工资、管理者id\n\n```mysql\nmysql> select last_name, salary, manager_id\n    -> from employees\n    -> where manager_id <=> '100' or manager_id <=> '101' or manager_id <=> '110';\n+-----------+----------+------------+\n| last_name | salary   | manager_id |\n+-----------+----------+------------+\n| Kochhar   | 17000.00 |        100 |\n| De Haan   | 17000.00 |        100 |\n| Greenberg | 12000.00 |        101 |\n| Raphaely  | 11000.00 |        100 |\n| Weiss     |  8000.00 |        100 |\n| Fripp     |  8200.00 |        100 |\n| Kaufling  |  7900.00 |        100 |\n| Vollman   |  6500.00 |        100 |\n| Mourgos   |  5800.00 |        100 |\n| Russell   | 14000.00 |        100 |\n| Partners  | 13500.00 |        100 |\n| Errazuriz | 12000.00 |        100 |\n| Cambrault | 11000.00 |        100 |\n| Zlotkey   | 10500.00 |        100 |\n| Whalen    |  4400.00 |        101 |\n| Hartstein | 13000.00 |        100 |\n| Mavris    |  6500.00 |        101 |\n| Baer      | 10000.00 |        101 |\n| Higgins   | 12000.00 |        101 |\n+-----------+----------+------------+\n19 rows in set (0.00 sec)\n```\n\n\n\n\n\n\n\n\n\n## 排序与分页\n\n### 查询员工的姓名和部门号和年薪，按年薪降序，按姓名升序显示\n\n```mysql\nmysql> select last_name, department_id, salary * 12 as annual_sal\n    -> from employees\n    -> order by annual_sal desc, last_name asc;\n```\n\n\n\n### 选择工资不在8000到17000 的员工的姓名和工资，按工资降序，显示第21到40位置的数据\n\n```mysql\nmysql> select last_name, salary from employees\n    -> where salary < 8000 or salary > 17000\n    -> order by salary desc\n    -> limit 20, 20;\n+-----------+---------+\n| last_name | salary  |\n+-----------+---------+\n| Ernst     | 6000.00 |\n| Fay       | 6000.00 |\n| Mourgos   | 5800.00 |\n| Pataballa | 4800.00 |\n| Austin    | 4800.00 |\n| Whalen    | 4400.00 |\n| Sarchand  | 4200.00 |\n| Lorentz   | 4200.00 |\n| Bull      | 4100.00 |\n| Bell      | 4000.00 |\n| Everett   | 3900.00 |\n| Chung     | 3800.00 |\n| Ladwig    | 3600.00 |\n| Dilly     | 3600.00 |\n| Rajs      | 3500.00 |\n| Dellinger | 3400.00 |\n| Mallin    | 3300.00 |\n| Bissot    | 3300.00 |\n| McCain    | 3200.00 |\n| Stiles    | 3200.00 |\n+-----------+---------+\n20 rows in set (0.00 sec)\n```\n\n\n\n### 查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序\n\n```mysql\nmysql> select * from employees\n    -> where email like '%e%'\n    -> order by length(email) desc, department_id asc;\n```\n\n\n\n\n\n\n\n\n\n## 多表连接\n\n### 多表连接：查询所有员工的姓名、部门号和部门名称\n\n```mysql\nSELECT e.last_name, e.department_id, d.department_name\nFROM employees e LEFT JOIN departments d\nON e.department_id = d.department_id;\n```\n\n### 带过滤条件的多表连接：查询90号部门员工的job_id和location_id\n\n```mysql\nselect e.job_id, d.location_id\nfrom employees e JOIN departments d\non e.department_id <=> d.department_id\nwhere e.department_id <=> 90;\n```\n\n### 带过滤条件的多个表的存在外连接的多表连接：选择**所有**有奖金的员工的last_name, department_name, locational_id, city。\n\n```mysql\nSELECT e.last_name, e.commission_pct, d.department_name, l.location_id, l.city\nfrom employees e LEFT JOIN departments d\nON e.department_id = d.department_id\nLEFT Join locations l\nON d.location_id = l.location_id\nwhere e.commission_pct is not null;\n```\n\n![image-20230610215112717](./Image/MySql基础笔记.assets/image-20230610215112717.png)\n\n### 带过滤条件的多个表的存在外连接的多表连接：选择city在Toronto工作的员工的last_name, job_id, department_id, department_name。\n\n```mysql\nSELECT e.last_name, e.job_id, e.department_id, d.department_name\nFROM employees e LEFT JOIN departments d\nON e.department_id = d.department_id\nLEFT JOIN locations l \non d.location_id = l.location_id\nwhere l.city = 'Toronto';\n```\n\n### 查询员工所在的部门名称、部门 ]地址、姓名、工作、工资，其中员工所在部门的部门名称为'Executive'\n\n由于可能在多个城市均存在同一个部门，且部门不一定有人，因此需要考虑外连接的情况。\n\n```mysql\nSELECT d.department_name, l.street_address, e.last_name, e.job_id, e.salary\nFROM departments d LEFT JOIN employees e \nON e.department_id = d.department_id\nLEFT JOIN locations l \nON d.location_id = l.location_id\nWHERE d.department_name = 'Executive';\n```\n\n\n\n### 含有外连接与自连接交叉：选择指定员工的姓名，员工号，以及他的管理者的姓名和员工号，结果类似于下面的格式：\n\nemployees\tEmp#\tmanager\tMgr#\nkochhar\t\t101\t\tking\t\t\t100\n\n```mysql\nSELECT e.last_name AS employees , e.employee_id AS 'Emp#', m.last_name AS manager, m.employee_id AS 'Mgr#'\nFROM employees e LEFT JOIN employees m\nON e.manager_id = m.employee_id;\n```\n\n### 查询哪些部门没 有员工\n\n```mysql\nSELECT  d.department_id, d.department_name\nFROM employees e RIGHT JOIN departments d\nON e.department_id = d.department_id\nWHERE e.employee_id <=> NULL;\n```\n\n\n\n### 查询哪个城市没有部门\n\n```mysql\nSELECT l.city \nFROM departments d RIGHT JOIN locations l\nON d.location_id = l.location_id\nWHERE d.department_id IS NULL;\n```\n\n\n\n\n\n### 查询部门名为Sales或IT的员工信息\n\n```mysql\nSELECT e.employee_id, e.last_name, d.department_name\nFROM employees e JOIN departments d\nON e.department_id = d.department_id\nWHERE d.department_name = 'Sales' OR d.department_name = 'IT';\n```\n\n\n\n\n\n### 自连接\n\n#### 查询员工id，员工姓名（last_name）以及其管理者的id和姓名。\n\n```mysql\nselect emp.employee_id As '雇员id', emp.last_name AS '雇员名字', emp.manager_id, manager.employee_id AS '雇员领导的id', manager.last_name AS '雇员领导的姓名'\nfrom employees emp, employees manager\nwhere emp.manager_id = manager.employee_id;\n```\n\n![[image-20230607142517156]](./Image/MySql基础笔记.assets/image-20230607142517156.png)\n\n\n\n#### 使用Join语法的内连接：\n\n查询员工的id、名字、部门名字、以及部门所在地址。\n\n```mysql\nSELECT e.employee_id, e.last_name, d.department_name, l.street_address\nFROM employees e join departments d\non e.department_id = d.department_id\njoin locations l\non d.location_id = l.location_id;\n```\n\n\n\n\n\n\n\n#### 使用Join实现左外连接\n\n查询**所有**员工的id、 名字、部门名字、以及部门所在地址。。对于不存在部门的员工信息一样要查出来\n\n```mysql\nselect e.employee_id, e.last_name, d.department_name\nfrom employees e left join departments d\non e.department_id = d.department_id;\n```\n\n![image-20230610154843171](./Image/MySql基础笔记.assets/image-20230610154843171.png)\n\n\n\n\n\n#### 使用Join实现左外连接\n\n查询所有部门都有那些职员，如果该部门没有人，也照样查询出来。\n\n```mysql\nselect e.employee_id, e.last_name, d.department_name\nfrom employees e right join departments d\non e.department_id = d.department_id;\n```\n\n![image-20230610160018062](./Image/MySql基础笔记.assets/image-20230610160018062.png)\n\n\n\n\n\n#### 使用MySQL实现满外连接的查询\n\nMySql不能直接执行满外连接的方法，只能通过UNOIN关键字间接的执行。\n\n##### 使用UNION关键字\n\n```mysql\nSELECT e.employee_id, d.department_name\nFROM employees e left JOIN departments d\nON e.department_id = d.department_id\nunion\nSELECT e.employee_id, d.department_name\nFROM employees e right JOIN departments d\nON e.department_id = d.department_id;\n```\n\n\n\n\n\n\n\n# 附录：常用的 SQL 标准有哪些\n\n在正式开始讲连接表的种类时，我们首先需要知道 SQL 存在不同版本的标准规范，因为不同规范下的表 连接操作是有区别的。 \n\nSQL 有两个主要的标准，分别是 `SQL92` 和 `SQL99` 。92 和 99 代表了标准提出的时间，SQL92 就是 92 年 提出的标准规范。当然除了 SQL92 和 SQL99 以外，还存在 SQL-86、SQL-89、SQL:2003、SQL:2008、 SQL:2011 和 SQL:2016 等其他的标准。 \n\n这么多标准，到底该学习哪个呢？**实际上最重要的 SQL 标准就是 SQL92 和 SQL99**。一般来说 SQL92 的 形式更简单，但是写的 SQL 语句会比较长，可读性较差。而 SQL99 相比于 SQL92 来说，语法更加复杂， 但可读性更强。我们从这两个标准发布的页数也能看出，SQL92 的标准有 500 页，而 SQL99 标准超过了 1000 页。实际上从 SQL99 之后，很少有人能掌握所有内容，因为确实太多了。就好比我们使用 Windows、Linux 和 Office 的时候，很少有人能掌握全部内容一样。我们只需要掌握一些核心的功能，满 足日常工作的需求即可。 \n\n**SQL92 和 SQL99 是经典的 SQL 标准，也分别叫做 SQL-2 和 SQL-3 标准**。也正是在这两个标准发布之 后，SQL 影响力越来越大，甚至超越了数据库领域。现如今 SQL 已经不仅仅是数据库领域的主流语言， 还是信息领域中信息处理的主流语言。在图形检索、图像检索以及语音检索中都能看到 SQL 语言的使用","tags":["protected","MySQL"],"categories":["MySQL"]},{"title":"Openwrt获取到了ipv6地址，但无法使用","url":"/2023/02/28/Openwrt获取到了ipv6地址，但无法使用/","content":"\n## Openwrt获取到了ipv6地址，但无法使用\n\n获取到了ipv6地址，但经测试无法使用ipv6的地址，而且ping具有v4/v6双栈响应的网站，显示的目标ip是ipv4。\n\n### 解决办法\n\n开启ipv6 转发和修改防火墙策略\n\n```\n# 修改/etc/sysctl.conf，将以下内容加进去,大意说接收广播并开启IPv6转发\nnet.ipv6.conf.default.forwarding=2\nnet.ipv6.conf.all.forwarding=2\nnet.ipv6.conf.default.accept_ra=2\nnet.ipv6.conf.all.accept_ra=2\nnet.ipv6.conf.default.accept_dad=2\nnet.ipv6.conf.all.accept_dad=2\nnet.ipv6.conf.default.dad_transmits=2\nnet.ipv6.conf.all.dad_transmits=2\n\n# 因为OpenWRT默认的防火墙配置不会管IPv6的nat表需要在/etc/firewall.user添加防火墙规则：\n# set up firewall\nip6tables -P INPUT ACCEPT\nip6tables -P OUTPUT ACCEPT\n\nip6tables -A OUTPUT -p tcp -j ACCEPT\nip6tables -A OUTPUT -p udp -j ACCEPT\n# input rules\nip6tables -A INPUT -p ipv6-crypt -j ACCEPT\nip6tables -A INPUT -p ipv6-auth -j ACCEPT\nip6tables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\nip6tables -A INPUT -m state --state NEW -j ACCEPT\nip6tables -A INPUT -m state --state INVALID -j DROP\n# allow DHCPv6\nip6tables -A INPUT -p udp --sport 547 --dport 546 -j ACCEPT\nip6tables -A INPUT -p udp --sport 500 --dport 500 -j ACCEPT\nip6tables -A INPUT -p udp --sport 4500 --dport 4500 -j ACCEPT\n# allow ipv6-icmp related packet\nip6tables -A INPUT -p ipv6-icmp --icmpv6-type router-solicitation -j ACCEPT \nip6tables -A INPUT -p ipv6-icmp --icmpv6-type packet-too-big -j ACCEPT \nip6tables -A INPUT -p ipv6-icmp --icmpv6-type time-exceeded -j ACCEPT \nip6tables -A INPUT -p ipv6-icmp --icmpv6-type parameter-problem -j ACCEPT \nip6tables -A INPUT -p ipv6-icmp --icmpv6-type echo-request -j ACCEPT \nip6tables -A INPUT -p ipv6-icmp --icmpv6-type echo-reply -j ACCEPT \nip6tables -A INPUT -p ipv6-icmp --icmpv6-type 130 -j ACCEPT \nip6tables -A INPUT -p ipv6-icmp --icmpv6-type 131 -j ACCEPT \nip6tables -A INPUT -p ipv6-icmp --icmpv6-type 132 -j ACCEPT \nip6tables -A INPUT -p ipv6-icmp --icmpv6-type router-solicitation -j ACCEPT \nip6tables -A INPUT -p ipv6-icmp --icmpv6-type router-advertisement -j ACCEPT \nip6tables -A INPUT -p ipv6-icmp --icmpv6-type neighbour-solicitation -j ACCEPT \nip6tables -A INPUT -p ipv6-icmp --icmpv6-type neighbour-advertisement -j ACCEPT \nip6tables -A INPUT -p ipv6-icmp --icmpv6-type 141 -j ACCEPT\nip6tables -A INPUT -p ipv6-icmp --icmpv6-type 142 -j ACCEPT\nip6tables -A INPUT -p ipv6-icmp --icmpv6-type 143 -j ACCEPT\nip6tables -A INPUT -p ipv6-icmp --icmpv6-type 148 -j ACCEPT\nip6tables -A INPUT -p ipv6-icmp --icmpv6-type 149 -j ACCEPT\nip6tables -A INPUT -p ipv6-icmp --icmpv6-type 151 -j ACCEPT\nip6tables -A INPUT -p ipv6-icmp --icmpv6-type 152 -j ACCEPT\nip6tables -A INPUT -p ipv6-icmp --icmpv6-type 153 -j ACCEPT\nip6tables -A INPUT -j DROP\n```\n\n### 来源\n\nhttps://blog.csdn.net/a735131232/article/details/117004464\n\n测试网址：\n\nhttps://www.test-ipv6.com/\n\n[IPv6地址查询工具 (zxinc.org)](http://ip.zxinc.org/ipquery/)\n","tags":["protected","OpenWRT"],"categories":["OpenWRT"]},{"title":"Windwos环境下F键的功能介绍","url":"/2023/02/28/Windwos环境下F键的功能介绍/","content":"## F键的功能\n\n- f1可以帮你在困境中寻找帮助\n  - 可以唤出帮助页\n- f2可以在你懒得动右手中指时助你快速重命名\n  - windows中可以快速的进行重命名操作\n- f3可以在你懒得动右手食指时助你搜遍文件夹\n  - windows中可以打开搜索框进行搜索\n- f4和alt放在一起可以让电脑自动做你要做的工作\n  - 这个组合键可以强制关闭选定的窗口/程序\n- f5可以陪伴你度过无聊的等待时光\n  - 可以对当前的页面进行刷新\n- f6可以在你懒得翻历史记录时助你搜到爱看的\n- f7可以在浏览器中切换使用文本光标浏览网页\n- f8可以在电脑启动时进入启动高级菜单选项（看电脑）\n- f9可以在windows media player降低音量 excel里计算\n- f10＋shift=鼠标右键\n  - Windows中可以用这个快捷键实现当前选项/界面的右键操作\n- f11可以让你看片看的更爽\n  - 浏览器中可以使用这个键进入全屏模式\n- f12可以进入开发者工具\n  - 浏览器中快速打开开发者工具。","tags":["protected","Windows"],"categories":["Windows"]},{"title":"C Sharp学习笔记/基础教程","url":"/2023/01/25/CSharp学习笔记_基础教程/","content":"\n# C#简介\n\n## CIL和JIT\n\n在编译使用.NET Framework或.NET Core库的代码时，不是立即创建专用于操作系统的本机代码，而是把代码编译为通用中间语言(Common Intermediate Language, CIL)代码,这些代码并非专门用于任何一种操作系统，也非专门用于C#。其他NET语言(如Visual Basic .NET或F#)也会在第一阶段编译为这种语言。开发C#应用程序时，这个编译步骤由Visual Studio完成。Microsoft Intermediate Language(MSIL)这一术语，它是CIL原来的名称，许多开发人员仍沿用这个术语。\n\n要执行应用程序，必须完成更多工作，这是Just-In-Time（JIT）编译器的任务，它把CIL编译为专用于OS和目标机器架构的本机代码。这样OS才能执行应用程序。这里编译器的名称Just-In-Time反映了CIL代码仅在需要时才编译的事实。这种编译可以在应用程序的运行过程中动态发生，不过开发人员一般不需要关心这个过程。除非要编写性能十分关键的高级代码，否则知道这个编译过程会在后台自动进行，并不需要人工干预就可以了。\n过去，经常需要把代码编译为几个应用程序，每个应用程序都用于特定的操作系统和CPU架构。这通常是一种优化形式(例如，为了让代码在AMD芯片组上运行得更快)，但有时则是非常重要的(例如，使应用程序可以同时工作在Win9x和WinNT/2000环境F)。现在就没必要了，因为JIT编译器使用CIL代码，而CIL代码是独立于计算机、操作系统和CPU的。目前有几种JIT编译器，每种编译器都用于不同的架构，CLR/CoreCLR会使用合适的编译器创建所需的本机代码。\n\n## 垃圾回收机制\n\n.NET垃圾回收会定期检查计算机的内存，从中删除不再需要的内容。执行垃圾回收的时间并不固定，可能\n一秒钟内会进行数千次的检查，也可能每几秒钟才检查- -次，不过一定会进行检查。\n这里要给程序员一些提示。因为是在不可预知的时间执行这项工作，所以在设计应用程序时，必须留意这\n一点。需要许多内存才能运行的代码应自行完成清理工作，而不是坐等垃圾回收，但这不像听起来那样难。\n\n\n\n\n\n\n\n# 类和名称空间\n\n- 类（class）构成程序主体\n\n  > ​\t类 (class) 是最基础的 C# 类型。类是一个数据结构，将`状态`（字段）和`操作`（方法和其他函数成员）组合在一个单元中。类为动态创建的类实例 (instance) 提供了定义，实例也称为对象 (object)。类支持继承 (inheritance) 和多态性 (polymorphism)，这是派生类 (derived class) 可用来扩展和专用化基类 (base class) 的机制。\n  >\n  > ​\t使用类声明可以创建新的类。类声明以一个声明头开始，其组成方式如下：先指定类的特性和修饰符，然后是类的名称，接着是基类（如有）以及该类实现的接口。声明头后面跟着类 { 和 } 之间的成员声明组成。\n\n- 名称空间（namespace）以树型结构组织类和其他类型\n\n  > 命名空间将类用良好的结构组合在一起，有效的避免了重名类带来的冲突。\n\n\n\neg：\n\n```c#\nusing System;\nnamespace ConsoleApp1\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello, World!\");            \n        }\n    }\n}\n```\n\n由于c#是完全面向对象的，因此入口点Main方法也需要在类内。\n\n其中的`Console`这个类，是系统定义的，这个使用了这个类中的`WriteLine`的方法，用于将指定的字符串输出到控制台。\n\n而编写的这个Program类，放在了ConsoleApp1这个命名空间中。\n\nusing System的作用就是，告诉编译器，如果我没有指定这个类的来源于哪个命名空间，就在引用的名称空间内部检索一边。\n\n如果想要手动指定属于某个名称空间的类的话，可以这样：System.Console.WriteLine(\"hello\");\n\n\n\n\n\n## 类库的引用\n\n- 类库引用是使用名称空间的物理基础 \n\n### dll引用（黑盒引用）\n\n只能使用，但无法修改。同时增加了依赖关系，如果引用的dll有错误或者不存在，则程序可能无法使用。  \n\n### 项目引用（白盒引用）\n\n\n\n\n\n## 类\n\n类（class）是现实世界事务的模型，将事务进行抽象后得到的结果，事务包括实体和逻辑等。\n\n### 类与对象的关系\n\n对象也称为实例，是类实例化后得到的内存中的实体\n\n实例化后的类就是对象，但不是所有的类都可以被实例化。\n\n使用new操作符创建类的实例\n\n### 类的三大成员\n\n#### 属性（Property）\n\n存储数据，组合起来表示类或对象的当前状态\n\n#### 方法（Method）\n\n由函数进化而来，表示类或对象能够做什么\n\n#### 事件（Event）\n\n类或对象通知其他类或对象的机制，为c#特有\n\n\n\n\n\n### 静态成员与实例成员\n\n- 静态（static）成员在语义上表示他是“类的成员”\n- 实例（非静态）成员在语义上表示他是“对象的成员”\n- 绑定（binding）指的是编译器如何把一个成员与类或对象关联起来\n- `.`操作符：用于成员的访问，全称为成员访问操作符。\n\n\n\n\n\n\n\n\n\n\n\n\n\n# C#的基本元素\n\n- 关键字（keyword）\n- 操作符（operator）\n- 标识符（identifier）\n  - 合法的标识符：用于给类、对象等命名\n    - 不能是关键字\n    - 可以由字母数字下划线组成，但不能以数字开头\n    - 如 果需要使用关键字作为标识符，需要在前面加上`@`（Unicode转义序列）\n    - 可以包含汉语，但不建议使用\n  - 大小写规范\n    - 大驼峰：命名空间、类型、接口、方法、属性、事件、非私有字段、枚举值\n    - 小驼峰：私有字段、参数、局部变量\n  - 命名规范\n    - 类、类的属性的名字是一个名词或者名词的复数形式‘\n    - 对类的方法命名的时候，需要是一个动词，或者动词短语\n- 标点符号\n  - 不同于加减乘除，不用来表示运算思想\n    - `;` \t表示语句结束\n    - `{}`  表示程序段\n    - 以及其他的一下\n- 文本（值）\n  - 整数\n    - int\n    - long：结尾需要加L\n  - 实数\n    - float：结尾需要加F\n    - double\n  - 字符\n    - char：单引号引起来的一个字符\n  - 字符串\n    - string：双引号引起来的零个或多个字符串\n  - 布尔\n    - bool：只能为true或false\n  - 空\n    - `null`，如str = null；\n- 注释与空白\n  - 单行注释：`//`开头的一行\n  - 多行注释（块注释）：`/*  */`内的字符，不可以嵌套使用\n  - 空白：空格、换行、注释等。\n\n除了注释与空白，其余的都是对编译器有意义的记号。也成为标记\n\n\n\n## 类型、变量与方法的概述\n\n- 类型（type），又称为数据类型（Data Type)\n- 变量是存储数据的地方\n  - 变量需要先声明后使用\n  - 声明方法：\n    - 类型名 + 变量名\n\n- 方法（旧称函数）是处理数据的逻辑，又称为算法\n  - 方法的声明\n    - 方法名需要是合法的标识符\n  - 方法的使用\n    - 类（对象）.方法名\n- 程序 = 变量 + 方法。\n\n\n\n\n\n## c#中的数据类型\n\n### 数据类型的概述\t\n\n#### 什么是类型（Type）\n\n- 是性质相同的值的集合\n- 数据类型配备了一系列针对这种类型的值的操作\n- 数据类型是数据在内存中存储时的“型号”\n\n\n\n#### 类型在C#中的作用\n\n一个C#类型中所包含的信息有：\n\n- 存储此类型变量所需的空间大小\n- 此类型的值可表示的最大、最小值范围\n- 此类型所包含的成员（如方法、属性、事件等）\n- 此类型有何基类派生而来\n- 程序运行的时候，此类型的变量分配在内存的什么位置\n  - c++没有内存回收机制，因此没有手动回收的话可能会造成内存泄漏；c#存在垃圾收集器的机制，当一个对象没有再被使用的时候，会自动进行回收，没有手动释放的一说。换句话说就是c#相对比较安全。\n  - 实例永远是分配在堆内\n- 此类型允许的操作（运算）\n\n\n\n\n\n#### C#语言的类型系统\n\n##### c#的五大数据类型\n\n- 类（Classes）：如Windows，Form，Console，Srting\n- 结构体（Structres）：如Int32，Int64，Single，Double\n- 枚举（Enumerations）如HorizontalAlignment，Visibility\n- 接口（Interfaces）\n- 委托（Delegates）\n\n\n\n\n\n##### c#的派生谱系\n\n![image-20230128132020066](./Image/C#学习笔记_基础教程.assets/image-20230128132020066.png)\n\n关键字解析：\n\n- 第一组\n  - object、string：真正的数据类型\n  - class、interface、delegate：不是具体的数据类型，而是用这三个关键字定义自己的数据类型\n- 第二组\n  - bool、byte、...、ushort：都是值类型\n  - struct、enum：定义自己的类型的关键字\n- 第三组\n  - true、false：布尔类型的值\n  - void、null：表示“空”\n  - var、dynamic：声明变量\n\n\n\n其中蓝色的都是基本数据类型（或称为`内建数据类型`），没有其他类型可以来构成他们\n\n\n\n\n\n## 变量、对象与内存\n\n### 变量概述\n\n- 表面上看，变量的用途是存储数据\n- 实际上，变量表示了存储位置，并且每一个变量都有一个类型，以决定什么样的值能够存入变量。变量名表示（对应着）变量的值在内存中的存储位置，变量类型表示从这个位置开始，往后多少个字节，用来保存这个变量的值。\n- 变量一共有七种\n  - 静态变量（静态字段）\n  - 实例变量（成员变量，字段）\n  - 数组元素\n  - 值参数\n  - 引用参数（ref修饰）\n  - 输出形参（out修饰）\n  - 局部变量\n- 狭义的变量是指局部变量，因为其他种类的变量都有自己的约定名称\n  - 局部变量就是方法体（函数体）内声明的变量\n- 变量的声明\n  - [有效的修饰符组合] 类型 变量名 [初始化器]\n  - 如：unsigned int a = 10;\n- 局部变量实在stack上分配内存的\n\n\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Student student= new Student();\n            int[] array = new int[5];//数组\n        }\n    \n    }\n    \n\n   \n    class Student\n    {\n        public static int Amount;//静态成员变量\n        public int Age;\n        public int Name;//Age Name都是成员变量（字段）\n        public double Add(ref double a, double b)//a：引用参数变量；b:值参数变量\n        {\n            return a + b;\n        }\n    }\n}\n\n```\n\n\n\n\n### 值类型的变量（简单数据类型）\n\n值类型没有实例，所谓的“实例”与变量名合二为一。\n\n| 类型    | 描述                                                         | 范围                                                    | 默认值 |\n| :------ | :----------------------------------------------------------- | :------------------------------------------------------ | :----- |\n| bool    | 布尔值                                                       | True 或 False                                           | False  |\n| byte    | 8 位无符号整数                                               | 0 到 255                                                | 0      |\n| char    | 16 位 Unicode 字符                                           | U +0000 到 U +ffff                                      | '\\0'   |\n| decimal | 128 位精确的十进制值，28-29 有效位数，也属于浮点数，只是底数是10. | (-7.9 x 10^28^ 到 7.9 x 10^28^) / 100 到 28             | 0.0M   |\n| double  | 64 位双精度浮点型，常规的浮点数，底数是2                     | (+/-)5.0 x 10^-324^ 到 (+/-)1.7 x 10^308^               | 0.0D   |\n| float   | 32 位单精度浮点型                                            | -3.4 x 10^38^ 到 + 3.4 x 10^38^                         | 0.0F   |\n| int     | 32 位有符号整数类型                                          | -2,147,483,648 到 2,147,483,647                         | 0      |\n| long    | 64 位有符号整数类型                                          | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | 0L     |\n| sbyte   | 8 位有符号整数类型                                           | -128 到 127                                             | 0      |\n| short   | 16 位有符号整数类型                                          | -32,768 到 32,767                                       | 0      |\n| uint    | 32 位无符号整数类型                                          | 0 到 4,294,967,295                                      | 0      |\n| ulong   | 64 位无符号整数类型                                          | 0 到 18,446,744,073,709,551,615                         | 0      |\n| ushort  | 16 位无符号整数类型                                          | 0 到 65,535                                             | 0      |\n\n\n\n\n\n\n\n###  引用类型（Reference types）的变量与实例\n\n​\t引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。换句话说，它们指的是一个内存位置。使用多个变量时，引用类型可以指向一个内存位置。如果内存位置的数据是由一个变量改变的，其他变量会自动反映这种值的变化。**内置的** 引用类型有：**object**、**dynamic** 和 **string**。\n\n​\t引用类型变量与实例的关系：引用类型变量里存储的数据是对象的内存地址。\n\n​\t也就是说，在创建引用类型的变量的时候，会在内存中开辟一段4个字节的内存空间，并全部置0，当这个变量指向一个实例的时候，会在堆内开辟空间，将这个空间的首地址存储到这个变量里面来。\n\n\n\n\n\n\n\n### 变量的作用域\n\n- 成员变量：在类中定义的变量，在整个类中都有效，类中定义的方法都可以使用该变量。成员变量又可以分为实例成员变量和静态成员变量。\n\n  - 静态成员变量：使用static修饰的成员变量，`static`用于把属性和方法绑定到类本身，而不是使用类创建的对象。使用静态成员变量时直接使用类名称进行调用，无论用户使用该类创建了多少个对象，静态成员变量始终只有一个，始终绑定到类本身，每个创建的对象中并不存在该静态成员变量。\n  - 实例成员变量：实例成员变量是绑定使用类创建的对象上的，要想使用实例成员变量，必须先使用类创建一个对象。使用实例成员变量时是使用对象名进行调用，使用同一类创建的多个对象中各自有自己的实例成员变量，互相隔离，互不干扰。\n\n- 局部变量：在方法体中定义的变量，其使用范围只局限在定义它的方法之中或者方法之中的循环体之内，作用域不超过一个大括号\n\n- 全局变量：在类中定义的变量用`static`修饰的变量为全局变量，在整个`namespace`中的所有类中都可以使用\n\n  \n\n需要注意的是：定义变量时不能在同一作用域内定义相同名称的变量\n\n\n\n\n\n\n\n### 装箱和拆箱\n\n​\t**对象（Object）类型** 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换.\n\n​\t当一个值类型转换为对象类型时，则被称为 **装箱**；另一方面，当一个对象类型转换为值类型时，则被称为 **拆箱**。\n\n​\t装箱：当obj类型的变量要引用的值不是堆上的实例，而是栈上的一个值类型的时候，会先在堆上找一块可以存储下的空间，然后将值类型的值copy到堆上开辟的空间，最后将obj变量指向新开辟的空间上。\n\n​\t拆箱：一个值类型的变量想要拿到obj在堆上面存储的值。将堆上的值按照要求复制到变量内。注意，编译器并不检测箱子内的数据的类型，比如将short类型装箱，然后以char形式拆箱，编译器不会报错，但运行的时候会出现`System.InvalidCastException:“指定的转换无效。”`的异常。\n\n还有就是，装箱和拆箱会损失系统性能。\n\n```c#\nint x = 100;\nobject obj;//需要注意，object类型是引用类型\nobj = x;//装箱\nint y = (int)obj;//拆箱\nConsole.WriteLine(y);\n```\n\n\n\n#### 扩展\n\n任意类型类型到Object都是装箱，从Object到原有类型都是拆箱。\n\n虽然会损失系统性能，但对于多态来说是非常常用的。\n\n发生装箱和拆箱的前提是两种类型之间存在了继承关系。如果没有继承关系，比如string和int，则相互转换属于类型转换而非装箱拆箱。\n\n\n\n\n\n\n\n\n\n## 复杂数据类型\n\n除了这些简单的变量类型外，C#还提供了3个较复杂(但非常有用)的变量:枚举、结构和数组。\n\n### 枚举（Enum）\n\n- 枚举类型 是由`基础整型数值类型`的一组命名常量定义的`值类型`。枚举类型是使用 `enum` 关键字声明的。\n- C# 枚举是`值类型`。换句话说，枚举包含自己的值，且不能继承或传递继承。\n- 不是仅声明一个给定类型的变量，而是声明和描述一个用户定义的类型，再声明这个新类型的变量。\n- **枚举的基本类型可以是byte,sbyte,short,ushort,int,uint,long,ulong。默认情况下为int。**不可以为浮点数或string，甚至是class。\n- 可以在声明的时候使用其他类型来节省空间。\n\n\n\n#### 声明 enum 变量\n\n声明枚举的一般语法：\n\n```c#\nenum <enum_name>\n{ \n    enumeration list \n};\n```\n\n其中，\n\n- *enum_name* 指定枚举的类型名称。\n- *enumeration list* 是一个用逗号分隔的标识符列表。\n\n**枚举列表中的每个符号代表一个整数值，一个比它前面的符号大的整数值。默认情况下，第一个枚举符号的值是 0**。\n\n例如：\n\n```c#\nenum Days { Sun, Mon, tue, Wed, thu, Fri, Sat };\n```\n\n\n\n​\t默认情况下，枚举成员的关联常数值为类型 `int`；它们从零开始，并按定义文本顺序递增 1。 可以显式指定任何其他整数数值类型作为枚举类型的基础类型。 还可以显式指定关联的常数值，如下面的示例所示：\n\n```c#\nenum ErrorCode : ushort\n{\n    None = 0,\n    Unknown = 1,\n    ConnectionLost = 100,\n    OutlierReading = 200,\n    NotFound = 404,\n    BadGateway = 502\n}\n```\n\n\n\n#### 样例\n\n下面的实例演示了枚举变量的用法：\n\n```c#\nusing System;\n\npublic class EnumTest\n{\n    enum Day { Sun, Mon, Tue, Wed, Thu, Fri, Sat };\n\n    static void Main()\n    {\n        int x = (int)Day.Sun;\n        int y = (int)Day.Fri;\n        Console.WriteLine(\"Sun = {0}\", x);\n        Console.WriteLine(\"Fri = {0}\", y);\n    }\n}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```c#\nSun = 0\nFri = 5\n```\n\n​\t\n\n#### 注意事项\n\n- 不能在枚举类型的定义内定义方法。 若要向枚举类型添加功能，请创建扩展方法。\n- 枚举类型 `E` 的默认值是由表达式 `(E)0` 生成的值，即使零没有相应的枚举成员也是如此。\n- 可以使用枚举类型，通过一组互斥值或选项组合来表示选项。 若要表示选项组合，请将枚举类型定义为位标志。\n\n\n\n#### 作为位标志的枚举类型\n\n​\t如果希望枚举类型表示选项组合，请为这些选项定义枚举成员，以便单个选项成为位字段。 也就是说，这些枚举成员的关联值应该是 2 的幂。 然后，可以使用按位逻辑运算符`|`或 `&` 分别合并选项或交叉组合选项。 若要指示枚举类型声明位字段，请对其应用 [Flags](https://learn.microsoft.com/zh-cn/dotnet/api/system.flagsattribute) 属性。 如下面的示例所示，还可以在枚举类型的定义中包含一些典型组合。\n\n```c#\nusing System;\nusing System.Windows.Diagnostics;\nusing System.Windows.Forms;\nnamespace ConsoleApp\n{\n\n    public enum Days\n    {\n        None = 0b_0000_0000,  // 0\n        Monday = 0b_0000_0001,  // 1\n        Tuesday = 0b_0000_0010,  // 2\n        Wednesday = 0b_0000_0100,  // 4\n        Thursday = 0b_0000_1000,  // 8\n        Friday = 0b_0001_0000,  // 16\n        Saturday = 0b_0010_0000,  // 32\n        Sunday = 0b_0100_0000,  // 64\n        Weekend = Saturday | Sunday\n    }\n\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Days meetingDays = Days.Monday | Days.Wednesday | Days.Friday; // 0001 0101 -> 21\n            Console.WriteLine(meetingDays);\n            // Output:\n            // Monday, Wednesday, Friday\n            //实际输出：21\n\n            Days workingFromHomeDays = Days.Thursday | Days.Friday;\n            Console.WriteLine($\"Join a meeting by phone on {meetingDays & workingFromHomeDays}\");\n            // Output:\n            // Join a meeting by phone on Friday\n\n            bool isMeetingOnTuesday = (meetingDays & Days.Tuesday) == Days.Tuesday;\n            Console.WriteLine($\"Is there a meeting on Tuesday: {isMeetingOnTuesday}\");\n            // Output:\n            // Is there a meeting on Tuesday: False\n\n            var a = (Days)37;\n            Console.WriteLine(a);\n            // Output:\n            // Monday, Wednesday, Saturday\n            //实际输出：37\n\n\n            Console.ReadKey();\n        }\n    }\n}\n```\n\n#### System.Enum 类型和枚举约束\n\n​\t`System.Enum` 类型是**所有枚举类型的抽象基类**。 它提供多种方法来获取有关枚举类型及其值的信息。 有关更多信息和示例，请参阅 System.Enum API 参考页。\n\n​\t可在基类约束中使用 `System.Enum`（称为枚举约束），以指定类型参数为枚举类型。 所有枚举类型也都满足 struct 约束，此约束用于指定类型参数为不可为 null 的值类型。\n\n\n\n#### 转换\n\n对于任何枚举类型，**枚举类型与其基础整型类型之间存在显式转换**。 如果将枚举值转换为其基础类型，则结果为枚举成员的关联整数值。\n\n如果基础整数类型转换到的枚举类型时，整数的值 不在 目标枚举类型的范围中（如下方样例中的，Season枚举内的值是0，1，2，3，但我将4转换为这个枚举类型），也不会报错，但对应的这个枚举的值就是目标转换的4（不是整型了，而是Season类型的枚举4，可以看到输出var的类型名是ConsoleApp.Season）。但如果进一步的查询4是否在Season枚举中，查询的结果是false。\n\n```c#\npublic enum Season\n{\n    Spring,\n    Summer,\n    Autumn,\n    Winter\n}\n\npublic class EnumConversionExample\n{\n    public static void Main()\n    {\n      \tSeason a = Season.Autumn;\n        Console.WriteLine($\"Integral value of {a} is {(int)a}\");  \n        // output: Integral value of Autumn is 2\n\n        var b = (Season)1;\n        Console.WriteLine(b);  // output: Summer\n        Console.WriteLine(b.GetType());     //output: ConsoleApp.Season\n\n        var c = (Season)4;\n        Console.WriteLine(c);  // output: 4\n        Console.WriteLine(c.GetType());  //output: ConsoleApp.Season\n        \n        Console.WriteLine(Enum.IsDefined(typeof(Season),4));//false\n    }\n}\n```\n\n\n\n\n\n使用 `Enum.IsDefined` 方法来确定枚举类型是否包含具有特定关联值的枚举成员。\n\n对于任何枚举类型，都存在分别与 `System.Enum` 类型的装箱和取消装箱相互转换。\n\n\n\n##### string类型转换为枚举值\n\n需要借助`Enum.Parse()`方法。\n\n\n\n基本语法如下：\n\n```c#\n(目标枚举类型)Enum.Parse(typeof(目标枚举类型),\"要转换的string字符串\");\n```\n\n###### 样例\n\n```c#\nusing System;\nusing System.Windows.Diagnostics;\nusing System.Windows.Forms;\nnamespace ConsoleApp\n{\n    public enum Error : short\n    {\n        NOT_FOUND = 404,\n        BAD_GATEWAY = 502\n    }\n\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Error err = Error.NOT_FOUND;\n\n            err = (Error)Enum.Parse(typeof(Error), \"502\");//将字符类型的502转换成对应的整型值为502的枚举类型。\n            \n\n            Console.WriteLine(err);//输出：BAD_GATEWAY\n\n            Console.ReadKey();\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n### 结构体（Struct）\n\n在 C# 中，结构体是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。`struct` 关键字用于创建结构体。\n\n结构体是用来代表一个记录。假设您想跟踪图书馆中书的动态。yy您可能想跟踪每本书的以下属性：\n\n- Title\n\n- Author\n- Subject\n- Book ID\n\n\n\n#### 定义结构体\n\nstruct 语句为程序定义了一个带有多个成员的新的数据类型。\n\n例如，可以按照如下的方式声明 Book 结构：\n\n```c#\nstruct Books\n{\n   public string title;\n   public string author;\n   public string subject;\n   public int book_id;\n};  \n```\n\n下面的程序演示了结构的用法：\n\n```c#\nusing System;\nusing System.Text;\n\nstruct Books\n{\n    public string title;\n    public string author;\n    public string subject;\n    public int book_id;\n};\n\npublic class testStructure\n{\n    public static void Main(string[] args)\n    {\n\n        Books Book1;        /* 声明 Book1，类型为 Books */\n        Books Book2;        /* 声明 Book2，类型为 Books */\n\n        /* book 1 详述 */\n        Book1.title = \"C Programming\";\n        Book1.author = \"Nuha Ali\";\n        Book1.subject = \"C Programming Tutorial\";\n        Book1.book_id = 6495407;\n\n        /* book 2 详述 */\n        Book2.title = \"Telecom Billing\";\n        Book2.author = \"Zara Ali\";\n        Book2.subject = \"Telecom Billing Tutorial\";\n        Book2.book_id = 6495700;\n\n        /* 打印 Book1 信息 */\n        Console.WriteLine(\"Book 1 title : {0}\", Book1.title);\n        Console.WriteLine(\"Book 1 author : {0}\", Book1.author);\n        Console.WriteLine(\"Book 1 subject : {0}\", Book1.subject);\n        Console.WriteLine(\"Book 1 book_id :{0}\", Book1.book_id);\n\n        /* 打印 Book2 信息 */\n        Console.WriteLine(\"Book 2 title : {0}\", Book2.title);\n        Console.WriteLine(\"Book 2 author : {0}\", Book2.author);\n        Console.WriteLine(\"Book 2 subject : {0}\", Book2.subject);\n        Console.WriteLine(\"Book 2 book_id : {0}\", Book2.book_id);\n\n        Console.ReadKey();\n\n    }\n}\n```\n\n\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```bash\nBook 1 title : C Programming\nBook 1 author : Nuha Ali\nBook 1 subject : C Programming Tutorial\nBook 1 book_id : 6495407\nBook 2 title : Telecom Billing\nBook 2 author : Zara Ali\nBook 2 subject : Telecom Billing Tutorial\nBook 2 book_id : 6495700\n```\n\n#### C# 结构的特点\n\n在 C# 中的结构与传统的 C 或 C++ 中的结构不同。C# 中的结构有以下特点：\n\n- **结构可带有方法、字段、索引、属性、运算符方法和事件**。\n\n- 结构可定义构造函数，但不能定义析构函数。但是，不能为结构定义无参构造函数。无参构造函数(默认)是自动定义的，且不能被改变。\n- 与类不同，结构不能继承其他的结构或类。\n- 结构不能作为其他结构或类的基础结构。\n- 结构可实现一个或多个接口。\n- 结构成员不能指定为 abstract、virtual 或 protected。\n- 当您使用 New 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。\n- 如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。\n\n\n\n\n\n\n\n#### 类与结构的区别\n\n类和结构有以下几个基本的不同点：\n\n- 类是引用类型，结构是值类型。\n\n- 结构不支持继承。\n- 结构不能声明默认的构造函数。\n- 针对上述讨论，让我们重写前面的实例：\n\n#### 样例\n\n```c#\nusing System;\nusing System.Text;\n\nstruct Books\n{\n    private string title;\n    private string author;\n    private string subject;\n    private int book_id;\n    public void setValues(string t, string a, string s, int id)\n    {\n        title = t;\n        author = a;\n        subject = s;\n        book_id = id;\n    }\n    public void display()\n    {\n        Console.WriteLine(\"Title : {0}\", title);\n        Console.WriteLine(\"Author : {0}\", author);\n        Console.WriteLine(\"Subject : {0}\", subject);\n        Console.WriteLine(\"Book_id :{0}\", book_id);\n    }\n\n};\n\npublic class testStructure\n{\n    public static void Main(string[] args)\n    {\n\n        Books Book1 = new Books(); /* 声明 Book1，类型为 Books */\n        Books Book2 = new Books(); /* 声明 Book2，类型为 Books */\n\n        /* book 1 详述 */\n        Book1.setValues(\"C Programming\",\n        \"Nuha Ali\", \"C Programming Tutorial\", 6495407);\n\n        /* book 2 详述 */\n        Book2.setValues(\"Telecom Billing\",\n        \"Zara Ali\", \"Telecom Billing Tutorial\", 6495700);\n\n        /* 打印 Book1 信息 */\n        Book1.display();\n\n        /* 打印 Book2 信息 */\n        Book2.display();\n\n        Console.ReadKey();\n\n    }\n}\n```\n\n\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```c#\nTitle : C Programming\nAuthor : Nuha Ali\nSubject : C Programming Tutorial\nBook_id : 6495407\nTitle : Telecom Billing\nAuthor : Zara Ali\nSubject : Telecom Billing Tutorial\nBook_id : 6495700\n```\n\n\n\n\n\n\n\n### C# 数组（Array）\n\n数组是一个存储相同类型元素的固定大小的顺序集合。数组是用来存储数据的集合，通常认为数组是一个同一类型变量的集合。\n\n声明数组变量并不是声明 number0、number1、...、number99 一个个单独的变量，而是声明一个就像 numbers 这样的变量，然后使用 numbers[0]、numbers[1]、...、numbers[99] 来表示一个个单独的变量。数组中某个指定的元素是通过索引来访问的。\n\n所有的数组都是由**连续的内存位置**组成的。最低的地址对应第一个元素，最高的地址对应最后一个元素。\n\n数组最大的一个局限性就是长度不可变。可以使用集合进行优化。 \n\n#### 声明数组\n\n在 C# 中声明一个数组，可以使用下面的语法：\n\n```c#\ndatatype[] arrayName;\n```\n\n其中，\n\n- datatype 用于指定被存储在数组中的元素的类型。\n- [ ]指定数组的秩（维度）。秩指定数组的大小。\n- arrayName 指定数组的名称。\n\n例如：\n\n```c#\ndouble[] balance;\n```\n\n\n\n##### 声明多维数组\n\n和一维的声明类似，但与c/c++有一定的差异。\n\n```c#\ndouble[,] d = new double[3,4];//二维数组的声明\nint[,,] ints = new int[3, 4, 5];//三维数组\n```\n\n\n\n#### 初始化数组\n\n**声明一个数组不会在内存中初始化数组**。当初始化数组变量时，可以赋值给数组。\n\n**数组是一个引用类型**，所以需要使用 new 关键字来创建数组的实例。\n\n例如：\n\n```c#\ndouble[] balance = new double[10];\n```\n\n#### 赋值给数组\n\n可以通过使用索引号赋值给一个单独的数组元素，比如：\n\n```c#\ndouble[] balance = new double[10];\nbalance[0] = 4500.0;\n```\n\n可以在声明数组的同时给数组赋值，比如：\n\n```c#\ndouble[] balance = { 2340.0, 4523.69, 3421.0};\n```\n\n也可以创建并初始化一个数组，比如：\n\n```c#\nint [] marks = new int[5]  { 99,  98, 92, 97, 95};\n```\n\n在上述情况下，你也可以省略数组的大小，比如：\n\n```c#\nint [] marks = new int[]  { 99,  98, 92, 97, 95};\n```\n\n也可以赋值一个数组变量到另一个目标数组变量中。在这种情况下，目标和源会指向相同的内存位置：\n\n```c#\nint [] marks = new int[]  { 99,  98, 92, 97, 95};\nint[] score = marks;\n```\n\n当创建一个数组时，C# 编译器会根据数组类型隐式初始化每个数组元素为一个默认值。例如，int 数组的所有元素都会被初始化为 0。\n\n#### 访问数组元素\n\n元素是通过带索引的数组名称来访问的。这是通过把元素的索引放置在数组名称后的方括号中来实现的。例如：\n\ndouble salary = balance[9];\n下面是一个实例，使用上面提到的三个概念，即声明、赋值、访问数组：\n\n##### 实例\n\n```c#\nusing System;\nnamespace ArrayApplication\n{\n   class MyArray\n   {\n      static void Main(string[] args)\n      {\n         int []  n = new int[10]; /* n 是一个带有 10 个整数的数组 */\n         int i,j;\n\n\n         /* 初始化数组 n 中的元素 */        \n         for ( i = 0; i < 10; i++ )\n         {\n            n[ i ] = i + 100;\n         }\n\n         /* 输出每个数组元素的值 */\n         for (j = 0; j < 10; j++ )\n         {\n            Console.WriteLine(\"Element[{0}] = {1}\", j, n[j]);\n         }\n         Console.ReadKey();\n      }\n   }\n}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```c#\nElement[0] = 100\nElement[1] = 101\nElement[2] = 102\nElement[3] = 103\nElement[4] = 104\nElement[5] = 105\nElement[6] = 106\nElement[7] = 107\nElement[8] = 108\nElement[9] = 109\n```\n\n\n\n##### 实例2\n\n```c#\nusing System;\nusing System.Windows.Diagnostics;\nusing System.Windows.Forms;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            double[,] d = new double[3,4];//二维数组的声明\n            int[,,] ints = new int[3, 4, 5];//三维数组\n\n            for(int i = 0;i < 3; i++)\n            {\n                for(int j = 0; j < 4; j++)\n                {\n                    for(int k = 0; k < 5; k++)\n                    {\n                        ints[i,j,k] = i; \n                    }\n                    d[i,j] = j;\n                }\n            }\n\n            foreach(double x in d)\n            {\n                Console.WriteLine(x);             \n            }\n            foreach(int x in ints)\n            {\n                Console.WriteLine(x);\n            }\n\n            Console.ReadKey();\n        }\n    }\n\n}\n```\n\n\n\n#### 使用 foreach 循环\n\n在前面的实例中，我们使用一个 for 循环来访问每个数组元素。也可以使用一个 foreach 语句来遍历数组。\n\n##### 实例1 一维数组的使用\n\n```c#\nusing System;\n\nnamespace ArrayApplication\n{\n   class MyArray\n   {\n      static void Main(string[] args)\n      {\n         int []  n = new int[10]; /* n 是一个带有 10 个整数的数组 */\n\n\n         /* 初始化数组 n 中的元素 */        \n         for ( int i = 0; i < 10; i++ )\n         {\n            n[i] = i + 100;\n         }\n\n         /* 输出每个数组元素的值 */\n         foreach (int j in n )\n         {\n            int i = j-100;\n            Console.WriteLine(\"Element[{0}] = {1}\", i, j);\n         }\n         Console.ReadKey();\n      }\n   }\n}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```c#\nElement[0] = 100\nElement[1] = 101\nElement[2] = 102\nElement[3] = 103\nElement[4] = 104\nElement[5] = 105\nElement[6] = 106\nElement[7] = 107\nElement[8] = 108\nElement[9] = 109\n```\n\n\n\n#### 数组的数组（锯齿数组）\n\n普通的数组称为矩形数组，因为每一行的元素个数都相等。\n\n如果需要每行的元素个数不同，可以使用锯齿数组（jagged array)\n\n\n\n```c#\nusing System;\nusing System.Windows.Diagnostics;\nusing System.Windows.Forms;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            int[][] jaggedIntArray;\n            //jaggedIntArray= new int[3][4];//不能像普通数组一样声明。就算可以，也没有意义。因为这样就像普通数组一样了。\n            //jaggedIntArray = { {1, 2, 3 }, { 4, 5}, { 6, 7, 8, 9} };//也不可以这样\n\n            //可用的两种方法：\n            jaggedIntArray = new int[2][];//先声明第一层\n            jaggedIntArray[0] = new int[3];//再声明第二层的第一个\n            jaggedIntArray[1] = new int[5];//再声明第二层第二个\n\n            //第二种方法\n            jaggedIntArray = new int[2][]\n            {\n                new int[]{0, 1, 2, 3},\n                new int[]{4, 5}\n            };\n\n            //遍历的时候，也不能简单的使用foreach了，需要根据层数嵌套\n            //foreach(int i in jaggedIntArray)\n            //{\n            //    Console.WriteLine(i);//因为i的类型是int[]\n            //}\n\n            foreach (int[] it in jaggedIntArray)\n            {\n                foreach(int i in it)\n                {\n                    Console.Write($\"{ i} \");\n                }\n                Console.WriteLine();\n            }\n\n            Console.ReadKey();\n        }\n    }\n\n}\n```\n\n\n\n\n\n#### 锯齿数组的注意事项\n\n- 声明和遍历方法均与普通的数组有一定的区别，需要注意。\n- 有点类似于c++中的数组指针？外一层的类型是内一层的数组指针，每一个指针单独malloc大小存储数据。\n\n\n\n\n\n#### C#\t 数组细节\n\n| 概念                                                         | 描述                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [多维数组](https://www.runoob.com/csharp/csharp-multi-dimensional-arrays.html) | C# 支持多维数组。多维数组最简单的形式是二维数组。            |\n| [交错数组](https://www.runoob.com/csharp/csharp-jagged-arrays.html) | C# 支持交错数组，即数组的数组。                              |\n| [传递数组给函数](https://www.runoob.com/csharp/csharp-passing-arrays-to-functions.html) | 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 |\n| [参数数组](https://www.runoob.com/csharp/csharp-param-arrays.html) | 这通常用于传递未知数量的参数给函数。                         |\n| [Array 类](https://www.runoob.com/csharp/csharp-array-class.html) | **在 System 命名空间中定义，是所有数组的基类，并提供了各种用于数组的属性和方法。** |\n| 数组的数据类型                                               | 数组元素的类型后面加上[]。如：System.Int32[]                 |\n\n\n\n\n\n## 常量\n\n比如 `const int N = 1e5+10;`\n\n​\t常量是固定值，程序执行期间不会改变。**常量可以是任何基本数据类型**，比如整数常量、浮点常量、字符常量或者字符串常量，还有枚举常量。\n\n​\t常量可以被当作常规的变量，只是它们的值在定义后不能被修改。\n\n​\t常量隶属于类型，因此没有实例常量一说。对于“实例常量”只能使用只读实例字段（属性）实现。\n\n​\t只读实例字段仍然是一个变量，访问变量需要访问这个这个变量所在的地址，**访问变量的效率不如访问常量**。\n\n​\t成员常量，是类的常量，如`Math.PI`, `int.MaxValue`等\n\n​\t局部常量，是在方法体内的常量，如\n\n```c#\nnamespace ConsoleApp\n{\n    internal class Program\n    {      \n\n        static void Main(string[] args)\n        {\n            const int x = 100;          \n            Console.ReadLine();\n        }\n    }\n}\n```\n\n\n\n### 整数常量\n\n​\t整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，没有前缀则表示十进制。\n\n​\t整数常量也可以有后缀，可以是 U 和 L 的组合，其中，U 和 L 分别表示 unsigned 和 long。后缀可以是大写或者小写，多个后缀以任意顺序进行组合。\n\n这里有一些整数常量的实例：\n\n```\n212         /* 合法 */\n215u        /* 合法 */\n0xFeeL      /* 合法 */\n078         /* 非法：8 不是一个八进制数字 */\n032UU       /* 非法：不能重复后缀 */\n```\n\n​\t以下是各种类型的整数常量的实例：\n\n```\n85         /* 十进制 */\n0213       /* 八进制 */\n0x4b       /* 十六进制 */\n30         /* int */\n30u        /* 无符号 int */\n30l        /* long */\n30ul       /* 无符号 long */\n```\n\n### 浮点常量\n\n​\t一个浮点常量是由整数部分、小数点、小数部分和指数部分组成。可以使用小数形式或者指数形式来表示浮点常量。\n\n​\t这里有一些浮点常量的实例：\n\n```\n3.14159       /* 合法 */\n314159E-5L    /* 合法 */\n510E          /* 非法：不完全指数 */\n210f          /* 非法：没有小数或指数 */\n.e55          /* 非法：缺少整数或小数 */\n```\n\n使用浮点形式表示时，必须包含小数点、指数或同时包含两者。使用指数形式表示时，必须包含整数部分、小数部分或同时包含两者。有符号的指数是用 e 或 E 表示的。\n\n### 字符常量和转义字符\n\n字符常量是括在单引号里，例如，'x'，且可存储在一个简单的字符类型变量中。一个字符常量可以是一个普通字符（例如 'x'）、一个转义序列（例如 '\\t'）或者一个通用字符（例如 '\\u02C0'）。\n\n在 C# 中有一些特定的字符，当它们的前面带有反斜杠时有特殊的意义，可用于表示换行符（\\n）或制表符 tab（\\t）。在这里，列出一些转义序列码：\n\n| 转义序列   | 含义                       |\n| :--------- | :------------------------- |\n| \\\\\\        | \\ 字符                     |\n| \\\\'        | ' 字符                     |\n| \\\\\"        | \" 字符                     |\n| \\?         | ? 字符                     |\n| \\a         | 警告（产生蜂鸣）           |\n| \\b         | 退格键（Backspace）        |\n| \\f         | 换页符（Form feed）        |\n| \\n         | 换行符（Newline）          |\n| \\r         | 回车                       |\n| \\t         | 水平制表符 tab             |\n| \\v         | 垂直制表符 tab             |\n| \\ooo       | 一到三位的八进制数         |\n| \\xhh . . . | 一个或多个数字的十六进制数 |\n\n以下是一些转义序列字符的实例：\n\n```c#\nnamespace EscapeChar\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello\\tWorld\\n\\n\");\n            Console.ReadLine();\n        }\n    }\n}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```\nHello   World\n```\n\n### 字符串常量\n\n字符串常量是括在双引号 `\"\"`里，或者是括在 `@\"\"` 里。字符串常量包含的字符与字符常量相似，可以是：普通字符、转义序列和通用字符\n\n使用字符串常量时，可以把一个很长的行拆成多个行，可以使用空格分隔各个部分。\n\n这里是一些字符串常量的实例。下面所列的各种形式表示相同的字符串。\n\n```\nstring a = \"hello, world\";                  // hello, world\nstring b = @\"hello, world\";               // hello, world\nstring c = \"hello \\t world\";               // hello     world\nstring d = @\"hello \\t world\";               // hello \\t world\nstring e = \"Joe said \\\"Hello\\\" to me\";      // Joe said \"Hello\" to me\nstring f = @\"Joe said \"\"Hello\"\" to me\";   // Joe said \"Hello\" to me\nstring g = \"\\\\\\\\server\\\\share\\\\file.txt\";   // \\\\server\\share\\file.txt\nstring h = @\"\\\\server\\share\\file.txt\";      // \\\\server\\share\\file.txt\nstring i = \"one\\r\\ntwo\\r\\nthree\";\nstring j = @\"one\ntwo\nthree\";\n```\n\n\n\n### 定义常量\n\n常量是使用 **const** 关键字来定义的 。定义一个常量的语法如下：\n\n```\nconst <data_type> <constant_name> = value;\n```\n\n下面的代码演示了如何在程序中定义和使用常量：\n\n### 实例\n\n```C#\nusing System;\n\npublic class ConstTest\n{\n  class SampleClass\n  {\n    public int x;\n    public int y;\n    public const int c1 = 5;\n    public const int c2 = c1 + 5;\n\n    public SampleClass(int p1, int p2)\n    {\n      x = p1;\n      y = p2;\n    }\n  }\n\n  static void Main()\n  {\n    SampleClass mC = new SampleClass(11, 22);\n    Console.WriteLine(\"x = {0}, y = {1}\", mC.x, mC.y);\n    Console.WriteLine(\"c1 = {0}, c2 = {1}\",\n             SampleClass.c1, SampleClass.c2);\n  }\n}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```\nx = 11, y = 22\nc1 = 5, c2 = 10\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 字符串（String）类型与处理\n\n​\t**字符串（String）类型** 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。**字符串（String）类型的值可以通过两种形式进行分配：双引号和 @双引号**\n\n例如：\n\n```c#\nString str = \"hurriedlu\";\n```\n\n一个 @引号字符串：\n\n```c#\n@\"hurriedlu\";\n```\n\nC# string 字符串的前面可以加 @（称作\"逐字字符串\"）将转义字符（\\）当作普通字符对待，比如：\n\n```c#\nstring str = @\"C:\\Windows\";\n```\n\n等价于：\n\n```\nstring str = \"C:\\\\Windows\";\n```\n\n@ 字符串中可以**任意换行**，换行符及缩进空格都计算在字符串长度之内。\n\n```c#\nstring str = @\"<script type=\"\"text/javascript\"\">\n    <!--\n    -->\n</script>\";\n```\n\n用户自定义引用类型有：class、interface 或 delegate。我们将在以后的章节中讨论这些类型。\n\n\n\n### 字符串的处理\n\n- string类型的遍历可以视为char变量的只读数组。\n\n  - 例如：char c = str[0];\n\n- 如果需要将string转换成一个可写的char数组，可以使用如下代码:\n\n  - ```c#\n    string str = \"hurriedlu\";\n    char[] myChars = str.ToCharArray();\n    ```\n\n- 也可以使用foreach遍历字符串\n\n  - ```c#\n    string str = \"hurriedlu\";\n    foreach(char c in str)\n    {\n    \tConsole.Write($\"{c} \");//输出：h u r r i e d l u\n    }\n    ```\n\n- 与普通数组一样，可以使用`.Length`获取数组长度。如：\n\n  - ```c#\n    string str = \"hurriedlu\";\n    Console.WriteLine(str.Length);//输出：9\n    ```\n\n- 将字符串转换成全大写或全小写\n\n  - ```c#\n    string str = \"hUrrIEdlu\";\n    Console.WriteLine(str);//原样输出\n    Console.WriteLine(str.ToLower());//转换成全小写后输出\n    Console.WriteLine(str.ToUpper());//转换成全大写后输出\n    //输出：hUrrIEdlu\n    //      hurriedlu\n    //      HURRIEDLU\n    ```\n\n  - 注意，这个方法不会改变原有的值，而是创建一个新的值，新的值是全大/小写的，并把这个值通过返回值的形式输出出去。\n\n- 去除多余的前后空格（也可以删除指定的字符）。使用Trim删除指定字符的时候，会遍历整个string遍历，遇到符合的字母就会删除，遇到不符合的就停止删除操作\n\n  - ```c#\n    string str = \"  hu  rr          \";\n    Console.WriteLine(str.Trim());//去除多余的前后空格，输出“hu  rr”\n    ```\n\n  - ```c#\n    char[] trimChars = new char[] { ' ', 'h', 'i', 'u' };\n    string str = \"  hu  rriedlu          \";\n    str = str.Trim(trimChars);//从头或者尾扫描，如果字符是数组trimChars的值就删掉，直到非trimChars数组的值停下，不再删除 直接返回剩余的字符串\n    Console.WriteLine(str);//删除指定的元素，这里指定了空格、h和i，输出“rriedl”\n    Console.WriteLine(str.Length);//输出6\n    ```\n\n    - 可以看到在这个样例中，开头和结尾处的指定元素已经被删除了，但在中间的i并没有被删除。因为只要遇到非trimChars数组的值就停下，然后直接返回剩余的值。\n\n- 在字符串的指定位置添加空格，常用于对齐字符串（数字）。\n\n  - ```c#\n    string str1 = \"hurr\";\n    string str2 = \"hurriedlu\";\n    //9表示字符串将变成9长度，在新增加的位置上补‘0’.\n    str1 = str1.PadLeft(9, '0');//可以自定义补充元素，如果不指定就默认是空格。\n    Console.WriteLine(str1);\n    Console.WriteLine(str2);\n    //输出：\n    // 00000hurr\n    // hurriedlu\n    ```\n\n    \n\n\n\n\n\n## 动态（Dynamic）类型\n\n​\t可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。\n\n### 声明动态类型的语法：\n\n```c#\ndynamic <variable_name> = value;\n```\n\n例如：\n\n```c#\ndynamic d = 20;\n```\n\n动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。\n\n\n\n\n\n## 隐式变量\n\n​\t可声明局部变量而无需提供显式类型。 `var` 关键字指示**编译器通过初始化语句右侧的表达式推断变量的类型**。 推断类型可以是内置类型、匿名类型、用户定义类型或 .NET 类库中定义的类型。 有关如何使用 `var` 初始化数组的详细信息，请参阅[隐式类型化数组](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/arrays/implicitly-typed-arrays)。\n\n以下示例演示使用 `var` 声明局部变量的各种方式：\n\n```c#\n// i is compiled as an int\nvar i = 5;\n\n// s is compiled as a string\nvar s = \"Hello\";\n\n// a is compiled as int[]\nvar a = new[] { 0, 1, 2 };\n\n// expr is compiled as IEnumerable<Customer>\n// or perhaps IQueryable<Customer>\nvar expr =\n    from c in customers\n    where c.City == \"London\"\n    select c;\n\n// anon is compiled as an anonymous type\nvar anon = new { Name = \"Terry\", Age = 34 };\n\n// list is compiled as List<int>\nvar list = new List<int>();\n```\n\n\n\n重要的是了解 `var` 关键字并不意味着“变体”，并且并不指示变量是松散类型或是后期绑定。 **它只表示由编译器确定并分配最适合的类型。**\n\n在以下上下文中，可使用 `var` 关键字：\n\n- 在局部变量（在方法范围内声明的变量）上，如前面的示例所示。\n\n- 在 [for](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement) 初始化语句中。\n\n  ```csharp\n  for (var x = 1; x < 10; x++)\n  ```\n\n- 在 [foreach](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement) 初始化语句中。\n\n  ```csharp\n  foreach (var item in list) {...}\n  ```\n\n- 在 [using](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/using-statement) 域间中。\n\n  ```csharp\n  using (var file = new StreamReader(\"C:\\\\myfile.txt\")) {...}\n  ```\n\n有关详细信息，请参阅[如何在查询表达式中使用隐式类型化局部变量和数组](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/how-to-use-implicitly-typed-local-variables-and-arrays-in-a-query-expression)。\n\n\n\n### var 和匿名类型\n\n在许多情况下，使用 `var` 是可选的，只是一种语法便利。 但是，在使用匿名类型初始化变量时，如果需要在以后访问对象的属性，则必须将变量声明为 `var`。 这是 LINQ 查询表达式中的常见方案。 有关详细信息，请参阅[匿名类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/types/anonymous-types)。\n\n从源代码角度来看，匿名类型没有名称。 因此，如果使用 `var` 初始化了查询变量，则访问返回对象序列中的属性的唯一方法是在 `foreach` 语句中将 `var` 用作迭代变量的类型。\n\n\n\n```csharp\nclass ImplicitlyTypedLocals2\n{\n    static void Main()\n    {\n        string[] words = { \"aPPLE\", \"BlUeBeRrY\", \"cHeRry\" };\n\n        // If a query produces a sequence of anonymous types,\n        // then use var in the foreach statement to access the properties.\n        var upperLowerWords =\n             from w in words\n             select new { Upper = w.ToUpper(), Lower = w.ToLower() };\n\n        // Execute the query\n        foreach (var ul in upperLowerWords)\n        {\n            Console.WriteLine(\"Uppercase: {0}, Lowercase: {1}\", ul.Upper, ul.Lower);\n        }\n    }\n}\n/* Outputs:\n    Uppercase: APPLE, Lowercase: apple\n    Uppercase: BLUEBERRY, Lowercase: blueberry\n    Uppercase: CHERRY, Lowercase: cherry\n */\n```\n\n\n\n### 备注\n\n以下限制适用于隐式类型化变量声明：\n\n- 仅当局部变量在相同语句中进行声明和初始化时，才能使用 `var`；**变量不能初始化为 null**，也不能初始化为方法组或匿名函数。\n- `var` 不能在类范围内对字段使用。\n- 使用 `var` 声明的变量不能在初始化表达式中使用。 换句话说，此表达式是合法的：`int i = (i = 20);`，但是此表达式会生成编译时错误：`var i = (i = 20);`\n- 不能在相同语句中初始化多个隐式类型化变量。\n- 如果一种名为 `var` 的类型处于范围内，则 `var` 关键字会解析为该类型名称，不会被视为隐式类型化局部变量声明的一部分。\n\n带 `var` 关键字的隐式类型只能应用于本地方法范围内的变量。 隐式类型不可用于类字段，因为 C# 编译器在处理代码时会遇到逻辑悖论：编译器需要知道字段的类型，但它在分析赋值表达式前无法确定类型，而表达式在不知道类型的情况下无法进行计算。 考虑下列代码：\n\n\n\n```csharp\nprivate var bookTitles;\n```\n\n`bookTitles` 是类型为 `var` 的类字段。 由于该字段没有要计算的表达式，编译器无法推断出 `bookTitles` 应该是哪种类型。 此外，向该字段添加表达式（就像对本地变量执行的操作一样）也是不够的：\n\n\n\n```csharp\nprivate var bookTitles = new List<string>();\n```\n\n当编译器在代码编译期间遇到字段时，它会在处理与其关联的任何表达式之前记录每个字段的类型。 编译器在尝试分析 `bookTitles` 时遇到相同的悖论：它需要知道字段的类型，但编译器通常会通过分析表达式来确定 `var` 的类型，这在事先不知道类型的情况下无法实现。\n\n你可能会发现，对于在其中难以确定查询变量的确切构造类型的查询表达式，`var` 也可能会十分有用。 这可能会针对分组和排序操作发生。\n\n当变量的特定类型在键盘上键入时很繁琐、或是显而易见、或是不会提高代码的可读性时，`var` 关键字也可能非常有用。 `var` 采用此方法提供帮助的一个示例是针对嵌套泛型类型（如用于分组操作的类型）。 在下面的查询中，查询变量的类型是 `IEnumerable<IGrouping<string, Student>>`。 只要你和必须维护你的代码的其他人了解这一点，使用隐式类型化实现便利性和简便性时便不会出现问题。\n\n```csharp\n// Same as previous example except we use the entire last name as a key.\n// Query variable is an IEnumerable<IGrouping<string, Student>>\nvar studentQuery3 =\n    from student in students\n    group student by student.Last;\n```\n\n**使用 `var` 有助于简化代码，但是它的使用应该限制在需要使用它的情况下，或在它可使代码更易于读取的情况下**。 有关何时正确使用 `var` 的详细信息，请参阅 C# 编码指南一文中的[隐式类型本地变量](https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/coding-style/coding-conventions#implicitly-typed-local-variables)节。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## C# 类型转换\n\n### 隐式转换和显示转换\n\n类型转换从根本上说是类型铸造，或者说是把数据从一种类型转换为另一种类型。在 C# 中，类型铸造有两种形式：\n\n- **隐式类型转换** - 这些转换是 C# 默认的以安全方式进行的转换, 不会导致数据丢失。例如，从小的整数类型转换为大的整数类型，从派生类转换为基类。\n  - 当试图用一个引用变量去访问它引用的实例的成员时，只能访问到这个变量所具有的成员。当用基类变量指向一个派生类的实例时，变量只能调用基类的成员（即使出现了重载，也会使用基类的而非派生类）。\n\n- **显式类型转换** - 显式类型转换，即强制类型转换。显式转换需要强制转换运算符，而且强制转换会造成数据丢失。\n\n下面的实例显示了一个显式的类型转换：\n\n```c#\nnamespace TypeConversionApplication\n{\n  class ExplicitConversion\n  {\n    static void Main(string[] args)\n    {\n      double d = 5673.74;\n      int i;\n\n      // 强制转换 double 为 int\n      i = (int)d;\n      Console.WriteLine(i);\n      Console.ReadKey();\n      \n    }\n  }\n}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```\n5673\n```\n\n\n\n#### 注意事项\n\n- 如果彼此之间没有什么关系的类型不能进行强制转换。如string到int。\n\n- 如果发生溢出，可以使用`checked`对可能溢出的代码进行修饰（或 包括），这样如果发生溢出就会抛出异常。详见`c#基本语句`中的`checked/unchecked语句`\n\n  \n\n\n\n### Convert转换\n\nC# 提供了Convert类，其中内置了下列的一些类型转换方法：\n\n| 序号 | 方法 & 描述                                                  |\n| :--- | :----------------------------------------------------------- |\n| 1    | **ToBoolean** 如果可能的话，把类型转换为布尔型。             |\n| 2    | **ToByte** 把类型转换为字节类型。                            |\n| 3    | **ToChar** 如果可能的话，把类型转换为单个 Unicode 字符类型。 |\n| 4    | **ToDateTime** 把类型（整数或字符串类型）转换为 日期-时间 结构。 |\n| 5    | **ToDecimal** 把浮点型或整数类型转换为十进制类型。           |\n| 6    | **ToDouble** 把类型转换为双精度浮点型。                      |\n| 7    | **ToInt16** 把类型转换为 16 位整数类型。                     |\n| 8    | **ToInt32** 把类型转换为 32 位整数类型。                     |\n| 9    | **ToInt64** 把类型转换为 64 位整数类型。                     |\n| 10   | **ToSbyte** 把类型转换为有符号字节类型。                     |\n| 11   | **ToSingle** 把类型转换为小浮点数类型。                      |\n| 12   | **ToString** 把类型转换为字符串类型。                        |\n| 13   | **ToType** 把类型转换为指定类型。                            |\n| 14   | **ToUInt16** 把类型转换为 16 位无符号整数类型。              |\n| 15   | **ToUInt32** 把类型转换为 32 位无符号整数类型。              |\n| 16   | **ToUInt64** 把类型转换为 64 位无符号整数类型。              |\n\n下面的实例把不同值的类型转换为字符串类型：\n\n```c#\nnamespace TypeConversionApplication\n{\n  class StringConversion\n  {\n    static void Main(string[] args)\n    {\n      int i = 75;\n      float f = 53.005f;\n      double d = 2345.7652;\n      bool b = true;\n\n      Console.WriteLine(i.ToString());\n      Console.WriteLine(f.ToString());\n      Console.WriteLine(d.ToString());\n      Console.WriteLine(b.ToString());\n      Console.ReadKey();\n     }\n  }\n}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```\n75\n53.005\n2345.7652\nTrue\n```\n\n#### 注意事项\n\n- 使用Convert类进行数值转换的时候，是比较安全的，转换的时候会自动检测精度是否会受损或者字符串是否是一个正确的数值，如果发生溢出或不是正确的字符串，会抛出异常。\n- 数值的有效表达方式：\n  - 首先是一个可选符号(加号或减号)，然后是0位或多位数字，一个可选的句点后跟一位或多位数字，接着是一个可选的e或E，后跟一个可选符号和一位或多位数字，除了还可能有空格(在这个序列之前或之后)，不能有其他字符。利用这些可选的额外数据，可将- 1.2451e -24这样复杂的字符串识别为数值。\n- 总是要进行溢出检查，checked 和unchecked关键字以及项目属性设置不起作用。\n\n### Parse转换\n\n用于string类型转其他类型，实际上是一种对字符串的解析。\n\n需要注意的是，Parse只对格式正确的字符串进行解析，对于格式不正确的字符串会抛出`System.FormatException:“输入字符串的格式不正确。”`异常。\n\n```c#\nstring str1 = \"123.456\";\nstring str2 = \"123.123.234\";//格式错误\n\ndouble d1 = double.Parse(str1);\n//double d2 = double.Parse(str2); //会抛出错误\n```\n\n#### 升级版的TryParse\n\n尝试转换，转换成功通过参数带回。返回值是一个布尔类型的变量。\n\n```c#\nstring str1 = \"123.456\";\nstring str2 = \"123.123.234\";//格式错误\ndouble d1;\ndouble d2;\nif(double.TryParse(str1,out d1))\n\tConsole.WriteLine(\"转换成功\");    \nelse\n\tConsole.WriteLine(\"转换失败\");\nif (double.TryParse(str2, out d2))\n\tConsole.WriteLine(\"转换成功\");\nelse\n\tConsole.WriteLine(\"转换失败\");\n```\n\n\n\n#### 自定义类型转换\n\n##### 基础知识\n\n​\t\t类型转换有2种：隐式转换和显式转换。但是，不管是隐式转换，还是显式转换，都是生成了一个新对象返回的。改变新对象的属性，不会影响老对象！(dynamic对象除外，详情搜索dynamic动态类型。)\n\n自定义隐式/显式转换的方法需要用到几个关键字：implicit(隐式转换)、explicit(显式转换)、operator(操作符)。更多的注意点见下：\n\n- 方法必须是static\n- 使用implicit或explicit\n- 搭配operator(此也是c#关键字，可在类别或结构宣告内多载内建运算子或提供使用者定义的转换)\n- 返回值为要转换为的目标类型，但不要在方法上声明，方法名为目标类型。注意：返回值不一定是本类类型。本类型和其他类型之间可以互相转换，只要定义转换方法就行。\n- 参数为原始类型，方法名为目标类型\n- 类A到类B的类型转换定义不能在类C中进行（即2个类的转换不能在第3个类中定义），否则会报错：用户定义的转换必须是转换成封闭类型，或者从封闭类型转换。具体查看后面的用户定义的转换必须是转换成封闭类型，或者从封闭类型转换\n- 不能被virtual/override修饰（不能“覆盖”运算符，因为它们是静态的。）Overriding implicit operators in C#\n\n对于自定义类型而言，可以手动的自定义类型转换。\n\n\n\n##### 样例1\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            A a = new A();\n            B b = (B)a;//自定义类型转换\n            Console.ReadLine();\n        }\n    \n    }\n\n    class A\n    {\n        public int n;\n\n        public static explicit operator B(A a)//自定义转换规则，显示类型转换，如果需要隐式转换，则将explicit换成implicit即可。\n        {\n            B b = new B();//创建一个目标对象\n            b.n = a.n;//将自己的值按照一定的规则传给b对象\n            return b;//转换完成后返回目标对象\n        }\n    }\n    class B\n    {\n        public int n;\n    }\n}\n\n```\n\n\n\n##### 样例2\n\n```c#\n//================定义类型和方法================\nclass Robot\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n\n    public Robot(int id, string name)\n    {\n        Id = id;\n        Name = name;\n    }\n\n    #region 其他类型->本类\n\n    //隐式转换\n    public static implicit operator Robot(string name)\n    {\n        return new Robot(101, name);\n    }\n\n    //显式转换\n    public static explicit operator Robot(int id)\n    {\n        return new Robot(id, \"miku\");\n    }\n\n    #endregion\n\n    #region 本类->其他类型\n\n    //隐式转换\n    public static implicit operator string(Robot robot)\n    {\n        return robot.Name;\n    }\n\n    //显式转换\n    public static explicit operator int(Robot robot)\n    {\n        return robot.Id;\n    }\n\n    #endregion\n}\n\n//================测试代码================\n#region 其他类型->本类\n\nstring gumiStr = \"gumi\";\nRobot gumi001 = gumiStr; //隐式转换\nConsole.WriteLine(\"隐式转换：gumi001 : {0}\", JsonConvert.SerializeObject(gumi001));\n\nint lukaId = 1004;\nRobot luka001 = (Robot)lukaId; //显式转换\nConsole.WriteLine(\"显式转换：luka001 : {0}\", JsonConvert.SerializeObject(luka001));\n\n#endregion\n\n#region 其他类型->本类\n\nRobot miku001 = new Robot(1001, \"miku10001\");\n//隐式转换\nstring mikuName = miku001;\n//显式转换\nint mikuId = (int)miku001;\n\nConsole.WriteLine(\"隐式转换：miku001 Name: {0}\", mikuName);\nConsole.WriteLine(\"显式转换：miku001 Id: {0}\", mikuId);\n\n#endregion\n```\n\n输出结果如下：\n\n```c#\n隐式转换：gumi001 : {\"Id\":101,\"Name\":\"gumi\"}\n显式转换：luka001 : {\"Id\":1004,\"Name\":\"miku\"}\n隐式转换：miku001 Name: miku10001\n显式转换：miku001 Id: 1001\n```\n\n\n\n\n\n##### 实际应用\n\n问题\n\n```\n[1,[[2,2],[2,2],[2,2],[2,2]]]\n```\n\n这样一个字符串，如何可以反序列化成一个对象？（如何定义这个类？）\n\n```c#\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\n                    \npublic class Program\n{\n    public static void Main()\n    {\n        var json = \"[1,[[2,2],[2,2],[2,2],[2,2]]]\";\n        var root = JsonConvert.DeserializeObject<Root>(json);\n        foreach(var ele in root)\n        {\n            if(ele.SingleValue.HasValue)\n            {//有值，原始数据为 1\n                Console.WriteLine(ele.SingleValue.Value);\n            }else\n            {//原始数据为 二维数组\n                Console.WriteLine(string.Join(\" \",ele.Select(x=>string.Join(\",\",x))));\n            }\n        }\n        Console.WriteLine(JsonConvert.SerializeObject(root));\n    }\n}\n\nclass Root : List<Element> { }\n[JsonConverter(typeof(CConverter))]\nclass Element : List<List<long>>\n{\n    //该属性，存放 1 。后续可以通过判断该属性是否有值来得知原始数据的情况\n    public long? SingleValue { get; set; }\n\n    //遇到 1 ，隐式转换为 该类型，其中 1 被存放到SingleValue属性\n    public static implicit operator Element(long d)\n    {\n        return new Element { SingleValue = d };\n    }\n}\n\npublic class CConverter : JsonConverter\n{\n    public override bool CanConvert(Type objectType)\n    {\n        return (objectType == typeof(Element));\n    }\n\n    public override bool CanRead  { get { return false; } }\n    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)\n    {\n        throw new NotImplementedException();\n    }\n\n    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)\n    {\n        var ele = value as Element;\n        var token = ele.SingleValue.HasValue ? JToken.FromObject(ele.SingleValue.Value) : JToken.FromObject(ele.ToList());\n        token.WriteTo(writer);\n    }\n\n    public override bool CanWrite { get { return true; } }\n}\n```\n\n来源：https://cloud.tencent.com/developer/article/1986028#:~:text=C%23%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%201%20%E6%96%B9%E6%B3%95%E5%BF%85%E9%A0%88%E6%98%AFstatic%202%20%E4%BD%BF%E7%94%A8%20implicit%20%E6%88%96%20explicit,%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%BF%85%E9%A1%BB%E6%98%AF%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%81%E9%97%AD%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%88%96%E8%80%85%E4%BB%8E%E5%B0%81%E9%97%AD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%207%20%E4%B8%8D%E8%83%BD%E8%A2%AB%20virtual%20%2F%20override%20%E4%BF%AE%E9%A5%B0%EF%BC%88%E4%B8%8D%E8%83%BD%E2%80%9C%E8%A6%86%E7%9B%96%E2%80%9D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%83%E4%BB%AC%E6%98%AF%E9%9D%99%E6%80%81%E7%9A%84%E3%80%82%20\n\n\n\n### C# 中的 Lvalues 和 Rvalues\n\nC# 中的两种表达式：（变量和常量？）\n\n1. **lvalue**：lvalue 表达式可以出现在赋值语句的左边或右边。\n2. **rvalue**：rvalue 表达式可以出现在赋值语句的右边，不能出现在赋值语句的左边。\n\n变量是 lvalue 的，所以可以出现在赋值语句的左边。数值是 rvalue 的，因此不能被赋值，不能出现在赋值语句的左边。下面是一个有效的语句：\n\n```\nint g = 20;\n```\n\n下面是一个无效的语句，会产生编译时错误：\n\n```\n10 = 20;\n```\n\n\n\n\n\n\n\n\n\n\n\n## C# 运算符\n\n| 类别               | 运算符                                                       |\n| ------------------ | ------------------------------------------------------------ |\n| 基本               | x.y f(x) a[x] x++ x-- new typeof default checked unchecked delegate sizeof -> |\n| 一元               | + - ! ~ ++ -- (T)x await &x *x                               |\n| 乘法               | * / %                                                        |\n| 加减               | + -                                                          |\n| 移位               | << >>                                                        |\n| 关系               | < > <= >=                                                    |\n| 类型检测           | is as                                                        |\n| 相等               | == !=                                                        |\n| 逻辑与             | &                                                            |\n| 逻辑异或           | ^                                                            |\n| 逻辑或             | \\|                                                           |\n| 条件与             | &&                                                           |\n| 条件或             | \\|\\|                                                         |\n| null 合并          | ??                                                           |\n| 条件               | ?:                                                           |\n| 赋值和lambda表达式 | = *= /= %= += -= <<= >>= &= ^= \\|= =>                        |\n\n   \n\n- 运算符也称为操作符\n- 运算符的本质是函数的“简记法”\n- 运算符不能脱离与它关联的数据类型\n\n\n\n运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。分类如下：\n\n- 算术运算符\n- 关系运算符\n- 逻辑运算符\n- 位运算符\n- 赋值运算符\n- 其他运算\n\n### 算术运算符\n\nC# 支持的所有算术运算符。假设变量 **A** 的值为 10，变量 **B** 的值为 20，则：\n\n| 运算符 | 描述                             | 实例             |\n| :----- | :------------------------------- | :--------------- |\n| +      | 把两个操作数相加                 | A + B 将得到 30  |\n| -      | 从第一个操作数中减去第二个操作数 | A - B 将得到 -10 |\n| *      | 把两个操作数相乘                 | A * B 将得到 200 |\n| /      | 分子除以分母                     | B / A 将得到 2   |\n| %      | 取模运算符，整除后的余数         | B % A 将得到 0   |\n| ++     | 自增运算符，整数值增加 1         | A++ 将得到 11    |\n| --     | 自减运算符，整数值减少 1         | A-- 将得到 9     |\n\n\n\n### 乘法运算符\n\n对于 x * y 形式的运算，应用二元运算符重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。\n\n下面列出了预定义的乘法运算符。这些运算符均计算 x 和 y 的乘积。\n\n·    整数乘法：\n\nint operator *(int x, int y);\nuint operator *(uint x, uint y);\nlong operator *(long x, long y);\nulong operator *(ulong x, ulong y);\n\n在 checked 上下文中，如果积超出结果类型的范围，则引发 System.OverflowException。在 unchecked 上下文中，不报告溢出并且结果类型范围外的任何有效高序位都被放弃。\n\n·    浮点乘法：\n\nfloat operator *(float x, float y);\ndouble operator *(double x, double y);\n\n根据 IEEE 754 算术运算法则计算乘积。下表列出了非零有限值、零、无穷大和 NaN 的所有可能组合的结果。在该表中，x 和 y 是正有限值，z 是 x * y 的结果。如果结果对目标类型而言太大，则 z 为无穷大。如果结果对目标类型而言太小，则 z 为零。\n\n\n\n|      | +y   | –y   | +0   | –0   | +∞   | –∞   | NaN  |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| +x   | +z   | –z   | +0   | –0   | +∞   | –∞   | NaN  |\n| –x   | –z   | +z   | –0   | +0   | –∞   | +∞   | NaN  |\n| +0   | +0   | –0   | +0   | –0   | NaN  | NaN  | NaN  |\n| –0   | –0   | +0   | –0   | +0   | NaN  | NaN  | NaN  |\n| +∞   | +∞   | –∞   | NaN  | NaN  | +∞   | –∞   | NaN  |\n| –∞   | –∞   | +∞   | NaN  | NaN  | –∞   | +∞   | NaN  |\n| NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |\n\n\n\n·    小数乘法：\n\ndecimal operator *(decimal x, decimal y);\n\n如果结果值太大，不能用 decimal 格式表示，则将引发 System.OverflowException。如果结果值太小，无法用 decimal 格式表示，则结果为零。在进行任何舍入之前，结果的小数位数是两个操作数的小数位数的和。\n\n小数乘法等效于使用 System.Decimal 类型的乘法运算符。\n\n### 除法运算符\n\n对于 x / y 形式的运算，应用二元运算符重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。\n\n下面列出了预定义的除法运算符。这些运算符均计算 x 和 y 的商。\n\n·    整数除法：\n\nint operator /(int x, int y);\nuint operator /(uint x, uint y);\nlong operator /(long x, long y);\nulong operator /(ulong x, ulong y);\n\n如果右操作数的值为零，则引发 System.DivideByZeroException 导常。\n\n除法将结果舍入到零。因此，结果的绝对值是小于或等于两个操作数的商的绝对值的最大可能整数。当两个操作数符号相同时，结果为零或正；当两个操作数符号相反时，结果为零或负。\n\n如果左操作数为最小可表示 int 或 long 值，右操作数为 –1，则发生溢出。在 checked 上下文中，这会导致引发 System.ArithmeticException（或其子类）。在 unchecked 上下文中，它由实现定义为或者引发 System.ArithmeticException（或其子类），或者不以左操作数的结果值报告溢出。\n\n·    浮点除法：\n\nfloat operator /(float x, float y);\ndouble operator /(double x, double y);\n\n根据 IEEE 754 算法法则计算商。下表列出了非零有限值、零、无穷大和 NaN 的所有可能组合的结果。在该表中，x 和 y 是正有限值，z 是 x / y 的结果。如果结果对目标类型而言太大，则 z 为无穷大。如果结果对目标类型而言太小，则 z 为零。\n\n\n\n|      | +y   | –y   | +0   | –0   | +∞   | –∞   | NaN  |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| +x   | +z   | –z   | +∞   | –∞   | +0   | –0   | NaN  |\n| –x   | –z   | +z   | –∞   | +∞   | –0   | +0   | NaN  |\n| +0   | +0   | –0   | NaN  | NaN  | +0   | –0   | NaN  |\n| –0   | –0   | +0   | NaN  | NaN  | –0   | +0   | NaN  |\n| +∞   | +∞   | –∞   | +∞   | –∞   | NaN  | NaN  | NaN  |\n| –∞   | –∞   | +∞   | –∞   | +∞   | NaN  | NaN  | NaN  |\n| NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |\n\n\n\n·    小数除法：\n\ndecimal operator /(decimal x, decimal y);\n\n如果右操作数的值为零，则引发 System.DivideByZeroException 导常。如果结果值太大，不能用 decimal 格式表示，则将引发 System.OverflowException。如果结果值太小，无法用 decimal 格式表示，则结果为零。结果的小数位数是最小的小数位数，它保留等于最接近真实算术结果的可表示小数值的结果。\n\n小数除法等效于使用 System.Decimal 类型的除法运算符。\n\n### 余数运算符\n\n对于 x % y 形式的运算，应用二元运算符重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。\n\n下面列出了预定义的余数运算符。这些运算符均计算 x 除以 y 的余数。\n\n·    整数余数：\n\nint operator %(int x, int y);\nuint operator %(uint x, uint y);\nlong operator %(long x, long y);\nulong operator %(ulong x, ulong y);\n\nx % y 的结果是由 x – (x / y) * y 生成的值。如果 y 为零，则将引发 System.DivideByZeroException。\n\n如果左侧的操作数是最小的 int 或 long 值，且右侧的操作数是 -1，则将引发 System.OverflowException。只要 x % y 不引发异常，x / y 也不会引发异常。\n\n·    浮点余数：\n\nfloat operator %(float x, float y);\ndouble operator %(double x, double y);\n\n下表列出了非零有限值、零、无穷大和 NaN 的所有可能组合的结果。在该表中，x 和 y 是有限的正值。z 是 x % y 的结果，按照 x – n * y 进行计算，其中 n 是小于或等于 x / y 的最大可能整数。这种计算余数的方法类似于用于整数操作数的方法，但不同于 IEEE 754 定义（在此定义中，n 是最接近 x / y 的整数）。\n\n\n\n|      | +y   | –y   | +0   | –0   | +∞   | –∞   | NaN  |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| +x   | +z   | +z   | NaN  | NaN  | x    | x    | NaN  |\n| –x   | –z   | –z   | NaN  | NaN  | –x   | –x   | NaN  |\n| +0   | +0   | +0   | NaN  | NaN  | +0   | +0   | NaN  |\n| –0   | –0   | –0   | NaN  | NaN  | –0   | –0   | NaN  |\n| +∞   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |\n| –∞   | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |\n| NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |\n\n\n\n·    小数余数：\n\ndecimal operator %(decimal x, decimal y);\n\n如果右操作数的值为零，则引发 System.DivideByZeroException 导常。在进行任何舍入之前，结果的小数位数是两个操作数中较大的小数位数，而且结果的符号与 x 的相同（如果非零）。\n\n小数余数等效于使用 System.Decimal 类型的余数运算符。\n\n###  加法运算符\n\n对于 x + y 形式的运算，应用二元运算符重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。\n\n下面列出了预定义的加法运算符。对于数值和枚举类型，预定义的加法运算符计算两个操作数的和。当一个或两个操作数为 string 类型时，预定义的加法运算符把两个操作数的字符串表示形式串联起来。\n\n·    整数加法：\n\nint operator +(int x, int y);\nuint operator +(uint x, uint y);\nlong operator +(long x, long y);\nulong operator +(ulong x, ulong y);\n\n在 checked 上下文中，如果和超出结果类型的范围，则引发 System.OverflowException。在 unchecked 上下文中，不报告溢出并且结果类型范围外的任何有效高序位都被放弃。\n\n·    浮点加法：\n\nfloat operator +(float x, float y);\ndouble operator +(double x, double y);\n\n根据 IEEE 754 算术运算法则计算和。下表列出了非零有限值、零、无穷大和 NaN 的所有可能组合的结果。在该表中，x 和 y 是非零有限值，z 是 x + y 的结果。如果 x 和 y 的绝对值相同但符号相反，则 zz 为正零。如果 x + y 太大，不能用目标类型表示，则 z 是与 x + y 具有相同符号的无穷大。\n\n\n\n|      | y    | +0   | –0   | +∞   | –∞   | NaN  |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| x    | z    | x    | x    | +∞   | –∞   | NaN  |\n| +0   | y    | +0   | +0   | +∞   | –∞   | NaN  |\n| –0   | y    | +0   | –0   | +∞   | –∞   | NaN  |\n| +∞   | +∞   | +∞   | +∞   | +∞   | NaN  | NaN  |\n| –∞   | –∞   | –∞   | –∞   | NaN  | –∞   | NaN  |\n| NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |\n\n\n\n·    小数加法：\n\ndecimal operator +(decimal x, decimal y);\n\n如果结果值太大，不能用 decimal 格式表示，则将引发 System.OverflowException。在进行任何舍入之前，结果的小数位数是两个操作数中较大的小数位数。\n\n小数加法等效于使用 System.Decimal 类型的加法运算符。\n\n·    枚举加法。每个枚举类型都隐式提供下列预定义运算符，其中 E 为枚举类型，U 为 E 的基础类型：\n\nE operator +(E x, U y);\nE operator +(U x, E y);\n\n在运行时，这些运算符完全按 (E)((U)x + (U)y) 计算。\n\n·    字符串串联：\n\nstring operator +(string x, string y);\nstring operator +(string x, object y);\nstring operator +(object x, string y);\n\n这些二元 + 运算符的重载执行字符串串连。在字符串串联运算中，如果它的一个操作数为 null，则用空字符串来替换此操作数。否则，任何非字符串参数都通过调用从 object 类型继承的虚 ToString 方法，转换为它的字符串表示形式。如果 ToString 返回 null，则将替换成空字符串。\n\nusing System;\n\nclass Test\n{\nstatic void Main() {\nstring s = null;\nConsole.WriteLine(\"s = >\" + s + \"<\");   // displays s = ><\nint i = 1;\nConsole.WriteLine(\"i = \" + i);      // displays i = 1\nfloat f = 1.2300E+15F;\nConsole.WriteLine(\"f = \" + f);      // displays f = 1.23E+15\ndecimal d = 2.900m;\nConsole.WriteLine(\"d = \" + d);      // displays d = 2.900\n}\n}\n\n字符串串联运算符的结果是一个字符串，由左操作数的字符后接右操作数的字符组成。字符串串联运算符从不返回 null 值。如果没有足够的内存可用于分配得到的字符串，则可能引发 System.OutOfMemoryException。\n\n·    委托组合。每个委托类型都隐式提供以下预定义运算符，其中 D 是委托类型：\n\nD operator +(D x, D y);\n\n当两个操作数均为某个委托类型 D 时，二元 + 运算符执行委托组合。（如果操作数具有不同的委托类型，则发生绑定时错误。）如果第一个操作数为 null，则运算结果为第二个操作数的值（即使此操作数也为 null）。否则，如果第二个操作数为 null，则运算结果为第一个操作数的值。否则，运算结果是一个新委托实例，该实例在被调用时调用第一个操作数，然后调用第二个操作数。有关委托组合的示例，请参见第 ‎7.8.5 节和第 ‎15.4 节。由于 System.Delegate 不是委托类型，因此不为它定义 operator +。\n\n### 减法运算符\n\n对于 x – y 形式的运算，应用二元运算符重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。\n\n下面列出了预定义的减法运算符。这些运算符均从 x 中减去 y。\n\n·    整数减法：\n\nint operator –(int x, int y);\nuint operator –(uint x, uint y);\nlong operator –(long x, long y);\nulong operator –(ulong x, ulong y);\n\n在 checked 上下文中，如果差超出结果类型的范围，则引发 System.OverflowException。在 unchecked 上下文中，不报告溢出并且结果类型范围外的任何有效高序位都被放弃。\n\n·    浮点减法：\n\nfloat operator –(float x, float y);\ndouble operator –(double x, double y);\n\n根据 IEEE 754 算术运算法则计算差。下表列出了非零有限值、零、无穷大和 NaN 的所有可能组合的结果。在该表中，x 和 y 是非零有限值，z 是 x – y 的结果。如果 x 和 y 相等，则 z 为正零。如果 x – y 太大，不能用目标类型表示，则 z 是与 x – y 具有相同符号的无穷大。\n\n\n\n|      | y    | +0   | –0   | +∞   | –∞   | NaN  |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| x    | z    | x    | x    | –∞   | +∞   | NaN  |\n| +0   | –y   | +0   | +0   | –∞   | +∞   | NaN  |\n| –0   | –y   | –0   | +0   | –∞   | +∞   | NaN  |\n| +∞   | +∞   | +∞   | +∞   | NaN  | +∞   | NaN  |\n| –∞   | –∞   | –∞   | –∞   | –∞   | NaN  | NaN  |\n| NaN  | NaN  | NaN  | NaN  | NaN  | NaN  | NaN  |\n\n\n\n·    小数减法：\n\ndecimal operator –(decimal x, decimal y);\n\n如果结果值太大，不能用 decimal 格式表示，则将引发 System.OverflowException。在进行任何舍入之前，结果的小数位数是两个操作数中较大的小数位数。\n\n小数减法等效于使用 System.Decimal 类型的减法运算符。\n\n·    枚举减法。每个枚举类型都隐式提供下列预定义运算符，其中 E 为枚举类型，U 为 E 的基础类型：\n\nU operator –(E x, E y);\n\n此运算符严格按 (U)((U)x – (U)y) 计算。换言之，运算符计算 x 和 y 的序数值之间的差，结果类型是枚举的基础类型。\n\nE operator –(E x, U y);\n\n此运算符严格按 (E)((U)x – y) 计算。换言之，该运算符从枚举的基础类型中减去一个值，得到枚举的值。\n\n·    委托移除。每个委托类型都隐式提供以下预定义运算符，其中 D 是委托类型：\n\nD operator –(D x, D y);\n\n当两个操作数均为某个委托类型 D 时，二元 – 运算符执行委托移除。如果操作数具有不同的委托类型，则发生绑定时错误。如果第一个操作数为 null，则运算结果为 null。否则，如果第二个操作数为 null，则运算结果为第一个操作数的值。否则，两个操作数都表示包含一项或多项的调用列表（第 ‎15.1 节），并且只要第二个操作数列表是第一个操作数列表的适当的邻接子列表，那么结果就是从第一个操作数的调用列表中移除了第二个操作数的调用列表所含各项后的一个新调用列表。     （为确定子列表是否相等，用委托相等运算符（第 ‎7.10.8 节）比较相对应的项。）否则，结果为左操作数的值。在此过程中两个操作数的列表均未被更改。如果第二个操作数的列表与第一个操作数的列表中的多个邻接项子列表相匹配，则移除最右边的那个匹配邻接项的子列表。如果移除导致空列表，则结果为 null。例如：\n\n```c#\ndelegate void D(int x);\n\nclass C\n{\n public static void M1(int i) { /* … */ }\n public static void M2(int i) { /* … */ }\n}\n\nclass Test\n{\n static void Main()\n {\n     D cd1 = new D(C.M1);\n     D cd2 = new D(C.M2);\n     D cd3 = cd1 + cd2 + cd2 + cd1; // M1 + M2 + M2 + M1\n     cd3 -= cd1;              // => M1 + M2 + M2\n\n     cd3 = cd1 + cd2 + cd2 + cd1;    // M1 + M2 + M2 + M1\n     cd3 -= cd1 + cd2;         // => M2 + M1\n\n     cd3 = cd1 + cd2 + cd2 + cd1;    // M1 + M2 + M2 + M1\n     cd3 -= cd2 + cd2;         // => M1 + M1\n\n     cd3 = cd1 + cd2 + cd2 + cd1;    // M1 + M2 + M2 + M1\n     cd3 -= cd2 + cd1;         // => M1 + M2\n\n     cd3 = cd1 + cd2 + cd2 + cd1;    // M1 + M2 + M2 + M1\n     cd3 -= cd1 + cd1;         // => M1 + M2 + M2 + M1\n }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 关系和类型测试运算符\n\n==、!=、<、>、<=、>=、is 和 as 运算符称为关系和类型测试运算符。\n\n- relational-expression:\n  -  shift-expression\n  -  relational-expression  <  shift-expression\n  -  relational-expression  >  shift-expression\n  -  relational-expression  <=  shift-expression\n  -  relational-expression  >=  shift-expression\n  -  relational-expression  is  type\n  -  relational-expression  as  type\n- equality-expression:\n  - relational-expression\n  - equality-expression  ==  relational-expression\n  - equality-expression  !=  relational-expression\n\nis 和 as 运算符分别在第 ‎7.10.10 节和第 ‎7.10.11 节中说明。\n\n==、!=、<、>、<= 和 >= 运算符为比较运算符 (comparison operator)。\n\n如果比较运算符的某个操作数为编译时类型 dynamic，则表达式是动态绑定的（第 ‎7.2.2 节）。在此情况下，表达式的编译时类型为 dynamic，并且会在运行时使用具有编译时类型 dynamic 的操作数的运行时类型进行下面所述的决策。\n\n对于 `x op y` 形式（其中 op 为比较运算符）的运算，应用重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。\n\n预定义的比较运算符详见下面各节的介绍。所有预定义的比较运算符都返回 bool 类型的结果，详见下表。\n\n\n\n| **运算** | **结果**                                        |\n| -------- | ----------------------------------------------- |\n| x == y   | 如果 x 等于  y，则为  true，否则为 false        |\n| x != y   | 如果 x 不等于  y，则为  true，否则为 false      |\n| x <  y   | 如果 x 小于  y，则为  true，否则为 false        |\n| x >  y   | 如果 x 大于  y，则为  true，否则为 false        |\n| x <=  y  | 如果 x 小于或等于 y，则为  true，否则为 false   |\n| x >=  y  | 如果 x 大于或等于 y，则为  true，否则为 false   |\n| x is y   | 如果x的类型与y的类型一致，则为true，否则为false |\n\n\n\n### 比较运算符\n\n#### 整数比较运算符\n\n预定义的整数比较运算符为：\n\nbool operator ==(int x, int y);\n bool operator ==(uint x, uint y);\n bool operator ==(long x, long y);\n bool operator ==(ulong x, ulong y);\n\nbool operator !=(int x, int y);\n bool operator !=(uint x, uint y);\n bool operator !=(long x, long y);\n bool operator !=(ulong x, ulong y);\n\nbool operator <(int x, int y);\n bool operator <(uint x, uint y);\n bool operator <(long x, long y);\n bool operator <(ulong x, ulong y);\n\nbool operator >(int x, int y);\n bool operator >(uint x, uint y);\n bool operator >(long x, long y);\n bool operator >(ulong x, ulong y);\n\nbool operator <=(int x, int y);\n bool operator <=(uint x, uint y);\n bool operator <=(long x, long y);\n bool operator <=(ulong x, ulong y);\n\nbool operator >=(int x, int y);\n bool operator >=(uint x, uint y);\n bool operator >=(long x, long y);\n bool operator >=(ulong x, ulong y);\n\n这些运算符都比较两个整数操作数的数值并返回一个 bool 值，该值指示特定的关系是 true 还是 false。\n\n#### 浮点比较运算符\n\n预定义的浮点比较运算符为：\n\nbool operator ==(float x, float y);\n bool operator ==(double x, double y);\n\nbool operator !=(float x, float y);\n bool operator !=(double x, double y);\n\nbool operator <(float x, float y);\n bool operator <(double x, double y);\n\nbool operator >(float x, float y);\n bool operator >(double x, double y);\n\nbool operator <=(float x, float y);\n bool operator <=(double x, double y);\n\nbool operator >=(float x, float y);\n bool operator >=(double x, double y);\n\n这些运算符根据 IEEE 754 标准法则比较操作数：\n\n·    如果两个操作数中的任何一个为 NaNN，则对于除 !=（对于此运算符，结果为 true）外的所有运算符，结果均为 false。对于任何两个操作数，x != y 始终生成与 !(x == y) 相同的结果。然而，当一个操作数或两个操作数为 NaN 时，<、>、<= 和 >= 运算符不产生与其对应的反向运算符的逻辑否定相同的结果。例如，如果 x 和 y 中的任何一个为 NaN，则 x < y 为 false，而 !(x >= y) 为 true。\n\n·    当两个操作数都不为 NaN 时，这些运算符就按下列顺序来比较两个浮点操作数的值\n\n–∞ < –max < ... < –min < –0.0 == +0.0 < +min < ... < +max < +∞\n\n这里的 min 和 max 是可以用给定浮点格式表示的最小和最大正有限值。这样排序的显著特点是：\n\no  负零和正零被视为相等。\n\no  负无穷大被视为小于所有其他值，但等于其他负无穷大。\n\no  正无穷大被视为大于所有其他值，但等于其他正无穷大。\n\n#### 小数比较运算符\n\n预定义的小数比较运算符为：\n\nbool operator ==(decimal x, decimal y);\n\nbool operator !=(decimal x, decimal y);\n\nbool operator <(decimal x, decimal y);\n\nbool operator >(decimal x, decimal y);\n\nbool operator <=(decimal x, decimal y);\n\nbool operator >=(decimal x, decimal y);\n\n这些运算符都比较两个 decimal 操作数的数值并返回一个 bool 值，该值指示特定的关系是 true 还是 false。各小数比较等效于使用 System.Decimal 类型的相应关系运算符或相等运算符。\n\n#### 布尔相等运算符\n\n预定义的布尔相等运算符为：\n\nbool operator ==(bool x, bool y);\n\nbool operator !=(bool x, bool y);\n\n如果 x 和 y 都为 true，或者如果 x 和 y 都为 false，则 == 的结果为 true。否则，结果为 false。\n\n如果 x 和 y 都为 true，或者如果 x 和 y 都为 false，则 != 的结果为 false。否则，结果为 true。当操作数为 bool 类型时，!= 运算符产生与 ^ 运算符相同的结果。\n\n#### 枚举比较运算符\n\n每种枚举类型都隐式提供下列预定义的比较运算符：\n\nbool operator ==(E x, E y);\n\nbool operator !=(E x, E y);\n\nbool operator <(E x, E y);\n\nbool operator >(E x, E y);\n\nbool operator <=(E x, E y);\n\nbool operator >=(E x, E y);\n\nx op y（其中 x 和 y 是具有基础类型 U 的枚举类型 E 的表达式，op 是一个比较运算符）的计算结果与 (E)((U)x) op ((U)y) 的计算结果完全相同。换言之，枚举类型比较运算符只比较两个操作数的基础整数值。\n\n#### 引用类型相等运算符\n\n预定义的引用类型相等运算符为：\n\nbool operator ==(object x, object y);\n\nbool operator !=(object x, object y);\n\n这些运算符返回两个引用是相等还是不相等的比较结果。\n\n由于预定义的引用类型相等运算符接受 object 类型的操作数，因此它们适用于所有那些没有为自己声明适用的 operator == 和 operator != 成员的类型。相反，任何适用的用户定义的相等运算符都有效地隐藏上述预定义的引用类型相等运算符。\n\n预定义的引用类型相等运算符要求满足以下条件之一：\n\n·    两个操作数均为已知的 reference-type 类型的值或文本 null。此外，存在从其中一个操作数的类型到另一个操作数的类型的显式引用转换（第 ‎6.2.4 节）。\n\n·    一个操作数是类型为 T 的值，其中 T 为 type-parameter，另一个操作数为文本 null。此外，T 不具有值类型约束。\n\n除非满足以下这些条件之一，否则将发生绑定时错误。这些规则中值得注意的含义是：\n\n·    使用预定义的引用类型相等运算符比较两个在绑定时已能确定是不相同的引用时，会导致绑定时错误。例如，如果操作数的绑定时类型是两种类类型 A 和 B，并且如果 A 和 B 都不是从对方派生的，则两个操作数不可能引用同一对象。因此，此运算被认为是绑定时错误。\n\n·    预定义的引用类型相等运算符不允许比较值类型操作数。因此，除非结构类型声明自己的相等运算符，否则不可能比较该结构类型的值。\n\n·    预定义的引用类型相等运算符从不会导致对它们的操作数执行装箱操作。执行此类装箱操作毫无意义，这是因为对新分配的已装箱实例的引用必将不同于所有其他引用。\n\n·    如果将类型参数类型 T 的操作数与 null进行比较，并且 T 的运行时类型为值类型，则比较结果为 false。\n\n下面的示例检查未受约束的类型形参类型的实参是否为 null。\n\n\n\n虽然 T 可能表示值类型，但是 x == null 构造是允许的，当 T 为值类型时，结果只是被定义为 false。\n\n对于 x == y 或 x != y 形式的运算，如果存在任何适用的 operator == 或 operator !=，则运算符重载决策（第 ‎7.3.4 节）规则将选择该运算符而不是上述的预定义的引用类型相等运算符。不过，始终可以通过将一个或两个操作数显式强制转换为 object 类型来选择预定义的引用类型相等运算符。下面的示例\n\n```c#\nusing System;\n\nclass Test\n{\n    static void Main()\n    {\n        string s = \"Test\";\n        string t = string.Copy(s);\n        Console.WriteLine(s == t);\n        Console.WriteLine((object)s == t);\n        Console.WriteLine(s == (object)t);\n        Console.WriteLine((object)s == (object)t);\n    }\n}\n```\n\n产生输出\n\nTrue\n False\n False\n False\n\n变量 s 和 t 引用两个包含相同字符的不同 string 实例。第一个比较输出 True，原因是当两个操作数都为 string 类型时选择了预定义的字符串相等运算符（第 ‎7.10.7 节）。其余的比较全都输出 False，这是因为是在一个或两个操作数为 object 类型时选定预定义的引用类型相等运算符。\n\n注意，以上技术对值类型没有意义。下面的示例\n\n```c#\nclass Test\n{\n    static void Main()\n    {\n        int i = 123;\n        int j = 123;\n        System.Console.WriteLine((object)i == (object)j);\n    }\n}\n```\n\n输出 False，这是因为强制转换创建对已装箱 int 值的两个单独实例的引用。\n\n#### 字符串相等运算符\n\n预定义的字符串相等运算符为：\n\nbool operator ==(string x, string y);\n\nbool operator !=(string x, string y);\n\n当下列条件中有一个为真时，两个 string 值被视为相等：\n\n·    两个值都为 null。\n\n·    两个值都是对字符串实例的非空引用，这两个字符串不仅具有相同的长度，而且在每个字符位置上的字符亦都彼此相同。\n\n字符串相等运算符比较的是字符串值而不是对字符串的引用。当两个单独的字符串实例包含完全相同的字符序列时，字符串的值相等，但引用不相同。正如第 ‎7.10.6 节中所描述的那样，引用类型相等运算符可用于比较字符串引用而不是字符串值。\n\n#### 委托相等运算符\n\n每个委托类型都隐式地提供下列预定义的比较运算符：\n\nbool operator ==(System.Delegate x, System.Delegate y);\n\nbool operator !=(System.Delegate x, System.Delegate y);\n\n两个委托实例按下面这样被视为相等：\n\n·    如果两个委托实例中有一个为 null，则当且仅当它们都为 null 时相等。\n\n·    具有不同运行时类型的委托永远不相等。\n\n·    如果两个委托实例都具有调用列表（第 ‎15.1) 节），则当且仅当它们的调用列表长度相同，并且一个实例的调用列表中的每项依次等于（如下面的定义）另一个的调用列表中的相应项时，这两个委托实例相等。\n\n以下规则控制调用列表项的相等性：\n\n·    如果两个调用列表项都引用同一静态方法，则这两项相等。\n\n·    如果两个调用列表项都引用同一个目标对象（引用相等运算符定义的目标对象）上的同一个非静态方法，则这两个调用列表项相等。\n\n·    允许（但不要求）具有相同被捕获外层变量实例集（可能为空集）且语义上相同的  anonymous-function-expression 计算生成的调用列表项相等。\n\n#### 相等运算符和 null\n\n== 和 != 运算符允许一个操作数是可为 null 的类型的值，另一个是 null 文本，即使运算中不存在预定义或用户定义的运算符（未提升或提升形式）。\n\n对于下面某个形式的操作\n\nx == null  null == x  x != null  null != x\n\n其中 x 是可为 null 的类型的表达式，如果运算符重载决策（第 7.2.4 节）未能找到适用的运算符，则改为从 x 的 HasValue 属性计算结果。具体而言，前两种形式将转换为 !x.HasValue，后两种形式将转换为 x.HasValue。\n\n#### is 运算符\n\nis 运算符用于动态检查对象的运行时类型是否与给定类型兼容。E is T 运算（其中 E 为表达式，T 为类型）的结果是布尔值，表示 E 的类型是否可通过引用转换、装箱转换或取消装箱转换而成功转换为类型 T。使用类型实参替换了所有类型形参后，按如下方式计算该运算：\n\n- 如果 E 是匿名函数，将发生编译时错误\n\n- 如果 E 是方法组或 null 文本，或者如果 E 的类型是引用类型或可为 null 的类型并且 E 的值为 null，则结果为 false。\n\n- 否则，根据下列规则让 D 表示 E 的动态类型：\n\n- 如果 E 的类型为引用类型，则 D 为 E 引用的实例的运行时类型。\n\n- 如果 E 的类型为可以为 null 的类型，则 D 为该可以为 null 的类型的基础类型。\n\n- 如果 E 的类型为不可以为 null 值的类型，则 D 为 E 的类型。\n\n- 该操作的结果取决于 D 和 T，具体如下：\n\n  - 如果 T 为引用类型，那么，在以下情况下结果为 true：D 和 T 为相同类型，或者 D 为引用类型并且存在从 D 到 T 的隐式引用转换，或者 D 为值类型并且存在从 D 到 T 的装箱转换。\n\n  - 如果 T 为可以为 null 的类型，那么，当 D 为 T 的基础类型时结果为 true。\n\n  - 如果 T 为不可以为 null 值的类型，那么，如果 D 和 T 为相同类型，则结果为 true。\n\n  - 否则，结果为 false。\n\n    \n\n请注意，用户定义的转换不在 is 运算符考虑之列。\n\n### as 运算符\n\nas 运算符用于将一个值显式转换为一个给定的引用类型或可为 null 的类型。与强制转换表达式不同，**as 运算符从不引发异常**。它采用的是：如果指定的转换不可能实施，则运算结果为 null。\n\n在 `E as T` 形式的操作中，E 必须为表达式，T 必须为引用类型、已知为引用类型的类型参数或可以为 null 的类型。此外，下列条件中必须至少有一条成立，否则会发生编译时错误：\n\n·    存在从 E 到 T 的以下类型转换：标识（第 6.1.1 节）、隐式可以为 null（第 ‎6.1.4 节）、隐式引用（第 ‎6.1.6 节）、装箱（第 ‎6.1.7 节）、显式可以为 null（第 ‎6.2.3 节）、显式引用（第 ‎6.2.4 节）或取消装箱（第 ‎6.2.5 节）转换。\n\n·    E 或 T 的类型为开放类型。\n\n·    E 为 null 文本。\n\n如果 E 的编译时类型不是 dynamic，则运算 E as T 将生成与下面的计算相同的结果\n\n`E is T ? (T)(E) : (T)null`\n\n不同的只是：实际执行中 E 只计算一次。编译器应该优化 E as T 以最多执行一次动态类型检查，而不是上面的扩展隐含的两次动态类型检查。\n\n如果 E 的编译时类型为 dynamic，则与强制转换运算符不同，as 运算符不是动态绑定的（第 ‎7.2.2 节）。因此这种情况下的扩展为：\n\n`E is T ? (T)(object)(E) : (T)null`\n\n请注意，不能使用 as 运算符执行某些转换（如用户定义的转换），应改为使用强制转换表达式来执行这些转换。\n\n在下面的示例中\n\n```c#\nusing System;\n\nclass X\n{\n\n    public string F(object o)\n    {\n        return o as string;   // OK, string is a reference type\n    }\n\n    public T G<T>(object o) where T : Attribute\n    {\n        return o as T;       // Ok, T has a class constraint\n    }\n\n    public U H<U>(object o)\n    {\n        return o as U;       // Error, U is unconstrained \n    }\n}\n```\n\nG 的类型参数 T 已知为引用类型，原因是它有类约束。但 H 的类型参数 U 不是；因此，不允许在 H 中使用 as 运算符。\n\n\n\n\n\n\n\n\n\n\n\n### 逻辑运算符\n\n下表显示了 C# 支持的所有逻辑运算符。假设变量 A 为布尔值 true，变量 B 为布尔值 false，则：\n\n| 运算符 | 描述                                                         | 实例              |\n| :----- | :----------------------------------------------------------- | :---------------- |\n| &&     | 称为逻辑与运算符。如果两个操作数都非零，则条件为真。         | (A && B) 为假。   |\n| \\|\\|   | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 | (A \\|\\| B) 为真。 |\n| !      | 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 | !(A && B) 为真。  |\n\n\n\n> ## 1.1 条件逻辑运算符\n>\n> && 和 || 运算符称为条件逻辑运算符。也称为“短路”逻辑运算符。\n>\n> conditional-and-expression:\n> inclusive-or-expression\n> conditional-and-expression  &&  inclusive-or-expression\n>\n> conditional-or-expression:\n> conditional-and-expression\n> conditional-or-expression  ||  conditional-and-expression\n>\n> && 和 || 运算符是 & 和 | 运算符的条件版本：\n>\n> ·    x && y 运算对应于 x & y 运算，但仅当 x 不为 false 时才计算 y。\n>\n> ·    x || y 运算对应于 x | y 运算，但仅当 x 不为 true 时才计算 y。\n>\n> 如果条件逻辑运算符的某个操作数具有编译时类型 dynamic，则表达式是动态绑定的（第 ‎7.2.2 节）。在此情况下，表达式的编译时类型为 dynamic，并且会在运行时使用具有编译时类型 dynamic 的操作数的运行时类型进行下面所述的决策。\n>\n> x && y 或 x || y 形式的运算通过应用重载决策（第 ‎7.3.4 节）来处理，就好比运算的书写形式为 x & y 或 x | y。然后，\n>\n> ·    如果重载决策未能找到单个最佳运算符，或者重载决策选择一个预定义的整数逻辑运算符，则发生绑定时错误。\n>\n> ·    否则，如果选定的运算符是一个预定义的布尔逻辑运算符（第 ‎7.11.3 节）或可以为 null 的布尔逻辑运算符（第 ‎7.11.4 节），则运算按第 ‎7.12.1 节中所描述的那样进行处理。\n>\n> ·    否则，选定的运算符为用户定义的运算符，且运算按第 ‎7.12.2 节中所描述的那样进行处理。\n>\n> 不可能直接重载条件逻辑运算符。不过，由于条件逻辑运算符按通常的逻辑运算符计算，因此通常的逻辑运算符的重载，在某些限制条件下，也被视为条件逻辑运算符的重载。第 ‎7.12.2 节对此有进一步描述。\n>\n> ### 1.1.1 布尔条件逻辑运算符\n>\n> 当 && 或 || 的操作数为 bool 类型时，或者当操作数的类型本身未定义适用的 operator & 或 operator |，但确实定义了到 bool 的隐式转换时，运算按下面这样处理：\n>\n> ·    运算 x && y 的求值过程相当于 x ? y : false。换言之，首先计算 x 并将其转换为 bool 类型。如果 x 为 true，则计算 y 并将其转换为 bool 类型，并且这成为运算结果。否则，运算结果为 false。\n>\n> ·    运算 x || y 的求值过程相当于 x ? true : y。换言之，首先计算 x 并将其转换为 bool 类型。然后，如果 x 为 true，则运算结果为 true。否则，计算 y 并将其转换为 bool 类型，并且这作为运算结果。\n>\n> ### 1.1.2 用户定义的条件逻辑运算符\n>\n> 当 && 或 || 的操作数所属的类型声明了适用的用户定义的 operator & 或 operator | 时，下列两个条件必须都为真（其中 T 是声明的选定运算符的类型）：\n>\n> ·    选定运算符的返回类型和每个参数的类型都必须为 T。换言之，该运算符必须计算类型为 T 的两个操作数的逻辑 AND 或逻辑 OR，且必须返回类型为 T 的结果。\n>\n> ·    T 必须包含 operator true 和 operator false 的声明。\n>\n> 如果这两个要求中有一个未满足，则发生绑定时错误。如果这两个要求都满足，则通过将用户定义的 operator true 或 operator false 与选定的用户定义的运算符组合在一起来计算 && 运算或 || 运算：\n>\n> ·    x && y 运算按 T.false(x) ? x : T.&(x, y) 进行计算，其中 T.false(x) 是 T 中声明的 operator false 的调用，T.&(x, y) 是选定 operator & 的调用。换言之，首先计算 x，然后对结果调用 operator false 以确定 x 是否肯定为 false。如果 x 肯定为假，则运算结果为先前为 x 计算的值。否则将计算 y，并对先前为 x 计算的值和为 y 计算的值调用选定的 operator & 以产生运算结果。\n>\n> ·    x || y 运算按 T.true(x) ? x : T.|(x, y) 进行计算，其中 T.true(x) 是 T 中声明的 operator true 的调用，T.|(x, y) 是选定 operator | 的调用。换言之，首先计算 x，然后对结果调用 operator true 以确定 x 是否肯定为 true。然后，如果 x 肯定为真，则运算结果为先前为 x 计算的值。否则将计算 y，并对先前为 x 计算的值和为 y 计算的值调用选定的 operator | 以产生运算结果。\n>\n> 在这两个运算中，x 给定的表达式只计算一次，y 给定的表达式要么不计算，要么只计算一次。\n>\n> 有关实现了 operator true 和 operator false 的类型的示例，请参见第 ‎11.4.2 节。\n\n\n\n\n\n### 位运算符\n\n位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：\n\n| p    | q    | p & q | p \\| q | p ^ q |\n| :--- | :--- | :---- | :----- | :---- |\n| 0    | 0    | 0     | 0      | 0     |\n| 0    | 1    | 0     | 1      | 1     |\n| 1    | 1    | 1     | 1      | 0     |\n| 1    | 0    | 0     | 1      | 1     |\n\n假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：\n\nA = 0011 1100\n\nB = 0000 1101\n\n\\-----------------\n\nA&B = 0000 1100\n\nA|B = 0011 1101\n\nA^B = 0011 0001\n\n~A = 1100 0011\n\n下表列出了 C# 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：\n\n| 运算符 | 描述                                                         | 实 例                                                        |\n| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| &      | 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。 | (A & B) 将得到 12，即为 0000 1100                            |\n| \\|     | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。   | (A \\| B) 将得到 61，即为 0011 1101                           |\n| ^      | 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。 | (A ^ B) 将得到 49，即为 0011 0001                            |\n| ~      | 按位取反运算符是一元运算符，具有\"翻转\"位效果，即0变成1，1变成0，包括符号位。 | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |\n| <<     | 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。   | A << 2 将得到 240，即为 1111 0000                            |\n| >>     | 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。   | A >> 2 将得到 15，即为 0000 1111                             |\n\n左移不管是正数还是负数，补的数都是0；\n\n右移：如果正在操作的数是证书的话，最高位补入0；如果是负数则补入1\n\n\n\n\n\n> ## 1.1 逻辑运算符\n>\n> &、^ 和 | 运算符称为逻辑运算符。\n>\n> and-expression:\n> equality-expression\n> and-expression  &  equality-expression\n>\n> exclusive-or-expression:\n> and-expression\n> exclusive-or-expression  ^  and-expression\n>\n> inclusive-or-expression:\n> exclusive-or-expression\n> inclusive-or-expression  |  exclusive-or-expression\n>\n> 如果逻辑运算符的某个操作数具有编译时类型 dynamic，则表达式是动态绑定的（第 ‎7.2.2 节）。在此情况下，表达式的编译时类型为 dynamic，并且会在运行时使用具有编译时类型 dynamic 的操作数的运行时类型进行下面所述的决策。\n>\n> 对于 x op y 形式的运算（其中 op 为一个逻辑运算符），应用重载决策（第 ‎7.3.4 节）以选择一个特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。\n>\n> 下列章节介绍了预定义的逻辑运算符。\n>\n> ### 1.1.1 整数逻辑运算符\n>\n> 预定义的整数逻辑运算符为：\n>\n> int operator &(int x, int y);\n> uint operator &(uint x, uint y);\n> long operator &(long x, long y);\n> ulong operator &(ulong x, ulong y);\n>\n> int operator |(int x, int y);\n> uint operator |(uint x, uint y);\n> long operator |(long x, long y);\n> ulong operator |(ulong x, ulong y);\n>\n> int operator ^(int x, int y);\n> uint operator ^(uint x, uint y);\n> long operator ^(long x, long y);\n> ulong operator ^(ulong x, ulong y);\n>\n> & 运算符计算两个操作数的按位逻辑 AND，| 运算符计算两个操作数的按位逻辑 OR，而 ^ 运算符计算两个操作数的按位逻辑 XOR。这些运算不可能产生溢出。\n>\n> ### 1.1.2 枚举逻辑运算符\n>\n> 每个枚举类型 E 都隐式地提供下列预定义的逻辑运算符：\n>\n> E operator &(E x, E y);\n> E operator |(E x, E y);\n> E operator ^(E x, E y);\n>\n> x op y（其中 x 和 y 是具有基础类型 U 的枚举类型 E 的表达式，op 是一个逻辑运算符）的计算结果与 (E)((U)x op (U)y) 的计算结果完全相同。换言之，枚举类型逻辑运算符直接对两个操作数的基础类型执行逻辑运算。\n>\n> ### 1.1.3 布尔逻辑运算符\n>\n> 预定义的布尔逻辑运算符为：\n>\n> bool operator &(bool x, bool y);\n>\n> bool operator |(bool x, bool y);\n>\n> bool operator ^(bool x, bool y);\n>\n> 如果 x 和 y 均为 true，则 x & y 的结果为 true。否则，结果为 false。\n>\n> 如果 x 或 y 为 true，则 x | y 的结果为 true。否则，结果为 false。\n>\n> 如果 x 为 true 且 y 为 false，或者 x 为 false 且 y 为 true，则 x ^ y 的结果为 true。否则，结果为 false。当操作数为 bool 类型时，^ 运算符计算结果与 != 运算符相同。\n>\n> ### 1.1.4 可以为 null 的布尔逻辑运算符\n>\n> 可以为 null 的布尔类型 bool? 可表示三个值 true、false 和 null，并且在概念上类似于 SQL 中的布尔表达式的三值类型。为了确保针对 bool? 操作数的 & 和 | 运算符产生的结果与 SQL 的三值逻辑一致，提供了下列预定义运算符：\n>\n> bool? operator &(bool? x, bool? y);\n>\n> bool? operator |(bool? x, bool? y);\n>\n> 下表列出了这些运算符对 true、false 和 null 值的所有组合所产生的结果。\n>\n> \n>\n> | x     | y     | x & y | x \\| y |\n> | ----- | ----- | ----- | ------ |\n> | true  | true  | true  | true   |\n> | true  | false | false | true   |\n> | true  | null  | null  | true   |\n> | false | true  | false | true   |\n> | false | false | false | false  |\n> | false | null  | false | null   |\n> | null  | true  | null  | true   |\n> | null  | false | false | null   |\n> | null  | null  | null  | null   |\n>\n> ###  1.2 移位运算符\n>\n> << 和 >> 运算符用于执行移位运算。\n>\n> shift-expression:\n> additive-expression \n> shift-expression  <<  additive-expression\n> shift-expression  right-shift  additive-expression\n>\n> 如果 shift-expression 的某个操作数具有编译时类型 dynamic，则表达式是动态绑定的（第 ‎7.2.2 节）。在此情况下，表达式的编译时类型为 dynamic，并且会在运行时使用具有编译时类型 dynamic 的操作数的运行时类型进行下面所述的决策。\n>\n> 对于 x << count 或 x >> count 形式的运算，应用二元运算符重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。\n>\n> 当声明重载移位运算符时，第一个操作数的类型必须总是包含运算符声明的类或结构，并且第二个操作数的类型必须总是 int。\n>\n> 下面列出了预定义的移位运算符。\n>\n> ·    左移位：\n>\n> int operator <<(int x, int count);\n> uint operator <<(uint x, int count);\n> long operator <<(long x, int count);\n> ulong operator <<(ulong x, int count);\n>\n> << 运算符将 x 向左位移若干个位，具体计算方法如下所述。\n>\n> 放弃 x 中经移位后会超出结果类型范围的那些高序位，将其余的位向左位移，将空出来的低序位均设置为零。\n>\n> ·    右移位：\n>\n> int operator >>(int x, int count);\n> uint operator >>(uint x, int count);\n> long operator >>(long x, int count);\n> ulong operator >>(ulong x, int count);\n>\n> \\>> 运算符将 x 向右位移若干个位，具体计算方法如下所述。\n>\n> 当 x 为 int 或 long 类型时，放弃 x 的低序位，将剩余的位向右位移，如果 x 非负，则将高序空位位置设置为零，如果 x 为负，则将其设置为 1。\n>\n> 当 x 为 uint 或 ulong 类型时，放弃 x 的低序位，将剩余的位向右位移，并将高序空位位置设置为零。\n>\n> 对于预定义运算符，位移的位数按下面这样计算：\n>\n> ·    当 x 的类型为 int 或 uint 时，位移计数由 count 的低序的 5 位给出。换言之，位移计数由 count & 0x1F 计算出。\n>\n> ·    当 x 的类型为 long 或 ulong 时，位移计数由 count 的低序的 6 位给出。换言之，位移计数由 count & 0x3F 计算出。\n>\n> 如果计算位移计数的结果为零，则移位运算符只返回 x 的值。\n>\n> 移位运算从不会导致溢出，并且在 checked 和 unchecked 上下文中产生的结果相同。\n>\n> 当 >> 运算符的左操作数为有符号的整型时，该运算符执行算术右移位，在此过程中，操作数的最有效位（符号位）的值扩展到高序空位位置。当 >> 运算符的左操作数为无符号的整型时，该运算符执行逻辑右移位，在此过程中，高序空位位置总是设置为零。若要执行与由操作数类型确定的不同的移位运算，可以使用显式强制转换。例如，如果 x 是 int 类型的变量，则 unchecked((int)((uint)x >> y)) 运算执行 x 的逻辑右移位。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 赋值运算符\n\n下表列出了 C# 支持的赋值运算符：\n\n| 运算符 | 描述                                                         | 实例                            |\n| :----- | :----------------------------------------------------------- | :------------------------------ |\n| =      | 简单的赋值运算符，把右边操作数的值赋给左边操作数             | C = A + B 将把 A + B 的值赋给 C |\n| +=     | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |\n| -=     | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |\n| *=     | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A         |\n| /=     | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |\n| %=     | 求模且赋值运算符，求两个操作数的模赋值给左边操作数           | C %= A 相当于 C = C % A         |\n| <<=    | 左移且赋值运算符                                             | C <<= 2 等同于 C = C << 2       |\n| >>=    | 右移且赋值运算符                                             | C >>= 2 等同于 C = C >> 2       |\n| &=     | 按位与且赋值运算符                                           | C &= 2 等同于 C = C & 2         |\n| ^=     | 按位异或且赋值运算符                                         | C ^= 2 等同于 C = C ^ 2         |\n| \\|=    | 按位或且赋值运算符                                           | C \\|= 2 等同于 C = C \\| 2       |\n\n\n\n\n\n> ## 1.1 赋值运算符\n>\n> 赋值运算符为变量、属性、事件或索引器元素赋新值。\n>\n> assignment:\n> unary-expression  assignment-operator  expression\n>\n> assignment-operator:\n> =\n>\n> +=\n> -=\n>\n> *=\n> /=\n> %=\n> &=\n> |=\n> ^=\n> <<=\n> right-shift-assignment\n>\n> 赋值的左操作数必须是属于变量、属性访问、索引器访问或事件访问类别的表达式。\n>\n> = 运算符称为简单赋值运算符。它将右操作数的值赋予左操作数给定的变量、属性或索引器元素。简单赋值运算符的左操作数一般不可以是一个事件访问（第 ‎10.8.1 节中描述的例外）。简单赋值运算符的介绍详见第 ‎7.17.1 节。\n>\n> 除 = 运算符以外的赋值运算符称为复合赋值运算符 (compound assignment operator)。这些运算符对两个操作数执行指示的运算，然后将结果值赋予左操作数指定的变量、属性或索引器元素。复合赋值运算符的介绍详见第 ‎7.17.2 节。\n>\n> 以事件访问表达式作为左操作数的 += 和 -= 运算符称为事件赋值运算符。当左操作数是事件访问时，其他赋值运算符都是无效的。事件赋值运算符的介绍详见第 ‎7.17.3 节。\n>\n> 赋值运算符为向右关联，即此类运算从右到左分组。例如，a = b = c 形式的表达式可以按 a = (b = c) 进行计算。\n>\n> ### 1.1.1 简单赋值\n>\n> = 运算符称为简单赋值运算符。\n>\n> 如果简单赋值的左操作数为 E.P 或 E[Ei] 形式，其中 E 具有编译时类型 dynamic，则赋值是动态绑定的（第 ‎7.2.2 节）。在此情况下，赋值表达式的编译时类型为 dynamic，并且会在运行时基于 E 的运行时类型进行下面所述的决策。\n>\n> 在简单赋值中，右操作数必须为可以隐式转换为左操作数所属类型的表达式。运算将右操作数的值赋予左操作数指定的变量、属性或索引器元素。\n>\n> 简单赋值表达式的结果是赋予左操作数的值。结果的类型与左操作数相同，且始终为值类别。\n>\n> 如果左操作数为属性或索引器访问，则该属性或索引器必须具有 set 访问器。如果不是这样，则发生绑定时错误。\n>\n> x = y 形式的简单赋值的运行时处理包括以下步骤：\n>\n> - 如果 x 属于变量：\n>   - 计算 x 以产生变量。\n>   - 计算 y，必要时还需通过隐式转换（第 ‎6.1 节）将其转换为 x 的类型。\n>   - 如果 x给定的变量是 reference-type 的数组元素，则执行运行时检查以确保为 y 计算的值与以 x 为其元素的那个数组实例兼容。如果 y 为 null，或存在从 y 引用的实例的实际类型到包含 x 的数组实例的实际元素类型的隐式引用转换（第 ‎6.1.6 节），则检查成功。否则，将引发 System.ArrayTypeMismatchException。\n>   - y 的计算和转换后所产生的值存储在 x 的计算所确定的位置中。\n> - 如果 x 属于属性或索引器访问：\n>   - 计算与 x 关联的实例表达式（如果 x 不是 static）和参数列表（如果 x 是索引器访问），结果用于后面的对和 set 访问器调用。\n>   - 计算 y，必要时还需通过隐式转换（第 ‎6.1 节）将其转换为 x 的类型。\n>   - 使用针对 y 计算的值作为 value 参数调用 x 的 set 访问器。\n>\n> 如果存在从 B 到 A 的隐式引用转换，则数组协变规则（第 ‎12.5 节）允许数组类型 A[] 的值是对数组类型 B[] 的实例的引用。由于这些规则，对 reference-type 的数组元素的赋值需要运行时检查以确保所赋的值与数组实例兼容。在下面的示例中\n>\n> ```c#\n> using System.Collections;\n> \n> string[] sa = new string[10];\n> object[] oa = sa;\n> \n> oa[0] = null;        // Ok\n> oa[1] = \"Hello\";       // Ok\n> oa[2] = new ArrayList(); // ArrayTypeMismatchException\n> ```\n>\n> 最后的赋值将导致引发 System.ArrayTypeMismatchException，这是因为 ArrayList 的实例不能存储在 string[] 的元素中。\n>\n> 当 struct-type 中声明的属性或索引器是赋值的目标时，与属性或索引器访问关联的实例表达式必须为变量类别。如果该实例表达式归类为值类别，则发生绑定时错误。由于第 ‎7.6.4 节中所说明的原因，同样的规则也适用于字段。\n>\n> 给定下列声明：\n>\n> ```c#\n> struct Point\n> {\n>     int x, y;\n> \n>     public Point(int x, int y)\n>     {\n>         this.x = x;\n>         this.y = y;\n>     }\n> \n>     public int X\n>     {\n>         get { return x; }\n>         set { x = value; }\n>     }\n> \n>     public int Y\n>     {\n>         get { return y; }\n>         set { y = value; }\n>     }\n> }\n> \n> struct Rectangle\n> {\n>     Point a, b;\n> \n>     public Rectangle(Point a, Point b)\n>     {\n>         this.a = a;\n>         this.b = b;\n>     }\n> \n>     public Point A\n>     {\n>         get { return a; }\n>         set { a = value; }\n>     }\n> \n>     public Point B\n>     {\n>         get { return b; }\n>         set { b = value; }\n>     }\n> }\n> ```\n>\n> 在下面的示例中\n>\n> ```c#\n> using System.Windows.Shapes;\n> \n> Point p = new Point();\n> p.X = 100;\n> p.Y = 100;\n> Rectangle r = new Rectangle();\n> r.A = new Point(10, 10);\n> r.B = p;\n> ```\n>\n> 由于 p 和 r 为变量，因此允许对 p.X、p.Y、r.A 和 r.B 进行赋值。但是，在以下示例中\n>\n> ```c#\n> Rectangle r = new Rectangle();\n>  r.A.X = 10;\n>  r.A.Y = 10;\n>  r.B.X = 100;\n>  r.B.Y = 100;\n> ```\n>\n> 由于 r.A 和 r.B 不是变量，因此赋值全部无效。\n>\n> ### 1.1.2 复合赋值\n>\n> 如果复合赋值的左操作数为 E.P 或 E[Ei] 形式，其中 E 具有编译时类型 dynamic，则赋值为动态绑定的（第 ‎7.2.2 节）。在此情况下，赋值表达式的编译时类型为 dynamic，并且会在运行时基于 E 的运行时类型进行下面所述的决策。\n>\n> x op= y 形式的运算是这样来处理的：应用重载决策（第 ‎7.3.4 节），就好比运算的书写形式为 x op y。然后，\n>\n> ·    如果选定的运算符的返回类型可“隐式”转换为 xx 的类型，则运算按 x = x op y 计算，但 x 只计算一次。\n>\n> ·    否则，如果选定运算符是预定义的运算符，选定运算符的返回类型可“显式”转换为 x 的类型，并且 y 可“隐式”转换为 x 的类型或者该运算符是移位运算符，则运算按 x = (T)(x op y) 计算（其中 T 是 x 的类型），但 x 只计算一次。\n>\n> ·    否则，复合赋值无效，且发生绑定时错误。\n>\n> 术语“只计算一次”表示：在 x op y 的计算中，x 的任何要素表达式的计算结果都临时保存起来，然后在执行对 x 的赋值时重用这些结果。例如，在计算赋值 A()[B()] += C() 时（其中 A 为返回 int[] 的方法，B 和 C 为返回 int 的方法），按 A、B、C 的顺序只调用这些方法一次。\n>\n> 当复合赋值的左操作数为属性访问或索引器访问时，属性或索引器必须同时具有 get 访问器和 set 访问器。如果不是这样，则发生绑定时错误。\n>\n> 上面的第二条规则允许在某些上下文中将 x op= y 按 x = (T)(x op y) 计算。按此规则，当左操作数为 sbyte、byte、short、ushort 或 char 类型时，预定义的运算符可用作复合运算符。甚至当两个参数都为这些类型之一时，预定义的运算符也产生 intint类型的结果，详见第 ‎7.3.6.2 节中的介绍。因此，不进行强制转换，就不可能把结果赋值给左操作数。\n>\n> 此规则对预定义运算符的直观效果只是：如果同时允许 x op y 和 x = y，则允许 x op= y。在下面的示例中\n>\n> ```c#\n> byte b = 0;\n> char ch = '\\0';\n> int i = 0;\n> \n> b += 1;      // Ok\n> b += 1000;    // Error, b = 1000 not permitted\n> b += i;      // Error, b = i not permitted\n> b += (byte)i;   // Ok\n> \n> ch += 1;       // Error, ch = 1 not permitted\n> ch += (char)1;  // Ok\n> ```\n>\n> 每个错误的直观理由是对应的简单赋值也发生错误。\n>\n> 这还意味着复合赋值运算支持提升运算。在下面的示例中\n>\n> ```c#\n> int? i = 0;\n>  i += 1;      // Ok\n> ```\n>\n> 使用了提升运算符 +(int?,int?)。\n>\n> ### 1.1.3 事件赋值\n>\n> 如果 += 或 -= 运算符的左操作数属于事件访问类别，则表达式按下面这样计算：\n>\n> ·    计算事件访问的实例表达式（如果有）。\n>\n> ·    计算 += 或 -= 运算符的右操作数，如果需要，通过隐式转换（第 ‎6.1 节）转换为左操作数的类型。\n>\n> ·    调用该事件的事件访问器，所需的参数列表由右操作数（经过计算和必要的转换后）组成。如果运算符为 +=，则调用 add 访问器；如果运算符为 -=，则调用 remove 访问器。\n>\n> 事件赋值表达式不产生值。因此，事件赋值表达式只在 statement-expression（第 ‎8.6 节）的上下文中是有效的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 其他运算符\n\n下表列出了 C# 支持的其他一些重要的运算符，包括 sizeof、typeof 和 ? :。\n\n| 运算符   | 描述                                                         | 实例                                                         |\n| :------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| sizeof() | 返回数据类型的大小。默认情况下只能获取基本数据类型在内存中占据的字节数（除了string object）。如果需要获取自定义结构体实例的大小，需要放在不安全的上下文中。 | sizeof(int)，将返回 4.                                       |\n| typeof() | 返回 class 的类型。                                          | typeof(StreamReader);                                        |\n| &        | 返回变量的地址。                                             | &a; 将得到变量的实际地址。                                   |\n| *        | 变量的指针。                                                 | *a; 将指向一个变量。                                         |\n| ? :      | 条件表达式                                                   | 如果条件为真 ? 则为 X : 否则为 Y                             |\n| new      | 在内存中创建指定类型的实例，并调用实例构造器。在类中要慎用new，一旦在某个类中调用的new，当前编写的类型就和创建实例的这个类型构成了紧密的耦合。一旦创建实例的类有问题，那么当前类也会出问题。 | new Form();                                                  |\n| checked  | 检查指定的运算是否产生溢出。如果产生抛出异常(OverflowException ) | uint i = unit.MaxValue; uint j = checked(i + 1); 或者checked{}(检查语句块) |\n| delegate | 声明匿名方法。一般并不作为操作符，而是声明委托数据类型。     |                                                              |\n| ~        | 求反操作符。对一个数在二进制层面按位取反                     |                                                              |\n\n\n\n### 空合并运算符\n\n​\t?? 运算符称为空合并运算符。\n\n​\ta ?? b 形式的空合并表达式要求 a 为可以为 null 的类型或引用类型。\n\n​\t如果 a 为非 null，则 a ?? b 的结果为 a；否则，结果为 b。仅当 a 为 null 时，该操作才计算 b。\n\n​\t空合并运算符为右结合运算符，表示操作从右向左进行组合。例如，a ?? b ?? c 形式的表达式可以按 a ?? (b ?? c) 进行计算。概括地说，E1 ?? E2 ?? ... ?? EN 形式的表达式返回第一个非 null 的操作数，如果所有操作数都为 null，则返回 null。\n\n表达式 a ?? b 的类型取决于对操作数可用的隐式转换。按照优先顺序，a ?? b 的类型为 A0、A 或 B，其中 A 是 a 的类型（如果 a 有类型），B 是 b 的类型（如果 b 有类型），A0 是 A 的基础类型（如果 A 是可以为 null 的类型）或 A（如果该项不是可以为 null 的类型）。具体而言，a ?? b 的处理过程如下：\n\n·    如果 A 存在并且不是可以为 null 的类型或引用类型，将发生编译时错误。\n\n·    如果 b 是动态表达式，则结果类型为 dynamic。在运行时，首先计算 a。如果 a 不为 null，则 aa 转换为动态类型，这成为结果。否则，计算 b，这成为结果。\n\n·    否则，如果 A 存在并且是可以为 null 的类型，并且存在从 b 到 A0 的隐式转换，则结果类型为 A0。在运行时，首先计算 a。如果 a 不为 null，则 a 解包为类型 A0，这即是结果。否则，计算 b 并转换为类型 A0，这即是结果。\n\n·    否则，如果 A 存在并且存在从 b 到 A 的隐式转换，则结果类型为 A。在运行时，首先计算 a。如果 a 不为 null，则 a 即是结果。否则，计算 b 并转换为类型 A，这即是结果。\n\n·    否则，如果 b 的类型为 B，并且存在从 a 到 B 的隐式转换，则结果类型为 B。在运行时，首先计算 a。如果 a 不为 null，则 a 解包为类型 A0（如果 A 存在并且可以为 null）并转换为类型 B，并且这成为结果。否则，计算 b 并且 b 作为结果。\n\n·    否则，a 和 b 不兼容，并发生编译时错误。\n\n\n\n可以使用以下代码来检查一个可空类型变量是否为null，并在它为null时返回一个默认值：\n\n```csharp\nint? x = null;\nint y = x ?? -1;\n```\n\n\n\n### ?. 空条件运算符\n\n在C#中，`?.`运算符被称为**空条件运算符**。它用于执行成员或元素访问操作，仅当操作数不为null时才执行。如果操作数为null，则表达式的结果为null。\n\n例如，您可以使用以下代码来检查一个对象是否为null，并在它不为null时访问其成员：\n\n```csharp\nstring s = null;\nint? length = s?.Length;\n```\n\n在上面的示例中，由于s的值为null，因此length的值将被设置为null。\n\n下面是一个使用`?.`运算符的示例：\n\n```csharp\npublic class Person\n{\n    public string Name { get; set; }\n}\n\nPerson person = null;\nstring name = person?.Name;\n```\n\n在上面的示例中，我们定义了一个名为`Person`的类，它具有一个名为`Name`的属性。然后，我们创建了一个名为`person`的变量，它的值为null。接下来，我们使用`?.`运算符来访问`person`对象的`Name`属性。由于`person`的值为null，因此`name`变量的值将被设置为null。\n\n如果我们将`person`变量的值更改为非null值，则可以正常访问其成员：\n\n```csharp\nPerson person = new Person { Name = \"John\" };\nstring name = person?.Name; // name will be \"John\"\n```\n\n在上面的示例中，由于`person`的值不为null，因此我们可以正常访问其成员，并且`name`变量的值将被设置为\"John\"。\n\n\n\n#### 用途\n\n##### 有助于避免繁杂的空值检查带来的代码歧义。\n\n如果想得到给定客户的订单数，就需要在设置计数值之前检查空值:\n\n```c#\nint count = 0;\nif (customer.orders != null)\n{\n\n\tcount = customer. orders.Count() ;\n}\n```\n\n如果只编写了这段代码，但客户没有订单(即为null),就会抛出System.ArgumentNullException:\n\n```c#\nint count = customer .orders. Count() ;\n```\n\n使用`?.`运算符，会把int? count设置为null，而不会抛出一一个异常。\n\n```c#\nint? count = customer . orders? .Count() ;\n```\n\n结合上一节讨论的空合并操作符??与空条件运算符?.可以在结果是null时设置一个默认值。\n\n```c#\nint? count = customer.orders?.Count() ?? 0;\n```\n\n##### 触发事件\n\n空条件运算符的另一个用途是触发事件。触发事件的最常见方法是使用如下代码模式:\n\n```c#\nvar onChanged = OnChanged;\nif (onChanged != null)\n{\n\tonChanged(this, args) ;\n}\n```\n\n这种模式不是线程安全的，因为有人会在null检查已经完成后，退订最后一个事件处理程序。此时会抛出异常，程序崩溃。使用空条件运算符可以避免这种情形:\n\n```c#\nOnChanged?.Invoke(this, args) ;\n```\n\n#### 注意\n\n如果使用运算符重载方法(例如==)，但没有检查null, 就会抛出System.NullReferenceException.\n\n\n\n\n\n### C# 中的运算符优先级\n\n运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。\n\n例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。\n\n下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。\n\n| 类别       | 运算符                            | 结合性   |\n| :--------- | :-------------------------------- | :------- |\n| 后缀       | () [] -> . ++ - -                 | 从左到右 |\n| 一元       | + - ! ~ ++ - - (type)* & sizeof   | 从右到左 |\n| 乘除       | * / %                             | 从左到右 |\n| 加减       | + -                               | 从左到右 |\n| 移位       | << >>                             | 从左到右 |\n| 关系       | < <= > >=                         | 从左到右 |\n| 相等       | == !=                             | 从左到右 |\n| 位与 AND   | &                                 | 从左到右 |\n| 位异或 XOR | ^                                 | 从左到右 |\n| 位或 OR    | \\|                                | 从左到右 |\n| 逻辑与 AND | &&                                | 从左到右 |\n| 逻辑或 OR  | \\|\\|                              | 从左到右 |\n| 条件       | ?:                                | 从右到左 |\n| 赋值       | = += -= *= /= %=>>= <<= &= ^= \\|= | 从右到左 |\n| 逗号       | ,                                 | 从左到右 |\n\n\n\n\n\n## c#表达式\n\n- 表达式（Expressions）是任何语言的基础组件之一（其二分别是命令和声明），而且是最重要的。\n- 表达式是一种语法实体，用于表达一定的算法意图。\n- 在C#中，表达式是由一个或多个操作数和零个或多个操作符组成的序列。表达式求值后，得到的结果为single value, object, method, or namespace.\n\n\n\n> expression 为 non-assignment-expression 或 assignment。\n>\n> expression: \n> non-assignment-expression\n> assignment\n>\n> non-assignment-expression:\n> conditional-expression\n> lambda-expression\n> query-expression\n>\n> \n>\n> 表示为 非赋值表达式或 分配\n> 表达式：\n> 非赋值表达式\n> 分配\n> 非赋值表达式：\n> 条件表达式\n> lambda表达式\n> 查询表达式\n\n\n\n\n\n\n\n# c#元组（Tuple）\n\n​\t元组功能在 **C# 7.0** 及更高版本中可用，它提供了简洁的语法，用于将多个数据元素分组成一个轻型数据结构。 \n\n​\t元组是一种 有序的，有限不可变的，支持混杂类型的固定个数的 一种数据结构。混杂指的是 Tuple 中的若干元素类型，即可以是同类型，也可以是不同类型。如一个元组中可以有int、string等不同类型的数据\n\n​\t常用于方法数据的传入和传出\n\n\n\n## 使用元组的场景\n\n- 如果你的方法需要返回多个值 或者 方法需要传递多个值。\n\n- 如果你不想为某些功能专门去定义一个类。\n\n- 如果你有若干个混杂元素，并且想提供对其简单的访问方式。\n\n用法和匿名类类似，但是，方法的返回值不能指定为匿名类型。\n\n\n\n## 元组的缺陷\n\n- Tuple 是引用类型不是值类型，意味着它会在 `托管堆` 上进行内存分配，如果 Tuple 过大并且没有很好的释放，对程序也是一个不小的性能挑战。\n\n## 声明和使用样例\n\n```c#\nusing System;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            //如果定义的时候不声明字段名，则使用的时候只能使用默认的 Item + 数字编号（从1起）\n            (double , int)numbers1 = (0.98, 2);\n            Console.WriteLine($\"numbers1元组中第一个值为：{numbers1.Item1}\\t第二个值为：{numbers1.Item2}\\t\\t元组的类型为：{numbers1.GetType()}\");\n            //如果在定义的时候声明了字段名，则使用的时候可以用字段名进行访问。此时，默认的Item名无法使用。\n            (int num1, double num2) numbers2 = (0, 0.02);\n            Console.WriteLine($\"numbers2元组中第一个值为：{numbers2.num1}\\t第二个值为：{numbers2.num2}\\t元组的类型为：{numbers2.GetType()}\");\n\n            numbers2 = MySwap(numbers1);//将number1的元组转换成num2的元组的形式\n            Console.WriteLine($\"numbers2元组中第一个值为：{numbers2.num1}\\t第二个值为：{numbers2.num2}\\t元组的类型为：{numbers2.GetType()}\");\n\n            //并不可以使用foreach遍历。\n            //foreach(var x in numbers2)\n            //{\n            //    Console.WriteLine(x);\n            //}\n            Console.ReadKey();\n        }\n\n        //一个样例方法，演示使用元组进行数据的传入和传出。\n        static (int, double)MySwap((double, int) x)\n        {\n            (int, double) t;\n            t.Item1 = x.Item2;\n            t.Item2 = x.Item1;\n            return t;\n        }\n    }\n\n}\n```\n\n\n\n## 使用元组时的注意事项\n\n​\t元组功能需要 `System.ValueTuple` 类型和相关的泛型类型（例如 `System.ValueTuple<T1,T2>`），这些类型在 `.NET Core` 和 `.NET Framework 4.7` 及更高版本中可用。 若要在面向 `.NET Framework 4.6.2` 或更早版本的项目中使用元组，请将 `NuGet` 包 `System.ValueTuple` 添加到项目。\n\n\n\n# C#的基本语句\n\n- 语句是命令式编程语言（高级语言）中最小的独立元素。用于表达将要执行的动作。\n- 语句对应着一组指令。\n- 简单地说就是，陈述算法思想，控制逻辑走向，完成有意义的动作。\n- **在c#中，语句一定是出现在方法体内**。\n\n\n\n## c#的语句种类\n\n- 声明语句\n  - 用于声明变量、常量等\n- 表达式语句\n- 嵌入式语句\n- 块语句（简称“块”）\n- 选择语句（判断、分支）\n- 迭代语句（循环）\n- 跳转语句\n- try...catch...finally语句\n- using语句\n- yield语句\n- checked/unchecked语句\n- lock语句（用于多线程）\n- 标签语句 labeled-statement（比较少见）\n- 空语句\n\n\n\n## 声明语句\n\n### 声明一个或多个局部变量。\n\n- 局部变量声明：\n\n  - 局部变量类型 局部变量声明器\n\n- 局部变量类型：\n\n  - 具体类型\n\n  - var类型\n\n- 局部变量声明器：\n\n  - 一个局部变量声明器\n\n  - 一组局部变量声明器 , 一个局部变量声明器\n\n- 一个局部变量声明符：\n\n  - 标识符\n\n  - 标识符 = 局部变量初始化器\n\n- 局部变量初始化器：\n\n  - 表达式（值）\n\n  - 数组初始化器\n\n> local-variable-declaration 声明一个或多个局部变量。\n>\n> local-variable-declaration:\n> local-variable-type  local-variable-declarators\n>\n> local-variable-type:\n> type\n> var\n>\n> local-variable-declarators:\n> local-variable-declarator\n> local-variable-declarators  ,  local-variable-declarator\n>\n> local-variable-declarator:\n> identifier\n> identifier  =  local-variable-initializer\n>\n> local-variable-initializer:\n> expression\n> array-initializer\n\n\n\n\n\n#### 样例\n\n```c#\nint x;//指定类型声明，但没有初始化\nx = 0;//赋值\nvar y = 100;//未指定类型的声明，靠编译器自动推断。一旦推断完成，就不可更改\nint z = 200;//与第一个样例不相等。这种是声明变量的时候追加了初始化器\nint[] arr = {x, y, z};//数组初始化器初始化数组\n```\n\n\n\n\n\n\n\n\n\n### 声明局部常量\n\n- 声明局部变量的前面加上`const`关键字。\n- 常量在声明的时候必须跟上初始化器，设定初始值。\n- 常量一旦定义不可修改。\n\n\n\n> local-constant-declaration 用于声明一个或多个局部常量。\n>\n> local-constant-declaration:\n> const  type  constant-declarators\n>\n> constant-declarators:\n> constant-declarator\n> constant-declarators  ,  constant-declarator\n>\n> constant-declarator:\n> identifier  =  constant-expression\n>\n> local-constant-declaration 的 type 指定由该声明引入的常量的类型。此类型后接一个 constant-declarator 列表，其中每一项都引入一个新常量。cconstant-declarator 包含一个命名常量的 identifier，后接一个“=”标记，然后是一个对该常量赋值的 constant-expression（第 ‎7.19 节）。\n>\n> 局部常量声明的 type 和 constant-expression 必须遵循与常量成员声明（第 ‎10.4 节）一样的规则。\n>\n> 可以在表达式中通过 simple-name（第 ‎7.6.2 节）来获取局部常量的值。\n>\n> 局部常量的范围是在其中声明了该常量的块。在局部常量的 constant-declarator 之前的文本位置中引用该局部常量是错误的。在局部常量的范围内声明其他具有相同名称的局部变量或常量是编译时错误。\n>\n> 声明多个常量的局部常量声明等效于多个同一类型的单个常量的声明。\n\n\n\n#### 样例\n\n```c#\nconst double PI = 3.1415926;\n```\n\n\n\n\n\n\n\n## 表达式语句\n\n- 简单的说就是可以形成表达式的语句。用于计算所给定的表达式。由此表达式计算出来的是（如果有）将被丢弃。\n- 不是所有的表达式都允许被作为语句。\n\n\n\n> expression-statement:\n> statement-expression  ;\n>\n> statement-expression:\n> invocation-expression\n> object-creation-expression\n> assignment\n> post-increment-expression\n> post-decrement-expression\n> pre-increment-expression\n> pre-decrement-expression\n> await-expression\n>\n> \n>\n> - 表达式语句：\n>   - 语句表达式；\n> - 语句表达式：\n>   - 调用表达式\n>   - 对象创建表达式\n>   - 赋值\n>   - 后增量表达式\n>   - 减量后表达式\n>   - 前增量表达式\n>   - 减量前表达式\n>   - 等待表达式\n\n\n\n#### 样例\n\n```c#\n//Console.WriteLine //成员访问，一旦添加括号即表示调用\nConsole.WriteLine(\"hello world\");//方法调用表达式\nForm form= new Form();//对象创建表达式\nx = 100;//赋值\nx++;//自增，只关心结果，不关心返回值（返回值为自增前的x）\nx--;\n++x;\n--x;\n//x + y;//不允许，因为无意义\n```\n\n\n\n## 块\n\n- 用于在只允许使用单个语句的上下文中编写多条语句。\n- 块 由一个扩在大括号内的可选的语句序列组成。如果没有语句序列，则称块是空的。\n- 所有语句都可以写在块内。\n- 块语句一定被大括号包裹，但被大括号包裹的语句不一定是块语句。（块语句是语句，因此一定出现在方法体内。）\n- 编译器将整个块视为一个完整的语句，不需要额外的分号。\n- 一般与判断、循环连用。\n- 块语句外声明的变量在块内也可以用，但在块内声明的在块外就无法使用。详见变量的生存期和作用域。\n\n\n\n\n\n## 选择语句\n\n​\t判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。\n\n​\t基本语法与c相同\n\n| 语句             | 描述                                                         |\n| :--------------- | :----------------------------------------------------------- |\n| if 语句          | 一个 **if 语句** 由一个布尔表达式后跟一个或多个语句组成。    |\n| if...else        | 一个 **if 语句** 后可跟一个可选的 **else 语句**，else 语句在布尔表达式为假时执行。 |\n| 嵌套 if 语句     | 您可以在一个 **if** 或 **else if** 语句内使用另一个 **if** 或 **else if** 语句。 |\n| switch 语句      | 一个 **switch** 语句允许测试一个变量等于多个值时的情况。需要注意switch的表达式类型必须是整形数、布尔类型、char、string或枚举类型。**不允许是浮点类型**，因为浮点不精确不可比较。 |\n| 嵌套 switch 语句 | 您可以在一个 **switch** 语句内使用另一个 **switch** 语句。   |\n\n\n\n### Switch语句\n\nC#与C++是有区别的。在C++中，可以在运行完一个case语句后，运行另一个case语句。即case后面的语句块中缺省break语句，一个case语句执行了两个以上的语句块。\n\n在C#中，**执行完每个部分的代码后，还需要有另一个语句break**。在执行完一个case块后，再执行第二个case语句是非法的。\n\n在C#代码中,还有其他方法可以防止程序流程从一个case语句转到下一个case语句。可以使用returm语句，中断当前函数的运行，而不是仅中断switch结构的执行(详见第6章)。也可以使用goto语句(如前所述)，\n\ncase语句实际上是在C#代码中定义的标签。\n\n一个case语句处理完毕后，不能自由进入下一个case 语句，但这条规则有一个例外。如果把多个case语句放在一起(堆叠它们)， 其后加一个代码块，实际上是一次检查多个条件。如果满足这些条件中的任何一个，\n就会执行代码，例如:\n\n```c#\nswitch (<testVar>) \n{\n    case <compari sonVa11>:\n\tcase <comparisonva12> :\n\t\t<当<testVar>=<comparisonva11>或<testVar>=<comparisonva12>时要执行的代码 >\n\tbreak;\n}\n\n```\n\n注意，这些条件也适用于default语句。default 语句不一定要放在比较操作列表的最后，还可以把它和case语句放在一起。用break或returm添加一个断点， 可确保在任何情况下，该结构都有一条有效的执行路径。\n\n\n\n### ? : 运算符\n\n **条件运算符 ? :**可以用来替代 **if...else** 语句。它的一般形式如下：\n\n```\nExp1 ? Exp2 : Exp3;\n```\n\n其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。\n\n? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。\n\n\n\n\n\n## 循环\n\n循环语句允许我们多次执行一个语句或语句组。\n\n### 基础循环\n\nC# 提供了以下几种循环类型。\n\n基本语法与c++相同。此处不再赘述。\n\n| 循环类型                                                     | 描述                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [while 循环](https://www.runoob.com/csharp/csharp-while-loop.html) | 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 |\n| [for/foreach 循环](https://www.runoob.com/csharp/csharp-for-loop.html) | 多次执行一个语句序列，简化管理循环变量的代码。               |\n| [do...while 循环](https://www.runoob.com/csharp/csharp-do-while-loop.html) | 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。    |\n| [嵌套循环](https://www.runoob.com/csharp/csharp-nested-loops.html) | 您可以在 while、for 或 do..while 循环内使用一个或多个循环。  |\n\n\n\n### foreach循环\n\n使用foreach可以迭代数组或者一个集合对象。\n\nforeach循环用于列举出集合中所有的元素，foreach语句中的表达式由关键字in隔开的两个项组成。**in右边的项是集合名，in左边的项是变量名，用来存放该集合中的每个元素。**\n\n该循环的运行过程如下：每一次循环时，从集合中取出一个新的元素值。放到只读变量中去，如果括号中的整个表达式返回值为true，foreach块中的语句就能够执行。一旦集合中的元素都已经被访问到，整个表达式的值为false，控制流程就转入到foreach块后面 的执行语句。\n\nforeach语句经常与数组一起使用，下面实例将通过foreach语句读取数组的值并进行显示。\n\n只要这个类实现了`IEnumerable`这个接口的类，就可以被foreach遍历。比如数组、泛型list\n\n循环的本意是调用类的迭代器。如：\n\n```c#\nint[] arr = new int[] { 1, 2, 3,4 };\nSystem.Collections.IEnumerator enumerator = arr.GetEnumerator();//获取arr的迭代器\nwhile(enumerator.MoveNext())\n{\n\tConsole.WriteLine(enumerator.Current); //输出\n}\n```\n\n\n\n\n\n#### 基本语法\n\n```c#\nforeach（type objName in collection/Array）\n```\n\n**注：** objName的数据类型type必须与collection/Array对象的类型相同或比它大。\n\n- type\n  - 迭代变量的数据类型\n- objName\n  - 迭代变量\n- collection/Array\n  - 需要循环的集合\n\n如：\n\n```c#\nint[,,] a = new int[2, 2, 2] { {{ 1, 2 }, { 3,4}},{{ 5, 6 }, { 7,8}} };//定义一个2行2列2纵深的3维数组a\nforeach(int i in a)\n{\n    Console .WriteLine (i);\n}\n```\n\n\n\n以下实例有三个部分：\n\n- 通过 foreach 循环输出整型数组中的元素。\n- 通过 for 循环输出整型数组中的元素。\n- foreach 循环设置数组元素的计算器。\n\n#### 实例\n\n```c#\nclass ForEachTest\n{\n  static void Main(string[] args)\n  {\n    int[] fibarray = new int[] { 0, 1, 1, 2, 3, 5, 8, 13 };\n    foreach (int element in fibarray)\n    {\n      System.Console.WriteLine(element);\n    }\n    System.Console.WriteLine();\n\n\n    // 类似 foreach 循环\n    for (int i = 0; i < fibarray.Length; i++)\n    {\n      System.Console.WriteLine(fibarray[i]);\n    }\n    System.Console.WriteLine();\n\n\n    // 设置集合中元素的计算器*\n    int count = 0;\n    foreach (int element in fibarray)\n    {\n      count += 1;\n      System.Console.WriteLine(\"Element #{0}: {1}\", count, element);\n    }\n    System.Console.WriteLine(\"Number of elements in the array: {0}\", count);\n  }\n}\n```\n\n输出结果为：\n\n```\n0\n1\n1\n2\n3\n5\n8\n13\n\n0\n1\n1\n2\n3\n5\n8\n13\n\nElement #1: 0\nElement #2: 1\nElement #3: 1\nElement #4: 2\nElement #5: 3\nElement #6: 5\nElement #7: 8\nElement #8: 13\nNumber of elements in the array: 8\n```\n\n\n\n#### 实例2\n\n通过遍历多维数组来比较for和foreach\n\n```c#\nint[,,] a = new int[2, 2, 2] { {{ 1, 2 }, { 3,4}},{{ 5, 6 }, { 7,8}} };// 定义一个2行2列2纵深的3维数组a\nfor (int i = 0; i < a.GetLength (0) ;i++ )  //用Array.GetLength(n)得到数组[0,1,,,n]上的维数的元素数，0代表行，1列，n代表此数组是n+1维\n{\n  for (int j = 0; j < a.GetLength(1); j++)\n  {\n    for (int z = 0; z < a.GetLength(2);z++ )//2代表得到纵深上的元素数，如果数组有n维就得写n个for循环\n    {\n      Console.WriteLine(a[i,j,z]);\n    }\n  }\n}\n```\n\n\n\n```c#\nint[,,] a = new int[2, 2, 2] { {{ 1, 2 }, { 3,4}},{{ 5, 6 }, { 7,8}} };//定义一个2行2列2纵深的3维数组a\nforeach(int i in a)\n{\n  Console .WriteLine (i);\n}\n```\n\n**两段程序的功能一样。**\n\n\n\n#### 注意事项\n\n- foreach是只读的\n  - foreach会迭代每个元素，依次把每个元素放在声明的变量中。如果在循环中试图给声明的变量赋一个值，编译器会报错。\n- foreach是相对安全的，不存在访问非法元素的危险。\n- 当循环次数特别大的时候，foreach的效率是远高于for的。（至少一个数量级）\n\n\n\n\n\n### 循环控制语句\n\n循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。\n\nC# 提供了下列的控制语句。点击链接查看每个语句的细节。\n\n| 控制语句      | 描述                                                         |\n| :------------ | :----------------------------------------------------------- |\n| break 语句    | 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 |\n| continue 语句 | 引起循环跳过主体的剩余部分，立即重新开始测试条件。           |\n\n\n\n\n\n## try语句(异常处理)\n\n- ​\ttry 语句提供一种机制，用于捕捉在块的执行期间发生的各种异常。此外，try 语句还能让您指定一个代码块，并保证当控制离开 try 语句时，总是先执行该代码。\n- 不管是否发生异常，finally子句都会执行。\n- 可以有多个catch子句，但只能执行其中的一个。\n- 有三种可能的 try 语句形式：\n  - 一个 try 块后接一个或多个 catch 块。\n  - 一个 try 块后接一个 finally 块。\n  - 一个 try 块后接一个或多个 catch 块，后面再跟一个 finally 块。\n- C# 异常处理时建立在四个关键词之上的：**try**、**catch**、**finally** 和 **throw**。\n  - **try**：一个 try 块标识了一个将被激活的特定的异常的代码块。后跟一个或多个 catch 块。\n  - **catch**：程序通过异常处理程序捕获异常。catch 关键字表示异常的捕获。可以不写异常类型，表示捕捉所有异常。\n  - **finally**：finally 块用于执行给定的语句，不管异常是否被抛出都会执行。例如，如果您打开一个文件，不管是否出现异常文件都要被关闭。\n  - **throw**：当问题出现时，程序抛出一个异常。使用 throw 关键字来完成。\n\n\n\n### 基本语法\n\n```c#\ntry\n{\n   // 可能引起异常的语句\n}\ncatch( ExceptionName e1 )\n{\n   // 错误处理代码\n}\ncatch( ExceptionName e2 )\n{\n   // 错误处理代码\n}\ncatch( ExceptionName eN )\n{\n    throw eN;//不处理，直接再次抛出\n}\nfinally\n{\n   // 要执行的语句\n}\n```\n\n\n\n### 样例\n\nC# 以 try 和 catch 块的形式提供了一种结构化的异常处理方案。使用这些块，把核心程序语句与错误处理语句分离开。\n\n这些错误处理块是使用 **try**、**catch** 和 **finally** 关键字实现的。下面是一个当除以零时抛出异常的实例：\n\n```c#\nusing System;\nnamespace ErrorHandlingApplication\n{\n    class DivNumbers\n    {\n        int result;\n        DivNumbers()\n        {\n            result = 0;\n        }\n        public void division(int num1, int num2)\n        {\n            try\n            {\n                result = num1 / num2;\n            }\n            catch (DivideByZeroException e)\n            {\n                Console.WriteLine(\"Exception caught: {0}\", e);\n            }\n            finally\n            {\n                Console.WriteLine(\"Result: {0}\", result);\n            }\n\n        }\n        static void Main(string[] args)\n        {\n            DivNumbers d = new DivNumbers();\n            d.division(25, 0);\n            Console.ReadKey();\n        }\n    }\n}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```c#\nException caught: System.DivideByZeroException: Attempted to divide by zero. \nat ...\nResult: 0\n```\n\n### 样例2\n\n捕捉全部异常\n\n```c#\nint a = 0;\nint b = 10;\nint c;\ntry\n{\n\tc = b / a;\n}\ncatch \n{\n\tConsole.WriteLine(\"发生错误\");\n}\n```\n\n\n\n**异常处理的详细说明详见`c#异常处理`部分**\n\n\n\n> try-statement:\n> try  block  catch-clauses\n> try  block  finally-clause\n> try  block  catch-clauses  finally-clause\n>\n> catch-clauses:\n> specific-catch-clauses  general-catch-clauseopt\n> specific-catch-clausesopt  general-catch-clause\n>\n> specific-catch-clauses:\n> specific-catch-clause\n> specific-catch-clauses  specific-catch-clause\n>\n> specific-catch-clause:\n> catch  (  class-type  identifieropt  )  block\n>\n> general-catch-clause:\n> catch  block\n>\n> finally-clause:\n> finally  block\n>\n> \n>\n> \n>\n> \n>\n> - try语句：\n>   - try-block catch子句\n>   - try-block finally子句\n>   - try-block catch子句 finally子句\n> - catch子句：\n>   - 通用捕获异常\n>   - 特定捕获异常\n> - 特定捕获异常：\n>   - 特定捕获异常\n>   - 特定捕获条款\n>   - 特定捕获条款：\n>   - catch（类类型 标识符~opt~）块\n> - 一般捕获子句：\n>   - catch子句\n> - finally-clause:\n>   - finally子句\n\n\n\n## 标签语句\n\n简单的说就是，在一个语句前面加上标签。\n\n标签遵循标识符的规范。\n\n类似于声明变量，只是不用加数据类型。\n\n```c#\nhurr://标签\n    {\n   \t \tConsole.WriteLine(\"hurriedlu\");\n    }\ngoto hurr;//跳转到指定的标签处\n```\n\n\n\n\n\n\n\n## checked/unchecked语句\n\n`checked` 和 `unchecked` 语句指定整型类型算术运算和转换的溢出检查上下文。 当发生整数算术溢出时，溢出检查上下文将定义发生的情况。 在已检查的上下文中，引发 [`System.OverflowException`](https://learn.microsoft.com/zh-cn/dotnet/api/system.overflowexception)；如果在常数表达式中发生溢出，则会发生编译时错误。 在未检查的上下文中，会通过丢弃任何不适应目标类型的高序位来将操作结果截断。 例如，在加法示例中，它将从最大值包装到最小值。 以下示例显示了 `checked` 和 `unchecked` 上下文中的相同操作：\n\n```c#\ntry\n{\n    checked\n    {\n        int x = Int32.MaxValue;\n        int y = x + 1;//发生溢出\n    }\n}\ncatch(OverflowException e)\n{\n    Console.WriteLine(\"捕获到溢出异常\");\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n# C#的类和成员\n\n更深入的了解一些细节。'\n\n> 类是一种数据结构，它可以包含数据成员（常量和字段）、函数成员（方法、属性、事件、索引器、运算符、实例构造函数、静态构造函数和析构函数）以及嵌套类型。类类型支持继承，继承是一种机制，它使派生类可以对基类进行扩展和专用化。 —— 《C# 语言规范》\n>\n> \n>\n> 当你定义一个类时，你定义了一个数据类型的蓝图。这实际上并没有定义任何的数据，但它定义了类的名称意味着什么，也就是说，类的对象由什么组成及在这个对象上可执行什么操作。对象是类的实例。构成类的方法和变量称为类的成员。\n\n\n\n\n\n## 类\n\n### 类的定义\n\n类的定义是以关键字 **class** 开始，后跟类的名称。类的主体，包含在一对花括号内。下面是类定义的一般形式：\n\n```c#\n<access specifier> class  class_name \n{\n    // member variables\n    <access specifier> <data type> variable1;\n    <access specifier> <data type> variable2;\n    ...\n    <access specifier> <data type> variableN;\n    // member methods\n    <access specifier> <return type> method1(parameter_list)\n    {\n        // method body\n    }\n    <access specifier> <return type> method2(parameter_list)\n    {\n        // method body\n    }\n    ...\n    <access specifier> <return type> methodN(parameter_list)\n    {\n        // method body\n    }\n}\n```\n\n- 访问标识符 /<access specifier\\> 指定了对类及其成员的访问规则。如果没有指定，则使用默认的访问标识符。类的默认访问标识符是 **internal**，成员的默认访问标识符是 **private**。\n- 数据类型 <data type> 指定了变量的类型，返回类型 <return type> 指定了返回的方法返回的数据类型。\n- 如果要访问类的成员，你要使用点（.）运算符。\n- 点运算符链接了对象的名称和成员的名称。\n- 如果\n\n\n\n### 注意事项\n\n- 所有类都直接或间接的继承自object（System.Object）\n- 类只能继承一个父类，但能继承（完成）多个接口.\n  - 关于继承的更多事宜，在面向对象编程单元中的继承子目录中有更详细的说明。\n\n\n\n### System.Object\n\n​\t所有类都继承于System.Object,所以这些类都可以访问该类中受保护的成员和公共成员。因为所有类都继承于System.Object，所以这些类都可以访问该类中受保护的成员和公共成员.\n\n| 方法                           | 返回类型    | 是否是虚拟 | 是否是静态 | 说明                                                         |\n| ------------------------------ | ----------- | ---------- | ---------- | ------------------------------------------------------------ |\n| Object()                       | N/A         | 否         | 否         | System.Object类型的构造函数,由派生类型的构造函数自动调用     |\n| ~Object()                      | N/A         | 否         | 否         | System.Object类型的析构函数，由派生类型的析构函数自动调用，不能手动调用 |\n| Equals(object)                 | bool        | 是         | 否         | 把调用该方法的对象与另一个对象相比，如果它们相等，就返回true。默认的实现代码会查看其对象参数是否引用了同一个对象(因为对象是引用类型)。如果想以不同方式来比较对象，则可以重写该方法，例如，比较两个对象的状态 |\n| Equals(object, object)         | bool        | 否         | 是         | 这个方法比较传送给它的两个对象，看看它们是否相等。检查时使用了Equalsl(object)方法。 注意，如果两个对象都是空引用，这个方法就返回true |\n| ReferenceEquals(object,object) | bool        | 否         | 是         | 这个方法比较传送给它的两个对象，看看它们是不是同一个实例的引用 |\n| ToString()                     | string      | 是         | 否         | 返回一个对应于对象实例的字符串。默认情况下，这是一个类类型的限定名称，但可以重写它，给类类型提供合适的实现代码 |\n| MemberwiseClone()              | object      | 否         | 否         | 通过创建一个新对象实例并复制成员，以复制该对象。成员复制不会得到这些成员的新实例。新对象的任何引用类型成员都将引用与源类相同的对象，这个方法是受保护的，所以只能在类或派生的类中使用 |\n| GetType()                      | System.Type | 否         | 否         | 以System.Type对象的形式返回对象的类型                        |\n| GetHashCode()                  | int         | 是         | 否         | 在需要此参数的地方，用作对象的散列函数，它返回一个以压缩形式标识对象状态的值 |\n\n\n\n### 成员\n\n| 成员     | 说明                                 |\n| -------- | ------------------------------------ |\n| 常量     | 与类关联的常量值                     |\n| 字段     | 类的变量                             |\n| 方法     | 类可执行的计算和操作                 |\n| 属性     | 与读写类的命名属性相关联的操作       |\n| 索引器   | 与以数组方式索引类的实例相关联的操作 |\n| 事件     | 可由类生成的通知                     |\n| 运算符   | 类所支持的转换和表达式运算符         |\n| 构造函数 | 初始化类的实例或类本身所需要的操作   |\n| 析构函数 | 在永久丢弃类的实例之前执行的操作     |\n| 类型     | 类所声明的嵌套类型                   |\n\n对于一个类或对象来说，最重要的三类成员就是属性（白色小扳手）、事件（黄色小闪电）和方法（紫色小方块）。\n\n属性：这个对象或类当前处于什么状态\n\n方法：当前这个类或方法能做什么\n\n事件：能在什么情况下通知谁\n\n存储数据、做事情、通知别人\n\n### 静态成员和实例成员\n\n​\t属性、方法和字段等成员是对象实例所特有的，此外，还有静态成员,例如静态方法、静态属性或静态字段。静态成员可以在类的实例之间共享，所以可将它们看成类的全局对象。静态属性和静态字段可以访问独立于任何对象实例的数据，静态方法可以执行与对象类型相关但与对象实例无关的命令。在使用静态成员时，甚至不需要实例化对象。\n\n​\t例如，Console.WriteLine()和Convert.ToString()方法就是静态的，根本不需要实例化Console或Convert类(如果试着进行这样的实例化，操作会失败,因为这些类的构造函数不是可公共可访问的，\n如前所述)。\n\n​\t许多情况下，静态属性和静态方法有很好的效果。例如，可以使用静态属性跟踪给类创建了多少个实例。在UML语法中，类的静态成员带有下画线。\n\n\n\n## 静态类\n\n​\t如果希望类只包含静态成员，且不能用于实例化对象(如Console)。一种简单的方法是使用静态类，而不是把类的构造函数设置为私有。静态类只能包含静态成员，不能包含实例构造函数，因为按照定义，它根本不能被实例化。但静态类可以有一个静态构造函数，如上一节所述。\n\n\n\n## 对象\n\n对象是实例化的类。\n\n\n\n### 对象的生存周期\n\n每一个对象都有一个明确的生命周期，除了\"正在使用\"的正常状态外，还有两个重要的阶段：\n\n- 构造阶段\n  - 第一次实例化一个对象时，需要初始化该对象。这个初始化过程称为构造阶段，由构造函数完成。\n- 析构阶段\n  - 在删除一个对象时，常常需要执行一些清理操作，如释放内存，这由析构函数完成。\n\n#### 构造函数\n\n对象的初始化过程是自动完成的，所有类定义都最少包含一个构造函数。\n\n在C#中，使用`new`关键字来调用构造函数。\n\n\n\n#### 析构函数\n\n​\t.NET Framework使用析构函数来清理对象。一般情况下，不需要提供析构函数的代码，而由默认的析构函数自动执行操作。但是，如果在删除对象实例前需要完成一些重要操作，就应提供具体的析构函数。\n\n​\t例如，如果变量超出了作用域,代码就不能访问它，但该变量仍存在于计算机内存的某个地方。只有在.NET运行程序执行其垃圾回收，进行清理时，该实例才被彻底删除。\n\n\n\n\n\n## 字段\n\n### 什么是字段\n\n- 字段（field）是一种表示与对象或类型（类与结构体）关联的**变量**\n  - 方法体中的局部变量是在方法运行的时候为方法暂时存储数据的，而字段是为一个对象或类型存储数据\n- 字段是类型的成员，旧称\"成员变量”\n- 与`对象`关联的字段亦称\"`实例字段`\"\n- 与`类型`关联的字段称为“`静态字段`\"，由static修饰。\n  - 静态字段为类所有，类不需要实例化即可使用。\n  - 需要注意的是，类一旦实例化成对象后便无法调用静态字段\n- **对于实例字段，其初始化的时机是在实例创建的时候。**\n- **对于静态字段，是在运行环境加载这个数据类型的时候。**\n\n\n\n\n\n### 字段的声明\n\n- 尽管字段声明带有分号,但它不是语句\n- 字段的名字一定是名词\n- 当声明字段的时候，一定要写在类体内，如果写到方法体中，就是局部变量了。\n- 如果不手动指定字段的初始值，编译器会自动指定一个对应类型的默认初始值。\n  - 也可以在构造函数中声明初始值\n\n#### 基本语法\n\n```c#\n[特性] [访问修饰符（可多个）] 数据类型 变量声明器;\n```\n\n#### 样例\n\n```c#\npublic int Amount = 0;\n```\n\n#### 访问修饰符\n\n- new\n\n- public\n\n- protected\n\n- private\n\n- static\n\n- readonly\n\n  - 修饰的字段将变成只读字段\n\n- volatile\n\n  \n\n### 只读字段\n\n又分为实例只读字段和静态只读字段\n\n修饰符为`readonly`\n\n对于只读字段，只能在初始化的时候进行赋值（构造器属于初始化），一旦初始化完成不可再修改。类似于常量？\n\n对于实例只读字段，常用于学生的编号等不可修改的场景；\n\n\n\n\n\n\n\n## 属性\n\n### 什么是属性\n\n\n\n​\t**属性（Property）** 是类（class）、结构（structure）和接口（interface）的命名（named）成员。类或结构中的成员变量或方法称为 **域（Field）**。属性（Property）是域（Field）的扩展，且可使用相同的语法来访问。它们使用 **访问器（accessors）** 让私有域的值可被读写或操作。\n\n​\t属性（Property）不会确定存储位置。相反，它们具有可读写或计算它们值的 **访问器（accessors）**。\n\n​\t属性( property)是一种用于访问**对象或类型的特征**的成员，特征反映了状态\n\n​\t属性是字段的自然扩展\n\n- 从命名上看. field更偏向于实例对象在内存中的布局，property更偏向于反映现实世界对象的特征\n- 对外:暴露数据，数据可以是存储在字段里的，也可以是动态计算出来的\n- 对内:保护字段不被非法值“污染”\n\n​\t属性由Get/Set方法对进化而来。(在Java、C++ 中，经常在类中使用Set和Get方法来设置和获取值，防止这个关键字段被污染)\n\n\n\n\n\n​\t例如，有一个名为 Student 的类，带有 age、name 和 code 的私有域。我们不能在类的范围以外直接访问这些域，但是我们可以拥有访问这些私有域的属性。\n\n\n\n### 访问器（Accessors）\n\n属性（Property）的访问器（accessor）**包含有助于获取（读取或计算）或设置（写入）属性的可执行语句**。\n\n访问器（accessor）声明可包含一个 get 访问器、一个 set 访问器，或者同时包含二者。例如：\n\n```c#\npublic string Code\n{\n   get\n   {\n      return code;\n   }\n   set\n   {\n      code = value;//访问器中只提供value，表示要写入的值\n   }\n}\n```\n\n在属性中，value是访问器中的一个`上下文关键字`（例如`this`，在vs中用蓝色进行标识），在访问器这个特定的代码中，指代了传入的值。\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 属性的声明\n\n#### 完整声明\n\n后台（back）成员变量与访问器\n\n正常的声明变量，然后在后面加一个大括号（访问器），在括号里面有set和get两部分。\n\n也可以分开写（propfull）\n\n```c#\nprivate int myVar;\n\npublic int MyProperty\n{\n\tget { return myVar; }\n\tset { myVar = value; }\n}\n```\n\n\n\n\n\n#### 简略声明 （自动属性）\n\n只有访问器\n\n```c#\nclass Student\n{\n\tpublic int MyProperty { get; set; }\n}\n```\n\n```c#\npublic int Age\n{\n\tget\n\t{\n\t\t//相关语句\n\t}\n\tset\n\t{\n\t\t//相关语句\n\t}\n}\n```\n\n注意：如果没有给get、set提供实现代码，这些块的实现代码（和底层的字段）都由编译器提供。\n\n使用自动属性时，只能通过\n\n\n\n\n\n#### 样例\n\n```c#\nusing System;\nnamespace runoob\n{\n    class Student\n    {\n\n        private string code = \"N.A\";\n        private string name = \"not known\";\n        private int age = 0;\n\n        // 声明类型为 string 的 Code 属性\n        public string Code\n        {\n            get\n            {\n                return code;\n            }\n            set\n            {\n                code = value;\n            }\n        }\n\n        // 声明类型为 string 的 Name 属性\n        public string Name\n        {\n            get\n            {\n                return name;\n            }\n            set\n            {\n                name = value;\n            }\n        }\n\n        // 声明类型为 int 的 Age 属性\n        public int Age\n        {\n            get\n            {\n                return age;\n            }\n            set//可以在里面写上相关的语句。value是访问器提供的一个变量，表示传入的值\n            {\n                if (value >= 0 && value <= 120)\n                {\n                    age = value;\n                }\n                else\n                {\n                    throw new Exception(\"Age value has error\");\n                }\n            }\n        }\n        public override string ToString()\n        {\n            return \"Code = \" + Code + \", Name = \" + Name + \", Age = \" + Age;\n        }\n    }\n    class ExampleDemo\n    {\n        public static void Main()\n        {\n            // 创建一个新的 Student 对象\n            Student s = new Student();\n\n            // 设置 student 的 code、name 和 age\n            s.Code = \"001\";\n            s.Name = \"Zara\";\n            s.Age = 9;//在使用的时候不必使用get、set，直接赋值即可。\n            Console.WriteLine(\"Student Info: {0}\", s);\n            // 增加年龄\n            s.Age += 1;\n            Console.WriteLine(\"Student Info: {0}\", s);\n\n\n            Student t = new Student();\n            t.Age = 120;\n            t.Age++;//只要属性发生变化，就自动调用set方法，以检查值是否合法，一旦不合法，就报错\n\n\n\n\n            Console.ReadKey();\n        }\n    }\n}\n```\n\n\n\n\n\n### 字段封装成属性\n\n选中字段后，ctrl r + ctrl e;\n\n![image-20230212121546115](./Image/C#学习笔记_基础教程.assets/image-20230212121546115.png)\n\n\n\n\n\n### 限制属性的读写\n\n#### 只读属性\n\n在访问器中删除set部分，即完成了属性的只读\n\n##### 样例\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            //Test.Age = 0;//在只读状态下无法写入\n            Console.WriteLine(Test.Age);//但可以正常读\n            \n\n            Console.ReadLine();\n        }    \n    }\n\n    class Test\n    {\n        static private int age = 10;\n\n        static public int Age\n        {\n            get { return age = 10; }\n        }\n\n\n    }\n}\n```\n\n\n\n#### 类外只读类内读写\n\n对于的set和get方法设置成private即可。\n\n##### 样例\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Test t = new Test();\n            t.Tools(100);//类外不能直接写\n            Console.WriteLine(t.Age);//类外可读\n            \n\n            Console.ReadLine();\n        }    \n    }\n\n    class Test\n    {\n        private int age = 10;\n\n        public int Age\n        {\n            get { return age; }\n            private set { age = value; }\n        }\n\n        public void Tools(int a)\n        {\n            Age = a;//类内可写\n        }\n    }\n}\n\n\n\n```\n\n\n\n**对于这种类内读写的属性对类外来说并不是只读属性，只是set从外界不能直接访问到**\n\n\n\n\n\n### 动态计算值的属性\n\n这个属性本身并没有封装一个字段，当从外界访问的时候，值是实时计算出来的。\n\n#### 被动计算\n\n当调用的时候才会被计算。\n\n如果访问的比较频繁，会比较浪费性能（每次访问都要计算）\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Test t = new Test();\n            t.Age = 20;\n            Console.WriteLine(t.Checked);//输出Checked的值\n            Console.ReadLine();\n        }    \n    }\n\n    class Test\n    {\n        private int age = 10;\n        public int Age\n        {\n            get { return age; }\n            set { age = value; }\n        }\n\n        /*\n         动态计算值的属性。Checked这个属性，并没有封装一个字段，当从外界访问的时候，值是实时计算出来的。\n         */\n        public bool Checked\n        {\n            get//获取值，必须确保一定有返回值\n            {\n                if(this.age >= 18)//计算，当 当前对象的age值大于等于18\n                    return true;//得到计算结果 true\n                else\n                    return false;//否则得到计算结果false\n            }\n        }\n    }\n}\n```\n\n\n\n#### 主动计算\n\n每次修改都会计算\n\n如果经常被设定但不经常check，还是被动计算比较好。\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Test t = new Test();\n            t.Age = 20;\n            Console.WriteLine(t.Check);//输出Checked的值\n            Console.ReadLine();\n        }\n    }\n\n    class Test\n    {\n        private int age = 10;\n        public int Age\n        {\n            get { return age; }\n            set\n            { \n                age = value;\n                //在值发生变化的时候，同时自动计算check的值\n                this.CalculateCheck();\n            }\n        }\n\n        //主动的计算\n\n        //创建一个计算属性\n        private bool check;\n\n        public bool Check\n        {\n            get { return check; }\n            set { check = value; }//据说是只读的属性，但注释掉这行后无法执行？\n        }\n        private void CalculateCheck()   //计算属性\n        {\n            if (this.age >= 18)//计算，当 当前对象的age值大于等于18\n                this.Check = true;\n            else\n                this.Check = false;\n        }\n    }\n}\n\n\n\n```\n\n\n\n注意实例属性和静态属性\n●属性的名字一 定是名词\n只读属性一只有getter没 有setter\n尽管语法上正确，几乎没有人使用\"只写属性”，因为属性的主要目的是通过向外暴露数据而表示对象/类型的状态\n\n### 属性与字段的关系\n\n- 一般情况下，它们都用于表示实体(对象或类型)的状态\n- 属性大多数情况下是字段的包装器( wrapper )\n- 建议:永远使用属性(而不是字段)来暴露数据，即字段永远都是`private`或`protected`的\n\n\n\n\n\n## 方法\n\n### 方法的由来\n\n- 方法（method）的前身是c/c++语言的函数（function）\n  - 方法是面向对象范畴的概念，在非面向对象语言中仍称为函数\n- 永远都是类（或结构体）的成员\n  - c#中方法不可独立于类（或结构体）之外\n  - 只有作为类（结构体）的成员的时候才称为方法\n- 方法是类（结构体）最基本的成员之一\n  - 类基本成员只有两个，字段和方法\n\n\n\n\n\n### 方法的定义与调用\n\n方法的声明和定义是放在一起的，没有头文件的概念\n\n**方法、属性的访问修饰符详见`c#封装`的部分。**\n\n#### 方法声明详细语法\n\n```c#\n<Access Specifier> <Return Type> <Method Name>(Parameter List)\n{\n   Method Body\n}\n```\n\n- **Access Specifier**：访问修饰符，这个决定了变量或方法对于另一个类的可见性。（详见后面的c#封装）\n  - new\n  - public\n  - protected\n  - internal\n  - private\n  - static（静态）\n  - virtual\n  - sealed\n  - override\n  - abstract\n  - extern\n  - async\n- **Return type**：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 **void**。\n- **Method name**：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。**并且需要时一个动词或动词短语，并满足大驼峰的规则**\n- **Parameter list**：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。\n- **Method body**：方法主体，包含了完成任务所需的指令集。\n\n\n\n\n\n#### 方法的调用\n\n`方法名(对应参数)；`\n\n\n\n### 方法的返回值\n\n通过函数进行数据交换的最简单方式是利用返回值。\n\n当函数返回一个值的时候，需要如下修改函数：\n\n1. 在函数声明中指定返回值类型，但不使用void关键字。\n2. 使用return关键字结束函数的执行把返回值传给主调函数\n\n需要注意的是，返回值的类型必须是声明时的返回值类型，或者可以隐式的转换成该类型。如声明返回int，实际可以返回short。\n\nreturn不一定在最后一行，一旦执行到return语句，方法将直接退出，不再执行return后面的语句（如果有）\n\n\n\n### 方法的参数\n\n#### 传值参数（值参数）\n\n- 声明时不带修饰符的形参是值形参。\n\n- 本质是作用域在当前方法的一个局部变量。其初始值是调用它的时候赋值在当前方法\n\n- 它的初始值是在调用这个方法的时候赋值给它的实参的值。换句话说就是传进来的实参的一个副本。即堆值参数的操作永远不会影响原来变量的值。\n\n- 当形参是值形参时，方法调用中的对应实参必须是表达式，并且它的类型可以隐式转换为形参的类型。\n\n- 允许方法将新值赋给值参数。这样的赋值只影响由该值形参表示的局部存储位置，而不会影响在方法调用时由调用方给出的实参。\n\n- 当传入的参数不是值类型的参数，而是引用类型的参数，则传入的是指向引用类型的对象。此时，方法内部和外部的两个变量指向的都是同一个对象。\n\n- 如果如果给传入的变量创建一个新的对象，在方法内使用的是新创建的对象，在方法外还是原来的那个对象。如：\n\n  - ```c#\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n    using System.Security.Policy;\n    using System.Text;\n    using System.Threading.Tasks;\n    using System.Windows.Forms;\n    using ShowInfos;\n    namespace ConsoleApp\n    {\n        internal class Program\n        {\n            static void Main(string[] args)\n            {\n                A a = new A();\n                a.Name= \"A\";//创建一个对象，这个对象中的Name属性的值是A\n                T(a);//把创建的引用类型的变量作为值传入到T方法中\n                Console.WriteLine(a.Name);//T方法结束后再次输出a的Name属性，结果还是A\n                Console.ReadLine();\n            }\n            static void T(A a)\n            {\n                Console.WriteLine(a.Name);//输出A\n                a = new A();\n                a.Name= \"B\";\n                Console.WriteLine(a.Name);//输出B\n            }\n        }\n    \n        class A//将被引用的对象\n        {\n            private string name;\n    \n            public string Name\n            {\n                get { return name; }\n                set { name = value; }\n            }\n        }\n    \n    }\n    ```\n\n  - 还可以更直接一点，输出hashcode检查一下是否是同一个对象\n\n\n\n\n\n使用值参数的时候，必须做到参数匹配。\n\n\n\n#### 引用参数\n\n​\t使用引用参数时，必须在方法的申明和调用中都使用关键字`ref`修饰符。\n\n​\t**实参必须是变量**，在用作**实参前必须被赋值**。如果是引用类型的变量，可以赋值为一个引用或者null值。\n\n​\t引用参数不会像值参数那样创建副本，而是直接指向传进来的参数所指向的地址。\n\n就像c++的`&`修饰符一样，可以使用引用的方式带回所需的数据。\n\n##### 样例\n\n​\t下面的代码阐明了引用参数的声明和调用的语法：\n\n```c#\nvoid MyMethod(ref int val)  //方法声明包含ref修饰符\n{\n    //your code\n}\n```\n\n```c#\nint y = 1;\t\t   //必须先赋值\nMyMethod(ref y);   //方法调用\n\nMyMethod(ref 3+5);  //错误,形参必须是变量\n```\n\n​\t如果传入的是引用类型的变量，则在方法内重新指向新的对象后，在方法外一样会指向新的对象。如：\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {      \n\n        static void Main(string[] args)\n        {\n            A a = new A();\n            a.Name = \"A\";\n\n            T(ref a);//引用参数要求调用的时候也明确声明是引用\n\n            Console.WriteLine(a.Name);//还是输出B，最早创建的Name = “A\"\n            Console.ReadLine();\n        }\n\n        static void T(ref A a)\n        {\n            Console.WriteLine(a.Name);//输出A\n            a = new A();\n            a.Name= \"B\";\n            Console.WriteLine(a.Name);//输出B\n        }\n\n    }\n\n    class A//被引用的对象\n    {\n        private string name;\n\n        public string Name\n        {\n            get { return name; }\n            set { name = value; }\n        }\n    }\n}\n```\n\n\n\n\n\n#### 输出参数\n\n​\t在声明的时候使用`out`关键字进行声明的参数\n\n​\t正常来说方法的返回值只能有一个，如果需要返回多个参数可以借助输出参数\n\n​\t输出参数和引用参数类似，都不会创建新的存储位置。引用参数在传入的时候必须有一个明确的值，而输出参数不需要，原有的值会被丢弃。\n\n​\t在方法返回前，必须对传进来的输出参数名确赋值，否则编译器会报错。\n\n​\t不能借助输出参数传入数据。因为在方法体中，如果未对输出参数进行赋值，则无法使用。一旦赋值先前带有的值则会被丢弃\n\n##### 样例1\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {      \n\n        static void Main(string[] args)\n        {\n            A a = new A();\n            a.Name= \"A\";\n            A b;//不需要赋值\n\n            T(out a, out b);//也需要在调用的时候声明出来\n\n            Console.WriteLine(b.Name);//还是输出B\n            Console.ReadLine();\n        }\n\n        static void T(out A a, out A b)\n        {\n            //Console.WriteLine(a.Name);//编译器报错：使用了未赋值的out参数\"a\"；\n            //a = new A();\n            a = null;\n            b = new A();\n            b.Name= \"B\";\n            Console.WriteLine(b.Name);//输出B\n        }\n    }\n\n    class A//被引用的对象\n    {\n        private string name;\n        public string Name\n        {\n            get { return name; }\n            set { name = value; }\n        }\n    }\n}\n```\n\n##### \t样例2 TryParse转换\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n\n        static void Main(string[] args)\n        {\n            string s;\n            s = \"123.45.6\";\n            double d = -1;\n            if (double.TryParse(s, out d))//尝试的转换，如果转换成功，则返回true，否则为false。同时转换完成的值以输出参数的形式带出，转换失败带出对应参数的默认值\n                Console.WriteLine(\"转换成功\");\n            else\n                Console.WriteLine(\"转换失败\");\n\n            Console.WriteLine(\"转换完成的值是：{0}\", d);\n\n            Console.ReadLine();\n        }\n    }\n}\n```\n\n\n\n\n\n#### 数组参数(形参数组,params)\n\n​\t有时，当声明一个方法时，**不能确定要传递给函数作为参数的参数数目**。C# 参数数组解决了这个问题，**参数数组通常用于传递未知数量的参数给函数。**\n\n​\t在使用数组作为形参时，C# 提供了 params 关键字，使调用数组为形参的方法时，既可以传递数组实参，也可以传递一组数组元素。params 的使用格式为：\n\n```c#\npublic 返回类型 方法名称( params 类型名称[] 数组名称 )\n```\n\n**需要注意，在使用params进行修饰的时候，只能存在一个被修饰的形参，且这个形参位于最后**（因为无法分辨那些是属于这个参数）。\n\n\n\n##### 样例\n\n在不使用形参数组作为形参的时候，写法是这样的，需要先创建一个数组，然后传入数组：\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n\n        static void Main(string[] args)\n        {\n            int[] arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n            Console.WriteLine(\"ans is {0}\", CalculateSum(arr));\n\n            Console.ReadLine();\n        }\n\n\n        static int CalculateSum(int[] arr)\n        {\n            int sum = 0;\n            foreach(var item in arr)\n            {\n                sum += item;\n            }\n\n            return sum;\n        }\n    }\n}\n```\n\n而使用形参数组之后，就不需要先新建一个数组，而是直接把数通过形参全部传入，且不需要指定传入的数的个数\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n\n        static void Main(string[] args)\n        {\n            int ans = CalculateSum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);//可以直接传入数个参数而不声明参数个数\n            Console.WriteLine(\"ans is {0}\", ans);\n            Console.ReadLine();\n        }\n        static int CalculateSum(params int[] arr)\n        {\n            int sum = 0;\n            foreach(var item in arr)\n            {\n                sum += item;\n            }\n\n            return sum;\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n#### 具名参数：参数的位置不再受约束\n\n严格来说不是具名参数不是某个参数的种类，而是参数的使用方法\n\n\n\n正常情况下，实参顺序要和形参顺序相等，这种调用就是不具名调用。如：\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            PrintInfo(\"张三\", 0);\n\n            Console.ReadLine();\n        }\n        static void PrintInfo(string name, int age)\n        {\n            Console.WriteLine(\"{0} {1}\", name, age);\n        }\n    }\n}\n```\n\n\n\n\n\n使用具名调用后：\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            PrintInfo(name: \"张三\", age: 0);//具名调用                                \n\n            Console.ReadLine();\n        }\n        static void PrintInfo(string name, int age)\n        {\n            Console.WriteLine(\"{0} {1}\", name, age);\n        }\n    }\n}\n```\n\n\n\n\n\n##### 优点\n\n1. 提高代码的可读性\n2. 参数的位置不受参数列表的约束\n\n\n\n#### 可选参数\n\n当在调用一个方法的时候，这个参数可写可不写。因为在声明参数的时候这个参数带有默认值。\n\n对于带有默认值的参数，如果在调用参数的时候不写这个参数，则这个参数获得声明时的值。\n\n不建议用可选参数。\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            PrintInfo(name: \"李四\", age: 20);//可以正常调用\n            PrintInfo();//当参数缺省时，使用默认值输出\n            Console.ReadLine();\n        }\n        static void PrintInfo(string name = \"张三\", int age = -1)\n        {\n            Console.WriteLine(\"{0} {1}\", name, age);\n        }\n    }\n}\n```\n\n\n\n#### 元组参数\n\n##### 使用样例\n\n```c#\n//一个样例方法，演示使用元组进行数据的传入和传出。\nstatic (int, double)MySwap((double, int) x)\n{\n    (int, double) t;\n    t.Item1 = x.Item2;\n    t.Item2 = x.Item1;\n    return t;\n}\n```\n\n具体见`c#元组`部分\n\n\n\n\n\n#### 扩展方法（this参数）\n\n方法必须是**公有的、静态的**，即被public static所修饰。\n\n必须是形参列表中的`第一个`，由this修饰\n\n必须由一个`静态类`（类名一般为 数据类型+Extension ，如DoubleExtension）来统一收纳。（必须放在一个静态类中）\n\n当无法对一个类型的源码进行修改的时候，可以使用扩展方法对这种数据类型进行追加方法。\n\n\n\n\n\n##### 具体步骤\n\n1. 创建一个静态类，类名为要扩展的数据类型的名字 + Extension。（不强制要求，但是是规范）\n2. 在这个静态类中创建一个静态的公共的方法，声明方法与常规方法相同，除了形参列表外。\n3. 形参列表的规则：\n   1. 有且最少有一个形参，并且第一个形参需要在前面加上this修饰符。形参的数据类型就是要扩展的数据类型，形参名随便，稍后要用。\n   2. this修饰符只允许存在一个，并且修饰的形参必须是第一个形参。\n   3. 后面可以有多个参数。\n4. 方法体中是这个扩展方法的实现过程，实现完后可以没有返回。\n\n\n\n##### 样例\n\n给string类型的变量增加一个ShowInfo的方法，以实现将string字符串输出到控制台。\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            string s = \"hurr\";\n            s.ShowInfo();\n            Console.ReadKey();\n        }\n    }\n\n    static class StringExtension\n    {\n        public static void ShowInfo(this string str)\n        {\n            Console.WriteLine(str);\n        }\n    }\n\n    static class DoubleExtension\n    {\n        public static double Round(this double input, int digits)\n        {\n            double result = Math.Round(input, digits);\n            return result;\n        }\n    }\n}\n```\n\n\n\n#### 各种参数的使用场景\n\n- 传值参数：参数的默认传递方式\n- 输出参数：用于除返回值外还需要返回输出的场景\n- 引用参数：用于需要修改实际参数值的场景\n- 数组参数：用于简化方法的调用\n- 具名参数：提高可读性\n- 可选参数：使参数拥有默认值\n- 扩展方法（this参数）：为目标数据类型“追加”方法\n\n\n\n\n\n\n\n\n\n### 方法的重载（Overload）\n\n#### 定义\n\n- 当为一个类创建方法的时候，方法名可以一样，但方法的签名不能一样。\n- 方法签名（method signature）由方法的名字、类型形参的个数和它每一个形参（按从左到右的顺序）的类型和种类（值、引用或输出）组成。**方法的签名不包含返回类型**\n- 重载决策（调用哪一个重载）：用于在给定了参数列表和一组候选函数成员的情况下，选择一个最佳函数成员来实施调用。\n\n简单地说就是，当多个方法的方法名相同，但所需的形参列表不同(类型或种类)的时候，就构成了方法的重载。注意方法的返回值是无所谓的\n\n\n\n\n\n\n\n### 方法的调用与栈的关系\n\n#### 方法调用时栈内存的分析\n\n- stack frame的分析：一个方法在被调用的时候在栈内存中的布局。\n\n- 栈内存在内存中由高字节位向低字节位分配，分配到最低后就溢出了。 \n\n- 在当前方法中调用另一个方法，当前方法称为主调者，被调用的方法称为被调者。\n\n  - ```c#\n    static void Main(string[] args)\n    {\n        Student student= new Student(10,\"张三\");\n        student.ShowInfo();//Main：主调者 caller ；ShowInfo：被调者 callee\n        Console.ReadLine();\n    }\n    ```\n\n- 传入的参数（变量）也需要压入栈中，并且在C#中，传入的变量归主调者管。入栈的时候，值是传入的参数，但类型是被调者形参决定的。如果主调者调用的方法的形参列表是double，但调用传入的时候是int类型的100，则在栈中，会分配一片double的空间，将int的100自动的进行隐式类型转换成double，然后存入。\n\n- 到被调者执行的时候，只需要再往栈中压入内部的局部变量即可（传进来的参数不用管，那个由主调者压）。\n\n- 除此之外，还需要压入主调者指针等其他参数\n\n- 返回值一般存储在cpu的寄存器中（前提是能存储下）\n\n\n\n### 静态方法\n\n#### 修饰符\n\n被static修饰。\n\n\n\n#### 特点\n\n1. 静态方法属于类所有，类实例化前即可使用（不需要实例化就可以方法）。\n2. 静态方法只能访问类中的静态成员，而非静态方法可以访问类中的任何成员。\n3. 静态方法在使用上不需要实例化类，而非静态方法需要实例化后才能调用。\n4. 静态方法不能直接使用非静态成员，因为非静态成员与实例相关，通过对象点取间接使用。\n5. 静态方法中不能用this（与实例相关）。\n6. 静态方法的生命周期很长，一旦被创建，直到程序结束位置。\n   - 静态变量不管是在全局还是局部声明的static变量都存放于程序的全局变量区域。\n   - 静态变量的作用域是变量的可见代码域（块作用域，函数作用域，类作用域，程序全局作用域）。\n\n\n\n\n\n#### 注意事项\n\n- 静态方法可以使用类名也可以使用对象来调用，而非静态方法只能使用对象来调用[1](https://bing.com/search?q=使用静态方法的注意事项有哪些).\n- 静态方法可以直接访问静态的成员，但是不能直接访问非静态的成员[1](https://bing.com/search?q=使用静态方法的注意事项有哪些).\n- 静态方法不能出现this或者super关键字，因为静态方法可以直接使用类名进行访问，而this关键字代表的是调用方法的对象，此时就会产生冲突。\n- 静态方法不宜过多。可能会占用过多的内存。\n\n\n\n\n\n\n\n\n\n## 索引器?\n\n### 什么是索引器\n\n**索引器（Indexer）** 允许一个对象可以像数组一样使用下标的方式来访问。\n\n当为类定义一个索引器时，该类的行为就会像一个 **虚拟数组（virtual array）** 一样，可以使用数组访问运算符 **[ ]** 来访问该类的的成员。\n\n\n\n### 语法\n\n```c#\nelement-type this[int index]\n{\n   // get 访问器\n   get\n   {\n      // 返回 index 指定的值\n   }\n\n   // set 访问器\n   set\n   {\n      // 设置 index 指定的值\n   }\n}\n```\n\n\n\n\n\n### 索引器（Indexer）的用途\n\n​\t索引器的行为的声明在某种程度上类似于属性（property）。就像属性（property），可使用 **get** 和 **set** 访问器来定义索引器。但是，属性返回或设置一个特定的**数据成员**，而索引器返回或设置**对象实例的一个特定值**。换句话说，它把实例数据分为更小的部分，并索引每个部分，获取或设置每个部分。\n\n​\t定义一个属性（property）包括提供属性名称。索引器定义的时候不带有名称，但带有 **this** 关键字，它指向对象实例。下面的实例演示了这个概念：\n\n```c#\nusing System;\nnamespace IndexerApplication\n{\n   class IndexedNames\n   {\n      private string[] namelist = new string[size];\n      static public int size = 10;\n      public IndexedNames()\n      {\n         for (int i = 0; i < size; i++)\n         namelist[i] = \"N. A.\";\n      }\n      public string this[int index]\n      {\n         get\n         {\n            string tmp;\n\n            if( index >= 0 && index <= size-1 )\n            {\n               tmp = namelist[index];\n            }\n            else\n            {\n               tmp = \"\";\n            }\n\n            return ( tmp );\n         }\n         set\n         {\n            if( index >= 0 && index <= size-1 )\n            {\n               namelist[index] = value;\n            }\n         }\n      }\n\n      static void Main(string[] args)\n      {\n         IndexedNames names = new IndexedNames();\n         names[0] = \"Zara\";\n         names[1] = \"Riz\";\n         names[2] = \"Nuha\";\n         names[3] = \"Asif\";\n         names[4] = \"Davinder\";\n         names[5] = \"Sunil\";\n         names[6] = \"Rubic\";\n         for ( int i = 0; i < IndexedNames.size; i++ )\n         {\n            Console.WriteLine(names[i]);\n         }\n         Console.ReadKey();\n      }\n   }\n}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```bash\nZara\nRiz\nNuha\nAsif\nDavinder\nSunil\nRubic\nN. A.\nN. A.\nN. A.\n```\n\n\n\n\n\n### 样例\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {      \n\n        static void Main(string[] args)\n        {\n            Student student = new Student();\n            student[0] = \"张三\";\n            student[1] = \"李四\";\n            student[2] = \"王五\";\n\n            for(int i = 0; i < Student.size; i++) \n            {\n                Console.WriteLine(student[i]);\n            }\n            \n\n            Console.ReadLine();\n        }\n    }\n\n\n    class Student\n    {\n        static public int size = 10;\n        private string[] nameList = new string[size];//创建一个string list\n\n        public Student()//无参构造器，默认全部构造成“空”\n        {\n            for(int i = 0; i < size; i++)\n            {\n                nameList[i] = \"NA\";\n            }\n        }\n\n        //索引器\n        public string this[int index]\n        {\n            get//读取\n            {\n                string tmp;//一个临时变量\n\n                if (index >= 0 && index < nameList.Length)//如果索引值在合法范围内\n                {\n                    tmp = nameList[index];//获取值\n                }\n                else\n                {\n                    tmp = \"\";//不在就返回空串\n                }\n                return tmp;//返回获取到的值\n            }\n\n\n            set//写入\n            {\n                if(index >=0 && index < size - 1) //如果没有超过规定的大小\n                {\n                    nameList[index] = value;//就读入\n                }\n            }\n        }\n    }\n}\n\n\n\n```\n\n\n\n> 索引器可以使用任何有效的访问修饰符（public、protected internal、protected、internal、private、private protected）。它们可能是密封、虚拟或者抽象的。与属性一样，可以在索引器中为get和set访问器指定不同的访问修饰符。还可以指定只读索引器（忽略set访问器）或只写索引器（忽略get访问器）。\n>\n> 属性的各种用法同样适用于索引器（唯一例外的是“自动实现属性”，编译器无法始终为索引器生成正确的存储）。\n>\n> **创建索引器的必备要素：**\n>\n> 1. 必须先创建索引器所需要的容器（可以理解为数据的存放）；\n> 2. 创建索引器需要使用this关键字；\n> 3. 索引器中必须包含get和set访问器，在C# 7.0后可以使用表达式（=>）主体进行简化；\n> 4. 在使用表达式主体成员进行索引时，必须额外的提供容器的修改接口（因为表达式主体不包括set访问器）。\n>\n> 索引器相当于一个方法，支持多个或多种类型的参数，与方法不同的是，索引器没有独立的名称，只能通过返回值的不同和参数的不同来区分不同的签名（从而实现重载），其返回值不能为void。索引器除了可以传入参数外，其返回值不能为void。索引器除了可以传入参数外，还可以对其进行赋值。\n>\n> 创建索引器时，其返回值为value关键字所使用的类型，定义了返回值类型的同时，也定义了其可接受的值类型。\n>\n> 总之，我对索引器的理解就是：是一个可以进行读写操作的自定义类中数据集合的接口。通过该接口，简化或丰富了该自定义类中数据集合的操作方式。\n>\n> 例如，在如下示例中，此索引器使用List作为容器，使用int类型的index进行索引，返回值为Measurements对象。\n\nhttps://zhuanlan.zhihu.com/p/488448024\n\n\n\n\n\n\n\n## 构造器\n\n对于类而言，可分为`静态构造器`和`实例构造器`两种。\n\n\n\n### 构造器（特殊的方法）\n\n- 构造器(constructor)（构造函数）是类的成员之一\n- 狭义的构造器是指“实例构造器”（instance constructor）\n- 一般来说构造器都是public的\n- 当声明了一个类之后，但又没有写构造器，编译器就会为它准备一个默认的构造器。一旦写了构造器，编译器将不会添加默认构造器。\n- 构造器没有返回值类型。\n- 构造器的名称必须和类名称相同。\n- 构造器可以被重载。\n- 当调用子类构造器时 会自动调用父类的构造器。\n\n\n\n#### 构造器的声明\n\n```c#\n访问修饰符 类名(参数列表) [: base(传递给父类构造器的实参)]\n{\n\t//执行语句\n}\n```\n\n##### 样例\n\n```c#\n    class A\n    {\n        public int a { get; set; }\n        public A(int a)\n        {\n            this.a = a;\n        }\n    }\n\n    class B : A\n    {\n        public int b { get; set; }\n        public B(int a, int b) : base(a)//当调用子类的构造函数时，会自动调用父类的构造函数。如果父类不存在无参构造函数，则需要使用base关键字向父类的构造函数传递值。\n        {\n            this.b = b;\n        }\n    }\n```\n\n\n\n\n\n\n\n\n\n### 静态构造器\n\n​\t在使用类中的静态成员的时候，需要预先初始化这些成员。\n\n​\t静态构造函数用于初始化任何[静态](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/static)数据，或执行仅需执行一次的特定操作。 将在创建第一个实例或引用任何静态成员之前自动调用静态构造函数。\n\n​\t他的语法规则和普通的构造器类似，要求都是方法名与类型相同，且都不可以有返回值；不同的是静态构造器的修饰符不再是public，而是static。\n\n​\t一个类只能有一个静态构造器，该构造器不能有访问修饰符，也不能带有任何参数。静态构造器不能直接调用，只能在下述情况下执行：\n\n- 创建包含静态构造函数的类实例时\n- 访问包含静态构造函数的类的静态成员时\n\n​\t首先先调用静态构造器，之后再实例化或访问静态成员。\n\n​\t可以说，只要类存在静态构造器，只要这个类被调用过，就会且只会调用一次静态构造器。\n\n​\t\n\n#### 样例\n\n```c#\nusing System;\nusing System.Diagnostics;\n\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"正在执行Main方法\");\n\n            A.num = 10;//当访问包含静态构造函数的类的静态成员时，运行环境会将这个类加载到内存中，同时会触发这个类的静态构造器。\n\n            B b1 = new B();//创建包含静态构造函数的类实例时，也会在调用实例构造器的同时调用静态构造器。\n\n            B b2 = new B();//静态构造器只会执行一次，再次创建实例的时候，只会再次调用实例构造器，而不会调用静态构造器。\n\n            Console.ReadKey();\n        } \n    }\n    \n    static class A\n    {\n        public static int num;\n        static A()//静态构造器，只在运行环境加载这个类的时候调用，且只调用一次。\n        {\n            Console.WriteLine(\"A的静态构造器已执行。\");\n        }\n    }\n     class B\n    {\n        static B()//静态构造器，只在运行环境加载这个类的时候调用，且只调用一次。\n        {\n            Console.WriteLine(\"B的静态构造器已执行。\");\n        }\n\n        public B()\n        {\n            Console.WriteLine(\"B的实例构造器已执行。\");\n        }\n\n        public int id\n        {\n            get; set;\n        }\n    }\n}\n```\n\n\n\n\n\n## 析构器\n\n析构方法（析构器）是在垃圾回收、释放资源时使用的。\n\n- 不能在结构中定义析构函数。只能对类使用析构函数。\n- 析构函数不能重载，一个类只能有一个析构函数。\n- 析构函数无法继承，他的子类将拥有除父类的析构函数外的所有元素（先执行子类的构造函数，再执行父类的构造函数。如果需要手动调用父类的构造函数，可以用base关键字）。\n- 无法调用析构函数。它们是被自动调用的。\n- 析构函数既没有修饰符，也没有参数。\n\n\n\n### 基本语法\n\n```c#\n~方法名()\n{\n    语句块；\n}\n```\n\n无法控制何时调用析构函数，因为这是由垃圾回收器决定的。垃圾回收器检查是否存在应用程序不再使用的对象。如果垃圾回收器认为某个对象符合析构，则调用析构函数（如果有）并回收用来存储此对象的内存。程序退出时也会调用析构函数。\n\n可以通过调用 `Collect` 强制进行垃圾回收，但大多数情况下应避免这样做，因为这样会导致性能问题。有关更多信息，请参见强制垃圾回收。\n\n\n\n\n\n\n\n\n\n## 接口\n\n​\t接口定义了所有类继承接口时应遵循的语法合同。接口定义了语法合同 \"是什么\" 部分，派生类定义了语法合同 \"怎么做\" 部分。\n\n​\t接口定义了属性、方法和事件，这些都是接口的成员。接口只包含了成员的声明。成员的定义是派生类的责任。接口提供了派生类应遵循的标准结构。\n\n​\t接口使得实现接口的类或结构在形式上保持一致。\n\n​\t抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。\n\n​\t接口本身并不实现任何功能，它只是和声明实现该接口的对象订立一个必须实现哪些行为的契约。\n\n​\t抽象类不能直接实例化，但允许派生出具体的，具有实际功能的类。\n\n​\t可以使用virtual或abstract来实现接口成员，但不能使用static或const。\n\n### 定义接口: MyInterface.cs\n\n接口使用 `interface` 关键字声明，它与类的声明类似。接口声明默认是 `public` 的。下面是一个接口声明的实例：\n\n```c#\ninterface IMyInterface\n{\n    void MethodToImplement();\n}\n```\n\n以上代码定义了接口 IMyInterface。通常接口命令以 `I` 字母开头，这个接口只有一个方法 MethodToImplement()，没有参数和返回值，当然我们可以按照需求设置参数和返回值。\n\n值得注意的是，该方法**并没有具体的实现**。\n\n接下来我们来实现以上接口：InterfaceImplementer.cs\n\n#### 样例\n\n```c#\nusing System;\n\ninterface IMyInterface\n{\n        // 接口成员\n    void MethodToImplement();\n}\n\nclass InterfaceImplementer : IMyInterface\n{\n    static void Main()\n    {\n        InterfaceImplementer iImp = new InterfaceImplementer();\n        iImp.MethodToImplement();\n    }\n\n    public void MethodToImplement()\n    {\n        Console.WriteLine(\"MethodToImplement() called.\");\n    }\n\n}\n```\n\n`InterfaceImplementer` 类实现了 `IMyInterface` 接口，接口的实现与类的继承语法格式类似：\n\n```c#\nclass InterfaceImplementer : IMyInterface\n```\n\n​\t继承接口后，我们需要实现接口的方法 `MethodToImplement()` , 方法名必须与接口定义的方法名一致。\n\n### 接口继承: InterfaceInheritance.cs\n\n以下实例定义了两个接口 `IMyInterface` 和 `IParentInterface`。\n\n如果一个接口继承其他接口，那么实现类或结构就需要实现所有接口的成员。\n\n以下实例 `IMyInterface` 继承了 `IParentInterface` 接口，因此接口实现类必须实现 `MethodToImplement()` 和 `ParentInterfaceMethod()` 方法：\n\n#### 样例\n\n```c#\nusing System;\n\ninterface IParentInterface\n{\n    void ParentInterfaceMethod();\n}\n\ninterface IMyInterface : IParentInterface\n{\n    void MethodToImplement();\n}\n\nclass InterfaceImplementer : IMyInterface\n{\n    static void Main()\n    {\n        InterfaceImplementer iImp = new InterfaceImplementer();\n        iImp.MethodToImplement();\n        iImp.ParentInterfaceMethod();\n    }\n\n    public void MethodToImplement()\n    {\n        Console.WriteLine(\"MethodToImplement() called.\");\n    }\n    \n    public void ParentInterfaceMethod()\n    {\n        Console.WriteLine(\"ParentInterfaceMethod() called.\");\n    }\n\n}\n```\n\n实例输出结果为：\n\n```bash\nMethodToImplement() called.\nParentInterfaceMethod() called.\n```\n\n\n\n\n\n\n\n\n\n## 嵌套类\n\n嵌套类顾名思义就是类或者结构中定义的类\n\n```c#\nclass Container\n{\n    class Nested\n    {\n        Nested() { }\n    }\n}\n```\n\n- 嵌套类的默认访问权限是private ，可以指定为public，protected，private，internal，protected internal。\n- 嵌套类型可以访问外部类（包裹嵌套类的类），如果要访问外部类型，要把外部类通过构造函数传进一个实例\n- 嵌套类中只能访问外部类中的静态成员，不能直接访问外部类的非静态成员。\n\n\n\n```c#\nnamespace ConsoleApplication11Anonymous\n{\n    class Class1\n    {\n        private int x;\n        protected string str;\n        static int y;\n        public class Nested\n        {\n            int xx;\n            string ss;\n            void print()\n            {\n                //int y = x;  //error,不能访问外部的非静态成员\n                int z = y;    //OK ,可以访问外部的静态成员\n            }\n            public Nested(Class1 A)\n            {\n                xx = A.x;   //通过外部类的实例来访问外部类私有成员\n                ss = A.str; //通过外部类的实例来访问外部类保护成员\n            }\n        }\n    } \n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Class1 X = new Class1();\n            Class1.Nested CN = new Class1.Nested( X );     \n        } \n     }\n}\n```\n\n\n\n根据C#作用域的规则，外部类只能通过内部类的实例来访问内部类的public成员，不能访问protected，private。\n\n```c#\nclass Class2\n    {\n        private int x;\n        static private int y;\n \n        public void func()\n        {\n            //x = xx;   //当前上下文中不存在名称“xx”\n            //x = zz;   //当前上下文中不存在名称“zz”\n            //x = aa;   //当前上下文中不存在名称“aa”\n            x = Nested.aa;\n            Console.WriteLine(x);\n        }\n \n        public void funcs()\n        {\n            //这个只能访问Nested类的public成员\n            Nested XX = new Nested();\n            x = XX.zz;\n            Console.WriteLine(x);\n            //x = XX.aa;//访问静态成员只能通过类名而不是实例\n            x = Nested.aa;\n            Console.WriteLine(x);\n        }\n \n        private class Nested\n        {\n            private int xx;\n            protected int yy;\n            public int zz;\n            public static int aa;\n            \n        }\n}\n```\n\n\n\n## C# 访问级别\n\n​\t**封装** 被定义为\"把一个或多个项目封闭在一个物理的或者逻辑的包中\"。在面向对象程序设计方法论中，封装是为了防止**对实现细节的访问**。\n\n​\t抽象和封装是面向对象程序设计的相关特性。抽象允许相关信息可视化，封装则使开发者*实现所需级别的抽象*。\n\n​\tC# 封装根据具体的需要，设置使用者的访问权限，并通过 **访问修饰符** 来实现。\n\n同一修饰符在一个类的声明中多次出现是编译时错误\n\n\n\n在C#中，不同的类型和成员有不同的默认访问级别，如下：\n\n- 类型（类、结构、枚举、委托等）在命名空间中声明时，默认访问级别是内部的（internal），这意味着它们只能在同一个程序集中访问；在其他类型中嵌套时，默认访问级别是私有的，这意味着它们只能在包含它们的类型中访问。\n- 类型成员（字段、属性、方法、事件等）默认访问级别是私有的，这意味着它们只能在类内部访问。\n- 接口成员默认访问级别是公共的，这意味着它们必须在实现接口的类或结构中公开。\n\n不好意思深夜打扰老师了，刚刚遇到一个小问题，关于c# 中的gethashcode方法，new bing回答我的时候说到了“GetHashCode()方法返回的值不能用来判断对象是否相等，也不能用来存储或比较数据”，我有点没看懂这个意思，gethashcode方法是不能可靠的辨别对象是否是同一个吗？\n\n\n\n\n\n一个 **访问修饰符** 定义了一个类成员的范围和可见性。C# 支持的访问修饰符如下所示：\n\n- public：所有对象都可以访问；\n- private：对象本身在对象内部可以访问；\n- protected：只有该类对象及其子类对象可以访问\n- internal：同一个程序集的对象可以访问；\n- protected internal：访问限于当前程序集或派生自包含类的类型。\n- sealed：用于修饰类。一旦类被这个关键字所修饰，就不允许再被继承。\n\n### Public 访问修饰符\n\nPublic 访问修饰符允许一个类将其成员变量和成员函数暴露给其他的函数和对象。任何公有成员可以被外部的类访问。\n\n下面的实例说明了这点：\n\n```c#\nusing System;\n\nnamespace RectangleApplication\n{\n  class Rectangle\n  {\n    *//成员变量*\n    public double length;\n    public double width;\n\n    public double GetArea()\n    {\n      return length * width;\n    }\n    public void Display()\n    {\n      Console.WriteLine(\"长度： {0}\", length);\n      Console.WriteLine(\"宽度： {0}\", width);\n      Console.WriteLine(\"面积： {0}\", GetArea());\n    }\n  }*// Rectangle 结束*\n\n  class ExecuteRectangle\n  {\n    static void Main(string[] args)\n    {\n      Rectangle r = new Rectangle();\n      r.length = 4.5;\n      r.width = 3.5;\n      r.Display();\n      Console.ReadLine();\n    }\n  }\n}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```\n长度： 4.5\n宽度： 3.5\n面积： 15.75\n```\n\n在上面的实例中，成员变量 length 和 width 被声明为 public，所以它们可以被函数 Main() 使用 Rectangle 类的实例 r 访问。\n\n成员函数 *Display()* 和 *GetArea()* 可以直接访问这些变量。\n\n成员函数 *Display()* 也被声明为 public，所以它也能被 *Main()* 使用 Rectangle 类的实例 r 访问。\n\n### Private 访问修饰符\n\nPrivate 访问修饰符允许一个类将其成员变量和成员函数对其他的函数和对象进行隐藏。只有同一个类中的函数可以访问它的私有成员。即使是类的实例也不能访问它的私有成员。\n\n下面的实例说明了这点：\n\n```c#\nusing System;\nnamespace RectangleApplication\n{\n  class Rectangle\n  {\n    *//成员变量*\n    private double length;\n    private double width;\n\n    public void Acceptdetails()\n    {\n      Console.WriteLine(\"请输入长度：\");\n      length = Convert.ToDouble(Console.ReadLine());\n      Console.WriteLine(\"请输入宽度：\");\n      width = Convert.ToDouble(Console.ReadLine());\n    }\n    public double GetArea()\n    {\n      return length * width;\n    }\n    public void Display()\n    {\n      Console.WriteLine(\"长度： {0}\", length);\n      Console.WriteLine(\"宽度： {0}\", width);\n      Console.WriteLine(\"面积： {0}\", GetArea());\n    }\n  }*//end class Rectangle*   \n  class ExecuteRectangle\n  {\n    static void Main(string[] args)\n    {\n      Rectangle r = new Rectangle();\n      r.Acceptdetails();\n      r.Display();\n      Console.ReadLine();\n    }\n  }\n}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```\n请输入长度：\n4.4\n请输入宽度：\n3.3\n长度： 4.4\n宽度： 3.3\n面积： 14.52\n```\n\n在上面的实例中，成员变量 length 和 width 被声明为 private，所以它们不能被函数 Main() 访问。\n\n成员函数 *AcceptDetails()* 和 *Display()* 可以访问这些变量。\n\n由于成员函数 *AcceptDetails()* 和 *Display()* 被声明为 public，所以它们可以被 *Main()* 使用 Rectangle 类的实例 r 访问。\n\n### Protected 访问修饰符\n\nProtected 访问修饰符允许子类访问它的基类的成员变量和成员函数。这样有助于实现继承。我们将在继承的章节详细讨论这个。更详细地讨论这个。\n\n### Internal 访问修饰符\n\nInternal 访问说明符允许一个类将其成员变量和成员函数暴露给当前程序中的其他函数和对象。换句话说，带有 internal 访问修饰符的任何成员可以被定义在该成员所定义的应用程序内的任何类或方法访问。\n\n如果一个类前面没有添加任何修饰符，则相当于添加了Internal修饰符。\n\n但，如果声明了internal，则在同一个项目中可以访问，在其他项目中无法访问。\n\n简单的说就是阻止跨项目的访问。\n\n#### 样例：\n\n环境说明：一个ConsoleApp项目下的Program文件，其中的命名空间时ConsoleApp，并且在ConsoleApp项目中的引用里添加了MyLib的引用\n\n一个MyLib类库下的Calculator文件，其中的命名空间为MyNamespace。\n\n一个MyLib类库下的test文件，其中的命名空间为MyNamespace2。\n\n\n\n##### Program文件：\n\n```c#\nusing System;\nusing System.Windows.Forms;\n\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            //MyLib.MyNamespace.ADD Add = new MyLib.MyNamespace.ADD();//编译器报错： 错误 CS0122\t“ADD”不可访问，因为它具有一定的保护级别 \n\n            MyLib.MyNamespace.SUB Sub = new MyLib.MyNamespace.SUB();//public修饰的则可以正常的访问\n            Console.ReadKey();\n        }\n    }\n}\n```\n\n##### Calculator文件\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace MyLib.MyNamespace\n{\n    internal class ADD\n    {\n        public double Add(double x, double y)\n        {\n            return x + y;\n        }\n    }\n\n    public class SUB\n    {\n        public double Sub(double x, double y)\n        {\n            return x - y;\n        }\n    }\n\n    public class test\n    {\n        ADD Add = new ADD();//在同一个命名空间中可以访问\n    }\n}\n```\n\n##### test文件\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace MyLib.MyNamespace2\n{\n    internal class test\n    {\n        MyNamespace.ADD Add = new MyNamespace.ADD();//同一项目下跨命名空间也是可以访问的\n    }\n}\n\n```\n\n![image-20230306085856474](./Image/C#学习笔记_基础教程.assets/image-20230306085856474.png)\n\n\n\n\n\n\n\n\n\n### Protected Internal 访问修饰符\n\nProtected Internal 访问修饰符允许在本类,派生类或者包含该类的程序集中访问。这也被用于实现继承。\n\n\n\n\n\n\n\n\n\n# 面向对象编程（OOP）\n\n\n\n\n\n\n\n## 继承\n\n继承是OOP的最重要的特征之一，任何类都可以从另一个类继承。\n\n​\t继承的本质是派生类在基类已有的成员的基础上，对基类进行的横向的和纵向的扩展。\n\n- 派生类基于已有的成员\n  - 当继承发生时，子类继承了父类所有的成员（除了构造函数和析构函数）\n- 在派生和继承的过程中，进行的是扩展\n  - 类的成员只能是越来越多，不可能减少。即不可以删除任何已有的成员。\n  - 一个类成员一旦被引入到继承链中，就会一直向下传递。\n  - 不要贸然引入新的类成员，不然可能造成对继承链的污染\n  - 部分动态语言可以做到移除成员变量，如python、js\n- 横向指的是添加类成员，纵向指的是重写类成员\n\n\n\n> ​\t在UML中，公共成员用+表示，其他成员用一(私有成员)、#(受 保护的成员)和斜体(虚拟成员)表示。\n>\n> ​\t虚拟成员不能是私有成员，因为这样会自相矛盾一不能既要求派生类重写成员，又不让派生类访问该成员。\n>\n> ​\tC#提供了第三种可访问性: protected, 只有派生类才能访问protected成员。对于外部代码来说，这个可访问性与私有成员一样:外部代码不能访问private成员和protected成员。详细说明见上方类与成员中\n\n\n\n### 继承的特性\n\n- 当子类的构造器被调用的时候，会自动调用父类的构造器。先调用父类，再调用子类。当结束时，会按照与构造器调用顺序相反的顺序调用析构器。\n\n  - ```c#\n    using System;\n    using System.Windows.Forms;\n    \n    namespace ConsoleApp\n    {\n        internal class Program\n        {\n            static void Main(string[] args)\n            {\n                A a = new A();\n                B b = new B();\n                //输出结果：\n                //A的构造器被调用了\n                //A的构造器被调用了\n                //B的构造器被调用了\n                //B的析构器被调用了\n                //A的析构器被调用了\n                //A的析构器被调用了\n                //请按任意键继续. . .\n    \n                Console.ReadKey();\n            }\n        }\n        class A\n        {\n            public A()\n            {\n                Console.WriteLine(\"A的构造器被调用了\");\n            }\n            ~A()\n            {\n                Console.WriteLine(\"A的析构器被调用了\");\n            }\n        }\n        class B : A\n        {\n            public B()\n            {\n                Console.WriteLine(\"B的构造器被调用了\");\n            }\n            ~B()\n            {\n                Console.WriteLine(\"B的析构器被调用了\");\n            }\n        }\n    \n    }\n    ```\n\n    \n\n- 一个类可以被多个类继承，但一个类只能继承一个类，整个关系呈现一个 `树状` 的形态\n\n- 子类 is a 父类。一个子类的实例同时也是父类的一个实例。子类是属于父类的，在子类实例化的对象可以被父变量所指向，但父变量只能调用一些父类中拥有的成员。\n\n  - ```c#\n    using System;\n    using System.Windows.Forms;\n    \n    namespace ConsoleApp\n    {\n        internal class Program\n        {\n            static void Main(string[] args)\n            {\n                A a = new A();\n                B b = new B();\n                A c = new B();\n                a.showinfo();//输出A\n                b.showinfo();//B\n                c.showinfo();//A \n                Console.WriteLine(a is B);//false，证明父类不属于子类\n                Console.WriteLine(b is A);//true，证明子类属于父类\n                Console.ReadKey();\n            }\n        }\n    \n        class A\n        {\n            public void showinfo()\n            {\n                Console.WriteLine(\"A\");\n            }\n        }\n        class B : A\n        {\n            public void showinfo()\n            {\n                Console.WriteLine(\"B\");\n            }\n        }\n    \n    }\n    ```\n\n- 在子类中可以使用base关键字访问父类的元素，但只能向上访问一层。\n\n  - ```c#\n    using System;\n    using System.Windows.Forms;\n    \n    namespace ConsoleApp\n    {\n        internal class Program\n        {\n            static void Main(string[] args)\n            {\n                A a = new A();\n                B b = new B();\n                a.ShowInfo();//A\n                b.ShowInfo();//B\n                b.ShoeInfoFa();//A\n    \n                Console.ReadKey();\n            }\n        }\n    \n        class S\n        {\n            public string str { get; set; }\n        }\n    \n        class A : S\n        {\n            public string str { get; set; }\n            public A()\n            {\n                str = \"A\";\n            }\n            public void ShowInfo()\n            {\n                Console.WriteLine(str);\n            }\n        }\n        class B : A\n        {\n            public string str { get; set; }\n            public B()\n            {\n                str = \"B\";\n            }\n            public void ShowInfo()\n            {\n                Console.WriteLine(str);\n            }\n            public void ShoeInfoFa()\n            {\n                Console.WriteLine(base.str);\n                //base.base.str = \"A\";  //是不被允许的\n            }\n        }\n    \n    }\n    ```\n\n\n- 子类的访问权限不能超越父类的访问权限。如父类的一个字段是保护的，可以将这个字段在子类中设置成私有、保护  ，但不能设置成public或internal。\n\n  \n\n## 多态性\n\n多态是同一个行为具有多个不同表现形式或形态的能力。\n\n**多态性**意味着有多重形式。在面向对象编程范式中，多态性往往表现为\"一个接口，多个功能\"。\n\n多态性可以是静态的或动态的。在**静态多态性**中，函数的响应是在编译时发生的。在**动态多态性**中，函数的响应是在运行时发生的。\n\n在 C# 中，每个类型都是多态的，因为包括用户定义类型在内的所有类型都继承自 Object。\n\n多态就是同一个接口，使用不同的实例而执行不同操作。\n\n多态的概念：让一个对象能够表现出多种状态。\n\n### 静态多态性\n\n在编译时，函数和对象的连接机制被称为早期绑定，也被称为静态绑定。C# 提供了两种技术来实现静态多态性。分别为：\n\n- 函数重载\n  - 具体见C#的类与成员中的方法部分 其中介绍了方法的重载\n- 运算符重载\n\n\n\n#### 运算符重载\n\n##### 概述\n\n可以重定义或重载 C# 中内置的运算符。因此，程序员也可以使用用户自定义类型的运算符。重载运算符是具有特殊名称的函数，是通过关键字 **operator** 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。\n\n注意，只能重载现有的C#运算符，不能创建新的运算符。\n\n​\t运算符重载其实就是函数重载。首先通过指定的运算表达式调用对应的运算符函数，然后再将运算对象转化为运算符函数的实参，接着根据实参的类型来确定需要调用的函数的重载，这个过程是由编译器完成。\n\n\n\n##### 可重载和不可重载运算符\n\n| 运算符                                | 描述                                               |\n| :------------------------------------ | :------------------------------------------------- |\n| +, -, !, ~, ++, --                    | 这些      一元运算符只有一个操作数，且可以被重载。 |\n| +, -, *, /, %                         | 这些二元运算符带有两个操作数，且可以被重载。       |\n| ==, !=, <, >, <=, >=                  | 这些比较运算符可以被重载。                         |\n| &&, \\|\\|                              | 这些条件逻辑运算符不能被直接重载。                 |\n| +=, -=, *=, /=, %=                    | 这些赋值运算符不能被重载。                         |\n| =, ., ?:, ->, new, is, sizeof, typeof | 这些运算符不能被重载。                             |\n\n\n\n##### 自定义类型转换\n\n###### 自定义隐式类型转换\n\n​\timplicit 关键字用于声明隐式的用户定义类型转换运算符。\n\n​\t如果可以确保转换过程不会造成数据丢失，则可使用该关键字在用户定义类型和其他类型之间进行隐式转换。隐式转换可以通过消除不必要的类型转换来提高源代码的可读性。 但是，因为隐式转换不需要程序员将一种类型显式强制转换为另一种类型，所以使用隐式转换时必须格外小心，以免出现意外结果。\n\n```c#\nusing System;\nnamespace ConsoleApp\n{ \n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Person p = new(\"张三\");\n            string str1 = p;\n\n            Console.WriteLine(str1);//输出张三\n\n            Console.ReadKey();\n        }\n    }\n    //Person类中此时只有一个属性Name，可以无损的转换成为string，因此可以使用自定义隐式类型转换进行转换\n    class Person\n    {\n        public string Name { get; set; }//姓名\n\n        public Person(string name)\n        {\n            Name = name;\n        }\n\n        public static implicit operator string(Person p)\n        {\n            return p.Name;\n        }\n    }\n}\n```\n\n\n\n\n\n###### 自定义显示类型转换\n\n当类型转换时会（可能）发生数据丢失，此时需要定义显式类型转换而不是隐式转换\n\n定义语法与隐式类似，只是关键字由`implicit`换成了`explicit`\n\n```c#\nusing System;\nnamespace ConsoleApp\n{ \n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Person p = new(\"张三\");\n            string str1 = (string)p;\n            int id = (int)p;\n            Console.WriteLine(str1);//输出张三\n            Console.WriteLine(id);\n\n            Console.ReadKey();\n        }\n    }\n    // Person类中此时有两个属性：Name、Id\n    // 不可以无损的转换到int或string，因此需要显式类型转换\n    class Person\n    {\n        static int id;\n        public string Name { get; set; }//姓名\n        public int uid { get; private set; }//序列号\n\n        public Person(string name)\n        {\n            id++;\n            Name = name;\n            uid = id;\n        }\n\n        public static explicit operator string(Person p)\n        {\n            return p.Name;\n        }\n\n        public static explicit operator int(Person p)\n        {\n            return p.uid;\n        }\n    }\n}\n```\n\n\n\n###### 反向隐式类型转换\n\n整个过程也可以反过来，用一个string类型的变量隐式的转换成Person类型的对象。\n\n```c#\nusing System;\nnamespace ConsoleApp\n{ \n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string str = \"张三\";\n            Person p = str;\n\n            Console.WriteLine(p.uid);\n            Console.WriteLine(p.Name);\n\n            Console.ReadKey();\n        }\n    }\n    // 自定义的反向隐式类型转换\n    class Person\n    {\n        static int id;\n        public string Name { get; set; }//姓名\n        public int uid { get; private set; }//序列号\n\n        public Person(string name)\n        {\n            id++;\n            Name = name;\n            uid = id;\n        }\n\n        public static implicit operator Person(string name)\n        {\n            return new Person(name);\n        }\n    }\n}\n```\n\n###### 反向显式类型转换\n\n既然可以反向隐式类型转换，那么就可以反向的显式类型转换。\n\n```c#\nusing System;\nnamespace ConsoleApp\n{ \n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string str = \"张三\";\n            Person p = (Person)str;\n\n            Console.WriteLine(p.uid);\n            Console.WriteLine(p.Name);\n\n            Console.ReadKey();\n        }\n    }\n    // 自定义的反向隐式类型转换\n    class Person\n    {\n        static int id;\n        public string Name { get; set; }//姓名\n        public int uid { get; private set; }//序列号\n\n        public Person(string name)\n        {\n            id++;\n            Name = name;\n            uid = id;\n        }\n\n        public static explicit operator Person(string name)\n        {\n            return new Person(name);\n        }\n    }\n}\n```\n\n\n\n\n\n###### 自定义类型转换的注意事项\n\n- 一般情况下，隐式转换运算符应当从不引发异常并且从不丢失信息，以便可以在程序员不知晓的情况下安全使用它们。 如果转换运算符不能满足那些条件，则应将其标记为 explicit（显示类型转换）。\n- 如果定义了隐式类型转换，则使用显式类型转换的语法也可以通过编译。\n\n\n\n##### 声明\n\noperator 关键字用于在类或结构声明中声明运算符。运算符声明可以采用下列四种形式之一：\n\n- public static result-type operator unary-operator ( op-type operand )\n- public static result-type operator binary-operator ( op-type operand, op-type2 operand2 )\n- public static implicit operator conv-type-out ( conv-type-in operand )\n- public static explicit operator conv-type-out ( conv-type-in operand )\n\n 参数说明：\n\n　　result-type：运算符的结果类型。\n　　unary-operator：下列运算符之一：+ - ! ~ ++ — true false\n　　op-type：第一个（或唯一一个）参数的类型。\n　　operand：第一个（或唯一一个）参数的名称。\n　　binary-operator：其中一个：+ - * / % & | ^ << >> == != > < >= <=\n　　op-type2：第二个参数的类型。\n　　operand2：第二个参数的名称。\n　　conv-type-out：类型转换运算符的目标类型。\n　　conv-type-in：类型转换运算符的输入类型。\n\n注意\n\n- 运算符重载的声明方式：operator 关键字告诉编译器，它实际上是一个运算符重载，后面是相关运算符的符号。\n- 运算符只能采用值参数，不能采用ref或out参数。可参考注意事项一实例。\n- 前两种形式声明了用户定义的重载内置运算符的运算符。op-type 和 op-type2 中**至少有一个必须是封闭类型**（即运算符所属的类型，或理解为自定义的类型）。例如，这将防止重定义整数加法运算符。可参考注意事项二实例。\n- 后两种形式声明了转换运算符。conv-type-in 和 conv-type-out 中正好有一个必须是封闭类型（即转换运算符只能从它的封闭类型转换为其他某个类型，或从其他某个类型转换为它的封闭类型）。\n- 对于二元运算符，第一个参数是放在运算符左边的值，一般命名为lhs；第二个参数是放在运算符右边的值，一般命名为rhs。\n- C#要求所有的运算符重载都声明为**public**和**static**，必须是类的静态方法，这表示**它们与它们的类或结构相关联，而不是与实例相关联**。\n\n\n\n##### 样例\n\n```c#\nusing System;\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Number n = new(-1);\n            Console.WriteLine(n);// -1\n            Number n2 = + n;//\n            Console.WriteLine(n2);// 1\n            n = -n2;\n            Console.WriteLine(n);// -1\n            n++;\n            Console.WriteLine(n);//0\n\n            Console.ReadKey();\n        }\n    }\n    // 自定义的反向隐式类型转换\n    class Number\n    {\n        public int Value { get; set; }\n        public Number(int value)\n        {\n            Value = value;\n        }\n        public static implicit operator string(Number n)\n        {\n            return n.Value.ToString();\n        }\n        //重载-符号 使得值强制取反\n        public static Number operator -(Number n)\n        {\n            n.Value = n.Value * -1;\n            return n;\n        }\n        //重载-符号 使得值强制为正数\n        public static Number operator +(Number n)\n        {\n            if(n.Value < 0)\n            {\n                positive(n);\n            }\n            return n;\n        } \n        // 重载++\n        public static Number operator ++ (Number n)\n        {\n            n.Value++;\n            return n;\n        }\n        //辅助函数\n        private static Number positive(Number n)\n        {\n            n.Value = n.Value * -1;\n            return n;\n        }\n    }\n}\n```\n\n\n\n\n### 动态多态性\n\nC# 允许使用关键字 **abstract** 创建抽象类，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。**抽象类**包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。\n\n请注意，下面是有关抽象类的一些规则：\n\n- 您不能创建一个抽象类的实例。\n- 您不能在一个抽象类外部声明一个抽象方法。\n- 通过在类定义前面放置关键字 **sealed**，可以将类声明为**密封类**。当一个类被声明为 **sealed** 时，它不能被继承。抽象类不能被声明为 sealed。\n\n\n\n\n\n#### 抽象类\n\n​\t抽象类指的是函数成员没有被完全实现的类。（有至少一个函数成员没被实现）\n\n​\t反过来，如果一个类的成员全部都实现了，就是具体类。\n\n​\t在抽象类中，没被实现的成员一定要用`abstract`关键字修饰，而且这个成员不能是`private`类型。因为私有类型不允许被重写，因此将无法将抽象类转变为具体类。\n\n​\t换句话说，一旦一个成员被`abstract`修饰，就就不能实现。\n\n​\t同时，抽象类也必须要用`abstract`进行修饰。\n\n​\t抽象类不允许被实例化，只能被继承或声明变量引用一个子类实例。\n\n​\t当抽象类作为变量引用子类实例时，通过抽象类调用的是子类的方法而不是父类的方法。\n\n​\t当子类实现父类的抽象方法时，子类成员需要加上`override`关键字\n\n​\t抽象方法在某些语言中也被称为纯虚方法。\n\n​\t当一个类没有任何实现的方法，全是抽象成员，在Java、C#中本质上就已经是接口了\n\n##### 样例\n\n```c#\nusing System;\nusing System.Windows.Forms;\n\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            //A a = new A();//一旦一个类是抽象类了，则这个类就不能实例化成对象\n            A c = new C();//但可以作为变量接收子类的实例.\t当抽象类作为变量引用子类实例时，通过抽象类调用的是子类的方法而不是父类的方法。\n            B b = new B();\n            c.ShowClassName();   //this is C\n            b.ShowClassName();   //this is B\n            c.Show();            //A 的 show被执行//不影响父类中已有的类\n\n\n            Console.ReadKey();\n        }\n    }\n    abstract class A//同时类名也需要加上abstract关键字\n    {\n        abstract public void ShowClassName();//当一个类需要多次被子类修改，且在父类中没有实现的必要，就可以使用抽象。关键字abstract\n        public void Show()\n        {\n            Console.WriteLine(\"A 的 show被执行\");\n        }\n    }\n    class B : A\n    {\n        public override void ShowClassName()//当子类实现父类的抽象方法时，子类成员需要加上`override`关键字。\n        {\n            Console.WriteLine(\"this is B\");\n        }\n        public void Show()\n        {\n            Console.WriteLine(\"B 的 show被执行\");\n        }\n    }\n    class C : A\n    {\n        public override void ShowClassName()\n        {\n            Console.WriteLine(\"this is C\");\n        }\n        public void Show()\n        {\n            Console.WriteLine(\"C 的 show被执行\");\n        }\n    }\n\n}\n```\n\n\n\n### 接口\n\n- 一个纯抽象类的本质就是接口。接口是由抽象类进化而来。\n\n  - 进化过程：\n    - ![image-20230312203400886](./Image/C#学习笔记_基础教程.assets/image-20230312203400886.png)\n    - 接口中的抽象方法不需要`abstract`修饰\n    - 抽象类中的方法不允许是`private`，但接口中的**抽象方法**必须是`public`（不允许有修饰符，强制public）\n    - 注意：接口的默认访问修饰符是internal，接口的成员才是public！！！！！\n\n- 接口的产生：自底向上（重构），自顶向下（设计）\n\n  - 自顶向下一般适用于非常了解技术、业务逻辑的人。\n\n  - 自底向下一般在重构代码的时候使用。\n\n- 与抽象类一样 也不允许实例化，但一样允许作为接口接收子类的实例。当通过接口调用子类的成员时，会调用最先实现这个成员的类所在的数据  \n\n- 定义与抽象类类似，类的关键字由`abstract`关键字替换为`interface`。\n\n- 接口要求内部所有成员的访问权限均是public。\n\n  - 声明接口类时默认就是public\n  - 里面的成员也不需要额外的声明，只需要返回值、方法名、参数列表这些基本元素即可。\n\n- 当一个类没有实现接口的所有方法时，此时这个类就转换为了抽象类，要遵循抽象类的约束。类前面加上abstract\n\n- 接口的命名：不成文的约定：以i开头，加上一个名词。\n\n- 接口即契约：甲方“我不会多要”；乙方“我不会少给”。\n\n  - 乙方不会少给：硬性规定，即一个类只要实现了接口，就必需实现接口里面的所有方法，一旦未全部实现，类就还只是个抽象类，就不能实例化\n  - 甲方不会多要：软性规定，是个设计问题\n\n- 接口还保证调用者去调用这些功能的时候都是实现好的，只需要关注功能，不需要关注功能是谁提供的。\n\n- 在代码中 只要有可以替换的地方，就一定会有接口的存在。\n\n- 接口就是为了解耦而生。\n\n- 松耦合它最大的好处就是可以让这个功能的提供方变得可替换，从而降低紧耦合的时候功能的提供方不能被替换所带来的这个高风险和高成本\n\n- 使用接口替换调实例变量时，只能调用接口内约定的方法。\n\n  \n\n#### 接口隔离：显式接口实现\n\n使用接口替换调实例变量时，只能调用接口内约定的方法。\n\n```c#\nusing System;\nusing System.Collections;\nusing System.Runtime.Remoting.Messaging;\nusing System.Windows.Controls;\nusing System.Windows.Forms;\nusing System.Xml.Linq;\n\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            IA a = new A();\n            IB b = new A();\n            a.A();//由于接口是显式实现，因此只能调用接口中约定的方法\n            //a.B();\n            b.B();//b也一样\n\n            Console.ReadKey();\n        }\n    }\n\n    interface IA\n    {\n        void A();\n    }\n    interface IB\n    {\n        void B();\n    }\n    class A : IA, IB\n    {\n        void IA.A()//接口的显式实现\n        {\n            Console.WriteLine(\"A方法\");\n        }\n        void IB.B()\n        {\n            Console.WriteLine(\"B方法\");\n        }\n    }\n\n\n\n    //一个接口，\n    public interface ICustomer\n    {\n        void SomeMethod();\n    }\n\n    //隐式实现接口,代码大致如下\n    public class Customer1 : ICustomer\n    {\n        public void SomeMethod()\n        {\n            throw new NotImplementedException();\n        }\n    }\n\n    //显式实现接口，代码大致如下\n    public class Customer2 : ICustomer\n    {\n        void ICustomer.SomeMethod()//\n        {\n            throw new NotImplementedException();\n        }\n    }\n\n}\n```\n\n\n\n#### 样例\n\n```c#\nusing System;\nusing System.Windows.Forms;\n\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            A a = new C();\n            a.ShowClassName();           //this is B    //当通过接口调用子类的成员时，会调用最先实现这个成员的类所在的数据\n            a.test();                    //C test       \n\n\n            Console.ReadKey();\n        }\n    }\n    interface A//声明接口只需要interface 接口名  即可。\n    {\n        void ShowClassName();//内部的成员只需要返回值 方法名 参数列表，不需要其他的声明标识符\n        void test();\n        \n    }\n\n    abstract class B : A//当一个类没有实现接口的所有方法时，此时这个类就转换为了抽象类，要遵循抽象类的约束。类前面加上abstract\n    {\n        public void ShowClassName()//当实现接口的时候，没必要加上override，直接按照正常的格式书写方法即可。\n        {                                                                      \n            Console.WriteLine(\"this is B\");\n        }\n       abstract public void test();//同时作为抽象方法抛给别的类\n    }\n\n    class C : B\n    {\n        public void ShowClassName()//当实现接口的时候，没必要加上override，直接按照正常的格式书写方法即可。\n        {\n            Console.WriteLine(\"this is B\");\n        }\n        public override void test()//实现的时候也需要按照抽象类的约束 加上override。\n        {\n            Console.WriteLine(\"C test\");\n        }\n    }\n}\n```\n\n\n\n#### 样例：实现对数组的求平均和求和。\n\n```c#\nusing System;\nusing System.Collections;\nusing System.Windows.Controls;\nusing System.Windows.Forms;\nusing System.Xml.Linq;\n\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            //要求：对下面两个序列求平均和求和。\n            int[] arr1 = { 1, 2, 3, 4, 5 };\n            ArrayList arr2 = new ArrayList { 1, 2, 3, 4, 5 };\n            Console.WriteLine($\"OldTools arr1 和：{OldTools.Sum(arr1)}\\t平均：{OldTools.Avg(arr1)}\");\n            Console.WriteLine($\"OldTools arr2 和：{OldTools.Sum(arr2)}\\t平均：{OldTools.Avg(arr2)}\");\n            Console.WriteLine($\"NewTools arr1 和：{NewTools.Sum(arr1)}\\t平均：{NewTools.Avg(arr1)}\");\n            Console.WriteLine($\"NewTools arr2 和：{NewTools.Sum(arr2)}\\t平均：{NewTools.Avg(arr2)}\");\n            Console.ReadKey();\n        }\n    }\n    //传统的方法：\n    static class OldTools\n    {\n        //求和\n        static public int Sum(int[] arr )\n        {\n            int sum = 0;\n            foreach(var item in arr)\n            {\n                sum += item;\n            }\n            return sum;\n        }\n\n        //求平均\n        static public double Avg(int[] arr)\n        {\n            int sum = 0;\n            double count = 0;\n            foreach(var item in arr)\n            {\n                sum += item;\n                count++;\n            }\n            return sum / count;\n        }\n\n        //求和\n        static public int Sum(ArrayList arr)\n        {\n            int sum = 0;\n            foreach (var item in arr)\n            {\n                sum += (int)item;\n            }\n            return sum;\n        }\n\n        //求平均\n        static public double Avg(ArrayList arr)\n        {\n            int sum = 0;\n            double count = 0;\n            foreach (var item in arr)\n            {\n                sum += (int)item;\n                count++;\n            }\n            return sum / count;\n        }\n    }\n\n    static class NewTools\n    {\n        //可以发现，主体部分都是foreach，foreach的本质是迭代，也就是实现了IEnumerable接口的类型都可以被迭代。\n        //因此 可以做一下修改，使用接口来接受子类的实例，可以大幅的降低代码重复\n\n        //求和\n        static public int Sum(IEnumerable arr)\n        {\n            int sum = 0;\n            foreach (var item in arr)\n            {\n                sum += (int)item;\n            }\n            return sum;\n        }\n\n        //求平均\n        static public double Avg(IEnumerable arr)\n        {\n            int sum = 0;\n            double count = 0;\n            foreach (var item in arr)\n            {\n                sum += (int)item;\n                count++;\n            }\n            return sum / count;\n        }\n    }\n\n}\n```\n\n#### 样例：解决紧耦合:引入接口\n\n```c#\nusing System;\nusing System.Collections;\nusing System.Runtime.Remoting.Messaging;\nusing System.Windows.Controls;\nusing System.Windows.Forms;\nusing System.Xml.Linq;\n\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            NokiaPhone phone1 = new NokiaPhone(); \n            PhoneUser user = new PhoneUser(phone1);//给用户一个诺基亚的手机\n            user.UserPhone();//用户使用手机\n\n            Console.WriteLine(\"\\n\\n用户更换手机了\\n\\n\");\n\n            EricssonPhone phone2 = new EricssonPhone();\n            user.phone = phone2;\n            user.UserPhone();\n\n            Console.ReadKey();\n        }\n    }\n\n    //用户\n    class PhoneUser\n    {\n        public IPhone phone { set; get; }//不再具体是某一款具体类型\n        public PhoneUser(IPhone phone)\n        {\n            this.phone = phone;\n        }\n        public void UserPhone()\n        {\n            phone.Dail();\n            phone.Send();\n            phone.Receive();\n            phone.Pickup();\n        }\n    }\n\n\n    interface IPhone\n    {\n        void Dail();//拨号\n        void Pickup();//接电话\n        void Send();//发短信\n        void Receive();//收短信\n    }\n\n    class NokiaPhone : IPhone\n    {\n        public void Dail()\n        {\n            Console.WriteLine(\"使用诺基亚打电话\");\n        }\n\n        public void Pickup()\n        {\n            Console.WriteLine(\"使用诺基亚接电话\");\n        }\n\n        public void Receive()\n        {\n            Console.WriteLine(\"使用诺基亚发短息\");\n        }\n\n        public void Send()\n        {\n            Console.WriteLine(\"使用诺基亚收短信\");\n        }\n    }\n\n    class EricssonPhone : IPhone \n    {\n        public void Dail()\n        {\n            Console.WriteLine(\"使用爱立信打电话\");\n        }\n\n        public void Pickup()\n        {\n            Console.WriteLine(\"使用爱立信接电话\");\n        }\n\n        public void Receive()\n        {\n            Console.WriteLine(\"使用爱立信发短息\");\n        }\n\n        public void Send()\n        {\n            Console.WriteLine(\"使用爱立信收短信\");\n        }\n    }\n}\n```\n\n\n\n\n\n### 接口和抽象类的概述\n\n- 接口和抽象类都是软件工程的产物\n\n- 具体类 -> 抽象类 -> 接口：越来越抽象，内部实现的东西越来越少\n\n  - 对于方法成员，方法体就是它的实现\n  - 对于数据成员，字段就是实现\n\n- 抽象类是未完全实现逻辑的类(可以有字段和public成员，它们代表了“具体逻辑”)\n\n  - 接口是完全未实现。\n\n- 抽象类为复用而生:专门作为基类来使用，也具有解耦功龍\n\n- 封装确定的，开放不确定的，推迟到合适的子类中去实现。\n\n  - 就是开闭原则\n\n- 接口是完全未实现逻辑的“类”(“纯虚类”:只有函数成员:成员全部public)\n\n- 接口为解耦而生:“高内聚，低耦合”，方便单元测试\n\n- 接口是一个“协约”，早已为工业生产所熟知(有分工必有协作，有协作必有协约)\n\n- 它们都不能实例化。只能用来声明变量、引用具体类(concrete class)的实例\n\n  - 因为有完成的成员\n\n- 依赖越直接 耦合就越紧。\n\n- 需要注意：当使用接口接口实现两个类的解耦合的时候，实际上是把紧耦合的关系转嫁给了接口也就是说，当类实现一个接口的时候，类与接口之间的关系也是“紧耦合”的。\n\n  \n\n\n\n### 依赖反转（倒置）\n\n单元测试：依赖反转（依赖倒置）在开发中的直接应用和直接受益者。\n\n自顶向下 逐步求精。\n\n![image-20230313104007404](./Image/C#学习笔记_基础教程.assets/image-20230313104007404.png)\n\n可以看到，图片中右侧有效的改善了依赖。\n\n所谓的依赖倒置，就是由原本的司机直接指向类，变成类指向一个接口，然后再用另一个类去调用这个接口的方法（IVehicle）。\n\n再次进化：\n\n![image-20230313104436372](./Image/C#学习笔记_基础教程.assets/image-20230313104436372.png)\n\n\n\nDriverBase派生出了两个子类：Driver、AiDriver。当需要这两个类调用Car、Truck类的时候，只需要通过IVehicle字段调用自己的run方法即可。\n\n这样以来，Driver可以驱动Car和Truck，AiDriver也可以驱动这两个类。\n\n\n\n\n\n#### 单元测试（使用依赖倒置）（需完善）\n\n对DeskFan进行测试，如果直接修改Power电压 可能会造成其他使用这个Power的类损毁（出bug）。\n\n```c#\nusing System;\nusing System.Collections;\nusing System.Runtime.Remoting.Messaging;\nusing System.Windows.Controls;\nusing System.Windows.Forms;\nusing System.Xml.Linq;\n\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            DeskFan fan = new DeskFan(new PowerSupply());//创建一个电扇，并给电扇配一个电源\n            Console.WriteLine(fan.Work()); //输出风扇的工作状态\n\n\n            Console.ReadKey();\n        }\n    }\n\n    class PowerSupply\n    {\n        public int GetPower()//想要测试的话 只能修改程序里面的值。当程序创建完成后 不可以轻易修改。\n        {\n            return 100;//标准电源 输出100\n        }\n    }\n    class DeskFan\n    {\n        private PowerSupply powerSupply;\n        public DeskFan(PowerSupply powerSupply)\n        {\n            this.powerSupply = powerSupply;\n        }\n        public string Work()\n        {\n            int power = powerSupply.GetPower();\n            if(power <= 0)\n            {\n                return \"不工作\";\n            }\n            else if(power < 100) \n            {\n                return \"Slow\";\n            }\n            else if(power < 200)\n            {\n                return \"Fast\";\n            }\n            else\n            {\n                return \"电压过高\";\n            }\n        }\n    }\n}\n```\n\n进行自底向上的解耦重构并进行单元测试。\n\n一般测试的时候，新建一个测试项目而不是在原先的项目上测试。\n\n```c#\n\n```\n\n\n\n\n\n显示类型实现\n\n\n\n\n\n\n\n\n\n### 反射\n\n反射并不是C#的功能，而是.Net框架的功能。换句话说就是，只要有.Net框架的地方，都可以实现反射。\n\n反射：以不变应万变\n\n#### 依赖注入\n\n \n\n\n\n\n\n### 虚方法\n\n对于用父类对象调用子类方法的时候，会从父类开始，向子类搜索第一个能被调用的方法。如果从父类到最终子类的途中存在已经实现了的方法，就直接调用这个方法。如果强制调用子类方法，则需要手动将父类转换成对应子类后调用。\n\n```c#\nusing System;\nusing System.Collections;\nusing System.ComponentModel;\nusing System.IO;\nusing System.Text;\n\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            A a = new C();\n            a.Say();\n        }\n    }\n\n    abstract class A\n    {\n        public abstract void Say();\n    }\n\n    class B : A\n    {\n        public override void Say()\n        {\n            Console.WriteLine(\"B\");\n        }\n    }\n\n    class C : B\n    {\n        public void Say()\n        {\n            Console.WriteLine(\"C\");\n        }\n    }\n}\n\n```\n\n\n\n# c#设计原则 \n\n- 单一职责原则（Single Responsibility Principle）；\n- 开闭原则（Open Closed Principle）；\n- 里氏替换原则（Liskov Substitution Principle）；\n- 迪米特法则（Law of Demeter），又叫“最少知道法则”；\n- 接口隔离原则（Interface Segregation Principle）；\n- 依赖倒置原则（Dependence Inversion Principle）。\n\n6 个原则结合使用的好处：建立稳定、灵活、健壮的设计。\n\n## 单一职责原则\n\n**单一职责原则的定义是：应该有且仅有一个原因引起类的变更。**\n\n举个例子。\n\n我们以打电话为例，电话通话的时候有 4 个过程发生：拨号、通话、回应、挂机。那我们写一个接口，类图如下：\n\n![image-20230307072642501](./Image/C#学习笔记_基础教程.assets/image-20230307072642501.png)\n\n```c#\ninterface IPhone\n{\n    //接电话\n    void dial(string phoneNumber);\n\n    //通话\n    void chat(object o);\n\n    //挂电话\n    void hangup();\n}\n```\n\n​\tIPhone这个接口包含了两个职责：协议管理和数据传送。dial 和 hangup 这两个方法实现的是协议管理，分别负责拨号接通和挂机，chat 方法实现的是数据传送。不管是协议接通的变化还是输出传送的变化，都会引起这个接口的变化。所以，IPhone这个接口并不符合单一职责原则。若要让IPhone满足单一职责原则，我们就要对其进行拆分，拆分后的类图如下：\n\n![image-20230307073137336](./Image/C#学习笔记_基础教程.assets/image-20230307073137336.png)\n\n​\t这样设计就完美了，一个类实现了两个接口，把两个职责融合在一个类中。你会觉得这个Phone有两个原因引起变化了啊，是的，但是别忘了我们是面向接口编程，我们对外公布的是接口而不是实现类。\n\n​\t另外，单一职责原则不仅适用于接口和类，也适用于方法。**一个方法尽可能只做一件事**，比如一个修改用户密码的方法，不要把这个方法放到“修改用户信息”方法中。\n\n\n\n### 单一职责的好处\n\n- 类的复杂性降低，实现什么职责都有清晰明确的定义；\n- 可读性高，复杂性降低，可读性自然就提高了；\n- 可维护性提高，可读性提高了，那自然更容易维护了；\n- 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。\n\n\n\n\n\n## 里氏替换原则\n\n​\t在面向对象的语言中，继承是必不可少的、非常优秀的语言机制，它有如下优点：\n\n1. 代码共享，减少创建类的工作量，每个子类都拥有父类的属性和方法；\n2. 提高代码的重用性；\n3. 子类可以形似父类，但又异于父类；\n4. 提高代码的可扩展性；\n5. 提高产品或项目的开放性。\n\n有优点就必然存在缺点：\n\n1. 继承是侵入性的。只要继承，就必须拥有父类的属性和方法。\n2. 降低代码的灵活性。子类会多一些父类的约束。\n3. 增强了耦合性。当父类的常量、变量、方法被修改时，需要考虑子类的修改。\n\n\n\n​\t为了让“利”的因素发挥最大的作用，同时减少“弊”带来的麻烦，引入了里氏替换原则（LSP）。\n\n历史替换原则最正宗的定义是：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代替o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。\n\n通俗点讲，就是只要父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常。\n\n里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义。\n\n1. 子类必须完全实现父类的方法。\n\n   - 我们在做系统设计的时候，经常会定义一个接口或抽象类，然后编码实现，调用类则直接传入接口或抽象类，其实这里就已经使用了里氏替换原则。我们以打CS举例，来描述一下里面用到的枪。类图如下：\n\n   - ![image-20230307073608061](./Image/C#学习笔记_基础教程.assets/image-20230307073608061.png)\n\n   - 枪的主要职责是射击，如何射击在各个具体的子类中实现，在士兵类Soldier中定义了一个方法 killEnemy，使用枪来kill敌人，具体用什么枪，调用的时候才知道。\n\n   - **注意：**在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。\n\n   - 实现代码：\n\n     - ```c#\n       using System;\n       using System.Windows.Forms;\n       \n       namespace ConsoleApp\n       {\n           //internal class Program\n           //{\n           //    static void Main(string[] args)\n           //    {\n           //        A a = new C();\n           //        a.ShowClassName();           //this is B    //当通过接口调用子类的成员时，会调用最先实现这个成员的类所在的数据\n           //        a.test();                    //C test       \n       \n       \n           //        Console.ReadKey();\n           //    }\n           //}\n       \n           //枪的抽象类\n           public abstract class AbstractGun\n           {\n               //射击方法\n               public abstract void shoot();\n           }\n       \n           //手枪、步枪、机枪的实现代码\n           //手枪：\n           public class HandGun : AbstractGun\n           {\n               //射击方法\n               public override void shoot()\n               {\n                   Console.WriteLine(\"手枪射击了\");\n               }\n           }\n           //步枪\n           public class Rifle : AbstractGun\n           {\n               public override void shoot()\n               {\n                   Console.WriteLine(\"步枪射击了\");\n               }\n           }\n           //机枪\n           public class MachineGun : AbstractGun\n           {\n               public override void shoot()\n               {\n                   Console.WriteLine(\"机枪射击了\");\n               }\n           }\n       \n       \n           //士兵的源码\n           public class Soldier\n           {\n               private AbstractGun gun;\n       \n               public Soldier(AbstractGun gun)\n               {\n                   this.gun = gun;\n               }\n       \n               //士兵开始射击\n               public void killEnemy()\n               {\n                   Console.WriteLine(\"士兵开始杀戮\");\n                   this.gun.shoot();//开枪\n               }\n           }\n       \n       \n       \n           //客户端源码\n           public class Client\n           {\n               public static void Main(string[] args)\n               {\n                   //创建一个士兵的对象，并给他一把手枪\n                   Soldier soldier1 =  new Soldier(new HandGun());\n                   \n                   //士兵射击\n                   soldier1.killEnemy();\n       \n                   //再次创建一个士兵，这次给他一把机枪\n                   Soldier soldier2 = new Soldier(new MachineGun());\n                   soldier2.killEnemy();//士兵2也射击\n       \n                   //执行结果\n                   //士兵开始杀戮\n                   //手枪射击了\n                   //士兵开始杀戮\n                   //机枪射击了\n       \n                   //可以看到，里氏替换原则的特性：父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常。\n       \n                   Console.ReadKey();\n               }\n           }\n       }\n       ```\n\n2. 孩子类可以有自己的个性。\n\n   1. 孩子类当然可以有自己的属性和方法了，也正因如此，在子类出现的地方，父类未必就可以代替。\n\n   2. 还是以上面的关于枪支的例子为例，步枪有 AK47、SKS狙击步枪等型号，把这两个型号的枪引入后的Rifle的子类图如下：\n\n   3. ![image-20230307081242661](./Image/C#学习笔记_基础教程.assets/image-20230307081242661.png)\n\n   4. SKS狙击步枪可以配一个8倍镜进行远程瞄准，相对于父类步枪，这就是SKS的个性。源码如下：\n\n   5. ```c#\n      using System;\n      using System.Windows.Forms;\n      \n      namespace ConsoleApp\n      {\n          //internal class Program\n          //{\n          //    static void Main(string[] args)\n          //    {\n          //        A a = new C();\n          //        a.ShowClassName();           //this is B    //当通过接口调用子类的成员时，会调用最先实现这个成员的类所在的数据\n          //        a.test();                    //C test       \n      \n      \n          //        Console.ReadKey();\n          //    }\n          //}\n      \n          //枪的抽象类\n          public abstract class AbstractGun\n          {\n              //射击方法\n              public abstract void shoot();\n          }\n      \n          //手枪、步枪、机枪的实现代码\n          //手枪：\n          public class HandGun : AbstractGun\n          {\n              //射击方法\n              public override void shoot()\n              {\n                  Console.WriteLine(\"手枪射击了\");\n              }\n          }\n          //步枪\n          public class Rifle : AbstractGun\n          {\n              public override void shoot()\n              {\n                  Console.WriteLine(\"步枪射击了\");\n              }\n          }\n          //机枪\n          public class MachineGun : AbstractGun\n          {\n              public override void shoot()\n              {\n                  Console.WriteLine(\"机枪射击了\");\n              }\n          }\n      \n      \n          //士兵的源码\n          public class Soldier\n          {\n              private AbstractGun gun;\n      \n              public Soldier(AbstractGun gun)\n              {\n                  this.gun = gun;\n              }\n      \n              //士兵开始射击\n              public void killEnemy()\n              {\n                  Console.WriteLine(\"士兵开始杀戮\");\n                  this.gun.shoot();//开枪\n              }\n          }\n      \n      \n      \n          //客户端源码\n          public class Client\n          {\n              public static void Main(string[] args)\n              {\n                  //创建一个狙击手的对象，并给他一把狙击枪\n                  Spinner spinner = new Spinner();\n                  spinner.setSks(new SKS());\n                  spinner.killEnemy();\n                  //输出结果\n                  //使用8倍镜进行瞄准\n                  //SKS射击\n      \n                  Console.ReadKey();\n              }\n          }\n      \n          //sks\n          public class SKS : Rifle\n          {\n              //配一个8倍镜\n              public void zoomOut()\n              {\n                  Console.WriteLine(\"使用8倍镜进行瞄准\");\n              }\n              public void shoot()\n              {\n                  Console.WriteLine(\"SKS射击\");\n              }\n          }\n      \n          //狙击手\n          public class Spinner\n          {\n              private SKS sks;\n              \n              public void setSks(SKS sks)\n              {\n                  this.sks = sks;\n              }\n      \n              public void killEnemy()\n              {\n                  //先瞄准后开枪\n                  sks.zoomOut();\n                  sks.shoot();\n              }\n          }\n      \n      }\n      ```\n\n3. 覆盖或实现父类的方法时，输入参数可以被放大。\n\n   - 即方法的重载\n\n4. 覆盖或实现父类的方法时，输出结果可以被缩小。\n\n   - 父类的一个方法的返回值是类型T，子类的相同方法（重载或重写）的返回值为类型S，那么里氏替换原则就要求S必须小于等于T。为什么呢？因为重写父类方法，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这时重写父类方法的要求。\n\n\n\n\n## 依赖倒置原则\n\n- 模块间的依赖通过抽象发生，实现类之间不直接发生依赖关系，其依赖关系是通过接口或抽象类产生的；\n- 接口或抽象类不依赖于实现类；\n- 实现类依赖接口或抽象类。\n\n说白了，就是“面向接口编程”。\n\n**依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。**\n\n以汽车和司机举例，画出类图：\n\n![image-20230307083434548](./Image/C#学习笔记_基础教程.assets/image-20230307083434548.png)\n\n```c#\n//奔驰车\npublic class Benz\n{\n    public void run()\n    {\n        Console.WriteLine(\"奔驰车开始运行\");\n    }\n}\n//司机\npublic class Driver\n{\n    public void driver(Benz benz)\n    {\n        benz.run();\n    }\n}\n//客户端\npublic class Client\n{\n    public static void main(string[] args)\n    {\n        Driver driver = new Driver();\n        driver.driver(new Benz());\n    }\n}\n\n```\n\n​\t由于司机现在只有开奔驰的方法，所以他是开不了宝马的。一个拿有C驾照的司机能开奔驰，不能开宝马？太不合理了。所以，这就暴露出上面的设计问题了。我们对上面的功能重新设计，首先新建两个接口。\n\n```c#\n//汽车接口ICar：\n    interface ICar\n    {\n        void run();\n    }\n\n    //司机接口IDriver：\n    interface IDriver\n    {\n        void driver(ICar car);\n    }\n\n    //IDriver中，通过传入ICar接口实现了抽象之间的依赖关系。\n\n    //汽车实现类：奔驰和宝马。\n    public class Benz : ICar\n    {\n        public void run()\n        {\n            Console.WriteLine(\"奔驰车开始运行\");\n        }\n    }\n    public class BWM : ICar\n    {\n        public void run()\n        {\n            Console.WriteLine(\"宝马车开始运行\");\n        }\n    }\n\n    //创建司机实现类：\n    public class Driver : IDriver\n    {\n        void IDriver.driver(ICar car)\n        {\n            car.run();//开车\n        }\n    }\n\n    //客户端\n    public class Client\n    {\n        public static void Main(string[] args)\n        {\n            IDriver driver = new Driver();\n            ICar car = new Benz();\n            driver.driver(car);//司机开奔驰\n            car = new BWM();\n            driver.driver(car);//司机开宝马\n            //如果还有别的车，直接new别的车就行\n            //Client属于高层业务逻辑，它对低层模块的依赖都建立在抽象上，driver的表面类型是IDriver，benz的表面类型是ICar。\n        }\n    }\n```\n\n### 依赖倒置原则的使用建议：\n\n1. 每个类尽量都有接口或抽象类，或者接口和抽象类两者都具备。\n2. 变量的表面类型尽量是接口或抽象类。\n3. 任何类都不应该从具体类派生。\n4. 尽量不要重写基类的方法。如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要重写。\n5. 结合里氏替换原则使用。\n\n\n\n\n\n## 接口隔离原则\n\n### 接口隔离原则的定义\n\n> Clients should not be forced to depend upon interfaces that they don't use.\n> 客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。\n\n> The dependency of one class to another one should depend on the smallest possible interface.\n> 类间的依赖关系应建立在最小的接口上。\n\n也就是说: 接口尽量细化，接口中的方法尽量少。\n\n\n\n### 接口隔离原则和单一职责原则\n\n从功能上来看，接口隔离原则和单一职责原则都是为了提高类的内聚, 降低类之间的耦合, 体现了封装的思想。但二者还是有区别的。\n\n（1）从原则约束来看: 接口隔离原则更关注的是接口依赖程度的隔离；而单一职责原则更加注重的是接口职责的划分。\n\n（2）从接口的细化程度来看: 单一职责原则对接口的划分更加精细，而接口隔离原则注重的是相同功能的接口的隔离。接口隔离里面的最小接口有时可以是多个单一职责的公共接口。\n\n（3）单一职责原则更加偏向对业务的约束: 接口隔离原则更加偏向设计架构的约束。这个应该好理解，职责是根据业务功能来划分的，所以单一原则更加偏向业务；而接口隔离更多是为了“高内聚”，偏向架构的设计。\n\n\n\n​\t接口隔离原则就是客户端不应该依赖它不需要的接口，或者说类间的依赖关系应该建立在最小的接口上。\n\n​\t以搜索美女为例，设计了如下的类图：\n\n![image-20230307091119168](./Image/C#学习笔记_基础教程.assets/image-20230307091119168.png)\n\n```c#\n    //美女及其实现类：\n    interface IPettyGirl\n    {\n        //高颜值\n        void goodLooking();\n        //好身材\n        void niceBody();\n        //有气质\n        void greatTemperament();\n    }\n    public class PettyGril : IPettyGirl\n    {\n        private string name;\n\n        public PettyGril(string name)\n        {\n            this.name = name;\n        }\n\n        //高颜值\n        void IPettyGirl.goodLooking()\n        {\n            Console.WriteLine($\"{this.name} 颜值很高 \");\n        }\n        //好身材\n        void IPettyGirl.niceBody()\n        {\n            Console.WriteLine($\"{this.name} 身材很好\");\n        }\n        //有气质\n        void IPettyGirl.greatTemperament()\n        {\n            Console.WriteLine($\"{this.name} 气质出众\");\n        }\n    }\n\n\n    //搜索程序及其子类源代码如下：\n    abstract class AbstractSearcher\n    {\n        protected IPettyGirl gril;\n        public AbstractSearcher(IPettyGirl gril)\n        {\n            this.gril = gril;\n        }\n\n        //输出美女信息\n        public abstract void show();\n    }\n     class Searcher : AbstractSearcher\n    {\n        public Searcher(IPettyGirl girl):base(girl)//调用父类的构造函数\n        {\n            \n        }\n        public override void show()//实现抽象方法\n        {\n            Console.WriteLine(\"美女信息如下：\");\n            base.gril.goodLooking();\n            base.gril.niceBody();\n            base.gril.greatTemperament();\n        }\n    }\n\n    //场景调用类\n    public class Client\n    {\n        public static void Main(string[] args)\n        {\n            IPettyGirl aa = new PettyGril(\"aa\");\n            AbstractSearcher searcher = new Searcher(aa);\n            searcher.show();\n        }\n    }\n    /*输出：\n     * 美女信息如下：\n        aa 颜值很高\n        aa 身材很好\n        aa 气质出众 \n     */\n```\n\nIPettyGirl接口是否做到了最优化？并没有。\n\n每个人的审美观不一样，张三认为颜值高就是美女，即使身材和气质一般；李四认为身材好就行，不在乎颜值和气质；而王五则认为颜值和身材都是外在，只要有气质，那就是美女。这时，IPettyGirl接口就满足不了了，因为IPettyGirl的要求是颜值、身材、气质兼具才是美女。所以为了满足各种人的口味，我们需要重新设计接口的结构。把IPettyGirl拆分为3个接口，分别表示颜值高、身材好、气质佳。修改后的类图如下：\n\n![image-20230310142839136](./Image/C#学习笔记_基础教程.assets/image-20230310142839136.png)\n\n\n\n\n\n\n\n\n\n\n\n# c#异常处理\n\n非中断（正常）模式下的调试\n\n## 输出调试信息\n\n- Debug.WriteLine()\n- Trace.WriteLine()\n\n这两个命令用法几乎相同，区别在于：第一个命令仅在调试模式下运行，而第二个命令还可用于发布程序。实际上Debug.Write甚至不能编译到可发布的程序中，在发布版本中，该命令会消失，可以减小文件体积。\n\n这两个方法都包含在System.Diangnostics名称空间中。using static只能用于静态类，比如System.Console，因此该指令不能用在- Debug.WriteLine()、Trace.WriteLine()函数中。\n\n\n\n​\t异常是在程序执行期间出现的问题。C# 中的异常是对程序运行时出现的特殊情况的一种响应，比如尝试除以零。\n\n​\t异常提供了一种把程序控制权从某个部分转移到另一个部分的方式。C# 异常处理时建立在四个关键词之上的：`try`、`catch`、`finally` 和 `throw`。\n\n- try：一个 try 块标识了一个将被激活的特定的异常的代码块。后跟一个或多个 catch 块。\n- catch：程序通过异常处理程序捕获异常。catch 关键字表示异常的捕获。\n- finally：finally 块用于执行给定的语句，不管异常是否被抛出都会执行。例如，如果您打开一个文件，不管是否出现异常文件都要被关闭。\n- throw：当问题出现时，程序抛出一个异常。使用 throw 关键字来完成。\n\n基本语法详见 `C#基本语句 - try语句`。\n\n\n\n## C# 中的异常类\n\nC# 异常是使用类来表示的。C# 中的异常类主要是直接或间接地派生于 `System.Exception` 类。`System.ApplicationException` 和 `System.SystemException` 类是派生于 `System.Exception` 类的异常类。\n\n`System.ApplicationException` 类支持由应用程序生成的异常。所以程序员定义的异常都应派生自该类。\n\n`System.SystemException` 类是所有预定义的系统异常的基类。\n\n下表列出了一些派生自 `System.SystemException` 类的预定义的异常类：\n\n| 异常类                            | 描述                                           |\n| :-------------------------------- | :--------------------------------------------- |\n| System.IO.IOException             | 处理 I/O 错误。                                |\n| System.IndexOutOfRangeException   | 处理当方法指向超出范围的数组索引时生成的错误。 |\n| System.ArrayTypeMismatchException | 处理当数组类型不匹配时生成的错误。             |\n| System.NullReferenceException     | 处理当依从一个空对象时生成的错误。             |\n| System.DivideByZeroException      | 处理当除以零时生成的错误。                     |\n| System.InvalidCastException       | 处理在类型转换期间生成的错误。                 |\n| System.OutOfMemoryException       | 处理空闲内存不足生成的错误。                   |\n| System.StackOverflowException     | 处理栈溢出生成的错误。                         |\n\n## 异常处理\n\n​\tC# 以 try 和 catch 块的形式提供了一种结构化的异常处理方案。使用这些块，把核心程序语句与错误处理语句分离开。\n\n​\t这些错误处理块是使用 try、catch 和 finally 关键字实现的。下面是一个当除以零时抛出异常的实例：\n\n### 实例\n\n```c#\nusing System;\nnamespace ErrorHandlingApplication\n{\n    class DivNumbers\n    {\n        int result;\n        DivNumbers()\n        {\n            result = 0;\n        }\n        public void division(int num1, int num2)\n        {\n            try\n            {\n                result = num1 / num2;\n            }\n            catch (DivideByZeroException e)\n            {\n                Console.WriteLine(\"Exception caught: {0}\", e);\n            }\n            finally\n            {\n                Console.WriteLine(\"Result: {0}\", result);\n            }\n\n    }\n    static void Main(string[] args)\n    {\n        DivNumbers d = new DivNumbers();\n        d.division(25, 0);\n        Console.ReadKey();\n    }\n}\n\n}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```c#\nException caught: System.DivideByZeroException: Attempted to divide by zero. \nat ...\nResult: 0\n```\n\n## 创建用户自定义异常\n\n您也可以定义自己的异常。用户自定义的异常类是派生自 `ApplicationException` 类。下面的实例演示了这点：\n\n### 实例\n\n```c#\nusing System;\nnamespace UserDefinedException\n{\n   class TestTemperature\n   {\n      static void Main(string[] args)\n      {\n         Temperature temp = new Temperature();\n         try\n         {\n            temp.showTemp();\n         }\n         catch(TempIsZeroException e)\n         {\n            Console.WriteLine(\"TempIsZeroException: {0}\", e.Message);\n         }\n         Console.ReadKey();\n      }\n   }\n}\npublic class TempIsZeroException: ApplicationException\n{\n   public TempIsZeroException(string message): base(message)\n   {\n   }\n}\npublic class Temperature\n{\n   int temperature = 0;\n   public void showTemp()\n   {\n      if(temperature == 0)\n      {\n         throw (new TempIsZeroException(\"Zero Temperature found\"));\n      }\n      else\n      {\n         Console.WriteLine(\"Temperature: {0}\", temperature);\n      }\n   }\n}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```\nTempIsZeroException: Zero Temperature found\n```\n\n## 抛出对象\n\n如果异常是直接或间接派生自 `System.Exception` 类，您可以抛出一个对象。您可以在 catch 块中使用 `throw` 语句来抛出当前的对象，如下所示：\n\n```c#\ncatch(Exception e)\n{\n   ...\n   throw e\n}\n```\n\n\n\n# c#泛型\n\n​\t泛型是一种在.NET中引入类型参数的概念，它使得设计类和方法可以推迟一个或多个类型的指定，直到客户端代码声明并实例化类或方法。例如，通过使用泛型类型参数T，您可以编写一个单一的类，其他客户端代码可以使用它而不会产生运行时转换或装箱操作的成本或风险。\n\n​\t泛型类和方法结合了可重用性、类型安全性和效率，而它们的非泛型对应物则不能做到这一点。泛型最常用于集合和操作它们的方法。System.Collections.Generic命名空间包含了几个基于泛型的集合类。\n\n​\t也可以创建自定义的泛型类型和方法，以提供您自己的类型安全和高效的通用解决方案和设计模式。\n\n\n\n\n\n## 使用泛型\n\n### 可空类型\n\n值类型区别于引用类型的一个特点是值类型必须包含一个值。\n\n使用可空泛型`System.Nullable<T>`类提供了使值类型为空的一种方式。\n\n\n\n#### 基本语法\n\n```c#\nSystem.Nullable<类型名> 变量名; // 创建指定类型的可空类型\n类型名? 变量名;// 两个语句功能相等\n```\n\n\n\n#### 使用可空类型时的注意事项\n\n- 可以使用只读属性Nullable\\<T>.HasValue和Nullable\\<T>.Value来检查和获取可空值类型变量的值。\n  - [Nullable.HasValue](https://learn.microsoft.com/en-us/dotnet/api/system.nullable-1.hasvalue)指示可为空值类型的实例是否具有其基础类型的值。\n  - [如果HasValue](https://learn.microsoft.com/en-us/dotnet/api/system.nullable-1.hasvalue)为`true`，则[Nullable.Value](https://learn.microsoft.com/en-us/dotnet/api/system.nullable-1.value)获取基础类型的值。如果[HasValue](https://learn.microsoft.com/en-us/dotnet/api/system.nullable-1.hasvalue)为`false`，则[Value](https://learn.microsoft.com/en-us/dotnet/api/system.nullable-1.value)属性将抛出[InvalidOperationException](https://learn.microsoft.com/en-us/dotnet/api/system.invalidoperationexception)。\n- 在使用泛型约束时，需要注意多个泛型约束不能以OR方式（更不严格）组合，只能以AND方式（更严格）组合。这意味着一个方法不能同时处理两种情况。泛型约束也不能用于为方法创建唯一签名，因此您需要使用两个单独的方法名称。\n\n\n\n\n\n例如：\n\n```c#\nusing System;\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // 声明一个变量 nullableInt ，它除了拥有int变量的所有值外，还可以拥有null值。\n            System.Nullable<int> nullableInt;\n            nullableInt = null;\n            if(nullableInt == null)\n            {\n                Console.WriteLine(\"nullableInt 的值是 null\");\n            }\n\n            // Console.WriteLine(nullableInt.GetType().FullName); // 注意 在值为null的时候，获取不到类型；当值为数值时，类型为int32.\n\n\n            // 同理 也可以存在可空类型的其他值类型 如bool：\n            // 注意，可空类型的语法可以进行缩写：bool? nullableBool等价于Nullable<bool> nullableBool\n            bool? nullableBool = null;\n\n            if(nullableBool == true)\n            {\n                Console.WriteLine(\"nullableBool的值是true\");\n            }\n            else if(nullableBool == false)\n            {\n                Console.WriteLine(\"nullableBool的值为false\");\n            }\n            else if (nullableBool == null)\n            {\n                Console.WriteLine(\"nullableBool的值为null\");\n            }\n\n            // 可空类型还有一个属性：HasValue，可以使用这个属性类查看可空类型的变量是否有值\n            // 如果HasValue值为true，则说明存在非null值，否则值为null。\n            // 注意 这并不适用于引用类型，即便引用类型也存在一个HasValue的属性。因为引用变量的值为null则表示不存在对象，所有不能通过对象来访问这个属性，不然就会抛出空引用的错误\n            Console.WriteLine(nullableInt.HasValue);// false\n            nullableInt = 1;\n            Console.WriteLine(nullableInt.HasValue);// true\n            Console.WriteLine(nullableInt.Value);// 1\n\n        }\n    }\n\n}\n```\n\n\n\n#### 从可空值类型到基础类型的转换\n\n如果要将可空值类型的值分配给不可空值类型变量，您可能需要指定要分配的值来代替`null`. 使用[null 合并运算符`??`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator)来执行此操作（也可以使用[Nullable.GetValueOrDefault(T)](https://learn.microsoft.com/en-us/dotnet/api/system.nullable-1.getvalueordefault#system-nullable-1-getvalueordefault(-0))方法来达到相同目的）：\n\n```c#\nint? a = 28;\nint b = a ?? -1;\nConsole.WriteLine($\"b is {b}\");  // output: b is 28\n\nint? c = null;\nint d = c ?? -1;\nConsole.WriteLine($\"d is {d}\");  // output: d is -1\n```\n\n也可以使用强制类型转换将可空类型强转成普通类型\n\n```c#\nint a = (int)nullableInt;\n```\n\n\n\n##### ?? 空合并运算符\n\n在C#中，??运算符被称为空合并运算符。它会返回其左操作数的值（如果不为null）。否则，它会计算右操作数并返回其结果。如果左操作数的值不为null，则??运算符不会计算其右操作数1。\n\n例如，您可以使用以下代码来检查一个可空类型变量是否为null，并在它为null时返回一个默认值：\n\n```c#\nint? x = null;\nint y = x ?? -1;\n```\n\n在上面的示例中，由于x的值为null，因此y的值将被设置为-1。\n\n更多信息，详见c#运算符。\n\n\n\n#### 可空类型与运算符\n\n对于简单类型，可以直接使用原有的运算符。\n\n如果一个或两个操作数是`null`，则产生`null`；否则，运算符使用其操作数中包含的值来计算结果。例如：\n\n```c#\nint? a = 10;\nint? b = null;\nint? c = 10;\n\na++;        // a is 11\na = a * c;  // a is 110\na = a + b;  // a is null\n```\n\n\n\n对于[比较运算符](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/comparison-operators) `<`, `>`, `<=`, 和`>=`，如果一个或两个操作数是`null`，则结果是`false`；否则，比较操作数包含的值。不要假设因为特定比较（例如`<=`）返回`false`，所以相反的比较 ( `>`) 返回`true`。下面的例子表明 10 是\n\n- 既不大于也不等于`null`\n- 不少于`null`\n\n```c#\nint? a = 10;\nConsole.WriteLine($\"{a} >= null is {a >= null}\");\nConsole.WriteLine($\"{a} < null is {a < null}\");\nConsole.WriteLine($\"{a} == null is {a == null}\");\n// Output:\n// 10 >= null is False\n// 10 < null is False\n// 10 == null is False\n\nint? b = null;\nint? c = null;\nConsole.WriteLine($\"null >= null is {b >= c}\");\nConsole.WriteLine($\"null == null is {b == c}\");\n// Output:\n// null >= null is False\n// null == null is True\n```\n\n\n\n##### 注意\n\n对于`bool?`类型，预定义的`&`和`|`运算符不遵循本节中描述的规则：运算符评估的结果可以是非空的，即使其中一个操作数是`null`。有关详细信息，请参阅[布尔逻辑运算符](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/boolean-logical-operators#nullable-boolean-logical-operators)一文的可空[布尔逻辑运算](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/boolean-logical-operators)符部分。\n\n\n\n#### 可空类型的装箱和拆箱\n\n可空值类型的实例按如下方式`T?`装箱：\n\n如果HasValue返回false，则生成空引用。\n如果HasValue返回true，则基础值类型的相应值被装箱，而不是`Nullable<T>T`的实例。\n可以将值类型的装箱值取消装箱T为相应的可为空值类型T?，如以下示例所示：\n\n```c#\nint a = 41;\nobject aBoxed = a;\nint? aNullable = (int?)aBoxed;\nConsole.WriteLine($\"Value of aNullable: {aNullable}\");\n\nobject aNullableBoxed = aNullable;\nif (aNullableBoxed is int valueOfA)\n{\n    Console.WriteLine($\"aNullableBoxed is boxed int: {valueOfA}\");\n}\n// Output:\n// Value of aNullable: 41\n// aNullableBoxed is boxed int: 41\n```\n\n\n\n\n\n### List\\<T>\n\nList\\<T>是C#中的一个泛型集合类型，它表示一组强类型对象，可以通过索引访问。它提供了用于创建对象列表、向列表中添加项以及查找、排序和更新列表项的方法1。\n\nList\\<T>是ArrayList的泛型版本，属于System.Collections.Generic命名空间。与ArrayList不同，List\\<T>可以包含指定类型的元素，并且由于它是泛型的，因此在编译时进行类型检查，不会执行装箱和拆箱操作。\n\n下面是一个简单的示例，演示如何创建一个`List<T>`并向其中添加元素：\n\n```csharp\nList<int> numbers = new List<int>();\nnumbers.Add(1);\nnumbers.Add(2);\nnumbers.Add(3);\n```\n\n在上面的示例中，我们创建了一个名为`numbers`的`List<int>`，并使用`Add`方法向其中添加了三个元素。\n\n#### 对泛型列表进行排序和搜索\n\n要对List\\<T>排序，可以在要排序的类型上提供IComparable\\<T>接口，或者提供IComparer\\<T>接口。另外，还可以提供泛型委托，作为排序方法。从了解代码工作原理的角度看，这非常有趣，因为实现上述接口并不比实现其非泛型版本更麻烦。\n\n一般情况下，给列表排序需要有一个方法来比较两个T类型的对象。要在列表中搜索，只需要一个方法来检查T类型的对象，看它是否满足某个条件。定义这样的方法很简单，这里给出两个可以使用的泛型委托类型:\n\n- Comparison\\<T>: 这个委托类型用于排序方法，其返回类型和参数如下:\n\n  - ```c#\n    int method(T objectA, T objectB)\n    ```\n\n- Predicate\\<T>: 这个委托类型用于搜索方法，其返回类型和参数如下:\n\n  - ```c#\n    bool method (T targetobject)\n    ```\n\n可以定义任意多个这样的方法，使用它们实现List\\<T>的搜索和排序方法。\n\n\n\n\n\n## 定义泛型类型\n\n### 定义泛型类\n\n泛型类封装不特定于特定数据类型的操作。 泛型类最常见用法是用于链接列表、哈希表、堆栈、队列和树等集合。 无论存储数据的类型如何，添加项和从集合删除项等操作的执行方式基本相同。\n\n对于大多数需要集合类的方案，推荐做法是使用 .NET 类库中提供的集合类。 有关使用这些类的详细信息，请参阅 [.NET 中的泛型集合](https://learn.microsoft.com/zh-cn/dotnet/standard/generics/collections)。\n\n通常，创建泛型类是从现有具体类开始，然后每次逐个将类型更改为类型参数，直到泛化和可用性达到最佳平衡。 创建自己的泛型类时，需要考虑以下重要注意事项：\n\n\n\n#### 定义方法\n\n要创建泛型类，需要在类名后面添加尖括号`<>`，并在其中指定一个或多个类型参数。类型参数可以在类的定义中用作占位符，表示未知的类型。当客户端代码声明并实例化类时，它将指定类型参数的具体类型。\n\n下面是一个简单的示例，演示如何创建一个泛型类：\n\n```csharp\npublic class MyGenericClass<T>\n{\n    private T value;\n\n    public MyGenericClass(T value)\n    {\n        this.value = value;\n    }\n\n    public T GetValue()\n    {\n        return value;\n    }\n}\n```\n\n在上面的示例中，我们定义了一个名为`MyGenericClass<T>`的泛型类。该类具有一个名为`value`的私有字段，其类型为`T`。我们还定义了一个构造函数和一个名为`GetValue`的方法，它们都使用了类型参数`T`。\n\n要使用这个泛型类，您需要在声明并实例化它时指定类型参数的具体类型。例如，您可以使用以下代码创建一个`MyGenericClass<int>`的实例：\n\n```csharp\nMyGenericClass<int> myInt = new MyGenericClass<int>(10);\nint value = myInt.GetValue(); // value will be 10\n```\n\n在上面的示例中，我们创建了一个名为`myInt`的`MyGenericClass<int>`实例，并使用构造函数将其初始化为10。然后，我们调用了`GetValue`方法来获取存储在该实例中的值。\n\n\n\n其中 上面提到的`T`可以是任意标识符。但一般只使用T\n\n\n\n也可以在定义泛型类时指定多个类型参数。只需在类名后面的尖括号`<>`中用逗号分隔多个类型参数即可。\n\n下面是一个简单的示例，演示如何创建一个带有两个类型参数的泛型类：\n\n```csharp\npublic class MyGenericClass<T1, T2>\n{\n    private T1 value1;\n    private T2 value2;\n\n    public MyGenericClass(T1 value1, T2 value2)\n    {\n        this.value1 = value1;\n        this.value2 = value2;\n    }\n\n    public T1 GetValue1()\n    {\n        return value1;\n    }\n\n    public T2 GetValue2()\n    {\n        return value2;\n    }\n}\n```\n\n在上面的示例中，我们定义了一个名为`MyGenericClass<T1, T2>`的泛型类。该类具有两个私有字段，分别为`value1`和`value2`，它们的类型分别为`T1`和`T2`。我们还定义了一个构造函数和两个方法，它们都使用了类型参数`T1`和`T2`。\n\n要使用这个泛型类，您需要在声明并实例化它时指定类型参数的具体类型。例如，您可以使用以下代码创建一个`MyGenericClass<int, string>`的实例：\n\n```csharp\nMyGenericClass<int, string> myPair = new MyGenericClass<int, string>(10, \"hello\");\nint value1 = myPair.GetValue1(); // value1 will be 10\nstring value2 = myPair.GetValue2(); // value2 will be \"hello\"\n```\n\n在上面的示例中，我们创建了一个名为`myPair`的`MyGenericClass<int, string>`实例，并使用构造函数将其初始化为`(10, \"hello\")`。然后，我们调用了`GetValue1`和`GetValue2`方法来获取存储在该实例中的值。\n\n\n\n##### default关键字\n\n在泛型类或方法中，可以使用`default`关键字来获取类型参数的默认值。`default(T)`表达式将返回类型`T`的默认值。对于引用类型，它将返回null；对于值类型，它将返回该类型的默认值（例如，对于`int`类型，它将返回0）。\n\n下面是一个简单的示例，演示如何在泛型类中使用`default`关键字：\n\n```csharp\npublic class MyGenericClass<T>\n{\n    private T value;\n\n    public MyGenericClass()\n    {\n        value = default(T);\n    }\n\n    public T GetValue()\n    {\n        return value;\n    }\n}\n```\n\n在上面的示例中，我们定义了一个名为`MyGenericClass<T>`的泛型类。该类具有一个名为`value`的私有字段，其类型为`T`。我们还定义了一个构造函数，在其中使用了`default(T)`表达式来初始化`value`字段。\n\n要使用这个泛型类，您需要在声明并实例化它时指定类型参数的具体类型。例如，您可以使用以下代码创建一个`MyGenericClass<int>`的实例：\n\n```csharp\nMyGenericClass<int> myInt = new MyGenericClass<int>();\nint value = myInt.GetValue(); // value will be 0\n```\n\n在上面的示例中，我们创建了一个名为`myInt`的`MyGenericClass<int>`实例，并使用构造函数将其初始化。由于我们在构造函数中使用了`default(T)`表达式来初始化`value`字段，因此该字段的值将被设置为0。\n\n\n\n\n\n\n\n\n\n#### where泛型约束\n\n泛型定义中的 `where` 子句指定对用作泛型类型、方法、委托或本地函数中类型参数的参数类型的约束。 约束可指定接口、基类或要求泛型类型为引用、值或非托管类型。 约束声明类型参数必须具有的功能，并且约束必须位于任何声明的基类或实现的接口之后。\n\n\n\n\n\n##### 作用\n\n泛型约束用于限制可替换类型参数的类型。当我们创建一个新的泛型类型实例时，我们可以使用约束来限制可替换类型参数的类型。如果客户端代码使用不满足约束的类型，编译器会发出错误。约束通过使用 where 上下文关键字指定1。\n\n例如，你可以声明一个泛型类 AGenericClass ，以使类型参数 T 实现 IComparable\\<T> 接口：\n\n```c#\npublic class AGenericClass<T> where T : IComparable<T>\n{\n}\n```\n\n这样，你就可以在泛型类中使用 Employee.Name 属性。 约束指定所有类型为 T 的项都保证是 Employee 对象或从 Employee 继承的对象。 可以对同一类型参数应用多个约束，约束本身也可以是泛型类型1。\n\n\n\n泛型约束有多种类型，它们可以帮助你限制可替换类型参数的类型。下面是一些常见的泛型约束类型：\n\n- where T : struct：类型参数必须是非空值类型。所有值类型都具有可访问的无参数构造函数，因此 struct 约束意味着 new() 约束，不能与 new() 约束结合使用。您不能将 struct 约束与 unmanaged 约束结合使用1。\n- where T : class：类型参数必须是引用类型。此约束也适用于任何类、接口、委托或数组类型。在可为空上下文中，T 必须是非空引用类型1。\n- where T : class?：类型参数必须是引用类型，可以为空或非空。此约束也适用于任何类、接口、委托或数组类型1。\n- where T : notnull：类型参数必须是非空类型。参数可以是非空引用类型或非空值类型1。\n- where T : new()：类型参数必须具有公共无参数构造函数。与其他约束一起使用时，new() 约束必须最后指定。new() 约束不能与 struct 和 unmanaged 约束结合使用1。\n- where T : \\<base class name>：类型参数必须是指定基类或从指定基类派生。在可为空上下文中，T 必须是从指定基类派生的非空引用类型1。\n\n这些约束可以帮助你更好地控制泛型类的行为，并确保客户端代码使用正确的类型来实例化泛型类。\n\n\n\n### 泛型方法\n\n\n\n\n\n协变 逆变\n\n泛型缓存\n\n\n\n\n\n\n\n\n\n\n\n# c#委托\n\n## 什么是委托\n\nC# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针，是函数指针的升级版，可以按照某些约束指向某个方法，使得对方法的间接调用。\n\n委托（Delegate） 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。\n\n委托（Delegate）特别用于实现事件和回调方法。所有的委托都派生自 **System.Delegate** 类。\n\n从数据结构来讲，委托是和类一样是一种用户自定义**类型**；从设计模式来讲，委托（类）提供了**方法**（对象）的抽象。\n\n\n\n## 为什么要使用委托\n\n\n\n\n\n\n\n## c#的内置泛型委托\n\n### Action委托\n\n​\tAction\\<T>是.NET Framework内置的泛型委托，可以使用Action\\<T>委托以参数形式传递方法，而不用显示声明自定义的委托。封装的方法必须与此委托定义的方法签名相对应。也就是说，封装的方法必须具有一个通过值传递给它的参数，并且**不能有返回值**。\n\n​\tAction其实就是没有返回值的delegate。\n\n\n\n#### Action委托定义\n\n```c#\nusing System.Runtime.CompilerServices;\n\nnamespace System\n{\n    //\n    // 摘要:\n    //     封装一个方法，该方法不具有参数且不返回值。\n    [TypeForwardedFrom(\"System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089\")]\n    public delegate void Action();\n}\n```\n\n- Action委托至少0个参数，至多16个参数，无返回值。\n- Action 表示无参，无返回值的委托。\n- Action<int,string> 表示有传入参数int,string无返回值的委托。\n- Action<int,string,bool> 表示有传入参数int,string,bool无返回值的委托。\n- Action<int,int,int,int> 表示有传入4个int型参数，无返回值的委托。\n\n#### 样例\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            //等待被委托的对象\n            Calculator calculator = new Calculator();\n\n            //Action委托的定义\n            Action action = new Action(calculator.Report);//使用action委托指向了新创建的方法\n            \n            //以下三条语句的功能相同，都是调用calculator的Report\n            calculator.Report();//直接调用目标发放\n            action.Invoke();//使用委托的Invoke方法进行间接调用\n            action();//简便写法，模仿了函数指针\n\n            Console.ReadKey();\n        }\n    }\n\n    class Calculator\n    {\n        public void Report()\n        {\n            Console.WriteLine(\"I have 3 methods\");\n        }\n\n        public int Add(int a, int b)\n        {\n            int res = a + b;\n            return res;\n        }\n\n        public int Sub(int a, int b)\n        {\n            int res = a - b;\n            return res;\n        }\n    }\n}\n```\n\n\n\n\n\n### Func委托\n\nFunc委托代表有返回类型的委托。\n\n\n\n#### Func委托定义\n\n```c#\nusing System.Runtime.CompilerServices;\n\nnamespace System\n{\n    //\n    // 摘要:\n    //     封装一个方法，该方法具有两个参数，并返回由 TResult 参数指定的类型的值。\n    //\n    // 参数:\n    //   arg1:\n    //     此委托封装的方法的第一个参数。\n    //\n    //   arg2:\n    //     此委托封装的方法的第二个参数。\n    //\n    // 类型参数:\n    //   T1:\n    //     此委托封装的方法的第一个参数的类型。\n    //\n    //   T2:\n    //     此委托封装的方法的第二个参数的类型。\n    //\n    //   TResult:\n    //     此委托封装的方法的返回值类型。\n    //\n    // 返回结果:\n    //     此委托封装的方法的返回值。\n    [TypeForwardedFrom(\"System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089\")]\n    public delegate TResult Func<in T1, in T2, out TResult>(T1 arg1, T2 arg2);\n}\n```\n\n\n\n\n\nFunc至少0个输入参数，至多16个输入参数，根据返回值泛型返回。**必须有返回值，不可void。**\n\nFunc\\<int> 表示没有输入参参，返回值为int类型的委托。\n\nFunc<object,string,int> 表示传入参数为object, string ，返回值为int类型的委托。\n\nFunc<object,string,int> 表示传入参数为object, string， 返回值为int类型的委托。\n\nFunc<T1,T2,,T3,int> 表示传入参数为T1,T2,,T3(泛型)，返回值为int类型的委托。\n\n\n\n#### 样例\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            //等待被委托的对象\n            Calculator calculator = new Calculator();\n\n            \n            //Func委托：分别指向了calculator的两个方法\n            Func<int, int, int> func1 = new Func<int, int, int>(calculator.Add);\n            Func<int, int, int> func2 = new Func<int, int, int>(calculator.Sub);\n\n            //Func<void> func3 = new Func<void>(calculator.Report);报错，不允许没有返回值\n\n            int x = 100;\n            int y = 200;\n            int z;\n\n            z = func1.Invoke(x, y);//可以用Invoke调用\n            Console.WriteLine(z);\n            //z = func2.Invoke(x, y);\n            z = func2(x, y);//也可以模仿函数指针的形式调用\n            Console.WriteLine(z);\n\n            Console.ReadKey();\n        }\n    }\n\n    class Calculator\n    {\n        public void Report()\n        {\n            Console.WriteLine(\"I have 3 methods\");\n        }\n\n        public int Add(int a, int b)\n        {\n            int res = a + b;\n            return res;\n        }\n\n        public int Sub(int a, int b)\n        {\n            int res = a - b;\n            return res;\n        }\n    }\n}\n```\n\n\n\n## 自定义委托\n\n委托是一种类（class），类是数据类型，所以委托也是一种数据类型。委托也可以创建实例、声明对象\n\n与类一样，委托类型必须在被使用之前进行声明。\n\n他的声明方式与一般的类不同。\n\n需要注意声明委托的地方：委托是一个类，是在命名空间下面的一个类，与其他类同级。\n\n类是可以被嵌套的，因此委托也可以，所以，委托是可以被声明在一个类中，运行可能也不会报错，但此时的委托已经不是一个独立的类了，而是外层类的一个嵌套类\n\n委托所封装的方法必须“类型兼容”，即声明委托的时候，所使用的目标方法的返回值类型、目标方法的参数列表类型，必须与目标方法保持一致。     声明的是什么类型，创建对象时指向的也得是什么类型。\n\n\n\n常用于将一个方法赋值给一个自定义的委托类型。前提是方法和委托的签名一样（即参数和返回值相同）\n\n### 声明\n\n新参列表只需要保证类型数量一致即可，形参名是否相等无所谓。\n\n注意委托是一个类，直属于命名空间，与其他类平级。\n\n```c#\ndelegate 目标方法的返回值 委托名（目标方法的形参列表）\n```\n\n#### 样例1\n\n```c#\npublic delegate double Calc(double x, double y);//自定义委托的声明\n```\n\n\n\n\n\n\n\n### 初始化\n\n#### 使用new运算符\n\nnew运算符的操作数的组成如下：\n\n- 委托类型名\n- 一组圆括号，其中包含作为调用列表中的第一个成员的方法的名字。方法可以是实例方法或静态方法。\n\n如：\n\n```c#\nCalc calc1 = new Calc(calculator.Add);\nCalc calc2 = new Calc(calculator.Sub);\n```\n\n\n\n#### 使用快捷语法\n\n快键语法，它**仅由方法说明符构成**。之所以能这样，是因为在方法名称和其相应的委托类型之间**有隐式转换**。\n\n如：\n\n```c#\nCalc calc3 = calculator.Mul;\nCalc calc4 = calculator.Div;\n```\n\n\n\n### 赋值委托\n\n 由于委托是引用类型，我们可以通过给它赋值来改变包含在委托变量中的方法地址引用。旧的引用会被垃圾回收器回收。\n\n```c#\nCalc calc1 = new Calc(calculator.Add);\ncalc1 = new Calc(calculator.Sub);\n```\n\n\n\n### 组合委托\n\n也称为委托的多播（Multicasting of a Delegate）\n\n委托可以使用额外的运算符来组合。这个运算最终会创建一个新的委托，其调用列表是两个操作数的委托调用列表的副本的连接。\n\n委托是恒定的，操作数委托创建后不会被改变。**委托组合拷贝的是操作数的副本**。\n\n可以使用+=运算符，为委托新增方法。\n\n同样可以使用-=运算符，为委托移除方法。\n\n具体的应用场景？\n\n```c#\nusing System;\n\ndelegate int NumberChanger(int n);\nnamespace DelegateAppl\n{\n   class TestDelegate\n   {\n      static int num = 10;\n      public static int AddNum(int p)\n      {\n         num += p;\n         return num;\n      }\n\n      public static int MultNum(int q)\n      {\n         num *= q;\n         return num;\n      }\n      public static int getNum()\n      {\n         return num;\n      }\n\n      static void Main(string[] args)\n      {\n         // 创建委托实例\n         NumberChanger nc;\n         NumberChanger nc1 = new NumberChanger(AddNum);\n         NumberChanger nc2 = new NumberChanger(MultNum);\n         nc = nc1;\n         nc += nc2;\n         // 调用多播\n         nc(5);\n         Console.WriteLine(\"Value of Num: {0}\", getNum());\n         Console.ReadKey();\n      }\n   }\n}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```\nValue of Num: 75\n```\n\n\n\n### 委托调用\n\n委托调用跟方法调用类似。委托调用后，调用列表的每个方法将会被执行。\n\n**在调用委托前，应判断委托是否为空**。调用空委托会抛出异常。\n\n```c#\nif(calc1 != null)\n{\n    c = calc1.Invoke(a, b);\n    Console.WriteLine(c);\n}\n```\n\n\n\n### 匿名方法\n\n匿名方法是在初始化委托时内联声明的方法。\n\n\n\n#### 基本结构：\n\n```c#\ndeleage( 参数 ) { 语句块 }\n```\n\n例如：\n\n```c#\ndelegate int MyDel (int x); //定义一个委托 \n\nMyDel del = delegate( int x){ return x; };\n```\n\n从上面我们可以看到，**匿名方法是不会显示声明返回值的**。\n\n\n\n## 泛型委托\n\n我们每次要使用一个委托时，都需要先声明这个委托类，规定参数和返回值类型，然后才能实例化、调用。为了简化这个过程， .NET 框架为我们封装了三个泛型委托类，因此大部分情况下我们不必再声明委托，可以拿来直接实例化使用，方便了我们的日常写代码。\n这三种泛型委托包括：Func委托、Action委托和Predicate委托。\n\n### 自定义泛型委托\n\n#### 声明\n\n```c#\npublic delegate int DelCompareT<T>(T t1,T t2);\n```\n\n#### 应用\n\n```c\npublic static T GetMaxT<T>(T[] nums, DelCompareT<T> del)\n{\n    T maxx = nums[0];\n    for(int i = 0; i < nums.Length; i++)\n    {\n        if(del(maxx, nums[i]) < 0)\n        {\n            maxx = nums[i];\n        }\n    }\n    return maxx;\n}\n\n```\n\n\n\n## 委托的一般使用\n\n常用于把委托当作方法的参数传到方法里面去。\n\n一个具有委托类型参数的方法，在方法体内使用传进来的委托间接的调用委托封装的那个方法，这样就形成了一种动态调用方法的结构。\n\n像这种把委托当作参数传进方法的用法，具体可分为两种：模板方法、回调（callback）方法\n\n### 模板方法\n\n​\t所谓模板方法，就是将传进来的委托参数，借用指定的外部方法来产生结果。\n\n​\t相当于在写的方法中有一个“填空题”，中间空缺的位置就用传进来的委托参数填补，也就是通过传进来的委托参数简介的调用指定的外部方法。这个方法一般是具有返回值的，当拿到返回值后，再继续执行后面的逻辑。\n\n​\t写了一个方法，这个方法是一个模板，这个模板里有一处是不确定的，区域部分是确定好的，这个不确定的部分，就是靠传进来的委托类型的参数所包含的方法来填补\n\n\n\n#### 样例\n\n没有直接使用MakePizza，而是通过委托间接的调用\n\n```c#\nusing System;\nusing System.Windows.Diagnostics;\n\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            ProductFactory productFactory = new ProductFactory();//生产工厂的实例\n            WrapFactory wrapFactory = new WrapFactory();//包装工厂的实例\n\n            //开始使用模板方法\n            //准备委托类型的变量，当作参数传入模板方法\n            Func<Product> func1 = new Func<Product>(productFactory.MakePizza);//生产披萨的委托 \n            Func<Product> func2 = new Func<Product>(productFactory.MakeToyCar);//生产玩具车\n\n            //调用模板方法\n            Box box1 = wrapFactory.WrapPorduct(func1);\n            Box box2 = wrapFactory.WrapPorduct(func2);\n\n            Console.WriteLine(box1.Product.Name);\n            Console.WriteLine(box2.Product.Name);\n\n\n\n            Console.ReadKey();\n        }\n    }\n\n    //产品\n    class Product\n    {\n        public string Name { get; set; }\n    }\n    //包装产品的箱子\n    class Box\n    {\n        public Product Product { get; set; }\n    }\n    //将产品包上箱子交给客户\n    class WrapFactory\n    {\n        //模板方法，大部分逻辑都已经被固定了，最大限度的实现了代码的重用\n        //准备一个箱子\n        //获取产品\n        //将产品装入box\n        //将打包好的box送回\n        //回调方法：使用Func委托，返回值是Product\n        public Box WrapPorduct(Func<Product> getProduct)\n        {\n            Box box = new Box();\n\n            //间接调用 生产工厂的生产方法 拿到一个product的对象\n            //可以动态的选择调用方法\n            Product product = getProduct();\n\n\n            box.Product = product;\n            return box;\n        }\n    }\n    //生产工厂\n    class ProductFactory\n    {\n        //生产披萨\n        public Product MakePizza()\n        {\n            Product product = new Product();\n            product.Name = \"Pizza\";\n            return product;\n        }\n\n        //生存玩具车\n        public Product MakeToyCar()\n        {\n            Product product = new Product();\n            product.Name = \"ToyCar\";\n            return product;\n        }\n    }\n}\n```\n\n\n\n### 回调方法\n\n回调：callback\n\n回调方法是是通过委托类型的参数传进主调方法的被调用方法，主调方法可以根据自己的逻辑决定是否调用这个方法。换句话说就是，某个方法可以调用它，也可以不调用它，而且可以动态地选择后续调用的方法。\n\n在以回调方法的形式来使用委托的时候，要做的是把委托类型的参数传进主调方法里面去，被传进主调方法里面的委托类型的参数，它内部会封装一个被回调的方法，也就是常说的回调方法。主调函数会根据自己的逻辑决定是否调用这个回调方法。\n\n就像一个流水线一样，主调方法会在主要逻辑执行完毕后，决定是否调用这个回调方法\n\n回调方法一般都位于主调方法的末尾，一般用于执行后续的工作，一般是没有返回值的。\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\n\n\n\n### 样例\n\n```c#\nusing System;\n\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Calculator calculator = new Calculator();\n\n            //委托的声明以及初始化实例\n            Calc calc1 = new Calc(calculator.Add);\n            Calc calc2 = new Calc(calculator.Sub);\n\n            //快键语法，它仅由方法说明符构成。\n            //之所以能这样，是因为在方法名称和其相应的委托类型之间有隐式转换。\n            Calc calc3 = calculator.Mul;\n            Calc calc4 = calculator.Div;\n\n\n            double a = 100;\n            double b = 200;\n            double c = 0;\n\n            //间接调用4个委托，也可以不用Invoke关键字，直接（）调用\n            c = calc1.Invoke(a, b);\n            Console.WriteLine(c);\n            c = calc2.Invoke(a, b);\n            Console.WriteLine(c);\n            c = calc3.Invoke(a, b);                \n            Console.WriteLine(c);\n            c = calc4.Invoke(a, b);\n            Console.WriteLine(c);\n\n\n            Console.ReadKey();\n        }\n    }\n\n    public delegate double Calc(double x, double y);//自定义委托的声明，只需要保证类型一致即可，形参名是否相等无所谓\n\n    class Calculator\n    {\n        public double Add(double x, double y)\n        {\n            return x + y;\n        }\n\n        public double Sub(double x, double y)\n        {\n            return x - y;\n        }\n\n        public double Mul(double x, double y)\n        {\n            return x * y;\n        }\n\n        public double Div(double x, double y)\n        {\n            return x / y;\n        }\n    }\n}\n```\n\n\n\n### 样例2：借助委托，使用一个方法调用不同的方法。\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace 委托\n{\n    //声明一个委托，指向一个函数\n    //委托所指向的函数必须和委托具有相同的签名（即参数和返回值）\n    public delegate void DelSayHi(string name);\n\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            //DelSayHi del = SayHiChinese;//不再创建一个对象，而是直接给一个方法\n            //del(\"张三\");\n\n            Test(\"张三\", SayHiChinese);\n            Test(\"张三\", SayHiEnglish);\n            Console.ReadLine();\n        }\n        \n        public static void Test(string name, DelSayHi del)\n        {\n            del(name);\n        }\n\n        public static void SayHiChinese(String name)\n        {\n            Console.WriteLine(\"你好，\" + name);\n        }\n\n        public static void SayHiEnglish(String name)\n        {\n            Console.WriteLine(\"hi，\" + name);\n        }\n    }\n}\n```\n\n\n\n\n\n### 样例3：借助委托，利用一个方法实现将string数组中每个元素变成全大写或全小写，然后再加上双引号\n\n```c\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.AccessControl;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace 委托\n{\n    //声明一个委托\n    delegate void DelStr(string[] str);\n\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] str = { \"Hello\", \"Any\", \"Hurr\" };\n\n            //Test(str, ProStrToUpper);//转大写\n            //Test(str, ProStrToLower);//转小写\n            Test(str, ProStrSYH);//加双引号\n\n            foreach(var s in str)\n            {\n                Console.WriteLine(s);\n            }\n\n            Console.ReadLine();\n\n        }\n\n        public static void Test(string[] str, DelStr del)\n        {\n            del(str);\n        }\n\n        public static void ProStrToUpper(string[] str)\n        {\n            for(int i = 0; i < str.Length; i++)\n            {\n                str[i] = str[i].ToUpper();\n            }\n        }\n\n        public static void ProStrToLower(string[] str)\n        {\n            for(int i = 0; i < str.Length; i ++)\n            {\n                str[i] = str[i].ToLower();\n            }\n        }\n\n        public static void ProStrSYH(string[] str)\n        {\n            for(int i = 0; i < str.Length; i++)\n            {\n                str[i] = \"\\\"\" + str[i] + \"\\\"\";\n            }\n        }\n\n    }\n}\n\n```\n\n\n\n\n\n### 样例4：借助委托，利用一个方法实现将string数组中每个元素变成全大写或全小写，然后再加上双引号。\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.AccessControl;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace 委托\n{\n    //声明一个委托\n    delegate void DelStr(string[] str);\n    public delegate string DelProStr(string str);\n\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] str = { \"Hello\", \"Any\", \"Hurr\" };\n            //ProStr(str, ProStrToUpper);\n            //ProStr(str, ProStrToLower);\n            ProStr(str, ProStrSYH);\n\n            foreach(var s in str)\n            {\n                Console.WriteLine(s);\n            }\n            Console.ReadLine();\n        }\n\n        public static void ProStr(string[] name, DelProStr del )\n        {\n            for(int i = 0; i < name.Length; i++)\n            {\n                name[i] = del(name[i]);\n            }\n        }\n\n        public static string ProStrToUpper(string str)\n        {\n            return str.ToUpper();\n        }\n\n        public static string ProStrToLower(string str)\n        {\n            return str.ToLower();\n        }\n\n        public static string ProStrSYH(string str)\n        {\n            return \"\\\"\" + str + \"\\\"\";            \n        }\n    }\n}\n\n```\n\n### 在上一个样例的基础上，修改成使用匿名方法的委托。\n\n```c\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.AccessControl;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace 委托\n{\n    //声明一个委托\n    delegate void DelStr(string[] str);\n    public delegate string DelProStr(string str);\n\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] str = { \"Hello\", \"Any\", \"Hurr\" };\n\n            //ProStr(str, delegate (string s)\n            //{\n            //    return s.ToUpper();\n            //});\n            //ProStr(str, delegate (string s)\n            //{\n            //    return s.ToLower();\n            //});\n            ProStr(str, delegate (string s)\n            {\n                return \"\\\"\" + s + \"\\\"\";\n            });\n\n            foreach (var s in str)\n            {\n                Console.WriteLine(s);\n            }\n            Console.ReadLine();\n        }\n\n        public static void ProStr(string[] name, DelProStr del)\n        {\n            for (int i = 0; i < name.Length; i++)\n            {\n                name[i] = del(name[i]);\n            }\n        }\n    }\n}\n\n```\n\n\n\n### 泛型委托的应用：求任意数组的最大值\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace 泛型委托\n{\n    public delegate int DelCompare(object x, object y);\n\n    //声明一个泛型委托\n    public delegate int DelCompareT<T>(T t1,T t2);\n\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            //object[] o = { 1, 5, 3, 9 };\n            //object[] o2 = { \"hurr\", \"Any\", \"Jam\" };\n            //object result = GetMax(o, CompareInt);\n            //result = GetMax(o2, CompareString);\n            //Console.WriteLine(result);\n\n            int[] nums = { 1, 2, 3, 4, 5 };\n            var Result = GetMaxT<int>(nums, CompareIntNew);\n            Console.WriteLine(Result);\n\n            Console.ReadLine();\n        }\n\n        public static int GetMaxNum(int[] num)\n        {\n            int maxx = num[0];\n            for(int i = 0; i < num.Length; i++)\n            {\n                if(maxx < num[i])\n                    maxx = num[i];\n            }\n            return maxx;\n        }\n\n        public static string GetMaxName(string[] names)\n        {\n            string maxx = names[0];\n            for(int i = 0; i < names.Length;i++)\n            {\n                if(maxx.Length < names[i].Length)\n                    maxx = names[i];\n            }\n            return maxx;\n        }\n\n\n        //传参的时候可以传一个委托，用于执行比较方法\n        public static object GetMax(object[] nums, DelCompare del)\n        {\n            object maxx = nums[0];\n            for (int i = 0; i < nums.Length; i++)\n            {\n                //要传一个委托的比较方法\n                if ( del(maxx, nums[i]) < 0)\n                    maxx = nums[i];\n            }\n            return maxx;\n        }\n\n        //泛型委托的应用\n        public static T GetMaxT<T>(T[] nums, DelCompareT<T> del)\n        {\n            T maxx = nums[0];\n            for(int i = 0; i < nums.Length; i++)\n            {\n                if(del(maxx, nums[i]) < 0)\n                {\n                    maxx = nums[i];\n                }\n            }\n            return maxx;\n        }\n\n\n        //比较方法\n        public static int CompareInt(object x, object y)\n        {\n            int a = (int)x;\n            int b = (int)y;\n            return a - b;\n        }\n\n        public static int CompareIntNew(int x, int y)\n        {\n            return x - y;\n        }\n\n        public static int CompareString(object x, object y)\n        {\n            string s1 = (string)x;\n            string s2 = (string)y;\n            return s1.Length - s2.Length;\n        }\n\n        public static int CompareStringNew(String x, string y)\n        {\n            return x.Length - y.Length;\n        }\n    }\n}\n\n```\n\n\n\n\n\n## 使用委托的时机\n\n​\t委托和接口都允许类设计器分离类型声明和实现。 任何[类](https://learn.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/0b0thckt(v=vs.100))或[结构](https://learn.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/ah19swz4(v=vs.100))都能继承和实现给定的[接口](https://learn.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/87d83y5b(v=vs.100))。 可以为任何类上的方法创建[委托](https://learn.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/900fyy8e(v=vs.100))，前提是该方法符合委托的方法签名。 接口引用或委托可由不了解实现该接口或委托方法的类的对象使用。 既然存在这些相似性，那么类设计器何时应使用委托，何时又该使用接口呢？\n\n在以下情况下，请使用委托：\n\n- 当使用事件设计模式时。\n- 当封装静态方法可取时。\n- 当调用方不需要访问实现该方法的对象中的其他属性、方法或接口时。\n- 需要方便的组合。\n- 当类可能需要该方法的多个实现时。\n\n在以下情况下，请使用接口：\n\n- 当存在一组可能被调用的相关方法时。\n- 当类只需要方法的单个实现时。\n- 当使用接口的类想要将该接口强制转换为其他接口或类类型时。\n- 当正在实现的方法链接到类的类型或标识时：例如比较方法。\n\n[IComparable](https://msdn.microsoft.com/zh-cn/library/ey2t2ys5(v=vs.100)) 或泛型版本 [IComparable](https://msdn.microsoft.com/zh-cn/library/4d7sx9hd(v=vs.100)) 就是一个使用单一方法接口而不使用委托的很好的示例。 **IComparable** 声明 [CompareTo](https://msdn.microsoft.com/zh-cn/library/4ah99705(v=vs.100)) 方法，该方法返回一个整数，指定相同类型的两个对象之间的小于、等于或大于关系。 **IComparable** 可用作排序算法的基础。 虽然将委托比较方法用作排序算法的基础是有效的，但是并不理想。 因为进行比较的能力属于类，而比较算法不会在运行时改变，所以单一方法接口是理想的。\n\n来源：https://learn.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/ms173173(v=vs.100)\n\n\n\n\n\n\n\n## Lambda表达式\n\n纵然匿名方法使用很方便，可惜她很快就成了过气网红，没能领多长时间的风骚。如今已经很少见到了，因为delegate关键字限制了她用途的扩展。自从C# 3.0开始，她就被Lambda表达式取代，而且Lambda表达式用起来更简单。**Lambda表达式本质上是改进的匿名方法。**\n\n### 表达式Lambda\n\n当匿名函数只有一行代码时，可采用这种形式。例如：\n\n```csharp\nMyCalculator myCal = (num1, num2) =>  num1 + num2;\nint num = myCal(1, 2);// 3\n```\n\n其中`=>`符号代表Lambda表达式，它的左侧是参数，右侧是要返回或执行的语句。参数要放在圆括号中，若只有一个参数，为了方便起见可省略圆括号。有多个参数或者没有参数时，不可省略圆括号。\n相比匿名函数，在表达式Lambda中，方法体的花括号{}和return关键字被省略掉了。\n\n### 语句Lambda\n\n当匿名函数有多行代码时，只能采用语句Lambda。\n\n```csharp\nMyCalculator myCal = (int num1, int num2)=>\n{\n    Console.WriteLine(System.Reflection.MethodBase.GetCurrentMethod().Name);\n    return num1 + num2;\n};\nint num = myCal(1, 2);// 3\n```\n\n语句Lambda不可以省略{}和return语句。\n\n\n\n### Lambda的主要用处\n\n实际中用到Lambda表达式的地方大都是委托，例如linq的对集合类的扩展查询方法；\n很多架构的搭建需要调用自定义方法，也离不开委托；\n事件机制是基于委托的；\n等等。\n\n\n\n### Lambda样例\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Lambda表达式\n{\n    internal class Program\n    {\n        public delegate void DelOne();//没有参数，没有返回值的委托\n        public delegate void DelTwo(string str);//有参数，但没有返回值的委托\n        public delegate string DelThree(string str);//有参数，也有返回值的委托\n\n        static void Main(string[] args)\n        {\n            //使用lambda表达式创建三个对应的委托\n            DelOne d1 = () => { Console.WriteLine(\"这是一个没有参数 没有返回值的Lambda表达式\"); };\n            DelTwo d2 = (string name) => { Console.WriteLine(\"这是一个有参数但没有返回值的Lambda表达式，值为：\" + name); };\n            DelThree d3 = (string name) => { Console.WriteLine(\"这是一个具有参数和返回值委托\"); return \"hello,\" + name; };\n\n            //调用三个委托\n            d1();\n            d2(\"hurr\");\n            Console.WriteLine(d3(\"hurr\"));\n\n\n            Console.ReadKey();\n\n        }\n    }\n}\n\n```\n\n#### 样例2：移除指定集合的元素\n\n```c\nList<int> list = new List<int>() {1, 2, 3, 4, 5, 6, 7, 8, 9 };\nlist.RemoveAll(n => n > 4);//使用lambda表达式来确定删除的范围。范围是大于4的元素\nforeach (int i in list)\n{\n    Console.WriteLine(i);\n}\n```\n\n\n\n\n\n# C# 事件（Event）\n\n## 事件的概述\n\n​\t事件（Event） 基本上说是一个**用户操作**，如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件。例如，中断。\n\n\n\n事件可以感知发生了什么事情，\n\n事件 使 对象或类具备了**通知能力**的成员。\n\n​\t事件本身不会主动通知别的对象或类，事件的拥有者在完成某个逻辑的之后，明确的告诉事件成员通知其他人的时候，才会进行通知。即事件不会主动发声，当被拥有者的某些内部逻辑触发后，才能够发声。\n\n事件的功能 = 通知 + 可选的事件参数（详细信息）\n\n\n\n\n\n\n\n事件的使用时机：\n\n​\t用于对象或类之间的动作协调与信息传递（消息推送）\n\n​\tC# 中使用**事件机制实现线程间的通信**。\n\n\n\n### 事件模型（发生-相应模型）\n\n#### 事件的组成部分\n\n- 事件的拥有者（event source， 对象）\n- 事件成员（event，成员）\n- 事件的响应者（event subscriber，对象）\n- 事件处理器（event handler， 成员）\n  - 本质是一个回调方法\n- 事件订阅\n  - 把事件处理器和事件关联在一起，本质上是一种以委托类型为基础的“约定”\n\n\n\n发布器（publisher）(事件的拥有者) \n\n​\t发布器是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器（publisher）类的对象调用这个事件，并通知其他的对象。\n\n订阅器（事件的响应者）\n\n​\t订阅器（subscriber） 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器（subscriber）类中的方法（事件处理程序）。\n\n\n\n##### 注意事项\n\n- 事件处理器是方法成员\n- 挂接事件处理器的时候，可以使用委托实例，也可以直接使用方法名（语法糖）\n- 事件处理器对事件的订阅不是随意的，匹配与否由声明事件时所使用的委托类型来检测。\n  - 用于订阅这个事件的事件处理器必须和事件遵循同一个约定，这个约定既约束了事件能够把什么样的消息发送给事件处理器，也约束了事件的处理器能够处理什么样的消息。\n  - 如果事件是使用某个约定定义的，而且事件处理器也遵循同样的约定，那就可以说事件处理器与事件是匹配的，就可以拿这个事件处理器去订阅这个事件。\n  - 如果提供的事件处理器与想订阅的事件没有遵循同一个约定，那么此时就可以说这个事件处理器与事件是不匹配的。此时编译器就会报错。\n  - 这个约定，就是所说的委托。\n- 事件可以同步调用也可以异步调用。\n\n\n\n#### 发生-响应的五个动作：\n\n1. 我有一个事件\n\n2. 有人关心我这个事件（订阅）\n\n3. 我的事件发生了\n\n4. 关心事件的人依次被通知到\n\n5. 被通知到的人根据拿到事件信息（数据、参数、通知）对事件进行响应（处理时间）\n\n   \n\n注意：以下几个术语表示的是同一个对象：\n\n- 事件的订阅者\n\n  - 事件消息的接收者\n  - 事件的处理者\n  - 事件的响应者\n  - 被事件所通知的对象\n\n- 事件参数\n\n  - 事件信息\n  - 事件消息\n  - 事件数据\n\n  \n\n\n\n#### 样例\n\n闹钟响了我起床了：\n\n- 闹钟：事件\n- 响了：事件发生了\n- 我：我被通知到了\n- 起床：我根据通知到的信息（闹钟响了）做出响应（起床）\n- 隐藏关系：订阅\n  - 我订阅了这个闹钟，我才会被这个闹钟通知，就像我的闹钟不会通知别人起床一样，如果我没有订阅别人的闹钟，那么别人的闹钟响了我也不会去响应，\n\n\n\n\n\n### 事件的应用场景\n\n- 常用于开发客户端程序\n  - 如桌面、手机等开发的客户端，这些程序常是用户通过事件来“驱动”\n\n\n\n### 事件的注意事项\n\n- 对于事件的机制各种语言的实现方法不尽相同\n- Java中没有事件这个成员，也没有委托。Java使用接口实现相应功能\n- MVC、MVP、MVVM等模式是事件模式的高级用法。\n  - 事件模式本身也是一种设计模式\n- 经常使用已有的事件，自己声明事件的情况较少\n  - 自己声明的场景：自定义控件\n\n\n\n\n\n## 事件的应用\n\n### 样例1\n\n- 创建一个事件拥有者Timer\n- 创建两个事件响应者A和B\n- 分别在响应者内部设置事件处理器\n  - 名字自定义，不限于Action\n- 分别订阅时间拥有着的拥有的Elapsed事件\n  - 订阅只能+= 或 -=\n- 开启事件\n  - Elapsed对应的开启方法为start\n\n```c#\nusing System;\nusing System.Timers;\n\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Timer timer = new Timer();//事件的拥有者\n            //事件的图标是一个黄色的小闪电，此处用Elapsed演示：度过一段时间后就会触发。(小扳手是属性，小方块是方法)\n            timer.Interval = 1000;//时间间隔1000ms，事件拥有者 拥有的 事件\n\n            A a = new A();//事件响应者\n\n            //创建事件，并订阅事件，+=左边是事件，右边是事件响应者的事件处理器\n            //事件订阅操作符： +=。只能是+= 或 -=，不能分开写\n            timer.Elapsed += a.Action;\n\n\n            timer.Start();//开启事件\n\n\n            B b = new B();//再次创建一个事件的响应者\n            timer.Elapsed += b.Action;//并订阅时间拥有着timer的Elapsed事件。\n\n\n\n            Console.ReadKey();\n        }\n \n    }\n\n    //事件的响应者\n    class A\n    {\n        //自动生成的事件处理器（vs的修补功能）\n        internal void Action(object sender, ElapsedEventArgs e)\n        {\n            //throw new NotImplementedException();\n            Console.WriteLine(\"+1s\");\n        }\n    }\n\n    class B\n    {\n        internal void Action(object sender, ElapsedEventArgs e)\n        {\n            Console.WriteLine(\"Ohhhhh!\");\n        }\n    }\n}\n```\n\n\n\n\n\n### 样例2 事件的拥有者和事件的响应者是完全不同的两个对象\n\nVC、MVB设计模式的雏形。\n\n![1677713203984](./Image/C#学习笔记_基础教程.assets/1677713203984.jpg)\n\n```c#\nusing System;\nusing System.Windows.Forms;\n\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            Form form = new Form();//事件的拥有者\n\n            Controller controller = new Controller(form);//事件的响应者\n\n            form.ShowDialog();\n\n            Console.ReadKey();\n\n        } \n    }\n\n\n    class Controller\n    {\n        private Form form;\n\n        public Controller(Form form)\n        {\n            if(form == null) \n                throw new ArgumentNullException(\"form is null\");\n            else\n            {\n                this.form = form;\n                this.form.Click += this.FormClicked;//事件 及 事件订阅\n            }\n\n        }\n\n        //vs自动生成的事件处理器\n        private void FormClicked(object sender, EventArgs e)\n        {\n            //throw new NotImplementedException();\n\n            this.form.Text = DateTime.Now.ToString();//当点击窗口时，让窗口的标题栏显示当前时间\n        }\n    }\n}\n```\n\n\n\n### 样例3事件的拥有者和事件的响应者是同一个对象。\n\n即一个对象用自己的方法去订阅处理自己的事件。\n\n![1677713203935](./Image/C#学习笔记_基础教程.assets/1677713203935.jpg)\n\n```c#\nusing System;\nusing System.Windows.Forms;\n\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            MyForm myForm = new MyForm();//事件的拥有者和响应者\n\n            myForm.Click += myForm.FormClicked;//事件订阅\n\n            myForm.ShowDialog();           \n\n            Console.ReadKey();\n\n        }\n\n        private static void MyForm_Click(object sender, EventArgs e)\n        {\n            throw new NotImplementedException();\n        }\n    }\n\n    class MyForm : Form\n    {\n        //事件处理器\n        internal void FormClicked(object sender, EventArgs e)\n        {\n            this.Text = DateTime.Now.ToString();\n        }\n    }\n}\n```\n\n\n\n### 样例4 事件的拥有者是事件响应者的一个字段成员，事件响应者用自己的方法订阅着自己字段成员的某个事件\n\n![1677713203967](./Image/C#学习笔记_基础教程.assets/1677713203967.jpg)\n\n```c#\nusing System;\nusing System.Windows.Forms;\n\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            MyForm myForm = new MyForm();//事件响应者\n            myForm.ShowDialog();\n            \n\n            Console.ReadKey();\n        }\n    }\n\n    class MyForm : Form\n    {        \n        private TextBox textBox;\n        private Button button;//事件的拥有者\n\n        public MyForm()\n        {\n            this.textBox = new TextBox();\n            this.button = new Button();\n\n            //使添加的按钮和文本框显示出来\n            this.Controls.Add(textBox);\n            this.Controls.Add(button);\n\n            this.button.Click += this.ButtonClicked;//事件 事件订阅\n\n\n            //美化\n            this.button.Text = \"Say Hello\";\n            this.button.Top = 100;//按键的上边缘距离绘制窗口的顶端的距离\n        }\n\n        //事件处理器\n        private void ButtonClicked(object sender, EventArgs e)\n        {\n            this.textBox.Text = \"Hello World\";\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n## 声明事件（Event）\n\n事件是基于委托的：\n\n​\t第一层：事件需要委托类型来做一个约束。约束既规定事件能发送什么样的消息给响应者，也规定事件响应者能收到什么样的事件消息。这就决定了事件响应者的事件处理器，必须能够和这个约束匹配上，才能够订阅这个事件。\n\n​\t第二层意思：当事件响应者向事件拥有者提供了能够匹配这个事件的事件处理器之后，需要把事件处理器保存或者记录下来。能够记录或者说引用方法的任务，只有委托类型的实例能够做到。\n\n简而言之，只有委托能把五要素连起来\n\n委托是事件的底层基础，事件是委托的上层建筑。\n\n\n\n声明一个委托类型和声明一个委托类型的字段，都可以简化为声明一个委托。\n\n如果形参含有ref out方法参数就用不了func和action委托\n\n\n\n### 完整声明\n\n\n\n### 简略声明\n\n\n\n\n\n在类的内部声明事件，首先必须声明该事件的委托类型。例如：\n\n```c#\npublic delegate void BoilerLogHandler(string status);\n```\n\n然后，声明事件本身，使用 event 关键字：\n\n```c#\n// 基于上面的委托定义事件\npublic event BoilerLogHandler BoilerEventLog;\n```\n\n上面的代码定义了一个名为 BoilerLogHandler 的委托和一个名为 BoilerEventLog 的事件，该事件在生成的时候会调用委托。\n\n## 样例\n\n### 样例1\n\n```c#\nusing System;\nnamespace SimpleEvent\n{\n  using System;\n  /***********发布器类***********/\n  public class EventTest\n  {\n    private int value;\n\n    public delegate void NumManipulationHandler();\n\n\n    public event NumManipulationHandler ChangeNum;\n    protected virtual void OnNumChanged()\n    {\n      if ( ChangeNum != null )\n      {\n        ChangeNum(); /* 事件被触发 */\n      }else {\n        Console.WriteLine( \"event not fire\" );\n        Console.ReadKey(); /* 回车继续 */\n      }\n    }\n\n\n    public EventTest()\n    {\n      int n = 5;\n      SetValue( n );\n    }\n\n\n    public void SetValue( int n )\n    {\n      if ( value != n )\n      {\n        value = n;\n        OnNumChanged();\n      }\n    }\n\n  }\n\n\n  /***********订阅器类***********/\n\n  public class subscribEvent\n  {\n    public void printf()\n    {\n      Console.WriteLine( \"event fire\" );\n      Console.ReadKey(); /* 回车继续 */\n    }\n  }\n\n  /***********触发***********/\n  public class MainClass\n  {\n    public static void Main()\n    {\n      EventTest e = new EventTest(); /* 实例化对象,第一次没有触发事件 */\n      subscribEvent v = new subscribEvent(); /* 实例化对象 */\n      e.ChangeNum += new EventTest.NumManipulationHandler( v.printf ); /* 注册 */\n      e.SetValue( 7 );\n      e.SetValue( 11 );\n    }\n  }\n}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```bash\nevent not fire\nevent fire\nevent fire\n```\n\n\n\n### 实例 2\n\n本实例提供一个简单的用于热水锅炉系统故障排除的应用程序。当维修工程师检查锅炉时，锅炉的温度和压力会随着维修工程师的备注自动记录到日志文件中。\n\n\n\n```c#\nusing System;\nusing System.IO;\n\nnamespace BoilerEventAppl\n{\n\n   // boiler 类\n   class Boiler\n   {\n      private int temp;\n      private int pressure;\n      public Boiler(int t, int p)\n      {\n         temp = t;\n         pressure = p;\n      }\n\n      public int getTemp()\n      {\n         return temp;\n      }\n      public int getPressure()\n      {\n         return pressure;\n      }\n\n   }\n   // 事件发布器\n   class DelegateBoilerEvent\n   {\n      public delegate void BoilerLogHandler(string status);\n\n      // 基于上面的委托定义事件\n      public event BoilerLogHandler BoilerEventLog;\n    \n      public void LogProcess()\n      {\n         string remarks = \"O. K\";\n         Boiler b = new Boiler(100, 12);\n         int t = b.getTemp();\n         int p = b.getPressure();\n         if(t > 150 || t < 80 || p < 12 || p > 15)\n         {\n            remarks = \"Need Maintenance\";\n         }\n         OnBoilerEventLog(\"Logging Info:\\n\");\n         OnBoilerEventLog(\"Temparature \" + t + \"\\nPressure: \" + p);\n         OnBoilerEventLog(\"\\nMessage: \" + remarks);\n      }\n    \n      protected void OnBoilerEventLog(string message)\n      {\n         if (BoilerEventLog != null)\n         {\n            BoilerEventLog(message);\n         }\n      }\n\n   }\n   // 该类保留写入日志文件的条款\n   class BoilerInfoLogger\n   {\n      FileStream fs;\n      StreamWriter sw;\n      public BoilerInfoLogger(string filename)\n      {\n         fs = new FileStream(filename, FileMode.Append, FileAccess.Write);\n         sw = new StreamWriter(fs);\n      }\n      public void Logger(string info)\n      {\n         sw.WriteLine(info);\n      }\n      public void Close()\n      {\n         sw.Close();\n         fs.Close();\n      }\n   }\n   // 事件订阅器\n   public class RecordBoilerInfo\n   {\n      static void Logger(string info)\n      {\n         Console.WriteLine(info);\n      }//end of Logger\n\n      static void Main(string[] args)\n      {\n         BoilerInfoLogger filelog = new BoilerInfoLogger(\"e:\\\\boiler.txt\");\n         DelegateBoilerEvent boilerEvent = new DelegateBoilerEvent();\n         boilerEvent.BoilerEventLog += new\n         DelegateBoilerEvent.BoilerLogHandler(Logger);\n         boilerEvent.BoilerEventLog += new\n         DelegateBoilerEvent.BoilerLogHandler(filelog.Logger);\n         boilerEvent.LogProcess();\n         Console.ReadLine();\n         filelog.Close();\n      }//end of main\n\n   }//end of RecordBoilerInfo\n}\n```\n\n当上面的代码被编译和执行时，它会产生下列结果：\n\n```bash\nLogging info:\n\nTemperature 100\nPressure 12\n\nMessage: O. K\n```\n\n\n\n\n\n# 集合、比较和转换\n\n## 概述\n\n- 集合:可以使用集合来维护对象组。与前面章节使用的数组不同，集合可以包含更高级的功能，例如，控制对它们包含的对象的访问、搜索和排序等。本章将介绍如何使用和创建集合类，学习充分利用它们的一些强大技术。\n- 比较:在处理对象时，常要比较它们。这对于集合尤其重要，因为这是排序的实现方式。本章将介绍如何以各种方式比较对象(包括运算符重载)，如何使用IComparable和IComparer接口对集合进行排序。\n- 转换:前面的章节介绍了如何把对象从一*种类型转换为另- 种类型。 本章讨论如何定制类型转换，以满足自己的需要。\n\n## 集合\n\n大多数集合都在System.Collections，System.Collections.Generic两个命名空间。其中System.Collections.Generic专门用于泛型集合。\n\n针对特定类型的集合类型位于System.Collections.Specialized;命名空间；\n\n线程安全的集合类位于System.Collections.Concurrent;命名空间。\n\nSystem.Collections名称空间中的以下几个接口提供了基本的集合功能:\n\n- IEnumerable：可以迭代集合中的项。\n- ICollection： 继承于IEnumerable。 可以获取集合中项的个数,并能把项复制到一个简单的数组类型中。\n- IList：继承于lEnumerable 和ICollection。 提供了集合的项列表，允许访问这些项，并提供其他- -些\n- 与项列表相关的基本功能。\n- IDictionary：继 承于lEnumerable 和ICollection。 类似于IList,但提供了可通过键值(而不是索引)访问\n- 的项列表。\n\nSystem.Array类实现了IList、ICollection 和lEnumerable,但不支持IList的- -些更高级功能，它表示大小固\n定的项列表。\n\n### 集合概述\n\n集合（Collection）类是专门用于数据存储和检索的类。这些类提供了对栈（stack）、队列（queue）、列表（list）和哈希表（hash table）的支持。大多数集合类实现了相同的接口。\n\n集合（Collection）类服务于不同的目的，如为元素动态分配内存，基于索引访问列表项等等。这些类创建 Object 类的对象的集合。在 C# 中，Object 类是所有数据类型的基类。\n\n\n\n### 集合和列表实现的接口\n\n| 接口                            | 说明                                                         |\n| ------------------------------- | ------------------------------------------------------------ |\n| lEoumerable\\<T>                 | 如果将foreach语句用于集合，就需要IEoumerable接口。这个接口定义了方法GetEoumerator0,它返回一个实现了IEnumerator接口的枚举 |\n| ICollection\\<T>                 | ICollection\\<T>接口由泛型集合类实现。使用这个接口可以获得集合中的元素个数(Count属性),把集合复制到数组中(CopyTo0方法),还可以从集合中添加和删除元素(Add0, Remove),Clear() |\n| IList\\<T>                       | IList<T>接口用于可通过位置访问其中的元素列表，这个接口定义了-个索引器，可以在集合的指定位置插入或删除某些项(nsert0和RemoveAt0方法)lList<T>接口派生自LCollction<T>接口 |\n| ISet\\<T>                        | ISet<T>接口是.NET 4中新增的。实现这个接口的集允许合并不同的集，获得两个集的交集，检查两个集是否重叠。ISet<T>接口派生自lCollection<T>接口 |\n| IDictionary<TKey,TValue>        | IDictionary<TKey,TValue>接口由包含键和值的泛型集合类实现。使用这个接口可以访问所有的键和值，使用键类型的索引器可以访问某些项，还可以添加或删除某些项 |\n| ILookup<TKey,Tvalue>            | lLookup<TKey,Tvalue>接口类似于Dictionary<IKey,TValue >接口,实现该接口的集合有键和值，且可以通过一个键包含多个值 |\n| IComparer \\<T>                  | 接口IComparer <T>由比较器实现，通过Compare()方法给集合中的元素排序 |\n| IEqualityComparer\\<T>           | 接口IEqualityComparer<T>由一个比较器实现，该比较器可用于字典中的键。使用这个接口,可以对对象进行相等性比较。在.NET4中，这个接口也由数组和元组实现 |\n| IProducerConsumerCollection\\<I> | IProducerConsumerCollection<I>接口是.NET4中新增的，它支持新的线程安全的集合类 |\n\n\n\n\n\n\n\n\n### 各种集合类和它们的用法\n\n| 类                                                           | 描述和用法                                                   |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [动态数组（ArrayList）](https://www.runoob.com/csharp/csharp-arraylist.html) | 它代表了可被单独**索引**的对象的有序集合。它基本上可以替代一个数组。但是，与数组不同的是，您可以使用**索引**在指定的位置添加和移除项目，动态数组会自动重新调整它的大小。它也允许在列表中进行动态内存分配、增加、搜索、排序各项。 |\n| [哈希表（Hashtable）](https://www.runoob.com/csharp/csharp-hashtable.html) | 它使用**键**来访问集合中的元素。当您使用键访问元素时，则使用哈希表，而且您可以识别一个有用的键值。哈希表中的每一项都有一个**键/值**对。键用于访问集合中的项目。 |\n| [排序列表（SortedList）](https://www.runoob.com/csharp/csharp-sortedlist.html) | 它可以使用**键**和**索引**来访问列表中的项。排序列表是数组和哈希表的组合。它包含一个可使用键或索引访问各项的列表。如果您使用索引访问各项，则它是一个动态数组（ArrayList），如果您使用键访问各项，则它是一个哈希表（Hashtable）。集合中的各项总是按键值排序。 |\n| [堆栈（Stack）](https://www.runoob.com/csharp/csharp-stack.html) | 它代表了一个**后进先出**的对象集合。当您需要对各项进行后进先出的访问时，则使用堆栈。当您在列表中添加一项，称为**推入**元素，当您从列表中移除一项时，称为**弹出**元素。 |\n| [队列（Queue）](https://www.runoob.com/csharp/csharp-queue.html) | 它代表了一个**先进先出**的对象集合。当您需要对各项进行先进先出的访问时，则使用队列。当您在列表中添加一项，称为**入队**，当您从列表中移除一项时，称为**出队**。 |\n| [点阵列（BitArray）](https://www.runoob.com/csharp/csharp-bitarray.html) | 它代表了一个使用值 1 和 0 来表示的**二进制**数组。当您需要存储位，但是事先不知道位数时，则使用点阵列。您可以使用**整型索引**从点阵列集合中访问各项，索引从零开始。 |\n\n\n\n### 使用简单集合\n\n本部分中的示例使用泛型 [List](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1) 类，通过此类可使用对象的强类型列表。\n\n以下示例创建字符串列表，并通过使用 [foreach](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement) 语句循环访问字符串。\n\n```csharp\n// Create a list of strings.\nvar salmons = new List<string>();\nsalmons.Add(\"chinook\");\nsalmons.Add(\"coho\");\nsalmons.Add(\"pink\");\nsalmons.Add(\"sockeye\");\n\n// Iterate through the list.\nforeach (var salmon in salmons)\n{\n    Console.Write(salmon + \" \");\n}\n// Output: chinook coho pink sockeye\n```\n\n如果集合中的内容是事先已知的，则可以使用集合初始值设定项来初始化集合。 \n\n以下示例与上一示例相同，除了有一个集合初始值设定项用于将元素添加到集合\n\n```csharp\n// Create a list of strings by using a\n// collection initializer.\nvar salmons = new List<string> { \"chinook\", \"coho\", \"pink\", \"sockeye\" };\n\n// Iterate through the list.\nforeach (var salmon in salmons)\n{\n    Console.Write(salmon + \" \");\n}\n// Output: chinook coho pink sockeye\n```\n\n可以使用 [for](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement) 语句，而不是 `foreach` 语句来循环访问集合。 通过按索引位置访问集合元素实现此目的。 元素的索引开始于 0，结束于元素计数减 1。\n\n以下示例通过使用 `for` 而不是 `foreach` 循环访问集合中的元素。\n\n```csharp\n// Create a list of strings by using a\n// collection initializer.\nvar salmons = new List<string> { \"chinook\", \"coho\", \"pink\", \"sockeye\" };\n\nfor (var index = 0; index < salmons.Count; index++)\n{\n    Console.Write(salmons[index] + \" \");\n}\n// Output: chinook coho pink sockeye\n```\n\n以下示例通过指定要删除的对象，从集合中删除一个元素。\n\n```csharp\n// Create a list of strings by using a\n// collection initializer.\nvar salmons = new List<string> { \"chinook\", \"coho\", \"pink\", \"sockeye\" };\n\n// Remove an element from the list by specifying\n// the object.\nsalmons.Remove(\"coho\");\n\n// Iterate through the list.\nforeach (var salmon in salmons)\n{\n    Console.Write(salmon + \" \");\n}\n// Output: chinook pink sockeye\n```\n\n以下示例从一个泛型列表中删除元素。 使用以降序进行循环访问的 `for` 语句，而非 `foreach` 语句。 这是因为 [RemoveAt](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1.removeat) 方法将导致已移除的元素后的元素的索引值减小。\n\n```csharp\nvar numbers = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\n// Remove odd numbers.\nfor (var index = numbers.Count - 1; index >= 0; index--)\n{\n    if (numbers[index] % 2 == 1)\n    {\n        // Remove the element by specifying\n        // the zero-based index in the list.\n        numbers.RemoveAt(index);\n    }\n}\n// 遍历列表\n// 一个lambda表达式被放置在ForEach方法中\n// of the List(T) object.\nnumbers.ForEach(\n    number => Console.Write(number + \" \"));\n// Output: 0 2 4 6 8\n```\n\n对于 [List](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1) 中的元素类型，还可以定义自己的类。 在下面的示例中，由 [List](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1) 使用的 `Galaxy` 类在代码中定义。\n\n```csharp\nprivate static void IterateThroughList()\n{\n    var theGalaxies = new List<Galaxy>\n        {\n            new Galaxy() { Name=\"Tadpole\", MegaLightYears=400},\n            new Galaxy() { Name=\"Pinwheel\", MegaLightYears=25},\n            new Galaxy() { Name=\"Milky Way\", MegaLightYears=0},\n            new Galaxy() { Name=\"Andromeda\", MegaLightYears=3}\n        };\n\n    foreach (Galaxy theGalaxy in theGalaxies)\n    {\n        Console.WriteLine(theGalaxy.Name + \"  \" + theGalaxy.MegaLightYears);\n    }\n\n    // Output:\n    //  Tadpole  400\n    //  Pinwheel  25\n    //  Milky Way  0\n    //  Andromeda  3\n}\n\npublic class Galaxy\n{\n    public string Name { get; set; }\n    public int MegaLightYears { get; set; }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 集合的类型\n\n许多通用集合由 .NET 提供。 每种类型的集合用于特定的用途。\n\n本部分介绍了一些通用集合类：\n\n- [System.Collections.Generic](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic) 类\n- [System.Collections.Concurrent](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent) 类\n- [System.Collections](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections) 类\n\n\n\n\n\n#### System.Collections.Generic 类\n\n可以使用 [System.Collections.Generic](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic) 命名空间中的某个类来创建泛型集合。 当集合中的所有项都具有相同的数据类型时，泛型集合会非常有用。 泛型集合通过仅允许添加所需的数据类型，强制实施强类型化。\n\n下表列出了 [System.Collections.Generic](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic) 命名空间中的一些常用类：\n\n| 类                                                           | 说明                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [Dictionary](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.dictionary-2) | 表示基于键进行组织的键/值对的集合。                          |\n| [List](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1) | 表示可按索引访问的对象的列表。 提供用于对列表进行搜索、排序和修改的方法。 |\n| [Queue](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.queue-1) | 表示对象的先进先出 (FIFO) 集合。                             |\n| [SortedList](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.sortedlist-2) | 表示基于相关的 [IComparer](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.icomparer-1) 实现按键进行排序的键/值对的集合。 |\n| [Stack](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.stack-1) | 表示对象的后进先出 (LIFO) 集合。                             |\n\n有关其他信息，请参阅[常用集合类型](https://learn.microsoft.com/zh-cn/dotnet/standard/collections/commonly-used-collection-types)、[选择集合类](https://learn.microsoft.com/zh-cn/dotnet/standard/collections/selecting-a-collection-class)和 。\n\n\n\n\n\n#### System.Collections.Concurrent 类\n\n在 .NET Framework 4 以及更新的版本中，[System.Collections.Concurrent](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent) 命名空间中的集合可提供高效的线程安全操作，以便从多个线程访问集合项。\n\n只要多个线程同时访问集合，就应使用 [System.Collections.Concurrent](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent) 命名空间中的类，而不是 [System.Collections.Generic](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic) 和 [System.Collections](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections) 命名空间中的相应类型。 有关详细信息，请参阅[线程安全集合](https://learn.microsoft.com/zh-cn/dotnet/standard/collections/thread-safe/)和 。\n\n包含在 [System.Collections.Concurrent](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent) 命名空间中的一些类为 [BlockingCollection](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.blockingcollection-1)、[ConcurrentDictionary](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentdictionary-2)、[ConcurrentQueue](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentqueue-1) 和 [ConcurrentStack](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentstack-1)。\n\n\n\n\n\n#### System.Collections 类\n\n[System.Collections](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections) 命名空间中的类不会将元素作为特别类型化的对象存储，而是作为 `Object` 类型的对象存储。\n\n只要可能，则应使用 [System.Collections.Generic](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic) 命名空间或 [System.Collections.Concurrent](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent) 命名空间中的泛型集合，而不是 `System.Collections` 命名空间中的旧类型。\n\n下表列出了 `System.Collections` 命名空间中的一些常用类：\n\n| 类                                                           | 描述                                               |\n| :----------------------------------------------------------- | :------------------------------------------------- |\n| [ArrayList](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.arraylist) | 表示对象的数组，这些对象的大小会根据需要动态增加。 |\n| [Hashtable](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.hashtable) | 表示根据键的哈希代码进行组织的键/值对的集合。      |\n| [Queue](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.queue) | 表示对象的先进先出 (FIFO) 集合。                   |\n| [Stack](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.stack) | 表示对象的后进先出 (LIFO) 集合。                   |\n\n[System.Collections.Specialized](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.specialized) 命名空间提供专门类型化以及强类型化的集合类，例如只包含字符串的集合以及链接列表和混合字典。\n\n\n\n### ArrayList\n\n​\t在C#中，ArrayList是一个非泛型的对象集合，其大小会动态增加。它与数组相同，除了它的大小会动态增加。当不知道数据的类型和大小时，可以使用ArrayList添加未知数据。\n\n​\t创建ArrayList时，需要引入包含ArrayList类的命名空间`System.Collections`。可以使用`new`关键字创建`ArrayList`对象。例如：使用ArrayList arlist = new ArrayList();\n\n​\tArrayList可以包含多个null和重复值。\n\n​\tInsert 和 InsertRange的区别：（也适用于Add的两个方法）\n\n- Insert只能插入一个元素，InsertRange可以插入一堆元素\n- 如果使用Insert插入一个数组如`arrayList.Insert(0, new int[]{0, 0, 0});`，则表示将数组作为一个整体插入。如执行上面的语句，则表示插入一个`int[]`类型的元素\n- 如果使用`InsertRange`插入一个数组，如`arrayList.InsertRange(1, new int[] { -1, -1, -1 });`,则表示将数组中的元素逐个添加到集合中。相当于执行了3次插入，每次插入“-1”。\n\n\n\n\n\n​\t访问ArrayList时，可以使用索引器，与数组相同。索引从零开始，并且每个后续元素都会增加一。当需要访问其中的数据时，需要显式转换为适当的类型，或使用var变量。\n\n​\t迭代ArrayList时，可以使用foreach和for循环。ArrayList的Count属性返回ArrayList中元素的总数。\n\n​\t相对于数组，ArrayList的优点在于它是一个动态的、可调整大小的对象集合。它的大小可以根据需要动态增加或减少。这意味着不需要预先指定ArrayList的大小，而可以根据需要添加或删除元素。此外，ArrayList可以存储不同类型的数据，而数组只能存储特定类型的数据。\n\n​\t**然而，由于ArrayList不是强类型的，因此每次插入或检索都需要进行类型转换。此外，当ArrayList达到其容量时，它会动态扩展其内部数组的大小，这会带来一些性能损失**。\n\n\n\n```c#\nusing System;\nusing System.Collections;\n\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // 创建了一个集合对象\n            ArrayList arrayList = new ArrayList();\n\n            // 根据里氏转换原则，如果一个地方需要父类，可以使用一个子类代替。\n            // 因为ArrayList里面存放的元素是Object类型的，而所有元素都是继承于Object，因此可以存放任何的元素到ArrayList。\n            // 属于拆箱和装箱。\n            arrayList.Add(1);// 存放一个int\n            arrayList.Add(\"Hello World!\");// 存放一个string\n            arrayList.Add(1);//可以存放重复值\n            arrayList.Add(null);//null也可以放进去。\n            arrayList.Add(new Person());//自定义类型也可以。\n            arrayList.Add(new int[] { 1, 2, 3 });//甚至数组也可以。\n\n            // 删除集合中的元素\n            arrayList.Remove(1);//通过元素删除 删除第一次出现的这个元素。\n            arrayList.RemoveAt(2);// 通过下标进行删除（从0起）。\n            arrayList.RemoveRange(0, 1); // 删除指定范围的元素。\n\n            // 在指定的位置插入一个元素。\n            arrayList.Insert(0, new int[]{0, 0, 0});//在指定的位置插入一个元素\n            arrayList.InsertRange(1, new int[] { -1, -1, -1 });// 在指定的集合插入一个元素\n            // Insert 和 InsertRange的区别：（也适用于Add的两个方法）\n            // 前者只会插入一个元素（如果插入数组，则将整个数组视为一个整体插入）\n            // 后者只能插入一个集合或数组，并将数组中的元素依次插入\n            \n\n            arrayList.Add(\"over\");\n\n            // 可以通过count属性来获取ArrayList的长度。\n            // 可以使用foreach实现此功能。\n            for (int i = 0; i < arrayList.Count; i++)\n            {\n                var item = arrayList[i];//调用的时候需要显示的转换成为目标类型。\n\n                if (item is Person)\n                {\n                    ((Person)item).Say();//如果当前类型可以显示转换为Person类，则调用其中的Say方法。\n                }\n                else if (item is int[])//如果当前元素是数组，则遍历数组\n                {\n                    foreach (var x in (int[])item)\n                    {\n                        Console.Write(x + \" \");\n                    }\n                    Console.WriteLine();\n                }\n                else\n                {\n                    Console.WriteLine(item); //如果是简单类型，自动调用了ToString方法\n                }\n            }\n        }\n    }\n\n    class Person\n    {\n        public void Say()\n        {\n            Console.WriteLine(\"this is Person\");\n        }\n    }\n\n}\n```\n\n\n\n#### ArrayList分配空间的方式\n\nArrayList类使用内部的T []数组来实现。如果使用List\\<T> (int)构造函数进行初始化，它将分配指定大小的数组。如果使用默认构造函数，它将使用默认容量4，但在这种情况下，数组只会在第一次添加时分配。每次向列表中添加元素时，它首先检查容量是否已达到（即现有计数是否等于容量）。如果是，则创建一个新的大小为前一个数组两倍的新数组，将所有现有元素复制到其中，然后继续写入新元素。这将一直持续下去，直到达到您引用的硬限制（Int32.MaxValue）。\n\n​\t也就是说 初始插入数据的时候分配4个空间，以后的每次超限都会将空间扩大一倍。\n\n```c#\nusing System;\nusing System.Collections;\n\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // 创建了一个集合对象\n            ArrayList arrayList = new ArrayList();\n\n            /*\n             * count:表示这个集合中实际包含的元素的个数。\n             * capcity：表示这个集合中可以包含的元素的个数。\n             */\n\n            // 当其中没有元素的时候，实际包含的和可包含的都是0.\n            Console.WriteLine(\"未添加数据时\");\n            Console.WriteLine(\"arrayList.Count:\" + arrayList.Count);\n            Console.WriteLine(\"arrayList.Capacity:\" + arrayList.Capacity);\n\n            arrayList.Add(1);\n\n            //添加了一个数据之后，实际包含的个数变成了1，可包含的个数变成了4\n            Console.WriteLine(\"只添加一个数据时\");\n            Console.WriteLine(\"arrayList.Count:\" + arrayList.Count);\n            Console.WriteLine(\"arrayList.Capacity:\" + arrayList.Capacity);\n\n            arrayList.Add(1); arrayList.Add(1); arrayList.Add(1);\n\n            //添加了4个数据之后，实际包含的个数变成了4，可包含的个数变成了4\n            Console.WriteLine(\"添加了4个数据时\");\n            Console.WriteLine(\"arrayList.Count:\" + arrayList.Count);\n            Console.WriteLine(\"arrayList.Capacity:\" + arrayList.Capacity);\n\n            arrayList.Add(1);\n\n            //再次添加了一个数据之后，实际包含的个数变成了5，可包含的个数变成了8\n            Console.WriteLine(\"添加了5个数据时\");\n            Console.WriteLine(\"arrayList.Count:\" + arrayList.Count);\n            Console.WriteLine(\"arrayList.Capacity:\" + arrayList.Capacity);\n\n\n            // 再次实验 使得其中的数量再次超界\n            arrayList.Add(1); arrayList.Add(1); arrayList.Add(1); arrayList.Add(1);\n\n            // 可以看到 可包含的个数达到16个了。\n            Console.WriteLine(\"添加了9个数据时\");\n            Console.WriteLine(\"arrayList.Count:\" + arrayList.Count);\n            Console.WriteLine(\"arrayList.Capacity:\" + arrayList.Capacity);\n\n            // 也就是说 初始插入数据的时候分配4个空间，以后的每次超限都会将空间扩大一倍\n        }\n    }\n}\n```\n\n\n\n\n\n### 键/值对集合（Hashtable）\n\n根据键去找值。键和值一一对应。\n\n\n\n\n\n```c#\nusing System;\nusing System.Collections;\n\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // 声明一个键值对\n            Hashtable ht = new Hashtable();\n\n            // 添加元素\n            ht.Add(1, \"张三\");// 前者是键，后者是值。\n            ht.Add(2, \"李四\");\n            ht.Add(3, \"王五\");\n            ht.Add(false, \"错误\");//任何类型均可作为键或值，因为所需的参数是Object类型。\n            //ht.Add(3, \"王六\");// 当发生值重复的时候，会抛出异常System.ArgumentException:“Item has already been added. Key in dictionary: '3'  Key being added: '3'”\n            ht[4] = \"王六\";// 也可以使用这种方式来添加数据\n            ht[4] = \"王七\";// 此时可以避免因键重复而导致的异常。\n            \n            \n            // 访问元素\n            // 在键值对集合中，是通过键去找值的。\n            // 因此，在键值对集合中，键必须是唯一的，而值可以重复。\n            //Console.WriteLine(ht[false]); //根据键 false 去寻找对应的值，然后输出值。 可以看到 这里输出了“错误”\n\n            // 因此，在键值对集合中，不能用for循环来遍历。只能用forweach遍历。具体方法如下：\n            // 需要注意的是，如果使用foreach进行遍历，其顺序是与添加顺序相逆的。\n            foreach (var item in ht.Keys)\n            {\n                Console.WriteLine(ht[item]);\n            }\n            //或者直接遍历值。\n            foreach (var item in ht.Values)\n            {\n                Console.WriteLine(item);\n            }\n\n\n            Console.WriteLine(); Console.WriteLine();\n            Console.WriteLine(\"常用方法演示\");\n            // hashtable常用的一些方法：\n            // 插入数据前判断一下要插入的“键”是否是已存在的\n            if (!ht.ContainsKey(\"abc\"))// 如果键值对集合中不存在键为abc的对，\n            {\n                ht.Add(\"abc\", \"cba\");// 则添加abc -> cba的键值对\n            }\n\n            //删除键值对中的指定元素\n            ht.Remove(4);\n            foreach (var item in ht.Values)\n            {\n                Console.WriteLine(item);\n            }\n\n            // 清空键值对集合\n            ht.Clear();\n\n            \n\n            Console.WriteLine(); Console.WriteLine();\n            Console.WriteLine(\"注意事项部分：\");\n\n            //注意事项\n            Console.WriteLine(ht.ContainsKey(0));//查看一下是否存在键为0的键值对\n            Console.WriteLine(ht[0]);//在不存在的前提下方法一下这个键值对\n            Console.WriteLine(ht.ContainsKey(0));//此时可以发现。如果不存在，则访问后还不存在。\n            ht[0] = 1;\n            Console.WriteLine(ht.ContainsKey(0));//除非手动插入\n            Console.WriteLine(); Console.WriteLine();\n\n\n        }\n    }\n}\n```\n\n\n\n\n\n### Dictionary：字典键值对\n\nDictionary是一个通用集合，通常用于存储键/值对。\n\n它的工作方式与非通用的哈希表非常相似。Dictionary的优点是它是一种通用类型。Dictionary定义在System.Collections.Generic命名空间下。\n\nDictionary<TKey, TValue>存储键值对，实现了IDictionary<TKey, TValue>接口。键必须是唯一的且不能为空。值可以为空或重复。可以通过传递关联键来访问值，例如myDictionary [key] 。\n\n```c#\nusing System;\nusing System.Collections;\nusing System.IO;\nusing System.Text;\n\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            //创建一个字典键值对集合\n            //与hashtable不同，键和值的类型在定义的时候就已经被定义了。\n            Dictionary<int, string> dic = new Dictionary<int, string>();\n            \n            //添加数据\n            //键只能是int，值只能是string\n            //同样键不可以重复\n            dic.Add(1, \"张三\");\n            dic.Add(2, \"李四\");\n            dic[3] = \"王五\";\n\n            //遍历\n            //可以以键值对的形式进行遍历\n            foreach(KeyValuePair<int, string> kvp in dic)\n            {\n                Console.WriteLine($\"key:{kvp.Key}\\tvalue:{kvp.Value}\");\n            }\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### List 泛型集合\n\n对集合中的类型已经有了比较确切的定义（和数组一样）。\n\n具体操作和普通的ArrayList类型。\n\n特殊的地方就是可以与数组相互转换。能转成什么类型的数组取决于是什么类型的集合。\n\n### 使用 LINQ 访问集合\n\n可以使用 LINQ（语言集成查询）来访问集合。 LINQ 查询提供筛选、排序和分组功能。 有关详细信息，请参阅 [C# 中的 LINQ 入门](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/)。\n\n以下示例运行一个对泛型 `List` 的 LINQ 查询。 LINQ 查询返回一个包含结果的不同集合。\n\n```csharp\nprivate static void ShowLINQ()\n{\n    List<Element> elements = BuildList();\n\n    // LINQ Query.\n    var subset = from theElement in elements\n                 where theElement.AtomicNumber < 22\n                 orderby theElement.Name\n                 select theElement;\n\n    foreach (Element theElement in subset)\n    {\n        Console.WriteLine(theElement.Name + \" \" + theElement.AtomicNumber);\n    }\n\n    // Output:\n    //  Calcium 20\n    //  Potassium 19\n    //  Scandium 21\n}\n\nprivate static List<Element> BuildList()\n{\n    return new List<Element>\n    {\n        { new Element() { Symbol=\"K\", Name=\"Potassium\", AtomicNumber=19}},\n        { new Element() { Symbol=\"Ca\", Name=\"Calcium\", AtomicNumber=20}},\n        { new Element() { Symbol=\"Sc\", Name=\"Scandium\", AtomicNumber=21}},\n        { new Element() { Symbol=\"Ti\", Name=\"Titanium\", AtomicNumber=22}}\n    };\n}\n\npublic class Element\n{\n    public string Symbol { get; set; }\n    public string Name { get; set; }\n    public int AtomicNumber { get; set; }\n}\n```\n\n\n\n\n\n### 对集合排序\n\n以下示例阐释了对集合排序的过程。 该示例对 [List](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1) 中存储的 `Car` 类的实例进行排序。 `Car` 类实现 [IComparable](https://learn.microsoft.com/zh-cn/dotnet/api/system.icomparable-1) 接口，此操作需要实现 [CompareTo](https://learn.microsoft.com/zh-cn/dotnet/api/system.icomparable-1.compareto) 方法。\n\n每次对 [CompareTo](https://learn.microsoft.com/zh-cn/dotnet/api/system.icomparable-1.compareto) 方法的调用均会执行用于排序的单一比较。 `CompareTo` 方法中用户编写的代码针对当前对象与另一个对象的每个比较返回一个值。 如果当前对象小于另一个对象，则返回的值小于零；如果当前对象大于另一个对象，则返回的值大于零；如果当前对象等于另一个对象，则返回的值等于零。 这使你可以在代码中定义大于、小于和等于条件。\n\n在 `ListCars` 方法中，`cars.Sort()` 语句对列表进行排序。 对 [List](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1) 的 [Sort](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1.sort) 方法的此调用将导致为 `List` 中的 `Car` 对象自动调用 `CompareTo` 方法。\n\n```csharp\nusing System;\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            ListCars();\n\n            Console.ReadKey();\n        }\n\n\n        private static void ListCars()\n        {\n            var cars = new List<Car>\n            {\n                { new Car() { Name = \"car1\", Color = \"blue\", Speed = 20}},\n                { new Car() { Name = \"car2\", Color = \"red\", Speed = 50}},\n                { new Car() { Name = \"car3\", Color = \"green\", Speed = 10}},\n                { new Car() { Name = \"car4\", Color = \"blue\", Speed = 50}},\n                { new Car() { Name = \"car5\", Color = \"blue\", Speed = 30}},\n                { new Car() { Name = \"car6\", Color = \"red\", Speed = 60}},\n                { new Car() { Name = \"car7\", Color = \"green\", Speed = 50}}\n            };\n\n            // 按颜色字母顺序排序，然后按速度降序排序。\n            cars.Sort();\n\n            // View all of the cars.\n            foreach (Car thisCar in cars)\n            {\n                Console.Write(thisCar.Color.PadRight(5) + \" \");\n                Console.Write(thisCar.Speed.ToString() + \" \");\n                Console.Write(thisCar.Name);\n                Console.WriteLine();\n            }\n\n            // Output:\n            //  blue  50 car4\n            //  blue  30 car5\n            //  blue  20 car1\n            //  green 50 car7\n            //  green 10 car3\n            //  red   60 car6\n            //  red   50 car2\n        }\n    }\n\n    public class Car : IComparable<Car>\n    {\n        public string Name { get; set; }\n        public int Speed { get; set; }\n        public string Color { get; set; }\n\n\n        /// <summary>\n        /// 摘要：\n        /// 将当前实例与同一类型的另一个对象进行比较，并返回一个整数，\n        /// 该整数指示当前实例在排序顺序中是在其他对象之前、之后还是出现在相同的位置。\n        /// </summary>\n        /// <param name=\"other\">要与此实例进行比较的对象。</param>\n        /// <returns>\n        /// \n        /// 一个值，表示被比较对象的相对顺序。返回值具有以下含义：\n        ///  价值–意义\n        ///  小于零–此实例在排序顺序上位于其他实例之前。\n        ///  零–此实例与其他实例在排序顺序中出现在相同的位置。\n        ///  大于零–此实例在排序顺序上跟在其他实例之后。\n        /// \n        /// </returns>\n        public int CompareTo(Car other)\n        {\n            // 对该方法的调用将进行一次用于排序的比较。\n\n            // 确定被比较对象的相对顺序。\n            // 按颜色字母顺序排序，然后按速度降序排序。\n\n            // 比较颜色。\n            int compare;\n            compare = String.Compare(this.Color, other.Color, true);\n\n            // 如果颜色相同，请比较速度。\n            if (compare == 0)\n            {\n                compare = this.Speed.CompareTo(other.Speed);\n\n                // 使用降序表示速度。\n                compare = -compare;\n            }\n\n            return compare;\n        }\n    }\n\n\n}\n```\n\n### 定义自定义集合\n\n可以通过实现 [IEnumerable](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.ienumerable-1)\\<T> 或 [IEnumerable](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerable) 接口来定义集合。\n\n尽管可以定义自定义集合，但通常最好使用包含在 .NET 中的集合，这在本文前面的[集合类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/collections#BKMK_KindsOfCollections)中进行了介绍。\n\n以下示例定义一个名为 `AllColors` 的自定义集合类。 此类实现 [IEnumerable](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerable) 接口，此操作需要实现 [GetEnumerator](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerable.getenumerator) 方法。\n\n`GetEnumerator` 方法返回 `ColorEnumerator` 类的一个实例。 `ColorEnumerator` 实现 [IEnumerator](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerator) 接口，此操作需要实现 [Current](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerator.current) 属性、[MoveNext](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerator.movenext) 方法以及 [Reset](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerator.reset) 方法。\n\n```csharp\nprivate static void ListColors()\n{\n    var colors = new AllColors();\n\n    foreach (Color theColor in colors)\n    {\n        Console.Write(theColor.Name + \" \");\n    }\n    Console.WriteLine();\n    // Output: red blue green\n}\n\n// Collection class.\npublic class AllColors : System.Collections.IEnumerable\n{\n    Color[] _colors =\n    {\n        new Color() { Name = \"red\" },\n        new Color() { Name = \"blue\" },\n        new Color() { Name = \"green\" }\n    };\n\n    public System.Collections.IEnumerator GetEnumerator()\n    {\n        return new ColorEnumerator(_colors);\n\n        // Instead of creating a custom enumerator, you could\n        // use the GetEnumerator of the array.\n        //return _colors.GetEnumerator();\n    }\n\n    // Custom enumerator.\n    private class ColorEnumerator : System.Collections.IEnumerator\n    {\n        private Color[] _colors;\n        private int _position = -1;\n\n        public ColorEnumerator(Color[] colors)\n        {\n            _colors = colors;\n        }\n\n        object System.Collections.IEnumerator.Current\n        {\n            get\n            {\n                return _colors[_position];\n            }\n        }\n\n        bool System.Collections.IEnumerator.MoveNext()\n        {\n            _position++;\n            return (_position < _colors.Length);\n        }\n\n        void System.Collections.IEnumerator.Reset()\n        {\n            _position = -1;\n        }\n    }\n}\n\n// Element class.\npublic class Color\n{\n    public string Name { get; set; }\n}\n```\n\n\n\n\n\n### 迭代器\n\n迭代器用于对集合执行自定义迭代。 迭代器可以是一种方法，或是一个 `get` 访问器。 迭代器使用 [yield return](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/yield) 语句返回集合的每一个元素，每次返回一个元素。\n\n通过使用 [foreach](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement) 语句调用迭代器。 `foreach` 循环的每次迭代都会调用迭代器。 迭代器中到达 `yield return` 语句时，会返回一个表达式，并保留当前在代码中的位置。 下次调用迭代器时，将从该位置重新开始执行。\n\n有关详细信息，请参阅[迭代器 (C#)](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/iterators)。\n\n下面的示例使用迭代器方法。 迭代器方法具有位于 `for` 循环中的 `yield return` 语句。 在 `ListEvenNumbers` 方法中，`foreach` 语句体的每次迭代都会创建对迭代器方法的调用，并将继续到下一个 `yield return` 语句。\n\n\n\n```csharp\nprivate static void ListEvenNumbers()\n{\n    foreach (int number in EvenSequence(5, 18))\n    {\n        Console.Write(number.ToString() + \" \");\n    }\n    Console.WriteLine();\n    // Output: 6 8 10 12 14 16 18\n}\n\nprivate static IEnumerable<int> EvenSequence(\n    int firstNumber, int lastNumber)\n{\n    // Yield even numbers in the range.\n    for (var number = firstNumber; number <= lastNumber; number++)\n    {\n        if (number % 2 == 0)\n        {\n            yield return number;\n        }\n    }\n}\n```\n\n\n\n## 比较\n\n对象间的比较可以分为两大类，分别是`类型比较`、`引用比较`、`值比较`、`深度比较`、`大小比较`等\n\n- 类型比较，即比较两个对象的类型是否是同一个\n- 引用比较，即比较两个对象的引用是否相同，可以使用Object.ReferenceEquals方法或者==操作符（对于引用类型）。\n- 值比较，即比较两个对象的值是否相等，可以使用Object.Equals方法或者重载的==操作符（对于值类型或者自定义类型）。\n- 深度比较，即比较两个引用类型对象中包含的所有属性或字段是否相等，可以使用一些第三方库，如Objects Comparer或者自己实现一个递归的比较方法。\n- 大小比较，即比较两个对象的大小顺序，可以使用IComparable接口或者IComparer\\<T>接口。\n\n\n\n注意：类型比较和引用比较不是指的同一个。类型比较是指比较两个对象的类型是否相同，可以使用`GetType`方法或者`is`操作符。引用比较是指比较两个对象的引用是否相同，可以使用`Object.ReferenceEquals`方法或者`==`操作符（对于引用类型）。\n\n\n\n### 类型比较\n\n在比较对象时，常需要了解它们的类型，才能确定是否可以进行值的比较。常用的方法有：`GetType()`和`is` 运算符。它可以提供可读性较高的代码，还可以检查基类。在`is`运算符之前，需要了解处理值类型(与引用类型相反)时后台的一些常见操作:封箱(boxing)和拆箱(unboxing)。\n\n\n\n#### is运算符\n\n##### 基本语法\n\n\\<operand> is \\<type>\n这个表达式的结果如下:\n\n- 如果\\<type>是一个类类型， 而\\<operand>也是该类型，或者它继承了该类型，或者它可以封箱到该类型中，则结果为true。\n- 如果\\<type>是 一个接口类型，而\\<operand> 也是该类型，或者它是实现该接口的类型，则结果为tnue.\n- 如果\\<type>是一个值类型， 而\\<operand>也是该类型， 或者它可以拆箱到该类型中，则结果为true。\n\n##### 样例\n\nis运算符是一种用来判断对象是否是某种类型，或者是否可以转换为某种类型的运算符。如果是，这个运算符就返回true，否则返回false12。例如：\n\n```c#\ndouble x = 100;\nConsole.WriteLine(x is double); // 输出：True\nConsole.WriteLine(x is int); // 输出：False\n```\n\nis运算符还可以用来匹配表达式与模式，如常量模式，关系模式，属性模式等3。例如：\n\n```c#\nstatic bool IsFirstFridayOfOctober(DateTime date) => date is { Month: 10, Day: <=7, DayOfWeek: DayOfWeek.Friday };\n```\n\n```csharp\nstatic bool IsFirstFridayOfOctober(DateTime date)\n{\n    return date.Month == 10 && date.Day <= 7 && date.DayOfWeek == DayOfWeek.Friday;\n}\n```\n\n在这个例子中，is运算符将date与一个属性模式匹配，判断它是否是10月的第一个星期五。\n\n\n\n### 引用比较\n\n引用比较是一种用来判断两个对象是否指向同一个内存地址的比较方式。在c#中，可以使用Object.ReferenceEquals静态方法或者==运算符（对于引用类型）来进行引用比较。例如：\n\n```c#\nstring s1 = \"hello\";\nstring s2 = \"hello\";\nstring s3 = new string(\"hello\".ToCharArray());\nConsole.WriteLine(Object.ReferenceEquals(s1, s2)); // 输出：True\nConsole.WriteLine(Object.ReferenceEquals(s1, s3)); // 输出：False\nConsole.WriteLine(s1 == s2); // 输出：True\nConsole.WriteLine(s1 == s3); // 输出：True\n```\n\n在这个例子中，s1和s2都是指向字符串常量池中的同一个字符串对象，所以引用比较返回true。而s3是通过构造函数创建的一个新的字符串对象，所以引用比较返回false。注意，==运算符对于字符串类型是进行内容比较的，所以s1和s3的内容比较返回true。\n\n\n\n### 值比较\n\n值比较是一种用来判断两个对象的内容是否相等的比较方式。在c#中，可以使用Object.Equals静态方法或者==运算符（对于值类型）来进行值比较。例如：\n\n```c#\nint x = 10;\nint y = 10;\nConsole.WriteLine(Object.Equals(x, y)); // 输出：True\nConsole.WriteLine(x == y); // 输出：True\n```\n\n在这个例子中，x和y都是值类型，所以它们的值比较返回true。注意，==运算符对于值类型是进行值比较的，而对于引用类型是进行引用比较的。\n\n#### IComparable和IComparer接口\n\nIComparable和IComparer接日是.NETFramework中比较对象的标准方式。这两个接口之间的区别如下:\n\n- IComparable 在要比较的对象的类中实现，可以比较该对象和另一个对象。\n- IComparer 在一个单独的类中实现，可以比较任意两个对象\n\n​\tIComparable提供了一个方法CompareTo() , 这个方法接受一个对象。 例如，在实现该方法时，使其可以接\n受一个Peson对象，以便确定这个人比当前的人更年老还是更年轻。实际上，这个方法返回一个int, 所以也\n可以确定第二个人与当前的人的年龄差:\n\n```c#\nif(person1.CompareTo(person2) == 0)\n{\n\tConsole.WriteLine(\"SameAge\");\n}\nelse if(person1.CompareTo(person2) > 0)\n{\n\tConsole.WriteLine(\"person1 is older\");\n}\nelse\n{\n\tConsole.WriteLine(\"person1 is Younger\");\n}\n```\n\n\n\nIComparer也提供-一个方法Compare()。 这个方法接受两个对象，返回一个整型结果，这与Compare To()相同。\n对于支持IComparer的对象，可使用下面的代码:\n\n```c#\nif (personComparer.Compare(personl, person2) == 0)\n{\n\tWriteLine (\"Same age\") ;\n}\nelse if (personComparer.Compare(person1, person2) > 0)\n{\n\tConsole.WriteLine(\"person1 is older\");\n}\nelse\n{\n\tConsole.WriteLine(\"person1 is Younger\");\n}\n```\n\n\n\n#### 值比较的方法\n\n- 使用String.Compare()方法，它接受两个字符串作为参数，并返回一个整数值，表示两个字符串的比较结果。如果两个字符串相等，返回0；如果第一个字符串小于第二个字符串，返回负数；如果第一个字符串大于第二个字符串，返回正数。\n- 使用CompareTo()方法，它是一个实例方法，用于比较当前对象和另一个对象的值。它也返回一个整数值，表示两个对象的比较结果。如果两个对象相等，返回0；如果当前对象小于另一个对象，返回负数；如果当前对象大于另一个对象，返回正数。\n- 使用==和!=运算符，它们用于比较两个值是否相等或不相等。它们返回一个布尔值，表示两个值的比较结果。如果两个值相等，返回true；如果两个值不相等，返回false。\n\n\n\n\n\n#### 对自定义类实现sort排序\n\n在c#中实现对自定义类的sort排序的方法有以下几种：\n\n- 让自定义类实现IComparable接口，并定义CompareTo方法，用于比较当前对象和另一个对象。然后使用List\\<T>.Sort()方法对列表进行排序，它会使用默认的比较器。\n- 定义一个实现IComparer接口的类，并定义Compare方法，用于比较两个对象。然后使用List\\<T>.Sort(IComparer\\<T>)方法对列表进行排序，它会使用指定的比较器。\n- 使用LINQ的orderby子句对列表进行排序，它会返回一个排序后的序列。可以指定排序的属性和顺序。\n\n\n\n##### 样例\n\n假设有一个自定义类Student，有两个属性Name和Score，表示学生的姓名和成绩。\n\n- 使用IComparable接口的示例代码：\n\n```c#\nusing System;\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<StudentA> studentsA = new List<StudentA>()// 创建要比较的序列\n            {\n                new StudentA(\"张三\", 20),\n                new StudentA(\"李四\", 21),\n                new StudentA(\"王五\", -10)\n            };\n            studentsA.Sort();//直接调用\n            foreach(var t in studentsA)\n            {\n                Console.WriteLine($\"name : {t.Name}   age : {t.Age}\");\n            }\n            Console.ReadKey();\n        }\n    }\n\n\n    /// <summary>\n    /// 样例1 在自定义的类内定义比较方法\n    /// 使用Icomparable实现类内自带比较方法\n    /// </summary>\n    class StudentA : IComparable<StudentA>\n    {\n        public string Name { get; set; }\n        public int Age { get; set; }\n\n        public int CompareTo(StudentA other)//加上一个?表示这个参数是一个可空类型，可以接受null作为值。这样可以增加方法的灵活性，可以处理null的情况。例如，如果other是null，那么可以返回1，表示当前对象大于null。\n        {\n            return other.Age - this.Age;//调整这个实现正序、逆序的排序\n        }\n\n        public StudentA(string name, int age)\n        {\n            Name = name;\n            Age = age;\n        }\n    }\n}\n```\n\n- 使用IComparer接口的示例代码：\n\n```c#\nusing System;\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<StudentB> studentsB = new List<StudentB>()// 创建要比较的序列\n            {\n                new StudentB(\"张三\", 20),\n                new StudentB(\"李四\", 21),\n                new StudentB(\"王五\", -10)\n            };\n            // 实例化比较对象\n            MyComparer myComparer = new MyComparer();\n\n            //使用Sort进行排序\n            studentsB.Sort(myComparer);\n\n            foreach (var t in studentsB)\n            {\n                Console.WriteLine($\"name : {t.Name}   age : {t.Age}\");\n            }\n            Console.ReadKey();\n        }\n    }\n\n    /// <summary>\n    /// 样例2 使用第三方比较类实现\n    /// </summary>\n    class StudentB\n    {\n        public string Name { get; set; }\n        public int Age { get; set; }\n\n        public StudentB(string name, int age)\n        {\n            Name = name;\n            Age = age;\n        }\n    }\n\t// yo\n    class MyComparer : IComparer<StudentB>\n    {\n        public int Compare(StudentB x, StudentB y)\n        {\n            return x.Age - y.Age;//调整这个实现正序、逆序的排序\n        }\n    }\n    \n}\n```\n\n- 使用LINQ的orderby子句的示例代码：\n\n```c#\n//定义Student类\nclass Student\n{\n    public string Name { get; set; }\n    public int Score { get; set; }\n}\n\n//创建一个Student列表\nList<Student> students = new List<Student>()\n{\n    new Student() { Name = \"Alice\", Score = 90 },\n    new Student() { Name = \"Bob\", Score = 80 },\n    new Student() { Name = \"Charlie\", Score = 85 },\n    new Student() { Name = \"David\", Score = 95 }\n};\n\n//使用LINQ的orderby子句对列表进行排序，按照成绩升序，姓名降序\nvar sortedStudents = from student in students orderby student.Score, student.Name descending select student;\n\n//打印排序后的序列\nforeach (var student in sortedStudents)\n{\n    Console.WriteLine($\"{student.Name}: {student.Score}\");\n}\n```\n\n\n\n\n\n# 文件\n\n## 文件编码\n\n- 文本文件有不同的存储方式，将字符串以什么形式保存为二进制，这个就是编码。常见的编码有UTF-8、ASCII、Unicode、gbk等。\n- 如果出现乱码一般都是编码的问题，文本文件相关的函数一般都具有一个Encoding类型的参数。\n- 取得编码的方式：Encoding.Defaule，Encoding.UTF8、Encoding.GetEncoding(\"GBK\")\n- 常用静态方法\n  - void AppendAllText(string path, string contents);\n    - 将文本contents附加到文件path中\n  - bool Exists(string path)\n    - 判断文件path是否存在\n  - string[ ReadAllL ines(string path)读取文本文件到字符串数组中\n  - string ReadAIIText(string path)读取文本文件到字符串中\n    void WriteAllText(string path, string contents)\n    将文本contents保存到文件path中，会覆盖旧内容。\n    WriteAllL ines(string path,string[ contents);\n    将字符串数组逐行保存到文件path中，会覆盖旧内容。\n\n## 输入输出的类\n\n### Path类\n\nPath 类是 C# 中的一个`静态类`，它属于 `System.IO` 命名空间和 `System.Runtime.dll` 程序集。这个类用于对包含文件路径或目录路径信息的字符串实例执行操作。路径是一个字符串，它提供了文件或目录的位置，它可以是绝对位置或相对位置。这些操作以跨平台的方式执行。\n\n例如，可以使用 Path 类的一些方法来检查文件路径是否有扩展名（HasExtension），检查文件路径是否为根路径（IsPathRooted），获取临时文件的完整路径（GetFullPath），获取临时文件的位置（GetTempPath）以及获取可用于使用的临时文件名（GetTempFileName）。\n\n此外，还可以使用 Combine 方法将多个路径组合在一起。\n\n```c#\nusing System;\nusing System.Collections;\nusing System.IO;\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string str = @\"D:\\Documents\\hurriedlu\\资源\\hurr.wav\";// @的意思是忽略后续字符串中的转义字符，当作普通字符进行处理\n            // 获取路径中的文件名：\n            // 传统做法：\n            int index = str.LastIndexOf(\"\\\\\");//找到最后一个斜杠的位置\n            string name = str.Substring(index + 1);// 从最后一个斜杠的下一个位置开始截取，截取剩下全部的字符\n            Console.WriteLine(name);\n\n            // 使用Path类实现\n            //获取文件的名字。\n            Console.WriteLine(Path.GetFileName(str));//hurr.wav\n            //只获取文件名而不获取扩展名。\n            Console.WriteLine(Path.GetFileNameWithoutExtension(str));//hurr\n            //只获取扩展名(包括点)。\n            Console.WriteLine(Path.GetExtension(str));//.wav\n            //获取文件所在的文件夹的地址(文件夹的绝对地址)\n            Console.WriteLine(Path.GetDirectoryName(str));//D:\\Documents\\hurriedlu\\资源\n            //组合路径\n            //注意，如果组合时当前分块没有扩展名，则会自动添加/。例如：将文件名和扩展名组合在一起：hurr\\.wav\n            Console.WriteLine(Path.Combine(Path.GetFileNameWithoutExtension(str), Path.GetExtension(str)));\n            //组合可以不止两个，但依然存在上面的问题 例如：D:\\Documents\\hurriedlu\\资源\\hurr\\.wav\n            Console.WriteLine(Path.Combine(Path.GetDirectoryName(str), Path.GetFileNameWithoutExtension(str), Path.GetExtension(str)));\n            //组合文件夹和文件名\n            Console.WriteLine(Path.Combine(Path.GetDirectoryName(str), Path.GetFileName(str)));\n\n\n            //获取完整的路径（绝对地址）。\n            Console.WriteLine(Path.GetFullPath(str));\n            //检查提供的路径是否含有扩展名（返回类型bool）\n            Console.WriteLine(Path.HasExtension(str));\n            //检查是否是根路径\n            Console.WriteLine(Path.IsPathRooted(str));\n\n            //获取临时文件位置\n            string temp = Path.GetTempPath();\n            Console.WriteLine(temp);\n\n            //创建临时文件\n            temp = Path.GetTempFileName();\n            Console.WriteLine(temp);\n            /*\n             * GetTempFileName 方法用于在磁盘上创建一个唯一命名的零字节临时文件，并返回该文件的完整路径。\n             * 该临时文件将在用户的临时文件夹内创建，该路径是由 GetTempPath 方法返回的路径。\n             * 需要注意的是，如果在不删除先前的临时文件的情况下使用此方法创建超过 65535 个文件，\n             * GetTempFileName 方法将引发 IOException。\n             * 如果没有可用的唯一临时文件名，GetTempFileName 方法也会引发 IOException。\n             * 要解决此错误，请删除所有不需要的临时文件。\n            */\n        }\n    }\n}\n```\n\n### File类\n\nFile 类是 C# 中的一个`静态类`，它属于 `System.IO` 命名空间和 `System.Runtime.dll` 程序集。这个类提供了用于创建、复制、删除、移动和打开单个文件的静态方法，并帮助创建 `FileStream` 对象。\n\n可以使用 File 类执行诸如复制、移动、重命名、创建、打开、删除和追加到单个文件的典型操作。还可以使用 File 类获取和设置与文件创建、访问和写入相关的文件属性或 DateTime 信息。\n\n例如，可以使用 Exists 方法检查文件是否存在，使用 Copy 方法复制文件，使用 Create 方法创建或覆盖文件，使用 Delete 方法删除文件，使用 ReadAllText 方法读取文件内容，使用 WriteAllText 方法创建新文件并将内容写入其中（如果文件已存在，则将其覆盖）。\n\n#### 常用方法\n\n##### 判断文件是否存在：Exists\n\n```c#\nif (File.Exists(@\"D:\\tmp\\tmp.txt\"))\n{\n    Console.WriteLine(\"已存在\");\n}\nelse\n{\n    Console.WriteLine(\"不存在\");\n}\n\n```\n\n\n\n##### 创建文件：Create\n\n```c#\nFile.Create(@\"D:\\tmp\\tmp.txt\");\n```\n\n​\t使用File创建一个文件。注意，只能创建文件，而不能创建目录。如果目录不存在，则会抛出异常。\n​\t当使用File创建文件的时候，如果重复执行（已存在要创建的文件），则会对要创建的文件进行修改，而不是删除再创建。\n\n\n\n##### 剪切（移动）一个文件：Move\n\n```c#\nFile.Move(@\"D:\\tmp\\tmp1.txt\", @\"D:\\tmp\\1\\tmp.txt\");\n```\n\n同时在移动的过程中允许对移动的文件进行重命名操作。\n\n\n\n##### 复制一个文件：Copy\n\n```c#\nFile.Copy(@\"D:\\tmp\\tmp.txt\", @\"D:\\tmp\\tmp1.txt\");\n```\n\n如果目标文件（tmp1）已存在，则会抛出异常\n\n\n\n##### 删除一个文件：Delete\n\n```c#\nFile.Delete(@\"D:\\tmp\\tmp.txt\");\n```\n\n注意，使用File删除文件的时候，是直接删除一个文件，而非移动到回收站\n\n```c#\nusing System;\nusing System.Collections;\nusing System.IO;\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            //使用File创建一个文件。注意，只能创建文件，而不能创建目录。如果目录不存在，则会抛出异常。\n            //当使用File创建文件的时候，如果重复执行（已存在要创建的文件），则会对要创建的文件进行修改，而不是删除再创建。\n            //File.Create(@\"D:\\tmp\\tmp.txt\");\n\n            // 删除一个指定的文件\n            // 直接删除一个文件，不经过回收站\n            //File.Delete(@\"D:\\tmp\\tmp.txt\");\n\n            //复制一个文件\n            //如果目标文件（tmp1）已存在，则会抛出异常\n            //File.Copy(@\"D:\\tmp\\tmp.txt\", @\"D:\\tmp\\tmp1.txt\");\n\n            // 移动一个文件\n            // 同时在移动的过程中允许对移动的文件进行重命名操作。\n            //File.Move(@\"D:\\tmp\\tmp1.txt\", @\"D:\\tmp\\1\\tmp.txt\");\n\n            // 判断文件是否存在\n            //if (File.Exists(@\"D:\\tmp\\tmp.txt\"))\n            //{\n            //    Console.WriteLine(\"已存在\");\n            //}\n            //else\n            //{\n            //    Console.WriteLine(\"不存在\");\n            //}\n        }\n    }\n}\n```\n\n\n\n\n\n#### 使用File读写数据\n\n一般来说，只是用File操作小文件。\n\n对于ReadAllBytes来说可以读取非文本文件，但对于其他方法来说，只能读取文本文件。\n\n\n\n```c#\nusing System;\nusing System.Collections;\nusing System.IO;\nusing System.Text;\n\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            //逐行读取文本，并将每一行的文本信息转换成一个string对象存入string数组中\n            // 参数二可以缺省，如果缺省则使用默认的编码格式进行解码。也可以指定解码方式\n            string[] str = File.ReadAllLines(@\"D:\\tmp\\tmp.txt\",Encoding.UTF8);\n            foreach (string item in str)\n            {\n                Console.WriteLine(item);\n            }\n\n            //直接读取所有的文本，存入一个string类型的变量中后返回\n            //同上方的逐行读取一样，也可以指定解码编码\n            //会将所有的字符（包括回车）存入string字符串中返回。\n            string s = File.ReadAllText(@\"D:\\tmp\\tmp.txt\", Encoding.UTF8);\n            Console.WriteLine(s);\n\n            //以字节的形式去读取一个文件，将每个字节的二进制编码直接汇集成数组返回。\n            //输出的时候需要将字节数组转换为字符串\n            byte[] buffer = File.ReadAllBytes(@\"D:\\tmp\\tmp.txt\");\n            string strbuf = Encoding.UTF8.GetString(buffer);\n            strbuf = Encoding.GetEncoding(\"UTF-8\").GetString(buffer);//也可以这么写。但需要注意，如果编码输入错误，会直接抛异常！！！\n            Console.WriteLine(strbuf);\n        }\n    }\n}\n```\n\n#### 使用File写数据\n\n注意，使用file写数据会使得原先的所有文本信息丢失。\n\n使用方法和读数据类似\n\n```c#\nusing System;\nusing System.Collections;\nusing System.IO;\nusing System.Text;\n\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            //使用WriteAllBytes逐字节写入到指定文件中\n            //注意！！！会从文件头开始写，导致先前的所有文本都丢失\n            //string str = \"张三李四王五\";\n            //byte[] buffer = Encoding.UTF8.GetBytes(str);//将字符串变成字节数组\n            //File.WriteAllBytes(@\"D:\\tmp\\tmp.txt\", buffer);//将转换完成的字节数组写入到指定的文件中\n\n            //以行的形式写入到指定的文本文件中\n            //也是从文件头开始写\n            //File.WriteAllLines(@\"D:\\tmp\\tmp.txt\", new string[] {\"tmp\", \"test\"});\n\n            //以字符串的形式写入到指定的文本文件中去\n            //依然复写\n            //File.WriteAllText(@\"D:\\tmp\\tmp.txt\", \"副本\");\n        }\n    }\n}\n\n```\n\n#### 使用file追加数据\n\n```c#\nusing System;\nusing System.Collections;\nusing System.IO;\nusing System.Text;\n\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            //向指定的文本文件追加n行文本\n            //从源文件末尾开始追加，保留原有文本\n            //File.AppendAllLines(@\"D:\\tmp\\tmp.txt\", new string[] { \"hurr\", \"visual\" });\n\n            //向指定的文本文件追加指定字符串\n            //保留原有文本，支持转义字符\n            //File.AppendAllText(@\"D:\\tmp\\tmp.txt\", \"\\n测试\");\n\n        }\n    }\n}\n\n```\n\n注意，追加数据的话，只能追加文本文件，File并没有能追加二进制数据的能力。\n\n#### 注意事项\n\n使用File只适合读取小文件，对于大文件不适用。因为File的读写是一次性完成的，容易爆内存\n\n### FileInfo类\n\n可以看作非静态的File类。\n\nFileInfo 类是 C# 中的一个类，它属于 System.IO 命名空间和 System.Runtime.dll 程序集。这个类提供了用于创建、复制、删除、移动和打开文件的属性和实例方法，并帮助创建 FileStream 对象。\n\nFileInfo 类提供了许多用于操作文件的实例方法。与静态 File 类不同，FileInfo 类允许您在同一文件上执行多个操作，而不需要每次都进行安全检查。\n\n下面是一些常用的 FileInfo 类方法（与File类似）：\n\n- `AppendText`：创建一个 StreamWriter，它将文本追加到由此 FileInfo 实例表示的文件中。\n- `CopyTo`：将现有文件复制到新文件，不允许覆盖现有文件。\n- `Create`：创建文件。\n- `CreateText`：创建一个 StreamWriter，它写入新文本文件。\n- `Decrypt`：解密由当前帐户使用 Encrypt 方法加密的文件。\n- `Delete`：删除指定的文件。\n- `Encrypt`：加密文件，以便只有加密该文件的帐户才能解密它。\n- `GetAccessControl`：获取封装指定文件的访问控制列表 (ACL) 条目的 FileSecurity 对象。\n- `MoveTo`：将指定的文件移动到新位置，提供指定新文件名的选项。\n- `Open`：以指定的 FileMode 打开文件。\n- `OpenRead`：创建一个只读 FileStream。\n- `OpenText`：创建一个使用 UTF8 编码从现有文本文件读取的 StreamReader。\n- `OpenWrite`：创建一个只写 FileStream。\n- `Replace`：使用当前 FileInfo 对象描述的文件替换指定文件的内容，删除原始文件，并创建被替换文件的备份。\n\n#### FileInfo的专用属性：\n\n- Director\n  - 检索一个DirectorInfo对象，表示包括当前文件的目录。这个属性是只读的。\n- DirectorName\n  - 返回文件目录的路径，这个属性也是只读的。\n- IsReadOnly\n  - 文件只读的快捷方式，也可以通过Attributes来访问这个属性。\n- Length\n  - 获取文件的大小（以字节为单位），返回long值，这个属性是只读的。\n\n### Directory类\n\nDirectory 类是 C# 中的一个静态类，它属于 Sys`t`em.IO 命名空间和 `System.Runtime.dll` 程序集。这个类提供了用于创建、复制、移动和删除目录和子目录的静态方法。\n\n可以使用 Directory 类执行诸如复制、移动、重命名、创建和删除目录的典型操作。要创建目录，可以使用 CreateDirectory 方法。要删除目录，可以使用 Delete 方法。要获取或设置应用程序的当前目录，可以使用 GetCurrentDirectory 或 SetCurrentDirectory 方法。使用 Exists 方法检查目录是否存在，使用 CreateDirectory 方法创建目录，使用 Move 方法移动目录，使用 GetDirectories 方法获取目录中的所有子目录。\n\nDirectory 类提供了许多用于操作目录和子目录的静态方法。下面是一些常用的 Directory 类方法：\n\n- `CreateDirectory`：创建目录。\n- `Delete`：删除目录。\n  - 使用这个方法的时候，需要注意catch一下。当要删除的目录为非空目录时，需要指定第二个参数为true。\n  - 并且默认只删除最后的以后的一个文件夹\n- `Exists`：检查目录是否存在。\n- `GetDirectories`：返回指定目录中的所有子目录的string对象数组。\n- `GetFiles`：返回指定目录中的所有文件名称的string对象数组。\n- `GetFileSystemEntries`：返回指定目录中的所有文件和子目录的string数组\n- `Move`：移动目录。\n- `EnumerateDirectories`：枚举目录中的所有子目录。\n- `EnumerateFiles`：枚举目录中的所有文件。\n- `EnumerateFileSystemEntries`：枚举目录中的所有文件和子目录。\n\n注意：Enum和Get的功能类似，只是返回类型由string数组变成`IEnumerable<string>`的集合。\n\n当存在大量文件和目录的时候，EnumerateXXX方法要好于Get XXX方法。\n\n\n\n其余不常用的方法\n\n- `GetCreationTime`：获取目录的创建时间。\n- `GetCreationTimeUtc`：获取目录的 UTC 创建时间。\n- `GetCurrentDirectory`：获取应用程序的当前工作目录。\n- `GetDirectories`：获取目录中的所有子目录。\n- `GetDirectoryRoot`：获取指定路径的根目录信息。\n- `GetLastAccessTime`：获取目录上次访问时间。\n- `GetLastAccessTimeUtc`：获取目录上次 UTC 访问时间。\n- `GetLastWriteTime`：获取目录上次写入时间。\n- `GetLastWriteTimeUtc`：获取目录上次 UTC 写入时间。\n- `GetLogicalDrives`：检索计算机上逻辑驱动器名称的字符串数组。\n- `SetCreationTime`：设置目录的创建时间。\n- `SetCreationTimeUtc`：设置目录的 UTC 创建时间。\n- `SetCurrentDirectory`：设置应用程序的当前工作目录。\n- `SetLastAccessTime`：设置目录上次访问时间。\n- `SetLastAccessTimeUtc`：设置目录上次 UTC 访问时间。\n- `SetLastWriteTime`：设置目录上次写入时间。\n- `SetLastWriteTimeUtc`：设置目录上次 UTC 写入时间。\n\n\n\n\n\n### DirectorInfo类\n\nDirectoryInfo类的作用类似于FileInfo类。它是一个实例化的对象，表示计算机上的单一目录。与FileInfo类一样，在Directory和DirectoryInfo之间存在许多类似的方法调用。选择使用File 或FileInfo方法的规则也适用于DirectoryInfo方法: \n\n- 如果执行单一调用，就使用静态Directory类。\n- 如果执行一系列调用，则使用实例化的DirectoryInfo对象。\n\nDirectoryInfo类的大多数属性继承自FileSystemInfo， 与FileInfo 类一样， 但这些属性作用于目录上，而不是文件上。还有两个DirectoryInfo专用属性。\n\n- Parent\n  - 检索一个DirectorInfo对象，表示包含当前目录的目录。这个属性是只读的。\n- Root\n  - 检索一个DirectorInfo对象，表示包含当前目录的根目录，例如C:\\。这个属性是只读的。\n\n\n\n## 文件流\n\n### FileStream\n\nFileStream是C#中用于读写文件的类，它属于System.IO命名空间。要使用FileStream操作文件，您需要创建一个FileStream类的对象。这个对象有四个参数：文件名、FileMode、FileAccess和FileShare。它为文件操作提供了一个流，可以执行同步和异步的读写操作。\n\n当您创建一个FileStream类的对象时，需要提供四个参数：文件名、FileMode、FileAccess和FileShare。\n\n- 文件名（FileName）：指定要打开或创建的文件的名称。\n- FileMode：指定操作文件时所使用的模式。它是一个枚举类型，包括以下几种值：Append（在文件末尾追加内容）、Create（创建新文件，如果文件已存在则覆盖）、CreateNew（创建新文件，如果文件已存在则引发异常）、Open（打开现有文件）、OpenOrCreate（打开现有文件，如果文件不存在则创建新文件）和Truncate（打开现有文件并截断为零字节）。\n- FileAccess：指定对文件的访问权限。它是一个枚举类型，包括以下几种值：Read（读取权限）、ReadWrite（读写权限）和Write（写入权限）。\n- FileShare：指定文件的共享级别。它是一个枚举类型，包括以下几种值：None（拒绝共享）、Read（允许随后打开该文件进行读取）、ReadWrite（允许随后打开该文件进行读取或写入）、Write（允许随后打开该文件进行写入）和Delete（允许随后删除该文件）。\n\n\n\n#### using框架\n\n将创建文件流对象的过程写在using框架中，会自动挡释放占用的资源\n\n- 创建流的过程写在小括号中\n- 创建、写入的过程写在大括号中\n\n```c#\nusing ()\n{\n\n}\n```\n\n\n\n#### 使用FileStream读取文件\n\n##### 样例1\n\n```c#\nusing System;\nusing System.Collections;\nusing System.IO;\nusing System.Text;\n\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // 使用文件流打开一个文件\n            // 常用的一个重载是第一个参数是路径，第二个参数是打开方式\n            // 其中第二个参数是一个枚举类型的参数。可以选择打开、创建、追加等方式打开文件\n            // 这里选的枚举值是打开或创建。对于单独打开来说，如果文件不存在就会跑异常，对于打开或创建来说，如果不存在就创建一个，然后再打开\n            // 第三个参数的意思是对文件进行什么操作。是读、写还是又读又写\n            FileStream fsReader = new FileStream(@\"D:\\tmp\\tmp.txt\", FileMode.OpenOrCreate, FileAccess.Read);\n\n            //创建一个5兆的buffer\n            byte[] buffer = new byte[1024 * 1024 * 5];\n\n            //读取数据，一次只读5兆的数据\n            //参数依次为：读取到哪个数组、从哪个地方开始读、读多少数据\n            //能少则少，降低内存压力\n            //返回值是实际读到的字节数\n            int len = fsReader.Read(buffer, 0, buffer.Length);\n            \n            // 将读到的字节按照指定的编码格式解码成字符串\n            //最好限制一下解码长度。可能版本更新了修复了？？\n            string str = Encoding.UTF8.GetString(buffer, 0, len);\n\n            Console.WriteLine(str);\n            Console.WriteLine($\"读到了{len }个字节\");\n            \n            //使用完毕后一定要关闭流\n            //文件流是少数的几个垃圾回收机制gc回收不了的东西\n            fsReader.Close();//关闭流\n            fsReader.Dispose();//释放资源\n        }\n    }\n}\n```\n\n\n\n##### 样例2 使用using框架改造样例1\n\n```c#\nusing System;\nusing System.Collections;\nusing System.IO;\nusing System.Text;\n\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            byte[] buffer = new byte[1024 * 1024 * 5];\n            int len;\n            using (FileStream fsReader = new FileStream(@\"D:\\tmp\\tmp.txt\", FileMode.OpenOrCreate, FileAccess.Read))\n            {                \n                len = fsReader.Read(buffer, 0, buffer.Length);\n            }\n            string str = Encoding.UTF8.GetString(buffer, 0, len);\n            Console.WriteLine(str);\n        }\n    }\n}\n```\n\n\n\n\n\n#### 使用FileStream写入文件\n\n```c#\nusing System;\nusing System.Collections;\nusing System.ComponentModel;\nusing System.IO;\nusing System.Text;\n\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            //5KB的buffer\n            byte[] buffer = new byte[1024 * 1024 * 5];\n            for(int i = 0; i < buffer.Length;i++)\n            {\n                buffer[i] = (byte)((i % 26) + 'a');\n            }\n\n            /*\n             * 对于文件流的写入，只要每次流不断，文件指针就不会断。\n             * 比如下方的例子中的Write方法，第二个值的意思是相对文件指针的位置，\n             * 虽然循环了十次，但写入的起始位置第一次是0，第二次就是50兆+1的位置，\n             * 依次类推。\n             * 虽然wirte的第2、3个参数是int，但不代表不能写入超过int大小的字节数\n             * \n             * 对于覆盖：\n             * 不想file的全部覆盖，filestream的覆盖是只覆盖有的字符。\n             * 比如文件原先是已经存在了的，文件中存在100字节的内容\n             * 现在往里面写50个字节，则只有前50个字节会被覆盖，后50个字节原来是什么还是什么\n             */\n            using (FileStream fsWrite = new FileStream(@\"D:\\tmp\\tmp_using_test.txt\", FileMode.OpenOrCreate, FileAccess.Write))\n            {\n                for (int i = 0; i < 100; i ++)\n                {\n                    fsWrite.Write(buffer, 0, buffer.Length);\n                }\n            }\n        }\n    }\n}\n\n```\n\n\n\n### StreamReader、StreamWriter\n\n常用于操作字符。\n\nusing框架同样适用于这两个。\n\n#### 样例1：使用StreamReader逐行读取文本文件，并将结果在控制台显示出来。\n\n```c#\nusing System;\nusing System.Collections;\nusing System.ComponentModel;\nusing System.IO;\nusing System.Text;\n\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            using (StreamReader sr = new StreamReader(@\"D:\\tmp\\tmp.txt\"))\n            {\n                // 只要文件流没到结束\n                while(!sr.EndOfStream)\n                {\n                    //输出读到的行\n                    Console.WriteLine(sr.ReadLine());\n                }\n            }\n        }\n    }\n}\n\n```\n\n\n\n#### 样例2：使用StreamWriter向文本文件写入数据\n\n```c#\nusing System;\nusing System.Collections;\nusing System.ComponentModel;\nusing System.IO;\nusing System.Text;\n\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            //对于要写入的文件来说，如果文件不存在会自动创建\n            using (StreamWriter sw = new StreamWriter(@\"D:\\tmp\\tmp_StreamWrite_test.txt\"))\n            {\n                //和file一样，全部覆盖\n                //第二个参数可以缺省，缺省则表示使用ANSI编码（当前地区的默认编码）写入\n                sw.Write(\"StreamWrite测试\", Encoding.UTF8);\n            }\n\n            //如果需要追加，则需要在创建流的时候使用第二个参数\n            using (StreamWriter sw = new StreamWriter(@\"D:\\tmp\\tmp_StreamWrite_test.txt\", true))\n            {\n                sw.Write(\"\\n追加测试\", Encoding.UTF8);\n            }\n        }\n    }\n}\n\n```\n\n\n\n## Directory\n\n用于操作文件夹和目录。\n\n可以创建、复制、移动和删除目录和子目录。\n\nDirectory类是静态类，直接调用即可。\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ConsoleApp4\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            //在指定目录下创建一个文件夹\n            //可以依次创建直到指定的目录都可以被访问到\n            //如果指定的目录不存在则不进行操作\n            //Directory.CreateDirectory(@\"D:\\tmp\\tmp\\CreateTheDirectory\");\n\n            // 删除指定的文件夹：\n            // 只能删除空的文件夹。如果文件夹非空，则抛异常\n            // 只会删除指定的文件夹，对于指定文件夹之前的路径不会进行删除\n            //Directory.Delete(@\"D:\\tmp\\tmp\\CreateTheDirectory\");\n            // 如果要删除目标文件夹不是空的，里面含义子目录或者文件，可以使用第二个参数\n            // 将第二个参数的值设置成true后表示全部删除\n            //Directory.Delete(@\"D:\\tmp\\tmp\\CreateTheDirectory\",true);\n\n\n            //移动指定的文件夹\n            // 如果指定的文件夹不存在，则抛出异常\n            // 在移动的时候可以对文件夹进行重命名\n            // 如果文件夹中存在子文件夹或文件，则照样移动\n            //Directory.Move(@\"D:\\tmp\\tmp1\", @\"D:\\tmp\\tmp\\tmpTest\");\n\n            // 获取指定文件夹下的所有文件名\n            // 对所有的文件汇集到string数组中，但不汇集子目录下的文件\n            //string[] FileName = Directory.GetFiles(@\"D:\\tmp\\\");\n            //foreach (string str in FileName)\n            //{\n            //    Console.WriteLine(str);\n            //}\n            // 可以筛选只要符合要求的文件。比如只要MP3文件\n            // 使用第二个参数可以进行搜索匹配，支持通配符\n            //FileName = Directory.GetFiles(@\"D:\\tmp\\\", \"*.mp3\");\n            //foreach (string str in FileName)\n            //{\n            //    Console.WriteLine(str);\n            //}\n\n\n            // 获取指定目录下所有文件夹的路径\n            // 如果指定的文件夹不存在，则抛异常\n            //string[] DirectoryName = Directory.GetDirectories(@\"D:\\tmp1\\\");\n            //foreach(string dir in DirectoryName)\n            //{\n            //    Console.WriteLine(dir);\n            //}\n\n\n            //判断指定的路径是否存在\n            Console.WriteLine(Directory.Exists(@\"D:\\tmp\\\"));\n        }\n    }\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 多线程\n\n## 进程和线程基础知识\n\n### 进程\n\n可以将计算机中每一个运行的程序视为一个进程。而一个进程又是由多个线程组成的。\n\n进程指一个应用程序所运行的操作系统单元，它是操作系统环境中的基本成分、是系统进行资源分配的基本单位。\n\n进程是执行程序的实例。\n当运行一个应用程序后，就生成了一个进程，这个进程拥有自己的独立内存空间。\n每一个进程对应一个活动的程序，当进程激活时，操作系统就将系统的资源包括内存、I/O和CPU等分配给它，使它执行。\n\n- 进程在运行时创建的资源随着进程的终止而死亡。\n- 进程间获得专用数据或内存的唯一途径就是通过协议来共享内存块，这是一种协作策略。\n- 一个进程可以创建多个线程及子进程（启动外部程序）。\n- 一个进程内部的线程可以共享该进程所分配的资源。\n\n由于进程之间的切换非常消耗资源和时间，为了提高操作系统的并发性，提高CPU的利用率，在进程下面又加入了线程的概念。\n线程的创建与撤销、线程之间的切换所占用的资源比进程少很多。\n\n\n\n### 线程\n\n在.Net环境下，是不允许跨线程访问的。\n\n进程可以分为若干个独立执行流（路径），这些执行流被称为线程。\n\n线程是指进程内的一个**执行单元**，也是进程内的可调度实体。\n线程是进程的一个实体，是CPU调度和分配时间的基本单位。\n\n线程基本不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），但是它可与同一进程的其它线程共享进程所拥有的全部资源。\n所以线程间共享内存空间很容易做到，多线程协作也很容易和便捷。\n\n一个线程可以创建和撤销另一个线程，同一个进程中的多个线程间可以并发执行。\n\n线程提供了多任务处理的能力。\n\n\n\n### 线程和进程的区别\n\n- 地址空间：\n\n  - 进程拥有自己独立的内存地址空间；\n\n  - 线程共享进程的地址空间；\n\n    > 换句话说就是进程间彼此是完全隔绝的，同一进程的所有线程共享(堆heap)内存；\n\n- 资源拥有：\n\n  - 进程是资源分配和拥有的单位\n  - 同一进程内的线程共享进程的资源；\n\n- 系统粒度：\n\n  - 进程是分配资源的基本单位\n  - 线程则是系统（处理器）调度的基本单位；\n\n- 执行过程：\n\n  - 每个独立的进程都有一个程序运行的入口、顺序执行序列和程序的出口；\n  - 线程不能独立执行，必须依存于进程中；\n\n- 系统开销：\n\n  创建或撤销进程时，系统都要为之分配或回收资源（如内存空间、IO设备）\n  进程间的切换也要消耗远大于线程切换的开销。\n\n二者均可并发执行。\n\n一个程序至少有一个进程，一个进程至少有一个线程（主线程）。\n主线程以函数地址的形式，如Main或WinMain函数，提供程序的启动点，当主线程终止时，进程也随之终止。\n一个进程中的所有线程都在该进程的虚拟地址空间中，使用该进程的全局变量和系统资源。\n\n\n\n### 并发/并行\n\n在单CPU系统中，系统调度在某一刻只能让一个线程运行，虽然这种调度机制有多种形式（时分/频分），但无论如何，要通过不断切换需要运行的线程，这种运行模式称为并发（Concurrent）。\n\n而在多CPU系统中，可以让两个以上的线程同时运行，这种运行模式称为并行（Parallel）。\n\n\n\n### 同步/异步操作\n\n#### 同步与异步的定义\n\n同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)\n\n- 同步，就是调用某个东西，调用方得等待这个调用返回结果才能继续往后执行。（类似于函数调用？直到执行完成后才能进行下一步操作）\n- 异步，和同步相反 调用方不会立即得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状态来通知调用者，或者通过回掉函数来处理这个调用。\n\n所有的程序最终都会由计算机硬件来执行，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。\n这些无须消耗CPU时间的I/O操作是异步操作的硬件基础。\n硬盘、光驱、网卡、声卡、显卡都具有DMA功能。\n\nDMA（DirectMemory Access）是直接内存访问的意思，它是不经过CPU而直接进行内存数据存储的数据交换模式。\n\nI/O操作包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.Net Remoting等跨进程的调用。\n\n异步操作可达到避免调用线程堵塞的目的，从而提高软件的可响应性。\n\n#### 同步与异步的对比\n\n线程不是一个计算机的硬件功能，而是操作系统提供的一种逻辑功能，线程本质上是进程中一段并发运行的代码，所以线程需要操作系统投入CPU资源来运行和调度。\n\n异步模式无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必共享变量，减少了死锁的可能。\n\n不过，编写异步操作的复杂程度比较高，程序主要使用回调方式进行处理，与人的思维方式有出入，而且难以调试。\n\n计算密集型工作使用多线程（如图形处理、算法）；IO密集型工作使用异步机制。\n\n### 任务管理器\n\n映射名称列：\n\t进程并不拥有独立于其所属实例的映射名称；\n\n> 如果运行5个Notepad拷贝，你会看到5个称为Notepad.exe的进程；\n\n它们是根据进程ID进行区分的，该进程ID是由系统维护，并可以循环使用。\n\nCPU列：\n它是进程中线程所占用的CPU时间百分比\n\n每个任务管理器中的进程，其实内部都包含若干个线程，每个时间点都是某个程序进程中的某个线程在运行。\n\n### 线程是如何工作的\n\n线程被一个线程协调程序管理着——一个CLR委托给操作系统的函数。\n线程协调程序确保将所有活动的线程被分配适当的执行时间；\n并且那些等待或阻止的线程——比如说在排它锁中、或在用户输入——都是不消耗CPU时间的。\n\n在单核处理器的电脑中，线程协调程序完成一个时间片之后迅速地在活动的线程之间进行切换执行。\n这就导致“波涛汹涌”的行为，例如在第一个例子，每次重复的X 或 Y 块相当于分给线程的时间片。\n在Windows XP中时间片通常在10毫秒内选择要比CPU开销在处理线程切换的时候的消耗大的多。(即通常在几微秒区间)\n\n在多核的电脑中，多线程被实现成混合时间片和真实的并发——不同的线程在不同的CPU上运行。\n但这仍然会出现一些时间切片,因为操作系统的服务线程、以及一些其他的应用程序都会争夺对CPU的使用权。\n\n线程由于外部因素（比如时间片）被中断被称为被抢占，在大多数情况下,一个线程在被抢占的那一刻就失去了对它的控制权。\n\n### 线程安全\n\n当使用线程（Thread）时，必须注意同步处理的问题\n\n理论上每个Thread都是独立运行的个体，由CLR来主导排程，视Thread的优先权的设置，每个Thread会分到特定的运行时间，当某个Thread的运行时间用完时，CLR就会强制将运行权由该Thread取回，转交给下个Thread\n\n这也就意味着Thread本身无法得知自己何时会丧失运行权，所以会发生所谓的race condition（竞速状态）。\n\n当两个线程争夺一个锁的时候（在这个例子里是locker），一个线程等待，或者说被阻止到那个锁变的可用。\n在这种情况下，就确保了在同一时刻只有一个线程能进入临界区，所以”Done”只被打印了1次。代码以如此方式在不确定的多线程环境中被叫做线程安全。\n\n临时暂停，或阻止是多线程的协同工作，同步活动的本质特征。\n等待一个排它锁被释放是一个线程被阻止的原因，另一个原因是线程想要暂停或Sleep一段时间：\n\nThread.Sleep (TimeSpan.FromSeconds (30)); // 阻止30秒\n\n一个线程也可以使用它的Join方法来等待另一个线程结束：\n\nThreadt = new Thread(Go); // 假设Go是某个静态方法\n\nt.Start();\n\nt.Join(); // 等待（阻止）直到线程t结束\n\n##  使用多线程的情况分析\n\n### 2.1 为什么要使用多线程\n\n- 并发需要\n  在C/S或B/S模式下的服务端需要处理来自不同终端的并发请求，使用单线程是不可思议的。\n- 提高应用程序的响应速度\n  当一个耗时的操作进行时，当前程序都会等待这个操作结束\n  此时程序不会响应键盘、鼠标、菜单等操作，程序处于假死状态；\n  使用多线程可将耗时长的操作（Time Consuming）置于一个新的线程，此时程序仍能响应用户的其它操作\n- 提高CPU利用率\n  在多CPU体系中，操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。\n- 改善程序结构\n  一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分\n  这样的程序会利于理解和修改。\n- 花销小、切换快\n  线程间的切换时间很小，可以忽略不计\n- 方便的通信机制\n  线程间共享内存，互相间交换数据很简单。\n\n多线程的意义在于\n一个应用程序中，有多个执行部分可以同时执行：\n一个线程可以在后台读取数据，而另一个线程可以在前台展现已读取的数据。\n\nC#支持通过多线程并行地执行代码，一个线程有它独立的执行路径，能够与其它的线程同时地运行。\n一个C#程序开始于一个单线程，这个单线程是被CLR和操作系统（也称为“主线程”）自动创建的，并具有多线程创建额外的线程。\n\n#### 何时使用多线程\n\n多线程程序一般被用来在后台执行耗时的任务：主线程保持运行，而工作线程执行后台工作。\n\n- 对于Windows Forms程序来说，如果主线程执行了一个冗长的操作，键盘和鼠标的操作会变的迟钝，程序也会失去响应，进入假死的状态，可能导致用户强制结束程序进程而出现错误。\n  有鉴于此，应该在主线程运行一个耗时任务时另外添加一个工作线程，同时在主线程上有一个友好的提示“处理中…”，允许继续接收事件（比如响应鼠标、键盘操作）。\n  同时程序还应该实现“取消”功能，允许取消/结束当前工作线程。\n  BackgroundWorker类就提供这一功能。\n- 在没有用户界面的程序里，比如说WindowsService中使用多线程特别的有意义。\n  当一个任务有潜在的耗时（在等待被请求方的响应——比如应用服务器，数据库服务器），用工作线程完成任务意味着主线程可以在发送请求后立即做其它的事情。\n- 另一个多线程的用途是在需要完成一个复杂的计算工作时,它会在多核的电脑上运行得更快，如果工作量被多个线程分开的话（C#中可使用Environment.ProcessorCount属性来侦测处理芯片的数量）。\n\n远程服务器，或WebServices或ASP.NET程序将别无选择，必须使用多线程；\n\n一个单线程的ASP.NET Web Service是不可想象的；\n\n幸运的是，应用服务器中多线程是相当普遍的；\n\n唯一值得关心的是提供适当锁机制的静态变量问题。\n\n### 何时不用多线程\n\n多线程也同样会带来缺点，最大的问题是它使程序变的过于复杂。\n拥有多线程本身并不复杂，复杂是的线程的交互作用。\n无论交互是否是有意的，都会带来较长的开发周期，以及带来间歇性和非重复性的Bugs。\n因此，要么多线程的交互设计简单一些，要么就根本不使用多线程，除非你有强烈的重写和调试欲望。\n\n当用户频繁地分配和切换线程时，多线程会带来增加资源和CPU的开销。\n在某些情况下，太多的I/O操作是非常棘手的，当只有一个或两个工作线程要比有众多的线程在相同时间执行任务快的多。\n\n##  C#中的线程\n\n### 程序域\n\n在.Net中Process由AppDomain对象所取代。\n\n虽然AppDomain在CLR中被视为Process的替代品，但实际上AppDomain跟Process是属于主从关系的，AppDomain被放置在一个Process中，\n每个Process可以拥有多个AppDomain，\n每个AppDomain又可拥有多个Thread对象。\n\nProcess、AppDomain、Thread的关系如下图所示：\n\n![image-20230515195414250](./Image/C#学习笔记_基础教程.assets/image-20230515195414250.png)\n\nAppDomain定义了一些事件供程序员使用。\n\n| 事件         | 说明                                                         |\n| ------------ | ------------------------------------------------------------ |\n| AssemblyLoad | 触发于AppDomain载入一个Assembly时                            |\n| DomainUnLoad | 触发于AppDomain卸载时，也就是Unload函数被调用或是该AppDomain被消灭前 |\n| ProcessExit  | 当默认的AppDomain被卸载时触发，多半是应用程序退出时          |\n\n各AppDomain间互不影响。\n\n### C#中实现线程的方法\n\n一个C#程序成为多线程可以通过2种方式来实现：\n\n- 明确地创建和运行多线程\n- 使用.NET Framework中封装了多线程的类\n  比如:\n  - BackgroundWorker类\n  - 线程池\n  - Threading Timer\n\n\n\n\n\n## Thread类\n\n### 概述\n\n- 使用Thread类通过ThreadStart（无参数）或ParameterizedThreadStart（一个输入参数）类型的委托创建一个Thread对象，开启一个新线程，执行该委托传递的任务，此时线程尚未处于运行状态。\n- 调用Start()函数启动线程，当前线程继续执行。\n- 调用Join()函数可以阻塞当前线程，直到调用Join()的线程终止。\n- 调用Abort()方法，如需中止线程，在调用该方法的线程上抛出ThreadAbortException异常，以结束该线程\n- 可以通过Thread.ResetAbort()方法阻止线程的中止。\n\n\n\n### 属性表\n\n\n\n| 属性          | 说明                                         |\n| ------------- | -------------------------------------------- |\n| Name          | 属性，获取或设置线程的名称                   |\n| Priority      | 属性，获取或设置线程的优先级                 |\n| ThreadState   | 属性，获取线程当前的状态                     |\n| IsAlive       | 属性，获取当前线程是否处于启动状态           |\n| IsBackground  | 属性，获取或设置值，表示该线程是否为后台线程 |\n| CurrentThread | 属性，获取当前正在运行的线程                 |\n\n### 方法表\n\n| 方法                          | 说明                                     |\n| ----------------------------- | ---------------------------------------- |\n| Start()                       | 方法，启动线程                           |\n| Sleep(int millisecondsTimout) | 方法，将当前线程暂停指定的毫秒数         |\n| Suspend()                     | 方法，挂起当前线程（已经被弃用）         |\n| Join()                        | 方法，阻塞调用线程，直到某个线程终止为止 |\n| Interrupt()                   | 方法，中断当前线程                       |\n| Resume()                      | 方法，继续已经挂起的线程（已经被弃用）   |\n| Abort()                       | 方法，终止线程（已经被弃用）             |\n\n###  开启线程\n\n首先用new申请Thread对象，然后对象调用Start()方法启用线程。\n\n```c#\nclass Program\n{\n    static void DownLoad()\n    {\n        Console.WriteLine(\"DownLoad Begin \" + Thread.CurrentThread.ManagedThreadId);\n        Thread.Sleep(1000);\n        Console.WriteLine(\"DownLoad End\");\n    }\n    static void Main(string[] args)\n    {\n        //创建Thread对象\n        Thread thread = new Thread(DownLoad);\n        //启动线程\n        thread.Start();\n        Console.WriteLine(\"Main\");\n        Console.ReadKey();\n    }\n}\n```\n\n> Thread.CurrentThread.ManagedThreadId获取当前线程的ID，便于管理。\n\n用Lambda表达式代替函数调用，也能达到相同的效果\n\n```c#\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Thread thread = new Thread(() =>\n        {\n            Console.WriteLine(\"DownLoad Begin \" + Thread.CurrentThread.ManagedThreadId);\n            Thread.Sleep(1000);\n            Console.WriteLine(\"DownLoad End\");\n        });\n        thread.Start();\n        Console.WriteLine(\"Main\");\n        Console.ReadKey();\n    }\n}\n```\n\n### 传递参数\n\n有两种为线程传递参数的方法：\n\n- Start()函数传参法\n- 对象成员方法传参法\n- 匿名方法传参法\n\n####  Start()函数传参\n\n为某方法创建新线程后，在使用Start()方法启动线程时传递该方法需要的参数。\n\n```c#\nclass Program\n{\n    static void DownLoad(object name)\n    {\n        Console.WriteLine(\"DownLoad Begin \" + name);\n        Thread.Sleep(1000);\n        Console.WriteLine(\"DownLoad End\");\n    }\n    static void Main(string[] args)\n    {\n        //创建Thread对象\n        Thread thread = new Thread(DownLoad);\n        //启动线程\n        thread.Start(\"April\");\n        Console.WriteLine(\"Main\");\n        Console.ReadKey();\n    }\n}\n```\n\n#### 对象传递\n\n初始化一个对象，然后用对象的方法初始化Thread，这样该线程就可以使用这个对象的所有成员。\n\n```c#\nclass Program\n{\n    public class Download\n    {\n        private int Id;\n        private string Name;\n        public Download(int id, string name)\n        {\n            Id = id;\n            Name = name;\n        }\n        public void DownloadFile()\n        {\n            Console.WriteLine(\"DownLoad Begin \" + \"ID: \" + Id + \" Name: \" + Name);\n            Thread.Sleep(1000);\n            Console.WriteLine(\"DownLoad End\");              \n        }\n    }\n    static void Main(string[] args)\n    {\n        Download download = new Download(1, \"人民日报\");\n        Thread thread = new Thread(download.DownloadFile);\n        thread.Start();\n        Console.WriteLine(\"Main\");\n        Console.ReadKey();\n    }\n}\n```\n\n#### 匿名方法\n\n需要接收多个参数的解决方案是使用一个匿名方法调用，方法如下\n\n```c#\nclass Program\n{\n    static void Main()\n    {\n        Thread t = new Thread(delegate() { WriteText(\"Hello\"); });\n        t.Start();\n    }\n\n    static void WriteText(string text)\n    { \n        Console.WriteLine(text); \n    }\n}\n```\n\n它的优点是目标方法（这里是WriteText），可以接收任意数量的参数，并且没有装箱操作。\n\n不过这需要将一个外部变量放入到匿名方法中，如下示例：\n\n```c#\nclass Program\n{\n    static void Main()\n    {\n        string text = \"Before\";\n\n        Thread t = new Thread(delegate () { WriteText(text); });\n\n        text = \"After\";\n\n        t.Start();\n\n    }\n\n    static void WriteText(string text) \n    { \n        Console.WriteLine(text); \n    }\n}\n\n```\n\n需要注意的是:\n当外部变量的值被修改，匿名方法可能进行无意的互动，导致一些古怪的现象。\n一旦线程开始运行，外部变量最好被处理成只读的。除非有人愿意使用适当的锁。\n\n### 线程命名\n\n线程可以通过它的Name属性进行命名，这非常有利于调试：\n\n可以用Console.WriteLine打印出线程的名字\n\nMicrosoft Visual Studio可以将线程的名字显示在调试工具栏的位置上。\n\n线程的名字可以在被任何时间设置，但只能设置一次，重命名会引发异常。\n\n程序的主线程也可以被命名，下面例子里主线程通过CurrentThread命名：\n\n```c#\nclass ThreadNaming\n{\n    static void Main()\n    {\n        Thread.CurrentThread.Name = \"main\";\n\n        Thread worker = new Thread(Go);\n\n        worker.Name = \"worker\";\n\n        worker.Start();\n\n        Go();\n\n    }\n\n    static void Go()\n    {\n        Console.WriteLine(\"Hello from \" + Thread.CurrentThread.Name);\n    }\n}\n```\n\n输出\n\nHellofrom main\n\nHellofrom worker\n\n### 前台线程和后台线程\n\n- 前台线程(用户界面线程)\n  只要存在有一个前台线程在运行，应用程序就在运行\n  通常用来处理用户的输入并响应各种事件和消息\n- 后台线程(工作线程)\n  应用程序关闭时，如果后台线程没有执行完，会被强制性的关闭\n  用来执行程序的后台处理任务，比如计算、调度、对串口的读写操作等\n\n例如：\n\n```c#\nclass Program\n{\n    static void DownLoad()\n    {\n        Console.WriteLine(\"DownLoad Begin \" + Thread.CurrentThread.ManagedThreadId);\n        Thread.Sleep(1000);\n        Console.WriteLine(\"DownLoad End\");\n    }\n    static void Main(string[] args)\n    {\n        //创建Thread对象\n        Thread thread = new Thread(DownLoad);\n        //设为后台线程\n        thread.IsBackground = true;\n        //启动线程\n        thread.Start();\n        Console.WriteLine(\"Main\");\n    }\n}\n```\n\n在上例中，thread被设置为后台线程。\nMain执行完后，没有前台线程了，应用程序就结束，虽然后台线程thread此时尚未执行完，也被终止。\n\n> 改变线程从前台到后台不会以任何方式改变它在CPU协调程序中的优先级和状态。\n\n\n\n拥有一个后台工作线程是有益的，最直接的理由是当提到结束程序它总是可能有最后的发言权。\n\n交织以不会消亡的前台线程，保证程序的正常退出。\n\n抛弃一个前台工作线程是尤为险恶的，尤其对Windows Forms程序，因为程序直到主线程结束时才退出（至少对用户来说），但是它的进程仍然运行着。\n\n在Windows任务管理器它将从应用程序栏消失不见，但却可以在进程栏找到它。\n\n除非用户找到并结束它，它将继续消耗资源，并可能阻止一个新的实例的运行从开始或影响它的特性。\n\n对于程序失败退出的普遍原因就是存在“被忘记”的前台线程。\n\n| 线程类型 | 动作       | 结束 | 后续处理                  |\n| -------- | ---------- | ---- | ------------------------- |\n| 前台线程 | 主程序关闭 | 否   | 显示关闭线程/杀掉当前进程 |\n| 后台线程 | 主程序关闭 | 是   | 无                        |\n\n### 注意事项\n\n- Thread类创建的线程默认为前台线程，可以通过IsBackground属性设置其为前台或后台线程。\n\n  > 用Thread类创建的线程是前台线程，线程池中的线程总是后台线程\n\n- 可以通过Priority属性设置线程的优先级。\n\n- 线程内部可以通过try catch捕获该异常，在catch模块中进行一些必要的处理\n  如释放持有的锁和文件资源等\n\n- 慎重使用Abort()方法\n  如果在当前线程中抛出该异常，其结果是可预测的\n  但是对于其他线程，它会中断任何正在执行的代码，有可能中断静态对象的生成，造成不可预测的结果。\n\n## 线程池\n\n### 概述\n\nThreadPool类维护一个线程的列表，提供给用户以执行不同的小任务，减少频繁创建线程的开销。\n\n该线程池可用于执行任务、发送工作项、处理异步 I/O、代表其他线程等待以及处理计时器。\n\n线程池其实就是一个存放线程对象的“池子(pool)”，他提供了一些基本方法，如：设置pool中最小/最大线程数量、把要执行的方法排入队列等等。ThreadPool是一个静态类，因此可以直接使用，不用创建对象。\n\n### 线程池的优点\n\n每新建一个线程都需要占用内存空间和其他资源\n而新建了那么多线程，有很多在休眠，或者在等待资源释放；\n又有许多线程只是周期性的做一些小工作，如刷新数据等等，太浪费了，划不来。\n实际编程中大量线程突发，然后在短时间内结束的情况很少见。\n\n于是，就提出了线程池的概念。\n\n线程池中的线程执行完指定的方法后并不会自动消除，而是以挂起状态返回线程池，如果应用程序再次向线程池发出请求，那么处以挂起状态的线程就会被激活并执行任务，而不会创建新线程，这就节约了很多开销。\n\n只有当线程数达到最大线程数量，系统才会自动销毁线程。\n\n因此，使用线程池可以避免大量的创建和销毁的开支，具有更好的性能和稳定性，其次，开发人员把线程交给系统管理，可以集中精力处理其他任务。\n\n### 线程池的使用\n\n- 设置线程池最大最小：\n  `ThreadPool.SetMaxThreads (int workerThreads,int completionPortThreads)`\n  - 设置可以同时处于活动状态的线程池的请求数目。所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。\n    还可以设置最小线程数。\n  - 将任务添加进线程池:\n    `ThreadPool.QueueUserWorkItem(new WaitCallback(方法名));`或`ThreadPool.QueueUserWorkItem(new WaitCallback(方法名), 参数);`\n\n但是线程池的使用也有一些限制：\n\n- 线程池中的线程均为后台线程，并且不能修改为前台线程\n- 不能给入池的线程设置优先级或名称\n- 对于COM对象，入池的所有线程都是多线程单元（MTA）线程，许多COM对象都需要单线程单元（STA） 线程\n- 入池的线程只适合时间较短的任务，如果线程需要长时间运行，应使用Thread类创建线程或使用Task的LongRunning选项\n- .Net下线程池最小默认允许4个工作线程，最大允许2048个工作线程。\n  并发线程启动后，瞬间会启动4个线程。\n  而剩下的会依据环境每0.5秒或者1秒启动一个。\n  如果同时运行的线程达到Max工作线程，那么剩下的就会挂起\n  直到线程池中的线程有空闲得了，才会去执行。\n\n\n\n\n\n## Parallel类\n\n### 概述\n\nParallel和Task类都位于System.Threading.Task命名空间中，是对Thread和ThreadPool类更高级的抽象。\n\nParrallel类有For()、ForEach()、Invoke()三个方法\n\n- Invoke()\n  实现任务并行性\n  允许同时调用不同的方法，\n- Parallel.For()和 Parallel.ForEach()\n  实现数据并行性\n  在每次迭代中调用相同的代码\n\n### 常用方法\n\n#### Parallel.For()\n\nParallel.For()方法类似于 C#的 for循环语旬,也是多次执行一个任务。\n使用Parallel.For()方法,可以并行运行迭代。\n\n迭代的顺序没有定义，不能保证。\n\n在For()方法中：\n\n- 前两个参数定义了循环的开头和结束。示例从0迭代到 9。\n- 第 3个参数是一个Action委托\n  是要并行运行迭代的方法\n- 整数参数是循环的迭代次数,该参数被传递给Action委托引用的方法。\n- Parallel.For()方法的返回类型是ParalleLoopResult结构,它提供了循环是否结束的信息。\n\n案例如下：\n\n```c#\npublic static void Main()\n{\n    ParallelLoopResult result = Parallel.For(0, 10, i =>\n    {\n        Console.WriteLine\n        (\"i:{0}, thread id: {1}\", i, Thread.CurrentThread.ManagedThreadId);\n        Thread.Sleep(10);\n    });\n\n    Console.WriteLine(\"Is completed: {0}\", result.IsCompleted);\n\n    //i: 0, thread id: 9\n    //i: 2, thread id: 10\n    //i: 1, thread id: 9\n    //i: 3, thread id: 10\n    //i: 4, thread id: 9\n    //i: 6, thread id: 11\n    //i: 7, thread id: 10\n    //i: 5, thread id: 9\n    //i: 8, thread id: 12\n    //i: 9, thread id: 11\n    //Is completed: True\n\n    Console.ReadKey();\n}\n```\n\n同For()循环类似，Parallel.For()方法也可以中断循环的执行。\n\nParallel.For()方法的一个重载版本接受第3个Action<int, ParallelLoopState>类型的参数。\n使用这些参数定义一个方法,就可以调用ParalleLoopState的Break()或Stop()方法,以影响循环的结果。\n\n> 注意,迭代的顺序没有定义\n\n案例如下：\n\n```c#\npublic static void Main()\n{\n    ParallelLoopResult result = Parallel.For(0, 100, (i, state) =>\n    {\n        Console.WriteLine(\"i:{0}, thread id: {1}\", i, Thread.CurrentThread.ManagedThreadId);\n\n        if (i > 10)\n            state.Break();\n\n        Thread.Sleep(10);\n    });\n\n    Console.WriteLine(\"Is completed: {0}\", result.IsCompleted);\n    Console.WriteLine(\"Lowest break iteration: {0}\", result.LowestBreakIteration);\n\n    //i: 0, thread id: 10\n    //i: 25, thread id: 6\n    //i: 1, thread id: 10\n    //i: 2, thread id: 10\n    //i: 3, thread id: 10\n    //i: 4, thread id: 10\n    //i: 5, thread id: 10\n    //i: 6, thread id: 10\n    //i: 7, thread id: 10\n    //i: 8, thread id: 10\n    //i: 9, thread id: 10\n    //i: 10, thread id: 10\n    //i: 11, thread id: 10\n    //Is completed: False\n    //Lowest break iteration: 11\n\n    Console.ReadKey();\n}\n```\n\n#### Parallel.For < TLocal >\n\nParallel.For()方法可能使用几个线程来执行循环 。\n\n如果需要对每个线程进行初始化,就可以使用Parallel.For方法。\n除了from和to对应的值之外,For()方法的泛型版本还接受3个委托参数:\n\n- 第一个参数的类型是Func< TLocal >\n  因为这里的例子对于TLocal使用字符串,所以该方法需要定义为Func< string >,即返回string的方法。\n  这个方法仅对于用于执行迭代的每个线程调用一次\n- 第二个委托参数为循环体定义了委托\n  在示例中,该参数的类型是Func<int, ParallelLoopState, string, string>。\n  其中第一个参数是循环迭代,第二个参数 ParallelLoopstate允许停止循环,如前所述 。\n  循环体方法通过第3个参数接收从init方法返回的值,循环体方法还需要返回一个值,其类型是用泛型for参数定义的。\n- For()方法的最后一个参数指定一个委托Action< TLocal >;在该示例中,接收一个字符串。\n  这个方法仅对于每个线程调用一次,这是一个线程退出方法。\n\n案例如下：\n\n```c#\nstatic void Main()\n{\n    Parallel.For<string>(0, 20, () =>\n    {\n        Console.WriteLine(\"init thread {0},\\t task {1}\", Thread.CurrentThread.ManagedThreadId, Task.CurrentId);\n        return string.Format(\"t{0}\", Thread.CurrentThread.ManagedThreadId);\n    },\n    (i, pls, str) =>\n    {\n        Console.WriteLine(\"body i {0} \\t str {1} \\t thread {2} \\t task {3}\", i, str, Thread.CurrentThread.ManagedThreadId, Task.CurrentId);\n        Thread.Sleep(10);\n        return string.Format(\"i \\t{0}\", i);\n    },\n    (str) =>\n    {\n        Console.WriteLine(\"finally\\t {0}\", str);\n    });\n    Console.ReadKey();\n}\n```\n\n**Parallel.For 方法 (Int32, Int32, Func, Func<Int32, ParallelLoopState, TLocal, TLocal>, Action)**\n\n参数表：\n\n| 参数名        | 数据类型                                              | 作用                                           |\n| ------------- | ----------------------------------------------------- | ---------------------------------------------- |\n|               | TLoca                                                 | 线程本地数据的类型                             |\n| fromInclusive | System.Int32                                          | 开始索引（含）                                 |\n| toExclusive   | System.Int32                                          | 结束索引（不含）                               |\n| localInit     | System.Func                                           | 用于返回每个任务的本地数据的初始状态的函数委托 |\n| body          | System.Func<Int32, ParallelLoopState, TLocal, TLocal> | 将为每个迭代调用一次的委托                     |\n| localFinally  | System.Action                                         | 用于对每个任务的本地状态执行一个最终操作的委托 |\n| 返回值        | System.Threading.Tasks.ParallelLoopResult             |                                                |\n\n在迭代范围 (fromInclusive，toExclusive) ，为每个值调用一次body 委托。\n为它提供以下参数：\n\n- 迭代次数 (Int32)\n- 可用来提前退出循环的ParallelLoopState实例\n- 可以在同一线程上执行的迭代之间共享的某些本地状态。\n\n对于参与循环执行的每个任务调用 localInit 委托一次，并返回每个任务的初始本地状态。\n这些初始状态传递给第一个在该任务上 调用的 body。\n然后，每个后续正文调用返回可能修改过的状态值，传递到下一个正文调用。\n最后，每个任务上的最后正文调用返回传递给 localFinally 委托的状态值。\n每个任务调用 localFinally 委托一次，以对每个任务的本地状态执行最终操作。\n此委托可以被多个任务同步调用；\n因此您必须同步对任何共享变量的访问。\n\nParallel.For方法比在它执行生存期的线程可能使用更多任务，作为现有的任务完成并被新任务替换。\n这使基础 TaskScheduler 对象有机会添加、更改或移除服务循环的线程。\n\n如果 fromInclusive 大于或等于 toExclusive，则该方法立即返回，而无需执行任何迭代。\n\n#### Parallel.ForEach()\n\nParallel.ForEach()方法遍历实现了IEnumerable的集合,其方式类似于foreach语句,但以异步方式遍历。\n这里也没有确定遍历顺序。\n\n```c#\nstatic void Main()\n{\n    string[] data = { \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\" };\n    ParallelLoopResult result = Parallel.ForEach<string>(data, (s) =>\n    {\n        Console.WriteLine(s);\n    });\n    Console.ReadKey();\n}\n```\n\n中断循环\n如果需要中断循环,就可以使用ForEach()方法的重载版本和ParallelLoopState参数。其方式与前面的For()方法相同。\nForEach()方法的一个重载版本也可以用于访问索引器,从而获得迭代次数\n如下所示:　\n\n```c#\nstatic void Main()\n{\n    string[] data = { \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\" };\n    ParallelLoopResult result = Parallel.ForEach<string>(data, (s, pls, l) =>\n    {\n        Console.WriteLine(\"{0}\\t{1}\", s, l);\n        if (l > 10)\n        {\n            pls.Break();\n        }\n    });\n    Console.WriteLine(\"Lowest break iteration: {0}\", result.LowestBreakIteration);\n    Console.ReadKey();\n}\n```\n\n### 4.2.4 Parallel.Invoke()\n\n如果多个任务应并行运行,就可以使用Parallel.Invoke()方法。\nParallel.Invoke()方法允许传递一个Action委托数组,在其中可以指定应运行的方法。\n示例代码传递了要并行调用的Foo()和Bar()方法:\n\n```c#\nstatic void Main(string[] args)\n{\n    Parallel.Invoke(Foo, Bar);\n    Console.ReadKey();\n}\nstatic void Foo()\n{\n    Console.WriteLine(\"Foo\");\n}\n\nstatic void Bar()\n{\n    Console.WriteLine(\"Bar\");\n}\n```\n\n如需同时执行多个不同的任务，可以使用Parallel.Invoke()方法，它允许传递一个Action委托数组。\n\n```c#\npublic static void Main()\n{\n    Parallel.Invoke(Func1, Func2, Func3);\n    Console.ReadKey();\n}\n```\n\n## Task类\n\n### 概述\n\n相比于Thread类，Task类为控制线程提供了更大的灵活性。\n\n- Task类可以获取线程的返回值\n- 可以定义连续的任务：在一个任务结束结束后开启下一个任务\n- 可以在层次结构中安排任务，在父任务中可以创建子任务\n  这样就创建了一种依赖关系，如果父任务被取消，子任务也随之取消\n\n> 注意：\n> Task类默认使用线程池中的线程，如果该任务需长期运行，应使用TaskCreationOptions.LongRunning属性告诉任务管理器创建一个新的线程，而不是使用线程池中的线程。\n\n### 任务Task和线程Thread的区别：\n\n- 任务是架构在线程之上的\n  也就是说任务最终还是要**抛给线程**去执行。\n- **任务跟线程不是一对一的关系**\n  比如开10个任务并不是说会开10个线程，这一点任务有点类似线程池，但是任务相比线程池有很小的开销和精确的控制。\n- Task和Thread一样，位于System.Threading命名空间下!\n\n### Task的生存周期与状态\n\n| 状态            | 说明                                               |\n| --------------- | -------------------------------------------------- |\n| Created         | 表示默认初始化任务，但是“工厂创建的”实例直接跳过。 |\n| WaitingToRun    | 这种状态表示等待任务调度器分配线程给任务执行。     |\n| RanToCompletion | 任务执行完毕。                                     |\n\n```c#\nstatic void Main()\n{\n    //查看Task中的状态\n    var task1 = new Task(() =>\n    {\n        Console.WriteLine(\"Begin\");\n        System.Threading.Thread.Sleep(2000);\n        Console.WriteLine(\"Finish\");\n    });\n    Console.WriteLine(\"Before start:\" + task1.Status);\n    task1.Start();\n    Console.WriteLine(\"After start:\" + task1.Status);\n    task1.Wait();\n    Console.WriteLine(\"After Finish:\" + task1.Status);\n\n    /*\n     * Before start:Created\n     * After start:WaitingToRun\n     * Begin\n     * Finish\n     * After Finish:RanToCompletion\n     */\n}\n```\n\n### Task的使用方法\n\n#### 启动任务\n\n以下程序演示了几种通过Task类启动任务的方式：\n\n- 实例化后手动start()\n\n  ```c#\n  var task1 = new Task(() =>\n  {\n      //TODO you code\n  });\n  task1.Start();\n  ```\n\n- 使用Task工厂对象创建新任务并执行\n\n  ```c#\n  TaskFactory tf = new TaskFactory();\n  Task t1 = tf.StartNew(TaskMethod.DoTask, \"using a task factory\");\n  ```\n\n- 工厂创建，直接执行\n\n  ```c#\n  Task t2 = Task.Factory.StartNew(TaskMethod.DoTask, \"factory via a task\");\n  ```\n\n案例如下：\n\n```c#\npublic class ThreadExample\n{\n    public static void Main()\n    {\n        TaskFactory tf = new TaskFactory();\n        Task t1 = tf.StartNew(TaskMethod.DoTask, \"using a task factory\");\n\n        Task t2 = Task.Factory.StartNew(TaskMethod.DoTask, \"factory via a task\");\n\n        Task t3 = new Task(TaskMethod.DoTask, \"using a task constructor and start\");\n        t3.Start();\n\n        //需要.NetFramework 4.5以上\n        var t4 = Task.Run(() => TaskMethod.DoTask(\"using Run method\"));\n\n        Console.ReadKey();\n    }\n\n    class TaskMethod\n    {\n        static object taskLock = new object();\n        public static void DoTask(object msg)\n        {\n            lock (taskLock)\n            {\n                Console.WriteLine(msg);\n                Console.WriteLine(\"Task id:{0}, Thread id :{1}\",\n                               Task.CurrentId == null ? \"no task\" : Task.CurrentId.ToString(),\n                               Thread.CurrentThread.ManagedThreadId);\n            }\n        }\n    }\n}\n```\n\n#### 任务控制\n\n##### Task.Wait()\n\n就是等待任务执行（task1）完成，task1的状态变为Completed。\n\n##### Task.WaitAll()\n\n等待所有的任务都执行完成：\n例如：\n\n```c#\nTask.WaitAll(task,task2,task3...N)\nConsole.WriteLine(\"All task finished!\");\n```\n\n即当task,task2,task3…N全部任务都执行完成之后才会往下执行代码（打印出：“All task finished!”）\n\n##### Task.WaitAny()\n\n同Task.WaitAll，等待任何一个任务完成就继续向下执行，将上面的代码WaitAll替换为WaitAny\n\n```c#\nTask.WaitAny(task,task2,task3...N)\nConsole.WriteLine(\"Any task finished!\");\n```\n\n即当task,task2,task3…N任意一个任务都执行完成之后就会往下执行代码（打印出：” Any task finished!”）\n\n##### Task.ContinueWith()\n\n在第一个Task完成后自动启动下一个Task，实现Task的延续，编写如下代码：\n\n```c#\npublic static void Main()\n{\n    TaskFactory tf = new TaskFactory();\n    Task t1 = tf.StartNew(()=>\n    {\n        Console.WriteLine(\"Current Task id = {0}\", Task.CurrentId);\n        Console.WriteLine(\"执行任务1\\r\\n\");\n        Thread.Sleep(10);\n    });\n\n    Task t2 = t1.ContinueWith((t) =>\n    {\n        Console.WriteLine(\"Last Task id = {0}\", t.Id);\n        Console.WriteLine(\"Current Task id = {0}\", Task.CurrentId);\n        Console.WriteLine(\"执行任务2\\r\\n\");\n        Thread.Sleep(10);\n    });\n\n    Task t3 = t2.ContinueWith(delegate(Task t) \n    {\n        Console.WriteLine(\"Last Task id = {0}\", t.Id);\n        Console.WriteLine(\"Current Task id = {0}\", Task.CurrentId);\n        Console.WriteLine(\"执行任务3\\r\\n\");\n    }, TaskContinuationOptions.OnlyOnRanToCompletion);\n\n    Console.ReadKey(); \n}\n    //执行结果\n    //\n    //Current Task id = 1\n    //执行任务1\n\n    //Last Task id = 1\n    //Current Task id = 2\n    //执行任务2\n\n    //Last Task id = 2\n    //Current Task id = 3\n    //执行任务3\n```\n\n从执行结果可以看出，任务1，2，3被顺序执行，同时通过 TaskContinuationOptions 还可以指定何种情况下继续执行该任务，常用的值包括OnlyOnFaulted, OnlyOnCanceled, NotOnFaulted, NotOnCanceled等。如将上例中的OnlyOnRanToCompletion改为OnlyOnFaulted，任务2结束之后，任务3将不被执行。\n\n对于ContinueWith()的使用，MSDN演示了更加优雅的“流式”调用方法：\n\n```c#\nprivate void Button1_Click(object sender, EventArgs e)  \n{  \n   var backgroundScheduler = TaskScheduler.Default;  \n   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  \n   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  \n                         backgroundScheduler).  \n   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  \n                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  \n                             backgroundScheduler).  \n                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  \n}\n```\n\n##### RunSynchronously()\n\n用于实现同步调用，直接在当前线程上调用该任务。\n\n```c#\npublic static void Main()\n{\n    TaskMethod.DoTask(\"Just Main thread\");\n    Task t1 = new Task(TaskMethod.DoTask, \"using Run Sync\");\n    t1.RunSynchronously();\n    //输出结果\n    //Just Main thread\n    //Task id: no task, Thread id: 9\n    //\n    //using Run Sync\n    //Task id:1, Thread id :9\n}\n```\n\n#### 任务取消\n\n当我们启动了一个task,出现异常或者用户点击取消等等，我们可以取消这个任务。\n\n我们通过cancellation的tokens来取消一个Task。\n在很多Task的Body里面包含循环，我们可以在轮询的时候判断IsCancellationRequested属性是否为True\n如果是True的话就return或者抛出异常，抛出异常后面再说，因为还没有说异常处理的东西。\n\n下面在代码中看下如何实现任务的取消，代码如下：\n\n```c#\npublic static void Main()\n        {\n            var tokenSource = new CancellationTokenSource();\n            var token = tokenSource.Token;\n            var task = Task.Factory.StartNew(() =>\n            {\n                for (var i = 0; i < 1000; i++)\n                {\n                    System.Threading.Thread.Sleep(1000);\n                    if (token.IsCancellationRequested)\n                    {\n                        Console.WriteLine(\"Abort mission success!\");\n                        return;\n                    }\n                }\n            }, token);\n            token.Register(() =>\n            {\n                Console.WriteLine(\"Canceled\");\n            });\n            Console.WriteLine(\"Press enter to cancel task...\");\n            Console.ReadKey();\n            tokenSource.Cancel();\n\n            Console.ReadKey();\n        }\n```\n\n这里开启了一个Task,并给token注册了一个方法，输出一条信息，然后执行ReadKey开始等待用户输入，用户点击回车后，执行tokenSource.Cancel方法，取消任务。\n\n> 注意：\n> 因为任务通常运行以异步方式在线程池线程上，创建并启动任务的线程将继续执行，一旦该任务已实例化。\n> 在某些情况下，当调用线程的主应用程序线程，该应用程序可能会终止之前任何任务实际开始执行。\n> 其他情况下，应用程序的逻辑可能需要调用线程继续执行，仅当一个或多个任务执行完毕。\n> 您可以同步调用线程的执行，以及异步任务它启动通过调用 Wait 方法来等待要完成的一个或多个任务。\n> 若要等待完成一项任务，可以调用其 Task.Wait 方法。\n> 调用 Wait 方法将一直阻塞调用线程直到单一类实例都已完成执行。\n\n#### 接收任务的返回值\n\n对于任务有返回值的情况，可使用Task泛型类，TResult定义了返回值的类型，以下代码演示了调用返回int值的任务的方法。\n\n```\npublic static void Main()\n{\n    var t5 = new Task<int>(TaskWithResult, Tuple.Create<int, int>(1, 2));\n    t5.Start();\n    t5.Wait();\n    Console.WriteLine(\"adder results: {0}\", t5.Result);\n\n    Console.ReadKey(); \n}\n\npublic static int TaskWithResult(object o)\n{\n    Tuple<int, int> adder = (Tuple<int, int>)o;\n    return adder.Item1 + adder.Item2;\n}\nCopy\n```\n\n### 任务的层次结构\n\n如果在一个Task内部创建了另一个任务，这两者间就存在父/子的层次结构，当父任务被取消时，子任务也会被取消。\n\n如果不希望使用该层次结构，可在创建子任务时选择TaskCreationOptions.DetachedFromParent。\n\n\n## BackgroundWorker控件\n\n### 概述\n\nC#提供了BackgroundWorker控件帮助用户更简单、安全地实现多线程运算。\n\n该控件提供了DoWork, ProgressChanged 和 RunWorkerCompleted事件\n为DoWork添加事件处理函数，再调用RunWorkerAsync()方法，即可创建一个新的线程执行DoWork任务\n\nProgressChanged和RunWorkerCompleted事件均在UI线程中执行，添加相应的处理函数，即可完成任务线程与UI线程间的交互，可用于显示任务的执行状态（完成百分比）、执行结果等。\n\n同时，该控件还提供了CancleAsync()方法，以中断线程的执行\n需注意的是，调用该方法后，只是将控件的CancellationPending属性置True，用户需在程序执行过程中查询该属性以判定是否应中断线程。\n\n具体用法可参考MSDN：[BackgroundWorker用法范例](https://docs.microsoft.com/zh-cn/dotnet/api/system.componentmodel.backgroundworker?view=netframework-4.7.2)\n可以看的出来，BackgroundWorker组件提供了一种执行异步操作（后台线程）的同时，并且还能妥妥的显示操作进度的解决方案。\n\n### 属性表\n\n#### WorkerReportsProgress\n\nbool类型，指示BackgroundWorker是否可以报告进度更新。\n\n- True时，可以成功调用ReportProgress方法\n- 否则将引发InvalidOperationException异常\n\n用法：\n\n```c#\nprivate BackgroundWorker bgWorker = new BackgroundWorker();\nbgWorker.WorkerReportsProgress = true;\n```\n\n#### WorkerSupportsCancellation\n\nbool类型，指示BackgroundWorker是否支持异步取消操作\n\n- True时，将可以成功调用CancelAsync方法\n\n- 否则将引发InvalidOperationException异\n  用法：\n\n  ```c#\n  bgWorker.WorkerSupportsCancellation = true;\n  ```\n\n#### CancellationPending\n\nbool类型，指示应用程序是否已请求取消后台操作。\n此属性通常放在用户执行的异步操作内部，用来判断用户是否取消执行异步操作。\n当执行BackgroundWorker.CancelAsync()方法时，该属性值将变为True。\n用法：\n\n```c#\n//在DoWork中键入如下代码\n  for (int i = 0; i <= 100; i++)\n  {\n      if (bgWorker.CancellationPending)\n      {\n          e.Cancel = true;\n          return;\n      }\n      else\n      {\n          bgWorker.ReportProgress(i,\"Working\");\n          System.Threading.Thread.Sleep(10);\n      }\n  }   \n```\n\n#### IsBusy\n\nbool类型，指示BackgroundWorker是否正在执行一个异步操作。\n此属性通常放在BackgroundWorker.RunWorkerAsync()方法之前，避免多次调用RunWorkerAsync()方法引发异常。\n当执行BackgroundWorker.RunWorkerAsync()方法是，该属性值将变为True。\n\n```c#\n//防止重复执行异步操作引发错误\n if (bgWorker.IsBusy)\n     return;\n bgWorker.RunWorkerAsync();\n```\n\n### 方法表\n\n#### RunWorkerAsync()\n\n开始执行一个后台操作。\n\n调用该方法后，将触发BackgroundWorker.DoWork事件，并以异步的方式执行DoWork事件中的代码。\n该方法还有一个带参数的重载方法：RunWorkerAsync(Object)。\n该方法允许传递一个Object类型的参数到后台操作中，并且可以通过DoWork事件的DoWorkEventArgs.Argument属性将该参数提取出来。\n\n> 注：当BackgroundWorker的IsBusy属性为True时，调用该方法将引发InvalidOperationException异常。\n\n```c#\n//在启动异步操作的地方键入代码\nbgWorker.RunWorkerAsync(\"hello\");\n```\n\n#### ReportProgress(Int percentProgress)\n\n报告操作进度。\n\n调用该方法后，将触发BackgroundWorker. ProgressChanged事件。\n另外，该方法包含了一个int类型的参数percentProgress，用来表示当前异步操作所执行的进度百分比。\n\n该方法还有一个重载方法：ReportProgress(Int percentProgress, Object userState)。\n允许传递一个Object类型的状态对象到 ProgressChanged事件中\n并且可以通过ProgressChanged事件的ProgressChangedEventArgs.UserState属性取得参数值。\n\n> 注：调用该方法之前需确保WorkerReportsProgress属性值为True，否则将引发InvalidOperationException异常。\n\n用法：\n\n```c#\nfor (int i = 0; i <= 100; i++)\n{\n    //向ProgressChanged报告进度\n    bgWorker.ReportProgress(i,\"Working\");\n    System.Threading.Thread.Sleep(10);\n}\n```\n\n#### CancelAsync()\n\n请求取消当前正在执行的异步操作。\n\n调用该方法将使BackgroundWorker.CancellationPending属性设置为True。\n但需要注意的是，并非每次调用CancelAsync()都能确保异步操作，CancelAsync()通常不适用于取消一个紧密执行的操作，更适用于在循环体中执行。\n用法：\n\n```c#\n//在需要执行取消操作的地方键入以下代码\nbgWorker.CancelAsync();\n```\n\n### 事件表\n\n#### DoWork\n\n用于承载异步操作。当调用BackgroundWorker.RunWorkerAsync()时触发。\n\n需要注意的是：\n由于DoWork事件内部的代码运行在非UI线程之上，所以在DoWork事件内部应避免于用户界面交互，\n而于用户界面交互的操作应放置在ProgressChanged和RunWorkerCompleted事件中。\n\n#### ProgressChanged\n\n当调用BackgroundWorker.ReportProgress(int percentProgress)方式时触发该事件。\n该事件的ProgressChangedEventArgs.ProgressPercentage属性可以接收来自ReportProgress方法传递的percentProgress参数值,ProgressChangedEventArgs.UserState属性可以接收来自ReportProgress方法传递的userState参数。\n\n#### RunWorkerCompleted\n\n异步操作完成或取消时执行的操作，当调用DoWork事件执行完成时触发。\n\n该事件的RunWorkerCompletedEventArgs参数包含三个常用的属性Error,Cancelled,Result。其中，Error表示在执行异步操作期间发生的错误；Cancelled用于判断用户是否取消了异步操作；Result属性接收来自DoWork事件的DoWorkEventArgs参数的Result属性值，可用于传递异步操作的执行结果。\n\n### 案例\n\n```c#\nusing System;\nusing System.ComponentModel;\nusing System.Threading;\nusing System.Windows.Forms;\n \nnamespace bcworker\n{\n    public partial class Form1 : Form\n    {\n        //后台工作\n        private BackgroundWorker bw = new BackgroundWorker();\n \n        public Form1()\n        {\n            InitializeComponent();\n            //后台工作初始化\n            bw.WorkerReportsProgress = true;//报告进度\n            bw.WorkerSupportsCancellation = true;//支持取消\n            bw.DoWork += new DoWorkEventHandler(bgWorker_DoWork);//开始工作\n            bw.ProgressChanged += new ProgressChangedEventHandler(bgWorker_ProgessChanged);//进度改变事件\n            bw.RunWorkerCompleted += new RunWorkerCompletedEventHandler(bgWorker_WorkerCompleted);//进度完成事件\n        }\n \n        private void btnStart_Click(object sender, EventArgs e)\n        {\n            //后台工作运行中，避免重入\n            if (bw.IsBusy) return;\n            bw.RunWorkerAsync(\"参数\");//触发DoWork事件并异步执行，IsBusy置为True\n        }\n        //后台工作将异步执行\n        public void bgWorker_DoWork(object sender, DoWorkEventArgs e)\n        {\n            //(string)e.Argument == \"参数\";\n            for (int i = 0; i <= 100; i++)\n            {\n \n                if (bw.CancellationPending)\n                {//用户取消了工作\n                    e.Cancel = true;\n                    return;\n                }\n                else\n                {\n                    bw.ReportProgress(i, \"Working\");//报告进度，触发ProgressChanged事件\n                    Thread.Sleep(10);//模拟工作\n                }\n            }\n        }\n        //进度改变事件\n        public void bgWorker_ProgessChanged(object sender, ProgressChangedEventArgs e)\n        {\n            //(string)e.UserState==\"Working\"\n            progressBar1.Value = e.ProgressPercentage;//取得进度更新控件，不用Invoke了\n        }\n        //后台工作执行完毕,IsBusy置为False\n        public void bgWorker_WorkerCompleted(object sender, RunWorkerCompletedEventArgs e)\n        {\n            //e.Error == null 是否发生错误\n            //e.Cancelled 完成是由于取消还是正常完成\n        }\n \n        private void btnCancel_Click(object sender, EventArgs e)\n        {\n            if (bw.IsBusy) bw.CancelAsync();//设置CancellationPending属性为True\n        }\n \n    }\n}\n```\n\n\n\n# 调用系统对话框\n\n注意，需要在winform应用程序下实现。\n\n如需在控制台中使用，注意引入System.Windows.Forms命名空间（需要先引入对应的dll），而且还存在某些问题\n\n## 打开文件对话框\n\n```c#\npublic void OpenFileDialogFunction()\n{\n    /*实例化出打开文件对话框的对象*/\n    OpenFileDialog ofd = new OpenFileDialog();\n\n    /*设置对话框的参数*/\n    //设置对话框的标题\n    ofd.Title = \"对话框的标题\";\n\n    //设置对话框是否可以多选文件。允许多选为true，否则为false\n    ofd.Multiselect = true;\n\n    //设置对话框的初始目录\n    //默认是在当前用户的文档文件夹下？\n    ofd.InitialDirectory = @\"D:\\files\";\n\n    //设置允许打开文件的类型\n    //竖线分隔，前面是提示信息，后面是筛选的文件格式。支持多个，可以一对一，也可以一对多。\n    //对于一对多（多个文件格式）,每个筛选条件后面都需要加上分号表示结束。\n    ofd.Filter = \"文本文件|*.txt; | 可执行文件|*.exe;*.apk; | 压缩文件|*.zip;*.rar;*.7z; | 所有文件|*.*;\";\n\n\n    /*显示对话框*/\n    ofd.ShowDialog();\n\n    /*获取选中文件的路径*/\n    //对于允许多选的打开文件类型，可以通过FileNames获取。\n    //如果允许了多选文件，并且运行的时候确实多选了文件，使用FileName属性获取也不会报错\n    //只是只会获取到多选中第一个文件的路径\n    string[] fileName = ofd.FileNames;\n\n\n    /*将获取到的信息展示出来*/\n    lblInfo.Text = \"\";\n    foreach(string file in ofd.FileNames)\n    {\n        lblInfo.Text += file;\n        lblInfo.Text += \"\\n\";\n    }\n}\n```\n\n\n\n## 保存文件对话框\n\n```c#\npublic void SaveFileDialogFunction()\n{\n    //实例化出一个保存对话框的对象\n    SaveFileDialog sfd = new SaveFileDialog();\n\n    /*设置对话框的属性*/\n    //设置对话框的标题\n    sfd.Title = \"保存对话框的标题\";\n\n    //设置保存对话框的默认路径\n    sfd.InitialDirectory = @\"D:\\files\";\n\n    //设置保存的格式\n    sfd.Filter = \"文本文件|*.txt; | 所有文件|*.*\";\n\n    //对于保存对话框来说，不存在多选的选项\n\n\n    /*展示对话框*/\n    sfd.ShowDialog();\n\n\n    /*获取用户要保存的路径*/\n    //因为不允许多选，因此这里只有这一个属性\n    string path = sfd.FileName;\n    lblInfo.Text = path;\n\n}\n\n```\n\n# Socket套接字\n\nSocket作为进程通信机制，通常也被称为套接字。用于描述IP地址和端口号，是一个通信链的句柄。\n\n建立连接的时候，服务器应该有一个用于监听的Socket，用于监听应用程序是否有人连接。这个有用于监听的Socket就相当于电话的接线员，一旦检测到有连接，就创建一个负责跟客户端连接的Socket。此时，服务器端Socket的数量为2（至少两个），其中一个只负责监听，另外一个只负责通信；而客户端，从始至终都只有1个Socket。\n\n需要注意，一个Socket一次只能连接一台主机，且Socket被关闭后无法再次被使用。\n\n每个Socket对象只能一台主机连接，如果需要连接多台主机，必须创建多个Socket对象。\n\n\n\n## Socket的通信过程\n\n### 服务器端\n\n1. 申请一个Socket\n2. 绑定到一个IP地址和端口号上\n3. 开启侦听，等待连接\n\n### 客户端\n\n1. 申请一个Socket\n2. 连接服务器（需要指明ip地址和端口号）\n\n### 过程\n\n服务器接到连接请求后，产生一个新的Socket（端口号需要大于1024）与客户端建立连接并进行通信，**原监听Socket继续监听**。\n\n\n\n![image-20230521163803975](./Image/C#学习笔记_基础教程.assets/image-20230521163803975.png)\n\n\n\n## Socket的构造函数\n\n连接通过构造函数\n\n\n\n\n\n\n\n# GDI+\n\n​\tGDI+ (Graphics Device Interface)是一种绘图装置接口，可应用程序和绘图硬件分隔，让我们能够编写与装置无关的应用程序。它可以让我们不需注意特定显示装置的详细数据，便可在屏幕或打印机显示信息。我们可以呼叫GDI+类别所提供的方法，然后这些方法会适当地呼叫特定的装置驱动程序，而完成绘图。而且与.NET进行了更好的融合。\n\n\n\n## 后端\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\n\nnamespace GDITest\n{\n    public partial class Form1 : Form\n    {\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        /*\n        * 在Windows中，当窗口移动、最小化、还原或遮盖时，窗口的内容会被清除。\n        * 为了保持窗口内容的一致性，需要在窗口的Paint事件中重新绘制窗口内容。\n        * 这就是为什么需要重新绘制的原因。\n        * \n        * 只要在事件中添加了对应的方法后，只要对应的图形出显示屏\n        * 系统就会自动调用这个事件。重新绘制（只要出一点就调用）\n        */\n\n        /// <summary>\n        /// 使用GDI绘制一条直线\n        /// </summary>\n        void GDITest1()\n        {\n\n\n            //使用GDI绘制的时候，需要准备一根笔、颜色、两个点、绘制直线的对象\n\n            //创建GDI对象\n            //Graphics g = new Graphics(); 不能直接创建\n            Graphics g = this.CreateGraphics();//只能通过this创建对象\n\n            //创建画笔对象\n            Pen pen = new Pen(Brushes.Blue);\n\n            //创建两个点，用于确定绘制范围\n            Point p1 = new Point(30, 50);\n            Point p2 = new Point(250, 250);\n\n            //开始绘制\n            g.DrawLine(pen, p1, p2);\n\n        }\n\n        /// <summary>\n        /// 使用GDI绘制一个矩形\n        /// </summary>\n        void GDITest2()\n        {\n            //获得GDI对象\n            Graphics g = this.CreateGraphics();\n            //实例化画笔\n            Pen pen = new Pen(Brushes.Blue);\n            //设置绘制的大小\n            Size size = new System.Drawing.Size(80, 80);\n            //设置要绘制的矩形尺寸，从窗口左上角开始的50，50点开始，生成一个80x80像素的矩形\n            Rectangle r1 = new Rectangle(new Point(50, 50), size);\n            //使用画笔绘制出指定的矩形\n            g.DrawRectangle(pen, r1);\n        }\n\n        /// <summary>\n        /// 绘制一个扇形\n        /// </summary>\n        void GDITest3()\n        {\n            Graphics g = this.CreateGraphics();\n\n            //从文本框中拿到所需要的信息\n            if (txt1.Text == \"\" || txt2.Text == \"\" || txt3.Text == \"\" || txt4.Text == \"\" || txt5.Text == \"\" || txt6.Text == \"\")\n            {\n                MessageBox.Show(\"请在个文本框中分别输入信息以生成扇形\");\n                return;\n            }\n            int x = int.Parse(txt1.Text);\n            int y = int.Parse(txt2.Text);\n            int L = int.Parse(txt3.Text);\n            int W = int.Parse(txt4.Text);\n            float f1 = float.Parse(txt5.Text);\n            float f2 = float.Parse(txt6.Text);            \n\n            //生成一个画笔和对应的颜色\n            Pen pen = new Pen(Color.Blue);\n\n            //生成一个矩形\n            Size size = new System.Drawing.Size(L, W);//设置一下初始位置\n            Rectangle r1 = new Rectangle(new Point(x, y), size);//借助位置生成一个矩形\n\n            \n\n            //需要四个参数，分别是画笔、矩形和两个角度。\n            //两个角度分别是：从x轴到扇形的第一条边沿顺时针方向度量的角（以度为单位）\n            //和： 从上一个参数开始到扇形的第二条边沿顺时针方向度量的角（以度为单位）\n            g.DrawPie(pen, r1, f1, f2);\n\n        }\n\n        /// <summary>\n        /// 使用GDI绘制一个文本\n        /// </summary>\n        void GDITest4()\n        {\n            int x = int.Parse(txt1.Text);\n            int y = int.Parse (txt2.Text);\n\n            //获取GDI对象\n            Graphics g =this.CreateGraphics();\n\n            //所需参数：\n            //要显示的文本信息\n            //字体信息\n            //颜色\n            //显示位置\n            g.DrawString(txtInfo.Text, new Font(\"微软雅黑\", 20, FontStyle.Bold), Brushes.Black, new Point(x, y));\n\n        }\n\n        /// <summary>\n        /// 绘制一个验证码\n        /// </summary>\n        void GDITest5()\n        {\n            //生成随机数\n            Random random = new Random();\n            string str = null;\n            for(int i = 0; i < 5; i++)\n            {\n                int rNum = random.Next(0, 10);\n                str += rNum.ToString();\n            }\n\n            //生成位图\n            //因为Bitmap继承于Image，而Image是抽象类不可以被实例化，因此只能用Bitmap替代Image传入GDI\n            Bitmap bmp = new Bitmap(100, 20);\n\n            //创建GDI对象\n            Graphics g = Graphics.FromImage(bmp);\n\n            //设置一些随机化的值\n            //生成的字体从这些集合中选\n            string[] fonts = { \"微软雅黑\", \"宋体\", \"隶书\", \"黑体\", \"仿宋\" };\n            //文字的颜色在这个集合中随机选\n            Color[] colors = { Color.Yellow, Color.Blue, Color.Red, Color.Black, Color.Green };\n\n\n            //将产生的随机数绘制到位图中\n            for(int i = 0; i < 5; i++)\n            {\n                Point point = new Point(i * 15 + 2, 0);\n                g.DrawString(str[i].ToString(), new Font(fonts[random.Next(0,5)], 15, FontStyle.Bold), new SolidBrush(colors[random.Next(0,5)]), point);\n            }\n\n            //增加干扰线\n            for(int i = 0;i < 15; i++)\n            {\n                //随机生成点作为绘制坐标。\n                //要求起始点的横坐标在0到图片的宽度之间，纵坐标在0到图片的高度之间随机选择\n                Point p1 = new Point(random.Next(0, bmp.Width), random.Next(0, bmp.Height));\n                Point p2 = new Point(random.Next(0, bmp.Width), random.Next(0, bmp.Height));\n\n                g.DrawLine(new Pen(Brushes.Green), p1, p2);\n            }\n\n            //增加像素颗粒\n            for(int i = 0; i < 100; i++)\n            {\n                bmp.SetPixel(random.Next(0, bmp.Width), random.Next(0, bmp.Height), Color.Black);\n            }\n\n            //将图片镶嵌到PictureBox中\n            pictureBox1.Image = bmp;\n        }\n\n        private void btn1_Click(object sender, EventArgs e)\n        {\n            GDITest1();\n\n        }\n\n        //在窗口改变的时候重新绘制指定的GDI\n        private void Form1_Paint(object sender, PaintEventArgs e)\n        {\n            //GDITest1();\n        }\n\n        private void button2_Click(object sender, EventArgs e)\n        {\n            GDITest2();\n        }\n\n        private void btn3_Click(object sender, EventArgs e)\n        {\n            GDITest3();\n        }\n\n        private void Form1_Load(object sender, EventArgs e)\n        {\n\n        }\n\n        private void btn4_Click(object sender, EventArgs e)\n        {\n            GDITest4();\n        }\n\n        private void btn5_Click(object sender, EventArgs e)\n        {\n            GDITest5();\n        }\n    }\n}\n\n```\n\n\n\n\n\n# 序列化\n\n## 关于二进制序列化需要注意的事项:\n\n- 要序列化的类型必须标记为: [Serializable]\n- 该类型的父类也必须标记为: [Serializable]\n- 该类型中的所有成员的类型也必须标记为: [Seralizable]\n- 序列化只会对类中的**字段**序列化。(只能序列化一些状态信息)\n- 需要头文件：`System.Runtime.Serialization.Formatters.Binary` \n\n```c\nusing System;\nusing System.Runtime.Serialization.Formatters.Binary;\n\nnamespace ConsoleApp\n{\n    class Program\n    {\n        /*\n         * 序列化步骤：\n         * 首先将要序列化的对象的类标记为可以被序列化的\n         * 然后产生一个文件流用于写入被序列化的对象（可缺省？）\n         * 接着创建一个BinaryFormatter的对象用于对目标类进行序列化\n         * 最后调用这个对象的Serialize方法将目标对象进行序列化，并保存到对应的位置\n         */\n\n        static void Main(string[] args) \n        {\n            //创建Person对象\n            Person p = new Person();\n            p.Name = \"张三\";\n            p.Age = 30;\n            p.Gender = '男';\n\n            using (FileStream fsWrite = new FileStream(@\"D:\\tmp\\tmp.txt\", FileMode.OpenOrCreate, FileAccess.Write))\n            {\n                //创建用于序列化的对象\n                BinaryFormatter bf = new BinaryFormatter();\n                //开始序列化\n                bf.Serialize(fsWrite, p);\n            }\n            Console.WriteLine(\"序列化完成\");          \n\n\n\n            //开始反序列化\n            //将保存到文件的对象的字段信息还原成一个对象\n\n            using(FileStream fsRead = new FileStream(@\"D:\\tmp\\tmp.txt\", FileMode.Open, FileAccess.Read))\n            {\n                //创建用于反序列化的对象\n                BinaryFormatter bf = new BinaryFormatter();\n                //反序列化对象\n                //返回的是一个object类型的对象\n                object o =  bf.Deserialize(fsRead);\n                //经is判断可以得出o是Person的对象\n                Console.WriteLine(o is Person);\n                //拆箱成为原始类型的对象\n                Person pt = (Person)o;\n                //输出反序列化后的一些信息\n                Console.WriteLine(pt.Name);\n                Console.WriteLine(pt.Age);\n                Console.WriteLine(pt.Gender);\n                \n            }\n        }\n    }\n\n\n    //将类标记为可以被序列化的\n    [Serializable]\n    public class Person\n    {\n        public string Name { get; set; }\n        public int Age { get; set; }\n        public char Gender { get; set; }\n    }\n\n}\n\n```\n\n\n\n# c#复制\n\nc#中复制可分为深复制、浅复制两种。\n\n首先要明确拷贝产生的结果都是reference type（引用类型）的，本质上还是指向一个对象（毕竟primitive type（简单类型）不需要）\n\n所以深拷贝和浅拷贝的区别，就是拷贝这个reference指向的对象是不是之前的。\n\n## 浅复制\n\n对于值类型来说，C#中的浅复制指的是创建一个新对象，并将当前对象的值类型字段复制到新对象中。\n\n对于数据是引用类型时，只复制引用，而不复制引用的对象本身。因此，原始对象和副本对象指向同一个对象。浅复制可以使用Object.MemberwiseClone方法来实现，也可以使用其他方式。与深复制相比，浅复制更快，但也更容易出现数据不一致或内存泄漏的问题。\n\n\n\n### 使用浅复制的场景\n\n\n\n- 当我们想要创建一个新对象，但不想完全复制原始对象的所有数据时，例如，当原始对象包含大量的引用类型字段时，深复制会消耗更多的内存和时间。\n- 当我们想要保持原始对象和副本对象之间的一些联系时，例如，当原始对象和副本对象共享一些引用类型字段时，我们可以通过修改其中一个来影响另一个。\n- 当我们不需要担心数据不一致或内存泄漏的问题时，例如，当原始对象和副本对象的生命周期相同或相近时，或者当我们可以正确地管理引用类型字段的释放时。\n\n### 样例\n\n假设有一个类Person，它有两个字段：name和address。name是一个字符串，是值类型；address是一个类Address，是引用类型。\n\n下面是Person类的定义：\n\n```csharp\nclass Person\n{\n    public string name;\n    public Address address;\n\n    public Person(string name, Address address)\n    {\n        this.name = name;\n        this.address = address;\n    }\n\n    public Person ShallowCopy()\n    {\n        return (Person)this.MemberwiseClone();//MemberwiseClone()功能见后续解释\n    }\n}\n```\n\n下面是Address类的定义：\n\n```csharp\nclass Address\n{\n    public string city;\n    public string street;\n\n    public Address(string city, string street)\n    {\n        this.city = city;\n        this.street = street;\n    }\n}\n```\n\n现在我们创建一个Person对象p1，并用ShallowCopy方法创建一个浅复制对象p2：\n\n```csharp\nPerson p1 = new Person(\"Alice\", new Address(\"Beijing\", \"Xidan\"));\nPerson p2 = p1.ShallowCopy();\n```\n\n这时，p1和p2都有相同的name和address字段的值，但是它们指向不同的对象。如果我们修改p1的name字段，那么p2的name字段不会受到影响，因为它们是值类型：\n\n```csharp\np1.name = \"Bob\";\nConsole.WriteLine(p1.name); // Bob\nConsole.WriteLine(p2.name); // Alice\n```\n\n但是如果我们修改p1的address字段，那么p2的address字段也会受到影响，因为它们是引用类型，并且指向同一个Address对象：\n\n```csharp\np1.address.city = \"Shanghai\";\nConsole.WriteLine(p1.address.city); // Shanghai\nConsole.WriteLine(p2.address.city); // Shanghai\n```\n\n#### 样例中部分方法的解释\n\n##### MemberwiseClone()\n\nMemberwiseClone();是一个Object类的方法，它可以创建一个新对象，其字段是对原始对象字段的逐位复制。如果字段是值类型的，那么新对象和原始对象的字段值相同；如果字段是引用类型的，那么新对象和原始对象的字段指向同一个引用对象。因此，MemberwiseClone();方法可以实现浅复制。要使用这个方法，我们需要在自定义类中定义一个ShallowCopy()方法，并在其中调用MemberwiseClone();方法，然后返回新对象。\n\n\n\n### 浅复制与赋值的区别\n\n浅复制和赋值的区别是，浅复制会创建一个**新对象**，并将原始对象的值类型字段复制到新对象中，而赋值只是将原始对象的引用赋给一个变量，不会创建新对象。例如，如果我们用赋值代替浅复制：\n\n```csharp\nPerson p1 = new Person(\"Alice\", new Address(\"Beijing\", \"Xidan\"));\nPerson p2 = p1;\n```\n\n这时，p1和p2都指向同一个Person对象，如果我们修改p1或p2的任何字段，都会影响另一个变量：\n\n```csharp\np1.name = \"Bob\";\nConsole.WriteLine(p1.name); // Bob\nConsole.WriteLine(p2.name); // Bob\n\np2.address.city = \"Shanghai\";\nConsole.WriteLine(p1.address.city); // Shanghai\nConsole.WriteLine(p2.address.city); // Shanghai\n```\n\n\n\n\n\n## 深复制\n\n为什么要用到深拷贝呢？比如我们建了某个类Person，并且实例化出一个对象，然后，突然需要把这个对象复制一遍，并且复制出来的对象要跟之前的一模一样，如果两个变量直接赋值，如： `A a = new A(); A b = a;` 得到的还是同一个对象，并没有复制真正的内容。这时候如果需要复制真正内容的话，就需要用到深拷贝的方式了。\n\n### 几种常见的深拷贝方式\n\n#### 利用反射实现\n\n```c#\npublic static T DeepCopyByReflection<T>(T obj)\n{\n　　if (obj is string || obj.GetType().IsValueType)\n　　return obj;\n\n　　object retval = Activator.CreateInstance(obj.GetType());\n　　FieldInfo[] fields = obj.GetType().GetFields(BindingFlags.Public|BindingFlags.NonPublic|BindingFlags.Static|BindingFlags.Instance);\n　　foreach(var field in fields)\n　　{\n　　　　try\n　　　　{\n　　　　　　field.SetValue(retval, DeepCopyByReflection(field.GetValue(obj)));\n　　　　}\n　　　　catch { }\n　　}\n\n　　return (T)retval;\n}\n```\n\n \n\n#### 利用二进制序列化和反序列化\n\n```c#\npublic static T DeepCopyByBinary<T>(T obj)\n{\n　　object retval;\n　　using (MemoryStream ms = new MemoryStream())\n　　{\n　　　　BinaryFormatter bf = new BinaryFormatter();\n　　　　bf.Serialize(ms, obj);\n　　　　ms.Seek(0, SeekOrigin.Begin);\n　　　　retval = bf.Deserialize(ms);\n　　　　ms.Close();\n　　}\n　　return (T)retval;\n}\n```\n\n注意，使用二进制序列化和反序列化时，在需要序列化的类上要加上[Serializable]\n\n```c#\n[Serializable]\npublic class Person\n{\n　　public string Name { get; set; }\n}\n```\n\n \n\n#### 利用xml序列化和反序列化\n\n```c#\npublic static T DeepCopyByXml<T>(T obj)\n{\n　　object retval;\n　　using (MemoryStream ms = new MemoryStream())\n　　{\n　　　　XmlSerializer xml=new XmlSerializer(typeof(T));\n　　　　xml.Serialize(ms, obj);\n　　　　ms.Seek(0, SeekOrigin.Begin);\n　　　　retval = xml.Deserialize(ms);\n　　　　ms.Close();\n　　}\n　　return (T)retval;\n}\n```\n\n\n\n\n\nc#中复制可分为深复制、浅复制两种。\n\n首先要明确拷贝产生的结果都是reference type（引用类型）的，本质上还是指向一个对象（毕竟primitive type（简单类型）不需要）\n\n所以深拷贝和浅拷贝的区别，就是拷贝这个reference指向的对象是不是之前的。\n\n有以下两种方式，更推荐第一种：\n\n## 泛型+反射\n\n```c#\n /* 利用反射实现深拷贝*/\n public static object DeepCopy(object _object)\n {\n     Type T = _object.GetType();\n     object o = Activator.CreateInstance(T);\n     PropertyInfo[] PI = T.GetProperties();\n     for (int i = 0; i < PI.Length; i++)\n     {\n         PropertyInfo P = PI[i];\n         P.SetValue(o, P.GetValue(_object));\n     }\n     return o;\n }\n```\n\n> 反射是.NET中的重要机制,通过反射,可以在运行时获得程序或程序集中每一个类型(包括类、结构、委托、接口和枚举等)的成员和成员的信息。有了反射,即可对每一个类型了如指掌。另外**我还可以直接创建对象,即使这个对象的类型在编译时还不知道**。可以实现从对象的外部来了解对象(或程序集)内部结构的功能,哪怕你不知道这个对象(或程序集)是个什么东西,另外.NET中的反射还可以运态创建出对象并执行它其中的方法。\n> 为什么要用反射呢? 举个最简单的例子,当你在VS的设计器里拖入一个控件后,设计器会通过反射获取这个控件的属性,并提供给你进行设置，**设计器在做的时候,根本不可能预知将来有什么控件会被你拖入进去，所以要用反射**。\n\n这样的好处在于，它消除了模块之间的耦合，便于动态接口调用，在一些灵活的系统里面比较常用。\n\n### 反射和泛型来实现深拷贝怎么做\n\n- 首先我们应该获取传入参数的那个对象的类型，也就是反射的GetType()\n- 接下来Activator.CreateInstance(T); 用类型创建新拷贝的对象\n- PropertyInfo[] PI = T.GetProperties(); 这里使用PropertyInfo了解属性的名称、数据类型、声明类型、反射类型和只读或可写状态等,获取或设置属性值。\n- 接下来用Property的SetValue和GetValue来给新对象属性逐个赋值\n- 大功告成，返回新对象就行\n\n所以思路很清晰，调用的时候 Test b = (Test)DeepCopy(a); 泛型把object转回来就行\n\n总的来说我觉得这是一种比较简单直接也好理解的方法\n\n## 二进制流的方式（序列化）\n\n```c#\n/// 深拷贝 【不建议使用二进制流方法，此方法即使在类前面加了可序列化标志，调用该方法时也会报未序列化错误】，推荐使用反射方式\npublic object DeepCopy()\n{\n    using (MemoryStream stream = new MemoryStream())\n    {\n        BinaryFormatter bFormatter = new BinaryFormatter();\n        bFormatter.Serialize(stream, this);\n        stream.Seek(0, SeekOrigin.Begin);\n        return (InvoiceDetailResponse)bFormatter.Deserialize(stream);\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n# return原则\n\n## 尽早return\n\n在进入方法的时候先判断是否满足条件，如果不满足直接return；而不是判断条件是否满足而执行指定的代码。\n\n\n\n## 必须保证一定可以return\n\n\n\n\n\n\n\n\n\n\n\n# 单例模式\n\n只能创建一个对象\n\n1. 将构造函数私有化\n2. 对外提供一个静态方法，返回一个对象\n3. 创建一个单例\n4. 返回单例\n\n演示环境：WinForm\n\n## Form1代码：\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\n\nnamespace 单例模式\n{\n    public partial class Form1 : Form\n    {\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        private void Form1_Load(object sender, EventArgs e)\n        {\n\n        }\n\n        private void button1_Click(object sender, EventArgs e)\n        {            \n            Form2 frm2 = Form2.GetSingle();\n            frm2.ShowDialog();\n        }\n    }\n}\n\n```\n\n## Form2代码\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\n\nnamespace 单例模式\n{\n    public partial class Form2 : Form\n    {\n        //全局唯一的单例\n        public static Form2 FrmSingle = null;\n\n        //首先私有化构造函数\n        private Form2()\n        {\n            InitializeComponent();\n        }\n\n        private void Form2_Load(object sender, EventArgs e)\n        {\n\n        }\n\n        /// <summary>\n        /// 提供一个静态方法，返回一个对象\n        /// </summary>\n        /// <returns></returns>\n        public static Form2 GetSingle()\n        {\n            //只有这个对象没被实例化的时候才会被创建对象\n            if(FrmSingle == null)\n            {\n                FrmSingle = new Form2();\n            }\n            //如果已经存在了一个对象，则直接返回这个对象\n            return FrmSingle;\n        }\n    }\n}\n\n```\n\n\n\n# XML 可扩展的标记语言\n\n用于存储数据，并且严格区分大小写。\n\nxml中所有能看到的都是元素\n\n其中一对一对的标签都是节点。\n\n节点包含元素，但元素不都是节点。\n\n对于xml文档来说，有且只能有一个根节点。\n\n## 通过代码创建xml文档\n\n1. 引用命名空间\n2. 创建xml文档对象\n3. 创建根节点\n4. 创建子节点\n5. 为子节点再创建子节点\n6. 将子节点添加到父节点\n7. 保存xml对象。\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Xml;\n\nnamespace XML\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            //2. 创建xml对象\n            XmlDocument doc = new XmlDocument();\n\n            //3. 创建第一行描述信息，并添加到doc文档中\n            //第一个参数是xml的版本号，第二个是编码方式\n            //返回的是一个类型为XmlDeclaration的xml节点信息\n            XmlDeclaration dec =  doc.CreateXmlDeclaration(\"1.0\", \"utf-8\", null);\n\n            //4. 将节点加入到xml文档中\n            doc.AppendChild(dec); //追加节点\n\n            //创建根节点\n            XmlElement books = doc.CreateElement(\"Books\");\n            //将根节点添加到文档中\n            doc.AppendChild(books);\n\n            //5. 给根节点Books创建子节点\n            XmlElement book1 = doc.CreateElement(\"Boook\");\n            //将创建出来的子节点添加到根节点中\n            books.AppendChild(book1);\n\n            //6. 给Book1添加子节点\n            XmlElement name1 = doc.CreateElement (\"Name\");\n            XmlElement price1 = doc.CreateElement(\"Price\");\n            XmlElement des1 = doc.CreateElement(\"Des\");\n            //给这个子节点添加文本\n            name1.InnerText = \"西游记\";\n            price1.InnerText = \"10\";\n            des1.InnerText = \"向西的游记\";\n            //将子节点添加到Book1中\n            book1.AppendChild(name1);\n            book1.AppendChild (price1);\n            book1.AppendChild (des1);\n\n            //将xml进行保存\n            doc.Save(@\"D:\\tmp\\test.xml\");\n\n        }\n    }\n}\n```\n\n\n\n\n\n## 创建带属性的XML文档\n\n```c\nstatic void Main(string[] args)\n{\n    //创建xml对象\n    XmlDocument doc = new XmlDocument();\n    //创建版本声明\n    XmlDeclaration dec = doc.CreateXmlDeclaration(\"1.1\", \"utf-8\", null);\n    //将版本声明添加到xml对象中\n    doc.AppendChild(dec);\n\n    //创建根节点\n    XmlElement order = doc.CreateElement(\"Order\");\n    doc.AppendChild(order);\n\n    //创建子节点，并将子节点添加到根节点\n    XmlElement customerName = doc.CreateElement(\"CustomerName\");\n    customerName.InnerText = \"张三\";\n    order.AppendChild(customerName);\n\n    XmlElement customerNumber = doc.CreateElement(\"CustomerNumber\");\n    customerNumber.InnerText = \"10001\";\n    order.AppendChild(customerNumber);\n\n    //创建带属性的子节点\n    XmlElement items = doc.CreateElement(\"items\");\n    order.AppendChild(items);\n\n    XmlElement orderItem1 = doc.CreateElement(\"OrderItem\");\n    //给节点添加属性\n    orderItem1.SetAttribute(\"Name\", \"码表\");\n    orderItem1.SetAttribute(\"Count\", \"10\");\n    //将这个子节点添加到Item\n    items.AppendChild(orderItem1);\n\n    //添加更多带属性的子节点\n    XmlElement orderItem2 = doc.CreateElement(\"OrderItem\");\n    orderItem2.SetAttribute(\"Name\", \"ESP8266\");\n    orderItem2.SetAttribute(\"Count\", \"10\");\n    items.AppendChild(orderItem2);\n    XmlElement orderItem3 = doc.CreateElement(\"OrderItem\");\n    orderItem3.SetAttribute(\"Name\", \"ESP8266\");\n    orderItem3.SetAttribute(\"Count\", \"10\");\n    items.AppendChild(orderItem3);\n    XmlElement orderItem4 = doc.CreateElement(\"OrderItem\");\n    orderItem4.SetAttribute(\"Name\", \"ESP32\");\n    orderItem4.SetAttribute(\"Count\", \"10\");\n    items.AppendChild(orderItem4);\n\n    doc.Save(@\"D:\\tmp\\Order.xml\");\n\n}\n```\n\n\n\n## 向XML文档中追加内容\n\n大致流程\n\n1. 实例化XML对象\n2. 创建根节点XmlElement，但不给对象\n3. 通过File的Exists判断文件是否存在\n4. 如果存在则加载到根节点\n5. 如果不存在则创建根节点并添加版本信息\n6. 生成要追加的子节点\n7. 将子节点保存到根节点中\n8. 保存Xml对象\n\n```c#\nstatic void Main(string[] args)\n{\n    //追加XML文档\n    //只要对XML操作，就需要创建XML对象。\n    XmlDocument doc = new XmlDocument();\n\n    //声明一个根节点，但不给对象\n    XmlElement books = null;\n\n    //如果XML文件存在，只需要拿到根节点\n    //如果文件不存在，则需要创建XML文档\n    if (File.Exists(@\"D:\\tmp\\test.xml\"))\n    {\n        //文件存在， 拿到根节点\n\n        //先加载\n        doc.Load(@\"D:\\tmp\\test.xml\");\n        //后获取\n        books = doc.DocumentElement;\n\n    }\n    else\n    {\n        //不存在，就先创建在添加\n        XmlDeclaration dec = doc.CreateXmlDeclaration(\"1.0\", \"utf-8\", null);\n        doc.AppendChild(dec);//将说明添加进去\n        //创建根节点\n        books = doc.CreateElement(\"Books\");\n        doc.AppendChild(books);\n    }\n\n    //拿到根节点后，就可以往里面添加数据了。\n\n    //给根节点Books创建子节点\n    XmlElement book1 = doc.CreateElement(\"Boook\");\n    //将创建出来的子节点添加到根节点中\n    books.AppendChild(book1);\n    //给Book1添加子节点\n    XmlElement name1 = doc.CreateElement(\"Name\");\n    XmlElement price1 = doc.CreateElement(\"Price\");\n    XmlElement des1 = doc.CreateElement(\"Des\");\n    //给这个子节点添加文本\n    name1.InnerText = \"C#开发\";\n    price1.InnerText = \"110\";\n    des1.InnerText = \"csharp\";\n    //将子节点添加到Book1中\n    book1.AppendChild(name1);\n    book1.AppendChild(price1);\n    book1.AppendChild(des1);\n    //将xml进行保存\n    doc.Save(@\"D:\\tmp\\test.xml\");\n}\n```\n\n\n\n## 读取Xml文档\n\n```c#\nstatic void Main(string[] args)\n{\n    //实例化xml对象\n    XmlDocument doc = new XmlDocument();\n\n    //加载要读取的文件\n    doc.Load(@\"D:\\tmp\\test.xml\");\n\n    //获取根节点\n    XmlElement books = doc.DocumentElement;\n\n    //根据父节点获取子节点。返回的是子节点的集合\n    XmlNodeList xnl = books.ChildNodes;\n\n    foreach (XmlNode xn in xnl)\n    {\n        Console.WriteLine(xn.InnerText);//遍历集合中每个子节点的值\n    }\n}\n\n```\n\n\n\n## 读取带有属性的Xml文档\n\n```c#\nstatic void Main(string[] args)\n{\n    //创建xml对象\n    XmlDocument doc = new XmlDocument();\n    //加载文档\n    doc.Load(@\"D:\\tmp\\Order.xml\");\n    \n    //查找指定的路径下的节点，返回的是一个节点的集合\n    XmlNodeList xnl = doc.SelectNodes(\"/Order/items/OrderItem\");\n\t//遍历这个集合，并输出其中的值\n    foreach (XmlNode xn in xnl)\n    {\n        Console.WriteLine(xn.Attributes[\"Name\"].Value);\n        Console.WriteLine(xn.Attributes[\"Count\"].Value);\n    }\n    Console.ReadKey();\n}\n\n```\n\n\n\n\n\n## 删除节点\n\n```c#\nstatic void Main(string[] args)\n{\n    //创建xml对象并加载文档\n    XmlDocument doc = new XmlDocument();\n    doc.Load(@\"D:\\tmp\\Order.xml\");\n\n    //查找到指定的节点\n    XmlNode xn = doc.SelectSingleNode(\"/Order/items\");\n\n    //删除指定节点下的所有子节点\n    xn.RemoveAll();\n    doc.Save(@\"D:\\tmp\\Order2.xml\");\n    Console.ReadKey();\n}\n\n```\n\n\n\n\n\n\n\n\n\n## 注意事项\n\n- 当需要往节点中添加标签的时候，需要使用InnerXml属性添加。\n- 当要添加文本的时候，需要使用InnerText添加。\n- 区别：InnerText添加的时候会对一些特殊字符进行转义。\n\n\n\n\n\n\n\n# 对象的生存周期\n\n每一个对象都有一个明确的生命周期，除了\"正在使用\"的正常状态外，还有两个重要的阶段：\n\n- 构造阶段\n  - 第一次实例化一个对象时，需要初始化该对象。这个初始化过程称为构造阶段，由构造函数完成。\n- 析构阶段\n  - 在删除一个对象时，常常需要执行一些清理操作，如释放内存，这由析构函数完成。\n\n#### 构造函数\n\n对象的初始化过程是自动完成的，所有类定义都最少包含一个构造函数。\n\n在C#中，使用`new`关键字来调用构造函数。\n\n\n\n#### 析构函数\n\n​\t.NET Framework使用析构函数来清理对象。一般情况下，不需要提供析构函数的代码，而由默认的析构函数自动执行操作。但是，如果在删除对象实例前需要完成一些重要操作，就应提供具体的析构函数。\n\n​\t例如，如果变量超出了作用域,代码就不能访问它，但该变量仍存在于计算机内存的某个地方。只有在.NET运行程序执行其垃圾回收，进行清理时，该实例才被彻底删除。\n\n\n\n\n\n# C# 编码约定\n\n编码约定可实现以下目的：\n\n- 它们为代码创建一致的外观，以确保读取器专注于内容而非布局。\n- 它们使得读取器可以通过基于之前的经验进行的假设更快地理解代码。\n- 它们便于复制、更改和维护代码。\n- 它们展示 C# 最佳做法。\n\n\n\nMicrosoft 根据本文中的准则来开发样本和文档。 根据 [.NET 运行时 C# 编码样式](https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md)指南采用它们。 可使用它们，或者按照你的需求采用它们。 主要目标是在项目、团队、组织或公司源代码中实现一致性和可读性。\n\n\n\n## 简要\n\n### Pascal （大驼峰）命名方式\n\n命名空间、类、接口、抽象类、结构体、[枚举类](https://so.csdn.net/so/search?q=枚举类&spm=1001.2101.3001.7020)、方法名、以及类中的属性，须要使用 Pascal 命名规范；名称中每一个单词的首字母都要大写；\n\n###  Camel （小驼峰）命名方式\n\n方法参数、局部变量、以及私有的成员变量，须要使用 Camel 命名规范；名称中第一个单词是小写的，从第二个单词起，后面每一个单词的首字母都要大写；\n\n\n\n## 命名约定\n\n编写 C# 代码时需要考虑几个命名约定。\n\n在下面的示例中，在使用 `protected` 和 `protected internal` 元素时，还需遵守与标记了 `public` 的元素相关的任何指南 - 所有这些元素都旨在对外部调用方可见。\n\n\n\n### 帕斯卡拼写法(大驼峰)\n\n命名 `class`、`record` 或 `struct` 时，使用 pascal 大小写（“PascalCasing”）。\n\n```csharp\npublic class DataService\n{\n}\n```\n\n```csharp\npublic record PhysicalAddress(\n    string Street,\n    string City,\n    string StateOrProvince,\n    string ZipCode);\n```\n\n```csharp\npublic struct ValueCoordinate\n{\n}\n```\n\n命名 `interface` 时，使用 pascal 大小写并在名称前面加上前缀 `I`。 这可以清楚地向使用者表明这是 `interface`。\n\n```csharp\npublic interface IWorkerQueue\n{\n}\n```\n\n命名类型的 `public` 成员（例如字段、属性、事件、方法和本地函数）时，请使用 pascal 大小写。\n\n```csharp\npublic class ExampleEvents\n{\n    // A public field, these should be used sparingly\n    public bool IsValid;\n\n    // An init-only property\n    public IWorkerQueue WorkerQueue { get; init; }\n\n    // An event\n    public event Action EventProcessing;\n\n    // Method\n    public void StartEventProcessing()\n    {\n        // Local function\n        static int CountQueueItems() => WorkerQueue.Count;\n        // ...\n    }\n}\n```\n\n编写位置记录时，对参数使用 pascal 大小写，因为它们是记录的公共属性。\n\n```csharp\npublic record PhysicalAddress(\n    string Street,\n    string City,\n    string StateOrProvince,\n    string ZipCode);\n```\n\n有关位置记录的详细信息，请参阅[属性定义的位置语法](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/record#positional-syntax-for-property-definition)。\n\n\n\n### 驼峰式大小写（小驼峰）\n\n命名 `private` 或 `internal` 字段时，使用驼峰式大小写（“camelCasing”），并且它们以 `_` 作为前缀。\n\n```csharp\npublic class DataService\n{\n    private IWorkerQueue _workerQueue;\n}\n```\n\n在支持语句完成的 IDE 中编辑遵循这些命名约定的 C# 代码时，键入 `_` 将显示所有对象范围的成员。\n\n使用为 `private` 或 `internal` 的`static` 字段时 请使用 `s_` 前缀，对于线程静态，请使用 `t_`。\n\n```csharp\npublic class DataService\n{\n    private static IWorkerQueue s_workerQueue;\n\n    [ThreadStatic]\n    private static TimeSpan t_timeSpan;\n}\n```\n\n编写方法参数时，请使用驼峰式大小写。\n\n```csharp\npublic T SomeMethod<T>(int someNumber, bool isValid)\n{\n}\n```\n\n有关 C# 命名约定的详细信息，请参阅 [C# 编码样式](https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md)。\n\n### 其他命名约定\n\n- 在不包括 [using 指令](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/using-directive)的示例中，使用命名空间限定。 如果你知道命名空间默认导入项目中，则不必完全限定来自该命名空间的名称。 如果对于单行来说过长，则可以在点 (.) 后中断限定名称，如下面的示例所示。\n\n  ```csharp\n  var currentPerformanceCounterCategory = new System.Diagnostics.\n      PerformanceCounterCategory();\n  ```\n\n- 你不必更改使用 Visual Studio 设计器工具创建的对象的名称以使它们适合其他准则。\n\n\n\n## 布局约定\n\n好的布局利用格式设置来强调代码的结构并使代码更便于阅读。 Microsoft 示例和样本符合以下约定：\n\n- 使用默认的代码编辑器设置（智能缩进、4 字符缩进、制表符保存为空格）。 有关详细信息，请参阅[选项、文本编辑器、C#、格式设置](https://learn.microsoft.com/zh-cn/visualstudio/ide/reference/options-text-editor-csharp-formatting)。\n\n- 每行只写一条语句。\n\n- 每行只写一个声明。\n\n- 如果连续行未自动缩进，请将它们缩进一个制表符位（四个空格）。\n\n- 在方法定义与属性定义之间添加至少一个空白行。\n\n- 使用括号突出表达式中的子句，如下面的代码所示。\n\n  \n\n  ```csharp\n  if ((val1 > val2) && (val1 > val3))\n  {\n      // Take appropriate action.\n  }\n  ```\n\n\n\n## 将 using 指令放在命名空间声明之外\n\n当 `using` 指令位于命名空间声明之外时，该导入的命名空间是其完全限定的名称。 这样就比较清楚了。 如果 `using` 指令位于命名空间内部，它可以是相对于该命名空间的，也可以是完全限定的名称。 这容易说不清楚。\n\n```csharp\nusing Azure;\n\nnamespace CoolStuff.AwesomeFeature\n{\n    public class Awesome\n    {\n        public void Stuff()\n        {\n            WaitUntil wait = WaitUntil.Completed;\n            …\n        }\n    }\n}\n```\n\n假设存在对 [WaitUntil](https://learn.microsoft.com/zh-cn/dotnet/api/azure.waituntil) 类的引用（直接或间接）。\n\n现在，让我们稍作改动：\n\n```csharp\nnamespace CoolStuff.AwesomeFeature\n{\n    using Azure;\n    \n    public class Awesome\n    {\n        public void Stuff()\n        {\n            WaitUntil wait = WaitUntil.Completed;\n            …\n        }\n    }\n}\n```\n\n今天的编译成功了。 明天的也没问题。 但在下周的某个时候，此（保持不变）代码故障，并出现两个错误：\n\n控制台复制\n\n```console\n- error CS0246: The type or namespace name 'WaitUntil' could not be found (are you missing a using directive or an assembly reference?)\n- error CS0103: The name 'WaitUntil' does not exist in the current context\n```\n\n其中一个依赖项已在命名空间中引入了此类，然后以 `.Azure` 结尾：\n\n```csharp\nnamespace CoolStuff.Azure\n{\n    public class SecretsManagement\n    {\n        public string FetchFromKeyVault(string vaultId, string secretId) { return null; }\n    }\n}\n```\n\n放置在命名空间中的 `using` 指令与上下文相关，使名称解析复杂化。 在此示例中，它是它找到的第一个命名空间。\n\n- `CoolStuff.AwesomeFeature.Azure`\n- `CoolStuff.Azure`\n- `Azure`\n\n添加匹配 `CoolStuff.Azure` 或 `CoolStuff.AwesomeFeature.Azure` 的新命名空间将在全局 `Azure` 命名空间前匹配。 可以通过向 `using` 声明添加 `global::` 修饰符来解决此问题。 但是，改为将 `using` 声明放在命名空间之外更容易。\n\n```csharp\nnamespace CoolStuff.AwesomeFeature\n{\n    using global::Azure;\n    \n    public class Awesome\n    {\n        public void Stuff()\n        {\n            WaitUntil wait = WaitUntil.Completed;\n            …\n        }\n    }\n}\n```\n\n\n\n## 注释约定\n\n- 将注释放在单独的行上，而非代码行的末尾。\n\n- 以大写字母开始注释文本。\n\n- 以句点结束注释文本。\n\n- 在注释分隔符 (//) 与注释文本之间插入一个空格，如下面的示例所示。\n\n  \n\n  ```csharp\n  // The following declaration creates a query. It does not run\n  // the query.\n  ```\n\n- 请勿在注释周围创建格式化的星号块。\n\n- 请确保所有公共成员都有必要的 XML 注释，从而提供有关其行为的适当说明。\n\n\n\n## 语言准则\n\n以下各节介绍 C# 遵循以准备代码示例和样本的做法。\n\n\n\n### 字符串数据类型\n\n- 使用[字符串内插](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/tokens/interpolated)来连接短字符串，如下面的代码所示。\n\n  ```csharp\n  string displayName = $\"{nameList[n].LastName}, {nameList[n].FirstName}\";\n  ```\n\n- 若要在循环中追加字符串，尤其是在使用大量文本时，请使用 [StringBuilder](https://learn.microsoft.com/zh-cn/dotnet/api/system.text.stringbuilder) 对象。\n\n  ```csharp\n  var phrase = \"lalalalalalalalalalalalalalalalalalalalalalalalalalalalalala\";\n  var manyPhrases = new StringBuilder();\n  for (var i = 0; i < 10000; i++)\n  {\n      manyPhrases.Append(phrase);\n  }\n  //Console.WriteLine(\"tra\" + manyPhrases);\n  ```\n\n### 隐式类型本地变量\n\n- 当变量类型明显来自赋值的右侧时，或者当精度类型不重要时，请对本地变量进行[隐式类型化](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables)。\n\n  ```csharp\n  var var1 = \"This is clearly a string.\";\n  var var2 = 27;\n  ```\n\n- 当类型并非明显来自赋值的右侧时，请勿使用 [var](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/declarations#implicitly-typed-local-variables)。 请勿假设类型明显来自方法名称。 如果变量类型为 `new` 运算符或显式强制转换，则将其视为明显来自方法名称。\n\n  ```csharp\n  int var3 = Convert.ToInt32(Console.ReadLine()); \n  int var4 = ExampleClass.ResultSoFar();\n  ```\n\n- 请勿依靠变量名称来指定变量的类型。 它可能不正确。 在以下示例中，变量名称 `inputInt` 会产生误导性。 它是字符串。\n\n  ```csharp\n  var inputInt = Console.ReadLine();\n  Console.WriteLine(inputInt);\n  ```\n\n- 避免使用 `var` 来代替 [dynamic](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/reference-types)。 如果想要进行运行时类型推理，请使用 `dynamic`。 有关详细信息，请参阅[使用类型 dynamic（C# 编程指南）](https://learn.microsoft.com/zh-cn/dotnet/csharp/advanced-topics/interop/using-type-dynamic)。\n\n- 使用隐式类型化来确定 [`for`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement) 循环中循环变量的类型。\n\n  下面的示例在 `for` 语句中使用隐式类型化。\n\n  ```csharp\n  var phrase = \"lalalalalalalalalalalalalalalalalalalalalalalalalalalalalala\";\n  var manyPhrases = new StringBuilder();\n  for (var i = 0; i < 10000; i++)\n  {\n      manyPhrases.Append(phrase);\n  }\n  //Console.WriteLine(\"tra\" + manyPhrases);\n  ```\n\n- 不要使用隐式类型化来确定 [`foreach`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement) 循环中循环变量的类型。 在大多数情况下，集合中的元素类型并不明显。 不应仅依靠集合的名称来推断其元素的类型。\n\n  下面的示例在 `foreach` 语句中使用显式类型化。\n\n  ```csharp\n  foreach (char ch in laugh)\n  {\n      if (ch == 'h')\n          Console.Write(\"H\");\n      else\n          Console.Write(ch);\n  }\n  Console.WriteLine();\n  ```\n\n   备注\n\n  注意不要意外更改可迭代集合的元素类型。 例如，在 `foreach` 语句中从 [System.Linq.IQueryable](https://learn.microsoft.com/zh-cn/dotnet/api/system.linq.iqueryable) 切换到 [System.Collections.IEnumerable](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerable) 很容易，这会更改查询的执行。\n\n### 无符号数据类型\n\n通常，使用 `int` 而非无符号类型。 `int` 的使用在整个 C# 中都很常见，并且当你使用 `int` 时，更易于与其他库交互。\n\n### 数组\n\n当在声明行上初始化数组时，请使用简洁的语法。 在以下示例中，请注意不能使用 `var` 替代 `string[]`。\n\n```csharp\nstring[] vowels1 = { \"a\", \"e\", \"i\", \"o\", \"u\" };\n```\n\n如果使用显式实例化，则可以使用 `var`。\n\n```csharp\nvar vowels2 = new string[] { \"a\", \"e\", \"i\", \"o\", \"u\" };\n```\n\n### 委托\n\n使用 [`Func<>` 和 `Action<>`](https://learn.microsoft.com/zh-cn/dotnet/standard/delegates-lambdas)，而不是定义委托类型。 在类中，定义委托方法。\n\n```csharp\npublic static Action<string> ActionExample1 = x => Console.WriteLine($\"x is: {x}\");\n\npublic static Action<string, string> ActionExample2 = (x, y) => \n    Console.WriteLine($\"x is: {x}, y is {y}\");\n\npublic static Func<string, int> FuncExample1 = x => Convert.ToInt32(x);\n\npublic static Func<int, int, int> FuncExample2 = (x, y) => x + y;\n```\n\n使用 `Func<>` 或 `Action<>` 委托定义的签名来调用方法。\n\n```csharp\nActionExample1(\"string for x\");\n\nActionExample2(\"string for x\", \"string for y\");\n\nConsole.WriteLine($\"The value is {FuncExample1(\"1\")}\");\n\nConsole.WriteLine($\"The sum is {FuncExample2(1, 2)}\");\n```\n\n如果创建委托类型的实例，请使用简洁的语法。 在类中，定义委托类型和具有匹配签名的方法。\n\n```csharp\npublic delegate void Del(string message);\n\npublic static void DelMethod(string str)\n{\n    Console.WriteLine(\"DelMethod argument: {0}\", str);\n}\n```\n\n创建委托类型的实例，然后调用该实例。 以下声明显示了紧缩的语法。\n\n```csharp\nDel exampleDel2 = DelMethod;\nexampleDel2(\"Hey\");\n```\n\n以下声明使用了完整的语法。\n\n```csharp\nDel exampleDel1 = new Del(DelMethod);\nexampleDel1(\"Hey\");\n```\n\n\n\n### `try`-`catch` 和 `using` 语句正在异常处理中\n\n- 对大多数异常处理使用 [try-catch](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/try-catch) 语句。\n\n  ```csharp\n  static string GetValueFromArray(string[] array, int index)\n  {\n      try\n      {\n          return array[index];\n      }\n      catch (System.IndexOutOfRangeException ex)\n      {\n          Console.WriteLine(\"Index is out of range: {0}\", index);\n          throw;\n      }\n  }\n  ```\n\n- 通过使用 C# [using 语句](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/using-statement)简化你的代码。 如果具有 [try-finally](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/try-finally) 语句（该语句中 `finally` 块的唯一代码是对 [Dispose](https://learn.microsoft.com/zh-cn/dotnet/api/system.idisposable.dispose) 方法的调用），请使用 `using` 语句代替。\n\n  在以下示例中，`try`-`finally` 语句仅在 `finally` 块中调用 `Dispose`。\n\n  \n\n  ```csharp\n  Font font1 = new Font(\"Arial\", 10.0f);\n  try\n  {\n      byte charset = font1.GdiCharSet;\n  }\n  finally\n  {\n      if (font1 != null)\n      {\n          ((IDisposable)font1).Dispose();\n      }\n  }\n  ```\n\n  可以使用 `using` 语句执行相同的操作。\n\n  ```csharp\n  using (Font font2 = new Font(\"Arial\", 10.0f))\n  {\n      byte charset2 = font2.GdiCharSet;\n  }\n  ```\n\n  使用不需要大括号的新 [`using` 语法](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/using-statement)：\n\n  ```csharp\n  using Font font3 = new Font(\"Arial\", 10.0f);\n  byte charset3 = font3.GdiCharSet;\n  ```\n\n\n\n### `&&` 和 `||` 运算符\n\n若要通过跳过不必要的比较来避免异常并提高性能，请在执行比较时使用 [`&&`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#conditional-logical-and-operator-)（而不是 [`&`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#logical-and-operator-)）和 [`||`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#conditional-logical-or-operator-)（而不是 [`|`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#logical-or-operator-)），如下面的示例所示。\n\n```csharp\nConsole.Write(\"Enter a dividend: \");\nint dividend = Convert.ToInt32(Console.ReadLine());\n\nConsole.Write(\"Enter a divisor: \");\nint divisor = Convert.ToInt32(Console.ReadLine());\n\nif ((divisor != 0) && (dividend / divisor > 0))\n{\n    Console.WriteLine(\"Quotient: {0}\", dividend / divisor);\n}\nelse\n{\n    Console.WriteLine(\"Attempted division by 0 ends up here.\");\n}\n```\n\n如果除数为 0，则 `if` 语句中的第二个子句将导致运行时错误。 但是，当第一个表达式为 false 时，&& 运算符将发生短路。 也就是说，它并不评估第二个表达式。 如果 `divisor` 为 0，则 & 运算符将同时计算这两个表达式，这会导致运行时错误。\n\n### `new` 运算符\n\n- 使用对象实例化的简洁形式之一，如以下声明中所示。 第二个示例显示了从 C# 9 开始可用的语法。\n\n  ```csharp\n  var instance1 = new ExampleClass();\n  ```\n\n  ```csharp\n  ExampleClass instance2 = new();\n  ```\n\n  前面的声明等效于下面的声明。\n\n  ```csharp\n  ExampleClass instance2 = new ExampleClass();\n  ```\n\n- 使用对象初始值设定项简化对象创建，如以下示例中所示。\n\n  ```csharp\n  var instance3 = new ExampleClass { Name = \"Desktop\", ID = 37414,\n      Location = \"Redmond\", Age = 2.3 };\n  ```\n\n  下面的示例设置了与前面的示例相同的属性，但未使用初始值设定项。\n\n  ```csharp\n  var instance4 = new ExampleClass();\n  instance4.Name = \"Desktop\";\n  instance4.ID = 37414;\n  instance4.Location = \"Redmond\";\n  instance4.Age = 2.3;\n  ```\n\n### 事件处理\n\n如果你正在定义一个稍后不需要删除的事件处理程序，请使用 lambda 表达式。\n\n```csharp\npublic Form2()\n{\n    this.Click += (s, e) =>\n        {\n            MessageBox.Show(\n                ((MouseEventArgs)e).Location.ToString());\n        };\n}\n```\n\nLambda 表达式缩短了以下传统定义。\n\n```csharp\npublic Form1()\n{\n    this.Click += new EventHandler(Form1_Click);\n}\n\nvoid Form1_Click(object? sender, EventArgs e)\n{\n    MessageBox.Show(((MouseEventArgs)e).Location.ToString());\n}\n```\n\n\n\n### 静态成员\n\n使用类名调用 [static](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/static) 成员：ClassName.StaticMember。 这种做法通过明确静态访问使代码更易于阅读。 请勿使用派生类的名称来限定基类中定义的静态成员。 编译该代码时，代码可读性具有误导性，如果向派生类添加具有相同名称的静态成员，代码可能会被破坏。\n\n### LINQ 查询\n\n- 对查询变量使用有意义的名称。 下面的示例为位于西雅图的客户使用 `seattleCustomers`。\n\n  ```csharp\n  var seattleCustomers = from customer in customers\n                         where customer.City == \"Seattle\"\n                         select customer.Name;\n  ```\n\n- 使用别名确保匿名类型的属性名称都使用 Pascal 大小写格式正确大写。\n\n  ```csharp\n  var localDistributors =\n      from customer in customers\n      join distributor in distributors on customer.City equals distributor.City\n      select new { Customer = customer, Distributor = distributor };\n  ```\n\n- 如果结果中的属性名称模棱两可，请对属性重命名。 例如，如果你的查询返回客户名称和分销商 ID，而不是在结果中将它们保留为 `Name` 和 `ID`，请对它们进行重命名以明确 `Name` 是客户的名称，`ID` 是分销商的 ID。\n\n  ```csharp\n  var localDistributors2 =\n      from customer in customers\n      join distributor in distributors on customer.City equals distributor.City\n      select new { CustomerName = customer.Name, DistributorID = distributor.ID };\n  ```\n\n- 在查询变量和范围变量的声明中使用隐式类型化。\n\n  ```csharp\n  var seattleCustomers = from customer in customers\n                         where customer.City == \"Seattle\"\n                         select customer.Name;\n  ```\n\n- 对齐 [`from`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/from-clause) 子句下的查询子句，如上面的示例所示。\n\n- 在其他查询子句前面使用 [`where`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/where-clause) 子句，确保后面的查询子句作用于经过缩减和筛选的一组数据。\n\n  ```csharp\n  var seattleCustomers2 = from customer in customers\n                          where customer.City == \"Seattle\"\n                          orderby customer.Name\n                          select customer;\n  ```\n\n- 使用多行 `from` 子句代替 [`join`](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/join-clause) 子句来访问内部集合。 例如，`Student` 对象的集合可能包含测验分数的集合。 当执行以下查询时，它返回高于 90 的分数，并返回得到该分数的学生的姓氏。\n\n  ```csharp\n  var scoreQuery = from student in students\n                   from score in student.Scores!\n                   where score > 90\n                   select new { Last = student.LastName, score };\n  ```\n\n\n\n## 安全性\n\n请遵循[安全编码准则](https://learn.microsoft.com/zh-cn/dotnet/standard/security/secure-coding-guidelines)中的准则。\n\n## 请参阅\n\n- [.NET 运行时编码准则](https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md)\n- [Visual Basic 编码约定](https://learn.microsoft.com/zh-cn/dotnet/visual-basic/programming-guide/program-structure/coding-conventions)\n- [安全编码准则](https://learn.microsoft.com/zh-cn/dotnet/standard/security/secure-coding-guidelines)\n\n\n\n\n# 附录\n\n## XXX.ToString 格式化数值结果表\n\n| 格式说明符 | 说明     | 示例                   | 输出          |\n| ---------- | -------- | ---------------------- | ------------- |\n| C          | 货币     | 15.ToString(“C”)       | ￥15.00       |\n|            |          | 15.ToString(“C1”)      | ￥15.0        |\n|            |          | 15.ToString(“C3”)      | ￥15.000      |\n| D          | 十进制数 | 15.ToString(“D1”)      | 15            |\n|            |          | 15.ToString(“D2”)      | 15            |\n|            |          | 15.ToString(“D5”)      | 00015         |\n| E          | 科学型   | 15.ToString(“E”)       | 1.500000E+001 |\n|            |          | 1500.ToString(“E”)     | 1.500000E+003 |\n|            |          | 0.15.ToString(“E”)     | 1.500000E-001 |\n|            |          | 0.0015.ToString(“E”)   | 1.500000E-003 |\n|            |          | 0.0015.ToString(“E0”)  | 2E-003        |\n|            |          | 0.0015.ToString(“E1”)  | 1.5E-003      |\n|            |          | 0.0015.ToString(“E2”)  | 1.50E-003     |\n| F          | 固定点   | 15.ToString(“F1”)      | 15.0          |\n|            |          | 15.ToString(“F2”)      | 15.00         |\n| G          | 常规     | 2.5.ToString(“G”)      | 2.5           |\n| N          | 数字     | 1500000.ToString(“N”)  | 1,500,000.00  |\n|            |          | 1500000.ToString(“N0”) | 1,500,000     |\n|            |          | 1500000.ToString(“N1”) | 1,500,000.0   |\n| X          | 十六进制 | 15.ToString(“X”)       | F             |\n|            |          | 15.ToString(“X3”)      | 00F           |\n\n\n\n\n\n## String.Format 格式化数值结果表\n\n| 字符 | 说明             | 示例                               | 输出       |\n| ---- | ---------------- | ---------------------------------- | ---------- |\n| C    | 货币             | string.Format(\"{0:C3}\", 2)         | ＄2.000    |\n| D    | 十进制           | string.Format(\"{0:D3}\", 2)         | 002        |\n| E    | 科学计数法       | 1.20E+001                          | 1.20E+001  |\n| G    | 常规             | string.Format(\"{0:G}\", 2)          | 2          |\n| N    | 用分号隔开的数字 | string.Format(\"{0:N}\", 250000)     | 250,000.00 |\n| X    | 十六进制         | string.Format(\"{0:X000}\", 12)      | C          |\n| 0    | 零占位符         | string.Format(\"{0:000.000}\", 12.3) | 012.300    |\n| #    | 数字占位符       | String.Format(\"{0:#}\", 12.3)       | 12         |\n|      |                  | String.Format(\"{0:##}\", 12.3)      | 12         |\n|      |                  | String.Format(\"{0:###}\", 12.3)     | 12         |\n|      |                  | String.Format(\"{0:###.#}\", 12.3)   | 12.3       |\n\n\n\n\n\n\n\n## String.Format 自定义模式输出\n\n1. “0”描述：占位符，如果可能，填充位\n\n```c#\nString.Format(\"{0:000000}\", 1234);  // 结果：001234\n```\n\n2. “#”描述：占位符，如果可能，填充位\n\n```c#\nString.Format(\"{0:######}\", 1234);  // 结果：1234\nString.Format(\"{0:#0####}\", 1234);  // 结果：01234\nString.Format(\"{0:0#0####}\", 1234);  // 结果：0001234\n```\n\n3. \".\"描述：小数点\n\n```c#\nString.Format(\"{0:000.000}\", 1234);  // 结果：1234.000\nString.Format(\"{0:000.000}\", 4321.12543);  // 结果：4321.125\n```\n\n4. \",\"描述：数字分组，也用于增倍器\n\n```c\nString.Format(\"{0:0,0}\", 1234567);  // 结果：1,234,567\n```\n\n5. \"%\"描述：格式为百分数\n\n```c#\nString.Format(\"{0:0%}\", 1234);  // 结果：123400%\nString.Format(\"{0:#%}\", 1234.125);  // 结果：123413%\nString.Format(\"{0:0.00%}\", 1234);  // 结果： 123400.00%\nString.Format(\"{0:#.00%}\", 1234.125);  // 结果：123412.50%\n```\n\n6. \"abc\"描述：显示单引号内的文本\n\n```c#\nString.Format(\"{0:'文本'0}\", 1234);  // 结果：文本1234\n```\n\n7. \"\"描述：用于转移符\n\n```c#\nString.Format(\"\\\"abc!\\\"\");  // 结果：abc!\n```\n\n8. c\"@\"描述：后跟要打印字符串c\n\n```c#\nString.Format(@\"\"abc!\"\");  // 结果：abc! \n```\n\n\n\n# c#的一些小样例 \n\n\n\n## 读取键盘输入的值到变量\n\n**System** 命名空间中的 **Console** 类提供了一个函数 **ReadLine()**，用于接收来自用户的输入，并把它存储到一个变量中。\n\n例如：\n\n```\nint num;\nnum = Convert.ToInt32(Console.ReadLine());\n```\n\n函数 **Convert.ToInt32()** 把用户输入的数据转换为 int 数据类型，因为 **Console.ReadLine()** 只接受字符串格式的数据。\n\n## c#指针\n\nc#是可以用指针的，但不推荐。如果必须要使用，则需要在这段程序的前面加上修饰符`unsafe`，表示在书写不安全的代码。\n\n同时可能还需要在visual studio的项目-项目属性-生成（build）勾选上允许不安全代码。\n\n这样：\n\n```c#\npublic class Test\n    {\n        public unsafe void Fun()\n        {\n            int a = 10;\n            int* p = &a;\n            Console.WriteLine(*p);\n        }\n    }\n```\n\n或这样：把涉及到指针的代码放到一个代码块内，然后声明这个代码块是不安全的\n\n```c#\npublic  void Fun()\n        {\n            int a = 10;\n            unsafe\n            {\n                int* p = &a;\n                Console.WriteLine(*p);\n            }            \n            \n        }\n```\n\n\n\n\n\n## 强制分配数组在栈空间中\n\n```c#\n    public class Test\n    {\n        public  void Fun()\n        {\n            int[] a = new int[10];//正常的创建一个数组\n            unsafe\n            {\n                int* b = stackalloc int[10];//强制的在栈上创建一个数组\n            }\n        }\n    }\n```\n\n\n\n\n\n## 常量和只读字段的区别\n\n- 常量隶属于类,而不是对象,即没有\"实例常量\"\n- \"实例常量\"的角色由只读实例字段担当\n\n\n\n### 常见的应用场景\n\n- 为了提高程序可读性和执行效率 ==> 常量\n- 为了防止对象的值被改变 ==> 只读字段\n- 向外暴露不允许修改的数据 ==> 只读属性(静态或非静态), 功能与常量有一些重叠\n- 当希望成为常量的值其类型不能被常量声明接收时(类/自定义结构体) ==> 静态只读字段 (这句话太绕了)\n\n\n\n```c#\nnamespace ConsoleApp1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(Web.WebsiteURL);\n\n            Web web = new Web();\n            Console.WriteLine(web.version);\n        }\n    }\n\n    class Web\n    {\n    \t// 常量\n        public const string WebsiteURL = \"http://www.baidu.com\";\n        // 只读字段\n        public readonly string version = \"1.0.0\";\n    }\n}\n```\n\n\n\n\n\n\n\n## 各种“只读”的应用场景\n\n为了提高程序的可读性和执行效率——常量\n\n为了放置对象的值被修改——只读字段\n\n向外暴露不允许修改的数据——只读属性\n\n当希望成为常量的值其类型不能被常量声明接受时（类/自定义结构）——静态只读字段（常量只能是基本数据类型）\n\n\n\n\n\n\n\n\n\n\n\n## 值类型和值参数的区别\n\n值参数是一个变量，他有值类型和引用类型两种。\n\n值类型在作为参数传递进方法的时候是复制传入\n\n\n\n\n\n## 判断两个对象是否是同一个\n\n因为在c#中，所有的类都继承于Object，而object具有一个方法，就是GetHashCode。\n\nGetHashCode获取到的值类似于对象的指纹，每一个对象都具有不同的hash\n\nGetHashCode获取到的值是一个32位有符号整型。（有疑问，为什么是32位？是因为编译出来的是32位的应用吗）\n\n```c#\nstring s = \"hurr\";\nConsole.WriteLine(s.GetHashCode());//获取并输出s字符串的hash\n```\n\n\n\n\n\n## TryParse类型转换\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n\n        static void Main(string[] args)\n        {\n            string s;\n            s = \"123.45.6\";\n            double d = -1;\n            if (double.TryParse(s, out d))//尝试的转换，如果转换成功，则返回true，否则为false。同时转换完成的值以输出参数的形式带出\n                Console.WriteLine(\"转换成功\");\n            else\n                Console.WriteLine(\"转换失败\");\n\n            Console.WriteLine(\"转换完成的值是：{0}\", d);\n\n            Console.ReadLine();\n        }\n    }\n}\n```\n\n\n\n\n\n## 使用Split方法使得string字符串进行按指定符号分割。\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Policy;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ShowInfos;\nnamespace ConsoleApp\n{\n    internal class Program\n    {\n\n        static void Main(string[] args)\n        {\n            string str = \"tim,hurrr;amy.Lisa\";//一个字符串，里面存在多个符号\n            string[] res = str.Split(',', ';', '.');//用string类自带的Split方法，指出其中的符号，并存到一个string数组中返回\n            foreach(var item in res)//遍历分割完的字符串\n            {\n                Console.WriteLine(item);\n            }\n            Console.ReadLine();\n        }\n        \n    }\n}\n```\n\n\n\n\n\n## string的花样玩法：深入理解C# 中 “$” 符号的作用以及用法 \n\n前言：`$`是c# 6.0 的语言特性，功能类似`string.format()`，更方便的地方在于不要像`format`一样使用索引，可以直接使用变量、表达式或者方法的执行。\n\n\n\n### C#中`$`的作用\n\n谈及这个`$`，其实它是C#6.0语法中模板字符串的一种写法，什么是模版字符串？还记得你们用过的格式化字符串吗？`string.Format()` 这个方法，是最常用的方法之一。\n\n那`$`又是什么呢？它是为了替代`string.format()`的，原先赋值需要占位符和变量，当需要拼接多个变量会造成语句过长等不易理解问题。\n\n`$`是为了替代`string.format()`，可以把字符串中的C#变量`{}`包含起来达到识别C#变量的目的`$\"{id}\"`；也支持表达式，使用`$\"{(你的表达式)}\"`；或者方法的执行，使用`$\"{(方法)}\"`。\n\n### C#中`$`的用法\n\nC# 中`$`符号的作用是C#6.0中新出现的一个特性，也即是字符串的拼接优化。\n\n#### 语法格式\n\n```c#\n$\"string {参数}\"\n```\n\n解释：以`$`符号开头开始字符串，其中以`{}`来进行传参，可以多个参数累加。\n\n例如:\n\n```c#\nvar results = $\"Hello {Name}\";\n```\n\n\n\n### `$`的示例\n\n```csharp\nvar str = string.Format(\"我的名字叫{1}，我今年{1}岁。\", \"张三\", 23);\nConsole.WriteLine(str);\n```\n\n这是我们使用`string.format()`的写法，下来我们使用`$`改写一下。\n\n```csharp\nvar str = $\"我的名字叫{\"张三\"}，我今年{23}岁。\";\nConsole.WriteLine(str);\n12\n```\n\n通过上面这个案例，我们发现，现在使用`$`代码简洁，可读性强。\n\n可能有些朋友觉得效果不太明显，那么请看下面这个案例：\n\n```csharp\nvar name = \"张三\";\nvar age = 23;\nvar sex = \"男\";\nvar message = string.Format(\"我叫{0},我的年龄为{1},我的性别是{2}\", name, age, sex);\nvar show = $\"我叫{name},我的年龄为{age},我的性别是{sex}\";\nConsole.WriteLine(message);\nConsole.WriteLine(show);\n1234567\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200610092838146.png)\n如果还感受不到，那么请你试想一下：如果我们要操作的数据很多，假设它是一个多条的SQL语句，那么在长篇字符串中定位索引，那是不是很累啊！纵使你写对了索引（没写对还得一个个检查、修改），好不容易完工了。但下一个需求让你加两个参数，你的索引位置又得变，还得在万码丛中查找你原来索引在哪里的，是不是很恶心？\n\n哈哈，不用沮丧，此时C#6.0模版字符串就可以闪亮登场啦！\n\n\n\n怎么用？总结一下，就是在字符串的双引号前面加一个 $ 符号，在需要使用变量的地方用{变量}就可以了。这个在我们上面的案例中，也有体现。\n\n\n\n### 关于`$`的补充知识\n\n正如我们上面所说，`{变量}`表示在字符串中输出变量的值，当然`{}`中间也可以是一个表达式或者方法的执行。\n\n```csharp\n$\"我的姓名是{GetName()}\";\n$\"name的类型是{name.GetType()}\";\n12\n```\n\n如上，这样就很方便，帅气了！那么变量和索引可以混用吗？当然也是可以的，如下：\n\n```csharp\nvar name = \"张三\";\nvar age = 23;\nvar sex = \"男\";\nvar show = string.Format($\"我是{name}，今年{age}，家住在{{0}}\", sex); \nConsole.WriteLine(show);\n12345\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200610094030175.png)\n\n> 要注意的是需要用两次大括号 `{{}}` 将索引包含起来，也就是这样的形式，`\"({*2)索引(}*2)\"`。因为一次是输出表达式，两次就转义成普通的占位符了，这点一定要注意！\n\n\n\n\n## 查询枚举类型是否包含具有特定关联值的枚举成员\n\n使用Enum.IsDefined 方法\n\n如：\n\n```c#\nusing System;\nusing System.Windows.Diagnostics;\nusing System.Windows.Forms;\nnamespace ConsoleApp\n{\n\n    public enum Season\n    {\n        Spring,\n        Summer,\n        Autumn,\n        Winter\n    }\n\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            var c = (Season)4;\n            Console.WriteLine(c);  // output: 4\n            Console.WriteLine(c.GetType());//output：ConsoleApp.Season\n            Console.WriteLine(Enum.IsDefined(typeof(Season),4));//false\n            Console.ReadKey();\n        }\n    }\n}\n```\n\n\n\n\n\n## 添加引用依赖：类库\n\n![image-20230306082409521](./Image/C#学习笔记_基础教程.assets/image-20230306082409521.png)\n\n纠错：\n\n​\t如果是别人编写的dll，不是微软自带的，需要在最下方的浏览中添加进来。而不是在程序集中添加。\n\n\n\n\n\n## MD5转换\n\n```c#\nusing System;\nusing System.Collections;\nusing System.ComponentModel;\nusing System.IO;\nusing System.Security.Cryptography;\nusing System.Text;\n\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(GetMD5(\"123\"));\n        }\n\n        public static string GetMD5(string str)\n        {\n            //将目标字符串转换成字节\n            byte[] buffer = Encoding.UTF8.GetBytes(str);\n\n            // 创建MD5对象\n            MD5 md5 = MD5.Create();\n            byte[] MD5Buffer =  md5.ComputeHash(buffer);\n\n            string strmd5 = \"\";\n            //将加密完成的字节数组转换成字符串\n            for(int i = 0; i < MD5Buffer.Length; i++)\n            {\n                strmd5 += MD5Buffer[i].ToString(\"x\");//注意需要转换成16进制。默认是10进制\n            }\n\n            return strmd5;\n        }\n    }\n\n}\n\n```\n\n\n\n\n\n# 对于使用.Net FrameWork的控制台应用程序，调用From窗体。\n\n1. 引入依赖\n   1. 右击引用，选择添加引用![image-20230517150043313](./Image/C#学习笔记_基础教程.assets/image-20230517150043313.png)\n   2. 找到System.Windwos.Forms，选择确认加入引用![image-20230517150238641](./Image/C#学习笔记_基础教程.assets/image-20230517150238641.png)\n   3. 使用using语句引用导入的forms。如果这一步报错，则表示上一步的引入没引成功。![image-20230517150336335](./Image/C#学习笔记_基础教程.assets/image-20230517150336335.png)\n2. 实例化Form对象，然后ShowDialog显示出来。\n\n\n\n\n\n\n# 存在的问题\n\nstring的比较，能否直接用`==`。\n\n输入一个string的字符串，假设输入的值与待比较的值相等，`==`是否可以进行比较。\n\n```c#\nstring str;\nstr = Console.ReadLine();//假设输入hurr\nif(str.ToLower() == \"hurr\")//true or false？\n```\n\n在c#中string也是引用类型，因此str是一个4字节的变量，而输入的文本存储在堆中，`==`运算符是否可以比较存储的值而不是变量的值。\n\n\n\n属性与类的关系\n\n完整声明中的private部分，是否可以是为一个动态计算值的属性？\n\n\n\n\n\n\n\nc#索引器\n\n一个类只能有一个list？\n\n是否需要单独拎出一个类作为属性类来实现？是否增加了耦合？就像在当前类中new另外一个类\n\n\n\n\n\n\n\n\n\n委托中组合委托（组播）的用途？引用场景？\n\n委托的用途：常见的使用场景？\n\n自定义委托相比Action或Func有什么特点？或者是有什么不可替代性？\n\n\n\n\n\n枚举中：作为位标志的枚举类型的部分\n\n\n\n\n\nc#的锯齿数组与c++中的数组指针的区别\n\n\n\nc#中是否存在着：不使用Main方法作为入口点。如像在c++中的 `static int s = execute();`这样的语句，在main前面，初始化静态变量的时候调用第三方函数，使得第三方函数的运行在main前。\n\n\n\n\n\n方法参数中的引用参数，ref修饰符在public的位置时，表示的是什么意思？（p86）\n\nref在参数前面，表示的是指定的参数是引用参数，在声明和调用的时候要在参数前面加上ref修饰符；\n\n如果这样，ref此时表示什么意思？\n\n```c#\nstatic ref int ReturnByRef()\n{\n    int[] arr = { 2 };\n    return ref arr[0];\n}\n\n```\n\n\n\n\n\n\n\n接口\n\n当一个类实现了多个接口的时候，是不是必须显式实现接口？\n\n\n\n\n\n\n\n\n\nc#中的GetHashCode\n\n[在C#中，GetHashCode()方法是用来返回一个对象的哈希码，也就是一个整数值，用于表示对象的内容或状态](https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=net-8.0)[1](https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=net-8.0)[。GetHashCode()方法可以返回负值，因为它没有限制哈希码的范围](https://stackoverflow.com/questions/9084735/will-string-gethashcode-return-negative-value)[2](https://stackoverflow.com/questions/9084735/will-string-gethashcode-return-negative-value)[。GetHashCode()方法只要求相等的对象返回相同的哈希码，但不要求不相等的对象返回不同的哈希码](https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=net-8.0)[1](https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=net-8.0)[3](https://learn.microsoft.com/en-us/dotnet/api/system.string.gethashcode?view=net-8.0)[。因此，GetHashCode()方法返回的值不能用来判断对象是否相等，也不能用来存储或比较数据](https://stackoverflow.com/questions/9084735/will-string-gethashcode-return-negative-value)[2](https://stackoverflow.com/questions/9084735/will-string-gethashcode-return-negative-value)[3](https://learn.microsoft.com/en-us/dotnet/api/system.string.gethashcode?view=net-8.0)[。GetHashCode()方法只能用来优化一些数据结构或算法，例如哈希表或字典](https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=net-8.0)[1](https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=net-8.0)。\n\ngethashcode是否能可靠的判断两个对象是否相等？\n\n\n\n\n\n\n\n\n\n如何判断两个对象是否相等。\n\n[在C#中，判断两个对象是否相等有多种方法，取决于你想要比较的是对象的引用还是值。](https://www.educba.com/c-sharp-object-compare/)[1](https://www.educba.com/c-sharp-object-compare/)\n\n[如果你想要比较两个对象的引用，也就是说，它们是否指向同一个内存地址，你可以使用`Object.ReferenceEquals`方法或者`==`运算符（如果该类型重载了该运算符）。](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/equality-operators)[2](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/equality-operators)\n\n[如果你想要比较两个对象的值，也就是说，它们是否具有相同的属性和字段，你可以使用`Object.Equals`方法或者`IEquatable`接口（如果该类型实现了该接口）。](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/equality-operators)[2](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/equality-operators)\n\n[另外，你也可以使用反射来遍历两个对象的所有属性，并返回它们之间的差异。](https://stackoverflow.com/questions/4951233/compare-two-objects-and-find-the-differences)[3](https://stackoverflow.com/questions/4951233/compare-two-objects-and-find-the-differences)[4](https://stackoverflow.com/questions/2920399/c-sharp-how-to-find-if-two-objects-are-equal)\n\n\n\n","tags":["protected","基础教程","CSharp"],"categories":["CSharp"]},{"title":"C++ STL学习笔记","url":"/2023/01/08/C++STL学习笔记/","content":"\n# STL概论\n\n​\t\t为了建立数据结构和算法的一套标准，并且降低他们之间的耦合关系，以提升各自的独立性、弹性、交互操作性(相互合作性,interoperability),诞生了STL。\n\n\n\n## STL基本概念\n\n​\tSTL(Standard Template Library,标准模板库)，是惠普实验室开发的一系列软件的统称。现在主要出现在 c++中，但是在引入 c++之前该技术已经存在很长时间了。\n\n​\tSTL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator),容器和算法之间通过迭代器进行无缝连接。\n\n## STL六大组件简介\n\n​\tSTL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。\n\n- 容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。\n- 算法：各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.\n- 迭代器：扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-> , operator++,operator--等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。\n- 仿函数：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template\n- 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。\n- 空间配置器：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.\n\n\n​\tSTL六大组件的交互关系：容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。\n\n\n\n## STL优点\n\n​\tSTL 是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。\n​\tSTL 的一个重要特性是将**数据和操作**分离。**数据由容器类别加以管理**，操**作则由可定制的算法定义**。**迭代器在两者之间充当“粘合剂**”,以使算法可以和容器交互运作\n\n​\tSTL 具有高可重用性，高性能，高移植性，跨平台的优点。\n\n- 高可重用性：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。\n- 高性能：如 map 可以高效地从十万条记录里面查找出指定的记录，因为 map 是采用红黑树的变体实现的。\n- 高移植性：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。\n\n\n\n# STL三大组件\n\n## 容器\n\n​\t容器，置物之所也。\n\n​\t研究数据的特定排列方式，以利于搜索或排序或其他特殊目的，这一门学科我们称为数据结构。STL容器就是将运用最广泛的一些数据结构实现出来。\n常用的数据结构：数组(array),链表(list),tree(树)，栈(stack),队列(queue),集合(set),映射表(map),根据数据在容器中的排列特性，这些数据分为序列式容器和关联式容器两种。\n\n- 序列式容器强调值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。\n- 关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。**关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。**Set/multiset容器 Map/multimap容器\n\n\n\n## 算法\n\n​\t算法，问题之解法也。\n\n​\t以有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms).\n\n​\t算法分为:质变算法和非质变算法。\n\n- 质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等\n- 非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等\n\n\n\n\n\n## 迭代器\n\n​\t迭代器(iterator)是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。\n\n​\t在《Design Patterns》一书中提供了23中设计模式的完整描述，其中iterator模式定义如下：**提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式**。\n\n​\t迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器(container)和算法(algorithms)分开，彼此独立设计，最后再一贴胶着剂将他们撮合在一起。从技术角度来看，容器和算法的泛型化并不困难，c++的class template和function template可分别达到目标，如果设计出两这个之间的良好的胶着剂，才是大难题。\n\n迭代器的种类:\n\n- 输入迭代器 提供对数据的只读访问 只读，支持++、==、！=\n- 输出迭代器 提供对数据的只写访问 只写，支持++\n- 前向迭代器 提供读写操作，并能向前推进迭代器 读写，支持++、==、！=\n- 双向迭代器 提供读写操作，并能向前和向后操作 读写，支持++、--，\n- 随机访问迭代器 提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器 读写，支持++、--、[n]、-n、<、<=、>、>=\n\n### 案例\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n//STL 中的容器 算法 迭代器\nvoid test01() {\n\tvector<int> v; //STL 中的标准容器之一 ：动态数组\n\tv.push_back(1); //vector 容器提供的插入数据的方法\n\tv.push_back(5);\n\tv.push_back(3);\n\tv.push_back(7);\n\t//迭代器\n\tvector<int>::iterator pStart = v.begin(); //vector 容器提供了 begin()方法 返回指向第一个元素的迭代器\n\tvector<int>::iterator pEnd = v.end(); //vector 容器提供了 end()方法 返回指向最后一个元素下一个位置的迭代器\n\t//通过迭代器遍历\n\twhile (pStart != pEnd) {\n\t\tcout << *pStart << \" \";\n\t\tpStart++;\n\t}\n\tcout << endl;\n\t//算法 count 算法 用于统计元素的个数\n\tint n = count(pStart, pEnd, 5);\n\tcout << \"n:\" << n << endl;\n}\n//STL 容器不单单可以存储基础数据类型，也可以存储类对象\nclass Teacher\n{\npublic:\n\tTeacher(int age) :age(age) {};\n\t~Teacher() {};\npublic:\n\tint age;\n};\nvoid test02() {\n\tvector<Teacher> v; //存储 Teacher 类型数据的容器\n\tTeacher t1(10), t2(20), t3(30);\n\tv.push_back(t1);\n\tv.push_back(t2);\n\tv.push_back(t3);\n\tvector<Teacher>::iterator pStart = v.begin();\n\tvector<Teacher>::iterator pEnd = v.end();\n\t//通过迭代器遍历\n\twhile (pStart != pEnd) {\n\t\tcout << pStart->age << \" \";\n\t\tpStart++;\n\t}\n\tcout << endl;\n}\n//存储 Teacher 类型指针\nvoid test03() {\n\tvector<Teacher*> v; //存储 Teacher 类型指针\n\tTeacher* t1 = new Teacher(10);\n\tTeacher* t2 = new Teacher(20);\n\tTeacher* t3 = new Teacher(30);\n\tv.push_back(t1);\n\tv.push_back(t2);\n\tv.push_back(t3);\n\t//拿到容器迭代器\n\tvector<Teacher*>::iterator pStart = v.begin();\n\tvector<Teacher*>::iterator pEnd = v.end();\n\t//通过迭代器遍历\n\twhile (pStart != pEnd) {\n\t\tcout << (*pStart)->age << \" \";\n\t\tpStart++;\n\t}\n\tcout << endl;\n}\n//容器嵌套容器 难点(不理解，可以跳过)\nvoid test04()\n{\n\tvector< vector<int> > v;\n\tvector<int>v1;\n\tvector<int>v2;\n\tvector<int>v3;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tv1.push_back(i);\n\t\tv2.push_back(i * 10);\n\t\tv3.push_back(i * 100);\n\t}\n\tv.push_back(v1);\n\tv.push_back(v2);\n\tv.push_back(v3);\n\tfor (vector< vector<int> >::iterator it = v.begin(); it != v.end(); it++)\n\t{\n\t\tfor (vector<int>::iterator subIt = (*it).begin(); subIt != (*it).end(); subIt++)\n\t\t{\n\t\t\tcout << *subIt << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\nint main() {\n\t//test01();\n\t//test02();\n\t//test03();\n\ttest04();\n\tsystem(\"pause\");\n\treturn EXIT_SUCCESS;\n}\n```\n\n\n\n\n\n# 常用容器\n\n## string容器\n\n### string容器基本概念\n\n​\tC风格字符串(以空字符结尾的字符数组)太过复杂难于掌握，不适合大程序的开发，所以C++标准库定义了一种string类，定义在头文件`<string>`。\n\n​\tString和c风格字符串对比：\n\n- Char*是一个指针，String是一个类\n  - string封装了`char*`，管理这个字符串，是一个`char*`型的容器。\n- String封装了很多实用的成员方法\n  查找find，拷贝copy，删除delete 替换replace，插入insert\n- 不用考虑内存释放和越界\n  string管理`char*`所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。\n\n### string容器常用操作\n\n#### string 构造函数\n\n```cpp\nstring();//创建一个空的字符串 例如: string str; \nstring(const string& str);//使用一个string对象初始化另一个string对象\nstring(const char* s);//使用字符串s初始化\nstring(int n, char c);//使用n个字符c初始化 \n```\n\n#####\n\n```cpp\n/// <summary>\n/// 构造演示\n/// </summary>\nvoid t1()\n{\n\tstring s1;//创建一个空字符串\n\tstring s2(s1);//拷贝构造，s2在初始化的时候初始化成值与s1相同的一个容器。\n\tstring s3(\"hurriedlu\");//有参构造，在初始化的时候将字符串的值赋给s3。这里也可以是char型数组。\n\tstring s4(10, 'a');//双参数有参构造。把n个字符c赋值给s4；\n\n\tcout << s3 << endl;\n\tcout << s4 << endl;\n\tcout << endl << endl;\n}\n```\n\n\n\n#### string基本赋值操作\n\n```cpp\nstring& operator=(const char* s);//char*类型字符串 赋值给当前的字符串\nstring& operator=(const string &s);//把字符串s赋给当前的字符串\nstring& operator=(char c);//字符赋值给当前的字符串\nstring& assign(const char *s);//把字符串s赋给当前的字符串\nstring& assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串\nstring& assign(const string &s);//把字符串s赋给当前字符串\nstring& assign(int n, char c);//用n个字符c赋给当前字符串\nstring& assign(const string &s, int start, int n);//将s从start开始n个字符赋值给字符串\n```\n\n##### 样例\n\n```cpp\n/// <summary>\n/// 基本赋值\n/// </summary>\nvoid t2()\n{\n\tstring s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\ts1 = s2;//直接赋值\n\ts2 = \"hurriedlu\";//字符串直接赋值\n\ts3 = 'a';//字符赋值\n\ts4.assign(\"hello world\");//利用内部函数进行赋值\n\ts5.assign(\"hello world\", 5);//指定只复制前n个，此处为hello。也可以不是字符串是另一个string容器。\n\ts6.assign(10, 'a');//用n个字符c赋给当前字符串\n\ts7.assign(s4, 4, 3); //将s从start开始n个字符赋值给字符串。start从0起，包括start。\n\tcout << s7 << endl;\n}\n```\n\n\n\n#### string存取字符操作\n\n```cpp\nchar& operator[](int n);//通过[]方式取字符\nchar& at(int n);//通过at方法获取字符\n```\n\n##### 样例\n\n```cpp\nvoid t3()\n{\n\tstring s1 = \"Hi!\";\n\tcout << s1[0] << \" \";//通过[]方式取字符\n\tcout << s1.at(1) << endl;//通过at方法获取字符\n}\n```\n\n##### 区别：\n\n[]访问越界会直接挂掉；而at()会抛出一个异常（out_of_range）。\n\n\n\n\n\n#### string拼接操作\n\n```cpp\nstring& operator+=(const string& str);//重载+=操作符\nstring& operator+=(const char* str);//重载+=操作符\nstring& operator+=(const char c);//重载+=操作符\nstring& append(const char *s);//把字符串s连接到当前字符串结尾\nstring& append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾\nstring& append(const string &s);//同operator+=()\nstring& append(const string &s, int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾\nstring& append(int n, char c);//在当前字符串结尾添加n个字符c\n```\n\n\n\n##### 样例\n\n```cpp\nvoid t4()\n{\n\tstring s1, s2;\n\ts1 = \"hello\";\n\ts2 = \"world\";\n\ts1 += s2;//s1 = \"helloworld\";\n\ts1 += \"!\";//s1 = \"helloworld!\";\n}\n```\n\n\n\n##### string查找和替换\n\n```cpp\nint find(const string& str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找\nint find(const char* s, int pos = 0) const;  //查找s第一次出现位置,从pos开始查找\nint find(const char* s, int pos, int n) const;  //从pos位置查找s的前n个字符第一次位置\nint find(const char c, int pos = 0) const;  //查找字符c第一次出现位置\nint rfind(const string& str, int pos = npos) const;//查找str最后一次位置,从pos开始查找\nint rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找\nint rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置\nint rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置\nstring& replace(int pos, int n, const string& str); //替换从pos开始n个字符为字符串str\nstring& replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串s\n```\n\n##### 样例\n\n```cpp\nvoid t5()\n{\n\tstring s1, s2, s3;\n\ts1 = \"hurriedlu\";\n\ts2 = \"ie\";\n\tcout << s1.find(s2, 0) << endl; //4,在s1字符串中查找s2字符串的内容，n表示从s1中的第几位开始查找，可缺省\n\tcout << s1.find('u', 0) << endl;//1，查找u这个字符，从s1的第零位开始\n\tcout << s1.find('u', 2) << endl;//8，查找u这个字符，从s1的第2位开始查找。\n\tcout << s1.rfind('u') << endl; //8，从后往前开始查找u这个字符。也可以指定从第几位开始查找\n}\n```\n\n##### 注意\n\n当查找不到的时候，返回-1。\n\n#### string比较操作\n\n```cpp\n/*\ncompare函数在>时返回 1，<时返回 -1，==时返回 0。\n比较区分大小写，比较时参考字典顺序，排越前面的越小。\n大写的A比小写的a小。\n*/\nint compare(const string &s) const;//与字符串s比较\nint compare(const char *s) const;//与字符串s比较\n```\n\n##### 样例\n\n```cpp\nvoid t6()\n{\n\tstring s1, s2, s3;\n\ts1 = \"aaa\";\n\ts2 = \"aab\";\n\ts3 = \"aaa\";\n\tcout << s1.compare(s2) << endl;//s1与s2进行比较，因为b大于a，被比较的s2大，因此返回-1\n\tcout << s2.compare(s1) << endl;//s2与s1进行比较，被比较的s1小，返回1；\n\tcout << s3.compare(s1) << endl;//s3与s1进行比较，相等，返回0；\n}\n```\n\n\n\n\n\n#### string子串\n\n```cpp\nstring substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串\n```\n\n##### 样例\n\n```cpp\nvoid t7()\n{\n\t//string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串\n\tstring s1 = \"hello world\";\n\tstring s2 = s1.substr(4, 3);//获取s1从第四位开始，连续3个字符的子串。\n\tcout << s2 << endl;//o w\n}\n```\n\n##### 注意事项\n\n- **当n小于pos的时候，则表示获取从pos开始的所有数据**\n\n#### string插入和删除操作\n\n```cpp\nstring& insert(int pos, const char* s); //插入字符串\nstring& insert(int pos, const string& str); //插入字符串\nstring& insert(int pos, int n, char c);//在指定位置插入n个字符c\nstring& erase(int pos, int n = npos);//删除从Pos开始的n个字符 \n```\n\n##### 样例\n\n```cpp\nvoid t8()\n{\n\tstring s1 = \"hellorld\";\n\ts1.insert(4, \"o w\");//在第n位插入指定的字符串\n\tcout << s1 << endl;//\"hello world\"\n\n\ts1.insert(11, 3, '!');//在第11个位置追加3个！\n\tcout << s1 << endl;//\"hello world!!!\"\n\n\ts1.erase(12, 2);//从第12个位置，删除连续的两个字符\n\tcout << s1 << endl;//\"hello world!\"\n}\n```\n\n\n\n#### string和c-style字符串转换\n\n```cpp\n//string 转 char*\nstring str = \"hurriedlu\";\nconst char* cstr = str.c_str();\n//char* 转 string \nchar* s = \"hurriedlu\";\nstring str(s);//借助有参构造\n```\n\n##### 提示\n\n​\t存在`const char*`到`string`的隐式类型转换，但不存在从一个string对象到C_string的自动类型转换。\n\n`对于string类型的字符串，可以通过c_str()函数返回string对象对应的C_string`.\n 通常，程序员在整个程序中应坚持使用string类对象，直到必须将内容转化为char*时才将其转换为C_string.\n\n  为了修改string字符串的内容，下标操作符[]和at都会返回字符的引用。但**当字符串的内存被重新分配之后，可能发生错误**.\n\n```cpp\nvoid t9()\n{\n\tstring s = \"abcdefg\";\n\tchar& a = s[2];//获取s的下标为2的地址\n\tchar& b = s[3];\n\ta = '1';\n\tb = '2';\n\tcout << s << endl;//ab12efg\n\n\tcout << (int*)s.c_str() << endl;//验证是否符合下方的说法，在改变之前获取其中字串的地址\n\n\ts = \"pppppppppppppppppppppppp\";//从新修改了s的字符串，变长了，触发了string的内存重分配策略\n\n\t//a = '1';\t\n\t//b = '2'; //再次执行，因为s的位置更新了，原先的位置被释放掉了，所以再次对原先位置的修改就会出错。\n\n\tcout << s << endl;\n\tcout << (int*)s.c_str() << endl;//再次获取发现两个串的开头已经不一样了。\n\n\tchar& c = s[2];\n\ts = \"hhhhhhhhhhhhhhhhhhhhh\";//修改字符串s的值，但不要触发内存重新分配\n\tcout << s << endl;\n\tc = '0';//此时是可以再次修改的\n\tcout << s << endl;\t\n}\n\n```\n\n\n\n\n\n## vector容器\n\n### vector容器基本概念\n\n​\tvector的数据安排以及操作方式，与数组非常相似，两者的唯一差别在于空间的运用的灵活性。\n\n​\t数组是静态空间，一旦配置了就不能改变，要换大一点或者小一点的空间，可以，一切琐碎得由自己来，首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。Vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。因此vector的运用对于内存的合理利用与运用的灵活性有很大的帮助。\n\n​\tVector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率，一旦vector旧空间满了，如果客户每新增一个元素，vector内部只是扩充一个元素的空间，实为不智，因为所谓的扩充空间(不论多大)，一如刚所说，是”配置新空间-数据移动-释放旧空间”的大工程,时间成本很高，应该加入某种未雨绸缪的考虑，稍后我们便可以看到vector的空间配置策略。\n\n![说明: 2015-11-10_151152](./Image/C++STL学习笔记.assets/clip_image002.jpg)\n\n### vector迭代器\n\n​\tVector维护一个线性空间，所以不论元素的型别如何，普通指针都可以作为vector的迭代器，因为vector迭代器所需要的操作行为，如`operaroe*, operator->, operator++, operator--, operator+, operator-, operator+=, operator-=`, 普通指针天生具备。\n\nVector支持随机存取。所以vector提供的是随机访问迭代器(Random Access Iterators).\n\n### vector的数据结构\n\nVector所采用的数据结构非常简单，线性连续空间，它以两个迭代器_Myfirst和_Mylast分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器_Myend指向整块连续内存空间的尾端。\n**为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求大一些，以备将来可能的扩充**，这便是容量的概念。换句话说，**一个vector的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个vector容器就得另觅居所**。\n\n注意：\n  所谓动态增加大小，**并不是在原空间之后续接新空间**(因为无法保证原空间之后尚有可配置的空间)，而是一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。**因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了**，务必小心。\n\n\n\n### vector常用API操作\n\n\n\n#### vector容量分配策略\n\n```cpp\nvoid t1()\n{\n\tvector<int> v;\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tv.push_back(i);\n\t\tcout << v.capacity() << \" \";//每插入一个数据，就输出一下vector容器的具体大小；   \n\t}\n\t//1 2 3 4 6 6 9 9 9 13\n\t//并不是没插一个数就增加一次空间，因为这样会很浪费时间\n}\n```\n\n\n\n#### vector构造函数\n\n```cpp\nvector<数据类型> v; //采用模板实现类实现，默认构造函数\nvector(v.begin(), v.end());//有参构造，将v[begin(), end())区间中的元素拷贝给本身。\nvector(n, elem);//构造函数将n个elem拷贝给本身。\nvector(const vector &vec);//拷贝构造函数。\n```\n\n##### 样例\n\n```cpp\nvoid t2()\n{\n\tvector<int> v1;//默认构成\n\tvector<int> v2(10, 8);//初始化成10个8；\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tv1.push_back(i);\n\t}\n\tvector<int> v3(v1.begin(), v1.begin() + 5);//根据指定位置数据来初始化vector\n\tvector<int> v4(v3);//拷贝构造\n\n\tint arr[] = { 2,3,4,1,9 };\n\tvector<int> v5(arr, arr + sizeof(arr) / sizeof(int));//根据指定位置数据来初始化vector\n}\n```\n\n\n\n#### vector常用赋值操作\n\n```cpp\nassign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。\nassign(n, elem);//将n个elem拷贝赋值给本身。\nvector& operator=(const vector  &vec);//重载等号操作符\nswap(vec);// 将vec与本身的元素互换。\n```\n\n##### 样例\n\n```cpp\n/// <summary>\n/// 常用的赋值操作\n/// </summary>\nvoid t3()\n{\n\tvector<int> v1(10, 0);//初始化成10个0的vector\n\tvector<int> v2;\n\tv2.assign(v1.begin(), v1.end());//将指定区间的数赋值给v2。左开右闭原则。\n\tvector<int> v3;\n\tv3 = v2;//借助内部重载的赋值操作符进行赋值\n\tv1.swap(v2);//使用内部的swap方法，使得v1与v2进行交换，v1变成空值，v2变成十个0.\n\n\tfor (auto it : v1)\n\t{\n\t\tcout << it << \" \";\n\t}\n}\n```\n\n\n\n#### vector大小操作\n\n```cpp\nsize();//返回容器中元素的个数\nempty();//判断容器是否为空\nresize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。\nresize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长>度的元素被删除。\ncapacity();//容器的容量\nreserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。\n```\n\n##### 样例\n\n```cpp\n/// <summary>\n/// vector容器的大小操作\n/// </summary>\nvoid t4()\n{\n\tvector<int> v1(10, 5);\n\tint tmp;\n\n\ttmp = v1.size();//获取容器中的元素的个数，注意不是容器的大小\n\tcout << tmp << endl;\n\n\tbool flag = v1.empty();//获取当前容器是否为空，为空返回true，否则false\n\tcout << flag << endl;\n\n\tv1.resize(v1.size() / 2);\t//重新指定容器的大小，如果指定的大小小于元素，则尾部超出指定大小后的所有元素都会被删除。\n\tfor (auto it : v1)\t\t\t\t\n\t{\n\t\tcout << it << \" \";\n\t}\n\tcout << endl;\n\tv1.resize(v1.size() + 5);\t//如果指定的大小大于当前所有元素的数量，则用默认值填充新的位置\n\tfor (auto it : v1)\t\t\t\t\n\t{\n\t\tcout << it << \" \";\n\t}\n\tcout << endl;\n\tv1.resize(v1.size() + 5, 10);//也可以指定填充新位置的值\n\tfor (auto it : v1)\n\t{\n\t\tcout << it << \" \";\n\t}\n\tcout << endl;\n\n\ttmp = v1.capacity();//获取容器当前的容量值\n\tcout << tmp << endl;\n\n\tv1.reserve(20);\n\ttmp = v1.capacity();//再次获取容器当前的容量值\n\tcout << tmp << endl;\n\ttmp = v1.size();//再次获取容器中元素的个数\n\tcout << tmp << endl;\n}\n```\n\n\n\n#### vector数据存取操作\n\n```cpp\nat(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。\noperator[];//返回索引idx所指的数据，越界时，运行直接报错\nfront();//返回容器中第一个数据元素\nback();//返回容器中最后一个数据元素\n```\n\n##### 样例\n\n```cpp\n/// <summary>\n/// 元素的存取\n/// </summary>\nvoid t5()\n{\n\t//at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。\n\t//operator[];//返回索引idx所指的数据，越界时，运行直接报错\n\t//front();//返回容器中第一个数据元素\n\t//back();//返回容器中最后一个数据元素\n\n\tvector<int> v1;\n\tv1.push_back(1);\n\tv1.push_back(2);\n\tv1.push_back(3);\n\tv1.push_back(4);\n\n\tcout << v1.at(2) << endl;//利用at获取指定位置的元素。优点：当访问越界的会弹出一个out_of_range的异常\n\tcout << v1[2] << endl;//也可以用下标的方式进行访问，在不会发生越界的情况下使用。\n\tv1.at(0) = 0;//也可以修改\n\tv1[3] = 10;\n\n\tfor (auto it : v1)\n\t{\n\t\tcout << it << \" \";\n\t}\n\tcout << endl;\n\n\tcout << v1.front() << endl;//获取v1容器中第一个元素的值\n\t\n\tcout << v1.back() << endl;//获取v1容器中最后一个元素的值\n\n}\n```\n\n\n\n#### vector插入和删除操作\n\n```cpp\ninsert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele.\npush_back(ele); //尾部插入元素ele\npop_back();//删除最后一个元素\nerase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素\nerase(const_iterator pos);//删除迭代器指向的元素\nclear();//删除容器中所有元素\n```\n\n##### 样例\n\n```cpp\n/// <summary>\n/// 插入和删除\n/// </summary>\nvoid t6()\n{\n\tvector<int> v1;\n\tv1.push_back(1);\n\tv1.push_back(2);\n\tv1.push_back(3);\n\tv1.push_back(4);\n\n\tv1.insert(v1.begin(), 0);//在指定位置（此处指定了容器的起始位置）插入以一个元素0；\n\n\tv1.push_back(10);//在容器的尾部插入一个元素\n\n\tfor (auto it : v1)\n\t{\n\t\tcout << it << \" \";\n\t}\n\tcout << endl;\n\n\tv1.pop_back();//删除容器中最后的一个元素\n\n\tfor (auto it : v1)\n\t{\n\t\tcout << it << \" \";\n\t}\n\tcout << endl;\n\n\tv1.erase(v1.end() - 2, v1.end());//删除指定位置的所有元素（此处指定了最后两个），范围依旧是左开右闭\n\n\tfor (auto it : v1)\n\t{\n\t\tcout << it << \" \";\n\t}\n\tcout << endl;\n\n\tv1.erase(v1.begin());//删除指定位置的元素（此处指定了开头的一个元素）\n\n\tfor (auto it : v1)\n\t{\n\t\tcout << it << \" \";\n\t}\n\tcout << endl;\n\n\tv1.clear();//删除容器中所有的元素\n\tcout << v1.empty() << endl;//容器已经为空，输出1表示true。\n}\n```\n\n\n\n### vector小案例\n\n#### 使用用swap，收缩内存空间\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<vector>\nusing namespace std;\nint main() \n{\n\tvector<int> v;\n\tfor (int i = 0; i < 100000; i++) {\n\t\tv.push_back(i);\n\t}\n\n\tcout << \"容量：\" << v.capacity() << endl;//此时可以看到整个容器内部的容量已经到达13万+\n\tcout << \"元素个数：\" << v.size() << endl;//但元素个数只有10万个\n\n\t//此时 通过resize改变容器大小\n\tv.resize(10);//使得元素的个数只有10个，但不修改容量，使得容量保持在13万\n\n\tcout << \"容量：\" << v.capacity() << endl;//容量有13万\n\tcout << \"元素个数：\" << v.size() << endl;//元素个数只剩十个\n\n\t//容量没有改变\n\n\t//开始收缩内存\n\t/*\n\tvector<int>(v)：利用拷贝构造函数来初始化一个匿名对象。初始化的时候系统会按照v的size进行开辟，而不是按照容量。\n\tswap(v)：本质是交换两个容器的指针，每个容器的名字是存储在栈的一个指针，而内容是存储在堆内的，因此相当于v这个指针指向了新开辟的匿名对象指向的堆，而v原来的东西被匿名对象指定；当执行完这个语句后，匿名对象就会消失，被回收掉。\n\n\t简单的说就是，新开辟一个vector数组，并使用一定的方法将要压缩的容器内部的元素赋值给新的数组\n\t然后两个数组交换\n\t新开辟的数组删除。\n\t*/\n\tvector<int>(v).swap(v);\n\n\tcout << \"容量：\" << v.capacity() << endl;\n\tcout << \"元素个数：\" << v.size() << endl;\n\n\tsystem(\"pause\");\n\treturn EXIT_SUCCESS;\n}\n```\n\n\n\n#### 使用reserve预留空间，避免造成时间浪费\n\n用途：在已知会有巨量数据插入的时候，可以首先使用reserve手动帮助容器去确定大小。\n\n使用原因：容器不清楚你会插入多少数据，本着节约空间的思想会尽可能少的开辟空间。但每次开辟空间都比较费时，因此需要这个方法来节约时间。\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<vector>\nusing namespace std;\nint main() {\n\tvector<int> v;\n\t//预先开辟空间\n\tv.reserve(100000);\n\n\tint* pStart = NULL;\n\tint count = 0;\n\tfor (int i = 0; i < 100000; i++) {\n\t\tv.push_back(i);\n\t\tif (pStart != &v[0]) {//比较空间首地址是否发生了变化，如果发生，则将记录刷新，同时计数器++\n\t\t\tpStart = &v[0];\n\t\t\tcount++;\n\t\t}\n\t}\n\tcout << \"count:\" << count << endl;//输出统计了的重新分配的次数。\n\tsystem(\"pause\");\n\treturn EXIT_SUCCESS;\n}\n\n\n```\n\n#### 逆序遍历\n\n对一个给定的vector数组进行逆序输出。\n\n```cpp\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<vector>\nusing namespace std;\nint main() {\n\tvector<int> v;\n\tv.push_back(1);\n\tv.push_back(2);\n\tv.push_back(3);\n\tv.push_back(4);\n\tv.push_back(5);\n\n\t//使用下标进行逆序遍历\n\tfor (int i = v.size() - 1; i >= 0; i--)\n\t\tcout << v[i] << \" \";\n\tcout << endl;\n\n\t//使用逆向迭代器进行逆序遍历\n\t//迭代器需要是特殊的，否则会报错：\"std::reverse_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>>\" 到 \"std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>\" 的适当转换\n\t//定义迭代器的时候，需要定义成reverse_iterator\n\tfor (vector<int>::reverse_iterator it = v.rbegin(); it != v.rend(); it++)\n\t\tcout << *it << \" \";\n\tcout << endl;\n\treturn;\n}\n```\n\n\n\n\n\n\n\n## deque容器\n\n### deque容器基本概念\n\n​\tVector容器是单向开口的连续内存空间，deque则是一种双向开口的连续线性空间。**所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作**，当然，vector容器也可以在头尾两端插入元素，但是在其头部操作**效率奇差**，无法被接受。\n\n​\tDeque容器和vector容器最大的差异，一在于**deque允许使用常数项时间对头端进行元素的插入和删除操作**。二在于**deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来**，换句话说，像vector那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。也因此，deque没有必须要提供所谓的空间保留(reserve)功能.\n虽然deque容器也提供了Random Access Iterator（随机存储迭代器）,但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用vector，而不是deque。**对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque.**\n\n简单的说就是，deque的底层是一个类似链表的数组，而vector是一个数组。\n\n![说明: 2015-11-19_204101](./Image/C++STL学习笔记.assets/clip_image002-16689529807244.jpg)\n\n\n\n### deque容器实现原理\n\nDeque容器是连续的空间，至少逻辑上看来如此，连续现行空间总是令我们联想到array和vector，array无法成长，vector虽可成长，却只能向尾端成长，而且其成长其实是一个假象，事实上(1) 申请更大空间 (2)原数据复制新空间 (3)释放原空间 三步骤，如果不是vector每次配置新的空间时都留有余裕，其成长假象所带来的代价是非常昂贵的。\n\n​\tDeque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。Deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。\n既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。Deque代码的实现远比vector或list都多得多。\n**Deque采取一块所谓的map(注意，不是STL的map容器)作为主控，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是deque的存储空间的主体。**\n\n**![说明: 2015-11-19_204209](./Image/C++STL学习笔记.assets/clip_image002-16689529915256.jpg)**\n\n\n\n\n\n### deque常用API\n\n#### deque构造函数\n\n```cpp\ndeque<T> deqT;//默认构造形式\ndeque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。\ndeque(n, elem);//构造函数将n个elem拷贝给本身。\ndeque(const deque &deq);//拷贝构造函数。\n```\n\n##### 样例\n\n```cpp\nvoid t1()\n{\n\tdeque<int> d1;//默认构造\n\n\tvector<int> v;\n\tv.push_back(1);\n\tv.push_back(2);\n\tv.push_back(3);\n\tv.push_back(4);\n\tdeque<int> d2(v.begin(), v.end());//将指定范围的数作为初始化的值\n\n\tdeque<int> d3(10, 0);//指定元素个数的初始化\n\n\tdeque<int> d4(d3);//拷贝构造\n}\n```\n\n\n\n#### deque赋值操作\n\n```cpp\nassign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。\nassign(n, elem);//将n个elem拷贝赋值给本身。\ndeque& operator=(const deque &deq); //重载等号操作符 \nswap(deq);// 将deq与本身的元素互换\n```\n\n##### 样例\n\n```cpp\nvoid t2()\n{\n\tdeque<int> d1;\n\td1.push_back(1);\n\td1.push_back(2);\n\td1.push_back(3);\n\td1.push_back(4);\n\t\n\tdeque<int> d2;\n\td2.push_back(0);\n\td2.assign(d1.begin() + 1, d1.end());//复制指定位置的值到当前容器，并顶替掉当前容器已有的值。\n\tfor (deque<int>::iterator it = d2.begin(); it != d2.end(); it++)\n\t\tcout << *it << \" \";\n\tcout << endl;\n\n\tdeque<int> d3;\n\td3 = d2;//容器内部重载了赋值号这个操作，可以直接赋值。\n\n\td2.swap(d1);//两个容器的存储部分进行交换操作。\n}\n```\n\n\n\n#### deque大小操作\n\n```cpp\ndeque.size();//返回容器中元素的个数\ndeque.empty();//判断容器是否为空\ndeque.resize(num);//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。\ndeque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。\n```\n\n##### 样例\n\n```cpp\nvoid t3()\n{\n\tdeque<int> d1;\n\td1.push_back(1);\n\td1.push_back(2);\n\td1.push_back(3);\n\td1.push_back(4);\n\n\tcout << d1.size() << endl;//获取d1的元素个数\n\n\tif(d1.empty()!= NULL)\n\t\tcout << \"不为空\" << endl;//判断当前容器是否为空\n\n\td1.resize(d1.size() + 2);//重新设置d1的元素的个数，如果变长用默认值填充，变短删除尾端元素\n\n\td1.resize(d1.size() + 2,-1);//重新设置d1的元素的个数，并指定填充元素的值\n\n\tfor (deque<int>::iterator it = d1.begin(); it != d1.end(); it++)\n\t\tcout << *it << \" \";\n\tcout << endl;\n}\n```\n\n\n\n#### deque双端插入和删除操作\n\n```cpp\npush_back(elem);//在容器尾部添加一个数据\npush_front(elem);//在容器头部插入一个数据\npop_back();//删除容器最后一个数据\npop_front();//删除容器第一个数据\n```\n\n##### 样例\n\n```cpp\nvoid t4()\n{\n\tdeque<int> d1;\n\n\td1.push_back(1);//在d1的尾部插入一个1\n\td1.push_back(2);//再次尾插\n\td1.push_front(3);//在d1的前面插入一个3，此时d1的值为： 3 1 2\n\tfor (deque<int>::iterator it = d1.begin(); it != d1.end(); it++)\n\t\tcout << *it << \" \";\n\tcout << endl;\n\n\td1.pop_back();//删除一个尾部元素\n\td1.pop_front();//删除一个头部元素\n\n\tfor (deque<int>::iterator it = d1.begin(); it != d1.end(); it++)\n\t\tcout << *it << \" \";\n\tcout << endl;\n\n```\n\n\n\n#### deque数据存取\n\n```cpp\nat(idx);//返回索引idx所指的数据，如果idx越界，抛出out_of_range。\noperator[];//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。\nfront();//返回第一个数据。\nback();//返回最后一个数据\n```\n\n##### 样例\n\n```cpp\nvoid t5()\n{\n\tdeque<int> d1;\n\td1.push_back(1);\n\td1.push_back(2);\n\td1.push_back(3);\n\td1.push_back(4);\n\n\tcout << d1[0] << endl;//直接索引下标为0的元素\n\tcout << d1.at(1) << endl;//利用at返回对应下标的元素\n\tcout << d1.front() << endl;//获取容器的第一个元素\n\tcout << d1.back() << endl;//获取容器的最后一个元素\n}\n```\n\n\n\n#### deque插入操作\n\n```cpp\ninsert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置。\ninsert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。\ninsert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。\n```\n\n##### 样例\n\n```cpp\nvoid t6()\n{\n\tdeque<int> d1;\n\td1.insert(d1.begin(), 12);//在d1容器的开头的位置插入一个值12\n\td1.insert(d1.begin(), 5, 0);//在d1容器的开头插入5个0；\n\n\tdeque<int> d2;\n\td2.insert(d2.begin(),d1.begin(), d1.end());//在d2开头的位置插入d1容器的内容\n}\n```\n\n\n\n#### deque删除操作\n\n```cpp\nclear();//移除容器的所有数据\nerase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。\nerase(pos);//删除pos位置的数据，返回下一个数据的位置。\n```\n\n##### 样例\n\n```cpp\nvoid t7()\n{\n\t//clear();//移除容器的所有数据\n\t//erase(beg, end);//删除[beg,end)区间的数据，返回下一个数据的位置。\n\t//erase(pos);//删除pos位置的数据，返回下一个数据的位置。\n\tdeque<int> d1;\n\td1.push_back(1);\n\td1.push_back(2);\n\td1.push_back(3);\n\td1.push_back(4);\n\n\tif (d1.empty())\n\t\tcout << \"d1容器是空的\" << endl;\n\telse\n\t\tcout << \"d1容器不是空的\" << endl;\n\n\td1.clear();//对d1进行清空\n\n\tif (d1.empty())\n\t\tcout << \"d1容器是空的\" << endl;\n\telse\n\t\tcout << \"d1容器不是空的\" << endl;\n\n\t//再次插入4个元素\n\td1.push_back(1);\n\td1.push_back(2);\n\td1.push_back(3);\n\td1.push_back(4);\n\n\td1.erase(d1.begin() + 2, d1.end());//只保留前面两个元素\n\tfor (deque<int>::iterator it = d1.begin(); it != d1.end(); it++)\n\t\tcout << *it << \" \";\n\tcout << endl;\n\n\td1.erase(d1.end() - 1);//删除最后一个元素\n\tfor (deque<int>::iterator it = d1.begin(); it != d1.end(); it++)\n\t\tcout << *it << \" \";\n\tcout << endl;\n}\n```\n\n\n\n## stack容器\n\n### stack容器基本概念\n\n​\tstack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口，形式如图所示。\n\n​\tstack容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，**stack不允许有遍历行为**。\n​\t有元素推入栈的操作称为:push,将元素推出stack的操作称为pop.\n\n![说明: 2015-11-15_195707](./Image/C++STL学习笔记.assets/clip_image002-16690312276401.jpg)\n\n \n\n\n\n### 3.4.2 stack没有迭代器\n\n​\t**Stack所有元素的进出都必须符合”先进后出”的条件**，只有stack顶端的元素，才有机会被外界取用。**Stack不提供遍历功能，也不提供迭代器。**\n\n### stack常用API\n\n#### stack构造函数\n\n```cpp\nstack<T> stkT;//stack采用模板类实现， stack对象的默认构造形式： \nstack(const stack &stk);//拷贝构造函数\n```\n\n##### 样例\n\n```cpp\nvoid t1()\n{\n\tstack<int> t1;//无参构造\n\tt1.push(1);\n\tt1.push(2);\n\tt1.push(3);\n\tt1.push(4);\n\n\tstack<int> t2(t1);//拷贝构造\n\n\twhile (!t2.empty())\n\t{\n\t\tcout << t2.top() << \" \";\n\t\tt2.pop();\n\t}\n\tcout << endl;\n}\n```\n\n\n\n#### stack赋值操作\n\n```cpp\nstack& operator=(const stack &stk);//重载等号操作符\n```\n\n##### 样例\n\n```cpp\nvoid t2()\n{\n\tstack<int> t1;\n\tt1.push(1);\n\tt1.push(2);\n\tt1.push(3);\n\tt1.push(4);\n\n\tstack<int> t2;\n\n\tt2 = t1;//直接赋值\n\n\twhile (!t2.empty())\n\t{\n\t\tcout << t2.top() << \" \";\n\t\tt2.pop();\n\t}\n\tcout << endl;\n}\n```\n\n\n\n#### stack数据存取操作\n\n```cpp\npush(elem);//向栈顶添加元素\npop();//从栈顶移除第一个元素\ntop();//返回栈顶元素\n```\n\n##### 样例\n\n```cpp\nvoid t3()\n{\n\tstack<int> t1;\n\tt1.push(1);//添加元素到栈顶\n\tt1.push(2);\n\tt1.push(3);\n\tt1.push(4);\n\n\twhile (!t1.empty())//只要栈不空就循环\n\t{\n\t\tcout << t1.top() << \" \";//获取当前的栈顶元素\n\t\tt1.pop();//栈顶元素出栈\n\t}\n\tcout << endl;\n}\n```\n\n\n\n#### stack大小操作\n\n```cpp\nempty();//判断堆栈是否为空\nsize();//返回堆栈的大小\n```\n\n##### 样例\n\n```cpp\nvoid t4()\n{\n\tstack<int> t1;\n\tif(t1.empty())//判断栈是否为空\n\t\tcout << \"空栈\" << endl;\n\telse\n\t\tcout << \"非空栈\" << endl;\n\n\tt1.push(1);\n\n\tcout << t1.size() << endl;//获取栈中元素的个数\n}\n```\n\n\n\n## queue容器\n\n### queue容器基本概念\n\n​\tQueue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口，queue容器允许从一端新增元素，从另一端移除元素。即队列。\n\n\n\n### queue没有迭代器\n\n​\tQueue所有元素的进出都必须符合”先进先出”的条件，只有queue的顶端元素，才有机会被外界取用。**Queue不提供遍历功能，也不提供迭代器**。\n\n### queue常用API\n\n#### queue构造函数\n\n```cpp\nqueue<T> queT;//queue采用模板类实现，queue对象的默认构造形式：\nqueue(const queue &que);//拷贝构造函数\n```\n\n\n\n##### 样例\n\n#### queue存取、插入和删除操作\n\n```cpp\npush(elem);//往队尾添加元素\npop();//从队头移除第一个元素\nback();//返回最后一个元素\nfront();//返回第一个元素\n```\n\n\n\n##### 样例\n\n#### queue赋值操作\n\n```cpp\nqueue& operator=(const queue &que);//重载等号操作符\n```\n\n\n\n##### 样例\n\n#### queue大小操作\n\n```cpp\nempty();//判断队列是否为空\nsize();//返回队列的大小\n```\n\n\n\n##### 样例\n\n\n\n## list容器\n\n### list容器基本概念\n\n链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。\n相较于vector的连续线性空间，list就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。\nList和vector是两个最常被使用的容器。\nList容器是一个双向链表。\n\n\n\n\n\n\n\n\n\n 采用动态存储分配，不会造成内存浪费和溢出\n 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素\n 链表灵活，但是空间和时间额外耗费较大\n\n### list容器的迭代器\n\nList容器不能像vector一样以普通指针作为迭代器，因为其节点不能保证在同一块连续的内存空间上。List迭代器必须有能力指向list的节点，并有能力进行正确的递增、递减、取值、成员存取操作。所谓”list正确的递增，递减、取值、成员取用”是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取的是节点的成员。\n由于list是一个双向链表，迭代器必须能够具备前移、后移的能力，所以list容器提供的是Bidirectional Iterators.\nList有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效。这在vector是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效，甚至List元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。\n\n### list容器的数据结构\n\nlist容器不仅是一个双向链表，而且还是一个循环的双向链表。\n\n\n\\#define _CRT_SECURE_NO_WARNINGS\n\\#include<iostream>\n\\#include<list>\nusing namespace std;\n\n\nint main(){\n\n\nlist<int> myList;\nfor (int i = 0; i < 10; i ++){\nmyList.push_back(i);\n}\n\n\nlist<int>::_Nodeptr node =  myList._Myhead->_Next;\n\n\nfor (int i = 0; i < myList._Mysize * 2;i++){\ncout << \"Node:\" << node->_Myval << endl;\nnode = node->_Next;\nif (node == myList._Myhead){\nnode = node->_Next;\n}\n}\n\n\nsystem(\"pause\");\nreturn EXIT_SUCCESS;\n}\n\n### list常用API\n\n#### list构造函数\n\nlist<T> lstT;//list采用采用模板类实现,对象的默认构造形式：\nlist(beg,end);//构造函数将[beg, end)区间中的元素拷贝给本身。\nlist(n,elem);//构造函数将n个elem拷贝给本身。\nlist(const list &lst);//拷贝构造函数。\n\n#### list数据元素插入和删除操作\n\npush_back(elem);//在容器尾部加入一个元素\npop_back();//删除容器中最后一个元素\npush_front(elem);//在容器开头插入一个元素\npop_front();//从容器开头移除第一个元素\ninsert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。\ninsert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。\ninsert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。\nclear();//移除容器的所有数据\nerase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。\nerase(pos);//删除pos位置的数据，返回下一个数据的位置。\nremove(elem);//删除容器中所有与elem值匹配的元素。\n\n\n\n#### list大小操作\n\nsize();//返回容器中元素的个数\nempty();//判断容器是否为空\nresize(num);//重新指定容器的长度为num，\n若容器变长，则以默认值填充新位置。\n如果容器变短，则末尾超出容器长度的元素被删除。\nresize(num, elem);//重新指定容器的长度为num，\n若容器变长，则以elem值填充新位置。\n如果容器变短，则末尾超出容器长度的元素被删除。\n\n#### list赋值操作\n\nassign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。\nassign(n, elem);//将n个elem拷贝赋值给本身。\nlist& operator=(const list &lst);//重载等号操作符\nswap(lst);//将lst与本身的元素互换。\n\n#### list数据的存取\n\nfront();//返回第一个元素。\nback();//返回最后一个元素。\n\n#### list反转排序\n\nreverse();//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。\nsort(); //list排序\n\n\n3.7 set/multiset容器\n3.7.1 set/multiset容器基本概念\n3.7.1.1 set容器基本概念\nSet的特性是。所有元素都会根据元素的键值自动被排序。Set的元素不像map那样可以同时拥有实值和键值，set的元素即是键值又是实值。Set不允许两个元素有相同的键值。\n我们可以通过set的迭代器改变set元素的值吗？不行，因为set元素值就是其键值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织。换句话说，set的iterator是一种const_iterator.\nset拥有和list某些相同的性质，当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效，被删除的那个元素的迭代器必然是一个例外。\n3.7.1.2 multiset容器基本概念\nmultiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。set和multiset的底层实现是红黑树，红黑树为平衡二叉树的一种。\n树的简单知识：\n二叉树就是任何节点最多只允许有两个字节点。分别是左子结点和右子节点。\n\n\n\n二叉树示意图\n\n\n二叉搜索树，是指二叉树中的节点按照一定的规则进行排序，使得对二叉树中元素访问更加高效。二叉搜索树的放置规则是：任何节点的元素值一定大于其左子树中的每一个节点的元素值，并且小于其右子树的值。因此从根节点一直向左走，一直到无路可走，即得到最小值，一直向右走，直至无路可走，可得到最大值。那么在儿茶搜索树中找到最大元素和最小元素是非常简单的事情。下图为二叉搜索树：\n\n\n\n上面我们介绍了二叉搜索树，那么当一个二叉搜索树的左子树和右子树不平衡的时候，那么搜索依据上图表示，搜索9所花费的时间要比搜索17所花费的时间要多，由于我们的输入或者经过我们插入或者删除操作，二叉树失去平衡，造成搜索效率降低。\n所以我们有了一个平衡二叉树的概念，所谓的平衡不是指的完全平衡。\n\n\n\nRB-tree(红黑树)为二叉树的一种。\n\n\n3.7.2 set常用API\n3.7.2.1 set构造函数\nset<T> st;//set默认构造函数：\nmulitset<T> mst; //multiset默认构造函数: \nset(const set &st);//拷贝构造函数\n3.7.2.2 set赋值操作\nset& operator=(const set &st);//重载等号操作符\nswap(st);//交换两个集合容器\n3.7.2.3 set大小操作\nsize();//返回容器中元素的数目\nempty();//判断容器是否为空\n\n\n3.7.2.4 set插入和删除操作\ninsert(elem);//在容器中插入元素。\nclear();//清除所有元素\nerase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。\nerase(beg, end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。\nerase(elem);//删除容器中值为elem的元素。\n\n\n3.7.2.5 set查找操作\nfind(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();\ncount(key);//查找键key的元素个数\nlower_bound(keyElem);//返回第一个key>=keyElem元素的迭代器。\nupper_bound(keyElem);//返回第一个key>keyElem元素的迭代器。\nequal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。\n\n\n\n\n\n\n\n\nset的返回值   指定set排序规则:\n\n\n//插入操作返回值\nvoid test01(){\n\n\nset<int> s;\npair<set<int>::iterator,bool> ret = s.insert(10);\nif (ret.second){\ncout << \"插入成功:\" << *ret.first << endl;\n}\nelse{\ncout << \"插入失败:\" << *ret.first << endl;\n}\n\nret = s.insert(10);\nif(ret.second){\ncout << \"插入成功:\" << *ret.first << endl;\n}\nelse{\ncout << \"插入失败:\" << *ret.first << endl;\n}\n\n\n}\n\n\nstruct MyCompare02{\nbool operator()(int v1,int v2){\nreturn v1 > v2;\n}\n};\n\n\n//set从大到小\nvoid test02(){\n\n\nsrand((unsigned int)time(NULL));\n//我们发现set容器的第二个模板参数可以设置排序规则，默认规则是less<_Kty>\nset<int, MyCompare02> s;\nfor (int i = 0; i < 10;i++){\ns.insert(rand() % 100);\n}\n\nfor (set<int, MyCompare02>::iterator it = s.begin(); it != s.end(); it ++){\ncout << *it << \" \";\n}\ncout << endl;\n}\n\n\n//set容器中存放对象\nclass Person{\npublic:\nPerson(string name,int age){\nthis->mName = name;\nthis->mAge = age;\n}\npublic:\nstring mName;\nint mAge;\n};\n\n\n\n\nstruct MyCompare03{\nbool operator()(const Person& p1,const Person& p2){\nreturn p1.mAge > p2.mAge;\n}\n};\n\n\nvoid test03(){\n\n\nset<Person, MyCompare03> s;\n\n\nPerson p1(\"aaa\", 20);\nPerson p2(\"bbb\", 30);\nPerson p3(\"ccc\", 40);\nPerson p4(\"ddd\", 50);\n\n\ns.insert(p1);\ns.insert(p2);\ns.insert(p3);\ns.insert(p4);\n\n\nfor (set<Person, MyCompare03>::iterator it = s.begin(); it != s.end(); it++){\ncout << \"Name:\" << it->mName << \" Age:\" << it->mAge << endl;\n}\n\n\n}\n\n\n3.7.3 对组(pair)\n对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问。\n类模板：template <class T1, class T2> struct pair.\n如何创建对组?\n//第一种方法创建一个对组\npair<string, int> pair1(string(\"name\"), 20);\ncout << pair1.first << endl; //访问pair第一个值\ncout << pair1.second << endl;//访问pair第二个值\n//第二种\npair<string, int> pair2 = make_pair(\"name\", 30);\ncout << pair2.first << endl;\ncout << pair2.second << endl;\n//pair=赋值\npair<string, int> pair3 = pair2;\ncout << pair3.first << endl;\ncout << pair3.second << endl;\n\n\n3.8 map/multimap容器\n3.8.1 map/multimap基本概念\nMap的特性是，所有元素都会根据元素的键值自动排序。Map所有的元素都是pair,同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。\n我们可以通过map的迭代器改变map的键值吗？答案是不行，因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织。如果想要修改元素的实值，那么是可以的。\nMap和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。\nMultimap和map的操作类似，唯一区别multimap键值可重复。\nMap和multimap都是以红黑树为底层实现机制。\n3.8.2 map/multimap常用API\n3.8.2.1 map构造函数\nmap<T1, T2> mapTT;//map默认构造函数: \nmap(const map &mp);//拷贝构造函数\n\n\n\n\n3.8.2.2 map赋值操作\nmap& operator=(const map &mp);//重载等号操作符\nswap(mp);//交换两个集合容器\n\n\n3.8.2.3 map大小操作\nsize();//返回容器中元素的数目\nempty();//判断容器是否为空\n3.8.2.4 map插入数据元素操作\nmap.insert(...); //往容器插入元素，返回pair<iterator,bool>\nmap<int, string> mapStu;\n// 第一种 通过pair的方式插入对象\nmapStu.insert(pair<int, string>(3, \"小张\"));\n// 第二种 通过pair的方式插入对象\nmapStu.inset(make_pair(-1, \"校长\"));\n// 第三种 通过value_type的方式插入对象\nmapStu.insert(map<int, string>::value_type(1, \"小李\"));\n// 第四种 通过数组的方式插入值\nmapStu[3] = \"小刘\";\nmapStu[5] = \"小王\";\n3.8.2.5 map删除操作\nclear();//删除所有元素\nerase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。\nerase(beg,end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。\nerase(keyElem);//删除容器中key为keyElem的对组。\n3.8.2.6 map查找操作\nfind(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();\ncount(keyElem);//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。\nlower_bound(keyElem);//返回第一个key>=keyElem元素的迭代器。\nupper_bound(keyElem);//返回第一个key>keyElem元素的迭代器。\nequal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。\n3.8.3 multimap案例\n//公司今天招聘了5个员工，5名员工进入公司之后，需要指派员工在那个部门工作\n//人员信息有: 姓名 年龄 电话 工资等组成\n//通过Multimap进行信息的插入 保存 显示\n//分部门显示员工信息 显示全部员工信息\n\n\n\\#define _CRT_SECURE_NO_WARNINGS\n\n\n\\#include<iostream>\n\\#include<map>\n\\#include<string>\n\\#include<vector>\nusing namespace std;\n\n\n//multimap 案例\n//公司今天招聘了 5 个员工，5 名员工进入公司之后，需要指派员工在那个部门工作\n//人员信息有: 姓名 年龄 电话 工资等组成\n//通过 Multimap 进行信息的插入 保存 显示\n//分部门显示员工信息 显示全部员工信息\n\n\n\n\n\\#define SALE_DEPATMENT 1 //销售部门\n\\#define DEVELOP_DEPATMENT 2 //研发部门\n\\#define FINACIAL_DEPATMENT 3 //财务部门\n\\#define ALL_DEPATMENT 4 //所有部门\n\n\n//员工类\nclass person{\npublic:\nstring name; //员工姓名\nint age; //员工年龄\ndouble salary; //员工工资\nstring tele; //员工电话\n};\n\n\n//创建5个员工\nvoid CreatePerson(vector<person>& vlist){\n\n\nstring seed = \"ABCDE\";\nfor (int i = 0; i < 5; i++){\nperson p;\np.name = \"员工\";\np.name += seed[i];\np.age = rand() % 30 + 20;\np.salary = rand() % 20000 + 10000;\np.tele = \"010-8888888\";\nvlist.push_back(p);\n}\n\n\n}\n\n\n//5名员工分配到不同的部门\nvoid PersonByGroup(vector<person>& vlist, multimap<int, person>& plist){\n\n\n\n\nint operate = -1; //用户的操作\n\n\nfor (vector<person>::iterator it = vlist.begin(); it != vlist.end(); it++){\n\n\ncout << \"当前员工信息:\" << endl;\ncout << \"姓名：\" << it->name << \" 年龄:\" << it->age << \" 工资:\" << it->salary << \" 电话：\" << it->tele << endl;\ncout << \"请对该员工进行部门分配(1 销售部门, 2 研发部门, 3 财务部门):\" << endl;\nscanf(\"%d\", &operate);\n\n\nwhile (true){\n\n\nif (operate == SALE_DEPATMENT){  //将该员工加入到销售部门\nplist.insert(make_pair(SALE_DEPATMENT, *it));\nbreak;\n}\nelse if (operate == DEVELOP_DEPATMENT){\nplist.insert(make_pair(DEVELOP_DEPATMENT, *it));\nbreak;\n}\nelse if (operate == FINACIAL_DEPATMENT){\nplist.insert(make_pair(FINACIAL_DEPATMENT, *it));\nbreak;\n}\nelse{\ncout << \"您的输入有误，请重新输入(1 销售部门, 2 研发部门, 3 财务部门):\" << endl;\nscanf(\"%d\", &operate);\n}\n\n\n}\n\n\n}\ncout << \"员工部门分配完毕!\" << endl;\ncout << \"***********************************************************\" << endl;\n\n\n}\n\n\n//打印员工信息\nvoid printList(multimap<int, person>& plist, int myoperate){\n\n\nif (myoperate == ALL_DEPATMENT){\nfor (multimap<int, person>::iterator it = plist.begin(); it != plist.end(); it++){\ncout << \"姓名：\" << it->second.name << \" 年龄:\" << it->second.age << \" 工资:\" << it->second.salary << \" 电话：\" << it->second.tele << endl;\n}\nreturn;\n}\n\n\nmultimap<int, person>::iterator it = plist.find(myoperate);\nint depatCount = plist.count(myoperate);\nint num = 0;\nif (it != plist.end()){\nwhile (it != plist.end() && num < depatCount){\ncout << \"姓名：\" << it->second.name << \" 年龄:\" << it->second.age << \" 工资:\" << it->second.salary << \" 电话：\" << it->second.tele << endl;\nit++;\nnum++;\n}\n}\n}\n\n\n//根据用户操作显示不同部门的人员列表\nvoid ShowPersonList(multimap<int, person>& plist, int myoperate){\n\n\nswitch (myoperate)\n{\ncase SALE_DEPATMENT:\nprintList(plist, SALE_DEPATMENT);\nbreak;\ncase DEVELOP_DEPATMENT:\nprintList(plist, DEVELOP_DEPATMENT);\nbreak;\ncase FINACIAL_DEPATMENT:\nprintList(plist, FINACIAL_DEPATMENT);\nbreak;\ncase ALL_DEPATMENT:\nprintList(plist, ALL_DEPATMENT);\nbreak;\n}\n}\n\n\n//用户操作菜单\nvoid PersonMenue(multimap<int, person>& plist){\n\n\nint flag = -1;\nint isexit = 0;\nwhile (true){\ncout << \"请输入您的操作((1 销售部门, 2 研发部门, 3 财务部门, 4 所有部门, 0退出)：\" << endl;\nscanf(\"%d\", &flag);\n\n\nswitch (flag)\n{\ncase SALE_DEPATMENT:\nShowPersonList(plist, SALE_DEPATMENT);\nbreak;\ncase DEVELOP_DEPATMENT:\nShowPersonList(plist, DEVELOP_DEPATMENT);\nbreak;\ncase FINACIAL_DEPATMENT:\nShowPersonList(plist, FINACIAL_DEPATMENT);\nbreak;\ncase ALL_DEPATMENT:\nShowPersonList(plist, ALL_DEPATMENT);\nbreak;\ncase 0:\nisexit = 1;\nbreak;\ndefault:\ncout << \"您的输入有误，请重新输入!\" << endl;\nbreak;\n}\n\n\nif (isexit == 1){\nbreak;\n}\n}\n\n\n}\n\n\nint main(){\n\n\nvector<person>  vlist; //创建的5个员工 未分组\nmultimap<int, person> plist; //保存分组后员工信息\n\n\n//创建5个员工\nCreatePerson(vlist);\n//5名员工分配到不同的部门\nPersonByGroup(vlist, plist);\n//根据用户输入显示不同部门员工信息列表 或者 显示全部员工的信息列表\nPersonMenue(plist);\n\n\nsystem(\"pause\");\nreturn EXIT_SUCCESS;\n}\n\n\n\n\n3.9 STL容器使用时机\nvector  deque list  set multiset  map multimap\n典型内存结构 单端数组  双端数组 双向链表  二叉树 二叉树  二叉树 二叉树\n可随机存取 是  是 否 否 否 对key而言：不是 否\n元素搜寻速度 慢  慢 非常慢 快 快 对key而言：快 对key而言：快\n元素安插移除 尾端  头尾两端 任何位置  - - - -\n\n\n\n\n vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。\n deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。\n   vector与deque的比较：\n 一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置 却是不固定的。\n  二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。\n  三：deque支持头部的快速插入与快速移除，这是deque的优点。\n list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。\n set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。 \n map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。\n\\4. 常用算法\n4.1 函数对象\n重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象，也叫仿函数(functor),其实就是重载“()”操作符，使得类对象可以像函数那样调用。\n注意:\n1.函数对象(仿函数)是一个类，不是一个函数。\n2.函数对象(仿函数)重载了”() ”操作符使得它可以像函数一样调用。\n分类:假定某个类有一个重载的operator()，而且重载的operator()要求获取一个参数，我们就将这个类称为“一元仿函数”（unary functor）；相反，如果重载的operator()要求获取两个参数，就将这个类称为“二元仿函数”（binary functor）。\n函数对象的作用主要是什么？STL提供的算法往往都有两个版本，其中一个版本表现出最常用的某种运算，另一版本则允许用户通过template参数的形式来指定所要采取的策略。\n\n\n//函数对象是重载了函数调用符号的类\nclass MyPrint\n{\npublic:\nMyPrint()\n{\nm_Num = 0;\n}\nint m_Num;\n\n\npublic:\nvoid operator() (int num)\n{\ncout << num << endl;\nm_Num++;\n}\n};\n\n\n//函数对象\n//重载了()操作符的类实例化的对象，可以像普通函数那样调用,可以有参数 ，可以有返回值\nvoid test01()\n{\nMyPrint myPrint;\nmyPrint(20);\n\n\n}\n// 函数对象超出了普通函数的概念，可以保存函数的调用状态\nvoid test02()\n{\nMyPrint myPrint;\nmyPrint(20);\nmyPrint(20);\nmyPrint(20);\ncout << myPrint.m_Num << endl;\n}\n\n\nvoid doBusiness(MyPrint print,int num)\n{\nprint(num);\n}\n\n\n//函数对象作为参数\nvoid test03()\n{\n//参数1：匿名函数对象\ndoBusiness(MyPrint(),30);\n}\n\n\n总结：\n1、函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题。\n2、函数对象超出普通函数的概念，函数对象可以有自己的状态\n3、函数对象可内联编译，性能好。用函数指针几乎不可能\n4、模版函数对象使函数对象具有通用性，这也是它的优势之一\n\n\n4.2 谓词\n谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数)。如果operator接受一个参数，那么叫做一元谓词,如果接受两个参数，那么叫做二元谓词，谓词可作为一个判断式。\nclass GreaterThenFive\n{\npublic:\nbool operator()(int num)\n{\nreturn num > 5;\n}\n\n\n};\n//一元谓词\nvoid test01()\n{\nvector<int> v;\nfor (int i = 0; i < 10;i ++)\n{\nv.push_back(i);\n}\n\nvector<int>::iterator it =  find_if(v.begin(), v.end(), GreaterThenFive());\nif (it == v.end())\n{\ncout << \"没有找到\" << endl;\n}\nelse\n{\ncout << \"找到了: \" << *it << endl;\n}\n}\n\n\n//二元谓词\nclass MyCompare\n{\npublic:\nbool operator()(int num1, int num2)\n{\nreturn num1 > num2;\n}\n};\n\n\nvoid test02()\n{\nvector<int> v;\nv.push_back(10);\nv.push_back(40);\nv.push_back(20);\nv.push_back(90);\nv.push_back(60);\n\n\n//默认从小到大\nsort(v.begin(), v.end());\nfor (vector<int>::iterator it = v.begin(); it != v.end();it++)\n{\ncout << *it << \" \";\n}\ncout << endl;\ncout << \"----------------------------\" << endl;\n//使用函数对象改变算法策略，排序从大到小\nsort(v.begin(), v.end(),MyCompare());\nfor (vector<int>::iterator it = v.begin(); it != v.end(); it++)\n{\ncout << *it << \" \";\n}\ncout << endl;\n}\n\n\n4.3 内建函数对象\nSTL内建了一些函数对象。分为:算数类函数对象,关系运算类函数对象，逻辑运算类仿函数。这些仿函数所产生的对象，用法和一般函数完全相同，当然我们还可以产生无名的临时对象来履行函数功能。使用内建函数对象，需要引入头文件 #include<functional>。\n\n\n 6个算数类函数对象,除了negate是一元运算，其他都是二元运算。\ntemplate<class T> T plus<T>//加法仿函数\ntemplate<class T> T minus<T>//减法仿函数\ntemplate<class T> T multiplies<T>//乘法仿函数\ntemplate<class T> T divides<T>//除法仿函数\ntemplate<class T> T modulus<T>//取模仿函数\ntemplate<class T> T negate<T>//取反仿函数\n\n\n 6个关系运算类函数对象,每一种都是二元运算。\ntemplate<class T> bool equal_to<T>//等于\ntemplate<class T> bool not_equal_to<T>//不等于\ntemplate<class T> bool greater<T>//大于\ntemplate<class T> bool greater_equal<T>//大于等于\ntemplate<class T> bool less<T>//小于\ntemplate<class T> bool less_equal<T>//小于等于\n\n\n 逻辑运算类运算函数,not为一元运算，其余为二元运算。\ntemplate<class T> bool logical_and<T>//逻辑与\ntemplate<class T> bool logical_or<T>//逻辑或\ntemplate<class T> bool logical_not<T>//逻辑非\n\n\n内建函数对象举例:\n//取反仿函数\nvoid test01()\n{\nnegate<int> n;\ncout << n(50) << endl;\n}\n\n\n//加法仿函数\nvoid test02()\n{\nplus<int> p;\ncout << p(10, 20) << endl;\n}\n\n\n//大于仿函数\nvoid test03()\n{\nvector<int> v;\nsrand((unsigned int)time(NULL));\nfor (int i = 0; i < 10; i++){\nv.push_back(rand() % 100);\n}\n\n\nfor (vector<int>::iterator it = v.begin(); it != v.end(); it++){\ncout << *it << \" \";\n}\ncout << endl;\nsort(v.begin(), v.end(), greater<int>());\n\n\nfor (vector<int>::iterator it = v.begin(); it != v.end(); it++){\ncout << *it << \" \";\n}\ncout << endl;\n\n\n}\n\n\n3.1.4 函数对象适配器\n//函数适配器bind1st bind2nd\n//现在我有这个需求 在遍历容器的时候，我希望将容器中的值全部加上100之后显示出来，怎么做？\n//我们直接给函数对象绑定参数 编译阶段就会报错\n//for_each(v.begin(), v.end(), bind2nd(myprint(),100));\n//如果我们想使用绑定适配器,需要我们自己的函数对象继承binary_function 或者 unary_function\n//根据我们函数对象是一元函数对象 还是二元函数对象\nclass MyPrint :public binary_function<int,int,void>\n{\npublic:\nvoid operator()(int v1,int v2) const\n{\ncout << \"v1 = : \" << v1 << \" v2 = :\" <<v2  << \" v1+v2 = :\" << (v1 + v2) << endl; \n}\n};\n//1、函数适配器\nvoid test01()\n{\nvector<int>v;\nfor (int i = 0; i < 10; i++)\n{\nv.push_back(i);\n}\ncout << \"请输入起始值：\" << endl;\nint x;\ncin >> x;\n\n\nfor_each(v.begin(), v.end(), bind1st(MyPrint(), x));\n//for_each(v.begin(), v.end(), bind2nd( MyPrint(),x ));\n}\n//总结：  bind1st和bind2nd区别?\n//bind1st ： 将参数绑定为函数对象的第一个参数\n//bind2nd ： 将参数绑定为函数对象的第二个参数\n//bind1st bind2nd将二元函数对象转为一元函数对象\n\n\n\n\nclass GreaterThenFive:public unary_function<int,bool>\n{\npublic:\nbool operator ()(int v) const\n{\nreturn v > 5;\n}\n};\n\n\n//2、取反适配器\nvoid test02()\n{\nvector <int> v;\nfor (int i = 0; i < 10;i++)\n{\nv.push_back(i);\n}\n\n// vector<int>::iterator it =  find_if(v.begin(), v.end(), GreaterThenFive()); //返回第一个大于5的迭代器\n// vector<int>::iterator it = find_if(v.begin(), v.end(),  not1(GreaterThenFive())); //返回第一个小于5迭代器\n//自定义输入\nvector<int>::iterator it = find_if(v.begin(), v.end(), not1 ( bind2nd(greater<int>(),5)));\nif (it == v.end())\n{\ncout << \"没找到\" << endl;\n}\nelse\n{\ncout << \"找到\" << *it << endl;\n}\n\n\n//排序  二元函数对象\nsort(v.begin(), v.end(), not2(less<int>()));\nfor_each(v.begin(), v.end(), [](int val){cout << val << \" \"; });\n\n\n}\n//not1 对一元函数对象取反\n//not2 对二元函数对象取反\n\n\nvoid MyPrint03(int v,int v2)\n{\ncout << v + v2<< \" \";\n}\n\n\n//3、函数指针适配器  ptr_fun\nvoid test03()\n{\nvector <int> v;\nfor (int i = 0; i < 10; i++)\n{\nv.push_back(i);\n}\n// ptr_fun( )把一个普通的函数指针适配成函数对象\nfor_each(v.begin(), v.end(), bind2nd( ptr_fun( MyPrint03 ), 100));\n}\n\n\n\n\n//4、成员函数适配器\nclass Person\n{\npublic:\nPerson(string name, int age)\n{\nm_Name = name;\nm_Age = age;\n}\n\n\n//打印函数\nvoid ShowPerson(){\ncout << \"成员函数:\" << \"Name:\" << m_Name << \" Age:\" << m_Age << endl;\n}\nvoid Plus100()\n{\nm_Age += 100;\n}\npublic:\nstring m_Name;\nint m_Age;\n};\n\n\nvoid MyPrint04(Person &p)\n{\ncout << \"姓名：\" <<  p.m_Name << \" 年龄：\" << p.m_Age << endl;\n\n\n};\n\n\nvoid test04()\n{\nvector <Person>v;\nPerson p1(\"aaa\", 10);\nPerson p2(\"bbb\", 20);\nPerson p3(\"ccc\", 30);\nPerson p4(\"ddd\", 40);\nv.push_back(p1);\nv.push_back(p2);\nv.push_back(p3);\nv.push_back(p4);\n\n\n//for_each(v.begin(), v.end(), MyPrint04);\n//利用 mem_fun_ref 将Person内部成员函数适配\nfor_each(v.begin(), v.end(), mem_fun_ref(&Person::ShowPerson));\n// for_each(v.begin(), v.end(), mem_fun_ref(&Person::Plus100));\n// for_each(v.begin(), v.end(), mem_fun_ref(&Person::ShowPerson));\n}\n\n\nvoid test05(){\n\n\nvector<Person*> v1;\n//创建数据\nPerson p1(\"aaa\", 10);\nPerson p2(\"bbb\", 20);\nPerson p3(\"ccc\", 30);\nPerson p4(\"ddd\", 40);\n\n\nv1.push_back(&p1);\nv1.push_back(&p2);\nv1.push_back(&p3);\nv1.push_back(&p4);\n\n\nfor_each(v1.begin(), v1.end(), mem_fun(&Person::ShowPerson));\n}\n\n\n//如果容器存放的是对象指针，  那么用mem_fun\n//如果容器中存放的是对象实体，那么用mem_fun_ref\n\n\n4.2 算法概述\n算法主要是由头文件<algorithm> <functional> <numeric>组成。\n<algorithm>是所有STL头文件中最大的一个,其中常用的功能涉及到比较，交换，查找,遍历，复制，修改，反转，排序，合并等...\n<numeric>体积很小，只包括在几个序列容器上进行的简单运算的模板函数.\n<functional> 定义了一些模板类,用以声明函数对象。\n4.3 常用遍历算法\n/*\n  遍历算法 遍历容器元素\n@param beg 开始迭代器\n@param end 结束迭代器\n@param _callback  函数回调或者函数对象\n@return 函数对象\n*/\nfor_each(iterator beg, iterator end, _callback);\n/*\ntransform算法 将指定容器区间元素搬运到另一容器中\n注意 : transform 不会给目标容器分配内存，所以需要我们提前分配好内存\n@param beg1 源容器开始迭代器\n@param end1 源容器结束迭代器\n@param beg2 目标容器开始迭代器\n@param _cakkback 回调函数或者函数对象\n@return 返回目标容器迭代器\n*/\ntransform(iterator beg1, iterator end1, iterator beg2, _callbakc)\n\n\n\n\nfor_each:\n/*\n\n\ntemplate<class _InIt,class _Fn1> inline\nvoid for_each(_InIt _First, _InIt _Last, _Fn1 _Func)\n{\nfor (; _First != _Last; ++_First)\n_Func(*_First);\n}\n\n\n*/\n\n\n//普通函数\nvoid print01(int val){\ncout << val << \" \";\n}\n//函数对象\nstruct print001{\nvoid operator()(int val){\ncout << val << \" \";\n}\n};\n\n\n//for_each算法基本用法\nvoid test01(){\n\nvector<int> v;\nfor (int i = 0; i < 10;i++){\nv.push_back(i);\n}\n\n\n//遍历算法\nfor_each(v.begin(), v.end(), print01);\ncout << endl;\n\n\nfor_each(v.begin(), v.end(), print001());\ncout << endl;\n\n\n}\n\n\nstruct print02{\nprint02(){\nmCount = 0;\n}\nvoid operator()(int val){\ncout << val << \" \";\nmCount++;\n}\nint mCount;\n};\n\n\n//for_each返回值\nvoid test02(){\n\n\nvector<int> v;\nfor (int i = 0; i < 10; i++){\nv.push_back(i);\n}\n\n\nprint02 p = for_each(v.begin(), v.end(), print02());\ncout << endl;\ncout << p.mCount << endl;\n}\n\n\nstruct print03 : public binary_function<int, int, void>{\nvoid operator()(int val,int bindParam) const{\ncout << val + bindParam << \" \";\n}\n};\n\n\n//for_each绑定参数输出\nvoid test03(){\n\nvector<int> v;\nfor (int i = 0; i < 10; i++){\nv.push_back(i);\n}\n\n\nfor_each(v.begin(), v.end(), bind2nd(print03(),100));\n}\n\n\n\n\ntransform:\n//transform 将一个容器中的值搬运到另一个容器中\n/*\ntemplate<class _InIt, class _OutIt, class _Fn1> inline \n_OutIt _Transform(_InIt _First, _InIt _Last,_OutIt _Dest, _Fn1 _Func)\n{ \n\n\nfor (; _First != _Last; ++_First, ++_Dest)\n*_Dest = _Func(*_First);\nreturn (_Dest);\n}\n\n\ntemplate<class _InIt1,class _InIt2,class _OutIt,class _Fn2> inline\n_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1,_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)\n{ \nfor (; _First1 != _Last1; ++_First1, ++_First2, ++_Dest)\n*_Dest = _Func(*_First1, *_First2);\nreturn (_Dest);\n}\n*/\n\n\nstruct transformTest01{\nint operator()(int val){\nreturn val + 100;\n}\n};\nstruct print01{\nvoid operator()(int val){\ncout << val << \" \";\n}\n};\nvoid test01(){\n\n\nvector<int> vSource;\nfor (int i = 0; i < 10;i ++){\nvSource.push_back(i + 1);\n}\n\n\n//目标容器\nvector<int> vTarget;\n//给vTarget开辟空间\nvTarget.resize(vSource.size());\n//将vSource中的元素搬运到vTarget\nvector<int>::iterator it = transform(vSource.begin(), vSource.end(), vTarget.begin(), transformTest01());\n//打印\nfor_each(vTarget.begin(), vTarget.end(), print01()); cout << endl;\n\n}\n\n\n//将容器1和容器2中的元素相加放入到第三个容器中\nstruct transformTest02{\nint operator()(int v1,int v2){\nreturn v1 + v2;\n}\n};\nvoid test02(){\n\n\nvector<int> vSource1;\nvector<int> vSource2;\nfor (int i = 0; i < 10; i++){\nvSource1.push_back(i + 1); \n}\n\n\n//目标容器\nvector<int> vTarget;\n//给vTarget开辟空间\nvTarget.resize(vSource1.size());\ntransform(vSource1.begin(), vSource1.end(), vSource2.begin(),vTarget.begin(), transformTest02());\n//打印\nfor_each(vTarget.begin(), vTarget.end(), print01()); cout << endl;\n}\n\n\n4.4 常用查找算法\n/*\nfind算法 查找元素\n@param beg 容器开始迭代器\n@param end 容器结束迭代器\n@param value 查找的元素\n@return 返回查找元素的位置\n*/\nfind(iterator beg, iterator end, value)\n/*\nfind_if算法 条件查找\n@param beg 容器开始迭代器\n@param end 容器结束迭代器\n@param  callback 回调函数或者谓词(返回bool类型的函数对象)\n@return bool 查找返回true 否则false\n*/\nfind_if(iterator beg, iterator end, _callback);\n\n\n/*\nadjacent_find算法 查找相邻重复元素\n@param beg 容器开始迭代器\n@param end 容器结束迭代器\n@param  _callback 回调函数或者谓词(返回bool类型的函数对象)\n@return 返回相邻元素的第一个位置的迭代器\n*/\nadjacent_find(iterator beg, iterator end, _callback);\n/*\nbinary_search算法 二分查找法\n注意: 在无序序列中不可用\n@param beg 容器开始迭代器\n@param end 容器结束迭代器\n@param value 查找的元素\n@return bool 查找返回true 否则false\n*/\nbool binary_search(iterator beg, iterator end, value);\n/*\ncount算法 统计元素出现次数\n@param beg 容器开始迭代器\n@param end 容器结束迭代器\n@param  value回调函数或者谓词(返回bool类型的函数对象)\n@return int返回元素个数\n*/\ncount(iterator beg, iterator end, value);\n/*\ncount算法 统计元素出现次数\n@param beg 容器开始迭代器\n@param end 容器结束迭代器\n@param  callback 回调函数或者谓词(返回bool类型的函数对象)\n@return int返回元素个数\n*/\ncount_if(iterator beg, iterator end, _callback);\n\n\n4.5 常用排序算法\n/*\nmerge算法 容器元素合并，并存储到另一容器中\n@param beg1 容器1开始迭代器\n@param end1 容器1结束迭代器\n@param beg2 容器2开始迭代器\n@param end2 容器2结束迭代器\n@param dest  目标容器开始迭代器\n*/\nmerge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)\n/*\nsort算法 容器元素排序\n注意:两个容器必须是有序的\n@param beg 容器1开始迭代器\n@param end 容器1结束迭代器\n@param _callback 回调函数或者谓词(返回bool类型的函数对象)\n*/\nsort(iterator beg, iterator end, _callback)\n/*\nsort算法 对指定范围内的元素随机调整次序\n@param beg 容器开始迭代器\n@param end 容器结束迭代器\n*/\nrandom_shuffle(iterator beg, iterator end)\n/*\nreverse算法 反转指定范围的元素\n@param beg 容器开始迭代器\n@param end 容器结束迭代器\n*/\nreverse(iterator beg, iterator end)\n\n\n\n\n4.6 常用拷贝和替换算法\n/*\ncopy算法 将容器内指定范围的元素拷贝到另一容器中\n@param beg 容器开始迭代器\n@param end 容器结束迭代器\n@param dest 目标起始迭代器\n*/\ncopy(iterator beg, iterator end, iterator dest)\n/*\nreplace算法 将容器内指定范围的旧元素修改为新元素\n@param beg 容器开始迭代器\n@param end 容器结束迭代器\n@param oldvalue 旧元素\n@param oldvalue 新元素\n*/\nreplace(iterator beg, iterator end, oldvalue, newvalue)\n/*\nreplace_if算法 将容器内指定范围满足条件的元素替换为新元素\n@param beg 容器开始迭代器\n@param end 容器结束迭代器\n@param callback函数回调或者谓词(返回Bool类型的函数对象)\n@param oldvalue 新元素\n*/\nreplace_if(iterator beg, iterator end, _callback, newvalue)\n/*\nswap算法 互换两个容器的元素\n@param c1容器1\n@param c2容器2\n*/\nswap(container c1, container c2)\n\n\n4.7 常用算数生成算法\n/*\naccumulate算法 计算容器元素累计总和\n@param beg 容器开始迭代器\n@param end 容器结束迭代器\n@param value累加值\n*/\naccumulate(iterator beg, iterator end, value)\n/*\nfill算法 向容器中添加元素\n@param beg 容器开始迭代器\n@param end 容器结束迭代器\n@param value t填充元素\n*/\nfill(iterator beg, iterator end, value)\n\n\n\n\n4.8 常用集合算法\n/*\nset_intersection算法 求两个set集合的交集\n注意:两个集合必须是有序序列\n@param beg1 容器1开始迭代器\n@param end1 容器1结束迭代器\n@param beg2 容器2开始迭代器\n@param end2 容器2结束迭代器\n@param dest  目标容器开始迭代器\n@return 目标容器的最后一个元素的迭代器地址\n*/\nset_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)\n/*\nset_union算法 求两个set集合的并集\n注意:两个集合必须是有序序列\n@param beg1 容器1开始迭代器\n@param end1 容器1结束迭代器\n@param beg2 容器2开始迭代器\n@param end2 容器2结束迭代器\n@param dest  目标容器开始迭代器\n@return 目标容器的最后一个元素的迭代器地址\n*/\nset_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)\n/*\nset_difference算法 求两个set集合的差集\n注意:两个集合必须是有序序列\n@param beg1 容器1开始迭代器\n@param end1 容器1结束迭代器\n@param beg2 容器2开始迭代器\n@param end2 容器2结束迭代器\n@param dest  目标容器开始迭代器\n@return 目标容器的最后一个元素的迭代器地址\n*/\nset_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)\n\n\n\n\n\\5. STL综合案例(学校演讲比赛)\n演讲比赛案例\n\n\n比赛规则：\n\n\n     某市举行一场演讲比赛（ speech_contest ），共有24个人参加。比赛共三轮，前两轮为淘汰赛，第三轮为决赛。\n\n\n      比赛方式：分组比赛，每组6个人；选手每次要随机分组，进行比赛；\n\n\n第一轮分为4个小组，每组6个人。比如编号为: 100-123.  整体进行抽签（draw）后顺序演讲。当小组演讲完后，淘汰组内排名最后的三个选手，然后继续下一个小组的比赛。\n\n\n第二轮分为2个小组，每组6人。比赛完毕，淘汰组内排名最后的三个选手，然后继续下一个小组的比赛。\n\n\n第三轮只剩下1组6个人，本轮为决赛，选出前三名。\n\n​      比赛评分：10个评委打分，去除最低、最高分，求平均分每个选手演讲完由10个评委分别打分。该选手的最终得分是去掉一个最高分和一个最低分，求得剩下的8个成绩的平均分。选手的名次按得分降序排列。\n\n\n\n\n用STL编程，求解这个问题\n1） 请打印出所有选手的名字与参赛号，并以参赛号的升序排列。\n2） 打印每一轮比赛后，小组比赛成绩和小组晋级名单\n\n\n需求分析：\n\\1) 产生选手 （ ABCDEFGHIJKLMNOPQRSTUVWX ） 姓名、得分；选手编号\n\n\n\\2) 第1轮  选手抽签 选手比赛 查看比赛结果 \n\\3) 第2轮  选手抽签 选手比赛 查看比赛结果\n\\4) 第3轮  选手抽签 选手比赛 查看比赛结果\n实现思路：\n需要把选手信息、选手得分信息、选手比赛抽签信息、选手的晋级信息保存在容器中，需要涉及到各个容器的选型。\n选手可以设计一个类Speaker（姓名和得分）\n所有选手的编号可以单独放在一个vector容器中，做抽签用\n\n\n\n\n所有选手编号和选手信息，可以放在容器内：map<int, Speaker> \n所有选手的编号名单，可以放在容器：vecter<int> v1中\n第1轮晋级编号名单，可以放在容器vecter<int> v2中 \n第2轮晋级编号名单，可以放在容器vecter<int> v3中\n第3轮前三名名单，可以放在容器vecter<int> v4中\n\n\n\n每个小组的比赛得分信息，按照从大到小的顺序放在multimap<成绩, 编号, greater<int>>中\n\n每个选手的得分，可以放在容器deque<int> dscore; 方便去除最低最高分.\n\n\n\n\n\n\n\n\n\n\n\n## 案例及总结\n\n\n\n### 判断迭代器的类型\n\n```cpp\nvector<int>::iterator it;\nit++; it--;//如果这两个操作都支持，就证明是双向迭代器了。\nit = it + 1;//如果这条语句也可以执行，就可以证明这个迭代器是随机访问迭代器。\n```\n\n\n\n### 迭代器类型\n\n- iterator\n\n  - 普通迭代器\n\n- reverse_iterator\n\n  - 反转迭代器，提供了`rbegin()`、`rend()`两个迭代器，用以反向输出容器的值。\n\n- const_iterator\n\n  - 只读迭代器，防止在不应该被修改的地方被修改了。\n\n  - ```cpp\n    void test(const deque<int> &d)\n    {\n    \tfor (deque<int>::const_iterator it = d.begin(); it != d.end(); it++)\n    \t\tcout << *it << endl;\n    }\n    ```\n\n\n\n\n\n### 网址分解\n\n给定一个网址，求出网址的各个域名并输出出来。\n\n```cpp\n/// <summary>\n/// 小测试，将str字符串中的网址的各级域名进行分解\n/// </summary>\nvoid test1()\n{\n\tstring str = \"www.pixiv.net\";//数据\n\tint pos = 0, start = 0;//结束点，起始点\n\tvector<string> ans;//答案数组\n\twhile (pos == -1){\t\t\n\t\tpos = str.find(\".\", start);//获取新的结束点。从起始点开始查找，查找第一次出现 分隔符 . 的位置作为结束标志点.\n\t\t\n\t\tans.push_back(str.substr(start, pos - start));//使用子串函数，从起始点开始，连续获取 结束点 - 起始点 个字符，并将这个字符存入答案中。\n\t\tstart = pos + 1;//新的起始点等于旧的结束点的后一位。\n\t}\n\t//将获取到的答案进行输出。\n\tfor (auto it : ans)\n\t{\n\t\tcout << it << endl;\n\t} \n}\n```\n\n\n\n### string大小写转换\n\n```cpp\nvoid t10()\n{\n\tstring s1 = \"Hurriedlu\";\n\n\tfor (int i = 0; i < s1.size(); i++)\n\t{\n\t\ts1[i] = toupper(s1[i]);//小写转大写\n\n\t\ts1[i] = tolower(s1[i]);//大写转小写\n\t}\n\tcout << s1 << endl;\n}\n```\n\n\n","tags":["protected","C++","STL"],"categories":["C++"]},{"title":"排序的总类 思想 效率","url":"/2022/09/08/算法_排序的总类_思想_效率/","content":"\n# 准备\n\n## 随机数生成\n\nC++中没有自带的random函数，要实现随机数的生成就需要使用rand()和srand()。\n\n不过，由于rand()的内部实现是用线性同余法做的，所以生成的并不是真正的随机数，而是在一定范围内可看为随机的伪随机数。\n\n\n\n### **rand（）**\n\nrand()会返回一随机数值, 范围在0至RAND_MAX 间。RAND_MAX定义在stdlib.h, 其值为2147483647。\n\n\n\n#### 参考代码\n\n```c\n#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nint main()\n{\n    for (int i = 0; i < 10; i++)\n    {\n        cout << rand()%100<< \" \";\n    }\n    return 0;\n}\n\n//在100中产生随机数， 但是因为没有随机种子所以，下一次运行也是这个数，因此就要引出srand\n```\n\n\n\n### **srand（）**\n\nsrand()可用来设置rand()产生随机数时的随机数种子。通过设置不同的种子，我们可以获取不同的随机数序列。\n\n可以利用srand((int)(time(NULL))的方法，利用系统时钟，产生不同的随机数种子。不过要调用time()，需要加入头文件< ctime >。\n\n#### 参考代码\n\n```c\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\nint main()\n{\n    srand((int)time(0));  // 产生随机种子  把0换成NULL也行\n    for (int i = 0; i < 10; i++)\n    {\n        cout << rand()%100<< \" \";\n    }\n    return 0;\n}\n\n\n\n```\n\n\n\n为了使用方便可以使用宏定义来替换rand函数（或者srand）\n\n```c\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#define random(x) rand()%(x)\nusing namespace std;\n\nint main()\n{\n    srand((int)time(0));  // 产生随机种子  把0换成NULL也行\n    for (int i = 0; i < 10; i++)\n    {\n        cout << random(100) << \" \";\n    }\n    return 0;\n}\n```\n\n\n\n\n\n### 其他的随机数的范围通式\n\n产生一定范围随机数的通用表示公式是：\n\n要取得[0,n) 就是rand（）%n   表示 从0到n-1的数\n\n要取得[a,b)的随机整数，使用(rand() % (b-a))+ a; \n\n要取得[a,b]的随机整数，使用(rand() % (b-a+1))+ a; \n\n要取得(a,b]的随机整数，使用(rand() % (b-a))+ a + 1; \n\n\n\n通用公式:a + rand() % n；其中的a是起始值，n是整数的范围。 \n\n要取得a到b之间的随机整数，另一种表示：a + (int)b \\* rand() / (RAND_MAX + 1)。 \n\n要取得0～1之间的浮点数，可以使用rand() / double(RAND_MAX)。\n\n\n\n### 来源\n\nhttps://www.cnblogs.com/xiaokang01/p/9786751.html\n\n\n\n## 显示计算机当前的时间\n\n\n\n\n\n\n\n# 冒泡排序\n\n## 思想\n\n1. 比较相邻元素，如果第一个比第二个大，就进行交换，使得最大的数（或者最小的数）在最后\n2. 继续第一步，总共需要进行 n - 1 次的循环，就可以实现排序完成\n\n\n\n## 效率及特点\n\n- 双重循环，因此时间复杂度是 n^2^\n- 因为前后两个数是通过大于 或者 小于 的方法进行比较，因此排序具有稳定性。即如果两个数相等，排完序后两个数的前后关系不会改变。\n- 可以进行优化，如果当前循环内没有进行交换，则认为数组已经是有序的了，可以停止排序直接退出。\n\n\n\n## 实现代码\n\n```c\n/// <summary>\n/// 冒泡排序\n/// </summary>\n/// <param name=\"arr\">要排序的数组</param>\n/// <param name=\"len\">数组的长度</param>\nvoid bubbleSort(int arr[], int len)\n{\n    \n    for (int i = 0; i < len - 1; i++)\n    {\n        for (int j = 0; j < len - i - 1; j++)\n        {\n            //如果当前元素比后一个元素的值大（或者小），就进行交换，循环一遍后使得最大的元素到达最后\n            if (arr[j] > arr[j + 1])\n            {\n                swap(arr[j], arr[j + 1]);\n            }\n        }\n    }\n}\n```\n\n\n\n优化后的版本\n\n\n\n```c\n/// <summary>\n/// 优化过的冒泡排序\n/// </summary>\n/// <param name=\"arr\">数组名</param>\n/// <param name=\"len\">数组长度</param>\nvoid bubbleSort_s(int arr[], int len)\n{\n    bool flag ;\n    for (int i = 0; i < len - 1; i++)\n    {\n        flag = true;\n        for (int j = 0; j < len - i - 1; j++)\n        {\n            //如果当前元素比后一个元素的值大（或者小），就进行交换，循环一遍后使得最大的元素到达最后\n            if (arr[j] > arr[j + 1])\n            {\n                swap(arr[j], arr[j + 1]);\n                flag = false;//如果发生排序，则证明数列还不一定是有序的\n            }\n        }\n\n        if (flag == true)//如果这个循环中没有进行过交换，则认为数列已经有序，可以退出\n        {\n            break;\n        }\n    }\n}\n```\n\n\n\n# 选择排序\n\n## 思想\n\n1. 在当前数列中设第一位是最小值\n2. 将最小值的与当前数列的每一位元素进行比较，达到最小值是整个未排序的数列中最小的元素。\n3. 将最小值与数列的第一位进行交换，使得每次循环后，最小的在最前面。\n\n\n\n## 效率和特点\n\n- 和冒泡类似，都是双重循环，因此时间复杂度是n^2^。\n- 不好继续优化，对于全是同一个数的数列来说不能像冒泡排序一样循环一遍后直接退出。\n- 节省空间？因为对于结构体数组来说，每次判断只需要存储下标。\n- 需要注意的是选择排序是不稳定的，可能出现两个相等的数前后的位置关系发生改变。\n\n\n\n## 实现代码\n\n```\n/// <summary>\n/// 选择排序\n/// </summary>\n/// <param name=\"arr\">要排序的数组名</param>\n/// <param name=\"len\">数组长度</param>\nvoid selectSort(int arr[], int len)\n{\n    int minn;//设定一个最小值\n\n    for (int i = 0; i < len; i++)\n    {\n        minn = i;// 设当前数列的第一个数是整个数列最小的数（或者最大的数）。只存储下标，方便交换\n        for (int j = i; j < len; j++)\n        {\n            if (arr[j] < arr[minn])//如果当前的数比数列的第一个要小，则更新下标值.通过更改这个对比实现升序降序的选择。\n                minn = j;\n        }\n        swap(arr[minn], arr[i]);//将当前数列的最小值与第一个互换，保证每次循环中最小的值在最前面\n    }\n}\n```\n\n\n\n\n\n# 插入排序\n\n## 思想\n\n1. 每次循环后使数组后移一位，然后将最小值或最大值插入到整个数列中第一个比他小的位置。\n\n\n\n## 效率和特点\n\n1. 双重循环，n^2^\n2. 稳定。\n3. 最优情况：数列相等或者顺序符合要求，只会比较n - 1次\n4. 最坏情况：数列完全逆序，需要2(1 + 2 + .. + n-1)次的比较和移动(即 n^2^ - n)。\n\n\n\n## 实现代码\n\n```c\n/// <summary>\n/// 插入排序\n/// </summary>\n/// <param name=\"arr\">数组名</param>\n/// <param name=\"len\">数组长度</param>\nvoid insertSort(int arr[], int len)\n{\n    int key;\n    for (int i = 1; i < len; i++)\n    {\n        key = arr[i];\n        int j = i - 1;\n        while ((j >= 0) && (key < arr[j]))//只要j大于0并且关键字始终小于当前元素，就不停的后移\n        {\n            arr[j + 1] = arr[j];//数组中的数 每次都后移一位\n            j--;\n        }\n        arr[j + 1] = key;//把最小的值插入到前面\n    }\n}\n```\n\n\n\n# 快速排序\n\n## 思想\n\n1. 从数列中挑出一个元素，称为 \"基准\"（pivot）。可以是第一个元素，也可以是最后一个元素，或者中间的任意一个元素\n2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（**相同的数可以到任一边**）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；\n\n\n\n## 效率及特点\n\n- 时间复杂度只有nlogn，因为是二叉树形式的递归\n\n\n\n\n\n## 实现代码\n\n```c\nvoid quickSort(int arr[], int l, int r)\n{\n    //如果左右边界相等了，就证明当前数列中只有一个元素，可以认为当前数列是有序的\n    if (l >= r)\n        return;\n\n    int x = arr[l + r >> 1];//对数组取中间元素的值作为分界值\n    int i = l - 1;//生成本轮循环的左边界\n    int j = r + 1;//生成本轮循环的右边界\n\n    //使得分界值左边所有元素都小于分界值，右边所有元素都大于分界值。\n    while (i < j)//开始本轮循环 要求左右边界不能碰面\n    {\n        do {\n            i++;\n        } while (arr[i] < x);//从头开始，寻找第一个值大于等于分界值的元素\n\n        do {\n            j--;\n        } while (arr[j] > x);//从后往前，寻找第一个值小于等于分界值的元素\n\n        if (i < j)//如果左指针比右指针小，就交换两个元素。可能会有越界的行为，因此在交换前需要先判断\n            swap(arr[i], arr[j]);\n    }\n\n    //从分界点开始递归排序\n    quickSort(arr, l, j);\n    quickSort(arr, j + 1, r);\n}\n```\n\n\n\n\n\n\n\n\n\n# 归并排序\n\n## 思想\n\n​\t\t整个算法是基于基于分治的，先对要排序的数列求出中间值，然后以中间值为界限，将左右两边依次递归的进行排序，直到序列中只有一个元素为止。\n\n​\t\t在归并中，有两个指针分别指向左右两个序列的起始位置，依次判断当前指针指向的数的大小，并按要求将指定的数存入临时数组，此过程可以保证排序的稳定性。\n\n​\t\t当归并完成后，依次对两个数列进行“扫尾”的操作，将剩下的没有进行归并的数全部依次存入临时数组。\n\n​\t\t最后将临时数组返回或者复制到答案数组中。\n\n\n\n## 效率及特点\n\n- 虽然时间复杂度都是nlogn，但在对1e7的数量级的0-100的随机数进行排序的时候发现，归并排序只需要4秒钟，快排需要8秒。（排序数据相同，没修改过随机种子）。需要注意的是，用于归并的辅助数组一定要在归并函数外面定义，如果定义在内部会导致巨量的内存及时间的浪费（13秒，2G）\n- 相比快排具有稳定性。\n- 基于分治的思想\n\n\n\n## 实现代码\n\n```c\nvoid mergeSort(int nums[], int l, int r)\n{\n    //int* tmp = (int*)malloc((r - l) * sizeof(int));\n    if (l >= r)\n        return;\n\n    int mid = l + r >> 1;\n\n    mergeSort(nums, l, mid);\n    mergeSort(nums, mid + 1, r);\n\n\n    int k = 0;\n    int i = l, j = mid + 1;\n    while (i <= mid && j <= r)\n    {\n        if (nums[i] < nums[j])\n            tmp[k++] = nums[i++];\n        else\n            tmp[k++] = nums[j++];\n    }\n\n    //进行扫尾操作\n    while (i <= mid)\n        tmp[k++] = nums[i++];\n    while (j <= r)\n        tmp[k++] = nums[j++];\n\n    for (int i = l, j = 0; i <= r; i++, j++)\n    {\n        nums[i] = tmp[j];\n    }\n}\n```\n\n","tags":["protected","算法","排序"],"categories":["算法"]},{"title":"Linux基础案例","url":"/2022/08/18/Linux案例/","content":"# 案例\n\n## 设置全局代理\n\nLinux系统设置全局代理（http代理，socks代理）\n\n### 临时\n\n```bash\nexport http_proxy=http://ip:port\nexport https_proxy=http://ip:port\n\nexport http_proxy=http://192.168.68.204:7890\nexport https_proxy=http://192.168.68.204:7890\n\nexport http_proxy=http://192.168.228.235:7890\nexport https_proxy=http://192.168.228.235:7890\n\n```\n\n### 永久\n\n```bash\nvim /etc/profile\nhttp_proxy=http://127.0.0.1:9666 #代理程序地址\nhttps_proxy=http://127.0.0.1:9666\nftp_proxy=http://127.0.0.1:9666\nexport http_proxy\nexport ftp_proxy\nexport https_proxy\n```\n\n![image-20230612224231907](./Image/Linux基础.assets/image-20230612224231907.png)\n\n针对上面变量的设置方法：\n\n1、在/etc/profile文件\n\n2、在~/.bashrc\n\n3、在~/.zshrc\n\n4、在/etc/profile.d/文件夹下新建一个文件xxx.sh\n\n写入如下配置：\n\n1. `export proxy=\"http://192.168.5.14:8118\"`\n2. `export http_proxy=$proxy`\n3. `export https_proxy=$proxy`\n4. `export ftp_proxy=$proxy`\n5. `export no_proxy=\"localhost, 127.0.0.1, ::1\"`\n\n而对于要取消设置可以使用如下命令，其实也就是取消环境变量的设置：\n\n1. `unset http_proxy`\n2. `unset https_proxy`\n3. `unset ftp_proxy`\n4. `unset no_proxy`\n\n\n\n\n\n\n\n## 设置IP v6 DDNS\n\n在 Linux 主机上设置 IPv6 的 DDNS，可以参考以下步骤：\n\n1. 选择一家支持 IPv6 DDNS 的服务提供商，例如 dynv6.com。\n2. 在服务提供商网站上注册账户，并创建一个域名。例如，你可以创建一个名为 \"example.dynv6.net\" 的域名。\n3. 在 Linux 主机上安装 ddclient 工具。ddclient 是一个动态 DNS 客户端程序，可以将本地的 IP 地址信息上传到 DDNS 服务器，从而实现 DDNS 功能。在 Ubuntu 主机上，可以使用 apt 命令来安装 ddclient：\n\n```csharp\nsudo apt-get install ddclient\n```\n\n安装完成后可能会提示：\n\n```bash\nConfiguring ddclient\n--------------------\n\nDynamic DNS service you are using. If the service you use is not listed, choose \"other\".\n\n  1. no-ip.com           4. domains.google   7. www.dslreports.com\n  2. freedns.afraid.org  5. www.dyndns.com   8. www.zoneedit.com\n  3. duckdns.org         6. www.easydns.com  9. other\nDynamic DNS service provider:\n```\n\n选择ddns运营商即可。\n\n\n\n1. 配置 ddclient 工具。编辑 /etc/ddclient.conf 文件，将以下内容添加到该文件末尾（注意将域名和认证令牌替换为你自己的信息）：\n\n```perl\n   protocol=dyndns2\n   use=if, if=eth0 # 根据实际情况修改网络接口名\n   server=ipv6.dynv6.com\n   login=your_token # 替换为你自己的认证令牌\n   password=\n   your_ipv6_address\n   your_hostname.example.dynv6.net\n```\n\n- protocol：指定协议类型，这里使用 dyndns2。\n- use：指定使用哪个网络接口的 IPv6 地址。\n- server：指定 DDNS 服务器地址。\n- login：指定认证令牌。\n- password：留空即可。\n- youripv6address：你的 IPv6 地址，可以使用 ifconfig 命令来获取。\n- your_hostname.example.dynv6.net：你在 DDNS 服务器上创建的完整域名。\n\n1. 启动 ddclient 服务。运行以下命令启动 ddclient 服务：\n\n```sql\n   sudo systemctl start ddclient\n```\n\n1. 验证 DDNS 是否生效。运行以下命令查看 ddclient 日志输出：\n\n```bash\n   sudo tail /var/log/syslog | grep ddclient\n```\n\n如果能够看到 \"SUCCESS\" 的提示信息，则说明 DDNS 设置成功。此时你可以在浏览器中输入你的域名进行访问，应该能够看到你的 Linux 主机的网页内容。\n\n\n\n\n\n## 解决按上下箭头会乱码\n\n在Linux中，按上下左右键为什么变成^[[A^[[B^[[C^[[D？\n\n在一些linux终端里，按上下左右键，会回显^[[A^[[B^[[C^[[D。这是什么编码？还有其他那些键位会出现这样的乱码\n\n原因可能是Linux 下的命令环境问题，我尝试用 bash 即可解决；\n\n出现上述问题的时候，命令行只显示一个提示符：\n\n> $\n\n1、可以直接输入：\n\n> bash\n\n使用 bash 模式输入命令；\n\n2、输入：\n\n> chsh\n\n在Login Shell [*]后输入\n\n> /bin/bash\n\n即可，以后每次连接都会使用 bash ；\n\n\n\n## 无法使用`IP`命令\n\n在大多数Linux发行版中，`ip`命令已经预装。如果您的系统没有预装`ip`命令，您可以按照以下步骤安装：\n\n1. 打开终端并使用管理员权限登录系统。\n2. 在终端中运行以下命令之一，根据您的Linux发行版选择一个：\n\n- Debian/Ubuntu系统：`sudo apt-get install iproute2`\n- CentOS/Fedora系统：`sudo yum install iproute`\n\n1. 等待安装完成后，您可以在终端中使用`ip`命令了。\n\n\n\n\n\n## 查看以 `.`开头的隐藏文件\n\n在Linux系统中，可以使用ls命令来查看文件列表，包括隐藏文件。如果想要显示所有文件，包括隐藏文件，可以在ls命令中添加-a选项。例如，要查看当前目录下的所有文件，包括隐藏文件，可以使用以下命令：\n\n```bash\nls -a\n```\n\n通过执行该命令，会列出当前目录中的所有文件和子目录，包括以\".\"开头的隐藏文件和目录。\n\n\n\n\n\n## 启用私钥形式登录\n\nSSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。\n\n\n\n### 创建公钥和私钥\n\n使用ssh-keygen生成公钥和私钥\n\n- ssh-keygen -t \"加密方式\" -C“描述”\n\n-C参数可不加，直接用ssh-keygen -t rsa 即可。当然也可以选择其他的加密方式\n\n\n\n这里直接 `ssh-keygen -t rsa`。\n\n\n\n默认创建位置都在个人目录下的.ssh/\n\nPassphrases是私钥的密码，可以选择输入密码也可以留空，每次私钥登录都会要求输入密码。\n\n当生成指纹之后就说明生成成功了。此时~/.ssh/目录下会生成两个文件，id_rsa和id_rsa.pub\n\n```bash\nhurr@onecloud:~$ ssh-keygen -t rsa\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/hurr/.ssh/id_rsa): \nCreated directory '/home/hurr/.ssh'.\nEnter passphrase (empty for no passphrase): \nEnter same passphrase again: \nYour identification has been saved in /home/hurr/.ssh/id_rsa\nYour public key has been saved in /home/hurr/.ssh/id_rsa.pub\nThe key fingerprint is:\nSHA256:+Q96WcNwBqreApk6bjznOgU+J6deNXgxlKW+bqP9UKQ hurr@onecloud\nThe key's randomart image is:\n+---[RSA 3072]----+\n|      .o.        |\n|     ...  .      |\n|      + .. .     |\n|  .  o =... o    |\n| . ..oE.S  =     |\n|  + Bo.+ .  +    |\n| . O.oo.  oo .   |\n|  O..o=...oo     |\n| ++Booo+o.  .    |\n+----[SHA256]-----+\nhurr@onecloud:~$ \n```\n\n\n\n\n\n### 安装公钥\n\nssh登录时会先检查公钥，公钥位置在~/.ssh/authorized_keys\n\n此时我们发现.ssh下并没有authorized_keys\n\n需要将公钥放入authorized_keys\n\n使用cat或者mv都可以，这里我使用cat命令\n\n```bash\ncat id_rsa.pub > authorized_keys\n```\n\n### 更改权限\n\nauthorized_keys需要600\n\n.ssh需要700\n\n使用chmod命令\n\n```bash\nchmod 600 ~/.ssh/authorized_keys\nchmod 700 ~/.ssh\n```\n\n### 下载私钥到本地\n\n将~/.ssh/id_rsa下载到本地\n\n使用scp下载\n\n在本地电脑上使用scp user@hostname:~/.ssh/id_rsa 本地目录\n\n列如\n\n```text\nscp user@hostname:~/.ssh/id_rsa ./Desktop/id_rsa\n```\n\n将私钥放在桌面\n\n### 打开公钥登录\n\n编辑/etc/ssh/sshd_config\n\n```bash\nvim /etc/ssh/sshd_config\n```\n\n![image-20230614214920714](./Image/Linux基础.assets/image-20230614214920714.png)\n\nPubkeyAuthentication no改为yes\n\n然后:wq!推出\n\n\n\n### 重启ssh服务\n\n```bash\nsystemctl restart sshd.service\n```\n\n### 测试公钥登录\n\n### openssh登录\n\nssh -i 私钥位置 user@hostname\n\n如果有私钥密码的话会提示输入私钥密码，没有密码则直接登录成功\n\n\n\n\n\n### 关闭密码登录\n\n更改/etc/ssh/sshd_config\n\n```bash\nsudo vim /etc/ssh/sshd_config\n```\n\n找到PasswordAuthentication 将yes改为no\n\n![image-20230614215051429](./Image/Linux基础.assets/image-20230614215051429.png)\n\n:wq!保存配置\n\n再次使用密码登录的时候服务器已经拒绝了。这样安全性就会大大提升。\n\n\n\n\n\n## Ubuntu修改默认SSH端口\n\n### 防火墙设置\n\n- 如果服务器没有防火墙 ，则先安装防火墙 ： `sudo apt install ufw`\n- 防火墙安装好后，查看服务器防火墙状态：`sudo ufw status`\n  - ![image-20230616214724197](./Image/Linux基础.assets/image-20230616214724197.png)\n- 我这里防火墙状态： `status: active`表示为已启动。如果是`inactive`表示未启动状态 ，我们可以通过`sudo ufw enable`来启动防火墙 。\n  启动防火墙时 ，服务器会提示：`Command may disrupt existing ssh connections. Proceed with operation (y|n)?`\n  意思就是,命令有可能会中断本次ssh的连接，是否继续。\n  我们选择继续： `y`，会提示防火墙已打开。\n\n\n\n注意，如果防火墙是这回安装的，重启防火墙之前一定要记得执行一下`sudo ufw allow 22`开放默认的ssh端口否则无法再次连接到系统\n\n\n\n\n\n如果之前安装过防火墙，这里使用`sudo ufw allow 自定义的端口`先放行准备修改的端口。\n\n\n\n### 服务器防火墙端口开放&关闭与ssh默认22端口修改\n\n- 在防火墙状态开启的状态下 ，我们可以设置开放的端口 。比如ssh连接默认用到的22端口 。在终端继续执行 `sudo ufw allow 22`这样 ，22端口就可以访问了 。\n- 考虑到服务器安全因素。我想把ssh默认的22端口禁止访问，并修改成自定义端口替代。\n  - 第一步：先在防火墙内设置允许开发你需要自定义的端口：`sudo ufw allow 指定的端口号`\n  - 第二步：编辑ssh配置文件： `sudo vim /etc/ssh/sshd_config`， 加入`Port 指定的端口号`保存`:wq`退出。（注意如果不想关闭22端口的话 ，可以不注释掉，linux允许多个端口进行SSH登录）\n  - 第三步： 在改好配置文件后 ，重新启动ssh服务：`service ssh restart`就生效了。\n\n\n\n\n\n## 安装transmission的WebUI版本\n\n### Transmission介绍\n\nTransmission是一个强大的BitTorrent开源客户端，实现了BT协议中描述的大多数功能。目前，在它的官方网站上提供了多个版本可以下载，包括：Mac、GTK+、QT版本，还有Daemon版本。\n\nUbuntu下有多个版本，区分：\n\n- transmission-gtk: GTK+界面的Transmission BT客户端\n- transmission-qt: QT界面的Transmission BT客户端\n- transmission-cli: 命令行界面的Transmission BT客户端，与QT、GTK+版本功能一样，是命令行下一个完备的BT客户端\n- transmission-daemon: 是一个Transmission的后台守护程序，本身不具备操作指令，只能通过Web客户端或者transmission-remote-cli来进行控制。这个程序特别适合安装在服务器上或者嵌入式系统中，以及一些没有显示器的设备上\n- transmission-remote-cli: 用来控制transmission-daemon的命令套件，本身不具备下载BT的功能，只能够配合daemon使用\n\n\n\n\n\n### 安装transmission(注意版本不能高于4.0)\n\n```bash\nsudo apt-get install transmission-daemon=3.00-2ubuntu2\n```\n\n确认后一路到底，很快，结束后再看看，使用以下命令显示包的信息及其依赖\n\n```bash\ndpkg -s transmission-daemon\n```\n\n\n\n### 配置transmission\n\n1. 停止Transmission守护进程\n\n   - ```bash\n     sudo service transmission-daemon stop\n     ```\n\n     \n\n2. 编辑Transmission配置文件以启用Web界面。在终端中输入以下命令打开配置文件：(下方命令中的文件位置是默认位置，如果改动了需要替换掉)\n\n   - ```\n     sudo vim /etc/transmission-daemon/settings.json\n     ```\n\n     \n\n   - 主要修改如下部分：\n\n     - “download-dir”: “改成下载目录”\n     - “rpc-host-whitelist-enabled”: true,\n     - “rpc-password”: “改成你要的密码”,\n     - “rpc-port”: 9091,\n     - “rpc-url”: “/transmission/”,\n     - “rpc-username”: “改成你要的用户名”,\n     - “rpc-whitelist”: “*”, // 白名单，直接设置 * 就行\n     - “rpc-whitelist-enabled”: false,\n\n3. 修改完后重新启动daemon后，如果密码被修改过，程序会计算密码的hash值，并将其填充到\"rpc-password\"这一项里，图里的也是一串字符\n\n   - ![image-20230617103045078](./Image/Linux基础.assets/image-20230617103045078.png)\n\n\n\n\n\n### 重新启动transmission\n\n```bash\nsudo service transmission-daemon start\n```\n\n\n\n\n\n### 存在的一些问题\n\n#### 装好后开始下载种子，会提示权限不够，即无法写入文件夹\n\n使用 `ps -ef` 查看，发现transmission运行在Debian用户下，而文件夹都是root才能rwx\n\n方法一：修改文件夹权限，0777，参考网上一些经验，可能不解决问题\n\n方法二：使transmission运行在root或特定的用户下\n\n先停止服务，方法很多，这里与前面不同（一般服务都有几种方法停止）\n\n```bash\nsudo systemctl stop transmission-daemon.service\n```\n\n \n\n**修改用户**\n\n```bash\nsudo vim /etc/init.d/transmission-daemon\n```\n\n在里面加入这一行，root可替换为需要的用户名\n\n```bash\nUSER=root\n```\n\n**再修改一项**\n\n```bash\nsudo systemctl edit transmission-daemon.service\n```\n\n里面加上如下部分，注意大小写\n\n```\n[Service]\nUser=root\n```\n\n \n\n重启服务后即可使用，这里要重启两个部分\n\n缺少前一个会提示\n\n```bash\nWarning: The unit file, source configuration file or drop-ins of transmission-da\nemon.service changed on disk. Run 'systemctl daemon-reload' to reload units.\n```\n\n重启的命令，两条先后执行\n\n```bash\nsudo systemctl daemon-reload\nsudo systemctl start transmission-daemon.service\n```\n\n\n\n\n\n#### 安装完成后，使用`ip:端口号`的形式打不开管理页面\n\n- 检查防火墙有没有放行对应的端口\n  - 如果没放行就添加端口放行\n- 检查配置文件的白名单 `whitelist`，查看访问时的ip是否在白名单中。\n\n\n\n\n\n### 安装美化的WebUI\n\nhttps://github.com/ronggang/transmission-web-control\n\nhttps://github.com/ronggang/transmission-web-control/raw/master/release/install-tr-control-cn.sh\n\n\n\n\n\n\n\n## 安装qBittorrent webUI\n\n### 安装本体\n\n```bash\nsudo apt install qbittorrent\n```\n\n### 安装WebUI\n\n下载可能会很卡顿 可以尝试挂梯子\n\n```bash\nsudo add-apt-repository ppa:qbittorrent-team/qbittorrent-stable\n\nsudo apt update\n\nsudo apt install qbittorrent-nox\n```\n\n### 打开qb\n\n```bash\nqbittorrent-nox\n```\n\n![image-20230617222108951](./Image/Linux基础.assets/image-20230617222108951.png)\n\n\n\n\n\n### 设置自动启动\n\n创建用户和组，以便它可以作为非特权用户运行，这将提高服务器的安全性：\n\n```bash\nsudo adduser your-username qbittorrent-nox\n```\n\n然后创建一个系统化服务文件：\n\n```bash\nsudo vim /etc/systemd/qbittorrent-nox.service\n```\n\n将以下行复制并粘贴到文件中。如果有其他服务使用端口 8080，则需要将 qBitorrent 的端口号更改为其他服务，如 8081。\n\n```bash\n[Unit]\nDescription=qBittorrent Command Line Client\nAfter=network.target\n \n[Service]\n#Do not change to \"simple\"\nType=forking\nUser=qbittorrent-nox\nGroup=qbittorrent-nox\nUMask=007\nExecStart=/usr/bin/qbittorrent-nox\nRestart=on-failure\n \n[Install]\nWantedBy=multi-user.target\n```\n\n保存文件之后，启动qb系统服务：\n\n```\nsudo systemctl start qbittorrent-nox\n```\n\n重新加载系统守护程序：\n\n```\nsudo systemctl daemon-reload\n```\n\n设置跟随系统自动启动：\n\n```\nsudo systemctl enable qbittorrent-nox\n```\n\n查看启动状态：\n\n```\nsystemctl status qbittorrent-nox\n```\n\n访问`Web UI`：\n\n同样采用`IP:8080`的方式。用户名为`admin`，密码为`adminadmin`\n\n\n\n\n\n## armv7l 安装docker-compose\n\n### 摘要\n\n[docker官网安装docker-compose](https://docs.docker.com/compose/install/)出现下载失败，手动下载安装[docker](https://so.csdn.net/so/search?q=docker&spm=1001.2101.3001.7020)-compose\n\n### 安装\n\n#### 1、下载\n\n[github地址](https://github.com/docker/compose/releases)\n\n如果不知道自己系统版本的可以在服务器输入：\n\n```bash\necho \"docker-compose-$(uname -s)-$(uname -m)\"\n\ndocker-compose-linux-aarch64\n```\n\n直接下载相应系统的包(如docker-compose-linux-aarch64)到服务器上\n\n#### 2、拷贝到/usr/local/bin/目录，修改权限\n\n```bash\ncp docker-compose-linux-aarch64 /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\nsudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose\n123\n```\n\n### 使用\n\n```bash\ndocker-compose --version\n```\n\n\n\n## 玩客云armbian5.67手动安装qb,tr,samba,FTP实现文件下载与共享\n\n### 环境\n\n![img](./Image/Linux基础.assets/144313kpdbpk8v2ibb1pv2.png)\n\n\n刷了amrbian5.67的玩客云\n\n\n之前也刷过高内核的版本，不过很不稳定，不定时死机。\n\n5.67刷起来最简单，千兆口，跑起来最稳定不用担心死机问题。通过QB下载PT资源也能跑到25mb/s 200M宽带 不过CPU负载接近满了。\n通过Zerotier内网穿透，在外也能随便访问家里的玩客云资源，当个小NAS也够用了。Zerotier教程网上挺多的可以去搜下\n\n最终在这台盒子上装了Zerotier实现内网穿透Xray实现XX上网\nFile Browser文件管理器：文件下载\nsamba PURE-FTP文件共享与下载\nqbittorrent与transmission BT PT下载\n\n\n只要是个LINUX系统的都可以用此方法安装这些软件\n\n贴个清华软件源 vim /etc/apt/sources.list\n\n```\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ stretch main contrib non-free\n\ndeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ stretch main contrib non-free\n\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ stretch-updates main contrib non-free\n\ndeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ stretch-updates main contrib non-free\n\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian-security/ stretch/updates main contrib non-free\n\ndeb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security/ stretch/updates main contrib non-free\n```\n\n\n\n改个时区\n\n```\ntimedatectl set-timezone Asia/Shanghai\n```\n\n\n\n### qbittorrent安装\n\n**1.添加软件源**5.67是基于 debian9的\n\n因为denbian9软件源自带的qbittorrent市3.几的很老的版本，我们要装的是4.25版本。\n\n进入debian官方packages：https://packages.debian.org/\n\n划到最下面 搜索软件包的内容 搜索 qbittorrent-nox\n\n发行版选择testing\n\n硬件架构选择：根据自己设备CPU选择： 玩客云选armhf\n\n![img](./Image/Linux基础.assets/151831m8uo8c2iiu998zx8.png)\n搜索完点击软件包\n![img](./Image/Linux基础.assets/152157b9l82niwi8anvwln.png)\n划到最下面选择对应的CPU架构\n![img](./Image/Linux基础.assets/151938ouwcwncrm0a41uun.png)\n进入如下页面根据提示\n![img](./Image/Linux基础.assets/152719ku32uy9r2wrajsrd.png)\n我们选择一个亚洲的站点\n![img](./Image/Linux基础.assets/152747mfn6z6mrbwf1ymff.png)\n最终打开 vi/etc/apt/sources.list 文件\n\n#### 添加以下软件源，保存退出\n\n上面那些图片流程其实都可以略过 直接添加以下软件源就可以了\n\n```\ndeb http://ftp.cn.debian.org/debian bullseye main\n```\n\n#### 安装执行命令更新软件源\n\n```\napt update\n```\n\n\n\n#### 执行`apt show qbittorrent-nox`确定出现的为4.2.5版本就可以安装了\n\n```\nroot@debian:~# apt show qbittorrent-nox\n\nPackage: qbittorrent-nox\n\nVersion: 4.2.5-0.1\n```\n\n\n\n#### 安装\n\n```\napt install qbittorrent-nox\n```\n\n\n\n#### 启动命令\n\n```\nqbittorrent-nox\n```\n\n\n\n******** 信息 ********\n欲通过 Web UI 控制 qBittorrent，请访问[http://localhost:8080](http://localhost:8080/)\nWeb UI 管理员的用户名是：admin\nWeb UI 管理员的密码仍为默认密码：adminadmin\n存在安全风险，请考虑在程序设置中更改密码。\n\n![img](./Image/Linux基础.assets/153816w4ip4zc5lucjbupa.png)\n\n\n\n#### **配置开机自启动服务**\n\n使用命令启动，终端一关服务就停止了，很不方便。所以要配置一个开机自启动服务\n\n\n新建一个文件\n\n```\nvim /etc/systemd/system/qbittorrent.service\n```\n\n\n\n写入以下内容\n\n\n\n```\n[Unit]\nDescription=qbittorrent torrent server\n\n[Service]\nUser=root\nExecStart=/usr/bin/qbittorrent-nox\nRestart=on-abort\n\n[Install]\nWantedBy=multi-user.target\n```\n\n\n\n重新加载单元\n\n```\nsystemctl daemon-reload\n```\n\n\n\n设置成开机自启动\n\n```\nsystemctl enable qbittorrent     #开启自启\nsystemctl start qbittorrent #开启qb\nsystemctl stop qbittorrent #关闭qb\nsystemctl restart qbittorrent #重启qb\n```\n\n\n\n\n\n### transmission安装\n\n#### **1.安装**\n\n```\napt install transmission-daemon\n```\n\n\n\n访问地址：IP：9091\n打开浏览器访问错误的话****修改以下选项\n打开配置文件\n\n```\nvim /etc/transmission-daemon/settings.json\n```\n\n\n\n找到以下两项其中一项进行修改\n\n```\n\"rpc-whitelist\": \"*\", #输入* 所有IP都可以访问，或者自定义。\n或者\n\"rpc-whitelist-enabled\": false, #关闭白名单功能\n```\n\n#### **2.中文面板**\n\n项目地址：[color=var(--link-color)]https://github.com/ronggang/transmission-web-control\n\n下载安装脚本\n\n```\nwget https://github.com/ronggang/transmission-web-control/raw/master/release/install-tr-control-cn.sh\n```\n\n\n\n执行安装 输入 1 安装\n\n```\nbash install-tr-control-cn.sh\n```\n\n\n\n完成后重启\n\n```\nsystemctl restart transmission-daemon\n```\n\n\n\n![img](./Image/Linux基础.assets/155105snfva69mwssaplsc.png)\n\n\n\n\n\n### **Samba安装**\n\n```\napt install samba\n```\n\n创建测试用户\n\n```\nuseradd sambashare\n```\n\n设置用户密码\n\n```\npasswd sambashare  sambahurr9999!\n```\n\n将sambashare用户加入Samba用户数据库\n\n```\nsmbpasswd -a sambashare\n```\n\n打开配置文件\n\n```\nvim /etc/samba/smb.conf\n```\n\n在下面添加需要账号密码登陆的配置\n\n```\n[sambashare]\n   comment = test share dir\n   browsable = yes\n   path = /hdisk    #共享目录\n   public = yes  #公开\n   valid users = sambashare #用户名\n   read only =no  #只读---只读和可写二选一\n   writable = yes  #可写---只读和可写二选一       \n   create mask = 0700\n   directory mask = 0700\n```\n\n匿名访问\n\n```\n[anonymous]\n   path = /dir\n   force group = test\n   create mask = 0700\n   directory mask = 0700\n   browsable =yes  \n   read only =yes  #只读\n   guest ok = yes  #来宾访问\n```\n\n保存重启\n\n```\nsystemctl restart smbd\n```\n\n### **5.Pure-ftp 安装**安装\n\n```\napt install pure-ftpd\n```\n\n\n\n配置文件路径\n\n```\nvim /etc/pure-ftpd/pure-ftpd.conf\n```\n\n创建测试用户\n\n```\nuseradd test\n```\n\n设置用户密码\n\n```\npasswd test\n```\n\n创建FPT用户\n\n```\npure-pw useradd test2 -u test -d /xxx\n```\n\n-u：选项将虚拟用户test2与系统用户test关联在一起，即使用test2账号登录FTP后，会以test的身份来读取和下载文件。\n\n-d：选项后面的目录为test2账户的家目录，这样可以使test2只能访问其家目录/xxx\ntest\n\n创建用户信息数据库文件\n\n```\npure-pw mkdb\n```\n\n查看用户列表\n\n```\npure-pw list\n\ntest2          /xxx/./\n```\n\n查看用户信息\n\n```\npure-pw show test2\n```\n\n重启服务\n\n```\nsystemctl restart pure-ftpd\n```\n\n都装好好需要测试调试，还有接硬盘需要挂载，百度一下挂载教程。\n","tags":["protected","Linux"],"categories":["Linux"]},{"title":"Linux基础","url":"/2022/08/18/Linux基础/","content":"\n# 启动过程概述(大部分均未验证，可靠性存疑？)\n\nLinux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段：\n\n- 内核的引导。\n- 运行 init。\n- 系统初始化。\n- 建立终端 。\n- 用户登录系统。\n\n> init程序的类型：\n>\n> - **SysV:** init, CentOS 5之前, 配置文件： /etc/inittab。\n> - **Upstart:** init,CentOS 6, 配置文件： /etc/inittab, /etc/init/*.conf。\n> - **Systemd：** systemd, CentOS 7,配置文件： /usr/lib/systemd/system、 /etc/systemd/system。\n\n\n\n## 内核引导\n\n首先BIOS自检，然后按照设置的启动设备来启动。\n\n当操作系统接管硬件以后，首先读入/boot 目录下的内核文件。\n\n\n\n## 运行init\n\ninit进程是系统所有进程的起点，没有这个进程，系统中任何进程都不会启动（类似于所有进程的父类）、\n\ninit程序首先是需要读取配置文件 /etc/inittab\n\n\n\n### 运行级别\n\n​\t\t许多程序需要开机启动。它们在Windows叫做\"服务\"（service），在Linux就叫做\"守护进程\"（daemon）。\n\n​\t\tinit进程的一大任务，就是去运行这些开机启动的程序。\n\n​\t\t但是，**不同的场合需要启动不同的程序**，比如用作服务器时，需要启动Apache，用作桌面就不需要。\n\n​\t\tLinux允许为不同的场合，分配不同的开机启动程序，这就叫做\"运行级别\"（runlevel）。也就是说，启动时根据\"运行级别\"，确定要运行哪些程序。\n\n\n\n#### Linux的七个运行级别\n\n**Linux系统有7个运行级别(runlevel)：**\n\n- **运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动**\n- **运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆**\n- **运行级别2：多用户状态(没有NFS)**\n- **运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式**\n- **运行级别4：系统未使用，保留**\n- **运行级别5：X11控制台，登陆后进入图形GUI模式**\n- **运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动**\n\n\n\n## 系统初始化\n\n​\t\t在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。\n\n​\t\t它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。\n\n\n\n## 建立终端\n\nrc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。\n\ninit接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：\n\n```\n1:2345:respawn:/sbin/mingetty tty1\n2:2345:respawn:/sbin/mingetty tty2\n3:2345:respawn:/sbin/mingetty tty3\n4:2345:respawn:/sbin/mingetty tty4\n5:2345:respawn:/sbin/mingetty tty5\n6:2345:respawn:/sbin/mingetty tty6\n```\n\n从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。\n\n同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。\n\n\n\n## 用户登录系统\n\n一般来说，用户的登录方式有三种：\n\n- （1）命令行登录\n- （2）ssh登录\n- （3）图形界面登录\n\n​\t\t对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。\n\nLinux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。\n\n然后 login 会对用户名进行分析：如果用户名不是 root，且存在 /etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出。\n\n这通常用来系统维护时防止非root用户登录。只有/etc/securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。\n\n/etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。\n\n\n\n## 图形模式与文字模式的切换方式\n\nLinux预设提供了六个命令窗口终端机让我们来登录。\n\n默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。\n\n如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。\n\n当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。\n\n如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space + F1~F6. 如果你在图形界面下请按Alt + Shift + Ctrl + F1~F6 切换至命令窗口。\n\n\n\n# Linux的关机、重启、用户登录\n\n## 关机&重启（需要root权限）\n\n### sync\n\n​\t将内存中的数据写入到硬盘中，做好关机的准备。\n\n\n\n### shutdown\n\n- 无参数，单独一个shutdown命令，系统会在一分钟后关机\n- now\n  - shutdown now，立刻关机\n- 时间\n  - shutdown 15:48 \t\t//在15：48时关闭\n\n- 分钟数\n  - 在指定的分钟数后关机\n\n- -c\n  - 取消之前设定的关机\n\n- -r\n  - 关机后自动开机，进行一次重启操作，效果等于reboot\n\n- -H\n  - 等同于halt\n\n- \n\n\n\n### halt\n\n​\t\t停机，关闭系统，但不断电。进入下图的状态\n\n![image-20220819103611661](image-20220819103611661.png)\n\n\n\n\n\n### poweroff\n\n​\t\t关机，断电。\n\n\n\n### reboot\n\n- 立刻重启计算机\n- \n\n| 命令     | 参数   | 作用                                |\n| -------- | ------ | ----------------------------------- |\n| shutdown |        | 一分钟后关机                        |\n| shutdown | -h 1   | 一分钟后关机，可以将1改为其他数值。 |\n| shutdown | now    | 立刻关机                            |\n| shutdown | -r now | 立刻重启                            |\n| halt     |        | 关机                                |\n| reboot   |        | 立刻重启                            |\n| sync     |        | 将内存的数据同步到磁盘              |\n\n### 补充说明\n\n- 当使用shutdown命令关机时，在还没有关机的时候可以使用 `-c\t`来取消关机（shutdown -c）\n\n\n\n\n\n\n\n## 用户登录\n\n### 切换其他用户\n\nsu - 用户名\n\n单一个su表示切换到root账户\n\n需要注意的是，当从root账户切换到普通账户的时候，是不需要输入密码的。\n\n### 退出当前用户 logout（图形界面无效）\n\n如果登陆后没有切换用户直接执行logout则直接退出系统；如果切换了其他系统后执行logout，则回退到切换之前的账户（类似于栈的规则，登录依次入栈一个，登出出栈，直到栈空退出） \n\n   \n\n\n\n\n\n# Linux文件\n\n## 基本属性\n\nLinux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。\n\n为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。\n\n\n\n## 文件权限\n\n在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：\n\n- chown (change owner) ： 修改所属用户与组。\n- chmod (change mode) ： 修改用户的权限。\n\n可以通过chown 来授权用户，通过 chmod 为用户设置可以开门的权限。\n\n\n\n在 Linux 中可以使用 **ll** 或者 **ls –l** 命令来显示一个文件的属性以及文件所属的用户和组，如：\n\n> [hurr@MiWiFi-R3-srv ~]$ ll\n> total 0\n> drwxr-xr-x. 2 hurr hurr 41 Aug  6 05:25 Desktop\n> drwxr-xr-x. 2 hurr hurr  6 Aug  5 05:49 下载\n> drwxr-xr-x. 2 hurr hurr  6 Aug  5 05:49 公共\n> drwxr-xr-x. 2 hurr hurr  6 Aug  5 05:49 图片\n> drwxr-xr-x. 2 hurr hurr  6 Aug  5 05:49 文档\n> drwxr-xr-x. 2 hurr hurr  6 Aug  5 05:49 桌面\n> drwxr-xr-x. 2 hurr hurr  6 Aug  5 05:49 模板\n> drwxr-xr-x. 2 hurr hurr  6 Aug  5 05:49 视频\n> drwxr-xr-x. 2 hurr hurr  6 Aug  5 05:49 音乐\n>\n> [hurr@MiWiFi-R3-srv ~]$ cd ./Desktop\n> [hurr@MiWiFi-R3-srv Desktop]$ ll\n> total 4\n> -rw-rw-r--. 1 hurr hurr 64 Aug  6 02:14 Hello.c\n\n**bin** 文件的第一个属性用 **d** 表示。**d** 在 Linux 中代表该文件是一个目录文件。\n\n**在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等**。\n\n- 当为 **d** 则是目录\n- 当为 **-** 则是文件；\n- 若是 **l** 则表示为链接文档(link file)；\n- 若是 **b** 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；\n- 若是 **c** 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。\n\n接下来的字符中，以三个为一组，且均为 **rwx** 的三个参数的组合。其中， **r** 代表可读(read)、 **w** 代表可写(write)、 **x** 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 **-** 而已。\n\n![img]({DC987EEF-7038-4633-A9D5-0A1A34E1EC50})\n\n**每个文件的属性由左边第一部分的 10 个字符来确定（如下图）。**\n\n**![image-20220807145839123](image-20220807145839123.png)**\n\n从左至右用 **0-9** 这些数字来表示。\n\n第 **0** 位确定文件类型，第 **1-3** 位确定属主（该文件的所有者）拥有该文件的权限。\n\n第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。\n\n其中，第 **1、4、7** 位表示读权限，如果用 **r** 字符表示，则有读权限，如果用 **-** 字符表示，则没有读权限；\n\n第 **2、5、8** 位表示写权限，如果用 **w** 字符表示，则有写权限，如果用 **-** 字符表示没有写权限；第 **3、6、9** 位表示可执行权限，如果用 **x** 字符表示，则有执行权限，如果用 **-** 字符表示，则没有执行权限。\n\n\n\n### Linux文件属主和属组\n\n对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。\n\n同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。\n\n文件所有者以外的用户又可以分为文件所属组的同组用户和其他用户。\n\n因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。\n\n> [hurr@MiWiFi-R3-srv ~]$ ll\n> total 0\n> drwxr-xr-x. 2 hurr hurr 41 Aug  6 05:25 Desktop\n\n在以上实例中，Desktop 文件是一个目录文件，属主和属组都为 hurr，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。\n\n**对于 root 用户来说，一般情况下，文件的权限对其不起作用。**\n\n\n\n\n\n### 更改文件属性（需要root权限）\n\n#### chgrp：更改文件属组\n\n语法：\n\n```\nchgrp [-R] 属组名 文件名\n```\n\n参数选项\n\n- -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。\n\n#### chown：更改文件属主，也可以同时更改文件属组\n\n语法：\n\n```\nchown [–R] 属主名 文件名\nchown [-R] 属主名：属组名 文件名\n```\n\n进入 /root 目录（~）将install.log的拥有者改为bin这个账号：\n\n```\n[root@www ~] cd ~\n[root@www ~]# chown bin install.log\n[root@www ~]# ls -l\n-rw-r--r--  1 bin  users 68495 Jun 25 08:53 install.log\n```\n\n将install.log的拥有者与群组改回为root：\n\n```\n[root@www ~]# chown root:root install.log\n[root@www ~]# ls -l\n-rw-r--r--  1 root root 68495 Jun 25 08:53 install.log\n```\n\n####chmod：更改文件9个属性\n\nLinux文件属性有两种设置方法，一种是数字，一种是符号。\n\nLinux 文件的基本权限就有九个，分别是 **owner/group/others(拥有者/组/其他)** 三种身份各有自己的 **read/write/execute（读/写/执行）** 权限。\n\n##### 数字方式修改\n\n先复习一下刚刚上面提到的数据：文件的权限字符为： **-rwxrwxrwx** ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：\n\n- r:4\n- w:2\n- x:1\n\n每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： **-rwxrwx---** 分数则是：\n\n- owner = rwx = 4+2+1 = 7\n- group = rwx = 4+2+1 = 7\n- others= --- = 0+0+0 = 0\n\n所以等一下我们设定权限的变更时，该文件的权限数字就是 **770**。变更权限的指令 chmod 的语法是这样的：\n\n```\n chmod [-R] xyz 文件或目录\n```\n\n选项与参数：\n\n- **xyz** : 就是刚刚提到的数字类型的权限属性，为 **rwx** 属性数值的相加。\n- **-R** : 进行递归(recursive)的持续变更，以及连同次目录下的所有文件都会变更\n\n举例来说，如果要将 **.bashrc** 这个文件所有的权限都设定启用，那么命令如下：\n\n```\n[root@www ~]# ls -al .bashrc\n-rw-r--r--  1 root root 395 Jul  4 11:45 .bashrc\n[root@www ~]# chmod 777 .bashrc\n[root@www ~]# ls -al .bashrc\n-rwxrwxrwx  1 root root 395 Jul  4 11:45 .bashrc\n```\n\n那如果要将权限变成 *-rwxr-xr--* 呢？那么权限的分数就成为 [4+2+1] [4+0+1] [4+0+0]=754。\n\n##### 符号类型改变文件权限\n\n还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：\n\n- user：用户\n- group：组\n- others：其他\n\n那么我们就可以使用 **u, g, o** 来代表三种身份的权限。\n\n此外， **a** 则代表 **all**，即全部的身份。读写的权限可以写成 **r, w, x**，也就是可以使用下表的方式来看：\n\n\n\n| chmod | u g o a | +(加入) -(除去) =(设定) | r w x | 文件或目录 |\n| ----- | ------- | ----------------------- | ----- | ---------- |\n\n\n\n如果我们需要将文件权限设置为 **-rwxr-xr--** ，可以使用 **chmod u=rwx,g=rx,o=r 文件名** 来设定:\n\n```\ntouch test1    // 创建 test1 文件\nls -l test1    // 查看 test1 默认权限\n-rw-r--r-- 1 root root 0 Nov 15 10:32 test1\nchmod u=rwx,g=rx,o=r  test1    // 修改 test1 权限，注意符号两边不能有空格\nls -l test1\n-rwxr-xr-- 1 root root 0 Nov 15 10:32 test1\n```\n\n而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：\n\n```\nchmod  a-x test1\nls -l test1\n-rw-r--r-- 1 root root 0 Nov 15 10:32 test1\n```\n\n------\n\n\n\n## 目录结构\n\n### 基本介绍\n\n1. 采用树状目录结构，最上层的根目录是 / 。\n2. 其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。\n3. 在Linux中，一切皆文件 。Linux会把硬件映射成一个文件挂载到dev目录下。\n\n\n\n#### 绝对路径与相对路径\n\n- **绝对路径：**\n  路径的写法，由根目录 **/** 写起，例如： /usr/share/doc 这个目录。\n- **相对路径：**\n  路径的写法，不是由 **/** 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： **cd ../man** 这就是相对路径的写法。其中，..返回到表示上一级目录\n\n###  具体的目录结构\n\n1. /bin [常用] (链接，链接到 /usr/bin 、 /usr/local/bin) \n\n   是 Binary 的缩写, 这个目录存放着最经常使用的命令 \n\n2. /sbin (/usr/sbin 、 /usr/local/sbin) \n\n   s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。 \n\n3. /home [常用] \n\n   存放**普通用户**的主目录，在 Linux 中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名\n\n4. /root [常用]\n\n   该目录为系统管理员，也称作超级权限者 的用户主目录。一般用户无法进入该目录\n\n5. /lib \n\n   系统开机所需要最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要 用到这些共享库 \n\n6. /lost+found \n\n   这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。平时不可见\n\n7. /etc [常用] \n\n   所有的系统管理所需要的配置文件和子目录, 比如安装 mysql 数据库 my.conf \n\n8. /usr [常用] \n\n   这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与 windows 下的 program files 目录。 \n\n9. /boot [常用]\n\n   存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。\n\n10. /proc [不能动] \n\n    这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息 \n\n11. /srv [不能动] \n\n    service 缩写，该目录存放一些服务启动之后需要提取的数据 \n\n12. /sys [不能动]\n\n    这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统\n\n13. /tmp \n\n    这个目录是用来存放一些临时文件的\n\n14. /dev \n\n    类似于 windows 的设备管理器，把所有的硬件用文件的形式存储 \n\n15. /media [常用] \n\n    linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个 目录下 \n\n16. /mnt [常用] \n\n    系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。 d:/myshare \n\n17. /opt \n\n    这是给主机额外安装软件所存放的目录。如安装 ORACLE 数据库就可放到该目录下。默认为空 \n\n18. /usr/local [常用] \n\n    这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序 \n\n19. /var [常用] \n\n    这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件\n\n20. /selinux [security-enhanced linux] \n\n    SELinux 是一种安全子系统,它能控制程序只能访问特定文件, 有三种工作模式，可以自行设置\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Linux 磁盘管理\n\nLinux 磁盘管理好坏直接关系到整个系统的性能问题。\n\nLinux 磁盘管理常用三个命令为 **df**、**du** 和 **fdisk**。\n\n- **df**（英文全称：disk free）：列出文件系统的整体磁盘使用量（显示每个分区的大小？）\n- **du**（英文全称：disk used）：检查磁盘空间使用量(递归显示每个文件夹（包括隐藏文件）的大小)\n- **fdisk**：用于磁盘分区\n\n\n\n## df\n\ndf命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。\n\n语法：\n\n```\ndf [-ahikHTm] [目录或文件名]\n```\n\n选项与参数：\n\n- -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；\n- -k ：以 KBytes 的容量显示各文件系统；\n- -m ：以 MBytes 的容量显示各文件系统；\n- -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；\n- -H ：以 M=1000K 取代 M=1024K 的进位方式；\n- -T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；\n- -i ：不用硬盘容量，而以 inode 的数量来显示\n\n### 实例 1\n\n将系统内所有的文件系统列出来！\n\n```\n[root@www ~]# df\nFilesystem      1K-blocks      Used Available Use% Mounted on\n/dev/hdc2         9920624   3823112   5585444  41% /\n/dev/hdc3         4956316    141376   4559108   4% /home\n/dev/hdc1          101086     11126     84741  12% /boot\ntmpfs              371332         0    371332   0% /dev/shm\n```\n\n​\t\t在 Linux 底下如果 df 没有加任何选项，那么默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！\n\n### 实例 2\n\n将容量结果以易读的容量格式显示出来\n\n```\n[root@www ~]# df -h\nFilesystem            Size  Used Avail Use% Mounted on\n/dev/hdc2             9.5G  3.7G  5.4G  41% /\n/dev/hdc3             4.8G  139M  4.4G   4% /home\n/dev/hdc1              99M   11M   83M  12% /boot\ntmpfs                 363M     0  363M   0% /dev/shm\n```\n\n### 实例 3\n\n将系统内的所有特殊文件格式及名称都列出来\n\n```\n[root@www ~]# df -aT\nFilesystem    Type 1K-blocks    Used Available Use% Mounted on\n/dev/hdc2     ext3   9920624 3823112   5585444  41% /\nproc          proc         0       0         0   -  /proc\nsysfs        sysfs         0       0         0   -  /sys\ndevpts      devpts         0       0         0   -  /dev/pts\n/dev/hdc3     ext3   4956316  141376   4559108   4% /home\n/dev/hdc1     ext3    101086   11126     84741  12% /boot\ntmpfs        tmpfs    371332       0    371332   0% /dev/shm\nnone   binfmt_misc         0       0         0   -  /proc/sys/fs/binfmt_misc\nsunrpc  rpc_pipefs         0       0         0   -  /var/lib/nfs/rpc_pipefs\n```\n\n### 实例 4\n\n将 /etc 底下的可用的磁盘容量以易读的容量格式显示\n\n```\n[root@www ~]# df -h /etc\nFilesystem            Size  Used Avail Use% Mounted on\n/dev/hdc2             9.5G  3.7G  5.4G  41% /\n```\n\n\n\n\n\n\n\n## du\n\nLinux du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍 Linux du 命令。\n\n语法：\n\n```\ndu [-ahskm] 文件或目录名称\n```\n\n选项与参数：\n\n- -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。\n- -h ：以人们较易读的容量格式 (G/M) 显示；\n- -s ：列出总量而已，而不列出每个各别的目录占用容量；\n- -S ：不包括子目录下的总计，与 -s 有点差别。\n- -k ：以 KBytes 列出容量显示；\n- -m ：以 MBytes 列出容量显示；\n\n### 实例 1\n\n只列出当前目录下的所有文件夹容量（包括隐藏文件夹）:\n\n```\n[root@www ~]# du\n8       ./test4     <==每个目录都会列出来\n8       ./test2\n....中间省略....\n12      ./.gconfd   <==包括隐藏文件的目录\n220     .           <==这个目录(.)所占用的总量\n```\n\n**直接输入 du 没有加任何选项时，则 du 会分析当前所在目录里的子目录所占用的硬盘空间。**\n\n### 实例 2\n\n将文件的容量也列出来\n\n```\n[root@www ~]# du -a\n12      ./install.log.syslog   <==有文件的列表了\n8       ./.bash_logout\n8       ./test4\n8       ./test2\n....中间省略....\n12      ./.gconfd\n220     .\n```\n\n### 实例 3\n\n检查根目录底下每个目录所占用的容量\n\n```\n[root@www ~]# du -sm /*\n7       /bin\n6       /boot\n.....中间省略....\n0       /proc\n.....中间省略....\n1       /tmp\n3859    /usr     <==系统初期最大就是他了啦！\n77      /var\n```\n\n通配符 * 来代表每个目录。\n\n与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据。\n\n\n\n## fdisk\n\nfdisk 是 Linux 的磁盘分区表操作工具。\n\n语法：\n\n```\nfdisk [-l] 装置名称\n```\n\n选项与参数：\n\n- -l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。\n\n### 实例 1\n\n列出所有分区信息\n\n```\n[root@MiWiFi-R3-srv Desktop]# fdisk  -l\n\nDisk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x000ad03a\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/sda1   *        2048      616447      307200   83  Linux\n/dev/sda2          616448     4810751     2097152   82  Linux swap / Solaris\n/dev/sda3         4810752    41943039    18566144   83  Linux\n[root@MiWiFi-R3-srv Desktop]#\n\n```\n\n### 实例 2\n\n找出你系统中的根目录所在磁盘，并查阅该硬盘内的相关信息\n\n```\n[root@www ~]# df /            <==注意：重点在找出磁盘文件名而已\nFilesystem           1K-blocks      Used Available Use% Mounted on\n/dev/hdc2              9920624   3823168   5585388  41% /\n\n[root@www ~]# fdisk /dev/hdc  <==仔细看，不要加上数字喔！\nThe number of cylinders for this disk is set to 5005.\nThere is nothing wrong with that, but this is larger than 1024,\nand could in certain setups cause problems with:\n1) software that runs at boot time (e.g., old versions of LILO)\n2) booting and partitioning software from other OSs\n   (e.g., DOS FDISK, OS/2 FDISK)\n\nCommand (m for help):     <==等待你的输入！\n```\n\n输入 m 后，就会看到底下这些命令介绍\n\n```\nCommand (m for help): m   <== 输入 m 后，就会看到底下这些命令介绍\nCommand action\n   a   toggle a bootable flag\n   b   edit bsd disklabel\n   c   toggle the dos compatibility flag\n   d   delete a partition            <==删除一个partition\n   l   list known partition types\n   m   print this menu\n   n   add a new partition           <==新增一个partition\n   o   create a new empty DOS partition table\n   p   print the partition table     <==在屏幕上显示分割表\n   q   quit without saving changes   <==不储存离开fdisk程序\n   s   create a new empty Sun disklabel\n   t   change a partition's system id\n   u   change display/entry units\n   v   verify the partition table\n   w   write table to disk and exit  <==将刚刚的动作写入分割表\n   x   extra functionality (experts only)\n```\n\n离开 fdisk 时按下 `q`，那么所有的动作都不会生效！相反的， 按下`w`就是动作生效的意思。\n\n```\nCommand (m for help): p  <== 这里可以输出目前磁盘的状态\n\nDisk /dev/hdc: 41.1 GB, 41174138880 bytes        <==这个磁盘的文件名与容量\n255 heads, 63 sectors/track, 5005 cylinders      <==磁头、扇区与磁柱大小\nUnits = cylinders of 16065 * 512 = 8225280 bytes <==每个磁柱的大小\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/hdc1   *           1          13      104391   83  Linux\n/dev/hdc2              14        1288    10241437+  83  Linux\n/dev/hdc3            1289        1925     5116702+  83  Linux\n/dev/hdc4            1926        5005    24740100    5  Extended\n/dev/hdc5            1926        2052     1020096   82  Linux swap / Solaris\n# 装置文件名 启动区否 开始磁柱    结束磁柱  1K大小容量 磁盘分区槽内的系统\n\nCommand (m for help): q\n```\n\n想要不储存离开吗？按下 q 就对了！不要随便按 w 啊！\n\n使用 `p` 可以列出目前这颗磁盘的分割表信息，这个信息的上半部在显示整体磁盘的状态。\n\n\n\n\n\n### 磁盘格式化\n\n磁盘分割完毕后自然就是要进行文件系统的格式化，格式化的命令非常的简单，使用 `mkfs`（make filesystem） 命令。\n\n语法：\n\n```\nmkfs [-t 文件系统格式] 装置文件名\n```\n\n选项与参数：\n\n- -t ：可以接文件系统格式，例如 ext3, ext2, vfat 等(系统有支持才会生效)\n\n### 实例 1\n\n查看 mkfs 支持的文件格式\n\n```\n[root@www ~]# mkfs[tab][tab]\nmkfs         mkfs.cramfs  mkfs.ext2    mkfs.ext3    mkfs.msdos   mkfs.vfat\n```\n\n按下两个[tab]键，会发现 mkfs 支持的文件格式如上所示。\n\n### 实例 2\n\n将分区 /dev/hdc6（可指定你自己的分区） 格式化为 ext3 文件系统：\n\n```\n[root@www ~]# mkfs -t ext3 /dev/hdc6\nmke2fs 1.39 (29-May-2006)\nFilesystem label=                <==这里指的是分割槽的名称(label)\nOS type: Linux\nBlock size=4096 (log=2)          <==block 的大小配置为 4K \nFragment size=4096 (log=2)\n251392 inodes, 502023 blocks     <==由此配置决定的inode/block数量\n25101 blocks (5.00%) reserved for the super user\nFirst data block=0\nMaximum filesystem blocks=515899392\n16 block groups\n32768 blocks per group, 32768 fragments per group\n15712 inodes per group\nSuperblock backups stored on blocks:\n        32768, 98304, 163840, 229376, 294912\n\nWriting inode tables: done\nCreating journal (8192 blocks): done <==有日志记录\nWriting superblocks and filesystem accounting information: done\n\nThis filesystem will be automatically checked every 34 mounts or\n180 days, whichever comes first.  Use tune2fs -c or -i to override.\n# 这样就创建起来我们所需要的 Ext3 文件系统了！简单明了！\n```\n\n\n\n\n\n## 磁盘检验\n\nfsck（file system check）用来检查和维护不一致的文件系统。\n\n若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。\n\n语法：\n\n```\nfsck [-t 文件系统] [-ACay] 装置名称\n```\n\n选项与参数：\n\n- -t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数\n- -s : 依序一个一个地执行 fsck 的指令来检查\n- -A : 对/etc/fstab 中所有列出来的 分区（partition）做检查\n- -C : 显示完整的检查进度\n- -d : 打印出 e2fsck 的 debug 结果\n- -p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行\n- -R : 同时有 -A 条件时，省略 / 不检查\n- -V : 详细显示模式\n- -a : 如果检查有错则自动修复\n- -r : 如果检查有错则由使用者回答是否修复\n- -y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。\n\n### 实例 1\n\n查看系统有多少文件系统支持的 fsck 命令：\n\n```\n[root@www ~]# fsck[tab][tab]\nfsck         fsck.cramfs  fsck.ext2    fsck.ext3    fsck.msdos   fsck.vfat\n```\n\n### 实例 2\n\n强制检测 /dev/hdc6 分区:\n\n```\n[root@www ~]# fsck -C -f -t ext3 /dev/hdc6 \nfsck 1.39 (29-May-2006)\ne2fsck 1.39 (29-May-2006)\nPass 1: Checking inodes, blocks, and sizes\nPass 2: Checking directory structure\nPass 3: Checking directory connectivity\nPass 4: Checking reference counts\nPass 5: Checking group summary information\nvbird_logical: 11/251968 files (9.1% non-contiguous), 36926/1004046 blocks\n```\n\n如果没有加上 -f 的选项，则由于这个文件系统不曾出现问题，检查的经过非常快速！若加上 -f 强制检查，才会一项一项的显示过程。\n\n------\n\n## 磁盘挂载与卸除\n\nLinux 的磁盘挂载使用 `mount` 命令，卸载使用 `umount` 命令。\n\n磁盘挂载语法：\n\n```\nmount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点\n```\n\n### 实例 1\n\n用默认的方式，将刚刚创建的 /dev/hdc6 挂载到 /mnt/hdc6 上面！\n\n```\n[root@www ~]# mkdir /mnt/hdc6\n[root@www ~]# mount /dev/hdc6 /mnt/hdc6\n[root@www ~]# df\nFilesystem           1K-blocks      Used Available Use% Mounted on\n.....中间省略.....\n/dev/hdc6              1976312     42072   1833836   3% /mnt/hdc6\n```\n\n磁盘卸载命令 `umount` 语法：\n\n```\numount [-fn] 装置文件名或挂载点\n```\n\n选项与参数：\n\n- -f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；\n- -n ：不升级 /etc/mtab 情况下卸除。\n\n卸载/dev/hdc6\n\n```\n[root@www ~]# umount /dev/hdc6     \n```\n\n\n\n\n\n# 网络配置和系统管理操作\n\n\n\n## 使用静态ip（需要root权限，因为要修改的文件普通用户的权限为只读）\n\n1. 使用ifconfig命令查看网络信息，找到要修改的连接。\n\n   > [hurr@MiWiFi-R3-srv /]$ ifconfig\n   > ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n   >      inet 192.168.228.152  netmask 255.255.255.0  broadcast 192.168.228.255\n   >      inet6 fe80::5585:1c87:20a1:81bb  prefixlen 64  scopeid 0x20<link>\n   >      ether 00:0c:29:4b:64:ef  txqueuelen 1000  (Ethernet)\n   >      RX packets 266683  bytes 35918505 (34.2 MiB)\n   >      RX errors 0  dropped 0  overruns 0  frame 0\n   >      TX packets 10057  bytes 1028319 (1004.2 KiB)\n   >      TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n   >\n   > lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536\n   >      inet 127.0.0.1  netmask 255.0.0.0\n   >      inet6 ::1  prefixlen 128  scopeid 0x10<host>\n   >      loop  txqueuelen 1000  (Local Loopback)\n   >      RX packets 91  bytes 8784 (8.5 KiB)\n   >      RX errors 0  dropped 0  overruns 0  frame 0\n   >      TX packets 91  bytes 8784 (8.5 KiB)\n   >      TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n   >\n   > virbr0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500\n   >      inet 192.168.122.1  netmask 255.255.255.0  broadcast 192.168.122.255\n   >      ether 52:54:00:97:44:be  txqueuelen 1000  (Ethernet)\n   >      RX packets 0  bytes 0 (0.0 B)\n   >      RX errors 0  dropped 0  overruns 0  frame 0\n   >      TX packets 0  bytes 0 (0.0 B)\n   >      TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\n2. 记住要修改的连接的名称，如`ens33` 。使用vim编辑器编辑 `/etc/sysconfig/network-scripts/ifcfg-ens33`，将其中的`BOOTPROTO=\"dhcp\"`更改为`BOOTPROTO=\"static\"` ，并在后面加上：(子网掩码可以不写，前提是没有划分子网)\n\n   - IPADDR=指定的IP地址\n   - GATEWAY=当前网络的网关\n   - DNS1=DNS服务器地址（如有多个可以继续DNS2=...）\n\n3. 修改后，需要重启计算机或者使用`service network restart`命令重启网络服务后才能生效。\n\n   ### 修改后的文件样例\n\n   ```\n   TYPE=\"Ethernet\"\n   PROXY_METHOD=\"none\"\n   BROWSER_ONLY=\"no\"\n   BOOTPROTO=\"static\"\n   DEFROUTE=\"yes\"\n   IPV4_FAILURE_FATAL=\"no\"\n   IPV6INIT=\"yes\"\n   IPV6_AUTOCONF=\"yes\"\n   IPV6_DEFROUTE=\"yes\"\n   IPV6_FAILURE_FATAL=\"no\"\n   IPV6_ADDR_GEN_MODE=\"stable-privacy\"\n   NAME=\"ens33\"\n   UUID=\"54409aa0-de89-4ec9-94f8-3d7f1285527b\"\n   DEVICE=\"ens33\"\n   ONBOOT=\"yes\"\n   #IP地址\n   IPADDR=192.168.228.98\n   #网关\n   GATEWAY=192.168.228.254\n   #域名解析器（dns)\n   DNS1=192.168.228.254\n   \n   ```\n\n\n\n\n\n## 配置主机名（也需要root权限才能保存）\n\n相关信息：\n\n- 查看当前计算机的主机名：`hostname`\n- 存储主机名的配置文件：`/etc/hostnam`\n- 查看当前计算机的系统信息：`hostnamectl`\n\n1. 使用vim编辑器编辑`/etc/hostname`文件，里面存储了当前计算机的主机名。\n   - 或者使用`hostnamectl set-hostname 想要修改的用户名`\n2. 重启服务，可以重启计算机（有时不重启也能成功？）\n\n\n\n# 系统管理\n\n## service服务管理（CentOS6）\n\n### 基本语法\n\n```\nservice 服务名 start|stop|restart|status(开启，结束，重启，当前状态)\n```\n\n需要注意的是，使用的服务名，都必须是在`/etc/init.d/`目录中有的\n\n\n\n\n\n## systemctl\t(CentOS7)\n\n### 基本语法\n\n```\nsystemctl start|stop|restart|status 服务名\n```\n\n同service一样，systemctl所执行的服务都存放在一个目录下面，不过变成了`/usr/lib/systemd/system/`\n\n\n\n### 常用的方法\n\n#### 查看服务\n\nls /usr/lib/sysytemd/\n\n\n\n## 设置服务的自启动\n\n在终端中输入`setup`命令，会进入一个特殊的界面：\n\n（上下左右移动光标，空格键选中）\n\n![image-20220818144055354](image-20220818144055354.png)\n\n进入System services界面\n\n![image-20220818144308427](image-20220818144308427.png)\n\n前面带星号的就是会开机自启的服务，如果想关闭或开启，移动光标到服务名，按空格切换。\n\n\n\n\n\n# 常用的基本命令\n\n\n\n## 帮助命令\n\n### man 获取外部命令的帮助信息\n\n#### 基本语法\n\n- man [命令或配置文件]\n  - -f \n    - 如果命令是内置的，则需要加上-f标志\n\n#### 显示说明\n\n| 信息        | 功能                     |\n| ----------- | ------------------------ |\n| NAME        | 命令的名称和单行描述     |\n| SYNOPSIS    | 怎样使用命令             |\n| DESCRIPTION | 命令功能的深入讨论       |\n| EXAMPLES    | 怎样使用命令的例子       |\n| SEE ALSO    | 相关主题（通常是手册页） |\n\n#### 注意事项\n\n- ​\tman命令初始可能是英文的，需要安装中文语言包。安装命令如下，且安装时需要root权限\n\n  - ` sudo yum install man-pages-zh-CN`\n\n- 只对外部命令生效。\n\n  \n\n### help 获得 shell 内置命令的帮助信息\n\n​\t\t一部分基础功能的系统命令是直接内嵌在 shell 中的，系统加载启动之后会随着 shell 一起加载，常驻系统内存中。这部分命令被称为“内置（built-in）命令”；相应的其它命令 被称为“外部命令”。\n\n#### 基本语法 \n\n- help 内置命令（功能描述：获得 shell 内置命令的帮助信息）\n\n#### 用法样例\n\n` help cd `\n\n#### 注意事项\n\n- 只对内部命令有效，如对外部命令使用会提示\n\n  ```\n  -bash: help: no help topics match `ls'.  Try `help help' or `man -k ls' or `info ls'.\n  ```\n\n\n\n### type 查询命令属于内部命令还是外部命令\n\n#### 基本语法\n\n- type +命令名\n  - 如果命令是内嵌在shell里的，会提示是 shell 内嵌或者is a shell builtin；\n  - 如果命令是外部的，则会显示命令的存放位置或者别名\n\n#### 使用样例\n\n```\n[root@hurr98 hurr]# type cd\ncd 是 shell 内嵌\n[root@hurr98 hurr]# type ls\nls 是 `ls --color=auto' 的别名\n```\n\n```\n[hurr@hurr98 /]$ type cd\ncd is a shell builtin\n[hurr@hurr98 /]$ type ls\nls is aliased to `ls --color=auto'\n```\n\n\n\n### 常用快捷键\n\n| 常用快捷键 | 功能                                 |\n| ---------- | ------------------------------------ |\n| ctrl c     | 停止进程                             |\n| ctrl l     | 清屏，等同于clear，彻底清屏是：reset |\n| tab键      | 根据可用的内容信息进行提示补全       |\n| 上下键     | 查找当前账户执行过的命令             |\n\n\n\n## 常用的关于文件的命令\n\n### pwd 显示当前工作目录的绝对路径\n\n​\t\tpwd ：print working directory 打印工作目录 \n\n#### 基本语法\n\n- ​\tpwd （功能描述：显示当前工作目录的绝对路径）\n  - **-P** ：显示出确实的路径，而非使用链接 (link) 路径。很多命令都有这个选项，在于忽略链接直接考虑实际路径。\n\n \n\n###  ls 列出目录的内容\n\n#### 基本语法\n\n- ls\n  - -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)\n  - -d ：仅列出目录本身，而不是列出目录内的文件数据(常用)（一般与 l 连用？不清楚具体使用目的）\n  - -l ：长数据串列出，包含文件的属性与权限等等数据；(常用)\n\n列出当前目录下的所有文件夹及文件\n\n如：\n\n> [root@MiWiFi-R3-srv /]# ls\n> bin   etc   lib64  opt   run   sys  var\n> boot  home  media  proc  sbin  tmp\n> dev   lib   mnt    root  srv   usr\n\n\n\n### cd 切换路径\n\n#### 基本语法\n\n- cd \n  - cd 绝对路径\t切换到指定的路径\n  - cd 相对路径\t切换到指定的路径\n  - 无参数，或者为~\t回到当前用户的家目录\n  - cd -\t回到上一次所在的目录\n  - cd ..\t回到上一级目录（相对地址中的..为上一级目录）\n  - cd -P\t跳转到实际物理路劲，而非快捷方式路径\n\n\n\n\n\n\n### mkdir 创建一个新的目录\n\n#### 基本语法\n\n- mkdir + 要创建的目录\n  - -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～\n  - -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！\n\n#### 样例\n\n- ​\t在当前目录（文件夹）下创建一个名叫test目录（文件夹）:\t\t\n\n\n```\nmkdir test\n```\n\n- ​\t在当前文件夹下创建一个目录为test1/test2/test3/test4的目录（即一条命令创建一个文件夹的嵌套组合）\n\n\n```\n[root@MiWiFi-R3-srv Desktop]# mkdir test1/test2/test3/test4\nmkdir: cannot create directory ‘test1/test2/test3/test4’: No such file or directory            //直接创建会报错，需要加上-p\n[root@MiWiFi-R3-srv Desktop]# mkdir -p test1/test2/test3/test4\n[root@MiWiFi-R3-srv Desktop]#\n```\n\n- ​\t指定创建出来的目录的权限（不可读不可写不可执行）\n\n\n​\t\t\tmkdir -m 000 tmp\n\n​\t\t\t上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。\n\n​\t\t\t如果使用 -m ，如上例我们给予 -m 000 来给予新的目录 d--------- 的权限。\n\n\n\n### rmdir删除一个空的目录\n\n#### 基本语法\n\n- rmdir + 要删除的目录名\n  - **-p ：**从该目录起，一次删除多级空目录\n\n注意，该命令只能删除空的文件夹，如果删除的文件夹内存在文件，则会报： Directory not empty（目录不为空）；哪怕是root用户都不能用此命令删除非空的文件夹。\n\n\n\n#### 样例\n\n- 删除当前目录下的test的空文件夹\t\n\n\n```\nrmdir test\n```\n\n- 删除嵌套的多层的空文件夹（上一个命令创建的test嵌套组合）\n\n\n```\nrmdir -p test1/test2/test3/test4\n```\n\n\n\n### touch创建文件\n\n#### 基本语法\n\n- touch + 文件名\n\n#### 样例\n\n​\t在当前目录下创建一个名叫test的文件：\ttouch test\n​\t执行完此命令后创建的文件的属组和属主继承于父文件\n\n\n\n### cp复制文件或目录\n\n#### 基本语法\n\n-  cp 源地址 目的地址\n   - **-a：**相当于 -pdr 的意思，至于 pdr 请参考下列说明；(常用)\n   - **-d：**若来源档为链接档的属性(link file)，则复制链接档属性而非文件本身；\n   - **-f：**为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；\n   - **-i：**若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)\n   - **-l：**进行硬式链接(hard link)的链接档创建，而非复制文件本身；\n   - **-p：**连同文件的属性一起复制过去，而非使用默认属性(备份常用)；\n   - **-r：**递归持续复制，用于目录的复制行为；(常用)\n   - **-s：**复制成为符号链接档 (symbolic link)，亦即『捷径（快捷方式）』文件；\n   - **-u：**若 destination 比 source 旧才升级 destination ！\n\n#### 样例\n\n​\t将桌面上的Hello.c文件复制到test文件夹\n\n```\ncd /home/hurr/Desktop\t\t//跳转到到桌面\ncp ./Hello.c ./test\t\t\t//复制\n```\n\n\n\n### rm 删除文件或目录\n\n#### 基本语法\n\n- rm 文件或目录名\n  - -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；\n  - -i ：互动模式，在删除前会询问使用者是否动作\n  - -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！\n  - -v 显示指令的详细执行过程\n\n#### 样例\n\n​\t删除当前文件夹下的tmp.txt文件\n\n​\t\t rm ./tmp.txt\n\n​\t删除当前文件夹下的test文件夹\n\n​\t\trm -r ./test\n\n\n\n### mv 移动文件与目录，或者修改名称\n\n#### 基本语法\n\n- mv 源地址 目的地址\n- mv 当前名称 新名称\n  - -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；\n  - -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！\n  - -u ：若目标文件已经存在，且 源文件 比较新，才会升级 (update)\n\n\n\n#### 样例 \n\n​\t移动当前目录下的test文件夹到mvtest文件夹内\n\n```\t\nmkdir mvtest\t\t//创建目录\nmv test mvtest\t//移动\n```\n\n​\t将当前目录下的mvtest文件夹改名为mv\n\n``` \nmv mvtest mv\n```\n\n\n\n\n\n\n\n### 文件内容查看\n\n#### cat 正序显示文件的内容\n\n##### 基本语法\n\n- cat + 文件名\n  - -A ：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已；\n  - -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！\n  - -E ：将结尾的断行字节 $ 显示出来；\n  - -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；\n  - -T ：将 [tab] 按键以 ^I 显示出来；\n  - -v ：列出一些看不出来的特殊字符\n\n##### 样例\n\n​\t显示当前目录下的Hello.c文件，并显示行号\n\n> cat Hello.c -b\n>\n> ​     1  #include <stdio.h>\n> ​     2  int main()\n> ​     3  {\n> ​     4          printf(\"Hello\");\n> ​     5          return 0;\n> ​     6  }\n\n\n\n#### tac 倒序显示文件的内容\n\n##### 基本语法\n\n- tac + 文件地址\n\n##### 样例\n\n```\ntac Hello.c\n\n}\n     return 0;\n     printf(\"Hello\");\n{\nint main()\n\n#include <stdio.h>\n```\n\n\n\n#### 显示文件的行号（功能类似于 cat?）\n\n- nl + 文件名\n  - -b ：指定行号指定的方式，主要有两种：\n    -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；\n    -b t ：如果有空行，空的那一行不要列出行号(默认值)；\n  - -n ：列出行号表示的方法，主要有三种：\n    -n ln ：行号在荧幕的最左方显示；\n    -n rn ：行号在自己栏位的最右方显示，且不加 0 ；\n    -n rz ：行号在自己栏位的最右方显示，且加 0 ；\n  - -w ：行号栏位的占用的位数。\n\n##### 样例\n\n显示当前目录下的Hello.c文件\n\n```\n[hurr@MiWiFi-R3-srv Desktop]$ nl Hello.c\n     1  #include <stdio.h>\n     2  int main()\n     3  {\n     4          printf(\"Hello\");\n     5\n     6          return 0;\n\n     7  }\n\n[hurr@MiWiFi-R3-srv Desktop]$\n```\n\n\n\n#### more 逐页显示文件\n\n##### 基本语法\n\n- more + 文件名\n  - 在 more 这个程序的运行过程中，你有几个按键可以按的：\n    - 空白键 (space)：代表向下翻一页；\n    - Enter     ：代表向下翻『一行』；\n    - /字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；\n    - :f      ：立刻显示出档名以及目前显示的行数；\n    - q       ：代表立刻离开 more ，不再显示该文件内容。\n    - b 或 ctrl + b ：代表往回翻页，不过这动作只对文件有用，对管线无用。\n    - = ：显示当前的行号\n\n##### 样例\n\n```\n[root@www ~]# more /etc/man_db.config \n#\n# Generated automatically from man.conf.in by the\n# configure script.\n#\n# man.conf from man-1.6d\n....(中间省略)....\n--More--(28%)  <== 重点在这一行喔！你的光标也会在这里等待你的命令\n```\n\n\n\n#### less 分屏翻动显示，具有搜索功能\n\n- less + 文件名\n  - less运行时可以输入的命令有：\n    - 空白键  ：向下翻动一页；\n    - [pagedown]：向下翻动一页；\n    - [pageup] ：向上翻动一页；\n    - /字串   ：向下搜寻『字串』的功能；\n    - ?字串   ：向上搜寻『字串』的功能；\n    - n     ：重复前一个搜寻 (与 / 或 ? 有关！)\n    - N     ：反向的重复前一个搜寻 (与 / 或 ? 有关！)\n    - q     ：离开 less 这个程序；\n\n\n\n样例：一页一页翻动，以下实例输出/etc/man.config文件的内容：\n\n```\n[root@www ~]# less /etc/man.config\n#\n# Generated automatically from man.conf.in by the\n# configure script.\n#\n# man.conf from man-1.6d\n....(中间省略)....\n:   <== 这里可以等待你输入命令！\n```\n\n\n\n#### head 取出文件的前几行\n\n- head + 文件名\n  - -n ：后面接数字，代表显示几行的意思\n  - 默认的情况中，显示前面 10 行。\n\n\n\n#### tail 取出文件的后面几行\n\n- ​\ttail + 文件名\n  - -n ：后面接数字，代表显示几行的意思\n  - -f ：**表示持续侦测后面所接的档名，按下[ctrl]-c结束tail的侦测，按下[ctrl]-s暂停tail的侦测 如查看日志的操作**\n  - 同样，默认的情况中，显示后面 10 行。\n\n\n\n### echo 输出内容到控制台\n\n#### 基本语法\n\n- echo [选项] [输出内容]\n  -  -e： 支持转义字符，规则和c一样。\n  -  -$ 然后tab，可以查看当前的环境变量（不安静变量有以$开头）\n\n\n\n#### 输出重定向>  追加>>\n\n#### 基本语法\n\n- ls -l > 文件名\n  - 将ls -l命令输出的所有信息写入到指定的文件中（从头写入，覆盖原有）。\n- ls -l >> 文件名\n  - 将ls -l命令输出的所有信息追加写入到指定的文件中（从文件末尾追加写入，保留原有。如果不存在指定的文件，则会自动创建，功能等同于重定向）。\n- cat 文件1 > 文件2\n  - 将文件1的内容覆盖写入到文件2（只要是能在shell中显示的信息都可以通过重定向或者追加运算符写入到指定的文件中去）\n\n\n\n### ln软链接\n\n​\t也称为符号链接，类似于快捷方式或者指针，有自己的数据块，主要存放了链接其他文件的路径。（可以认为是一个特殊的文件）\n\n#### 基本语法\n\n- ln -s [原始文件或目录] [软链接名]\n  - 创建一个软连接\n- ln 文件名 链接名\n  - 创建一个硬链接\n\n#### 注意事项\n\n##### 删除软链接\n\n` rm -rf 软链接名`，而不是 `rm -rf 软链接名/ `\n\n​\t\t**如果使用 `rm -rf 软链接名/ `删除，会把软链接对应的真实目录下内容删掉** \n\n##### 查询是否是软链接\n\n​\t\t通过 `ll`或`ls -l` 就可以查看，列表属性第 1 位是` l`，尾部会有位置指向。\n\n\n\n##### 软链接与硬链接的区别\n\n硬链接相当于指定的文件多了一个指向的链接，而链接是单独的创建了一个单独的文件指向了目标文件。\n\n硬链接相当于创建了一个inode编号相同，但名称不相同的文件，删除硬链接后源文件不会丢失；而软连接只是创建了一个链接文件，通过文件指向源文件，不存在一个inode编号相同名称不同的节点。\n\n\n\n###  history 查看已经执行过的历史命令\n\n#### 基本语法\n\n- history\n\n  - +数量：显示最近执行的几条命令。\n  - -c ：清空所有历史命令的记录\n\n  \n\n#### 注意事项\n\n​\t\t使用此命令可以查看当前使用过的所有命令，并以`序号 命令`的形式逐行显示。\n\n​\t\t如果想要执行第多少号命令，可以通过`! 序号`的形式调用历史上执行过的第几条命令\n\n\n\n\n\n\n\n## 时间日期类\n\n### date显示当前时间\n\n#### 基本语法\n\n- date\n\n  - <+日期时间格式> 指定显示时使用的日期时间格式。\n    - 格式如下：\n    - %Y ：显示年份（4位）\n    - %y：显示年份（2位）\n    - %m：显示月份\n    - %d：显示是哪一天\n    - %H：显示小时\n    - %M：显示分钟\n    - %S：显示秒数\n    - %s：当前时间的时间戳\n    - 注意，如果需要组合显示，则组合起来的符号串不可以有空格，如果需要空格，则需要加上双引号使得格式变成一个连续的字符串。\n\n  - 什么都不加单一个date：显示当前的日期。\n  - -d<时间字符串> 显示指定的“时间字符串”表示的时间，而非当前时间。\n    - 如：显示一天前：date -d '1 days ago'\n      - 显示前一年：date -d \"1 years ago\"\n      - 显示后一天：date -d '-1 days ago'\n  - -s<日期时间> 设置系统日期时间\n    - 设定指定的日期时间为当前时间：\n      - date -s \"2020-06-28 12:13\"\n      - 如果缺省时间，则默认为0\n\n\n\n### 配置时钟\n\n#### 通过硬件时钟配置系统时间\n\n- hwclock -s\n\n#### 通过ntp服务器更新时间\n\n- ntpdate + 服务器地址\n\n（如果提示没安装需要手动安装这个服务）\n\n\n\n### cal 查看日历\n\n##### 基本语法\n\n- cal\n  - 什么都不加，默认显示当前月份的日历，并高亮天数。\n    - ![image-20220820125810807](image-20220820125810807.png)\n  - -数字 显示当前月份前后几个月的日历。如显示前后三个月的日历\n    - ![image-20220820125920267](image-20220820125920267.png)\n  - 直接加数字不带 `-` 号\t，表示显示这一年的日历。如显示2020年的日历。\n    - ![image-20220820130206088](image-20220820130206088.png)\n  - -m 从周一作为第一天显示（默认周日第一天）\n\n\n\n\n\n\n\n## 用户管理类\n\n​\t\tLinux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。\n\n​\t\t用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。\n\n每个用户账号都拥有一个唯一的用户名和各自的口令。\n\n用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。\n\n实现用户账号的管理，要完成的工作主要有如下几个方面：\n\n- 用户账号的添加、删除与修改。\n- 用户口令的管理。\n- 用户组的管理。\n\n\n\n​\t\t用户账号的管理工作主要涉及到用户账号的**添加、修改和删除**。\n\n​\t\t添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。\n\n### useradd 添加用户命令\n\n#### 基本语法\n\n```\nuseradd 选项 用户名\n```\n\n#### 参数说明\n\n- 选项:\n\n  - -c comment 指定一段注释性描述。\n  - -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。\n  - -g 用户组 指定用户所属的用户组。\n  - -G 用户组，用户组 指定用户所属的附加组。\n  - -s Shell文件 指定用户的登录Shell。\n  - -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。\n\n- 用户名:\n\n  指定新账号的登录名。\n\n#### 样例1：创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）。\n\n```\nuseradd –d  /home/sam -m sam\n```\n\n​\t\t注意：如果不指定用户主目录，则默认会在/home目录下面创建一个与用户名相同的文件夹，并将这个文件夹设定成当前用户的主目录。\n\n​\t\t也就是说，在样例1中，可以缺省-d -m以及其附带的参数\n\n#### 样例2：新建了一个用户gem，该用户的登录Shell是 `/bin/sh`，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。\n\n```\nuseradd -s /bin/sh -g group –G adm,root gem\n```\n\n这里可能新建组：`#groupadd group及groupadd adm`\n\n\n\n增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。\n\nLinux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。\n\n\n\n\n\n​\t\n\n\n\n### passwd 修改用户的密码\n\n​\t\t用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。\n\n​\t指定和修改用户口令的Shell命令是`passwd`。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：\n\n#### 基本语法\n\n```\npasswd 选项 用户名\n```\n\n可使用的选项：\n\n- -l 锁定口令，即禁用账号。\n- -u 口令解锁。\n- -d 使账号无口令。\n- -f 强迫用户下次登录时修改口令。\n\n​\t\t**如果默认用户名，则修改当前用户的口令。**如果是root用户，则可以修改其他账户的密码，且不需要验证旧密码\n\n​\t\t例如，假设当前用户是sam，则下面的命令修改该用户自己的口令：\n\n```\npasswd \nOld password:****** \nNew password:******* \nRe-enter new password:*******\n```\n\n​\t\t如果是超级用户，可以用下列形式指定任何用户的口令：\n\n```\npasswd sam \nNew password:******* \nRe-enter new password:*******\n```\n\n​\t\t普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。\n\n​\t\t为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。\n\n\n\n​\t\t为用户指定空口令时，执行下列形式的命令：\n\n```\npasswd -d sam\n```\n\n​\t\t此命令将用户 sam 的口令删除，这样用户 sam 下一次登录时，系统就不再需要该用户输入登录密码了。\n\npasswd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：\n\n```\npasswd -l sam\n```\n\n##### 样例 为用户`tony`修改密码\n\n![image-20220820143156229](image-20220820143156229.png)\n\n##### 注意事项\n\n1. 对于管理员修改他人密码，是不需要知道旧密码的，直接输入新密码即可\n2. 对于管理员创建的简单密码，系统会弹出警告，但只是警告，可以使用，而对于普通用户使用此命令修改自己的密码时，对于简单的密码是不生效的。\n3. 普通用户也可以使用这条命令，但仅限不带用户名的，只对自己账户生效的清空下使用。\n\n\n\n\n\n### id 查看用户信息\n\n可以查看用户所属的详细信息。\n\n#### 基本语法\n\n```\nid 用户名\n```\n\n#### 样例\n\n![image-20220820155158261](image-20220820155158261.png)\n\n\n\n#### 批量查看用户\n\n​\t\t如果需要批量查看账号，可以查看/etc/passwd文件，里面存储了账号的信息。里面存储了用户的。\n\n​\t\t其中有很多用户都是系统默认创建出来的，如bin，halt，这些跟系统服务相关的用户。这些用户创建出来就是为了运行相应的系统服务的，这些用户一般被称为系统用户或者伪用户，因为不能真正作为用户的身份去登陆。\n\n​\t\t这些伪用户一般情况下是不可以删除的，可能会导致系统的崩溃。\n\npasswd文件中存储的用户的格式一般如下：\n\n`用户名:密码(隐藏了):uid:组id::家目录:登陆系统后跟系统交互的方式`\n\n\n\n### su 切换账号\n\nsu: swith user 切换用户\n\n#### 基本语法\n\n-  su 用户名称 \n   - 切换用户，只能获得用户的执行权限，不能获得环境变量\n-  su - 用户名称 \n   - 功能描述：切换到用户并获得该用户的环境变量及执行权限\n-  su\n   - 当不加用户名时，默认切换到root用户\n\n\n\n#### 注意事项\n\n- 当root用户使用su命令切换到其他用户的时候，是不需要输入用户的密码的。\n- 用户的切换是一个嵌套的过程，类似于栈的存在，可以根据切换的顺序层层退出。\n- 可以通过who am i命令（带空格）查询当前会话的发起用户\n- 如果缩写上面的命令变成whoami，则直接显示当前用户。区别在于：如果是root切换到普通用户后，带空格的还会显示root，但不带空格的则会显示切换完的用户。\n\n\n\n### sudo 对普通用户临时授予root权限\n\n需要注意的是，在使用sudo命令之前，首先需要root用户将对应的普通用户加入到sudoers文件中。\n\n且因为这是一个只读文件，root用户在修改完成的时候需要使用`wq!`命令才能强制保存退出。\n\n#### 修改过程\n\n1. 使用vim修改sudoers文件\n   - `vi /etc/sudoers`\n2. 找到下面的信息，在下面添加一行\n\n```\n## Allow root to run any commands anywhere\nroot ALL=(ALL) ALL\n用户名 ALL=(ALL) ALL\n```\n\n如果想要配置成采用 sudo 命令时，不需要输入密码的话，则可以改成`用户名 ALL=(ALL) NOPASSWD:ALL`\n\n\n\n### userdel删除帐号\n\n​\t\t如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。\n\n#### 基本语法\n\n```\nuserdel 选项 用户名\n```\n\n- #### 选项 \n\n  -  **-r**：把用户的主目录一起删除。（不建议这么做）\n\n例如，删除上面创建的sam用户：\n\n​\t\tuserdel -r sam\n\n​\t\t此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。\n\n​\t\t需要注意的是，如果缺省 -r 选项，则用户的主目录不会删除，需要手动删除。\n\n\n\n### who 查看登录用户的身份\n\n#### 基本语法\n\n- whoami\n  - 显示当前的用户名称\n- who am i\n  - 显示当前会话发起的用户的名称\n\n\n\n\n\n### usermod 修改帐号\n\n​\t\t修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。\n\n​\t\t修改已有用户的信息使用`usermod`命令，其格式如下：\n\n#### 基本语法\n\n```\nusermod 选项 用户名\n```\n\n​\t\t常用的选项包括`-c, -d, -m, -g, -G, -s, -u以及-o等`，这些选项的意义与`useradd`命令中的选项一样，可以为用户指定新的资源值。\n\n​\t\t另外，有些系统可以使用选项：-l 新用户名\n\n​\t\t这个选项指定一个新的账号，即将原来的用户名改为新的用户名。\n\n例如：\n\n```\nusermod -s /bin/ksh -d /home/z –g developer sam\n```\n\n​\t\t此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer(用户组需要存在)。\n\n\n\n\n\n## 用户组管理命令\n\n​\t\t每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同。\n\n​\t\t如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。 用户组的管理涉及用户组的添加、删除和修改。\n\n​\t\t组的增加、删除和修改实际上就是对 /etc/group文件的更新。 \n\n\n\n### groupadd 新增用户组\n\n使用groupadd命令。其格式如下：\n\n```\ngroupadd 选项 用户组\n```\n\n可以使用的选项有：\n\n- -g GID 指定新用户组的组标识号（GID）。\n- -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。\n\n#### 实例1：\n\n```\ngroupadd group1\n```\n\n此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。\n\n#### 实例2：\n\n```\ngroupadd -g 101 group2\n```\n\n此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。\n\n\n\n### groupdel 删除组\n\n#### 基本语法\n\n```\ngroupdel 组名\n```\n\n\n\n#### 例如：\n\n```\n# groupdel group1\n```\n\n此命令从系统中删除组group1。\n\n\n\n### groupmod 修改组\n\n#### 基本语法\n\n```\ngroupmod 选项 用户组\n```\n\n\n\n#### 选项说明\n\n- -g GID 为用户组指定新的组标识号。\n- -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。\n- -n新用户组 将用户组的名字改为新名字\n\n\n\n#### 实例1：\n\n```\n# groupmod -g 102 group2\n```\n\n此命令将组group2的组标识号修改为102。\n\n#### 实例2：\n\n```\n# groupmod –g 10000 -n group3 group2\n```\n\n此命令将组group2的标识号改为10000，组名修改为group3。\n\n\n\n\n\n### cat /etc/group 查看创建了哪些组\n\n```\ncat /etc/group\n```\n\n\n\n 7.6 文件权限类 7.6.1 文件属性 Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。 为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做 了不同的规定。在Linux中我们可以使用ll或者ls -l命令来显示一个文件的属性以及文件所属 的用户和组。 1）从左到右的 10 个字符表示\n\n\n\n\n\n\n\n\n\n\n\n### 切换当前用户的用户组\n\n​\t\t如果一个用户**同时属于多个用户组**，**那么用户可以在用户组之间切换**，以便具有其他用户组的权限。\n\n​\t\t用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：\n\n```\n$ newgrp root\n```\n\n​\t\t这条命令将当前用户切换到root用户组，**前提条件是root用户组确实是该用户的主组或附加组**。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。\n\n\n\n\n\n## 与用户账号有关的系统文件\n\n完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。\n\n与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。\n\n下面分别介绍这些文件的内容。\n\n### /etc/passwd文件\n\npasswd文件是用户管理工作涉及的最重要的一个文件。\n\nLinux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。\n\n这个文件对所有用户都是可读的。它的内容类似下面的例子：\n\n```\ncat /etc/passwd\n\nroot:x:0:0:Superuser:/:\ndaemon:x:1:1:System daemons:/etc:\nbin:x:2:2:Owner of system commands:/bin:\nsys:x:3:3:Owner of system files:/usr/sys:\nadm:x:4:4:System accounting:/usr/adm:\nuucp:x:5:5:UUCP administrator:/usr/lib/uucp:\nauth:x:7:21:Authentication administrator:/tcb/files/auth:\ncron:x:9:16:Cron daemon:/usr/spool/cron:\nlisten:x:37:4:Network daemon:/usr/net/nls:\nlp:x:71:18:Printer administrator:/usr/spool/lp:\nsam:x:200:50:Sam san:/home/sam:/bin/sh\n```\n\n从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：\n\n```\n用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell\n```\n\n### 1）\"用户名\"是代表用户账号的字符串\n\n通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。\n\n为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。\n\n### 2）“口令”一些系统中，存放着加密后的用户口令字。\n\n虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。\n\n### 3）“用户标识号”是一个整数，系统内部用它来标识用户。\n\n一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。\n\n通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。\n\n### 4）“组标识号”字段记录的是用户所属的用户组。\n\n它对应着/etc/group文件中的一条记录。\n\n### 5)“注释性描述”字段记录着用户的一些个人情况。\n\n例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。\n\n### 6)“主目录”，也就是用户的起始工作目录。\n\n它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。\n\n### 7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。\n\nShell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。\n\n系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。\n\n用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。\n\n利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。\n\n### 8)系统中有一类用户称为伪用户（pseudo users）。\n\n这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。\n\n常见的伪用户如下所示：\n\n```\n伪 用 户 含 义 \nbin 拥有可执行的用户命令文件 \nsys 拥有系统文件 \nadm 拥有帐户文件 \nuucp UUCP使用 \nlp lp或lpd子系统使用 \nnobody NFS使用\n```\n\n------\n\n\n\n## 用户帐户文件\n\n**1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。**\n\n​\t\t由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。\n\n**2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生**\n\n它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用\":\"隔开。这些字段是：\n\n```\n登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志\n```\n\n1. \"登录名\"是与/etc/passwd文件中的登录名相一致的用户账号\n2. \"口令\"字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。\n3. \"最后一次修改时间\"表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。\n4. \"最小时间间隔\"指的是两次修改口令之间所需的最小天数。\n5. \"最大时间间隔\"指的是口令保持有效的最大天数。\n6. \"警告时间\"字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。\n7. \"不活动时间\"表示的是用户没有登录活动但账号仍能保持有效的最大天数。\n8. \"失效时间\"字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。\n\n下面是/etc/shadow的一个例子：\n\n```\ncat /etc/shadow\n\nroot:Dnakfw28zf38w:8764:0:168:7:::\ndaemon:*::0:0::::\nbin:*::0:0::::\nsys:*::0:0::::\nadm:*::0:0::::\nuucp:*::0:0::::\nnuucp:*::0:0::::\nauth:*::0:0::::\ncron:*::0:0::::\nlisten:*::0:0::::\nlp:*::0:0::::\nsam:EkdiSECLWPdSa:9740:0:0::::\n```\n\n### 3、用户组的所有信息都存放在/etc/group文件中。\n\n将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。\n\n每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。\n\n当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。\n\n用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。\n\n用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：\n\n```\n组名:口令:组标识号:组内用户列表\n```\n\n1. \"组名\"是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。\n2. \"口令\"字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。\n3. \"组标识号\"与用户标识号类似，也是一个整数，被系统内部用来标识组。\n4. \"组内用户列表\"是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。\n\n/etc/group文件的一个例子如下：\n\n```\nroot::0:root\nbin::2:root,bin\nsys::3:root,uucp\nadm::4:root,adm\ndaemon::5:root,daemon\nlp::7:root,lp\nusers::20:root,sam\n```\n\n\n\n\n\n\n\n## 添加批量用户\n\n添加和删除用户是轻而易举的事，比较棘手的是如果要添加几十个、上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加，必然要找一种简便的创建大量用户的方法。Linux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下：\n\n### （1）先编辑一个文本用户文件。\n\n每一列按照`/etc/passwd`密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：\n\n```\nuser001::600:100:user:/home/user001:/bin/bash\nuser002::601:100:user:/home/user002:/bin/bash\nuser003::602:100:user:/home/user003:/bin/bash\nuser004::603:100:user:/home/user004:/bin/bash\nuser005::604:100:user:/home/user005:/bin/bash\nuser006::605:100:user:/home/user006:/bin/bash\n```\n\n### （2）以root身份执行命令 `/usr/sbin/newusers`，从刚创建的用户文件`user.txt`中导入数据，创建用户：\n\n```\nnewusers < user.txt\n```\n\n然后可以执行命令 `vipw` 或 `vi /etc/passwd` 检查 `/etc/passwd` 文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。\n\n### （3）执行命令/usr/sbin/pwunconv。\n\n将 `/etc/shadow` 产生的 `shadow` 密码解码，然后回写到 `/etc/passwd` 中，并将`/etc/shadow`的`shadow`密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 `shadow password` 功能。\n\n```\npwunconv\n```\n\n### （4）编辑每个用户的密码对照文件。\n\n格式为：用户名:密码\n\n实例文件 `passwd.txt` 内容如下：\n\n```\nuser001:123456\nuser002:123456\nuser003:123456\nuser004:123456\nuser005:123456\nuser006:123456\n```\n\n### （5）以 root 身份执行命令 `/usr/sbin/chpasswd`。\n\n创建用户密码，`chpasswd` 会将经过 `/usr/bin/passwd` 命令编码过的密码写入 `/etc/passwd` 的密码栏。\n\n```\nchpasswd < passwd.txt\n```\n\n### （6）确定密码经编码写入/etc/passwd的密码栏后。\n\n执行命令 `/usr/sbin/pwconv` 将密码编码为 `shadow password`，并将结果写入 `/etc/shadow`。\n\n```\npwconv\n```\n\n这样就完成了大量用户的创建了，之后您可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。\n\n\n\n\n\n\n\n\n\n\n\n# vi/vim编辑器\n\n\n\n![image-20220806200406152](image-20220806200406152.png)\n\n## vi 和 vim 的基本介绍\n\n​\tLinux 系统内置了 vi 文本编辑器，类似于没有图形界面的记事本。\n\n​\t Vim 具有程序编辑的能力，可以看做是 Vi 的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。 \n\n\n\n## vi 和 vim 常用的三种模式\n\n### 命令模式：\n\n用户刚刚启动 vi/vim，便进入了命令模式。\n\n此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。\n\n以下是常用的几个命令：\n\n- **i** 切换到输入模式，以输入字符。(也可以是 i, I, o, O, a, A, r, R 等任何一个字母)\n- **x** 删除当前光标所在处的字符。\n- **:** 切换到底线命令模式，以在最底一行输入命令。\n\n若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。\n\n命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。\n\n\n\n### 输入模式\n\n在命令模式下按下i就进入了输入模式。\n\n在输入模式中，可以使用以下按键：\n\n- **字符按键以及Shift组合**，输入字符\n\n- **ENTER**，回车键，换行\n\n- **BACK SPACE**，退格键，删除光标前一个字符\n\n- **DEL**，删除键，删除光标后一个字符\n\n- **方向键**，在文本中移动光标\n\n- **HOME**/**END**，移动光标到行首/行尾\n\n- **Page Up**/**Page Down**，上/下翻页\n\n- **Insert**，切换光标为输入/替换模式，光标将变成竖线/下划线\n\n- **ESC**，退出输入模式，切换到命令模式\n\n  \n\n### 底线命令模式\n\n在命令模式下按下:（英文冒号）就进入了底线命令模式。\n\n底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。\n\n在底线命令模式中，基本的命令有（已经省略了冒号）：\n\n- q 退出程序\n- w 保存文件\n- wq 保存文件并退出\n- q! 强制退出\n\n按ESC键可随时退出底线命令模式。\n\n简单的说，我们可以将这三个模式想成底下的图标来表示：\n\n![image-20220806195513590](image-20220806195513590.png)\n\n\n\n\n\n## vi 和 vim 快捷键\n\n| 使用时的模式 | 命令名称                                           | 关键字                 |\n| ------------ | -------------------------------------------------- | ---------------------- |\n| 命令模式     | 拷贝当前行                                         | yy                     |\n| 命令模式     | 拷贝当前向下的5行（拷贝多行）                      | 5yy（数量+yy)          |\n| 命令模式     | 删除当前行                                         | dd                     |\n| 命令模式     | 删除当前向下的5行（拷贝多行）                      | 5dd                    |\n| 命令模式     | 粘贴剪切板中的内容到当前行                         | p                      |\n| 命令模式     | 查找指定的关键字（大小写敏感）第一次出现的地方     | /关键字                |\n|              | 查找指定的关键字（大小写敏感）第二次往后出现的地方 | 上一条命令，n          |\n| 命令模式     | 撤销上一步的操作(无法撤销撤销)                     | u                      |\n| 底线命令模式 | 显示行号（或者命令模式下+冒号）                    | set nu                 |\n| 底线命令模式 | 隐藏行号（同上）                                   | set nonu               |\n| 命令模式     | 跳转到首行                                         | gg                     |\n| 命令模式     | 跳转到末行                                         | G                      |\n| 命令模式     | 跳转到指定的行                                     | 行数+G（行数+shift+g） |\n\n  \n\n# Linux yum 命令\n\nyum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。\n\n基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。\n\nyum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。\n\n### yum 语法\n\n```\nyum [options] [command] [package ...]\n```\n\n- **options：**可选，选项包括-h（帮助），-y（当安装过程提示选择全部为 \"yes\"），-q（不显示安装的过程）等等。\n- **command：**要进行的操作。\n- **package：**安装的包名。\n\n------\n\n## yum常用命令\n\n1. 列出所有可更新的软件清单命令：**yum check-update**\n\n2. 更新所有软件命令：**yum update**\n\n3. 仅安装指定的软件命令：**yum install <package_name>**\n\n4. 仅更新指定的软件命令：**yum update <package_name>**\n\n5. 列出所有可安裝的软件清单命令：**yum list**\n\n6. 删除软件包命令：**yum remove <package_name>**\n\n7. 查找软件包命令：**yum search <keyword>**\n\n8. 清除缓存命令:\n\n   - **yum clean packages**: 清除缓存目录下的软件包\n\n   - **yum clean headers**: 清除缓存目录下的 headers\n\n   - **yum clean oldheaders**: 清除缓存目录下旧的 headers\n\n   - **yum clean, yum clean all (= yum clean packages; yum clean oldheaders)** :清除缓存目录下的软件包及旧的 headers\n\n### 实例 1\n\n安装 pam-devel\n\n```\n[root@www ~]# yum install pam-devel\nSetting up Install Process\nParsing package install arguments\nResolving Dependencies  <==先检查软件的属性相依问题\n--> Running transaction check\n---> Package pam-devel.i386 0:0.99.6.2-4.el5 set to be updated\n--> Processing Dependency: pam = 0.99.6.2-4.el5 for package: pam-devel\n--> Running transaction check\n---> Package pam.i386 0:0.99.6.2-4.el5 set to be updated\nfilelists.xml.gz          100% |=========================| 1.6 MB    00:05\nfilelists.xml.gz          100% |=========================| 138 kB    00:00\n-> Finished Dependency Resolution\n……(省略)\n```\n\n### 实例 2\n\n移除 pam-devel\n\n```\n[root@www ~]# yum remove pam-devel\nSetting up Remove Process\nResolving Dependencies  <==同样的，先解决属性相依的问题\n--> Running transaction check\n---> Package pam-devel.i386 0:0.99.6.2-4.el5 set to be erased\n--> Finished Dependency Resolution\n\nDependencies Resolved\n\n=============================================================================\n Package                 Arch       Version          Repository        Size\n=============================================================================\nRemoving:\n pam-devel               i386       0.99.6.2-4.el5   installed         495 k\n\nTransaction Summary\n=============================================================================\nInstall      0 Package(s)\nUpdate       0 Package(s)\nRemove       1 Package(s)  <==还好，并没有属性相依的问题，单纯移除一个软件\n\nIs this ok [y/N]: y\nDownloading Packages:\nRunning rpm_check_debug\nRunning Transaction Test\nFinished Transaction Test\nTransaction Test Succeeded\nRunning Transaction\n  Erasing   : pam-devel                    ######################### [1/1]\n\nRemoved: pam-devel.i386 0:0.99.6.2-4.el5\nComplete!\n```\n\n### 实例 3\n\n利用 yum 的功能，找出以 pam 为开头的软件名称有哪些？\n\n```\n[root@www ~]# yum list pam*\nInstalled Packages\npam.i386                  0.99.6.2-3.27.el5      installed\npam_ccreds.i386           3-5                    installed\npam_krb5.i386             2.2.14-1               installed\npam_passwdqc.i386         1.0.2-1.2.2            installed\npam_pkcs11.i386           0.5.3-23               installed\npam_smb.i386              1.1.7-7.2.1            installed\nAvailable Packages <==底下则是『可升级』的或『未安装』的\npam.i386                  0.99.6.2-4.el5         base\npam-devel.i386            0.99.6.2-4.el5         base\npam_krb5.i386             2.2.14-10              base\n```\n\n------\n\n## 国内 yum 源\n\n网易（163）yum源是国内最好的yum源之一 ，无论是速度还是软件版本，都非常的不错。\n\n将yum源设置为163 yum，可以提升软件包安装和更新的速度，同时避免一些常见软件版本无法找到。\n\n### 安装步骤\n\n首先备份/etc/yum.repos.d/CentOS-Base.repo\n\n```\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n```\n\n下载对应版本 repo 文件, 放入 /etc/yum.repos.d/ (操作前请做好相应备份)\n\n- [CentOS5](http://mirrors.163.com/.help/CentOS5-Base-163.repo) ：http://mirrors.163.com/.help/CentOS5-Base-163.repo\n- [CentOS6](http://mirrors.163.com/.help/CentOS6-Base-163.repo) ：http://mirrors.163.com/.help/CentOS6-Base-163.repo\n- [CentOS7](http://mirrors.163.com/.help/CentOS7-Base-163.repo) ：http://mirrors.163.com/.help/CentOS7-Base-163.repo\n\n```\nwget http://mirrors.163.com/.help/CentOS6-Base-163.repo\nmv CentOS6-Base-163.repo CentOS-Base.repo\n```\n\n运行以下命令生成缓存\n\n```\nyum clean all\nyum makecache\n```\n\n除了网易之外，国内还有其他不错的 yum 源，比如中科大和搜狐。\n\n中科大的 yum 源，安装方法查看：https://lug.ustc.edu.cn/wiki/mirrors/help/centos\n\nsohu 的 yum 源安装方法查看: http://mirrors.sohu.com/help/centos.html\n\n\n\n\n\n\n\n\n\n\n\n# Linux apt 命令\n\napt（Advanced Packaging Tool）是一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。\n\napt 命令提供了查找、安装、升级、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。\n\n**apt 命令执行需要超级管理员权限(root)。**\n\n### apt 语法\n\n```\n  apt [options] [command] [package ...]\n```\n\n- **options：**可选，选项包括 -h（帮助），-y（当安装过程提示选择全部为\"yes\"），-q（不显示安装的过程）等等。\n- **command：**要进行的操作。\n- **package**：安装的包名。\n\n------\n\n## apt 常用命令\n\n- 列出所有可更新的软件清单命令：**sudo apt update**\n\n- 升级软件包：**sudo apt upgrade**\n\n  列出可更新的软件包及版本信息：**apt list --upgradeable**\n\n  升级软件包，升级前先删除需要更新软件包：**sudo apt full-upgrade**\n\n- 安装指定的软件命令：**sudo apt install <package_name>**\n\n  安装多个软件包：**sudo apt install <package_1> <package_2> <package_3>**\n\n- 更新指定的软件命令：**sudo apt update <package_name>**\n\n- 显示软件包具体信息,例如：版本号，安装大小，依赖关系等等：**sudo apt show <package_name>**\n\n- 删除软件包命令：**sudo apt remove <package_name>**\n\n- 清理不再使用的依赖和库文件: **sudo apt autoremove**\n\n- 移除软件包及配置文件: **sudo apt purge <package_name>**\n\n- 查找软件包命令： **sudo apt search <keyword>**\n\n- 列出所有已安装的包：**apt list --installed**\n\n- 列出所有已安装的包的版本信息：**apt list --all-versions**\n\n### 实例\n\n查看一些可更新的包：\n\n```\nsudo apt update\n```\n\n\n\n升级安装包：\n\n```\nsudo apt upgrade\n```\n\n\n在以上交互式输入字母 **Y** 即可开始升级。\n\n可以将以下两个命令组合起来，一键升级：\n\n```\nsudo apt update && sudo apt upgrade -y\n```\n\n安装 mplayer 包：\n\n```\nsudo apt install mplayer\n```\n\n\n如过不太记得完整的包名，我们可以只输入前半部分的包名，然后按下 **Tab** 键，会列出相关的包名：\n\n\n\n以上实例我们输入来 **reds**，然后按下 **Tab** 键，输出来四个相关的包。\n\n如果我们想安装一个软件包，但如果软件包已经存在，则不要升级它，可以使用 **–no-upgrade** 选项:\n\n\n安装 mplayer 如果存在则不要升级：\n\n```\nsudo apt install mplayer --no-upgrade\n```\n\n\n如果只想升级，不要安装可以使用 **--only-upgrade** 参数：\n\n```\nsudo apt install <package_name> --only-upgrade\n```\n\n只升级 mplayer，如果不存在就不要安装它：\n\n```\nsudo apt install mplayer --only-upgrade\n```\n\n\n如果需要设置指定版本，语法格式如下：\n\n```\nsudo apt install <package_name>=<version_number>\n```\n\n**package_name** 为包名，**version_number** 为版本号。\n\n移除包可以使用 remove 命令：\n\n```\nsudo apt remove mplayer\n```\n\n\n查找名为 libimobile 的相关包：\n\n```\napt search libimobile\n```\n\n查看 pinta 包的相关信息：\n\n```\napt show pinta\n```\n\n\n列出可更新的软件包：\n\n```\napt list --upgradeable\n```\n\n\n清理不再使用的依赖和库文件：\n\n```\nsudo apt autoremove\n```\n\n\n在以上交互式输入字母 **Y** 即可开始清理。\n\n\n\n# Linux文件杂谈\n\n## /etc/fstab\n\n/etc/fstab是用来存放文件系统的静态信息的文件。位于/etc/目录下，可以用命令less /etc/fstab 来查看，如果要修改的话，则用命令 vi /etc/fstab 来修改。\n\n**当系统启动的时候，系统会自动地从这个文件读取信息，并且会自动将此文件中指定的文件系统挂载到指定的目录。下面我来介绍如何在此文件下填写信息。**\n\n\n\n### 文件示例\n\n\n\n一个简单的 `/etc/fstab`，使用内核名称标识磁盘:\n\n```text\n/etc/fstab\n# <file system>        <dir>         <type>    <options>             <dump> <pass>\ntmpfs                  /tmp          tmpfs     nodev,nosuid          0      0\n/dev/sda1              /             ext4      defaults,noatime      0      1\n/dev/sda2              none          swap      defaults              0      0\n/dev/sda3              /home         ext4      defaults,noatime      0      2\n```\n\n### 字段定义\n\n`/etc/fstab` 文件包含了如下字段，通过空格或 Tab 分隔：\n\n```text\n<file system>\t<dir>\t<type>\t<options>\t<dump>\t<pass>\n```\n\n- **<file systems>** - 要挂载的分区或存储设备。可以为指定分区或存储设备的UUID值。\n  - 获取UUID的值的方法参考下方图片\n- **<dir>** - 要的挂载位置。\n- **<type>** - 要挂载设备或是分区的文件系统类型，支持许多种不同的文件系统：`ext2`, `ext3`, `ext4`, `reiserfs`, `xfs`, `jfs`, `smbfs`, `iso9660`, `vfat`, `ntfs`, `swap` 及 `auto`。 设置成`auto`类型，mount 命令会猜测使用的文件系统类型，对 CDROM 和 DVD 等移动设备是非常有用的。\n  - 具体格式和UUID可以通过`blkid 设备位置`查看。如：`blkid /dev/sda1`。\n    - ![image-20230812212519433](./Image/Linux基础.assets/image-20230812212519433.png)\n  - 设备位置可以通过`fdisk -l`命令查看。如果磁盘大于2T，也可以用gdisk命令替代fdisk。\n    - ![image-20230812212429393](./Image/Linux基础.assets/image-20230812212429393.png)\n- **<options>** - 挂载时使用的参数，注意有些mount 参数是特定文件系统才有的。一些比较常用的参数有：\n  - `auto` - 在启动时或键入了 `mount -a` 命令时自动挂载。\n  - `noauto` - 只在你的命令下被挂载。\n  - `exec` - 允许执行此分区的二进制文件。\n  - `noexec` - 不允许执行此文件系统上的二进制文件。\n  - `ro` - 以只读模式挂载文件系统。\n  - `rw` - 以读写模式挂载文件系统。\n  - `user` - 允许任意用户挂载此文件系统，若无显示定义，隐含启用 `noexec`, `nosuid`, `nodev` 参数。\n  - `users` - 允许所有 users 组中的用户挂载文件系统.\n  - `nouser` - 只能被 root 挂载。\n  - `owner` - 允许设备所有者挂载.\n  - `sync` - I/O 同步进行。\n  - `async` - I/O 异步进行。\n  - `dev` - 解析文件系统上的块特殊设备。\n  - `nodev` - 不解析文件系统上的块特殊设备。\n  - `suid` - 允许 suid 操作和设定 sgid 位。这一参数通常用于一些特殊任务，使一般用户运行程序时临时提升权限。\n  - `nosuid` - 禁止 suid 操作和设定 sgid 位。\n  - `noatime` - 不更新文件系统上 inode 访问记录，可以提升性能(参见 atime 参数)。\n  - `nodiratime` - 不更新文件系统上的目录 inode 访问记录，可以提升性能(参见 atime 参数)。\n  - `relatime` - 实时更新 inode access 记录。只有在记录中的访问时间早于当前访问才会被更新。（与 noatime 相似，但不会打断如 mutt 或其它程序探测文件在上次访问后是否被修改的进程。），可以提升性能(参见 atime 参数)。\n  - `flush` - `vfat` 的选项，更频繁的刷新数据，复制对话框或进度条在全部数据都写入后才消失。\n  - `defaults` - 使用文件系统的默认挂载参数，例如 `ext4` 的默认参数为:`rw`, `suid`, `dev`, `exec`, `auto`, `nouser`, `async`.\n- **<dump>** dump 工具通过它决定何时作备份. dump 会检查其内容，并用数字来决定是否对这个文件系统进行备份。 允许的数字是 0 和 1 。0 表示忽略， 1 则进行备份。大部分的用户是没有安装 dump 的 ，对他们而言 <dump> 应设为 0。\n- **<pass>** fsck 读取 <pass> 的数值来决定需要检查的文件系统的检查顺序。允许的数字是0, 1, 和2。 根目录应当获得最高的优先权 1, 其它所有需要被检查的设备设置为 2. 0 表示设备不会被 fsck 所检查。\n\n\n\n### 文件系统标识\n\n在 `/etc/fstab`配置文件中你可以以三种不同的方法表示文件系统：内核名称、UUID 或者 label。使用 UUID 或是 label 的好处在于它们与磁盘顺序无关。如果你在 BIOS 中改变了你的存储设备顺序，或是重新拔插了存储设备，或是因为一些 BIOS 可能会随机地改变存储设备的顺序，那么用 UUID 或是 label 来表示将更有效。参见 持久化块设备名称 。\n\n要显示分区的基本信息请运行：\n\n```text\n$ lsblk -f\nNAME   FSTYPE LABEL      UUID                                 MOUNTPOINT\nsda                                                         \n├─sda1 ext4   Arch_Linux 978e3e81-8048-4ae1-8a06-aa727458e8ff /\n├─sda2 ntfs   Windows    6C1093E61093B594                     \n└─sda3 ext4   Storage    f838b24e-3a66-4d02-86f4-a2e73e454336 /media/Storage\nsdb                                                           \n├─sdb1 ntfs   Games      9E68F00568EFD9D3                     \n└─sdb2 ext4   Backup     14d50a6c-e083-42f2-b9c4-bc8bae38d274 /media/Backup\nsdc                                                           \n└─sdc1 vfat   Camera     47FA-4071                            /media/Camera\n```\n\n#### 内核名称\n\n你可以使用 `fdisk -l` 来获得内核名称，前缀是 `dev`.\n\n#### 标签\n\n**注意:** 使用这一方法，每一个标签必须是唯一的.\n\n要显示所有设备的标签，可以使用 `lsblk -f` 命令。在 `/etc/fstab` 中使用 `LABEL=` 作为设备名的开头 :\n\n```text\n/etc/fstab\n# <file system>        <dir>         <type>    <options>             <dump> <pass>\n\ntmpfs                  /tmp          tmpfs     nodev,nosuid   0      0\n \nLABEL=Arch_Linux       /             ext4      defaults,noatime      0      1\nLABEL=Arch_Swap        none          swap      defaults              0      0\n```\n\n#### UUID\n\n所有分区和设备都有唯一的 UUID。它们由文件系统生成工具 (`mkfs.*`) 在创建文件系统时生成。\n\n`lsblk -f` 命令将显示所有设备的 UUID 值。`/etc/fstab` 中使用 `UUID=` 前缀:\n\n```text\n/etc/fstab\n# <file system>                           <dir>         <type>    <options>             <dump> <pass>\n\ntmpfs                                     /tmp          tmpfs     nodev,nosuid          0      0\n \nUUID=24f28fc6-717e-4bcd-a5f7-32b959024e26 /     ext4              defaults,noatime      0      1\nUUID=03ec5dd3-45c0-4f95-a363-61ff321a09ff /home ext4              defaults,noatime      0      2\nUUID=4209c845-f495-4c43-8a03-5363dd433153 none  swap              defaults              0      0\n```\n\n### 提示和技巧\n\n#### 自动挂载\n\n- 如果 `/home` 分区较大，可以让不依赖 `/home` 分区的服务先启动。把下面的参数添加到 `/etc/fstab` 文件中 `/home` 项目的参数部分即可：\n\n```text\nnoauto,x-systemd.automount\n```\n\n这样 `/home` 分区只有需要访问时才会被挂载。内核会缓存所有的文件操作，直到 `/home` 分区准备完成。\n\n**注意:** 这样做会使 `/home` 的文件系统类型被识别为 `autofs`，造成 mlocate 查询时忽略该目录。实际加速效果因配置而异，所以请自己权衡是否需要。\n\n- 挂载远程文件系统也是同理。如果你仅想在需要的时候才挂载，也可以添加 `noauto,x-systemd.automount` 参数。另外，可以设置 `x-systemd.device-timeout=#` 参数，设置超时时间，以防止网络资源不能访问的时候浪费时间。\n- 如果你的加密文件系统需要密钥，则需要添加 `noauto` 参数到 `/etc/crypttab` 文件中的对应位置。systemd 开机的时候就不会打开这个加密设备，会一直等待到设备被访问时再使用密钥文件挂载。比如在使用加密RAID设备的时候可以节省一定的时间，因为 systemd 不必等到设备可用后才能访问。例如：\n\n```text\n/etc/crypttab\ndata /dev/md0 /root/key noauto\n```\n\n#### 交换分区 UUID\n\n如果交换分区没有 UUID，可以手动加入。如果使用 `lsblk -f` 命令没有列出交换分区的 UUID 就说明发生了这种情况。下面是为交换分区指定 UUID 的步骤：\n\n确定交换分区：\n\n```text\n# swapon -s\n```\n\n禁用交换分区：\n\n```text\n# swapoff /dev/sda7\n```\n\n用新 UUID 重新创建交换分区：\n\n```text\n# mkswap -U random /dev/sda7\n```\n\n激活交换分区:\n\n```text\n# swapon /dev/sda7\n```\n\n#### 路径名有空格\n\n如果挂载的路径中有空格，可以使用 \"\\040\" 转义字符来表示空格（以三位八进制数来进行表示）\n\n```text\n/etc/fstab\nUUID=47FA-4071     /home/username/Camera\\040Pictures   vfat  defaults,noatime      0  2\n/dev/sda7          /media/100\\040GB\\040(Storage)       ext4  defaults,noatime,user  0  0\n```\n\n.....</nowiki>}}\n\n#### 外部设备\n\n外部设备在插入时挂载，在未插入时忽略。这需要 `nofail` 选项，可以在启动时若设备不存在直接忽略它而不报错.\n\n```text\n/etc/fstab\n /dev/sdg1    /media/backup    jfs    defaults,nofail    0  2\n```\n\n#### atime 参数\n\n使用 `noatime`, `nodiratime` 或 `relatime` 可以提升 ext2， ext3 及 ext4 格式磁盘的性能。 Linux 在默认情况下使用`atime`选项，每次在磁盘上读取（或写入）数据时都会产生一个记录。这是为服务器设计的，在桌面使用中意义不大。默认的 `atime` 选项最大的问题在于即使从页面缓存读取文件(从内存而不是磁盘读取)，也会产生磁盘写操作！\n\n使用 `noatime` 选项阻止了读文件时的写操作。大部分应用程序都能很好工作。只有少数程序如 Mutt 需要这些信息。Mutt 的用户应该使用 `relatime` 选项。使用 `relatime` 选项后，只有文件被修改时才会产生文件访问时间写操作。`nodiratime` 选项仅对目录禁用了文件访问时间。`relatime` 是比较好的折衷，Mutt 等程序还能工作，但是仍然能够通过减少访问时间更新提升系统性能。\n\n**注意:** `noatime` 已经包含了 `nodiratime`。不需要同时指定。\n\n#### tmpfs\n\ntmpfs 是一个临时文件系统，驻留于你的交换分区或是内存中（取决于你的使用情况）。使用它可以提高文件访问速度，并能保证重启时会自动清除这些文件。\n\n经常使用 tmpfs 的目录有 /tmp, /var/lock and /var/run. 不要将之使用于 /var/tmp, 因为这一目录中的临时文件在重启过程中需要被保留。使用 tmpfs `/run` 目录，`/var/run` 和 `/var/lock` 是为了兼容老版本建立的链接。默认 `/etc/fstab`中的的`/tmp`也是 tmpfs.\n\n默认情况下， tmpfs 分区被设置为你总的内存的一半，当然你可以自由设定这一值。注意实际中内存和交换分区的使用情况取决于你的使用情况，而 tmpfs 分区在其真正使用前是不会占用存储空间的。\n\n要将 `/tmp` 放到 tmpfs，将下行加入 `/etc/fstab`：\n\n```text\n/etc/fstab\n.....\ntmpfs /tmp      tmpfs nodev,nosuid                 0 0\n.....\n```\n\n可以指定大小，但不要修改 `mode` 选项，以保证文件具有正确的访问权限(1777)。在上例中 `/tmp` 将最多使用一半内存，要指定最大空间，使用 `size` 挂载选项：\n\n```text\n/etc/fstab\n.....\ntmpfs /tmp      tmpfs nodev,nosuid,size=2G          0 0\n.....\n```\n\n这里有一个更高级的例子，展示如何为用户添加 tmpfs 挂载。这对于网站、mysql 临时文件, `~/.vim/`, 和其他情况很有用。尝试并获得理想的挂载选项来完成目标是很重要的。目标是尽量采用安全的策略来防止滥用。限制大小，同时指定 uid 和 gid 加上 mode 是非常安全的。更多信息.\n\n```text\n/etc/fstab\ntmpfs /www/cache tmpfs rw,size=1G,nr_inodes=5k,noexec,nodev,nosuid,uid=648,gid=648,mode=1700 0 0\n```\n\n参阅 **mount** 命令 man 手册以获得更多的内容。\n\n重启后方能生效。注意不要直接执行 `mount -a` 命令，因为可能造成无法访问当前目录中的文件（比如你应该保证 lockfiles 的正常存在）。然而，如果它们都是空的，那么就可以直接执行 `mount -a` 而不必重启电脑。\n\n应用更改后，可以通过 `findmnt` 检查是否生效：\n\n```text\n$ findmnt --target /tmp\nTARGET SOURCE FSTYPE OPTIONS\n/tmp   tmpfs  tmpfs  rw,nosuid,nodev,relatime\n```\n\n#### 使用\n\n一般需要大量读写操作的程序在使用 tmpfs 时都会提升性能。有些程序把共享内存放到 tmpfs 上时性能会大幅提升，例如将 Firefox Profile 文件夹放到内存后，Firefox 性能大幅提升。\n\n**Note:** tmpfs 目录(`/tmp`) 挂载时需要去掉 `noexec` 参数，否则有些编译程序无法执行，此外，tmpfs 的默认大小是内存的一般，可能会产生空间不够的问题。\n\n下面命令可以让makepkg在tmpfs目录进行编辑，也可以在在`/etc/makepkg.conf`中进行设置:\n\n```text\n$ BUILDDIR=/tmp/makepkg makepkg\n```\n\n#### 普通用户读写 FAT32\n\n为了取得对 FAT32 分区的写权限，你必须修改`/etc/fstab`文件。\n\n```text\n/etc/fstab\n/dev/sdxY    /mnt/some_folder  vfat   user,rw,umask=000              0  0\n```\n\n“users”标签的意思是任何用户（甚至非 root 用户）都可以挂载或卸载分区 '/dev/sdX'。“rw”标签则分配读写的使用权。但我不知道“umask”标签的意义（umask 是权限掩码命令 umask=000 指任何人没有特权，且权限为777，即所有人都可以读、写、执行）。我曾试图在“man mount”中查询，但是没有什么结果。\n\n比如你的 FAT32 分区在 '/dev/sda9'，你想将其挂载到 '/mnt/fat32'，那么你需要输入并运行\n\n```text\n/etc/fstab\n/dev/sda9    /mnt/fat32        vfat   user,rw,umask=111,dmask=000    0  0\n```","tags":["protected","Linux"],"categories":["Linux"]},{"title":"Linux部署Tomcat","url":"/0202/01/26/Linux部署Tomcat/","content":"\n# 部署\n\nLinux环境下安装Tomcat并运行已经打包成WAR格式的Java项目，可以按照以下步骤进行操作：\n\n1. 下载Tomcat：访问Apache Tomcat官方网站（https://tomcat.apache.org/）下载最新版本的Tomcat压缩包（通常是.tar.gz格式）。\n\n2. 解压Tomcat：在终端中，使用以下命令解压下载的Tomcat压缩包：\n\n   ```\n   tar -zxvf apache-tomcat-<version>.tar.gz\n   ```\n\n   这将解压缩Tomcat到当前目录下的一个新文件夹中。\n\n3. 移动Tomcat：将解压后的Tomcat文件夹移动到适当的位置，比如`/opt`目录：\n\n   ```\n   sudo mv apache-tomcat-<version> /opt/tomcat\n   ```\n\n4. 设置环境变量：打开终端配置文件（例如`.bashrc`或`.bash_profile`，或者全局配置文件 `/etc/profile`），并添加以下行来设置Tomcat的环境变量：\n\n   ```\n   export CATALINA_HOME=/opt/tomcat\n   export PATH=$PATH:$CATALINA_HOME/bin\n   ```\n\n5. 重新加载配置：执行以下命令以使环境变量生效：\n\n   ```\n   source ~/.bashrc\n   ```\n\n6. 启动Tomcat：使用以下命令启动Tomcat服务器：\n\n   ```\n   catalina.sh start\n   ```\n\n   或者使用下面的命令（如果你的系统使用的是systemd）：\n\n   ```\n   systemctl start tomcat\n   ```\n\n7. 部署WAR文件：将你的WAR文件复制到Tomcat的`webapps`目录下：\n\n   ```\n   cp yourapp.war /opt/tomcat/webapps/\n   ```\n\n8. Tomcat自动解压WAR文件：Tomcat会自动解压WAR文件并将其部署为一个Web应用程序。你可以在`/opt/tomcat/webapps`目录中看到解压后的应用程序文件夹。\n\n9. 访问应用程序：使用浏览器访问应用程序。默认情况下，Tomcat会监听8080端口，所以你可以通过以下URL访问应用程序：\n\n   ```\n   http://localhost:8080/yourapp\n   ```\n\n\n\n# 修改访问端口\n\n1. 配置Tomcat的Connector：打开Tomcat的配置文件`server.xml`，该文件位于Tomcat的`conf`目录下。找到类似以下的Connector配置：\n\n   ```xml\n   <Connector port=\"8080\" protocol=\"HTTP/1.1\"\n              connectionTimeout=\"20000\"\n              redirectPort=\"8443\" />\n   ```\n\n   将`port`属性的值改为所需的值，比如80，即：\n\n   ```xml\n   <Connector port=\"80\" protocol=\"HTTP/1.1\"\n              connectionTimeout=\"20000\"\n              redirectPort=\"8443\" />\n   ```\n\n   这将使Tomcat监听80端口，这是Web应用程序的默认HTTP端口。\n\n2. 重启Tomcat：保存并关闭`server.xml`文件，然后重启Tomcat服务器，以使配置更改生效。\n\n\n\n\n\n# 直接访问应用程序不添加上下文路径\n\n要在Tomcat中直接访问应用程序而不需要添加上下文路径，你可以将应用程序部署为ROOT应用程序。这样，当你访问Tomcat时，应用程序将作为默认应用程序加载。\n\n以下是步骤：\n\n1. 将WAR文件重命名为`ROOT.war`：将你的应用程序的WAR文件重命名为`ROOT.war`。\n\n2. 将`ROOT.war`文件复制到Tomcat的`webapps`目录下：执行以下命令将`ROOT.war`文件复制到Tomcat的`webapps`目录中：\n\n   ```\n   cp yourapp.war /opt/tomcat/webapps/ROOT.war\n   ```\n\n3. 删除现有的ROOT目录（如果存在）：如果在`webapps`目录下已经存在一个名为`ROOT`的目录，请删除它。可以使用以下命令删除目录：\n\n   ```\n   rm -rf /opt/tomcat/webapps/ROOT\n   ```\n\n4. 重启Tomcat：重启Tomcat服务器以使更改生效。\n\n现在，当你访问Tomcat时，应用程序将作为默认应用程序加载，而无需添加上下文路径。你可以通过以下URL直接访问应用程序：\n\n```\nhttp://localhost:8080/\n```\n\n请确保在执行上述步骤时，你已经停止Tomcat服务器，并且没有其他应用程序正在使用ROOT上下文路径。\n\n\n\n# 给Tomcat增加ssl证书实现https访问\n\n要给Tomcat增加SSL证书以实现HTTPS，你可以按照以下步骤进行操作：7\n\n1. 获取SSL证书：首先，你需要获取一个有效的SSL证书。你可以购买一个证书，或者使用免费的证书颁发机构（如Let's Encrypt）来获取证书。\n\n2. 生成密钥库文件：使用Java的`keytool`工具生成一个密钥库文件（.keystore），其中包含你的SSL证书。打开命令行终端，并导航到Java的`bin`目录（通常在JDK安装目录的`bin`子目录中）。然后运行以下命令来生成密钥库文件：\n\n   ```\n   keytool -genkey -alias mydomain -keyalg RSA -keystore /path/to/keystore.jks\n   ```\n\n   在命令中，将`/path/to/keystore.jks`替换为你希望保存密钥库文件的路径和文件名。在生成过程中，你需要提供一些信息，如密钥库密码、组织名称、组织单位、城市、州/省、国家/地区和证书有效期等。\n\n3. 配置Tomcat的SSL连接器：打开Tomcat的配置文件`server.xml`，通常位于Tomcat的`conf`目录下。找到以下注释中的配置块：\n\n   ```xml\n   <!-- Define a SSL Coyote HTTP/1.1 Connector on port 8443 -->\n   <!--\n   <Connector\n      protocol=\"org.apache.coyote.http11.Http11NioProtocol\"\n      port=\"8443\" maxThreads=\"200\"\n      scheme=\"https\" secure=\"true\" SSLEnabled=\"true\"\n      keystoreFile=\"${user.home}/.keystore\" keystorePass=\"changeit\"\n      clientAuth=\"false\" sslProtocol=\"TLS\"/>\n   -->\n   ```\n\n   将注释解除，并根据你的密钥库文件和密码进行配置。将`keystoreFile`和`keystorePass`属性的值分别设置为你生成的密钥库文件的路径和密码。\n\n4. 配置其他SSL连接器属性（可选）：你还可以根据需要配置其他SSL连接器属性，如`ciphers`、`SSLProtocol`等。这些属性可以用于进一步定制和优化SSL连接。\n\n5. 保存并关闭`server.xml`文件。\n\n6. 启动Tomcat：使用启动脚本或命令启动Tomcat服务器。Tomcat将加载配置的SSL连接器并使用SSL证书提供HTTPS服务。\n\n一旦你完成了上述步骤，你的Tomcat服务器将配置为使用SSL证书提供HTTPS连接。你可以通过访问`https://yourdomain.com:8443/`来测试HTTPS连接，其中`yourdomain.com`是你的域名或服务器的IP地址，`8443`是你在配置文件中指定的SSL连接器端口。\n\n请注意，上述步骤仅适用于使用Tomcat作为Web服务器的情况。如果你使用其他Web服务器（如Nginx或Apache）作为反向代理服务器，你需要参考相应服务器的文档来配置SSL证书。","tags":["protected","Linux","Tomcat"],"categories":["Linux部署"]}]