<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis学习笔记 | 柊</title><meta name="author" content="棨"><meta name="copyright" content="棨"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#59b9c6"><meta name="description" content="Redis学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis学习笔记">
<meta property="og:url" content="https://chaoqijiang.github.io/2025/08/26/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="柊">
<meta property="og:description" content="Redis学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chaoqijiang.github.io/Image/avatar.png">
<meta property="article:published_time" content="2025-08-26T13:26:33.000Z">
<meta property="article:modified_time" content="2025-10-19T14:34:42.982Z">
<meta property="article:author" content="棨">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="protected">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chaoqijiang.github.io/Image/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis学习笔记",
  "url": "https://chaoqijiang.github.io/2025/08/26/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
  "image": "https://chaoqijiang.github.io/Image/avatar.png",
  "datePublished": "2025-08-26T13:26:33.000Z",
  "dateModified": "2025-10-19T14:34:42.982Z",
  "author": [
    {
      "@type": "Person",
      "name": "棨",
      "url": "https://chaoqijiang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chaoqijiang.github.io/2025/08/26/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#59b9c6')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 24 || hour >= 24
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":30,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#165e83","bgDark":"#507ea4","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/Image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴/归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/Image/topImage.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/Image/Logo.ico" alt="Logo"><span class="site-name">柊</span></a><a class="nav-page-title" href="/"><span class="site-name">Redis学习笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴/归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Redis学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-26T13:26:33.000Z" title="发表于 2025-08-26 21:26:33">2025-08-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-19T14:34:42.982Z" title="更新于 2025-10-19 22:34:42">2025-10-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">23k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>87分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><h2 id="Redis-核心概念与基础"><a href="#Redis-核心概念与基础" class="headerlink" title="Redis 核心概念与基础"></a><strong>Redis 核心概念与基础</strong></h2><ol>
<li><strong>Redis 是什么？</strong><ul>
<li>Redis 简介：内存数据结构存储，可用作数据库、缓存和消息中间件。</li>
<li>核心优势：高性能（基于内存）、丰富的数据类型、原子性操作。</li>
<li>主要应用场景：缓存系统、分布式会话、排行榜、计数器、消息队列、分布式锁等。</li>
</ul>
</li>
<li><strong>安装与启动</strong><ul>
<li>在不同操作系统（Linux, macOS, Windows&#x2F;WSL, Docker）上安装 Redis。</li>
<li>启动 Redis 服务器。</li>
<li>使用 redis-cli：连接、执行命令、PING&#x2F;PONG 测试。</li>
<li>Redis 配置文件 (redis.conf) 的基本介绍。</li>
</ul>
</li>
<li><strong>Redis 五大核心数据类型（理论与 redis-cli 实战）</strong><ul>
<li><strong>String (字符串)</strong><ul>
<li>简介：最基本的数据类型，可以是字符串、整数或浮点数。</li>
<li>常用命令：SET, GET, DEL, INCR, DECR, SETEX, MSET。<br>常用命令：SET， GET， DEL， INCR， DECR， SETEX， MSET。</li>
</ul>
</li>
<li><strong>List (列表)</strong><ul>
<li>简介：字符串列表，按插入顺序排序，底层是双向链表。</li>
<li>常用命令：LPUSH, RPUSH, LPOP, RPOP, LRANGE, LLEN。 兰奇，莱伦。</li>
</ul>
</li>
<li><strong>Hash (哈希&#x2F;字典)</strong><ul>
<li>简介：键值对集合，适合存储对象。</li>
<li>常用命令：HSET, HGET, HGETALL, HDEL, HKEYS, HVALS。<br>HGETALL， HDEL， HKEYS， HVALS。</li>
</ul>
</li>
<li><strong>Set (集合)</strong><ul>
<li>简介：无序的、唯一的字符串集合。</li>
<li>常用命令：SADD, SREM, SMEMBERS, SISMEMBER, SUNION, SINTER。<br>SISMEMBER、SUNION、SINTER。</li>
</ul>
</li>
<li><strong>Sorted Set (ZSET &#x2F; 有序集合)<br>Sorted Set （ZSET &#x2F; 有序集合）</strong><ul>
<li>简介：唯一的字符串集合，每个成员都关联一个 double 类型的分数（score），并按分数排序。</li>
<li>常用命令：ZADD, ZREM, ZRANGE, ZREVRANGE, ZRANGEBYSCORE, ZCARD。<br>常用命令：ZADD， ZREM， ZRANGE， ZREVRANGE， ZRANGEBYSCORE， ZCARD。</li>
</ul>
</li>
</ul>
</li>
<li><strong>通用键命令 (Key Commands)</strong><ul>
<li>KEYS pattern: 查找所有符合给定模式的 key（生产环境慎用）。</li>
<li>EXISTS key: 检查 key 是否存在。</li>
<li>TYPE key: 返回 key 所存储的值的类型。</li>
<li>EXPIRE key seconds: 为 key 设置过期时间。</li>
<li>TTL key: 查看 key 的剩余生存时间。</li>
<li>RENAME key newkey: 重命名 key。<br>Rename 的 Newkie：重命名 Ki。</li>
</ul>
</li>
</ol>
<h2 id="Go-与-Redis-集成"><a href="#Go-与-Redis-集成" class="headerlink" title="Go 与 Redis 集成"></a><strong>Go 与 Redis 集成</strong></h2><ol>
<li><strong>准备 Go 环境</strong><ul>
<li>选择一个 Redis Go 客户端：go-redis&#x2F;redis (推荐) vs gomodule&#x2F;redigo。</li>
<li>安装 go-redis 库：go get github.com&#x2F;go-redis&#x2F;redis&#x2F;v9。</li>
</ul>
</li>
<li><strong>连接 Redis</strong><ul>
<li>创建 Redis 客户端 (redis.NewClient)。</li>
<li>配置连接选项：地址、密码、数据库编号。</li>
<li>连接池的概念与配置。</li>
<li>测试连接：在 Go 中执行 Ping 命令。</li>
</ul>
</li>
<li><strong>在 Go 中操作 Redis 核心数据类型</strong><ul>
<li><strong>String 操作</strong><ul>
<li>Set(ctx, key, value, expiration)<br>Set（ctx， key， value， expiration）</li>
<li>Get(ctx, key) Get（ctx， 键）</li>
<li>错误处理：redis.Nil 的特殊处理。</li>
</ul>
</li>
<li><strong>List 操作</strong><ul>
<li>LPush(ctx, key, values…)<br>LPush（ctx， key， values…）</li>
<li>RPop(ctx, key) RPop（ctx，密钥）</li>
<li>LRange(ctx, key, start, stop)<br>LRange（ctx， key， start， stop）</li>
</ul>
</li>
<li><strong>Hash 操作</strong><ul>
<li>HSet(ctx, key, field, value)<br>HSet（ctx， 键， 字段， 值）</li>
<li>HGet(ctx, key, field) HGet（ctx， 键， 字段）</li>
<li>HGetAll(ctx, key) HGetAll（ctx，密钥）</li>
</ul>
</li>
<li><strong>Set 操作</strong><ul>
<li>SAdd(ctx, key, members…)<br>SAdd（ctx， key， members…）</li>
<li>SMembers(ctx, key) SMembers（ctx， 密钥）</li>
</ul>
</li>
<li><strong>Sorted Set 操作 Sorted Set 作</strong><ul>
<li>ZAdd(ctx, key, members…) (使用 redis.Z 结构)<br>ZAdd（ctx， key， members…） （使用 redis.Z 结构）</li>
<li>ZRange(ctx, key, start, stop)<br>ZRange（ctx， key， start， stop）</li>
</ul>
</li>
</ul>
</li>
<li><strong>上下文管理 (context.Context)<br>上下文管理 (context. Context)</strong><ul>
<li>为什么 go-redis 的每个操作都需要 context？</li>
<li>使用 context 控制超时和取消操作。</li>
</ul>
</li>
</ol>
<h2 id="Redis-进阶主题与-Go-实战"><a href="#Redis-进阶主题与-Go-实战" class="headerlink" title="Redis 进阶主题与 Go 实战"></a><strong>Redis 进阶主题与 Go 实战</strong></h2><ol>
<li><strong>事务 (Transactions) 事务 （Transactions）</strong><ul>
<li>Redis 事务：MULTI, EXEC, DISCARD, WATCH 命令。<br>Redis 事务：MULTI， EXEC， DISCARD， WATCH 命令</li>
<li>go-redis 中的 Pipeline 和 TxPipeline：一次性发送多个命令，减少网络开销。</li>
<li>在 Go 中使用 WATCH 实现乐观锁。</li>
</ul>
</li>
<li><strong>发布&#x2F;订阅 (Pub&#x2F;Sub)</strong><ul>
<li>Pub&#x2F;Sub 模式简介。</li>
<li>在 Go 中创建订阅者 (Subscribe)。 订阅）。</li>
<li>在 Go 中创建发布者 (Publish)。</li>
<li>实现一个简单的实时聊天室或通知系统。</li>
</ul>
</li>
<li><strong>持久化 (Persistence) 持久化 （Persistence）</strong><ul>
<li><strong>RDB (快照)</strong>：工作原理、优缺点。</li>
<li><strong>AOF (只追加文件)</strong>：工作原理、优缺点。</li>
<li>如何选择合适的持久化策略。</li>
</ul>
</li>
<li><strong>Lua 脚本</strong><ul>
<li>为什么需要 Lua 脚本？（保证原子性、减少网络请求）。</li>
<li>在 Go 中执行 Lua 脚本 (Eval, EvalSha)。 Eval， EvalSha）。</li>
<li>一个使用 Lua 脚本实现原子性操作的例子（例如：安全的库存扣减）。</li>
</ul>
</li>
<li><strong>Redis Streams (流) Redis Streams （流）</strong><ul>
<li>简介：强大的、支持消费者组的消息队列。</li>
<li>核心命令：XADD, XREAD, XGROUP CREATE, XREADGROUP。<br>XGROUP 创建，XREADGROUP。</li>
<li>在 Go 中使用 Streams 实现一个可靠的消息队列。</li>
</ul>
</li>
</ol>
<h2 id="高级应用与实战模式"><a href="#高级应用与实战模式" class="headerlink" title="高级应用与实战模式"></a><strong>高级应用与实战模式</strong></h2><ol>
<li><strong>构建缓存层 (Caching)</strong><ul>
<li>缓存模式：Cache-Aside (旁路缓存)。</li>
<li>在 Go Web 应用中集成 Redis 缓存，减轻数据库压力。</li>
<li>缓存穿透、缓存击穿、缓存雪崩问题及其解决方案。</li>
</ul>
</li>
<li><strong>实现分布式锁</strong><ul>
<li>基于 SETNX 的基本实现。</li>
<li>带有超时和唯一请求 ID 的安全分布式锁实现。</li>
<li>Redlock 算法思想简介。</li>
</ul>
</li>
<li><strong>位图 (Bitmaps) 与 HyperLogLogs<br>位图 （Bitmaps） 与 HyperLogLogs</strong><ul>
<li><strong>Bitmaps</strong>：用于高效存储布尔信息（如用户签到、在线状态）。<ul>
<li>Go 中的 SetBit, GetBit, BitCount 操作。</li>
</ul>
</li>
<li><strong>HyperLogLogs</strong>：用于基数统计（如统计独立访客数），占用空间极小。<ul>
<li>Go 中的 PFAdd, PFCount 操作。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="运维与最佳实践"><a href="#运维与最佳实践" class="headerlink" title="运维与最佳实践"></a><strong>运维与最佳实践</strong></h2><ol>
<li><strong>Redis 高可用与扩展</strong><ul>
<li><strong>主从复制 (Replication)</strong>：数据备份与读写分离。</li>
<li><strong>哨兵 (Sentinel)</strong>：实现高可用，自动故障转移。</li>
<li><strong>集群 (Cluster)</strong>：分布式方案，解决单机瓶颈。</li>
</ul>
</li>
<li><strong>性能与监控</strong><ul>
<li>INFO 命令：获取 Redis 实例的详细信息。</li>
<li>SLOWLOG 命令：查找慢查询。</li>
<li>常见性能优化技巧。</li>
<li>内存管理与淘汰策略（LRU, LFU 等）。</li>
</ul>
</li>
</ol>
<h1 id="Redis-核心概念与基础-1"><a href="#Redis-核心概念与基础-1" class="headerlink" title="Redis 核心概念与基础"></a><strong>Redis 核心概念与基础</strong></h1><p>在正式用 Go 语言连接和操作 Redis 之前，我们必须先牢固地掌握 Redis 本身的核心概念。这部分内容将完全聚焦于 Redis 的理论知识和基础操作，我们将使用 redis-cli 这个官方命令行工具来与 Redis 服务进行交互和学习。</p>
<h2 id="1-Redis-是什么？"><a href="#1-Redis-是什么？" class="headerlink" title="1. Redis 是什么？"></a><strong>1. Redis 是什么？</strong></h2><p>Redis (REmote DIctionary Server，远程字典服务) 是一个开源的、使用 C 语言编写的、高性能的 <strong>键值 (Key-Value) 存储系统</strong>。</p>
<p>它通常被称作“数据结构服务器”，因为它的值（value）可以是多种复杂的数据结构，而不仅仅是简单的字符串。这些数据结构的设计使得 Redis 在处理特定业务场景时极为高效。</p>
<ul>
<li><strong>核心定位</strong>：基于内存的存储，同时支持持久化。这意味着数据主要存储在内存中，以实现极高的读写速度，但也可以将数据定期或实时地写入磁盘，以防止服务器重启后数据丢失。</li>
<li><strong>核心优势</strong>：<ul>
<li><strong>极高的性能</strong>：由于数据在内存中，读写速度非常快，官方数据称其读操作可达 11万次&#x2F;秒，写操作可达 8.1万次&#x2F;秒。</li>
<li><strong>丰富的数据类型</strong>：支持字符串、列表、哈希、集合、有序集合等多种数据结构，这让它能灵活应对各种应用场景。</li>
<li><strong>原子性操作</strong>：Redis 的所有操作都是原子性的，这意味着一个操作要么完全执行，要么完全不执行，不会出现中间状态。这得益于其单线程的事件处理模型。</li>
<li><strong>多功能性</strong>：除了作为数据库，它还可以用作<strong>缓存系统</strong>和<strong>消息中间件</strong> (Pub&#x2F;Sub, Streams)。</li>
</ul>
</li>
<li><strong>主要应用场景</strong>：<ul>
<li><strong>缓存系统</strong>：为高频访问的数据提供快速读取，减轻后端数据库（如 MySQL）的压力。</li>
<li><strong>分布式会话存储</strong>：在分布式 Web 应用中，将用户的 session 信息存储在 Redis 中，实现多台服务器间的会话共享。</li>
<li><strong>排行榜</strong>：利用有序集合 (Sorted Set) 的分数排序功能，轻松实现实时排行榜，如游戏积分榜、热门文章榜。</li>
<li><strong>计数器</strong>：利用 String 类型的 INCR 原子性自增命令，实现如文章阅读量、点赞数等高并发计数功能。</li>
<li><strong>消息队列</strong>：利用 List 的 LPUSH&#x2F;RPOP 或更专业的 Streams 类型，实现简单的消息队列，用于任务解耦和异步处理。</li>
<li><strong>分布式锁</strong>：利用 SETNX (SET if Not eXists) 命令，在分布式系统中实现资源的互斥访问。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-安装与启动"><a href="#2-安装与启动" class="headerlink" title="2. 安装与启动"></a><strong>2. 安装与启动</strong></h2><p>学习 Redis 最好的方式就是亲手实践。</p>
<ul>
<li><p><strong>在 Linux (Ubuntu&#x2F;Debian) 上安装</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install redis-server</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 macOS 上安装</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 Windows 上安装</strong>：<br>官方推荐使用 WSL (Windows Subsystem for Linux)。在 WSL 环境中，可以按照 Linux 的方式进行安装。</p>
</li>
<li><p><strong>使用 Docker (推荐，跨平台最方便)</strong>：<br>这是最简单、最干净的安装方式，不会污染你的主机环境。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 运行一个名为 my-redis 的 Redis 容器，并将容器的 6379 端口映射到主机的 6379 端口</span><br><span class="line">docker run --name my-redis -p 6379:6379 -d redis</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>启动服务与连接</strong></p>
<p>安装完成后，Redis 服务通常会自动启动。你可以使用 redis-cli (Redis Command Line Interface) 来连接并与之交互。</p>
<ol>
<li><p>打开你的终端。</p>
</li>
<li><p>输入 redis-cli 并回车。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>看到这个提示符就代表你已经成功连接了。现在，来执行你的第一个 Redis 命令——PING。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PING</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>

<p>如果服务器返回 PONG，说明连接正常，服务器正在运行。</p>
</li>
</ol>
<p><strong>配置文件</strong></p>
<p>Redis 的所有配置都在一个名为 redis.conf 的文件中。你可以在里面修改端口、设置密码、配置持久化策略等。这个文件通常位于 &#x2F;etc&#x2F;redis&#x2F;redis.conf (Linux) 或你的 Homebrew 安装目录下。在后面的进阶部分我们会接触到它。</p>
<hr>
<h2 id="3-Redis-五大核心数据类型"><a href="#3-Redis-五大核心数据类型" class="headerlink" title="3. Redis 五大核心数据类型"></a><strong>3. Redis 五大核心数据类型</strong></h2><p>这是 Redis 的精髓所在。下面我将为你详细介绍 Redis 的五种核心数据类型：String、List、Hash、Set 和 Sorted Set。</p>
<p>对于每种数据类型，我都会从以下几个方面进行阐述：</p>
<ol>
<li><strong>简介</strong>：它是什么，有什么特点。</li>
<li><strong>内部实现</strong>：简述其底层的实现原理，这有助于理解其性能特征。</li>
<li><strong>应用场景</strong>：在实际开发中通常用它来做什么。</li>
<li><strong>Redis CLI 示例</strong>：通过 <code>redis-cli</code> 命令行工具进行操作演示。</li>
<li><strong>Go 语言示例</strong>：使用流行的 <code>go-redis/redis</code> 库进行代码实现。</li>
</ol>
<hr>
<h3 id="Go-语言环境准备"><a href="#Go-语言环境准备" class="headerlink" title="Go 语言环境准备"></a>Go 语言环境准备</h3><p>在开始 Go 语言示例之前, 请确保你已经安装了 Go 环境，并获取了 <code>go-redis</code> 库：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go get github.com/go-redis/redis/v9</span><br></pre></td></tr></table></figure>

<p>我们将使用下面的 Go 代码模板来连接 Redis，并为每种数据类型创建独立的演示函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/go-redis/redis/v8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ctx = context.Background()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局 Redis 客户端</span></span><br><span class="line"><span class="keyword">var</span> rdb *redis.Client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 初始化 Redis 客户端</span></span><br><span class="line">	rdb = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr:     <span class="string">&quot;localhost:6379&quot;</span>, <span class="comment">// Redis 服务器地址</span></span><br><span class="line">		Password: <span class="string">&quot;&quot;</span>,               <span class="comment">// 没有密码，就留空</span></span><br><span class="line">		DB:       <span class="number">0</span>,                <span class="comment">// 使用默认的 DB</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 测试连接</span></span><br><span class="line">	_, err := rdb.Ping(ctx).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;成功连接到 Redis!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 运行各个数据类型的示例</span></span><br><span class="line">    stringDemo()</span><br><span class="line">    listDemo()</span><br><span class="line">    hashDemo()</span><br><span class="line">    setDemo()</span><br><span class="line">    sortedSetDemo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 下面将实现各个 demo 函数</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-字符串-String"><a href="#1-字符串-String" class="headerlink" title="1. 字符串 (String)"></a>1. 字符串 (String)</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>String 是 Redis 最基本的数据类型，也是最常用的。它可以存储任何形式的字符串，包括文本、序列化的 JSON、甚至是二进制数据（如图片），最大可以存储 512MB 的数据。</p>
<h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><p>Redis 的 String 类型并不是 C 语言的原生字符串，而是自己实现的一种名为 <strong>简单动态字符串 (Simple Dynamic String, SDS)</strong> 的数据结构。SDS 相比 C 字符串有以下优点：</p>
<ul>
<li><strong>O(1) 复杂度获取字符串长度</strong>：SDS 结构中直接记录了长度。</li>
<li><strong>杜绝缓冲区溢出</strong>：在修改字符串时，SDS 会自动检查空间并进行扩容。</li>
<li><strong>二进制安全</strong>：可以存储任意二进制数据，不会因为遇到 <code>\0</code> 字符而截断。</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><strong>缓存</strong>：缓存用户信息、文章内容、全页缓存等。</li>
<li><strong>计数器</strong>：利用 <code>INCR</code>、<code>DECR</code> 等原子操作实现网站访问量、点赞数、库存数量等。</li>
<li><strong>分布式锁</strong>：利用 <code>SETNX</code> (SET if Not eXists) 命令的原子性实现。</li>
<li><strong>共享 Session</strong>：在分布式系统中存储用户会话信息。</li>
</ul>
<h4 id="Redis-CLI-示例"><a href="#Redis-CLI-示例" class="headerlink" title="Redis CLI 示例"></a>Redis CLI 示例</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置一个键值对</span></span><br><span class="line"><span class="comment"># SET key value</span></span><br><span class="line">&gt; SET user:1:name <span class="string">&quot;Alice&quot;</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取一个键的值</span></span><br><span class="line"><span class="comment"># GET key</span></span><br><span class="line">&gt; GET user:1:name</span><br><span class="line"><span class="string">&quot;Alice&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置一个会自动过期的键 (10秒后过期)</span></span><br><span class="line"><span class="comment"># SETEX key seconds value</span></span><br><span class="line">&gt; SETEX session:token <span class="string">&quot;some-random-token&quot;</span> 10</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数字进行原子自增</span></span><br><span class="line"><span class="comment"># INCR key</span></span><br><span class="line">&gt; SET views:article:123 100</span><br><span class="line">OK</span><br><span class="line">&gt; INCR views:article:123</span><br><span class="line">(<span class="built_in">integer</span>) 101</span><br><span class="line">&gt; GET views:article:123</span><br><span class="line"><span class="string">&quot;101&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有当 key 不存在时才设置</span></span><br><span class="line"><span class="comment"># SETNX key value</span></span><br><span class="line">&gt; SETNX lock:payment:order:456 1</span><br><span class="line">(<span class="built_in">integer</span>) 1  <span class="comment"># 成功设置，返回 1</span></span><br><span class="line">&gt; SETNX lock:payment:order:456 1</span><br><span class="line">(<span class="built_in">integer</span>) 0  <span class="comment"># 设置失败，因为 key 已存在，返回 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量设置</span></span><br><span class="line"><span class="comment"># MSET key1 value1 key2 value2 ...</span></span><br><span class="line">&gt; MSET user:1:email <span class="string">&quot;alice@example.com&quot;</span> user:1:city <span class="string">&quot;New York&quot;</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量获取</span></span><br><span class="line"><span class="comment"># MGET key1 key2 ...</span></span><br><span class="line">&gt; MGET user:1:name user:1:email</span><br><span class="line">1) <span class="string">&quot;Alice&quot;</span></span><br><span class="line">2) <span class="string">&quot;alice@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="Go-语言示例"><a href="#Go-语言示例" class="headerlink" title="Go 语言示例"></a>Go 语言示例</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打印一个分隔符，表示当前正在演示字符串相关的 Redis 操作</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- String Demo ---&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// --- SET 操作：设置一个字符串类型的键值对 ---</span></span><br><span class="line">	<span class="comment">// 使用 rdb.Set() 将键 &quot;user:1:name&quot; 的值设为 &quot;Bob&quot;</span></span><br><span class="line">	<span class="comment">// 第三个参数是过期时间，0 表示永不过期</span></span><br><span class="line">	<span class="comment">// .Err() 用于获取执行结果中的错误信息</span></span><br><span class="line">	err := rdb.Set(ctx, <span class="string">&quot;user:1:name&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">0</span>).Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果设置失败，抛出异常并终止程序（学习时便于发现问题）</span></span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- GET 操作：获取指定键的值 ---</span></span><br><span class="line">	<span class="comment">// 使用 rdb.Get() 获取键 &quot;user:1:name&quot; 的当前值</span></span><br><span class="line">	<span class="comment">// .Result() 返回实际的值和可能的错误</span></span><br><span class="line">	name, err := rdb.Get(ctx, <span class="string">&quot;user:1:name&quot;</span>).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果获取失败（例如键不存在），报错</span></span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 成功获取后打印结果</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;user:1:name:&quot;</span>, name)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- SETEX：设置带过期时间的键值对 ---</span></span><br><span class="line">	<span class="comment">// SetEX 类似于 Set，但明确指定过期时间为 10 秒</span></span><br><span class="line">	<span class="comment">// 这里模拟设置一个会话 token，10 秒后自动失效</span></span><br><span class="line">	err = rdb.Set(ctx, <span class="string">&quot;session:token&quot;</span>, <span class="string">&quot;some-random-token-go&quot;</span>, <span class="number">10</span>*time.Second).Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;session:token 设置成功，10秒后过期&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- INCR：原子性自增操作 ---</span></span><br><span class="line">	<span class="comment">// 先设置初始浏览量为 1000</span></span><br><span class="line">	rdb.Set(ctx, <span class="string">&quot;views:article:456&quot;</span>, <span class="number">1000</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="comment">// 调用 Incr 对该键的值原子性地加 1</span></span><br><span class="line">	<span class="comment">// 原子性意味着在高并发下不会出现数据竞争问题</span></span><br><span class="line">	newViews, err := rdb.Incr(ctx, <span class="string">&quot;views:article:456&quot;</span>).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印自增后的最新浏览量</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;文章 456 的新浏览量:&quot;</span>, newViews)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- SETNX：SET if Not eXists，常用于实现分布式锁 ---</span></span><br><span class="line">	<span class="comment">// 尝试设置键 &quot;lock:payment:order:789&quot;，只有当它不存在时才设置成功</span></span><br><span class="line">	<span class="comment">// 同时设置 10 秒过期时间，防止死锁</span></span><br><span class="line">	<span class="comment">// 返回布尔值表示是否设置成功</span></span><br><span class="line">	locked, err := rdb.SetNX(ctx, <span class="string">&quot;lock:payment:order:789&quot;</span>, <span class="string">&quot;process-1&quot;</span>, <span class="number">10</span>*time.Second).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> locked &#123;</span><br><span class="line">		<span class="comment">// 设置成功，说明获得了“锁”</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;成功获取锁 lock:payment:order:789&quot;</span>)</span><br><span class="line">		<span class="comment">// 此处可以执行关键业务逻辑（如支付处理）</span></span><br><span class="line">		<span class="comment">// 注意：业务完成后应调用 Del 删除锁，或依赖过期自动释放</span></span><br><span class="line">		<span class="comment">// 示例代码中注释掉了释放锁的操作，实际使用需谨慎管理锁生命周期</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 设置失败，说明锁已被其他进程持有</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;获取锁 lock:payment:order:789 失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// --- MSET：批量设置多个键值对 ---</span></span><br><span class="line">	<span class="comment">// 一次性设置用户的多个字段（名称和邮箱），减少网络往返开销</span></span><br><span class="line">	err = rdb.MSet(ctx, <span class="string">&quot;user:2:name&quot;</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;user:2:email&quot;</span>, <span class="string">&quot;charlie@example.com&quot;</span>).Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- MGET：批量获取多个键的值 ---</span></span><br><span class="line">	<span class="comment">// 一次性获取用户的所有相关信息，提高效率</span></span><br><span class="line">	vals, err := rdb.MGet(ctx, <span class="string">&quot;user:2:name&quot;</span>, <span class="string">&quot;user:2:email&quot;</span>).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// vals 是一个 []interface&#123;&#125; 类型的切片，包含对应键的值</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;批量获取 user:2 的信息:&quot;</span>, vals)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-列表-List"><a href="#2-列表-List" class="headerlink" title="2. 列表 (List)"></a>2. 列表 (List)</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>List 是一个<strong>有序的字符串集合</strong>，其元素可以重复。它本质上是一个双向链表，所以从列表的头部（Left）或尾部（Right）添加或移除元素非常快，时间复杂度是 O(1)。但是通过索引访问元素则比较慢，时间复杂度是 O(N)。</p>
<h4 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h4><p>在 Redis 3.2 之前，List 底层由 <code>ziplist</code> (压缩列表) 或 <code>linkedlist</code> (双向链表) 实现。之后，统一由 <strong><code>quicklist</code></strong> 实现。<code>quicklist</code> 是一个 <code>ziplist</code> 的双向链表，它结合了两者的优点，既节省空间，又保证了插入和删除的效率。</p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><strong>消息队列&#x2F;任务队列</strong>：利用 <code>LPUSH</code> 生产消息，<code>RPOP</code> 消费消息（或者反过来），可以实现简单的消息队列。<code>BRPOP</code> (阻塞式弹出) 更适合做任务队列。</li>
<li><strong>文章&#x2F;动态列表</strong>：比如微博的关注人动态，最新评论列表。每当有新动态，<code>LPUSH</code> 进列表，然后用 <code>LTRIM</code> 保持列表的固定长度。</li>
<li><strong>栈和队列</strong>：<code>LPUSH</code> + <code>LPOP</code> 实现一个栈 (FILO)；<code>LPUSH</code> + <code>RPOP</code> 实现一个队列 (FIFO)。</li>
</ul>
<h4 id="Redis-CLI-示例-1"><a href="#Redis-CLI-示例-1" class="headerlink" title="Redis CLI 示例"></a>Redis CLI 示例</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从左侧推入元素</span></span><br><span class="line"><span class="comment"># LPUSH key element [element ...]</span></span><br><span class="line">&gt; LPUSH tasks <span class="string">&quot;task1&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; LPUSH tasks <span class="string">&quot;task2&quot;</span> <span class="string">&quot;task3&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment"># 当前列表: [&quot;task3&quot;, &quot;task2&quot;, &quot;task1&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从右侧推入元素</span></span><br><span class="line"><span class="comment"># RPUSH key element [element ...]</span></span><br><span class="line">&gt; RPUSH tasks <span class="string">&quot;task0&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"><span class="comment"># 当前列表: [&quot;task3&quot;, &quot;task2&quot;, &quot;task1&quot;, &quot;task0&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看列表长度</span></span><br><span class="line"><span class="comment"># LLEN key</span></span><br><span class="line">&gt; LLEN tasks</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看列表范围内的元素 (0 是第一个, -1 是最后一个)</span></span><br><span class="line"><span class="comment"># LRANGE key start stop</span></span><br><span class="line">&gt; LRANGE tasks 0 -1</span><br><span class="line">1) <span class="string">&quot;task3&quot;</span></span><br><span class="line">2) <span class="string">&quot;task2&quot;</span></span><br><span class="line">3) <span class="string">&quot;task1&quot;</span></span><br><span class="line">4) <span class="string">&quot;task0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从左侧弹出一个元素</span></span><br><span class="line"><span class="comment"># LPOP key</span></span><br><span class="line">&gt; LPOP tasks</span><br><span class="line"><span class="string">&quot;task3&quot;</span></span><br><span class="line"><span class="comment"># 当前列表: [&quot;task2&quot;, &quot;task1&quot;, &quot;task0&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从右侧弹出一个元素</span></span><br><span class="line"><span class="comment"># RPOP key</span></span><br><span class="line">&gt; RPOP tasks</span><br><span class="line"><span class="string">&quot;task0&quot;</span></span><br><span class="line"><span class="comment"># 当前列表: [&quot;task2&quot;, &quot;task1&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 阻塞式地从右侧弹出一个元素，如果列表为空，等待 10 秒</span></span><br><span class="line"><span class="comment"># BRPOP key [key ...] timeout</span></span><br><span class="line">&gt; BRPOP new_tasks 10</span><br><span class="line"><span class="comment"># (如果 10 秒内没有元素推入 new_tasks，则返回 nil)</span></span><br></pre></td></tr></table></figure>

<h4 id="Go-语言示例-1"><a href="#Go-语言示例-1" class="headerlink" title="Go 语言示例"></a>Go 语言示例</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打印一个分隔提示，表示接下来将演示 Redis 的 List（列表）类型操作</span></span><br><span class="line">	<span class="comment">// List 在 Redis 中是一个有序的字符串元素集合，支持从两端插入和删除，非常适合用作队列或栈</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- List Demo ---&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义一个键名，用于存储任务列表</span></span><br><span class="line">	<span class="comment">// 键的命名通常采用冒号分隔的层级结构（如 &quot;资源类型:ID:字段&quot;），便于组织和理解</span></span><br><span class="line">	listKey := <span class="string">&quot;tasks:go&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- 清理旧数据：防止之前测试残留数据影响本次演示 ---</span></span><br><span class="line">	<span class="comment">// 使用 Del 删除指定键，如果该键存在则删除，不存在也不会报错</span></span><br><span class="line">	<span class="comment">// 这是为了保证每次运行 demo 时都从一个干净的状态开始</span></span><br><span class="line">	rdb.Del(ctx, listKey)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- LPUSH：Left Push，从列表的左侧（头部）插入一个或多个元素 ---</span></span><br><span class="line">	<span class="comment">// 语法：LPush(上下文, 键名, 要插入的值...)</span></span><br><span class="line">	<span class="comment">// 插入顺序是 &quot;task3&quot;, &quot;task2&quot;, &quot;task1&quot;</span></span><br><span class="line">	<span class="comment">// 因为是从左边插入，所以最终顺序是：task1 -&gt; task2 -&gt; task3（task1 在最左边）</span></span><br><span class="line">	rdb.LPush(ctx, listKey, <span class="string">&quot;task3&quot;</span>, <span class="string">&quot;task2&quot;</span>, <span class="string">&quot;task1&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 查看当前列表的长度（元素个数）</span></span><br><span class="line">	<span class="comment">// LLen 返回的是 Redis 的整数响应，.Val() 是将其转换为 Go 的 int64 类型</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;LPUSH 后，任务列表长度:&quot;</span>, rdb.LLen(ctx, listKey).Val())</span><br><span class="line">	<span class="comment">// 此时列表中的实际顺序为：[&quot;task1&quot;, &quot;task2&quot;, &quot;task3&quot;]（从左到右）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- RPUSH：Right Push，从列表的右侧（尾部）插入元素 ---</span></span><br><span class="line">	<span class="comment">// 在列表末尾添加 &quot;task0&quot;</span></span><br><span class="line">	<span class="comment">// 当前列表变为：[&quot;task1&quot;, &quot;task2&quot;, &quot;task3&quot;, &quot;task0&quot;]</span></span><br><span class="line">	rdb.RPush(ctx, listKey, <span class="string">&quot;task0&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 再次查看列表长度，确认新增了一个元素</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;RPUSH 后，任务列表长度:&quot;</span>, rdb.LLen(ctx, listKey).Val())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- LRANGE：获取列表中指定范围的元素 ---</span></span><br><span class="line">	<span class="comment">// 语法：LRANGE(key, start, stop)</span></span><br><span class="line">	<span class="comment">// 参数说明：</span></span><br><span class="line">	<span class="comment">//   start: 起始索引（从0开始）</span></span><br><span class="line">	<span class="comment">//   stop:  结束索引（-1 表示最后一个，-2 表示倒数第二个，以此类推）</span></span><br><span class="line">	<span class="comment">// 这里传入 (0, -1) 表示获取整个列表的所有元素</span></span><br><span class="line">	tasks, err := rdb.LRange(ctx, listKey, <span class="number">0</span>, <span class="number">-1</span>).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果发生错误（比如连接问题），程序崩溃便于调试</span></span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印当前列表中的所有任务</span></span><br><span class="line">	<span class="comment">// 注意顺序：[&quot;task1&quot;, &quot;task2&quot;, &quot;task3&quot;, &quot;task0&quot;]</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;当前任务列表:&quot;</span>, tasks)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- LPOP：Left Pop，从列表左侧（头部）移除并返回一个元素 ---</span></span><br><span class="line">	<span class="comment">// 这个操作会把最左边的元素取出来，并从列表中删除它</span></span><br><span class="line">	<span class="comment">// 类似于“取队列的第一个任务来处理”</span></span><br><span class="line">	task, err := rdb.LPop(ctx, listKey).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此时被弹出的是 &quot;task1&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;LPOP 弹出的任务:&quot;</span>, task)</span><br><span class="line">	<span class="comment">// 弹出后列表变为：[&quot;task2&quot;, &quot;task3&quot;, &quot;task0&quot;]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- RPOP：Right Pop，从列表右侧（尾部）移除并返回一个元素 ---</span></span><br><span class="line">	<span class="comment">// 与 LPOP 相对，从右边取出元素</span></span><br><span class="line">	<span class="comment">// 这类似于栈的操作（后进先出）</span></span><br><span class="line">	task, err = rdb.RPop(ctx, listKey).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此时被弹出的是最右边的 &quot;task0&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;RPOP 弹出的任务:&quot;</span>, task)</span><br><span class="line">	<span class="comment">// 弹出后列表变为：[&quot;task2&quot;, &quot;task3&quot;]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 再次使用 LRANGE 获取剩余的所有任务，验证前面的操作结果</span></span><br><span class="line">	tasks, _ = rdb.LRange(ctx, listKey, <span class="number">0</span>, <span class="number">-1</span>).Result()</span><br><span class="line">	<span class="comment">// 注意这里忽略了错误（_），仅用于展示目的，生产环境中仍需检查错误</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;弹出后剩余的任务列表:&quot;</span>, tasks)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-哈希-Hash"><a href="#3-哈希-Hash" class="headerlink" title="3. 哈希 (Hash)"></a>3. 哈希 (Hash)</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>Hash 是一个<strong>字符串字段 (field) 和字符串值 (value) 的映射表</strong>，它非常适合用来存储对象。你可以把它看作是 <code>Map&lt;String, String&gt;</code>。相比于将整个对象序列化成 JSON 字符串存入 String 类型，Hash 的优势在于可以对对象中的单个字段进行读写，节省网络开销。</p>
<h4 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a>内部实现</h4><p>Hash 底层采用 <code>ziplist</code> (压缩列表) 或 <code>hashtable</code> (哈希表) 存储。当字段数量较少且值较短时，使用 <code>ziplist</code> 非常节省内存。当超过阈值时，会自动转换为 <code>hashtable</code> 以保证查询效率。</p>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><strong>存储对象</strong>：用户信息（用户名、年龄、邮箱）、商品信息（名称、价格、库存）等。</li>
<li><strong>购物车</strong>：用一个 Hash 存储用户的购物车，<code>field</code> 是商品 ID，<code>value</code> 是商品数量。</li>
<li><strong>缓存</strong>：相比 String 缓存整个对象，Hash 可以只缓存对象的某些字段，或只更新某个变化的字段。</li>
</ul>
<h4 id="Redis-CLI-示例-2"><a href="#Redis-CLI-示例-2" class="headerlink" title="Redis CLI 示例"></a>Redis CLI 示例</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置单个字段</span></span><br><span class="line"><span class="comment"># HSET key field value</span></span><br><span class="line">&gt; HSET user:1 name <span class="string">&quot;Alice&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置多个字段</span></span><br><span class="line"><span class="comment"># HSET key field1 value1 field2 value2 ...</span></span><br><span class="line">&gt; HSET user:1 age 25 email <span class="string">&quot;alice@example.com&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取单个字段的值</span></span><br><span class="line"><span class="comment"># HGET key field</span></span><br><span class="line">&gt; HGET user:1 name</span><br><span class="line"><span class="string">&quot;Alice&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取多个字段的值</span></span><br><span class="line"><span class="comment"># HMGET key field1 field2 ...</span></span><br><span class="line">&gt; HMGET user:1 name age city</span><br><span class="line">1) <span class="string">&quot;Alice&quot;</span></span><br><span class="line">2) <span class="string">&quot;25&quot;</span></span><br><span class="line">3) (nil) <span class="comment"># city 字段不存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有字段和值</span></span><br><span class="line"><span class="comment"># HGETALL key</span></span><br><span class="line">&gt; HGETALL user:1</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;Alice&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">4) <span class="string">&quot;25&quot;</span></span><br><span class="line">5) <span class="string">&quot;email&quot;</span></span><br><span class="line">6) <span class="string">&quot;alice@example.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对字段的值进行原子自增</span></span><br><span class="line"><span class="comment"># HINCRBY key field increment</span></span><br><span class="line">&gt; HSET product:100 stock 50</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; HINCRBY product:100 stock -5  <span class="comment"># 卖出 5 个</span></span><br><span class="line">(<span class="built_in">integer</span>) 45</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有字段</span></span><br><span class="line"><span class="comment"># HKEYS key</span></span><br><span class="line">&gt; HKEYS user:1</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">3) <span class="string">&quot;email&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="Go-语言示例-2"><a href="#Go-语言示例-2" class="headerlink" title="Go 语言示例"></a>Go 语言示例</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打印一个分隔提示，表示接下来将演示 Redis 的 Hash（哈希）类型操作</span></span><br><span class="line">	<span class="comment">// Hash 类似于一个“小型对象”或“字典”，适合存储一个实体的多个字段</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- Hash Demo ---&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义一个键名，用于表示用户 3 的信息</span></span><br><span class="line">	<span class="comment">// 使用冒号分隔命名空间：user:3:go 表示“用户3的Go语言示例数据”</span></span><br><span class="line">	userKey := <span class="string">&quot;user:3:go&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- 清理旧数据：确保每次运行 demo 都从干净状态开始 ---</span></span><br><span class="line">	<span class="comment">// 删除之前可能存在的同名键，避免影响本次演示结果</span></span><br><span class="line">	<span class="comment">// 即使键不存在，Del 也不会报错</span></span><br><span class="line">	rdb.Del(ctx, userKey)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- HSET：Hash Set，设置一个或多个字段-值对到指定的 hash 键中 ---</span></span><br><span class="line">	<span class="comment">// 语法：HSet(上下文, 键名, 字段1, 值1, 字段2, 值2, ...)</span></span><br><span class="line">	<span class="comment">// 这里给 user:3:go 设置了三个字段：name, age, email</span></span><br><span class="line">	err := rdb.HSet(ctx, userKey, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">30</span>, <span class="string">&quot;email&quot;</span>, <span class="string">&quot;david@example.com&quot;</span>).Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果设置失败（比如连接中断），直接 panic 中断程序以便调试</span></span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 提示信息：说明用户信息已成功写入 Redis</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;HSET 设置用户信息&quot;</span>)</span><br><span class="line">	<span class="comment">// 此时 Redis 中存储的数据结构类似于：</span></span><br><span class="line">	<span class="comment">// user:3:go = &#123;</span></span><br><span class="line">	<span class="comment">//   &quot;name&quot;:  &quot;David&quot;,</span></span><br><span class="line">	<span class="comment">//   &quot;age&quot;:   &quot;30&quot;,</span></span><br><span class="line">	<span class="comment">//   &quot;email&quot;: &quot;david@example.com&quot;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- HGET：Hash Get，获取 hash 中某个字段的值 ---</span></span><br><span class="line">	<span class="comment">// 语法：HGet(上下文, 键名, 字段名)</span></span><br><span class="line">	<span class="comment">// 这里我们只想获取用户的姓名</span></span><br><span class="line">	name, err := rdb.HGet(ctx, userKey, <span class="string">&quot;name&quot;</span>).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 成功获取后打印结果</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;获取用户名:&quot;</span>, name) <span class="comment">// 输出：David</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- HMGET：Hash Multiple Get，批量获取多个字段的值 ---</span></span><br><span class="line">	<span class="comment">// 语法：HMGet(上下文, 键名, 字段1, 字段2, ...)</span></span><br><span class="line">	<span class="comment">// 可以一次请求多个字段，提高效率</span></span><br><span class="line">	<span class="comment">// 注意：如果某个字段不存在（如 &quot;city&quot;），其返回值为 nil（在 Go 中表现为 interface&#123;&#125; 类型的 nil）</span></span><br><span class="line">	fields, err := rdb.HMGet(ctx, userKey, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;city&quot;</span>).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印结果：[David 30 &lt;nil&gt;]，其中 city 不存在所以是 nil</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;批量获取用户信息:&quot;</span>, fields)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- HGETALL：获取 hash 中所有的字段和值 ---</span></span><br><span class="line">	<span class="comment">// 语法：HGetAll(上下文, 键名)</span></span><br><span class="line">	<span class="comment">// 返回值是一个 map[string]string，包含所有字段及其对应的值</span></span><br><span class="line">	user, err := rdb.HGetAll(ctx, userKey).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印整个用户信息 map</span></span><br><span class="line">	<span class="comment">// 输出示例：map[age:30 email:david@example.com name:David]</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;获取所有用户信息 (map):&quot;</span>, user)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- HINCRBY：对 hash 中某个字段进行整数增减操作（原子性）---</span></span><br><span class="line">	<span class="comment">// 常用于库存、积分、浏览量等需要频繁更新的数值型字段</span></span><br><span class="line">	<span class="comment">// 语法：HIncrBy(上下文, 键名, 字段名, 步长)</span></span><br><span class="line">	<span class="comment">// 这里我们模拟减少商品库存：商品 101 的 stock 字段减去 2</span></span><br><span class="line">	<span class="comment">// 如果键或字段不存在，Redis 会先创建并初始化为 0，再进行运算</span></span><br><span class="line">	newStock, err := rdb.HIncrBy(ctx, <span class="string">&quot;product:101:go&quot;</span>, <span class="string">&quot;stock&quot;</span>, <span class="number">-2</span>).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 假设原库存是 100，则 newStock = 98</span></span><br><span class="line">	<span class="comment">// 如果之前没有设置过，Redis 会自动设为 0，然后 0 - 2 = -2</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;商品 101 减库存后剩余:&quot;</span>, newStock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-集合-Set"><a href="#4-集合-Set" class="headerlink" title="4. 集合 (Set)"></a>4. 集合 (Set)</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>Set 是一个<strong>无序且唯一的字符串集合</strong>。它的主要特点是元素唯一不重复，并且提供了高效的集合运算，如交集、并集、差集等。</p>
<h4 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a>内部实现</h4><p>Set 底层采用 <code>intset</code> (整数集合) 或 <code>hashtable</code> (哈希表)。当所有元素都是整数且数量不多时，使用 <code>intset</code> 存储，非常节省内存。否则，转换为 <code>hashtable</code>。</p>
<h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><strong>标签系统</strong>：一篇文章可以有多个标签，用 Set 存储一篇文章的所有标签。<code>SISMEMBER</code> 可以快速判断文章是否有某个标签。</li>
<li><strong>共同好友&#x2F;关注</strong>：利用 <code>SINTER</code> (交集) 计算两个用户的共同好友。</li>
<li><strong>抽奖系统</strong>：用 <code>SADD</code> 将所有参与用户ID加入集合，用 <code>SRANDMEMBER</code> 或 <code>SPOP</code> 随机抽取中奖用户。</li>
<li><strong>点赞&#x2F;收藏</strong>：用 Set 存储对某篇文章点赞的所有用户 ID，可以快速判断某用户是否已点赞。</li>
<li><strong>独立 IP 统计</strong>：用 Set 存储访问某页面的所有 IP 地址，集合的大小就是独立 IP 数。</li>
</ul>
<h4 id="Redis-CLI-示例-3"><a href="#Redis-CLI-示例-3" class="headerlink" title="Redis CLI 示例"></a>Redis CLI 示例</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加一个或多个成员</span></span><br><span class="line"><span class="comment"># SADD key member [member ...]</span></span><br><span class="line">&gt; SADD tags:article:1 <span class="string">&quot;redis&quot;</span> <span class="string">&quot;database&quot;</span> <span class="string">&quot;nosql&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看集合的所有成员</span></span><br><span class="line"><span class="comment"># SMEMBERS key</span></span><br><span class="line">&gt; SMEMBERS tags:article:1</span><br><span class="line">1) <span class="string">&quot;redis&quot;</span></span><br><span class="line">2) <span class="string">&quot;nosql&quot;</span></span><br><span class="line">3) <span class="string">&quot;database&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断成员是否存在于集合中</span></span><br><span class="line"><span class="comment"># SISMEMBER key member</span></span><br><span class="line">&gt; SISMEMBER tags:article:1 <span class="string">&quot;redis&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; SISMEMBER tags:article:1 <span class="string">&quot;mysql&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取集合的成员数量</span></span><br><span class="line"><span class="comment"># SCARD key</span></span><br><span class="line">&gt; SCARD tags:article:1</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合运算</span></span><br><span class="line">&gt; SADD user:1:friends <span class="string">&quot;A&quot;</span> <span class="string">&quot;B&quot;</span> <span class="string">&quot;C&quot;</span> <span class="string">&quot;D&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">&gt; SADD user:2:friends <span class="string">&quot;C&quot;</span> <span class="string">&quot;D&quot;</span> <span class="string">&quot;E&quot;</span> <span class="string">&quot;F&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交集 (共同好友)</span></span><br><span class="line"><span class="comment"># SINTER key [key ...]</span></span><br><span class="line">&gt; SINTER user:1:friends user:2:friends</span><br><span class="line">1) <span class="string">&quot;C&quot;</span></span><br><span class="line">2) <span class="string">&quot;D&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并集 (所有好友)</span></span><br><span class="line"><span class="comment"># SUNION key [key ...]</span></span><br><span class="line">&gt; SUNION user:1:friends user:2:friends</span><br><span class="line">1) <span class="string">&quot;A&quot;</span></span><br><span class="line">2) <span class="string">&quot;B&quot;</span></span><br><span class="line">3) <span class="string">&quot;C&quot;</span></span><br><span class="line">4) <span class="string">&quot;D&quot;</span></span><br><span class="line">5) <span class="string">&quot;E&quot;</span></span><br><span class="line">6) <span class="string">&quot;F&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 差集 (user1 有但 user2 没有的好友)</span></span><br><span class="line"><span class="comment"># SDIFF key [key ...]</span></span><br><span class="line">&gt; SDIFF user:1:friends user:2:friends</span><br><span class="line">1) <span class="string">&quot;A&quot;</span></span><br><span class="line">2) <span class="string">&quot;B&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="Go-语言示例-3"><a href="#Go-语言示例-3" class="headerlink" title="Go 语言示例"></a>Go 语言示例</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打印一个分隔提示，表示接下来将演示 Redis 的 Set（集合）类型操作</span></span><br><span class="line">	<span class="comment">// Set 是 Redis 中一种无序、不重复的字符串元素集合，非常适合用于“关系”类数据的存储</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- Set Demo ---&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义两个键名，分别代表用户1和用户2的好友列表</span></span><br><span class="line">	<span class="comment">// 使用清晰的命名规则：user:&lt;ID&gt;:friends:&lt;tag&gt;，便于理解和维护</span></span><br><span class="line">	user1FriendsKey := <span class="string">&quot;user:1:friends:go&quot;</span></span><br><span class="line">	user2FriendsKey := <span class="string">&quot;user:2:friends:go&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- 清理旧数据：确保每次运行 demo 都在一个干净的环境中 ---</span></span><br><span class="line">	<span class="comment">// 使用 Del 删除之前可能存在的数据，避免历史数据干扰当前演示</span></span><br><span class="line">	<span class="comment">// 可以同时删除多个键</span></span><br><span class="line">	rdb.Del(ctx, user1FriendsKey, user2FriendsKey)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- SADD：Set Add，向集合中添加一个或多个成员 ---</span></span><br><span class="line">	<span class="comment">// 语法：SAdd(上下文, 键名, 成员1, 成员2, ...)</span></span><br><span class="line">	<span class="comment">// 特点：</span></span><br><span class="line">	<span class="comment">//   - 集合中**元素是唯一的**，重复添加同一个值只会保存一份</span></span><br><span class="line">	<span class="comment">//   - 元素**无序**，不保证插入顺序</span></span><br><span class="line">	<span class="comment">//  为用户1添加三位朋友：Alice、Bob、Charlie</span></span><br><span class="line">	rdb.SAdd(ctx, user1FriendsKey, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>)</span><br><span class="line">	<span class="comment">// 为用户2添加三位朋友：Charlie、David、Eve</span></span><br><span class="line">	rdb.SAdd(ctx, user2FriendsKey, <span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;Eve&quot;</span>)</span><br><span class="line">	<span class="comment">// 注意：Charlie 同时出现在两个用户的集合中</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- SMEMBERS：获取集合中的所有成员 ---</span></span><br><span class="line">	<span class="comment">// 语法：SMembers(上下文, 键名)</span></span><br><span class="line">	<span class="comment">// 返回集合中所有的元素（无序）</span></span><br><span class="line">	friends, err := rdb.SMembers(ctx, user1FriendsKey).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果出错（如连接失败），直接 panic 终止程序以便调试</span></span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印用户1的所有朋友</span></span><br><span class="line">	<span class="comment">// 输出可能是：[Alice Bob Charlie] 或任意顺序，因为 Set 是无序的</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;User 1 的朋友:&quot;</span>, friends)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- SISMEMBER：判断某个元素是否是集合的成员 ---</span></span><br><span class="line">	<span class="comment">// 语法：SIsMember(上下文, 键名, 元素)</span></span><br><span class="line">	<span class="comment">// 返回布尔值：true 表示存在，false 表示不存在</span></span><br><span class="line">	isFriend, err := rdb.SIsMember(ctx, user1FriendsKey, <span class="string">&quot;Bob&quot;</span>).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断 Bob 是否在用户1的朋友列表中</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Bob 是 User 1 的朋友吗?&quot;</span>, isFriend) <span class="comment">// 应该输出 true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- SINTER：Set Intersection，求多个集合的交集 ---</span></span><br><span class="line">	<span class="comment">// 语法：SInter(上下文, 键1, 键2, ...)</span></span><br><span class="line">	<span class="comment">// 返回同时存在于所有指定集合中的元素</span></span><br><span class="line">	<span class="comment">// 这里用于找出“用户1和用户2共同的朋友”</span></span><br><span class="line">	commonFriends, err := rdb.SInter(ctx, user1FriendsKey, user2FriendsKey).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 因为只有 &quot;Charlie&quot; 同时出现在两个集合中，所以交集就是 [&quot;Charlie&quot;]</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;共同的朋友:&quot;</span>, commonFriends)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- SUNION：Set Union，求多个集合的并集 ---</span></span><br><span class="line">	<span class="comment">// 语法：SUnion(上下文, 键1, 键2, ...)</span></span><br><span class="line">	<span class="comment">// 返回所有集合中的**去重合并结果**</span></span><br><span class="line">	<span class="comment">// 即：把两个集合的所有元素放在一起，并自动去除重复项</span></span><br><span class="line">	allFriends, err := rdb.SUnion(ctx, user1FriendsKey, user2FriendsKey).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 结果包含：Alice, Bob, Charlie, David, Eve（共5人，Charlie 不重复）</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;所有的朋友:&quot;</span>, allFriends)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-有序集合-Sorted-Set-ZSet"><a href="#5-有序集合-Sorted-Set-ZSet" class="headerlink" title="5. 有序集合 (Sorted Set &#x2F; ZSet)"></a>5. 有序集合 (Sorted Set &#x2F; ZSet)</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>Sorted Set 和 Set 类似，也是一个<strong>不允许重复</strong>的字符串集合。但不同的是，每个成员都会关联一个 <code>double</code> 类型的<strong>分数 (score)</strong>。Redis 正是根据这个分数来为集合中的成员进行排序。成员是唯一的，但分数可以重复。</p>
<h4 id="内部实现-4"><a href="#内部实现-4" class="headerlink" title="内部实现"></a>内部实现</h4><p>Sorted Set 底层由 <code>ziplist</code> 或 <code>skiplist</code> (跳跃表) + <code>hashtable</code> 实现。</p>
<ul>
<li>当元素数量少、成员值短时，使用 <code>ziplist</code> 节省内存。</li>
<li>否则，使用 <code>skiplist</code> 和 <code>hashtable</code> 的组合：<ul>
<li><strong>Skiplist</strong>：保证了元素的有序性，并能以 O(logN) 的时间复杂度进行查找和范围查询。</li>
<li><strong>Hashtable</strong>：存储成员到分数的映射，可以 O(1) 的时间复杂度获取指定成员的分数。<br>这种组合设计让 Sorted Set 在保持排序的同时，也拥有高效的单点查询能力。</li>
</ul>
</li>
</ul>
<h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><strong>排行榜</strong>：游戏积分榜、文章热度榜、销售额排行榜等。<code>score</code> 就是积分&#x2F;热度值。</li>
<li><strong>带权重的任务队列</strong>：<code>score</code> 可以作为任务的优先级或执行时间，分数越小（或越大）的任务优先被处理。</li>
<li><strong>延时队列</strong>：用 <code>score</code> 存储任务的执行时间戳，然后轮询第一个元素，看时间戳是否已到。</li>
<li><strong>范围查找</strong>：比如查找积分在 1000 到 2000 之间的所有玩家。</li>
</ul>
<h4 id="Redis-CLI-示例-4"><a href="#Redis-CLI-示例-4" class="headerlink" title="Redis CLI 示例"></a>Redis CLI 示例</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加一个或多个成员及其分数</span></span><br><span class="line"><span class="comment"># ZADD key score member [score member ...]</span></span><br><span class="line">&gt; ZADD leaderboard 100 <span class="string">&quot;player1&quot;</span> 250 <span class="string">&quot;player2&quot;</span> 80 <span class="string">&quot;player3&quot;</span> 300 <span class="string">&quot;player4&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加某个成员的分数</span></span><br><span class="line"><span class="comment"># ZINCRBY key increment member</span></span><br><span class="line">&gt; ZINCRBY leaderboard 50 <span class="string">&quot;player1&quot;</span></span><br><span class="line"><span class="string">&quot;150&quot;</span> <span class="comment"># 返回 player1 的新分数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按分数从低到高获取排名</span></span><br><span class="line"><span class="comment"># ZRANGE key start stop [WITHSCORES]</span></span><br><span class="line">&gt; ZRANGE leaderboard 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">&quot;player3&quot;</span></span><br><span class="line">2) <span class="string">&quot;80&quot;</span></span><br><span class="line">3) <span class="string">&quot;player1&quot;</span></span><br><span class="line">4) <span class="string">&quot;150&quot;</span></span><br><span class="line">5) <span class="string">&quot;player2&quot;</span></span><br><span class="line">6) <span class="string">&quot;250&quot;</span></span><br><span class="line">7) <span class="string">&quot;player4&quot;</span></span><br><span class="line">8) <span class="string">&quot;300&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按分数从高到低获取排名</span></span><br><span class="line"><span class="comment"># ZREVRANGE key start stop [WITHSCORES]</span></span><br><span class="line">&gt; ZREVRANGE leaderboard 0 2 WITHSCORES <span class="comment"># 获取前三名</span></span><br><span class="line">1) <span class="string">&quot;player4&quot;</span></span><br><span class="line">2) <span class="string">&quot;300&quot;</span></span><br><span class="line">3) <span class="string">&quot;player2&quot;</span></span><br><span class="line">4) <span class="string">&quot;250&quot;</span></span><br><span class="line">5) <span class="string">&quot;player1&quot;</span></span><br><span class="line">6) <span class="string">&quot;150&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定成员的分数</span></span><br><span class="line"><span class="comment"># ZSCORE key member</span></span><br><span class="line">&gt; ZSCORE leaderboard <span class="string">&quot;player2&quot;</span></span><br><span class="line"><span class="string">&quot;250&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定成员的排名 (从低到高, 排名从 0 开始)</span></span><br><span class="line"><span class="comment"># ZRANK key member</span></span><br><span class="line">&gt; ZRANK leaderboard <span class="string">&quot;player2&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>

<h4 id="Go-语言示例-4"><a href="#Go-语言示例-4" class="headerlink" title="Go 语言示例"></a>Go 语言示例</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedSetDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打印一个分隔提示，表示接下来将演示 Redis 的 Sorted Set（有序集合）类型操作</span></span><br><span class="line">	<span class="comment">// Sorted Set 是 Redis 中最强大的数据结构之一，特别适合用于“排行榜”类场景</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- Sorted Set Demo ---&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义一个键名，用于存储排行榜数据</span></span><br><span class="line">	<span class="comment">// leaderboard:go 表示“Go 示例中的排行榜”</span></span><br><span class="line">	leaderboardKey := <span class="string">&quot;leaderboard:go&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- 清理旧数据：确保每次运行 demo 都从干净状态开始 ---</span></span><br><span class="line">	<span class="comment">// 删除之前可能存在的同名键，避免历史数据干扰本次演示</span></span><br><span class="line">	rdb.Del(ctx, leaderboardKey)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- ZADD：Sorted Set Add，向有序集合中添加成员及其分数 ---</span></span><br><span class="line">	<span class="comment">// 语法：ZAdd(上下文, 键名, &amp;redis.Z&#123;Score: 分数, Member: 成员&#125;, ...)</span></span><br><span class="line">	<span class="comment">// 特点：</span></span><br><span class="line">	<span class="comment">//   - 每个成员（Member）都有一个对应的分数（Score）</span></span><br><span class="line">	<span class="comment">//   - 成员唯一（不能重复），但分数可以相同</span></span><br><span class="line">	<span class="comment">//   - 所有成员会根据分数**自动排序**（从小到大）</span></span><br><span class="line">	<span class="comment">// 这里添加三位玩家及其初始分数：</span></span><br><span class="line">	<span class="comment">//   player1: 100 分</span></span><br><span class="line">	<span class="comment">//   player2: 250 分</span></span><br><span class="line">	<span class="comment">//   player3: 80 分</span></span><br><span class="line">	rdb.ZAdd(ctx, leaderboardKey,</span><br><span class="line">		&amp;redis.Z&#123;Score: <span class="number">100</span>, Member: <span class="string">&quot;player1&quot;</span>&#125;,</span><br><span class="line">		&amp;redis.Z&#123;Score: <span class="number">250</span>, Member: <span class="string">&quot;player2&quot;</span>&#125;,</span><br><span class="line">		&amp;redis.Z&#123;Score: <span class="number">80</span>, Member: <span class="string">&quot;player3&quot;</span>&#125;,</span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// 提示信息：说明玩家已加入排行榜</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;添加玩家到排行榜&quot;</span>)</span><br><span class="line">	<span class="comment">// 此时按分数升序排列为：player3(80) → player1(100) → player2(250)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- ZINCRBY：对某个成员的分数进行增减（原子操作）---</span></span><br><span class="line">	<span class="comment">// 语法：ZIncrBy(上下文, 键名, 增量, 成员名)</span></span><br><span class="line">	<span class="comment">// 类似于 Hash 中的 HIncrBy，但用于 Sorted Set</span></span><br><span class="line">	<span class="comment">// 这里给 player1 加 50 分</span></span><br><span class="line">	newScore, err := rdb.ZIncrBy(ctx, leaderboardKey, <span class="number">50</span>, <span class="string">&quot;player1&quot;</span>).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 原来是 100 分，加 50 后变成 150 分</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;player1 增加 50 分后，新分数为:&quot;</span>, newScore)</span><br><span class="line">	<span class="comment">// 更新后排名变为：player3(80) → player1(150) → player2(250)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- ZREVRANGE WITHSCORES：从高到低获取指定范围的成员（带分数）---</span></span><br><span class="line">	<span class="comment">// 语法：ZRevRangeWithScores(上下文, 键名, 开始索引, 结束索引)</span></span><br><span class="line">	<span class="comment">// 注意：</span></span><br><span class="line">	<span class="comment">//   - ZRevRange 是“倒序”（从高分到低分）</span></span><br><span class="line">	<span class="comment">//   - WithScores 表示同时返回分数</span></span><br><span class="line">	<span class="comment">//   - 索引从 0 开始</span></span><br><span class="line">	<span class="comment">// 这里获取 Top 3 玩家（最高分的前3名）</span></span><br><span class="line">	topPlayers, err := rdb.ZRevRangeWithScores(ctx, leaderboardKey, <span class="number">0</span>, <span class="number">2</span>).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印排行榜前3名</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;排行榜 Top 3:&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> _, player := <span class="keyword">range</span> topPlayers &#123;</span><br><span class="line">		<span class="comment">// player.Member 是玩家名称（string 类型）</span></span><br><span class="line">		<span class="comment">// player.Score 是分数（float64 类型），使用 %.0f 不显示小数</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;  - 玩家: %s, 分数: %.0f\n&quot;</span>, player.Member, player.Score)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 输出示例：</span></span><br><span class="line">	<span class="comment">//   - 玩家: player2, 分数: 250</span></span><br><span class="line">	<span class="comment">//   - 玩家: player1, 分数: 150</span></span><br><span class="line">	<span class="comment">//   - 玩家: player3, 分数: 80</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- ZRANK：获取成员在有序集合中的排名（从小到大）---</span></span><br><span class="line">	<span class="comment">// 语法：ZRank(上下文, 键名, 成员名)</span></span><br><span class="line">	<span class="comment">// 返回值是从 0 开始的索引：</span></span><br><span class="line">	<span class="comment">//   分数最低的排第 0 名，第二低的排第 1 名，依此类推</span></span><br><span class="line">	<span class="comment">// 所以 ZRank 是“升序排名”</span></span><br><span class="line">	rank, err := rdb.ZRank(ctx, leaderboardKey, <span class="string">&quot;player2&quot;</span>).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果成员不存在，Redis 返回 redis.Nil 错误</span></span><br><span class="line">		<span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;player2 不在排行榜中&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 其他错误（如网络问题）则 panic</span></span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 成功获取排名</span></span><br><span class="line">		<span class="comment">// 当前 player2 分数最高，所以 ZRank 返回 2（他是第3个，索引从0开始）</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;player2 的排名 (从0开始) 是: %d\n&quot;</span>, rank)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注意：如果想从 1 开始显示排名，可以写成 rank + 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是 Redis 五种核心数据类型的详细介绍和示例。理解每种数据类型的特点和适用场景，是高效使用 Redis 的关键。在实际应用中，往往需要组合使用这些数据类型来解决复杂问题。</p>
<h1 id="Go-与-Redis-集成-1"><a href="#Go-与-Redis-集成-1" class="headerlink" title="Go 与 Redis 集成"></a><strong>Go 与 Redis 集成</strong></h1><h2 id="1-准备-Go-环境"><a href="#1-准备-Go-环境" class="headerlink" title="1. 准备 Go 环境"></a><strong>1. 准备 Go 环境</strong></h2><p>在开始之前，你需要选择一个 Go 语言的 Redis 客户端库。目前社区中最主流的有以下两个：</p>
<ol>
<li><strong><code>go-redis/redis</code></strong>: 这是一个功能非常全面、性能优秀且API设计现代化的库。它内置了连接池管理，并与 Go 的 <code>context</code> 机制深度集成，是目前新项目的首选。<strong>（本笔记将使用此库进行教学）</strong></li>
<li><code>gomodule/redigo</code>: 这是一个更老牌、更轻量级的库，API 风格更接近原始的 Redis 命令。虽然依然稳定可靠，但对于新手而言，<code>go-redis</code> 的封装更友好。</li>
</ol>
<p><strong>安装 <code>go-redis</code> 库</strong></p>
<p>首先，确保你的 Go 环境已经搭建好。然后，在你的项目目录下，打开终端并执行以下命令来安装 <code>go-redis</code> 的最新版本（v9）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/go-redis/redis/v9</span><br></pre></td></tr></table></figure>

<h2 id="2-连接-Redis"><a href="#2-连接-Redis" class="headerlink" title="2. 连接 Redis"></a><strong>2. 连接 Redis</strong></h2><p>使用 <code>go-redis</code> 连接 Redis 非常简单。你只需要创建一个 <code>redis.Client</code> 实例，并提供 Redis 服务器的连接信息即可。</p>
<ul>
<li><p><strong>连接选项 (<code>redis.Options</code>)</strong>:</p>
<ul>
<li><code>Addr</code>: Redis 服务器的地址，格式为 <code>&quot;host:port&quot;</code>。例如 <code>&quot;localhost:6379&quot;</code>。</li>
<li><code>Password</code>: Redis 的密码，如果没有设置则留空。</li>
<li><code>DB</code>: 要连接的数据库编号，默认为 <code>0</code>。Redis 支持 0-15 共 16 个数据库。</li>
</ul>
</li>
<li><p><strong>连接池 (Connection Pool)</strong>:<br>你不需要手动管理连接池！<code>go-redis</code> 客户端在内部已经实现并维护了一个高效的连接池。每次你执行命令时，它会自动从池中获取一个连接，使用完毕后会放回池中，这大大提升了高并发场景下的性能。</p>
</li>
</ul>
<p><strong>示例代码：连接并测试</strong></p>
<p>让我们创建一个简单的 Go 程序来连接本地 Redis 服务并测试连通性。</p>
<p><code>main.go</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-redis/redis/v9&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局的 redis.Client 变量</span></span><br><span class="line"><span class="keyword">var</span> rdb *redis.Client</span><br><span class="line"></span><br><span class="line"><span class="comment">// initClient 函数用于初始化 Redis 连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initClient</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 创建一个新的 Redis 客户端</span></span><br><span class="line">	rdb = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr:     <span class="string">&quot;localhost:6379&quot;</span>, <span class="comment">// Redis 服务器地址</span></span><br><span class="line">		Password: <span class="string">&quot;&quot;</span>,               <span class="comment">// Redis 密码，没有则留空</span></span><br><span class="line">		DB:       <span class="number">0</span>,                <span class="comment">// 使用默认的 DB 0</span></span><br><span class="line">		PoolSize: <span class="number">10</span>,               <span class="comment">// 连接池大小</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// context.Background() 返回一个空的 Context，它永远不会被取消，没有值，也没有截止日期。</span></span><br><span class="line">	<span class="comment">// 它通常由 main 函数、初始化和测试使用，并作为传入请求的顶级 Context。</span></span><br><span class="line">	ctx := context.Background()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 Ping 命令测试连接</span></span><br><span class="line">	_, err = rdb.Ping(ctx).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := initClient()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;连接 Redis 失败, error: %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;成功连接到 Redis！&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在这里可以开始执行 Redis 操作...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解析</strong>：</p>
<ol>
<li>我们导入了 <code>context</code> 和 <code>github.com/go-redis/redis/v9</code> 包。</li>
<li><code>redis.NewClient</code> 接收一个 <code>redis.Options</code> 结构体指针，用于配置连接参数。</li>
<li>我们使用 <code>rdb.Ping(ctx).Result()</code> 来发送 <code>PING</code> 命令。<code>go-redis</code> 的所有命令都遵循 <code>Command(ctx, args...).Result()</code> 的模式。<code>.Result()</code> 会等待命令执行完成，并返回最终结果和错误。</li>
</ol>
<hr>
<h2 id="3-在-Go-中操作-Redis-核心数据类型"><a href="#3-在-Go-中操作-Redis-核心数据类型" class="headerlink" title="3. 在 Go 中操作 Redis 核心数据类型"></a><strong>3. 在 Go 中操作 Redis 核心数据类型</strong></h2><p>现在，我们将把第一部分用 <code>redis-cli</code> 执行的命令，全部用 Go 代码重新实现一遍。</p>
<p><strong>重要提示</strong>：<code>go-redis</code> 的每一个操作都需要一个 <code>context.Context</code> 参数。在接下来的示例中，我们为了简化，将一直使用 <code>context.Background()</code>。在后面的小节会专门讲解 <code>context</code> 的重要性。</p>
<h3 id="3-1-String-操作"><a href="#3-1-String-操作" class="headerlink" title="3.1 String 操作"></a><strong>3.1 String 操作</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringOperations</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;--- String 操作 ---&quot;</span>)</span><br><span class="line">	<span class="comment">// Set(ctx, key, value, expiration)</span></span><br><span class="line">	<span class="comment">// expiration 参数为 0 表示没有过期时间</span></span><br><span class="line">	err := rdb.Set(ctx, <span class="string">&quot;user:1:name&quot;</span>, <span class="string">&quot;Chris&quot;</span>, <span class="number">0</span>).Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get(ctx, key)</span></span><br><span class="line">	val, err := rdb.Get(ctx, <span class="string">&quot;user:1:name&quot;</span>).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;获取 user:1:name:&quot;</span>, val)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当 Get 的 key 不存在时，会返回 redis.Nil 错误</span></span><br><span class="line">	val2, err := rdb.Get(ctx, <span class="string">&quot;non_existent_key&quot;</span>).Result()</span><br><span class="line">	<span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;non_existent_key 不存在&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;non_existent_key:&quot;</span>, val2)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// SetEX 设置一个带过期时间的键</span></span><br><span class="line">    err = rdb.Set(ctx, <span class="string">&quot;session_token&quot;</span>, <span class="string">&quot;some-random-string&quot;</span>, <span class="number">10</span> * time.Second).Err()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 main 函数中调用</span></span><br><span class="line"><span class="comment">// stringOperations(context.Background())</span></span><br></pre></td></tr></table></figure>

<p><strong>要点</strong>：错误处理。当一个键不存在时，<code>Get</code> 操作会返回一个特殊的错误 <code>redis.Nil</code>。你需要显式地检查这个错误，而不是把它当作一个普通错误来处理。</p>
<h3 id="3-2-List-操作"><a href="#3-2-List-操作" class="headerlink" title="3.2 List 操作"></a><strong>3.2 List 操作</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listOperations</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- List 操作 ---&quot;</span>)</span><br><span class="line">	<span class="comment">// 先清理一下，防止重复运行导致列表过长</span></span><br><span class="line">	rdb.Del(ctx, <span class="string">&quot;tasks&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LPUSH 从左侧推入</span></span><br><span class="line">	rdb.LPush(ctx, <span class="string">&quot;tasks&quot;</span>, <span class="string">&quot;Task A&quot;</span>, <span class="string">&quot;Task B&quot;</span>)</span><br><span class="line">	<span class="comment">// RPUSH 从右侧推入</span></span><br><span class="line">	rdb.RPush(ctx, <span class="string">&quot;tasks&quot;</span>, <span class="string">&quot;Task C&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LRange 获取列表所有元素</span></span><br><span class="line">	tasks, err := rdb.LRange(ctx, <span class="string">&quot;tasks&quot;</span>, <span class="number">0</span>, <span class="number">-1</span>).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;当前任务列表:&quot;</span>, tasks) <span class="comment">// 输出: [Task B, Task A, Task C]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LPop 从左侧弹出一个元素</span></span><br><span class="line">	task, err := rdb.LPop(ctx, <span class="string">&quot;tasks&quot;</span>).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;处理任务:&quot;</span>, task) <span class="comment">// 输出: Task B</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 main 函数中调用</span></span><br><span class="line"><span class="comment">// listOperations(context.Background())</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-Hash-操作"><a href="#3-3-Hash-操作" class="headerlink" title="3.3 Hash 操作"></a><strong>3.3 Hash 操作</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashOperations</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- Hash 操作 ---&quot;</span>)</span><br><span class="line">	userKey := <span class="string">&quot;user:2&quot;</span></span><br><span class="line">	rdb.Del(ctx, userKey) <span class="comment">// 清理</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// HSet 设置哈希字段，可以使用 map[string]interface&#123;&#125;</span></span><br><span class="line">	fields := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;dave&quot;</span>, <span class="string">&quot;email&quot;</span>: <span class="string">&quot;dave@example.com&quot;</span>&#125;</span><br><span class="line">	err := rdb.HSet(ctx, userKey, fields).Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	rdb.HSet(ctx, userKey, <span class="string">&quot;age&quot;</span>, <span class="number">35</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// HGetAll 获取所有字段和值</span></span><br><span class="line">	allFields, err := rdb.HGetAll(ctx, userKey).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;用户 User:2 的信息:&quot;</span>, allFields) <span class="comment">// 输出 map[age:35 email:dave@example.com username:dave]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 main 函数中调用</span></span><br><span class="line"><span class="comment">// hashOperations(context.Background())</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-Set-操作"><a href="#3-4-Set-操作" class="headerlink" title="3.4 Set 操作"></a><strong>3.4 Set 操作</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setOperations</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- Set 操作 ---&quot;</span>)</span><br><span class="line">	post1Tags := <span class="string">&quot;tags:post:1&quot;</span></span><br><span class="line">	post2Tags := <span class="string">&quot;tags:post:2&quot;</span></span><br><span class="line">	rdb.Del(ctx, post1Tags, post2Tags) <span class="comment">// 清理</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// SAdd 添加集合成员</span></span><br><span class="line">	rdb.SAdd(ctx, post1Tags, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;go&quot;</span>, <span class="string">&quot;database&quot;</span>)</span><br><span class="line">	rdb.SAdd(ctx, post2Tags, <span class="string">&quot;go&quot;</span>, <span class="string">&quot;docker&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// SMembers 获取所有成员</span></span><br><span class="line">	members, err := rdb.SMembers(ctx, post1Tags).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;文章1的标签:&quot;</span>, members)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// SInter 计算交集</span></span><br><span class="line">	commonTags, err := rdb.SInter(ctx, post1Tags, post2Tags).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;文章1和文章2的共同标签:&quot;</span>, commonTags) <span class="comment">// 输出: [go]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 main 函数中调用</span></span><br><span class="line"><span class="comment">// setOperations(context.Background())</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-Sorted-Set-ZSET-操作"><a href="#3-5-Sorted-Set-ZSET-操作" class="headerlink" title="3.5 Sorted Set (ZSET) 操作"></a><strong>3.5 Sorted Set (ZSET) 操作</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zsetOperations</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- Sorted Set 操作 ---&quot;</span>)</span><br><span class="line">	leaderboardKey := <span class="string">&quot;leaderboard&quot;</span></span><br><span class="line">	rdb.Del(ctx, leaderboardKey) <span class="comment">// 清理</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ZAdd 添加成员和分数，需要使用 redis.Z 结构体</span></span><br><span class="line">	members := []redis.Z&#123;</span><br><span class="line">		&#123;Score: <span class="number">2500</span>, Member: <span class="string">&quot;Alice&quot;</span>&#125;,</span><br><span class="line">		&#123;Score: <span class="number">3100</span>, Member: <span class="string">&quot;Bob&quot;</span>&#125;,</span><br><span class="line">		&#123;Score: <span class="number">1800</span>, Member: <span class="string">&quot;Charlie&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	rdb.ZAdd(ctx, leaderboardKey, members...)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ZRevRange 按分数从高到低获取 Top 2</span></span><br><span class="line">	topPlayers, err := rdb.ZRevRangeWithScores(ctx, leaderboardKey, <span class="number">0</span>, <span class="number">1</span>).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;排行榜 Top 2:&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> _, player := <span class="keyword">range</span> topPlayers &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;  玩家: %s, 分数: %.0f\n&quot;</span>, player.Member, player.Score)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 main 函数中调用</span></span><br><span class="line"><span class="comment">// zsetOperations(context.Background())</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-上下文管理-context-Context"><a href="#4-上下文管理-context-Context" class="headerlink" title="4. 上下文管理 (context.Context)"></a><strong>4. 上下文管理 (<code>context.Context</code>)</strong></h2><p>你可能已经注意到，<code>go-redis/v9</code> 的每个命令都需要一个 <code>context.Context</code> 作为第一个参数。这不是一个繁琐的设计，而是 Go 语言中处理请求、超时和取消操作的最佳实践。</p>
<ul>
<li><p><strong>为什么需要 <code>context</code>？</strong><br>在一个网络应用中，一个操作（比如一次 Redis 查询）不应该无限期地等待下去。如果 Redis 服务器因为高负载而响应缓慢，或者网络出现问题，我们不希望整个应用程序被这个慢查询拖垮。<code>context</code> 提供了一种机制，可以为操作设定一个“截止日期”（Timeout）或一个“取消信号”。</p>
</li>
<li><p><strong>使用 <code>context</code> 控制超时</strong><br>假设我们希望一个 Redis 查询最多只能执行 50 毫秒，否则就立即放弃并返回一个超时错误。我们可以这样做：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">contextExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;\n--- Context 超时示例 ---&quot;</span>)</span><br><span class="line">    <span class="comment">// 创建一个有 50 毫秒超时的 context</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">50</span>*time.Millisecond)</span><br><span class="line">    <span class="comment">// defer cancel() 是一个好习惯，用于在函数退出时释放 context 相关的资源</span></span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设这是一个执行很慢的命令，例如在一个巨大的集合中查找</span></span><br><span class="line">    <span class="comment">// 为了模拟，我们这里还是用 Get，但关键是看超时的效果</span></span><br><span class="line">    _, err := rdb.Get(ctx, <span class="string">&quot;some_key&quot;</span>).Result()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查返回的错误是否是 context 的超时错误</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 在 Go 1.20+ 中，可以使用 errors.Is</span></span><br><span class="line">        <span class="keyword">if</span> errors.Is(err, context.DeadlineExceeded) &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Redis 操作超时了！&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他错误，比如 redis.Nil</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;发生错误: %v\n&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>总结</strong>：<code>context</code> 是构建健壮、高可用的 Go 应用程序的基石。在每次调用 Redis 命令时，都应该传递一个合适的 <code>context</code>。对于一个 Web 请求，你应该把请求自带的 <code>context</code> (<code>r.Context()</code>) 一路传递下来；对于后台任务，可以创建一个带超时的 <code>context</code></p>
<p>好的，我们进入第三部分。这部分内容将带你了解 Redis 更强大、更专业的特性，并学习如何在 Go 中利用这些特性来构建更复杂的应用。</p>
<hr>
<h1 id="Redis-进阶主题与-Go-实战-1"><a href="#Redis-进阶主题与-Go-实战-1" class="headerlink" title="Redis 进阶主题与 Go 实战"></a><strong>Redis 进阶主题与 Go 实战</strong></h1><h2 id="1-事务-Transactions"><a href="#1-事务-Transactions" class="headerlink" title="1. 事务 (Transactions)"></a><strong>1. 事务 (Transactions)</strong></h2><p>在很多场景下，我们需要一次性执行多个命令，并希望这个操作序列是<strong>原子性</strong>的，即要么全部成功，要么全部失败。</p>
<ul>
<li><p><strong>Redis 事务命令</strong>:</p>
<ul>
<li><code>MULTI</code>: 开启一个事务块，此后的命令都会进入一个队列，而不会立即执行。</li>
<li><code>EXEC</code>: 原子性地执行队列中的所有命令。</li>
<li><code>DISCARD</code>: 清空事务队列，放弃事务。</li>
<li><code>WATCH key [key ...]</code>: 监视一个或多个 key。如果在 <code>MULTI</code> 执行之前，任何被 <code>WATCH</code> 的 key 被其他客户端修改了，那么整个事务将被取消，<code>EXEC</code> 会返回一个空回复。这提供了一种<strong>乐观锁 (Optimistic Locking)</strong> 的机制。</li>
</ul>
</li>
<li><p><strong><code>go-redis</code> 中的实现：<code>Pipeline</code> 和 <code>TxPipeline</code></strong><br><code>go-redis</code> 提供了两种方式来批量执行命令：</p>
<ol>
<li><strong><code>Pipeline</code></strong>: 将多个命令打包一次性发送给 Redis，用于减少网络往返时延 (RTT)。<strong>它不保证原子性</strong>，只是一个性能优化手段。</li>
<li><strong><code>TxPipeline</code> (Transactional Pipeline)</strong>: 这才是真正的事务实现。它会自动在命令序列前后加上 <code>MULTI</code> 和 <code>EXEC</code>，从而保证原子性。</li>
</ol>
</li>
</ul>
<p><strong>Go 实战：使用 <code>WATCH</code> 和 <code>TxPipeline</code> 实现乐观锁</strong></p>
<p>一个经典的场景：在高并发下更新一个计数器。我们希望读取当前值，加 1，然后写回。这个过程必须是原子的，否则可能导致数据丢失。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-redis/redis/v9&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (省略 initClient 和 rdb 变量定义) ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// optimisticIncrement 函数安全地增加一个 key 的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">optimisticIncrement</span><span class="params">(ctx context.Context, key <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// TxFn 是一个事务函数，go-redis 会在 WATCH 和 MULTI/EXEC 块中执行它</span></span><br><span class="line">	txf := <span class="function"><span class="keyword">func</span><span class="params">(tx *redis.Tx)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="comment">// 1. 在事务中获取当前值</span></span><br><span class="line">		currentVal, err := tx.Get(ctx, key).Int()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != redis.Nil &#123;</span><br><span class="line">			<span class="keyword">return</span> err <span class="comment">// 如果是 redis.Nil 以外的错误，则返回</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 计算新值</span></span><br><span class="line">		newValue := currentVal + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3. 使用 tx.Pipelined 执行 SET 命令</span></span><br><span class="line">		<span class="comment">// Pipelined 在事务中是必需的，它会将命令放入队列</span></span><br><span class="line">		_, err = tx.Pipelined(ctx, <span class="function"><span class="keyword">func</span><span class="params">(pipe redis.Pipeliner)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			pipe.Set(ctx, key, newValue, <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// rdb.Watch 会自动处理重试逻辑</span></span><br><span class="line">	<span class="comment">// 如果在 txf 执行期间，被 WATCH 的 key (&quot;counter&quot;) 发生变化，</span></span><br><span class="line">	<span class="comment">// 整个 txf 函数会从头开始重试，直到成功为止。</span></span><br><span class="line">	err := rdb.Watch(ctx, txf, key)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transactionExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- 事务与乐观锁示例 ---&quot;</span>)</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	counterKey := <span class="string">&quot;counter&quot;</span></span><br><span class="line">	rdb.Set(ctx, counterKey, <span class="string">&quot;0&quot;</span>, <span class="number">0</span>) <span class="comment">// 初始化计数器</span></span><br><span class="line"></span><br><span class="line">	err := optimisticIncrement(ctx, counterKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;增加计数器失败: %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		finalValue, _ := rdb.Get(ctx, counterKey).Result()</span><br><span class="line">		fmt.Printf(<span class="string">&quot;成功增加计数器，当前值为: %s\n&quot;</span>, finalValue)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解析</strong>:</p>
<ol>
<li><code>rdb.Watch</code> 是 <code>go-redis</code> 对乐观锁事务的高级封装。它接收一个要监视的 <code>key</code> 和一个事务函数 <code>txf</code>。</li>
<li><code>go-redis</code> 会自动执行 <code>WATCH key</code> 命令。</li>
<li>然后它会执行你传入的 <code>txf</code> 函数。在 <code>txf</code> 内部，你通过 <code>tx</code> 对象（一个 <code>redis.Tx</code> 实例）来读取和写入数据。</li>
<li><code>tx.Pipelined</code> 用于将写命令（如 <code>SET</code>）放入事务队列。</li>
<li><code>go-redis</code> 会自动执行 <code>EXEC</code>。如果因为 <code>key</code> 被其他客户端修改而导致 <code>EXEC</code> 失败，<code>rdb.Watch</code> 会自动<strong>重试</strong>整个 <code>txf</code> 函数，直到事务成功执行。</li>
</ol>
<hr>
<h2 id="2-发布-订阅-Pub-Sub"><a href="#2-发布-订阅-Pub-Sub" class="headerlink" title="2. 发布&#x2F;订阅 (Pub&#x2F;Sub)"></a><strong>2. 发布&#x2F;订阅 (Pub&#x2F;Sub)</strong></h2><p>Pub&#x2F;Sub 是一种消息通信模式，发送者（发布者, Publisher）将消息发送到特定的“频道 (Channel)”，而不关心谁会接收。接收者（订阅者, Subscriber）可以订阅一个或多个频道，并接收发送到这些频道的消息。</p>
<ul>
<li><strong>用途</strong>: 实时聊天系统、消息通知、服务间解耦。</li>
</ul>
<p><strong>Go 实战：实现一个简单的实时通知系统</strong></p>
<p>我们将创建两个 Go 程序：一个作为订阅者，持续监听；另一个作为发布者，发送消息。</p>
<p><strong>订阅者 (<code>subscriber.go</code>)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subscriber</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;订阅者已启动，正在监听 &#x27;my-channel&#x27;...&quot;</span>)</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Subscribe 返回一个 *PubSub 对象</span></span><br><span class="line">	pubsub := rdb.Subscribe(ctx, <span class="string">&quot;my-channel&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// defer pubsub.Close() 是一个好习惯</span></span><br><span class="line">	<span class="keyword">defer</span> pubsub.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Receive 从频道接收消息。这是一个阻塞操作。</span></span><br><span class="line">	<span class="comment">// 通常在一个新的 goroutine 中运行。</span></span><br><span class="line">	<span class="keyword">for</span> msg := <span class="keyword">range</span> pubsub.Channel() &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;从频道 [%s] 收到消息: %s\n&quot;</span>, msg.Channel, msg.Payload)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发布者 (<code>publisher.go</code>)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">publisher</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 等待几秒钟，确保订阅者已经准备好</span></span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;发布者开始发送消息...&quot;</span>)</span><br><span class="line">	err := rdb.Publish(ctx, <span class="string">&quot;my-channel&quot;</span>, <span class="string">&quot;Hello, this is a message from publisher!&quot;</span>).Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"></span><br><span class="line">	err = rdb.Publish(ctx, <span class="string">&quot;my-channel&quot;</span>, <span class="string">&quot;This is the second message.&quot;</span>).Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何运行</strong>：</p>
<ol>
<li>在一个终端中运行订阅者程序。</li>
<li>在另一个终端中运行发布者程序。</li>
<li>你将看到订阅者的终端打印出从发布者收到的消息。</li>
</ol>
<hr>
<h2 id="3-持久化-Persistence"><a href="#3-持久化-Persistence" class="headerlink" title="3. 持久化 (Persistence)"></a><strong>3. 持久化 (Persistence)</strong></h2><p>持久化是指将内存中的数据写入到磁盘，防止因进程退出或服务器宕机导致数据丢失。Redis 提供了两种主要的持久化方式：</p>
<ol>
<li><p><strong>RDB (Redis Database) 快照</strong></p>
<ul>
<li><strong>工作原理</strong>: 在指定的时间间隔内，将内存中的数据集快照写入一个名为 <code>dump.rdb</code> 的二进制文件中。你可以配置如 <code>save 900 1</code> (900秒内有1次写入)、<code>save 300 10</code> 等规则。</li>
<li><strong>优点</strong>:<ul>
<li>生成的文件是紧凑的二进制文件，非常适合备份。</li>
<li>恢复大数据集时，速度比 AOF 快。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li>由于是间隔性保存，如果 Redis 在两次快照之间宕机，会丢失最后一次快照后的所有数据。</li>
<li><code>fork()</code> 子进程进行保存时，如果数据集巨大，可能会导致服务器短暂停止服务几毫秒或更久。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>AOF (Append Only File) 只追加文件</strong></p>
<ul>
<li><strong>工作原理</strong>: 以日志的形式，记录下每一个<strong>写</strong>操作命令。当 Redis 重启时，会重新执行 AOF 文件中的所有命令来恢复数据集。</li>
<li><strong>优点</strong>:<ul>
<li>数据持久性更高。可以配置为每秒同步 (<code>everysec</code>)，最多只会丢失 1 秒的数据。</li>
<li>AOF 文件是一个只追加的日志文件，即使出现写入不完整的情况，也可以用 <code>redis-check-aof</code> 工具轻松修复。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li>对于相同的数据集，AOF 文件通常比 RDB 文件大。</li>
<li>数据恢复速度通常慢于 RDB。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>如何选择？</strong></p>
<ul>
<li><strong>如果只追求高性能，可以接受分钟级别的数据丢失</strong>：单独使用 RDB。</li>
<li><strong>如果追求数据安全，不希望丢失任何数据</strong>：单独使用 AOF (配置为 <code>always</code> 同步，但会影响性能)。</li>
<li><strong>官方推荐，也是最安全的做法</strong>：<strong>同时开启 RDB 和 AOF</strong>。在这种情况下，当 Redis 重启时，会优先使用 AOF 文件来恢复数据，因为它能保证数据的完整性最高。而 RDB 文件则可以用于做更方便的冷备份。</li>
</ul>
<p>在 Go 代码层面，你不需要直接操作持久化，这是 Redis 服务器的配置 (<code>redis.conf</code>) 和运维工作。</p>
<hr>
<h2 id="4-Lua-脚本"><a href="#4-Lua-脚本" class="headerlink" title="4. Lua 脚本"></a><strong>4. Lua 脚本</strong></h2><p>当某些操作需要原子性，但 Redis 没有提供现成的命令时（比如“判断库存并扣减”），Lua 脚本就派上了用场。</p>
<ul>
<li><strong>为什么需要 Lua 脚本？</strong><ol>
<li><strong>原子性</strong>: Redis 会将整个 Lua 脚本作为一个原子操作执行，中间不会被其他命令插入。</li>
<li><strong>减少网络开销</strong>: 将多个命令组合在一个脚本中，只需一次网络请求，而不是多次。</li>
<li><strong>复用性</strong>: 脚本可以被缓存，通过 <code>EVALSHA</code> 命令使用 SHA1 校验和来调用，避免了重复传输脚本内容。</li>
</ol>
</li>
</ul>
<p><strong>Go 实战：使用 Lua 脚本实现安全的库存扣减</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">luaScriptExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- Lua 脚本示例 ---&quot;</span>)</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	stockKey := <span class="string">&quot;product:1:stock&quot;</span></span><br><span class="line">	rdb.Set(ctx, stockKey, <span class="number">10</span>, <span class="number">0</span>) <span class="comment">// 初始化库存为 10</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lua 脚本：</span></span><br><span class="line">	<span class="comment">// KEYS[1]: 库存的 key</span></span><br><span class="line">	<span class="comment">// ARGV[1]: 本次要扣减的数量</span></span><br><span class="line">	<span class="comment">// 如果当前库存 &gt;= 扣减数量，则执行扣减并返回 1；否则，什么都不做，返回 0。</span></span><br><span class="line">	luaScript := <span class="string">`</span></span><br><span class="line"><span class="string">        local current_stock = tonumber(redis.call(&#x27;GET&#x27;, KEYS[1]))</span></span><br><span class="line"><span class="string">        local purchase_quantity = tonumber(ARGV[1])</span></span><br><span class="line"><span class="string">        if current_stock &gt;= purchase_quantity then</span></span><br><span class="line"><span class="string">            redis.call(&#x27;DECRBY&#x27;, KEYS[1], purchase_quantity)</span></span><br><span class="line"><span class="string">            return 1</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建一个 redis.Script 实例</span></span><br><span class="line">	script := redis.NewScript(luaScript)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一次尝试购买 3 个，应该成功</span></span><br><span class="line">	result, err := script.Run(ctx, rdb, []<span class="type">string</span>&#123;stockKey&#125;, <span class="number">3</span>).Int()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;购买 3 个，结果: %d (1=成功, 0=失败)\n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二次尝试购买 10 个，应该失败</span></span><br><span class="line">	result, err = script.Run(ctx, rdb, []<span class="type">string</span>&#123;stockKey&#125;, <span class="number">10</span>).Int()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;购买 10 个，结果: %d (1=成功, 0=失败)\n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line">	finalStock, _ := rdb.Get(ctx, stockKey).Result()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;最终库存: %s\n&quot;</span>, finalStock) <span class="comment">// 应该是 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解析</strong>:</p>
<ol>
<li>我们定义了一个 Lua 脚本字符串。<code>KEYS[1]</code> 对应传入的第一个 key，<code>ARGV[1]</code> 对应第一个参数。</li>
<li><code>redis.NewScript</code> 创建一个脚本对象。</li>
<li><code>script.Run</code> 负责执行脚本。它会智能地先尝试用 <code>EVALSHA</code>，如果服务器没有缓存该脚本，它会自动使用 <code>EVAL</code> 发送脚本内容，并将其缓存起来。</li>
</ol>
<hr>
<h2 id="5-Redis-Streams-流"><a href="#5-Redis-Streams-流" class="headerlink" title="5. Redis Streams (流)"></a><strong>5. Redis Streams (流)</strong></h2><p>Redis Streams 是 Redis 5.0 引入的全新数据类型，它是一个功能强大的、支持持久化的消息队列。它借鉴了 Kafka 的设计思想，特别是<strong>消费者组 (Consumer Group)</strong> 的概念。</p>
<ul>
<li><strong>相比于 List 实现的消息队列，Streams 的优势</strong>:<ul>
<li><strong>支持消费者组</strong>: 允许多个消费者共同消费同一个流，每个消息只会被组内的一个消费者处理，非常适合横向扩展。</li>
<li><strong>消息持久化</strong>: 消息是持久的，除非显式删除。</li>
<li><strong>消息 ID 和有序性</strong>: 每个消息都有一个唯一的、按时间排序的 ID。</li>
<li><strong>支持阻塞读取</strong>: 和 <code>BLPOP</code> 类似，但功能更强大。</li>
</ul>
</li>
</ul>
<p><strong>Go 实战：使用 Streams 实现一个简单的消息队列</strong></p>
<p><strong>生产者 (<code>producer_stream.go</code>)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">streamProducer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Stream 生产者启动...&quot;</span>)</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	streamKey := <span class="string">&quot;mystream&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// XAdd 命令用于向流中添加消息</span></span><br><span class="line">	<span class="comment">// * 表示让 Redis 自动生成消息 ID</span></span><br><span class="line">	<span class="comment">// &quot;name&quot;, &quot;alice&quot;, &quot;age&quot;, &quot;25&quot; 是消息的键值对内容</span></span><br><span class="line">	err := rdb.XAdd(ctx, &amp;redis.XAddArgs&#123;</span><br><span class="line">		Stream: streamKey,</span><br><span class="line">		Values: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="string">&quot;25&quot;</span>&#125;,</span><br><span class="line">	&#125;).Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = rdb.XAdd(ctx, &amp;redis.XAddArgs&#123;</span><br><span class="line">		Stream: streamKey,</span><br><span class="line">		Values: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="string">&quot;30&quot;</span>&#125;,</span><br><span class="line">	&#125;).Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;已向 &#x27;mystream&#x27; 发送两条消息&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者 (<code>consumer_stream.go</code>)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">streamConsumer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Stream 消费者启动...&quot;</span>)</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	streamKey := <span class="string">&quot;mystream&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// XRead 命令用于从一个或多个流中读取消息</span></span><br><span class="line">	<span class="comment">// &quot;0&quot; 表示从头开始读取所有消息</span></span><br><span class="line">	<span class="comment">// Count: 10 表示一次最多读取 10 条</span></span><br><span class="line">	<span class="comment">// Block: 0 表示无限期阻塞等待新消息</span></span><br><span class="line">	streams, err := rdb.XRead(ctx, &amp;redis.XReadArgs&#123;</span><br><span class="line">		Streams: []<span class="type">string</span>&#123;streamKey, <span class="string">&quot;0&quot;</span>&#125;,</span><br><span class="line">		Count:   <span class="number">10</span>,</span><br><span class="line">		Block:   <span class="number">0</span>,</span><br><span class="line">	&#125;).Result()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != redis.Nil &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, stream := <span class="keyword">range</span> streams &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;从流 [%s] 中读取到 %d 条消息:\n&quot;</span>, stream.Stream, <span class="built_in">len</span>(stream.Messages))</span><br><span class="line">		<span class="keyword">for</span> _, msg := <span class="keyword">range</span> stream.Messages &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;  ID: %s, 内容: %v\n&quot;</span>, msg.ID, msg.Values)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：<br>这是一个最简单的消费者模型。在实际应用中，你会使用<strong>消费者组 (<code>XGROUP CREATE</code>, <code>XREADGROUP</code>)</strong> 来实现更可靠、可扩展的消息处理，并处理消息确认 (<code>XACK</code>)。</p>
<hr>
<p>第三部分内容到此结束。你已经掌握了 Redis 的事务处理、消息模式和高级数据结构。这些是构建复杂、健壮和高性能应用的关键。在下一部分，我们将探讨如何将这些技术应用到具体的实战模式中，例如构建缓存层和实现分布式锁。</p>
<p>好的，我们现在进入第四部分。在这一部分，我们将把之前学到的所有知识融会贯通，应用到一些常见且高级的实战模式中。这些模式是构建可扩展、高性能后端服务的核心组件。</p>
<hr>
<h1 id="高级应用与实战模式-1"><a href="#高级应用与实战模式-1" class="headerlink" title="高级应用与实战模式"></a><strong>高级应用与实战模式</strong></h1><h2 id="1-构建缓存层-Caching"><a href="#1-构建缓存层-Caching" class="headerlink" title="1. 构建缓存层 (Caching)"></a><strong>1. 构建缓存层 (Caching)</strong></h2><p>将 Redis 用作缓存是其最广泛的应用场景。通过将热点数据（高频访问且不频繁变更的数据）放入 Redis，可以极大地降低后端数据库的压力，并显著提升应用程序的响应速度。</p>
<ul>
<li><p><strong>核心缓存模式：Cache-Aside (旁路缓存)</strong><br>这是最常用、最经典的缓存模式，其逻辑非常清晰：</p>
<ol>
<li><strong>读操作</strong>：<ul>
<li>应用先请求 Redis 获取数据。</li>
<li>如果 Redis 中有数据（<strong>缓存命中</strong>），则直接返回给应用。</li>
<li>如果 Redis 中没有数据（<strong>缓存未命中</strong>），则应用去请求数据库。</li>
<li>应用从数据库获取数据后，<strong>将数据写入 Redis</strong>（并设置一个过期时间），然后再返回给应用。</li>
</ul>
</li>
<li><strong>写操作</strong>：<ul>
<li>先更新数据库。</li>
<li>然后<strong>直接删除 Redis 中对应的缓存</strong>。</li>
</ul>
</li>
</ol>
<p><strong>为什么是删除缓存，而不是更新缓存？</strong><br>因为更新缓存的操作路径更复杂，可能存在并发问题（例如，两个并发的写操作，缓存的最终值可能与数据库不一致）。而删除缓存则简单有效，下次读取时会自然地从数据库加载最新数据并回填缓存（这个过程也叫“懒加载”）。</p>
</li>
</ul>
<p><strong>Go 实战：为获取文章详情接口添加缓存</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-redis/redis/v9&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (省略 initClient 和 rdb 变量定义) ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Article 结构体</span></span><br><span class="line"><span class="keyword">type</span> Article <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID      <span class="type">string</span> <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">	Title   <span class="type">string</span> <span class="string">`json:&quot;title&quot;`</span></span><br><span class="line">	Content <span class="type">string</span> <span class="string">`json:&quot;content&quot;`</span></span><br><span class="line">	Author  <span class="type">string</span> <span class="string">`json:&quot;author&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一个缓慢的数据库查询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getArticleFromDB</span><span class="params">(id <span class="type">string</span>)</span></span> (*Article, <span class="type">error</span>) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;慢查询：正在从数据库获取文章 %s...\n&quot;</span>, id)</span><br><span class="line">	time.Sleep(<span class="number">500</span> * time.Millisecond) <span class="comment">// 模拟 I/O 延迟</span></span><br><span class="line">	<span class="comment">// 实际应用中，这里会是 SQL 查询</span></span><br><span class="line">	<span class="keyword">return</span> &amp;Article&#123;</span><br><span class="line">		ID:      id,</span><br><span class="line">		Title:   <span class="string">&quot;Go-Redis 实战&quot;</span>,</span><br><span class="line">		Content: <span class="string">&quot;这是一篇关于如何在 Go 中使用 Redis 的文章...&quot;</span>,</span><br><span class="line">		Author:  <span class="string">&quot;Gemini&quot;</span>,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetArticleByID 实现了 Cache-Aside 模式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetArticleByID</span><span class="params">(ctx context.Context, id <span class="type">string</span>)</span></span> (*Article, <span class="type">error</span>) &#123;</span><br><span class="line">	cacheKey := fmt.Sprintf(<span class="string">&quot;article:%s&quot;</span>, id)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 先从 Redis 读取</span></span><br><span class="line">	val, err := rdb.Get(ctx, cacheKey).Result()</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123; <span class="comment">// 缓存命中</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;缓存命中：从 Redis 获取文章 %s\n&quot;</span>, id)</span><br><span class="line">		<span class="keyword">var</span> article Article</span><br><span class="line">		<span class="keyword">if</span> err := json.Unmarshal([]<span class="type">byte</span>(val), &amp;article); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;article, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 仅当错误是 redis.Nil 时，才继续执行，否则说明是 Redis 服务出错了</span></span><br><span class="line">	<span class="keyword">if</span> err != redis.Nil &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err <span class="comment">// Redis 服务错误，直接返回</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 缓存未命中，从数据库读取</span></span><br><span class="line">	article, err := getArticleFromDB(id)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 将数据写入 Redis，并设置过期时间</span></span><br><span class="line">	jsonData, err := json.Marshal(article)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置 1 分钟的缓存过期时间</span></span><br><span class="line">	err = rdb.Set(ctx, cacheKey, jsonData, <span class="number">1</span>*time.Minute).Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 即使缓存设置失败，也应该将从数据库读到的结果返回给用户</span></span><br><span class="line">		<span class="comment">// 但需要记录日志</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;警告：设置缓存失败: %v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> article, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缓存问题与解决方案</strong></p>
<ul>
<li><strong>缓存穿透</strong>: 查询一个<strong>绝对不存在</strong>的数据。这会导致每次请求都“穿透”缓存，直接打到数据库，失去了缓存的意义。<ul>
<li><strong>解决方案</strong>: 当从数据库查询不到数据时，也在 Redis 中缓存一个<strong>空值</strong>或特殊占位符，并设置一个较短的过期时间（如 30 秒），防止恶意攻击。</li>
</ul>
</li>
<li><strong>缓存击穿</strong>: 一个<strong>热点 Key</strong> 在某个时刻突然过期，导致大量并发请求瞬间全部打到数据库上，可能导致数据库崩溃。<ul>
<li><strong>解决方案</strong>: 使用互斥锁。当缓存未命中时，只允许第一个请求去查询数据库并回填缓存，其他请求则等待。在 Go 中，<code>golang.org/x/sync/singleflight</code> 包是实现此模式的利器。</li>
</ul>
</li>
<li><strong>缓存雪崩</strong>: 大量 Key 在<strong>同一时间</strong>集中过期，导致数据库瞬时压力剧增。<ul>
<li><strong>解决方案</strong>: 在设置 Key 的过期时间时，增加一个<strong>随机值</strong>，比如 <code>过期时间 = 基础时间 + random(1, 300)</code> 秒，将过期时间点打散。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-实现分布式锁"><a href="#2-实现分布式锁" class="headerlink" title="2. 实现分布式锁"></a><strong>2. 实现分布式锁</strong></h2><p>在分布式系统中（例如，你的服务部署了多个实例），当需要修改某个共享资源时，需要一种机制来保证同一时间只有一个实例能够执行修改操作。这就是分布式锁。</p>
<ul>
<li><strong>核心思想</strong>: 利用 Redis 的 <code>SET key value NX PX milliseconds</code> 原子命令。<ul>
<li><code>SET key value</code>: 尝试设置一个 key。</li>
<li><code>NX</code>: (if Not eXists) 只有当 <code>key</code> 不存在时，<code>SET</code> 操作才会成功。</li>
<li><code>PX milliseconds</code>: 为这个 <code>key</code> 设置一个以毫秒为单位的过期时间。</li>
<li><code>value</code>: 必须是一个唯一的随机字符串（如 UUID），用于标识锁的持有者。</li>
</ul>
</li>
</ul>
<p><strong>为什么必须是原子命令？</strong><br>如果分两步 <code>SETNX</code> 和 <code>EXPIRE</code>，那么在执行完 <code>SETNX</code> 后，服务实例崩溃，<code>EXPIRE</code> 没能执行，这个锁将永远无法被释放，造成“死锁”。</p>
<p><strong>为什么 <code>value</code> 必须唯一？</strong><br>为了安全地释放锁。假设客户端 A 获取了锁（过期时间 10 秒），但由于网络延迟或 GC，它的业务执行了 15 秒。此时，锁已经被 Redis 自动释放，客户端 B 获取了同一个锁。然后客户端 A 执行完毕，执行 <code>DEL</code> 命令，它会错误地释放掉客户端 B 的锁。</p>
<p><strong>Go 实战：实现一个安全、可重入性低的分布式锁</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-redis/redis/v9&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/google/uuid&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AcquireLock 尝试获取一个分布式锁</span></span><br><span class="line"><span class="comment">// lockKey: 锁的名称</span></span><br><span class="line"><span class="comment">// lockValue: 锁的唯一标识</span></span><br><span class="line"><span class="comment">// expiration: 锁的过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AcquireLock</span><span class="params">(ctx context.Context, lockKey <span class="type">string</span>, lockValue <span class="type">string</span>, expiration time.Duration)</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// SetNX 返回一个 bool 类型的 val，true 表示设置成功，false 表示 key 已存在</span></span><br><span class="line">	<span class="keyword">return</span> rdb.SetNX(ctx, lockKey, lockValue, expiration).Result()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReleaseLock 安全地释放一个分布式锁</span></span><br><span class="line"><span class="comment">// 使用 Lua 脚本保证“比较”和“删除”的原子性</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReleaseLock</span><span class="params">(ctx context.Context, lockKey <span class="type">string</span>, lockValue <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// Lua 脚本：</span></span><br><span class="line">	<span class="comment">// 如果 key 的值等于我们传入的 value，就删除这个 key，并返回 1；否则返回 0。</span></span><br><span class="line">	luaScript := <span class="string">`</span></span><br><span class="line"><span class="string">        if redis.call(&#x27;GET&#x27;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">            return redis.call(&#x27;DEL&#x27;, KEYS[1])</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">	script := redis.NewScript(luaScript)</span><br><span class="line">	result, err := script.Run(ctx, rdb, []<span class="type">string</span>&#123;lockKey&#125;, lockValue).Int()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> result == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;锁释放失败：可能锁已被他人持有或已过期&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分布式锁使用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distributedLockExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- 分布式锁示例 ---&quot;</span>)</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	lockKey := <span class="string">&quot;my-distributed-lock&quot;</span></span><br><span class="line">	<span class="comment">// 为每个锁请求生成一个唯一ID</span></span><br><span class="line">	lockValue := uuid.New().String()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 尝试获取锁，有效期 10 秒</span></span><br><span class="line">	locked, err := AcquireLock(ctx, lockKey, lockValue, <span class="number">10</span>*time.Second)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> locked &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;成功获取锁！正在执行业务逻辑...&quot;</span>)</span><br><span class="line">		time.Sleep(<span class="number">5</span> * time.Second) <span class="comment">// 模拟业务处理</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;业务逻辑执行完毕，准备释放锁。&quot;</span>)</span><br><span class="line">		</span><br><span class="line">		err := ReleaseLock(ctx, lockKey, lockValue)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;成功释放锁！&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;获取锁失败，其他进程正在处理。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-位图-Bitmaps-与-HyperLogLogs"><a href="#3-位图-Bitmaps-与-HyperLogLogs" class="headerlink" title="3. 位图 (Bitmaps) 与 HyperLogLogs"></a><strong>3. 位图 (Bitmaps) 与 HyperLogLogs</strong></h2><p>这是两种非常高级且节省内存的数据结构，它们实际上是基于 Redis 的 String 类型实现的。</p>
<h3 id="3-1-Bitmaps-位图"><a href="#3-1-Bitmaps-位图" class="headerlink" title="3.1 Bitmaps (位图)"></a><strong>3.1 Bitmaps (位图)</strong></h3><p>你可以将一个 String 值看作是一个无限大的 bit 数组。Bitmaps 提供了一系列命令，让你能够像操作数组一样，设置或获取某一个 bit 位的值（0 或 1）。</p>
<ul>
<li><p><strong>用途</strong>: 非常适合用于记录大量用户的布尔状态，例如：</p>
<ul>
<li>用户每日签到状态</li>
<li>用户是否在线</li>
<li>用户是否看过某篇文章</li>
</ul>
</li>
<li><p><strong>优点</strong>: 极度节省空间。记录 1 亿用户的签到状态，每天只需要 <code>100,000,000 bits / 8 / 1024 / 1024 ≈ 12 MB</code> 的空间。</p>
</li>
</ul>
<p><strong>Go 实战：记录用户每日签到</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bitmapExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- Bitmaps 签到示例 ---&quot;</span>)</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Key 的格式：sign:&#123;yyyyMMdd&#125;</span></span><br><span class="line">	today := time.Now().Format(<span class="string">&quot;20060102&quot;</span>)</span><br><span class="line">	signKey := fmt.Sprintf(<span class="string">&quot;sign:%s&quot;</span>, today)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 假设有三个用户，ID 分别为 100, 101, 102</span></span><br><span class="line">	<span class="comment">// SetBit(key, offset, value)</span></span><br><span class="line">	<span class="comment">// offset 就是用户 ID</span></span><br><span class="line">	<span class="comment">// value 1 表示签到，0 表示未签到</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用户 100 签到</span></span><br><span class="line">	rdb.SetBit(ctx, signKey, <span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 用户 102 签到</span></span><br><span class="line">	rdb.SetBit(ctx, signKey, <span class="number">102</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查用户 100 和 101 是否签到</span></span><br><span class="line">	isSigned100, _ := rdb.GetBit(ctx, signKey, <span class="number">100</span>).Result()</span><br><span class="line">	isSigned101, _ := rdb.GetBit(ctx, signKey, <span class="number">101</span>).Result()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;用户 100 今天是否签到: %d (1=是, 0=否)\n&quot;</span>, isSigned100)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;用户 101 今天是否签到: %d (1=是, 0=否)\n&quot;</span>, isSigned101)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统计今天总的签到人数</span></span><br><span class="line">	totalSigned, _ := rdb.BitCount(ctx, signKey, <span class="literal">nil</span>).Result()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;今天总签到人数: %d\n&quot;</span>, totalSigned)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-HyperLogLogs-HLL"><a href="#3-2-HyperLogLogs-HLL" class="headerlink" title="3.2 HyperLogLogs (HLL)"></a><strong>3.2 HyperLogLogs (HLL)</strong></h3><p>HyperLogLog 是一种<strong>概率性</strong>数据结构，用于进行<strong>基数统计</strong>（即统计一个集合中不重复元素的数量）。</p>
<ul>
<li><strong>用途</strong>: 在需要统计巨大数量的独立访客（UV）、独立 IP 数等场景下，它非常有用。</li>
<li><strong>优点</strong>: 占用空间极小且固定。在 Redis 中，每个 HLL key 只占用 12KB 的内存，就可以统计高达 2^64 个不同元素的基数。</li>
<li><strong>缺点</strong>: 统计结果是一个<strong>估算值</strong>，存在一定的误差（标准误差为 0.81%）。你无法获取具体是哪些元素，只能获取它们的总数。</li>
</ul>
<p><strong>Go 实战：统计网站每日独立访客 (UV)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hyperLogLogExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- HyperLogLog 统计 UV 示例 ---&quot;</span>)</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	uvKey := fmt.Sprintf(<span class="string">&quot;uv:%s&quot;</span>, time.Now().Format(<span class="string">&quot;20060102&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟用户访问，每个用户有一个唯一的 ID (可以是 userID, sessionID, IP地址等)</span></span><br><span class="line">	<span class="comment">// PFAdd(key, elements...)</span></span><br><span class="line">	rdb.PFAdd(ctx, uvKey, <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;user2&quot;</span>, <span class="string">&quot;user3&quot;</span>)</span><br><span class="line">	rdb.PFAdd(ctx, uvKey, <span class="string">&quot;user2&quot;</span>, <span class="string">&quot;user3&quot;</span>, <span class="string">&quot;user4&quot;</span>, <span class="string">&quot;user5&quot;</span>) <span class="comment">// 重复的 user2, user3 不会增加计数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// PFCount(key) 获取基数估算值</span></span><br><span class="line">	uvCount, err := rdb.PFCount(ctx, uvKey).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;今天网站的估算独立访客数 (UV): %d\n&quot;</span>, uvCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>第四部分到此结束。你现在已经学会了如何使用 Redis 来构建企业级的缓存系统、实现健壮的分布式锁，以及利用 Bitmaps 和 HyperLogLogs 进行高效的数据统计。这些模式是在真实世界项目中非常有价值的技能。在最后一部分，我们将讨论一些关于运维和最佳实践的话题。</p>
<p>好的，我们来到了这份学习笔记的最后一个部分。这部分内容将超越代码层面，聚焦于如何在生产环境中健康、高效地运行和维护 Redis，并总结一些重要的开发最佳实践。</p>
<hr>
<h1 id="运维与最佳实践-1"><a href="#运维与最佳实践-1" class="headerlink" title="运维与最佳实践"></a><strong>运维与最佳实践</strong></h1><p>一个稳定可靠的 Redis 服务，离不开合理的架构设计和持续的监控维护。</p>
<h2 id="1-Redis-高可用与扩展"><a href="#1-Redis-高可用与扩展" class="headerlink" title="1. Redis 高可用与扩展"></a><strong>1. Redis 高可用与扩展</strong></h2><p>当业务流量增长，单个 Redis 实例可能会遇到瓶颈，或者成为系统的单点故障 (Single Point of Failure)。Redis 提供了多种方案来解决这个问题。</p>
<h3 id="1-1-主从复制-Replication"><a href="#1-1-主从复制-Replication" class="headerlink" title="1.1 主从复制 (Replication)"></a><strong>1.1 主从复制 (Replication)</strong></h3><ul>
<li><strong>工作原理</strong>: 配置一个 Redis 实例（<strong>Master</strong>）和多个其他实例（<strong>Slaves</strong>）。所有写操作都在 Master 上进行，然后 Master 会异步地将数据变更同步给所有的 Slaves。Slaves 通常是只读的。</li>
<li><strong>主要用途</strong>:<ol>
<li><strong>数据冗余</strong>: 当 Master 宕机时，Slave 上有完整的数据备份，可以手动将其提升为新的 Master，但这个过程需要人工介入。</li>
<li><strong>读写分离</strong>: 对于读多写少的场景，可以将所有读请求分发到多个 Slave 节点上，从而分担 Master 的读取压力，提高整体性能。</li>
</ol>
</li>
<li><strong>缺点</strong>: 无法实现自动故障转移。如果 Master 宕机，系统将无法写入，直到运维人员手动处理。</li>
</ul>
<h3 id="1-2-哨兵-Sentinel"><a href="#1-2-哨兵-Sentinel" class="headerlink" title="1.2 哨兵 (Sentinel)"></a><strong>1.2 哨兵 (Sentinel)</strong></h3><ul>
<li><p><strong>工作原理</strong>: Sentinel 是一个独立的进程，它通过“监视”一组 Master-Slave 节点来工作。它是一个高可用性的解决方案。</p>
</li>
<li><p><strong>核心功能</strong>:</p>
<ol>
<li><strong>监控 (Monitoring)</strong>: Sentinel 会持续检查 Master 和 Slaves 是否正常工作。</li>
<li><strong>通知 (Notification)</strong>: 当某个 Redis 实例出现问题时，Sentinel 可以通过 API 向管理员或其他应用程序发送通知。</li>
<li><strong>自动故障转移 (Automatic Failover)</strong>: 这是 Sentinel 最核心的功能。如果 Master 宕机，Sentinel 会在 Slaves 中选举出一个新的 Master，并通知其他 Slaves 连接到新的 Master。同时，它也会通知客户端新的 Master 地址。</li>
<li><strong>配置提供者 (Configuration Provider)</strong>: 客户端连接时，可以直接向 Sentinel 查询当前 Master 的地址，而不需要在代码中硬编码。</li>
</ol>
</li>
<li><p><strong>架构</strong>: 为了保证 Sentinel 本身的可用性，生产环境通常会部署一个由 3 个或 5 个 Sentinel 进程组成的集群。</p>
</li>
<li><p><strong>在 Go 中连接 Sentinel 管理的 Redis</strong><br><code>go-redis</code> 提供了专门的客户端来连接 Sentinel。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 NewFailoverClient 连接由 Sentinel 管理的集群</span></span><br><span class="line">rdb := redis.NewFailoverClient(&amp;redis.FailoverOptions&#123;</span><br><span class="line">    MasterName:    <span class="string">&quot;mymaster&quot;</span>, <span class="comment">// 在 Sentinel 配置文件中定义的主节点名称</span></span><br><span class="line">    SentinelAddrs: []<span class="type">string</span>&#123;<span class="string">&quot;sentinel1:26379&quot;</span>, <span class="string">&quot;sentinel2:26379&quot;</span>, <span class="string">&quot;sentinel3:26379&quot;</span>&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-3-集群-Cluster"><a href="#1-3-集群-Cluster" class="headerlink" title="1.3 集群 (Cluster)"></a><strong>1.3 集群 (Cluster)</strong></h3><ul>
<li><p><strong>工作原理</strong>: 当数据量巨大，单个 Master 的内存无法容纳，或者写请求的 QPS 过高时，就需要 Redis Cluster。它是一种<strong>分布式</strong>解决方案，通过<strong>分片 (Sharding)</strong> 将数据分散存储在多个 Redis 节点上。</p>
</li>
<li><p><strong>核心概念</strong>:</p>
<ul>
<li><strong>哈希槽 (Hash Slot)</strong>: Redis Cluster 预设了 16384 个哈希槽。当一个 key 需要存储时，Cluster 会对这个 key 使用 CRC16 算法计算出一个值，然后对 16384 取模，决定这个 key 应该存放在哪个槽里。</li>
<li><strong>节点分工</strong>: 每个 Master 节点负责一部分哈希槽。例如，一个 3 主 3 从的集群，可能是：<ul>
<li>Node A (Master) 负责 0 - 5500 槽</li>
<li>Node B (Master) 负责 5501 - 11000 槽</li>
<li>Node C (Master) 负责 11001 - 16383 槽</li>
</ul>
</li>
<li><strong>高可用</strong>: Cluster 中的每个 Master 节点都可以有自己的 Slave 节点，当 Master 宕机时，其对应的 Slave 会自动提升为新的 Master，接管哈希槽，保证服务不中断。</li>
</ul>
</li>
<li><p><strong>在 Go 中连接 Redis Cluster</strong><br>客户端必须是“集群感知”的，<code>go-redis</code> 完美支持。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 NewClusterClient 连接 Redis 集群</span></span><br><span class="line">rdb := redis.NewClusterClient(&amp;redis.ClusterOptions&#123;</span><br><span class="line">    Addrs: []<span class="type">string</span>&#123;<span class="string">&quot;node1:7001&quot;</span>, <span class="string">&quot;node2:7002&quot;</span>, <span class="string">&quot;node3:7003&quot;</span>&#125;,</span><br><span class="line">    <span class="comment">// ... 其他选项，如密码等</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<table>
<thead>
<tr>
<th align="left">方案</th>
<th align="left">解决的问题</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>主从复制</strong></td>
<td align="left">数据备份、读扩展</td>
<td align="left">结构简单，易于部署</td>
<td align="left">无自动故障转移</td>
</tr>
<tr>
<td align="left"><strong>哨兵</strong></td>
<td align="left">高可用、自动故障转移</td>
<td align="left">自动切换主库，保证服务可用性</td>
<td align="left">无法解决单 Master 的写瓶颈和内存限制</td>
</tr>
<tr>
<td align="left"><strong>集群</strong></td>
<td align="left">高可用、海量数据存储、高并发写入</td>
<td align="left">同时提供高可用和水平扩展能力</td>
<td align="left">架构更复杂，部分命令（如涉及多 key 的）使用受限</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-性能与监控"><a href="#2-性能与监控" class="headerlink" title="2. 性能与监控"></a><strong>2. 性能与监控</strong></h2><ul>
<li><p><strong><code>INFO</code> 命令</strong>:<br>这是最重要的监控命令，它返回关于 Redis 服务器的全方位信息。在 <code>redis-cli</code> 中执行 <code>INFO</code>，你会看到多个部分。</p>
<ul>
<li><code># Memory</code>:<ul>
<li><code>used_memory_human</code>: 当前已使用的内存，是监控内存是否溢出的核心指标。</li>
<li><code>mem_fragmentation_ratio</code>: 内存碎片率。大于 1.5 表明碎片较多，可能需要重启实例来整理。小于 1 表明 Redis 使用的内存超过了系统分配的内存，可能在进行内存交换（Swap），性能会急剧下降。</li>
</ul>
</li>
<li><code># Stats</code>:<ul>
<li><code>total_connections_received</code>: 累计连接数。</li>
<li><code>total_commands_processed</code>: 累计处理的命令数 (QPS&#x2F;OPS)。</li>
<li><code>keyspace_hits</code> &amp; <code>keyspace_misses</code>: 缓存命中和未命中的次数。缓存命中率 &#x3D; <code>hits / (hits + misses)</code>，这个比率是衡量缓存效率的关键。</li>
</ul>
</li>
<li><code># Persistence</code>: RDB 和 AOF 的相关信息。</li>
</ul>
</li>
<li><p><strong><code>SLOWLOG</code> 命令</strong>:<br>Redis 会记录执行时间超过指定阈值（通过 <code>slowlog-log-slower-than</code> 配置）的命令。使用 <code>SLOWLOG GET [number]</code> 可以查看这些慢命令，是排查性能瓶颈的重要工具。</p>
</li>
</ul>
<hr>
<h2 id="3-Go-开发最佳实践"><a href="#3-Go-开发最佳实践" class="headerlink" title="3. Go 开发最佳实践"></a><strong>3. Go 开发最佳实践</strong></h2><ol>
<li><p><strong>统一的键命名规范</strong>:<br>为你的 Key 设计一个清晰、有层次的命名空间，可以极大地提高可维护性。推荐使用冒号分隔。</p>
<ul>
<li><strong>格式</strong>: <code>项目名:业务模块:对象类型:对象ID:[字段]</code></li>
<li><strong>示例</strong>: <code>myproject:user:profile:1001</code>, <code>myproject:cache:article:8809</code></li>
</ul>
</li>
<li><p><strong>避免重量级命令</strong>:<br>因为 Redis 是单线程处理命令，一个慢命令会阻塞所有其他客户端的请求。</p>
<ul>
<li><strong>绝对禁止在生产环境使用 <code>KEYS</code></strong>。请使用 <code>SCAN</code> 命令进行安全的、基于游标的迭代。</li>
<li>谨慎使用 <code>HGETALL</code>, <code>LRANGE 0 -1</code>, <code>SMEMBERS</code> 等命令操作包含数万甚至数百万个元素的巨大 Key，这可能导致长时间阻塞。如果需要，考虑分批获取。</li>
</ul>
</li>
<li><p><strong>为缓存键设置合理的过期时间</strong>:<br>这是防止 Redis 内存被无用数据耗尽的最重要手段。</p>
<ul>
<li><strong>永不过期的数据要警惕</strong>。确保它们是确实需要永久存在的。</li>
<li>使用随机化过期时间来<strong>防止缓存雪崩</strong>。</li>
</ul>
</li>
<li><p><strong>理解内存管理与淘汰策略</strong>:<br>当 Redis 内存使用达到 <code>maxmemory</code> 上限时，会触发<strong>数据淘汰策略 (Eviction Policy)</strong>。</p>
<ul>
<li>在 <code>redis.conf</code> 中配置 <code>maxmemory-policy</code>。</li>
<li>常用策略：<ul>
<li><code>volatile-lru</code>: (默认) 从已设置过期时间的 key 中，淘汰最近最少使用的。</li>
<li><code>allkeys-lru</code>: 从所有 key 中，淘汰最近最少使用的。</li>
<li><code>volatile-lfu</code>: (Redis 4.0+) 从已设置过期时间的 key 中，淘汰最不经常使用的。</li>
<li><code>allkeys-lfu</code>: 从所有 key 中，淘汰最不经常使用的。</li>
<li><code>noeviction</code>: 不淘汰任何数据，后续的写操作会直接返回错误。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Go 客户端使用技巧</strong>:</p>
<ul>
<li><strong>复用 <code>redis.Client</code> 对象</strong>: <code>redis.Client</code> 是并发安全的，并且内置了连接池。你应该在应用启动时初始化一个全局的客户端实例，并在所有地方复用它，而不是每次请求都创建一个新的。</li>
<li><strong>善用 <code>context</code> 控制超时</strong>: 为每个 Redis 操作传递带有超时的 <code>context</code>，可以防止因为 Redis 慢查询而拖垮整个应用。</li>
<li><strong>使用 <code>Pipeline</code> 批量操作</strong>: 当你需要连续执行多个命令且不要求原子性时，使用 <code>Pipeline</code> 可以显著减少网络延迟，提升性能。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>总结</strong></p>
<p>恭喜你！至此，你已经系统地学习了从 Redis 的基础概念、五大数据类型，到在 Go 语言中的实战应用，再到事务、发布订阅等高级主题，最后覆盖了分布式锁、缓存模式以及运维和最佳实践。</p>
<p>Redis 是一个功能极其强大且应用广泛的工具。这份笔记为你打下了坚实的基础，但真正的精通来自于不断的实践。现在，尝试在你的下一个项目中引入 Redis，解决实际问题吧！</p>
<h1 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h1><h2 id="Pub-Sub模型"><a href="#Pub-Sub模型" class="headerlink" title="Pub&#x2F;Sub模型"></a>Pub&#x2F;Sub模型</h2><ul>
<li>程序 A：发布者（Publisher）</li>
<li>程序 B：订阅者（Subscriber），可以有 1 个，也可以有 N 个同时运行</li>
<li>当发布者发送消息时，所有订阅者都会实时收到</li>
</ul>
<p>下面我给你写两个完全独立的 Go 程序，直接可运行。</p>
<hr>
<h3 id="publisher"><a href="#publisher" class="headerlink" title="publisher"></a>publisher</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// publisher.go</span></span><br><span class="line"><span class="comment">// 声明这个文件属于 main 包</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入需要的标准库和第三方包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span> <span class="comment">// 用于处理上下文，如超时、取消等</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span>     <span class="comment">// 用于格式化输入输出</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span>    <span class="comment">// 用于处理时间和日期</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/redis/go-redis/v9&quot;</span> <span class="comment">// Redis 的 Go 客户端库</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个空的 context.Background()，它是所有 context 的根节点</span></span><br><span class="line"><span class="comment">// 通常在主函数、初始化和测试时使用</span></span><br><span class="line"><span class="keyword">var</span> ctx = context.Background()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个新的 Redis 客户端实例</span></span><br><span class="line">	<span class="comment">// &amp;redis.Options 结构体包含了连接 Redis 的配置选项</span></span><br><span class="line">	<span class="comment">// Addr 指定了 Redis 服务器的地址，这里是本地默认端口 6379</span></span><br><span class="line">	rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr: <span class="string">&quot;localhost:6379&quot;</span>, <span class="comment">// Redis 服务器地址</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 for 循环发布 10 条消息</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 获取当前时间并格式化为 &quot;2006-01-02 15:04:05&quot; 的格式</span></span><br><span class="line">		<span class="comment">// 注意：Go 的时间格式化模板是固定的，必须使用 2006-01-02 15:04:05 这个特定时间</span></span><br><span class="line">		currentTime := time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建消息内容，包含序号和当前时间</span></span><br><span class="line">		<span class="comment">// fmt.Sprintf 用于格式化字符串，%d 是整数的占位符，%s 是字符串的占位符</span></span><br><span class="line">		msg := fmt.Sprintf(<span class="string">&quot;消息 %d - %s&quot;</span>, i, currentTime)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用 Publish 方法向 &quot;demo-channel&quot; 频道发布消息</span></span><br><span class="line">		<span class="comment">// ctx 是上下文，&quot;demo-channel&quot; 是频道名，msg 是消息内容</span></span><br><span class="line">		<span class="comment">// .Err() 用于获取发布操作可能产生的错误</span></span><br><span class="line">		err := rdb.Publish(ctx, <span class="string">&quot;demo-channel&quot;</span>, msg).Err()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检查发布操作是否出错</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 如果出错，打印错误信息并退出程序</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;发布失败:&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 打印成功发布的消息内容</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;已发布:&quot;</span>, msg)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 暂停 1 秒</span></span><br><span class="line">		<span class="comment">// time.Sleep 用于让程序休眠指定的时间</span></span><br><span class="line">		<span class="comment">// 1 * time.Second 表示 1 秒</span></span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="subscriber"><a href="#subscriber" class="headerlink" title="subscriber"></a>subscriber</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// subscriber.go</span></span><br><span class="line"><span class="comment">// 声明这个文件属于 main 包</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入需要的标准库和第三方包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span> <span class="comment">// 用于处理上下文，如超时、取消等</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span>     <span class="comment">// 用于格式化输入输出</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/redis/go-redis/v9&quot;</span> <span class="comment">// Redis 的 Go 客户端库</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个空的 context.Background()，它是所有 context 的根节点</span></span><br><span class="line"><span class="comment">// 通常在主函数、初始化和测试时使用</span></span><br><span class="line"><span class="keyword">var</span> ctx = context.Background()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个新的 Redis 客户端实例</span></span><br><span class="line">	<span class="comment">// &amp;redis.Options 结构体包含了连接 Redis 的配置选项</span></span><br><span class="line">	<span class="comment">// Addr 指定了 Redis 服务器的地址，这里是本地默认端口 6379</span></span><br><span class="line">	rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr: <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 Redis 客户端订阅名为 &quot;demo-channel&quot; 的频道</span></span><br><span class="line">	<span class="comment">// Subscribe 方法返回一个订阅对象</span></span><br><span class="line">	sub := rdb.Subscribe(ctx, <span class="string">&quot;demo-channel&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取订阅频道的消息通道</span></span><br><span class="line">	<span class="comment">// Channel() 返回一个 channel，用于接收订阅到的消息</span></span><br><span class="line">	ch := sub.Channel()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印提示信息，表示开始订阅</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;开始订阅 demo-channel ...&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 for-range 循环持续监听频道消息</span></span><br><span class="line">	<span class="comment">// 每当有新消息到达时，msg 变量就会接收到消息</span></span><br><span class="line">	<span class="comment">// 这个循环会一直运行，直到程序被终止或通道关闭</span></span><br><span class="line">	<span class="keyword">for</span> msg := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		<span class="comment">// 打印接收到的消息内容</span></span><br><span class="line">		<span class="comment">// msg.Payload 包含了消息的实际内容</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;收到消息: %s\n&quot;</span>, msg.Payload)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>启动一个或多个订阅者（可以开 N 个终端同时运行 <code>subscriber.go</code>）：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go run subscriber.go</span><br></pre></td></tr></table></figure>

<ol>
<li>启动发布者：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go run publisher.go</span><br></pre></td></tr></table></figure>

<ol>
<li>你会看到所有订阅者<strong>同时收到相同的消息</strong>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">收到消息: 消息 0</span><br><span class="line">收到消息: 消息 1</span><br><span class="line">收到消息: 消息 2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<hr>
<p> 特别说明：</p>
<ul>
<li><strong>Pub&#x2F;Sub 不会存储消息</strong>，如果订阅者启动得比发布者晚，之前发过的消息收不到。</li>
<li>如果你需要“后来的订阅者还能收到旧消息”，那就要用 <strong>Redis Streams</strong>。</li>
<li>由于接收端是管道，因此会阻塞住。如果不想被阻塞，可能需要添加defalut等语句。</li>
<li>当没有订阅者时：<ul>
<li>发布者照常 <code>PUBLISH</code>，Redis 会执行成功。</li>
<li>不过这个消息不会被任何人接收到，相当于“丢弃”。</li>
<li>Redis 会告诉你有多少个订阅者收到了消息（一般返回 <code>0</code>）。</li>
</ul>
</li>
<li>当没有发布者时：<ul>
<li>订阅者执行 <code>SUBSCRIBE</code> 后就会挂起，等待消息。</li>
<li>这时没有消息，它就一直阻塞在那里，不会报错。</li>
<li>一旦有发布者发消息，它会立刻收到。</li>
</ul>
</li>
<li>发布者和订阅者都不存在<ul>
<li>Redis 什么都不会做，就静静待在那里，也不会报错。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>总结</strong></p>
<ul>
<li>Pub&#x2F;Sub 是<strong>松耦合</strong>的，发布者和订阅者可以任意存在或缺失。</li>
<li>最多只是消息“没人接收”，但不会抛异常或报错。</li>
<li>所以在 Go 代码里，不需要加额外的错误处理来保证“对方一定在线”。</li>
</ul>
<hr>
<h2 id="Streams模型"><a href="#Streams模型" class="headerlink" title="Streams模型"></a>Streams模型</h2><h3 id="Pub-Sub和-Streams-的区别"><a href="#Pub-Sub和-Streams-的区别" class="headerlink" title="Pub&#x2F;Sub和 Streams 的区别"></a>Pub&#x2F;Sub和 Streams 的区别</h3><p>Redis 里的 <strong>Pub&#x2F;Sub</strong> 和 <strong>Streams</strong> 看似都是消息机制，但它们的定位和能力差别很大。你可以把它们理解成两个层级的工具：</p>
<hr>
<h4 id="1-Pub-Sub"><a href="#1-Pub-Sub" class="headerlink" title="1. Pub&#x2F;Sub"></a>1. Pub&#x2F;Sub</h4><p><strong>特点：</strong></p>
<ul>
<li><strong>即时性</strong>：消息只会实时发送给在线订阅者。</li>
<li><strong>不存储</strong>：消息发出去，如果没人订阅，就直接丢弃。</li>
<li><strong>无状态</strong>：订阅者断开再连，不会收到历史消息。</li>
<li><strong>简单</strong>：轻量级实现，性能高，延迟低。</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>聊天室（在线用户实时收到消息）。</li>
<li>实时通知（告警推送、在线状态广播）。</li>
<li>对消息可靠性要求不高的系统。</li>
</ul>
<hr>
<h4 id="2-Streams"><a href="#2-Streams" class="headerlink" title="2. Streams"></a>2. Streams</h4><p><strong>特点：</strong></p>
<ul>
<li><strong>持久化</strong>：消息会存储在 Redis 里，直到显式删除。</li>
<li><strong>可回溯</strong>：消费者可以从任意 ID 开始读消息，能获取历史消息。</li>
<li><strong>消费者组</strong>：支持多个消费者分工合作（类似 Kafka 的 consumer group）。</li>
<li><strong>确认机制</strong>：消费者需要 ACK，保证消息至少被消费一次。</li>
<li><strong>功能更全</strong>：可以做消息队列、日志系统。</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>日志收集（存储和回放）。</li>
<li>任务队列（保证任务不会丢失，失败可以重新消费）。</li>
<li>事件流处理（IoT 数据、交易流水）。</li>
</ul>
<hr>
<h4 id="3-核心区别对比表"><a href="#3-核心区别对比表" class="headerlink" title="3. 核心区别对比表"></a>3. 核心区别对比表</h4><table>
<thead>
<tr>
<th>特性</th>
<th>Pub&#x2F;Sub</th>
<th>Streams</th>
</tr>
</thead>
<tbody><tr>
<td><strong>消息存储</strong></td>
<td>不存储</td>
<td>持久化存储</td>
</tr>
<tr>
<td><strong>历史消息</strong></td>
<td>不可获取</td>
<td>可回溯</td>
</tr>
<tr>
<td><strong>消费者模式</strong></td>
<td>广播给所有订阅者</td>
<td>消费者组分工，避免重复</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>无保证，消息可能丢</td>
<td>支持 ACK，保证至少一次</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>高，延迟低</td>
<td>略高开销</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>即时通知、在线聊天室</td>
<td>队列、日志、任务分发</td>
</tr>
</tbody></table>
<hr>
<h4 id="4-类比一下"><a href="#4-类比一下" class="headerlink" title="4. 类比一下"></a>4. 类比一下</h4><ul>
<li><strong>Pub&#x2F;Sub &#x3D; 广播电台</strong>：主播一说话，听众当场能听见；错过就没有了。</li>
<li><strong>Streams &#x3D; 点播系统</strong>：内容会存下来，你可以随时点播，还能多人分工听不同部分。</li>
</ul>
<hr>
<p> 总结：</p>
<ul>
<li>如果你要做 <strong>实时消息推送</strong>，选 Pub&#x2F;Sub。</li>
<li>如果你要做 <strong>可靠队列 &#x2F; 日志流</strong>，选 Streams。</li>
</ul>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// producer.go</span></span><br><span class="line"><span class="keyword">package</span> main <span class="comment">// 声明这是 main 包，表示这是一个可执行程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ( <span class="comment">// 导入所需的包</span></span><br><span class="line">	<span class="string">&quot;context&quot;</span> <span class="comment">// 用于上下文控制</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span>     <span class="comment">// 用于格式化输入输出</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span>      <span class="comment">// 用于操作系统相关功能，如获取命令行参数</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span> <span class="comment">// 用于字符串和其他基本类型之间的转换</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/redis/go-redis/v9&quot;</span> <span class="comment">// Redis 客户端库</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ctx = context.Background() <span class="comment">// 创建一个空的上下文，用于 Redis 操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">// 程序入口函数</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &lt; <span class="number">2</span> &#123; <span class="comment">// 检查命令行参数数量</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;用法: go run producer.go &lt;N&gt;&quot;</span>) <span class="comment">// 打印使用说明</span></span><br><span class="line">		<span class="keyword">return</span>                                    <span class="comment">// 退出程序</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	N, _ := strconv.Atoi(os.Args[<span class="number">1</span>]) <span class="comment">// 将第一个参数转换为整数（要发送的消息数量）</span></span><br><span class="line">	<span class="keyword">if</span> N &lt;= <span class="number">0</span> &#123;                      <span class="comment">// 检查 N 是否小于等于 0</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;不发送任何消息 (N=0)&quot;</span>) <span class="comment">// 打印提示信息</span></span><br><span class="line">		<span class="keyword">return</span>                       <span class="comment">// 退出程序</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rdb := redis.NewClient(&amp;redis.Options&#123; <span class="comment">// 创建 Redis 客户端</span></span><br><span class="line">		Addr: <span class="string">&quot;localhost:6379&quot;</span>, <span class="comment">// Redis 服务器地址</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= N; i++ &#123; <span class="comment">// 循环 N 次，发送 N 条消息</span></span><br><span class="line">		id, err := rdb.XAdd(ctx, &amp;redis.XAddArgs&#123; <span class="comment">// 向流中添加消息</span></span><br><span class="line">			Stream: <span class="string">&quot;demo-stream&quot;</span>, <span class="comment">// 指定要添加消息的流名称</span></span><br><span class="line">			Values: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123; <span class="comment">// 定义消息内容</span></span><br><span class="line">				<span class="string">&quot;msg&quot;</span>: fmt.Sprintf(<span class="string">&quot;消息 %d&quot;</span>, i), <span class="comment">// 创建格式化的消息文本</span></span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;).Result()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">// 检查添加是否出错</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;发送失败:&quot;</span>, err) <span class="comment">// 打印错误信息</span></span><br><span class="line">			<span class="keyword">return</span>                    <span class="comment">// 退出程序</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;已发送: 消息 %d (ID=%s)\n&quot;</span>, i, id) <span class="comment">// 打印发送成功的消息和其ID</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// consumer.go</span></span><br><span class="line"><span class="keyword">package</span> main <span class="comment">// 声明这是 main 包，表示这是一个可执行程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ( <span class="comment">// 导入所需的包</span></span><br><span class="line">	<span class="string">&quot;context&quot;</span> <span class="comment">// 用于上下文控制</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span>     <span class="comment">// 用于格式化输入输出</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span>      <span class="comment">// 用于操作系统相关功能，如获取命令行参数</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span> <span class="comment">// 用于字符串和其他基本类型之间的转换</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/redis/go-redis/v9&quot;</span> <span class="comment">// Redis 客户端库</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ctx = context.Background() <span class="comment">// 创建一个空的上下文，用于 Redis 操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">// 程序入口函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &lt; <span class="number">2</span> &#123; <span class="comment">// 检查命令行参数数量</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;用法: go run consumer.go &lt;N&gt;&quot;</span>) <span class="comment">// 打印使用说明</span></span><br><span class="line">		<span class="keyword">return</span>                                    <span class="comment">// 退出程序</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;开始接收消息...&quot;</span>)</span><br><span class="line"></span><br><span class="line">	N, _ := strconv.Atoi(os.Args[<span class="number">1</span>]) <span class="comment">// 将第一个参数转换为整数（要接收的消息数量）</span></span><br><span class="line">	<span class="keyword">if</span> N &lt;= <span class="number">0</span> &#123;                      <span class="comment">// 检查 N 是否小于等于 0</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;不接收任何消息 (N=0)&quot;</span>) <span class="comment">// 打印提示信息</span></span><br><span class="line">		<span class="keyword">return</span>                       <span class="comment">// 退出程序</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rdb := redis.NewClient(&amp;redis.Options&#123; <span class="comment">// 创建 Redis 客户端</span></span><br><span class="line">		Addr: <span class="string">&quot;localhost:6379&quot;</span>, <span class="comment">// Redis 服务器地址</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	lastID := <span class="string">&quot;0&quot;</span> <span class="comment">// 初始化最后读取的消息ID为&quot;0&quot;，表示从头开始读取</span></span><br><span class="line">	count := <span class="number">0</span>    <span class="comment">// 初始化已接收消息计数器</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> count &lt; N &#123; <span class="comment">// 循环直到接收到 N 条消息</span></span><br><span class="line">		streams, err := rdb.XRead(ctx, &amp;redis.XReadArgs&#123; <span class="comment">// 从流中读取消息</span></span><br><span class="line">			Streams: []<span class="type">string</span>&#123;<span class="string">&quot;demo-stream&quot;</span>, lastID&#125;, <span class="comment">// 指定要读取的流和起始ID</span></span><br><span class="line">			Count:   <span class="number">1</span>,                               <span class="comment">// 每次读取最多 1 条消息</span></span><br><span class="line">			Block:   <span class="number">0</span>,                               <span class="comment">// 阻塞等待新消息，0 表示无限等待</span></span><br><span class="line">		&#125;).Result()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">// 检查读取是否出错</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;接收失败:&quot;</span>, err) <span class="comment">// 打印错误信息</span></span><br><span class="line">			<span class="keyword">return</span>                    <span class="comment">// 退出程序</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, msg := <span class="keyword">range</span> streams[<span class="number">0</span>].Messages &#123; <span class="comment">// 遍历接收到的消息</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;收到消息: ID=%s, 内容=%v\n&quot;</span>, msg.ID, msg.Values) <span class="comment">// 打印消息ID和内容</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 删除消息</span></span><br><span class="line">			deleted, err := rdb.XDel(ctx, <span class="string">&quot;demo-stream&quot;</span>, msg.ID).Result()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;删除消息 %s 失败: %v\n&quot;</span>, msg.ID, err)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> deleted &gt; <span class="number">0</span> &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;消息 %s 已删除\n&quot;</span>, msg.ID)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			lastID = msg.ID <span class="comment">// 更新最后读取的消息ID</span></span><br><span class="line">			count++         <span class="comment">// 增加已接收消息计数器</span></span><br><span class="line">			<span class="keyword">if</span> count &gt;= N &#123; <span class="comment">// 检查是否已接收足够的消息</span></span><br><span class="line">				<span class="keyword">break</span> <span class="comment">// 跳出循环</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li><strong>先清空旧的 Stream（避免历史消息干扰）：</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli DEL demo-stream</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>运行 Producer 发送消息：</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go run producer.go 5</span><br></pre></td></tr></table></figure>

<p>会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">已发送: 消息 1 (ID=1725349102374-0)</span><br><span class="line">已发送: 消息 2 (ID=1725349102375-0)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>运行 Consumer 接收消息：</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go run consumer.go 5</span><br></pre></td></tr></table></figure>

<p>会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">收到消息: ID=1725349102374-0, 内容=map[msg:消息 1]</span><br><span class="line">收到消息: ID=1725349102375-0, 内容=map[msg:消息 2]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="特性验证"><a href="#特性验证" class="headerlink" title="特性验证"></a>特性验证</h3><ul>
<li>如果 <strong>先运行 Producer</strong>，消息会存储在 Stream 里；Consumer 之后启动，依然能读到之前的消息。</li>
<li>如果 <strong>先运行 Consumer</strong>，它会阻塞等待，直到 Producer 发消息才会收到。</li>
<li>如果传 <code>N=0</code>，则双方都不会发送&#x2F;接收任何消息，不会报错。</li>
<li>如果接收端没有删除，则所有信息都会被redis保留。<ul>
<li><code>deleted, err := rdb.XDel(ctx, &quot;demo-stream&quot;, msg.ID).Result()</code></li>
</ul>
</li>
</ul>
<h4 id="Redis-Stream-消息-ID-和-消息内容格式"><a href="#Redis-Stream-消息-ID-和-消息内容格式" class="headerlink" title="Redis Stream 消息 ID 和 消息内容格式"></a>Redis <strong>Stream 消息 ID</strong> 和 <strong>消息内容格式</strong></h4><h5 id="ID-是怎么生成的？"><a href="#ID-是怎么生成的？" class="headerlink" title="ID 是怎么生成的？"></a>ID 是怎么生成的？</h5><p>Redis Stream 的消息 ID 由两部分组成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ID&gt; = &lt;毫秒级时间戳&gt;-&lt;序列号&gt;</span><br></pre></td></tr></table></figure>

<p>比如：<code>1756907190367-1</code></p>
<ul>
<li><strong>1756907190367</strong>：消息写入时的毫秒级时间戳（Unix epoch）。</li>
<li><strong>1</strong>：同一毫秒内的顺序号（避免冲突）。</li>
</ul>
<p>举个例子：</p>
<ul>
<li>如果你在同一毫秒内调用两次 <code>XADD</code>：<ul>
<li>第一次 → <code>1756907190367-0</code></li>
<li>第二次 → <code>1756907190367-1</code></li>
</ul>
</li>
<li>如果时间戳变了，就从 <code>-0</code> 开始。</li>
</ul>
<p>这个 ID 是 Redis 自动生成的（除非你手动指定），所以全局唯一，能保证消息顺序。</p>
<hr>
<h5 id="2-发送的消息内容是什么格式？"><a href="#2-发送的消息内容是什么格式？" class="headerlink" title="2. 发送的消息内容是什么格式？"></a>2. 发送的消息内容是什么格式？</h5><p>在 Redis Stream 里，每条消息的内容本质是一个 <strong>键值对集合</strong>，类似于哈希表。</p>
<p>在 Go 里，调用 <code>XAdd</code> 时传的就是一个 <strong><code>map[string]interface{}</code></strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">id, _ := rdb.XAdd(ctx, &amp;redis.XAddArgs&#123;</span><br><span class="line">    Stream: <span class="string">&quot;demo-stream&quot;</span>,</span><br><span class="line">    Values: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">&quot;user&quot;</span>: <span class="string">&quot;alice&quot;</span>,</span><br><span class="line">        <span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;).Result()</span><br></pre></td></tr></table></figure>

<p>Redis 里存的就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ID=1756907190367-1</span><br><span class="line">user =&gt; alice</span><br><span class="line">msg  =&gt; hello world</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-那么，能不能直接发-JSON？"><a href="#3-那么，能不能直接发-JSON？" class="headerlink" title="3. 那么，能不能直接发 JSON？"></a>3. 那么，能不能直接发 JSON？</h5><p>可以的，但 Redis 本身不会帮你序列化 JSON。你需要在 Go 里手动把对象转成 JSON 字符串，再存进去：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">    User <span class="type">string</span> <span class="string">`json:&quot;user&quot;`</span></span><br><span class="line">    Msg  <span class="type">string</span> <span class="string">`json:&quot;msg&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m := Message&#123;User: <span class="string">&quot;alice&quot;</span>, Msg: <span class="string">&quot;hello world&quot;</span>&#125;</span><br><span class="line">jsonData, _ := json.Marshal(m)</span><br><span class="line"></span><br><span class="line">id, _ := rdb.XAdd(ctx, &amp;redis.XAddArgs&#123;</span><br><span class="line">    Stream: <span class="string">&quot;demo-stream&quot;</span>,</span><br><span class="line">    Values: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">&quot;data&quot;</span>: <span class="type">string</span>(jsonData), <span class="comment">// 存 JSON 字符串</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;).Result()</span><br></pre></td></tr></table></figure>

<p>Redis 里就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ID=1756907190367-1</span><br><span class="line">data =&gt; &#123;&quot;user&quot;:&quot;alice&quot;,&quot;msg&quot;:&quot;hello world&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>读取时再 <code>json.Unmarshal</code> 回 Go 结构体即可。</p>
<hr>
<h5 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h5><ul>
<li><strong>ID</strong>：<code>&lt;毫秒时间戳&gt;-&lt;同毫秒内的序列号&gt;</code>，Redis 自动生成，保证顺序。</li>
<li><strong>消息体</strong>：一个 <code>map[string]interface{}</code>，可以存多个字段。</li>
<li>如果想发 JSON，就把 JSON 当成一个字符串存到 map 的 value 里。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chaoqijiang.github.io">棨</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chaoqijiang.github.io/2025/08/26/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://chaoqijiang.github.io/2025/08/26/Redis学习笔记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://chaoqijiang.github.io" target="_blank">柊</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/protected/">protected</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post-share"><div class="social-share" data-image="/Image/avatar.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/27/Linux%20%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" title="Linux 命令大全"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Linux 命令大全</div></div><div class="info-2"><div class="info-item-1">Linux 命令大全</div></div></div></a><a class="pagination-related" href="/2025/10/06/Golang_validator/" title="Golang validator 库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Golang validator 库</div></div><div class="info-2"><div class="info-item-1">主要讲解如何在Go中使用validator库进行数据验证。通过一系列章节，你将学会如何使用validator库来确保你的数据符合预期。从基本的验证规则到自定义的验证函数，再到处理错误信息的高级技巧，本教程将带你一步步深入学习。validator 是一个非常强大的库，它可以帮助你确保你的数据在进入程序之前就已经是干净、合规的。让我们一起开始这段学习之旅吧！</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%9F%E6%88%90/" title="AI提示词_学习笔记生成"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-08</div><div class="info-item-2">AI提示词_学习笔记生成</div></div><div class="info-2"><div class="info-item-1">AI提示词，用于引导AI生成学习笔记，根据提示的设定，对没有基础背景背景的小白生成学习笔记。</div></div></div></a><a class="pagination-related" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E8%AF%95%E9%A2%98%E7%94%9F%E6%88%90/" title="AI提示词_试题生成"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-08</div><div class="info-item-2">AI提示词_试题生成</div></div><div class="info-2"><div class="info-item-1">AI提示词，用于根据提示信息生成对应的试题，帮助学习者检验理解深度。</div></div></div></a><a class="pagination-related" href="/2025/05/04/Armbian%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8RNDIS%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E4%B8%8A%E7%BD%91/" title="Armbian系统使用RNDIS协议进行上网"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-04</div><div class="info-item-2">Armbian系统使用RNDIS协议进行上网</div></div><div class="info-2"><div class="info-item-1">Armbian系统使用RNDIS协议进行上网</div></div></div></a><a class="pagination-related" href="/2023/01/08/C++STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="C++ STL学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-08</div><div class="info-item-2">C++ STL学习笔记</div></div><div class="info-2"><div class="info-item-1">C++ STL学习笔记</div></div></div></a><a class="pagination-related" href="/2023/12/01/Docker%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" title="Docker基础教程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-01</div><div class="info-item-2">Docker基础教程</div></div><div class="info-2"><div class="info-item-1">Docker基础教程</div></div></div></a><a class="pagination-related" href="/2023/06/07/ESP8266%E7%9B%B8%E5%85%B3%E6%A1%88%E4%BE%8B%E7%AC%94%E8%AE%B0/" title="ESP8266相关案例笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-07</div><div class="info-item-2">ESP8266相关案例笔记</div></div><div class="info-2"><div class="info-item-1">ESP8266相关案例笔记</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/Image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">棨</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:chaoqijiang@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E7%BA%B2"><span class="toc-number">1.</span> <span class="toc-text">大纲</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">Redis 核心概念与基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go-%E4%B8%8E-Redis-%E9%9B%86%E6%88%90"><span class="toc-number">1.2.</span> <span class="toc-text">Go 与 Redis 集成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E8%BF%9B%E9%98%B6%E4%B8%BB%E9%A2%98%E4%B8%8E-Go-%E5%AE%9E%E6%88%98"><span class="toc-number">1.3.</span> <span class="toc-text">Redis 进阶主题与 Go 实战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%9E%E6%88%98%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">高级应用与实战模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%BB%B4%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.5.</span> <span class="toc-text">运维与最佳实践</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E7%A1%80-1"><span class="toc-number">2.</span> <span class="toc-text">Redis 核心概念与基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Redis-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">1. Redis 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%90%AF%E5%8A%A8"><span class="toc-number">2.2.</span> <span class="toc-text">2. 安装与启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Redis-%E4%BA%94%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">3. Redis 五大核心数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">2.3.1.</span> <span class="toc-text">Go 语言环境准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2-String"><span class="toc-number">2.3.2.</span> <span class="toc-text">1. 字符串 (String)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-CLI-%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.2.4.</span> <span class="toc-text">Redis CLI 示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Go-%E8%AF%AD%E8%A8%80%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.2.5.</span> <span class="toc-text">Go 语言示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%97%E8%A1%A8-List"><span class="toc-number">2.3.3.</span> <span class="toc-text">2. 列表 (List)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-CLI-%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">2.3.3.4.</span> <span class="toc-text">Redis CLI 示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Go-%E8%AF%AD%E8%A8%80%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">2.3.3.5.</span> <span class="toc-text">Go 语言示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%93%88%E5%B8%8C-Hash"><span class="toc-number">2.3.4.</span> <span class="toc-text">3. 哈希 (Hash)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-CLI-%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">2.3.4.4.</span> <span class="toc-text">Redis CLI 示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Go-%E8%AF%AD%E8%A8%80%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">2.3.4.5.</span> <span class="toc-text">Go 语言示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%9B%86%E5%90%88-Set"><span class="toc-number">2.3.5.</span> <span class="toc-text">4. 集合 (Set)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number">2.3.5.3.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-CLI-%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">2.3.5.4.</span> <span class="toc-text">Redis CLI 示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Go-%E8%AF%AD%E8%A8%80%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">2.3.5.5.</span> <span class="toc-text">Go 语言示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88-Sorted-Set-ZSet"><span class="toc-number">2.3.6.</span> <span class="toc-text">5. 有序集合 (Sorted Set &#x2F; ZSet)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">2.3.6.2.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="toc-number">2.3.6.3.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-CLI-%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">2.3.6.4.</span> <span class="toc-text">Redis CLI 示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Go-%E8%AF%AD%E8%A8%80%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">2.3.6.5.</span> <span class="toc-text">Go 语言示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Go-%E4%B8%8E-Redis-%E9%9B%86%E6%88%90-1"><span class="toc-number">3.</span> <span class="toc-text">Go 与 Redis 集成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%87%86%E5%A4%87-Go-%E7%8E%AF%E5%A2%83"><span class="toc-number">3.1.</span> <span class="toc-text">1. 准备 Go 环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%9E%E6%8E%A5-Redis"><span class="toc-number">3.2.</span> <span class="toc-text">2. 连接 Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9C%A8-Go-%E4%B8%AD%E6%93%8D%E4%BD%9C-Redis-%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">3. 在 Go 中操作 Redis 核心数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-String-%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1 String 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-List-%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.2 List 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Hash-%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3 Hash 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Set-%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.4.</span> <span class="toc-text">3.4 Set 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-Sorted-Set-ZSET-%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.5.</span> <span class="toc-text">3.5 Sorted Set (ZSET) 操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86-context-Context"><span class="toc-number">3.4.</span> <span class="toc-text">4. 上下文管理 (context.Context)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E8%BF%9B%E9%98%B6%E4%B8%BB%E9%A2%98%E4%B8%8E-Go-%E5%AE%9E%E6%88%98-1"><span class="toc-number">4.</span> <span class="toc-text">Redis 进阶主题与 Go 实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BA%8B%E5%8A%A1-Transactions"><span class="toc-number">4.1.</span> <span class="toc-text">1. 事务 (Transactions)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85-Pub-Sub"><span class="toc-number">4.2.</span> <span class="toc-text">2. 发布&#x2F;订阅 (Pub&#x2F;Sub)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8C%81%E4%B9%85%E5%8C%96-Persistence"><span class="toc-number">4.3.</span> <span class="toc-text">3. 持久化 (Persistence)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Lua-%E8%84%9A%E6%9C%AC"><span class="toc-number">4.4.</span> <span class="toc-text">4. Lua 脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Redis-Streams-%E6%B5%81"><span class="toc-number">4.5.</span> <span class="toc-text">5. Redis Streams (流)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%9E%E6%88%98%E6%A8%A1%E5%BC%8F-1"><span class="toc-number">5.</span> <span class="toc-text">高级应用与实战模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9E%84%E5%BB%BA%E7%BC%93%E5%AD%98%E5%B1%82-Caching"><span class="toc-number">5.1.</span> <span class="toc-text">1. 构建缓存层 (Caching)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">5.2.</span> <span class="toc-text">2. 实现分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BD%8D%E5%9B%BE-Bitmaps-%E4%B8%8E-HyperLogLogs"><span class="toc-number">5.3.</span> <span class="toc-text">3. 位图 (Bitmaps) 与 HyperLogLogs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Bitmaps-%E4%BD%8D%E5%9B%BE"><span class="toc-number">5.3.1.</span> <span class="toc-text">3.1 Bitmaps (位图)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-HyperLogLogs-HLL"><span class="toc-number">5.3.2.</span> <span class="toc-text">3.2 HyperLogLogs (HLL)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%BB%B4%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-1"><span class="toc-number">6.</span> <span class="toc-text">运维与最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Redis-%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%8E%E6%89%A9%E5%B1%95"><span class="toc-number">6.1.</span> <span class="toc-text">1. Redis 高可用与扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-Replication"><span class="toc-number">6.1.1.</span> <span class="toc-text">1.1 主从复制 (Replication)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%93%A8%E5%85%B5-Sentinel"><span class="toc-number">6.1.2.</span> <span class="toc-text">1.2 哨兵 (Sentinel)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E9%9B%86%E7%BE%A4-Cluster"><span class="toc-number">6.1.3.</span> <span class="toc-text">1.3 集群 (Cluster)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%80%A7%E8%83%BD%E4%B8%8E%E7%9B%91%E6%8E%A7"><span class="toc-number">6.2.</span> <span class="toc-text">2. 性能与监控</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Go-%E5%BC%80%E5%8F%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">6.3.</span> <span class="toc-text">3. Go 开发最佳实践</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B"><span class="toc-number">7.</span> <span class="toc-text">实际案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Pub-Sub%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.1.</span> <span class="toc-text">Pub&#x2F;Sub模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#publisher"><span class="toc-number">7.1.1.</span> <span class="toc-text">publisher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#subscriber"><span class="toc-number">7.1.2.</span> <span class="toc-text">subscriber</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.3.</span> <span class="toc-text">使用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Streams%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.2.</span> <span class="toc-text">Streams模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pub-Sub%E5%92%8C-Streams-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.2.1.</span> <span class="toc-text">Pub&#x2F;Sub和 Streams 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Pub-Sub"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">1. Pub&#x2F;Sub</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Streams"><span class="toc-number">7.2.1.2.</span> <span class="toc-text">2. Streams</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">7.2.1.3.</span> <span class="toc-text">3. 核心区别对比表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%B1%BB%E6%AF%94%E4%B8%80%E4%B8%8B"><span class="toc-number">7.2.1.4.</span> <span class="toc-text">4. 类比一下</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Producer"><span class="toc-number">7.2.2.</span> <span class="toc-text">Producer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Consumer"><span class="toc-number">7.2.3.</span> <span class="toc-text">Consumer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">7.2.4.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E9%AA%8C%E8%AF%81"><span class="toc-number">7.2.5.</span> <span class="toc-text">特性验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-Stream-%E6%B6%88%E6%81%AF-ID-%E5%92%8C-%E6%B6%88%E6%81%AF%E5%86%85%E5%AE%B9%E6%A0%BC%E5%BC%8F"><span class="toc-number">7.2.5.1.</span> <span class="toc-text">Redis Stream 消息 ID 和 消息内容格式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ID-%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%9F%E6%88%90%E7%9A%84%EF%BC%9F"><span class="toc-number">7.2.5.1.1.</span> <span class="toc-text">ID 是怎么生成的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8F%91%E9%80%81%E7%9A%84%E6%B6%88%E6%81%AF%E5%86%85%E5%AE%B9%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%BC%E5%BC%8F%EF%BC%9F"><span class="toc-number">7.2.5.1.2.</span> <span class="toc-text">2. 发送的消息内容是什么格式？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%82%A3%E4%B9%88%EF%BC%8C%E8%83%BD%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E5%8F%91-JSON%EF%BC%9F"><span class="toc-number">7.2.5.1.3.</span> <span class="toc-text">3. 那么，能不能直接发 JSON？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-number">7.2.5.1.4.</span> <span class="toc-text">4. 总结</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/12/Hexo%E6%96%B0%E5%A2%9E%E5%88%86%E7%B1%BB%E6%A0%87%E7%AD%BE%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E8%AF%A6%E8%A7%A3/" title="Hexo 新增分类、标签与自定义页面详解">Hexo 新增分类、标签与自定义页面详解</a><time datetime="2025-10-12T05:46:03.000Z" title="发表于 2025-10-12 13:46:03">2025-10-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E9%80%9A%E7%94%A8%E8%93%9D%E5%9B%BE/" title="高可用高并发后端架构通用蓝图">高可用高并发后端架构通用蓝图</a><time datetime="2025-10-08T15:42:00.000Z" title="发表于 2025-10-08 23:42:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%9F%E6%88%90/" title="AI提示词_学习笔记生成">AI提示词_学习笔记生成</a><time datetime="2025-10-08T15:15:00.000Z" title="发表于 2025-10-08 23:15:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E8%AF%95%E9%A2%98%E7%94%9F%E6%88%90/" title="AI提示词_试题生成">AI提示词_试题生成</a><time datetime="2025-10-08T15:15:00.000Z" title="发表于 2025-10-08 23:15:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/Golang_swag/" title="Golang swag 库">Golang swag 库</a><time datetime="2025-10-08T15:07:00.000Z" title="发表于 2025-10-08 23:07:00">2025-10-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/Image/topImage.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By 棨</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>