<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux 命令大全 | 柊</title><meta name="author" content="棨"><meta name="copyright" content="棨"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#59b9c6"><meta name="description" content="Linux 命令大全">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 命令大全">
<meta property="og:url" content="https://chaoqijiang.github.io/2025/07/27/Linux%20%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/index.html">
<meta property="og:site_name" content="柊">
<meta property="og:description" content="Linux 命令大全">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chaoqijiang.github.io/Image/avatar.png">
<meta property="article:published_time" content="2025-07-27T04:29:17.000Z">
<meta property="article:modified_time" content="2025-10-19T14:37:10.721Z">
<meta property="article:author" content="棨">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="protected">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chaoqijiang.github.io/Image/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux 命令大全",
  "url": "https://chaoqijiang.github.io/2025/07/27/Linux%20%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/",
  "image": "https://chaoqijiang.github.io/Image/avatar.png",
  "datePublished": "2025-07-27T04:29:17.000Z",
  "dateModified": "2025-10-19T14:37:10.721Z",
  "author": [
    {
      "@type": "Person",
      "name": "棨",
      "url": "https://chaoqijiang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chaoqijiang.github.io/2025/07/27/Linux%20%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#59b9c6')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 24 || hour >= 24
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":30,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#165e83","bgDark":"#507ea4","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux 命令大全',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/Image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴/归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/Image/topImage.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/Image/Logo.ico" alt="Logo"><span class="site-name">柊</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux 命令大全</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴/归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Linux 命令大全</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-27T04:29:17.000Z" title="发表于 2025-07-27 12:29:17">2025-07-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-19T14:37:10.721Z" title="更新于 2025-10-19 22:37:10">2025-10-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">163.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>601分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Linux-命令大全"><a href="#Linux-命令大全" class="headerlink" title="Linux 命令大全"></a>Linux 命令大全</h1><p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/cover-linux-commands-tutorial.webp" alt="Linux 命令大全"></p>
<p>这里收集并整理各种实用的 Linux 命令，大致分为如下几大类。</p>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>awk、chmod、diff、find、less、mc、patch、rm、tar、umask、wc、zip、cat、chown、echo、grep、ln、more、read、sed、tee、unzip、xz、chattr、cp、file、head、locate、mv、tail、touch、vim、zcat ……</p>
<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><p>blkid、df、eject、lsblk、mkfs、popd、stat、sync、cd、dirs、fdisk、ls、mount、pushd、rsync、swapoff、tree、dd、du、fsck、mkdir、parted、pwd、sfdisk、swapon、umount ……</p>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>bg、fg、ipcs、killall、lsof、nohup、pidof、ps、renice、top、chrt、htop、jobs、kill、nice、pgrep、pkill、taskset ……</p>
<h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><p>addgroup、delgroup、fbset、history、lsb_release、nproc、rmmod、sysctl、uptime、whois、adduser、deluser、getcap、hwclock、lscpu、passwd、screen、systemctl、useradd、who、chroot、depmod、getconf、id、lsmod、poweroff、setcap、timedatectl、userdel、chsh、dmesg、groupadd、insmod、modinfo、printenv、shutdown、time、usermod、crontab、env、groupdel、last、modprobe、sudo、type、watch、date、export、groupmod、locale、neofetch、reboot、su、unset、whoami ……</p>
<h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><p>arp、ftp、ip、nethogs、nmap、ntop、route、ss、trippy、curl、ifconfig、iptables、netstat、nmcli、ntopng、scp、tcpdump、ufw、dig、ifstat、mtr、networkctl、nm-connection-editor、ping、socat、tcptrack、wget、ethr、iftop、nc、nfsstat、nmtui、pppd、speedtest、telnet、wvdialconf、ethtool、iperf、netcat、nload、nslookup、ssh、traceroute、wvdial ……</p>
<h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p>gpiodetect、gpioinfo、i2cdetect、i2cset、lspci、minicom、ppsctl、spi-pipe、usb_modeswitch、gpiofind、gpiomon、i2cdump、i2ctransfer、lsusb、mmc、stty、xrandr、gpioget、gpioset、i2cget、lshw、microcom、modpoll、spi-config、udevadm ……</p>
<h3 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h3><p>dmidecode、free、iostat、numactl、pmap、smartctl、vmstat ……</p>
<h3 id="系统服务"><a href="#系统服务" class="headerlink" title="系统服务"></a>系统服务</h3><p>chronyc、chronyd ……</p>
<h3 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h3><p>apt-cache、apt-config、apt-get、apt、dnf、dpkg、flatpak、pkg、snap、yum ……</p>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>gcc、install、ldconfig、ldd、nm、objdump、readelf、size ……</p>
<h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><p>cyclitest、declare、hexdump、ltrace、memtester、seq、strace、timeout ……</p>
<h3 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h3><p>ascii、convert、dos2unix、gpsd、jq、phc_ctl、pv、redshift、capinfos、cwebp、dwebp、gpsmon、mergecap、pmc、qrencode、ronn、cgps、debootstrap、editcap、gpspipe、phc2sys、ptp4l ……</p>
<h3 id="音视频"><a href="#音视频" class="headerlink" title="音视频"></a>音视频</h3><p>alsamixer、amixer、aplay、arecord ……</p>
<h3 id="命令帮助"><a href="#命令帮助" class="headerlink" title="命令帮助"></a>命令帮助</h3><p>command、info、man、whatis、whereis、which ……</p>
<p>提示</p>
<p>注意：命令的选项参数和功能可能会因 Linux 发行版而有所不同，建议查阅相应发行版的文档以获取详细信息。</p>
<h1 id="Linux-apt-命令-APT软件包管理工具"><a href="#Linux-apt-命令-APT软件包管理工具" class="headerlink" title="Linux apt 命令 - APT软件包管理工具"></a>Linux apt 命令 - APT软件包管理工具</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>apt</strong>（英文全拼：Advanced Packaging Tool）是 Debian&#x2F;Ubuntu 系统中的 Shell 前端软件包管理器。该命令提供了查找、安装、升级、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
<p>提示：apt 命令执行需要超级管理员权限（root）。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt [options] [<span class="built_in">command</span>] [package ...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">options</span><br></pre></td></tr></table></figure>

<p>：可选选项，例如：</p>
<ul>
<li><code>-h</code> ：显示帮助信息。</li>
<li><code>-y</code> ：将安装过程中所有提示选择设为 yes。</li>
<li><code>-q</code> ：不显示安装的过程等等。</li>
</ul>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command</span><br></pre></td></tr></table></figure>

<p>：要进行的操作，例如：</p>
<ul>
<li><code>update</code> ：更新软件包索引信息。</li>
<li><code>upgrade</code> ：升级当前已安装的软件包（如果可更新）。</li>
<li><code>full-upgrade</code> ：升级当前已安装的软件包（升级前先删除需要更新软件包）。</li>
<li><code>install</code> ：安装软件包。</li>
<li><code>reinstall</code> ：重新安装软件包。</li>
<li><code>remove</code> ：卸载软件包（保留软件的配置文件）。</li>
<li><code>purge</code> ：卸载软件包（不保留软件的配置文件）。</li>
<li><code>autoremove</code> ：清理不再使用的依赖和库文件。</li>
<li><code>satisfy</code> ：使系统满足依赖关系字符串（Apt 1.9 的新命令）。</li>
<li><code>search</code> ：查找软件包。</li>
<li><code>show</code> ：显示软件包具体信息，例如版本号、安装大小、依赖关系等信息。</li>
<li><code>list</code> ：列出可更新的软件包及版本信息。</li>
<li><code>edit-sources</code> ：编辑 sources.list 配置文件。</li>
</ul>
</li>
<li><p><code>package</code> ：安装的包名。</p>
</li>
</ul>
<p>提示：在使用 apt 命令时，如果不太记得完整的软件包名称，可以只输入前面一部分的字符，然后按下 <strong>Tab</strong> 键自动搜索和补全。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>更新软件包索引信息（可通过该方式查看近期可更新的软件包）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure>



<p>更新软件包索引信息后升级软件包（使用 yes 选项）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt upgrade -y</span><br></pre></td></tr></table></figure>



<p>安装 vim 软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install vim</span><br></pre></td></tr></table></figure>



<p>安装 vim 软件包，如果软件包已经存在，则不要升级它</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install vim --no-upgrade</span><br></pre></td></tr></table></figure>



<p>只升级 vim 软件包，如果不存在就不要安装它</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install vim --only-upgrade</span><br></pre></td></tr></table></figure>



<p>安装指定软件包版本（<strong>package_name</strong> 为包名，<strong>version_number</strong> 为版本号。）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install &lt;package_name&gt;=&lt;version_number&gt;</span><br></pre></td></tr></table></figure>



<p>卸载 vim 软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt remove vim</span><br></pre></td></tr></table></figure>



<p>查找名为 libiphone 的相关包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt search libiphone</span><br></pre></td></tr></table></figure>



<p>查看 vim 包的相关信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt show vim</span><br></pre></td></tr></table></figure>



<p>列出所有已安装的软件包的版本信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt list --all-versions</span><br></pre></td></tr></table></figure>



<p>列出所有已安装的软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt list --installed</span><br></pre></td></tr></table></figure>



<p>列出可更新的软件包及版本信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt list --upgradeable</span><br></pre></td></tr></table></figure>





<h1 id="Linux-apt-get-命令-APT软件包管理工具"><a href="#Linux-apt-get-命令-APT软件包管理工具" class="headerlink" title="Linux apt-get 命令 - APT软件包管理工具"></a>Linux apt-get 命令 - APT软件包管理工具</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><strong>apt-get</strong> 是基于 Debian 的操作系统（包括 Debian、Ubuntu、Linux Mint 等）中用来安装和卸载软件的包管理器命令。主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。</p>
<p>注意</p>
<p>老版本的 Linux 系统只支持 apt-get 命令，在新版本的 Linux 系统中，<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/apt/">apt</a> 集成了 apt-get、apt-cache 的常用命令，因此可用 apt 命令代替 apt-get 命令。</p>
<p>提示：apt-get 命令执行需要超级管理员权限（root）。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get [options] [<span class="built_in">command</span>] [package ...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-h, --help</code>：查看帮助文档。</li>
<li><code>-v, --version</code>：查看 apt-get 的版本。</li>
<li><code>-y</code>：在需要确认的场景中回应 yes。</li>
<li><code>-s, --dry-run</code>：模拟执行并输出结果。</li>
<li><code>-d, --download-only</code>：把包下载到缓存中而不安装。</li>
<li><code>--only-upgrade</code>：更新当前版本的包而不是安装新的版本。</li>
<li><code>--no-upgrade</code>：在执行 install 命令时，不安装已安装包的更新。</li>
<li><code>-q, --quiet</code>：减少输出。</li>
<li><code>--purge</code>：配合 remove 命令删除包的配置文件。</li>
<li><code>--reinstall</code>：重新安装已安装的包或其新版本。</li>
</ul>
<p><strong>子命令</strong>：</p>
<ul>
<li><p><strong>update</strong></p>
<p>update 命令用于更新软件包索引文件，&#x2F;etc&#x2F;apt&#x2F;sources.list 文件中的配置指定了软件包索引文件的来源。更新了包索引文件后就可以得到可用的包的更新信息和新的包信息。于是系统就知道有哪些软件的哪些版本可以从什么地方（源）下载安装。在安装或升级软件包之前先执行 update 命令是一个好习惯。</p>
</li>
<li><p><strong>install</strong></p>
<p>install 命令用于安装或者升级软件包。每个软件包都有一个包名，执行子命令时需要指定包名。在安装时，该软件包所依赖的包也将被安装。</p>
</li>
<li><p><strong>upgrade</strong></p>
<p>upgrade 命令用于从 &#x2F;etc&#x2F;apt&#x2F;sources.list 中列出的源安装系统上当前安装的所有包的最新版本。在任何情况下，当前安装的软件包都不会被删除，尚未安装的软件包也不会被检索和安装。如果当前安装的软件包的新版本不能在不更改另一个软件包的安装状态的情况下升级，则将保留当前版本。必须提前执行 update 命令以便 apt-get 知道已安装的包是否有新版本可用。</p>
<p>注意 update 与 upgrade 的区别：update 是更新软件列表，upgrade 是更新软件。</p>
</li>
<li><p><strong>dist-upgrade</strong></p>
<p>除执行升级功能外，dist-upgrade 还智能地处理与新版本软件包的依赖关系的变化。apt-get 有一个 “智能” 的冲突解决系统，如果有必要，它将尝试升级最重要的包，以牺牲不那么重要的包为代价。因此，distr -upgrade 命令可能会删除一些包。因此在更新系统中的包时，建议按顺序执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get update</span><br><span class="line">$ apt-get upgrade -y</span><br><span class="line">$ apt-get dis-upgrade -y</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>remove</strong></p>
<p>remove 是 install 的反向操作，即删除软件包。值得一提的是，使用 remove 命令删除一个软件包时，会将其配置文件留在系统上。</p>
</li>
<li><p><strong>purge</strong></p>
<p>purge 命令与 remove 命令类似，purge 命令在删除包的同时也删除了包的配置文件。</p>
</li>
<li><p><strong>autoremove</strong></p>
<p>autoremove 命令用于删除自动安装的软件包，这些软件包当初是为了满足其他软件包对它的依赖关系而安装的，而现在已经不再需要了。</p>
</li>
<li><p><strong>download</strong></p>
<p>download 命令把指定包的二进制文件下载到当前目录中。注意，是类似 *.deb 这样的包文件。</p>
</li>
<li><p><strong>clean</strong></p>
<p>clean 命令清除在本地库中检索到的包。它从 &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F; 和 &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;partial&#x2F; 目录删除除锁文件之外的所有内容。</p>
</li>
<li><p><strong>autoclean</strong></p>
<p>与 clean 命令类似，autoclean 命令清除检索到的包文件的本地存储库。不同之处在于，它只删除不能再下载的软件包文件，而且这些文件在很大程度上是无用的。这允许长时间维护缓存，而不至于大小失控。</p>
</li>
<li><p><strong>source</strong></p>
<p>source 命令用于下载软件包的源代码。默认会下载最新可用版本的源代码到当前目录中。</p>
</li>
<li><p><strong>changelog</strong></p>
<p>changelog 命令尝试下载并显示软件包的更新日志。</p>
</li>
</ul>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>查看帮助文档：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get -h</span><br></pre></td></tr></table></figure>



<p>更新包索引文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br></pre></td></tr></table></figure>



<p>安装 nginx 软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install nginx</span><br></pre></td></tr></table></figure>



<p>安装 nginx 软件包，并在需要确认的场景中回应 yes：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install -y nginx</span><br></pre></td></tr></table></figure>



<p>更新指定的包（注意，不是通过 upgrade 命令完成的，而是使用 intall 命令）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install vim</span><br></pre></td></tr></table></figure>



<p>重新安装已安装的包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install --reinstall curl</span><br></pre></td></tr></table></figure>



<p>安装指定版本的包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install tree=1.7.0-5</span><br></pre></td></tr></table></figure>



<p>把包下载到缓存中而不安装（把软件包的下载和安装步骤分开）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install -d nginx</span><br><span class="line"><span class="built_in">sudo</span> apt-get upgrade -d</span><br><span class="line"><span class="built_in">sudo</span> apt-get dist-upgrade -d</span><br></pre></td></tr></table></figure>



<p>删除包（只删除程序文件，保留相关的配置文件）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get remove vim</span><br></pre></td></tr></table></figure>



<p>彻底清除包（同时删除程序文件及其配置文件）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get purge vim</span><br></pre></td></tr></table></figure>



<p>在执行 remove 命令时使用 –purge 选项的效果等同于执行 purge 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get remove --purge vim</span><br></pre></td></tr></table></figure>



<p>删除包后执行一下 autoremove，可以自动删除不再需要的软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get autoremvoe</span><br></pre></td></tr></table></figure>



<p>在执行 install&#x2F;remove 命令时使用 –autoremove 选项，可以同时删除无用的依赖包，类似在执行完 install&#x2F;remove 命令后再执行一次 autoremove 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get remove --autoremove vim</span><br></pre></td></tr></table></figure>



<p>清除系统中缓存的包安装文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get clean</span><br></pre></td></tr></table></figure>



<p>自动清除不能再下载的软件包文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get autoclean</span><br></pre></td></tr></table></figure>



<p>查看已安装包的更改日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get changelog tree</span><br></pre></td></tr></table></figure>



<p>下载包的源代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get <span class="built_in">source</span> tree</span><br></pre></td></tr></table></figure>





<h1 id="Linux-apt-config-命令-管理-APT-配置文件"><a href="#Linux-apt-config-命令-管理-APT-配置文件" class="headerlink" title="Linux apt-config 命令 - 管理 APT 配置文件"></a>Linux apt-config 命令 - 管理 APT 配置文件</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p><strong>apt-config</strong> 命令是 Debian 系操作系统（包括 Ubuntu）中用于显示或操作 APT（Advanced Package Tool）软件包管理系统配置项的工具。它允许用户查看 APT 的各种配置选项，包括软件源、包管理器的行为和其他相关设置。通过此命令，用户可以了解系统上 APT 的当前配置，并在需要时进行相应的调整。</p>
<p>提示</p>
<p>apt-config 命令主要用于 Debug 和编写 Shell 脚本。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-config [选项] 命令</span><br></pre></td></tr></table></figure>



<p><strong>常用命令</strong>：</p>
<ul>
<li><code>shell</code>：通过 shell 求值来获取设置值。</li>
<li><code>dump</code>：显示活动的设置选项。</li>
</ul>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>显示所有配置项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-config dump</span><br></pre></td></tr></table></figure>





<h1 id="Linux-apt-cache-命令-查询软件包信息"><a href="#Linux-apt-cache-命令-查询软件包信息" class="headerlink" title="Linux apt-cache 命令 - 查询软件包信息"></a>Linux apt-cache 命令 - 查询软件包信息</h1><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><p><strong>apt-cache</strong> 命令是一个用于查询 APT 软件包缓存的工具，它提供了有关已安装或可用软件包的信息，包括软件包的描述、依赖关系、版本号、可用性等。它是 Debian 和基于 Debian 的 Linux 发行版（例如 Ubuntu）中 APT 软件包管理系统的一部分。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-cache [选项] 命令</span><br><span class="line">apt-cache [选项] show 软件包1 [软件包2 ...]</span><br></pre></td></tr></table></figure>



<p><strong>常用命令</strong>：</p>
<ul>
<li><code>showsrc</code>：显示源文件的各项记录。</li>
<li><code>search</code>：根据正则表达式搜索软件包列表。</li>
<li><code>depends</code>：显示该软件包的依赖关系信息。</li>
<li><code>rdepends</code>：显示所有依赖于该软件包的软件包名字。</li>
<li><code>show</code>：以便于阅读的格式介绍该软件包。</li>
<li><code>pkgnames</code>：列出所有软件包的名字。</li>
<li><code>policy</code>：显示软件包的安装设置状态。</li>
</ul>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><p>搜索包含关键词的软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-cache search firefox</span><br></pre></td></tr></table></figure>



<p>显示特定软件包的详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-cache show firefox</span><br></pre></td></tr></table></figure>





<h1 id="Linux-dpkg-命令-管理-Debian-软件包"><a href="#Linux-dpkg-命令-管理-Debian-软件包" class="headerlink" title="Linux dpkg 命令 - 管理 Debian 软件包"></a>Linux dpkg 命令 - 管理 Debian 软件包</h1><h2 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h2><p><strong>dpkg</strong>（英文全拼：Debian package）命令是 Debian Linux 系统用来安装、创建和管理软件包的实用工具。它是 Debian 软件包管理器的基础，由伊恩·默多克创建于1993年。</p>
<p>从名称可以看出，dpkg 是专门为 Debian 开发的套件管理系统，方便软件的安装、更新及移除。实际上，所有源自 Debian 的 Linux 发行版都可以使用 dpkg 来管理软件包，例如 Ubuntu、Knoppix 等。</p>
<p>dpkg 本身是一个底层的工具，被用于安装、卸载和查询 .deb 软件包相关的信息。上层的工具，如 apt 则被用于从远程获取软件包以及处理复杂的软件包关系。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg [option...] action</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-i</code>, <code>--install</code> ：安装软件包。</li>
<li><code>-r</code>, <code>--remove</code> ：删除软件包。</li>
<li><code>-l</code>, <code>--list</code> ：显示已安装软件包列表。</li>
<li><code>-L</code>, <code>--listfiles</code> ：显示于软件包关联的文件。</li>
<li><code>-c</code> ：显示软件包内文件列表。</li>
<li><code>-?</code>, <code>--help</code> ：显示帮助信息。</li>
<li><code>--version</code> ：显示版本信息。</li>
</ul>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><p>安装软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg -i &lt;package-file&gt;</span><br><span class="line">dpkg -i helloworld_1.0.deb  # 以 helloworld_1.0.deb 软件包为例</span><br></pre></td></tr></table></figure>



<p>安装一个目录（如 &#x2F;usr&#x2F;local&#x2F;src）下面所有的软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -R /usr/local/src</span><br></pre></td></tr></table></figure>



<p>释放软件包，但是不进行配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg --unpack &lt;package-file&gt;</span><br></pre></td></tr></table></figure>



<p>重新配置和释放软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg --configure &lt;package-file&gt;</span><br></pre></td></tr></table></figure>



<p>卸载软件包（保留其配置信息）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg -r &lt;package-file&gt;</span><br></pre></td></tr></table></figure>



<p>卸载软件包（包括配置信息）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -P &lt;package-file&gt;</span><br><span class="line">dpkg --purge &lt;package-file&gt;</span><br></pre></td></tr></table></figure>



<p>列出已安装的软件包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg -l</span><br><span class="line">dpkg -l | grep helloworld # 在已安装的软件包中搜索 helloworld</span><br></pre></td></tr></table></figure>



<p>列出软件包的内容（目录信息）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg -c &lt;package-file&gt;</span><br></pre></td></tr></table></figure>



<p>从软件包里面读取软件的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -A &lt;package-file&gt;</span><br></pre></td></tr></table></figure>



<p>替代软件包的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg --update-avail [Packages-file]</span><br></pre></td></tr></table></figure>



<p>合并软件包信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg --merge-avail [Packages-file]</span><br></pre></td></tr></table></figure>



<p>丢失所有的 Uninstall 的软件包信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg --forget-old-unavail</span><br></pre></td></tr></table></figure>



<p>删除软件包的 Avaliable 信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg --clear-avail</span><br></pre></td></tr></table></figure>



<p>查找只有部分安装的软件包信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -C</span><br></pre></td></tr></table></figure>



<p>比较同一个包的不同版本之间的差别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg --compare-versions ver1 op ver2</span><br></pre></td></tr></table></figure>



<p>创建一个 deb 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -b &lt;directory&gt; &lt;package-file&gt;</span><br><span class="line">dpkg --build &lt;directory&gt; &lt;package-file&gt;</span><br></pre></td></tr></table></figure>



<p>显示一个 deb 软件包的描述信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -I &lt;package-file&gt;</span><br></pre></td></tr></table></figure>



<p>报告指定软件包的状态信息（是否已安装）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -s &lt;package-file&gt;</span><br></pre></td></tr></table></figure>



<p>显示一个软件包安装到系统里面的文件目录信息（该软件包必须已安装）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -L &lt;package-file&gt;</span><br><span class="line">dpkg -L vim <span class="comment"># 以 vim 为例</span></span><br></pre></td></tr></table></figure>



<p>搜索指定软件包里面的文件（模糊查询）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -S &lt;filename-search-pattern&gt;</span><br></pre></td></tr></table></figure>





<h1 id="Linux-dnf-命令-软件包管理工具"><a href="#Linux-dnf-命令-软件包管理工具" class="headerlink" title="Linux dnf 命令 - 软件包管理工具"></a>Linux dnf 命令 - 软件包管理工具</h1><h2 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h2><p><strong>dnf</strong>（Dandified Yum）是用于在基于 RPM 的 Linux 发行版中进行软件包管理的工具，如 Fedora、RHEL（Red Hat Enterprise Linux）以及它们的衍生发行版。值得一提的是，<code>dnf</code> 是 <code>yum</code> 的下一代版本，首次出现在 Fedora 18 这个发行版中，旨在提供更快的性能和更丰富的功能。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnf [参数]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>repolist</code>：显示系统中可用的 dnf 软件库。</li>
<li><code>list</code>：列出用户系统上的所有来自软件库的可用软件包和所有已经安装在系统上的软件包。</li>
<li><code>search &lt;包名&gt;</code>：搜索软件库中的软件包。</li>
<li><code>provides &lt;路径&gt;</code>：查找某一文件的提供者。</li>
<li><code>info &lt;包名&gt;</code>：查看软件包详情。</li>
<li><code>install &lt;包名&gt;</code>：安装软件包。</li>
<li><code>update &lt;包名&gt;</code>：升级软件包。</li>
<li><code>check-update</code>：检查系统软件包的更新。</li>
<li><code>update</code>：升级所有系统软件包。</li>
<li><code>remove</code>：删除软件包。</li>
<li><code>autoremove</code>：删除无用孤立的软件包。</li>
<li><code>clean all</code>：删除缓存的无用软件包。</li>
<li><code>help &lt;命令名&gt;</code>：获取有关某条命令的使用帮助。</li>
<li><code>help</code>：查看所有的dnf命令及其用途。</li>
<li><code>history</code>：查看dnf命令的执行历史。</li>
<li><code>grouplist</code>：查看所有的软件包组。</li>
<li><code>groupinstall &lt;软件包组名称&gt;</code>：安装一个软件包组。</li>
<li><code>groupupdate &lt;软件包组名称&gt;</code>：升级一个软件包组中的软件包。</li>
<li><code>groupremove &lt;软件包组名称&gt;</code>：删除一个软件包组。</li>
<li><code>distro-sync</code>：更新软件包到最新的稳定发行版。</li>
<li><code>reinstall &lt;包名&gt;</code>：重新安装特定软件包。</li>
<li><code>downgrade &lt;包名&gt;</code>：回滚某个特定软件的版本。</li>
<li><code>--version</code>：查看 dnf 包管理器版本。</li>
</ul>
<h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><p>安装软件包（安装指定名称的软件包及其依赖项）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnf install &lt;软件包名称&gt;</span><br></pre></td></tr></table></figure>



<p>将系统中所有已安装的软件包升级到最新版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnf upgrade</span><br></pre></td></tr></table></figure>



<p>搜索软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnf search &lt;关键词&gt;</span><br></pre></td></tr></table></figure>



<p>显示软件包信息（包括版本、依赖关系等详细信息）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnf info &lt;软件包名称&gt;</span><br></pre></td></tr></table></figure>



<p>移除软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnf remove &lt;软件包名称&gt;</span><br></pre></td></tr></table></figure>



<p>检查可用更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnf check-update</span><br></pre></td></tr></table></figure>



<p>列出已安装软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnf list installed</span><br></pre></td></tr></table></figure>



<p>清理 dnf 缓存（包括软件包和元数据）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnf clean all</span><br></pre></td></tr></table></figure>



<p>列出软件包的文件信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnf repoquery -l &lt;软件包名称&gt;</span><br></pre></td></tr></table></figure>



<p>启用&#x2F;禁用指定的软件仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnf config-manager --set-enabled &lt;仓库名称&gt;</span><br><span class="line">dnf config-manager --set-disabled &lt;仓库名称&gt;</span><br></pre></td></tr></table></figure>





<h1 id="Linux-yum-命令-管理-RPM-软件包"><a href="#Linux-yum-命令-管理-RPM-软件包" class="headerlink" title="Linux yum 命令 - 管理 RPM 软件包"></a>Linux yum 命令 - 管理 RPM 软件包</h1><h2 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h2><p><strong>yum</strong> 是用于在基于 RPM 的 Linux 发行版（例如 RHEL、CentOS、Fedora 等）中进行软件包管理的工具。其作用包括安装、升级和删除 rpm 软件包、搜索和显示软件包信息、处理软件包的依赖关系，以及管理软件源配置等。</p>
<p>提示</p>
<p>yum 是“Yellowdog Updater, Modified”的缩写，其中的 “Yellow Dog” 是指由 Fixstars 公司发布 Yellow Dog Linux 发行版（最后一个版本是2012年8月发布的 7.0）。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum [<span class="built_in">command</span>] [package ...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>install</code>：安装一个或多个 rpm 软件包。</li>
<li><code>update</code>：升级系统中所有已安装的 rpm 软件包。</li>
<li><code>check-update</code>：检查系统中所有已安装的 rpm 软件包是否有可用的更新。</li>
<li><code>remove</code>：卸载一个或多个已安装的 rpm 软件包。</li>
<li><code>list</code>：列出已安装的软件包信息。</li>
<li><code>search</code>：搜索可用的软件包。</li>
<li><code>info</code>：显示指定的 rpm 软件包的描述信息和概要信息。</li>
<li><code>clean</code>：清理 yum 过期的缓存。</li>
<li><code>shell</code>：进入 yum 的 shell 交互界面。</li>
<li><code>resolvedep</code>：显示 rpm 软件包的依赖关系。</li>
<li><code>localinstall</code>：安装本地的 rpm 软件包。</li>
<li><code>localupdate</code>：显示本地 rpm 软件包进行更新。</li>
<li><code>deplist</code>：显示 rpm 软件包的所有依赖关系。</li>
<li><code>provides</code>：查询某个程序所在安装包。</li>
</ul>
<h2 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h2><p>安装 nginx 软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install nginx</span><br></pre></td></tr></table></figure>



<p>升级所有已安装的软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum update</span><br></pre></td></tr></table></figure>



<p>删除已安装的 nginx 软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum remove nginx</span><br></pre></td></tr></table></figure>



<p>查询 nginx 软件包信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum info nginx</span><br></pre></td></tr></table></figure>



<p>搜索可用的软件包（例如 apache）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum search apache</span><br></pre></td></tr></table></figure>



<p>显示已安装软件包列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list installed</span><br></pre></td></tr></table></figure>



<p>检查系统中所有已安装软件包是否有可用的更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum check-update</span><br></pre></td></tr></table></figure>





<h1 id="Linux-pkg-命令-管理-FreeBSD-软件包"><a href="#Linux-pkg-命令-管理-FreeBSD-软件包" class="headerlink" title="Linux pkg 命令 - 管理 FreeBSD 软件包"></a>Linux pkg 命令 - 管理 FreeBSD 软件包</h1><h2 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h2><p><strong>pkg</strong> 命令是 FreeBSD 操作系统中用于管理软件包的工具，包括安装、升级、删除软件包，以及查询软件包信息等功能。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkg [<span class="built_in">command</span>] [package ...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-i, install</code>：安装一个或多个软件包。</li>
<li><code>-u, upgrade</code>：升级已安装的软件包。</li>
<li><code>-r, remove</code>：卸载一个或多个已安装的软件包。</li>
<li><code>-f, fetch</code>：下载软件包但不安装。</li>
<li><code>-l, list</code>：列出已安装的软件包。</li>
<li><code>-s, search</code>：搜索可用的软件包。</li>
<li><code>-I, info</code>：显示软件包的详细信息。</li>
<li><code>-q, query</code>：查询已安装文件属于哪个软件包。</li>
</ul>
<h2 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h2><p>安装 nginx 软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pkg install nginx</span><br></pre></td></tr></table></figure>



<p>升级系统中所有已安装的软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pkg upgrade</span><br></pre></td></tr></table></figure>



<p>卸载已安装的 nginx 软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pkg remove nginx</span><br></pre></td></tr></table></figure>



<p>查询软件包信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkg info nginx</span><br></pre></td></tr></table></figure>



<p>搜索可用的软件包（例如 apache）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkg search apache</span><br></pre></td></tr></table></figure>



<p>显示已安装软件包列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkg list</span><br></pre></td></tr></table></figure>



<p>查询 <code>/usr/local/bin/nginx</code> 文件属于哪个软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkg query %n /usr/local/bin/nginx</span><br></pre></td></tr></table></figure>





<h1 id="Linux-flatpak-命令-管理-Flatpak-应用程序"><a href="#Linux-flatpak-命令-管理-Flatpak-应用程序" class="headerlink" title="Linux flatpak 命令 - 管理 Flatpak 应用程序"></a>Linux flatpak 命令 - 管理 Flatpak 应用程序</h1><h2 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h2><p><strong>flatpak</strong> 是各种不同的 Linux 发行版上分发和运行应用程序的全新打包格式，并且使用该格式打包的软件可安全运行。你可以访问<a target="_blank" rel="noopener" href="https://flatpak.org/">官网</a>以获得关于 flatpak 打包格式的详细介绍。</p>
<p>想要在你的计算机上体验 Flatpak 格式的安装包，首先需要安装 flatpak 命令，它通常不会预先安装，但可在大多数 Linux 发行版的默认仓库中找到。例如，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install flatpak</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flatpak [OPTION...] &#123;COMMAND&#125;</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-h</code>, <code>--help</code>：显示帮助信息并退出。Show help options and exit.</li>
<li><code>-v</code>, <code>--verbose</code>：在命令处理期间打印调试信息。使用 -vv 获取更多详细信息。</li>
<li><code>--ostree-verbose</code>：在命令处理期间打印 OSTree 调试信息。</li>
<li><code>--version</code>：打印版本信息并退出。</li>
<li><code>--default-arch</code>：打印默认的体系架构（如 x86_64 ）并退出。</li>
<li><code>--supported-arches</code>：按优先顺序打印支持的体系架构并退出。</li>
<li><code>--gl-drivers</code>：打印活动的 GL 驱动程序列表并退出。</li>
</ul>
<p><strong>命令</strong>：</p>
<table>
<thead>
<tr>
<th>Flatpak 命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>flatpak build-bundle</code></td>
<td>从本地存储库创建单文件包。</td>
</tr>
<tr>
<td><code>flatpak build-commit-from</code></td>
<td>基于现有提交（可能来自另一个存储库）创建新提交。</td>
</tr>
<tr>
<td><code>flatpak build-export</code></td>
<td>从构建目录创建存储库。</td>
</tr>
<tr>
<td><code>flatpak build-finish</code></td>
<td>完成构建目录。</td>
</tr>
<tr>
<td><code>flatpak build-import-bundle</code></td>
<td>将文件包导入本地存储库。</td>
</tr>
<tr>
<td><code>flatpak build-init</code></td>
<td>初始化构建目录。</td>
</tr>
<tr>
<td><code>flatpak build-sign</code></td>
<td>签署应用程序或运行时。</td>
</tr>
<tr>
<td><code>flatpak build-update-repo</code></td>
<td>从构建目录创建存储库。</td>
</tr>
<tr>
<td><code>flatpak build</code></td>
<td>在目录中构建。</td>
</tr>
<tr>
<td><code>flatpak config</code></td>
<td>管理配置。</td>
</tr>
<tr>
<td><code>flatpak create-usb</code></td>
<td>将应用程序和&#x2F;或运行时复制到可移动媒体上。</td>
</tr>
<tr>
<td><code>flatpak document-export</code></td>
<td>将文件导出到沙盒应用程序。</td>
</tr>
<tr>
<td><code>flatpak document-info</code></td>
<td>显示有关导出文件的信息。</td>
</tr>
<tr>
<td><code>flatpak document-list</code></td>
<td>列出导出的文件。</td>
</tr>
<tr>
<td><code>flatpak document-unexport</code></td>
<td>停止导出文件。</td>
</tr>
<tr>
<td><code>flatpak permission-remove</code></td>
<td>列出权限。</td>
</tr>
<tr>
<td><code>flatpak permission-list</code></td>
<td>列出权限。</td>
</tr>
<tr>
<td><code>flatpak permission-show</code></td>
<td>列出权限。</td>
</tr>
<tr>
<td><code>flatpak permission-reset</code></td>
<td>重置权限。</td>
</tr>
<tr>
<td><code>flatpak enter</code></td>
<td>输入应用程序。</td>
</tr>
<tr>
<td><code>flatpak info</code></td>
<td>显示有关已安装应用程序或运行时的信息。</td>
</tr>
<tr>
<td><code>flatpak install</code></td>
<td>安装应用程序或运行时。</td>
</tr>
<tr>
<td><code>flatpak list</code></td>
<td>列出已安装的应用程序和&#x2F;或运行时。</td>
</tr>
<tr>
<td><code>flatpak make-current</code></td>
<td>使特定版本的应用程序成为最新版本。</td>
</tr>
<tr>
<td><code>flatpak override</code></td>
<td>覆盖应用程序要求。</td>
</tr>
<tr>
<td><code>flatpak remote-add</code></td>
<td>添加远程仓库。</td>
</tr>
<tr>
<td><code>flatpak remote-delete</code></td>
<td>删除远程仓库。</td>
</tr>
<tr>
<td><code>flatpak remote-info</code></td>
<td>在远程显示有关应用程序或运行时的信息。</td>
</tr>
<tr>
<td><code>flatpak remote-ls</code></td>
<td>显示可用的运行时和应用程序。</td>
</tr>
<tr>
<td><code>flatpak remote-modify</code></td>
<td>修改远程仓库。</td>
</tr>
<tr>
<td><code>flatpak remotes</code></td>
<td>列出远程仓库。</td>
</tr>
<tr>
<td><code>flatpak repair</code></td>
<td>修复 flatpak 安装。</td>
</tr>
<tr>
<td><code>flatpak repo</code></td>
<td>显示有关本地存储库的信息。</td>
</tr>
<tr>
<td><code>flatpak run</code></td>
<td>在 runtime 中运行应用程序或打开 shell。</td>
</tr>
<tr>
<td><code>flatpak search</code></td>
<td>搜索应用程序和运行时。</td>
</tr>
<tr>
<td><code>flatpak uninstall</code></td>
<td>卸载应用程序或运行时。</td>
</tr>
<tr>
<td><code>flatpak update</code></td>
<td>更新应用程序或运行时。</td>
</tr>
</tbody></table>
<h2 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h2><p>列出在系统中已经配置好远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flatpak remotes</span><br></pre></td></tr></table></figure>



<p>使用 <code>.flatpakrepo</code> 文件添加远程仓库：（ <code>.flatpakrepo</code> 文件包含远程仓库的信息和 GPG 秘钥）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flatpak remote-add --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo</span><br></pre></td></tr></table></figure>



<p>移除远程仓库 flathub：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flatpak remote-delete flathub</span><br></pre></td></tr></table></figure>



<p>查找远程仓库中的 GIMP 应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flatpak search gimp</span><br></pre></td></tr></table></figure>



<p>以 Flatpak 包的形式安装 GIMP 图像处理软件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flatpak install https://flathub.org/repo/appstream/org.gimp.GIMP.flatpakref</span><br></pre></td></tr></table></figure>





<h1 id="Linux-snap-命令-管理-Snap-应用包"><a href="#Linux-snap-命令-管理-Snap-应用包" class="headerlink" title="Linux snap 命令 - 管理 Snap 应用包"></a>Linux snap 命令 - 管理 Snap 应用包</h1><h2 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h2><p><strong>Snap</strong> 是 Canonical（开发 Ubuntu 系统的公司）推出的一种新的软件打包格式，其目的是为了彻底解决 Linux 依赖性的问题，Snap 软件包拥有更加稳定和安全的特性。同时，snap 也是 Linux 上安装 snap 软件包的命令。</p>
<p>如果你使用的是 Ubuntu 16.04 LTS 或更高版本，那么可以直接使用 snap 命令，无需额外安装。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap &lt;<span class="built_in">command</span>&gt; [&lt;options&gt;...]</span><br></pre></td></tr></table></figure>



<h2 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h2><p>snap 显示已安装的 snap 软件的基本信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap list</span><br></pre></td></tr></table></figure>



<p>snap 搜索包（在应用商店搜索）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap find &lt;package_name&gt;</span><br></pre></td></tr></table></figure>



<p>snap 安装一个包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap install &lt;package_name&gt;</span><br></pre></td></tr></table></figure>



<p>snap 更新所有软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap refresh</span><br></pre></td></tr></table></figure>



<p>snap 更新指定软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap refresh &lt;package_name&gt;</span><br></pre></td></tr></table></figure>



<p>snap 卸载软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap remove &lt;package_name&gt;</span><br></pre></td></tr></table></figure>



<p>snap 检查系统中最近的快照更改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap changes</span><br></pre></td></tr></table></figure>



<p>snap 还原到以前安装的版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snap revert &lt;package_name&gt;</span><br></pre></td></tr></table></figure>



<p>注意：部分 snap 命令需要添加 sudo 增加 root 权限。</p>
<h1 id="Linux-man-命令-查看命令手册页"><a href="#Linux-man-命令-查看命令手册页" class="headerlink" title="Linux man 命令 - 查看命令手册页"></a>Linux man 命令 - 查看命令手册页</h1><h2 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h2><p><strong>man</strong>（英文全拼：manuals）命令用于列出指定命令的说明文档，内容包括命令描述、语法、选项说明及相关命令等。</p>
<p>实际上，man 不仅可用于查看命令的使用手册，也可以查看软件服务配置文件、系统调用、库函数等帮助信息。</p>
<p>man 手册页文件存放在 &#x2F;usr&#x2F;share&#x2F;man 目录下。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man [选项...] [章节] 手册页...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-f</code>, <code>--whatis</code> ：等同于 whatis。</li>
<li><code>-k</code>, <code>--apropos</code> ：等同于 apropos。</li>
<li><code>-K</code>, <code>--global-apropos</code> ：在所有页面中搜索文字。</li>
<li><code>-l</code>, <code>--local-file</code> ：把“手册页”参数当成本地文件名来解读。</li>
<li><code>-w</code>, <code>--where</code>, <code>--path</code>, <code>--location</code> ：输出手册页的物理位置。</li>
<li><code>-W</code>, <code>--where-cat</code>, <code>--location-cat</code> ：输出 cat 文件的物理位置。</li>
<li><code>-c</code>, <code>--catman</code> ：由 catman 使用，用来对过时的 cat 页重新排版。</li>
<li><code>-R</code>, <code>--recode=编码</code> ：以指定编码输出手册页源码。</li>
</ul>
<p><strong>章节</strong>：</p>
<table>
<thead>
<tr>
<th>章节号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>可执行程序或 shell 命令</td>
</tr>
<tr>
<td>2</td>
<td>系统调用（内核提供的函数）</td>
</tr>
<tr>
<td>3</td>
<td>库调用（程序库中的函数）</td>
</tr>
<tr>
<td>4</td>
<td>特殊文件（通常位于 &#x2F;dev）</td>
</tr>
<tr>
<td>5</td>
<td>文件格式和约定，例如 &#x2F;etc&#x2F;passwd</td>
</tr>
<tr>
<td>6</td>
<td>游戏</td>
</tr>
<tr>
<td>7</td>
<td>杂项（包括宏包和规范，如 man(7)，groff(7)）</td>
</tr>
<tr>
<td>8</td>
<td>系统管理命令（通常只针对 root 用户）</td>
</tr>
<tr>
<td>9</td>
<td>内核例程 （非标准）</td>
</tr>
</tbody></table>
<h2 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h2><p>查看 man 命令本身的用法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man man</span><br></pre></td></tr></table></figure>



<p>将会打开一个字符阅读器，按 Enter 键或 Down 键逐行下翻，按 Up 键逐行上翻，按 q 键退出。</p>
<p>查看 cp 命令的用法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man <span class="built_in">cp</span></span><br></pre></td></tr></table></figure>



<p>查看 &#x2F;etc&#x2F;passwd 文件信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man /etc/passwd</span><br></pre></td></tr></table></figure>



<p>查看 chown 函数的用法（而不是 chown 命令，数字 2 指定章节不可忽略）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man 2 <span class="built_in">chown</span></span><br></pre></td></tr></table></figure>



<p>查看线程创建函数的用法（数字 3 指定章节可忽略）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man 3 pthread_create</span><br></pre></td></tr></table></figure>





<h1 id="Linux-info-命令-查看命令和程序的文档"><a href="#Linux-info-命令-查看命令和程序的文档" class="headerlink" title="Linux info 命令 - 查看命令和程序的文档"></a>Linux info 命令 - 查看命令和程序的文档</h1><h2 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍"></a>介绍</h2><p><strong>info</strong>（英文全拼：informations）命令用于阅读 Linux 下 info 格式的帮助信息。</p>
<p>就内容来说，info 页面比 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/man/">man</a> page 编写得要更好、更容易理解，也更友好，并支持链接跳转功能。但 man page 使用起来更容易，一个 man page 只有一页，而 info 页面则将内容组织成多个区段（称为节点），每个区段也可能包含子区段（称为子节点）。因此掌握 info 命令，需要学习如何在单独的 info 页面中浏览导航，以及如何在节点和子节点之间切换。</p>
<p>info 文档存放在 &#x2F;usr&#x2F;share&#x2F;info 目录中，该目录提供了整个软件包的帮助文档。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">info [选项] [参数]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-d</code> ：添加包含 info 格式帮助文档的目录。</li>
<li><code>-f</code> ：指定要读取的 info 格式的帮助文档。</li>
<li><code>-n</code> ：指定首先访问的 info 帮助文件的节点。</li>
<li><code>-o</code> ：输出被选择的节点内容到指定文件。</li>
<li><code>-w</code> ：显示 info 文档的物理位置。</li>
</ul>
<p><strong>参数</strong>：指定需要获得帮助的主题，可以是指令、函数或配置文件。</p>
<h2 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h2><p>查看 Automake 手册</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">info Automake</span><br></pre></td></tr></table></figure>



<p>查看 info 命令本身的 info 文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">info info</span><br></pre></td></tr></table></figure>



<p>显示 ls 命令 info 文档的位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">info -w <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>





<h1 id="Linux-whatis-命令-显示命令简要说明"><a href="#Linux-whatis-命令-显示命令简要说明" class="headerlink" title="Linux whatis 命令 - 显示命令简要说明"></a>Linux whatis 命令 - 显示命令简要说明</h1><h2 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍"></a>介绍</h2><p><strong>whatis</strong> 命令是用于查询一个命令执行什么功能，并将查询结果打印到终端上。</p>
<p>whatis 命令在用 <code>catman</code> 命令创建的数据库中查找选项参数中指定的命令、系统调用、库函数或特殊文件名。实际上，whatis 命令显示手册部分的页眉行，等同于使用 <code>man -f</code> 命令。</p>
<p>简单来说，如果你想知道某个不熟悉命令是干什么用的，那么可以使用 whatis 命令来快速查看。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">whatis [选项...] 关键词...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-d</code>, <code>--debug</code> ：输出调试信息。</li>
<li><code>-v</code>, <code>--verbose</code> ：输出详细的警告信息。</li>
<li><code>-r</code>, <code>--regex</code> ：把每个关键词都当作正则表达式解读。</li>
<li><code>-w</code>, <code>--wildcard</code> ：关键词里包含通配符。</li>
<li><code>-l</code>, <code>--long</code> ：不要把输出按终端宽度截断。</li>
<li><code>-C</code>, <code>--config-file=文件</code> ：使用该用户设置文件。</li>
<li><code>-L</code>, <code>--locale=区域</code> ：定义本次搜索所使用的区域设置。</li>
<li><code>-m</code>, <code>--systems=系统</code> ：使用来自其它系统的手册页。</li>
<li><code>-M</code>, <code>--manpath=路径</code> ：设置搜索手册页的路径为 PATH。</li>
<li><code>-s</code>, <code>--sections=列表</code>, <code>--section=列表</code> ：仅在这些分区中搜索（冒号分隔）。</li>
<li><code>-?</code>, <code>--help</code> ：显示帮助列表。</li>
<li><code>--usage</code> ：显示一份简洁的用法信息。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息。</li>
</ul>
<h2 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h2><p>查看 ls 命令的功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ whatis <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">ls</span> (1)               - list directory contents</span><br></pre></td></tr></table></figure>



<p>查看 cp 命令的功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ whatis <span class="built_in">cp</span></span><br><span class="line"><span class="built_in">cp</span> (1)               - copy files and directories</span><br></pre></td></tr></table></figure>



<p>查看 chown 命令的功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ whatis <span class="built_in">chown</span></span><br><span class="line"><span class="built_in">chown</span> (1)            - change file owner and group</span><br><span class="line"><span class="built_in">chown</span> (2)            - change ownership of a file</span><br></pre></td></tr></table></figure>



<p>查看 man 命令的功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ whatis man</span><br><span class="line">man (1)              - an interface to the system reference manuals</span><br><span class="line">man (7)              - macros to format man pages</span><br></pre></td></tr></table></figure>





<h1 id="Linux-whereis-命令-查找命令的路径和相关文件"><a href="#Linux-whereis-命令-查找命令的路径和相关文件" class="headerlink" title="Linux whereis 命令 - 查找命令的路径和相关文件"></a>Linux whereis 命令 - 查找命令的路径和相关文件</h1><h2 id="介绍-13"><a href="#介绍-13" class="headerlink" title="介绍"></a>介绍</h2><p><strong>whereis</strong> 命令用来定位命令的二进制程序、源代码文件和 man 手册页等相关文件的路径。</p>
<p>whereis 命令查找速度非常快，因为它不是在磁盘中乱找，而是在一个数据库中查询；数据库是 linux 系统自动创建的，包含有本地所有文件的信息，并且每天通过自动执行 updatedb 命令更新一次。正因为这样，whereis 命令的搜索结果有时候会不准确，比如刚添加的文件可能搜不到， 原因就是该数据库文件没有被更新。</p>
<p>注意：该指令只能用于查找二进制文件、源代码文件和 man手册页，一般文件的定位需使用 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/locate/">locate</a> 命令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">whereis [options] [-BMS directory... -f] name...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-b</code> ：只查找二进制文件。</li>
<li><code>-B &lt;目录&gt;</code> ：只在设置的目录下查找二进制文件。</li>
<li><code>-f</code> ：不显示文件名前的路径名称。</li>
<li><code>-m</code> ：只查找说明文件。</li>
<li><code>-M &lt;目录&gt;</code> ：只在设置的目录下查找说明文件。</li>
<li><code>-s</code> ：只查找原始代码文件。</li>
<li><code>-S &lt;目录&gt;</code> ：只在设置的目录下查找原始代码文件。</li>
<li><code>-u</code> ：查找不包含指定类型的文件。</li>
</ul>
<h2 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h2><p>查看 ssh 程序的位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ whereis ssh</span><br><span class="line">ssh: /usr/bin/ssh /etc/ssh /usr/share/man/man1/ssh.1.gz</span><br></pre></td></tr></table></figure>



<p>查看 ssh 的二进制程序的路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ whereis -b ssh</span><br><span class="line">ssh: /usr/bin/ssh /etc/ssh</span><br></pre></td></tr></table></figure>



<p>查看 ssh 命令的 man 手册页的路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ whereis -m ssh</span><br><span class="line">ssh: /usr/share/man/man1/ssh.1.gz</span><br></pre></td></tr></table></figure>





<h1 id="Linux-which-命令-查找命令的完整路径"><a href="#Linux-which-命令-查找命令的完整路径" class="headerlink" title="Linux which 命令 - 查找命令的完整路径"></a>Linux which 命令 - 查找命令的完整路径</h1><h2 id="介绍-14"><a href="#介绍-14" class="headerlink" title="介绍"></a>介绍</h2><p><strong>which</strong> 命令的作用是在 PATH 变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p>
<p>运维人员在日常工作中经常使用 which 命令来检查某个系统命令是否存在，或者找出所执行命令所对应的具体位置。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> [-a] filename ...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code> ：显示所有匹配的路径名</li>
</ul>
<h2 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h2><p>查找 mysql 命令的路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">which</span> mysql</span><br><span class="line">/usr/bin/mysql</span><br></pre></td></tr></table></figure>



<p>查看所有匹配 mysql 的路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">which</span> -a mysql</span><br><span class="line">/usr/bin/mysql</span><br><span class="line">/bin/mysql</span><br></pre></td></tr></table></figure>





<h1 id="Linux-command-命令-执行外部命令"><a href="#Linux-command-命令-执行外部命令" class="headerlink" title="Linux command 命令 - 执行外部命令"></a>Linux command 命令 - 执行外部命令</h1><h2 id="介绍-15"><a href="#介绍-15" class="headerlink" title="介绍"></a>介绍</h2><p><strong>command</strong> 命令用于执行一个简单命令或者显示命令的相关信息。command 命令可带 ARGS 参数运行指定的命令且抑制 shell 函数查询或显示。也就是说，当系统内定义了与 Linux 命令相同的函数时，使用 command 命令忽略 shell 函数，而执行相应的 Linux 命令。</p>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> [-pVv] 命令 [参数 ...]</span><br></pre></td></tr></table></figure>



<p><strong>选项：</strong></p>
<ul>
<li><code>-p</code>：搜索命令对应的路径，使用 PATH 变量的一个默认值以确保所有的标准工具都能被找到。</li>
<li><code>-V</code>：不执行命令，而是搜索命令并打印命令的详细描述。</li>
<li><code>-v</code>：不执行命令，但搜索命令和打印命令的描述，和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/type/">type</a> 内建命令相似。</li>
</ul>
<h2 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h2><p>使用 command 命令调用执行 echo 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">command</span> <span class="built_in">echo</span> GetIoT.tech</span><br><span class="line">GetIoT.tech</span><br></pre></td></tr></table></figure>



<p>搜索 nvm 命令，可用作检查 nvm 是否安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">command</span> -v nvm</span><br><span class="line">nvm</span><br></pre></td></tr></table></figure>



<p>搜索 free 命令并显示详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">command</span> -V free</span><br><span class="line">free 是 /usr/bin/free</span><br></pre></td></tr></table></figure>



<p>搜索 fdisk 命令对应的路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">command</span> -p fdisk</span><br><span class="line">命令 <span class="string">&#x27;fdisk&#x27;</span> 可在以下位置找到</span><br><span class="line"> * /sbin/fdisk</span><br><span class="line"> * /usr/sbin/fdisk</span><br><span class="line">fdisk：未找到命令</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ascii-命令-显示字符的-ASCII-码"><a href="#Linux-ascii-命令-显示字符的-ASCII-码" class="headerlink" title="Linux ascii 命令 - 显示字符的 ASCII 码"></a>Linux ascii 命令 - 显示字符的 ASCII 码</h1><h2 id="介绍-16"><a href="#介绍-16" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ascii</strong> 命令用于查询 <a target="_blank" rel="noopener" href="https://getiot.tech/computerbasics/ascii/">ASCII 码字符</a> 与字节（数字）的对应关系。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ascii [-dxohv] [-t] [char-alias...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-t</code> ：脚本友好模式，仅返回字符的 ISO、十进制、十六进制、八进制、二进制编码。</li>
<li><code>-s</code> ：解析多个字符，解析字符串的便捷方式。</li>
<li><code>-a</code> ：以垂直方向（4 列 x 16 行）而不是默认的 16 行 x 4 列打印。此选项仅与 -d -o -x -b 组合，并且必须在它们之前。</li>
<li><code>-d</code> ：以十进制输出 ASCII 表。</li>
<li><code>-x</code> ：以十六进制输出 ASCII 表。</li>
<li><code>-o</code> ：以八进制输出 ASCII 表。</li>
<li><code>-b</code> ：以二进制输出 ASCII 表。</li>
<li><code>-h</code>, <code>-?</code> ：显示帮助信息，并输出一个简单的 ASCII 表。</li>
<li><code>-v</code> ：显示版本信息。</li>
</ul>
<p><strong>参数</strong>：字符或字符串。</p>
<h2 id="示例-16"><a href="#示例-16" class="headerlink" title="示例"></a>示例</h2><p>以十进制输出 ASCII 表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ascii -d</span><br></pre></td></tr></table></figure>



<p>输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> 0 NUL    16 DLE    32      48 0    64 @    80 P    96 `   112 p </span><br><span class="line"> 1 SOH    17 DC1    33 !    49 1    65 A    81 Q    97 a   113 q </span><br><span class="line"> 2 STX    18 DC2    34 <span class="string">&quot;    50 2    66 B    82 R    98 b   114 r </span></span><br><span class="line"><span class="string"> 3 ETX    19 DC3    35 #    51 3    67 C    83 S    99 c   115 s </span></span><br><span class="line"><span class="string"> 4 EOT    20 DC4    36 $    52 4    68 D    84 T   100 d   116 t </span></span><br><span class="line"><span class="string"> 5 ENQ    21 NAK    37 %    53 5    69 E    85 U   101 e   117 u </span></span><br><span class="line"><span class="string"> 6 ACK    22 SYN    38 &amp;    54 6    70 F    86 V   102 f   118 v </span></span><br><span class="line"><span class="string"> 7 BEL    23 ETB    39 &#x27;    55 7    71 G    87 W   103 g   119 w </span></span><br><span class="line"><span class="string"> 8 BS     24 CAN    40 (    56 8    72 H    88 X   104 h   120 x </span></span><br><span class="line"><span class="string"> 9 HT     25 EM     41 )    57 9    73 I    89 Y   105 i   121 y </span></span><br><span class="line"><span class="string">10 LF     26 SUB    42 *    58 :    74 J    90 Z   106 j   122 z </span></span><br><span class="line"><span class="string">11 VT     27 ESC    43 +    59 ;    75 K    91 [   107 k   123 &#123; </span></span><br><span class="line"><span class="string">12 FF     28 FS     44 ,    60 &lt;    76 L    92 \   108 l   124 | </span></span><br><span class="line"><span class="string">13 CR     29 GS     45 -    61 =    77 M    93 ]   109 m   125 &#125; </span></span><br><span class="line"><span class="string">14 SO     30 RS     46 .    62 &gt;    78 N    94 ^   110 n   126 ~ </span></span><br><span class="line"><span class="string">15 SI     31 US     47 /    63 ?    79 O    95 _   111 o   127 DEL</span></span><br></pre></td></tr></table></figure>



<p>查询字符 R 对应的 ASCII 编码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ascii -t <span class="string">&quot;R&quot;</span></span><br><span class="line">5/2   82   0x52   0o122   01010010</span><br></pre></td></tr></table></figure>



<p>其中第一列表示字符 R 位于 ASCII 表的第5列第2行（从0开始），第二列表示其对应的十进制编码，第三列表示其对应的十六进制编码，第四列表示其对应的八进制编码，第五列表示其对应的二进制编码。</p>
<p>查询字符串 “getiot” 对应的 ASCII 编码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ascii -s <span class="string">&quot;getiot&quot;</span></span><br><span class="line">6/7   103   0x67   0o147   01100111</span><br><span class="line">6/5   101   0x65   0o145   01100101</span><br><span class="line">7/4   116   0x74   0o164   01110100</span><br><span class="line">6/9   105   0x69   0o151   01101001</span><br><span class="line">6/15   111   0x6F   0o157   01101111</span><br><span class="line">7/4   116   0x74   0o164   01110100</span><br></pre></td></tr></table></figure>





<h1 id="Linux-convert-命令-图像格式转换工具"><a href="#Linux-convert-命令-图像格式转换工具" class="headerlink" title="Linux convert 命令 - 图像格式转换工具"></a>Linux convert 命令 - 图像格式转换工具</h1><h2 id="介绍-17"><a href="#介绍-17" class="headerlink" title="介绍"></a>介绍</h2><p><strong>convert</strong> 命令用于对图像进行转换，支持包括转换图像格式、调整图像大小、模糊、裁剪、翻转、合并等功能。</p>
<p>convert 命令由 <a target="_blank" rel="noopener" href="https://imagemagick.org/index.php">ImageMagick</a> 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install imagemagick</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert [input-option] input-file [output-option] output-file</span><br></pre></td></tr></table></figure>



<h2 id="示例-17"><a href="#示例-17" class="headerlink" title="示例"></a>示例</h2><p>Convert 的 resize 子命令应该是在 ImageMagick 中使用较多的命令，它实现了图片任意大小的缩放，唯一需要掌握的就是如何使用它的一些参数测试设定值：</p>
<p>此说明文件中所用的原始文件（src.png），宽度：400，高度：300</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file src.png </span><br><span class="line">src.png: PNG image data, 400 x 300, 8-bit/color RGB, non-interlaced</span><br></pre></td></tr></table></figure>



<p>命令格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-resize &#123;width&#125;x&#123;height&#125;&#123;%&#125; &#123;@&#125; &#123;!&#125; &#123;&lt;&#125; &#123;&gt;&#125; &#123;^&#125;</span><br></pre></td></tr></table></figure>



<p>默认时，宽度和高度表示要最终需要转换图像的最大尺寸，同时 convert 会控制图片的宽和高，保证图片按比例进行缩放。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert -resize 200x150 src.png dst.png</span><br></pre></td></tr></table></figure>



<p>转换后的 dst.png 的图片大小（宽度为 200，而高度已经按比例调整为 150）。也可以只指定宽度或者高度，按比例对图片进行缩放。</p>
<p>只指定宽度：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert -resize 200 src.png dst.png</span><br></pre></td></tr></table></figure>



<p>只指定高度：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert -resize x150 src.png dst.png</span><br></pre></td></tr></table></figure>



<p>如果需要转换成 200x200，而图片无需保持原有比例，可以在宽高后面加上一个感叹号 !。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert -resize 200x200! src.png dst.png</span><br></pre></td></tr></table></figure>



<p>默认都是使用像素作为单位，也可以使用百分比来形象图片的缩放。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert -resize 50%x100%! src.png dst.png</span><br></pre></td></tr></table></figure>



<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert -resize 50%x100% src.png dst.png</span><br></pre></td></tr></table></figure>



<p>此参数只会按你的比例计算后缩放，不保持原有比例。（结果尺寸为 200×300）</p>
<p>使用 @ 来指定图片的像素个数。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert -resize <span class="string">&quot;10000@&quot;</span> src.png dst.png</span><br></pre></td></tr></table></figure>



<p>此命令执行后，dst.png 图片大小为（115×86），图片保持原有比例（115×86 &#x3D; 9080 &lt; 10000）。</p>
<p>当原始文件大于指定的宽高时，才进行图片放大缩小，可使用 &gt; 命令后缀。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert -resize <span class="string">&quot;200x100&gt;&quot;</span> src.png dst.png</span><br></pre></td></tr></table></figure>



<p>此命令执行后，dst.png 图片大小为（133×100），图片保持原有比例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert -resize <span class="string">&quot;200x100&gt;!&quot;</span> src.png dst.png</span><br></pre></td></tr></table></figure>



<p>此命令执行后，dst.jpg 图片大小为（100×50），图片不保持原有比例。</p>
<p>当原始文件小于指定的宽高时，才进行图片放大转换，可使用 &lt; 命令后缀。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert -resize <span class="string">&quot;100x500&lt;&quot;</span> src.png dst.png </span><br></pre></td></tr></table></figure>



<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert -resize <span class="string">&quot;100x100&lt;!&quot;</span> src.png dst.png</span><br></pre></td></tr></table></figure>



<p>此命令执行后，dst.png 和 src.png 大小相同，因为原始图片宽比 100 大。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert -resize <span class="string">&quot;600x600&lt;&quot;</span> src.png dst.png</span><br></pre></td></tr></table></figure>



<p>此命令执行后，dst.png 图片大小为（600×450），图片保持原有比例。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert -resize <span class="string">&quot;600x600&lt;!&quot;</span> src.png dst.png</span><br></pre></td></tr></table></figure>



<p>此命令执行后，dst.png 图片大小为（600×600），图片不保持原有比例。</p>
<p>使用 ^ 命令后缀可以使用宽高中较小的那个值作为尺寸。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert -resize <span class="string">&quot;600x600^&quot;</span> src.png dst.png</span><br></pre></td></tr></table></figure>



<p>此命令执行后，dst.png 图片大小为（800×600），图片保持原有比例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert -resize <span class="string">&quot;600x400^&quot;</span> src.png dst.png</span><br></pre></td></tr></table></figure>



<p>此命令执行后，dst.png 图片大小为（600×450），图片保持原有比例。</p>
<h1 id="Linux-qrencode-命令-生成二维码的工具"><a href="#Linux-qrencode-命令-生成二维码的工具" class="headerlink" title="Linux qrencode 命令 - 生成二维码的工具"></a>Linux qrencode 命令 - 生成二维码的工具</h1><h2 id="介绍-18"><a href="#介绍-18" class="headerlink" title="介绍"></a>介绍</h2><p><strong>qrencode</strong>（英文全拼：QR Encode）命令用于根据输入文本生成二维码，可保存为 PNG 或 EPS 格式图片。</p>
<p>在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install qrencode</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qrencode [OPTION]...  [STRING]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-o</code>, <code>--output=FILENAME</code> ：将图像输出到 FILENAME 文件，如果指定 <code>-</code> 则输出到标准输出。</li>
<li><code>-r</code>, <code>--read-from=FILENAME</code> ：从 FILENAME 文件读取输入数据。</li>
<li><code>-s</code>, <code>--size=NUMBER</code> ：指定二维码中每个点的像素大小（默认为 3）。</li>
<li><code>-m</code>, <code>--margin=NUMBER</code> ：指定 margin 宽度（默认为 4）</li>
<li><code>-d</code>, <code>--dpi=NUMBER</code> ：指定生成 PNG 图片的 DPI（默认为 72）</li>
<li><code>-t</code>, <code>--type=TYPE</code> ：指定生成的图片类型（默认为 PNG），支持参数包括 PNG、PNG32、EPS、SVG、XPM、ANSI、ANSI256、ASCII、ASCIIi、UTF8、ANSIUTF8。</li>
<li><code>-i</code>, <code>--ignorecase</code> ：忽略大小写区别，仅使用大写字母。</li>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息。</li>
</ul>
<p><strong>参数</strong>：字符串 STRING，如果没有给定则从标准输入获取</p>
<h2 id="示例-18"><a href="#示例-18" class="headerlink" title="示例"></a>示例</h2><p>根据 URL 在标准输出生成二维码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;https://getiot.tech&quot; | qrencode -o - -t ANSI</span><br></pre></td></tr></table></figure>



<p>生成二维码图片</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qrencode -o qrcode.png &#x27;https://getiot.tech&#x27;</span><br></pre></td></tr></table></figure>



<p>如下：</p>
<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/qrcode.png" alt="img"></p>
<p>指定生成图片的像素尺寸</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qrencode -s 4 -o qrcode.png &#x27;https://getiot.tech&#x27;</span><br></pre></td></tr></table></figure>





<h1 id="Linux-dos2unix-命令-转换文本文件格式"><a href="#Linux-dos2unix-命令-转换文本文件格式" class="headerlink" title="Linux dos2unix 命令 - 转换文本文件格式"></a>Linux dos2unix 命令 - 转换文本文件格式</h1><h2 id="介绍-19"><a href="#介绍-19" class="headerlink" title="介绍"></a>介绍</h2><p><strong>dos2unix</strong> 是一个 DOS&#x2F;Mac - Unix 文件格式转换器。</p>
<p>Windows 格式文件的换行符是 <code>\r\n</code>，而 Linux 使用的换行符是 <code>\n</code>。dos2unix 命令其实就是将文件中的 <code>\r\n</code> 转换为 <code>\n</code>。</p>
<p>Dos2unix 软件包包括两个工具 —— dos2unix 和 unix2dos，用于将纯文本文件在 DOS 或 Mac 格式与 Unix 格式之间相互转换。在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install dos2unix</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dos2unix [options] [file ...] [-n infile outfile ...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>--allow-chown</code> ：允许修改文件所有者。</li>
<li><code>-ascii</code> ：只转换换行符（默认）。</li>
<li><code>-iso</code> ：在 DOS 和 ISO-8859-1 字符集之间转换。</li>
<li><code>-7</code> ：转换 8 位字符到 7 位空间。</li>
<li><code>-b</code>, <code>--keep-bom</code> ：保留 UTF-8 BOM 头。</li>
<li><code>-c</code>, <code>--convmode &lt;convmode&gt;</code> ：转换模式 convmode 包括 ascii、7bit、iso 或 mac，默认为 ascii。</li>
<li><code>-f</code>, <code>--force</code> ：强制转换二进制文件。</li>
<li><code>-h</code>, <code>--help</code> ：显示本说明文字</li>
<li><code>-i</code>, <code>--info[=FLAGS] &lt;file&gt;</code> ：显示文件信息，file 是需要分析的文件。</li>
<li><code>-k</code>, <code>--keepdate</code> ：保留输出文件时间。</li>
<li><code>-L</code>, <code>--license</code> ：显示软件协议。</li>
<li><code>-l</code>, <code>--newline</code> ：加入额外的换行符。</li>
<li><code>-m</code>, <code>--add-bom</code> ：添加 UTF-8 BOM头（默认为UTF-8）。</li>
<li><code>-n</code>, <code>--newfile &lt;infile&gt; &lt;outfile&gt;</code> ：写入新文件，infile 为新文件模式中的原始文件，outfile 为新文件模式中的输出文件。</li>
<li><code>--no-allow-chown</code> ：不允许修改文件所有者（默认选项）。</li>
<li><code>-o</code>, <code>--oldfile &lt;file&gt;</code> ：写入原文件（默认），file 为旧文件模式中要转换的文件。</li>
<li><code>-q</code>, <code>--quiet</code> ：安静模式，不显示所有警告。</li>
<li><code>-r</code>, <code>--remove-bom</code> ：移除 UTF-8 BOM 头（默认）。</li>
<li><code>-s</code>, <code>--safe</code> ：跳过二进制文件（默认）。</li>
<li><code>-u</code>, <code>--keep-utf16</code> ：保留 UTF-16 编码。</li>
<li><code>-ul</code>, <code>--assume-utf16le</code> ：假定输入文件格式为 UTF-16LE。</li>
<li><code>-ub</code>, <code>--assume-utf16be</code> ：假定输入文件格式为 UTF-16BE。</li>
<li><code>-v</code>, <code>--verbose</code> ：显示更多信息。</li>
<li><code>-F</code>, <code>--follow-symlink</code> ：根据符号链接转换其目标文件。</li>
<li><code>-R</code>, <code>--replace-symlink</code> ：取代符号链接为转换后的文件（原链接目标文件保持不变）。</li>
<li><code>-S</code>, <code>--skip-symlink</code> ：保持符号链接及其目标不变（默认）。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本号。</li>
</ul>
<h2 id="示例-19"><a href="#示例-19" class="headerlink" title="示例"></a>示例</h2><p>在源文件基础上将此文件从 dos 格式转换为 unix 格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dos2unix book.csv</span><br></pre></td></tr></table></figure>



<p>保留源文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dos2unix -n book.csv newbook.csv</span><br></pre></td></tr></table></figure>



<p>不改变转换后文件的时间戳</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dos2unix -k book.csv</span><br></pre></td></tr></table></figure>



<p>静默转换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dos2unix -q book.csv</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ronn-命令-转换-Markdown-为-man-页"><a href="#Linux-ronn-命令-转换-Markdown-为-man-页" class="headerlink" title="Linux ronn 命令 - 转换 Markdown 为 man 页"></a>Linux ronn 命令 - 转换 Markdown 为 man 页</h1><h2 id="介绍-20"><a href="#介绍-20" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ronn</strong> 命令用于将 markdown 文档（roff 格式）转换成 Linux 标准的 manpages 帮助文档。</p>
<p>ronn-format 基于 markdown，但包含额外的规则和语法，用于编写手册。关于 ronn-format 的介绍可以通过 <code>man ronn-format</code> 获取。</p>
<p>在默认模式下，ronn 将一个或多个输入文件转换为 HTML 或 roff 输出文件。–roff、–html 和 –fragment 选项指示生成哪些输出文件。可以指定多个格式参数来生成多个输出文件。输出文件以输入文件命名并写入相同的目录。–server 和 –man 选项将输出行为从文件生成更改为提供动态生成的 HTML 联机帮助页或与 man 一样查看文件。</p>
<p>如果没有文件参数，ronn 将充当简单的过滤器。Ronn 源文本从标准输入读取，roff 输出写入标准输出。使用 –html、–roff 和 &#x2F; 或 –fragment 选项来选择输出格式。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ronn &lt;options&gt; &lt;file&gt;...</span><br><span class="line">ronn -m|--man &lt;file&gt;</span><br><span class="line">ronn -S|--server &lt;file&gt; ...</span><br><span class="line">ronn --pipe [&lt;file&gt;...]</span><br><span class="line">ronn &lt; file</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li>模式选项改变生成文件的默认行为：<ul>
<li><code>--pipe</code> ：写入标准输出而不是生成文件。</li>
<li><code>-m</code>, <code>--man</code> ：像 man 一样显示帮助手册。</li>
<li><code>-S</code>, <code>--server</code> ：在 <a target="_blank" rel="noopener" href="http://localhost:1207/">http://localhost:1207/</a> 提供服务文件。</li>
<li><code>--port &lt;port&gt;</code> ：使用指定端口而不是默认的 1207 运行服务器。</li>
<li><code>-o</code>, <code>--output-dir &lt;dir&gt;</code> ：将生成的文件写入指定目录。</li>
</ul>
</li>
<li>格式选项控制生成哪些文件格式：<ul>
<li><code>-r</code>, <code>--roff</code> ：生成 roff 格式输出。</li>
<li><code>-5</code>, <code>--html</code> ：生成带有布局的整个 HTML 页面。</li>
<li><code>-f</code>, <code>--fragment</code> ：生成 HTML 片段。</li>
<li><code>--markdown</code> ：生成后处理的（post-processed）markdown 格式输出。</li>
</ul>
</li>
<li>文档属性：<ul>
<li><code>--date=&lt;date&gt;</code> ：发布日期（底部居中），格式为 YYYY-MM-DD。</li>
<li><code>--manual=&lt;name&gt;</code> ：手册名称（顶部居中）。</li>
<li><code>--organization=&lt;name&gt;</code> ：出版团体或个人（左下）。</li>
</ul>
</li>
<li>其他选项：<ul>
<li><code>-w</code>, <code>--warnings</code> ：在 stderr 上显示 troff 警告。</li>
<li><code>-W disable</code> ：预先启用的 troff 警告。</li>
<li><code>--version</code> ：显示 ronn 的版本信息。</li>
<li><code>--help</code> ：显示帮助信息。</li>
</ul>
</li>
</ul>
<h2 id="示例-20"><a href="#示例-20" class="headerlink" title="示例"></a>示例</h2><p>转换 atinout.1.ronn 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ronn atinout.1.ronn</span><br></pre></td></tr></table></figure>





<h1 id="Linux-cwebp-命令-将图像转换为-WebP-格式"><a href="#Linux-cwebp-命令-将图像转换为-WebP-格式" class="headerlink" title="Linux cwebp 命令 - 将图像转换为 WebP 格式"></a>Linux cwebp 命令 - 将图像转换为 WebP 格式</h1><h2 id="介绍-21"><a href="#介绍-21" class="headerlink" title="介绍"></a>介绍</h2><p><strong>cwebp</strong>（英文全拼：compress WebP）命令用于将 JPEG、PNG 或 TIFF 格式的图片编码成 WebP 格式。</p>
<p>WebP 格式是谷歌在 2010 年推出的新一代图片格式，旨在加快图片加载速度。图片压缩体积大约只有 JPEG 的2&#x2F;3，能节省大量的服务器宽带资源和数据空间。WebP 既支持有损压缩也支持无损压缩，相较编码 JPEG 文件，编码同样质量的 WebP 文件需要占用更多的计算资源。</p>
<p>cwebp 命令由 webp 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install webp</span><br></pre></td></tr></table></figure>



<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/dwebp/">dwebp</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cwebp [options] input_file -o output_file.webp</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-h</code>, <code>-help</code> ：显示帮助信息（简单版）。</li>
<li><code>-H</code>, <code>-longhelp</code> ：显示帮助信息（详细版）。</li>
<li><code>-q &lt;float&gt;</code> ：品质参数（0：最小，100：最优），缺省值为 75。</li>
<li><code>-alpha_q &lt;int&gt;</code> ：为 alpha 压缩指定一个 0 到 100 的数值。alpha 无损压缩用 100，小于 100 将产生有损压缩。默认值100。</li>
<li><code>-preset &lt;string&gt;</code> ：指定一组预定义的值用来区分不同的文件材料。可能的值有 default、photo、picture、drawing、icon、text。由于 -preset 覆盖其他参数的值（除了 -q），这个值最好出现在所有参数最前面。</li>
<li><code>-z &lt;int&gt;</code> ：切换无损压缩模式级别从 0 到 9，0 最快，9 最慢。速度越快文件越大。比较好的默认值是 6。这个参数是一个预定义压缩质量快捷阐述。如果参数 -q 或者 -m 被随后用到，这个 -z 就无效了。</li>
<li><code>-m &lt;int&gt;</code> ：制定压缩模式。这个参数控制了编码的速度，压缩文件大小，质量。值范围为 0 到 6，默认 4。值越大，花费时间越大用来检查额外的编码能力和质量。小的值会产生快的压缩速度，大的文件和低的压缩质量。</li>
<li><code>-segments &lt;int&gt;</code> ：更改在 sns 算法分段期间要使用的分区数。段的范围应为 1 到 4，默认值为 4。除非使用 -low_memory，否则此选项对方法 3 及更高版本无效。</li>
<li><code>-size &lt;int&gt;</code> ：为输出文件指定一个目标大小（单位 bytes），压缩器将多次压缩以接近这个目标。如果 -size 和 -psnr 同时使用, 那么 -size 优先。</li>
<li><code>-psnr &lt;float&gt;</code> ：指定目标 PSNR（以 dB 为单位）以尝试达到压缩输出。 压缩程序将通过几次部分编码，以便尽可能接近此目标。 如果同时使用 -size 和 -psnr，则以 -size 值为准。</li>
<li><code>-s &lt;int&gt; &lt;int&gt;</code> ：YUV 的输入大小（宽 x 高）。</li>
<li><code>-sns &lt;int&gt;</code> ：指定空间噪声整形的幅度（0：off，100：最大），缺省值为 50。</li>
<li><code>-f &lt;int&gt;</code> ：指定解过滤器的强度（0：off，100：最大），缺省值为 60。</li>
<li><code>-sharpness &lt;int&gt;</code> ：指定过滤的清晰度（0：最清晰，7：最不清晰），缺省值为 0。</li>
<li><code>-strong</code> ：使用强过滤替代简单过滤（默认开启强过滤）。</li>
<li><code>-nostrong</code> ：禁用强过滤，使用简单过滤。</li>
<li><code>-sharp_yuv</code> ：如果需要，请使用更准确，更清晰的 RGB-&gt; YUV 转换。 请注意，此过程比默认的“快速” RGB-&gt; YUV 转换要慢。</li>
<li><code>-partition_limit &lt;int&gt;</code> ：限制质量以适应第一个分区的 512k 限制（0：无降级，100：完全降级），缺省值为 0。</li>
<li><code>-pass &lt;int&gt;</code> ：设置选项 -size 或 -psnr 程序执行期间要使用的最大通过次数。参数范围 1 到 10，默认值为 1。如果使用选项 -size 或 -psnr，但未指定 -pass，则将使用默认值 6。</li>
<li><code>-crop &lt;x&gt; &lt;y&gt; &lt;w&gt; &lt;h&gt;</code> ：从左边顶部的点开始 (x_position, y_position) 计算来裁切图片。裁切区域必须在原文件图片区域内。</li>
<li><code>-resize &lt;w&gt; &lt;h&gt;</code> ：调整源文件的宽高。如果任意一个宽或者高的参数为 0，那么将按比例计算。</li>
<li><code>-mt</code> ：如果支持，采用多线程编码。</li>
<li><code>-low_memory</code> ：通过节省四倍于压缩大小（通常）来减少有损编码的内存使用。 这将使编码变慢，并且输出的大小和失真会稍有不同。</li>
<li><code>-map &lt;int&gt;</code> ：输出额外的 ASCII 映射编码信息。 可能的映射值范围是1到6。这仅是为了帮助调试。</li>
<li><code>-print_psnr</code> ：计算并报告平均 PSNR（峰值信噪比）。</li>
<li><code>-print_ssim</code> ：计算并报告平均 SSIM（结构相似性指标）。</li>
<li><code>-print_lsim</code> ：计算并报告局部相似性度量（像素邻居中的最低误差之和）。</li>
<li><code>-d &lt;file.pgm&gt;</code> ：转储压缩的输出（PGM 文件）。</li>
<li><code>-alpha_method &lt;int&gt;</code> ：指定用于 alpha 压缩的算法：0 或 1。算法 0 表示无压缩，1 使用 WebP 无损格式进行压缩。 预设值为 1。</li>
<li><code>-alpha_filter &lt;string&gt;</code> ：指定 Alpha 平面的预测过滤方法。有效值：none、fast、best，默认为 fast。</li>
<li><code>-exact</code> ：将 RGB 值保留在透明区域中。默认为关闭，以帮助压缩。</li>
<li><code>-blend_alpha &lt;hex&gt;</code> ：将颜色与以十六进制写入的 RGB 值表示的背景颜色混合，例如 0xc0e0d0 代表红色&#x3D;0xc0，绿色&#x3D;0xe0，蓝色&#x3D;0xd0。</li>
<li><code>-noalpha</code> ：使用此选项将丢弃 Alpha 通道。</li>
<li><code>-lossless</code> ：无损编码图片处理。意味着整个图片，包含透明区域、看不见的像素值（R&#x2F;G&#x2F;B 或 Y&#x2F;U&#x2F;V）都会被保存。</li>
<li><code>-near_lossless &lt;int&gt;</code> ：指定无损压缩级别对图片处理预处理（0..100&#x3D;off），缺省值为 100。这个参数用来调整像素帮助图片的可压缩性，但是尽可能减少图片可见区域质量。</li>
<li><code>-hint &lt;string&gt;</code> ：指定有关输入图像类型的提示。可能的值为：photo、picture 或 graph。</li>
<li><code>-metadata &lt;string&gt;</code> ：逗号分隔的元数据列表，如果存在，则从输入复制到输出。有效值：all、none、exif、icc、xmp。默认为 none。</li>
<li><code>-short</code> ：仅出于测试目的打印简要信息（输出文件大小和 PSNR）。</li>
<li><code>-quiet</code> ：安静模式（不打印任何东西）。</li>
<li><code>-version</code> ：打印版本信息并退出。</li>
<li><code>-noasm</code> ：禁用所有装配优化。</li>
<li><code>-v</code> ：打印更多信息（特别是编码时间）。</li>
<li><code>-progress</code> ：报告编码进度（百分比）。</li>
</ul>
<h2 id="示例-21"><a href="#示例-21" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cwebp -q 80 image.png -o image.webp</span><br></pre></td></tr></table></figure>





<h1 id="Linux-dwebp-命令-将-WebP-图像转换为其他格式"><a href="#Linux-dwebp-命令-将-WebP-图像转换为其他格式" class="headerlink" title="Linux dwebp 命令 - 将 WebP 图像转换为其他格式"></a>Linux dwebp 命令 - 将 WebP 图像转换为其他格式</h1><h2 id="介绍-22"><a href="#介绍-22" class="headerlink" title="介绍"></a>介绍</h2><p><strong>dwebp</strong>（英文全拼：decompress WebP）命令用于将 WebP 格式图片解码成 PNG、PAM、PPM 或 PGM 格式。</p>
<p>WebP 格式是谷歌在 2010 年推出的新一代图片格式，旨在加快图片加载速度。图片压缩体积大约只有 JPEG 的2&#x2F;3，能节省大量的服务器宽带资源和数据空间。WebP 既支持有损压缩也支持无损压缩，相较编码 JPEG 文件，编码同样质量的 WebP 文件需要占用更多的计算资源。</p>
<p>dwebp 命令由 webp 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install webp</span><br></pre></td></tr></table></figure>



<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/cwebp/">cwebp</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dwebp [options] input_file.webp</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-h</code> ：打印帮助信息。</li>
<li><code>-version</code> ：打印版本信息。</li>
<li><code>-bmp</code> ：将输出格式更改为未压缩的 BMP。</li>
<li><code>-tiff</code> ：将输出格式更改为未压缩的 TIFF。</li>
<li><code>-pam</code> ：将输出格式更改为 PAM（保留 alpha 通道）。</li>
<li><code>-ppm</code> ：将输出格式更改为 PPM（丢弃 alpha 通道）。</li>
<li><code>-pgm</code> ：将输出格式更改为 PGM。</li>
<li><code>-yuv</code> ：将输出格式更改为 YUV。</li>
</ul>
<h2 id="示例-22"><a href="#示例-22" class="headerlink" title="示例"></a>示例</h2><p>将 picture.webp 图片解码为 PNG 格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dwebp picture.webp -o output.png</span><br></pre></td></tr></table></figure>



<p>将 picture.webp 图片解码为 PPM 格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dwebp picture.webp -ppm -o output.ppm</span><br></pre></td></tr></table></figure>





<h1 id="Linux-pv-命令-显示数据传输进度"><a href="#Linux-pv-命令-显示数据传输进度" class="headerlink" title="Linux pv 命令 - 显示数据传输进度"></a>Linux pv 命令 - 显示数据传输进度</h1><h2 id="介绍-23"><a href="#介绍-23" class="headerlink" title="介绍"></a>介绍</h2><p><strong>pv</strong>（英文全拼：pipe viewer）命令用于通过管道监控数据处理的进度信息。这些信息包括已经耗费的时间、完成的百分比（通过进度条显示）、当前的速度、全部传输的数据，以及估计剩余的时间。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pv [OPTION] [FILE]...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-p</code>, <code>--progress</code> ：显示进度条。</li>
<li><code>-t</code>, <code>--timer</code> ：显示任务已经进行的时长。</li>
<li><code>-e</code>, <code>--eta</code> ：显示剩余多长时间完成。</li>
<li><code>-I</code>, <code>--fineta</code> ：以绝对时间显示预计完成时间。</li>
<li><code>-r</code>, <code>--rate</code> ：显示当前传输速率。</li>
<li><code>-a</code>, <code>--average-rate</code> ：显示平均传输速率。</li>
<li><code>-b</code>, <code>--bytes</code> ：显示传输的字节数。</li>
<li><code>-T</code>, <code>--buffer-percent</code> ：显示正在使用的传输缓冲区的百分比。</li>
<li><code>-A</code>, <code>--last-written NUM</code> ：显示最后写入的 NUM 个字节。</li>
<li><code>-F</code>, <code>--format FORMAT</code> ：设置输出格式为 FORMAT。</li>
<li><code>-n</code>, <code>--numeric</code> ：显示进度百分比数字，而不是可视化信息。</li>
<li><code>-q</code>, <code>--quiet</code> ：安静模式，不要输出任何传输信息。</li>
<li><code>-W</code>, <code>--wait</code> ：在传输第一个字节之前不显示任何内容。</li>
<li><code>-D</code>, <code>--delay-start SEC</code> ：在经过 SEC 秒数之前不显示任何内容。</li>
<li><code>-s</code>, <code>--size SIZE</code> ：将估计数据大小设置为 SIZE 字节。</li>
<li><code>-l</code>, <code>--line-mode</code> ：计数行而不是字节。</li>
<li><code>-0</code>, <code>--null</code> ：行是 null-terminated 的。</li>
<li><code>-i</code>, <code>--interval SEC</code> ：每 SEC 秒更新一次。</li>
<li><code>-w</code>, <code>--width WIDTH</code> ：假设终端是 WIDTH 个字符宽。</li>
<li><code>-H</code>, <code>--height HEIGHT</code> ：假设终端是 HEIGHT 行高。</li>
<li><code>-N</code>, <code>--name NAME</code> ：使用 NAME 作为可视信息的前缀。</li>
<li><code>-f</code>, <code>--force</code> ：强制输出，即使标准错误不是终端也输出。</li>
<li><code>-c</code>, <code>--cursor</code> ：使用光标定位转义序列。</li>
<li><code>-L</code>, <code>--rate-limit RATE</code> ：将传输限制为每秒 RATE 字节。</li>
<li><code>-B</code>, <code>--buffer-size BYTES</code> ：使用 BYTES 的缓冲区大小。</li>
<li><code>-C</code>, <code>--no-splice</code> ：从不使用 splice()，始终使用读&#x2F;写。</li>
<li><code>-E</code>, <code>--skip-errors</code> ：跳过输入中的读取错误。</li>
<li><code>-S</code>, <code>--stop-at-size</code> ：在传输 –size 字节后停止。</li>
<li><code>-R</code>, <code>--remote PID</code> ：更新进程 PID 的设置。</li>
<li><code>-P</code>, <code>--pidfile FILE</code> ：在 FILE 中保存进程 ID。</li>
<li><code>-d</code>, <code>--watchfd PID[:FD]</code> ：监视进程 PID 打开的文件 FD。</li>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息并退出。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息并退出。</li>
</ul>
<h2 id="示例-23"><a href="#示例-23" class="headerlink" title="示例"></a>示例</h2><p>复制文件时显示进度条（如果没有指定选项，默认使用 -p, -t, -e, -r 和 -b 选项）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pv getiot.db &gt; getiot.db.bak</span></span><br></pre></td></tr></table></figure>



<p>将 &#x2F;var&#x2F;log&#x2F;syslog 文件打包成 zip 压缩包，并显示进度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pv /var/log/syslog | zip &gt; syslog.zip</span></span><br></pre></td></tr></table></figure>



<p>使用 tar 命令解压缩时显示进度条</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pv rootfs.tar.bz2 | tar -jxf - -C rootfs/</span></span><br><span class="line">12.3MiB 0:00:02 [6.15MiB/s] [=========&gt;                                     ] 21% ETA 0:00:07</span><br></pre></td></tr></table></figure>



<p>解压完成</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pv rootfs.tar.bz2 | tar -jxf - -C rootfs/</span></span><br><span class="line">57.8MiB 0:00:10 [5.53MiB/s] [==============================================&gt;] 100%</span><br></pre></td></tr></table></figure>





<h1 id="Linux-redshift-命令-护眼色温调节工具"><a href="#Linux-redshift-命令-护眼色温调节工具" class="headerlink" title="Linux redshift 命令 - 护眼色温调节工具"></a>Linux redshift 命令 - 护眼色温调节工具</h1><h2 id="介绍-24"><a href="#介绍-24" class="headerlink" title="介绍"></a>介绍</h2><p>Linux 中的 <strong>redshift</strong> 命令可以根据一天中的时间设置显示器的色温。它通过改变显示器配色和亮度来加强用户夜间坐在屏幕前的体验，减少由于显示屏对眼睛造成的压力。</p>
<p>启动时，用户可以根据经度和纬度来配置地理坐标，redshift 会根据太阳的位置平滑地调整屏幕地配色和亮度。通常，夜间的屏幕色温会调向偏暖色。这是因为 redshift 有两个默认的色温值（日间色温：6500K，夜间色温：4500K），中性温度值为 6500K，使用此值不会改变显示器的色温，将色温设置为高于此值的值会导致更多的蓝光，而设置较低的值会导致更多的红光。</p>
<p>redshift 通常不会预先安装，但可在大多数 Linux 发行版的默认仓库中找到。例如，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install redshift</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redshift [-l LAT:LON | -l PROVIDER:OPTIONS] [-t DAY:NIGHT] [OPTIONS...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-h</code>：显示此帮助信息。</li>
<li><code>-v</code>：详细输出。</li>
<li><code>-V</code>：显示程序版本。</li>
<li><code>-b DAY:NIGHT</code>：设置要应用的屏幕亮度（介于 0.1 和 1.0 之间）。</li>
<li><code>-c FILE</code>：从指定的配置文件加载设置。</li>
<li><code>-g R:G:B</code>：设置要应用的额外伽马校正。</li>
<li><code>-l LAT:LON</code>：设置当前的位置。</li>
<li><code>-l PROVIDER</code>：选择位置自动更新提供者（输入“list”以查看可用的提供者）。</li>
<li><code>-m METHOD</code>：用于设置色温的方法（键入“list”以查看可用方法）。</li>
<li><code>-o</code>：单次模式（不连续调节色温）。</li>
<li><code>-O TEMP</code>：单次手动模式（设置色温）。</li>
<li><code>-p</code>：打印模式（仅打印参数并退出）。</li>
<li><code>-P</code>：在应用新的色彩效果之前重置现有的伽玛斜线（gamma ramps）。</li>
<li><code>-x</code>：重置模式（从屏幕上移除调整）。</li>
<li><code>-r</code>：禁用色温之间的淡入淡出。</li>
<li><code>-t DAY:NIGHT</code>：指定色温调整的时间点（白天&#x2F;晚上）。</li>
</ul>
<h2 id="示例-24"><a href="#示例-24" class="headerlink" title="示例"></a>示例</h2><p>自动获取地理位置来调整屏幕色温</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ redshift </span><br><span class="line">正在尝试位置服务”geoclue2“。</span><br><span class="line">正在使用服务”geoclue2“。</span><br><span class="line">正在使用模式 ”randr“。</span><br><span class="line">Waiting <span class="keyword">for</span> initial location to become available...</span><br><span class="line">位置：23.11 北纬, 113.25 东经</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ptp4l-命令-PTP-时间同步"><a href="#Linux-ptp4l-命令-PTP-时间同步" class="headerlink" title="Linux ptp4l 命令 - PTP 时间同步"></a>Linux ptp4l 命令 - PTP 时间同步</h1><h2 id="介绍-25"><a href="#介绍-25" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ptp4l</strong>（英文全拼：PTP for Linux）命令用于 PTP 同步。</p>
<p>ptp4l 是根据适用于 Linux 的 IEEE 标准 1588 的精确时间协议（PTP）的实现，它实现了边界时钟（Boundary Clock）和普通时钟（Ordinary Clock），支持硬件时钟同步和软件时间同步（系统时钟同步）。</p>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/phc2sys/">phc2sys</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/phc_ctl/">phc_ctl</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/pmc/">pmc</a></p>
<p>关于 PTP 详细介绍，请参考《<a target="_blank" rel="noopener" href="https://getiot.tech/protocol/ptp/">PTP 精确时间协议</a>》。</p>
<p><strong>安装</strong>：</p>
<p>ptp4l 命令由 LinuxPTP 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install linuxptp</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ptp4l  [ -AEP246HSLmqsv ] </span><br><span class="line">       [ -f config ] </span><br><span class="line">       [ -p phc-device ] </span><br><span class="line">       [ -l print-level ] </span><br><span class="line">       [ -i interface ] </span><br><span class="line">       [ long-options ] ...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<p>延迟机制选项</p>
<ul>
<li><code>-A</code>：自动模式，自动选择 E2E 延迟机制，当收到对等延迟请求时切换到 P2P。</li>
<li><code>-E</code>：E2E 模式，请求应答延迟机制（默认）。注意：单个 PTP 通信路径上的所有时钟必须使用相同的机制。</li>
<li><code>-P</code>：P2P 模式，对等延迟机制。</li>
</ul>
<p>网络传输选项</p>
<ul>
<li><code>-2</code>：IEEE 802.3</li>
<li><code>-4</code>：UDP IPv4（默认）</li>
<li><code>-6</code>：UDP IPv6</li>
</ul>
<p>时间戳选项</p>
<ul>
<li><code>-H</code>：硬件时间戳（默认）</li>
<li><code>-S</code>：软件模拟时间戳</li>
<li><code>-L</code>：老的硬件时间戳，LEGACY HW 需要配合 PHC 设备使用。</li>
</ul>
<p>其他选项</p>
<ul>
<li><code>-f [file]</code>：从指定文件 file 中读取配置，默认情况下不读取任何配置文件。</li>
<li><code>-i [dev]</code>：选择 PTP 接口设备，例如 eth0（可多次指定），必须至少使用此选项或配置文件指定一个端口。</li>
<li><code>-p [dev]</code>：此选项用于在旧 Linux 内核上指定要使用的 PHC 设备（例如 <code>/dev/ptp0</code> 时钟设备），默认为 auto，忽略软件&#x2F;LEGACY HW 时间戳。</li>
<li><code>-s</code>：从时钟模式（Slave only mode），将覆盖配置文件。</li>
<li><code>-t</code>：透明时钟模式。</li>
<li><code>-l [num]</code>：将日志记录级别设置为 num，默认为 6。</li>
<li><code>-m</code>：将消息打印到 stdout。</li>
<li><code>-q</code>：不打印消息到 syslog。</li>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息并退出。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息并退出。</li>
</ul>
<h2 id="示例-25"><a href="#示例-25" class="headerlink" title="示例"></a>示例</h2><p>要使用 ptp4l，首先得确定网卡支持的同步类型，可通过 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/ethtool/">ethtool</a> 命令测试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ethtool -T eth0</span><br></pre></td></tr></table></figure>



<p>对于支持硬件时间戳的主机，可通过以下命令运行主时钟</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ptp4l -m -H -i eth0</span><br></pre></td></tr></table></figure>



<p>运行 slave 时钟</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ptp4l -i eth0 -m -H -s</span><br></pre></td></tr></table></figure>



<p>若主机不支持硬件时间戳，可通过以下命令启用 PTP 软件时间戳</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ptp4l -m -S -i eth0          <span class="comment"># 主时钟</span></span><br><span class="line"><span class="built_in">sudo</span> ptp4l -m -S -s -i eth0       <span class="comment"># 从时钟</span></span><br></pre></td></tr></table></figure>



<p>将 ptp4l 作为服务运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start ptp4l</span><br></pre></td></tr></table></figure>



<ul>
<li>ptp4l 的配置文件：&#x2F;etc&#x2F;linuxptp&#x2F;ptp4l.conf</li>
<li>服务配置文件：&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;ptp4l.service</li>
</ul>
<h1 id="Linux-phc2sys-命令-同步-PTP-时钟与系统时钟"><a href="#Linux-phc2sys-命令-同步-PTP-时钟与系统时钟" class="headerlink" title="Linux phc2sys 命令 - 同步 PTP 时钟与系统时钟"></a>Linux phc2sys 命令 - 同步 PTP 时钟与系统时钟</h1><h2 id="介绍-26"><a href="#介绍-26" class="headerlink" title="介绍"></a>介绍</h2><p><strong>phc2sys</strong>（英文全拼：PTP hardware clock to system）命令用于同步两个或多个时钟。最常见的用法是，将系统时钟同步到网卡上的 PTP 硬件时钟（PHC）。PHC 本身可以使用 <code>ptp4l</code> 同步，系统时钟被视为从属时钟，而网卡上的时钟则为主时钟。</p>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/ptp4l/">ptp4l</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/phc_ctl/">phc_ctl</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/pmc/">pmc</a></p>
<p>关于 PTP 详细介绍，请参考《<a target="_blank" rel="noopener" href="https://getiot.tech/protocol/ptp/">PTP 精确时间协议</a>》。</p>
<p><strong>安装</strong>：</p>
<p>phc2sys 命令由 LinuxPTP 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install linuxptp</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">phc2sys -a [ -r ] [ -r ] [ options ]</span><br><span class="line">phc2sys [ -d pps-device ] [ -s device ] [ -c device ] [ -O offset ] [ -w ] [ options ]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<p>自动配置：</p>
<ul>
<li><code>-a</code>：开启自动配置。</li>
<li><code>-r</code>：同步系统（实时）时钟，重复 <code>-r</code> 将其也视为时间源。</li>
</ul>
<p>手动配置：</p>
<ul>
<li><code>-c [dev|name]</code>：从时钟（CLOCK_REALTIME）。</li>
<li><code>-d [dev]</code>：主 PPS 设备。</li>
<li><code>-s [dev|name]</code>：主时钟。</li>
<li><code>-O [offset]</code>：从主时间偏移量，默认为 0。</li>
<li><code>-w</code>：等待 ptp4l。</li>
</ul>
<p>通用选项：</p>
<ul>
<li><code>-E [pi|linreg]</code>：时钟伺服，默认为 pi。</li>
<li><code>-P [kp]</code>：比例常数，默认为 0.7。</li>
<li><code>-I [ki]</code>：积分常数，默认为 0.3。</li>
<li><code>-S [step]</code>：设置步阈值，默认不开启。</li>
<li><code>-F [step]</code>：仅在开始时设置步阈值，默认为 0.00002。</li>
<li><code>-R [rate]</code>：以 HZ 为单位的从属时钟更新率，默认为 1 HZ。</li>
<li><code>-N [num]</code>：每次更新的主时钟读数数量，默认为 5。</li>
<li><code>-L [limit]</code>：以 ppb 为单位的健全频率限制，默认为 200000000。</li>
<li><code>-M [num]</code>：NTP SHM 段号，默认为 0。</li>
<li><code>-u [num]</code>：摘要统计中的时钟更新次数，默认为 0。</li>
<li><code>-n [num]</code>：域编号（domain number），默认为 0。</li>
<li><code>-x</code>：通过伺服而不是内核应用闰秒。</li>
<li><code>-z [path]</code>：UDS 的服务器地址（&#x2F;var&#x2F;run&#x2F;ptp4l）。</li>
<li><code>-l [num]</code>：将日志记录级别设置为 num，默认为 6。</li>
<li><code>-t [tag]</code>：为日志消息添加标记（tag）。</li>
<li><code>-m</code>：将消息打印到标准输出（stdout）。</li>
<li><code>-q</code>：不要将消息打印到系统日志（syslog）。</li>
<li><code>-v</code>：显示版本信息并退出。</li>
<li><code>-h</code>：显示帮助信息并退出。</li>
</ul>
<h2 id="示例-26"><a href="#示例-26" class="headerlink" title="示例"></a>示例</h2><p>将系统时钟同步到网卡上的 PTP 硬件时钟（PHC），使用 <code>-s</code> 可按设备或网络接口指定主时钟，使用 <code>-w</code> 可等待直到 <code>ptp4l</code> 进入已同步状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> phc2sys -s eth0 -w</span><br></pre></td></tr></table></figure>



<p>PTP 按国际原子时（TAI）运行，而系统时钟使用的是协调世界时（UTC）。如果不指定 <code>-w</code> 来等待 <code>ptp4l</code> 同步，可以使用 <code>-O</code> 来指定 TAI 与 UTC 之间的偏差（以秒为单位）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> phc2sys -s eth0 -O -35</span><br></pre></td></tr></table></figure>



<p>将 <code>phc2sys</code> 作为服务运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start phc2sys</span><br></pre></td></tr></table></figure>





<h1 id="Linux-phc-ctl-命令-管理-PTP-硬件时钟"><a href="#Linux-phc-ctl-命令-管理-PTP-硬件时钟" class="headerlink" title="Linux phc_ctl 命令 - 管理 PTP 硬件时钟"></a>Linux phc_ctl 命令 - 管理 PTP 硬件时钟</h1><h2 id="介绍-27"><a href="#介绍-27" class="headerlink" title="介绍"></a>介绍</h2><p><strong>phc_ctl</strong>（英文全拼：PTP hardware clock control）是 linuxptp 套件中的一个命令，可以用来直接控制 PHC 时钟设备。<code>phc_ctl</code> 命令通常用于调试目的，很少用于设备的一般控制。对于 PHC 时钟设备的一般控制，应该使用 <code>phc2sys</code> 命令。</p>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/ptp4l/">ptp4l</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/phc2sys/">phc2sys</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/pmc/">pmc</a></p>
<p>关于 PTP 详细介绍，请参考《<a target="_blank" rel="noopener" href="https://getiot.tech/protocol/ptp/">PTP 精确时间协议</a>》。</p>
<p><strong>安装</strong>：</p>
<p>ptp4l 命令由 LinuxPTP 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install linuxptp</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">phc_ctl [ options ] &lt;device&gt; [ commands ]</span><br></pre></td></tr></table></figure>



<p>其中，device 用于指定以太网卡或 PTP 时钟设备。</p>
<p><strong>选项</strong>：</p>
<ul>
<li><code>-l print-level</code>：设置日志记录级别。</li>
<li><code>-q</code>：不将消息打印到 syslog 系统日志。</li>
<li><code>-Q</code>：不将消息打印到 stdout 标准输出。</li>
<li><code>-v</code>：打印软件版本并退出。</li>
<li><code>-h</code>：打印帮助信息并退出。</li>
</ul>
<p><strong>命令</strong>：</p>
<p>除了选项，还可以指定带有参数的命令（command），并且可以指定多个命令依次执行。</p>
<ul>
<li><code>set [seconds]</code>：设置 PHC 时间（默认为 CLOCK_REALTIME 上的时间）。</li>
<li><code>get</code>：获取 PHC 时间。</li>
<li><code>adj &lt;seconds&gt;</code>：通过偏移量 seconds 调整 PHC 时间。</li>
<li><code>freq [ppb]</code>：调整 PHC 频率（默认返回当前偏移）。</li>
<li><code>cmp</code>：将 PHC 偏移量与 CLOCK_REALTIME 进行比较。</li>
<li><code>caps</code>：显示设备功能（如果没有指定命令，默认为该模式）。</li>
<li><code>wait &lt;seconds&gt;</code>：命令之间暂停 seconds 秒。</li>
</ul>
<p>提示</p>
<p>命令中的参数 seconds 被读取为双精度浮点值。</p>
<h2 id="示例-27"><a href="#示例-27" class="headerlink" title="示例"></a>示例</h2><p>从 PTP 设备读取当前时钟时间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">phc_ctl /dev/ptp0 get</span><br></pre></td></tr></table></figure>



<p>将 PHC 时钟时间设置为 CLOCK_REALTIME：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">phc_ctl /dev/ptp0 <span class="built_in">set</span></span><br></pre></td></tr></table></figure>



<p>将 PHC 时钟时间设置为 0（自 Epoch 纪元以来的秒数，即 1970-01-01 00:00:00 UTC）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">phc_ctl /dev/ptp0 <span class="built_in">set</span> 0.0</span><br></pre></td></tr></table></figure>



<p>通过将转换频率设置为正 10%，将时钟重置为 0.0 时间，等待 10 秒，然后读取时间，快速检查频率转换的完整性。回读的时间应（大约）为 11 秒，因为时钟转动速度快了 10%。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">phc_ctl /dev/ptp0 freq 100000000 <span class="built_in">set</span> 0.0 <span class="built_in">wait</span> 10.0 get</span><br></pre></td></tr></table></figure>





<h1 id="Linux-pmc-命令-管理-PTP-网络"><a href="#Linux-pmc-命令-管理-PTP-网络" class="headerlink" title="Linux pmc 命令 - 管理 PTP 网络"></a>Linux pmc 命令 - 管理 PTP 网络</h1><h2 id="介绍-28"><a href="#介绍-28" class="headerlink" title="介绍"></a>介绍</h2><p><strong>pmc</strong>（英文全拼：PTP management client）是一个根据 IEEE 1588 标准实现的 PTP 管理客户端程序，可用于获取 ptp4l 的更详细信息。</p>
<p>pmc 从标准输入或命令行读取按名称和管理 ID（MANAGEMENT IDS）指定的操作。然后通过选定的传输发送操作，并列显收到的任何答复。支持三种操作：<code>GET</code> 检索指定的信息，<code>SET</code> 更新指定的信息，<code>CMD</code>（或 <code>COMMAND</code>）发起指定的事件。默认情况下，管理命令针对所有端口。</p>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/ptp4l/">ptp4l</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/phc2sys/">phc2sys</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/phc_ctl/">phc_ctl</a></p>
<p>关于 PTP 详细介绍，请参考《<a target="_blank" rel="noopener" href="https://getiot.tech/protocol/ptp/">PTP 精确时间协议</a>》。</p>
<p><strong>安装</strong>：</p>
<p>pmc 命令由 LinuxPTP 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install linuxptp</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pmc [options] [commands]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<p>网络传输选项</p>
<ul>
<li><code>-2</code>：使用 IEEE 802.3</li>
<li><code>-4</code>：使用 UDP IPV4（默认）</li>
<li><code>-6</code>：使用 UDP IPV6</li>
<li><code>-u</code>：使用本地 UDS（Unix Domain Socket）</li>
</ul>
<p>其他选项</p>
<ul>
<li><code>-b [num]</code>：边界跳数（boundary hops），默认为 1。</li>
<li><code>-d [num]</code>：域名（domain number），默认0。</li>
<li><code>-f [file]</code>：从文件中读取配置。</li>
<li><code>-i [dev]</code>：要使用的网络接口设备，网络默认为 eth0，UDS 为 <code>/var/run/pmc.$pid</code>。</li>
<li><code>-s [path]</code>：UDS 的服务器地址，默认为 <code>/var/run/ptp4l</code>。</li>
<li><code>-t [hex]</code>：传输特定字段，默认 0x0。</li>
<li><code>-z</code>：使用 GET 操作发送零长度 TLV 值。</li>
<li><code>-h</code>：打印帮助信息。</li>
<li><code>-v</code>：打印版本信息。</li>
</ul>
<p><strong>命令</strong>：</p>
<p>pmc 支持 <code>GET</code>、<code>SET</code>、<code>CMD</code> 三种操作，操作后面带上管理 ID，指定需要操作的目标。支持的管理 ID 包括：</p>
<ul>
<li><code>ANNOUNCE_RECEIPT_TIMEOUT</code></li>
<li><code>CLOCK_ACCURACY</code></li>
<li><code>CLOCK_DESCRIPTION</code></li>
<li><code>CURRENT_DATA_SET</code></li>
<li><code>DEFAULT_DATA_SET</code></li>
<li><code>DELAY_MECHANISM</code></li>
<li><code>DOMAIN</code></li>
<li><code>GRANDMASTER_SETTINGS_NP</code></li>
<li><code>LOG_ANNOUNCE_INTERVAL</code></li>
<li><code>LOG_MIN_PDELAY_REQ_INTERVAL</code></li>
<li><code>LOG_SYNC_INTERVAL</code></li>
<li><code>NULL_MANAGEMENT</code></li>
<li><code>PARENT_DATA_SET</code></li>
<li><code>PORT_DATA_SET</code></li>
<li><code>PORT_DATA_SET_NP</code></li>
<li><code>PRIORITY1</code></li>
<li><code>PRIORITY2</code></li>
<li><code>SLAVE_ONLY</code></li>
<li><code>TIMESCALE_PROPERTIES</code></li>
<li><code>TIME_PROPERTIES_DATA_SET</code></li>
<li><code>TIME_STATUS_NP</code></li>
<li><code>TRACEABILITY_PROPERTIES</code></li>
<li><code>USER_DESCRIPTION</code></li>
<li><code>VERSION_NUMBER</code></li>
</ul>
<h2 id="示例-28"><a href="#示例-28" class="headerlink" title="示例"></a>示例</h2><p>获取本地 ptp4l 运行信息（<code>CURRENT_DATA_SET</code>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pmc -u -b 0 <span class="string">&#x27;GET CURRENT_DATA_SET&#x27;</span></span><br></pre></td></tr></table></figure>



<p>获取本地 ptp4l 运行信息（<code>TIME_STATUS_NP</code>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pmc -u -b 0 <span class="string">&#x27;GET TIME_STATUS_NP&#x27;</span></span><br></pre></td></tr></table></figure>





<h1 id="Linux-gpsd-命令-管理-GPS-接收器服务"><a href="#Linux-gpsd-命令-管理-GPS-接收器服务" class="headerlink" title="Linux gpsd 命令 - 管理 GPS 接收器服务"></a>Linux gpsd 命令 - 管理 GPS 接收器服务</h1><h2 id="介绍-29"><a href="#介绍-29" class="headerlink" title="介绍"></a>介绍</h2><p><strong>gpsd</strong>（英文全拼：GPS daemon）是 Linux 系统中用于接收和处理 GPS 数据的守护进程，它可以监控通过串口或 USB 端口连接到主机计算机上的一个或多个 GPS 或 AIS 接收器，并将所有 GPS 传感器位置、航向、速度等数据通过 TCP 端口 2947 提供给客户端查询。</p>
<p>gpsd 服务是 <a target="_blank" rel="noopener" href="https://gitlab.com/gpsd/gpsd">GPSD</a> 项目的一部分，该项目提供一系列管理 GPS 设备和其他用于导航与精确计时的传感器的工具。</p>
<p>扩展阅读：《<a target="_blank" rel="noopener" href="https://getiot.tech/linux-note/linux-get-gps-data-using-gpsd/">Linux 使用 gpsd 获取 GPS 数据</a>》、《<a target="_blank" rel="noopener" href="https://getiot.tech/awesome-c/libgps/">libgps 使用教程</a>》。</p>
<p><strong>安装</strong>：</p>
<p>gpsd 命令由 gpsd 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gpsd</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpsd [OPTIONS] device...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-b</code>：bluetooth-safe 模式，打开只读数据源。</li>
<li><code>-D integer</code>：设置调试等级（默认为 0）。</li>
<li><code>-F sockfile</code>：指定控制套接字（control socket）的位置。</li>
<li><code>-f FRAMING</code>：将设备帧固定为 <code>FRAMING</code>（例如 8N1、8O1 等）。</li>
<li><code>-G</code>：使 gpsd 监听 <code>INADDR_ANY</code>，在此二进制文件中强制启用。</li>
<li><code>-h</code>：显示帮助信息。</li>
<li><code>-n</code>：不要等待客户端连接来轮询 GPS。</li>
<li><code>-N</code>：不要进入后台。</li>
<li><code>-P pidfile</code>：设置记录进程 ID 的文件。</li>
<li><code>-r</code>：即使没有修正也使用 GPS 时间。</li>
<li><code>-S PORT</code>：设置守护进程的端口（默认端口为 2947）</li>
<li><code>-s SPEED</code>：将设备速度固定为 <code>SPEED</code>。</li>
<li><code>-V</code>：显示版本信息并退出。</li>
</ul>
<h2 id="示例-29"><a href="#示例-29" class="headerlink" title="示例"></a>示例</h2><p>假设你在 Linux 系统的最小编号的 USB 端口（&#x2F;dev&#x2F;ttyUSB0）上连接了 GPS 设备，并且想要在默认的 2947 端口上读取它的报告，那么只需以 root 身份执行下面命令即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gpsd /dev/ttyUSB0</span><br></pre></td></tr></table></figure>



<p>你可以执行下面命令将当前用户（非 root 用户）添加到 dialout 用户组，这样可以免去每次都要添加 <code>sudo</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -a -G dialout <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>



<p>注意：上述命令在重启系统后生效。</p>
<h1 id="Linux-cgps-命令-显示-GPS-信息和位置"><a href="#Linux-cgps-命令-显示-GPS-信息和位置" class="headerlink" title="Linux cgps 命令 - 显示 GPS 信息和位置"></a>Linux cgps 命令 - 显示 GPS 信息和位置</h1><h2 id="介绍-30"><a href="#介绍-30" class="headerlink" title="介绍"></a>介绍</h2><p><strong>cgps</strong> 是 gpsd 软件包中的一个客户端命令行工具，它可以以更友好的方式展示 GPS 数据（NMEA 报文格式），可用于测试 GPS 设备故障情况。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cgps [-h] [-l &#123;d|m|s&#125;] [-m] [-s] [-V] [server[:port:[device]]]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><p><code>-D debug-level</code>：设置 debug 等级。</p>
</li>
<li><p><code>-l {d|m|s}</code>：选择 lat&#x2F;lon 输出格式，其中：</p>
<p><code>d</code> 表示 <code>DD.ddddddd</code>（默认）</p>
<p><code>m</code> 表示 <code>DD MM.mmmmmm&#39;</code></p>
<p><code>s</code> 表示 <code>DD MM&#39; SS.sssss&quot;</code></p>
</li>
<li><p><code>-m</code>：显示你的磁轨（但不是真实的磁轨），这是计算值，而不是测量值。磁力变化总是可能会出现较大的误差，但通常优于两度。</p>
</li>
<li><p><code>-s</code>：安静模式（不打印原始 gpsd 数据）。</p>
</li>
<li><p><code>-h</code>：显示帮助信息。</p>
</li>
<li><p><code>-V</code>：显示版本信息。</p>
</li>
</ul>
<h2 id="示例-30"><a href="#示例-30" class="headerlink" title="示例"></a>示例</h2><p>连接好 GPS 设备，启动 gpsd 守护进程后，执行 <code>cgps</code> 启动客户端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cgps</span><br></pre></td></tr></table></figure>



<p>可以看到类似如下的数据展示界面：</p>
<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/linux-gpsd-cgps.png" alt="img"></p>
<p>提示：可参考《<a target="_blank" rel="noopener" href="https://getiot.tech/linux-note/linux-get-gps-data-using-gpsd/">Linux 使用 gpsd 获取 GPS 数据</a>》。</p>
<h1 id="Linux-gpsmon-命令-监控-GPS-数据和状态"><a href="#Linux-gpsmon-命令-监控-GPS-数据和状态" class="headerlink" title="Linux gpsmon 命令 - 监控 GPS 数据和状态"></a>Linux gpsmon 命令 - 监控 GPS 数据和状态</h1><h2 id="介绍-31"><a href="#介绍-31" class="headerlink" title="介绍"></a>介绍</h2><p><strong>gpsmon</strong>（英文全拼：GPS monitor）是 GPSD 软件包中的一个监视器工具，用于监视来自 GPS 的数据包并将其与诊断信息一起显示。它支持可用于以各种方式调整 GPS 设置的命令，有些与设备无关，有些则随 GPS 芯片组类型而变化。当连接到未知的 GPS 类型时，它依然会表现得很正常，因为它只会转储数据包。</p>
<p>gpsmon 经常用于诊断 GPS 设备，因为它不会修改原始数据，不进行任何插值或建模来得出爬升&#x2F;下沉或误差估计。哪怕当数据质量太低时，它也不会丢弃报告。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpsmon [-?hVn] [-l logfile] [-D debuglevel] [-t <span class="built_in">type</span>] [server[:port:[device]]]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-L</code>：以表格形式列出 gpsmon 内置支持哪些 GPS 设备类型，以及哪些通用命令可以应用于哪些 GPS 类型。注意，这并未列出与各个 GPS 类型相关的特定于类型的命令。</li>
<li><code>-n</code>：强制 gpsmon 请求 NMEA0183 数据包，而不是来自 gpsd 的原始数据流。</li>
<li><code>-a</code>：启用不使用屏幕绘制的特殊调试模式。数据包正常转储；键入任何字符都会暂停数据包转储并显示命令提示符。主要是 GPSD 开发人员对该功能感兴趣。</li>
<li><code>-F sockfile</code>：该选项仅在客户端模式下有效，它指定程序应向其发送设备控制字符串的控制套接字。必须在本地文件系统上指定 Unix 域套接字的有效路径名。</li>
<li><code>-l logfile</code>：将日志记录设置为在设备打开时立即输出到指定文件。</li>
<li><code>-t type</code>：设置设备类型。设备类型通过一个字符串区分，它包含驱动程序类型名称的前缀。</li>
<li><code>-D debuglevel</code>：设置调试等级，这可能仅对 GPSD 代码的开发人员有用。你可以参阅 packet-getter 源代码以获取相关值。</li>
<li><code>-h</code>：显示帮助信息。</li>
<li><code>-V</code>：显示版本信息并退出。</li>
</ul>
<h2 id="示例-31"><a href="#示例-31" class="headerlink" title="示例"></a>示例</h2><p>连接好 GPS 设备，启动 gpsd 守护进程后，执行 <code>gpsmon</code> 启动监视器客户端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpsmon</span><br></pre></td></tr></table></figure>



<p>可以看到类似如下的数据展示界面：</p>
<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/linux-gpsd-gpsmon.png" alt="img"></p>
<p>列出 gpsmon 内置支持哪些 GPS 设备类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gpsmon -L</span><br><span class="line">General commands available per <span class="built_in">type</span>. <span class="string">&#x27;+&#x27;</span> means there are private commands.</span><br><span class="line">i l q ^S ^Q       x  	NMEA0183</span><br><span class="line">i l q ^S ^Q n     x  	Garmin NMEA</span><br><span class="line">i l q ^S ^Q n     x  	Garmin Serial binary</span><br><span class="line">i l q ^S ^Q       x +	Ashtech</span><br><span class="line">i l q ^S ^Q       x  	San Jose Navigation FV18</span><br><span class="line">i l q ^S ^Q       x  	Furuno Electric GH-79L4</span><br><span class="line">i l q ^S ^Q     x x  	MTK-3301</span><br><span class="line">i l q ^S ^Q          	AIVDM</span><br><span class="line">i l q ^S ^Q n s   x +	SiRF</span><br><span class="line">i l q ^S ^Q n s x x +	u-blox</span><br><span class="line">i l q ^S ^Q         +	iTalk</span><br><span class="line">i l q ^S ^Q n s   x +	SuperStarII</span><br><span class="line">i l q ^S ^Q       x +	Motorola Oncore</span><br><span class="line">i l q ^S ^Q   s   x +	True North</span><br><span class="line">i l q ^S ^Q          	JSON slave driver</span><br></pre></td></tr></table></figure>





<h1 id="Linux-gpspipe-命令-显示-GPS-数据流"><a href="#Linux-gpspipe-命令-显示-GPS-数据流" class="headerlink" title="Linux gpspipe 命令 - 显示 GPS 数据流"></a>Linux gpspipe 命令 - 显示 GPS 数据流</h1><h2 id="介绍-32"><a href="#介绍-32" class="headerlink" title="介绍"></a>介绍</h2><p><strong>gpspipe</strong>（英文全拼：GPS pipe）是 GPSD 软件包中的一个命令行工具，用于连接 gpsd 守护进程并将接收到的数据输出到 stdout。这使得 gpspipe 可用作从 gpsd 到另一个程序或文件的管道，从而实现读取实时的 GPS 数据流的功能。</p>
<p>gpspipe 的输出将包含原始 NMEA 或本地 GPSD 语句之一或两者，每行都可以选择带有时间戳。gpspipe 默认从本地主机的 2947 端口上获取并监视 gpsd 打开的所有设备，你也可以选择指定的服务器、TCP&#x2F;IP 端口号和远程设备。</p>
<p>提示</p>
<p>执行 gpspipe 命令不需要 root 权限，并且可以与连接到本地 gpsd 的其他工具同时运行。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpspipe [OPTIONS] [server[:port[:device]]]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-2</code>：设置 split24 标志。</li>
<li><code>-d</code>：作为守护进程运行。</li>
<li><code>-h</code>：显示帮助信息。</li>
<li><code>-l</code>：连接 gpsd 之前休眠十秒钟。</li>
<li><code>-n [count]</code>：计数数据包后退出。</li>
<li><code>-o [file]</code>：将输出写入文件。</li>
<li><code>-P</code>：在 NMEA 或原始模式下包含 JSON 格式的 PPS 信息。</li>
<li><code>-p</code>：在 JSON 中包含分析信息。</li>
<li><code>-r</code>：转储原始 NMEA。</li>
<li><code>-R</code>：转储超级原始模式（GPS 二进制）。</li>
<li><code>-s [serial dev]</code>：在串口上模拟 4800bps NMEA GPS（需要与 <code>-r</code> 选项一起使用）。</li>
<li><code>-S</code>：设置缩放标志（用于 AIS 和子帧数据）。</li>
<li><code>-T [format]</code>：设置时间戳格式（类似于 strftime，隐含 <code>-t</code> 选项）。</li>
<li><code>-t</code>：为数据添加时间戳。</li>
<li><code>-u</code>：usec 时间戳（隐含 <code>-t</code> 选项）。使用 <code>-uu</code> 输出 <em>sec.usec</em>。</li>
<li><code>-v</code>：打印一个小旋转器（spinner）。</li>
<li><code>-V</code>：显示版本信息并退出。</li>
<li><code>-w</code>：转储 gpsd 本机数据。</li>
<li><code>-x [seconds]</code>：指定延迟 seconds 秒后退出。</li>
<li><code>-Z</code>：设置时间戳格式为 iso8601（隐含 <code>-t</code> 选项）。</li>
</ul>
<p>提示</p>
<p>选项 <code>-r</code>、<code>-R</code> 或 <code>-w</code> 必须选择一个或多个；如果使用 <code>-d</code> 选项，那么必须使用 <code>-o</code> 选项。</p>
<h2 id="示例-32"><a href="#示例-32" class="headerlink" title="示例"></a>示例</h2><p>以默认格式显示 GPS 数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpspipe</span><br></pre></td></tr></table></figure>



<p>以原始 NMEA 格式显示 GPS 数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpspipe -r</span><br></pre></td></tr></table></figure>



<p>使用 grep 命令在 gpspipe 中过滤数据并显示特定信息。例如，要显示 GPS Fix 数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpspipe -w | grep -m 1 <span class="string">&#x27;TPV&#x27;</span> | jq <span class="string">&#x27;.tpv | &#123;lat, lon, alt&#125;&#x27;</span></span><br></pre></td></tr></table></figure>



<p>这会在标准输出中显示最新的 GPS Fix 数据，并仅显示经度、纬度和高度信息。在此命令中，管道（<code>|</code>）符号用于将 gpspipe 所生成的输出输入到 grep 中。-m 参数指定仅匹配一次，以便仅显示最新数据。你可以根据你的需求，使用其他选项来过滤数据。</p>
<p>注意：在上述命令中，使用了 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/jq/">jq</a> 命令来格式化 JSON 数据并仅显示特定字段。</p>
<h1 id="Linux-debootstrap-命令-创建-Debian-基础文件系统"><a href="#Linux-debootstrap-命令-创建-Debian-基础文件系统" class="headerlink" title="Linux debootstrap 命令 - 创建 Debian 基础文件系统"></a>Linux debootstrap 命令 - 创建 Debian 基础文件系统</h1><h2 id="介绍-33"><a href="#介绍-33" class="headerlink" title="介绍"></a>介绍</h2><p><strong>debootstrap</strong> 是 Debian&#x2F;Ubuntu 下的一个工具，用于构建一套基本的系统（根文件系统）。生成的目录符合 Linux 文件系统标准（FHS），即包含了 &#x2F;boot、&#x2F;etc、&#x2F;bin、&#x2F;usr 等等目录，但它比发行版本的 Linux 体积小很多，当然功能也没那么强大，因此，只能说是“基本的系统”。</p>
<p>debootstrap 通常用于安装基本的 Debian 系统到一个指定目录，以便在该目录中进行 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/chroot/">chroot</a> 操作；或者用于创建一个用于安装新系统的基础文件系统，以测试不同 Debian 版本和系统架构。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">debootstrap [OPTION]... &lt;suite&gt; &lt;target&gt; [&lt;mirror&gt; [&lt;script&gt;]]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>--arch=A</code>：指定目标系统的架构，如 amd64、i386、powerpc 等。</li>
<li><code>--variant=X</code>：指定文件系统的变种，常见的有 <code>buildd</code>、<code>fakechroot</code>、<code>minbase</code> 等。</li>
<li><code>--components=A,B,C</code>：指定要包含的软件包组件，如 <code>main</code>、<code>contrib</code>、<code>non-free</code>。</li>
<li><code>--include=A,B,C</code>：指定要包含在安装中的额外软件包。</li>
<li><code>--exclude=A,B,C</code>：指定要从安装中排除的软件包。</li>
</ul>
<h2 id="示例-33"><a href="#示例-33" class="headerlink" title="示例"></a>示例</h2><p>在指定目录中创建一个基本的 Debian 系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> debootstrap stable /path/to/installation/directory</span><br></pre></td></tr></table></figure>



<p>在指定目录中创建一个基本的 Debian 系统，并指定架构和变种：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> debootstrap --<span class="built_in">arch</span> amd64 --variant=minbase buster /path/to/installation/directory</span><br></pre></td></tr></table></figure>



<p>在指定目录中创建一个基本的 Debian 系统，并包含 <code>build-essential</code> 和 <code>git</code> 软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> debootstrap buster /path/to/installation/directory --include=build-essential,git</span><br></pre></td></tr></table></figure>



<p>在指定目录中创建一个基本的 Debian 系统，但排除安装 <code>python</code> 软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> debootstrap buster /path/to/installation/directory --exclude=python</span><br></pre></td></tr></table></figure>



<p>在指定目录中创建一个基本的 Debian 系统，使用指定的本地镜像源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> debootstrap --<span class="built_in">arch</span> amd64 --variant=minbase --include=build-essential,git,locales buster /path/to/installation/directory http://ftp.us.debian.org/debian</span><br></pre></td></tr></table></figure>



<p>提示</p>
<p>请注意，<code>debootstrap</code> 命令需要在具有 <code>sudo</code> 权限的系统上运行。上述示例中的版本（如 <code>buster</code>）和软件包名称应根据实际需求进行调整。此外，要在创建的 Debian 系统中进行 chroot，你可能需要额外的配置，如 <code>mount</code>、<code>chroot</code> 等。</p>
<h1 id="Linux-capinfos-命令-显示-pcap-文件信息"><a href="#Linux-capinfos-命令-显示-pcap-文件信息" class="headerlink" title="Linux capinfos 命令 - 显示 pcap 文件信息"></a>Linux capinfos 命令 - 显示 pcap 文件信息</h1><h2 id="介绍-34"><a href="#介绍-34" class="headerlink" title="介绍"></a>介绍</h2><p><strong>capinfos</strong> 是 Wireshark 工具集中的一个命令，用于查看 pcap 文件（网络捕获文件）的基本信息，包括文件大小、记录数量、时间戳范围等信息。</p>
<p>使用前请确保你的系统上已经安装 Wireshark 工具，如果未安装，可以参考下面安装方法：</p>
<ul>
<li>Ubuntu</li>
<li>CentOS&#x2F;RHEL</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install wireshark</span><br></pre></td></tr></table></figure>



<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/editcap/">editcap</a>, <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/mergecap/">mergecap</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">capinfos [options] &lt;infile&gt; ...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li>General infos:<ul>
<li><code>-t</code>：显示捕获文件的类型。</li>
<li><code>-E</code>：显示捕获文件封装（encapsulation）。</li>
<li><code>-I</code>：显示抓包文件接口信息。</li>
<li><code>-F</code>：显示附加捕获文件信息。</li>
<li><code>-H</code>：显示文件的 SHA256、RIPEMD160 和 SHA1 哈希值。</li>
<li><code>-k</code>：显示捕获的注释（comment）。</li>
</ul>
</li>
<li>Size infos:<ul>
<li><code>-c</code>：显示数据包数量。</li>
<li><code>-s</code>：显示文件的大小（以字节为单位）。</li>
<li><code>-d</code>：显示所有数据包的总长度（以字节为单位）。</li>
<li><code>-l</code>：显示数据包大小限制（快照长度）。</li>
</ul>
</li>
<li>Time infos:<ul>
<li><code>-u</code>：显示捕获持续时间（以秒为单位）。</li>
<li><code>-a</code>：显示捕获开始时间。</li>
<li><code>-e</code>：显示捕获结束时间。</li>
<li><code>-o</code>：显示捕获文件的时间顺序状态（True&#x2F;False）。</li>
<li><code>-S</code>：将开始和结束时间显示为秒。</li>
</ul>
</li>
<li>Statistic infos:<ul>
<li><code>-y</code>：显示平均数据速率（以字节&#x2F;秒为单位）。</li>
<li><code>-i</code>：显示平均数据速率（以位&#x2F;秒为单位）。</li>
<li><code>-z</code>：显示平均数据包大小（以字节为单位）。</li>
<li><code>-x</code>：显示平均数据包速率（以数据包&#x2F;秒为单位）。</li>
</ul>
</li>
<li>Metadata infos:<ul>
<li><code>-n</code>：显示已解析的 IPv4 和 IPv6 地址的数量。</li>
<li><code>-D</code>：显示解密密钥（decryption secrets）的数量。</li>
</ul>
</li>
<li>Output format:<ul>
<li><code>-L</code>：生成长报告（默认）。</li>
<li><code>-T</code>：生成表格报告。</li>
<li><code>-M</code>：在长报告中显示机器可读的值。</li>
</ul>
</li>
<li>Table report options:<ul>
<li><code>-R</code>：生成头记录（默认）。</li>
<li><code>-r</code>：不生成头记录。</li>
<li><code>-B</code>：用 TAB 字符分隔信息（默认）。</li>
<li><code>-m</code>：用逗号（<code>,</code>）字符分隔信息。</li>
<li><code>-b</code>：用 SPACE（空格）字符分隔信息。</li>
<li><code>-N</code>：不引用信息（默认）。</li>
<li><code>-q</code>：用单引号（<code>&#39;</code>）引用信息。</li>
<li><code>-Q</code>：用双引号（<code>&quot;</code>）引用信息。</li>
</ul>
</li>
<li>Miscellaneous:<ul>
<li><code>-h, --help</code>：显示帮助信息并退出。</li>
<li><code>-v, --version</code>：显示版本信息并退出。</li>
<li><code>-C</code>：如果文件打开失败则取消处理（默认为继续）。</li>
<li><code>-A</code>：生成所有信息（默认）。</li>
<li><code>-K</code>：禁用显示捕获注释（comment）。</li>
</ul>
</li>
</ul>
<h2 id="示例-34"><a href="#示例-34" class="headerlink" title="示例"></a>示例</h2><p>不带任何选项参数，以默认方式显示 pcap 文件的所有基本信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ capinfos 2023-09-26-14-31-42-30s.pcap</span><br><span class="line">File name:           2023-09-26-14-31-42-30s.pcap</span><br><span class="line">File <span class="built_in">type</span>:           Wireshark/tcpdump/... - pcap</span><br><span class="line">File encapsulation:  Ethernet</span><br><span class="line">File timestamp precision:  microseconds (6)</span><br><span class="line">Packet size <span class="built_in">limit</span>:   file hdr: 65535 bytes</span><br><span class="line">Number of packets:   300 k</span><br><span class="line">File size:           261 MB</span><br><span class="line">Data size:           256 MB</span><br><span class="line">Capture duration:    30.096327 seconds</span><br><span class="line">First packet <span class="keyword">time</span>:   2023-09-26 14:33:25.555011</span><br><span class="line">Last packet <span class="keyword">time</span>:    2023-09-26 14:33:55.651338</span><br><span class="line">Data byte rate:      8,512 kBps</span><br><span class="line">Data bit rate:       68 Mbps</span><br><span class="line">Average packet size: 854.00 bytes</span><br><span class="line">Average packet rate: 9,967 packets/s</span><br><span class="line">SHA256:              4cd82ce1b8fd3d498794d14e2ada82a3acbafca64f1e699574e58a6deec600cc</span><br><span class="line">RIPEMD160:           347128fa0c6a4aeabcdeb71b1e6cdaf94d100999</span><br><span class="line">SHA1:                a800fa328b3e65af40d2b783b37e0a2b5d80591f</span><br><span class="line">Strict <span class="keyword">time</span> order:   True</span><br><span class="line">Number of interfaces <span class="keyword">in</span> file: 1</span><br><span class="line">Interface <span class="comment">#0 info:</span></span><br><span class="line">                     Encapsulation = Ethernet (1 - ether)</span><br><span class="line">                     Capture length = 65535</span><br><span class="line">                     Time precision = microseconds (6)</span><br><span class="line">                     Time ticks per second = 1000000</span><br><span class="line">                     Number of <span class="built_in">stat</span> entries = 0</span><br><span class="line">                     Number of packets = 300000</span><br></pre></td></tr></table></figure>



<p>显示 pcap 文件的总大小：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ capinfos -s 2023-09-26-14-31-42-30s.pcap</span><br><span class="line">File name:           2023-09-26-14-31-42-30s.pcap</span><br><span class="line">File size:           261 MB</span><br></pre></td></tr></table></figure>



<p>显示 pcap 文件的时间长度：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ capinfos -u 2023-09-26-14-31-42-30s.pcap</span><br><span class="line">File name:           2023-09-26-14-31-42-30s.pcap</span><br><span class="line">Capture duration:    30.096327 seconds</span><br></pre></td></tr></table></figure>



<p>显示 pcap 文件的数据包总量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ capinfos -c 2023-09-26-14-31-42-30s.pcap</span><br><span class="line">File name:           2023-09-26-14-31-42-30s.pcap</span><br><span class="line">Number of packets:   300 k</span><br></pre></td></tr></table></figure>





<h1 id="Linux-editcap-命令-编辑和转换-pcap-文件"><a href="#Linux-editcap-命令-编辑和转换-pcap-文件" class="headerlink" title="Linux editcap 命令 - 编辑和转换 pcap 文件"></a>Linux editcap 命令 - 编辑和转换 pcap 文件</h1><h2 id="介绍-35"><a href="#介绍-35" class="headerlink" title="介绍"></a>介绍</h2><p><strong>editcap</strong> 是 Wireshark 工具集中的一个命令，用于编辑 pcap 文件（网络捕获文件），包括截断、拆分、过滤等操作。这个命令允许你对捕获的网络流量进行一些基本的编辑，以便更好地分析和处理。</p>
<p>使用前请确保你的系统上已经安装 Wireshark 工具，如果未安装，可以参考下面安装方法：</p>
<ul>
<li>Ubuntu</li>
<li>CentOS&#x2F;RHEL</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install wireshark</span><br></pre></td></tr></table></figure>



<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/capinfos/">capinfos</a>, <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/mergecap/">mergecap</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">editcap [options] ... &lt;infile&gt; &lt;outfile&gt; [ &lt;packet#&gt;[-&lt;packet#&gt;] ... ]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-r</code>：保留选定的数据包（默认是删除它们）。</li>
<li><code>-A &lt;start time&gt;</code>：只读取时间戳晚于（或等于）给定时间的数据包。时间格式为 <code>YYYY-MM-DDThh:mm:ss[.nnnnnnnnn][Z|+-hh:mm]</code>。</li>
<li><code>-B &lt;stop time&gt;</code>：只读取时间戳早于给定时间的数据包。时间格式同上。</li>
<li><code>-s &lt;snaplen&gt;</code>：将每个数据包截断为最大值 <code>&lt;snaplen&gt;</code> 字节数据。</li>
<li><code>-C [offset:]&lt;choplen&gt;</code>：将每个数据包切割 <code>&lt;choplen&gt;</code> 字节。正值在数据包开始处截断，负值在数据包结尾处截断。如果可选偏移量位于长度之前，则截断的字节将从该值开始偏移。正偏移量是从数据包开始处开始的，负偏移量是从数据包结束处开始的。你可以多次使用此选项，允许数据包内最多有 2 个斩波区域（chopping regions），前提是至少 1 个 choplen 为正值，至少 1 个为负值。</li>
<li><code>-c &lt;packets per file&gt;</code>：根据统一的数据包计数将数据包输出拆分到不同的文件，每个文件最多为 <code>&lt;packets per file&gt;</code>。</li>
<li><code>-i &lt;seconds per file&gt;</code>：根据统一的时间间隔将数据包输出拆分到不同的文件，每个文件的最大时间间隔为 <code>&lt;seconds per file&gt;</code>。</li>
<li><code>-F &lt;capture type&gt;</code>：设置输出文件类型，默认为 pcapng。空的 <code>-F</code> 选项将列出文件类型。</li>
<li><code>-T &lt;encap type&gt;</code>：设置输出文件封装类型，默认与输入文件相同。空的 <code>-T</code> 选项将列出封装类型。</li>
</ul>
<h2 id="示例-35"><a href="#示例-35" class="headerlink" title="示例"></a>示例</h2><p>假设有个 30 秒的 pcap 文件 2023-09-26-14-31-42-30s.pcap，我们先用 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/capinfos/"><code>capinfos</code></a> 命令查看它的起始和结束时间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ capinfos -a 2023-09-26-14-31-42-30s.pcap</span><br><span class="line">File name:           2023-09-26-14-31-42-30s.pcap</span><br><span class="line">First packet <span class="keyword">time</span>:   2023-09-26 14:33:25.555011</span><br><span class="line">$ capinfos -e 2023-09-26-14-31-42-30s.pcap</span><br><span class="line">File name:           2023-09-26-14-31-42-30s.pcap</span><br><span class="line">Last packet <span class="keyword">time</span>:    2023-09-26 14:33:55.651338</span><br></pre></td></tr></table></figure>



<p>现在，我们前后分别偏移 10 秒，即截取中间的 10 秒数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">editcap -A 2023-09-26T14:33:35 -B 2023-09-26T14:33:45 2023-09-26-14-31-42-30s.pcap 2023-09-26-14-31-42-10s.pcap</span><br></pre></td></tr></table></figure>



<p>按 1000 个包为间隔将 pcap 文件拆分成多个文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">editcap -c 1000 2023-09-26-14-31-42-30s.pcap output.pcap</span><br></pre></td></tr></table></figure>



<p>此时会在当前目录生成许多 <code>output_00*</code> 开头的 pcap 文件，例如 output_00214_20230926143347.pcap。</p>
<h1 id="Linux-mergecap-命令-合并多个-pcap-文件"><a href="#Linux-mergecap-命令-合并多个-pcap-文件" class="headerlink" title="Linux mergecap 命令 - 合并多个 pcap 文件"></a>Linux mergecap 命令 - 合并多个 pcap 文件</h1><h2 id="介绍-36"><a href="#介绍-36" class="headerlink" title="介绍"></a>介绍</h2><p><strong>mergecap</strong> 是 Wireshark 工具集中的一个命令，用于将多个 pcap 文件（网络捕获文件）合并为一个文件。这个命令允许你将多个捕获文件的数据合并到一个文件中，方便进行整体分析和处理。</p>
<p>使用前请确保你的系统上已经安装 Wireshark 工具，如果未安装，可以参考下面安装方法：</p>
<ul>
<li>Ubuntu</li>
<li>CentOS&#x2F;RHEL</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install wireshark</span><br></pre></td></tr></table></figure>



<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/editcap/">editcap</a>, <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/capinfos/">capinfos</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mergecap [options] -w &lt;outfile&gt;|- &lt;infile&gt; [&lt;infile&gt; ...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>：连接而不是合并文件，默认是根据帧时间戳进行合并。</li>
<li><code>-s &lt;snaplen&gt;</code>：将数据包截断为 <code>&lt;snaplen&gt;</code> 数据字节。</li>
<li><code>-w &lt;outfile&gt;|-</code>：将输出文件名设置为 <code>&lt;outfile&gt;</code> 或标准输出的 <code>-</code>。</li>
<li><code>-F &lt;capture type&gt;</code>：设置输出文件类型； 默认为 pcapng。空的 <code>-F</code> 选项将列出文件类型。</li>
<li><code>-I &lt;IDB merge mode&gt;</code>：设置接口描述块的合并模式，默认为 all。空的 <code>-I</code> 选项将列出合并模式。</li>
</ul>
<h2 id="示例-36"><a href="#示例-36" class="headerlink" title="示例"></a>示例</h2><p>列出支持的所有合并模式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mergecap -I</span><br><span class="line">mergecap: option requires an argument: I</span><br><span class="line">mergecap: The available IDB merge modes <span class="keyword">for</span> the <span class="string">&quot;-I&quot;</span> flag are:</span><br><span class="line">    none</span><br><span class="line">    all</span><br><span class="line">    any</span><br></pre></td></tr></table></figure>



<p>将合并 <code>file1.pcap</code> 和 <code>file2.pcap</code> 两个文件，并将结果保存到 <code>new.pcap</code> 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mergecap file1.pcap file2.pcap -w new.pcap</span><br></pre></td></tr></table></figure>



<p>也可以使用通配符来检索输入文件，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mergecap file*.pcap -w new.pcap</span><br></pre></td></tr></table></figure>



<p>在输入文件特别多的情况下非常有用！</p>
<h1 id="Linux-jq-命令-JSON-数据处理器"><a href="#Linux-jq-命令-JSON-数据处理器" class="headerlink" title="Linux jq 命令 - JSON 数据处理器"></a>Linux jq 命令 - JSON 数据处理器</h1><h2 id="介绍-37"><a href="#介绍-37" class="headerlink" title="介绍"></a>介绍</h2><p><strong>jq</strong> 是一个轻量级的和灵活的命令行 JSON 处理器，用于解析、查询和转换 JSON 数据。它可以帮助用户在命令行中轻松地处理和操作 JSON 格式的数据。</p>
<p>jq 的一个常见的使用场景是处理 JSON 输入，设置过滤器应用于其 JSON 文本输入，并将过滤器的结果生成为新的 JSON 文本打印到标准输出。最简单的过滤器是 <code>.</code>，它将 jq 的输入未经修改地复制到其输出中（格式设置除外）。</p>
<p>另外，需要注意的是，jq 当前仅支持 64 位双精度浮点数（IEEE754）。</p>
<ul>
<li>项目主页：<a target="_blank" rel="noopener" href="https://jqlang.github.io/jq">https://jqlang.github.io/jq</a></li>
<li>GitHub 仓库：<a target="_blank" rel="noopener" href="https://github.com/jqlang/jq">https://github.com/jqlang/jq</a></li>
</ul>
<p><strong>安装</strong>：</p>
<p>使用前请确保你的系统上已经安装 jq 工具，如果未安装，可以参考下面安装方法：</p>
<ul>
<li>Debian&#x2F;Ubuntu</li>
<li>CentOS&#x2F;RHEL</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install jq</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jq [options] &lt;jq filter&gt; [file...]</span><br><span class="line">jq [options] --args &lt;jq filter&gt; [strings...]</span><br><span class="line">jq [options] --jsonargs &lt;jq filter&gt; [JSON_TEXTS...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-c</code>：使用紧凑而不是漂亮的输出。</li>
<li><code>-n</code>：使用 <code>null</code> 作为单个输入值。</li>
<li><code>-e</code>：根据输出设置退出状态代码。</li>
<li><code>-s</code>：将所有输入读取（slurp）到数组中；对其应用过滤器。</li>
<li><code>-r</code>：输出原始字符串，而不是 JSON 文本。</li>
<li><code>-R</code>：读取原始字符串，而不是 JSON文本。</li>
<li><code>-C</code>：为 JSON 着色。</li>
<li><code>-M</code>：单色（不要为 JSON 着色）。</li>
<li><code>-S</code>：在输出上排序对象的键。</li>
<li><code>--tab</code>：使用制表符进行缩进。</li>
<li><code>--arg a v</code>：将变量 <code>$a</code> 设置为值 <code>&lt;v&gt;</code>。</li>
<li><code>--argjson a v</code>：将变量 <code>$a</code> 设置为 JSON 格式的值 <code>&lt;v&gt;</code>。</li>
<li><code>--slurpfile a f</code>：将变量 <code>$a</code> 设置为从 <code>&lt;f&gt;</code> 读取的 JSON 文本数组。</li>
<li><code>--rawfile a f</code>：将变量 <code>$a</code> 设置为包含 <code>&lt;f&gt;</code> 内容的字符串。</li>
<li><code>--args</code>：其余参数是字符串参数，而不是文件。</li>
<li><code>--jsonargs</code>：其余的参数是 JSON 参数，而不是文件。</li>
<li><code>--</code>：终止参数处理。</li>
</ul>
<h2 id="示例-37"><a href="#示例-37" class="headerlink" title="示例"></a>示例</h2><p>以漂亮的方式输出全部 JSON 数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;&#123; &quot;home&quot;: &#123; &quot;bedroom&quot;: &#123; &quot;temperature&quot;: 25.0 &#125; &#125; &#125;&#x27;</span> | jq <span class="string">&#x27;.&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;home&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;bedroom&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;temperature&quot;</span>: 25</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以紧凑的方式输出全部 JSON 数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;&#123; &quot;home&quot;: &#123; &quot;bedroom&quot;: &#123; &quot;temperature&quot;: 25.0 &#125; &#125; &#125;&#x27;</span> | jq -c <span class="string">&#x27;.&#x27;</span></span><br><span class="line">&#123;<span class="string">&quot;home&quot;</span>:&#123;<span class="string">&quot;bedroom&quot;</span>:&#123;<span class="string">&quot;temperature&quot;</span>:25&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>



<p>获取一个键的值（可以试试 <code>.home</code>、<code>.home.bedroom</code>、<code>.home?</code> 等过滤条件）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;&#123; &quot;home&quot;: &#123; &quot;bedroom&quot;: &#123; &quot;temperature&quot;: 25.0 &#125; &#125; &#125;&#x27;</span> | jq <span class="string">&#x27;.home.bedroom.temperature&#x27;</span></span><br><span class="line">25</span><br></pre></td></tr></table></figure>



<p>数组运算（可以试试 <code>.[]</code>、<code>.[]?</code>、<code>.[2]</code>、<code>.[0:10]</code> 等过滤条件）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;[&#123;&quot;name&quot;:&quot;bedroom1&quot;, &quot;temp&quot;:22.0&#125;, &#123;&quot;name&quot;:&quot;bedroom2&quot;, &quot;temp&quot;:28.0&#125;]&#x27;</span> | jq <span class="string">&#x27;.[1]&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bedroom2&quot;</span>,</span><br><span class="line">  <span class="string">&quot;temp&quot;</span>: 28</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>构造一个数组&#x2F;对象（通过 <code>[], {}</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;&#123;&quot;user&quot;:&quot;stedolan&quot;,&quot;titles&quot;:[&quot;JQ Primer&quot;, &quot;More JQ&quot;]&#125;&#x27;</span> | jq <span class="string">&#x27;&#123;user, title: .titles[]&#125;&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;user&quot;</span>: <span class="string">&quot;stedolan&quot;</span>,</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;JQ Primer&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;user&quot;</span>: <span class="string">&quot;stedolan&quot;</span>,</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;More JQ&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>计算一个值的长度（通过 <code>length</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;[[1,2], &quot;string&quot;, &#123;&quot;a&quot;:2&#125;, null]&#x27;</span> | jq <span class="string">&#x27;.[] | length&#x27;</span></span><br><span class="line">2</span><br><span class="line">6</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>



<p>取出数组中的键（通过 <code>keys</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;&#123;&quot;abc&quot;: 1, &quot;abcd&quot;: 2, &quot;Foo&quot;: 3&#125;&#x27;</span> | jq <span class="string">&#x27;keys&#x27;</span></span><br><span class="line">[</span><br><span class="line">  <span class="string">&quot;Foo&quot;</span>,</span><br><span class="line">  <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">  <span class="string">&quot;abcd&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>使用多个过滤器（通过 <code>,</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;&#123; &quot;foo&quot;: 42, &quot;bar&quot;: &quot;something else&quot;, &quot;baz&quot;: true&#125;&#x27;</span> | jq <span class="string">&#x27;.foo, .bar&#x27;</span></span><br><span class="line">42</span><br><span class="line"><span class="string">&quot;something else&quot;</span></span><br></pre></td></tr></table></figure>



<p>通过管道将一个过滤器的输出当做下一个过滤器的输入（通过 <code>|</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;[&#123;&quot;name&quot;:&quot;bedroom1&quot;, &quot;temp&quot;:22.0&#125;, &#123;&quot;name&quot;:&quot;bedroom2&quot;, &quot;temp&quot;:28.0&#125;]&#x27;</span> | jq <span class="string">&#x27;.[] | .name&#x27;</span></span><br><span class="line"><span class="string">&quot;bedroom1&quot;</span></span><br><span class="line"><span class="string">&quot;bedroom2&quot;</span></span><br></pre></td></tr></table></figure>



<p>通过 <code>select()</code> 选择器筛选，选出大于等于 3 的值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;[1,5,3,2,0,4,7]&#x27;</span> | jq <span class="string">&#x27;map(select(. &gt;= 3))&#x27;</span></span><br><span class="line">[</span><br><span class="line">  5,</span><br><span class="line">  3,</span><br><span class="line">  4,</span><br><span class="line">  7</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>通过 <code>map()</code> 将每个输入的值加一：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;[1,2,3]&#x27;</span> | jq <span class="string">&#x27;map(.+1)&#x27;</span></span><br><span class="line">[</span><br><span class="line">  2,</span><br><span class="line">  3,</span><br><span class="line">  4</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>条件判断（<code>if-then-else-end</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;2&#x27;</span> | jq <span class="string">&#x27;if . == 0 then &quot;zero&quot; elif . == 1 then &quot;one&quot; else &quot;many&quot; end&#x27;</span></span><br><span class="line"><span class="string">&quot;many&quot;</span></span><br></pre></td></tr></table></figure>



<p>在字符串中插入值并进行运算（通过 <code>\()</code> 表达式）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;12&#x27;</span> | jq <span class="string">&#x27;&quot;The input was \(.), which is one less than \(.+1)&quot;&#x27;</span></span><br><span class="line"><span class="string">&quot;The input was 12, which is one less than 13&quot;</span></span><br></pre></td></tr></table></figure>





<h1 id="Linux-gcc-命令-GNU-C-编译器"><a href="#Linux-gcc-命令-GNU-C-编译器" class="headerlink" title="Linux gcc 命令 - GNU C 编译器"></a>Linux gcc 命令 - GNU C 编译器</h1><h2 id="介绍-38"><a href="#介绍-38" class="headerlink" title="介绍"></a>介绍</h2><p><strong>GCC</strong>（英文全拼：GNU Compiler Collection）是 GNU 工具链的主要组成部分，是一套以 GPL 和 LGPL 许可证发布的程序语言编译器自由软件，由 Richard Stallman 于 1985 年开始开发。</p>
<p>GCC 原名为 GNU C语言编译器，因为它原本只能处理 C 语言，但如今的 GCC 不仅可以编译 C、C++ 和 Objective-C，还可以通过不同的前端模块支持各种语言，包括 Java、Fortran、Ada、Pascal、Go 和 D 语言等等。</p>
<p>GCC 的编译过程可以划分为四个阶段：预处理（Pre-Processing）、编译（Compiling）、汇编（Assembling）以及链接（Linking）。</p>
<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/gcc-process.png" alt="img"></p>
<p>Linux 程序员可以根据自己的需要控制 GCC 的编译阶段，以便检查或使用编译器在该阶段的输出信息，帮助调试和优化程序。以 C 语言为例，从源文件的编译到可执行文件的运行，整个过程大致如下。</p>
<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/what-happens-when-you-type-gcc.png" alt="img"></p>
<p>各文件后缀说明如下：</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>描述</th>
<th>后缀</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.c</td>
<td>C 源文件</td>
<td>.s&#x2F;.S</td>
<td>汇编语言源文件</td>
</tr>
<tr>
<td>.C&#x2F;.cc&#x2F;.cxx&#x2F;.cpp</td>
<td>C++ 源文件</td>
<td>.o&#x2F;.obj</td>
<td>目标文件</td>
</tr>
<tr>
<td>.h</td>
<td>C&#x2F;C++ 头文件</td>
<td>.a&#x2F;.lib</td>
<td>静态库</td>
</tr>
<tr>
<td>.i&#x2F;.ii</td>
<td>经过预处理的 C&#x2F;C++ 文件</td>
<td>.so&#x2F;.dll</td>
<td>动态库</td>
</tr>
</tbody></table>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc [options] file...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-pass-exit-codes</code> ：从一个阶段以最高错误代码退出。</li>
<li><code>--target-help</code> ：显示特定于目标的命令行选项。</li>
<li><code>--help={common|optimizers|params|target|warnings|[^]{joined|separate|undocumented}}[,...]</code> ：显示特定类型的命令行选项（使用 <code>-v --help</code> 显示子进程的命令行选项）。</li>
<li><code>-dumpspecs</code> ：显示所有内置规范字符串。</li>
<li><code>-dumpversion</code> ：显示编译器的版本。</li>
<li><code>-dumpmachine</code> ：显示编译器的目标处理器。</li>
<li><code>-print-search-dirs</code> ：显示编译器搜索路径中的目录。</li>
<li><code>-print-libgcc-file-name</code> ：显示编译器配套库的名称。</li>
<li><code>-print-file-name=&lt;lib&gt;</code> ：显示库 <code>&lt;lib&gt;</code> 的完整路径。</li>
<li><code>-print-prog-name=&lt;prog&gt;</code> ：显示编译器组件 <code>&lt;prog&gt;</code> 的完整路径。</li>
<li><code>-print-multiarch</code> ：显示目标的规范化 GNU 三元组，用作库路径中的一个组件。</li>
<li><code>-print-multi-directory</code> ：显示 libgcc 版本的根目录。</li>
<li><code>-print-multi-lib</code> ：显示命令行选项和多个库搜索目录之间的映射。</li>
<li><code>-print-multi-os-directory</code> ：显示操作系统库的相对路径。</li>
<li><code>-print-sysroot</code> ：显示目标库目录。</li>
<li><code>-print-sysroot-headers-suffix</code> ：显示用于查找标题的 sysroot 后缀。</li>
<li><code>-Wa,&lt;options&gt;</code> ：将逗号分隔的 <code>&lt;options&gt;</code> 传递给汇编器（assembler）。</li>
<li><code>-Wp,&lt;options&gt;</code> ：将逗号分隔的 <code>&lt;options&gt;</code> 传递给预处理器（preprocessor）。</li>
<li><code>-Wl,&lt;options&gt;</code> ：将逗号分隔的 <code>&lt;options&gt;</code> 传递给链接器（linker）。</li>
<li><code>-Xassembler &lt;arg&gt;</code> ：将 <code>&lt;arg&gt;</code> 传递给汇编器（assembler）。</li>
<li><code>-Xpreprocessor &lt;arg&gt;</code> ：将 <code>&lt;arg&gt;</code> 传递给预处理器（preprocessor）。</li>
<li><code>-Xlinker &lt;arg&gt;</code> ：将 <code>&lt;arg&gt;</code> 传递给链接器（linker）。</li>
<li><code>-save-temps</code> ：不用删除中间文件。</li>
<li><code>-save-temps=&lt;arg&gt;</code> ：不用删除指定的中间文件。</li>
<li><code>-no-canonical-prefixes</code> ：在构建其他 gcc 组件的相对前缀时，不要规范化路径。</li>
<li><code>-pipe</code> ：使用管道而不是中间文件。</li>
<li><code>-time</code> ：为每个子流程的执行计时。</li>
<li><code>-specs=&lt;file&gt;</code> ：使用 <code>&lt;file&gt;</code> 的内容覆盖内置规范。</li>
<li><code>-std=&lt;standard&gt;</code> ：假设输入源为 <code>&lt;standard&gt;</code>。</li>
<li><code>--sysroot=&lt;directory&gt;</code> ：使用 <code>&lt;directory&gt;</code> 作为头文件和库的根目录。</li>
<li><code>-B &lt;directory&gt;</code> ：将 <code>&lt;directory&gt;</code> 添加到编译器的搜索路径。</li>
<li><code>-v</code> ：显示编译器调用的程序。</li>
<li><code>-###</code> ：与 <code>-v</code> 类似，但引用的选项和命令不执行。</li>
<li><code>-E</code> ：仅执行预处理（不要编译、汇编或链接）。</li>
<li><code>-S</code> ：只编译（不汇编或链接）。</li>
<li><code>-c</code> ：编译和汇编，但不链接。</li>
<li><code>-o &lt;file&gt;</code> ：指定输出文件。</li>
<li><code>-pie</code> ：创建一个动态链接、位置无关的可执行文件。</li>
<li><code>-I</code> ：指定头文件的包含路径。</li>
<li><code>-L</code> ：指定链接库的包含路径。</li>
<li><code>-shared</code> ：创建共享库&#x2F;动态库。</li>
<li><code>-static</code> ：使用静态链接。</li>
<li><code>--help</code> ：显示帮助信息。</li>
<li><code>--version</code> ：显示编译器版本信息。</li>
</ul>
<h2 id="示例-38"><a href="#示例-38" class="headerlink" title="示例"></a>示例</h2><h3 id="阶段编译"><a href="#阶段编译" class="headerlink" title="阶段编译"></a>阶段编译</h3><p>假设有文件 hello.c，内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, GetIoT\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编译 hello.c，默认输出 a.out</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.c</span><br></pre></td></tr></table></figure>



<p>编译 hello.c 并指定输出文件为 hello</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></table></figure>



<p>只执行预处理，输出 hello.i 源文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure>



<p>只执行预处理和编译，输出 hello.s 汇编文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -S hello.c</span><br></pre></td></tr></table></figure>



<p>也可以由 hello.i 文件生成 hello.s 汇编文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure>



<p>只执行预处理、编译和汇编，输出 hello.o 目标文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c hello.c</span><br></pre></td></tr></table></figure>



<p>也可以由 hello.i 或 hello.s 生成目标文件 hello.o</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c hello.i -o hello.o</span><br><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure>



<p>由 hello.o 目标文件链接成可执行文件 hello</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure>



<h3 id="使用静态库"><a href="#使用静态库" class="headerlink" title="使用静态库"></a>使用静态库</h3><p>创建一个 foo.c 文件，内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Here is a static library\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>将 foo.c 编译成静态库 libfoo.a</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c foo.c             <span class="comment"># 生成 foo.o 目标文件</span></span><br><span class="line">ar rcs libfoo.a foo.o    <span class="comment"># 生成 libfoo.a 静态库</span></span><br></pre></td></tr></table></figure>



<p>查看文件描述</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file *</span><br><span class="line">foo.c:    C <span class="built_in">source</span>, ASCII text</span><br><span class="line">foo.o:    ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span><br><span class="line">libfoo.a: current ar archive</span><br></pre></td></tr></table></figure>



<p>修改 hello.c 文件，调用 foo 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, GetIoT\n&quot;</span>);</span><br><span class="line">    foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编译 hello.c 并链接静态库 libfoo.a（加上 <code>-static</code> 选项）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.c -static libfoo.a -o hello</span><br></pre></td></tr></table></figure>



<p>也可以使用 <code>-L</code> 指定库的搜索路径，并使用 <code>-l</code> 指定库名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.c -static -L. -lfoo -o hello</span><br></pre></td></tr></table></figure>



<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./hello</span><br><span class="line">Hello, GetIoT</span><br><span class="line">Here is a static library</span><br></pre></td></tr></table></figure>



<p>查看 hello 文件描述</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file hello</span><br><span class="line">hello: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=b72236c2211dd8f0c3003bc02ad5e70bb2354e8c, <span class="keyword">for</span> GNU/Linux 3.2.0, not stripped</span><br></pre></td></tr></table></figure>



<h3 id="使用共享库"><a href="#使用共享库" class="headerlink" title="使用共享库"></a>使用共享库</h3><p>修改 foo.c 文件，内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Here is a shared library\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>将其编译为动态库&#x2F;共享库（由于动态库可以被多个进程共享加载，所以需要使用 <code>-fPIC</code> 选项生成位置无关的代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc foo.c -shared -fPIC -o libfoo.so</span><br></pre></td></tr></table></figure>



<p>hello.c 代码无需修改，内容仍然如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, GetIoT\n&quot;</span>);</span><br><span class="line">    foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编译 hello.c 并链接共享库 libfoo.so</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.c libfoo.so -o hello</span><br></pre></td></tr></table></figure>



<p>也可以使用 <code>-L</code> 和 <code>-l</code> 选项指定库的路径和名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.c -L. -lfoo -o hello</span><br></pre></td></tr></table></figure>



<p>但是此时运行 hello 程序失败</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./hello</span><br><span class="line">./hello: error <span class="keyword">while</span> loading shared libraries: libfoo.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>



<p>原因是找不到 libfoo.so 共享库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ldd hello</span><br><span class="line">        linux-vdso.so.1 (0x00007fff5276d000)</span><br><span class="line">        libfoo.so =&gt; not found</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fcc90fa7000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007fcc911bd000)</span><br></pre></td></tr></table></figure>



<p>这是因为 libfoo.so 并不在 Linux 系统的默认搜索目录中，解决办法是我们主动告诉系统，libfoo.so 共享库在哪里。</p>
<p><strong>方式一</strong>：设置环境变量 <code>LD_LIBRARY_PATH</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=$(<span class="built_in">pwd</span>)</span><br></pre></td></tr></table></figure>



<p>将 libfoo.so 所在的当前目录添加到 <code>LD_LIBRARY_PATH</code> 变量，再次执行 hello</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./hello</span><br><span class="line">Hello, GetIoT</span><br><span class="line">Here is a shared library</span><br></pre></td></tr></table></figure>



<p><strong>方式二</strong>：使用 rpath 将共享库位置嵌入到程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.c -L. -lfoo -Wl,-rpath=`<span class="built_in">pwd</span>` -o hello</span><br></pre></td></tr></table></figure>



<p>rpath 即 run path，是种可以将共享库位置嵌入程序中的方法，从而不用依赖于默认位置和环境变量。这里在链接时使用 <code>-Wl,-rpath=/path/to/yours</code> 选项，<code>-Wl</code> 会发送以逗号分隔的选项到链接器，注意逗号分隔符后面没有空格哦。</p>
<p>这种方式要求共享库必须有一个固定的安装路径，欠缺灵活性，不过如果设置了 <code>LD_LIBRARY_PATH</code>，程序加载时也是会到相应路径寻找共享库的。</p>
<p><strong>方式三</strong>：将 libfoo.so 共享库添加到系统路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> libfoo.so /usr/lib/</span><br></pre></td></tr></table></figure>



<p>执行程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./hello</span><br><span class="line">Hello, GetIoT</span><br><span class="line">Here is a shared library</span><br></pre></td></tr></table></figure>



<p>如果 hello 程序仍然运行失败，请尝试执行 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/ldconfig/">ldconfig</a> 命令更新共享库的缓存列表。</p>
<p>此时，再次查看 hello 程序的共享库依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ldd hello</span><br><span class="line">        linux-vdso.so.1 (0x00007ffecfbb1000)</span><br><span class="line">        libfoo.so =&gt; /lib/libfoo.so (0x00007f3f3f1ad000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3f3efbb000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f3f3f1d6000)</span><br></pre></td></tr></table></figure>



<p>可以看到 libfoo.so 已经被发现了，其中 &#x2F;lib 是 &#x2F;usr&#x2F;lib 目录的软链接。</p>
<p>示例代码可以在 <a target="_blank" rel="noopener" href="https://github.com/getiot/linux-c/tree/main/hello">GitHub</a> 找到。</p>
<h1 id="Linux-ldd-命令-显示可执行文件的依赖库"><a href="#Linux-ldd-命令-显示可执行文件的依赖库" class="headerlink" title="Linux ldd 命令 - 显示可执行文件的依赖库"></a>Linux ldd 命令 - 显示可执行文件的依赖库</h1><h2 id="介绍-39"><a href="#介绍-39" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ldd</strong>（英文全拼：list dynamic dependencies）命令列出程序或库文件的动态依赖关系（所依赖的共享库列表）。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ldd [option]... file...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>--version</code>：打印指令版本号</li>
<li><code>-v</code>：详细信息模式，打印所有相关信息</li>
<li><code>-u</code>：打印未使用的直接依赖</li>
<li><code>-d</code>：执行重定位和报告任何丢失的对象</li>
<li><code>-r</code>：执行数据对象和函数的重定位，并且报告任何丢失的对象和函数</li>
<li><code>--help</code>：显示帮助信息</li>
</ul>
<p><strong>参数</strong>：指定可执行程序或者库文件</p>
<p><strong>原理</strong>： ldd 不是个可执行程式，而只是个 shell 脚本；ldd 显示可执行模块的 dependency 的工作原理，其实质是通过 ld-linux.so（elf 动态库的装载器）来实现的。</p>
<h2 id="示例-39"><a href="#示例-39" class="headerlink" title="示例"></a>示例</h2><p>示例：查看 ls 程序运行所依赖的库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ldd /bin/ls</span><br><span class="line">        linux-vdso.so.1 (0x00007ffcc3563000)</span><br><span class="line">        libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f87e5459000)</span><br><span class="line">        libcap.so.2 =&gt; /lib64/libcap.so.2 (0x00007f87e5254000)</span><br><span class="line">        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f87e4e92000)</span><br><span class="line">        libpcre.so.1 =&gt; /lib64/libpcre.so.1 (0x00007f87e4c22000)</span><br><span class="line">        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f87e4a1e000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00005574bf12e000)</span><br><span class="line">        libattr.so.1 =&gt; /lib64/libattr.so.1 (0x00007f87e4817000)</span><br><span class="line">        libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f87e45fa000)</span><br></pre></td></tr></table></figure>



<p>每一行会有两列或三列，含义如下：</p>
<ul>
<li>第1列：程序需要依赖什么库</li>
<li>第2列：系统提供的与程序需要的库所对应的库</li>
<li>第3列：库加载的开始地址</li>
</ul>
<p>通过上面的信息，我们可以得到以下几个信息：</p>
<ol>
<li>通过对比第1列和第2列，我们可以分析程序需要依赖的库和系统实际提供的，是否相匹配</li>
<li>通过观察第3列，我们可以知道在当前的库中的符号在对应的进程的地址空间中的开始位置</li>
</ol>
<p>如果依赖的某个库找不到，通过这个命令可以迅速定位问题所在。</p>
<h1 id="Linux-ldconfig-命令-更新共享库缓存"><a href="#Linux-ldconfig-命令-更新共享库缓存" class="headerlink" title="Linux ldconfig 命令 - 更新共享库缓存"></a>Linux ldconfig 命令 - 更新共享库缓存</h1><h2 id="介绍-40"><a href="#介绍-40" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ldconfig</strong> 命令用于管理 Linux 系统的动态链接库。</p>
<p>执行 ldconfig 命令，默认会在 <code>/lib</code> 和 <code>/usr/lib</code> 目录以及动态库配置文件 <code>/etc/ld.so.conf</code> 内所列出的目录下，搜索出可共享的动态链接库（格式如 <code>lib*.so*</code>），进而创建出动态装入程序（ld.so）所需的连接和缓存文件。缓存文件默认为 <code>/etc/ld.so.cache</code>，此文件保存已排好序的动态链接库名字列表，为了让动态链接库为系统所共享，就需要运行动态链接库的管理命令 ldconfig。</p>
<p>ldconfig 通常在系统启动时运行，当用户安装了一个新的动态链接库时，就需要手动运行该命令，以更新缓存文件。ldconfig 所做操作只与程序运行时有关，和编译过程没有关系，因此编译时需要加 <code>-L</code> 指定库路径的还得加上。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ldconfig [-nNvXV] [-f conf] [-C cache] [-r root] directory...</span><br><span class="line">ldconfig -l [-v] library...</span><br><span class="line">ldconfig -p</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-v</code> 或 <code>--verbose</code> ：用此选项时，ldconfig 将显示正在扫描的目录及搜索到的动态链接库，还有它所创建的连接的名字。</li>
<li><code>-n</code> ：用此选项时，ldconfig 仅扫描命令行指定的目录，不扫描默认目录（&#x2F;lib、&#x2F;usr&#x2F;lib），也不扫描配置文件 &#x2F;etc&#x2F;ld.so.conf 所列的目录。</li>
<li><code>-N</code> ：指示 ldconfig 不重建缓存文件（&#x2F;etc&#x2F;ld.so.cache），若未用 <code>-X</code> 选项，ldconfig 照常更新文件的连接。</li>
<li><code>-X</code> ：指示 ldconfig 不更新文件的连接，若未用 <code>-N</code> 选项，则缓存文件正常更新。</li>
<li><code>-f CONF</code> ：指定动态链接库的配置文件为 CONF，系统默认为 &#x2F;etc&#x2F;ld.so.conf。</li>
<li><code>-C CACHE</code> ：指定生成的缓存文件为 CACHE，系统默认的是 &#x2F;etc&#x2F;ld.so.cache，此文件存放已排好序的可共享的动态链接库的列表。</li>
<li><code>-r ROOT</code> ：改变应用程序的根目录为 ROOT（是调用 chroot 函数实现的）。选择此项时，系统默认的配置文件 &#x2F;etc&#x2F;ld.so.conf，实际对应的为 ROOT&#x2F;etc&#x2F;ld.so.conf。如用 -r &#x2F;usr&#x2F;zzz 时，打开配置文件 &#x2F;etc&#x2F;ld.so.conf 时，实际打开的是 &#x2F;usr&#x2F;zzz&#x2F;etc&#x2F;ld.so.conf 文件。用此选项，可以大大增加动态链接库管理的灵活性。</li>
<li><code>-l</code> ：通常情况下，ldconfig 搜索动态链接库时将自动建立动态链接库的连接，选择此项时，将进入专家模式，需要手工设置连接，一般用户不用此项。</li>
<li><code>-p</code> 或 <code>--print-cache</code> ：指示 ldconfig 打印出当前缓存文件所保存的所有共享库的名字。</li>
<li><code>-c FORMAT</code> 或 <code>--format=FORMAT</code> ：指定缓存文件所使用的格式，共有三种：old（老格式），new（新格式）和 compat（兼容格式，此为默认格式）。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息并退出。</li>
<li><code>-?</code> 或 <code>--help</code> 或 <code>--usage</code> ：显示帮助信息并退出。</li>
</ul>
<h2 id="示例-40"><a href="#示例-40" class="headerlink" title="示例"></a>示例</h2><p>将 libfoo.so 共享库添加到系统标准库路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> /home/username/foo/libfoo.so /usr/lib</span><br><span class="line">$ <span class="built_in">chmod</span> 0755 /usr/lib/libfoo.so</span><br></pre></td></tr></table></figure>



<p>更新共享库缓存列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ldconfig</span><br></pre></td></tr></table></figure>



<p>更新完成后检查（从当前缓存文件的中搜索 libfoo.so 库）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ldconfig -p | grep foo</span><br><span class="line">	libfoo.so (libc6) =&gt; /usr/lib/libfoo.so</span><br></pre></td></tr></table></figure>





<h1 id="Linux-objdump-命令-显示目标文件信息"><a href="#Linux-objdump-命令-显示目标文件信息" class="headerlink" title="Linux objdump 命令 - 显示目标文件信息"></a>Linux objdump 命令 - 显示目标文件信息</h1><h2 id="介绍-41"><a href="#介绍-41" class="headerlink" title="介绍"></a>介绍</h2><p><strong>objdump</strong> 命令用于显示二进制目标文件的信息，也就是以一种可阅读的格式让开发者更多地了解二进制文件可能带有的附加信息。它是 GNU Binutils 工具集中的一个命令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump &lt;options&gt; &lt;file&gt;</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>, <code>--archive-headers</code> ：显示档案库的成员信息，类似 <code>ls -l</code> 将 lib*.a 的信息列出。</li>
<li><code>-b</code>, <code>--target=BFDNAME</code> ：指定目标码格式。这不是必须的，objdump 能自动识别许多格式。</li>
<li><code>-C</code>, <code>--demangle[=STYLE]</code> ：将底层的符号名解码成用户级名字，除了去掉所开头的下划线之外，还使得 C++ 函数名以可理解的方式显示出来。</li>
<li><code>-d</code>, <code>--disassemble</code> ：反汇编可执行的 section 内容。</li>
<li><code>-D</code>, <code>--disassemble-all</code> ：反汇编所有 section 内容。</li>
<li><code>-e</code>, <code>--debugging-tags</code> ：类似 -g 选项，但是生成的信息是和 ctags 工具相兼容的格式。</li>
<li><code>-f</code>, <code>--file-headers</code> ：显示文件头信息。</li>
<li><code>-g</code>, <code>--debugging</code> ：显示调试信息。企图解析保存在文件中的调试信息并以 C 语言的语法显示出来。仅仅支持某些类型的调试信息。有些其他的格式被 <code>readelf -w</code> 支持。</li>
<li><code>-h</code>, <code>--[section-]headers</code> ：显示目标文件各个 section 的头部摘要信息。</li>
<li><code>-i</code>, <code>--info</code> ：显示对于 -b 或者 -m 选项可用的架构和目标格式列表。</li>
<li><code>-j</code>, <code>--section=NAME</code> ：仅仅显示指定名称为 name 的 section 的信息。</li>
<li><code>-m</code>, <code>--architecture=MACHINE</code> ：指定反汇编目标文件时使用的架构，当待反汇编文件本身没描述架构信息的时候（比如 S-records），这个选项很有用。可以用 -i 选项列出这里能够指定的架构。</li>
<li><code>-r</code>, <code>--reloc</code> ：显示文件的重定位入口。如果和 -d 或者 -D 一起使用，重定位部分以反汇编后的格式显示出来。</li>
<li><code>-R</code>, <code>--dynamic-reloc</code> ：显示文件的动态重定位入口，仅仅对于动态目标文件有意义，比如某些共享库。</li>
<li><code>-s</code>, <code>--full-contents</code> ：显示指定 section 的完整内容。默认所有的非空 section 都会被显示。</li>
<li><code>-S</code>, <code>--source</code> ：尽可能反汇编出源代码，尤其当编译的时候指定了-g 这种调试参数时，效果比较明显。隐含了-d 参数。</li>
<li><code>--start-address=ADDR</code> ：从指定地址开始显示数据，该选项影响 -d、-r 和 -s 选项的输出。</li>
<li><code>--stop-address=ADDR</code> ：显示数据直到指定地址为止，该项影响 -d、-r 和 -s 选项的输出。</li>
<li><code>-t</code>, <code>--syms</code> ：显示文件的符号表入口。类似于 <code>nm -s</code> 提供的信息。</li>
<li><code>-T</code>, <code>--dynamic-syms</code> ：显示文件的动态符号表入口，仅仅对动态目标文件意义，比如某些共享库。它显示的信息类似于 <code>nm -D|--dynamic</code> 显示的信息。</li>
<li><code>-x</code>, <code>--all-headers</code> ：显示所有可用的头信息，包括符号表、重定位入口。-x 等价于 -a -f -h -r -t 同时指定。</li>
<li><code>-z</code>, <code>--disassemble-zeroes</code> ：一般反汇编输出将省略大块的零，该选项使得这些零块也被反汇编。</li>
<li><code>-H</code>, <code>--help</code> ：显示帮助信息。</li>
<li><code>-v</code>, <code>--version</code> ：显示版本信息。</li>
</ul>
<h2 id="示例-41"><a href="#示例-41" class="headerlink" title="示例"></a>示例</h2><p>查看本机目标结构（使用大端还是小端存储）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -i</span><br></pre></td></tr></table></figure>



<p>查看所有的符号以及它们所在段（显示符号表入口）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -t main.o</span><br></pre></td></tr></table></figure>



<p>打印主要段的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -h main.o</span><br></pre></td></tr></table></figure>



<p>打印更多的详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -x main.o</span><br></pre></td></tr></table></figure>



<p>将所有段的内容以十六进制方式打印出来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -s main.o</span><br></pre></td></tr></table></figure>



<p>显示 main.o 文件中的 text 段的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump --section=.text -s main.o</span><br></pre></td></tr></table></figure>



<p>将所有包含指令的段反汇编</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -d main.o</span><br></pre></td></tr></table></figure>





<h1 id="Linux-readelf-命令-显示-ELF-文件信息"><a href="#Linux-readelf-命令-显示-ELF-文件信息" class="headerlink" title="Linux readelf 命令 - 显示 ELF 文件信息"></a>Linux readelf 命令 - 显示 ELF 文件信息</h1><h2 id="介绍-42"><a href="#介绍-42" class="headerlink" title="介绍"></a>介绍</h2><p><strong>readelf</strong> 命令用于显示一个或者多个 ELF 格式目标文件的信息。可以支持 32 位或 64 位的 elf 格式文件，也支持包含 elf 文件的文档（这里一般指的是使用 ar 命令将一些 elf 文件打包之后生成的例如 lib*.a 之类的静态库文件）。</p>
<p>readelf 和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/objdump/">objdump</a> 提供的功能类似，但是它显示的信息更为具体，并且它不依赖 BFD 库（BFD 库是一个 GNU 项目，它的目标就是希望通过一种统一的接口来处理不同的目标文件），所以即使 BFD 库有什么 bug 存在的话也不会影响到 readelf 程序。</p>
<p><strong>语法</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf &lt;options&gt; elf-file ...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong></p>
<ul>
<li><code>-a</code>, <code>--all</code> ：显示全部信息，等价于 -h -l -S -s -r -d -V -A -I。</li>
<li><code>-h</code>, <code>--file-header</code> ：显示 ELF 文件开始的文件头信息。</li>
<li><code>-l</code>, <code>--program-headers</code> ：显示程序头（段头）信息（如果有的话）。</li>
<li><code>--segments</code> ：是 –program-headers 的别名。</li>
<li><code>-S</code>, <code>--section-headers</code> ：显示节头信息（如果有的话）。</li>
<li><code>--sections</code> ：是 –section-headers 的别名。</li>
<li><code>-g</code>, <code>--section-groups</code> ：显示节组信息（如果有的话）。</li>
<li><code>-t</code>, <code>--section-details</code> ：显示节的详细信息（-S 的）。</li>
<li><code>-e</code>, <code>--headers</code> ：显示全部头信息，等价于 -h -l -S。</li>
<li><code>-s</code>, <code>--syms</code> ：显示符号表段中的项（如果有的话）。</li>
<li><code>--symbols</code> ：是 –syms 的别名。</li>
<li><code>-n</code>, <code>--notes</code> ：显示 note 段（内核注释）的信息。</li>
<li><code>-r</code>, <code>--relocs</code> ：显示可重定位段的信息。</li>
<li><code>-u</code>, <code>--unwind</code> ：显示 unwind 段信息。当前只支持 IA64 ELF 的 unwind 段信息。</li>
<li><code>-d</code>, <code>--dynamic</code> ：显示动态段的信息。</li>
<li><code>-V</code>, <code>--version-info</code> ：显示版本段的信息。</li>
<li><code>-A</code>, <code>--arch-specific</code> ：显示 CPU 构架信息。</li>
<li><code>-D</code>, <code>--use-dynamic</code> ：使用动态段中的符号表显示符号，而不是使用符号段。</li>
<li><code>-x</code>, <code>--hex-dump=&lt;number|name&gt;</code> ：以十六进制方式显示指定段内内容。number 指定段表中段的索引，或字符串指定文件中的段名。</li>
<li><code>-p</code>, <code>--string-dump=&lt;number|name&gt;</code> ：以字符串方式显示指定段内内容。number 指定段表中段的索引，或字符串指定文件中的段名。</li>
<li><code>-R</code>, <code>--relocated-dump=&lt;number|name&gt;</code> ：以重定位字节方式显示指定段内内容。number 指定段表中段的索引，或字符串指定文件中的段名。</li>
<li><code>-w[lLiaprmfFsoRtUuTgAckK]</code> ：显示调试段中指定的内容。</li>
<li><code>-I</code>, <code>--histogram</code> ：显示符号的时候，显示 bucket list 长度的柱状图。</li>
<li><code>-W</code>, <code>--wide</code> ：宽行输出。</li>
<li><code>-H</code>, <code>--help</code> ：显示帮助信息。</li>
<li><code>-v</code>, <code>--version</code> ：显示版本信息。</li>
</ul>
<h2 id="示例-42"><a href="#示例-42" class="headerlink" title="示例"></a>示例</h2><p>读取可执行文件 a.out 的 ELF 文件头信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -h a.out</span></span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  类别:                              ELF64</span><br><span class="line">  数据:                              2 补码，小端序 (little endian)</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          0</span><br><span class="line">  类型:                              EXEC (可执行文件)</span><br><span class="line">  系统架构:                          Advanced Micro Devices X86-64</span><br><span class="line">  版本:                              0x1</span><br><span class="line">  入口点地址：               0x401040</span><br><span class="line">  程序头起点：          64 (bytes into file)</span><br><span class="line">  Start of section headers:          15288 (bytes into file)</span><br><span class="line">  标志：             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         11</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         29</span><br><span class="line">  Section header string table index: 28</span><br></pre></td></tr></table></figure>



<p>读取目标文件 ldal.o 的 ELF 文件头信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -h ldal.o</span></span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  类别:                              ELF64</span><br><span class="line">  数据:                              2 补码，小端序 (little endian)</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          0</span><br><span class="line">  类型:                              REL (可重定位文件)</span><br><span class="line">  系统架构:                          Advanced Micro Devices X86-64</span><br><span class="line">  版本:                              0x1</span><br><span class="line">  入口点地址：               0x0</span><br><span class="line">  程序头起点：          0 (bytes into file)</span><br><span class="line">  Start of section headers:          25320 (bytes into file)</span><br><span class="line">  标志：             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         26</span><br><span class="line">  Section header string table index: 25</span><br></pre></td></tr></table></figure>



<p>读取共享库文件 libldal.so 的 ELF 文件头信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -h libldal.so</span></span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  类别:                              ELF64</span><br><span class="line">  数据:                              2 补码，小端序 (little endian)</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          0</span><br><span class="line">  类型:                              DYN (共享目标文件)</span><br><span class="line">  系统架构:                          Advanced Micro Devices X86-64</span><br><span class="line">  版本:                              0x1</span><br><span class="line">  入口点地址：               0x6140</span><br><span class="line">  程序头起点：          64 (bytes into file)</span><br><span class="line">  Start of section headers:          226976 (bytes into file)</span><br><span class="line">  标志：             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         11</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         36</span><br><span class="line">  Section header string table index: 35</span><br></pre></td></tr></table></figure>



<p>查看可执行文件 a.out 的 ELF 文件程序头表信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -l a.out</span></span><br><span class="line"></span><br><span class="line">Elf 文件类型为 EXEC (可执行文件)</span><br><span class="line">Entry point 0x401040</span><br><span class="line">There are 11 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">程序头：</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040</span><br><span class="line">                 0x0000000000000268 0x0000000000000268  R      0x8</span><br><span class="line">  INTERP         0x00000000000002a8 0x00000000004002a8 0x00000000004002a8</span><br><span class="line">                 0x000000000000001c 0x000000000000001c  R      0x1</span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000</span><br><span class="line">                 0x0000000000000438 0x0000000000000438  R      0x1000</span><br><span class="line">  LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000</span><br><span class="line">                 0x00000000000004a5 0x00000000000004a5  R E    0x1000</span><br><span class="line">  LOAD           0x0000000000002000 0x0000000000402000 0x0000000000402000</span><br><span class="line">                 0x0000000000000258 0x0000000000000258  R      0x1000</span><br><span class="line">  LOAD           0x0000000000002e10 0x0000000000403e10 0x0000000000403e10</span><br><span class="line">                 0x0000000000000420 0x0000000000000428  RW     0x1000</span><br><span class="line">  DYNAMIC        0x0000000000002e20 0x0000000000403e20 0x0000000000403e20</span><br><span class="line">                 0x00000000000001d0 0x00000000000001d0  RW     0x8</span><br><span class="line">  NOTE           0x00000000000002c4 0x00000000004002c4 0x00000000004002c4</span><br><span class="line">                 0x0000000000000044 0x0000000000000044  R      0x4</span><br><span class="line">  GNU_EH_FRAME   0x00000000000020e0 0x00000000004020e0 0x00000000004020e0</span><br><span class="line">                 0x000000000000004c 0x000000000000004c  R      0x4</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     0x10</span><br><span class="line">  GNU_RELRO      0x0000000000002e10 0x0000000000403e10 0x0000000000403e10</span><br><span class="line">                 0x00000000000001f0 0x00000000000001f0  R      0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  段节...</span><br><span class="line">   00</span><br><span class="line">   01     .interp</span><br><span class="line">   02     .interp .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt</span><br><span class="line">   03     .init .plt .text .fini</span><br><span class="line">   04     .rodata .eh_frame_hdr .eh_frame</span><br><span class="line">   05     .init_array .fini_array .dynamic .got .got.plt .data .bss</span><br><span class="line">   06     .dynamic</span><br><span class="line">   07     .note.gnu.build-id .note.ABI-tag</span><br><span class="line">   08     .eh_frame_hdr</span><br><span class="line">   09</span><br><span class="line">   10     .init_array .fini_array .dynamic .got</span><br></pre></td></tr></table></figure>



<p>显示 a.out 文件中的所有段，即查看段表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -S a.out</span></span><br><span class="line">There are 29 section headers, starting at offset 0x3bb8:</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [号] 名称              类型             地址              偏移量</span><br><span class="line">       大小              全体大小          旗标   链接   信息   对齐</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         00000000004002a8  000002a8</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.gnu.build-i NOTE             00000000004002c4  000002c4</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 3] .note.ABI-tag     NOTE             00000000004002e8  000002e8</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH         0000000000400308  00000308</span><br><span class="line">       000000000000001c  0000000000000000   A       5     0     8</span><br><span class="line">  [ 5] .dynsym           DYNSYM           0000000000400328  00000328</span><br><span class="line">       0000000000000060  0000000000000018   A       6     1     8</span><br><span class="line">  [ 6] .dynstr           STRTAB           0000000000400388  00000388</span><br><span class="line">       000000000000003f  0000000000000000   A       0     0     1</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>





<h1 id="Linux-size-命令-显示目标文件的大小"><a href="#Linux-size-命令-显示目标文件的大小" class="headerlink" title="Linux size 命令 - 显示目标文件的大小"></a>Linux size 命令 - 显示目标文件的大小</h1><h2 id="介绍-43"><a href="#介绍-43" class="headerlink" title="介绍"></a>介绍</h2><p>Linux 系统中的 <strong>size</strong> 命令用于显示指定目标文件或可执行文件各段的大小及其总和。</p>
<p>通常，size 针对每个目标文件或可执行文件，包括档案文件中的每个模块生成一行输出信息。其中，<em>objfiles</em> 是需要考察的一个或一组目标文件或可执行文件，也可以是一个 ar 档案文件，表示考察其中的所有模块文件。如果未指定文件，默认的输入文件是当前目录中的 a.out 文件。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">size [选项] [文件]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><p><code>-A|-B|-G, --format={sysv|berkeley|gnu}</code>：指定代码段的显示格式。其中，</p>
<ul>
<li><code>-A</code> 或 <code>--format=sysv</code> 表示 System V 格式；</li>
<li><code>-B</code> 或 <code>--format=berkeley</code> 表示默认的 Berkeley 格式；</li>
<li><code>-G</code> 或 <code>--format=gnu</code> 表示 GNU 格式。</li>
</ul>
</li>
<li><p><code>-o|-d|-x, --radix={8|10|16}</code>：指定输出数值的表示方式，其中，</p>
<ul>
<li><code>-o</code> 或 <code>--radix=8</code> 表示八进制数值；</li>
<li><code>-d</code> 或 <code>--radix=10</code> 表示十进制数值；</li>
<li><code>-x</code> 或 <code>--radix=16</code> 表示十六进制数值。</li>
</ul>
<p>在每一行输出信息中，各段的总和总是采用两种形式分别给出：十进制与十六进制数值（<code>-d</code> 或 <code>-x</code> 选项），八进制与十六进制数值（<code>-o</code> 选项）。</p>
</li>
<li><p><code>-t, --totals</code>：最后增加一行统计数据，显示所有目标文件或可执行文件的纵向累计（仅适用于 <code>-B</code> 选项的 Berkeley 显示格式）。</p>
</li>
<li><p><code>--common</code>：显示目标文件或可执行文件中通用标识符（<em>COM</em> syms）部分占用的空间总和。当使用 Berkeley 格式显示时，这个数据包含在 bss 段中。</p>
</li>
<li><p><code>--target=&lt;bfdname&gt;</code>：设置二进制文件格式。</p>
</li>
<li><p><code>@&lt;file&gt;</code>：从指定的文件 <code>&lt;file&gt;</code> 中读取命令行选项。</p>
</li>
<li><p><code>-h, --help</code>：显示帮助信息。</p>
</li>
<li><p><code>-v, --version</code>：显示版本信息。</p>
</li>
</ul>
<h2 id="示例-43"><a href="#示例-43" class="headerlink" title="示例"></a>示例</h2><p>采用默认的 Berkeley 格式显示 bash 和 find 命令文件各段的大小与总和：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">size -B /bin/bash /bin/find</span></span><br><span class="line">   text	   data	    bss	    dec	    hex	filename</span><br><span class="line">1127345	  47356	  40056	1214757	 128925	/bin/bash</span><br><span class="line"> 300059	  10408	   2712	 313179	  4c75b	/bin/find</span><br></pre></td></tr></table></figure>



<p>在上述基础上增加一行统计数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ size -Bt /bin/bash /bin/find</span><br><span class="line">   text	   data	    bss	    dec	    hex	filename</span><br><span class="line">1127345	  47356	  40056	1214757	 128925	/bin/bash</span><br><span class="line"> 300059	  10408	   2712	 313179	  4c75b	/bin/find</span><br><span class="line">1427404	  57764	  42768	1527936	 175080	(TOTALS)</span><br></pre></td></tr></table></figure>





<h1 id="Linux-nm-命令-列出目标文件的符号表"><a href="#Linux-nm-命令-列出目标文件的符号表" class="headerlink" title="Linux nm 命令 - 列出目标文件的符号表"></a>Linux nm 命令 - 列出目标文件的符号表</h1><h2 id="介绍-44"><a href="#介绍-44" class="headerlink" title="介绍"></a>介绍</h2><p><strong>nm</strong>（英文全拼：names）命令是 <a target="_blank" rel="noopener" href="https://www.gnu.org/software/binutils/">GNU Binutils</a> 二进制工具集的一员，用于显示二进制文件（例如库文件和可执行文件等）中的符号。如果没有为 nm 命令指明目标文件，则 nm 假定目标文件是 a.out。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nm [选项] [文件]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-A</code>, <code>-o</code>, <code>--print-file-name</code> ：在找到的各个符号的名字前加上文件名，而不是在此文件的所有符号前只出现文件名一次。</li>
<li><code>-a</code>, <code>--debug-syms</code> ：显示调试符号。</li>
<li><code>-B</code>, <code>--format=bsd</code> ：用来兼容 MIPS 的 nm。</li>
<li><code>-C</code>, <code>--demangle[=STYLE]</code> ：将低级符号名解码（demangle）成用户级名字，比如去除编译时添加的前置下划线，这样可以使得 C++ 函数名具有可读性。不同的编译器符号修饰风格不同，可以使用 &#x3D;STYLE 参数来选择合适的解码风格。</li>
<li><code>-D</code>, <code>--dynamic</code> ：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。</li>
<li><code>-f</code>, <code>--format=FORMAT</code> ：FORMAT 可取值 bsd、sysv 或 posix，该选项在 GNU nm 中有用，默认为 bsd。</li>
<li><code>-g</code>, <code>--extern-only</code> ：仅显示外部符号。</li>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息。</li>
<li><code>-l</code>, <code>--line-numbers</code> ：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。</li>
<li><code>-n</code>, <code>-v</code>, <code>--numeric-sort</code> ：按符号对应地址的顺序排序，而非按符号名的字符顺序。</li>
<li><code>-P</code>, <code>--portability</code> ：使用 POSIX.2 标准输出格式代替默认的输出格式。等同于 -f posix。</li>
<li><code>-p</code>, <code>--no-sort</code> ：按目标文件中遇到的符号顺序显示，不排序。</li>
<li><code>-r</code>, <code>--reverse-sort</code> ：逆序排序。例如，升序变为降序。</li>
<li><code>-S</code>, <code>--print-size</code> ：以 BSD 输出样式输出已定义符号的值和大小。对于不记录符号大小的目标文件格式，此选项不起作用，除非使用了–size sort，在这种情况下，将显示计算的大小。</li>
<li><code>-s</code>, <code>--print-armap</code> ：当列出库中成员的符号时，同时列出索引。索引的内容包含：模块与其包含的名字的定义之间的映射。</li>
<li><code>-t</code>, <code>--radix=RADIX</code> ：使用基数 radix 进制显示符号值。radix 只能为 d（十进制）、o（八进制）或 x（十六进制）。</li>
<li><code>-u</code>, <code>--undefined-only</code> ：仅显示没有定义的符号。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息并退出。</li>
<li><code>-X</code> ：为了与 AIX 版本的 nm 兼容，选项 -X 将被忽略。它可接受一个参数，该参数必须是字符串 32_64。AIX nm 的默认模式对应于 -X 32，GNU nm 不支持模式 -X 32。</li>
<li><code>--defined-only</code> ：仅显示有定义的符号。</li>
<li><code>--no-demangle</code> ：不解码低级符号名，这是默认选项。</li>
<li><code>--plugin NAME</code> ：加载名为 name 的插件以添加对额外目标类型的支持。只有在启用插件支持的情况下构建了工具链时，此选项才可用。</li>
<li><code>--size-sort</code> ：按符号大小排列。</li>
<li><code>--special-syms</code> ：显示目标相关的具体特殊含义的符号。这些符号通常被特定目标文件用于某些特殊处理，当包含在正常符号列表中时通常不起作用。例如，对于 ARM 目标，此选项将跳过用于标记 ARM 代码、Thumb 代码和数据之间转换的映射符号。</li>
<li><code>--synthetic</code> ：输出合成符号。合成符号是链接器为各种目的创建的特殊符号，默认情况下不会显示它们，因为它们不是二进制文件源代码的一部分。</li>
<li><code>--target=BFDNAME</code> ：指定系统默认格式以外的目标文件格式。</li>
</ul>
<h2 id="示例-44"><a href="#示例-44" class="headerlink" title="示例"></a>示例</h2><p>假设 hello.c 代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_test;</span><br><span class="line"><span class="type">int</span> baud_table[<span class="number">5</span>] = &#123;<span class="number">9600</span>, <span class="number">19200</span>, <span class="number">38400</span>, <span class="number">57600</span>, <span class="number">115200</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l_test;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, GetIoT\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>执行 <code>gcc hello.c</code> 编译后，查看 a.out 文件中所有的符号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nm a.out </span><br><span class="line">0000000000004010 D baud_table</span><br><span class="line">0000000000004024 B __bss_start</span><br><span class="line">0000000000004024 b completed.8060</span><br><span class="line">                 w __cxa_finalize@@GLIBC_2.2.5</span><br><span class="line">0000000000004000 D __data_start</span><br><span class="line">0000000000004000 W data_start</span><br><span class="line">0000000000001090 t deregister_tm_clones</span><br><span class="line">0000000000001100 t __do_global_dtors_aux</span><br><span class="line">0000000000003dc0 d __do_global_dtors_aux_fini_array_entry</span><br><span class="line">0000000000004008 D __dso_handle</span><br><span class="line">0000000000003dc8 d _DYNAMIC</span><br><span class="line">0000000000004024 D _edata</span><br><span class="line">0000000000004030 B _end</span><br><span class="line">00000000000011e8 T _fini</span><br><span class="line">0000000000001140 t frame_dummy</span><br><span class="line">0000000000003db8 d __frame_dummy_init_array_entry</span><br><span class="line">000000000000215c r __FRAME_END__</span><br><span class="line">0000000000003fb8 d _GLOBAL_OFFSET_TABLE_</span><br><span class="line">                 w __gmon_start__</span><br><span class="line">0000000000002014 r __GNU_EH_FRAME_HDR</span><br><span class="line">0000000000004028 b g_test</span><br><span class="line">0000000000001000 t _init</span><br><span class="line">0000000000003dc0 d __init_array_end</span><br><span class="line">0000000000003db8 d __init_array_start</span><br><span class="line">0000000000002000 R _IO_stdin_used</span><br><span class="line">                 w _ITM_deregisterTMCloneTable</span><br><span class="line">                 w _ITM_registerTMCloneTable</span><br><span class="line">00000000000011e0 T __libc_csu_fini</span><br><span class="line">0000000000001170 T __libc_csu_init</span><br><span class="line">                 U __libc_start_main@@GLIBC_2.2.5</span><br><span class="line">0000000000001149 T main</span><br><span class="line">                 U puts@@GLIBC_2.2.5</span><br><span class="line">00000000000010c0 t register_tm_clones</span><br><span class="line">0000000000001060 T _start</span><br><span class="line">0000000000004028 D __TMC_END__</span><br></pre></td></tr></table></figure>



<h2 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h2><p>对于每一个符号来说，其类型如果是小写的，则表明该符号是 local 的；大写则表明该符号是 global（external）的。</p>
<ul>
<li><p>A 该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。</p>
</li>
<li><p>B 该符号的值出现在非初始化数据段（bss）中。例如，在一个文件中定义全局 static int test。则该符号 test 的类型为 b，位于 bss section 中。其值表示该符号在 bss 段中的偏移。一般而言，bss 段分配于 RAM 中。</p>
</li>
<li><p>C 该符号为 common。common symbol 是未初始话数据段。该符号没有包含于一个普通 section 中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个 c 文件中，定义 int test，并且该符号在别的地方会被引用，则该符号类型即为 C。否则其类型为 B。</p>
</li>
<li><p>D 该符号位于初始化数据段中。一般来说，分配到 data section 中。</p>
<p>例如：定义全局 <code>int baud_table[5] = {9600, 19200, 38400, 57600, 115200};</code>，会分配到初始化数据段中。</p>
</li>
<li><p>G 该符号也位于初始化数据段中。主要用于 small object 提高访问 small data object 的一种方式。</p>
</li>
<li><p>I 该符号是对另一个符号的间接引用。</p>
</li>
<li><p>N 该符号是一个 debugging 符号。</p>
</li>
<li><p>R 该符号位于只读数据区。</p>
<p>例如：定义全局 <code>const int test[] = {123, 123};</code>，则 test 就是一个只读数据区的符号。</p>
</li>
<li><p>S 符号位于非初始化数据区，用于 small object。</p>
</li>
<li><p>T 该符号位于代码区 text section。</p>
</li>
<li><p>U 该符号在当前文件中是未定义的，即该符号的定义在别的文件中。</p>
<p>例如：当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为 C，在使用它的文件中，其类型为 U。</p>
</li>
<li><p>V 该符号是一个 weak object。</p>
</li>
<li><p>W 该符号是一个弱符号，没有被专门标记为 weak object 符号。</p>
</li>
<li><p>? 该符号类型没有定义</p>
</li>
</ul>
<h1 id="Linux-install-命令-复制并安装文件"><a href="#Linux-install-命令-复制并安装文件" class="headerlink" title="Linux install 命令 - 复制并安装文件"></a>Linux install 命令 - 复制并安装文件</h1><h2 id="介绍-45"><a href="#介绍-45" class="headerlink" title="介绍"></a>介绍</h2><p><strong>install</strong> 命令用于安装、升级软件，或者备份数据。</p>
<p>install 的功能和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/cp/">cp</a> 命令类似，都可以将文件&#x2F;目录拷贝到指定的位置。不同的是，install 允许你控制目标文件的属性，通常用于程序的 Makefile 文件（执行 <code>make install</code>），使用它来将程序拷贝到目标（安装）目录。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">install [OPTION]... [-T] SOURCE DEST</span><br><span class="line">install [OPTION]... SOURCE... DIRECTORY</span><br><span class="line">install [OPTION]... -t DIRECTORY SOURCE...</span><br><span class="line">install [OPTION]... -d DIRECTORY...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>--backup[=CONTROL]</code> ：为每个已存在的目的地文件进行备份。</li>
<li><code>-b</code> ：类似 <code>--backup</code>，但不接受任何参数。</li>
<li><code>-C</code>, <code>--compare</code> ：比较每对源文件和目标文件，在某些情况下，根本不修改目标</li>
<li><code>-d</code>, <code>--directory</code> ：所有参数都作为目录处理，而且会创建指定目录的所有主目录。</li>
<li><code>-D</code> ：创建 <code>DEST</code> 前的所有主目录，然后将 <code>SOURCE</code> 复制至 <code>DEST</code>，在第一种使用格式中有用。</li>
<li><code>-g</code>, <code>--group=GROUP</code> ：自行设定所属组，而不是进程目前的所属组。</li>
<li><code>-m</code>, <code>--mode=MODE</code> ：自行设定权限模式（类似 chmod），而不是 rwxr-xr-x。</li>
<li><code>-o</code>, <code>--owner=OWNER</code> ：自行设定所有者（只适用于 root 用户）。</li>
<li><code>-p</code>, <code>--preserve-timestamps</code> ：以 <code>SOURCE</code> 文件的访问&#x2F;修改时间作为相应的目的地文件的时间属性。</li>
<li><code>-s</code>, <code>--strip</code> ：用 strip 命令删除 symbol table，只适用于第一和第二种使用格式。</li>
<li><code>-S</code>, <code>--suffix=SUFFIX</code> ：自行指定备份文件的后缀。</li>
<li><code>-t</code>, <code>--target-directory=DIRECTORY</code> ：将所有 <code>SOURCE</code> 参数复制到 <code>DIRECTORY</code> 中。</li>
<li><code>-T</code>, <code>--no-target-directory</code> ：将 <code>DEST</code> 视为普通文件。</li>
<li><code>-v</code>, <code>--verbose</code> ：处理每个文件&#x2F;目录时显示详细信息（打印出名称）。</li>
<li><code>--help</code> ：显示帮助信息并退出。</li>
<li><code>--version</code> ：显示版本信息并退出。</li>
</ul>
<h2 id="示例-45"><a href="#示例-45" class="headerlink" title="示例"></a>示例</h2><p>将 libfoo.so 安装到系统库路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">install libfoo.so /usr/local/lib</span><br></pre></td></tr></table></figure>



<p>结果等效于</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp libfoo.so /usr/local/lib</span><br></pre></td></tr></table></figure>



<p>将 hello 程序安装到指定目录，并创建该目录前的主目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">install -D hello /opt/bin/hello</span><br></pre></td></tr></table></figure>



<p>结果等效于</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /opt/bin &amp;&amp; cp hello /opt/bin/hello</span><br></pre></td></tr></table></figure>



<p>提示：以上所有 install 命令执行时都需要 root 权限（加上 sudo 执行）。</p>
<h1 id="Linux-cat-命令-显示文件内容"><a href="#Linux-cat-命令-显示文件内容" class="headerlink" title="Linux cat 命令 - 显示文件内容"></a>Linux cat 命令 - 显示文件内容</h1><h2 id="介绍-46"><a href="#介绍-46" class="headerlink" title="介绍"></a>介绍</h2><p><strong>cat</strong>（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。常用于在 Shell 终端中显示文件内容。</p>
<p>注意：当文件较大时，文本在屏幕上迅速闪过（滚屏），用户往往看不清所显示的内容。因此，一般用 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/more/">more</a> 等命令分屏显示。为了控制滚屏，可以按 Ctrl+S 键，停止滚屏；按 Ctrl+Q 键可以恢复滚屏。按 Ctrl+C（中断）键可以终止该命令的执行，并且返回 Shell 提示符状态。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> [-AbeEnstTuv] [--<span class="built_in">help</span>] [--version] fileName</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-n</code>, <code>--number</code> ：由 1 开始对所有输出的行数编号。</li>
<li><code>-b</code>, <code>--number-nonblank</code> ：和 <code>-n</code> 相似，只不过对于空白行不编号。</li>
<li><code>-s</code>, <code>--squeeze-blank</code> ：当遇到有连续两行以上的空白行，就代换为一行的空白行。</li>
<li><code>-v</code>, <code>--show-nonprinting</code> ：使用 <code>^</code> 和 <code>M-</code> 符号，除了 LFD 和 TAB 之外。</li>
<li><code>-E</code>, <code>--show-ends</code> ：在每行结束处显示 <code>$</code>。</li>
<li><code>-T</code>, <code>--show-tabs</code> ：将 TAB 字符显示为 <code>^I</code>。</li>
<li><code>-A</code>, <code>--show-all</code> ：等价于 <code>-vET</code> 选项。</li>
<li><code>-e</code> ：等价于 <code>-vE</code> 选项。</li>
<li><code>-t</code> ：等价于 <code>-vT</code> 选项。</li>
</ul>
<h2 id="示例-46"><a href="#示例-46" class="headerlink" title="示例"></a>示例</h2><p>把 textfile1 文件的内容加上行号后输入 textfile2 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure>



<p>把 textfile1 和 textfile2 文件的内容加上行号（空白行不加）之后将内容附加到 textfile3 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure>



<p>清空 test.txt 文档内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /dev/null &gt; test.txt</span><br></pre></td></tr></table></figure>



<p>cat 也可以用来制作镜像文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /dev/sdb1 &gt; image-file</span><br></pre></td></tr></table></figure>



<p>也可以将镜像文件写到磁盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> image-file &gt; /dev/sdb1</span><br></pre></td></tr></table></figure>



<p>将多个拆解的 zip 包（如 linux.zip.001、linux.zip.002 和 linux.zip.003）合并成一个 zip 包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> linux.zip* &gt; linux.zip</span><br></pre></td></tr></table></figure>





<h1 id="Linux-zcat-命令-查看压缩文件内容"><a href="#Linux-zcat-命令-查看压缩文件内容" class="headerlink" title="Linux zcat 命令 - 查看压缩文件内容"></a>Linux zcat 命令 - 查看压缩文件内容</h1><h2 id="介绍-47"><a href="#介绍-47" class="headerlink" title="介绍"></a>介绍</h2><p><strong>zcat</strong> 命令用于查看压缩文件的内容，而无需对其进行解压缩。</p>
<p>它将压缩文件扩展为标准输出，使你可以查看其内容。zcat 的运行效果与 <code>gunzip -c</code> 命令完全相同。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zcat [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-c</code>, <code>--stdout</code> ：将文件内容写到标准输出，保持原始文件不变。</li>
<li><code>-d</code>, <code>--decompress</code> ：执行解压缩操作。</li>
<li><code>-f</code>, <code>--force</code> ：强制覆盖输出文件并压缩链接。</li>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息。</li>
<li><code>-k</code>, <code>--keep</code> ：保留（不删除）输入文件。</li>
<li><code>-l</code>, <code>--list</code> ：列出压缩文件内容。</li>
<li><code>-L</code>, <code>--license</code> ：显示软件许可信息。</li>
<li><code>-n</code>, <code>--no-name</code> 不保存或恢复原始名称和时间戳。</li>
<li><code>-N</code>, <code>--name</code> ：保存或恢复原始名称和时间戳。</li>
<li><code>-q</code>, <code>--quiet</code> ：禁用警告信息。</li>
<li><code>-r</code>, <code>--recursive</code> ：在目录上执行递归操作。</li>
<li><code>--rsyncable</code> ：制作 rsync-friendly 存档文件。</li>
<li><code>-S</code>, <code>--suffix=SUF</code> ：指定 gzip 格式的压缩包的后缀，当后缀不是标准压缩包后缀时使用此选项。</li>
<li><code>--synchronous</code> ：同步输出（如果系统崩溃，这会更安全，但速度更慢）。</li>
<li><code>-t</code>, <code>--test</code> ：测试压缩文件的完整性。</li>
<li><code>-v</code>, <code>--verbose</code> ：详细模式。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息。</li>
<li><code>-1</code>, <code>--fast</code> ：更快的压缩速度。</li>
<li><code>-9</code>, <code>--best</code> ：更高的压缩比。</li>
</ul>
<p><strong>参数</strong>：指定压缩文件名。</p>
<p>提示：zcat 是 gzip 软件包中的一个实用程序，上述许多选项参数对于 zcat 查看压缩文件内容来说是无实际效果的。另外，zutils 软件包也提供了 zcat 命令，两者在使用上有一些区别，因此要留意你正在使用的是哪个 zcat 命令。</p>
<h2 id="示例-47"><a href="#示例-47" class="headerlink" title="示例"></a>示例</h2><p>当 Linux 内核配置 <code>CONFIG_IKCONFIG</code> 和 <code>CONFIG_IKCONFIG_PROC</code> 为 <code>y</code> 时，在 &#x2F;proc 会中出现 config.gz 文件。它是内核提供给用户的当前 Linux 内核配置文件副本，并且是经过 gzip 格式压缩的。</p>
<p>例如，在 &#x2F;proc&#x2F;config.gz 文件中查找 IKCONFIG 配置信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@npi:~# zcat /proc/config.gz | grep IKCONFIG</span><br><span class="line">CONFIG_IKCONFIG=y</span><br><span class="line">CONFIG_IKCONFIG_PROC=y</span><br></pre></td></tr></table></figure>



<p>列出 &#x2F;proc&#x2F;config.gz 文件信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@npi:~# zcat -l /proc/config.gz</span><br><span class="line">         compressed        uncompressed  ratio uncompressed_name</span><br><span class="line">              34042              149025  77.2% /proc/config</span><br></pre></td></tr></table></figure>





<h1 id="Linux-echo-命令-输出字符串内容"><a href="#Linux-echo-命令-输出字符串内容" class="headerlink" title="Linux echo 命令 - 输出字符串内容"></a>Linux echo 命令 - 输出字符串内容</h1><h2 id="介绍-48"><a href="#介绍-48" class="headerlink" title="介绍"></a>介绍</h2><p><strong>echo</strong> 命令用于在 Shell 终端中输出内容（比如 shell 变量的值，或者直接输出指定的字符串）。</p>
<p>Linux 的 echo 命令，在 shell 编程中极为常用，通常起到一个提示的作用。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> [OPTION]... [STRING]...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-n</code> ：不输出尾随的换行符。</li>
<li><code>-e</code> ：激活转义字符。</li>
</ul>
<h2 id="示例-48"><a href="#示例-48" class="headerlink" title="示例"></a>示例</h2><p>显示普通字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Welcome to getiot.tech&quot;</span></span><br></pre></td></tr></table></figure>



<p>这里的双引号完全可以省略，以下命令与上面实例效果一致</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> Welcome to getiot.tech</span><br></pre></td></tr></table></figure>



<p>显示转义字符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\&quot;Welcome to getiot.tech\&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<p>不换行显示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;Welcome to getiot.tech&quot;</span></span><br></pre></td></tr></table></figure>



<p>转义输出（显示换行符）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Welcome to getiot.tech\n&quot;</span></span><br></pre></td></tr></table></figure>



<p>将显示结果重定向至文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Welcome to getiot.tech&quot;</span> &gt; file.txt</span><br></pre></td></tr></table></figure>



<p>把十六进制数据 0xdd 0xff 发送到串口 &#x2F;dev&#x2F;ttyUSB0</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e -n <span class="string">&quot;\xdd\xff&quot;</span> &gt; /dev/ttyUSB0</span><br></pre></td></tr></table></figure>



<p>显示命令执行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">date</span>`</span><br></pre></td></tr></table></figure>



<p>注意：这里使用的是反引号 <strong>&#96;</strong>，而不是单引号 <strong>‘</strong>。</p>
<h1 id="Linux-chmod-命令-改变文件权限"><a href="#Linux-chmod-命令-改变文件权限" class="headerlink" title="Linux chmod 命令 - 改变文件权限"></a>Linux chmod 命令 - 改变文件权限</h1><h2 id="介绍-49"><a href="#介绍-49" class="headerlink" title="介绍"></a>介绍</h2><p><strong>chmod</strong>（英文全拼：change mode）是 Linux 系统中用于改变文件权限的一个命令。对于文件或者目录的普通权限，共有 3 种，分别是 r（读取）、w（写入）和 x（执行）。chmod 是 Linux 系统中关于权限的重要命令之一，另外一个是 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/chown/"><code>chown</code></a> 命令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [<span class="built_in">who</span>] [operator] [permission] FILE...</span><br><span class="line"><span class="built_in">chmod</span> [OPTION]... OCTAL-MODE FILE...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-c</code>：若该文件权限确实已经更改，才显示其更改动作。</li>
<li><code>-f</code>：若该文件权限无法被更改也不要显示错误讯息。</li>
<li><code>-v</code>：显示权限变更的详细资料。</li>
<li><code>-R</code>：对目前目录下的所有文件与子目录进行相同的权限变更（即以递归的方式逐个变更）。</li>
</ul>
<p>每个模式字符串都应该匹配如下格式：<code>[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+</code>。</p>
<p>其中，who 包含的选项及其含义：</p>
<ul>
<li><code>u</code>：文件属主权限（Owner）</li>
<li><code>g</code>：属组用户权限（Group）</li>
<li><code>o</code>：其他用户权限（Other Users）</li>
<li><code>a</code>：所有用户（文件属主、属组用户及其他用户）</li>
</ul>
<p>operator 包含的选项及其含义：</p>
<ul>
<li><code>+</code>：增加权限</li>
<li><code>-</code>：取消权限</li>
<li><code>=</code>：设定权限</li>
</ul>
<p>permission 包含的选项及其含义：</p>
<ul>
<li><code>r</code>：读权限</li>
<li><code>w</code>：写权限</li>
<li><code>x</code>：执行权限</li>
<li><code>s</code>：文件属主和组 set-ID</li>
<li><code>t</code>：粘性位 *</li>
<li><code>l</code>：给文件加锁，使其他用户无法访问</li>
</ul>
<p>另外，权限也可以使用“八进制模式”来描述，针对文件属主、属组用户及其他用户，均可用 rwx 表示，组成一个八进制数字。</p>
<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/chmod-permission.jpeg" alt="img"></p>
<p>每个数字代表一种权限：</p>
<table>
<thead>
<tr>
<th align="center">r (read)</th>
<th align="center">w (write)</th>
<th align="center">x (execute)</th>
<th align="center">-</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读权限</td>
<td align="center">写权限</td>
<td align="center">可执行权限</td>
<td align="center">没有权限</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>这样就会产生 8 x 8 x 8 &#x3D; 256 种权限组合，例如：</p>
<ul>
<li><code>400</code> 文件属主可读</li>
<li><code>200</code> 文件属主可写</li>
<li><code>100</code> 文件属主可执行</li>
<li><code>040</code> 属组用户可读</li>
<li><code>020</code> 属组用户可写</li>
<li><code>010</code> 属组用户可执行</li>
<li><code>004</code> 其他用户可读</li>
<li><code>002</code> 其他用户可写</li>
<li><code>001</code> 其他用户可执行</li>
<li><code>777</code> 所有用户可读可写可执行</li>
</ul>
<h2 id="示例-49"><a href="#示例-49" class="headerlink" title="示例"></a>示例</h2><p>下面以文件 getiot 为例说明。</p>
<p>赋予文件属主执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+x getiot</span><br></pre></td></tr></table></figure>



<p>赋予属组用户写权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> g+w getiot</span><br></pre></td></tr></table></figure>



<p>赋予属组用户和其他用户执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> go+x getiot</span><br></pre></td></tr></table></figure>



<p>收回所有用户的执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a-x getiot</span><br></pre></td></tr></table></figure>



<p>收回属组用户和其他用户的写权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> og-w getiot</span><br></pre></td></tr></table></figure>



<p>将文件权限修改为 755：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 getiot</span><br></pre></td></tr></table></figure>



<p>将 &#x2F;temp 目录下的所有文件权限修改为 755：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R 755 getiot</span><br></pre></td></tr></table></figure>





<h1 id="Linux-chown-命令-改变文件所有者"><a href="#Linux-chown-命令-改变文件所有者" class="headerlink" title="Linux chown 命令 - 改变文件所有者"></a>Linux chown 命令 - 改变文件所有者</h1><h2 id="介绍-50"><a href="#介绍-50" class="headerlink" title="介绍"></a>介绍</h2><p><strong>chown</strong>（英文全拼：change owner）是 Linux 系统中用于改变文件所有者和文件关联组的一个命令。chown 是 Linux 系统中关于权限的重要命令之一，另外一个是 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/chmod/"><code>chmod</code></a> 命令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> [OPTION]... [OWNER][:[GROUP]] FILE...</span><br></pre></td></tr></table></figure>



<p>注意，这里的文件名可以使用空格分开的文件列表，在文件名中可以包含通配符。</p>
<p><strong>选项</strong>：</p>
<ul>
<li><code>OWNER</code>：新的文件拥有者的用户名或用户 ID。</li>
<li><code>GROUP</code>：新的文件拥有者的用户组名或组 ID。</li>
<li><code>-c</code>：显示更改的部分的信息。</li>
<li><code>-f</code>：忽略错误信息。</li>
<li><code>-h</code>：修复符号链接。</li>
<li><code>-v</code>：显示详细的处理信息。</li>
<li><code>-R</code>：递归处理指定目录以及其子目录下的所有文件。</li>
<li><code>--help</code>：显示帮助信息并退出。</li>
<li><code>--version</code>：显示版本信息并退出。</li>
</ul>
<h2 id="示例-50"><a href="#示例-50" class="headerlink" title="示例"></a>示例</h2><p>将文件 getiot 的拥有者权限修改为 rudy：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> rudy:rudy getiot</span><br></pre></td></tr></table></figure>



<p>将 &#x2F;opt&#x2F;data 目录的拥有者权限修改为 rudy：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R rudy:rudy /opt/data</span><br></pre></td></tr></table></figure>





<h1 id="Linux-less-命令-分页查看文件"><a href="#Linux-less-命令-分页查看文件" class="headerlink" title="Linux less 命令 - 分页查看文件"></a>Linux less 命令 - 分页查看文件</h1><h2 id="介绍-51"><a href="#介绍-51" class="headerlink" title="介绍"></a>介绍</h2><p><strong>less</strong> 与 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/more/">more</a> 类似，less 可以随意浏览文件，支持翻页和搜索，支持向上翻页和向下翻页。（less 命令允许用户向前或向后浏览文件，而 more 命令只能向前浏览 ）</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">less [options] file...</span><br></pre></td></tr></table></figure>



<p><strong>参数说明</strong>：</p>
<ul>
<li><code>-b &lt;缓冲区大小&gt;</code> ：设置缓冲区的大小</li>
<li><code>-e</code> ：当文件显示结束后，自动离开</li>
<li><code>-f</code> ：强迫打开特殊文件，例如外围设备代号、目录和二进制文件</li>
<li><code>-g</code> ：只标志最后搜索的关键词</li>
<li><code>-i</code> ：忽略搜索时的大小写</li>
<li><code>-m</code> ：显示类似 more 命令的百分比</li>
<li><code>-N</code> ：显示每行的行号</li>
<li><code>-o &lt;文件名&gt;</code> ：将 less 输出的内容在指定文件中保存起来</li>
<li><code>-Q</code> ：不使用警告音</li>
<li><code>-s</code> ：显示连续空行为一行</li>
<li><code>-S</code> ：行过长时间将超出部分舍弃</li>
<li><code>-x &lt;数字&gt;</code> ：将”tab”键显示为规定的数字空格</li>
</ul>
<p><strong>命令内部操作</strong>：</p>
<ul>
<li><code>/字符串</code> ：向下搜索”字符串”的功能</li>
<li><code>?字符串</code> ：向上搜索”字符串”的功能</li>
<li><code>n</code> ：重复前一个搜索（与 &#x2F; 或 ? 有关）</li>
<li><code>N</code> ：反向重复前一个搜索（与 &#x2F; 或 ? 有关）</li>
<li><code>b</code> ：向上翻一页</li>
<li><code>d</code> ：向后翻半页</li>
<li><code>h</code> ：显示帮助界面</li>
<li><code>Q</code> ：退出less 命令</li>
<li><code>u</code> ：向前滚动半页</li>
<li><code>y</code> ：向前滚动一行</li>
<li>空格键 ：滚动一页</li>
<li>回车键 ：滚动一行</li>
<li><code>[pagedown]</code> ： 向下翻动一页</li>
<li><code>[pageup]</code> ： 向上翻动一页</li>
</ul>
<h2 id="示例-51"><a href="#示例-51" class="headerlink" title="示例"></a>示例</h2><p>查看文件 getiot.log</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">less getiot.log</span><br></pre></td></tr></table></figure>



<p>ps 查看进程信息并通过 less 分页显示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | less</span><br></pre></td></tr></table></figure>



<p>查看命令历史使用记录并通过 less 分页显示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">history</span> | less</span><br></pre></td></tr></table></figure>



<p>浏览多个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">less getiot1.log getiot2.log</span><br></pre></td></tr></table></figure>



<p>说明：输入 <code>:n</code> 后，切换到 getiot1.log；输入 <code>:p</code> 后，切换到 getiot2.log</p>
<h1 id="Linux-more-命令-分页查看文件"><a href="#Linux-more-命令-分页查看文件" class="headerlink" title="Linux more 命令 - 分页查看文件"></a>Linux more 命令 - 分页查看文件</h1><h2 id="介绍-52"><a href="#介绍-52" class="headerlink" title="介绍"></a>介绍</h2><p><strong>more</strong> 命令类似 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/cat/">cat</a> ，不过会以一页一页的形式显示，更方便使用者逐页阅读。</p>
<p>more 最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">more [options] file...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-num</code> ：指定每屏显示的行数。</li>
<li><code>+num</code> ：从第 num 行开始显示。</li>
<li><code>-d</code> ：提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声。</li>
<li><code>-l</code> ：取消遇见特殊字元 <code>^L</code>（送纸字元）时会暂停的功能。</li>
<li><code>-f</code> ：计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）。</li>
<li><code>-p</code> ：不以卷动的方式显示每一页，而是先清除萤幕后再显示内容。</li>
<li><code>-c</code> ：与 <code>-p</code> 相似，不同的是先显示内容再清除其他旧资料。</li>
<li><code>-s</code> ：当遇到有连续两行以上的空白行，就代换为一行的空白行。</li>
<li><code>-u</code> ：不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）。</li>
<li><code>+/pattern</code> ：在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示。</li>
</ul>
<p><strong>命令内部操作</strong>：</p>
<ul>
<li>Space 键：显示文本的下一屏内容</li>
<li>Enter 键：向下n行，需要定义，默认为1行</li>
<li>斜线符 <code>\</code>：接着输入一个模式，可以在文本中寻找下一个相匹配的模式</li>
<li>H 键：显示帮助屏</li>
<li>B 键：显示上一屏内容</li>
<li>Q 键：退出 more 命令</li>
<li>Ctrl+F、空格键：向下滚动一屏</li>
<li>Ctrl+B：返回上一屏</li>
<li><code>=</code>： 输出当前的行号</li>
<li><code>:f</code>：输出文件名和当前的行号</li>
<li><code>V</code>：调用 vi 编辑器</li>
<li><code>!</code>：调用 Shell，并执行命令</li>
</ul>
<h2 id="示例-52"><a href="#示例-52" class="headerlink" title="示例"></a>示例</h2><p>显示文件 file 的内容，显示之前先清屏，附已显示的百分比：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">more -dc file</span><br></pre></td></tr></table></figure>



<p>显示文件 file 的内容，每10行显示一次，而且在显示之前先清屏：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">more -c -10 file</span><br></pre></td></tr></table></figure>



<p>显示文件 file 的内容，每5行显示一次，而且在显示之后再清屏：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">more -p -5 file</span><br></pre></td></tr></table></figure>



<p>逐页显示 file 文档内容，如有连续两行以上空白行则以一行空白行显示 ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">more -s file</span><br></pre></td></tr></table></figure>



<p>从第 20 行开始显示 file 之文档内容 ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">more +20 file</span><br></pre></td></tr></table></figure>





<h1 id="Linux-diff-命令-比较文件差异"><a href="#Linux-diff-命令-比较文件差异" class="headerlink" title="Linux diff 命令 - 比较文件差异"></a>Linux diff 命令 - 比较文件差异</h1><h2 id="介绍-53"><a href="#介绍-53" class="headerlink" title="介绍"></a>介绍</h2><p><strong>diff</strong>（英文全拼：different）命令用于在 Linux 系统中比较文件的差异。</p>
<p>diff 以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则 diff 会比较目录中相同文件名的文件，但不会比较其中子目录。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diff [OPTION]... FILES</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code> ：diff 预设只会逐行比较文本文件。</li>
<li><code>-b</code> ：不检查空格字符的不同。</li>
<li><code>-W</code> ： 在使用 <code>-y</code> 参数时，指定栏宽。</li>
<li><code>-x</code> ： 不比较选项中所指定的文件或目录。</li>
<li><code>-X=&lt;FILE&gt;</code> ：您可以将文件或目录类型存成文本文件，指定此文本文件。</li>
<li><code>-y</code> ：以并列的方式显示文件的异同之处。</li>
<li><code>--help</code> ：查看帮助信息。</li>
<li><code>--left-column</code> ：在使用 <code>-y</code> 参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。</li>
<li><code>--suppress-common-lines</code> ：在使用 <code>-y</code> 参数时，仅显示不同之处。</li>
</ul>
<h2 id="示例-53"><a href="#示例-53" class="headerlink" title="示例"></a>示例</h2><p>比较两个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diff testfile1 testfile2</span><br></pre></td></tr></table></figure>



<p>比较两个文件，且以并排格式输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diff testfile1 testfile2 -y -W 50</span><br></pre></td></tr></table></figure>



<p>比较两个文件，将差异保存到另一个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diff testfile1 testfile2 &gt; testfile.patch</span><br></pre></td></tr></table></figure>





<h1 id="Linux-patch-命令-应用文件补丁"><a href="#Linux-patch-命令-应用文件补丁" class="headerlink" title="Linux patch 命令 - 应用文件补丁"></a>Linux patch 命令 - 应用文件补丁</h1><h2 id="介绍-54"><a href="#介绍-54" class="headerlink" title="介绍"></a>介绍</h2><p><strong>patch</strong> 命令用于修补文件（给文件打补丁）。Linux 早期正是使用 patch 命令来合并代码。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">patch [options] [originalfile [patchfile]]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-i &lt;patchfile&gt;</code> 或 <code>--input=&lt;patchfile&gt;</code> ：指定补丁文件。</li>
<li><code>-p&lt;num&gt;</code> 或 <code>--strip=&lt;num&gt;</code> ：设置欲剥离几层路径名称（文件名是可以包含路径的，与 diff 命令配合）。</li>
<li><code>-E</code> 或 <code>--remove-empty-files</code> ：删除应用补丁后为空文件的文件。</li>
<li><code>-o &lt;outfile&gt;</code> 或 <code>--output=&lt;outfile&gt;</code> ：输出到一个文件而不是直接覆盖文件。</li>
</ul>
<h2 id="示例-54"><a href="#示例-54" class="headerlink" title="示例"></a>示例</h2><p>使用 patch 命令将文件 testfile1 升级，其升级补丁文件为 testfile.patch（补丁文件可由 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/diff/">diff</a> 命令生成）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">patch -p0 testfile1 testfile.patch </span><br></pre></td></tr></table></figure>



<p>在 Linux 开发中也常常会用到 patch 命令，比如内核打上 <code>PREEMPT_RT</code> 实时补丁：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">patch -p1 &lt; patch-5.4.47-rt28.patch</span><br></pre></td></tr></table></figure>





<h1 id="Linux-find-命令-查找文件或目录"><a href="#Linux-find-命令-查找文件或目录" class="headerlink" title="Linux find 命令 - 查找文件或目录"></a>Linux find 命令 - 查找文件或目录</h1><h2 id="介绍-55"><a href="#介绍-55" class="headerlink" title="介绍"></a>介绍</h2><p><strong>find</strong> 命令是 Linux 系统管理员中最强大的工具之一。find 命令会根据用户指定的表达式（权限、类型、日期、所有权、大小等条件）在目录层次结构中搜索文件和目录，并且可以对每个匹配的文件执行用户指定的操作。另外，也可以将 find 命令与其他工具结合使用，例如 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/grep/"><code>grep</code></a> 或 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/sed/"><code>sed</code></a>，实现更复杂的功能。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find [-H] [-L] [-P] [-Olevel] [-D debugopts] [path...] [expression]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>path...</code> 路径属性定义搜索文件的起始目录，可以指定一个或多个起始目录。</li>
<li><code>expression</code> 表达式属性由选项，搜索模式和由运算符分隔的动作组成。</li>
</ul>
<p>要在目录中搜索文件，调用 <code>find</code> 命令的用户需要对起始目录以及子目录具有读取权限。</p>
<p>让我们看一下示例 <code>find -L /var/www -name &quot;*.js&quot;</code>。选项<code>-L</code>告诉<code>find</code>命令跟随符号链接。</p>
<p><code>/var/www</code>是find命令搜索的开始目录。表达式<code>-name &quot;*.js</code>告诉<code>find</code>搜索以<code>.js</code>结尾的文件JavaScript文件。</p>
<h2 id="示例-55"><a href="#示例-55" class="headerlink" title="示例"></a>示例</h2><h3 id="按名称查找-搜索文件"><a href="#按名称查找-搜索文件" class="headerlink" title="按名称查找&#x2F;搜索文件"></a>按名称查找&#x2F;搜索文件</h3><p>通过名称查找文件可能是 <code>find</code> 命令的最常见用法。要使用文件名查找文件，请在要搜索的文件名后加上 <code>-name</code> 选项。</p>
<p>例如，要在 <code>/home/getiot</code> 目录中搜索名为 <code>document.pdf</code> 的文件，可以使用命令 <code>find /home/getiot -type f -name document.pdf</code>。</p>
<p>find 的 <code>-name</code> 选项是区分大小写的，如果你需要运行不区分大小写的搜索，请将 <code>-name</code> 选项更改为 <code>-iname</code>。find 命令将匹配 <code>Document.pdf</code>，<code>DOCUMENT.pdf</code> 等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /home/getiot -<span class="built_in">type</span> f -iname document.pdf</span><br></pre></td></tr></table></figure>



<h3 id="按文件扩展名查找文件"><a href="#按文件扩展名查找文件" class="headerlink" title="按文件扩展名查找文件"></a>按文件扩展名查找文件</h3><p>根据扩展名搜索文件与按名称搜索文件相同。例如，要在 <code>/var/log/nginx</code> 目录中查找所有以 <code>.log.gz</code> 结尾的文件，可以使用下面命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /var/log/nginx -<span class="built_in">type</span> f -name <span class="string">&#x27;*.log.gz&#x27;</span></span><br></pre></td></tr></table></figure>



<p>值得一提的是，使用通配符时，必须加单&#x2F;双引号或用反斜杠<code>\</code>转义星号符号<code>*</code>，以避免shell解释它。</p>
<p>要查找与正则表达式 <code>*.log.gz</code> 不匹配的所有文件，可以使用 find 命令的 <code>-not</code> 选项。例如，要查找所有未以 <code>*.log.gz</code> 结尾的文件，你可以使用以下 find 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /var/log/nginx -<span class="built_in">type</span> f -not -name <span class="string">&#x27;*.log.gz&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="按类型查找文件"><a href="#按类型查找文件" class="headerlink" title="按类型查找文件"></a>按类型查找文件</h3><p>有时你可能需要搜索指定的文件类型，例如普通文件，目录或符号链接。在 Linux 中，一切都是文件，包括目录。</p>
<p>要根据文件的类型搜索文件，请使用 find 的 <code>-type</code> 选项指定文件类型。这里我们列出了 Linux 中所有文件的类型。</p>
<p><code>f</code> 是常规文件，<code>d</code> 是目录，<code>l</code> 是<a target="_blank" rel="noopener" href="https://getiot.tech/linux/linux-hard-soft-link/">符号链接</a>，<code>c</code> 是字符设备，<code>b</code> 是块设备，<code>p</code> 是命名管道 FIFO，<code>s</code> 是 socket 套接字。</p>
<p>例如，要在当前工作目录中查找所有目录，可以使用命令 <code>find . -type d</code>，这里 <code>.</code> 表是当前目录，<code>-type d</code> 指定文件类型是目录。</p>
<p>常见示例是使用 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/chmod/"><code>chmod</code></a> 命令将网站文件权限递归更改为 <code>644</code>，目录权限更改为 <code>755</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /var/www/my_website -<span class="built_in">type</span> d -<span class="built_in">exec</span> <span class="built_in">chmod</span> 0755 &#123;&#125; \;</span><br><span class="line">find /var/www/my_website -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">chmod</span> 0644 &#123;&#125; \;</span><br></pre></td></tr></table></figure>



<h3 id="按大小查找文件"><a href="#按大小查找文件" class="headerlink" title="按大小查找文件"></a>按大小查找文件</h3><p>要根据文件大小查找文件，请使用 find 命令的 <code>-size</code> 选项，之后指定文件的大小。你可以使用以下后缀指定文件大小。</p>
<p>如果你使用 <code>-size</code> 选项，但为指定文件的大小，find 将会使用 512 字节作为大小进行文件的搜索。</p>
<p><code>b</code> 是 512 字节，<code>c</code> 是字节，<code>w</code> 是两字节，<code>k</code> 千字节即 kb， <code>M</code> 是兆字节，即 MB，<code>G</code> 是千兆字节即是 GB。</p>
<p>例如命令 <code>find /tmp -type f -size 1024c</code> 将在 <code>/tmp</code> 目录中找到所有 1024 字节的文件。</p>
<p>find 命令还允许你搜索大于或小于指定大小的文件。你可以使用加减符号和文件的大小表示大于或者小于，<code>+</code> 符号表示大于，<code>-</code> 减符号表示小于。</p>
<p>例如命令 <code>find . -type f -size -1M</code>，将在当前工作目录中搜索所有小于 <code>1MB</code> 的文件。注意大小值之前的是减号符号 <code>-</code>。</p>
<p>命令 <code>find . -type f -size +1M</code> 将搜索大小大于 <code>1MB</code> 的文件，注意大小值之前的是加号符号 <code>+</code>。</p>
<p>你甚至可以搜索大小范围内的文件。以下 find 命令将在当前目录下搜索&#x2F;查找 <code>1MB</code> 到和 <code>2MB</code> 之间的所有文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -size +1M -size 21M</span><br></pre></td></tr></table></figure>



<h3 id="按日期查找文件"><a href="#按日期查找文件" class="headerlink" title="按日期查找文件"></a>按日期查找文件</h3><p><code>find</code>命令还可以根据文件的最后修改，访问或更改时间来搜索文件。与按大小搜索时相同，使用加号和减号表示大于或小于。</p>
<p>例如命令 <code>find /etc/dovecot/conf.d -name &quot;*.conf&quot; -mtime 5</code>。将搜索 <code>/etc/dovecot/conf.d</code> 目录下以 <code>.conf</code> 结尾并且在最近五天内已被修改的所有文件。</p>
<p>除了使用 24 小时作为单位之外，你还可以使用分钟、小时、秒等单位作为搜索的条件。我们将在这里列出这些选项。</p>
<p><code>-amin</code> 表示文件最后的访问时间，以分钟作为单位。<code>-atime</code> 表示最后的访问时间，以 24 小时作为单位，即一天。这两个选项都表示在指定访问时间之内。</p>
<p><code>-cmin</code> 表示文件在最后更改时间，以分钟作为单位。<code>-ctime</code> 表示文件在最后更改时间，但以 24 小时作为单位，即一天。这两个选项都表示在指定最后更改时间之内。</p>
<p><code>-mmin</code> 表示文件的最后修改时间，以分钟作为单位。<code>-mtime</code> 表示文件的最后修改时间，但以 24 小时作为单位，即一天。这两个选项都表示在指定修改时间之内。</p>
<p>如果你需要指定修改，访问或更改时间之外作为搜索条件。你可以使用 find 的 <code>-daystart</code> 选项。它将会修改以上选项为时间之外。</p>
<p>这是根据修改日期过滤文件的另一个示例。以下命令将列出 <code>/home</code> 目录中 30 多天之后修改的所有文件，包括 30 天的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /home -mtime +30 -daystart</span><br></pre></td></tr></table></figure>



<h3 id="按权限查找文件"><a href="#按权限查找文件" class="headerlink" title="按权限查找文件"></a>按权限查找文件</h3><p>find 的 <code>-perm</code> 选项可让你根据文件权限搜索文件。你可以使用文件权限的符号模式，或者数字模式进行搜索。</p>
<p>我们建议你使用数字模式，因为符号模式会显得更复杂，这不易于阅读。你可以在数字模式前加上减号 <code>-</code> 或斜线 <code>/</code>。</p>
<p>如果将斜线 <code>/</code> 用作前缀，则至少是用户，组或其他人的其中一个权限位与文件匹配。如果将减号 <code>-</code> 用作前缀，则文件的权限位必须全匹配。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -perm /444</span><br><span class="line">find . -perm -664</span><br></pre></td></tr></table></figure>



<h3 id="按所有者查找文件"><a href="#按所有者查找文件" class="headerlink" title="按所有者查找文件"></a>按所有者查找文件</h3><p>find 的 <code>-user</code> 和 <code>-group</code> 选项允许你要查找指定用户或组拥有的文件。例如命令 <code>find / -user getiot</code>，将会搜索用户 <code>getiot</code> 拥有的所有文件和目录。</p>
<p>这是一个真实的例子。假设你要查找 <code>www-data</code> 用户拥有的所有文件，并将匹配文件的所有权从 <code>www-data</code> 更改为 <code>nginx</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -user www-data -<span class="built_in">type</span> f  -<span class="built_in">exec</span> <span class="built_in">chown</span> nginx &#123;&#125; \;</span><br></pre></td></tr></table></figure>



<h3 id="查找并删除文件"><a href="#查找并删除文件" class="headerlink" title="查找并删除文件"></a>查找并删除文件</h3><p>将 <code>-delete</code> 选项附加到匹配表达式的末尾。find 将会删除所有匹配的文件。</p>
<p>建议仅在确定结果与要删除的文件匹配时，使用 <code>-delete</code> 选项。你可以先打印匹配的文件，然后再加 <code>-delete</code> 选项。请谨慎使用 <code>-delete</code> 选项。</p>
<p>对于目录的删除，find 的 <code>--delete</code> 选项只能删除与 <code>rmdir</code> 相同的空目录。例如，要从 <code>/var/log/</code> 中删除所有以 <code>.temp</code> 结尾的文件，你可以运行以下 find 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /var/log/ -name `*.temp` -delete</span><br></pre></td></tr></table></figure>





<h1 id="Linux-grep-命令-搜索文本内容"><a href="#Linux-grep-命令-搜索文本内容" class="headerlink" title="Linux grep 命令 - 搜索文本内容"></a>Linux grep 命令 - 搜索文本内容</h1><h2 id="介绍-56"><a href="#介绍-56" class="headerlink" title="介绍"></a>介绍</h2><p><strong>grep</strong>（英文全拼：Global Regular Expression Print）命令是一个强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<p>grep 的工作方式是在一个或多个文件中搜索字符串模板，如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。在 shell 脚本中常常使用 grep 命令进行一些自动化的文本处理工作。</p>
<p>相关命令：egrep、fgrep、rgrep</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep [OPTION...] PATTERNS [FILE...]</span><br><span class="line">grep [OPTION...] -e PATTERNS ... [FILE...]</span><br><span class="line">grep [OPTION...] -f PATTERN_FILE ... [FILE...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>, <code>--text</code> ：不要忽略二进制的数据。</li>
<li><code>-b</code>, <code>--byte-offset</code> ：在显示符合样式的那一行之前，标示出该行第一个字符的编号。</li>
<li><code>-c</code>, <code>--count</code> ：计算符合样式的列数。</li>
<li><code>-A</code>, <code>--after-context=NUM</code> ：除了显示符合范本样式的那一列之外，并显示该行之后的内容。</li>
<li><code>-B</code>, <code>--before-context=NUM</code> ：除了显示符合样式的那一行之外，并显示该行之前的内容。</li>
<li><code>-C</code>, <code>--context=NUM</code> ：除了显示符合样式的那一行之外，并显示该行之前后的内容。</li>
<li><code>-d</code>, <code>--directories=ACTION</code> ：当指定要查找的是目录而非文件时，必须使用这项参数，否则 grep 指令将回报信息并停止动作。</li>
<li><code>-e</code>, <code>--regexp=PATTERNS</code> ：指定字符串做为查找文件内容的样式。</li>
<li><code>-f</code>, <code>--file=FILE</code> ：指定规则文件，其内容含有一个或多个规则样式，让 grep 查找符合规则条件的文件内容，格式为每行一个规则样式。</li>
<li><code>-E</code>, <code>--extended-regexp</code> ：将样式为延伸的正则表达式来使用。</li>
<li><code>-F</code>, <code>--fixed-regexp</code> ：将样式视为固定字符串的列表。</li>
<li><code>-G</code>, <code>--basic-regexp</code> ：将样式视为普通的表示法来使用。</li>
<li><code>-h</code>, <code>--no-filename</code> ：在显示符合样式的那一行之前，不标示该行所属的文件名称。</li>
<li><code>-H</code>, <code>--with-filename</code> ：在显示符合样式的那一行之前，表示该行所属的文件名称。</li>
<li><code>-i</code>, <code>--ignore-case</code> ：忽略字符大小写的差别。</li>
<li><code>-l</code>, <code>--file-with-matches</code> ：列出文件内容符合指定的样式的文件名称。</li>
<li><code>-L</code>, <code>--files-without-match</code> ：列出文件内容不符合指定的样式的文件名称。</li>
<li><code>-n</code>, <code>--line-number</code> ：在显示符合样式的那一行之前，标示出该行的列数编号。</li>
<li><code>-o</code>, <code>--only-matching</code> ：只显示匹配 PATTERN 部分。</li>
<li><code>-q</code>, <code>--quiet</code>, <code>--silent</code> ：不显示任何信息。</li>
<li><code>-r</code>, <code>--recursive</code> ：递归查找指定目录下的所有文件。</li>
<li><code>-s</code>, <code>--no-messages</code> : 不显示错误信息。</li>
<li><code>-v</code>, <code>--invert-match</code> ：显示不包含匹配文本的所有行。</li>
<li><code>-w</code>, <code>--word-regexp</code> ：只显示全字符合的列。</li>
<li><code>-x</code>, <code>--line-regexp</code> ：只显示全列符合的列。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息。</li>
</ul>
<h2 id="示例-56"><a href="#示例-56" class="headerlink" title="示例"></a>示例</h2><h3 id="查找进程"><a href="#查找进程" class="headerlink" title="查找进程"></a>查找进程</h3><p>查找指定进程（init 进程）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep init</span><br></pre></td></tr></table></figure>



<p>查找指定进程个数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep init -c</span><br></pre></td></tr></table></figure>



<p>查找指定进程，但不显示 grep 查找进程本身</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep init | grep -v <span class="string">&quot;grep&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="查找文件内容"><a href="#查找文件内容" class="headerlink" title="查找文件内容"></a>查找文件内容</h3><p>假设文件 dialogue.txt 内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Rudy: Hello, Welcome to getiot.tech website.</span><br><span class="line">Tina: Hello, Rudy. That is so cool.</span><br><span class="line">Rudy: Thanks, I<span class="string">&#x27;m so glad you like it.</span></span><br><span class="line"><span class="string">Tina: Of courses, I&#x27;</span>ve subscribed it.</span><br></pre></td></tr></table></figure>



<p>keywords.txt 文件保存关键字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getiot</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>



<p>从文件中读取关键词进行搜索</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> dialogue.txt | grep -f keywords.txt</span><br></pre></td></tr></table></figure>



<p>从文件中读取关键词进行搜索，并显示行号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> dialogue.txt | grep -nf keywords.txt</span><br></pre></td></tr></table></figure>



<p>从文件中查找关键词 getiot</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;getiot&quot;</span> dialogue.txt</span><br></pre></td></tr></table></figure>



<p>从文件中查找关键词 hello（不区分大小写）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -i <span class="string">&quot;hello&quot;</span> dialogue.txt</span><br></pre></td></tr></table></figure>



<p>从当前目录中递归查找关键词，并显示行号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -rn <span class="string">&quot;getiot&quot;</span> ./*</span><br></pre></td></tr></table></figure>



<p>找出以 R 开头的行内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> dialogue.txt | grep ^R</span><br></pre></td></tr></table></figure>



<p>输出非 R 开头的行内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> dialogue.txt | grep ^[^R]</span><br></pre></td></tr></table></figure>



<p>输出以 it. 结尾的行内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> dialogue.txt | grep it.$</span><br></pre></td></tr></table></figure>



<p>显示包含 so 或者 to 字符的内容行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> dialogue.txt | grep -E <span class="string">&quot;so|to&quot;</span></span><br></pre></td></tr></table></figure>





<h1 id="Linux-read-命令-读取用户输入"><a href="#Linux-read-命令-读取用户输入" class="headerlink" title="Linux read 命令 - 读取用户输入"></a>Linux read 命令 - 读取用户输入</h1><h2 id="介绍-57"><a href="#介绍-57" class="headerlink" title="介绍"></a>介绍</h2><p><strong>read</strong> 命令用于从标准输入读取当行数据。</p>
<p>read 是一个 bash 的内建命令，这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span> [选项] [参数]</span><br></pre></td></tr></table></figure>



<p><strong>参数说明:</strong></p>
<ul>
<li><code>-a</code> ：后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。</li>
<li><code>-d</code> ：后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。</li>
<li><code>-p</code> ：后面跟提示信息，即在输入前打印提示信息。</li>
<li><code>-e</code> ：在输入的时候可以使用命令补全功能。</li>
<li><code>-n</code> ：后跟一个数字，定义输入文本的长度，很实用。</li>
<li><code>-r</code> ：屏蔽 <code>\</code>，如果没有该选项，则 <code>\</code> 作为一个转义字符，有的话 <code>\</code> 就是个正常的字符了。</li>
<li><code>-s</code> ：安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。</li>
<li><code>-t</code> ：后面跟秒数，定义输入字符的等待时间。</li>
<li><code>-u</code> ：后面跟 fd，从文件描述符中读入，该文件描述符可以是 exec 新开启的。</li>
</ul>
<h2 id="示例-57"><a href="#示例-57" class="headerlink" title="示例"></a>示例</h2><p>简单读取键盘输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;输入网站名: &quot;</span></span><br><span class="line"><span class="built_in">read</span> file</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;你输入的网站名是 <span class="variable">$file</span>&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>



<p>允许在 read 命令行中直接指定一个提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;输入网站名:&quot;</span> file </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;你输入的网站名是 <span class="variable">$file</span>&quot;</span>  </span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>



<p>指定 read 命令等待输入的秒数。当计时满时，read 命令返回一个非零退出状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">read</span> -t 5 -p <span class="string">&quot;输入网站名:&quot;</span> file </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;你输入的网站名是 <span class="variable">$file</span>&quot;</span> </span><br><span class="line"><span class="keyword">else</span>     </span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;\n抱歉，你输入超时了。&quot;</span> </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>



<p>设置 read 命令计数输入的字符。当输入的字符数目达到预定数目时，自动退出，并将输入的数据赋值给变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="built_in">read</span> -n1 -p <span class="string">&quot;Do you want to continue [Y/N]?&quot;</span> answer</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$answer</span> <span class="keyword">in</span> </span><br><span class="line">Y | y)       </span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;fine ,continue&quot;</span>;; </span><br><span class="line">N | n)       </span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;ok,good bye&quot;</span>;; </span><br><span class="line">*)      </span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;error choice&quot;</span>;;  </span><br><span class="line"><span class="keyword">esac</span> </span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>



<p>使 read 命令中输入的数据不显示在命令终端上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="built_in">read</span> -s -p <span class="string">&quot;请输入您的密码:&quot;</span> pass </span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\n您输入的密码是 <span class="variable">$pass</span>&quot;</span> </span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>





<h1 id="Linux-umask-命令-设置文件权限掩码"><a href="#Linux-umask-命令-设置文件权限掩码" class="headerlink" title="Linux umask 命令 - 设置文件权限掩码"></a>Linux umask 命令 - 设置文件权限掩码</h1><h2 id="介绍-58"><a href="#介绍-58" class="headerlink" title="介绍"></a>介绍</h2><p><strong>umask</strong> 命令用于显示或设置创建文件的权限掩码。在 Linux 系统中，权限掩码是由3个八进制的数字所组成，将现有的存取权限减掉权限掩码后，即可产生建立文件时预设的权限。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">umask</span> [-p] [-S] [mode]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-p</code> ：以文字的方式来表示权限掩码。</li>
<li><code>-S</code> ：输出的权限掩码可直接作为指令来执行。</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li><code>mode</code>（可选）：八进制数或符号组合。</li>
</ul>
<h2 id="示例-58"><a href="#示例-58" class="headerlink" title="示例"></a>示例</h2><p>查看系统当前权限掩码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">umask</span> </span><br><span class="line">0002</span><br></pre></td></tr></table></figure>



<p>以文字的方式输出权限掩码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">umask</span> -p</span><br><span class="line"><span class="built_in">umask</span> 0002</span><br></pre></td></tr></table></figure>



<p>以符号组合的方式输出权限掩码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">umask</span> -S</span><br><span class="line">u=rwx,g=rwx,o=rx</span><br></pre></td></tr></table></figure>



<p>输出的结果 <code>u=rwx,g=rwx,o=rx</code> 转化为八进制数等于 <code>775</code>。</p>
<p>提示</p>
<ul>
<li><code>u</code> 符号代表当前用户。</li>
<li><code>g</code> 符号代表和当前用户在同一个组的用户，以下简称组用户。</li>
<li><code>o</code> 符号代表其他用户。</li>
<li><code>a</code> 符号代表所有用户。</li>
<li><code>r</code> 符号代表读权限以及八进制数 <code>4</code>。</li>
<li><code>w</code> 符号代表写权限以及八进制数 <code>2</code>。</li>
<li><code>x</code> 符号代表执行权限以及八进制数 <code>1</code>。</li>
<li><code>+</code> 符号代表添加目标用户相应的权限。</li>
<li><code>-</code> 符号代表删除目标用户相应的权限。</li>
<li><code>=</code> 符号代表添加目标用户相应的权限，删除未提到的权限。</li>
</ul>
<p>为组用户添加写权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">umask</span> g+w</span><br></pre></td></tr></table></figure>



<p>删除其他用户的写、执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">umask</span> o-wx</span><br></pre></td></tr></table></figure>



<p>赋值全部用户所有权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">umask</span> a=rwx</span><br></pre></td></tr></table></figure>



<p>上述命令等效于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">umask</span> u=rwx,g=rwx,o=rwx</span><br></pre></td></tr></table></figure>



<p>清除其他用户的读、写、执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">umask</span> o=</span><br></pre></td></tr></table></figure>





<h1 id="Linux-touch-命令-创建或更新文件"><a href="#Linux-touch-命令-创建或更新文件" class="headerlink" title="Linux touch 命令 - 创建或更新文件"></a>Linux touch 命令 - 创建或更新文件</h1><h2 id="介绍-59"><a href="#介绍-59" class="headerlink" title="介绍"></a>介绍</h2><p><strong>touch</strong> 命令有两个功能：一是创建新的空文件，二是改变已有文件的时间戳属性。</p>
<p>touch 命令会根据当前的系统时间更新指定文件的访问时间和修改时间。如果文件不存在，将会创建新的空文件。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> [OPTION]... FILE...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code> ：改变文件的读取时间记录。</li>
<li><code>-m</code> ：改变文件的修改时间记录。</li>
<li><code>-c</code> ：假如目标文件不存在，不会建立新的文件。与 <code>--no-create</code> 的效果一样。</li>
<li><code>-f</code> ：不使用，是为了与其他 unix 系统的相容性而保留。</li>
<li><code>-r</code> ：使用参考文件的时间记录，与 <code>--file</code> 的效果一样。</li>
<li><code>-d</code> ：设定时间与日期，可以使用各种不同的格式。</li>
<li><code>-t</code> ：设定文件的时间记录，格式与 date 指令相同。</li>
<li><code>--no-create</code> ：不会建立新档案。</li>
<li><code>--help</code> ：显示帮助信息。</li>
<li><code>--version</code> ：显示版本信息。</li>
</ul>
<h2 id="示例-59"><a href="#示例-59" class="headerlink" title="示例"></a>示例</h2><p>创建空文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> file.txt</span><br></pre></td></tr></table></figure>



<p>批量创建文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> file&#123;1..5&#125;.txt </span><br></pre></td></tr></table></figure>



<p>修改文件的 access（访问）时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> -a file.txt</span><br></pre></td></tr></table></figure>



<p>提示：文件的 access（访问）时间可通过 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/stat/">stat</a> 命令查看。</p>
<h1 id="Linux-cp-命令-复制文件或目录"><a href="#Linux-cp-命令-复制文件或目录" class="headerlink" title="Linux cp 命令 - 复制文件或目录"></a>Linux cp 命令 - 复制文件或目录</h1><h2 id="介绍-60"><a href="#介绍-60" class="headerlink" title="介绍"></a>介绍</h2><p><strong>cp</strong>（英文全拼：copy）命令用于复制文件或目录。</p>
<p>可以将多个文件复制到一个具体的文件名或一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> [options] <span class="built_in">source</span> dest</span><br><span class="line"><span class="built_in">cp</span> [options] <span class="built_in">source</span>... directory</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于 dpR 参数组合。</li>
<li><code>-b</code>：覆盖已存在的文件目标前将目标文件备份。</li>
<li><code>-d</code>：当复制符号链接时，把目标文件或目录也建立为符号链接，并指向与源文件或目录链接的原始文件或目录。</li>
<li><code>-f</code>：覆盖已经存在的目标文件而不给出提示。</li>
<li><code>-i</code>：与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 “y” 时目标文件将被覆盖。</li>
<li><code>-p</code>：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</li>
<li><code>-r</code>：递归复制文件和目录。若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</li>
<li><code>-l</code>：对源文件建立硬链接，而非复制文件。</li>
<li><code>-s</code>：对源文件建立符号链接，而非复制文件。</li>
<li><code>-v</code>：详细显示 cp 命令执行的操作过程。</li>
</ul>
<h2 id="示例-60"><a href="#示例-60" class="headerlink" title="示例"></a>示例</h2><p>复制文件（源文件 testfile1，目标文件 testfile2）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> testfile1 testfile2</span><br></pre></td></tr></table></figure>



<p>将文件 testfile1 复制到目录 dir 里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> testfile1 <span class="built_in">dir</span>/</span><br></pre></td></tr></table></figure>



<p>同时将文件 testfile1 和 testfile2 复制到目录 dir 里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> testfile1 testfile2 <span class="built_in">dir</span>/</span><br></pre></td></tr></table></figure>



<p>复制目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r dir1 dir2</span><br></pre></td></tr></table></figure>





<h1 id="Linux-rm-命令-删除文件或目录"><a href="#Linux-rm-命令-删除文件或目录" class="headerlink" title="Linux rm 命令 - 删除文件或目录"></a>Linux rm 命令 - 删除文件或目录</h1><h2 id="介绍-61"><a href="#介绍-61" class="headerlink" title="介绍"></a>介绍</h2><p><strong>rm</strong>（英文全拼：remove）命令用于删除一个文件或者目录。</p>
<p>rm 是常用的命令，它可以删除一个指定文件或目录，也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。</p>
<p>rm 是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令。所以，在执行 rm 命令之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-i</code> ：删除前逐一询问确认。</li>
<li><code>-f</code> ：即使文件属性为只读，也直接删除，无需逐一确认。</li>
<li><code>-r</code> ：将目录及其里面的文件逐一删除。</li>
</ul>
<h2 id="示例-61"><a href="#示例-61" class="headerlink" title="示例"></a>示例</h2><p>删除文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> test.txt</span><br></pre></td></tr></table></figure>



<p>删除目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -r <span class="built_in">dir</span>/</span><br></pre></td></tr></table></figure>



<p>删除前逐一询问确认：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> -i <span class="built_in">dir</span>/*</span><br></pre></td></tr></table></figure>



<p>直接删除，不作任何提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f test.txt.bz2  </span><br></pre></td></tr></table></figure>



<p>清空系统中所有的文件（谨慎！除非你知道自己在干嘛，否则永远不要使用）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /*</span><br></pre></td></tr></table></figure>



<p>如果不小心创建了一些特殊文件，可不好删除，比如一个名为 <code>-D</code> 的文件。执行 <code>rm -D</code> 会将文件名误认为选项，这时候可以通过文件的 inode 硬链接编号来删除。</p>
<p>首先，使用 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/stat/">stat</a> 命令查看 inode 号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  文件：./-D</span><br><span class="line">  大小：0               块：0          IO 块：4096   普通空文件</span><br><span class="line">设备：816h/2070d        Inode：9568258     硬链接：1</span><br><span class="line">权限：(0664/-rw-rw-r--)  Uid：( 1000/    rudy)   Gid：( 1000/    rudy)</span><br><span class="line">最近访问：2021-04-14 15:12:32.962045401 +0800</span><br><span class="line">最近更改：2021-04-14 15:12:32.962045401 +0800</span><br><span class="line">最近改动：2021-04-14 15:12:32.962045401 +0800</span><br></pre></td></tr></table></figure>



<p>或者，使用 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/ls/">ls</a> 命令加 <code>-i</code> 选项查看 inode 号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -il</span><br><span class="line">9568258 -rw-rw-r--   1 rudy rudy         0 4月  14 15:12 -D</span><br></pre></td></tr></table></figure>



<p>接着使用 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/find/">find</a> 命令通过 inode 号查找文件并使用 rm 命令删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ find . -inum 9568258 -<span class="built_in">exec</span> <span class="built_in">rm</span> -i &#123;&#125; \;</span><br><span class="line"><span class="built_in">rm</span>：是否删除普通空文件 <span class="string">&#x27;./-D&#x27;</span>？ y</span><br></pre></td></tr></table></figure>



<p>为避免删错文件，这里使用了 rm 的交互式删除。</p>
<p>不需要交互时，可以将 rm 后的 <code>-i</code> 选项去掉，或者直接使用 delete 进行删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ find . -inum 9568258 -delete</span><br></pre></td></tr></table></figure>





<h1 id="Linux-mv-命令-移动或重命名文件"><a href="#Linux-mv-命令-移动或重命名文件" class="headerlink" title="Linux mv 命令 - 移动或重命名文件"></a>Linux mv 命令 - 移动或重命名文件</h1><h2 id="介绍-62"><a href="#介绍-62" class="headerlink" title="介绍"></a>介绍</h2><p><strong>mv</strong>（英文全拼：move）命令用于移动文件或对其重命名。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> [options] <span class="built_in">source</span> dest</span><br><span class="line"><span class="built_in">mv</span> [options] <span class="built_in">source</span>... directory</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-b</code> ：当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。</li>
<li><code>-i</code> ：如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 “y” 表示直接覆盖，输入 “n” 表示取消该操作。</li>
<li><code>-f</code> ：如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。</li>
<li><code>-n</code> ：不要覆盖任何已存在的文件或目录。</li>
<li><code>-u</code> ：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。</li>
</ul>
<h2 id="示例-62"><a href="#示例-62" class="headerlink" title="示例"></a>示例</h2><p>将文件 testfile1 重命名为 testfile2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> testfile1 testfile2</span><br></pre></td></tr></table></figure>



<p>将文件 file 移动到目录 dir 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> file <span class="built_in">dir</span>/</span><br></pre></td></tr></table></figure>



<p>将目录 dir1 移动目录 dir2 中（前提是目录 dir2 已存在，若不存在为重命名）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> dir1/ dir2/</span><br></pre></td></tr></table></figure>





<h1 id="Linux-vim-命令-文本编辑器"><a href="#Linux-vim-命令-文本编辑器" class="headerlink" title="Linux vim 命令 - 文本编辑器"></a>Linux vim 命令 - 文本编辑器</h1><h2 id="介绍-63"><a href="#介绍-63" class="headerlink" title="介绍"></a>介绍</h2><p><strong>vim</strong> 是 Linux 系统中非常流行的一个文本编辑器，绝大多数 Linux 系统都会内置 vim。</p>
<p>vim 是 Vi IMproved 的简写，从名字可以看出，它是从 vi 发展出来的一个文本编辑器，提供了代码补完、编译及错误跳转等方便编程的功能。同时，可通过 vim 插件扩展其功能，将 vim 打造成一款强大的 IDE 工具。</p>
<p>可以说，vim 是 Linux 系统中的一个神兵利器。但对于初学者来说，vim 可能会显得有些复杂，因为要想熟练使用它，需要记住很多操作命令。</p>
<p>提示</p>
<p>Vim 的第一个版本由布莱姆·米勒在1991年发布，如今代码托管在 <a target="_blank" rel="noopener" href="https://github.com/vim/vim">GitHub</a> 上。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim [参数] [文件 ..]        <span class="comment"># 编辑指定的文件</span></span><br><span class="line">vim [参数] -               <span class="comment"># 从标准输入(stdin)读取文本</span></span><br><span class="line">vim [参数] -t tag          <span class="comment"># 编辑 tag 定义处的文件</span></span><br><span class="line">vim [参数] -q [errorfile]  <span class="comment"># 编辑第一个出错处的文件</span></span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>--</code>：在这以后只有文件名。</li>
<li><code>-v</code>：Vi 模式（同 “vi”）。</li>
<li><code>-e</code>：Ex 模式（同 “ex”）。</li>
<li><code>-E</code>：改进的 Ex 模式。</li>
<li><code>-s</code>：安静（批处理）模式（只能与 “ex” 一起使用）。</li>
<li><code>-d</code>：Diff 模式（同 “vimdiff”）。</li>
<li><code>-y</code>：容易模式（同 “evim”，无模式）。</li>
<li><code>-R</code>：只读模式（同 “view”）。</li>
<li><code>-Z</code>：限制模式（同 “rvim”）。</li>
<li><code>-m</code>：不可修改（写入文件）。</li>
<li><code>-M</code>：文本不可修改。</li>
<li><code>-b</code>：二进制模式。</li>
<li><code>-l</code>：Lisp 模式。</li>
<li><code>-C</code>：兼容传统的 Vi（compatible）。</li>
<li><code>-N</code>：不完全兼容传统的 Vi（nocompatible）。</li>
<li><code>-V[N][fname]</code>：将 N 等级的详细消息记录到 fname 文件。</li>
<li><code>-D</code>：调试模式。</li>
<li><code>-n</code>：不使用交换文件，只使用内存。</li>
<li><code>-r</code>：列出交换文件并退出。</li>
<li><code>-r (跟文件名)</code>：恢复崩溃的会话。</li>
<li><code>-L</code>：同 <code>-r</code>。</li>
<li><code>-A</code>：以 Arabic 模式启动。</li>
<li><code>-H</code>：以 Hebrew 模式启动。</li>
<li><code>-T &lt;terminal&gt;</code>：设定终端类型为 <code>&lt;terminal&gt;</code>。</li>
<li><code>--not-a-term</code>：跳过输入&#x2F;输出不是终端的警告。</li>
<li><code>--ttyfail</code>：如果输入或输出不是终端则退出。</li>
<li><code>-u &lt;vimrc&gt;</code>：使用 <code>&lt;vimrc&gt;</code> 替代任何 .vimrc。</li>
<li><code>--noplugin</code>：不加载 plugin 脚本。</li>
<li><code>-p[N]</code>：打开 N 个标签页（默认值：每个文件一个）。</li>
<li><code>-o[N]</code>：打开 N 个窗口（默认值：每个文件一个）。</li>
<li><code>-O[N]</code>：同 -o 但垂直分割。</li>
<li><code>+</code>：启动后跳到文件末尾。</li>
<li><code>+&lt;lnum&gt;</code>：启动后跳到第 <code>&lt;lnum&gt;</code> 行。</li>
<li><code>--cmd &lt;command&gt;</code>：加载任何 vimrc 文件前执行 <code>&lt;command&gt;</code>。</li>
<li><code>-c &lt;command&gt;</code>：加载第一个文件后执行 <code>&lt;command&gt;</code>。</li>
<li><code>-S &lt;session&gt;</code>：加载第一个文件后执行文件 <code>&lt;session&gt;</code>。</li>
<li><code>-s &lt;scriptin&gt;</code>：从文件 <code>&lt;scriptin&gt;</code> 读入正常模式的命令。</li>
<li><code>-w &lt;scriptout&gt;</code>：将所有输入的命令追加到文件 <code>&lt;scriptout&gt;</code>。</li>
<li><code>-W &lt;scriptout&gt;</code>：将所有输入的命令写入到文件 <code>&lt;scriptout&gt;</code>。</li>
<li><code>-x</code>：编辑加密的文件。</li>
<li><code>--startuptime &lt;file&gt;</code>：将启动时序消息（startup timing messages）写入文件 <code>&lt;file&gt;</code>。</li>
<li><code>-i &lt;viminfo&gt;</code>：使用 <code>&lt;viminfo&gt;</code> 取代 .viminfo。</li>
<li><code>--clean</code>：Vim 默认模式，没有插件，没有 viminfo。</li>
<li><code>-h, --help</code>：打印帮助信息。</li>
<li><code>--version</code>：打印版本信息。</li>
</ul>
<h2 id="示例-63"><a href="#示例-63" class="headerlink" title="示例"></a>示例</h2><p>打开当前目录下的 hello.txt 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim hello.txt</span><br></pre></td></tr></table></figure>



<p>同时打开 hello.txt 和 world.txt 文件：</p>
<ul>
<li>首先执行 <code>vim hello.txt</code> 打开其中一个文件；</li>
<li>然后在 vim 中输入 <code>:split world.txt</code>，打开另一个文件（默认是上下分隔窗口）；</li>
<li>如果想要左右分割窗口，则输入 <code>:vsplit world.txt</code>。</li>
</ul>
<p>关于 vim 编辑器的详细使用方法，可参考《<a target="_blank" rel="noopener" href="https://getiot.tech/linux/linux-vim-text-editor/">Vim 文本编辑器</a>》。</p>
<h1 id="Linux-file-命令-识别文件类型"><a href="#Linux-file-命令-识别文件类型" class="headerlink" title="Linux file 命令 - 识别文件类型"></a>Linux file 命令 - 识别文件类型</h1><h2 id="介绍-64"><a href="#介绍-64" class="headerlink" title="介绍"></a>介绍</h2><p><strong>file</strong> 命令用于探测 Linux 系统中指定文件的类型，也可用来辨别一些文件的编码格式。</p>
<p>与 Windows 系统通过扩展名来确定文件类型不同，file 命令通过查看文件的头部信息来获取文件类型。file 命令对文件的检查分为文件系统、魔法幻数检查和语言检查 3 个过程。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file [options] &lt;file&gt; ...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-b</code>, <code>--brief</code> ：列出辨识结果时，不显示文件名称。</li>
<li><code>-c</code>, <code>--checking-printout</code> ：详细显示指令执行过程，便于排错或分析程序执行的情形。</li>
<li><code>-f</code>, <code>--files-from &lt;namefile&gt;</code> ：指定名称文件，其内容有一个或多个文件名称时，让 file 依序辨识这些文件，格式为每列一个文件名称。</li>
<li><code>-L</code>, <code>--dereference</code> ：直接显示符号连接所指向的文件类别。</li>
<li><code>-m</code>, <code>--magic-file &lt;magicfiles&gt;</code> ：指定魔法数字文件。</li>
<li><code>-z</code>, <code>--uncompress</code> ：尝试去解读压缩文件的内容。</li>
<li><code>-v</code>, <code>--version</code> ：显示版本信息。</li>
<li><code>--help</code> ：显示帮助信息。</li>
</ul>
<h2 id="示例-64"><a href="#示例-64" class="headerlink" title="示例"></a>示例</h2><p>查看当前目录下的 main.c 文件类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file main.c </span><br><span class="line">main.c: C <span class="built_in">source</span>, ASCII text</span><br></pre></td></tr></table></figure>



<p>查看当前目录下的 README.md 文件类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file README.md </span><br><span class="line">README.md: UTF-8 Unicode text</span><br></pre></td></tr></table></figure>



<p>查看 &#x2F;bin&#x2F;sh 文件类型（软链接）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file /bin/sh</span><br><span class="line">/bin/sh: symbolic <span class="built_in">link</span> to dash</span><br></pre></td></tr></table></figure>



<p>查看系统 &#x2F;etc&#x2F;profile 文件类型（不显示文件名称）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file -b /etc/profile</span><br><span class="line">ASCII text</span><br></pre></td></tr></table></figure>



<p>查看当前用户主目录的文件类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file <span class="variable">$HOME</span></span><br><span class="line">/home/rudy: directory</span><br></pre></td></tr></table></figure>





<h1 id="Linux-tee-命令-读取并输出到文件"><a href="#Linux-tee-命令-读取并输出到文件" class="headerlink" title="Linux tee 命令 - 读取并输出到文件"></a>Linux tee 命令 - 读取并输出到文件</h1><h2 id="介绍-65"><a href="#介绍-65" class="headerlink" title="介绍"></a>介绍</h2><p><strong>tee</strong> 命令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件 。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tee [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>, <code>--append</code> ：附加到既有文件的后面，而非覆盖它．</li>
<li><code>-i</code>, <code>--ignore-interrupts</code> ：忽略中断信号。</li>
<li><code>--help</code> ：显示帮助。</li>
<li><code>--version</code> ：显示版本信息。</li>
</ul>
<h2 id="示例-65"><a href="#示例-65" class="headerlink" title="示例"></a>示例</h2><p>将用户输入的数据同时保存到文件 file1 和 file2 中：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tee</span> file1 file2 </span><br></pre></td></tr></table></figure>



<p>将 ping 的信息输出到终端，同时也写入到文件中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping google.com | tee output.txt</span><br></pre></td></tr></table></figure>





<h1 id="Linux-wc-命令-统计文件内容"><a href="#Linux-wc-命令-统计文件内容" class="headerlink" title="Linux wc 命令 - 统计文件内容"></a>Linux wc 命令 - 统计文件内容</h1><h2 id="介绍-66"><a href="#介绍-66" class="headerlink" title="介绍"></a>介绍</h2><p><strong>wc</strong>（英文全拼：word counts）命令统计指定文件中的字节数、字数、行数，并将统计结果显示输出。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wc</span> [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-c</code>, <code>--bytes</code> ：只显示字节数。</li>
<li><code>-m</code>, <code>--chars</code> ：只显示字符数。</li>
<li><code>-l</code>, <code>--lines</code> ：显示行数。</li>
<li><code>-w</code>, <code>--words</code> ：只显示字数。</li>
<li><code>--help</code> ：在线帮助。</li>
<li><code>--version</code> ：显示版本信息。</li>
</ul>
<h2 id="示例-66"><a href="#示例-66" class="headerlink" title="示例"></a>示例</h2><p>统计文件字数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wc</span> -w test.txt </span><br></pre></td></tr></table></figure>



<p>统计文件字节数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wc</span> -c test.txt </span><br></pre></td></tr></table></figure>



<p>统计文件字符数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wc</span> -m test.txt </span><br></pre></td></tr></table></figure>



<p>统计文件行数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wc</span> -l test.txt </span><br></pre></td></tr></table></figure>



<p>打印最长行的长度：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wc</span> -L test.txt</span><br></pre></td></tr></table></figure>



<p>统计当前目录下的文件和目录总数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> | <span class="built_in">wc</span> -w</span><br></pre></td></tr></table></figure>





<h1 id="Linux-awk-命令-文本处理工具"><a href="#Linux-awk-命令-文本处理工具" class="headerlink" title="Linux awk 命令 - 文本处理工具"></a>Linux awk 命令 - 文本处理工具</h1><h2 id="介绍-67"><a href="#介绍-67" class="headerlink" title="介绍"></a>介绍</h2><p><strong>awk</strong> 是一种强大的文本处理工具，用于在 Unix 和 Linux 系统中处理和分析文本数据。它是一种基于模式匹配和动作执行的编程语言，通常用于从结构化文本中提取和操作数据。awk 常常用于处理行格式的文本数据，例如日志文件或表格数据。</p>
<p>awk 提供了丰富的功能，允许用户执行复杂的文本处理任务。它在脚本编程和数据分析中都非常有用。需要注意的是，awk 使用空格或制表符作为默认字段分隔符，但可以通过 <code>-F</code> 选项来指定其他分隔符。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;模式 &#123; 动作 &#125;&#x27;</span> 文件</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>模式</strong>：指定要匹配的条件，如果省略模式，则默认匹配所有行。</li>
<li><strong>动作</strong>：指定在匹配到模式时要执行的操作，可以是打印、计算、赋值等。</li>
</ul>
<h2 id="示例-67"><a href="#示例-67" class="headerlink" title="示例"></a>示例</h2><p>打印文件中每行的第二列和第四列：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print $2, $4&#125;&#x27;</span> filename</span><br></pre></td></tr></table></figure>



<p>将 <code>ls -l</code> 的结果作为输入，打印其中每行的第二列和第四列：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l | awk <span class="string">&#x27;&#123;print $2, $4&#125;&#x27;</span></span><br></pre></td></tr></table></figure>



<p>计算文件中第一列的总和，并在文件末尾输出总和值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;sum += $1&#125; END &#123;print &quot;Sum =&quot;, sum&#125;&#x27;</span> filename</span><br></pre></td></tr></table></figure>



<p>打印包含指定模式的所有行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;/pattern/ &#123;print&#125;&#x27;</span> filename</span><br></pre></td></tr></table></figure>



<p>根据第三列的值打印相应的消息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;if ($3 &gt; 50) print $1, &quot;High&quot;; else print $1, &quot;Low&quot;&#125;&#x27;</span> filename</span><br></pre></td></tr></table></figure>



<p>使用冒号作为字段分隔符，打印 <code>/etc/passwd</code> 文件中的第一列和第三列：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F<span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $1, $3&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>





<h1 id="Linux-sed-命令-流编辑器"><a href="#Linux-sed-命令-流编辑器" class="headerlink" title="Linux sed 命令 - 流编辑器"></a>Linux sed 命令 - 流编辑器</h1><h2 id="介绍-68"><a href="#介绍-68" class="headerlink" title="介绍"></a>介绍</h2><p><strong>sed</strong>（流编辑器）是一个在 Linux 和 Unix 系统上广泛使用的文本处理工具。它允许用户通过脚本或命令行对文本进行基本的编辑和转换。sed 主要用于处理文本流，它可以从输入流中读取文本，对文本进行处理，并将处理后的文本送到输出流。sed 命令在文本处理和脚本编程中非常有用，可以通过组合多个命令来执行复杂的文本编辑任务。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed [选项]... <span class="string">&#x27;动作&#x27;</span> [输入文件]...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-n, --quiet, --silent</code>：禁止默认输出，只有经过处理的行才会输出。</li>
<li><code>--debug</code>：对程序运行进行标注。</li>
<li><code>-e 脚本, --expression=脚本</code>：允许多个编辑命令，添加“脚本”到程序的运行列表。</li>
<li><code>-f 脚本文件, --file=脚本文件</code>：添加“脚本文件”到程序的运行列表。</li>
<li><code>--follow-symlinks</code>：直接修改文件时跟随软链接。</li>
<li><code>-i[扩展名], --in-place[=扩展名]</code>：直接修改文件内容，而不是输出到标准输出（如果指定扩展名则备份文件）。</li>
<li><code>-l N, --line-length=N</code>：指定 <code>l</code> 命令的换行期望长度。</li>
<li><code>--posix</code>：关闭所有 GNU 扩展。</li>
<li><code>-E, -r, --regexp-extended</code>：在脚本中使用扩展正则表达式（为保证可移植性使用 <code>POSIX -E</code>）。</li>
<li><code>-s, --separate</code>：将输入文件视为各个独立的文件而不是单个长的连续输入流。</li>
<li><code>--sandbox</code>：在沙盒模式中进行操作（禁用 e&#x2F;r&#x2F;w 命令）。</li>
<li><code>-u, --unbuffered</code>：从输入文件读取最少的数据，更频繁的刷新输出。</li>
<li><code>-z, --null-data</code>：使用 NUL 字符分隔各行。</li>
<li><code>--help</code>：打印帮助并退出。</li>
<li><code>--version</code>：输出版本信息并退出。</li>
</ul>
<p>动作通常以单引号括起来，其中包含一个或多个 <code>sed</code> 命令，如替换、删除、添加等。</p>
<ul>
<li><code>a</code>：新增，a 的后面可以接字串，而这些字串会在新的一行出现（目前的下一行）。</li>
<li><code>c</code>：取代，c 的后面可以接字串，这些字串可以取代 <code>n1,n2</code> 之间的行。</li>
<li><code>d</code>：删除，后面通常不接任何字串。</li>
<li><code>i</code>：插入，i 的后面可以接字串，这些字串会在新的一行出现（目前的上一行）。</li>
<li><code>p</code>：打印，亦即将某个选择的数据印出。通常会与参数 <code>sed -n</code> 一起运行。</li>
<li><code>s</code>：取代，可以直接进行取代的工作，通常这个 s 的动作可以搭配正则表达式，例如 <code>1,20s/old/new/g</code>。</li>
</ul>
<h2 id="示例-68"><a href="#示例-68" class="headerlink" title="示例"></a>示例</h2><p>在文件中查找 <code>old_text</code> 并将其替换为 <code>new_text</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/old_text/new_text/&#x27;</span> filename</span><br></pre></td></tr></table></figure>



<p>删除包含指定模式（<code>pattern</code>）的行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/pattern/d&#x27;</span> filename</span><br></pre></td></tr></table></figure>



<p>只显示包含指定模式的行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;/pattern/p&#x27;</span> filename</span><br></pre></td></tr></table></figure>



<p>分别在第 3 行之前和之后添加新行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;3i\New line before the 3rd line&#x27;</span> filename</span><br><span class="line">sed <span class="string">&#x27;3a\New line after the 3rd line&#x27;</span> filename</span><br></pre></td></tr></table></figure>



<p>直接修改文件内容，而不是在标准输出中显示结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/old_text/new_text/&#x27;</span> filename</span><br></pre></td></tr></table></figure>



<p>需要注意的是，sed 不会修改原始文件，除非使用 <code>-i</code> 选项。</p>
<h1 id="Linux-head-命令-显示文件头部"><a href="#Linux-head-命令-显示文件头部" class="headerlink" title="Linux head 命令 - 显示文件头部"></a>Linux head 命令 - 显示文件头部</h1><h2 id="介绍-69"><a href="#介绍-69" class="headerlink" title="介绍"></a>介绍</h2><p><strong>head</strong> 命令可用于查看文件的开头部分的内容，默认显示前 10 行的内容。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-q</code> ：隐藏文件名。</li>
<li><code>-v</code> ：显示文件名。</li>
<li><code>-c</code>, <code>--bytes=[-]NUM</code> ：显示的字节数。</li>
<li><code>-n</code>, <code>--lines=[-]NUM</code> ：显示的行数。</li>
</ul>
<h2 id="示例-69"><a href="#示例-69" class="headerlink" title="示例"></a>示例</h2><p>显示 getiot.log 文件的开头 10 行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> getiot.log</span><br></pre></td></tr></table></figure>



<p>显示 getiot.log 文件的开头 5 行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 5 getiot.log</span><br></pre></td></tr></table></figure>



<p>显示 getiot.log 文件除最后 5 行外的其他所有内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> -n -5 getiot.log</span><br></pre></td></tr></table></figure>



<p>显示 getiot.log 文件前 233 个字节：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> -c 233 getiot.log</span><br></pre></td></tr></table></figure>





<h1 id="Linux-tail-命令-显示文件尾部"><a href="#Linux-tail-命令-显示文件尾部" class="headerlink" title="Linux tail 命令 - 显示文件尾部"></a>Linux tail 命令 - 显示文件尾部</h1><h2 id="介绍-70"><a href="#介绍-70" class="headerlink" title="介绍"></a>介绍</h2><p><strong>tail</strong> 命令可用于查看文件的末尾部分的内容，默认显示后 10 行的内容。有一个常用的参数 <strong>-f</strong> 常用于查阅正在改变的日志文件。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-f</code> ：循环读取。</li>
<li><code>-q</code> ：不显示处理信息。</li>
<li><code>-v</code> ：显示详细的处理信息。</li>
<li><code>-c</code>, <code>--bytes=[+]NUM</code> ：显示的字节数。</li>
<li><code>-n</code>, <code>--lines=[+]NUM</code> ：显示文件的尾部 n 行内容。</li>
<li><code>--pid=PID</code> ：与 <code>-f</code> 合用，表示在进程 ID、PID 死掉之后结束。</li>
<li><code>-q</code>, <code>--quiet</code>, <code>--silent</code> ：从不输出给出文件名的首部。</li>
<li><code>-s</code>, <code>--sleep-interval=S</code> ：与 <code>-f</code> 合用，表示在每次反复的间隔休眠S秒。</li>
</ul>
<h2 id="示例-70"><a href="#示例-70" class="headerlink" title="示例"></a>示例</h2><p>显示 getiot.log 文件的最后 10 行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail getiot.log</span><br></pre></td></tr></table></figure>



<p>跟踪名为 getiot.log 的文件的增长情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f getiot.log</span><br></pre></td></tr></table></figure>



<p>此命令显示 getiot.log 文件的最后 10 行。当将某些行添加至 getiot.log 文件时，tail 命令会继续显示这些行。 显示一直继续，直到您按下（Ctrl-C）组合键停止显示。</p>
<p>显示文件 getiot.log 的内容，从第 20 行至文件末尾：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -n +20 notes.log</span><br></pre></td></tr></table></figure>



<p>显示文件 getiot.log 的最后 5 个字符：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -c 5 notes.log</span><br></pre></td></tr></table></figure>





<h1 id="Linux-tar-命令-压缩或解压缩文件"><a href="#Linux-tar-命令-压缩或解压缩文件" class="headerlink" title="Linux tar 命令 - 压缩或解压缩文件"></a>Linux tar 命令 - 压缩或解压缩文件</h1><h2 id="介绍-71"><a href="#介绍-71" class="headerlink" title="介绍"></a>介绍</h2><p><strong>tar</strong>（英文全拼：tape archive）命令用于在磁带、或者磁盘上创建和提取归档文件。</p>
<p>tar 命令默认只是把多个文件打包放到一起，并不会对文件进行压缩，如果想要进行压缩或解压缩操作，则需要使用对应的选项参数。</p>
<p><strong>语法</strong>：</p>
<p>tar 命令的用法有三种风格</p>
<ul>
<li><p>传统风格</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar &#123;A|c|d|r|t|u|x&#125;[GnSkUWOmpsMBiajJzZhPlRvwo] [ARG...]</span><br></pre></td></tr></table></figure>


</li>
<li><p>UNIX 风格</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -A [OPTIONS] ARCHIVE ARCHIVE</span><br><span class="line">tar -c [-f ARCHIVE] [OPTIONS] [FILE...]</span><br><span class="line">tar -d [-f ARCHIVE] [OPTIONS] [FILE...]</span><br><span class="line">tar -t [-f ARCHIVE] [OPTIONS] [MEMBER...]</span><br><span class="line">tar -r [-f ARCHIVE] [OPTIONS] [FILE...]</span><br><span class="line">tar -u [-f ARCHIVE] [OPTIONS] [FILE...]</span><br><span class="line">tar -x [-f ARCHIVE] [OPTIONS] [MEMBER...]</span><br></pre></td></tr></table></figure>


</li>
<li><p>GNU 风格</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar &#123;--catenate|--concatenate&#125; [OPTIONS] ARCHIVE ARCHIVE</span><br><span class="line">tar --create [--file ARCHIVE] [OPTIONS] [FILE...]</span><br><span class="line">tar &#123;--diff|--compare&#125; [--file ARCHIVE] [OPTIONS] [FILE...]</span><br><span class="line">tar --del--extractete [--file ARCHIVE] [OPTIONS] [MEMBER...]</span><br><span class="line">tar --append [-f ARCHIVE] [OPTIONS] [FILE...]</span><br><span class="line">tar --list [-f ARCHIVE] [OPTIONS] [MEMBER...]</span><br><span class="line">tar --test-label [--file ARCHIVE] [OPTIONS] [LABEL...]</span><br><span class="line">tar --update [--file ARCHIVE] [OPTIONS] [FILE...]</span><br><span class="line">tar --update [-f ARCHIVE] [OPTIONS] [FILE...]</span><br><span class="line">tar &#123;--extract|--get&#125; [-f ARCHIVE] [OPTIONS] [MEMBER...]</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>选项</strong>：</p>
<ul>
<li><code>-A</code>, <code>--catenate</code> ：将新增的归档文件附加到已存在的另一个归档文件。</li>
<li><code>-c</code>, <code>--create</code> ：建立新的归档文件。</li>
<li><code>-d</code>, <code>--diff</code> ：对比归档文件内和文件系统上的文件的差异。</li>
<li><code>-k</code>, <code>--keep-old-files</code> ：解压时不替换存在的文件，而将其认为是错误。</li>
<li><code>-m</code>, <code>--touch</code> ：不要解压文件的修改时间。</li>
<li><code>-r</code>, <code>--append</code> ：将新增文件附加到已存在的归档文件的结尾。</li>
<li><code>-S</code>, <code>--sparse</code> ：高效处理离散文件。</li>
<li><code>-t</code>, <code>--list</code> ：列出归档文件的内容。</li>
<li><code>-u</code>, <code>--update</code> ：仅置换较归档文件内的文件更新的文件。</li>
<li><code>-x</code>, <code>--extract</code>, <code>--get</code> ：从归档文件中提取文件。</li>
<li><code>-f &lt;ARCHIVE&gt;</code> ：指定归档文件。</li>
<li><code>-j</code>, <code>--bzip2</code> ：通过 bzip2 命令处理归档文件。</li>
<li><code>-J</code>, <code>--xz</code> ：通过 xz 命令处理归档文件。</li>
<li><code>-z</code>, <code>--gzip</code>, <code>--gunzip</code>, <code>--ungzip</code> ：通过 gzip 命令处理归档文件。</li>
<li><code>-Z</code>, <code>--compress</code>, <code>--uncompress</code> ：通过 compress 命令处理归档文件。</li>
<li><code>-v</code>, <code>--verbose</code> ：显示命令执行过程。</li>
<li><code>--exclude=PATTERN</code> ：排除 PATTERN 匹配的所有文件。</li>
</ul>
<h2 id="示例-71"><a href="#示例-71" class="headerlink" title="示例"></a>示例</h2><p>使用 gzip 格式压缩文件（将 hello.c 和 world.c 压缩为 getiot.tar.gz）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> hello.c world.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar zcvf getiot.tar.gz hello.c world.c</span> </span><br><span class="line">hello.c</span><br><span class="line">world.c</span><br></pre></td></tr></table></figure>



<p>列出压缩文件内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar ztvf getiot.tar.gz</span> </span><br><span class="line">-rw-rw-r-- rudy/rudy         0 2021-05-25 23:56 hello.c</span><br><span class="line">-rw-rw-r-- rudy/rudy         0 2021-05-25 23:56 world.c</span><br></pre></td></tr></table></figure>



<p>解压文件（解压到 &#x2F;tmp 目录）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar zxvf getiot.tar.gz -C /tmp</span></span><br><span class="line">hello.c</span><br><span class="line">world.c</span><br></pre></td></tr></table></figure>



<p>压缩当前目录下的所有文件（排除 .git 目录）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar jcvf getiot.tar.bz2 --exclude=.git ./*</span><br></pre></td></tr></table></figure>





<h1 id="Linux-xz-命令-压缩或解压缩文件"><a href="#Linux-xz-命令-压缩或解压缩文件" class="headerlink" title="Linux xz 命令 - 压缩或解压缩文件"></a>Linux xz 命令 - 压缩或解压缩文件</h1><h2 id="介绍-72"><a href="#介绍-72" class="headerlink" title="介绍"></a>介绍</h2><p><strong>xz</strong> 命令是为 POSIX 平台开发具有高压缩率的工具。它使用 LZMA2 压缩算法，生成的压缩文件比 POSIX 平台传统使用的 gzip、bzip2 生成的压缩文件更小，而且解压缩速度也很快。</p>
<p>最初 XZ Utils 的是基于 LZMA-SDK 开发，但是 LZMA-SDK 包含了一些 Windows 平台的特性，而 XZ Utils 为适应 POSIX 平台作了大幅的修改。XZ Utils 的出现也是为了取代 POSIX 系统中旧的 LZMA Utils。</p>
<p>xz 命令由 XZ Utils 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install xz-utils</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xz [option...]  [file...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-z, --compress</code>：强制压缩。</li>
<li><code>-d, --decompress</code>：强制解压缩。</li>
<li><code>-t, --test</code>：测试压缩文件完整性。</li>
<li><code>-l, --list</code>：列出 .xz 文件的信息。</li>
<li><code>-k, --keep</code>：保留（不要删除）输入文件。</li>
<li><code>-f, --force</code>：强制覆写输出文件和（解）压缩链接。</li>
<li><code>-c, --stdout</code>：向标准输出写入，同时不要删除输入文件。</li>
<li><code>-0 ... -9</code>：压缩预设等级；默认为 6；使用 7-9 的等级之前，请先考虑压缩和解压缩所需的内存用量！（会占用大量内存空间）</li>
<li><code>-e, --extreme</code>：尝试使用更多 CPU 时间来改进压缩比率；不会影响解压缩的内存需求量。</li>
<li><code>-T, --threads=数量</code>：使用最多指定数量的线程；默认值为 1；设置为 0 可以使用与处理器内核数量相同的线程数。</li>
<li><code>-q, --quiet</code>：不显示警告信息；指定两次可不显示错误信息。</li>
<li><code>-v, --verbose</code>：输出详细信息；指定两次可以输出更详细的信息。</li>
<li><code>-h, --help</code>：显示本短帮助信息并退出。</li>
<li><code>-H, --long-help</code>：显示长帮助信息（同时列出高级选项）。</li>
<li><code>-V, --version</code>：显示软件版本号并退出。</li>
</ul>
<h2 id="示例-72"><a href="#示例-72" class="headerlink" title="示例"></a>示例</h2><p>压缩一个文件 hello.txt，压缩成功后生成 hello.txt.xz：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xz hello.txt</span><br></pre></td></tr></table></figure>



<p>解压 hello.txt.xz 文件，并保持原文件不被删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xz -d -k hello.txt.xz</span><br></pre></td></tr></table></figure>



<p>注意</p>
<p>xz 在压缩和解压的时候，默认都会将原文件删除，如果不希望删除原文件，请使用 <code>-k</code> 选项。</p>
<p>查看 .xz 文件的基本信息（包括压缩率、校验方式等），可与 <code>-v</code> 或 <code>-vv</code> 选项配合显示更详尽的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xz -l  hello.txt.xz</span><br><span class="line">Strms  Blocks   Compressed Uncompressed  Ratio  Check   Filename</span><br><span class="line">    1       1        856 B      5,913 B  0.145  CRC64   hello.txt.xz</span><br></pre></td></tr></table></figure>



<p>使用参数 -0, -1, -2, … -6, … -9 或参数 <code>--fast</code>, <code>--best</code> 设定压缩率：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xz -k7 hello.txt</span><br><span class="line">$ xz -k --fast hello.txt</span><br></pre></td></tr></table></figure>



<p>再次查看 hello.txt.xz 文件基本信息，可以发现压缩大小和压缩比例和之前不一样了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xz -l hello.txt.xz </span><br><span class="line">Strms  Blocks   Compressed Uncompressed  Ratio  Check   Filename</span><br><span class="line">    1       1        896 B      5,913 B  0.152  CRC64   hello.txt.xz</span><br></pre></td></tr></table></figure>



<p>提示</p>
<p>xz 命令的默认的压缩率预设值为 -6 ，对于大多数系统来说，甚至是一些较旧的系统，-4 … -6 压缩率预设值都不错的表现。</p>
<p>借助 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/xargs/"><code>xargs</code></a> 命令并行压缩多文件，例如将 &#x2F;var&#x2F;log 目录下所有的扩展名为 .log 的文件压缩在一起：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /var/log -<span class="built_in">type</span> f -iname <span class="string">&quot;*.log&quot;</span> -print0 | xargs -P4 -n16 xz -T1</span><br></pre></td></tr></table></figure>





<h1 id="Linux-mc-命令-字符界面文件管理器"><a href="#Linux-mc-命令-字符界面文件管理器" class="headerlink" title="Linux mc 命令 - 字符界面文件管理器"></a>Linux mc 命令 - 字符界面文件管理器</h1><h2 id="介绍-73"><a href="#介绍-73" class="headerlink" title="介绍"></a>介绍</h2><p><strong>mc</strong>（英文全拼：Midnight Commander）是一个基于字符的目录浏览器和文件管理器。</p>
<p>在 Linux 的世界中，使用图形文件管理器可以轻松完成许多常见的文件操作，但命令行工具通常有更多额外功能和灵活性，而 mc 则将图形文件管理器和命令行工具这两个世界联系在一起了。</p>
<p>mc 的设计基于文件管理器的一个普遍概念 —— 双目录窗口，同时显示两个目录的列表，用于显示文件&#x2F;目录移动或复制等操作的源（source）和目标（destination）。执行 mc 之后，将会看到菜单式的文件管理程序，共分成 5 个部分。</p>
<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/midnight-commander-screen-layout.png" alt="img"></p>
<ol>
<li><strong>左右目录面板</strong> —— 屏幕中央是两个大的目录面板，在任何时刻都会有其中之一（称为“当前面板”）处于活动状态，按 Tab 键可切换当前面板。</li>
<li><strong>功能键标签</strong> —— 最下面一栏包含最常用的功能快捷键，使用功能键（F1 到 F10）进行选择，从左到右依次是：帮助、目录、显示、编辑、复制、更名或移动、新建目录、删除、菜单、退出。</li>
<li><strong>菜单栏</strong> —— 最上面一栏包含一组下拉菜单的菜单栏，可通过功能键 F9 激活菜单栏。</li>
<li><strong>命令行</strong> —— 在功能键标签栏上方有一个 shell 提示符，可以按常规方式输入命令。一个特别有用的命令是 <code>cd</code>，后面加目录路径名，便可切换当前面板中显示的目录。</li>
<li><strong>迷你状态行</strong> —— 在目录面板最底部，命令行上方，是迷你状态行，该区域用于显示有关当前所选项目的补充信息，例如符号链接的目标。</li>
</ol>
<p>概括来说，mc 是一个强大的工具，并拥有广泛的功能，包括：</p>
<ul>
<li>涵盖所有常见的文件和目录操作，例如复制、移动、重命名、链接和删除；</li>
<li>允许操纵文件和目录权限；</li>
<li>可以将远程系统（通过 FTP 或 SSH）视为本地目录；</li>
<li>可以将存档文件（例如 .tar 和 .zip）视为本地目录；</li>
<li>允许创建用户自定义的常用目录“hotlist”；</li>
<li>可以根据文件名或文件内容搜索文件，并将搜索结果视为目录。</li>
</ul>
<p>mc 项目网址：<a target="_blank" rel="noopener" href="https://midnight-commander.org/">https://midnight-commander.org</a></p>
<h2 id="示例-73"><a href="#示例-73" class="headerlink" title="示例"></a>示例</h2><h3 id="切换列表显示格式"><a href="#切换列表显示格式" class="headerlink" title="切换列表显示格式"></a>切换列表显示格式</h3><p>循环按 <code>Alt + t</code> 可以切换当前面板的显示格式，比如输出 <code>ls -l</code> 的效果。另外，按 <code>Ctrl + x</code> 再按 <code>i</code>，可在另一个面板显示当前面板选中项的详细信息，再次按 <code>Ctrl + x</code> 再按 <code>i</code> 即可关闭。</p>
<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/midnight-commander-information-mode.png" alt="img"></p>
<h3 id="设置另一个面板的目录"><a href="#设置另一个面板的目录" class="headerlink" title="设置另一个面板的目录"></a>设置另一个面板的目录</h3><p>可以通过当前面板设置另一个面板的显示目录，例如移动光标到某一目录，按 <code>Alt + o</code> 将会在另一个面板中显示该目录下的子目录和文件，按 <code>Alt + i</code> 则将另一个面板显示与当前面板相同的目录。</p>
<h1 id="Linux-zip-命令-压缩文件为-zip-格式"><a href="#Linux-zip-命令-压缩文件为-zip-格式" class="headerlink" title="Linux zip 命令 - 压缩文件为 zip 格式"></a>Linux zip 命令 - 压缩文件为 zip 格式</h1><h2 id="介绍-74"><a href="#介绍-74" class="headerlink" title="介绍"></a>介绍</h2><p><strong>zip</strong> 命令用于打包和压缩文件，压缩后的文件后缀名为 .zip。</p>
<p>zip 命令可以将一个或多个压缩文件与有关文件的信息（名称、路径、日期、上次修改的时间、保护和检查信息以验证文件完整性）一起放入一个压缩存档中。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip [-options] [-b path] [-t mmddyyyy] [-n suffixes] [zipfile list] [-xi list]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-q</code> ：不显示指令执行过程。</li>
<li><code>-r</code> ：递归处理，将指定目录下的所有文件和子目录一并处理。</li>
<li><code>-z</code>, <code>--archive-comment</code> ：替压缩文件加上注释。</li>
<li><code>-v</code>, <code>--verbose</code> ：显示指令执行过程。</li>
<li><code>-n</code>, <code>--suffixes &lt;suffixes&gt;</code> ：不压缩具有特定字尾字符串的文件。</li>
<li><code>-sf</code>, <code>--show-files</code> ：显示压缩包中的文件。</li>
</ul>
<h2 id="示例-74"><a href="#示例-74" class="headerlink" title="示例"></a>示例</h2><p>假设当前目录下有一个 test 目录，里面有两个文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span>/</span><br><span class="line">├── hello.c</span><br><span class="line">└── world.c</span><br></pre></td></tr></table></figure>



<p>将 test 目录下所有文件（和文件夹）打包为当前目录下的 test.zip：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ zip -q -r test.zip <span class="built_in">test</span></span><br></pre></td></tr></table></figure>



<p>不解压直接查看压缩包中的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ zip -sf test.zip </span><br><span class="line">Archive contains:</span><br><span class="line">  <span class="built_in">test</span>/</span><br><span class="line">  <span class="built_in">test</span>/world.c</span><br><span class="line">  <span class="built_in">test</span>/hello.c</span><br><span class="line">Total 3 entries (12 bytes)</span><br></pre></td></tr></table></figure>





<h1 id="Linux-unzip-命令-解压缩-zip-文件"><a href="#Linux-unzip-命令-解压缩-zip-文件" class="headerlink" title="Linux unzip 命令 - 解压缩 zip 文件"></a>Linux unzip 命令 - 解压缩 zip 文件</h1><h2 id="介绍-75"><a href="#介绍-75" class="headerlink" title="介绍"></a>介绍</h2><p><strong>unzip</strong> 命令用于列出、测试和提取 zip 格式存档中的文件。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip [-Z] [-opts[modifiers]] file[.zip] [list] [-x xlist] [-d exdir]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-l</code> ：显示压缩文件内所包含的文件。</li>
<li><code>-c</code> ：将解压缩的结果显示到屏幕上，并对字符做适当的转换。</li>
<li><code>-n</code> ：解压缩时不要覆盖原有的文件。</li>
<li><code>-j</code> ：不处理压缩文件中原有的目录路径。</li>
<li><code>-v</code> ：显示压缩文件的详细信息和诊断信息。</li>
<li><code>-d exdir</code> ：指定解压目录。</li>
</ul>
<h2 id="示例-75"><a href="#示例-75" class="headerlink" title="示例"></a>示例</h2><p>将 test.zip 解压缩到当前目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip test.zip</span></span><br></pre></td></tr></table></figure>



<p>将 test.zip 解压缩到当前目录的 tmp 目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip test.zip -d tmp</span></span><br></pre></td></tr></table></figure>



<p>列出压缩文件 test.zip 中的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip -l test.zip</span> </span><br><span class="line">Archive:  test.zip</span><br><span class="line">  Length      Date    Time    Name</span><br><span class="line">---------  ---------- -----   ----</span><br><span class="line">        0  2021-06-06 00:38   test/</span><br><span class="line">        6  2021-06-06 00:38   test/world.c</span><br><span class="line">        6  2021-06-06 00:38   test/hello.c</span><br><span class="line">---------                     -------</span><br><span class="line">       12                     3 files</span><br></pre></td></tr></table></figure>



<p>列出压缩文件 test.zip 的详细信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip -v test.zip</span> </span><br><span class="line">Archive:  test.zip</span><br><span class="line"> Length   Method    Size  Cmpr    Date    Time   CRC-32   Name</span><br><span class="line">--------  ------  ------- ---- ---------- ----- --------  ----</span><br><span class="line">       0  Stored        0   0% 2021-06-06 00:38 00000000  test/</span><br><span class="line">       6  Stored        6   0% 2021-06-06 00:38 363a3020  test/world.c</span><br><span class="line">       6  Stored        6   0% 2021-06-06 00:38 363a3020  test/hello.c</span><br><span class="line">--------          -------  ---                            -------</span><br><span class="line">      12               12   0%                            3 files</span><br></pre></td></tr></table></figure>



<p>验证压缩文件 test.zip 的完整性：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip -t test.zip</span> </span><br><span class="line">Archive:  test.zip</span><br><span class="line">    testing: test/                    OK</span><br><span class="line">    testing: test/world.c             OK</span><br><span class="line">    testing: test/hello.c             OK</span><br><span class="line">No errors detected in compressed data of test.zip.</span><br></pre></td></tr></table></figure>





<h1 id="Linux-chattr-命令-改变文件属性"><a href="#Linux-chattr-命令-改变文件属性" class="headerlink" title="Linux chattr 命令 - 改变文件属性"></a>Linux chattr 命令 - 改变文件属性</h1><h2 id="介绍-76"><a href="#介绍-76" class="headerlink" title="介绍"></a>介绍</h2><p><strong>chattr</strong>（英文全拼：change file attributes）命令用于修改 Linux 文件系统中的文件属性。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chattr [ -RVf ] [ -v version ] [ -p project ] [ mode ] files...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-R</code> ：递归处理目录下的所有文件。</li>
<li><code>-V</code> ：显示指令执行过程。</li>
<li><code>-f</code> ：禁止显示大多数错误消息。</li>
<li><code>-v version</code> ：设置文件的版本&#x2F;代号。</li>
<li><code>-p project</code> ：设置文件的项目编号。</li>
<li><code>+&lt;属性&gt;</code>：开启文件或目录的该项属性。</li>
<li><code>-&lt;属性&gt;</code>：关闭文件或目录的该项属性。</li>
<li><code>=&lt;属性&gt;</code>：指定文件或目录的该项属性。</li>
</ul>
<p><strong>模式</strong>：</p>
<p>通用格式为：<code>+-=[aAcCdDeijsStTu]</code>，其中 <code>aAcCdDeijsStTu</code> 表示可以赋予文件的新属性，说明如下。</p>
<ul>
<li><code>a</code>：让文件或目录仅供附加用途。</li>
<li><code>A</code>：当一个具有 <code>A</code> 属性的文件被访问时，它的 atime 记录不会被修改。</li>
<li><code>c</code>：将文件或目录压缩后存放。</li>
<li><code>d</code>：将文件或目录排除在倾倒操作之外。</li>
<li><code>i</code>：不得任意更动文件或目录。</li>
<li><code>j</code>：如果文件系统安装有 <code>data=order</code> 或 <code>data=writeback</code> 选项，则具有 <code>j</code> 属性的文件在写入文件本身之前将其所有数据写入 ext 3 日志。</li>
<li><code>s</code>：当删除具有 <code>s</code> 属性集的文件时，其块将被归零并写回磁盘。</li>
<li><code>S</code>：当修改具有 <code>S</code> 属性集的文件时，更改将同步写入磁盘；这相当于应用于文件子集的“同步”挂载选项。</li>
<li><code>u</code>：当删除具有 <code>u</code> 属性集的文件时，它的内容将被保存。</li>
</ul>
<h2 id="示例-76"><a href="#示例-76" class="headerlink" title="示例"></a>示例</h2><p>用 chattr 命令防止系统中某个关键文件被修改（加锁）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chattr +i /opt/test.txt</span><br></pre></td></tr></table></figure>



<p>然后试一下 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/rm/">rm</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/mv/">mv</a>、rename 等命令操作于该文件，都是得到 “Operation not permitted” 的结果。</p>
<p>执行下面命令可以解锁该文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chattr -i /opt/test.txt</span><br></pre></td></tr></table></figure>



<p>让某个文件只能往里面追加内容，不能删除，一些日志文件适用于这种操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chattr +a /data/user_act.log</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ln-命令-创建文件链接"><a href="#Linux-ln-命令-创建文件链接" class="headerlink" title="Linux ln 命令 - 创建文件链接"></a>Linux ln 命令 - 创建文件链接</h1><h2 id="介绍-77"><a href="#介绍-77" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ln</strong>（英文全拼：link）命令是 Linux 系统中非常重要的命令，它的作用是为某一个文件在另一个位置建立一个同步的链接。</p>
<p>Linux 文件系统中的链接（link）可分为两种 —— 硬链接（hard link）与软链接&#x2F;符号链接（symbolic link）。软链接类似于 Windows 系统中的快捷方式。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> [OPTION]... [-T] TARGET LINK_NAME</span><br><span class="line"><span class="built_in">ln</span> [OPTION]... TARGET</span><br><span class="line"><span class="built_in">ln</span> [OPTION]... TARGET... DIRECTORY</span><br><span class="line"><span class="built_in">ln</span> [OPTION]... -t DIRECTORY TARGET...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>--backup[=CONTROL]</code> ：为每个已存在的目标文件创建备份文件。</li>
<li><code>-b</code> ：类似 –backup，但不接受任何参数。</li>
<li><code>-d</code>, <code>-F</code>, <code>--directory</code> ：允许超级用户尝试创建指向目录的硬链接（注意：此操作可能因系统限制而失败）。</li>
<li><code>-f</code>, <code>--force</code> ：强行删除任何已存在的目标文件。</li>
<li><code>-i</code>, <code>--interactive</code> ：删除目标文件前进行确认。</li>
<li><code>-L</code>, <code>--logical</code> ：如目标为符号链接，本次创建链接时将其解引用。</li>
<li><code>-n</code>, <code>--no-dereference</code> ：如果给定链接名是一个链接至某目录的符号链接，将其作为普通文件处理。</li>
<li><code>-P</code>, <code>--physical</code> ：创建直接指向符号链接文件的硬链接。</li>
<li><code>-r</code>, <code>--relative</code> ：创建相对于链接位置的符号链接。</li>
<li><code>-s</code>, <code>--symbolic</code> ：创建符号链接而非硬链接。</li>
<li><code>-S</code>, <code>--suffix=后缀</code> ：自行指定备份文件的后缀。</li>
<li><code>-t</code>, <code>--target-directory=目录</code> ：在指定目录中创建链接。</li>
<li><code>-T</code>, <code>--no-target-directory</code> ：总是将给定的链接名当作普通文件。</li>
<li><code>-v</code>, <code>--verbose</code> ：列出每个链接的文件名称。</li>
<li><code>--help</code> ：显示此帮助信息并退出。</li>
<li><code>--version</code> ：显示版本信息并退出。</li>
</ul>
<h2 id="示例-77"><a href="#示例-77" class="headerlink" title="示例"></a>示例</h2><p>假设当前目录下有一个 libldal.so.1.0.0 共享库文件，可以通过如下命令创建软链接 libldal.so.1 和 libldal.so：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s libldal.so.1.0.0 libldal.so.1</span><br><span class="line"><span class="built_in">ln</span> -s libldal.so.1 libldal.so</span><br></pre></td></tr></table></figure>



<p>创建软链接后的文件情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lrwxrwxrwx 1 root root     12 Sep  2 16:15 libldal.so -&gt; libldal.so.1</span><br><span class="line">lrwxrwxrwx 1 root root     16 Sep  2 16:14 libldal.so.1 -&gt; libldal.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root 278416 Sep  2 16:12 libldal.so.1.0.0</span><br></pre></td></tr></table></figure>





<h1 id="Linux-locate-命令-快速查找文件"><a href="#Linux-locate-命令-快速查找文件" class="headerlink" title="Linux locate 命令 - 快速查找文件"></a>Linux locate 命令 - 快速查找文件</h1><h2 id="介绍-78"><a href="#介绍-78" class="headerlink" title="介绍"></a>介绍</h2><p><strong>locate</strong> 命令用于在 Linux 系统中查找符合条件的文档，作用类似于 find 命令。不过，locate 命令会去保存文档和目录名称的数据库内，查找合乎范本样式条件的文档或目录。一般情况，我们只需要输入 <code>locate &lt;filename&gt;</code> 即可查找指定文件。</p>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/which/">which</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/whereis/">whereis</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/find/">find</a></p>
<p><strong>安装</strong>：</p>
<p>locate 命令由 mlocate 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install mlocate</span><br></pre></td></tr></table></figure>



<p>在安装 mlocate 软件包期间，Linux 系统将创建一个 cron 作业，该作业每24小时运行一次 <code>updatedb</code> 命令，这样可以确保数据库得到定期更新。有关 cron 作业的更多信息，请检查 <code>/etc/cron.daily/mlocate</code> 文件。</p>
<p>如果需要手动更新数据库，可以通过 root 或具有 sudo 特权的用户身份运行 <code>updatedb</code> 命令。更新过程将花费一些时间，具体取决于文件和目录的数量以及系统的速度。</p>
<p>与功能强大的 <code>find</code> 命令相比，<code>locate</code> 命令的运行速度更快，使用方法更简单。但它缺少许多高级功能，只能按文件名进行搜索。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locate [-d  path | --database=path] [-e | -E | --[non-]existing] [-i |</span><br><span class="line">       --ignore-case] [-0 | --null] [-c | --count] [-w |  --wholename]  [-b  |</span><br><span class="line">       --<span class="built_in">basename</span>]  [-l  N  |  --<span class="built_in">limit</span>=N]  [-S | --statistics] [-r | --regex ]</span><br><span class="line">       [--regextype R] [--max-database-age D] [-P | -H  |  --nofollow]  [-L  |</span><br><span class="line">       --follow] [--version] [-A | --all] [-p | --<span class="built_in">print</span>] [--<span class="built_in">help</span>] pattern...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-b</code>, <code>--basename</code>：仅匹配路径名的基本名称。</li>
<li><code>-c</code>, <code>--count</code>：只输出找到的数量。</li>
<li><code>-d</code>, <code>--database DBPATH</code>：使用 DBPATH 指定的数据库，而不是默认数据库 &#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db。</li>
<li><code>-e</code>, <code>--existing</code>：仅打印当前现有文件的条目。</li>
<li><code>-1</code>：如果是 1，则启动安全模式。在安全模式下，使用者不会看到权限无法看到的档案。这会使速度减慢，因为 locate 必须到实际的档案系统中取得档案的权限资料。</li>
<li><code>-0</code>, <code>--null</code>：在输出上带有 NUL 的单独条目。</li>
<li><code>-S</code>, <code>--statistics</code>：不搜索条目，打印有关每个数据库的统计信息。</li>
<li><code>-q</code>：安静模式，不会显示任何错误讯息。</li>
<li><code>-P</code>, <code>--nofollow</code>, <code>-H</code>：检查文件存在时不要遵循尾随的符号链接。</li>
<li><code>-l</code>, <code>--limit</code>, <code>-n LIMIT</code>：将输出（或计数）限制为 LIMIT 个条目。</li>
<li><code>-n</code>：至多显示 n 个输出。</li>
<li><code>-m</code>, <code>--mmap</code>：被忽略，为了向后兼容。</li>
<li><code>-r</code>, <code>--regexp REGEXP</code>：使用基本正则表达式。</li>
<li><code>--regex</code>：使用扩展正则表达式。</li>
<li><code>-q</code>, <code>--quiet</code>：安静模式，不会显示任何错误讯息。</li>
<li><code>-s</code>, <code>--stdio</code>：被忽略，为了向后兼容。</li>
<li><code>-o</code>：指定资料库存的名称。</li>
<li><code>-h</code>, <code>--help</code>：显示帮助。</li>
<li><code>-i</code>, <code>--ignore-case</code>：忽略大小写。</li>
<li><code>-V</code>, <code>--version</code>：显示版本信息。</li>
</ul>
<h2 id="示例-78"><a href="#示例-78" class="headerlink" title="示例"></a>示例</h2><p>查找 passwd 文件，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locate passwd</span><br></pre></td></tr></table></figure>



<p>搜索 etc 目录下所有以 sh 开头的文件 ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locate /etc/sh</span><br></pre></td></tr></table></figure>



<p>忽略大小写搜索当前用户目录下所有以 r 开头的文件 ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locate -i ~/r</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ls-命令-列出目录内容"><a href="#Linux-ls-命令-列出目录内容" class="headerlink" title="Linux ls 命令 - 列出目录内容"></a>Linux ls 命令 - 列出目录内容</h1><h2 id="介绍-79"><a href="#介绍-79" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ls</strong>（英文全拼：list files）命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)，在 Linux 中是使用率较高的命令。ls 命令的输出信息可以进行彩色加亮显示，以分区不同类型的文件。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> [选项] &lt;参数&gt;</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>：显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）；</li>
<li><code>-A</code>：显示除影藏文件“.”和“..”以外的所有文件列表；</li>
<li><code>-C</code>：多列显示输出结果。这是默认选项；</li>
<li><code>-l</code>：与“-C”选项功能相反，所有输出信息用单列格式输出，不输出为多列；</li>
<li><code>-F</code>：在每个输出项后追加文件的类型标识符，具体含义：“<code>*</code>”表示具有可执行权限的普通文件，“<code>/</code>”表示目录，“<code>@</code>”表示符号链接，“<code>|</code>”表示命令管道 FIFO，“<code>=</code>”表示 sockets 套接字。当文件为普通文件时，不输出任何标识符；</li>
<li><code>-b</code>：将文件中的不可输出的字符以反斜线“<code>\</code>”加字符编码的方式输出；</li>
<li><code>-c</code>：与“-lt”选项连用时，按照文件状态时间排序输出目录内容，排序的依据是文件的索引节点中的ctime字段。与“-l”选项连用时，则排序的一句是文件的状态改变时间；</li>
<li><code>-d</code>：仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表；</li>
<li><code>-f</code>：此参数的效果和同时指定“aU”参数相同，并关闭“lst”参数的效果；</li>
<li><code>-i</code>：显示文件索引节点号（inode）。一个索引节点代表一个文件；</li>
<li><code>--file-type</code>：与“<code>-F</code>”选项的功能相同，但是不显示“<code>*</code>”；</li>
<li><code>-k</code>：以 KB（千字节）为单位显示文件大小；</li>
<li><code>-l</code>：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；</li>
<li><code>-m</code>：用“<code>,</code>”号区隔每个文件和目录的名称；</li>
<li><code>-n</code>：以用户识别码和群组识别码替代其名称；</li>
<li><code>-r</code>：以文件名反序排列并输出目录内容列表；</li>
<li><code>-s</code>：显示文件和目录的大小，以区块为单位；</li>
<li><code>-t</code>：用文件和目录的更改时间排序；</li>
<li><code>-L</code>：如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录；</li>
<li><code>-R</code>：递归处理，将指定目录下的所有文件及子目录一并处理；</li>
<li><code>--full-time</code>：列出完整的日期与时间；</li>
<li><code>--color[=WHEN]</code>：使用不同的颜色高亮显示不同类型的。</li>
</ul>
<p><strong>参数</strong>：指定要显示列表的目录或文件</p>
<h2 id="示例-79"><a href="#示例-79" class="headerlink" title="示例"></a>示例</h2><p>显示当前目录下非影藏文件与目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure>



<p>显示当前目录下包括影藏文件在内的所有文件列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -a</span><br></pre></td></tr></table></figure>



<p>输出长格式列表（列出文件和文件夹的详细信息）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure>



<p>显示文件的 inode 信息（索引节点（index inode 简称为“inode”）是 Linux 中一个特殊的概念，具有相同的索引节点号的两个文本本质上是同一个文件（除文件名不同外）。）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -i -l README.md SUMMARY.md</span><br></pre></td></tr></table></figure>



<p>水平输出文件列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -m</span><br></pre></td></tr></table></figure>



<p>垂直输出文件列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -1</span><br></pre></td></tr></table></figure>



<p>最近修改的文件显示在最上面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -t</span><br></pre></td></tr></table></figure>



<p>显示递归文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -R</span><br></pre></td></tr></table></figure>



<p>打印文件的 UID 和 GID</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -n</span><br></pre></td></tr></table></figure>



<p>列出可读文件和文件夹详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lh</span><br></pre></td></tr></table></figure>



<p>显示文件夹信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -ld /etc/</span><br></pre></td></tr></table></figure>



<p>按时间列出文件和文件夹详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lt</span><br></pre></td></tr></table></figure>



<p>按修改时间列出文件和文件夹详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -ltr</span><br></pre></td></tr></table></figure>



<p>按照特殊字符对文件进行分类</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -F</span><br></pre></td></tr></table></figure>



<p>列出文件并标记颜色分类</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> --color=auto</span><br></pre></td></tr></table></figure>





<h1 id="Linux-lsblk-命令-列出块设备信息"><a href="#Linux-lsblk-命令-列出块设备信息" class="headerlink" title="Linux lsblk 命令 - 列出块设备信息"></a>Linux lsblk 命令 - 列出块设备信息</h1><h2 id="介绍-80"><a href="#介绍-80" class="headerlink" title="介绍"></a>介绍</h2><p><strong>lsblk</strong>（英文全拼：list block devices）命令用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出 RAM 盘的信息。常见的块设备包括硬盘、闪存盘、CD-ROM 等等。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsblk [options] [device...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-a, --all            显示所有设备。</span><br><span class="line">-b, --bytes          以bytes方式显示设备大小。</span><br><span class="line">-d, --nodeps         不显示 slaves 或 holders。</span><br><span class="line">-D, --discard        <span class="built_in">print</span> discard capabilities。</span><br><span class="line">-e, --exclude &lt;list&gt; 排除设备 (default: RAM disks)。</span><br><span class="line">-f, --fs             显示文件系统信息。</span><br><span class="line">-h, --<span class="built_in">help</span>           显示帮助信息。</span><br><span class="line">-i, --ascii          use ascii characters only。</span><br><span class="line">-m, --perms          显示权限信息。</span><br><span class="line">-l, --list           使用列表格式显示。</span><br><span class="line">-n, --noheadings     不显示标题。</span><br><span class="line">-o, --output &lt;list&gt;  输出列。</span><br><span class="line">-P, --pairs          使用key=<span class="string">&quot;value&quot;</span>格式显示。</span><br><span class="line">-r, --raw            使用原始格式显示。</span><br><span class="line">-t, --topology       显示拓扑结构信息。</span><br></pre></td></tr></table></figure>



<h2 id="示例-80"><a href="#示例-80" class="headerlink" title="示例"></a>示例</h2><p>列出系统所有块设备（默认以树状展示）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lsblk</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">loop0    7:0    0   9.1M  1 loop /snap/canonical-livepatch/97</span><br><span class="line">...</span><br><span class="line">sda      8:0    0 931.5G  0 disk</span><br><span class="line">├─sda1   8:1    0 930.9G  0 part</span><br><span class="line">└─sda2   8:2    0   642M  0 part</span><br><span class="line">sdb      8:16   0   944G  0 disk</span><br><span class="line">├─sdb1   8:17   0 190.8G  0 part /</span><br><span class="line">├─sdb2   8:18   0     1K  0 part</span><br><span class="line">├─sdb5   8:21   0  15.7G  0 part [SWAP]</span><br><span class="line">└─sdb6   8:22   0 737.6G  0 part /home</span><br><span class="line">sdc      8:32   1  29.7G  0 disk</span><br><span class="line">├─sdc1   8:33   1  1023M  0 part</span><br><span class="line">└─sdc2   8:34   1  28.7G  0 part</span><br></pre></td></tr></table></figure>



<p>指定块设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lsblk /dev/sdc</span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sdc      8:32   1 29.7G  0 disk</span><br><span class="line">├─sdc1   8:33   1 1023M  0 part</span><br><span class="line">└─sdc2   8:34   1 28.7G  0 part</span><br></pre></td></tr></table></figure>



<p>七个栏目说明如下：</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>NAME</code></td>
<td>这是块设备名。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>MAJ:MIN</code></td>
<td>本栏显示主要和次要设备号。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>RM</code></td>
<td>本栏显示设备是否可移动设备。例如，在本例中设备 sdc 的 RM 值为1，表明它是可移动设备。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><code>SIZE</code></td>
<td>本栏列出设备的容量大小信息。例如，190.8G 表明该设备大小为 190.8GB，而 1K 表明该设备大小为 1KB。</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>RO</code></td>
<td>该项表明设备是否为只读。例如，loop0 设备的 RO 值为1，表明它是只读的。</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><code>TYPE</code></td>
<td>本栏显示块设备是否是磁盘或磁盘上的一个分区。</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><code>MOUNTPOINT</code></td>
<td>本栏指出设备挂载的挂载点。</td>
</tr>
</tbody></table>
<p>默认选项不会列出所有空设备。要查看这些空设备，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsblk -a</span><br></pre></td></tr></table></figure>



<p>lsblk命令也可以用于列出一个特定设备的拥有关系，同时也可以列出组和模式。可以通过以下命令来获取这些信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsblk -m</span><br></pre></td></tr></table></figure>



<p>该命令也可以只获取指定设备的信息。这可以通过在提供给lsblk命令的选项后指定设备名来实现。例如，你可能对了解以字节显示你的磁盘驱动器大小比较感兴趣，那么你可以通过运行以下命令来实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsblk -b /dev/sda</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"></span><br><span class="line">lsblk --bytes /dev/sda</span><br></pre></td></tr></table></figure>



<p>你也可以组合几个选项来获取指定的输出。例如，你也许想要以列表格式列出设备，而不是默认的树状格式。你可能也对移除不同栏目名称的标题感兴趣。可以将两个不同的选项组合，以获得期望的输出，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsblk -<span class="built_in">nl</span></span><br></pre></td></tr></table></figure>



<p>要获取 SCSI 设备的列表，你只能使用 -S 选项。该选项是大写字母 S，不能和 -s 选项混淆，该选项是用来以颠倒的顺序打印依赖的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsblk -S</span><br></pre></td></tr></table></figure>



<p>lsblk 列出 SCSI 设备，而 -s 是逆序选项（将设备和分区的组织关系逆转过来显示），其将给出如下输出。输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsblk -s</span><br></pre></td></tr></table></figure>



<p>列出块设备的 LABLE、UUID 等信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsblk -f</span><br></pre></td></tr></table></figure>





<h1 id="Linux-blkid-命令-显示块设备信息"><a href="#Linux-blkid-命令-显示块设备信息" class="headerlink" title="Linux blkid 命令 - 显示块设备信息"></a>Linux blkid 命令 - 显示块设备信息</h1><h2 id="介绍-81"><a href="#介绍-81" class="headerlink" title="介绍"></a>介绍</h2><p><strong>blkid</strong>（英文全称：block id）命令主要用来对系统的块设备（包括交换分区）所使用的文件系统类型、LABEL、UUID 等信息进行查询。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blkid [选项]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-g</code>, <code>--garbage-collect</code> ：收集 blkid 缓存</li>
<li><code>-o</code>, <code>--output &lt;format&gt;</code> ：指定输出格式</li>
<li><code>-s</code>, <code>--match-tag &lt;tag&gt;</code> ：显示指定 tag 的信息</li>
<li><code>-p</code>, <code>--probe</code> ：低级超级块探测（旁路缓存）</li>
<li><code>-i</code>, <code>--info</code> ：收集有关 I&#x2F;O 限制的信息</li>
</ul>
<p>注：UUID（Universally unique identifier）在 Linux 块设备中用作唯一标识符。使用如下命令也可以查看块设备的 UUID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /dev/disk/by-uuid/</span><br></pre></td></tr></table></figure>



<h2 id="示例-81"><a href="#示例-81" class="headerlink" title="示例"></a>示例</h2><p>显示指定设备 UUID</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blkid -s UUID /dev/sda5 </span><br></pre></td></tr></table></figure>



<p>显示所有设备 LABEL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blkid -s LABEL </span><br></pre></td></tr></table></figure>



<p>以列表方式查看详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blkid -o list </span><br></pre></td></tr></table></figure>



<p>显示所有设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blkid -o device </span><br></pre></td></tr></table></figure>



<p>显示所有设备文件系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blkid -s TYPE </span><br></pre></td></tr></table></figure>





<h1 id="Linux-cd-命令-切换当前目录"><a href="#Linux-cd-命令-切换当前目录" class="headerlink" title="Linux cd 命令 - 切换当前目录"></a>Linux cd 命令 - 切换当前目录</h1><h2 id="介绍-82"><a href="#介绍-82" class="headerlink" title="介绍"></a>介绍</h2><p><strong>cd</strong>（英文全拼：change directory）命令用于切换当前工作目录。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> [dirName]</span><br></pre></td></tr></table></figure>



<p><strong>参数</strong>：</p>
<ul>
<li><code>dirName</code> 可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录（也就是刚 login 时所在的目录）。</li>
<li>另外，<strong><code>~</code></strong> 也表示为 home 目录的意思， <strong><code>.</code></strong> 则是表示目前所在的目录， <strong><code>..</code></strong> 则表示目前目录位置的上一层目录。</li>
</ul>
<h2 id="示例-82"><a href="#示例-82" class="headerlink" title="示例"></a>示例</h2><p>进入 &#x2F;etc&#x2F;apache2 目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/apache2</span><br></pre></td></tr></table></figure>



<p>跳到当前用户的 home 目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br></pre></td></tr></table></figure>



<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure>



<p>返回上级目录（若当前目录为“&#x2F;“，则执行完后还在“&#x2F;“；”..”为上级目录的意思）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure>



<p>返回上两级目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../..</span><br></pre></td></tr></table></figure>



<p>返回进入此目录之前所在的目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure>



<p>把上个命令的参数作为 cd 参数使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> !$</span><br></pre></td></tr></table></figure>





<h1 id="Linux-df-命令-显示磁盘使用情况"><a href="#Linux-df-命令-显示磁盘使用情况" class="headerlink" title="Linux df 命令 - 显示磁盘使用情况"></a>Linux df 命令 - 显示磁盘使用情况</h1><h2 id="介绍-83"><a href="#介绍-83" class="headerlink" title="介绍"></a>介绍</h2><p><strong>df</strong>（英文全拼：disk free） 命令用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>



<p>选项：</p>
<ul>
<li><code>-a</code> 或 <code>--all</code>：包含全部的文件系统；</li>
<li><code>--block-size=&lt;区块大小&gt;</code>：以指定的区块大小来显示区块数目；</li>
<li><code>-h</code> 或 <code>--human-readable</code>：以可读性较高的方式来显示信息；</li>
<li><code>-H</code> 或 <code>--si</code>：与-h参数相同，但在计算时是以 1000 Bytes 为换算单位而非 1024 Bytes；</li>
<li><code>-i</code> 或 <code>--inodes</code>：显示 inode 的信息；</li>
<li><code>-k</code> 或 <code>--kilobytes</code>：指定区块大小为 1024 字节；</li>
<li><code>-l</code> 或 <code>--local</code>：仅显示本地端的文件系统；</li>
<li><code>-m</code> 或 <code>--megabytes</code>：指定区块大小为 1048576 字节；</li>
<li><code>--no-sync</code>：在取得磁盘使用信息前，不要执行 sync 指令，此为预设值；</li>
<li><code>-P</code> 或 <code>--portability</code>：使用 POSIX 的输出格式；</li>
<li><code>--sync</code>：在取得磁盘使用信息前，先执行sync指令；</li>
<li><code>-t &lt;文件系统类型&gt;</code> 或 <code>--type=&lt;文件系统类型&gt;</code>：仅显示指定文件系统类型的磁盘信息；</li>
<li><code>-T</code> 或 <code>--print-type</code>：显示文件系统的类型；</li>
<li><code>-x &lt;文件系统类型&gt;</code> 或 <code>--exclude-type=&lt;文件系统类型&gt;</code>：不要显示指定文件系统类型的磁盘信息；</li>
<li><code>--help</code>：显示帮助；</li>
<li><code>--version</code>：显示版本信息。</li>
</ul>
<h2 id="示例-83"><a href="#示例-83" class="headerlink" title="示例"></a>示例</h2><p>显示文件系统的磁盘使用情况统计</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">df</span> </span><br><span class="line">Filesystem     1K-blocks    Used     Available Use% Mounted on </span><br><span class="line">udev             3914416         0   3914416    0%   /dev</span><br><span class="line">tmpfs             788796      1956    786840    1%   /run</span><br><span class="line">/dev/sdb1      195811956  96620276  89175324   53%   /</span><br><span class="line">tmpfs            3943968    303828   3640140    8%   /dev/shm</span><br><span class="line">tmpfs               5120         4      5116    1%   /run/lock</span><br></pre></td></tr></table></figure>



<p>第1列指定文件系统的名称，第2列指定一个特定的文件系统1K-块（1K是1024字节）为单位的总内存，Used 和 Available 列表示已使用和可用的内存容量，Use% 列显示使用的内存的百分比，而最后一列”Mounted on”显示的文件系统的挂载点。</p>
<p>df 也可以显示磁盘使用的文件系统信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">df</span> /dev/shm/</span><br><span class="line">Filesystem     1K-blocks    Used      Available Use% Mounted on </span><br><span class="line">tmpfs          3943968      293584    3650384    8%   /dev/shm</span><br></pre></td></tr></table></figure>



<p>用 <code>-i</code> 选项的 <code>df</code> 命令的输出显示 <code>inode</code> 信息而非块使用量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> -i </span><br></pre></td></tr></table></figure>



<p>显示所有的信息:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> --total </span><br></pre></td></tr></table></figure>



<p>我们看到输出的末尾，包含一个额外的行，显示总的每一列。</p>
<p>用 <code>-h</code> 选项，通过它可以产生可读的格式 df 命令的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure>



<p>输出的数字以 G（千兆字节）、M（兆字节）和 K（千字节）为单位。</p>
<h1 id="Linux-dirs-命令-显示当前目录栈"><a href="#Linux-dirs-命令-显示当前目录栈" class="headerlink" title="Linux dirs 命令 - 显示当前目录栈"></a>Linux dirs 命令 - 显示当前目录栈</h1><h2 id="介绍-84"><a href="#介绍-84" class="headerlink" title="介绍"></a>介绍</h2><p><strong>dirs</strong> 命令用于显示当前记住的目录列表（目录栈）。通过 <code>pushd</code> 命令可以将目录存入列表中；<code>popd</code> 命令可用于遍历弹出列表。</p>
<p>所谓的目录栈（或目录堆栈），其实就是在内存中的一个列表，这个列表用于存放目录条目信息。</p>
<p>和 cd 命令一样，dirs、pushd、popd 命令也是 bash 的内建命令，因此无法使用 which 命令查找，只要登录到 bash，就可以使用这几个命令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dirs</span> [选项] [参数]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-c</code>：删除所有元素以清空目录栈</li>
<li><code>-l</code>：不打印与主目录相关的波浪号前缀的目录</li>
<li><code>-p</code>：每行一个条目打印目录栈</li>
<li><code>-v</code>：每行一个条目，以栈中位置为前缀打印目录栈</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li><code>+N</code>：显示 dirs 不带选项启动时显示的目录列表左起中第 N 个目录，从零开始。</li>
<li><code>-N</code>：显示 dirs 不带选项启动时显示的目录列表右起中第 N 个目录，从零开始。</li>
</ul>
<h2 id="示例-84"><a href="#示例-84" class="headerlink" title="示例"></a>示例</h2><p>显示当前的目录栈</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">dirs</span></span><br><span class="line">~/workspace</span><br></pre></td></tr></table></figure>



<p>显示当前的目录栈（不带波浪号前缀）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">dirs</span> -l</span><br><span class="line">/home/rudy/workspace</span><br></pre></td></tr></table></figure>



<p>使用 pushd 命令将指定目录（&#x2F;usr&#x2F;lib&#x2F;fonts 和 &#x2F;usr&#x2F;share&#x2F;fonts）压入目录栈中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">pushd</span> /usr/lib/fonts</span><br><span class="line">/usr/lib/fonts ~</span><br><span class="line">$ <span class="built_in">pushd</span> /usr/share/fonts/</span><br><span class="line">/usr/share/fonts /usr/lib/fonts ~</span><br></pre></td></tr></table></figure>



<p>按条目显示目录列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">dirs</span> -p -v</span><br><span class="line"> 0  /usr/share/fonts</span><br><span class="line"> 1  /usr/lib/fonts</span><br><span class="line"> 2  ~</span><br></pre></td></tr></table></figure>



<p>在最近两个目录之间切换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">pushd</span></span><br></pre></td></tr></table></figure>



<p>注意：用 pushd 不加参数在最近的两个目录之间切换时，当前目录总是位于堆栈的最上面。</p>
<p>在多个目录之间切换，比如切换到 <strong>~</strong> 目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">pushd</span> +2</span><br></pre></td></tr></table></figure>



<p>从目录堆栈中删除目录（从堆栈顶端删除）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">popd</span> </span><br></pre></td></tr></table></figure>



<p>从目录堆栈中删除指定目录（删除堆栈中第1个目录）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">popd</span> +1</span><br></pre></td></tr></table></figure>



<p>清空目录堆栈</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">dirs</span> -c</span><br></pre></td></tr></table></figure>





<h1 id="Linux-pushd-命令-将目录压入目录栈"><a href="#Linux-pushd-命令-将目录压入目录栈" class="headerlink" title="Linux pushd 命令 - 将目录压入目录栈"></a>Linux pushd 命令 - 将目录压入目录栈</h1><p>Linux <strong>pushd</strong> 命令把原目录和当前目录压入到一个虚拟的目录堆栈中（可通过 dirs 命令查看），如果不指定参数，则会回到前一个目录，并把堆栈中最近的两个目录作交换。</p>
<p>具体参考 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/dirs/">dirs 命令用法</a></p>
<h1 id="Linux-popd-命令-恢复目录栈顶部目录"><a href="#Linux-popd-命令-恢复目录栈顶部目录" class="headerlink" title="Linux popd 命令 - 恢复目录栈顶部目录"></a>Linux popd 命令 - 恢复目录栈顶部目录</h1><p>Linux <strong>popd</strong> 命令弹出目录堆栈中的目录，与 dirs 和 pushd 命令配合使用。</p>
<p>具体参考 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/dirs/">dirs 命令用法</a></p>
<h1 id="Linux-du-命令-显示文件和目录大小"><a href="#Linux-du-命令-显示文件和目录大小" class="headerlink" title="Linux du 命令 - 显示文件和目录大小"></a>Linux du 命令 - 显示文件和目录大小</h1><h2 id="介绍-85"><a href="#介绍-85" class="headerlink" title="介绍"></a>介绍</h2><p><strong>du</strong>（英文全拼：disk usage）命令用于显示指定的目录或文件所占用的磁盘空间。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">du</span> [-abcDhHklmsSx] [-L &lt;符号连接&gt;] [-X &lt;文件&gt;]</span><br><span class="line">   [--block-size]</span><br><span class="line">   [--exclude=&lt;目录或文件&gt;]</span><br><span class="line">   [--max-depth=&lt;目录层数&gt;]</span><br><span class="line">   [--<span class="built_in">help</span>]</span><br><span class="line">   [--version]</span><br><span class="line">   [目录或文件]</span><br></pre></td></tr></table></figure>



<p><strong>参数说明</strong>：</p>
<ul>
<li><code>-a</code> 或 <code>-all</code> 显示目录中个别文件的大小。</li>
<li><code>-b</code> 或 <code>-bytes</code> 显示目录或文件大小时，以 byte 为单位。</li>
<li><code>-c</code> 或 <code>--total</code> 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。</li>
<li><code>-D</code> 或 <code>--dereference-args</code> 显示指定符号连接的源文件大小。</li>
<li><code>-h</code> 或 <code>--human-readable</code> 以 K，M，G 为单位，提高信息的可读性。</li>
<li><code>-H</code> 或 <code>--si</code> 与 <code>-h</code> 参数相同，但是 K，M，G 是以 1000 为换算单位。</li>
<li><code>-k</code> 或 <code>--kilobytes</code> 以 1024 bytes 为单位。</li>
<li><code>-l</code> 或 <code>--count-links</code> 重复计算硬件连接的文件。</li>
<li><code>-L &lt;符号连接&gt;</code> 或 <code>--dereference &lt;符号连接&gt;</code> 显示选项中所指定符号连接的源文件大小。</li>
<li><code>-m</code> 或 <code>--megabytes</code> 以 1MB 为单位。</li>
<li><code>-s</code> 或 <code>--summarize</code> 仅显示总计。</li>
<li><code>-S</code> 或 <code>--separate-dirs</code> 显示个别目录的大小时，并不含其子目录的大小。</li>
<li><code>-x</code> 或 <code>--one-file-xystem</code> 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。</li>
<li><code>-X &lt;文件&gt;</code> 或 <code>--exclude-from=&lt;文件&gt;</code> 在 <code>&lt;文件&gt;</code> 指定目录或文件。</li>
<li><code>--exclude=&lt;目录或文件&gt;</code> 略过指定的目录或文件。</li>
<li><code>--max-depth=&lt;目录层数&gt;</code> 超过指定层数的目录后，予以忽略。</li>
<li><code>--help</code> 显示帮助。</li>
<li><code>--version</code> 显示版本信息。</li>
</ul>
<h2 id="示例-85"><a href="#示例-85" class="headerlink" title="示例"></a>示例</h2><p>显示目录或者文件所占空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">du</span></span><br><span class="line">49012   ./dir</span><br><span class="line">57188   .</span><br></pre></td></tr></table></figure>



<p>只显示当前目录下面的子目录的目录大小和当前目录的总的大小，最下面的 57188 为当前目录的总大小。</p>
<p>显示指定文件（当前目录下所有文件和目录）所占空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">du</span> ./*</span><br><span class="line">49012   ./dir</span><br><span class="line">4       ./file1</span><br><span class="line">8168    ./file2</span><br></pre></td></tr></table></figure>



<p>以方便阅读的格式显示当前目录所占空间情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">du</span> -sh ./*</span><br><span class="line">48M     ./dir</span><br><span class="line">4.0K    ./file1</span><br><span class="line">8.0M    ./file2</span><br></pre></td></tr></table></figure>





<h1 id="Linux-mkdir-命令-创建目录"><a href="#Linux-mkdir-命令-创建目录" class="headerlink" title="Linux mkdir 命令 - 创建目录"></a>Linux mkdir 命令 - 创建目录</h1><h2 id="介绍-86"><a href="#介绍-86" class="headerlink" title="介绍"></a>介绍</h2><p><strong>mkdir</strong>（英文全拼：make directory）命令用于创建目录。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> [选项] dirName</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-Z</code>：设置安全上下文，当使用 SELinux 时有效；</li>
<li><code>-m &lt;目标属性&gt;</code> 或 <code>--mode&lt;目标属性&gt;</code>：建立目录的同时设置目录的权限；</li>
<li><code>-p</code> 或 <code>--parents</code>：若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；</li>
<li><code>--version</code>：显示版本信息。</li>
</ul>
<p><strong>参数</strong>：</p>
<p>参数 <code>dirName</code> 为将要创建的目录名称。如果在目录名的前面没有加任何路径名，则在当前目录下创建由 <code>dirName</code> 指定的目录；如果给出了一个已经存在的路径，将会在该目录下创建一个指定的目录。在创建目录时，应保证新建的目录与它所在目录下的文件没有重名。</p>
<h2 id="示例-86"><a href="#示例-86" class="headerlink" title="示例"></a>示例</h2><p>在当前目录下创建一个名为 getiot 的子目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> getiot</span><br></pre></td></tr></table></figure>



<p>创建并设置 getiot 目录权限为 700</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -m 700 getiot</span><br></pre></td></tr></table></figure>



<p>在当前目录下创建 getiot&#x2F;linux 目录（如果 getiot 目录不存在，则创建一个）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p getiot/linux </span><br></pre></td></tr></table></figure>



<p>注意：如果不加 -p 参数，且 getiot 目录不存在，会产生错误。</p>
<h1 id="Linux-pwd-命令-显示当前工作目录"><a href="#Linux-pwd-命令-显示当前工作目录" class="headerlink" title="Linux pwd 命令 - 显示当前工作目录"></a>Linux pwd 命令 - 显示当前工作目录</h1><h2 id="介绍-87"><a href="#介绍-87" class="headerlink" title="介绍"></a>介绍</h2><p><strong>pwd</strong>（英文全拼：print working directory） 命令用于显示用户当前所在的工作目录（以绝对路径显示）。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span> [选项]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-L</code> 或 <code>--logical</code>：使用 PWD 环境变量，即使它包含符号链接</li>
<li><code>-P</code> 或 <code>--physical</code>：避免使用符号链接</li>
<li><code>--help</code>：查看帮助</li>
<li><code>--version</code>：显示版本信息</li>
</ul>
<h2 id="示例-87"><a href="#示例-87" class="headerlink" title="示例"></a>示例</h2><p>查看当前所在目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/rudy/workspace</span><br></pre></td></tr></table></figure>



<p>在 workspace 下创建一个 dir 目录，并创建一个 dir_link 软链接指向 dir 目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="built_in">dir</span></span><br><span class="line"><span class="built_in">ln</span> -s <span class="built_in">dir</span>/ dir_link</span><br></pre></td></tr></table></figure>



<p>切换到 dir_link 目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> dir_link</span><br></pre></td></tr></table></figure>



<p>查看当前所在目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/rudy/workspace/dir_link</span><br></pre></td></tr></table></figure>



<p>以 logical 方式查看当前所在目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span> -L</span><br><span class="line">/home/rudy/workspace/dir_link</span><br></pre></td></tr></table></figure>



<p>以 physical 方式查看当前所在目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span> -P</span><br><span class="line">/home/rudy/workspace/dir</span><br></pre></td></tr></table></figure>





<h1 id="Linux-mount-命令-挂载文件系统"><a href="#Linux-mount-命令-挂载文件系统" class="headerlink" title="Linux mount 命令 - 挂载文件系统"></a>Linux mount 命令 - 挂载文件系统</h1><h2 id="介绍-88"><a href="#介绍-88" class="headerlink" title="介绍"></a>介绍</h2><p><strong>mount</strong> 命令用于挂载系统外的文件系统到指定加载点。</p>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/umount/">umount</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount [选项] [参数]</span><br></pre></td></tr></table></figure>



<p>详细语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount [-l|-h|-V]</span><br><span class="line">mount -a [-fFnrsvw] [-t fstype] [-O optlist]</span><br><span class="line">mount [-fnrsvw] [-o options] device|<span class="built_in">dir</span></span><br><span class="line">mount [-fnrsvw] [-t fstype] [-o options] device <span class="built_in">dir</span></span><br></pre></td></tr></table></figure>



<p><strong>参数</strong>：</p>
<ul>
<li><code>-V</code>：显示程序版本。</li>
<li><code>-h</code>：显示辅助信息。</li>
<li><code>-l</code>：显示以加载的文件系统列表。</li>
<li><code>-v</code>：冗长模式，输出指令执行的详细信息，通常和 <code>-f</code> 用来除错。</li>
<li><code>-a</code>：将 &#x2F;etc&#x2F;fstab 中定义的所有档案系统挂上。</li>
<li><code>-F</code>：这个命令通常和 <code>-a</code> 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。</li>
<li><code>-f</code>：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 <code>-v</code> 一起使用。</li>
<li><code>-n</code>：加载没有写入文件“&#x2F;etc&#x2F;mtab”中的文件系统。</li>
<li><code>-r</code>：将文件系统加载为只读模式。</li>
<li><code>-s-r</code>：等于 <code>-o ro</code></li>
<li><code>-w</code>：等于 <code>-o rw</code></li>
<li><code>-L</code>：将含有特定标签的硬盘分割挂上。</li>
<li><code>-U</code>：将档案分割序号为 的档案系统挂下。<code>-L</code> 和 <code>-U</code> 必须在 &#x2F;proc&#x2F;partition 这种档案存在时才有意义。</li>
<li><code>-t</code>：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。</li>
<li><code>-o async</code>：打开非同步模式，所有的档案读写动作都会用非同步模式执行。</li>
<li><code>-o sync</code>：在同步模式下执行。</li>
<li><code>-o atime</code>、<code>-o noatime</code>：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。</li>
<li><code>-o auto</code>、<code>-o noauto</code>：打开&#x2F;关闭自动挂上模式。</li>
<li><code>-o defaults</code>：使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.</li>
<li><code>-o dev</code>、<code>-o nodev-o exec</code>、<code>-o noexec</code> 允许执行档被执行。</li>
<li><code>-o suid</code>、<code>-o nosuid</code>：允许执行档在 root 权限下执行。</li>
<li><code>-o user</code>、<code>-o nouser</code>：使用者可以执行 mount&#x2F;umount 的动作。</li>
<li><code>-o remount</code>：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是只读的系统，现在用可读写的模式重新挂上。</li>
<li><code>-o ro</code>：用只读模式挂载。</li>
<li><code>-o rw</code>：用可读写模式挂载。</li>
<li><code>-o loop=</code>：使用 loop 模式用来将一个档案当成硬盘分割挂载上系统。</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li>设备文件名：指定要加载的文件系统对应的设备名（如 &#x2F;dev&#x2F;sdb1）；</li>
<li>加载点：指定加载点目录。</li>
</ul>
<h2 id="示例-88"><a href="#示例-88" class="headerlink" title="示例"></a>示例</h2><p>将 &#x2F;dev&#x2F;sdb1 挂载到 &#x2F;mnt 目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/sdb1 /mnt</span><br></pre></td></tr></table></figure>



<p>将 &#x2F;dev&#x2F;sdb1 以只读方式挂载到 &#x2F;mnt 目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -o ro /dev/sdb1 /mnt</span><br></pre></td></tr></table></figure>



<p>挂载光盘设备到 &#x2F;mnt&#x2F;cdrom 目录（目录不存在，需要先创建）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -t auto /dev/cdrom /mnt/cdrom</span><br></pre></td></tr></table></figure>



<p>将 &#x2F;tmp&#x2F;image.iso 这个光碟的 image 档使用 loop 模式挂载到 &#x2F;mnt&#x2F;cdrom 目录。用这种方法可以将一般网络上可以找到的 Linux 光碟 ISO 档在不烧录成光碟的情况下查看其内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -o loop /tmp/image.iso /mnt/cdrom</span><br></pre></td></tr></table></figure>



<p>将远程 NFS 网络文件系统挂载到本地 &#x2F;mnt 目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -t nfs -o nolock 192.168.30.189:/srv/nfs/ /mnt/</span><br></pre></td></tr></table></figure>





<h1 id="Linux-umount-命令-卸载文件系统"><a href="#Linux-umount-命令-卸载文件系统" class="headerlink" title="Linux umount 命令 - 卸载文件系统"></a>Linux umount 命令 - 卸载文件系统</h1><h2 id="介绍-89"><a href="#介绍-89" class="headerlink" title="介绍"></a>介绍</h2><p><strong>umount</strong>（英文全拼：unmount）命令用于卸载文件系统。</p>
<p>利用设备名或挂载点都能 umount 文件系统，不过最好还是通过挂载点卸载，以免使用绑定挂载（一个设备，多个挂载点）时产生混乱。如果存在多个挂载点，每次执行 umount 会按先进后出的方式卸载。</p>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/mount/">mount</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount [选项] [参数]</span><br></pre></td></tr></table></figure>



<p>详细语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount -a [-dflnrv] [-t fstype] [-O option...]</span><br><span class="line">umount [-dflnrv] &#123;directory|device&#125;...</span><br><span class="line">umount -h|-V</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code> 卸载 &#x2F;etc&#x2F;mtab 中记录的所有文件系统。</li>
<li><code>-h</code> 显示帮助。</li>
<li><code>-n</code> 卸载时不要将信息存入 &#x2F;etc&#x2F;mtab 文件中。</li>
<li><code>-r</code> 若无法成功卸载，则尝试以只读的方式重新挂载文件系统。</li>
<li><code>-t &lt;文件系统类型&gt;</code> 仅卸载选项中所指定的文件系统。</li>
<li><code>-v</code> 执行时显示详细的信息。</li>
<li><code>-V</code> 显示版本信息。</li>
</ul>
<p><strong>参数</strong>：文件系统（可以是设备名或挂载点）。</p>
<h2 id="示例-89"><a href="#示例-89" class="headerlink" title="示例"></a>示例</h2><p>通过设备名卸载，并打印详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> umount -v /dev/sdc1</span><br><span class="line">umount: /mnt (/dev/sdc1) unmounted</span><br></pre></td></tr></table></figure>



<p>通过挂载点卸载，并打印详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> umount -v /mnt</span><br><span class="line">umount: /mnt unmounted</span><br></pre></td></tr></table></figure>



<p>注意：执行 umount 命令需要 root 权限，因此需要在命令前添加 sudo。</p>
<p>如果设备正忙，执行 umount 将会失败。卸载失败的常见原因是，某个打开的 shell 当前目录为挂载点里的某个目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> umount -v /mnt</span><br><span class="line">umount: /mnt: target is busy.</span><br></pre></td></tr></table></figure>



<p>有时，导致设备忙的原因并不好找。碰到这种情况时，可以用 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/lsof/">lsof</a> 列出已打开文件，然后搜索列表查找待卸载的挂载点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lsof | grep mnt</span><br><span class="line">bash    1894    rudy  cwd    DIR    8,33    4096    1 /mnt</span><br></pre></td></tr></table></figure>



<p>从上面的输出可知，无法卸载的原因在于，rudy 运行的 PID 为 1894 的 bash 进程打开了挂载点 &#x2F;mnt。</p>
<p>应对系统文件正忙的另一种方法是执行延迟卸载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> umount -vl /mnt</span><br></pre></td></tr></table></figure>



<p>延迟卸载（lazy unmount）会立即卸载目录树里的文件系统，等到设备不再繁忙时才清理所有相关资源。卸载可移动存储介质还可以用 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/eject/">eject</a> 命令。</p>
<p>下面命令会卸载 cdrom 分区并弹出 CD：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> eject /dev/cdrom</span><br></pre></td></tr></table></figure>





<h1 id="Linux-eject-命令-弹出可移动介质"><a href="#Linux-eject-命令-弹出可移动介质" class="headerlink" title="Linux eject 命令 - 弹出可移动介质"></a>Linux eject 命令 - 弹出可移动介质</h1><h2 id="介绍-90"><a href="#介绍-90" class="headerlink" title="介绍"></a>介绍</h2><p><strong>eject</strong> 命令用于退出抽取式设备。若设备已挂载，则先将该设备卸载再退出。</p>
<p>eject 允许可移动介质（典型是 CD-ROM、软盘、磁带、或者 JAZ 以及 zip 磁盘）在软件控制下弹出。该命令也可以控制一些多盘片 CD-ROM 控制器，控制一些设备支持的自动弹出功能，以及控制一些 CD-ROM 驱动器磁盘托盘的关闭。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">eject [选项] [参数]</span><br></pre></td></tr></table></figure>



<p>详细语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">eject [-vnrsfmqp] [&lt;name&gt;]</span><br><span class="line">eject [-vn] -d</span><br><span class="line">eject [-vn] -a on|off|1|0 [&lt;name&gt;]</span><br><span class="line">eject [-vn] -c slot [&lt;name&gt;]</span><br><span class="line">eject [-vn] -i on|off|1|0 [&lt;name&gt;]</span><br><span class="line">eject [-vn] -t [&lt;name&gt;]</span><br><span class="line">eject [-vn] -T [&lt;name&gt;]</span><br><span class="line">eject [-vn] -x &lt;speed&gt; [&lt;name&gt;]</span><br><span class="line">eject [-vn] -X [&lt;name&gt;]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a &lt;开关&gt;</code> 或 <code>--auto &lt;开关&gt;</code>：控制设备的自动退出功能。</li>
<li><code>-c &lt;光驱编号&gt;</code> 或 <code>--changerslut &lt;光驱编号&gt;</code>：选择光驱柜中的光驱。</li>
<li><code>-d</code> 或 <code>--default</code>：显示预设的设备，而不是实际执行动作。</li>
<li><code>-f</code> 或 <code>--floppy</code>：退出抽取式磁盘。</li>
<li><code>-h</code> 或 <code>--help</code>：显示帮助。</li>
<li><code>-n</code> 或 <code>--noop</code>：显示指定的设备。</li>
<li><code>-q</code> 或 <code>--tape</code>：退出磁带。</li>
<li><code>-r</code> 或 <code>--cdrom</code>：退出光盘。</li>
<li><code>-s</code> 或 <code>--scsi</code>：以 SCSI 指令来退出设备。</li>
<li><code>-t</code> 或 <code>--trayclose</code>：关闭光盘的托盘。</li>
<li><code>-v</code> 或 <code>--verbose</code>：执行时，显示详细的说明。</li>
</ul>
<p><strong>参数</strong>：指定弹出的文件 name，可以是设备名或挂载点。</p>
<h2 id="示例-90"><a href="#示例-90" class="headerlink" title="示例"></a>示例</h2><p>不加参数默认弹出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ eject</span><br></pre></td></tr></table></figure>



<p>指定弹出设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ eject -r /dev/cdrom</span><br></pre></td></tr></table></figure>





<h1 id="Linux-stat-命令-显示文件或文件系统状态"><a href="#Linux-stat-命令-显示文件或文件系统状态" class="headerlink" title="Linux stat 命令 - 显示文件或文件系统状态"></a>Linux stat 命令 - 显示文件或文件系统状态</h1><h2 id="介绍-91"><a href="#介绍-91" class="headerlink" title="介绍"></a>介绍</h2><p><strong>stat</strong>（英文全拼：status）命令用于显示文件或文件系统的状态，以文字的格式来显示 inode 的内容。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> [OPTION]... FILE...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-L</code>：支持符号连接</li>
<li><code>-f</code>：显示文件系统状态而非文件状态</li>
<li><code>-t</code>：以简洁方式输出信息</li>
<li><code>--help</code>：显示指令的帮助信息</li>
<li><code>--version</code>：显示指令的版本信息</li>
</ul>
<p><strong>参数</strong>：文件或目录</p>
<h2 id="示例-91"><a href="#示例-91" class="headerlink" title="示例"></a>示例</h2><p>假设当前目录下由 dir 目录及软链接 dir_link</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -ld <span class="built_in">dir</span>*</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr 13 10:33 <span class="built_in">dir</span></span><br><span class="line">lrwxrwxrwx 1 root root    3 Apr 13 13:55 dir_link -&gt; <span class="built_in">dir</span></span><br></pre></td></tr></table></figure>



<p>查看 dir 目录的 inode 内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">stat</span> <span class="built_in">dir</span></span><br><span class="line">  File: <span class="built_in">dir</span></span><br><span class="line">  Size: 4096            Blocks: 8          IO Block: 4096   directory</span><br><span class="line">Device: b302h/45826d    Inode: 2752621     Links: 2</span><br><span class="line">Access: (0755/drwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2021-04-13 10:33:54.796081184 +0000</span><br><span class="line">Modify: 2021-04-13 10:33:47.508153771 +0000</span><br><span class="line">Change: 2021-04-13 10:33:47.508153771 +0000</span><br><span class="line"> Birth: 2021-04-13 10:33:08.968537620 +0000</span><br></pre></td></tr></table></figure>



<p>查看 dir_link 目录的 inode 内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> dir_link</span><br><span class="line">  File: dir_link -&gt; <span class="built_in">dir</span></span><br><span class="line">  Size: 3               Blocks: 0          IO Block: 4096   symbolic <span class="built_in">link</span></span><br><span class="line">Device: b302h/45826d    Inode: 2752631     Links: 1</span><br><span class="line">Access: (0777/lrwxrwxrwx)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2021-04-13 13:55:59.591319842 +0000</span><br><span class="line">Modify: 2021-04-13 13:55:54.755368008 +0000</span><br><span class="line">Change: 2021-04-13 13:55:54.755368008 +0000</span><br><span class="line"> Birth: 2021-04-13 13:55:54.755368008 +0000</span><br></pre></td></tr></table></figure>



<p>查看 file 文件的 inode 内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">stat</span> file</span><br><span class="line">  File: file</span><br><span class="line">  Size: 8360846         Blocks: 16336      IO Block: 4096   regular file</span><br><span class="line">Device: b302h/45826d    Inode: 2752632     Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2021-04-13 13:59:07.161451669 +0000</span><br><span class="line">Modify: 2021-04-13 13:59:07.197451310 +0000</span><br><span class="line">Change: 2021-04-13 13:59:07.197451310 +0000</span><br><span class="line"> Birth: 2021-04-13 13:59:07.161451669 +0000</span><br></pre></td></tr></table></figure>





<h1 id="Linux-tree-命令-以树形结构显示目录"><a href="#Linux-tree-命令-以树形结构显示目录" class="headerlink" title="Linux tree 命令 - 以树形结构显示目录"></a>Linux tree 命令 - 以树形结构显示目录</h1><h2 id="介绍-92"><a href="#介绍-92" class="headerlink" title="介绍"></a>介绍</h2><p><strong>tree</strong> 命令以树状图列出目录的内容。执行 tree 指令，会列出指定目录下的所有文件，包括子目录里的文件。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tree [选项] [参数]</span><br></pre></td></tr></table></figure>



<p>详细语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tree [-acdfghilnpqrstuvxACDFQNSUX]  [-L level [-R]] [-H baseHREF] </span><br><span class="line">     [-T title] [-o filename] [--nolinks] [-P pattern] [-I pattern]</span><br><span class="line">     [--inodes] [--device] [--noreport] [--dirsfirst] [--version] </span><br><span class="line">     [--<span class="built_in">help</span>] [--filelimit <span class="comment">#] [--si] [--prune] [--du] [--timefmt  format]</span></span><br><span class="line">     [--matchdirs] [--fromfile] [--] [directory ...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code> 显示所有文件和目录。</li>
<li><code>-A</code> 使用 ASNI 绘图字符显示树状图而非以 ASCII 字符组合。</li>
<li><code>-C</code> 在文件和目录清单加上色彩，便于区分各种类型。</li>
<li><code>-d</code> 显示目录名称而非内容。</li>
<li><code>-D</code> 列出文件或目录的更改时间。</li>
<li><code>-f</code> 在每个文件或目录之前，显示完整的相对路径名称。</li>
<li><code>-F</code> 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上 “<code>*</code>“、”<code>/</code>“、”<code>=</code>“、”<code>@</code>“、”<code>|</code>“ 号。</li>
<li><code>-g</code> 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。</li>
<li><code>-i</code> 不以阶梯状列出文件或目录名称。</li>
<li><code>-L level</code> 限制目录显示层级。</li>
<li><code>-l</code> 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。</li>
<li><code>-n</code> 不在文件和目录清单加上色彩。</li>
<li><code>-N</code> 直接列出文件和目录名称，包括控制字符。</li>
<li><code>-p</code> 列出权限标示。</li>
<li><code>-P &lt;范本样式&gt;</code> 只显示符合范本样式的文件或目录名称。</li>
<li><code>-q</code> 用 “<code>?</code>“ 号取代控制字符，列出文件和目录名称。</li>
<li><code>-s</code> 列出文件或目录大小。</li>
<li><code>-t</code> 用文件和目录的更改时间排序。</li>
<li><code>-u</code> 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。</li>
<li><code>-x</code> 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</li>
</ul>
<p><strong>参数</strong>：目录（可以是绝对路径或相对路径）。</p>
<h2 id="示例-92"><a href="#示例-92" class="headerlink" title="示例"></a>示例</h2><p>以树状图列出当前目录结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── file</span><br><span class="line">├── subdir1</span><br><span class="line">│   ├── hello.txt</span><br><span class="line">│   └── world.txt</span><br><span class="line">└── subdir2</span><br><span class="line">    ├── hello.txt</span><br><span class="line">    └── world.txt</span><br><span class="line"></span><br><span class="line">2 directories, 5 files</span><br></pre></td></tr></table></figure>



<p>只显示一级目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── file</span><br><span class="line">├── subdir1</span><br><span class="line">└── subdir2</span><br><span class="line"></span><br><span class="line">2 directories, 1 file</span><br></pre></td></tr></table></figure>





<h1 id="Linux-fdisk-命令-管理磁盘分区表"><a href="#Linux-fdisk-命令-管理磁盘分区表" class="headerlink" title="Linux fdisk 命令 - 管理磁盘分区表"></a>Linux fdisk 命令 - 管理磁盘分区表</h1><h2 id="介绍-93"><a href="#介绍-93" class="headerlink" title="介绍"></a>介绍</h2><p><strong>fdisk</strong> 是一个创建和维护分区表的程序，它兼容 DOS 类型的分区表、BSD 或者 SUN 类型的磁盘列表。</p>
<p>fdisk 命令可用于观察硬盘实体使用情况，也可对硬盘分区。它采用传统的问答式界面，而非类似 DOS fdisk 的 cfdisk 互动式操作界面，因此在使用上较为不便，但功能却丝毫不打折扣。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk [选项] [参数]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-b &lt;分区大小&gt;</code>：指定每个分区的大小。</li>
<li><code>-l</code>：列出指定的外围设备的分区表状况。</li>
<li><code>-s &lt;分区编号&gt;</code>：将指定的分区大小输出到标准输出上，单位为区块。</li>
<li><code>-u</code>：搭配 “<code>-l</code>“ 参数列表，会用分区数目取代柱面数目，来表示每个分区的起始地址。</li>
<li><code>-v</code>：显示版本信息。</li>
</ul>
<p><strong>参数</strong>： 指定要进行分区或者显示分区的硬盘设备文件。</p>
<p><strong>分区菜单操作说明</strong>：</p>
<ul>
<li><code>m</code> ：显示菜单和帮助信息</li>
<li><code>a</code> ：活动分区标记&#x2F;引导分区</li>
<li><code>d</code> ：删除分区</li>
<li><code>l</code> ：显示分区类型</li>
<li><code>n</code> ：新建分区</li>
<li><code>p</code> ：显示分区信息</li>
<li><code>q</code> ：退出不保存</li>
<li><code>t</code> ：设置分区号</li>
<li><code>v</code> ：进行分区检查</li>
<li><code>w</code> ：保存修改</li>
<li><code>x</code> ：扩展应用，高级功能</li>
</ul>
<h2 id="示例-93"><a href="#示例-93" class="headerlink" title="示例"></a>示例</h2><p>显示当前分区情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> fdisk -l</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 10.7 GB, 10737418240 bytes</span><br><span class="line">255 heads, 63 sectors/track, 1305 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line"></span><br><span class="line">  Device Boot   Start     End   Blocks  Id System</span><br><span class="line">/dev/sda1  *      1     13   104391  83 Linux</span><br><span class="line">/dev/sda2       14    1305  10377990  8e Linux LVM</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 5368 MB, 5368709120 bytes</span><br><span class="line">255 heads, 63 sectors/track, 652 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb doesn<span class="string">&#x27;t contain a valid partition table</span></span><br></pre></td></tr></table></figure>



<p>对磁盘进行分区，首先选择要进行操作的磁盘（如 &#x2F;dev&#x2F;sdb）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> fdisk /dev/sdb</span><br></pre></td></tr></table></figure>



<p>输入 <code>m</code> 列出可以执行的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> (m <span class="keyword">for</span> <span class="built_in">help</span>): m</span><br><span class="line">Command action</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   delete a partition</span><br><span class="line">   l   list known partition types</span><br><span class="line">   m   <span class="built_in">print</span> this menu</span><br><span class="line">   n   add a new partition</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   p   <span class="built_in">print</span> the partition table</span><br><span class="line">   q   quit without saving changes</span><br><span class="line">   s   create a new empty Sun disklabel</span><br><span class="line">   t   change a partition<span class="string">&#x27;s system id</span></span><br><span class="line"><span class="string">   u   change display/entry units</span></span><br><span class="line"><span class="string">   v   verify the partition table</span></span><br><span class="line"><span class="string">   w   write table to disk and exit</span></span><br><span class="line"><span class="string">   x   extra functionality (experts only)</span></span><br></pre></td></tr></table></figure>



<p>输入<code>p</code>列出磁盘目前的分区情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 3221 MB, 3221225472 bytes</span><br><span class="line">255 heads, 63 sectors/track, 391 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1               1           1        8001   8e  Linux LVM</span><br><span class="line">/dev/sdb2               2          26      200812+  83  Linux</span><br></pre></td></tr></table></figure>



<p>输入<code>d</code>然后选择分区，删除现有分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): d</span><br><span class="line">Partition number (1-4): 1</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): d</span><br><span class="line">Selected partition 2</span><br></pre></td></tr></table></figure>



<p>查看分区情况，确认分区已经删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): <span class="built_in">print</span></span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 3221 MB, 3221225472 bytes</span><br><span class="line">255 heads, 63 sectors/track, 391 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>):</span><br></pre></td></tr></table></figure>



<p>输入<code>n</code>建立新的磁盘分区，首先建立两个主磁盘分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Command action</span><br><span class="line">   e   extended</span><br><span class="line">   p   primary partition (1-4)</span><br><span class="line">p    <span class="comment"># 建立主分区</span></span><br><span class="line">Partition number (1-4): 1  <span class="comment"># 分区号</span></span><br><span class="line">First cylinder (1-391, default 1):  <span class="comment"># 分区起始位置</span></span><br><span class="line">Using default value 1</span><br><span class="line">last cylinder or +size or +sizeM or +sizeK (1-391, default 391): 100  <span class="comment"># 分区结束位置，单位为扇区</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n  <span class="comment"># 再建立一个分区</span></span><br><span class="line">Command action</span><br><span class="line">   e   extended</span><br><span class="line">   p   primary partition (1-4)</span><br><span class="line">p </span><br><span class="line">Partition number (1-4): 2  <span class="comment"># 分区号为2</span></span><br><span class="line">First cylinder (101-391, default 101):</span><br><span class="line">Using default value 101</span><br><span class="line">Last cylinder or +size or +sizeM or +sizeK (101-391, default 391): +200M  <span class="comment"># 分区结束位置，单位为M</span></span><br></pre></td></tr></table></figure>



<p>确认分区建立成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 3221 MB, 3221225472 bytes</span><br><span class="line">255 heads, 63 sectors/track, 391 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1               1         100      803218+  83  Linux</span><br><span class="line">/dev/sdb2             101         125      200812+  83  Linux</span><br></pre></td></tr></table></figure>



<p>再建立一个逻辑分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Command action</span><br><span class="line">   e   extended</span><br><span class="line">   p   primary partition (1-4)</span><br><span class="line">e  <span class="comment"># 选择扩展分区</span></span><br><span class="line">Partition number (1-4): 3</span><br><span class="line">First cylinder (126-391, default 126):</span><br><span class="line">Using default value 126</span><br><span class="line">Last cylinder or +size or +sizeM or +sizeK (126-391, default 391):</span><br><span class="line">Using default value 391</span><br></pre></td></tr></table></figure>



<p>确认扩展分区建立成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 3221 MB, 3221225472 bytes</span><br><span class="line">255 heads, 63 sectors/track, 391 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1               1         100      803218+  83  Linux</span><br><span class="line">/dev/sdb2             101         125      200812+  83  Linux</span><br><span class="line">/dev/sdb3             126         391     2136645    5  Extended</span><br></pre></td></tr></table></figure>



<p>在扩展分区上建立两个逻辑分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Command action</span><br><span class="line">   l   logical (5 or over)</span><br><span class="line">   p   primary partition (1-4)</span><br><span class="line">l <span class="comment"># 选择逻辑分区</span></span><br><span class="line">First cylinder (126-391, default 126):</span><br><span class="line">Using default value 126</span><br><span class="line">Last cylinder or +size or +sizeM or +sizeK (126-391, default 391): +400M    </span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Command action</span><br><span class="line">   l   logical (5 or over)</span><br><span class="line">   p   primary partition (1-4)</span><br><span class="line">l</span><br><span class="line">First cylinder (176-391, default 176):</span><br><span class="line">Using default value 176</span><br><span class="line">Last cylinder or +size or +sizeM or +sizeK (176-391, default 391):</span><br><span class="line">Using default value 391</span><br></pre></td></tr></table></figure>



<p>确认逻辑分区建立成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 3221 MB, 3221225472 bytes</span><br><span class="line">255 heads, 63 sectors/track, 391 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1               1         100      803218+  83  Linux</span><br><span class="line">/dev/sdb2             101         125      200812+  83  Linux</span><br><span class="line">/dev/sdb3             126         391     2136645    5  Extended</span><br><span class="line">/dev/sdb5             126         175      401593+  83  Linux</span><br><span class="line">/dev/sdb6             176         391     1734988+  83  Linux</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>):</span><br></pre></td></tr></table></figure>



<p>从上面的结果我们可以看到，在硬盘sdb我们建立了2个主分区（sdb1，sdb2），1个扩展分区（sdb3），2个逻辑分区（sdb5，sdb6）</p>
<p>注意：主分区和扩展分区的磁盘号位1-4，也就是说最多有4个主分区或者扩展分区，逻辑分区开始的磁盘号为5，因此在这个实验中试没有 sdb4 的。</p>
<p>最后对分区操作进行保存：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure>



<p>建立好分区之后我们还需要对分区进行格式化才能在系统中使用磁盘。</p>
<p>在 sdb1 上建立 ext2 分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> mkfs.ext2 /dev/sdb1</span><br></pre></td></tr></table></figure>



<p>在 sdb6 上建立 ext3 分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> mkfs.ext3 /dev/sdb6</span><br></pre></td></tr></table></figure>



<p>建立两个目录 <code>/oracle</code> 和 <code>/web</code>，将新建好的两个分区挂载到系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">mkdir</span> /oracle</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">mkdir</span> /web</span><br><span class="line">$ <span class="built_in">sudo</span> mount /dev/sdb1 /oracle</span><br><span class="line">$ <span class="built_in">sudo</span> mount /dev/sdb6 /web</span><br></pre></td></tr></table></figure>



<p>查看分区挂载情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">df</span> -h</span><br><span class="line">文件系统              容量  已用 可用 已用% 挂载点</span><br><span class="line">/dev/mapper/VolGroup00-LogVol00</span><br><span class="line">                      6.7G  2.8G  3.6G  44% /</span><br><span class="line">/dev/sda1              99M   12M   82M  13% /boot</span><br><span class="line">tmpfs                 125M     0  125M   0% /dev/shm</span><br><span class="line">/dev/sdb1             773M  808K  733M   1% /oracle</span><br><span class="line">/dev/sdb6             1.7G   35M  1.6G   3% /web</span><br></pre></td></tr></table></figure>



<p>如果需要每次开机自动挂载则需要修改 <code>/etc/fstab</code> 文件，加入两行配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/sdb1       /oracle    ext2    defaults      0 0</span><br><span class="line">/dev/sdb6       /web       ext3    defaults      0 0</span><br></pre></td></tr></table></figure>





<h1 id="Linux-sfdisk-命令-管理磁盘分区表"><a href="#Linux-sfdisk-命令-管理磁盘分区表" class="headerlink" title="Linux sfdisk 命令 - 管理磁盘分区表"></a>Linux sfdisk 命令 - 管理磁盘分区表</h1><h2 id="介绍-94"><a href="#介绍-94" class="headerlink" title="介绍"></a>介绍</h2><p><strong>sfdisk</strong> 命令用于显示或操作磁盘分区表。</p>
<p>与 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/fdisk/">fdisk</a> 菜单式交互操作不同，sfdisk 是一个面向脚本的工具，由命令驱动（从文件或 stdin 读取输入），因此通常用于在 shell 脚本中对硬盘进行分区或对分区表进行备份和恢复。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sfdisk [options] device [-N partition-number]</span><br><span class="line">sfdisk [options] <span class="built_in">command</span></span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-d</code> ：显示硬盘分区的设置。</li>
<li><code>-g</code> ：输出模块的载入信息。</li>
<li><code>-l</code> ：显示后硬盘分区的相关设置。</li>
<li><code>-s</code> ：显示分区的大小，单位为区块。</li>
<li><code>-T</code> ：显示所有 sfdisk 能辨识的文件系统 ID。</li>
<li><code>-V</code> ：检查硬盘分区是否正常。</li>
<li><code>-x</code> ：显示扩展分区中的逻辑分区。</li>
<li><code>-N</code> ：按照从标准输入读取的分区表，在指定的块设备上创建分区表。</li>
<li><code>-A</code> ：打开指定分区的启动标记（仅可用于 MBR 分区表）。</li>
<li><code>--delete</code> ：删除指定&#x2F;全部的分区。</li>
<li><code>-J</code> ：按照 JSON 格式导出指定块设备的现有分区表。</li>
<li><code>-F</code> ：列出指定&#x2F;全部块设备上尚未被分区的剩余空间。</li>
<li><code>-r</code> ：按照各分区的起始扇区，对现有分区进行重新编号。</li>
<li><code>-a</code> ：仅在现有的分区表上添加新分区，而不是创建一个全新的分区表。</li>
<li><code>-f</code> ：禁用所有一致性检查，强制执行看上去明显的错误动作。</li>
<li><code>-n</code> ：模拟操作（并不真正写入块设备）。</li>
<li><code>-o</code> ：仅输出指定的字段。</li>
<li><code>-q</code> ：不显示所有多余的信息。</li>
<li><code>-X</code> ：指定分区表的类型。如果未明确指定此选项，那么表示使用块设备上的现有类型。 如果现有块设备上不存在分区表，那么默认为 dos 类型（MBR）。</li>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息。</li>
<li><code>-v</code>, <code>--version</code> ：显示版本信息。</li>
</ul>
<h2 id="示例-94"><a href="#示例-94" class="headerlink" title="示例"></a>示例</h2><p>sfdisk 读取以下形式的行，每行填充一个分区描述符。当字段不存在或为空时，将使用默认值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;start&gt; &lt;size&gt; &lt;<span class="built_in">id</span>&gt; &lt;bootable&gt; &lt;c,h,s&gt; &lt;c,h,s&gt;</span><br></pre></td></tr></table></figure>



<p>例如，文件 emmc_partition_table.txt 记录 eMMC 分区信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># partition table of /dev/mmcblk0</span></span><br><span class="line">unit: sectors</span><br><span class="line"></span><br><span class="line">/dev/mmcblk0p1 : start=    20480, size=  2097152, Id= c, bootable</span><br><span class="line">/dev/mmcblk0p2 : start=  2117632, size= 46137344, Id=83</span><br><span class="line">/dev/mmcblk0p3 : start= 48254976, size= 10485760, Id=83</span><br><span class="line">/dev/mmcblk0p4 : start= 58740736, size=122142719, Id= 5  <span class="comment"># extended partition</span></span><br><span class="line">/dev/mmcblk0p5 : start= 58741736, size= 41943040, Id=83</span><br><span class="line">/dev/mmcblk0p6 : start=100684776, size= 20971520, Id=83</span><br></pre></td></tr></table></figure>



<p>使用该分区表对块设备 &#x2F;dev&#x2F;mmcblk0 进行分区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sfdisk /dev/mmcblk0 &lt; emmc_partition_table.txt</span><br></pre></td></tr></table></figure>



<p>查看指定硬盘分区的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sfdisk -l /dev/mmcblk0</span><br></pre></td></tr></table></figure>



<p>输出内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Disk /dev/mmcblk0: 58.25 GiB, 62537072640 bytes, 122142720 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x1bbe4bb6</span><br><span class="line"></span><br><span class="line">Device         Boot     Start       End  Sectors  Size Id Type</span><br><span class="line">/dev/mmcblk0p1 *        20480   2117631  2097152    1G  c W95 FAT32 (LBA)</span><br><span class="line">/dev/mmcblk0p2        2117632  48254975 46137344   22G 83 Linux</span><br><span class="line">/dev/mmcblk0p3       48254976  58740735 10485760    5G 83 Linux</span><br><span class="line">/dev/mmcblk0p4       58740736 122142719 63401984 30.2G  5 Extended</span><br><span class="line">/dev/mmcblk0p5       58741736 100684775 41943040   20G 83 Linux</span><br><span class="line">/dev/mmcblk0p6      100684776 121656295 20971520   10G 83 Linux</span><br></pre></td></tr></table></figure>



<p>查看指定硬盘分区的设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sfdisk -d /dev/mmcblk0</span><br></pre></td></tr></table></figure>



<p>输出内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">label: dos</span><br><span class="line">label-id: 0x1bbe4bb6</span><br><span class="line">device: /dev/mmcblk0</span><br><span class="line">unit: sectors</span><br><span class="line"></span><br><span class="line">/dev/mmcblk0p1 : start=       20480, size=     2097152, <span class="built_in">type</span>=c, bootable</span><br><span class="line">/dev/mmcblk0p2 : start=     2117632, size=    46137344, <span class="built_in">type</span>=83</span><br><span class="line">/dev/mmcblk0p3 : start=    48254976, size=    10485760, <span class="built_in">type</span>=83</span><br><span class="line">/dev/mmcblk0p4 : start=    58740736, size=    63401984, <span class="built_in">type</span>=5</span><br><span class="line">/dev/mmcblk0p5 : start=    58741736, size=    41943040, <span class="built_in">type</span>=83</span><br><span class="line">/dev/mmcblk0p6 : start=   100684776, size=    20971520, <span class="built_in">type</span>=83</span><br></pre></td></tr></table></figure>



<p>删除 &#x2F;dev&#x2F;mmcblk0 块设备上的所有分区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sfdisk --delete /dev/mmcblk0</span><br></pre></td></tr></table></figure>





<h1 id="Linux-parted-命令-管理磁盘分区"><a href="#Linux-parted-命令-管理磁盘分区" class="headerlink" title="Linux parted 命令 - 管理磁盘分区"></a>Linux parted 命令 - 管理磁盘分区</h1><h2 id="介绍-95"><a href="#介绍-95" class="headerlink" title="介绍"></a>介绍</h2><p><strong>parted</strong> 是 GNU 组织开发的一个磁盘&#x2F;硬盘分区操作的程序。它支持多种分区表格式，包括 MS-DOS 和 GPT。可用于为新操作系统创建空间、重新组织磁盘使用（例如调整分区大小）以及将数据复制到新硬盘等操作。</p>
<p>与 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/fdisk/">fdisk</a> 命令不同，parted 支持调整分区的大小，作为一种设计用于 GNU&#x2F;Linux 的工具，它没有构建成处理与 fdisk 关联的多种分区类型。但是，parted 可以处理最常见的分区格式，包括：ext2、ext3、fat16、fat32、NTFS、ReiserFS、JFS、XFS、UFS、HFS 以及 Linux 交换分区。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">parted [options] [device [<span class="built_in">command</span> [options...]...]]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-l</code>, <code>--list</code>：列出所有块设备的分区配置。</li>
<li><code>-m</code>, <code>--machine</code>：显示机器可解析的输出。</li>
<li><code>-s</code>, <code>--script</code>：从不提示用户。</li>
<li><code>-a</code>, <code>--align=[none|cyl|min|opt]</code>：新分区的对齐。</li>
<li><code>-h</code>, <code>--help</code>：打印帮助信息。</li>
<li><code>-v</code>, <code>--version</code>：显示版本信息。</li>
</ul>
<p><strong>命令</strong>：</p>
<ul>
<li><code>align-check &lt;type&gt; &lt;partition&gt;</code>：检查分区是否满足类型的对齐约束。类型 type 必须是”minimal”（最小）或 “optimal”（最佳）之一。</li>
<li><code>mklabel &lt;label-type&gt;</code>：创建新的磁盘卷标（分区表）。</li>
<li><code>mkpart [part-type name fs-type] start end</code>：在起始点和结束点之间创建一个分区。</li>
<li><code>name &lt;partition&gt; &lt;name&gt;</code>：将指定“分区编号”的分区命名为“名称”。</li>
<li><code>print [devices|free|list,all|数字]</code>：显示分区表、可用设备、剩余空间、所有分区或特殊分区。</li>
<li><code>quit</code>：退出程序。</li>
<li><code>rescue &lt;start&gt; &lt;end&gt;</code>：挽救临近“起始点”、“终止点”的遗失的分区。</li>
<li><code>resizepart &lt;partition&gt; &lt;end&gt;</code>：改变分区的大小。</li>
<li><code>rm &lt;NUMBER&gt;</code>：删除编号为 <code>NUMBER</code> 的分区。</li>
<li><code>select &lt;device&gt;</code>：选择要编辑的设备。</li>
<li><code>set &lt;partition&gt; &lt;flag&gt; &lt;state&gt;</code>：改变指定“编号”分区的标志。</li>
<li><code>toggle &lt;partition&gt; &lt;flag&gt;</code>：切换“编号”分区上的“标志”状态。</li>
<li><code>unit &lt;unit&gt;</code>：设置缺省的“单位”。</li>
</ul>
<h2 id="示例-95"><a href="#示例-95" class="headerlink" title="示例"></a>示例</h2><p>直接输入 <code>parted</code> 命令，默认选择系统中可用的第一个硬盘驱动器（如 &#x2F;dev&#x2F;sda），执行该命令需要 root 权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> parted </span><br><span class="line">GNU Parted 3.3</span><br><span class="line">使用 /dev/sda</span><br><span class="line">欢迎使用 GNU Parted！输入 <span class="string">&#x27;help&#x27;</span> 来查看命令列表。</span><br><span class="line">(parted) </span><br></pre></td></tr></table></figure>



<p>查看指定硬盘中所有可用的分区，显示硬盘属性，如型号、大小、扇区大小和分区表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> parted /dev/sda <span class="built_in">print</span></span><br><span class="line">型号：ATA RD-S325MMN-M01T4 (scsi)</span><br><span class="line">磁盘 /dev/sda: 1014GB</span><br><span class="line">扇区大小 (逻辑/物理)：512B/512B</span><br><span class="line">分区表：msdos</span><br><span class="line">磁盘标志：</span><br><span class="line"></span><br><span class="line">编号  起始点  结束点  大小    类型     文件系统  标志</span><br><span class="line"> 1    1049kB  1014GB  1014GB  primary  ext4</span><br></pre></td></tr></table></figure>





<h1 id="Linux-fsck-命令-检查和修复文件系统"><a href="#Linux-fsck-命令-检查和修复文件系统" class="headerlink" title="Linux fsck 命令 - 检查和修复文件系统"></a>Linux fsck 命令 - 检查和修复文件系统</h1><h2 id="介绍-96"><a href="#介绍-96" class="headerlink" title="介绍"></a>介绍</h2><p><strong>fsck</strong>（英文全拼：file system check）命令用于检查与修复 Linux 文件系统，并且可以同时检查一个或多个 Linux 文件系统。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fsck [-sACVRP] [-t fstype] [--] [fsck-options] filesys [...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>：自动修复文件系统，不询问任何问题。</li>
<li><code>-A</code>：依照 &#x2F;etc&#x2F;fstab 配置文件的内容，检查文件内所列的全部文件系统。</li>
<li><code>-N</code>：不执行指令，仅列出实际执行会进行的动作。</li>
<li><code>-P</code>：当搭配 “<code>-A</code>“ 参数使用时，则会同时检查所有的文件系统。</li>
<li><code>-r</code>：采用互动模式，在执行修复时询问问题，让用户得以确认并决定处理方式。</li>
<li><code>-R</code>：当搭配”-A”参数使用时，则会略过&#x2F;目录的文件系统不予检查。</li>
<li><code>-s</code>：依序执行检查作业，而非同时执行。</li>
<li><code>-t &lt;文件系统类型&gt;</code>：指定要检查的文件系统类型。</li>
<li><code>-T</code>：执行 fsck 指令时，不显示标题信息。</li>
<li><code>-V</code>：显示指令执行过程。</li>
</ul>
<p><strong>参数</strong>：指定文件系统 filesys，可以是设备名或挂载点。</p>
<h2 id="示例-96"><a href="#示例-96" class="headerlink" title="示例"></a>示例</h2><p>检查 msdos 文件系统的 &#x2F;dev&#x2F;hda5 是否正常，如果有异常便自动修复 :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> fsck -t msdos -a /dev/hda5</span><br></pre></td></tr></table></figure>



<p>Linux 的文件系统损坏会导致系统不正常关机，出错的时候如果系统提示是哪一块硬盘的分区有问题，比如是 &#x2F;dev&#x2F;hda2，接着就可以用如下的命令去对付它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> fsck -y /dev/hda2</span><br></pre></td></tr></table></figure>



<p>结束后使用 reboot 命令重启系统这样就好了！</p>
<p>如果不知道时哪个地方出了问题，可以直接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> fsck</span><br></pre></td></tr></table></figure>



<p>在随后的多个确认对话框中输入 <code>:y</code></p>
<p>结束后同样使用 reboot 命令重启系统这样就好了！</p>
<h1 id="Linux-sync-命令-同步文件系统缓存"><a href="#Linux-sync-命令-同步文件系统缓存" class="headerlink" title="Linux sync 命令 - 同步文件系统缓存"></a>Linux sync 命令 - 同步文件系统缓存</h1><h2 id="介绍-97"><a href="#介绍-97" class="headerlink" title="介绍"></a>介绍</h2><p><strong>sync</strong>（英文全拼：synchronize）命令用于数据同步，强制将内存缓冲区中的数据立即写入磁盘。</p>
<p>在 Linux&#x2F;Unix 系统中，在文件或数据处理过程中一般先放到内存缓冲区（filesystem buffer）中，等到适当的时候再写入磁盘，以提高系统的运行效率。</p>
<p>用户通常不需执行 sync 命令，系统会自动周期性执行 update 或 bdflush 操作，将缓冲区的数据写入磁盘。只有在 update 或 bdflush 无法执行或用户需要非正常关机时，才需手动执行 sync 命令。在关闭 Linux 系统时也会自动执行 sync 命令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sync</span> [OPTION] [FILE]...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-d, --data</code>：仅同步文件数据，不同步不需要的元数据（metadata）。</li>
<li><code>-f, --file-system</code>：同步包含文件的文件系统。</li>
<li><code>--help</code>：显示帮助信息。</li>
<li><code>--version</code>：显示版本信息。</li>
</ul>
<h2 id="示例-97"><a href="#示例-97" class="headerlink" title="示例"></a>示例</h2><p>手动的输入 sync 命令来真正地去写磁盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sync</span></span><br></pre></td></tr></table></figure>





<h1 id="Linux-rsync-命令-远程数据同步工具"><a href="#Linux-rsync-命令-远程数据同步工具" class="headerlink" title="Linux rsync 命令 - 远程数据同步工具"></a>Linux rsync 命令 - 远程数据同步工具</h1><h2 id="介绍-98"><a href="#介绍-98" class="headerlink" title="介绍"></a>介绍</h2><p><strong>rsync</strong>（英文全拼：remote synchronize）是 Linux 系统中的一个远程数据同步工具，可通过 LAN&#x2F;WAN 快速同步多台主机间的文件。需要注意的是，rsync 可以在本地主机和远程主机之间，或者在两个本地目录之间同步文件，但不支持两台远程主机之间的同步。</p>
<p>rsync 使用所谓的“rsync算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync [OPTION]... SRC [SRC]... DEST</span><br><span class="line">rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST</span><br><span class="line">rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST</span><br><span class="line">rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST</span><br><span class="line">rsync [OPTION]... [USER@]HOST:SRC [DEST]</span><br><span class="line">rsync [OPTION]... [USER@]HOST::SRC [DEST]</span><br><span class="line">rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-v</code>, <code>--verbose</code>：详细模式输出。</li>
<li><code>-q</code>, <code>--quiet</code>：精简输出模式。</li>
<li><code>-c</code>, <code>--checksum</code>：打开校验开关，强制对文件传输进行校验。</li>
<li><code>-a</code>, <code>--archive</code>：归档模式，表示以递归方式传输文件，并保持所有文件属性。</li>
<li><code>-r</code>, <code>--recursive</code>：对子目录以递归模式处理。</li>
<li><code>-R</code>, <code>--relative</code>：使用相对路径信息。</li>
<li><code>-b</code>, <code>--backup</code>：创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为 ~filename。可以使用 <code>--suffix</code> 选项来指定不同的备份文件前缀。</li>
<li><code>--backup-dir</code>：将备份文件（如 ~filename）存放在在目录下。</li>
<li><code>-suffix=SUFFIX</code>：定义备份文件前缀。</li>
<li><code>-u</code>, <code>--update</code>：仅仅进行更新，也就是跳过所有已经存在于 DST，并且文件时间晚于要备份的文件，不覆盖更新的文件。</li>
<li><code>-l</code>, <code>--links</code>：保留软链结。</li>
<li><code>-L</code>, <code>--copy-links</code>：想对待常规文件一样处理软链结。</li>
<li><code>--copy-unsafe-links</code>：仅仅拷贝指向 SRC 路径目录树以外的链结。</li>
<li><code>--safe-links</code>：忽略指向 SRC 路径目录树以外的链结。</li>
<li><code>-H</code>, <code>--hard-links</code>：保留硬链结。</li>
<li><code>-p</code>, <code>--perms</code>：保持文件权限。</li>
<li><code>-o</code>, <code>--owner</code>：保持文件属主信息。</li>
<li><code>-g</code>, <code>--group</code>：保持文件属组信息。</li>
<li><code>-D</code>, <code>--devices</code>：保持设备文件信息。</li>
<li><code>-t</code>, <code>--times</code>：保持文件时间信息。</li>
<li><code>-S</code>, <code>--sparse</code>：对稀疏文件进行特殊处理以节省 DST 的空间。</li>
<li><code>-n</code>, <code>--dry-run</code>：现实哪些文件将被传输。</li>
<li><code>-w</code>, <code>--whole-file</code>：拷贝文件，不进行增量检测。</li>
<li><code>-x</code>, <code>--one-file-system</code>：不要跨越文件系统边界。</li>
<li><code>-B</code>, <code>--block-size=SIZE</code>：检验算法使用的块尺寸，默认是 700 字节。</li>
<li><code>-e</code>, <code>--rsh=command</code>：指定使用rsh、ssh方式进行数据同步。</li>
<li><code>--rsync-path=PATH</code>：指定远程服务器上的rsync命令所在路径信息。</li>
<li><code>-C</code>, <code>--cvs-exclude</code>：使用和 CVS 一样的方法自动忽略文件，用来排除那些不希望传输的文件。</li>
<li><code>--existing</code>：仅仅更新那些已经存在于 DST 的文件，而不备份那些新创建的文件。</li>
<li><code>--delete</code>：删除那些 DST 中 SRC 没有的文件。</li>
<li><code>--delete-excluded</code>：同样删除接收端那些被该选项指定排除的文件。</li>
<li><code>--delete-after</code>：传输结束以后再删除。</li>
<li><code>--ignore-errors</code>：及时出现 IO 错误也进行删除。</li>
<li><code>--max-delete=NUM</code>：最多删除 NUM 个文件。</li>
<li><code>--partial</code>：保留那些因故没有完全传输的文件，以是加快随后的再次传输。</li>
<li><code>--force</code>：强制删除目录，即使不为空。</li>
<li><code>--numeric-ids</code>：不将数字的用户和组 ID 匹配为用户名和组名。</li>
<li><code>--timeout=time</code>：IP 超时时间，单位为秒。</li>
<li><code>-I</code>, <code>--ignore-times</code>：不跳过那些有同样的时间和长度的文件。</li>
<li><code>--size-only</code>：当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。</li>
<li><code>--modify-window=NUM</code>：决定文件是否时间相同时使用的时间戳窗口，默认为 0。</li>
<li>-T –temp-dir&#x3D;DIR：在 DIR 中创建临时文件。</li>
<li><code>--compare-dest=DIR</code>：同样比较 DIR 中的文件来决定是否需要备份。</li>
<li><code>-P</code>：等同于 <code>--partial</code>。</li>
<li><code>--progress</code>：显示备份过程。</li>
<li><code>-z</code>, <code>--compress</code>：对备份的文件在传输时进行压缩处理。</li>
<li><code>--exclude=PATTERN</code>：指定排除不需要传输的文件模式。</li>
<li><code>--include=PATTERN</code>：指定不排除而需要传输的文件模式。</li>
<li><code>--exclude-from=FILE</code>：排除 FILE 中指定模式的文件。</li>
<li><code>--include-from=FILE</code>：不排除 FILE 指定模式匹配的文件。</li>
<li><code>--version</code>：打印版本信息。</li>
<li><code>--address</code>：绑定到特定的地址。</li>
<li><code>--config=FILE</code>：指定其他的配置文件，不使用默认的 rsyncd.conf 文件。</li>
<li><code>--port=PORT</code>：指定其他的 rsync 服务端口。</li>
<li><code>--blocking-io</code>：对远程 shell 使用阻塞 I&#x2F;O。</li>
<li><code>--stats</code>：给出某些文件的传输状态。</li>
<li><code>--progress</code>：在传输时显示传输过程。</li>
<li><code>--log-format=formAT</code>：指定日志文件格式。</li>
<li><code>--password-file=FILE</code>：从 FILE 中得到密码。</li>
<li><code>--bwlimit=KBPS</code>：限制 I&#x2F;O 带宽，单位为 KBytes per second。</li>
<li><code>-h</code>, <code>--help</code>：显示帮助信息。</li>
</ul>
<h2 id="示例-98"><a href="#示例-98" class="headerlink" title="示例"></a>示例</h2><p>关联两个本地的目录，保持文件同步：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -r /Dir1 /Dir2</span><br></pre></td></tr></table></figure>



<p>列出本地指定目录内的文件列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync /Dir1</span><br></pre></td></tr></table></figure>



<p>将本地目录（&#x2F;web_root）与远程目录（192.168.1.10:&#x2F;web_root）相关联，保持文件同步：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -r /web_root 192.168.1.10:/web_root</span><br></pre></td></tr></table></figure>



<p>将远程目录（192.168.1.10:&#x2F;web_root）与本地目录（&#x2F;web_root）相关联，保持文件同步：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -r 192.168.1.10:/web_root /web_root</span><br></pre></td></tr></table></figure>





<h1 id="Linux-mkfs-命令-创建文件系统"><a href="#Linux-mkfs-命令-创建文件系统" class="headerlink" title="Linux mkfs 命令 - 创建文件系统"></a>Linux mkfs 命令 - 创建文件系统</h1><h2 id="介绍-99"><a href="#介绍-99" class="headerlink" title="介绍"></a>介绍</h2><p><strong>mkfs</strong>（英文全拼：make file system）命令用于在特定的分区上建立 Linux 文件系统。</p>
<p>mkfs 本身并不执行建立文件系统的工作，而是去调用相关的程序来执行。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs [options] [-t <span class="built_in">type</span>] [fs-options] device [size]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-t &lt;文件系统类型&gt;</code>：指定要建立何种文件系统，Linux 的默认值为 ext2。</li>
<li><code>-c</code>：在制作文件系统前，检查该分区是否有坏轨。</li>
<li><code>-l bad_blocks_file</code>：将有坏轨的 block 资料加到 bad_blocks_file 里面。</li>
<li><code>-V</code>：详细显示模式（如果不带参数则显示版本信息）。</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li><code>device</code>：指定要创建的文件系统对应的设备文件名。</li>
<li><code>size</code>：指定文件系统的磁盘块数。</li>
</ul>
<h2 id="示例-99"><a href="#示例-99" class="headerlink" title="示例"></a>示例</h2><p>在 <code>/dev/hda5</code> 上建一个 msdos 的文件系统，同时检查是否有坏轨存在，并且将过程详细列出来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> mkfs -V -t msdos -c /dev/hda5</span><br></pre></td></tr></table></figure>



<p>将 sdb1 分区格式化为 ext3 格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> mfks -t ext3 /dev/sdb1</span><br></pre></td></tr></table></figure>



<p>将 sdb1 分区格式化为 ext3 格式，并检查坏轨，且详细显示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> mfks -V -t ext3 -c /dev/sdb1</span><br></pre></td></tr></table></figure>



<p><strong>注意</strong>：这里的文件系统是要指定的，比如 ext2、ext3、ext4、reiserfs、fat32、msdos 等。如果不想指定文件系统，可使用 mkfs.ext2、mkfs.ext3、mkfs.fat 等命令。</p>
<h1 id="Linux-dd-命令-数据复制和转换"><a href="#Linux-dd-命令-数据复制和转换" class="headerlink" title="Linux dd 命令 - 数据复制和转换"></a>Linux dd 命令 - 数据复制和转换</h1><h2 id="介绍-100"><a href="#介绍-100" class="headerlink" title="介绍"></a>介绍</h2><p><strong>dd</strong>（英文全拼：disk dump）命令用于读取、转换并输出数据。可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。</p>
<p>dd 命令功能很强大的，对于一些比较底层的问题，使用 dd 命令往往可以得到出人意料的效果。用的比较多的还是用 dd 来备份裸设备。</p>
<p>提示</p>
<p>裸设备（raw device，也称裸分区或原始分区）是一种没有经过格式化，不被 Linux 系统通过文件系统来读取的特殊块设备文件。裸设备不被操作系统直接管理，不经过文件系统的缓冲，直接由应用程序对它进行读写操作。因此 I&#x2F;O 效率更高，不少数据库都能通过使用裸设备作为存储介质来提高 I&#x2F;O 效率。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> [选项]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><p><code>if=&lt;文件&gt;</code>：输入文件名，即指定源文件。</p>
</li>
<li><p><code>of=&lt;文件&gt;</code>：输出文件名，即指定目的文件。</p>
</li>
<li><p><code>bs=&lt;字节数&gt;</code>：将 ibs（输入）与 obs（输出）设成指定的字节数。（bs 是 block size 的缩写）</p>
</li>
<li><p><code>ibs=&lt;字节数&gt;</code>：每次读取的字节数，即指定一个块的大小。</p>
</li>
<li><p><code>obs=&lt;字节数&gt;</code>：每次输出的字节数，即指定一个块的大小。</p>
</li>
<li><p><code>cbs=&lt;字节数&gt;</code>：转换时，每次只转换指定的字节数（即指定转换缓冲区大小）。</p>
</li>
<li><p><code>count=&lt;区块数&gt;</code>：仅读取指定的区块数，块大小等于 (i&#x2F;o)bs 指定的字节数。</p>
</li>
<li><p><code>skip=&lt;区块数&gt;</code>：一开始从输入文件读取时，跳过指定的区块数。</p>
</li>
<li><p><code>seek=&lt;区块数&gt;</code>：一开始写入到输出文件时，跳过指定的区块数。</p>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conv=&lt;关键字&gt;</span><br></pre></td></tr></table></figure>

<p>：指定文件转换的方式；关键字可以是：</p>
<ul>
<li>conversion：用指定的参数转换文件</li>
<li>ascii：转换 ebcdic 为 ascii</li>
<li>ebcdic：转换 ascii 为 ebcdic</li>
<li>ibm：转换 ascii 为 alternate ebcdic</li>
<li>block：把每一行转换为长度为 cbs，不足部分用空格填充</li>
<li>unblock：使每一行的长度都为 cbs，不足部分用空格填充</li>
<li>lcase：把大写字符转换为小写字符</li>
<li>ucase：把小写字符转换为大写字符</li>
<li>swap：交换输入的每对字节</li>
<li>noerror：出错时不停止</li>
<li>notrunc：不截短输出文件</li>
<li>sync：将每个输入块填充到 ibs 个字节，不足部分用空（NUL）字符补齐</li>
<li>fdatasync：在完成之前实际写入数据到输出文件</li>
<li>fsync：类似于 fdatasync，但同时会写入 metadata 元数据</li>
</ul>
</li>
<li><p><code>--help</code>：显示帮助信息。</p>
</li>
<li><p><code>--version</code>：显示版本信息。</p>
</li>
</ul>
<p>另外，块大小可以使用的计量单位如下表所示。</p>
<table>
<thead>
<tr>
<th>单元大小</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>字节（1B）</td>
<td>c</td>
</tr>
<tr>
<td>字节（2B）</td>
<td>w</td>
</tr>
<tr>
<td>块（512B）</td>
<td>b</td>
</tr>
<tr>
<td>千字节（1024B）</td>
<td>k</td>
</tr>
<tr>
<td>兆字节（1024KB）</td>
<td>M</td>
</tr>
<tr>
<td>吉字节（1024MB）</td>
<td>G</td>
</tr>
</tbody></table>
<h2 id="示例-100"><a href="#示例-100" class="headerlink" title="示例"></a>示例</h2><p>将 openwrt.img 写入 TF 卡（&#x2F;dev&#x2F;sdx）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/tmp/upload/openwrt.img of=/dev/sdx</span><br></pre></td></tr></table></figure>



<p>将 flash.bin 写入 TF 卡，并偏移 33 个区块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=flash.bin of=/dev/sdx bs=1k seek=33 conv=fsync</span><br></pre></td></tr></table></figure>



<p>创建一个 1M 大小的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=output.txt bs=1M count=1</span><br><span class="line">1+0 records <span class="keyword">in</span></span><br><span class="line">1+0 records out</span><br><span class="line">1048576 bytes (1.0 MB) copied, 0.006107 seconds, 172 MB/s</span><br></pre></td></tr></table></figure>



<p>该命令创建了一个 1M 大小的文件 output.txt。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">du</span> -sh output.txt </span><br><span class="line">1.1M    output.txt</span><br></pre></td></tr></table></figure>



<p>说明：<strong>&#x2F;dev&#x2F;zero</strong> 是一个字符设备，会不断返回 0 值字节（<code>\0</code>）。上述命令可用来测试内存操作速度。</p>
<p>将 testfile 文件中的所有英文字母转换为大写，然后转成为 testfile_1 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=testfile of=testfile_1 conv=ucase </span><br></pre></td></tr></table></figure>



<p>由标准输入设备读入字符串，并将字符串转换成大写后，再输出到标准输出设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> conv=ucase </span><br></pre></td></tr></table></figure>



<p>输入以上命令后按回车键，输入字符串，再按回车键，按组合键 Ctrl+D 退出，出现以下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">dd</span> conv=ucase</span><br><span class="line">hello, getiot.tech  <span class="comment"># 输入字符串后按回车键</span></span><br><span class="line">HELLO, GETIOT.TECH  <span class="comment"># 按组合键Ctrl+D退出，转换成大写结果</span></span><br><span class="line">记录了0+1 的读入</span><br><span class="line">记录了0+1 的写出</span><br><span class="line">19字节已复制，9.27639 s，0.0 kB/s</span><br></pre></td></tr></table></figure>



<h3 id="读写测试"><a href="#读写测试" class="headerlink" title="读写测试"></a>读写测试</h3><p>在 Linux 系统中，我们经常用 dd 命令使用 &#x2F;dev&#x2F;zero 和 &#x2F;dev&#x2F;null 设备来测试硬盘读写速度，配合 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/time/">time</a> 命令可以计算 dd 命令执行过程的资源使用情况（比如 cpu 时间）。</p>
<p><strong>测试硬盘写能力</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/testw.dbf bs=4k count=100000</span><br></pre></td></tr></table></figure>



<p>因为 &#x2F;dev&#x2F;zero 是一个伪设备，它只产生空字符流，对它不会产生 IO，所以，IO 都会集中在 of 文件中，of 文件只用于写，所以这个命令相当于测试磁盘的写能力。命令结尾添加 <code>oflag=direct</code> 将跳过内存缓存，添加 <code>oflag=sync</code> 将跳过 hdd 缓存。</p>
<p><strong>测试硬盘读能力</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sdb of=/dev/null bs=4k</span><br></pre></td></tr></table></figure>



<p>因为 &#x2F;dev&#x2F;sdb 是一个物理分区，对它的读取会产生 IO，&#x2F;dev&#x2F;null 是伪设备，相当于黑洞，of 到该设备不会产生 IO，所以，这个命令的 IO 只发生在 &#x2F;dev&#x2F;sdb 上，也相当于测试磁盘的读能力。（Ctrl+C 终止测试）</p>
<p><strong>测试同时读写能力</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sdb of=/testrw.dbf bs=4k</span><br></pre></td></tr></table></figure>



<p><strong>测试纯写入性能</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=<span class="built_in">test</span> bs=8k count=10000 oflag=direct</span><br></pre></td></tr></table></figure>



<p><strong>测试纯读取性能</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=<span class="built_in">test</span> of=/dev/null bs=8k count=10000 iflag=direct</span><br></pre></td></tr></table></figure>



<p>注意：dd 只能提供一个大概的测试结果，而且是连续 I&#x2F;O 而不是随机 I&#x2F;O，理论上文件规模越大，测试结果越准确。 同时，iflag&#x2F;oflag 提供 direct 模式，direct 模式是把写入请求直接封装成 I&#x2F;O 指令发到磁盘，非 direct 模式只是把数据写入到系统缓存就认为 I&#x2F;O 成功，并由操作系统决定缓存中的数据什么时候被写入磁盘。</p>
<h1 id="Linux-swapon-命令-启用交换空间"><a href="#Linux-swapon-命令-启用交换空间" class="headerlink" title="Linux swapon 命令 - 启用交换空间"></a>Linux swapon 命令 - 启用交换空间</h1><h2 id="介绍-101"><a href="#介绍-101" class="headerlink" title="介绍"></a>介绍</h2><p><strong>swapon</strong> 命令用于检查或启用 Linux 系统中用于分页和交换的设备和文件。</p>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/swapoff/">swapoff</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapon [options] [specialfile...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><p><code>-a</code>, <code>--all</code> ：使能所有在 &#x2F;etc&#x2F;fstab 中被标记为 “swap” 的块设备，带 “noauto” 选项的除外，已被用作 swap 的设备也将会默默跳过。</p>
</li>
<li><p><code>-d</code>, <code>--discard[=policy]</code> ：如果 swap 设备支持丢弃或修剪操作，则启用交换丢弃。这可能会提高某些固态设备的性能，但通常不会。该选项允许在两种可用的交换丢弃策略之间进行选择：</p>
<ul>
<li><code>--discard=once</code> 对整个交换区域执行一次丢弃操作；</li>
<li><code>--discard=pages</code> 在它们可用于重用之前异步丢弃已释放的交换页面。</li>
</ul>
<p>如果未选择任何策略，则默认行为是启用两种丢弃类型。 &#x2F;etc&#x2F;fstab 挂载选项discard、discard&#x3D;once 或discard&#x3D;pages 也可用于启用丢弃标志。</p>
</li>
<li><p><code>-e</code>, <code>--ifexists</code> ：默默跳过不存在的设备，&#x2F;etc&#x2F;fstab 挂载选项 “nofail” 也可用于跳过不存在的设备。</p>
</li>
<li><p><code>-f</code>, <code>--fixpgsz</code> ：如果交换空间的页面大小与当前运行内核的页面大小不匹配，则重新初始化（执行 mkswap）交换空间，mkswap 会初始化整个设备并且不检查坏块。</p>
</li>
<li><p><code>-h</code>, <code>--help</code> ：显示帮助信息并退出。</p>
</li>
<li><p><code>-L label</code> ：使用具有指定标签的分区（可以访问 &#x2F;proc&#x2F;partitions 获知）。</p>
</li>
<li><p><code>-o</code>, <code>--options opts</code> ：通过 fstab 兼容的逗号分隔字符串指定交换选项。</p>
</li>
<li><p><code>-p</code>, <code>--priority priority</code> ：指定 swap 设备的优先级。优先级是一个介于 -1 和 32767 之间的值，数字越大表示优先级越高，可以将 <code>pri=value</code> 添加到 &#x2F;etc&#x2F;fstab 的选项字段以与 <code>swapon -a</code> 一起使用，如果未定义优先级，则默认为 -1。</p>
</li>
<li><p><code>-s</code>, <code>--summary</code> ：按设备显示 swap 使用情况摘要，相当于 “cat &#x2F;proc&#x2F;swaps”。此输出格式已被弃用，使用 <code>--show</code> 能得到更好地控制输出数据。</p>
</li>
<li><p><code>--show[=column...]</code> ：显示可定义的交换区域表。</p>
</li>
<li><p><code>--output-all</code> ：输出所有可用的列。</p>
</li>
<li><p><code>--noheadings</code> ：显示 <code>--show</code> 输出时不要打印标题。</p>
</li>
<li><p><code>--raw</code> ：显示 <code>--show</code> 输出时忽略表格对齐。</p>
</li>
<li><p><code>--bytes</code> ：显示 <code>--show</code> 输出时以字节为单位，而不是用户友好的单位。</p>
</li>
<li><p><code>-U uuid</code> ：使用 uuid 指定磁盘分区。</p>
</li>
<li><p><code>-v</code>, <code>--verbose</code> ：详细模式。</p>
</li>
<li><p><code>-V</code>, <code>--version</code> ：显示版本信息并退出。</p>
</li>
</ul>
<p><strong>参数</strong>：指定的 swap 设备（分区、逻辑卷或文件）。</p>
<h2 id="示例-101"><a href="#示例-101" class="headerlink" title="示例"></a>示例</h2><p>读取 swap 区域的摘要信息（以千字节为单位）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swapon -s</span><br><span class="line">Filename          Type           Size          Used        Priority</span><br><span class="line">/dev/sdb5         partition      16438268      100352      -2</span><br></pre></td></tr></table></figure>



<p>禁用 &#x2F;dev&#x2F;sdb5 交换区域</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> swapoff /dev/sdb5</span><br></pre></td></tr></table></figure>



<p>再启用 &#x2F;dev&#x2F;sdb5 交换区域</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> swapon /dev/sdb5</span><br></pre></td></tr></table></figure>



<p>启用交换区域时可附加选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swapon -o pri=1,discard=pages,nofail /dev/sdb5</span><br></pre></td></tr></table></figure>





<h1 id="Linux-swapoff-命令-禁用交换空间"><a href="#Linux-swapoff-命令-禁用交换空间" class="headerlink" title="Linux swapoff 命令 - 禁用交换空间"></a>Linux swapoff 命令 - 禁用交换空间</h1><h2 id="介绍-102"><a href="#介绍-102" class="headerlink" title="介绍"></a>介绍</h2><p><strong>swapoff</strong> 命令用于关闭 Linux 系统中用于分页和交换的设备和文件。</p>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/swapon/">swapon</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapoff [-va] [specialfile...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>, <code>--all</code> ：禁用所有在 &#x2F;etc&#x2F;fstab 中被标记为 “swap” 的块设备。</li>
<li><code>-v</code>, <code>--verbose</code> ：详细模式。</li>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息并退出。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息并退出。</li>
</ul>
<p><strong>参数</strong>：指定的 swap 设备（分区、逻辑卷或文件）。</p>
<h2 id="示例-102"><a href="#示例-102" class="headerlink" title="示例"></a>示例</h2><p>查看当前 Linux 系统内存和 swap 区域情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ free -h</span><br><span class="line">            总计         已用        空闲      共享    缓冲/缓存    可用</span><br><span class="line">内存：     7.5Gi       2.8Gi       199Mi     282Mi   4.5Gi     4.1Gi</span><br><span class="line">交换：      15Gi        98Mi        15Gi</span><br></pre></td></tr></table></figure>



<p>查找 swap 对应的块设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> fdisk -l | grep swap</span><br><span class="line">/dev/sdb5       400003072  432879615   32876544  15.7G 82 Linux swap / Solaris</span><br></pre></td></tr></table></figure>



<p>关闭该交换区域</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> swapoff /dev/sdb5</span><br></pre></td></tr></table></figure>



<p>再次查看 swap 区域情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ free -h</span><br><span class="line">            总计         已用        空闲      共享    缓冲/缓存    可用</span><br><span class="line">内存：     7.5Gi       2.8Gi       145Mi     335Mi   4.5Gi     4.1Gi</span><br><span class="line">交换：        0B          0B          0B</span><br></pre></td></tr></table></figure>





<h1 id="Linux-chronyd-命令-Chrony-服务守护进程"><a href="#Linux-chronyd-命令-Chrony-服务守护进程" class="headerlink" title="Linux chronyd 命令 - Chrony 服务守护进程"></a>Linux chronyd 命令 - Chrony 服务守护进程</h1><h2 id="介绍-103"><a href="#介绍-103" class="headerlink" title="介绍"></a>介绍</h2><p><strong>chronyd</strong>（英文全拼：chrony daemon）是 Chrony 时间同步服务的守护进程。Chrony 是网络时间协议（NTP）的一种实现，也是一个类 Unix 系统上 ntpd 服务的替代品，包括 chronyc 客户端和 chronyd 服务端两部分。</p>
<p>chronyd 可以将时钟与 NTP 服务器、参考时钟（例如 GPS 接收器）同步，并通过 chronyc 使用手表和键盘进行手动输入。它还可以作为 NTPv4（RFC 5905）服务器和对等方运行，为网络中的其他计算机提供时间服务。</p>
<p>提示</p>
<p>如果在命令行上没有指定配置指令，chronyd 将从配置文件中读取它们，默认位置是 &#x2F;etc&#x2F;chrony&#x2F;chrony.conf。另外，chronyd 运行的消息和警告将记录到 syslog 系统日志中。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chronyd [-4|-6] [-n|-d] [-q|-Q] [-r] [-R] [-s] [-t TIMEOUT] [-f FILE|COMMAND...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-4</code>：使用此选项，主机名将仅解析为 IPv4 地址，并且仅创建 IPv4 套接字。</li>
<li><code>-6</code>：使用此选项，主机名将仅解析为 IPv6 地址，并且仅创建 IPv6 套接字。</li>
<li><code>-f file</code>：此选项可用于指定配置文件的备用位置（默认为 &#x2F;etc&#x2F;chrony&#x2F;chrony.conf）。</li>
<li><code>-n</code>：当在此模式下运行时，程序不会将自身与终端分离。</li>
<li><code>-d</code>：在此模式下运行时，程序不会将自身与终端分离，并且所有消息都将写入终端而不是系统日志。当 chronyd 编译时带有调试支持时，可以使用此选项两次来打印调试消息。</li>
<li><code>-l file</code>：此选项指定一个应该用于记录而不是系统日志或终端的文件。</li>
<li><code>-q</code>：当在此模式下运行时，chronyd 将设置一次系统时钟并退出。该模式下，它不会与终端分离。</li>
<li><code>-Q</code>：此选项与 <code>-q</code> 选项类似，不同之处在于它仅打印偏移量而不对时钟进行任何更正，并且它允许 chronyd 在没有 root 权限的情况下启动。</li>
<li><code>-r</code>：此选项将尝试重新加载，然后删除包含每个服务器和正在使用的参考时钟的示例历史记录的文件。这些文件应位于配置文件中 dumpdir 指令指定的目录中。如果你出于任何原因想要暂时停止并重新启动 chronyd，则此选项非常有用，例如安装新版本。但是，它只能用于内核可以维持时钟补偿但不受 chronyd 控制的系统（即 Linux、FreeBSD、NetBSD、Solaris 和 macOS 10.13 或更高版本）。</li>
<li><code>-R</code>：使用此选项时，将忽略 initstepslew 指令和使用正限制的 makestep 指令。该选项在重新启动 chronyd 时很有用，并且可以与 <code>-r</code> 选项结合使用。</li>
<li><code>-s</code>：此选项将从计算机的实时时钟（RTC）设置系统时钟或由 driftfile 指令指定的文件的最后修改时间。仅 Linux 支持实时时钟。如果与 <code>-r</code> 标志结合使用，chronyd 将在从 RTC 设置系统时钟后尝试保留旧样本。这可用于允许 chronyd 对系统重新启动期间的增益或丢失率执行长期平均，并且对于间歇性访问网络且在不使用时关闭的系统非常有用。为了使其正常工作，它依赖于 chronyd 能够确定计算机上次打开时 RTC 和系统时钟之间差异的准确统计数据。如果漂移文件的最后修改时间晚于当前时间和 RTC 时间，系统时间将被设置为它以恢复 chronyd 先前停止时的时间。这对于没有 RTC 或 RTC 损坏（例如没有电池）的计算机很有用。</li>
<li><code>-t timeout</code>：此选项设置超时（以秒为单位），超过此时间 chronyd 将退出。如果时钟不同步，它将以非零状态退出。这对于缩短等待测量的最大时间的 <code>-q</code> 或 <code>-Q</code> 选项很有用，或者与 <code>-r</code> 选项一起限制 chronyd 运行的时间，但仍然允许它调整系统时钟的频率。</li>
<li><code>-u user</code>：此选项设置 chronyd 在启动后将切换到的系统用户的名称，以放弃 root 权限。它覆盖用户指令（默认_chrony）。在 Linux 上，chronyd 需要在编译时支持 libcap 库。在 macOS 上，FreeBSD、NetBSD 和 Solaris chronyd 分叉为两个进程。子进程保留 root 权限，但只能代表父进程执行非常有限范围的特权系统调用。</li>
<li><code>-F level</code>：当 chronyd 编译为支持 Linux 安全计算（seccomp）工具时，此选项配置系统调用过滤器。在级别 1 中，当进行禁止的系统调用时，进程将被终止；在级别 -1 中，将抛出 <code>SIGSYS</code> 信号；在级别 0 中，过滤器被禁用（默认为 0）。建议仅当已知过滤器适用于安装 chrony 的系统版本时才启用过滤器，因为过滤器还需要允许从 chronyd 正在使用的库（例如 libc）以及库的不同版本或实现进行的系统调用 可能会进行不同的系统调用。如果过滤器缺少某些系统调用，即使在正常操作下，chronyd 也可能被终止。</li>
<li><code>-P priority</code>：在 Linux 上，此选项将以指定的优先级（必须在 0 到 100 之间）选择 <code>SCHED_FIFO</code> 实时调度程序。在 macOS 上，此选项的值必须为 0（默认值）以禁用线程时间限制策略，或为 1 以启用该策略。其他系统不支持此选项。</li>
<li><code>-m</code>：此选项会将 chronyd 锁定到 RAM 中，这样它就永远不会被调出。注意，此模式仅在 Linux 上受支持。</li>
<li><code>-x</code>：该选项禁用系统时钟的控制。chronyd 不会尝试对时钟进行任何调整。它将假设时钟自由运行，并且仍然跟踪其相对于估计真实时间的偏移和频率。此选项允许 chronyd 在无法调整或设置系统时钟（例如在某些容器中）的情况下运行，以便作为 NTP 服务器运行。当另一个进程控制系统时钟时，不建议运行 chronyd（带或不带 <code>-x</code>）。</li>
<li><code>-v</code>：打印 chronyd 的版本号并退出。</li>
</ul>
<h2 id="示例-103"><a href="#示例-103" class="headerlink" title="示例"></a>示例</h2><p>启动 chronyd 守护进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start chronyd</span><br></pre></td></tr></table></figure>



<p>停止 chronyd 守护进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop chronyd</span><br></pre></td></tr></table></figure>



<p>重新加载 chronyd 的配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl reload chronyd</span><br></pre></td></tr></table></figure>





<h1 id="Linux-chronyc-命令-Chrony-服务交互工具"><a href="#Linux-chronyc-命令-Chrony-服务交互工具" class="headerlink" title="Linux chronyc 命令 - Chrony 服务交互工具"></a>Linux chronyc 命令 - Chrony 服务交互工具</h1><h2 id="介绍-104"><a href="#介绍-104" class="headerlink" title="介绍"></a>介绍</h2><p><strong>chronyc</strong>（英文全称：chrony command-line）命令用于设置时间与时钟服务器的同步工作。Chrony 是 Linux 系统中一个用于保持系统时间与 NTP 时钟服务器或 GPS 同步的服务，chronyc 则是 chronyd 服务的配置工具。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chronyc [-h HOST] [-p PORT] [-n] [-c] [-d] [-4|-6] [-m] [COMMAND]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-4</code>：使用此选项，主机名将仅解析为 IPv4 地址。</li>
<li><code>-6</code>：使用此选项，主机名将仅解析为 IPv6 地址。</li>
<li><code>-n</code>：此选项禁用将 IP 地址解析为主机名，以避免缓慢的 DNS 查找。</li>
<li><code>-c</code>：此选项允许以逗号分隔值（CSV）格式打印报告。IP 地址不会解析为主机名，时间将打印为自纪元以来的秒数，并且以秒为单位的值不会转换为其他单位。</li>
<li><code>-d</code>：如果 chronyc 编译时带有调试支持，则此选项启用调试消息的打印。</li>
<li><code>-m</code>：通常，命令行上的所有参数都被解释为一个命令。使用此选项可以指定多个命令，每个参数都将被解释为一个完整的命令。</li>
<li><code>-h &lt;host&gt;</code>：此选项允许用户指定要联系运行 chronyd 程序的主机（或逗号分隔的地址列表）。这允许远程监控，而无需先通过 SSH 连接到另一台主机。默认是联系在运行 chronyc 的同一主机上运行的 chronyd。</li>
<li><code>-p &lt;port&gt;</code>：此选项允许用户指定目标 chronyd 用于其监控连接的 UDP 端口号。默认为 323；通常不需要改变。</li>
<li><code>-f &lt;file&gt;</code>：此选项将被忽略，仅用于兼容性目的。</li>
<li><code>-a</code>：此选项将被忽略，仅用于兼容性目的。</li>
<li><code>-v</code>：显示其版本号并退出。</li>
</ul>
<p><strong>常用命令</strong>：</p>
<ul>
<li><code>sources</code>：时间同步源</li>
<li><code>sourcestats</code>：时间同步源状态</li>
<li><code>-v</code>：详细信息模式</li>
</ul>
<h2 id="示例-104"><a href="#示例-104" class="headerlink" title="示例"></a>示例</h2><p>查看 chronyd 的状态信息，包括系统时钟的偏移和调整信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chronyc tracking </span><br><span class="line">Reference ID    : CA760151 (time.neu.edu.cn)</span><br><span class="line">Stratum         : 2</span><br><span class="line">Ref <span class="keyword">time</span> (UTC)  : Wed Apr 19 19:24:17 2023</span><br><span class="line">System <span class="keyword">time</span>     : 0.003332454 seconds slow of NTP <span class="keyword">time</span></span><br><span class="line">Last offset     : -0.003015077 seconds</span><br><span class="line">RMS offset      : 0.002894906 seconds</span><br><span class="line">Frequency       : 18.189 ppm fast</span><br><span class="line">Residual freq   : -0.488 ppm</span><br><span class="line">Skew            : 0.811 ppm</span><br><span class="line">Root delay      : 0.055464264 seconds</span><br><span class="line">Root dispersion : 0.002117821 seconds</span><br><span class="line">Update interval : 1031.6 seconds</span><br><span class="line">Leap status     : Normal</span><br></pre></td></tr></table></figure>



<p>显示与 chronyd 同步的 NTP 服务器的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chronyc sources</span><br><span class="line">210 Number of sources = 8</span><br><span class="line">MS Name/IP address         Stratum Poll Reach LastRx Last sample               </span><br><span class="line">===============================================================================</span><br><span class="line">^- prod-ntp-3.ntp4.ps5.cano&gt;     2  10   177   61m    -14ms[  -20ms] +/-  163ms</span><br><span class="line">^? prod-ntp-4.ntp1.ps5.cano&gt;     0   6     0     -     +0ns[   +0ns] +/-    0ns</span><br><span class="line">^? prod-ntp-3.ntp4.ps5.cano&gt;     0   6     0     -     +0ns[   +0ns] +/-    0ns</span><br><span class="line">^? prod-ntp-5.ntp4.ps5.cano&gt;     0   6     0     -     +0ns[   +0ns] +/-    0ns</span><br><span class="line">^* time.neu.edu.cn               1  10   377   169  +2287us[ -728us] +/-   28ms</span><br><span class="line">^+ 119.28.183.184                2  10   377   30m    +56us[-3936us] +/-   60ms</span><br><span class="line">^? 2001:67c:21bc:1e::123         0   6     0     -     +0ns[   +0ns] +/-    0ns</span><br><span class="line">^? 2603:c020:0:8369::feeb:d&gt;     0   6     0     -     +0ns[   +0ns] +/-    0ns</span><br></pre></td></tr></table></figure>





<h1 id="Linux-free-命令-显示内存使用情况"><a href="#Linux-free-命令-显示内存使用情况" class="headerlink" title="Linux free 命令 - 显示内存使用情况"></a>Linux free 命令 - 显示内存使用情况</h1><h2 id="介绍-105"><a href="#介绍-105" class="headerlink" title="介绍"></a>介绍</h2><p><strong>free</strong> 命令用于显示系统内存的使用情况，包括物理内存、交换内存（swap）和内核缓冲区（buffer）内存。其显示的信息来自 &#x2F;proc&#x2F;meminfo 文件。</p>
<p>在 Linux 系统监控的工具中，free 命令是最经常使用的命令之一。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free [options]</span><br></pre></td></tr></table></figure>



<p><strong>参数</strong>：</p>
<ul>
<li><code>-b</code>, <code>--bytes</code> ：以 Bytes 为单位显示内存使用情况。</li>
<li><code>-k</code>, <code>--kibi</code> ：以 Kibibytes 为单位显示内存使用情况（默认）。</li>
<li><code>-m</code>, <code>--mebi</code> ：以 Mebibytes 为单位显示内存使用情况。</li>
<li><code>-g</code>, <code>--gibi</code> ：以 Gibibytes 为单位显示内存使用情况。</li>
<li><code>--tebi</code> ：以 Tebibytes 为单位显示内存使用情况。</li>
<li><code>--pebi</code> ：以 Pebibytes 为单位显示内存使用情况。</li>
<li><code>--kilo</code> ：以 Kilobytes 为单位显示内存使用情况。</li>
<li><code>--mega</code> ：以 Megabytes 为单位显示内存使用情况。</li>
<li><code>--giga</code> ：以 Gigabytes 为单位显示内存使用情况。</li>
<li><code>--tera</code> ：以 Terabytes 为单位显示内存使用情况。</li>
<li><code>--peta</code> ：以 Petabytes 为单位显示内存使用情况。</li>
<li><code>-h</code>, <code>--human</code> ：以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。</li>
<li><code>-w</code>, <code>--wide</code> ：以 wide 模式显示，每行长度超过 80 个字符，buffers 和 cache 会分开两列显示。</li>
<li><code>-c</code>, <code>--count count</code> ：显示结果统计次数，需要结合 -s 选项。</li>
<li><code>-l</code>, <code>--lohi</code> ：显示详细的低和高内存统计信息。</li>
<li><code>-s</code>, <code>--seconds delay</code> ：以 delay 秒为间隔连续显示。</li>
<li><code>--si</code> ：使用 kilo、mega、giga 等（1000 倍）替代 kibi、mebi、gibi（1024 倍）。</li>
<li><code>-t</code>, <code>--total</code> ：增加一行显示列总计。</li>
<li><code>--help</code> ：显示帮助信息。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息。</li>
</ul>
<h2 id="示例-105"><a href="#示例-105" class="headerlink" title="示例"></a>示例</h2><p>显示系统内存使用情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ free</span><br><span class="line">            total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:      7887904     2914244     1405500      352828     3568160     4316020</span><br><span class="line">Swap:    16438268           0    16438268</span><br></pre></td></tr></table></figure>



<p>加上 -h 选项，输出的结果会友好很多</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ free -h</span><br><span class="line">            total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        7.5Gi       2.8Gi       1.3Gi       344Mi       3.4Gi       4.1Gi</span><br><span class="line">Swap:        15Gi          0B        15Gi</span><br></pre></td></tr></table></figure>



<p>输出内容解释：</p>
<ul>
<li><strong>Mem</strong> 行是内存的使用情况。</li>
<li><strong>Swap</strong> 行是交换空间的使用情况。</li>
<li><strong>total</strong> 列显示系统总计可用物理内存和交换空间大小。</li>
<li><strong>used</strong> 列显示已用的物理内存和交换空间。</li>
<li><strong>free</strong> 列显示还有多少空闲的物理内存和交换空间可以使用。</li>
<li><strong>shared</strong> 列显示共享内存大小。</li>
<li><strong>buff&#x2F;cache</strong> 列显示内核缓冲区&#x2F;页面高速缓存使用的组合内存。</li>
<li><strong>available</strong> 列显示还可以被应用程序使用的物理内存大小。</li>
</ul>
<p>每隔1秒打印一次内存使用情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ free -h -s 1</span><br></pre></td></tr></table></figure>



<p>利用 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/watch/">watch</a> 命令也能达到循环输出的效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ watch -n 1 free -h</span><br></pre></td></tr></table></figure>





<h1 id="Linux-pmap-命令-显示进程内存映射"><a href="#Linux-pmap-命令-显示进程内存映射" class="headerlink" title="Linux pmap 命令 - 显示进程内存映射"></a>Linux pmap 命令 - 显示进程内存映射</h1><h2 id="介绍-106"><a href="#介绍-106" class="headerlink" title="介绍"></a>介绍</h2><p><strong>pmap</strong>（英文全拼：process memory map）命令用于查看进程的内存映射。</p>
<p>pmap 实际上是一个 Sun OS 上的命令，Linux 仅支持其有限的功能。可以显示一个或多个进程的内存状态，其报告进程的地址空间和内存状态信息。对查看完整的进程地址空间很有帮助。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pmap [options] pid [...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-x</code>, <code>--extended</code> ：显示扩展格式。</li>
<li><code>-d</code>, <code>--device</code> ：显示设备格式。</li>
<li><code>-q</code>, <code>--quiet</code> ：不显示 header 和 footer 行。</li>
<li><code>-A</code>, <code>--range low,high</code> ：将给定范围内的结果限制为低地址和高地址范围。请注意，low 和 high 参数是用逗号分隔的单个字符串。</li>
<li><code>-X</code> ：显示比 -x 选项更多的详细信息。注意：格式根据 &#x2F;proc&#x2F;PID&#x2F;smaps 更改。</li>
<li><code>-XX</code> ：显示内核提供的一切。</li>
<li><code>-p</code>, <code>--show-path</code> ：在映射列中显示文件的完整路径。</li>
<li><code>-c</code>, <code>--read-rc</code> ：读取默认配置。</li>
<li><code>-C</code>, <code>--read-rc-from file</code> ：从文件 file 中读取配置。</li>
<li><code>-n</code>, <code>--create-rc</code> ：创建新的默认配置。</li>
<li><code>-N</code>, <code>--create-rc-to file</code> ：创建新的配置，并保存到文件。</li>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息并退出。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息并退出。</li>
</ul>
<p><strong>参数</strong>：进程 PID（可接多个参数）</p>
<h2 id="示例-106"><a href="#示例-106" class="headerlink" title="示例"></a>示例</h2><p>查看单一进程内存状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pmap 5969</span></span><br><span class="line">5969:   /usr/share/typora/Typora README.md</span><br><span class="line">0000315900000000     48K rw---   [ anon ]</span><br><span class="line">000031590000c000    208K -----   [ anon ]</span><br><span class="line">0000315900040000      4K rw---   [ anon ]</span><br><span class="line">0000315900041000      4K -----   [ anon ]</span><br><span class="line">0000315900042000     64K r-x--   [ anon ]</span><br><span class="line">...</span><br><span class="line">00007fc4383b8000     28K rw--- libepoxy.so.0.0.0</span><br><span class="line">00007fc4383bf000     16K r---- libcairo-gobject.so.2.11600.0</span><br><span class="line">00007fc4383c3000      8K r-x-- libcairo-gobject.so.2.11600.0</span><br><span class="line">00007fc4383c5000      8K r---- libcairo-gobject.so.2.11600.0</span><br><span class="line">00007fc4383c7000      4K ----- libcairo-gobject.so.2.11600.0</span><br><span class="line">00007fc4383c8000      8K r---- libcairo-gobject.so.2.11600.0</span><br><span class="line">00007fc4383ca000      4K rw--- libcairo-gobject.so.2.11600.0</span><br><span class="line">00007fc4383cb000     64K r---- libsystemd.so.0.28.0</span><br><span class="line">00007fc4383db000    468K r-x-- libsystemd.so.0.28.0</span><br><span class="line">00007fc438450000    148K r---- libsystemd.so.0.28.0</span><br><span class="line">00007fc438475000     12K r---- libsystemd.so.0.28.0</span><br><span class="line">00007fc438478000      4K rw--- libsystemd.so.0.28.0</span><br><span class="line">...</span><br><span class="line">00007fff3fc90000    132K rw---   [ stack ]</span><br><span class="line">00007fff3fcc8000     16K r----   [ anon ]</span><br><span class="line">00007fff3fccc000      8K r-x--   [ anon ]</span><br><span class="line">ffffffffff600000      4K --x--   [ anon ]</span><br><span class="line"> total          4931388K</span><br></pre></td></tr></table></figure>



<p>查看多进程内存状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pmap 5969 5972 5973</span></span><br></pre></td></tr></table></figure>



<p>以扩展形式显示进程内存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pmap -x 5969</span></span><br><span class="line">5969:   /usr/share/typora/Typora README.md</span><br><span class="line">Address           Kbytes     RSS   Dirty Mode  Mapping</span><br><span class="line">0000315900000000      48      48      48 rw---   [ anon ]</span><br><span class="line">000031590000c000     208       0       0 -----   [ anon ]</span><br><span class="line">0000315900040000       4       4       4 rw---   [ anon ]</span><br><span class="line">0000315900041000       4       0       0 -----   [ anon ]</span><br><span class="line">0000315900042000      64      64      64 r-x--   [ anon ]</span><br><span class="line">...</span><br><span class="line">00007fc4383b8000      28      28      28 rw--- libepoxy.so.0.0.0</span><br><span class="line">00007fc4383bf000      16      16       0 r---- libcairo-gobject.so.2.11600.0</span><br><span class="line">00007fc4383c3000       8       8       0 r-x-- libcairo-gobject.so.2.11600.0</span><br><span class="line">00007fc4383c5000       8       8       0 r---- libcairo-gobject.so.2.11600.0</span><br><span class="line">00007fc4383c7000       4       0       0 ----- libcairo-gobject.so.2.11600.0</span><br><span class="line">00007fc4383c8000       8       8       8 r---- libcairo-gobject.so.2.11600.0</span><br><span class="line">00007fc4383ca000       4       4       4 rw--- libcairo-gobject.so.2.11600.0</span><br><span class="line">00007fc4383cb000      64      64       0 r---- libsystemd.so.0.28.0</span><br><span class="line">00007fc4383db000     468      60       0 r-x-- libsystemd.so.0.28.0</span><br><span class="line">00007fc438450000     148       0       0 r---- libsystemd.so.0.28.0</span><br><span class="line">00007fc438475000      12      12      12 r---- libsystemd.so.0.28.0</span><br><span class="line">00007fc438478000       4       4       4 rw--- libsystemd.so.0.28.0</span><br><span class="line">...</span><br><span class="line">00007fff3fc90000     132      88      88 rw---   [ stack ]</span><br><span class="line">00007fff3fcc8000      16       0       0 r----   [ anon ]</span><br><span class="line">00007fff3fccc000       8       4       0 r-x--   [ anon ]</span><br><span class="line">ffffffffff600000       4       0       0 --x--   [ anon ]</span><br><span class="line">---------------- ------- ------- ------- </span><br><span class="line">total kB         4931388  163028   44052</span><br></pre></td></tr></table></figure>



<p>各字段说明如下：</p>
<ul>
<li>Address：内存开始地址；</li>
<li>Kbytes：占用内存的字节数（KB）；</li>
<li>RSS：保留内存的字节数（KB）；</li>
<li>Dirty：脏页的字节数（包括共享和私有的）（KB）；</li>
<li>Mode：内存的权限包括 read、write、execute、shared、private（写时复制）；</li>
<li>Mapping：占用内存的文件，或 [anon]（分配的内存）、[stack]（堆栈）。</li>
</ul>
<h1 id="Linux-vmstat-命令-统计虚拟内存情况"><a href="#Linux-vmstat-命令-统计虚拟内存情况" class="headerlink" title="Linux vmstat 命令 - 统计虚拟内存情况"></a>Linux vmstat 命令 - 统计虚拟内存情况</h1><h2 id="介绍-107"><a href="#介绍-107" class="headerlink" title="介绍"></a>介绍</h2><p><strong>vmstat</strong>（英文全拼：virtual memory statistics）命令用于统计 Linux 系统虚拟内存使用情况，可实时动态监视操作系统的虚拟内存、进程、CPU 活动。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vmstat [options] [delay [count]]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>delay</code> ：两次输出之间的延迟时间，如果未指定，则只打印一次报告（包含自启动以来的平均值）</li>
<li><code>count</code> ：统计次数（定义 delay 参数时生效），如果未指定，默认为无限次。</li>
<li><code>-a</code>, <code>--active</code> ：显示处于 active 和 inactive 状态的内存量。</li>
<li><code>-f</code>, <code>--forks</code> ：显示自启动以来的 forks 数，包括 <code>fork()</code>、<code>vfork()</code> 和 <code>clone()</code> 系统调用，相当于创建的任务总数。每个进程由一个或多个任务表示，具体取决于线程使用情况。该选项不支持重复显示。</li>
<li><code>-m</code>, <code>--slabs</code> ：显示 slab 信息。</li>
<li><code>-n</code>, <code>--one-header</code> ：在周期性输出时，只显示一次头部信息。</li>
<li><code>-s</code>, <code>--stats</code> ：显示各种事件计数器和内存统计信息的表格。该选项不支持重复显示。</li>
<li><code>-d</code>, <code>--disk</code> ：报告磁盘统计信息。</li>
<li><code>-D</code>, <code>--disk-sum</code> ：报告有关磁盘活动的一些摘要统计信息。</li>
<li><code>-p</code>, <code>--partition device</code> ：显示磁盘分区详细统计。</li>
<li><code>-S</code>, <code>--unit character</code> ：在 1000 (k)、1024 (K)、1000000 (m) 或 1048576 (M) 字节之间切换。注意：这不会改变 block (bi&#x2F;bo) 字段单位，这些字段始终以块为单位进行测量。</li>
<li><code>-t</code>, <code>--timestamp</code> ：在每一行后面附上时间戳。</li>
<li><code>-w</code>, <code>--wide</code> ：以宽模式输出（适用于具有更高内存量的系统），输出宽度超过每行 80 个字符。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息并退出。</li>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息并退出。</li>
</ul>
<h2 id="示例-107"><a href="#示例-107" class="headerlink" title="示例"></a>示例</h2><p>显示系统虚拟内存统计信息（连续输出 5 次，每次间隔 5 秒）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vmstat 5 5</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 1  0      0 407004 111360 308324    0    0  5039    30   65  243 12  6 78  4  0</span><br><span class="line"> 1  0      0 407508 111372 308328    0    0     0    42  980  762 26  1 73  0  0</span><br><span class="line"> 2  0      0 407256 111392 308332    0    0     0    47  974  749 26  1 73  0  0</span><br><span class="line"> 3  0      0 919572 111400 308340    0    0     0    28  818  680 13  2 85  0  0</span><br><span class="line"> 0  0      0 919288 111676 308428    0    0     0   614 1200 1325  1  3 97  0  0</span><br></pre></td></tr></table></figure>



<p>字段含义：</p>
<ul>
<li><p>Procs</p>
<p>（进程）</p>
<ul>
<li>r ：运行队列中进程数量</li>
<li>b ：等待 IO 的进程数量</li>
</ul>
</li>
<li><p>Memory</p>
<p>（内存）</p>
<ul>
<li>swpd ：使用虚拟内存大小</li>
<li>free ：可用内存大小</li>
<li>buff ：用作缓冲区的内存大小</li>
<li>cache ：用作缓存的内存大小</li>
</ul>
</li>
<li><p>Swap</p>
<ul>
<li>si ：每秒从交换区写到内存的大小</li>
<li>so ：每秒写入交换区的内存大小</li>
</ul>
</li>
<li><p>IO</p>
<p>（现在的 Linux 版本块的大小为 1024 bytes）</p>
<ul>
<li>bi ：每秒读取的块数</li>
<li>bo ：每秒写入的块数</li>
</ul>
</li>
<li><p>System</p>
<ul>
<li>in ：每秒中断数，包括时钟中断</li>
<li>cs ：每秒上下文切换数</li>
</ul>
</li>
<li><p>CPU</p>
<p>（以百分比表示）</p>
<ul>
<li>us ：用户进程执行时间（user time）</li>
<li>sy ：系统进程执行时间（system time）</li>
<li>id ：空闲时间（包括 IO 等待时间）（idle time）</li>
<li>wa ：等待 IO 时间（wait time）</li>
</ul>
</li>
</ul>
<h1 id="Linux-iostat-命令-显示-I-O-统计信息"><a href="#Linux-iostat-命令-显示-I-O-统计信息" class="headerlink" title="Linux iostat 命令 - 显示 I&#x2F;O 统计信息"></a>Linux iostat 命令 - 显示 I&#x2F;O 统计信息</h1><h2 id="介绍-108"><a href="#介绍-108" class="headerlink" title="介绍"></a>介绍</h2><p><strong>iostat</strong>（英文全拼：I&#x2F;O statistics）是 Linux 系统中用于查看系统的磁盘 I&#x2F;O（输入&#x2F;输出）统计信息的命令。它能够提供关于磁盘和 CPU 使用情况的详细报告，对于监控系统性能和磁盘活动非常有用。</p>
<p>和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/vmstat/">vmstat</a> 一样，iostat 也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。iostat 命令由 sysstat 软件包提供，使用前需要安装，安装命令如下。</p>
<ul>
<li>Debian&#x2F;Ubuntu</li>
<li>RedHat&#x2F;CentOS</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install sysstat</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iostat [选项] [间隔时间] [次数]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-c</code>：显示 CPU 使用情况。</li>
<li><code>-d</code>：显示磁盘活动情况。</li>
<li><code>-k</code>：以 KB 为单位显示磁盘活动情况。</li>
<li><code>-m</code>：以 MB 为单位显示磁盘活动情况。</li>
<li><code>-t</code>：在输出中添加时间戳。</li>
</ul>
<p><strong>间隔时间</strong>：指定报告之间的时间间隔，单位为秒。</p>
<p><strong>次数</strong>：指定生成报告的次数。</p>
<h2 id="示例-108"><a href="#示例-108" class="headerlink" title="示例"></a>示例</h2><p>显示整体系统的平均磁盘活动情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iostat </span><br><span class="line">Linux 5.14.0-1059-oem (Latitude-3420) 	2023年12月19日 	_x86_64_	(8 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %<span class="built_in">nice</span> %system %iowait  %steal   %idle</span><br><span class="line">           4.17    0.04    1.32    0.16    0.00   94.31</span><br><span class="line"></span><br><span class="line">Device             tps    kB_read/s    kB_wrtn/s    kB_dscd/s    kB_read    kB_wrtn    kB_dscd</span><br><span class="line">loop0             0.00         0.00         0.00         0.00         17          0          0</span><br><span class="line">loop1             0.01         0.26         0.00         0.00      30552          0          0</span><br><span class="line">nvme0n1          22.66       223.72       438.86         0.00   26153612   51304365          0</span><br><span class="line">sda               5.50        95.04       165.04         0.00   11110209   19294060          0</span><br><span class="line">sdb               0.02         0.24         0.01         0.00      27975       1368          0</span><br></pre></td></tr></table></figure>



<p>CPU 属性值说明：</p>
<ul>
<li><code>%user</code>：CPU 处在用户模式下的时间百分比。</li>
<li><code>%nice</code>：CPU 处在带 NICE 值的用户模式下的时间百分比。</li>
<li><code>%system</code>：CPU 处在系统模式下的时间百分比。</li>
<li><code>%iowait</code>：CPU 等待输入输出完成时间的百分比。</li>
<li><code>%steal</code>：管理程序维护另一个虚拟处理器时，虚拟 CPU 的无意识等待时间百分比。</li>
<li><code>%idle</code>：CPU 空闲时间百分比。</li>
</ul>
<p>提示</p>
<p>如果 <code>%iowait</code> 的值过高，表示硬盘存在 I&#x2F;O 瓶颈；<code>%idle</code> 值高，表示 CPU 较空闲；如果 <code>%idle</code> 值高但系统响应慢时，有可能是 CPU 等待分配内存，此时应加大内存容量。<code>%idle</code> 值如果持续低于 10，那么系统的 CPU 处理能力相对较低，表明系统中最需要解决的资源是 CPU。</p>
<p>显示磁盘活动详细信息（包括读取和写入速率、I&#x2F;O 等待时间等）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iostat -d</span><br></pre></td></tr></table></figure>



<p>显示 CPU 使用情况的报告（包括用户、系统和空闲时间）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iostat -c</span><br></pre></td></tr></table></figure>



<p>每 5 秒显示一次磁盘活动的详细报告：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iostat -d 5</span><br></pre></td></tr></table></figure>



<p>以 MB 为单位显示磁盘活动情况（而不是默认的块大小）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iostat -m</span><br></pre></td></tr></table></figure>





<h1 id="Linux-dmidecode-命令-读取-DMI-信息"><a href="#Linux-dmidecode-命令-读取-DMI-信息" class="headerlink" title="Linux dmidecode 命令 - 读取 DMI 信息"></a>Linux dmidecode 命令 - 读取 DMI 信息</h1><h2 id="介绍-109"><a href="#介绍-109" class="headerlink" title="介绍"></a>介绍</h2><p><strong>dmidecode</strong> 命令主要是通过 DMI 获取 Linux 主机的硬件信息。遵循 SMBIOS&#x2F;DMI 标准，输出的信息包括 BIOS、系统、主板、处理器、内存、缓存等等。</p>
<p>DMI（Desktop Management Interface）是帮助收集电脑系统信息的管理系统，它的主要组成部分是 MIF（Management InformationFormat）数据库，这个数据库包括了所有有关电脑系统和配件的信息。dmidecode 的工作原理就是将 DMI 数据库中的信息解码，以人类可读的文本方式显示出来。但由于 DMI 信息可以人为修改，因此里面的信息不一定是系统准确的信息。</p>
<p>DMI 信息的收集必须在严格遵照 SMBIOS 规范的前提下进行。SMBIOS（System Management BIOS）是主板或系统制造者以标准格式显示产品管理信息所需遵循的统一规范。SMBIOS 和 DMI 是由行业指导机构 Desktop Management Task Force (DMTF) 起草的开放性的技术标准，其中 DMI 设计适用于任何的平台和操作系统。DMI 充当了管理工具和系统层之间接口的角色，它建立了标准的可管理系统更加方便了电脑厂商和用户对系统的了解。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmidecode [OPTIONS]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-d</code>, <code>--dev-mem FILE</code> ：从设备文件（默认为 &#x2F;dev&#x2F;mem）读取信息。</li>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息。</li>
<li><code>-q</code>, <code>--quiet</code> ：输出尽可能少的信息。</li>
<li><code>-s</code>, <code>--string KEYWORD</code> ：只显示指定 DMI 字符串的信息。</li>
<li><code>-t</code>, <code>--type TYPE</code> ：只显示指定类型的条目。</li>
<li><code>-H</code>, <code>--handle HANDLE</code> ：只显示指定句柄的条目内容。</li>
<li><code>-u</code>, <code>--dump</code> ：显示未解码的原始条目内容。</li>
<li><code>--dump-bin FILE</code> ：将 DMI 数据转储到一个二进制文件中。</li>
<li><code>--from-dump FILE</code> ：从一个二进制文件读取 DMI 数据。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息。</li>
</ul>
<p><strong>关键字 KEYWORD 的合法字符串包括</strong>：</p>
<ul>
<li>bios-vendor</li>
<li>bios-version</li>
<li>bios-release-date</li>
<li>system-manufacturer</li>
<li>system-product-name</li>
<li>system-version</li>
<li>system-serial-number</li>
<li>system-uuid</li>
<li>baseboard-manufacturer</li>
<li>baseboard-product-name</li>
<li>baseboard-version</li>
<li>baseboard-serial-number</li>
<li>baseboard-asset-tag</li>
<li>chassis-manufacturer</li>
<li>chassis-type</li>
<li>chassis-version</li>
<li>chassis-serial-number</li>
<li>chassis-asset-tag</li>
<li>processor-family</li>
<li>processor-manufacturer</li>
<li>processor-version</li>
<li>processor-frequency</li>
</ul>
<p><strong>类型 TYPE 的合法字符串包括</strong>：</p>
<ul>
<li>bios</li>
<li>system</li>
<li>baseboard</li>
<li>chassis</li>
<li>processor</li>
<li>memory</li>
<li>cache</li>
<li>connector</li>
<li>slot</li>
</ul>
<h2 id="示例-109"><a href="#示例-109" class="headerlink" title="示例"></a>示例</h2><p>不带选项执行通常会输出所有的硬件信息（该命令需要 root 权限，请自行添加 sudo）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmidecode</span><br></pre></td></tr></table></figure>



<p>查看服务器型号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmidecode | grep &#x27;Product Name&#x27;</span><br></pre></td></tr></table></figure>



<p>查看主板的序列号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmidecode |grep &#x27;Serial Number&#x27;</span><br></pre></td></tr></table></figure>



<p>查看系统序列号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmidecode -s system-serial-number</span><br></pre></td></tr></table></figure>



<p>查看内存信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmidecode -t memory</span><br></pre></td></tr></table></figure>



<p>查看 BIOS 信息（对应 type 为 0）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmidecode -t 0</span><br></pre></td></tr></table></figure>



<p>以简洁形式输出所有硬件信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmidecode -q</span><br></pre></td></tr></table></figure>





<h1 id="Linux-smartctl-命令-管理-SMART-磁盘"><a href="#Linux-smartctl-命令-管理-SMART-磁盘" class="headerlink" title="Linux smartctl 命令 - 管理 SMART 磁盘"></a>Linux smartctl 命令 - 管理 SMART 磁盘</h1><h2 id="介绍-110"><a href="#介绍-110" class="headerlink" title="介绍"></a>介绍</h2><p><strong>smartctl</strong> 是用于 SMART 磁盘的控制和监视的一个实用程序。SMART 是 Self-Monitoring, Analysis and Reporting Technology 的缩写，即“自监控、分析和报告技术”，该技术内置于大多数 ATA&#x2F;SATA 和 SCSI&#x2F;SAS 硬盘驱动器和固态驱动器中。</p>
<p>SMART 的目的是监控硬盘的可靠性和预测硬盘故障，并进行不同类型的硬盘自检。smartctl 还支持一些与 SMART 无关的功能，在 Linux 物理服务器中非常有用。</p>
<p>smartctl 命令由 smartmontools 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install smartmontools</span><br></pre></td></tr></table></figure>



<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smartctl [options] device</span><br></pre></td></tr></table></figure>



<p><strong>选项：</strong></p>
<ul>
<li><code>-h</code>, <code>--help</code>, <code>--usage</code>：显示帮助信息并退出。</li>
<li><code>-V</code>, <code>--version</code>, <code>--copyright</code>, <code>--license</code>：打印许可证、版权和版本信息并退出。</li>
<li><code>-i</code>, <code>--info</code>：显示设备的身份信息。</li>
<li><code>--identify[=[w][nvb]]</code>：显示来自 IDENTIFY DEVICE 数据的字（words）和位（bits）。</li>
<li><code>-g NAME</code>, <code>--get=NAME</code>：获取设备设置。</li>
<li><code>-a</code>, <code>--all</code>：显示设备的所有 SMART 信息。</li>
<li><code>-x</code>, <code>--xall</code>：显示设备的所有信息。</li>
<li><code>--scan</code>：扫描设备。</li>
<li><code>--scan-open</code>：扫描设备并尝试打开每个设备。</li>
<li><code>-j</code>, <code>--json[=[cgiosuv]]</code>：以 JSON 格式打印输出。</li>
<li><code>-q TYPE</code>, <code>--quietmode=TYPE</code>：设置安静模式。</li>
<li><code>-d TYPE</code>, <code>--device=TYPE</code>：指定设备类型。</li>
<li><code>-T TYPE</code>, <code>--tolerance=TYPE</code>：设置宽容模式。</li>
<li><code>-b TYPE</code>, <code>--badsum=TYPE</code>：设置错误校验和的操作。</li>
<li><code>-r TYPE</code>, <code>--report=TYPE</code>：报告交易。</li>
<li><code>-n MODE[,STATUS]</code>, <code>--nocheck=MODE[,STATUS]</code>：如果是 never, sleep, standby, idle 模式则不检查。</li>
<li><code>-s VALUE</code>, <code>--smart=VALUE</code>：在设备上启用或禁用 SMART (on&#x2F;off)。</li>
<li><code>-o VALUE</code>, <code>--offlineauto=VALUE</code>：在设备上启用或禁用自动离线测试 (on&#x2F;off)。</li>
<li><code>-S VALUE</code>, <code>--saveauto=VALUE</code>：在设备上启用或禁用属性自动保存 (on&#x2F;off)。</li>
<li><code>-s NAME[,VALUE]</code>, <code>--set=NAME[,VALUE]</code>：启用或禁用设备设置 (on&#x2F;off)。</li>
<li><code>-H</code>, <code>--health</code>：显示设备 SMART 健康状态。</li>
<li><code>-c</code>, <code>--capabilities</code>：显示设备 SMART 功能。</li>
<li><code>-A</code>, <code>--attributes</code>：显示设备 SMART 供应商特定的属性和值。</li>
<li><code>-f FORMAT</code>, <code>--format=FORMAT</code>：设置属性的输出格式。</li>
<li><code>-l TYPE</code>, <code>--log=TYPE</code>：显示设备日志。</li>
<li><code>-v N,OPTION</code>, <code>--vendorattribute=N,OPTION</code>：设置供应商属性 N 的显示选项。</li>
<li><code>-F TYPE</code>, <code>--firmwarebug=TYPE</code>：使用固件错误解决方法。</li>
<li><code>-P TYPE</code>, <code>--presets=TYPE</code>：驱动器特定的预设。</li>
<li><code>-B [+]FILE</code>, <code>--drivedb=[+]FILE</code>：从 FILE 读取并替换（add）驱动器数据库（默认是 +&#x2F;etc&#x2F;smart_drivedb.h，然后是 &#x2F;var&#x2F;lib&#x2F;smartmontools&#x2F;drivedb&#x2F;drivedb.h）。</li>
<li><code>-t TEST</code>, <code>--test=TEST</code>：运行测试。</li>
<li><code>-C</code>, <code>--captive</code>：在捕获模式下进行测试（需要同时使用 -t 选项）。</li>
<li><code>-X</code>, <code>--abort</code>：中止设备上的任何非强制测试。</li>
</ul>
<h2 id="示例-110"><a href="#示例-110" class="headerlink" title="示例"></a>示例</h2><p>打印 &#x2F;dev&#x2F;sda 设备的所有 SMART 信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smartctl --all /dev/sda</span><br></pre></td></tr></table></figure>



<p>在第一个磁盘上（&#x2F;dev&#x2F;sda）启用 SMART</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smartctl --smart=on --offlineauto=on --saveauto=on /dev/sda</span><br></pre></td></tr></table></figure>



<p>执行扩展磁盘自检</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smartctl --<span class="built_in">test</span>=long /dev/sda</span><br></pre></td></tr></table></figure>



<p>打印自检和属性错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smartctl --attributes --<span class="built_in">log</span>=selftest --quietmode=errorsonly /dev/sda</span><br></pre></td></tr></table></figure>



<p>打印 3ware RAID 控制器上第三个 ATA 磁盘的所有 SMART 信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smartctl --all --device=3ware,2 /dev/sda</span><br><span class="line">smartctl --all --device=3ware,2 /dev/twe0</span><br><span class="line">smartctl --all --device=3ware,2 /dev/twa0</span><br><span class="line">smartctl --all --device=3ware,2 /dev/twl0</span><br></pre></td></tr></table></figure>



<p>打印连接到第 1 个 HighPoint RAID 控制器第 1 个通道的第 3 个 PMPort 的 SATA 磁盘的所有 SMART 信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smartctl --all --device=hpt,1/1/3 /dev/sda</span><br></pre></td></tr></table></figure>



<p>打印 Areca RAID 控制器上第一个机箱的第三个 ATA 磁盘的所有 SMART 信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smartctl --all --device=areca,3/1 /dev/sg2</span><br></pre></td></tr></table></figure>





<h1 id="Linux-numactl-命令-设置-NUMA-策略"><a href="#Linux-numactl-命令-设置-NUMA-策略" class="headerlink" title="Linux numactl 命令 - 设置 NUMA 策略"></a>Linux numactl 命令 - 设置 NUMA 策略</h1><h2 id="介绍-111"><a href="#介绍-111" class="headerlink" title="介绍"></a>介绍</h2><p><strong>numactl</strong>（英文全拼：NUMA Control）命令用于查看当前服务器的 NUMA 节点配置和运行状态，可通过该工具将进程绑定到指定 CPU core，由指定 CPU core 来运行对应进程。</p>
<p>numactl 通常不会预先安装，但可在大多数 Linux 发行版的默认仓库中找到。例如，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install numactl</span><br></pre></td></tr></table></figure>



<p>安装完成后会有两个命令：<code>numactl</code> 和 <code>numastat</code></p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">numactl  [  --all ] [ --interleave nodes ] [ --preferred node ] [ --membind nodes ] </span><br><span class="line">         [ --cpunodebind nodes ] [ --physcpubind cpus ] [ --localalloc ] [--] <span class="built_in">command</span> &#123;arguments ...&#125;</span><br><span class="line">numactl --show</span><br><span class="line">numactl --hardware</span><br><span class="line">numactl [ --huge ] [ --offset offset ] [ --shmmode shmmode ] [ --length length ] [ --strict ]</span><br><span class="line">        [ --shmid <span class="built_in">id</span> ] --shm shmkeyfile | --file tmpfsfile</span><br><span class="line">        [ --<span class="built_in">touch</span> ] [ --dump ] [ --dump-nodes ] memory policy</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><p><code>--interleave=nodes</code>, <code>-i nodes</code>：这个选项用于设定内存的交织分配模式。也就是说系统在为多个节点分配内存空间的时候，将会以轮询分发的方式被分配给这多个节点。如果在当前众多的交织分配内存节点中的目标节点无法正确的分配内存空间的话，内存空间将会由其他的节点来分配。</p>
</li>
<li><p><code>--membind=nodes</code>, <code>-m nodes</code>：选项 <code>--membind</code> 仅用来从节点中分配内存空间所用。如果在这些节点中无法分配出所请求的空间大小的话该分配操作将会失败。</p>
</li>
<li><p><code>--cpunodebind=nodes</code>, <code>-N nodes</code>：上述命令仅用于施加在运行与 CPU 上的进程。这个命令用于显示 CPU 的个数，CPU 数目信息同样记录在系统中的存放处理器领域信息的 &#x2F;proc&#x2F;cpuinfo 文件夹下，或者是按照关联的 CPU 信息，在当前的 CPU 集中所存放。</p>
</li>
<li><p><code>--localalloc</code>, <code>-l</code>：这个命令选项通常是为当前的节点分配内存的。</p>
</li>
<li><p><code>--preferred=node</code>：该命令由于指定优先分配内存空间的节点，如果无法将空间分配给该节点的话，应该分配给该节点上的空间将会被分发到其他的节点上，该命令选项后面仅接收一个单独的节点标号。</p>
</li>
<li><p><code>--show</code>, <code>-s</code>：该命令用于显示 NUMA 机制作用在当前运行的那些进程上。</p>
</li>
<li><p><code>--hardware</code>, <code>-H</code>：该命令用于显示当前系统中有多少个可用的节点。</p>
</li>
<li><p><code>--huge</code>：当创建一个基于大内存页面的系统级的共享内存段的时候,使用 <code>--huge</code> 这个选项。<code>--huge</code> 选项仅在 <code>--shmid</code> 或是 <code>--shm</code> 命令的后面使用才有效。</p>
</li>
<li><p><code>--offset</code>：该参数选项用于指定共享内存段中的位移量的偏移。默认的情况下偏移量是 0 。有效的偏移量单位是 m、g、k，分别表示 MB、GB 和 KB，没有指定则被认为是以字节为单位。</p>
</li>
<li><p><code>--strict</code>：这个参数选项 当施加了 NUMA 调度机制的共享内存段区域的页面被施加了另一个机制而导致错误的时候，使用 <code>--strict</code> 选项将会把错误信息显示出来，默认情况是不使用该选项的。</p>
</li>
<li><p><code>--shmmode &lt;shmmode&gt;</code>：该选项仅在 <code>--shmid</code> 或是 <code>--shm</code> 之前使用才会生效。当创建一个共享内存段的时候，通过整型数值来指定共享内存的共享的模式类型。</p>
</li>
<li><p><code>--length &lt;length&gt;</code>：将策略应用于共享内存段中的长度范围或使段长度变长，默认是使用剩余长度，需要创建共享内存段时指定新段的长度。有效的单位是 m、g、k，分别表示 MB、GB 和 KB，没有指定则被认为是以字节为单位。</p>
</li>
<li><p><code>--shmid &lt;id&gt;</code>：通过 ID 号码来创建或使用一个共享内存段。(如果共享内存段已经存在，那么通过 shmid 来指定下面要使用某个 ID 的共享内存段 ; 如果该 ID 对应的共享内存段并不存在的话，那么就创建一个)。</p>
</li>
<li><p><code>--shm &lt;shmkeyfile&gt;</code>：通过存放在 shmkeyfile（共享内存-键文件）中的 ID 号码来创建或者是使用一个共享内存段。访问 shmkeyfile 文件的进程是通过 <code>fork(3 arguments)</code> 方法来实现的。</p>
</li>
<li><p><code>--file &lt;tmpfsfile&gt;</code>：将 NUMA 机制施加于文件上面，这个文件属于 tmpfs 或者是 hugetlbfs 这种特殊的文件系统。</p>
</li>
<li><p><code>--touch</code>：通过将 NUMA 机制施加于刚刚页面上来实现内存的早期 NUMA 化。默认情况下是不使用该选项，如果存在映射或是访问页面的应用的话，将会使用该早期实行 NUMA 机制的这种方法。</p>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--dump</span><br></pre></td></tr></table></figure>

<p>：该选项用于废除将已经 NUMA 化的特定区域上的 NUMA 性质。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--dump</span><br></pre></td></tr></table></figure>

<p>选项后面，有效指定 node 的书写方式为：</p>
<ul>
<li><code>all</code>：用于将所有的节点上的 NUMA 特性移除；</li>
<li><code>number</code>：通过指定 node 后接的数值来废除该数字对应的 node；</li>
<li><code>number1(number2)</code>：node number1（node number2）上的 NUMA 特性将会被移除；</li>
<li><code>number1-number2</code>：node number1 – node number2 区间上的所有存在的 node 的 NUMA 特性将会被移除；</li>
<li><code>!nodes</code>：除了 nodes 所指定的节点以外的所有节点上的 NUMA 特性全都会被移除。</li>
</ul>
</li>
</ul>
<h2 id="示例-111"><a href="#示例-111" class="headerlink" title="示例"></a>示例</h2><p>1、查看当前的 NUMA 运行状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ numastat</span><br><span class="line">                           node0</span><br><span class="line">numa_hit              2011064712</span><br><span class="line">numa_miss                      0</span><br><span class="line">numa_foreign                   0</span><br><span class="line">interleave_hit             47040</span><br><span class="line">local_node            2011064712</span><br><span class="line">other_node                     0</span><br></pre></td></tr></table></figure>



<p>字段说明：</p>
<ul>
<li><code>numa_hit</code> 表示节点内 CPU 核访问本地内存的次数。</li>
<li><code>numa_miss</code> 表示节点内核访问其他节点内存的次数。跨节点的内存访问会存在高延迟从而降低性能，因此 <code>numa_miss</code> 的值应当越低越好，如果过高，则应当考虑绑核。</li>
</ul>
<p>2、查看当前服务器的 NUMA 配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">numactl -H</span><br></pre></td></tr></table></figure>



<p>3、将应用程序 test 绑定到 0~7 核运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">numactl -C 0-7 ./test</span><br></pre></td></tr></table></figure>





<h1 id="Linux-export-命令-导出环境变量"><a href="#Linux-export-命令-导出环境变量" class="headerlink" title="Linux export 命令 - 导出环境变量"></a>Linux export 命令 - 导出环境变量</h1><h2 id="介绍-112"><a href="#介绍-112" class="headerlink" title="介绍"></a>介绍</h2><p><strong>export</strong> 是 Linux 系统中用于设置环境变量的命令，也是一个重要系统命令。环境变量是一种在操作系统级别上保存配置信息和可在不同进程之间共享的变量。使用 <code>export</code> 可以将变量从当前 shell 传递到其子 shell。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> [-fn] [NAME[=VALUE] ...]</span><br><span class="line"><span class="built_in">export</span> -p</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-f</code>：指 shell 函数。</li>
<li><code>-n</code>：删除每个 <code>NAME</code> 名称的导出属性。</li>
<li><code>-p</code>：显示所有导出的变量和函数的列表。</li>
</ul>
<p><code>export</code> 将标记每个 <code>NAME</code> 名称为自动导出到后续命令执行的环境。如果提供了 <code>VALUE</code> 则导出前将其作为赋值。</p>
<h2 id="示例-112"><a href="#示例-112" class="headerlink" title="示例"></a>示例</h2><p>创建一个名为 <code>MY_VARIABLE</code> 的环境变量，并将其值设置为 “Hello”：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> MY_VARIABLE=<span class="string">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>



<p>设置路径变量（<code>PATH</code>），将 <code>/usr/local/bin</code> 添加到现有的 <code>PATH</code> 环境变量中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/bin</span><br></pre></td></tr></table></figure>





<h1 id="Linux-unset-命令-取消环境变量"><a href="#Linux-unset-命令-取消环境变量" class="headerlink" title="Linux unset 命令 - 取消环境变量"></a>Linux unset 命令 - 取消环境变量</h1><h2 id="介绍-113"><a href="#介绍-113" class="headerlink" title="介绍"></a>介绍</h2><p><strong>unset</strong> 命令用于删除已定义的 shell 变量（包括环境变量）或函数的值和属性。注意，unset 命令不能够删除具有只读属性（参考 readonly）的 shell 变量和环境变量。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unset</span> [-f] [-v] [-n] [NAME ...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-f</code>：将每个 <code>NAME</code> 视为函数。</li>
<li><code>-v</code>：将每个 <code>NAME</code> 视为变量。</li>
<li><code>-n</code>：将每个 <code>NAME</code> 视为名称引用，只取消其本身而非其指向的变量。</li>
</ul>
<p><strong>参数</strong>：对每一个 <code>NAME</code> 名称，删除对应的变量或函数。</p>
<p>提示</p>
<p>unset 是 bash 内建命令，相关的帮助信息可通过命令 <code>help unset</code> 查看。</p>
<h2 id="示例-113"><a href="#示例-113" class="headerlink" title="示例"></a>示例</h2><p>先使用 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/export/">export</a> 创建一个环境变量 <code>GETIOT_ROOT</code> 及其对应的值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> GETIOT_ROOT=/opt/getiot</span><br></pre></td></tr></table></figure>



<p>查看 <code>GETIOT_ROOT</code> 环境变量的值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$GETIOT_ROOT</span></span><br><span class="line">/opt/getiot</span><br></pre></td></tr></table></figure>



<p>取消 <code>GETIOT_ROOT</code> 环境变量定义：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">unset</span> GETIOT_ROOT</span><br></pre></td></tr></table></figure>



<p>再次查看该环境变量可发现其值为空。</p>
<p>在 Shell 脚本编程中，通常使用 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/declare/">declare</a> 声明变量，例如声明一个整型变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -i paper_size=100</span><br></pre></td></tr></table></figure>



<p>删除该变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">unset</span> -v paper_size</span><br></pre></td></tr></table></figure>



<p>通过 function 创建一个 Shell 函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">function</span> <span class="function"><span class="title">show_result</span></span>()&#123; <span class="built_in">echo</span> <span class="string">&#x27;Last Command Return: $?&#x27;</span>; &#125;</span><br></pre></td></tr></table></figure>



<p>删除该函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">unset</span> -f show_result</span><br></pre></td></tr></table></figure>





<h1 id="Linux-env-命令-显示环境变量"><a href="#Linux-env-命令-显示环境变量" class="headerlink" title="Linux env 命令 - 显示环境变量"></a>Linux env 命令 - 显示环境变量</h1><h2 id="介绍-114"><a href="#介绍-114" class="headerlink" title="介绍"></a>介绍</h2><p><strong>env</strong> 是一个用于显示或设置环境变量的命令。在 Linux 系统中，它通常用于在运行命令时设置临时环境变量，以影响该命令的行为。</p>
<p>env 命令在脚本和命令行中非常有用，特别是当你想要在执行命令时设置特定的环境变量时。它提供了一种在不改变当前 shell 环境的情况下，临时修改环境变量的方法。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">env</span> [选项]... [-] [名称=值]... [命令 [参数]...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-i, --ignore-environment</code>：以空环境启动（清除所有环境变量）。</li>
<li><code>-0, --null</code>：以 <code>NUL</code> 空字符而非换行符结束每一输出行。</li>
<li><code>-u, --unset=名称</code>：从当前环境中移除一个变量。</li>
<li><code>-C, --chdir=目录</code>：将工作目录变更为指定目录。</li>
<li><code>-S, --split-string=S</code>：处理并将 <code>S</code> 拆分为单独的参数，用于在 shebang（<code>#!</code>）行上传递多个参数。</li>
<li><code>-v, --debug</code>：打印每个处理步骤的详细信息。</li>
<li><code>--help</code>：显示帮助信息并退出。</li>
<li><code>--version</code>：显示版本信息并退出。</li>
</ul>
<h2 id="示例-114"><a href="#示例-114" class="headerlink" title="示例"></a>示例</h2><p>显示当前 shell 的所有环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">env</span></span><br></pre></td></tr></table></figure>



<p>设置环境变量 <code>VAR</code> 的值为 <code>value</code>，然后运行 <code>command</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">env</span> VAR=value <span class="built_in">command</span></span><br></pre></td></tr></table></figure>



<p>清除所有环境变量，然后仅设置 <code>VAR</code> 变量，并运行 <code>command</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">env</span> -i VAR=value <span class="built_in">command</span></span><br></pre></td></tr></table></figure>



<p>移除指定环境变量，并运行 <code>command</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">env</span> -u VAR <span class="built_in">command</span></span><br></pre></td></tr></table></figure>





<h1 id="Linux-printenv-命令-打印环境变量"><a href="#Linux-printenv-命令-打印环境变量" class="headerlink" title="Linux printenv 命令 - 打印环境变量"></a>Linux printenv 命令 - 打印环境变量</h1><h2 id="介绍-115"><a href="#介绍-115" class="headerlink" title="介绍"></a>介绍</h2><p><strong>printenv</strong> 命令用于显示当前环境变量的值。它在 Linux 和 Unix 系统上广泛使用，允许用户查看当前 shell 进程中定义的所有环境变量。</p>
<p>注意</p>
<p>printenv 只能查看当前 shell 的环境变量，如果有子 shell 或新的进程，则它们将具有独立的环境。</p>
<p>和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/env/">env</a> 命令不同，<code>printenv</code> 主要用于显示环境变量，而不提供设置环境变量的功能。而 <code>env</code> 不仅可以显示环境变量，还可以在运行命令时设置环境变量。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printenv</span> [选项]... [变量]...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-0, --null</code>：以空字符而非换行符结束每一输出行。</li>
<li><code>--help</code>：显示帮助信息并退出。</li>
<li><code>--version</code>：显示版本信息并退出。</li>
</ul>
<p>如果没有指定变量，则打印出所有变量的名称和值。</p>
<h2 id="示例-115"><a href="#示例-115" class="headerlink" title="示例"></a>示例</h2><p>显示当前 shell 进程中定义的所有环境变量及其值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printenv</span></span><br></pre></td></tr></table></figure>



<p>显示环境变量 <code>PATH</code> 的值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printenv</span> PATH</span><br></pre></td></tr></table></figure>





<h1 id="Linux-passwd-命令-更改用户密码"><a href="#Linux-passwd-命令-更改用户密码" class="headerlink" title="Linux passwd 命令 - 更改用户密码"></a>Linux passwd 命令 - 更改用户密码</h1><h2 id="介绍-116"><a href="#介绍-116" class="headerlink" title="介绍"></a>介绍</h2><p>在 Linux 系统中，<strong>passwd</strong> 命令用于设置用户的认证信息，包括用户密码、账户锁定、密码失效等。直接运行 passwd 命令修改当前的用户密码，对其他用户的密码操作需要管理员权限。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd [选项] [用户名]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a, --all</code>：报告所有帐户的密码状态。</li>
<li><code>-d, --delete</code>：删除指定帐户的密码。</li>
<li><code>-e, --expire</code>：强制使指定帐户的密码过期。</li>
<li><code>-h, --help</code>：显示此帮助信息并推出。</li>
<li><code>-k, --keep-tokens</code>：仅在过期后修改密码。</li>
<li><code>-i, --inactive INACTIVE</code>：密码过期后设置密码不活动为 <code>INACTIVE</code>。</li>
<li><code>-l, --lock</code>：锁定指定的帐户。</li>
<li><code>-n, --mindays MIN_DAYS</code>：设置到下次修改密码所须等待的最短天数为 <code>MIN_DAYS</code>。</li>
<li><code>-q, --quiet</code>：安静模式。</li>
<li><code>-r, --repository REPOSITORY</code>：在 <code>REPOSITORY</code> 库中改变密码。</li>
<li><code>-R, --root CHROOT_DIR</code>：chroot 到的目录。</li>
<li><code>-S, --status</code>：报告指定帐户密码的状态。</li>
<li><code>-u, --unlock</code>：解锁被指定帐户。</li>
<li><code>-w, --warndays WARN_DAYS</code>：设置过期警告天数为 <code>WARN_DAYS</code>。</li>
<li><code>-x, --maxdays MAX_DAYS</code>：设置到下次修改密码所须等待的最多天数为 <code>MAX_DAYS</code>。</li>
</ul>
<h2 id="示例-116"><a href="#示例-116" class="headerlink" title="示例"></a>示例</h2><p>修改当前登陆的账户密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure>



<p>修改其他用户密码（假设有 getiot 用户）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd getiot</span><br></pre></td></tr></table></figure>



<p>锁定 getiot 用户密码，不允许修改其密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd -l getiot</span><br></pre></td></tr></table></figure>



<p>解除锁定 getiot 用户密码，允许修改其密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd -u getiot</span><br></pre></td></tr></table></figure>



<p>下次登录 getiot 账号时强制修改其密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd -e getiot</span><br></pre></td></tr></table></figure>



<p>清除登录 getiot 账号密码（清除之后登录时无需密码，风险极大）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd -d getiot</span><br></pre></td></tr></table></figure>



<p>查询密码状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd -S getiot</span><br></pre></td></tr></table></figure>





<h1 id="Linux-useradd-命令-添加新用户"><a href="#Linux-useradd-命令-添加新用户" class="headerlink" title="Linux useradd 命令 - 添加新用户"></a>Linux useradd 命令 - 添加新用户</h1><h2 id="介绍-117"><a href="#介绍-117" class="headerlink" title="介绍"></a>介绍</h2><p>在 Linux 系统中，<strong>useradd</strong> 命令用来创建新的用户或更改用户的信息。</p>
<p>useradd 可用来建立用户帐号，而当帐号建好之后，再通过 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/passwd/">passwd</a> 命令设定帐号的密码。使用 useradd 命令所建立的帐号，实际上是保存在 &#x2F;etc&#x2F;passwd 文本文件中。</p>
<p>提示</p>
<p>使用 <code>useradd</code> 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd [选项] 用户名</span><br><span class="line">useradd -D</span><br><span class="line">useradd -D [选项]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-b, --base-dir BASE_DIR</code>：新账户的主目录的基目录。</li>
<li><code>-c, --comment COMMENT</code>：新账户的 GECOS 字段。</li>
<li><code>-d, --home-dir HOME_DIR</code>：新账户的主目录。</li>
<li><code>-D, --defaults </code>：显示或更改默认的 useradd 配置。</li>
<li><code>-e, --expiredate EXPIRE_DATE</code>：新账户的过期日期。</li>
<li><code>-f, --inactive INACTIVE</code>：新账户的密码不活动期。</li>
<li><code>-g, --gid GROUP </code>：新账户主组的名称或 ID。</li>
<li><code>-G, --groups GROUPS</code>：新账户的附加组列表。</li>
<li><code>-h, --help</code>：显示帮助信息。</li>
<li><code>-k, --skel SKEL_DIR</code>：使用此目录作为骨架目录。</li>
<li><code>-K, --key KEY=VALUE</code>：不使用 &#x2F;etc&#x2F;login.defs 中的默认值。</li>
<li><code>-l, --no-log-init</code>：不要将此用户添加到最近登录和登录失败数据库。</li>
<li><code>-m, --create-home</code>：创建用户的主目录。</li>
<li><code>-M, --no-create-home </code>：不创建用户的主目录。</li>
<li><code>-N, --no-user-group</code>：不创建同名的组。</li>
<li><code>-o, --non-unique </code>：允许使用重复的 UID 创建用户。</li>
</ul>
<h2 id="示例-117"><a href="#示例-117" class="headerlink" title="示例"></a>示例</h2><p>创建新用户 getiot：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd getiot</span><br></pre></td></tr></table></figure>



<p>创建新用户 getiot，但不创建家目录，并且禁止登录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -M -s /sbin/nologin getiot</span><br></pre></td></tr></table></figure>



<p>创建新用户 getiot，并指定 UID 为 888，指定归属用户组为 root、dialout 成员，其 shell 类型为 &#x2F;bin&#x2F;sh：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -u 888 -s /bin/sh -G root,dialout getiot</span><br></pre></td></tr></table></figure>



<p>创建新用户 getiot，设置家目录为 &#x2F;data&#x2F;getiot，用户过期时间为 2030&#x2F;12&#x2F;31，过期后两天停权：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -e <span class="string">&quot;2030/12/31&quot;</span> -f 2 -d /data/getiot getiot</span><br></pre></td></tr></table></figure>





<h1 id="Linux-userdel-命令-删除用户"><a href="#Linux-userdel-命令-删除用户" class="headerlink" title="Linux userdel 命令 - 删除用户"></a>Linux userdel 命令 - 删除用户</h1><h2 id="介绍-118"><a href="#介绍-118" class="headerlink" title="介绍"></a>介绍</h2><p>在 Linux 系统中，<strong>userdel</strong> 命令用于删除指定的用户及与该用户相关的文件。在实现上，userdel 命令其实只是修改了系统的用户账号文件 &#x2F;etc&#x2F;passwd、&#x2F;etc&#x2F;shadow 以及 &#x2F;etc&#x2F;group 文件。这与 Linux系统“一切操作皆文件”的思想正好吻合。</p>
<p>值得注意的是，如果有该要删除用户相关的进程正在运行，userdel 命令通常不会删除该用户账号。如果确实必须要删除，建议先终止用户进程，然后再执行 userdel 命令进行删除。不过，userdel 命令也提供了一个面对这种情况的选项，即 <code>-f</code> 选项。</p>
<p>提示</p>
<p>使用 <code>userdel</code> 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">userdel [选项] 用户名</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-f, --force</code>：强制删除用户账号。</li>
<li><code>-r, --remove</code>：删除用户主目录及其中的所有文件。</li>
<li><code>-R, --root CHROOT_DIR</code>：chroot 到指定目录。</li>
<li><code>-Z, --selinux-user</code>：为用户删除所有的 SELinux 用户映射。</li>
<li><code>-h, --help</code>：显示帮助信息。</li>
</ul>
<h2 id="示例-118"><a href="#示例-118" class="headerlink" title="示例"></a>示例</h2><p>删除用户 getiot，但不删除其家目录及文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">userdel getiot</span><br></pre></td></tr></table></figure>



<p>删除用户 getiot，并将其家目录及文件一并删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">userdel -r getiot</span><br></pre></td></tr></table></figure>





<h1 id="Linux-usermod-命令-修改用户属性"><a href="#Linux-usermod-命令-修改用户属性" class="headerlink" title="Linux usermod 命令 - 修改用户属性"></a>Linux usermod 命令 - 修改用户属性</h1><h2 id="介绍-119"><a href="#介绍-119" class="headerlink" title="介绍"></a>介绍</h2><p>在 Linux 系统中，<strong>usermod</strong> 命令用于修改用户账号的各项设定。在实现上，usermod 命令其实只是修改了系统的用户账号文件 &#x2F;etc&#x2F;passwd、&#x2F;etc&#x2F;shadow 以及 &#x2F;etc&#x2F;group 文件。</p>
<p>usermod 命令不允许你改变正在线上的使用者帐号名称。另外，当 usermod 命令用来改变 user id，必须确认系统中没有该用户相关的进程正在运行。</p>
<p>提示</p>
<p>使用 <code>usermod</code> 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod [选项] 用户名</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-c, --comment 注释</code>：修改用户账号的备注文字（GECOS 字段）。</li>
<li><code>-d, --home HOME_DIR</code>：设置用户的新主目录。</li>
<li><code>-e, --expiredate EXPIRE_DATE</code>：设定帐户过期的日期为 <code>EXPIRE_DATE</code>。</li>
<li><code>-f, --inactive INACTIVE</code>：过期 <code>INACTIVE</code> 天数后，设定密码为失效状态。</li>
<li><code>-g, --gid GROUP</code>：强制使用 <code>GROUP</code> 为新主组。</li>
<li><code>-G, --groups GROUPS</code>：新的附加组列表 <code>GROUPS</code>。</li>
<li><code>-a, --append GROUP</code>：将用户追加至上边 <code>-G</code> 中提到的附加组中，并不从其它组中删除此用户。</li>
<li><code>-h, --help</code>：显示帮助信息。</li>
<li><code>-l, --login LOGIN</code>：设置新的登录名称。</li>
<li><code>-L, --lock</code>：锁定用户帐号。</li>
<li><code>-m, --move-home</code>：将家目录内容移至新位置（仅于 <code>-d</code> 一起使用）。</li>
<li><code>-o, --non-unique</code>：允许使用重复的（非唯一的）UID。</li>
<li><code>-p, --password PASSWORD</code>：将加密过的密码（<code>PASSWORD</code>）设为新密码。</li>
<li><code>-R, --root CHROOT_DIR</code>：chroot 到指定目录。</li>
<li><code>-s, --shell SHELL</code>：该用户帐号的新登录 shell。</li>
<li><code>-u, --uid UID</code>：用户帐号的新 UID。</li>
<li><code>-U, --unlock</code>：解锁用户帐号。</li>
<li><code>-v, --add-subuids FIRST-LAST</code>：添加子 UID 范围。</li>
<li><code>-V, --del-subuids FIRST-LAST</code>：移除子 UID 范围。</li>
<li><code>-w, --add-subgids FIRST-LAST</code>：添加子 GID 范围。</li>
<li><code>-W, --del-subgids FIRST-LAST</code>：移除子 GID 范围。</li>
<li><code>-Z, --selinux-user SEUSER</code>：用户账户的新 SELinux 用户映射。</li>
</ul>
<h2 id="示例-119"><a href="#示例-119" class="headerlink" title="示例"></a>示例</h2><p>更改用户 getiot 的家目录为 &#x2F;home&#x2F;linux：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -d /home/linux getiot</span><br></pre></td></tr></table></figure>



<p>将用户 getiot 添加到组 dialout 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -G dialout getiot</span><br></pre></td></tr></table></figure>



<p>修改 getiot 的用户名为 linux：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -l linux getiot</span><br></pre></td></tr></table></figure>



<p>锁定账号 getiot：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -L getiot</span><br></pre></td></tr></table></figure>



<p>解除对 getiot 的锁定：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -U getiot</span><br></pre></td></tr></table></figure>





<h1 id="Linux-groupadd-命令-添加用户组"><a href="#Linux-groupadd-命令-添加用户组" class="headerlink" title="Linux groupadd 命令 - 添加用户组"></a>Linux groupadd 命令 - 添加用户组</h1><h2 id="介绍-120"><a href="#介绍-120" class="headerlink" title="介绍"></a>介绍</h2><p><strong>groupadd</strong> 命令用于在 Linux 系统中创建新的用户组（group）。它允许系统管理员通过命令行创建和管理用户组。</p>
<p>提示</p>
<p>使用 <code>groupadd</code> 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd [选项] group</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-f, --force</code>：若用户组已存在，则以成功状态退出。</li>
<li><code>-g, --gid GID</code>：指定用户组的组 ID（GID）。如果不指定，系统将自动分配。</li>
<li><code>-h, --help</code>：显示帮助信息。</li>
<li><code>-K, --key KEY=VALUE</code>：设置新用户组的属性（覆盖配置文件 &#x2F;etc&#x2F;login.defs）。这允许管理员设置各种用户组属性。</li>
<li><code>-o, --non-unique</code>：允许使用重复的 GID。这在某些情况下可能有用。</li>
<li><code>-p, --password PASSWORD</code>：设置用户组密码。</li>
<li><code>-r, --system</code>：创建系统用户组。注意，系统工作组的组 ID 小于 500。</li>
<li><code>-R, --root CHROOT_DIR</code>：应用 <code>CHROOT_DIR</code> 目录中的更改并使用 <code>CHROOT_DIR</code> 目录中的配置文件。</li>
<li><code>-P, --prefix PREFIX_DIR</code>：应用 <code>PREFIX_DIR</code> 目录中的更改并使用 <code>PREFIX_DIR</code> 目录中的配置文件。此选项不会 chroot，旨在准备交叉编译目标。一些限制：NIS 和 LDAP 用户&#x2F;组未经过验证；PAM 身份验证使用主机文件；没有 SELINUX 支持。</li>
</ul>
<h2 id="示例-120"><a href="#示例-120" class="headerlink" title="示例"></a>示例</h2><p>创建一个名为 students 的新用户组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> groupadd students</span><br></pre></td></tr></table></figure>



<p>创建一个名为 students 的新用户组，并指定组 ID（GID）为 1001：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> groupadd -g 1001 students</span><br></pre></td></tr></table></figure>





<h1 id="Linux-groupdel-命令-删除用户组"><a href="#Linux-groupdel-命令-删除用户组" class="headerlink" title="Linux groupdel 命令 - 删除用户组"></a>Linux groupdel 命令 - 删除用户组</h1><h2 id="介绍-121"><a href="#介绍-121" class="headerlink" title="介绍"></a>介绍</h2><p><strong>groupdel</strong> 命令用于在 Linux 系统中删除指定用户组。它允许系统管理员通过命令行删除不再需要的用户组，本质上是修改的系统中的 &#x2F;ect&#x2F;group 和 &#x2F;ect&#x2F;gshadow 文件。</p>
<p>你可以使用 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/userdel/"><code>userdel</code></a> 命令修改系统用户文件，删除与 GROUP 相关的所有项目。需要注意的是，若该群组中仍包括某些用户，则必须先删除这些用户后，才能删除群组。</p>
<p>提示</p>
<p>使用 <code>groupdel</code> 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupdel [选项] GROUP</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-h, --help</code>：显示帮助信息并退出。</li>
<li><code>-R, --root CHROOT_DIR</code>：在 <code>CHROOT_DIR</code> 目录中应用更改并使用 <code>CHROOT_DIR</code> 目录中的配置文件。</li>
<li><code>-P, --prefix PREFIX_DIR</code>：应用 <code>PREFIX_DIR</code> 目录中的更改并使用 <code>PREFIX_DIR</code> 目录中的配置文件。此选项不会 chroot，旨在准备交叉编译目标。一些限制：NIS 和 LDAP 用户&#x2F;组未经过验证；PAM 身份验证使用主机文件；没有 SELINUX 支持。</li>
<li><code>-f, --force</code>：强制删除。</li>
</ul>
<h2 id="示例-121"><a href="#示例-121" class="headerlink" title="示例"></a>示例</h2><p>删除名为 students 的用户组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> groupdel students</span><br></pre></td></tr></table></figure>



<p>强制删除名为 students 的用户组，即使该组有用户成员：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> groupdel -f students</span><br></pre></td></tr></table></figure>





<h1 id="Linux-groupmod-命令-修改用户组"><a href="#Linux-groupmod-命令-修改用户组" class="headerlink" title="Linux groupmod 命令 - 修改用户组"></a>Linux groupmod 命令 - 修改用户组</h1><h2 id="介绍-122"><a href="#介绍-122" class="headerlink" title="介绍"></a>介绍</h2><p><strong>groupmod</strong> 命令用于在 Linux 系统中修改用户组的属性。通过 <code>groupmod</code> 命令，管理员可以更改用户组的名称或 GID（组 ID），以及其他一些属性。</p>
<p>不过建议大家不要随意修改用户名、组名和 GID，因为非常容易造成管理员逻辑混乱。如果非要修改用户名或组名，建议先删除旧的，再建立新的。</p>
<p>提示</p>
<p>使用 <code>groupmod</code> 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupmod [选项] GROUP</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-g, --gid GID</code>：将组 ID 改为 <code>GID</code>。</li>
<li><code>-h, --help</code>：显示帮助信息。</li>
<li><code>-n, --new-name NEW_GROUP</code>：将组名修改为 <code>NEW_GROUP</code>。</li>
<li><code>-o, --non-unique</code>：允许使用重复的 GID。</li>
<li><code>-p, --password PASSWORD</code>：将密码更改为（加密过的）<code>PASSWORD</code>。</li>
<li><code>-R, --root CHROOT_DIR</code>：在 <code>CHROOT_DIR</code> 目录中应用更改并使用 <code>CHROOT_DIR</code> 目录中的配置文件。</li>
<li><code>-P, --prefix PREFIX_DIR</code>：应用 <code>PREFIX_DIR</code> 目录中的更改并使用 <code>PREFIX_DIR</code> 目录中的配置文件。此选项不会 chroot，旨在准备交叉编译目标。一些限制：NIS 和 LDAP 用户&#x2F;组未经过验证；PAM 身份验证使用主机文件；没有 SELINUX 支持。</li>
</ul>
<h2 id="示例-122"><a href="#示例-122" class="headerlink" title="示例"></a>示例</h2><p>修改用户组的名称：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> groupmod -n newgroupname oldgroupname</span><br></pre></td></tr></table></figure>



<p>修改用户组的组 ID（GID）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> groupmod -g 1001 groupname</span><br></pre></td></tr></table></figure>





<h1 id="Linux-adduser-命令-添加新用户"><a href="#Linux-adduser-命令-添加新用户" class="headerlink" title="Linux adduser 命令 - 添加新用户"></a>Linux adduser 命令 - 添加新用户</h1><h2 id="介绍-123"><a href="#介绍-123" class="headerlink" title="介绍"></a>介绍</h2><p><strong>adduser</strong> 命令用于在 Linux 系统中添加新用户。在一些发行版中，<code>adduser</code> 实际上是 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/useradd/"><code>useradd</code></a> 命令的一个符号链接，而另一些发行版中，<code>adduser</code> 是一个对 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/useradd/"><code>useradd</code></a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/groupadd/"><code>groupadd</code></a> 和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/usermod/"><code>usermod</code></a> 命令进行封装的脚本程序，提供一些交互式的步骤以更方便地配置用户信息。大多数情况下，两者可以互相替代。</p>
<p>提示</p>
<p>使用 <code>adduser</code> 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adduser [options] user</span><br><span class="line">adduser [options] user group</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>--conf FILE</code>：使用指定的配置文件替代默认的 &#x2F;etc&#x2F;adduser.conf。</li>
<li><code>--disabled-login</code>：不要运行 <code>passwd</code> 来设置密码。在设置密码之前，用户将无法使用其帐户。</li>
<li><code>--disabled-password</code>：类似于 <code>--disabled-login</code> 选项，但仍然可以登录（例如使用 SSH RSA 密钥），但不能使用密码身份验证。</li>
<li><code>--force-badname</code>：默认情况下，将根据配置文件中指定的可配置正则表达式 <code>NAME_REGEX</code>（如果指定了 <code>--system</code>，则为 <code>NAME_REGEX_SYSTEM</code>）检查用户和组名称。此选项强制 adduser 和 addgroup 仅对名称的有效性应用弱检查。<code>NAME_REGEX</code> 在 adduser.conf 中描述。</li>
<li><code>--gecos GECOS</code>：为生成的新条目设置 gecos 字段。如果给出此选项，adduser 将不会询问指纹信息。</li>
<li><code>--gid ID</code>：创建组时，此选项强制新的组 ID 为给定的数字。创建用户时，此选项会将用户放入该组中。</li>
<li><code>--group</code>：与 <code>--system</code> 结合使用时，将创建与系统用户具有相同名称和 ID 的组。如果不与 <code>--system</code> 结合使用，则会创建具有给定名称的组。如果程序作为 addgroup 调用，则这是默认操作。</li>
<li><code>--help</code>：显示帮助信息。</li>
</ul>
<h2 id="示例-123"><a href="#示例-123" class="headerlink" title="示例"></a>示例</h2><p>添加名为 getiot 的新用户，并按照提示设置密码等信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> adduser getiot</span><br></pre></td></tr></table></figure>





<h1 id="Linux-deluser-命令-删除用户"><a href="#Linux-deluser-命令-删除用户" class="headerlink" title="Linux deluser 命令 - 删除用户"></a>Linux deluser 命令 - 删除用户</h1><h2 id="介绍-124"><a href="#介绍-124" class="headerlink" title="介绍"></a>介绍</h2><p>在许多 Linux 发行版中，<strong>deluser</strong> 是一个命令行工具，是对 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/userdel/"><code>userdel</code></a> 和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/groupdel/"><code>groupdel</code></a> 命令进行封装的脚本，用于删除系统中的用户账户。这个命令通常会删除用户的主目录以及与之相关的文件和组。</p>
<p>提示</p>
<p>使用 <code>deluser</code> 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deluser [options] user</span><br><span class="line">deluser [options] user group</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>--conf FILE</code>：使用 <code>FILE</code> 替代默认的 &#x2F;etc&#x2F;deluser.conf 和 &#x2F;etc&#x2F;adduser.conf 文件。</li>
<li><code>--group</code>：删除一个组。如果程序作为 delgroup 调用，则这是默认操作。</li>
<li><code>--help</code>：显示帮助信息。</li>
<li><code>--quiet</code>：禁止显示进度信息。</li>
<li><code>--system</code>：仅当用户&#x2F;组是系统用户&#x2F;组时才删除。这可以避免意外删除非系统用户&#x2F;组。此外，如果用户不存在，则不会返回错误值。该选项主要用于 Debian 软件包维护者脚本。</li>
<li><code>--only-if-empty</code>：仅在没有成员留下时才删除。</li>
<li><code>--backup</code>：将 userhome 和 mailspool 文件中包含的所有文件备份到名为 <code>/$user.tar.bz2</code> 或 <code>/$user.tar.gz</code> 的文件中。</li>
<li><code>--backup-to</code>：备份文件不放在 <code>/</code> 下，而是放在该参数指定的目录下。这也隐式设置了 <code>--backup</code>。</li>
<li><code>--remove-home</code>：删除用户的主目录及其邮件池。如果指定了 <code>--backup</code>，则执行备份后将删除文件。</li>
<li><code>--remove-all-files</code>：从该用户拥有的系统中删除所有文件。注意：<code>--remove-home</code> 不再起作用。如果指定了 <code>--backup</code>，则执行备份后将删除文件。</li>
<li><code>--version</code>：显示版本和版权信息。</li>
</ul>
<h2 id="示例-124"><a href="#示例-124" class="headerlink" title="示例"></a>示例</h2><p>删除用户 getiot（保留主目录）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> deluser getiot</span><br></pre></td></tr></table></figure>



<p>删除用户并删除主目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> deluser --remove-home getiot</span><br></pre></td></tr></table></figure>



<p>删除用户及其主目录和所有相关文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> deluser --remove-all-files getiot</span><br></pre></td></tr></table></figure>



<p>备份用户主目录并删除用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> deluser --backup getiot</span><br></pre></td></tr></table></figure>



<p>将用户从 students 组中删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> deluser getiot students</span><br></pre></td></tr></table></figure>





<h1 id="Linux-addgroup-命令-添加用户组"><a href="#Linux-addgroup-命令-添加用户组" class="headerlink" title="Linux addgroup 命令 - 添加用户组"></a>Linux addgroup 命令 - 添加用户组</h1><h2 id="介绍-125"><a href="#介绍-125" class="headerlink" title="介绍"></a>介绍</h2><p>在 Linux 系统中，<strong>addgroup</strong> 命令用于创建新的用户组（group）。<code>addgroup</code> 在不同的发行版中有不同的实现，它可能是 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/groupadd/"><code>groupadd</code></a> 的别名，也可能是一个脚本程序，可以更方便地创建用户组。</p>
<p>提示</p>
<p>使用 <code>addgroup</code> 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">addgroup [options] group</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>--quiet | -q</code>：不将进程信息发给 stdout。</li>
<li><code>--force-badname</code>：允许与 <code>NAME_REGEX[_SYSTEM]</code> 配置变量不匹配的用户名。</li>
<li><code>--extrausers</code>：使用额外的用户作为数据库。</li>
<li><code>--help | -h</code>：显示帮助信息。</li>
<li><code>--version | -v</code>：显示版本信息。</li>
<li><code>--conf | -c FILE</code>：使用 <code>FILE</code> 作为配置文件。</li>
</ul>
<h2 id="示例-125"><a href="#示例-125" class="headerlink" title="示例"></a>示例</h2><p>创建一个新用户组 students：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> addgroup students</span><br></pre></td></tr></table></figure>





<h1 id="Linux-delgroup-命令-删除用户组"><a href="#Linux-delgroup-命令-删除用户组" class="headerlink" title="Linux delgroup 命令 - 删除用户组"></a>Linux delgroup 命令 - 删除用户组</h1><h2 id="介绍-126"><a href="#介绍-126" class="headerlink" title="介绍"></a>介绍</h2><p>在 Linux 系统中，<strong>delgroup</strong> 命令用于删除用户组（group）。<code>delgroup</code> 在不同的发行版中有不同的实现，它可能是 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/groupdel/"><code>groupdel</code></a> 的别名，也可能是一个脚本程序，可以更方便地创建用户组。</p>
<p>提示</p>
<p>使用 <code>delgroup</code> 命令需要具有足够的权限，通常需要以超级用户（root）或具有 sudo 权限的用户身份运行。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">delgroup [options] [--only-if-empty] group</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>--quiet | -q</code>：不将进程信息发给 stdout。</li>
<li><code>--system</code>：只有当该用户组是系统用户组时才删除。</li>
<li><code>--only-if-empty</code>：只有当该用户组中无成员时才删除。</li>
<li><code>--help | -h</code>：显示帮助信息。</li>
<li><code>--version | -v</code>：显示版本信息。</li>
<li><code>--conf | -c FILE</code>：使用 <code>FILE</code> 作为配置文件。</li>
</ul>
<h2 id="示例-126"><a href="#示例-126" class="headerlink" title="示例"></a>示例</h2><p>删除 students 用户组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> addgroup students</span><br></pre></td></tr></table></figure>



<p>等效于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> deluser --group students</span><br></pre></td></tr></table></figure>





<h1 id="Linux-uptime-命令-显示系统运行时间"><a href="#Linux-uptime-命令-显示系统运行时间" class="headerlink" title="Linux uptime 命令 - 显示系统运行时间"></a>Linux uptime 命令 - 显示系统运行时间</h1><h2 id="介绍-127"><a href="#介绍-127" class="headerlink" title="介绍"></a>介绍</h2><p><strong>uptime</strong> 命令用于显示系统运行时间。</p>
<p>和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/who/">who</a> 命令一样，uptime 命令也会从 &#x2F;var&#x2F;run&#x2F;utmp 文件获取系统信息，也可以从 &#x2F;proc&#x2F;uptime 中读取。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uptime [options]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-p</code>, <code>--pretty</code> ：以漂亮的格式显示正常运行时间。</li>
<li><code>-s</code>, <code>--since</code> ：以 yyyy-mm-dd HH:MM:SS 格式显示系统启动时间。</li>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息。</li>
</ul>
<h2 id="示例-127"><a href="#示例-127" class="headerlink" title="示例"></a>示例</h2><p>显示系统运行时间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uptime</span></span> </span><br><span class="line"> 00:00:01 up  5:27,  1 user,  load average: 0.33, 0.40, 0.33</span><br></pre></td></tr></table></figure>



<p>以更便于阅读的格式显示系统运行时间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uptime</span> -p</span></span><br><span class="line">up 5 hours, 27 minutes</span><br></pre></td></tr></table></figure>



<p>显示系统启动时间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uptime</span> -s</span></span><br><span class="line">2021-04-30 18:32:54</span><br></pre></td></tr></table></figure>





<h1 id="Linux-time-命令-统计命令执行时间"><a href="#Linux-time-命令-统计命令执行时间" class="headerlink" title="Linux time 命令 - 统计命令执行时间"></a>Linux time 命令 - 统计命令执行时间</h1><h2 id="介绍-128"><a href="#介绍-128" class="headerlink" title="介绍"></a>介绍</h2><p><strong>time</strong> 命令用于计算特定指令执行时所需消耗的时间及系统资源等数据。例如 cpu 时间、内存、IO 资源等。</p>
<p>我们经常用 time 命令来计算某个程序的运行耗时（real），用户态 cpu 耗时（user），系统态 cpu 耗时（sys）。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">time [options] COMMAND [arguments]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-o</code>, <code>--output=FILE</code> ：指定结果输出文件。将 time 的输出写入文件中，如果文件已经存在，则覆盖其内容。</li>
<li><code>-a</code>, <code>--append</code> ：配合 <code>-o</code> 选项使用，将结果写入到文件的末端，而不会覆盖原有内容。</li>
<li><code>-f</code>, <code>--format FORMAT</code> ：以 FORMAT 格式字符串设定显示方式。如果没有指定，则使用系统预设的格式，亦可通过系统环境变量 <code>TIME</code> 来设定该格式。</li>
</ul>
<h2 id="示例-128"><a href="#示例-128" class="headerlink" title="示例"></a>示例</h2><p>直接执行 time 命令（显示 real、user、sys 时间）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="keyword">time</span></span></span><br><span class="line"></span><br><span class="line">real    0m0.000s</span><br><span class="line">user    0m0.000s</span><br><span class="line">sys     0m0.000s</span><br></pre></td></tr></table></figure>



<p>其中，real 表示程序运行耗时，user 表示用户态 cpu 耗时，sys 表示内核态 cpu 耗时。</p>
<p>计算 <code>sleep 2</code> 命令的执行时间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="keyword">time</span> <span class="built_in">sleep</span> 2</span></span><br><span class="line"></span><br><span class="line">real    0m2.004s</span><br><span class="line">user    0m0.001s</span><br><span class="line">sys     0m0.001s</span><br></pre></td></tr></table></figure>



<p>计算硬盘写测试所用的时间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">time dd if=/dev/zero of=testw.dbf bs=4k count=102400</span><br><span class="line">102400+0 records in</span><br><span class="line">102400+0 records out</span><br><span class="line">419430400 bytes (419 MB, 400 MiB) copied, 1.98527 s, 211 MB/s</span><br><span class="line"></span><br><span class="line">real    0m1.990s</span><br><span class="line">user    0m0.104s</span><br><span class="line">sys     0m1.866s</span><br></pre></td></tr></table></figure>



<p>注意：real time 表示时钟走过的时间，user time 表示程序在用户态占用 cpu 的时间，sys time 表示程序在内核态占用 cpu 的时间。real、user 和 sys 三者之间没有严格的关系，user + sys 不等于 real 时间，在多核系统中，user + sys 可能会大于 real 时间。</p>
<p>我们可以这样计算程序运行期间的 CPU 占用率：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">cpu_usage = (user_time + sys_time)/real_time * 100%</span></span><br></pre></td></tr></table></figure>





<h1 id="Linux-date-命令-显示-设置日期时间"><a href="#Linux-date-命令-显示-设置日期时间" class="headerlink" title="Linux date 命令 - 显示&#x2F;设置日期时间"></a>Linux date 命令 - 显示&#x2F;设置日期时间</h1><h2 id="介绍-129"><a href="#介绍-129" class="headerlink" title="介绍"></a>介绍</h2><p><strong>date</strong> 命令用于显示或设置 Linux 系统的日期和时间。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> [OPTION]... [+FORMAT]</span><br><span class="line"><span class="built_in">date</span> [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-d</code>, <code>--date=STRING</code> ：显示字符串所指的日期与时间，字符串前后必须加上双引号。</li>
<li><code>-s</code>, <code>--set=STRING</code> ：根据字符串来设置日期与时间，字符串前后必须加上双引号。</li>
<li><code>-u</code>, <code>--utc</code>, <code>--universal</code> ：以 UTC 时间显示或设置。</li>
<li><code>--help</code> ：显示帮助信息。</li>
<li><code>--version</code> ：显示版本信息。</li>
</ul>
<p><strong>参数</strong>：指定显示时使用的日期时间格式。</p>
<p>具体的日期格式字符串列表如下：</p>
<ul>
<li><code>%H</code> 小时，24小时制（00~23）</li>
<li><code>%I</code> 小时，12小时制（01~12）</li>
<li><code>%k</code> 小时，24小时制（0~23）</li>
<li><code>%l</code> 小时，12小时制（1~12）</li>
<li><code>%M</code> 分钟（00~59）</li>
<li><code>%p</code> 显示出 AM 或 PM</li>
<li><code>%r</code> 显示时间，12小时制（<code>hh:mm:ss %p</code>）</li>
<li><code>%s</code> 从1970年1月1日 00:00:00 到目前经历的秒数</li>
<li><code>%S</code> 显示秒（00~59）</li>
<li><code>%T</code> 显示时间，24小时制（<code>hh:mm:ss</code>）</li>
<li><code>%X</code> 显示时间的格式（<code>%H:%M:%S</code>）</li>
<li><code>%Z</code> 显示时区，日期域（CST）</li>
<li><code>%a</code> 显示星期的缩写（Sun~Sat）</li>
<li><code>%A</code> 显示星期的全称（Sunday~Saturday）</li>
<li><code>%h</code>, <code>%b</code> 显示月份的缩写（Jan~Dec）</li>
<li><code>%B</code> 显示月份的全称（January~December）</li>
<li><code>%c</code> 显示日期和时间（Tue Nov 20 14:12:58 2012）</li>
<li><code>%d</code> 显示一个月的第几天（01~31）</li>
<li><code>%x</code>, <code>%D</code> 显示日期（<code>mm/dd/yy</code>）</li>
<li><code>%j</code> 显示一年的第几天（001~366）</li>
<li><code>%m</code> 显示月份（01~12）</li>
<li><code>%w</code> 显示一个星期的第几天（0 代表星期天）</li>
<li><code>%W</code> 显示一年的第几个星期（00~53，星期一为第一天）</li>
<li><code>%y</code> 显示年份的最后两个数字（1999 则是 99）</li>
</ul>
<h2 id="示例-129"><a href="#示例-129" class="headerlink" title="示例"></a>示例</h2><p>显示当前日期（年、月、日）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">date</span> +<span class="string">&quot;%Y year %m month %d day&quot;</span></span><br><span class="line">2021 year 05 month 30 day</span><br></pre></td></tr></table></figure>



<p>显示昨天日期：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">date</span> -d <span class="string">&quot;1 day ago&quot;</span> +<span class="string">&quot;%Y-%m-%d&quot;</span></span><br><span class="line">2021-05-29</span><br></pre></td></tr></table></figure>



<p>显示前天日期：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;-2 day&quot;</span></span><br></pre></td></tr></table></figure>



<p>显示 30 秒后的时间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> -d <span class="string">&quot;30 second&quot;</span></span><br></pre></td></tr></table></figure>



<p>以指定时间显示（而不是当前时间）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> --<span class="built_in">date</span>=<span class="string">&quot;2060/01/01 08:00:00&quot;</span></span><br></pre></td></tr></table></figure>



<p>重新设定系统时间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> --<span class="built_in">set</span>=<span class="string">&quot;2060/01/01 08:00:00&quot;</span></span><br></pre></td></tr></table></figure>



<p>查看当前日期的时间戳：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> +%s</span><br></pre></td></tr></table></figure>



<p>查看指定日期的时间戳：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> -d <span class="string">&#x27;2020-12-01 00:00:00&#x27;</span> +%s</span><br></pre></td></tr></table></figure>



<p>将时间戳转换为时间显示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> -d @1669345425</span><br></pre></td></tr></table></figure>





<h1 id="Linux-dmesg-命令-显示内核消息"><a href="#Linux-dmesg-命令-显示内核消息" class="headerlink" title="Linux dmesg 命令 - 显示内核消息"></a>Linux dmesg 命令 - 显示内核消息</h1><h2 id="介绍-130"><a href="#介绍-130" class="headerlink" title="介绍"></a>介绍</h2><p><strong>dmesg</strong>（英文全拼：diagnostic messages）命令用于显示和控制 Linux 内核环形缓冲区中的信息。</p>
<p>kernel 会将开机信息存储在 ring buffer 中。开机时来不及查看的信息，后续可利用 dmesg 来仔细查看。同时，开机信息也会保存在 &#x2F;var&#x2F;log&#x2F;dmesg 文件里。</p>
<p>dmesg 中的 ‘d’ 通常被认为是 display 或 debug 的意思，但最开始的含义应该是 diagnostic，也就是诊断信息。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmesg [options]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-c</code>, <code>--read-clear</code> ：显示信息后，清除 ring buffer 中的内容。</li>
<li><code>-s</code>, <code>--buffer-size &lt;size&gt;</code> ：指定用于查询的缓冲区大小。预设置为 8196，刚好等于 ring buffer 的大小。</li>
<li><code>-n</code>, <code>--console-level &lt;level&gt;</code> ：设置记录信息的层级。</li>
<li><code>-k</code>, <code>--kernel</code> ：打印内核信息。</li>
<li><code>-H</code>, <code>--human</code> ：以便于人类阅读的方式输出。</li>
</ul>
<h2 id="示例-130"><a href="#示例-130" class="headerlink" title="示例"></a>示例</h2><p>输出所有诊断信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmesg</span><br></pre></td></tr></table></figure>



<p>上述命令输出的内容很多，不便于查看，可以加 <code>-H</code> 参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmesg -H</span><br></pre></td></tr></table></figure>



<p>通常可以使用管道配合其他工具查看，比如 more 分页显示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmesg | more</span><br></pre></td></tr></table></figure>



<p>按关键词搜索：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmesg | grep usb</span><br></pre></td></tr></table></figure>



<p>忽略大小写搜索关键词：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmesg | grep -i memory </span><br></pre></td></tr></table></figure>



<p>显示开机信息的前20行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmesg | head -20</span><br></pre></td></tr></table></figure>



<p>显示开机信息的最后20行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmesg | tail -20</span><br></pre></td></tr></table></figure>



<p>清空 dmesg 环形缓冲区中的日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmesg -c</span><br></pre></td></tr></table></figure>





<h1 id="Linux-uname-命令-显示系统信息"><a href="#Linux-uname-命令-显示系统信息" class="headerlink" title="Linux uname 命令 - 显示系统信息"></a>Linux uname 命令 - 显示系统信息</h1><h2 id="介绍-131"><a href="#介绍-131" class="headerlink" title="介绍"></a>介绍</h2><p><strong>uname</strong> 是一个 Linux 命令，用于显示操作系统和内核的相关信息，包括内核名称、操作系统类型、内核版本等。它是一个非常有用的工具，可以快速获取关于系统的基本信息。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname [OPTION]...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>, <code>--all</code>：显示所有信息，包括内核名称、主机名、内核版本、内核发布号、机器硬件名称、处理器类型、硬件平台和操作系统。</li>
<li><code>-s</code>, <code>--kernel-name</code>：显示内核名称。</li>
<li><code>-n</code>, <code>--nodename</code>：显示网络节点主机名。</li>
<li><code>-r</code>, <code>--kernel-release</code>：显示内核发布号。</li>
<li><code>-v</code>, <code>--kernel-version</code>：显示内核版本。</li>
<li><code>-m</code>, <code>--machine</code>：显示机器硬件名称。</li>
<li><code>-p</code>, <code>--processor</code>：显示处理器类型（有时是“unknown”）。</li>
<li><code>-i</code>, <code>--hardware-platform</code>：显示硬件平台（有时是“unknown”）。</li>
<li><code>-o</code>, <code>--operating-system</code>：显示操作系统名称。</li>
<li><code>--help</code>：显示帮助信息并退出。</li>
<li><code>--version</code>：显示版本信息并退出。</li>
</ul>
<h2 id="示例-131"><a href="#示例-131" class="headerlink" title="示例"></a>示例</h2><p>显示所有信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> -a</span><br><span class="line">Linux Latitude-3420 5.15.0-107-generic <span class="comment">#117~20.04.1-Ubuntu SMP Tue Apr 30 10:35:57 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure>



<p>显示操作系统名称：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> -o</span><br><span class="line">GNU/Linux</span><br></pre></td></tr></table></figure>



<p>显示内核名称：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> -s</span><br><span class="line">Linux</span><br></pre></td></tr></table></figure>



<p>显示内核发布号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> -r</span><br><span class="line">5.15.0-107-generic</span><br></pre></td></tr></table></figure>



<p>显示内核版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> -v</span><br><span class="line"><span class="comment">#117~20.04.1-Ubuntu SMP Tue Apr 30 10:35:57 UTC 2024</span></span><br></pre></td></tr></table></figure>



<p>显示网络节点主机名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> -n</span><br><span class="line">Latitude-3420</span><br></pre></td></tr></table></figure>



<p>显示机器硬件名称：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> -m</span><br><span class="line">x86_64</span><br></pre></td></tr></table></figure>



<p>显示处理器类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> -p</span><br><span class="line">x86_64</span><br></pre></td></tr></table></figure>



<p>显示硬件平台：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> -i</span><br><span class="line">x86_64</span><br></pre></td></tr></table></figure>





<h1 id="Linux-hwclock-命令-显示-设置硬件时钟"><a href="#Linux-hwclock-命令-显示-设置硬件时钟" class="headerlink" title="Linux hwclock 命令 - 显示&#x2F;设置硬件时钟"></a>Linux hwclock 命令 - 显示&#x2F;设置硬件时钟</h1><h2 id="介绍-132"><a href="#介绍-132" class="headerlink" title="介绍"></a>介绍</h2><p><strong>hwclock</strong>（英文全拼：hardware clock）命令用于显示与设定硬件时钟（RTC）。</p>
<p>在 Linux 系统中，有硬件时钟与系统时钟等两种时钟。硬件时钟保存在 RTC 中，由外置电池供电，系统掉电后仍会继续工作。在系统启动是，系统时钟会从硬件时钟获取，以便得到一个相对准确的时钟，之后系统时钟便独立工作，通常还会从 NTP 服务器同步更新时间。更新后的系统时间可以通过 hwclock 命令回写到硬件时钟。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hwclock [<span class="keyword">function</span>] [option...]</span><br></pre></td></tr></table></figure>



<p><strong>功能</strong>：</p>
<ul>
<li><code>-r</code>, <code>--show</code> ：读取硬件时钟，并按 ISO 8601 格式输出（默认功能）。</li>
<li><code>--get</code> ：读取硬件时钟，等效于 <code>--show</code>。</li>
<li><code>--set</code> ：根据 <code>--date</code> 选项给定的值设定硬件时钟。</li>
<li><code>-s</code>, <code>--hctosys</code> ：从硬件时钟设定系统时钟。</li>
<li><code>-w</code>, <code>--systohc</code> ：从系统时钟设定硬件时钟。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息并退出。</li>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息并退出。</li>
</ul>
<p><strong>选项</strong>：</p>
<ul>
<li><code>-D</code>, <code>--debug</code> ：显示 hwclock 执行时详细的信息（该选项已过时，建议使用 <code>--verbose</code>）。</li>
<li><code>--date=date_string</code> ：与 <code>--set</code> 功能一起使用，用于指定日期时间字符串。</li>
<li><code>--delay=seconds</code> ：此选项允许在设置时钟时间时覆盖内部使用的延迟。rtc_cmos 的默认值为 0.5 (500ms)，对于其他 RTC 类型，延迟为 0。如果 RTC 类型无法确定（从 sysfs），那么它也默认为 0.5 以向后兼容。</li>
<li><code>--directisa</code> ：hwclock 预设从 &#x2F;dev&#x2F;rtc 设备来存取硬件时钟。若无法存取时，可用此参数直接以 I&#x2F;O 指令来存取硬件时钟。</li>
<li><code>--test</code> ：仅测试程序，而不会实际更改硬件时钟。</li>
<li><code>-l</code>, <code>--localtime</code> ：使用本地时间进行设置。</li>
<li><code>-u</code>, <code>--utc</code> ：使用 UTC 时间进行设置。</li>
<li><code>-v</code>, <code>--verbose</code> ：显示 hwclock 执行时详细的信息。</li>
</ul>
<p>注意：hwclock 命令的功能（function）是互斥的，同一时间只能指定一个功能；选项（option）则可以灵活使用。</p>
<h2 id="示例-132"><a href="#示例-132" class="headerlink" title="示例"></a>示例</h2><p>使用硬件时钟作为参考（看作 UTC 时间），设置系统时钟：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hwclock --utc --hctosys</span><br></pre></td></tr></table></figure>



<p>将系统时钟回同步到硬件时钟（看作 UTC 时间）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hwclock --utc --systohc</span><br></pre></td></tr></table></figure>





<h1 id="Linux-screen-命令-多窗口终端"><a href="#Linux-screen-命令-多窗口终端" class="headerlink" title="Linux screen 命令 - 多窗口终端"></a>Linux screen 命令 - 多窗口终端</h1><h2 id="介绍-133"><a href="#介绍-133" class="headerlink" title="介绍"></a>介绍</h2><p><strong>screen</strong> 命令是一个多重视窗管理程序，这里的“视窗”是指一个全屏幕的文字模式画面。用户可以通过该软件同时连接多个本地或远程的命令行会话（通常是交互式 shell），并在其间自由切换。通常，在使用 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/telnet/">telnet</a> 登入主机或是使用老式的终端机时，才有可能用到 screen 程序。</p>
<p>使用前请确保你的系统上已经安装 screen 命令，如果未安装，可以参考下面安装方法：</p>
<ul>
<li>Debian&#x2F;Ubuntu</li>
<li>CentOS&#x2F;RHEL</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install screen</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen [-opts] [cmd [args]]</span><br><span class="line">screen -r [host.tty]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-A</code>：将所有的视窗都调整为目前终端机的大小。</li>
<li><code>-d</code>：将指定的 screen 作业离线。</li>
<li><code>-m</code>：即使目前已在作业中的 screen 作业，仍强制建立新的 screen 作业。</li>
<li><code>-r [session]</code>：恢复离线的 screen 作业。</li>
<li><code>-R</code>：先试图恢复离线的作业，若找不到离线的作业，即建立新的 screen 作业。</li>
<li><code>-s &lt;shell&gt;</code>：指定建立新视窗时，所要执行的 shell。</li>
<li><code>-S &lt;sockname&gt;</code>：指定 screen 作业的名称，使用 <code>&lt;pid&gt;.sockname</code> 代替 <code>&lt;pid&gt;.&lt;tty&gt;.&lt;host&gt;</code>。</li>
<li><code>-x</code>：恢复之前离线的 screen 作业。</li>
<li><code>-ls [match]</code>：显示目前所有的 screen 作业。</li>
<li><code>-list</code>：显示目前所有的 screen 作业。</li>
<li><code>-wipe</code>：检查目前所有的 screen 作业，并删除已经无法使用的 screen 作业。</li>
<li><code>-v</code>：显示版本信息。</li>
</ul>
<h2 id="示例-133"><a href="#示例-133" class="headerlink" title="示例"></a>示例</h2><p><strong>创建窗口</strong></p>
<p>直接输入 screen，创建一个新的窗口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen</span><br></pre></td></tr></table></figure>



<p>但是这样启动的 screen 会话没有名字，实践上推荐为每个 screen 会话取一个名字方便分辨，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -S getiot</span><br></pre></td></tr></table></figure>



<p>screen 启动后，会创建第一个窗口，也就是窗口 No. 0，并在其中打开一个系统默认的 shell（一般是 bash）。当执行 <code>screen</code> 命令之后，会立刻又返回到命令提示符，仿佛什么也没有发生似的，其实你已经进入 screen 的世界了。（执行 <code>exit</code> 退出 screen 窗口）</p>
<p>也可以在 screen 命令之后加入你喜欢的参数，使之直接打开你指定的程序，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen vi getiot.txt</span><br></pre></td></tr></table></figure>



<p>screen 创建一个执行 <code>vi getiot.txt</code> 的单窗口会话，退出 vi 将退出该窗口&#x2F;会话。</p>
<p><strong>查看窗口</strong></p>
<p>打开多个窗口后，可以使用快捷键 <code>Ctrl</code>+<code>A</code> 再按 <code>W</code> 列出当前所有窗口。如果使用文本终端，这个列表会列在屏幕左下角，如果使用 X 环境下的终端模拟器，这个列表会列在标题栏里。窗口列表一般像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0$ bash  1-$ bash  2*$ bash  </span><br></pre></td></tr></table></figure>



<p>这个例子中，我们开启了三个窗口，其中 <code>*</code> 号表示当前位于窗口 2，<code>-</code> 号表示上一次切换窗口时位于窗口 1。</p>
<p><strong>会话分离与恢复</strong></p>
<p>你可以不中断 screen 窗口中程序的运行而暂时断开（detach）screen 会话，并在随后时间重新连接（attach）该会话，重新控制各窗口中运行的程序。例如，我们打开一个 screen 窗口编辑 &#x2F;tmp&#x2F;getiot.txt 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen vi /tmp/getiot.txt</span><br></pre></td></tr></table></figure>



<p>之后我们想暂时退出做点别的事情，比如出去散散步，那么在 screen 窗口键入 <code>Ctrl</code>+<code>A</code> 再按 <code>D</code>，screen 会给出 detached 提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[detached from 35507.getiot]</span><br></pre></td></tr></table></figure>



<p>半个小时之后回来了，找到该 screen 会话：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ screen -<span class="built_in">ls</span></span><br><span class="line">There is a screen on:</span><br><span class="line">	35507.getiot	(2024年02月23日 15时55分40秒)	(Detached)</span><br><span class="line">1 Socket <span class="keyword">in</span> /run/screen/S-rudy.</span><br></pre></td></tr></table></figure>



<p>重新连接会话：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">screen -r 35507</span><br></pre></td></tr></table></figure>



<p>或者：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -r 35507.getiot</span><br></pre></td></tr></table></figure>



<p>会话中的一切都还在。</p>
<p>当然，如果你在另一台机器上没有分离一个 screen 会话，就无从恢复会话了。这时可以使用下面命令强制将这个会话从它所在的终端分离，转移到新的终端上来：</p>
<p><strong>清除 dead 会话</strong></p>
<p>如果由于某种原因其中一个会话死掉了（例如人为杀掉该会话），这时 <code>screen -ls</code> 会显示该会话为 dead 状态。可以使用下面命令清除该会话：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -wipe</span><br></pre></td></tr></table></figure>



<p><strong>关闭或杀死一个 screen 会话</strong></p>
<p>正常情况下，当你退出一个窗口中最后一个程序（通常是 bash）后，这个窗口就关闭了。另一个关闭窗口的方法是使用 <code>Ctrl</code>+<code>A</code> 键，然后按下 <code>K</code> 键，最后当提示你是否要杀死这个会话时按下 <code>Y</code> 键，这个快捷键会杀死当前的窗口，同时也将杀死这个窗口中正在运行的进程。</p>
<p>如果一个 screen 会话中最后一个窗口被关闭了，那么整个 screen 会话也就退出了，screen 进程会被终止。</p>
<h1 id="Linux-fbset-命令-帧缓冲设置"><a href="#Linux-fbset-命令-帧缓冲设置" class="headerlink" title="Linux fbset 命令 - 帧缓冲设置"></a>Linux fbset 命令 - 帧缓冲设置</h1><h2 id="介绍-134"><a href="#介绍-134" class="headerlink" title="介绍"></a>介绍</h2><p><strong>fbset</strong>（英文全拼：framebuffer set）命令用于显示或设置 Linux 系统中帧缓冲区的大小，同时还兼具调整画面的分辨率、位置、高低宽窄、色彩深度等功能，并可决定是否启动显卡的各项硬件特性。</p>
<p>提示</p>
<p>所谓的“帧缓冲设备”就是一块用于图形显示的内存区域，使用 <code>fbset</code> 命令可以查看和更改与该设备相关的设置。</p>
<p>帧缓冲设备提供了一个简单而独特的接口来访问不同类型的图形显示，可通过位于 &#x2F;dev 目录中的特殊设备节点进行访问，这些节点的命名方案始终为 <code>fb&lt;n&gt;</code>，其中 n 是所使用的帧缓冲区设备的编号。</p>
<p>fbset 使用位于 &#x2F;etc&#x2F;fb.modes 中的自己的视频模式数据库，该数据库中可以定义无限数量的视频模式。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fbset [options] [mode]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a, --all</code>：改变所有使用该设备之虚拟终端机的显示模式。</li>
<li><code>-db &lt;信息文件&gt;</code>：指定显示模式的信息文件，预设值文件名称为 fb.modes，存放在&#x2F;etc目录下</li>
<li><code>-fb &lt;外围设备代号&gt;</code>：指定用来做为输出帧缓冲区的外围设备，预设置为 <code>/dev/fd0</code>。</li>
<li><code>-h, -help</code>：显示帮助信息。</li>
<li><code>-i, --info</code>：列出所有帧缓冲区的相关信息。</li>
<li><code>-ifb &lt;外围设备代号&gt;</code>：使用另一个帧缓冲区外围设备的设置值。</li>
<li><code>-n, --now</code>：马上改变显示模式。</li>
<li><code>-ofb &lt;外围设备代号&gt;</code>：该选项参数效果和指定 <code>-fb</code> 参数相同。</li>
<li><code>-s, --show</code>：列出目前显示模式之设置。</li>
<li><code>-v, --verbose</code>：显示指令执行过程。</li>
<li><code>-V, --version</code>：显示版本信息。</li>
<li><code>-x, --xfree86</code>：使用 XFree86 兼容模式。</li>
<li><code>--test</code>：仅做测试，并不改变现行的显示模式。</li>
</ul>
<h2 id="示例-134"><a href="#示例-134" class="headerlink" title="示例"></a>示例</h2><p>要设置 X 窗口系统使用的视频模式，请在 rc.local 中插入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fbset -fb /dev/fb0 640x480-60</span><br></pre></td></tr></table></figure>



<p>并使 X 窗口系统知道所使用的帧缓冲设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> FRAMEBUFFER=/dev/fb0</span><br></pre></td></tr></table></figure>





<h1 id="Linux-insmod-命令-加载内核模块"><a href="#Linux-insmod-命令-加载内核模块" class="headerlink" title="Linux insmod 命令 - 加载内核模块"></a>Linux insmod 命令 - 加载内核模块</h1><h2 id="介绍-135"><a href="#介绍-135" class="headerlink" title="介绍"></a>介绍</h2><p><strong>insmod</strong>（英文全拼：install module）命令用于将模块载入 Linux 内核。</p>
<p>Linux 是一个允许用户在运行时加载内核模块以扩展内核功能的操作系统，LKM（Loadable Kernel Modules，可加载内核模块）通常用于添加对新硬件（作为设备驱动程序）和文件系统的支持，或用于增加系统调用。insmod 命令将带有&#x2F;不带参数的内核目标文件（.ko）载入内核。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insmod [filename] [module options...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-V</code>, <code>--version</code> ：显示版本信息。</li>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息。</li>
</ul>
<p><strong>参数</strong>：模块文件名（可带参数）</p>
<h2 id="示例-135"><a href="#示例-135" class="headerlink" title="示例"></a>示例</h2><p>将当前目录下的 getiot.ko 模块载入内核：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo insmod getiot.ko</span><br></pre></td></tr></table></figure>



<p>执行 insmod 命令需要 root 权限，因此需要添加 sudo，可通过 dmesg 命令查看内核模块的打印信息。</p>
<p>指定模块载入内核：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo insmod /home/rudy/getiot.ko</span><br></pre></td></tr></table></figure>



<p>加载内核模块时传入参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo insmod getiot.ko user=&quot;Rudy&quot;</span><br></pre></td></tr></table></figure>



<p>上述命令后面带的参数将传递给运行的内核模块，至于接收和使用什么参数则取决于该模块是怎么写的。</p>
<h1 id="Linux-lsmod-命令-列出加载模块"><a href="#Linux-lsmod-命令-列出加载模块" class="headerlink" title="Linux lsmod 命令 - 列出加载模块"></a>Linux lsmod 命令 - 列出加载模块</h1><h2 id="介绍-136"><a href="#介绍-136" class="headerlink" title="介绍"></a>介绍</h2><p><strong>lsmod</strong>（英文全拼：list modules）命令用于显示已经加载到内核中的模块的状态信息。</p>
<p>由于 Linux 操作系统内核支持模块化的特性，因此在编译内核时，无须把全部的功能都编译进内核，可以将这些功能编译成一个个单独的模块，待需要时再分别载入。</p>
<p>实际上，lsmod 的工作原理是从 &#x2F;proc&#x2F;modules 文件读取当前已加载的内核模块的信息，再以更方便用户阅读的格式显示。因此，lsmod 命令的用法很简单，不需要任何选项参数。</p>
<h2 id="示例-136"><a href="#示例-136" class="headerlink" title="示例"></a>示例</h2><p>查看当前系统已加载的内核模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lsmod</span><br><span class="line">Module                  Size  Used by</span><br><span class="line">rfcomm                 81920  4</span><br><span class="line">cmac                   16384  3</span><br><span class="line">algif_hash             16384  1</span><br><span class="line">algif_skcipher         16384  1</span><br><span class="line">af_alg                 28672  6 algif_hash,algif_skcipher</span><br><span class="line">bnep                   24576  2</span><br><span class="line">binfmt_misc            24576  1</span><br><span class="line">amdgpu               5214208  0</span><br><span class="line">iommu_v2               20480  1 amdgpu</span><br><span class="line">gpu_sched              36864  1 amdgpu</span><br><span class="line">snd_hda_codec_hdmi     61440  1</span><br><span class="line">intel_rapl_msr         20480  0</span><br><span class="line">intel_rapl_common      28672  1 intel_rapl_msr</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p>如果内核模块很多，不利于阅读，可以配合 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/grep/">grep</a> 等命令进行过滤。</p>
<p>比如查看是否已加载 coretemp 模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lsmod | grep coretemp</span><br><span class="line">coretemp               20480  0</span><br></pre></td></tr></table></figure>





<h1 id="Linux-rmmod-命令-移除内核模块"><a href="#Linux-rmmod-命令-移除内核模块" class="headerlink" title="Linux rmmod 命令 - 移除内核模块"></a>Linux rmmod 命令 - 移除内核模块</h1><h2 id="介绍-137"><a href="#介绍-137" class="headerlink" title="介绍"></a>介绍</h2><p><strong>rmmod</strong>（英文全拼：remove module）命令用于移除已载入内核的模块。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmmod [options] modulename</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-f</code>, <code>--force</code> ：强制移除模块，使用此选项比较危险。</li>
<li><code>-s</code>, <code>--syslog</code> ：将错误信息输出至 syslog 服务，而标准输出。</li>
<li><code>-v</code>, <code>--verbose</code> ：显示指令执行的详细信息。</li>
</ul>
<p><strong>参数</strong>：模块名</p>
<h2 id="示例-137"><a href="#示例-137" class="headerlink" title="示例"></a>示例</h2><p>卸载 getiot.ko 模块（模块名不需要带后缀）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmmod getiot</span><br></pre></td></tr></table></figure>



<p>卸载 getiot 模块并显示执行信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmmod -v getiot</span><br></pre></td></tr></table></figure>



<p>卸载 getiot 模块并将错误信息写入 syslog</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmmod -s getiot</span><br></pre></td></tr></table></figure>



<p>删除正在使用的 getiot 模块（谨慎使用）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmmod -f getiot</span><br></pre></td></tr></table></figure>





<h1 id="Linux-modinfo-命令-显示模块信息"><a href="#Linux-modinfo-命令-显示模块信息" class="headerlink" title="Linux modinfo 命令 - 显示模块信息"></a>Linux modinfo 命令 - 显示模块信息</h1><h2 id="介绍-138"><a href="#介绍-138" class="headerlink" title="介绍"></a>介绍</h2><p><strong>modinfo</strong>（英文全拼：module information）命令用于显示指定的 Linux 内核模块的相关信息。</p>
<p>默认情况下，为了便于阅读，会以 <code>fieldname : value</code> 的格式列出模块的每个属性。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modinfo [-0] [-F field] [modulename|filename...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-F</code>, <code>--field</code> ：仅在一行上显示 field 值，这对于脚本较为有用。常用的 field 有 author、description、licence、param、depends、alias、filename。</li>
<li><code>-0</code>, <code>--null</code> ：使用 ASCII 码的 <code>0</code> 字符分隔 field 值，而不是一个换行符。（该选项对脚本比较有用）</li>
<li><code>-a</code>、<code>-d</code>、<code>-l</code>、<code>-p</code>、<code>-n</code> ：这些分别是 author、description、license、param、filename 的简短形式，用于显示对应的信息。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息。</li>
</ul>
<p><strong>参数</strong>：模块名或文件名。如果使用模块名，而没有指定文件名，则会在 <code>/lib/modules/$(uname -r)</code> 目录中搜索，就像 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/modprobe/">modprobe</a> 一样。</p>
<h2 id="示例-138"><a href="#示例-138" class="headerlink" title="示例"></a>示例</h2><p>显示 sg 模块（SCSI generic 驱动）的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modinfo sg </span><br></pre></td></tr></table></figure>



<p>显示 sg 模块的开发人员信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modinfo -a sg</span><br></pre></td></tr></table></figure>



<p>显示 sg 模块的描述信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modinfo -d sg</span><br></pre></td></tr></table></figure>



<p>显示 sg 模块的许可信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modinfo -l sg</span><br></pre></td></tr></table></figure>



<p>显示 sg 模块所支持的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modinfo -p sg</span><br></pre></td></tr></table></figure>





<h1 id="Linux-modprobe-命令-自动加载模块"><a href="#Linux-modprobe-命令-自动加载模块" class="headerlink" title="Linux modprobe 命令 - 自动加载模块"></a>Linux modprobe 命令 - 自动加载模块</h1><h2 id="介绍-139"><a href="#介绍-139" class="headerlink" title="介绍"></a>介绍</h2><p><strong>modprobe</strong>（英文全拼：modules probe）命令用于智能地向内核中加载模块或者从内核中移除模块。</p>
<p>modprobe 可载入指定的个别模块，或是载入一组相依的模块。modprobe 会根据 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/depmod/">depmod</a> 所产生的相依关系，决定要载入哪些模块。若在载入过程中发生错误，则 modprobe 会卸载整组的模块。需要注意的是为了方便，模块名中的 <code>-</code> 和 <code>_</code> 是没有区别的。</p>
<p>modprobe 命令会查找 <code>/lib/modules/&#39;uname -r&#39;</code> 目录中的模块和文件 (<code>uname -r</code> 是内核版本），但是不会查找 <code>/etc/modprobe.conf</code> 和 <code>/etc/modprobe.d/</code> 目录下配置所排除的内容。</p>
<p>modprobe 命令不会修改模块内容，解析模块内容和使用模块参数是在内核中进行的，所以如果模块装载失败，内核会将失败的日志通过 dmesg 打印出来。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modprobe [options] modulename</span><br><span class="line">modprobe [options] -a modulename [modulename...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>, <code>--all</code> ：载入全部的模块。</li>
<li><code>-c</code>, <code>--show-conf</code> ：显示所有模块的设置信息。</li>
<li><code>-d</code>, <code>--debug</code> ：使用排错模式。</li>
<li><code>-l</code>, <code>--list</code> ：显示可用的模块。</li>
<li><code>-r</code>, <code>--remove</code> ：模块闲置不用时，即自动卸载模块。</li>
<li><code>-t</code>, <code>--type</code> ：指定模块类型。</li>
<li><code>-v</code>, <code>--verbose</code> ：执行时显示详细的信息。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息。</li>
<li><code>-h</code> ：显示帮助。</li>
</ul>
<p><strong>参数</strong>：模块名（使用 <code>-a</code> 选项可以接多个模块名）</p>
<h2 id="示例-139"><a href="#示例-139" class="headerlink" title="示例"></a>示例</h2><p>查看 modules 的配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modprobe -c</span><br></pre></td></tr></table></figure>



<p>这里，可以查看 modules 的配置文件，比如模块的 alias 别名是什么等，会打印许多行信息。</p>
<p>加载 spidev 模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> modprobe spidev</span><br></pre></td></tr></table></figure>



<p>卸载 spidev 模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> modprobe -r spidev</span><br></pre></td></tr></table></figure>





<h1 id="Linux-depmod-命令-处理模块依赖"><a href="#Linux-depmod-命令-处理模块依赖" class="headerlink" title="Linux depmod 命令 - 处理模块依赖"></a>Linux depmod 命令 - 处理模块依赖</h1><h2 id="介绍-140"><a href="#介绍-140" class="headerlink" title="介绍"></a>介绍</h2><p><strong>depmod</strong>（英文全拼：dependency modules）命令用于分析可载入模块的相依性，生成内核模块及其关联映射文件的依赖关系描述列表。</p>
<p>执行 depmod 命令将分析 <code>/lib/modules/&#39;uname -r&#39;</code> 目录中的内核模块（<code>uname -r</code> 是内核版本），并根据模块集中存在的符号创建一个类似于 Makefile 的依赖文件，名为 modules.dep。通常在构建嵌入式系统时，需要由这个命令来生成相应的文件，供 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/modprobe/">modprobe</a> 在安装模块时使用。</p>
<p>实际上，depmod 和 modprobe 命令工具简化了 Linux 模块化内核，方便系统维护人员进行管理。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">depmod [options]</span><br></pre></td></tr></table></figure>



<p>详细语法格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">depmod [ -a ] [ -b basedir ] [ -e ] [ -F System.map ] [ -n ] [ -v ] [ version ] [ -A ]</span><br><span class="line">       [-n] [-v] [-A] [-P prefix] [-w] [version]</span><br><span class="line"></span><br><span class="line">depmod [-e] [-E Module.symvers] [-F System.map] [-m] [-n] [-v] [-P prefix]</span><br><span class="line">       [-w] [version] [filename...][Tex]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>, <code>--all</code> ：分析所有可用的模块；</li>
<li><code>-d</code>, <code>debug</code> ：执行排错模式；</li>
<li><code>-e</code> ：输出无法参照的符号；</li>
<li><code>-i</code> ：不检查符号表的版本；</li>
<li><code>-s</code>, <code>--system-log</code> ：在系统记录中记录错误；</li>
<li><code>-v</code>, <code>--verbose</code> ：执行时显示详细的信息；</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息；</li>
<li><code>--help</code> ：显示帮助。</li>
</ul>
<h2 id="示例-140"><a href="#示例-140" class="headerlink" title="示例"></a>示例</h2><p>从默认位置检索模块文件，之后就可以将其载入内核</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /path/to/your-kernel-module.ko /lib/modules/`uname -r`</span><br><span class="line">sudo depmod -a</span><br><span class="line">sudo modprobe your-kernel-module</span><br></pre></td></tr></table></figure>





<h1 id="Linux-neofetch-命令-系统信息展示"><a href="#Linux-neofetch-命令-系统信息展示" class="headerlink" title="Linux neofetch 命令 - 系统信息展示"></a>Linux neofetch 命令 - 系统信息展示</h1><h2 id="介绍-141"><a href="#介绍-141" class="headerlink" title="介绍"></a>介绍</h2><p><strong>Neofetch</strong> 是一个快速、高度可定制的系统信息脚本，用 Bash 编写。主要用于系统信息的截图，支持 Linux、BSD、Mac OS X、iOS 和 Windows 操作系统。</p>
<p>Neofetch 会收集有关系统软硬件的信息，并在终端中显示结果。默认情况下，系统信息将与操作系统的 logo 一起显示。你可以进一步地自定义使用 ascii 图像或其他任何图片，还可以配置 Neofetch 显示的信息、信息的显示位置和时间。</p>
<p>Neofetch 通常不会预先安装，但可在大多数 Linux 发行版的默认仓库中找到。例如，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install neofetch</span><br></pre></td></tr></table></figure>



<h2 id="示例-141"><a href="#示例-141" class="headerlink" title="示例"></a>示例</h2><p>在我的 Ubuntu 上直接执行 <code>neofetch</code>，输出结果如下：</p>
<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/neofetch.png" alt="img"></p>
<p>列出的信息包括：</p>
<ul>
<li>OS：已安装操作系统的名称</li>
<li>Host：笔记本型号</li>
<li>Kernel：内核详细信息</li>
<li>Uptime：系统运行时间</li>
<li>Packages：默认和其他软件包管理器安装的软件数量</li>
<li>Shell：默认 shell</li>
<li>Resolution：屏幕分辨率</li>
<li>DE：桌面环境</li>
<li>WM：窗口管理器</li>
<li>WM Theme：窗口管理器的主题</li>
<li>Theme：系统主题</li>
<li>Icons：系统图标</li>
<li>Terminal：默认终端</li>
<li>CPU：CPU 类型</li>
<li>GPU：GPU 类型</li>
<li>Memory：已安装的内存</li>
</ul>
<h1 id="Linux-who-命令-显示当前登录用户"><a href="#Linux-who-命令-显示当前登录用户" class="headerlink" title="Linux who 命令 - 显示当前登录用户"></a>Linux who 命令 - 显示当前登录用户</h1><h2 id="介绍-142"><a href="#介绍-142" class="headerlink" title="介绍"></a>介绍</h2><p><strong>who</strong> 命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">who [OPTION]... [ FILE | ARG1 ARG2 ]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>, <code>--all</code> ：等价于 <code>-b -d --login -p -r -t -T -u</code>。</li>
<li><code>-b</code>, <code>--boot</code> ：显示最近一次系统启动的时间。</li>
<li><code>-H</code>, <code>--heading</code> ：打印行头标题。</li>
<li><code>-q</code>, <code>--count</code> ：只显示登录的账户名称和总人数。</li>
<li><code>-r</code>, <code>--runlevel</code> ：打印当前运行等级。</li>
<li><code>-s</code>, <code>--short</code> ：简短输出，只打印账户名称、线路和时间。</li>
<li><code>-u</code>, <code>--users</code> ：列出登录的所有用户。</li>
<li><code>--help</code> ：显示帮助信息。</li>
<li><code>--version</code> ：显示版本信息。</li>
</ul>
<p><strong>参数</strong>：如果没有指定 FILE，则默认使用 &#x2F;var&#x2F;run&#x2F;utmp。</p>
<h2 id="示例-142"><a href="#示例-142" class="headerlink" title="示例"></a>示例</h2><p>显示当前系统登录的用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">who</span><br></pre></td></tr></table></figure>



<p>显示当前系统登录的用户，并显示标题栏</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">who -H</span><br></pre></td></tr></table></figure>



<p>显示系统启动时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">who -b</span><br></pre></td></tr></table></figure>



<p>精简模式显示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">who -q</span><br></pre></td></tr></table></figure>





<h1 id="Linux-whoami-命令-显示当前用户"><a href="#Linux-whoami-命令-显示当前用户" class="headerlink" title="Linux whoami 命令 - 显示当前用户"></a>Linux whoami 命令 - 显示当前用户</h1><h2 id="介绍-143"><a href="#介绍-143" class="headerlink" title="介绍"></a>介绍</h2><p>在 Linux 系统中，<strong>whoami</strong> 命令可用于打印与当前有效用户 ID 关联的用户名。这个工具可以用来获取本地系统上当前用户（访问令牌）的用户名和组信息，以及相应的安全标识符（SID）、声明、本地系统上当前用户的权限、登录标识符（登录 ID）。</p>
<p>提示</p>
<p>whoami 命令显示自身的用户名称，本指令相当于执行 <code>id -un</code> 指令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">whoami</span> [OPTION]...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>--help</code>：显示帮助信息。</li>
<li><code>--version</code>：显示版本信息。</li>
</ul>
<h2 id="示例-143"><a href="#示例-143" class="headerlink" title="示例"></a>示例</h2><p>查询当前登录的用户名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">whoami</span></span><br></pre></td></tr></table></figure>





<h1 id="Linux-whois-命令-查询域名信息"><a href="#Linux-whois-命令-查询域名信息" class="headerlink" title="Linux whois 命令 - 查询域名信息"></a>Linux whois 命令 - 查询域名信息</h1><h2 id="介绍-144"><a href="#介绍-144" class="headerlink" title="介绍"></a>介绍</h2><p><strong>whois</strong> 命令用来查找并显示指定用户账号、域名相关信息，包括域名注册时间、拥有者、邮箱等。</p>
<p>使用前请确保你的系统上已经安装 whois 工具，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install whois</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">whois [OPTION]... OBJECT...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>：搜寻所有数据库。</li>
<li><code>-c</code>：找到最小的包含一个 mnt-irt 属性的匹配。</li>
<li><code>-d</code>：同时返回 DNS 反向查询的代理对象（需支持 RPSL 协议）。</li>
<li><code>-F</code>：快速输出原始数据。</li>
<li><code>-H</code>：隐藏法律声明内容。</li>
<li><code>-i ATTR</code>：进行一次反向查询。</li>
<li><code>-l</code>：将精确度降低一级的查询（需支持 RPSL 协议）。</li>
<li><code>-L</code>：找到所有低精确度匹配。</li>
<li><code>-m</code>：找到第一级较高精确度匹配。</li>
<li><code>-M</code>：找到所有较高精确度匹配。</li>
<li><code>-r</code>：查询联系信息时关闭递归查询。</li>
<li><code>-R</code>：显示本地域名对象副本。</li>
<li><code>-x</code>：精确匹配。</li>
<li><code>-h[主机]</code>：连接到指定 HOST 服务器。</li>
<li><code>-p[端口]</code>：连接到指定 PORT 端口。</li>
<li><code>-t[类型]</code>：查询指定类型对象头信息。</li>
<li><code>-T[类型]</code>：查找指定类型的对象。</li>
<li><code>-v[类型]</code>：查询指定类型对象冗余信息。</li>
<li><code>-q [版本|类型]</code>：查询特定的服务器信息（需支持 RPSL 协议）。</li>
</ul>
<h2 id="示例-144"><a href="#示例-144" class="headerlink" title="示例"></a>示例</h2><p>显示指定用户信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">whois root</span><br></pre></td></tr></table></figure>



<p>查询域名描述信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">whois getiot.tech</span><br></pre></td></tr></table></figure>



<p>查询域名信息省略法律声明：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">whois -H getiot.tech</span><br></pre></td></tr></table></figure>



<p>指定端口查询：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">whois -p 80 getiot.tech</span><br></pre></td></tr></table></figure>





<h1 id="Linux-watch-命令-重复执行命令"><a href="#Linux-watch-命令-重复执行命令" class="headerlink" title="Linux watch 命令 - 重复执行命令"></a>Linux watch 命令 - 重复执行命令</h1><h2 id="介绍-145"><a href="#介绍-145" class="headerlink" title="介绍"></a>介绍</h2><p><strong>watch</strong> 命令用于在 Linux 系统中周期性地执行一个程序，并全屏显示该程序的输出信息。</p>
<p>默认的，watch 命令会以 2 秒一次的频率重复运行参数中指定的命令，直到运行被中断。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">watch [options] <span class="built_in">command</span></span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-d</code>, <code>–differences</code> ：以高亮的形式显示出两次更新不同的部分，方便用户查看更改。</li>
<li><code>-n</code>, <code>–interval seconds</code> ：指定更新间隔，允许的最小时间间隔是 0.1 秒。</li>
<li><code>-p</code>, <code>–precise</code> ：尝试以 interval 间隔运行参数中的命令（默认间隔为 2 秒）。</li>
<li><code>-t</code>, <code>–no-title</code> ：不显示头部信息，包括运行间隔、运行命令、当前时间等信息。</li>
<li><code>-b</code>, <code>–beep</code> ：当命令异常退出时，发出蜂鸣声。</li>
<li><code>-e</code>, <code>–errexit</code> ：冻结命令错误的更新，并在按键后退出。</li>
<li><code>-g</code>, <code>–chgexit</code> ：当命令输出更改时，退出执行。</li>
<li><code>-c</code>, <code>–color</code> ：解释 ANSI 颜色和样式。</li>
<li><code>-x</code>, <code>–exec</code> ：此选项提供给 <code>sh -c</code>，这意味着您可能需要使用额外的引号才能获得所需的效果。</li>
</ul>
<p><strong>参数</strong>：command 命令及其选项参数</p>
<h2 id="示例-145"><a href="#示例-145" class="headerlink" title="示例"></a>示例</h2><p>周期显示系统内存使用情况，并高亮显示差异</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">watch -d  free -m</span><br></pre></td></tr></table></figure>



<p>每秒刷新一次</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">watch -n 1 free -m</span><br></pre></td></tr></table></figure>



<p>不显示头部信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">watch -t free -m</span><br></pre></td></tr></table></figure>





<h1 id="Linux-su-命令-切换用户身份"><a href="#Linux-su-命令-切换用户身份" class="headerlink" title="Linux su 命令 - 切换用户身份"></a>Linux su 命令 - 切换用户身份</h1><h2 id="介绍-146"><a href="#介绍-146" class="headerlink" title="介绍"></a>介绍</h2><p>在 Linux 系统中，<strong>su</strong>（英文全拼：substitute user）命令用于切换当前用户身份到指定用户，或者以指定用户的身份执行命令或程序。</p>
<p>普通用户切换到 root 用户，可以使用 <code>su --</code> 或 <code>su root</code>，但是必须输入 root 密码才能完成切换。root 用户切换到普通用户，可以使用 <code>su &lt;username&gt;</code>，不需要输入任何密码即可完成切换。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su [options] [-] [user [argument...]]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-c, --command</code>：执行完指定的指令后，即恢复原来的身份。</li>
<li><code>-f, --fast</code>：适用于 csh 与 tsch，使 shell 不用去读取启动文件。</li>
<li><code>-l, --login</code>：改变身份时，也同时变更工作目录，以及 HOME、SHELL、USER、logname，此外，也会变更 PATH 变量。</li>
<li><code>-m, -p, --preserve-environment</code>：变更身份时，不要变更环境变量。</li>
<li><code>-s, --shell</code>：指定要执行的 shell。</li>
<li><code>--help</code>：显示帮助信息。</li>
<li><code>--version</code>：显示版本信息。</li>
</ul>
<h2 id="示例-146"><a href="#示例-146" class="headerlink" title="示例"></a>示例</h2><p>切换到 getiot 用户，但环境变量仍然是当前用户的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su getiot</span><br></pre></td></tr></table></figure>



<p>切换到 getiot 用户，并改变为 getiot 用户环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - getiot</span><br></pre></td></tr></table></figure>





<h1 id="Linux-sudo-命令-以超级用户执行"><a href="#Linux-sudo-命令-以超级用户执行" class="headerlink" title="Linux sudo 命令 - 以超级用户执行"></a>Linux sudo 命令 - 以超级用户执行</h1><h2 id="介绍-147"><a href="#介绍-147" class="headerlink" title="介绍"></a>介绍</h2><p>在 Linux 系统中，<strong>sudo</strong> 是一种权限管理机制，管理员可以授权于一些普通用户去执行一些 root 执行的操作，而不需要知道 root 的密码。</p>
<p>sudo 允许一个已授权用户以超级用户或者其它用户的角色运行一个命令。当然，能做什么不能做什么都是通过安全策略来指定的。sudo 支持插件架构的安全策略，并能把输入输出写入日志。第三方可以开发并发布自己的安全策略和输入输出日志插件，并让它们无缝的和 sudo 一起工作。默认的安全策略记录在 &#x2F;etc&#x2F;sudoers 文件中。而安全策略可能需要用户通过密码来验证他们自己。也就是在用户执行 sudo 命令时要求用户输入自己账号的密码。如果验证失败，sudo 命令将会退出。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> -h | -K | -k | -V</span><br><span class="line"><span class="built_in">sudo</span> -v [-AknS] [-g group] [-h host] [-p prompt] [-u user]</span><br><span class="line"><span class="built_in">sudo</span> -l [-AknS] [-g group] [-h host] [-p prompt] [-U user] [-u user] [<span class="built_in">command</span>]</span><br><span class="line"><span class="built_in">sudo</span> [-AbEHknPS] [-r role] [-t <span class="built_in">type</span>] [-C num] [-g group] [-h host] [-p prompt] [-T <span class="built_in">timeout</span>] [-u user] [VAR=value] [-i|-s] [&lt;<span class="built_in">command</span>&gt;]</span><br><span class="line"><span class="built_in">sudo</span> -e [-AknS] [-r role] [-t <span class="built_in">type</span>] [-C num] [-g group] [-h host] [-p prompt] [-T <span class="built_in">timeout</span>] [-u user] file ...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-A, --askpass</code>：使用助手程序进行密码提示。</li>
<li><code>-b, --background</code>：在后台运行命令。</li>
<li><code>-B, --bell</code>：出现提示时按响铃。</li>
<li><code>-C, --close-from=num</code>：关闭所有 &gt;&#x3D; num 的文件描述符。</li>
<li><code>-E, --preserve-env</code>：在执行命令时保留用户环境。</li>
<li><code>--preserve-env=list</code>：保留特定的环境变量。</li>
<li><code>-e, --edit</code>：编辑文件而非执行命令。</li>
<li><code>-g, --group=group</code>：以指定的用户组或 ID 执行命令。</li>
<li><code>-H, --set-home</code>：将 HOME 变量设为目标用户的主目录。</li>
<li><code>-h, --help</code>：显示帮助信息。</li>
<li><code>-h, --host=host</code>：在主机上运行命令（如果插件支持）。</li>
<li><code>-i, --login</code>：以目标用户身份运行一个登录 shell；可同时指定一条命令。</li>
<li><code>-K, --remove-timestamp</code>：完全移除时间戳文件。</li>
<li><code>-k, --reset-timestamp</code>：无效的时间戳文件。</li>
<li><code>-l, --list</code>：列出用户权限或检查某个特定命令；对于长格式，使用两次。</li>
<li><code>-n, --non-interactive</code>：非交互模式，不提示。</li>
<li><code>-P, --preserve-groups</code>：保留组向量，而非设置为目标的组向量。</li>
<li><code>-p, --prompt=prompt</code>：使用指定的密码提示。</li>
<li><code>-r, --role=role</code>：以指定的角色创建 SELinux 安全环境。</li>
<li><code>-S, --stdin</code>：从标准输入读取密码。</li>
<li><code>-s, --shell</code>：以目标用户运行 shell；可同时指定一条命令。</li>
<li><code>-t, --type=type</code>：以指定的类型创建 SELinux 安全环境。</li>
<li><code>-T, --command-timeout=timeout</code>：在超出指定时间后终止命令。</li>
<li><code>-U, --other-user=user</code>：在列表模式中显示用户的权限。</li>
<li><code>-u, --user=user</code>：以指定用户或 ID 运行命令（或编辑文件）。</li>
<li><code>-V, --version</code>：显示版本信息。</li>
<li><code>-v, --validate</code>：更新用户的时间戳而不执行命令。</li>
<li><code>--</code>：停止处理命令行参数。</li>
</ul>
<h2 id="示例-147"><a href="#示例-147" class="headerlink" title="示例"></a>示例</h2><p>切换到 root 用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> su</span><br></pre></td></tr></table></figure>



<p>指定用户执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> -u getiot <span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure>



<p>以 root 权限执行上一条命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> !!</span><br></pre></td></tr></table></figure>



<p>列出目前的权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> -l</span><br></pre></td></tr></table></figure>



<p>列出 sudo 的版本信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> -V</span><br></pre></td></tr></table></figure>





<h1 id="Linux-id-命令-显示用户-ID-信息"><a href="#Linux-id-命令-显示用户-ID-信息" class="headerlink" title="Linux id 命令 - 显示用户 ID 信息"></a>Linux id 命令 - 显示用户 ID 信息</h1><h2 id="介绍-148"><a href="#介绍-148" class="headerlink" title="介绍"></a>介绍</h2><p><strong>id</strong> 命令可以显示真实有效的用户 ID（UID）和组 ID（GID）。UID 是对一个用户的单一身份标识。组 ID（GID）则对应多个 UID。id 命令已经默认预装在大多数 Linux 系统中。要使用它，只需要在你的控制台输入 id。</p>
<p>当我们想知道某个用户的 UID 和 GID 时，id 命令是非常有用的。一些程序可能需要 UID&#x2F;GID 来运行。id 使我们更加容易地找出用户的 UID 以 GID 而不必在 &#x2F;etc&#x2F;group 文件中搜寻。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span> [OPTION]... [USER]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-g</code>, <code>--group</code> ：显示用户所属群组的 ID。</li>
<li><code>-G</code>, <code>--groups</code> ：显示用户所属附加群组的 ID。</li>
<li><code>-n</code>, <code>--name</code> ：显示用户，所属群组或附加群组的名称。</li>
<li><code>-r</code>, <code>--real</code> ：显示实际 ID（UID）。</li>
<li><code>-u</code>, <code>--user</code> ：显示用户 ID（EUID）。</li>
<li><code>--help</code> ：显示帮助。</li>
<li><code>--version</code> ：显示版本信息。</li>
</ul>
<h2 id="示例-148"><a href="#示例-148" class="headerlink" title="示例"></a>示例</h2><p>不带选项输入 id 会显示如下，结果会使用活跃用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">id</span></span><br><span class="line">uid=1000(rudy) gid=1000(rudy) <span class="built_in">groups</span>=1000(rudy),4(adm),24(cdrom),27(<span class="built_in">sudo</span>),30(dip),46(plugdev),120(lpadmin),131(lxd),132(sambashare)</span><br></pre></td></tr></table></figure>



<p>解释：用户 rudy 的用户 ID 是 1000，组 ID 是 1000。同时，用户 rudy 是下面组的成员：</p>
<ul>
<li>rudy 组（GID &#x3D; 1000）</li>
<li>adm 组（GID &#x3D; 4）</li>
<li>cdrom 组（GID &#x3D; 24）</li>
<li>sudo 组（GID &#x3D; 27）</li>
<li>dip 组（GID &#x3D; 30）</li>
<li>plugdev 组（GID &#x3D; 46）</li>
<li>lpadmin 组（GID &#x3D; 120）</li>
<li>lxd 组（GID &#x3D; 131）</li>
<li>sambashare 组（GID &#x3D; 132）</li>
</ul>
<p>输出所有不同的组 ID（包括有效的、真实的和补充的）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">id</span> -G</span><br><span class="line">1000 4 24 27 30 46 120 131 132</span><br></pre></td></tr></table></figure>



<p>结果只会显示 GID 号。你可以和 <code>/etc/group</code> 文件比较。下面是 <code>/etc/group</code> 文件的示例内容：</p>
<p>只输出有效的组 ID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">id</span> -g</span><br><span class="line">1000</span><br></pre></td></tr></table></figure>



<p>输出特定用户信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">id</span> mysql</span><br><span class="line">uid=112(mysql) gid=116(mysql) <span class="built_in">groups</span>=116(mysql)</span><br></pre></td></tr></table></figure>





<h1 id="Linux-type-命令-显示命令类型"><a href="#Linux-type-命令-显示命令类型" class="headerlink" title="Linux type 命令 - 显示命令类型"></a>Linux type 命令 - 显示命令类型</h1><h2 id="介绍-149"><a href="#介绍-149" class="headerlink" title="介绍"></a>介绍</h2><p><strong>type</strong> 命令用于显示指定命令的类型，判断给出的指令是内部指令还是外部指令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">type [-afptP] NAME [NAME ...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><p><code>-a</code> ：显示所有包含名称为 NAME 的可执行文件的位置；包括别名、内建和函数。仅当 <code>-p</code> 选项没有使用时</p>
</li>
<li><p><code>-f</code> ：抑制 shell 函数查询</p>
</li>
<li><p><code>-P</code> ：为每个 NAME 名称惊醒 PATH 路径搜索（显示绝对路径），即使它是别名、内建或函数，并且返回将被执行的磁盘上文件的名称。</p>
</li>
<li><p><code>-p</code> ：返回将被执行的磁盘上文件的名称，或者当 <code>type -t NAME</code> 不返回 <code>file</code> 时，不返回任何值。</p>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-t</span><br></pre></td></tr></table></figure>

<p>：返回下列词中的任何一个：</p>
<ul>
<li><code>alias</code> ：别名。</li>
<li><code>keyword</code> ：关键字，Shell 保留字。</li>
<li><code>function</code> ：函数，Shell 函数。</li>
<li><code>builtin</code> ：内建命令，Shell 内建命令。</li>
<li><code>file</code> ：文件，磁盘文件，外部命令。</li>
<li><code>unfound</code> ：没有找到。</li>
</ul>
</li>
</ul>
<p><strong>参数</strong>：NAME，将要解析的命令。</p>
<h2 id="示例-149"><a href="#示例-149" class="headerlink" title="示例"></a>示例</h2><p>别名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">type</span> <span class="built_in">ls</span></span></span><br><span class="line">ls is aliased to `ls --color=tty&#x27;</span><br></pre></td></tr></table></figure>



<p>Shell 关键字</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">type</span> <span class="keyword">if</span></span></span><br><span class="line">if is a shell keyword</span><br></pre></td></tr></table></figure>



<p>Shell 内建命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">type</span> <span class="built_in">cd</span></span></span><br><span class="line">cd is a shell builtin</span><br></pre></td></tr></table></figure>



<p>一般文件（外部命令）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">type</span> <span class="built_in">date</span></span></span><br><span class="line">date is /bin/date</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">type</span> mysql</span></span><br><span class="line">mysql is /usr/bin/mysql</span><br></pre></td></tr></table></figure>



<p>没有找到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">type</span> nginx</span></span><br><span class="line">-bash: type: nginx: not found</span><br></pre></td></tr></table></figure>





<h1 id="Linux-history-命令-显示命令历史"><a href="#Linux-history-命令-显示命令历史" class="headerlink" title="Linux history 命令 - 显示命令历史"></a>Linux history 命令 - 显示命令历史</h1><h2 id="介绍-150"><a href="#介绍-150" class="headerlink" title="介绍"></a>介绍</h2><p><strong>history</strong> 命令用于列出当前用户的历史操作记录。可带数字参数用于指定需要查看的最近的命令条目。</p>
<p>history 的工作原理是启动 Shell 时读取环境变量 <code>HISTFILE</code> 文件（默认是 ~&#x2F;.bash_history）中的历史记录，存储在相应内存的缓冲区中，以便于用户可以通过上下方向键或符号 <code>!</code> 指定序号查找历史命令。用户在 Shell 中的所有操作记录都会存储在缓冲区中，直到退出 Shell，或者显式执行回写。</p>
<p>除了 <code>HISTFILE</code> 变量，history 命令还受如下一些环境变量影响：</p>
<ul>
<li><code>HISTSIZE</code> ：该变量用于控制存储历史命令的条目数量，默认为 1000，即仅能够存储 1000 条历史命令。</li>
<li><code>HISTFILESIZE</code> ：控制历史记录文件中的最大个数。</li>
<li><code>HISTIGNORE</code> ：设置哪些命令不记录到历史记录。</li>
<li><code>HISTTIMEFORMAT</code> ：设置历史命令显示的时间格式。</li>
<li><code>HISTCONTROL</code> ：扩展的控制选项。比如 ignorespace 表示忽略空格开头的命令，ignoredups 表示忽略连续重复命令，ignoreboth 表示上述两个参数都设置。</li>
</ul>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">history</span> [选项] [参数]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-c</code> ：清空当前历史命令。</li>
<li><code>-a</code> ：将历史命令缓冲区中命令写入历史命令文件中。</li>
<li><code>-r</code> ：将历史命令文件中的命令读入当前历史命令缓冲区。</li>
<li><code>-w</code> ：将当前历史命令缓冲区命令写入历史命令文件中。</li>
</ul>
<p><strong>参数</strong>：打印最近的 n 条历史命令。</p>
<h2 id="示例-150"><a href="#示例-150" class="headerlink" title="示例"></a>示例</h2><p>显示最近使用的10条历史命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">history</span>  10</span><br></pre></td></tr></table></figure>



<p>将当前缓冲区中的历史命令写入历史命令文件（~&#x2F;.bash_history）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">history</span>  -w</span><br></pre></td></tr></table></figure>





<h1 id="Linux-last-命令-显示登录记录"><a href="#Linux-last-命令-显示登录记录" class="headerlink" title="Linux last 命令 - 显示登录记录"></a>Linux last 命令 - 显示登录记录</h1><h2 id="介绍-151"><a href="#介绍-151" class="headerlink" title="介绍"></a>介绍</h2><p><strong>last</strong> 命令用于显示 Linux 系统近期用户或终端的登录情况，通过查看系统记录的日志文件内容，进而使管理员可以获知谁曾经或者企图连接系统。</p>
<p>执行 last 命令时，它会读取 &#x2F;var&#x2F;log&#x2F;wtmp 文件，并把该文件记录的登录系统或终端的用户名单全部显示出来。默认显示 &#x2F;var&#x2F;log&#x2F;wtmp 的记录，&#x2F;var&#x2F;log&#x2F;btmp 能显示的更详细，可以显示远程登录，例如 ssh 登录。</p>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/uptime/">uptime</a>，<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/who/">who</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">last [options] [username...] [<span class="built_in">tty</span>...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-R</code>, <code>--nohostname</code> ：省略 hostname 的栏位。</li>
<li><code>-f</code>, <code>--file &lt;file&gt;</code> ：指定文件以替代默认的 &#x2F;var&#x2F;log&#x2F;wtmp。</li>
<li><code>-F</code>, <code>--fulltimes</code> ：显示完整的登录和登出时间和日期。</li>
<li><code>-n</code>, <code>--limit number</code> ：显示最近的 number 行记录。</li>
<li><code>username</code> ：显示 username 的登录信息。</li>
<li><code>-x</code>, <code>--system</code> ：显示系统关机条目和运行级别更改信息。</li>
</ul>
<h2 id="示例-151"><a href="#示例-151" class="headerlink" title="示例"></a>示例</h2><p>简略显示最新的5行记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">last -n 5 -R</span><br></pre></td></tr></table></figure>



<p>使用 &#x2F;var&#x2F;log&#x2F;btmp 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> last -f /var/log/btmp</span><br></pre></td></tr></table></figure>



<p>显示系统历史启动的时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">last -x reboot</span><br></pre></td></tr></table></figure>



<p>只查看最后一次系统启动的时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">last -x reboot | <span class="built_in">head</span> -1</span><br></pre></td></tr></table></figure>



<p>显示系统历史关机时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">last -x shutdown</span><br></pre></td></tr></table></figure>



<p>只查看最后一次系统关机的时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">last -x shutdown | <span class="built_in">head</span> -1</span><br></pre></td></tr></table></figure>





<h1 id="Linux-lscpu-命令-显示-CPU-架构信息"><a href="#Linux-lscpu-命令-显示-CPU-架构信息" class="headerlink" title="Linux lscpu 命令 - 显示 CPU 架构信息"></a>Linux lscpu 命令 - 显示 CPU 架构信息</h1><h2 id="介绍-152"><a href="#介绍-152" class="headerlink" title="介绍"></a>介绍</h2><p><strong>lscpu</strong>（英文全拼：list cpu）命令用来显示 CPU 的相关信息。</p>
<p>该命令从 sysfs 和 &#x2F;proc&#x2F;cpuinfo 收集 cpu 体系结构信息，再以易读的格式输出，输出的信息包含 cpu 数量、核心数、线程数、套接字 和 NUMA（Non-Uniform Memory Access）、缓存等。但并不一定所有的字段都有数据显示，这和所支持的 CPU 架构有关系，如果指定了不支持的字段，那么 lscpu 将打印字段名，但不显示数据。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lscpu [选项]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>, <code>--all</code> ：同时打印在线和离线 CPU（-e 选项默认值）。</li>
<li><code>-b</code>, <code>--online</code> ：只打印在线 CPU（-p 选项默认值）。</li>
<li><code>-B</code>, <code>--bytes</code> ：以字节为单位打印。</li>
<li><code>-C</code>, <code>--caches[=&lt;list&gt;]</code> ：以易读的格式打印 cache 信息。</li>
<li><code>-c</code>, <code>--offline</code> ：只打印离线 CPU。</li>
<li><code>-J</code>, <code>--json</code> ：使用 JSON 格式作为默认或扩展格式。</li>
<li><code>-e</code>, <code>--extended[=&lt;列表&gt;]</code> ：打印扩展的可读格式。</li>
<li><code>-p</code>, <code>--parse[=&lt;列表&gt;]</code> ：打印可解析格式。</li>
<li><code>-s</code>, <code>--sysroot &lt;目录&gt;</code> ：以指定目录作为系统根目录。</li>
<li><code>-x</code>, <code>--hex</code> ：打印十六进制掩码而非 CPU 列表。</li>
<li><code>-y</code>, <code>--physical</code> ：打印物理 ID 而非逻辑 ID。</li>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息。</li>
</ul>
<h2 id="示例-152"><a href="#示例-152" class="headerlink" title="示例"></a>示例</h2><p>在 i.MX8MQ 上执行 lscpu，查看 CPU 信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@imx8mqevk:~# lscpu</span><br><span class="line">Architecture:                    aarch64</span><br><span class="line">CPU op-mode(s):                  32-bit, 64-bit</span><br><span class="line">Byte Order:                      Little Endian</span><br><span class="line">CPU(s):                          4</span><br><span class="line">On-line CPU(s) list:             0-3</span><br><span class="line">Thread(s) per core:              1</span><br><span class="line">Core(s) per socket:              4</span><br><span class="line">Socket(s):                       1</span><br><span class="line">NUMA node(s):                    1</span><br><span class="line">Vendor ID:                       ARM</span><br><span class="line">Model:                           4</span><br><span class="line">Model name:                      Cortex-A53</span><br><span class="line">Stepping:                        r0p4</span><br><span class="line">CPU max MHz:                     1300.0000</span><br><span class="line">CPU min MHz:                     800.0000</span><br><span class="line">BogoMIPS:                        16.66</span><br><span class="line">NUMA node0 CPU(s):               0-3</span><br><span class="line">Vulnerability Itlb multihit:     Not affected</span><br><span class="line">Vulnerability L1tf:              Not affected</span><br><span class="line">Vulnerability Mds:               Not affected</span><br><span class="line">Vulnerability Meltdown:          Not affected</span><br><span class="line">Vulnerability Spec store bypass: Not affected</span><br><span class="line">Vulnerability Spectre v1:        Mitigation; __user pointer sanitization</span><br><span class="line">Vulnerability Spectre v2:        Not affected</span><br><span class="line">Vulnerability Srbds:             Not affected</span><br><span class="line">Vulnerability Tsx async abort:   Not affected</span><br><span class="line">Flags:                           fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid</span><br></pre></td></tr></table></figure>



<p>各字段说明如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Architecture:        <span class="comment"># 架构</span></span><br><span class="line">CPU op-mode(s):      <span class="comment"># CPU运行模式</span></span><br><span class="line">Byte Order:          <span class="comment"># 字节序</span></span><br><span class="line">CPU(s):              <span class="comment"># 逻辑CPU颗数</span></span><br><span class="line">On-line CPU(s) list: <span class="comment"># 在线CPU列表</span></span><br><span class="line">Thread(s) per core:  <span class="comment"># 每个核的线程数</span></span><br><span class="line">Core(s) per socket:  <span class="comment"># 每个CPU插槽核数/每颗物理CPU核数</span></span><br><span class="line">CPU socket(s):       <span class="comment"># CPU插槽数</span></span><br><span class="line">NUMA node(s):        <span class="comment"># NUMA节点</span></span><br><span class="line">Vendor ID:           <span class="comment"># CPU厂商ID</span></span><br><span class="line">CPU family:          <span class="comment"># CPU系列</span></span><br><span class="line">Model:               <span class="comment"># 型号</span></span><br><span class="line">Model name:          <span class="comment"># 型号名称</span></span><br><span class="line">Stepping:            <span class="comment"># 步进</span></span><br><span class="line">CPU MHz:             <span class="comment"># CPU主频</span></span><br><span class="line">CPU max MHz:         <span class="comment"># CPU最大主频</span></span><br><span class="line">CPU min MHz:         <span class="comment"># CPU最小主频</span></span><br><span class="line">Virtualization:      <span class="comment"># CPU支持的虚拟化技术</span></span><br><span class="line">L1d cache:           <span class="comment"># 一级缓存（CPU的L1数据缓存）</span></span><br><span class="line">L1i cache:           <span class="comment"># 一级缓存（CPU的L1指令缓存）</span></span><br><span class="line">L2 cache:            <span class="comment"># 二级缓存</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>另外，除了 lscpu，通常还会从 &#x2F;sys 和 &#x2F;proc 获取 CPU 相关信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure>



<p>查看 cpu0 当前工作频率</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq</span><br></pre></td></tr></table></figure>





<h1 id="Linux-chsh-命令-更改登录-Shell"><a href="#Linux-chsh-命令-更改登录-Shell" class="headerlink" title="Linux chsh 命令 - 更改登录 Shell"></a>Linux chsh 命令 - 更改登录 Shell</h1><h2 id="介绍-153"><a href="#介绍-153" class="headerlink" title="介绍"></a>介绍</h2><p><strong>chsh</strong>（英文全拼：change shell）命令用于更改用户登录 shell。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chsh [选项] [登录]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-R</code>, <code>--root CHROOT_DIR</code> ：在 <code>CHROOT_DIR</code> 目录中应用更改并使用 <code>CHROOT_DIR</code> 目录中的配置文件。</li>
<li><code>-s</code>, <code>--shell SHELL</code> ：用户的新登录 shell 的名称（将此字段设置为空会让系统选择默认的登录 shell）。</li>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息并退出。</li>
</ul>
<h2 id="示例-153"><a href="#示例-153" class="headerlink" title="示例"></a>示例</h2><p>查看系统支持的 shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/shells </span><br><span class="line"><span class="comment"># /etc/shells: valid login shells</span></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/bin/rbash</span><br><span class="line">/usr/bin/rbash</span><br><span class="line">/bin/dash</span><br><span class="line">/usr/bin/dash</span><br></pre></td></tr></table></figure>



<p>查看当前登录的 shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>



<p>查看当前用户设置的默认 shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/passwd | grep sh</span><br><span class="line">rudy:x:1000:1000:rudy,,,:/home/rudy:/bin/bash</span><br></pre></td></tr></table></figure>



<p>将当前用户的默认 shell 由 bash 修改为 dash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chsh -s /bin/dash</span><br></pre></td></tr></table></figure>



<p>再次查看当前用户设置的默认 shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/passwd | grep sh</span><br><span class="line">rudy:x:1000:1000:rudy,,,:/home/rudy:/bin/dash</span><br></pre></td></tr></table></figure>



<p>将当前用户的默认 shell 设置回 bash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chsh -s /bin/bash</span><br></pre></td></tr></table></figure>





<h1 id="Linux-chroot-命令-改变根目录"><a href="#Linux-chroot-命令-改变根目录" class="headerlink" title="Linux chroot 命令 - 改变根目录"></a>Linux chroot 命令 - 改变根目录</h1><h2 id="介绍-154"><a href="#介绍-154" class="headerlink" title="介绍"></a>介绍</h2><p><strong>chroot</strong>（英文全称：change root directory）命令用于改变根目录。</p>
<p>Linux 系统的目录结构默认都是以 root 根目录（即 <code>/</code>）开始的，使用 chroot 命令可以将指定的目录作为根目录。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chroot</span> [OPTION] NEWROOT [COMMAND [ARG]...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>--groups=G_LIST</code> ：指定补充组，如 g1, g2, … , gN。</li>
<li><code>--userspec=USER:GROUP</code> ：指定使用的用户和组（通过 ID 或 name）。</li>
<li><code>--skip-chdir</code> ：不用将工作目录更改为 <code>/</code>。</li>
<li><code>--help</code> ：显示帮助信息并退出。</li>
<li><code>--version</code> ：显示版本信息并退出。</li>
</ul>
<p>如果没有指定 COMMAND 命令，chroot 默认会执行 <code>${SHELL} -i</code>，进入 shell 交互模式。</p>
<h2 id="示例-154"><a href="#示例-154" class="headerlink" title="示例"></a>示例</h2><p>假设 &#x2F;opt&#x2F;rootfs 目录是一个可用的文件系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> /opt/rootfs/</span><br><span class="line">bin  boot  dev  etc  home  lib  media  mnt  opt  proc  run  sbin  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>



<p>先执行下面命令查看当前进程指向的根目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -ld /proc/self/root</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun  5 14:14 /proc/self/root -&gt; /</span><br></pre></td></tr></table></figure>



<p>查看当前根文件系统的 &#x2F;etc&#x2F;version 信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/version</span><br><span class="line">20210330083304</span><br></pre></td></tr></table></figure>



<p>查看执行 chroot 后的 &#x2F;etc&#x2F;version 信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">chroot</span> /opt/rootfs <span class="built_in">cat</span> /etc/version</span><br><span class="line">20210605043324</span><br></pre></td></tr></table></figure>



<p>不带命令执行 chroot</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">chroot</span> /opt/rootfs</span><br></pre></td></tr></table></figure>



<p>再次查看此时的 &#x2F;etc&#x2F;version 信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/version</span><br><span class="line">20210605043324</span><br></pre></td></tr></table></figure>



<p>执行 <code>exit</code> 退出并返回到原来的根文件系统。</p>
<h1 id="Linux-getconf-命令-查询系统配置变量"><a href="#Linux-getconf-命令-查询系统配置变量" class="headerlink" title="Linux getconf 命令 - 查询系统配置变量"></a>Linux getconf 命令 - 查询系统配置变量</h1><h2 id="介绍-155"><a href="#介绍-155" class="headerlink" title="介绍"></a>介绍</h2><p><strong>getconf</strong>（英文全拼：get system configuration）命令用于查询系统配置变量的值。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getconf -a</span><br><span class="line">getconf [-v specification] system_var</span><br><span class="line">getconf [-v specification] path_var pathname</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code> ：显示当前系统的所有配置变量（configuration variables）及其值。</li>
<li><code>-v</code> ：指示获取配置变量的规范和版本。</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li><code>system_var</code> ：系统变量（具体系统变量名称参考 sysconf 或 confstr 定义）。</li>
<li><code>path_var</code> ：路径名称（具体参考 pathconf 定义），必须带上 pathname 参数。</li>
</ul>
<h2 id="示例-155"><a href="#示例-155" class="headerlink" title="示例"></a>示例</h2><p>查看当前系统的所有配置变量及其对应的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ getconf  -a</span><br><span class="line">LINK_MAX                           65000</span><br><span class="line">_POSIX_LINK_MAX                    65000</span><br><span class="line">MAX_CANON                          255</span><br><span class="line">_POSIX_MAX_CANON                   255</span><br><span class="line">MAX_INPUT                          255</span><br><span class="line">_POSIX_MAX_INPUT                   255</span><br><span class="line">NAME_MAX                           255</span><br><span class="line">_POSIX_NAME_MAX                    255</span><br><span class="line">PATH_MAX                           4096</span><br><span class="line">_POSIX_PATH_MAX                    4096</span><br><span class="line">PIPE_BUF                           4096</span><br><span class="line">_POSIX_PIPE_BUF                    4096</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>查看 Linux 内存页大小（单位字节）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ getconf PAGE_SIZE</span><br><span class="line">4096</span><br></pre></td></tr></table></figure>



<p>查看 &#x2F;usr 目录内的文件名允许的最大字节数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ getconf NAME_MAX /usr</span><br><span class="line">255</span><br></pre></td></tr></table></figure>



<p>查看 Linux 系统位数（32 位 &#x2F; 64 位）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ getconf LONG_BIT</span><br><span class="line">64</span><br></pre></td></tr></table></figure>





<h1 id="Linux-crontab-命令-定时任务表"><a href="#Linux-crontab-命令-定时任务表" class="headerlink" title="Linux crontab 命令 - 定时任务表"></a>Linux crontab 命令 - 定时任务表</h1><h2 id="介绍-156"><a href="#介绍-156" class="headerlink" title="介绍"></a>介绍</h2><p><strong>crontab</strong>（英文全拼：cron table）命令用于查看或设定在 Linux 系统中定期执行程序。</p>
<p>cron 是 Linux 系统中常用的任务规划软件，cron 是一个守护进程，用户可以通过 crontab 命令要求系统在特定的时间执行特定的任务。适用于需要周期性自动化执行的工作。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab [ -u user ] file</span><br><span class="line">crontab [ -u user ] [ -i ] &#123; -e | -l | -r &#125;</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-u user</code> ：指定操作时程表（crontab）的用户，如果不指定，则使用当前用户。</li>
<li><code>-e</code> ：执行文字编辑器来设定时程表，支持多种文字编辑器，如 nano、vim、emacs 等。</li>
<li><code>-r</code> ：删除目前的时程表。</li>
<li><code>-l</code> ：列出目前的时程表。</li>
<li><code>-i</code> ：使用 -r 选项删除时程表之前提示用户输入 ‘y&#x2F;Y’ 回复。</li>
</ul>
<p>crontab 时间格式如下所示，用户也可以将所有的设定先存放在文件中，再从 file 参数引入。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">f1   f2   f3   f4   f5   program</span><br><span class="line">*    *    *    *    *    *</span><br><span class="line">-    -    -    -    -    - <span class="built_in">command</span> to be executed</span><br><span class="line">|    |    |    |    |</span><br><span class="line">|    |    |    |    +----- day of week (0-7) (Sunday=0/7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line">|    |    |    +---------- month (1-12) OR jan,feb,mar,apr ...</span><br><span class="line">|    |    +--------------- day of month (1-31)</span><br><span class="line">|    +-------------------- hour (0-23)</span><br><span class="line">+------------------------- minute (0-59)</span><br></pre></td></tr></table></figure>



<ul>
<li>其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。</li>
<li>当 f1 为 <code>*</code> 时表示每分钟都要执行 program，f2 为 <code>*</code> 时表示每小时都要执行程序，其余类推。</li>
<li>当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其余类推。</li>
<li>当 f1 为 <code>*/n</code> 时表示每 n 分钟个时间间隔执行一次，f2 为 <code>*/n</code> 表示每 n 小时个时间间隔执行一次，其余类推。</li>
<li>当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其余类推。</li>
</ul>
<h2 id="示例-156"><a href="#示例-156" class="headerlink" title="示例"></a>示例</h2><p>每一分钟执行一次 getiot.sh 脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* * * * * /opt/getiot.sh 1&gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>



<p>每十分钟检查一次磁盘空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*/10 * * * * /home/getiot/bin/check-disk-space</span><br></pre></td></tr></table></figure>



<p>每天上午 9 点到下午 6 点，每一小时检查一次数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">00 09-18 * * * /home/getiot/bin/check-db-status</span><br></pre></td></tr></table></figure>



<p>每个工作日（周一到周五）上午 9 点到下午 6 点，每一小时检查一次数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">00 09-18 * * 1-5 /home/getiot/bin/check-db-status</span><br></pre></td></tr></table></figure>



<p>在 12 月内，每天的早上 6 点到 12 点，每隔 3 个小时执行一次 &#x2F;usr&#x2F;bin&#x2F;backup</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">00 06-12/3 * 12 * /usr/bin/backup</span><br></pre></td></tr></table></figure>



<p>周一到周五每天下午 5 点给 <a href="mailto:&#114;&#x75;&#x64;&#121;&#x40;&#x67;&#101;&#116;&#105;&#x6f;&#116;&#46;&#x74;&#101;&#x63;&#104;">rudy@getiot.tech</a> 寄一封信</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">00 17 * * 1-5 mail -s <span class="string">&quot;hi&quot;</span> rudy@getiot.tech &lt; /tmp/maildata</span><br></pre></td></tr></table></figure>





<h1 id="Linux-reboot-命令-重启系统"><a href="#Linux-reboot-命令-重启系统" class="headerlink" title="Linux reboot 命令 - 重启系统"></a>Linux reboot 命令 - 重启系统</h1><h2 id="介绍-157"><a href="#介绍-157" class="headerlink" title="介绍"></a>介绍</h2><p>在 Linux 系统中，<strong>reboot</strong> 命令用于重新启动计算机，类似于 Windows 系统中的 <code>restart</code> 命令。需要注意，机器重启必须要 root 用户才有权限。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reboot [OPTIONS...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-n</code>：在重启之前不做将记忆体资料写回硬盘的动作，即没有同步操作。</li>
<li><code>-w</code>：并不会真的重启，只是把记录写到 &#x2F;var&#x2F;log&#x2F;wtmp 文件里。</li>
<li><code>-d</code>：不把记录写到 &#x2F;var&#x2F;log&#x2F;wtmp 文件里（<code>-n</code> 选项包含了 <code>-d</code>）。</li>
<li><code>-f</code>：强制重启，不呼叫 <code>shutdown</code> 这个指令。</li>
<li><code>-i</code>：在重启之前先把所有网络相关的设备停止。</li>
</ul>
<h2 id="示例-157"><a href="#示例-157" class="headerlink" title="示例"></a>示例</h2><p>重新启动机器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>



<p>模拟重开机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reboot -w</span><br></pre></td></tr></table></figure>





<h1 id="Linux-poweroff-命令-关闭系统电源"><a href="#Linux-poweroff-命令-关闭系统电源" class="headerlink" title="Linux poweroff 命令 - 关闭系统电源"></a>Linux poweroff 命令 - 关闭系统电源</h1><h2 id="介绍-158"><a href="#介绍-158" class="headerlink" title="介绍"></a>介绍</h2><p>在 Linux 系统中，<strong>poweroff</strong> 命令用来关闭计算机操作系统并且切断系统电源。如果确认系统中已经没有用户存在且所有数据都已保存，需要立即关闭系统，可以使用 <code>poweroff</code> 命令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">poweroff [OPTIONS...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-n</code>：关闭操作系统时不执行 sync 操作。</li>
<li><code>-w</code>：不真正关闭操作系统，仅在日志文件 &#x2F;var&#x2F;log&#x2F;wtmp 中记录。</li>
<li><code>-d</code>：关闭操作系统时，不将操作写入日志文件 &#x2F;var&#x2F;log&#x2F;wtmp 中添加相应的记录。</li>
<li><code>-f</code>：强制关闭操作系统。</li>
<li><code>-i</code>：关闭操作系统之前关闭所有的网络接口。</li>
<li><code>-h</code>：关闭操作系统之前将系统中所有的硬件设置为备用模式。</li>
</ul>
<h2 id="示例-158"><a href="#示例-158" class="headerlink" title="示例"></a>示例</h2><p>关闭计算机操作系统并且切断系统电源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">poweroff</span><br></pre></td></tr></table></figure>



<p>在关闭操作系统之前将系统中所有的硬件设置为备用模式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">poweroff -h</span><br></pre></td></tr></table></figure>





<h1 id="Linux-shutdown-命令-系统关机命令"><a href="#Linux-shutdown-命令-系统关机命令" class="headerlink" title="Linux shutdown 命令 - 系统关机命令"></a>Linux shutdown 命令 - 系统关机命令</h1><h2 id="介绍-159"><a href="#介绍-159" class="headerlink" title="介绍"></a>介绍</h2><p>在 Linux 系统中，<strong>shutdown</strong> 命令用来系统关机命令。shutdown 指令可以关闭所有程序，并依用户的需要，进行重新开机或关机的动作。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shutdown [OPTIONS...] [TIME] [WALL...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-c</code>：当执行 <code>shutdown -h 11:50</code> 指令时，只要按 <code>+</code> 键就可以中断关机的指令。</li>
<li><code>-f</code>：重新启动时不执行 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/fsck/">fsck</a>。</li>
<li><code>-F</code>：重新启动时执行 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/fsck/">fsck</a>。</li>
<li><code>-h</code>：将系统关机。</li>
<li><code>-k</code>：只是送出信息给所有用户，但不会实际关机。</li>
<li><code>-n</code>：不调用init程序进行关机，而由 shutdown 自己进行。</li>
<li><code>-r</code>：shutdown 之后重新启动。</li>
<li><code>-t</code>：送出警告信息和删除信息之间要延迟多少秒。</li>
</ul>
<h2 id="示例-159"><a href="#示例-159" class="headerlink" title="示例"></a>示例</h2><p>现在立即关机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> shutdown -h now</span><br></pre></td></tr></table></figure>



<p>立即重新启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> shutdown -r now</span><br></pre></td></tr></table></figure>



<p>指定 10 分钟后关机：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> shutdown +10</span></span><br></pre></td></tr></table></figure>



<p>指定 10 分钟后关机，同时送出警告信息给登入用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> shutdown +10 <span class="string">&quot;System will shutdown after 10 minutes&quot;</span></span><br></pre></td></tr></table></figure>



<p>指定关机时间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> shutdown -h 22:12</span></span><br></pre></td></tr></table></figure>



<p>取消按预定时间关闭系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ shutdown -c</span><br></pre></td></tr></table></figure>





<h1 id="Linux-systemctl-命令-系统和服务管理"><a href="#Linux-systemctl-命令-系统和服务管理" class="headerlink" title="Linux systemctl 命令 - 系统和服务管理"></a>Linux systemctl 命令 - 系统和服务管理</h1><h2 id="介绍-160"><a href="#介绍-160" class="headerlink" title="介绍"></a>介绍</h2><p><strong>systemctl</strong>（英文全拼：system control）用于控制 systemd 系统和管理服务。</p>
<p>systemd 是目前 Linux 系统上主要的系统守护进程管理工具，由于 init 一方面对于进程的管理是串行化的，容易出现阻塞情况，另一方面 init 也仅仅是执行启动脚本，并不能对服务本身进行更多的管理。所以许多 Linux 发行版都由 systemd 取代了 init 作为默认的系统进程管理工具。</p>
<p>systemd 所管理的所有系统资源都称作 Unit，通过 systemd 命令集可以方便的对这些 Unit 进行管理。比如 systemctl、hostnamectl、timedatectl、localctl 等命令，这些命令虽然改写了 init 时代用户的命令使用习惯（不再使用 chkconfig、service 等命令），但确实也提供了很大的便捷性。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl [OPTIONS...] COMMAND [UNIT...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<p>command 选项字如下：</p>
<ul>
<li><code>start</code>：启动指定的 unit。</li>
<li><code>stop</code>：关闭指定的 unit。</li>
<li><code>restart</code>：重启指定 unit。</li>
<li><code>reload</code>：重载指定 unit。</li>
<li><code>enable</code>：系统开机时自动启动指定 unit，前提是配置文件中有相关配置。</li>
<li><code>disable</code>：开机时不自动运行指定 unit。</li>
<li><code>status</code>：查看指定 unit 当前运行状态。</li>
</ul>
<p><strong>参数</strong>：unit 是要配置的服务名称。</p>
<h2 id="示例-160"><a href="#示例-160" class="headerlink" title="示例"></a>示例</h2><p>重新加载 systemd unit 配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl --system daemon-reload</span><br></pre></td></tr></table></figure>



<p>查看一个 service 的状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status xxx.service</span><br></pre></td></tr></table></figure>



<p>启动和停止这个 service（本次启动有效）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start xxx.service</span><br><span class="line">systemctl stop xxx.service</span><br></pre></td></tr></table></figure>



<p>使能或关闭一个 service（下次启动有效）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> xxx.service</span><br><span class="line">systemctl <span class="built_in">disable</span> xxx.service</span><br></pre></td></tr></table></figure>



<p>上述 xxx.service 的后缀都是可以省略的，例如 nginx.service 可以直接写 nginx。</p>
<h1 id="Linux-timedatectl-命令-时间日期控制"><a href="#Linux-timedatectl-命令-时间日期控制" class="headerlink" title="Linux timedatectl 命令 - 时间日期控制"></a>Linux timedatectl 命令 - 时间日期控制</h1><h2 id="介绍-161"><a href="#介绍-161" class="headerlink" title="介绍"></a>介绍</h2><p><strong>timedatectl</strong>（英文全拼：timedate control）命令用于在 Linux 中设置或查询系统时间、日期和时区等配置。在 Linux 运维中，通常使用此命令来设置或更改当前的日期、时间和时区，或启用自动系统时钟与远程 NTP 服务器同步，以确保 Linux 系统始终保持正确的时间。</p>
<p>systemd 是目前 Linux 系统上主要的系统守护进程管理工具，由于 init 一方面对于进程的管理是串行化的，容易出现阻塞情况，另一方面 init 也仅仅是执行启动脚本，并不能对服务本身进行更多的管理。所以许多 Linux 发行版都由 systemd 取代了 init 作为默认的系统进程管理工具。</p>
<p>systemd 所管理的所有系统资源都称作 Unit，通过 systemd 命令集可以方便的对这些 Unit 进行管理。比如 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/systemctl/">systemctl</a>、hostnamectl、timedatectl、localctl 等命令，这些命令虽然改写了 init 时代用户的命令使用习惯（不再使用 chkconfig、service 等命令），但确实也提供了很大的便捷性。</p>
<p>从版本号 213 的 systemd 开始，包括了一个名为 <strong>systemd-timesyncd</strong> 的守护进程，将能够和远程的 NTP 服务器同步时间。此守护进程并不是为了取代已有的 NTP 服务，而是作为 SNTP 协议的实现客户端，它可用于更高级的任务和资源有限的系统。从版本号 216 的 systemd 开始，systemd-timesyncd 守护进程默认启用。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">timedatectl [OPTIONS...] COMMAND ...</span><br></pre></td></tr></table></figure>



<p><strong>命令</strong>：</p>
<ul>
<li><code>status</code> ：显示当前的时间设置。</li>
<li><code>show</code> ：显示 systemd-timedated 的属性。</li>
<li><code>set-time TIME</code> ：设置系统时间。</li>
<li><code>set-timezone ZONE</code> ：设置系统时区。</li>
<li><code>list-timezones</code> ：显示已知时区。</li>
<li><code>set-local-rtc BOOL</code> ：控制 RTC 是否在当地时间。（BOOL 的值可以是 1 &#x2F; true 或 0 &#x2F; false）</li>
<li><code>set-ntp BOOL</code> ：启用或禁用网络时间同步。（BOOL 的值可以是 1 &#x2F; true 或 0 &#x2F; false）</li>
<li><code>timesync-status</code> ：显示 systemd-timesyncd 的状态。</li>
<li><code>show-timesync</code> ：显示 systemd-timesyncd 的属性。</li>
</ul>
<p><strong>选项</strong>：</p>
<ul>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息。</li>
<li><code>--version</code> ：显示软件包版本。</li>
<li><code>--no-pager</code> ：不用将输出通过管道传输到寻呼机（pager）。</li>
<li><code>--no-ask-password</code> ：不提示输入密码。</li>
<li><code>-H</code>, <code>--host=[USER@]HOST</code> ：在远程主机上操作。</li>
<li><code>-M</code>, <code>--machine=CONTAINER</code> ：在本地容器上操作。</li>
<li><code>--adjust-system-clock</code> ：更改本地 RTC 模式时调整系统时钟。</li>
<li><code>--monitor</code> ：监控 systemd-timesyncd 的状态。</li>
<li><code>-p</code>, <code>--property=NAME</code> ：仅显示此名称的属性。</li>
<li><code>-a</code>, <code>--all</code> ：显示所有属性，包括空属性。</li>
<li><code>--value</code> ：显示属性时，只打印值。</li>
</ul>
<h2 id="示例-161"><a href="#示例-161" class="headerlink" title="示例"></a>示例</h2><p>显示系统当前时间和日期</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">timedatectl status</span></span><br><span class="line">               Local time: Tue 2021-09-14 16:02:41 CST</span><br><span class="line">           Universal time: Tue 2021-09-14 08:02:41 UTC</span><br><span class="line">                 RTC time: Tue 2021-09-14 16:02:35</span><br><span class="line">                Time zone: Asia/Shanghai (CST, +0800)</span><br><span class="line">System clock synchronized: yes</span><br><span class="line">              NTP service: active</span><br><span class="line">          RTC in local TZ: no</span><br></pre></td></tr></table></figure>



<p>显示 systemd-timedated 的属性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">timedatectl show</span></span><br><span class="line">Timezone=Asia/Shanghai</span><br><span class="line">LocalRTC=no</span><br><span class="line">CanNTP=yes</span><br><span class="line">NTP=yes</span><br><span class="line">NTPSynchronized=yes</span><br><span class="line">TimeUSec=Tue 2021-09-14 16:42:06 CST</span><br><span class="line">RTCTimeUSec=Tue 2021-09-14 16:42:06 CST</span><br></pre></td></tr></table></figure>



<p>显示系统所有可用的时区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">timedatectl list-timezones</span></span><br></pre></td></tr></table></figure>



<p>将本地时区从上海（Asia&#x2F;Shanghai）设置为阿姆斯特丹（Europe&#x2F;Amsterdam）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">timedatectl set-timezone <span class="string">&quot;Europe/Amsterdam&quot;</span></span></span><br></pre></td></tr></table></figure>



<p>将本地时区设置为协调世界时（UTC）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">timedatectl set-timezone UTC</span></span><br></pre></td></tr></table></figure>



<p>设置系统时间（格式：<code>HH:MM:SS</code>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">timedatectl set-time <span class="string">&quot;07:25:46&quot;</span></span></span><br></pre></td></tr></table></figure>



<p>设置系统日期（格式：<code>YYYY-MM-DD</code>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">timedatectl set-time <span class="string">&quot;2021-12-12&quot;</span></span></span><br></pre></td></tr></table></figure>



<p>如果只设置日期，那么时间将默认设置为 “00:00:00”（建议同时设置日期和时间）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">timedatectl set-time <span class="string">&quot;2021-12-12 07:25:46&quot;</span></span></span><br></pre></td></tr></table></figure>



<p>将硬件时钟（RTC）设置为本地时区（不建议，RTC 时钟统一使用 UTC 更恰当，避免在时区更改和夏令时调整方面产生各种问题）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">timedatectl set-local-rtc 1</span></span><br></pre></td></tr></table></figure>



<p>将硬件时钟（RTC）设置为协调世界时间（UTC）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">timedatectl set-local-rtc 0</span></span><br></pre></td></tr></table></figure>



<p>启用 NTP 自动时间同步</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">timedatectl set-ntp <span class="literal">true</span></span></span><br></pre></td></tr></table></figure>



<p>禁用 NTP 自动时间同步</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">timedatectl set-ntp <span class="literal">false</span></span></span><br></pre></td></tr></table></figure>



<p>查看 systemd-timesyncd 服务的状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">timedatectl timesync-status</span></span><br><span class="line">       Server: 91.189.94.4 (ntp.ubuntu.com)</span><br><span class="line">Poll interval: 17min 4s (min: 32s; max 34min 8s)</span><br><span class="line">         Leap: normal</span><br><span class="line">      Version: 4</span><br><span class="line">      Stratum: 2</span><br><span class="line">    Reference: 91EECB0E</span><br><span class="line">    Precision: 1us (-23)</span><br><span class="line">Root distance: 29.922ms (max: 5s)</span><br><span class="line">       Offset: +2.497ms</span><br><span class="line">        Delay: 199.540ms</span><br><span class="line">       Jitter: 5.834ms</span><br><span class="line"> Packet count: 6</span><br><span class="line">    Frequency: +13.039ppm</span><br></pre></td></tr></table></figure>



<p>systemd-timedated 可能默认配置了谷歌的 NTP 服务器（如 time1.google.com），为了顺利完成网络时间同步，您可以编辑 &#x2F;etc&#x2F;systemd&#x2F;timesyncd.conf 文件添加自己的 NTP 服务器地址。</p>
<p>相关文章：<a target="_blank" rel="noopener" href="https://getiot.tech/linux/linux-date-time-synchronization/">Linux 时间同步</a></p>
<h1 id="Linux-nproc-命令-显示可用处理器数"><a href="#Linux-nproc-命令-显示可用处理器数" class="headerlink" title="Linux nproc 命令 - 显示可用处理器数"></a>Linux nproc 命令 - 显示可用处理器数</h1><h2 id="介绍-162"><a href="#介绍-162" class="headerlink" title="介绍"></a>介绍</h2><p><strong>nproc</strong> 命令用于打印 Linux 系统当前进程可用的处理器数，注意此数目可能小于实际的 CPU 核心数。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nproc</span> [OPTION]...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>--all</code>：打印所拥有的处理器数目。</li>
<li><code>--ignore=N</code>：可能的话，排除 N 个处理单元。</li>
<li><code>--help</code>：显示此帮助信息并退出。</li>
<li><code>--version</code>：显示版本信息并退出。</li>
</ul>
<h2 id="示例-162"><a href="#示例-162" class="headerlink" title="示例"></a>示例</h2><p>在我的 Ubuntu 上直接执行 <code>nproc</code>，输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">nproc</span> </span><br><span class="line">8</span><br></pre></td></tr></table></figure>



<p><code>nproc</code> 命令本身很简单，更多的是用在 Shell 脚本中，例如 <code>make</code> 时以进程可用的最大核心数进行编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>





<h1 id="Linux-lsb-release-命令-显示-LSB-信息"><a href="#Linux-lsb-release-命令-显示-LSB-信息" class="headerlink" title="Linux lsb_release 命令 - 显示 LSB 信息"></a>Linux lsb_release 命令 - 显示 LSB 信息</h1><h2 id="介绍-163"><a href="#介绍-163" class="headerlink" title="介绍"></a>介绍</h2><p><strong>lsb_release</strong> 命令用于打印 Linux 发行版的系统信息，其中 LSB 是 Linux Standard Base 的缩写。需要注意，该命令并非在所有 Linux 系统上都可用，只在一部分 Linux 系统可用，例如 Ubuntu。</p>
<p>lsb_release 命令输出的信息通常位于 <code>/etc/lsb-release</code> 文件。另外，在所有基于 systemd 的 Linux 发行版中，都会使用 <code>/etc/os-release</code> 文件作为发行版的信息存储，保存诸如 Linux 发行版的类型、版本型号等基本信息。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsb_release [options]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-h</code>, <code>--help</code>：显示帮助信息。</li>
<li><code>-v</code>, <code>--version</code>：显示系统支持的 LSB 模块。</li>
<li><code>-i</code>, <code>--id</code>：显示发行版的 ID。</li>
<li><code>-d</code>, <code>--description</code>：显示发行版的描述信息。</li>
<li><code>-r</code>, <code>--release</code>：显示发行版的发布版本号。</li>
<li><code>-c</code>, <code>--codename</code>：显示发行版的代号。</li>
<li><code>-a</code>, <code>--all</code>：显示发行版的所有信息。</li>
<li><code>-s</code>, <code>--short</code>：以简短格式显示，和其他选项配合使用。</li>
</ul>
<h2 id="示例-163"><a href="#示例-163" class="headerlink" title="示例"></a>示例</h2><p>显示当前 Linux 发行版的所有信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:	Ubuntu</span><br><span class="line">Description:	Ubuntu 20.04.4 LTS</span><br><span class="line">Release:	20.04</span><br><span class="line">Codename:	focal</span><br></pre></td></tr></table></figure>



<p>作为对比，这里将 <code>/etc/lsb-release</code> 文件内容打印出来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/lsb-release </span><br><span class="line">DISTRIB_ID=Ubuntu</span><br><span class="line">DISTRIB_RELEASE=20.04</span><br><span class="line">DISTRIB_CODENAME=focal</span><br><span class="line">DISTRIB_DESCRIPTION=<span class="string">&quot;Ubuntu 20.04.4 LTS&quot;</span></span><br></pre></td></tr></table></figure>



<p>同时将 <code>/etc/os-release</code> 文件内容也打印出来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/os-release </span><br><span class="line">NAME=<span class="string">&quot;Ubuntu&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;20.04.4 LTS (Focal Fossa)&quot;</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">&quot;Ubuntu 20.04.4 LTS&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;20.04&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;https://www.ubuntu.com/&quot;</span></span><br><span class="line">SUPPORT_URL=<span class="string">&quot;https://help.ubuntu.com/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.launchpad.net/ubuntu/&quot;</span></span><br><span class="line">PRIVACY_POLICY_URL=<span class="string">&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span></span><br><span class="line">VERSION_CODENAME=focal</span><br><span class="line">UBUNTU_CODENAME=focal</span><br></pre></td></tr></table></figure>





<h1 id="Linux-sysctl-命令-读取-设置内核参数"><a href="#Linux-sysctl-命令-读取-设置内核参数" class="headerlink" title="Linux sysctl 命令 - 读取&#x2F;设置内核参数"></a>Linux sysctl 命令 - 读取&#x2F;设置内核参数</h1><h2 id="介绍-164"><a href="#介绍-164" class="headerlink" title="介绍"></a>介绍</h2><p><strong>sysctl</strong>（英文全拼：system control）命令被用于在 Linux 内核运行时动态地修改内核的运行参数。可用的内核参数会导出到 &#x2F;proc 文件系统的 sys 目录中，其中包含一些 TCP&#x2F;IP 堆栈和虚拟内存系统的高级选项，可用来控制 Linux 网络配置，这些参数对于系统性能非常重要。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl [options] [variable[=value] ...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>, <code>--all</code>：显示所有变量。</li>
<li><code>--deprecated</code>：将不推荐使用的参数包含到列表中。</li>
<li><code>-b</code>, <code>--binary</code>：打印值但不换行。</li>
<li><code>-e</code>, <code>--ignore</code>：忽略未知变量错误。</li>
<li><code>-N</code>, <code>--names</code>：打印没有值的变量名称。</li>
<li><code>-n</code>, <code>--values</code>：仅打印给定变量的值。</li>
<li><code>-p</code>, <code>--load[=&lt;file&gt;]</code>：从文件中读取值。</li>
<li><code>--system</code>：从所有系统目录读取值。</li>
<li><code>-r</code>, <code>--pattern &lt;expression&gt;</code>：选择与表达式匹配的设置。</li>
<li><code>-q</code>, <code>--quiet</code>：不回显变量集。</li>
<li><code>-w</code>, <code>--write</code>：允许将值写入变量。</li>
<li><code>-h</code>, <code>--help</code>：显示帮助信息。</li>
<li><code>-V</code>, <code>--version</code>：显示版本信息。</li>
</ul>
<h2 id="示例-164"><a href="#示例-164" class="headerlink" title="示例"></a>示例</h2><p>查看所有可读变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -a</span><br></pre></td></tr></table></figure>



<p>重新加载 &#x2F;etc&#x2F;sysctl.conf 配置文件，使配置生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>





<h1 id="Linux-locale-命令-显示区域设置"><a href="#Linux-locale-命令-显示区域设置" class="headerlink" title="Linux locale 命令 - 显示区域设置"></a>Linux locale 命令 - 显示区域设置</h1><h2 id="介绍-165"><a href="#介绍-165" class="headerlink" title="介绍"></a>介绍</h2><p><strong>locale</strong> 命令用于显示 Linux 系统本地语言环境等有关信息。如果未指定任何选项与参数，locale 将会显示 <code>LC_*</code> 系列环境变量表示的每个本地语言环境类别的当前设置。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locale [选项...] [names]</span><br><span class="line">locale [选项...] [-a|-m]</span><br></pre></td></tr></table></figure>



<p>其中，<code>names</code> 是 IEEE Std 1003.1-2001 定义的本地语言环境的类别，例如：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td><code>LC_CTYPE</code></td>
<td>字符集编码定义</td>
</tr>
<tr>
<td><code>LC_COLLATE</code></td>
<td>排序原则与顺序定义</td>
</tr>
<tr>
<td><code>LC_TIME</code></td>
<td>日期与时间格式定义</td>
</tr>
<tr>
<td><code>LC_NUMERIC</code></td>
<td>非钱币的小数点与千分号定义</td>
</tr>
<tr>
<td><code>LC_MONETARY</code></td>
<td>钱币符号、小数点与千分号等定义</td>
</tr>
<tr>
<td><code>LC_MESSAGES</code></td>
<td>肯定与否定回答定义</td>
</tr>
<tr>
<td><code>LC_NAME</code></td>
<td>称呼定义</td>
</tr>
</tbody></table>
<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>, <code>--all-locales</code>：输出系统支持的所有本地语言环境。</li>
<li><code>-m</code>, <code>--charmaps</code>：显示可用字符集的名字，如 UTF-8（中文字符集）。</li>
<li><code>-c</code>, <code>--category-name</code>：显示命令行参数指定的本地语言类别的详细定义。有效的本地语言类别是 <code>LC_CTYPE</code> 等。</li>
<li><code>-k</code>, <code>--keyword-name</code>：显示选定关键字（如 ctype-class-names）的定义。</li>
<li><code>-v</code>, <code>--verbose</code>：详细显示模式。</li>
<li><code>--usage</code>：显示命令的简要用法。</li>
<li><code>-?</code>, <code>--help</code>：显示命令的帮助信息，然后退出。</li>
<li><code>-V</code>, <code>--version</code>：显示命令的版本和版权等信息，然后退出。</li>
</ul>
<h2 id="示例-165"><a href="#示例-165" class="headerlink" title="示例"></a>示例</h2><p>显示系统支持的所有本地语言环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ locale -av</span><br><span class="line">locale: zh_CN.utf8      archive: /usr/lib/locale/locale-archive</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">    title | Chinese locale <span class="keyword">for</span> Peoples Republic of China</span><br><span class="line">    email | bug-glibc-locales@gnu.org</span><br><span class="line"> language | Chinese</span><br><span class="line">territory | China</span><br><span class="line"> revision | 0.1</span><br><span class="line">     <span class="built_in">date</span> | 2000-07-25</span><br><span class="line">  codeset | UTF-8</span><br></pre></td></tr></table></figure>



<p>显示本地语言环境的时间表示种类与方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ locale -cv LC_TIME</span><br><span class="line">LC_TIME</span><br><span class="line">日;一;二;三;四;五;六</span><br><span class="line">星期日;星期一;星期二;星期三;星期四;星期五;星期六</span><br><span class="line">1月;2月;3月;4月;5月;6月;7月;8月;9月;10月;11月;12月</span><br><span class="line">一月;二月;三月;四月;五月;六月;七月;八月;九月;十月;十一月;十二月</span><br><span class="line">上午;下午</span><br><span class="line">%Y年%m月%d日 %A %H时%M分%S秒</span><br><span class="line">%Y年%m月%d日</span><br><span class="line">%H时%M分%S秒</span><br><span class="line">%p %I时%M分%S秒</span><br></pre></td></tr></table></figure>





<h1 id="Linux-setcap-命令-设置文件特殊权限"><a href="#Linux-setcap-命令-设置文件特殊权限" class="headerlink" title="Linux setcap 命令 - 设置文件特殊权限"></a>Linux setcap 命令 - 设置文件特殊权限</h1><h2 id="介绍-166"><a href="#介绍-166" class="headerlink" title="介绍"></a>介绍</h2><p><strong>setcap</strong>（英文全拼：set capabilities）是在 Linux 系统中用于设置特殊权限的命令工具。它允许普通用户在执行特定程序时获得一些超过其正常权限的能力。具体来说，<code>setcap</code> 命令允许用户向可执行文件或动态链接库（共享对象）设置特殊的能力。这些能力使得程序能够执行某些通常需要超级用户权限才能完成的操作，例如绑定低于 1024 端口、访问摄像头、修改网络设置等。</p>
<p>通过使用 <code>setcap</code> 命令，用户不需要将整个程序以 root 身份运行，而只需为其设置所需的能力即可。这提供了更加灵活和安全的权限控制方式，同时避免了用户以超级用户身份运行程序带来的潜在风险。需要注意的是，<code>setcap</code> 命令需要以超级用户（root）身份执行，因为设置特殊能力是一个需要特权的操作。使用时应当慎重，确保仅将特定的能力赋予可信任的程序。</p>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/getcap/">getcap</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setcap</span> [-q] [-v] [-n &lt;rootid&gt;] (-r|-|&lt;caps&gt;) &lt;filename&gt;</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-q</code>：以简洁方式输出。</li>
<li><code>-v</code>：用于验证指定的功能当前是否与该文件关联（v 是 verify 的意思）。如果提供了 <code>-v</code> 和 <code>-n</code>，则还会验证 <code>-n &lt;rootid&gt;</code> 参数。</li>
<li><code>-n &lt;rootid&gt;</code>：设置仅在具有此 rootid 所有者的命名空间中使用的文件功能。</li>
<li><code>-r</code>：从文件中删除功能集。请注意，设置空功能集与删除它不同，空集可用于保证文件不会以特权执行。</li>
<li><code>-</code>：从标准输入读取功能。在这种情况下，功能集以空行终止。</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li><code>caps</code>：功能集。详细参考下面说明。</li>
<li><code>filename</code>：文件名称。</li>
</ul>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>Linux 内核从 2.2 版本开始，就增加了 Capabilities 的概念与机制，并随着版本升高逐步得到改进。在 Linux 中，root 权限被分割为以下 29 种能力：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CAP_CHOWN            <span class="comment"># 修改文件属主的权限</span></span><br><span class="line">CAP_DAC_OVERRIDE     <span class="comment"># 忽略文件的 DAC 访问限制</span></span><br><span class="line">CAP_DAC_READ_SEARCH  <span class="comment"># 忽略文件读及目录搜索的 DAC 访问限制</span></span><br><span class="line">CAP_FOWNER           <span class="comment"># 忽略文件属主 ID 必须和进程用户 ID 相匹配的限制</span></span><br><span class="line">CAP_FSETID           <span class="comment"># 允许设置文件的 setuid 位</span></span><br><span class="line">CAP_KILL             <span class="comment"># 允许对不属于自己的进程发送信号</span></span><br><span class="line">CAP_SETGID           <span class="comment"># 允许改变进程的组 ID</span></span><br><span class="line">CAP_SETUID           <span class="comment"># 允许改变进程的用户 ID</span></span><br><span class="line">CAP_SETPCAP          <span class="comment"># 允许向其他进程转移能力以及删除其他进程的能力</span></span><br><span class="line">CAP_LINUX_IMMUTABLE  <span class="comment"># 允许修改文件的 IMMUTABLE 和 APPEND 属性标志</span></span><br><span class="line">CAP_NET_BIND_SERVICE <span class="comment"># 允许绑定到小于 1024 的端口</span></span><br><span class="line">CAP_NET_BROADCAST    <span class="comment"># 允许网络广播和多播访问</span></span><br><span class="line">CAP_NET_ADMIN        <span class="comment"># 允许执行网络管理任务</span></span><br><span class="line">CAP_NET_RAW          <span class="comment"># 允许使用原始套接字</span></span><br><span class="line">CAP_IPC_LOCK         <span class="comment"># 允许锁定共享内存片段</span></span><br><span class="line">CAP_IPC_OWNER        <span class="comment"># 忽略 IPC 所有权检查</span></span><br><span class="line">CAP_SYS_MODULE       <span class="comment"># 允许插入和删除内核模块</span></span><br><span class="line">CAP_SYS_RAWIO        <span class="comment"># 允许直接访问 /devport,/dev/mem,/dev/kmem 及原始块设备</span></span><br><span class="line">CAP_SYS_CHROOT       <span class="comment"># 允许使用 chroot() 系统调用</span></span><br><span class="line">CAP_SYS_PTRACE       <span class="comment"># 允许跟踪任何进程</span></span><br><span class="line">CAP_SYS_PACCT        <span class="comment"># 允许执行进程的 BSD 式审计</span></span><br><span class="line">CAP_SYS_ADMIN        <span class="comment"># 允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等</span></span><br><span class="line">CAP_SYS_BOOT         <span class="comment"># 允许重新启动系统</span></span><br><span class="line">CAP_SYS_NICE         <span class="comment"># 允许提升优先级及设置其他进程的优先级</span></span><br><span class="line">CAP_SYS_RESOURCE     <span class="comment"># 忽略资源限制</span></span><br><span class="line">CAP_SYS_TIME         <span class="comment"># 允许改变系统时钟</span></span><br><span class="line">CAP_SYS_TTY_CONFIG   <span class="comment"># 允许配置 TTY 设备</span></span><br><span class="line">CAP_MKNOD            <span class="comment"># 允许使用 mknod() 系统调用</span></span><br><span class="line">CAP_LEASE            <span class="comment"># 允许修改文件锁的 FL_LEASE 标志</span></span><br></pre></td></tr></table></figure>



<p>使用 <code>setcap</code> 命令可以分割 root 用户的特权，即将 root 的特权分割成不同的能力，每种能力代表一定的特权操作。例如，能力 <code>CAP_SYS_MODULE</code> 表示用户能够加载（或卸载）内核模块的特权操作，而 <code>CAP_SETUID</code> 表示用户能够修改进程用户身份的特权操作。在 Capbilities 中系统将根据进程拥有的能力来进行特权操作的访问控制。</p>
<p>在 Capilities 中，只有进程和可执行文件才具有能力，每个进程拥有三组能力集，分别称为 cap_effective、cap_inheritable、cap_permitted（分别简记为：<code>pE</code>、<code>pI</code>、<code>pP</code>），其中：</p>
<ul>
<li>cap_permitted 表示进程所拥有的最大能力集；</li>
<li>cap_effective 表示进程当前可用的能力集，可以看做是 cap_permitted 的一个子集；</li>
<li>cap_inheitable 则表示进程可以传递给其子进程的能力集。</li>
</ul>
<p>系统根据进程的 cap_effective 能力集进行访问控制，cap_effective 为 cap_permitted 的子集，进程可以通过取消 cap_effective 中的某些能力来放弃进程的一些特权。</p>
<p>可执行文件也拥有三组能力集，对应于进程的三组能力集，分别称为 cap_effective、cap_allowed 和 cap_forced（分别简记为 <code>fE</code>、<code>fI</code>、<code>fP</code>），其中：</p>
<ul>
<li>cap_allowed 表示程序运行时可从原进程的 cap_inheritable 中集成的能力集；</li>
<li>cap_forced 表示运行文件时必须拥有才能完成其服务的能力集；</li>
<li>cap_effective 则表示文件开始运行时可以使用的能力。</li>
</ul>
<h2 id="示例-166"><a href="#示例-166" class="headerlink" title="示例"></a>示例</h2><p>安装 Wireshark 的时候，有一步是给 dumpcap 读网卡的权限，使得普通用户也可以使用 Wireshark 进行抓包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">setcap</span> <span class="string">&#x27;CAP_NET_RAW+eip CAP_NET_ADMIN+eip&#x27;</span> /usr/sbin/dumpcap</span><br></pre></td></tr></table></figure>



<p>给可执行文件 &#x2F;bin&#x2F;ping 加上 “cap_net_admin,cap_net_raw+ep” 权限，普通用户即可使用 ping：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">setcap</span> <span class="string">&#x27;cap_net_admin,cap_net_raw+ep&#x27;</span> /bin/ping</span><br></pre></td></tr></table></figure>



<p>给 nginx 加上使用 1024 以内端口的权限（无需 root 权限）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">setcap</span> <span class="string">&#x27;cap_net_bind_service=+eip&#x27;</span> /usr/sbin/nginx</span><br></pre></td></tr></table></figure>



<p>清除 nginx 可执行文件附加的权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">setcap</span> -r nginx</span><br></pre></td></tr></table></figure>





<h1 id="Linux-getcap-命令-查看文件的特殊权限"><a href="#Linux-getcap-命令-查看文件的特殊权限" class="headerlink" title="Linux getcap 命令 - 查看文件的特殊权限"></a>Linux getcap 命令 - 查看文件的特殊权限</h1><h2 id="介绍-167"><a href="#介绍-167" class="headerlink" title="介绍"></a>介绍</h2><p><strong>getcap</strong> 命令是在 Linux 系统中用于查看文件的特殊权限（capabilities）的工具。通过运行 <code>getcap</code> 命令，你可以查询指定文件或目录上设置的特殊权限。这些特殊权限描述了该文件或目录在执行时是否有一些超出普通权限的能力。</p>
<p>特殊权限是 Linux 内核引入的一种机制，可以让特定的程序在没有完全超级用户权限的情况下执行一些具有特权的操作。而不需要将整个程序或脚本设置为以超级用户身份运行。</p>
<p>通过 <code>getcap</code> 命令，你可以了解到哪些文件具有特殊权限，以及它们所具有的特权。这可以帮助你对系统中的文件和程序进行安全审计和权限管理。</p>
<p>需要注意的是，<code>getcap</code> 命令同样需要超级用户（root）权限才能查看特殊权限。可能并不是每个文件或目录都会设置特殊权限，所以返回结果中可能会有空白行。同时，应当只赋予可信任的程序特殊权限，并遵循安全最佳实践。</p>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/setcap/">setcap</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getcap</span> [-v] [-n] [-r] [-h] filename [ ... ]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-h</code>：打印命令的简明使用说明。</li>
<li><code>-n</code>：打印与文件功能关联的任何非零名称空间 rootid 值。</li>
<li><code>-r</code>：递归搜索文件。</li>
<li><code>-v</code>：显示所有搜索到的条目，即使它没有文件功能。</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li><code>filename</code>：文件名称或目录路径。</li>
</ul>
<h2 id="示例-167"><a href="#示例-167" class="headerlink" title="示例"></a>示例</h2><p>查看 &#x2F;bin&#x2F;ping 可执行文件的特殊权限（这将显示指定文件的特殊权限，如果有的话）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">getcap</span> /bin/ping</span><br><span class="line">/bin/ping = cap_net_raw+ep</span><br></pre></td></tr></table></figure>



<p>列出系统 &#x2F;bin 目录中所有具有特殊权限的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">getcap</span> -r /bin/*</span><br><span class="line">/bin/dumpcap = cap_net_admin,cap_net_raw+eip</span><br><span class="line">/bin/gnome-keyring-daemon = cap_ipc_lock+ep</span><br><span class="line">/bin/mtr-packet = cap_net_raw+ep</span><br><span class="line">/bin/ping = cap_net_raw+ep</span><br><span class="line">/bin/traceroute6.iputils = cap_net_raw+ep</span><br></pre></td></tr></table></figure>



<p>将输出结果保存到文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">getcap</span> -r /bin/* &gt; capabilities.txt</span><br></pre></td></tr></table></figure>



<p>使用重定向操作符 <code>&gt;</code>，可以将结果输出到指定的文件中，以便后续查阅或分析。</p>
<h1 id="Linux-arp-命令-显示和修改-ARP-缓存"><a href="#Linux-arp-命令-显示和修改-ARP-缓存" class="headerlink" title="Linux arp 命令 - 显示和修改 ARP 缓存"></a>Linux arp 命令 - 显示和修改 ARP 缓存</h1><h2 id="介绍-168"><a href="#介绍-168" class="headerlink" title="介绍"></a>介绍</h2><p>在 Linux 系统中，<strong>arp</strong>（英文全拼：Address Resolution Protocol）命令用于显示和修改系统的 ARP 缓存表，即存储 IP 地址与对应 MAC 地址的映射关系。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arp [选项] [参数]</span><br></pre></td></tr></table></figure>



<p>详细语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arp [-vn] [-H <span class="built_in">type</span>] [-i <span class="keyword">if</span>] [-ae] [hostname]</span><br><span class="line">arp [-v] [-i <span class="keyword">if</span>] -d hostname [pub]</span><br><span class="line">arp [-v] [-H <span class="built_in">type</span>] [-i <span class="keyword">if</span>] -s hostname hw_addr [temp]</span><br><span class="line">arp [-v] [-H <span class="built_in">type</span>] [-i <span class="keyword">if</span>] -s hostname hw_addr [netmask nm] pub</span><br><span class="line">arp [-v] [-H <span class="built_in">type</span>] [-i <span class="keyword">if</span>] -Ds hostname ifname [netmask nm] pub</span><br><span class="line">arp [-vnD] [-H <span class="built_in">type</span>] [-i <span class="keyword">if</span>] -f [filename]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>：以另一种（BSD）风格显示 ARP 缓存的所有条目（主机）。</li>
<li><code>-e</code>：以默认（Linux）样式显示 ARP 缓存的所有条目（主机）。</li>
<li><code>-s, --set</code>：设置一个新的 ARP 记录。</li>
<li><code>-d, --delete</code>：删除指定记录。</li>
<li><code>-v, --verbose</code>：显示详细的 ARP 缓存条目，包括缓存条目的统计信息。</li>
<li><code>-n, --numeric</code>：以数字方式（不解析名称）显示 ARP 缓存中的条目。</li>
<li><code>-i, --device</code>：指定网络接口（如 eth0）。</li>
<li><code>-D, --use-device</code>：读取所给定设备的硬件地址。</li>
<li><code>-A, -p, --protocol</code>：指定协议族。</li>
<li><code>-f, --file</code>：从文件或 &#x2F;etc&#x2F;ethers 中读取新记录。</li>
</ul>
<h2 id="示例-168"><a href="#示例-168" class="headerlink" title="示例"></a>示例</h2><p>显示本机 ARP 缓存表中所有记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arp</span><br></pre></td></tr></table></figure>



<p>以数字方式显示指定主机 ARP 缓存表条目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arp -n 192.168.0.1</span><br></pre></td></tr></table></figure>



<p>删除指定主机网卡上的 ARP 条目（例如 eth1 上 192.168.0.1）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arp -i eth1 -d 192.168.0.1</span><br></pre></td></tr></table></figure>



<p>这将使用 eth1 的 MAC 地址应答 eth0 上 192.168.0.2 的 ARP 请求：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arp -i eth0 -Ds 192.168.0.2 eth1 pub</span><br></pre></td></tr></table></figure>



<p>添加对指定的 IP 地址和 MAC 地址进行静态映射的条目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arp -s 192.168.0.10 c0:25:a5:29:12:e1</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ifconfig-命令-网络接口配置命令"><a href="#Linux-ifconfig-命令-网络接口配置命令" class="headerlink" title="Linux ifconfig 命令 - 网络接口配置命令"></a>Linux ifconfig 命令 - 网络接口配置命令</h1><h2 id="介绍-169"><a href="#介绍-169" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ifconfig</strong>（英文全拼：network interfaces configuring）命令用于配置和显示 Linux 内核中网络接口的网络参数。</p>
<p>ifconfig 命令由 net-tools 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install net-tools</span><br></pre></td></tr></table></figure>



<p>注意，通过 ifconfig 命令配置的网卡信息是临时的，在网卡重启或机器重启后，配置就不存在。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig [-v] [-a] [-s] [interface]</span><br><span class="line">ifconfig [-v] interface [aftype] options | address ...</span><br></pre></td></tr></table></figure>



<p><strong>选项参数</strong>：</p>
<ul>
<li><code>add &lt;地址&gt;</code> ：设置网络设备 IPv6 的 ip 地址；</li>
<li><code>del &lt;地址&gt;</code> ：删除网络设备 IPv6 的 IP 地址；</li>
<li><code>down</code> ：关闭指定的网络设备；</li>
<li><code>hw &lt;网络设备类型&gt; &lt;硬件地址&gt;</code> ：设置网络设备的类型与硬件地址；</li>
<li><code>io_addr &lt;I/O地址&gt;</code> ：设置网络设备的 I&#x2F;O 地址；</li>
<li><code>irq &lt;IRQ地址&gt;</code> ：设置网络设备的 IRQ；</li>
<li><code>media &lt;网络媒介类型&gt;</code> ：设置网络设备的媒介类型；</li>
<li><code>mem_start &lt;内存地址&gt;</code> ：设置网络设备在主内存所占用的起始地址；</li>
<li><code>metric &lt;数目&gt;</code> ：指定在计算数据包的转送次数时，所要加上的数目；</li>
<li><code>mtu &lt;字节&gt;</code> ：设置网络设备的 MTU；</li>
<li><code>netmask &lt;子网掩码&gt;</code> ：设置网络设备的子网掩码；</li>
<li><code>tunnel &lt;地址&gt;</code> ：建立 IPv4 与 IPv6 之间的隧道通信地址；</li>
<li><code>up</code> ：启动指定的网络设备；</li>
<li><code>-broadcast &lt;地址&gt;</code> ：将要送往指定地址的数据包当成广播数据包来处理；</li>
<li><code>-pointopoint &lt;地址&gt;</code> ：与指定地址的网络设备建立直接连线，此模式具有保密功能；</li>
<li><code>-promisc</code> ：关闭或启动指定网络设备的 promiscuous 模式；</li>
<li><code>address</code>：指定网络设备的 IP 地址；</li>
<li><code>interface</code> ：指定网络设备的名称。</li>
</ul>
<h2 id="示例-169"><a href="#示例-169" class="headerlink" title="示例"></a>示例</h2><p>显示网络设备信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>



<p>启动关闭指定网卡</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 down</span><br><span class="line">ifconfig eth0 up </span><br></pre></td></tr></table></figure>



<p>为网卡配置和删除 IPv6 地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 add 33ffe:3240:800:1005::2/64</span><br><span class="line">ifconfig eth0 del 33ffe:3240:800:1005::2/64</span><br></pre></td></tr></table></figure>



<p>修改网卡 MAC 地址（修改前须先关闭网卡）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE</span><br></pre></td></tr></table></figure>



<p>配置 IP 地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 192.168.1.56</span><br></pre></td></tr></table></figure>



<p>配置 IP 地址和子网掩码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 192.168.1.56 netmask 255.255.255.0</span><br></pre></td></tr></table></figure>



<p>配置 IP 地址和子网掩码以及广播地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 192.168.1.56 netmask 255.255.255.0 broadcast 192.168.1.255</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ip-命令-显示或设置网络设备"><a href="#Linux-ip-命令-显示或设置网络设备" class="headerlink" title="Linux ip 命令 - 显示或设置网络设备"></a>Linux ip 命令 - 显示或设置网络设备</h1><h2 id="介绍-170"><a href="#介绍-170" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ip</strong> 命令是 Linux 系统中的一个网络配置工具，主要用于显示或设置网络设备，功能非常全面，可完全替代 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/ifconfig/">ifconfig</a> 命令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip [ OPTIONS ] OBJECT &#123; COMMAND | help &#125;</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-V</code>：显示命令的版本信息。</li>
<li><code>-s</code>：输出更详细的信息。</li>
<li><code>-f</code>：强制使用指定的协议族。</li>
<li><code>-4</code>：指定使用的网络层协议是 IPv4 协议。</li>
<li><code>-6</code>：指定使用的网络层协议是 IPv6 协议。</li>
<li><code>-0</code>：输出信息每条记录输出一行，即使内容较多也不换行显示。</li>
<li><code>-r</code>：显示主机时，不使用 IP 地址，而使用主机的域名。</li>
<li><code>help</code>：为该命令的帮助信息。</li>
</ul>
<p>常用 OBJECT 对象及其含义如下：</p>
<table>
<thead>
<tr>
<th>OBJECT</th>
<th>缩写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>address</code></td>
<td><code>a</code> 或 <code>addr</code></td>
<td>设备上的协议（IPv4 或 IPv6）地址</td>
</tr>
<tr>
<td><code>addrlabel</code></td>
<td><code>addrl</code></td>
<td>用于协议地址选择的标签配置</td>
</tr>
<tr>
<td><code>l2tp</code></td>
<td></td>
<td>IP 上的以太网隧道（L2TPv3）</td>
</tr>
<tr>
<td><code>link</code></td>
<td><code>l</code></td>
<td>网络设备</td>
</tr>
<tr>
<td><code>maddress</code></td>
<td><code>m</code> 或 <code>maddr</code></td>
<td>多播地址</td>
</tr>
<tr>
<td><code>monitor</code></td>
<td></td>
<td>监视 netlink 消息</td>
</tr>
<tr>
<td><code>mroute</code></td>
<td><code>mr</code></td>
<td>组播路由缓存条目</td>
</tr>
<tr>
<td><code>mrule</code></td>
<td></td>
<td>组播路由策略数据库中的规则</td>
</tr>
<tr>
<td><code>neighbour</code></td>
<td><code>n</code> 或 <code>neigh</code></td>
<td>管理 ARP 或 NDISC 缓存条目</td>
</tr>
<tr>
<td><code>netns</code></td>
<td></td>
<td>管理网络命名空间</td>
</tr>
<tr>
<td><code>ntable</code></td>
<td></td>
<td>管理邻居高速缓存（neighbor cache）的操作</td>
</tr>
<tr>
<td><code>route</code></td>
<td><code>r</code></td>
<td>路由表条目</td>
</tr>
<tr>
<td><code>rule</code></td>
<td><code>ru</code></td>
<td>路由策略数据库中的规则</td>
</tr>
<tr>
<td><code>tcp_metrics/tcpmetrics</code></td>
<td></td>
<td>管理 TCP 指标（Metrics）</td>
</tr>
<tr>
<td><code>token</code></td>
<td></td>
<td>管理令牌化（tokenized）的接口标识符</td>
</tr>
<tr>
<td><code>tunnel</code></td>
<td><code>t</code></td>
<td>IP 上的隧道（tunnel）</td>
</tr>
<tr>
<td><code>tuntap</code></td>
<td></td>
<td>管理 TUN&#x2F;TAP 设备</td>
</tr>
<tr>
<td><code>xfrm</code></td>
<td><code>x</code></td>
<td>管理 IPSec 策略</td>
</tr>
</tbody></table>
<h2 id="示例-170"><a href="#示例-170" class="headerlink" title="示例"></a>示例</h2><p>显示所有网络接口的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure>



<p>只显示 TCP&#x2F;IP IPv4 的网络接口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip -4 a</span><br></pre></td></tr></table></figure>



<p>只显示 TCP&#x2F;IP IPv6 的网络接口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip -6 a</span><br></pre></td></tr></table></figure>



<p>显示指定接口的 TCP&#x2F;IP 详细信息，下面四个命令是等效的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip a show eth0</span><br><span class="line">ip a list eth0</span><br><span class="line">ip a show dev eth0</span><br><span class="line">ip a list dev eth0</span><br></pre></td></tr></table></figure>



<p>只显示正在运行的网络接口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> show up</span><br></pre></td></tr></table></figure>



<p>为指定网络接口设置 IP 地址的格式是 <code>ip a add {ip_addr/mask} dev {interface}</code>，例如下面两个命令是等效的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip a add 192.168.1.200/255.255.255.0 dev eth0</span><br><span class="line">ip a add 192.168.1.200/24 dev eth0</span><br></pre></td></tr></table></figure>



<p>为指定网络接口上添加广播地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr add broadcast 172.20.10.255 dev eth0</span><br></pre></td></tr></table></figure>



<p>从网络接口中删除 IP 地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip a del 192.168.1.200/24 dev eth0</span><br></pre></td></tr></table></figure>



<p>在所有 ppp（Point-to-Point）接口上禁用 IP 地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip -4 addr flush label <span class="string">&quot;ppp*&quot;</span></span><br></pre></td></tr></table></figure>



<p>关闭 eth1 网卡：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> dev eth1 down</span><br></pre></td></tr></table></figure>



<p>启动 eth1 网卡：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> dev eth1 up</span><br></pre></td></tr></table></figure>



<p>设置 eth0 网络接口的 txqueuelen（传输队列长度）大小为 10000：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> txqueuelen 10000 dev eth0</span><br></pre></td></tr></table></figure>



<p>设置 eth0 网络接口的 MTU 值为 9000：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> mtu 9000 dev eth0</span><br></pre></td></tr></table></figure>



<p>显示邻居（ARP）缓存：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ip n show</span><br><span class="line">192.168.1.3 dev eth0 lladdr 86:e5:ec:b7:bd:d3 STALE</span><br><span class="line">192.168.1.1 dev eth0 lladdr 3c:57:4f:f8:18:48 REACHABLE</span><br><span class="line">fe80::1 dev eth0 lladdr 3c:57:4f:f8:18:48 router REACHABLE</span><br></pre></td></tr></table></figure>



<p>输出结果的最后一个字段显示此条目的“<strong>neighbour unreachability detection</strong>”机器的状态，一共有 3 种状态：</p>
<ul>
<li><strong><code>STALE</code></strong>：邻居是有效的（valid），但可能已经无法访问，因此内核将尝试在第一次传输时检查它。</li>
<li><strong><code>DELAY</code></strong>：一个数据包已经发送给过时的（STALE 状态）邻居，内核正在等待确认。</li>
<li><strong><code>REACHABLE</code></strong>：邻居是有效的（valid），而且显然是可以联系到的（reachable）。</li>
</ul>
<p>添加一个 ARP 条目的格式是 <code>ip neigh add {IP-HERE} lladdr {MAC/LLADDRESS} dev {DEVICE} nud {STATE}</code>。例如，在设备 eth0 上为邻居 192.168.1.5 添加一个永久 ARP 条目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip neigh add 192.168.1.5 lladdr 00:1a:30:38:a8:00 dev eth0 nud perm</span><br></pre></td></tr></table></figure>



<p>nud 邻居状态（neighbour state）有 4 种：</p>
<ul>
<li><strong><code>permanent</code></strong>：邻居条目永远有效，只能由管理员指定删除。</li>
<li><strong><code>noarp</code></strong>：邻居条目是有效的，将不会尝试验证此项，但可以在其生存期过期时将其删除。</li>
<li><strong><code>stale</code></strong>：邻居的条目是有效的，但可疑。如果 <code>ip neigh</code> 选项有效且地址未被此命令更改，则该选项不会更改邻居状态。</li>
<li><strong><code>reachable</code></strong>：在可达性超时过期之前，邻居条目是有效的。</li>
</ul>
<p>删除一个 ARP 条目的格式是 <code>ip neigh del {IPAddress} dev {DEVICE}</code>，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip neigh del 192.168.1.5 dev eth1</span><br></pre></td></tr></table></figure>



<p>更改是设备 eth1 上邻居 192.168.1.100 的状态为 reachable：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip neigh chg 192.168.1.100 dev eth1 nud reachable</span><br></pre></td></tr></table></figure>



<p>刷新 ARP 记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip -s -s n flush 192.168.1.5</span><br></pre></td></tr></table></figure>



<p>显示路由表，下面几个命令是等效的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip r</span><br><span class="line">ip r list</span><br><span class="line">ip route</span><br><span class="line">ip route list</span><br></pre></td></tr></table></figure>



<p>增加一个新的路由，命令格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip route add &#123;NETWORK/MASK&#125; via &#123;GATEWAYIP&#125;</span><br><span class="line">ip route add &#123;NETWORK/MASK&#125; dev &#123;DEVICE&#125;</span><br><span class="line"><span class="comment">## Add default route using ip ##</span></span><br><span class="line">ip route add default &#123;NETWORK/MASK&#125; dev &#123;DEVICE&#125;</span><br><span class="line">ip route add default &#123;NETWORK/MASK&#125; via &#123;GATEWAYIP&#125;</span><br></pre></td></tr></table></figure>



<p>通过网关 192.168.1.254 向网络 192.168.1.0&#x2F;24 添加一个普通路由：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip route add 192.168.1.0/24 via 192.168.1.254</span><br></pre></td></tr></table></figure>



<p>通过 192.168.1.254 网关路由通过 eth0 网络接口连接的所有流量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip route add 192.168.1.0/24 dev eth0</span><br></pre></td></tr></table></figure>



<p>删除前面添加的一条网关路由：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip route del 192.168.1.0/24 dev eth0</span><br></pre></td></tr></table></figure>



<p>删除默认网关路由：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip route del default</span><br></pre></td></tr></table></figure>



<p>更改 eth0 网卡的 MAC 地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## show MAC address ##</span></span><br><span class="line">ip <span class="built_in">link</span> show eth0</span><br><span class="line"><span class="comment">## disable interface ##</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> dev eth0 down</span><br><span class="line"><span class="comment">## set new MAC address ##</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> dev eth0 address XX:YY:ZZ:AA:BB:CC</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> dev eth0 up</span><br></pre></td></tr></table></figure>





<h1 id="Linux-route-命令-显示或操作-IP-路由表"><a href="#Linux-route-命令-显示或操作-IP-路由表" class="headerlink" title="Linux route 命令 - 显示或操作 IP 路由表"></a>Linux route 命令 - 显示或操作 IP 路由表</h1><h2 id="介绍-171"><a href="#介绍-171" class="headerlink" title="介绍"></a>介绍</h2><p><strong>route</strong> 命令用于显示和操作 Linux 内核 IP 路由表。它的主要用途是在使用 ifconfig 程序配置后，设置一个网络接口（网卡）到特定主机或网络的静态路由。当使用 add 或 del 选项时，route 会修改路由表，如果没有这些选项，则会显示路由表的当前内容。也可通过 &#x2F;proc&#x2F;net&#x2F;route 查看路由表信息。</p>
<p>提示</p>
<p>基础知识：要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者一个同时位于两个网络的网关来实现。</p>
<p>在 Linux 系统中，设置路由通常是为了解决以下问题：该 Linux 系统在一个局域网中，局域网中有一个网关，能够让机器访问 Internet，那么就需要将这台机器的 IP 地址设置为 Linux 机器的默认路由。要注意的是，直接在命令行下执行 route 命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了。可以在 &#x2F;etc&#x2F;rc.local 中添加 route 命令来保证该路由设置永久有效。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">route [-nNvee] [-FC] [&lt;AF&gt;]           # 显示核心路由表</span><br><span class="line">route [-v] [-FC] &#123;add|del|flush&#125; ...  # 为AF修改路由表</span><br><span class="line">route &#123;-h|--help&#125; [&lt;AF&gt;]              # Detailed usage syntax for specified AF</span><br><span class="line">route &#123;-V|--version&#125;                  # 显示版本和作者信息并退出</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-v</code>, <code>--verbose</code> ：显示详细的处理信息。</li>
<li><code>-n</code>, <code>--numeric</code> ：不解析名称。</li>
<li><code>-e</code>, <code>--extend</code> ：显示更多信息。</li>
<li><code>-F</code>, <code>--fib</code> ：显示发送信息（默认）。</li>
<li><code>-C</code>, <code>--cache</code> ：显示路由缓存，而不是 FIB。</li>
<li><code>add</code> ：添加一条路由。</li>
<li><code>del</code> ：删除一条路由。</li>
<li><code>-net</code> ：目标地址是一个网络（network）。</li>
<li><code>-host</code> ：目标地址是一个主机（host）。</li>
<li><code>netmask NM</code> ：当添加一个网络路由时，需要使用网络掩码。</li>
<li><code>gw GW</code> ：路由数据包通过网关。注意，你指定的网关必须能够到达。</li>
<li><code>metric M</code> ：设置路由跳数。</li>
<li><code>mss M</code> ：将路由的 MTU（最大传输单元）设置为 M 字节。MTU 即 Maximum Transmission Unit，MSS 即 Maximum Segment Size。</li>
<li><code>window W</code> ：将此路由上的连接的 TCP 窗口大小设置为 W 字节。这通常仅用于 AX.25 网络并且驱动程序无法处理背靠背帧（back to back frames）。</li>
<li><code>irtt I</code> ：将此路由上 TCP 连接的初始往返时间（initial round trip time）设置为 I 毫秒 (1-12000)。这通常仅用于 AX.25 网络。如果省略，则使用 RFC 1122 默认值 300 毫秒。</li>
<li><code>reject</code> ：安装阻塞路由，这将强制路由查找失败，以达到屏蔽该路由的效果。例如，这用于在使用默认路由之前屏蔽网络。注意，这不适用于防火墙。</li>
<li><code>mod, dyn, reinstate</code> ：安装动态或修改过的路由。这些标志用于诊断目的，通常仅由路由守护程序设置。</li>
<li><code>dev If</code> ：强制路由与指定的设备相关联，否则内核将尝试自行确定设备（通过检查现有路由和设备规范，以及路由添加到的位置）。在大多数普通网络中，您不需要这个。如果 <code>dev If</code> 是命令行上的最后一个选项，则可以省略 <code>dev</code> 这个词，因为它是默认值。否则，路由修饰符（公制网络掩码 <code>gw dev</code>）的顺序无关紧要。</li>
</ul>
<h2 id="示例-171"><a href="#示例-171" class="headerlink" title="示例"></a>示例</h2><p>显示当前路由：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">route</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         *               0.0.0.0         U     0      0        0 ppp0</span><br><span class="line">10.64.64.64     *               255.255.255.255 UH    0      0        0 ppp0</span><br><span class="line">192.168.30.0    *               255.255.254.0   U     0      0        0 eth0</span><br></pre></td></tr></table></figure>



<p>显示当前路由（不解析名称，列出速度会比 route 快）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         0.0.0.0         0.0.0.0         U     0      0        0 ppp0</span><br><span class="line">10.64.64.64     0.0.0.0         255.255.255.255 UH    0      0        0 ppp0</span><br><span class="line">192.168.30.0    0.0.0.0         255.255.254.0   U     0      0        0 eth0</span><br></pre></td></tr></table></figure>



<p>各字段说明如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Destination</td>
<td>目标网段或者主机</td>
</tr>
<tr>
<td>Gateway</td>
<td>网关地址，<code>*</code> 表示目标是本主机所属的网络，不需要路由</td>
</tr>
<tr>
<td>Genmask</td>
<td>子网掩码</td>
</tr>
<tr>
<td>Flags</td>
<td>路由标志，用于标记当前网络节点的状态，各标记说明如下： - <code>U</code> 即 Up，表示此路由当前为启动状态 - <code>H</code> 即 Host，表示此网关为一主机 - <code>G</code> 即 Gateway，表示此网关为一路由器 - <code>R</code> 即 Reinstate Route，使用动态路由重新初始化的路由 - <code>D</code> 即 Dynamically，此路由是动态性地写入 - <code>M</code> 即 Modified，此路由是由路由守护程序或导向器动态修改 - <code>!</code> 表示此路由当前为关闭状态</td>
</tr>
<tr>
<td>Metric</td>
<td>跃点（路由距离），到达指定网络所需的中转数（Linux 内核暂时没有使用）</td>
</tr>
<tr>
<td>Ref</td>
<td>路由项引用次数（Linux 内核暂时没有使用）</td>
</tr>
<tr>
<td>Use</td>
<td>此路由项被路由软件查找的次数</td>
</tr>
<tr>
<td>Iface</td>
<td>该路由表项对应的输出接口</td>
</tr>
</tbody></table>
<p>增加到主机的路由信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">route add -host 192.16.128.1 dev eth0</span><br><span class="line">route add -host 192.16.128.1 gw 192.16.128.254</span><br></pre></td></tr></table></figure>



<p>添加网关&#x2F;设置网关（增加一条到达 224.0.0.0 的路由）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0</span><br></pre></td></tr></table></figure>



<p>屏蔽一条路由（增加一条屏蔽的路由，目的地址为 224.x.x.x 将被拒绝）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 reject</span><br></pre></td></tr></table></figure>



<p>删除路由记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">route del -net 224.0.0.0 netmask 240.0.0.0</span><br><span class="line">route del -net 224.0.0.0 netmask 240.0.0.0 reject</span><br></pre></td></tr></table></figure>



<p>删除和添加设置默认网关：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">route del default gw 192.168.120.240</span><br><span class="line">route add default gw 192.168.120.240</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ethtool-命令-查询设置网卡参数"><a href="#Linux-ethtool-命令-查询设置网卡参数" class="headerlink" title="Linux ethtool 命令 - 查询设置网卡参数"></a>Linux ethtool 命令 - 查询设置网卡参数</h1><h2 id="介绍-172"><a href="#介绍-172" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ethtool</strong>（英文全拼：ethernet tool）命令用于查看和修改网络设备（尤其是有线以太网设备）的驱动参数和硬件设置。你可以根据需要更改以太网卡的参数，包括自动协商、速度、双工和局域网唤醒等参数。</p>
<p><strong>安装</strong>：</p>
<p>默认情况下，大多数 Linux 发行版应该已经安装了 ethtool 工具，如果没有，可以参考如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Linux 对于 RHEL/CentOS 6/7 系统，使用 yum 命令安装</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y ethtool</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux 对于 RHEL/CentOS 8 和 Fedora 系统，使用 dnf 命令安装</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install -y ethtool</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux 对于基于 Debian/Ubuntu 的系统，使用 apt 或 apt-get 命令安装</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install ethtool</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux 对于 openSUSE 系统，使用 zypper 命令安装</span></span><br><span class="line"><span class="built_in">sudo</span> zypper install -y ethtool</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux 对于 Arch Linux 系统，使用 pacman 命令安装</span></span><br><span class="line"><span class="built_in">sudo</span> pacman -S ethtool</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ethtool [选项] [devname]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code> ：查看网卡中接收模块 RX、发送模块 TX 和 Autonegotiate 模块的状态（启动 on 或 停用 off）。</li>
<li><code>-A</code> ：修改网卡中接收模块 RX、发送模块 TX 和 Autonegotiate 模块的状态（启动 on 或 停用 off）。</li>
<li><code>-c</code> ：display the Coalesce information of the specified ethernet card。</li>
<li><code>-C</code> ：Change the Coalesce setting of the specified ethernet card。</li>
<li><code>-g</code> ：Display the rx&#x2F;tx ring parameter information of the specified ethernet card。</li>
<li><code>-G</code> ：change the rx&#x2F;tx ring setting of the specified ethernet card。</li>
<li><code>-i</code> ：显示网卡驱动的信息，如驱动的名称、版本等。</li>
<li><code>-d</code> ：显示 register dump 信息，部分网卡驱动不支持该选项。</li>
<li><code>-e</code> ：显示 EEPROM dump 信息，部分网卡驱动不支持该选项。</li>
<li><code>-E</code> ：修改网卡 EEPROM byte。</li>
<li><code>-k</code> ：显示网卡 Offload 参数的状态（on 或 off），包括 rx-checksumming、tx-checksumming 等。</li>
<li><code>-K</code> ：修改网卡 Offload 参数的状态。</li>
<li><code>-p</code> ：用于区别不同 ethX 对应网卡的物理位置，常用的方法是使网卡 port 上的 led 不断的闪；N 指示了网卡闪的持续时间，以秒为单位。</li>
<li><code>-r</code> ：如果 auto-negotiation 模块的状态为 on，则 restarts auto-negotiation。</li>
<li><code>-S</code> ：显示 NIC- and driver-specific 的统计参数，如网卡接收&#x2F;发送的字节数、接收&#x2F;发送的广播包个数等。</li>
<li><code>-t</code> ：让网卡执行自我检测，有两种模式（offline 或 online）。</li>
<li><code>-s</code> ：修改网卡的部分配置，包括网卡速度、单工&#x2F;全双工模式、mac 地址等。</li>
</ul>
<p><strong>参数</strong>：<code>devname</code>（网卡名称，可通过 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/ip/">ip</a> 或 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/ifconfig/">ifconfig</a> 命令查看）</p>
<h2 id="示例-172"><a href="#示例-172" class="headerlink" title="示例"></a>示例</h2><p>查看 eth0 网卡的硬件配置信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ethtool eth0</span><br></pre></td></tr></table></figure>



<p>查看 eth0 网卡的驱动程序和固件版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ethtool -i eth0</span><br></pre></td></tr></table></figure>



<p>查看 eth0 网卡的自动协商、RX 和 TX 等详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ethtool -a eth0</span><br></pre></td></tr></table></figure>



<p>查看 eth0 网卡网络使用情况统计</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ethtool -S eth0</span><br></pre></td></tr></table></figure>



<p>从多个物理接口中识别出特定网卡（闪烁网卡上的 LED）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ethtool -p eth0</span><br></pre></td></tr></table></figure>



<p>修改 eth0 以太网设备的速度为百兆（进行此操作时，网卡会自动掉线，您需要使用 ifup、ip 或 nmcli 命令将其重新上线）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ethtool -s eth0 speed 100</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 up</span><br></pre></td></tr></table></figure>



<p>启用&#x2F;禁用以太网卡的自动协商</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ethtool -s eth0 autoneg off</span><br><span class="line">ethtool -s eth0 autoneg on</span><br></pre></td></tr></table></figure>



<p>同时修改多个配置参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ethtool –s eth0 speed 1000 duplex full autoneg off</span><br></pre></td></tr></table></figure>



<p>注意：在系统重启后，使用 ethtool 所做的更改将恢复为默认值。如果需要使设置永久生效，您需要根据您的 Linux 发行版进行操作，可能需要将这些配置更新到正确的文件中。</p>
<p>查看网卡是否支持 PTP 硬件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ethtool -T eth0</span><br><span class="line">Time stamping parameters <span class="keyword">for</span> eth0:</span><br><span class="line">Capabilities:</span><br><span class="line">        hardware-transmit     (SOF_TIMESTAMPING_TX_HARDWARE)</span><br><span class="line">        software-transmit     (SOF_TIMESTAMPING_TX_SOFTWARE)</span><br><span class="line">        hardware-receive      (SOF_TIMESTAMPING_RX_HARDWARE)</span><br><span class="line">        software-receive      (SOF_TIMESTAMPING_RX_SOFTWARE)</span><br><span class="line">        software-system-clock (SOF_TIMESTAMPING_SOFTWARE)</span><br><span class="line">        hardware-raw-clock    (SOF_TIMESTAMPING_RAW_HARDWARE)</span><br><span class="line">PTP Hardware Clock: 0</span><br><span class="line">Hardware Transmit Timestamp Modes:</span><br><span class="line">        off                   (HWTSTAMP_TX_OFF)</span><br><span class="line">        on                    (HWTSTAMP_TX_ON)</span><br><span class="line">Hardware Receive Filter Modes:</span><br><span class="line">        none                  (HWTSTAMP_FILTER_NONE)</span><br><span class="line">        all                   (HWTSTAMP_FILTER_ALL)</span><br></pre></td></tr></table></figure>



<p>注意：对于 gPTP 同步，需要硬件支持，PTP Hardware Clock 选项要求为 1。</p>
<h1 id="Linux-netstat-命令-显示网络统计信息"><a href="#Linux-netstat-命令-显示网络统计信息" class="headerlink" title="Linux netstat 命令 - 显示网络统计信息"></a>Linux netstat 命令 - 显示网络统计信息</h1><h2 id="介绍-173"><a href="#介绍-173" class="headerlink" title="介绍"></a>介绍</h2><p><strong>netstat</strong>（英文全拼：network statistics）命令用于显示网络连接、路由表、接口统计、伪连接和组播成员等信息。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat [OPTION]...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code> ：显示所有连线中的 socket。</li>
<li><code>-p</code> ：显示正在使用 socket 的程序识别码和程序名称。</li>
<li><code>-t</code> ：仅显示 TCP 传输协议的连线状况。</li>
<li><code>-u</code> ：仅显示 UDP 传输协议的连线状况。</li>
<li><code>-l</code> ：仅显示处于 Listen（监听）状态的 socket。</li>
<li><code>-i</code> ：显示网络界面信息表单。</li>
<li><code>-n</code> ：直接使用 IP 地址，不通过域名服务器。</li>
</ul>
<h2 id="示例-173"><a href="#示例-173" class="headerlink" title="示例"></a>示例</h2><p>显示详细的网络状况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -a</span><br></pre></td></tr></table></figure>



<p>显示 UDP 连接状况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -nu</span><br></pre></td></tr></table></figure>



<p>显示 UDP 端口号的使用情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -apu</span><br></pre></td></tr></table></figure>



<p>显示 TCP、UDP 的端口和进程等相关情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -tunlp</span><br></pre></td></tr></table></figure>



<p>显示所有 4000 端口使用情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -tunlp | grep 4000</span><br></pre></td></tr></table></figure>



<p>显示网卡列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -i</span><br></pre></td></tr></table></figure>



<p>显示组播组的关系</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -g </span><br></pre></td></tr></table></figure>





<h1 id="Linux-nslookup-命令-查询-DNS-域名和-IP"><a href="#Linux-nslookup-命令-查询-DNS-域名和-IP" class="headerlink" title="Linux nslookup 命令 - 查询 DNS 域名和 IP"></a>Linux nslookup 命令 - 查询 DNS 域名和 IP</h1><h2 id="介绍-174"><a href="#介绍-174" class="headerlink" title="介绍"></a>介绍</h2><p><strong>nslookup</strong>（英文全拼：name server lookup）是一个域名查询工具，可用于查询 DNS 记录信息、查看域名解析是否正常。nslookup 是诊断网络故障的常用工具之一。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nslookup [-option] [name | -] [server]</span><br></pre></td></tr></table></figure>



<p>nslookup 有两种工作模式，即“交互模式”（Interactive mode）和“非交互模式”（Non-interactive mode）。在“交互模式”下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。而在“非交互模式”下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息。</p>
<p>进入交互模式的方法是直接输入 nslookup 命令（不加任何参数），此时 nslookup 会连接到默认的域名服务器（即 <code>/etc/resolv.conf</code> 的第一个 dns 地址）。或者输入 <code>nslookup -nameserver/ip</code> 命令指定 dns 地址。在交互模式输入想要查询的域名即可，输入 <code>exit</code> 退出交互模式。</p>
<p>而非交互模式，则直接输入 <code>nslookup 域名</code> 就可以了。在非交互模式，可以在域名 name 后面添加 DNS 服务器地址，指定要使用的域名服务器。</p>
<h2 id="示例-174"><a href="#示例-174" class="headerlink" title="示例"></a>示例</h2><p>查询 getiot.tech 域名信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nslookup getiot.tech</span><br><span class="line">Server:		127.0.0.53</span><br><span class="line">Address:	127.0.0.53#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:	getiot.tech</span><br><span class="line">Address: 42.192.64.149</span><br></pre></td></tr></table></figure>



<p>指定 DNS 服务器查询 getiot.tech 域名信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nslookup getiot.tech 8.8.8.8</span><br><span class="line">Server:		8.8.8.8</span><br><span class="line">Address:	8.8.8.8#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:	getiot.tech</span><br><span class="line">Address: 42.192.64.149</span><br></pre></td></tr></table></figure>





<h1 id="Linux-telnet-命令-远程登录协议命令"><a href="#Linux-telnet-命令-远程登录协议命令" class="headerlink" title="Linux telnet 命令 - 远程登录协议命令"></a>Linux telnet 命令 - 远程登录协议命令</h1><h2 id="介绍-175"><a href="#介绍-175" class="headerlink" title="介绍"></a>介绍</h2><p><strong>telnet</strong> 命令用于登录远程主机，并对远程主机进行管理。但由于 telnet 采用明文传送报文，安全性不好，因此通常会使用更安全的 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/ssh/">ssh</a> 方式登录远程主机。如今，很多 Linux 服务器都已经不开放 telnet 服务。</p>
<p>提示</p>
<p>Telnet 是一种应用层协议（端口 23），使用于互联网及局域网中，以虚拟终端的形式提供双向、以文字字符串为主的命令行接口交互功能。属于 TCP&#x2F;IP 协议族的其中之一，是互联网远程登录服务的标准协议和主要方式。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet [OPTION] [host [port]]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-8</code>：允许使用 8 位字符资料，包括输入与输出。</li>
<li><code>-a</code>：尝试自动登入远端系统。</li>
<li><code>-b &lt;address&gt;</code>：使用别名指定远端主机名称。</li>
<li><code>-d</code>：启动排错模式。</li>
<li><code>-e &lt;escapechar&gt;</code>：设置脱离字符。</li>
<li><code>-E</code>：滤除脱离字符。</li>
<li><code>-l &lt;user&gt;</code>：指定要登入远端主机的用户名称。</li>
<li><code>-L</code>：允许输出 8 位字符资料。</li>
<li><code>-n &lt;tracefile&gt;</code>：指定文件记录相关信息。</li>
<li><code>-r</code>：使用类似 rlogin 指令的用户界面。</li>
<li><code>-S &lt;tos&gt;</code>：设置 telnet 连线所需的 ip TOS 信息。</li>
<li><code>-x</code>：假设主机有支持数据加密的功能，就使用它。</li>
</ul>
<h2 id="示例-175"><a href="#示例-175" class="headerlink" title="示例"></a>示例</h2><p>登录远程主机 192.168.1.100，登录时需要输入用户名和密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet 192.168.1.100</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ssh-命令-远程登录安全协议"><a href="#Linux-ssh-命令-远程登录安全协议" class="headerlink" title="Linux ssh 命令 - 远程登录安全协议"></a>Linux ssh 命令 - 远程登录安全协议</h1><h2 id="介绍-176"><a href="#介绍-176" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ssh</strong>（SecureShell 的缩写）命令是 OpenSSH 套件的组成部分，是一个用于登录到远程机器并在远程机器上执行命令的客户端程序。它的目的是取代 rlogin 和 rsh，并在一个不安全的网络上提供两个不受信任的主机之间的安全加密通信。图形化应用程序 X11 连接和任意 TCP 端口也可以通过 ssh 安全通道进行转发。</p>
<p>除了 <code>ssh</code> 客户端命令以外，OpenSSH 套件还包括下面几个命令：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.ssh.com/ssh/keygen">ssh-keygen</a>：用于为 ssh 生成、管理和转换认证密钥，它支持 RSA 和 DSA 两种认证密钥。</li>
<li><a target="_blank" rel="noopener" href="https://www.ssh.com/ssh/copy-id">ssh-copy-id</a>：将把本地的 ssh 公钥文件安装到远程主机对应的账户下。</li>
<li><a target="_blank" rel="noopener" href="https://www.ssh.com/ssh/agent">ssh-agent</a>：代理持有单点登录的私钥，可以将它理解为一个密钥管理器。</li>
<li><a target="_blank" rel="noopener" href="https://www.ssh.com/ssh/add">ssh-add</a>：向代理添加密钥的工具。</li>
<li><a target="_blank" rel="noopener" href="https://www.ssh.com/ssh/scp">scp</a>：具有类 RCP 命令接口的文件传输客户端。</li>
<li><a target="_blank" rel="noopener" href="https://www.ssh.com/ssh/sftp">sftp</a>：具有类 FTP 命令接口的文件传输客户端。</li>
<li><a target="_blank" rel="noopener" href="https://www.ssh.com/ssh/sshd">sshd</a>：OpenSSH 服务端。</li>
</ul>
<p>SSH 的故事</p>
<p>SSH 在20世纪90年代取代了 Unix 和 Linux 中的一些旧命令和协议，包括 telnet、 rlogin 和 rsh。SSH 在 TCP&#x2F;IP 端口22上运行，这刚好是在 ftp（21 端口）和 telnet（23 端口）之间，它们是20年前的。阅读《<a target="_blank" rel="noopener" href="https://www.ssh.com/academy/ssh/port#how-ssh-port-became-22">The story of getting SSH port 22</a>》 可以了解 SSH 如何获得端口22的故事。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh [OPTIONS] [-p PORT] [USER@]HOSTNAME [COMMAND]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-1</code>：强制只使用协议第一版。</li>
<li><code>-2</code>：强制只使用协议第二版。</li>
<li><code>-4</code>：强制只使用 IPv4 地址。</li>
<li><code>-6</code>：强制只使用 IPv6 地址。</li>
<li><code>-A</code>：允许转发认证代理的连接。可以在配置文件中对每个主机单独设定这个参数。</li>
<li><code>-a</code>：禁止转发认证代理的连接。</li>
<li><code>-b BIND_ADDRESS</code>：在拥有多个地址的本地机器上，指定连接的源地址。</li>
<li><code>-C</code>：压缩所有数据。压缩算法与 gzip 使用的相同。</li>
<li><code>-c {blowfish | 3des | des}</code>：选择会话的密码算法。3des 是默认算法。</li>
<li><code>-c CIPHER_SPEC</code>：另外, 对于协议第二版，这里可以指定一组用逗号隔开、按优先顺序排列的加密算法。</li>
<li><code>-D [BIND_ADDRESS:]PORT</code>：指定一个本地主机动态的应用程序级的转发端口。工作原理是这样的，本地机器上分配了一个 socket 侦听 port 端口，一旦这个端口上有了连接，该连接就经过安全通道转发出去，根据应用程序的协议可以判断出远程主机将和哪里连接。目前支持 SOCKS4 和 SOCKS5 协议，而 ssh 将充当 SOCKS 服务器. 只有 root 才能转发特权端口。可以在配置文件中指定动态端口的转发。</li>
<li><code>-e ESCAPE_CHAR</code>：设置 pty 会话的转义字符，默认为字符 ~。转义字符只在行首有效，转义字符后面跟一个点表示结束连接，后跟一个 control-Z 表示挂起连接，跟转义字符自己表示输出转义字符自身。把转义字符设为 none 则禁止 转义功能，使会话完全透明。</li>
<li><code>-F CONFIGFILE</code>：指定 ssh 指令的配置文件，将忽略系统级配置文件 &#x2F;etc&#x2F;ssh&#x2F;ssh_config 和用户级配置文件 ~&#x2F;.ssh&#x2F;config。</li>
<li><code>-f</code>：ssh 在执行命令前退至后台。</li>
<li><code>-g</code>：允许远端主机连接本地的转发端口。</li>
<li><code>-I SMARTCARD_DEVICE</code>：指定智能卡设备。智能卡里面存储了用户的 RSA 私钥。</li>
<li><code>-i IDENTITY_FILE</code>：指定一个 RSA 或 DSA 认证所需的身份（私钥）文件。协议第一版的默认文件是 ~&#x2F;.ssh&#x2F;identity 以及协议第二版的 ~&#x2F;.ssh&#x2F;id_rsa 和 ~&#x2F;.ssh&#x2F;id_dsa 文件。可以同时使用多个 -i 选项，也可以在配置文件中指定多个身份文件。</li>
<li><code>-K</code>：启用基于 GSSAPI 的身份验证和向服务器转发 GSSAPI 凭据。</li>
<li><code>-k</code>：禁用向服务器转发 GSSAPI 凭据。</li>
<li><code>-L [BIND_ADDRESS:]PORT:HOST:HOSTPORT</code>：将本地主机的地址和端口接收到的数据通过安全通道转发给远程主机的地址和端口。</li>
<li><code>-l LOGIN_NAME</code>：指定登录远程主机的用户。可以在配置文件中对每个主机单独设定这个参数。</li>
<li><code>-M</code>：将 ssh 客户端置于主模式进行连接共享。多个 -M 选项将 ssh 置于主模式，并在接受从连接之前进行确认。</li>
<li><code>-m MAC_SPEC</code>：对于协议第二版，可以指定一组用逗号隔开，按优先顺序排列的 MAC (message authentication code) 算法。</li>
<li><code>-N</code>：不执行远程命令，用于转发端口。仅限协议第二版。</li>
<li><code>-n</code>：把 stdin 重定向到 &#x2F;dev&#x2F;null，防止从 stdin 读取数据。在后台运行时一定会用到这个选项。</li>
<li><code>-O CTL_CMD</code>：控制主动连接多路复用主进程。参数 <code>CTL_CMD</code> 将被传递给主进程。<code>CTL_CMD</code> 可取值 check（检查主进程是否正在运行）和 exit（让主进程退出）。</li>
<li><code>-o OPTION</code>：可以在这里给出某些选项，格式和配置文件中的格式一样。它用来设置那些没有单独的命令行标志的选项。</li>
<li><code>-p PORT</code>：指定远程主机的端口。可以在配置文件中对每个主机单独设定这个参数。</li>
<li><code>-q</code>：安静模式。消除大多数的警告和诊断信息。</li>
<li><code>-R [BIND_ADDRESS:]PORT:HOST:HOSTPORT</code>：将远程主机上的地址和端口接收的数据通过安全通道转发给本地主机的地址和端口。</li>
<li><code>-S CTL_PATH</code>：指定用于连接共享的控制套接字的位置。</li>
<li><code>-s</code>：用于请求远程系统上的子系统调用。子系统是 SSH2 协议的一个特性，它有助于将 SSH 用作其他应用程序（如 sftp(1)）的安全传输。子系统通过远程命令指定。</li>
<li><code>-T</code>：禁止分配伪终端。</li>
<li><code>-t</code>：强制分配伪终端。这可用于在远程计算机上执行基于屏幕的任意程序，例如菜单服务。多个 -t 选项强制分配终端, 即使没有本地终端。</li>
<li><code>-V</code>：显示版本信息并退出。</li>
<li><code>-v</code>：冗详模式。打印关于运行情况的调试信息。在调试连接、认证和配置问题时非常有用。多个 -v 选项能够增加冗详程度，最多三个。</li>
<li><code>-W HOST:PORT</code>：将客户端上的标准输入和输出通过安全通道转发给指定主机的端口。</li>
<li><code>-w LOCAL_TUN[:REMOTE_TUN]</code>：指定客户端和服务端之间转发的隧道设备。</li>
<li><code>-X</code>：允许 X11 转发，可以在配置文件中对每个主机单独设定这个参数。</li>
<li><code>-x</code>：禁止 X11 转发。</li>
<li><code>-Y</code>：启用受信任的 X11 转发。受信任的 X11 转发不受 X11 安全扩展控制的约束。</li>
<li><code>-y</code>：使用 syslog 系统模块发送日志信息。默认情况下，此信息被发送到 stderr。</li>
</ul>
<h2 id="示例-176"><a href="#示例-176" class="headerlink" title="示例"></a>示例</h2><p>使用指定用户名（root）登录远程主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@192.168.1.100</span><br></pre></td></tr></table></figure>



<p>使用指定用户名（root）和端口（3600）登录远程主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p3600 root@192.168.1.100</span><br></pre></td></tr></table></figure>



<p>输入用户登录密码后完成登录。</p>
<p>如果未指明端口和用户名，则分别由配置文件 ~&#x2F;.ssh&#x2F;ssh_config 和 &#x2F;etc&#x2F;ssh&#x2F;ssh_config 中的 Port 和 User 选项决定。如果配置文件未指定，则端口默认为 22 ，用户名默认为当前用户。</p>
<p>也可以在 ~&#x2F;.ssh&#x2F;config 配置文件中设置远程服务器别名，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host 服务器名A</span><br><span class="line">    User 用户名</span><br><span class="line">    Hostname 服务器ip</span><br><span class="line">    Port 端口号</span><br><span class="line">    Identityfile 本地私钥地址</span><br></pre></td></tr></table></figure>



<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host nanopi</span><br><span class="line">	HostName 192.168.1.100</span><br><span class="line">	User pi</span><br><span class="line">	Port 22</span><br><span class="line">	IdentityFile ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>



<p>这样，你就可以直接指定 nanopi 配置登录远程主机，命令如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ssh nanopi</span><br></pre></td></tr></table></figure>



<h2 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h2><p>下面是 ~&#x2F;.ssh&#x2F;config 配置文件的配置选项：</p>
<ul>
<li><p>必须配置</p>
<ul>
<li><code>Host</code>：指定配置块。</li>
<li><code>User</code>：指定登录用户。</li>
<li><code>Hostname</code>：指定服务器地址，通常用 <code>ip</code> 地址。</li>
<li><code>Port</code>：指定端口号，默认值为 <code>22</code>。</li>
</ul>
</li>
<li><p>可选</p>
<ul>
<li><p><code>Identityfile</code>：指定本地认证私钥地址。</p>
</li>
<li><p><code>ForwardAgent yes</code>：允许 <code>ssh-agent</code> 转发。</p>
</li>
<li><p><code>IdentitiesOnly</code>：指定<code>ssh</code>是否仅使用配置文件或命令行指定的私钥文件进行认证。值为 <code>yes</code> 或 <code>no</code>，默认为 <code>no</code>，该情况可在 <code>ssh-agent</code> 提供了太多的认证文件时使用。</p>
</li>
<li><p><code>IdentityFile</code>：指定认证私钥文件。</p>
</li>
<li><pre><code>StrictHostKeyChecking
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    ：有 3 种选项。</span><br><span class="line"></span><br><span class="line">    - `ask`：默认值，第一次连接陌生服务器时提示是否添加，同时如果远程服务器公钥改变时拒绝连接。</span><br><span class="line">    - `yes`：不会自动添加服务器公钥到 `~/.ssh/known_hosts` 中，同时如果远程服务器公钥改变时拒绝连接。</span><br><span class="line">    - `no`：自动增加新的主机键到 `~/.ssh/known_hosts` 中。</span><br><span class="line"></span><br><span class="line">另外，编辑 ~/.ssh/config 配置文件时还需要注意以下几点：</span><br><span class="line"></span><br><span class="line">- 通过 `Host` 指定配置块，用 `tab` 键来区分配置头和内置参数。</span><br><span class="line">- 所有参数值都可使用通配符设定，比如可以设置一个 `Host` 值为星号（`*`），用于设置全局配置。</span><br><span class="line">- 配置文件不区分大小写，所以 `Host` 和 `host` 一样。</span><br><span class="line">- 注释用 `#` 号开头。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Linux scp 命令 - 远程安全复制文件</span><br><span class="line"></span><br><span class="line">## 介绍</span><br><span class="line"></span><br><span class="line">**scp**（SecureCopy 的缩写）命令是 OpenSSH 套件的组成部分，是一个具有类 RCP 命令接口的文件传输客户端。用于在 Linux 下进行远程拷贝文件的命令，和它类似的命令有 [`cp`](https://getiot.tech/linux-command/cp/)，不过 `cp` 只是在本机进行拷贝不能跨服务器，而且 scp 传输是加密的。</span><br><span class="line"></span><br><span class="line">scp 占用资源少，不会对系统负荷造成太大影响，与之类似的 [`rsync`](https://getiot.tech/linux-command/rsync/) 虽然速度相当快，但会导致硬盘 I/O 非常高，而 scp 基本不影响系统正常使用。</span><br><span class="line"></span><br><span class="line">**语法**：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">scp [OPTION] source ... target</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>选项</strong>：</p>
<ul>
<li><code>-1</code>：强制 scp 命令使用协议 ssh1</li>
<li><code>-2</code>：强制 scp 命令使用协议 ssh2</li>
<li><code>-4</code>：强制 scp 命令只使用 IPv4 寻址</li>
<li><code>-6</code>：强制 scp 命令只使用 IPv6 寻址</li>
<li><code>-B</code>：使用批处理模式（传输过程中不询问传输口令或短语）</li>
<li><code>-C</code>：允许压缩（将 -C 标志传递给 ssh，从而打开压缩功能）</li>
<li><code>-p</code>：保留原文件的修改时间，访问时间和访问权限。</li>
<li><code>-q</code>：不显示传输进度条。</li>
<li><code>-r</code>：递归复制整个目录。</li>
<li><code>-v</code>：详细方式显示输出。scp 和 ssh 会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li>
<li><code>-c cipher</code>：以 cipher 将数据传输进行加密，这个选项将直接传递给 ssh。</li>
<li><code>-F ssh_config</code>：指定一个替代的 ssh 配置文件，此参数直接传递给 ssh。</li>
<li><code>-i identity_file</code>：从指定文件中读取传输时使用的密钥文件，此参数直接传递给 ssh。</li>
<li><code>-l limit</code>：限定用户所能使用的带宽，以 Kbit&#x2F;s 为单位。</li>
<li><code>-o ssh_option</code>：可用于以 ssh_config 中使用的格式将选项传递给 ssh。</li>
<li><code>-P port</code>：注意是大写的P，port 是指定数据传输用到的端口号</li>
<li><code>-S program</code>：指定加密传输时所使用的程序。此程序必须能够理解 ssh 的选项。</li>
</ul>
<h2 id="示例-177"><a href="#示例-177" class="headerlink" title="示例"></a>示例</h2><p>假设远程服务器 IP 地址为 192.168.1.100，用户名为 root。</p>
<p>将本地文件（例如 &#x2F;opt&#x2F;file.tar.gz）复制到远程服务器的 &#x2F;opt 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp /opt/file.tar.gz root@192.168.1.100:/opt/</span><br></pre></td></tr></table></figure>



<p>从远程服务器复制文件 file.tar.gz 到本地 &#x2F;opt 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp root@192.168.1.100:/opt/file.tar.gz /opt/</span><br></pre></td></tr></table></figure>



<p>将本地目录（例如 &#x2F;var&#x2F;www&#x2F;html）复制到远程服务器的 &#x2F;opt 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r /var/www/html root@192.168.1.100:/opt/</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ftp-命令-文件传输协议客户端"><a href="#Linux-ftp-命令-文件传输协议客户端" class="headerlink" title="Linux ftp 命令 - 文件传输协议客户端"></a>Linux ftp 命令 - 文件传输协议客户端</h1><h2 id="介绍-177"><a href="#介绍-177" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ftp</strong> 命令是 FTP 文件传输协议（File Transfer Protocol）的客户端工具，用于本地主机和远程文件服务器之间上传和下载文件。ftp 命令使用 FTP 协议和远程文件服务器进行通信。</p>
<p>FTP 协议使用明文传送用户的认证信息，和容易被局域网内的嗅探软件截获，所以使用 ftp 命令时要格外注意。</p>
<p>匿名 FTP 服务器在登录时使用“anonymous”作为用户名，用任意的电子邮件作为密码。通常，匿名 FTP 服务器只能下载文件，而不允许用户上传文件。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ftp [-46pinegvd] [host [port]]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-d</code> ：使用调试模式运行（会详细显示指令执行过程，便于排错或分析程序执行的情况）。</li>
<li><code>-i</code> ：关闭互动模式，在遇到问题时不询问用户而直接执行。</li>
<li><code>-g</code> ：关闭本地主机文件名称支持特殊字符的扩充特性。</li>
<li><code>-n</code> ：不使用自动登录。</li>
<li><code>-v</code> ：显示指令执行过程的详细信息。</li>
<li><code>-t</code> ：激活数据包包追踪。</li>
<li><code>-4</code> ：只使用 IPv4。</li>
<li><code>-6</code> ：只使用 IPv6。</li>
</ul>
<p><strong>参数</strong>：主机名或 IP 地址，以及端口号</p>
<h2 id="示例-178"><a href="#示例-178" class="headerlink" title="示例"></a>示例</h2><p>启动 vsftpd 服务（FTP 默认端口为 21）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> service vsftpd start</span> </span><br></pre></td></tr></table></figure>



<p>打开 ftp 客户端，进入交互界面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ftp</span></span><br><span class="line"><span class="meta prompt_">ftp&gt;</span></span><br></pre></td></tr></table></figure>



<p>在交互界面中查看内部命令的帮助</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">ftp&gt; </span><span class="language-bash"><span class="built_in">help</span></span></span><br></pre></td></tr></table></figure>



<p>在交互界面连接 FTP 服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">ftp&gt; </span><span class="language-bash">open 192.168.1.100</span></span><br></pre></td></tr></table></figure>



<p>如果端口不是 21，则需要指定端口（比如 2020）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">ftp&gt; </span><span class="language-bash">open 192.168.1.100 2020</span></span><br></pre></td></tr></table></figure>



<p>从服务器中下载文件到本地</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">ftp&gt; </span><span class="language-bash">get remote-file local-file</span></span><br></pre></td></tr></table></figure>



<p>将一个本地的文件上传到服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">ftp&gt; </span><span class="language-bash">put local-file remote-file</span></span><br></pre></td></tr></table></figure>



<p>退出 ftp 客户端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">ftp&gt; </span><span class="language-bash">quit</span></span><br></pre></td></tr></table></figure>





<h1 id="Linux-curl-命令-网络请求传输工具"><a href="#Linux-curl-命令-网络请求传输工具" class="headerlink" title="Linux curl 命令 - 网络请求传输工具"></a>Linux curl 命令 - 网络请求传输工具</h1><h2 id="介绍-178"><a href="#介绍-178" class="headerlink" title="介绍"></a>介绍</h2><p><strong>curl</strong>（英文全拼：CommandLine URL）命令是在命令行方式下工作，利用 URL 的语法进行数据的传输或者文件的传输。</p>
<p>通常大家会把 curl 理解为下载工具，但其实它的功能十分强大。curl 支持包括 HTTP、HTTPS、FTP 等传输协议，还支持 POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等功能。甚至可用于网页处理流程和数据检索自动化。</p>
<p>URL 即 Uniform Resource Locator（统一资源定位符），是用于完整地描述 Internet 上网页和其他资源的地址的一种标识方法。比如 <code>https://getiot.tech</code> 就是一个 URL。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl [options / URLs]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>, <code>--append</code> ：上传文件时，附加到目标文件。</li>
<li><code>-A</code>, <code>--user-agent &lt;string&gt;</code> ：设置用户代理发送给服务器。</li>
<li><code>-anyauth</code> ：可以使用“任何”身份验证方法。</li>
<li><code>-b</code>, <code>--cookie &lt;name=string/file&gt;</code> ：cookie 字符串或文件读取位置。</li>
<li><code>-c</code>, <code>--cookie-jar &lt;file&gt;</code> ：操作结束后把 cookie 写入到这个文件中。</li>
<li><code>-C</code>, <code>--continue-at &lt;offset&gt;</code> ：断点续转。</li>
<li><code>-d</code>, <code>--data &lt;data&gt;</code> ：以 post 的方式传送数据。</li>
<li><code>-D</code>, <code>--dump-header &lt;file&gt;</code> ：把 header 信息写入到该文件中。</li>
<li><code>-e</code>, <code>--referer</code> ：来源网址。</li>
<li><code>-E</code>, <code>--cert &lt;cert[:passwd]&gt;</code> ：客户端证书文件和密码（SSL）。</li>
<li><code>-f</code>, <code>--fail</code> ：连接失败时不显示 http 错误。</li>
<li><code>-F</code>, <code>--form &lt;name=content&gt;</code> ：模拟 http 表单提交数据。</li>
<li><code>-G</code>, <code>--get</code> ：以 get 的方式来发送数据。</li>
<li><code>-H</code>, <code>--header &lt;line&gt;</code> ：自定义头信息传递给服务器。</li>
<li><code>-I</code>, <code>--head</code> ：只显示请求头信息。</li>
<li><code>-o</code>, <code>--output &lt;file&gt;</code> ：写入文件而不是标准输出。</li>
<li><code>-O</code>, <code>--remote-name</code> ：将输出写入与远程文件名字相同的文件。</li>
<li><code>-s</code>, <code>--silent</code> ：静默模式。不输出任何东西。</li>
<li><code>-u</code>, <code>--user &lt;user[:password]&gt;</code> ：设置服务器的用户和密码。</li>
<li><code>-U</code>, <code>--proxy-user &lt;user[:password]&gt;</code> ：设置代理用户名和密码。</li>
</ul>
<h2 id="示例-179"><a href="#示例-179" class="headerlink" title="示例"></a>示例</h2><p>抓取“人人都懂物联网”网站首页：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://getiot.tech</span><br></pre></td></tr></table></figure>



<p>将网页数据保存到本地文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://getiot.tech &gt; index.html</span><br></pre></td></tr></table></figure>



<p>设置 cookies：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://getiot.tech --cookie <span class="string">&quot;user=root;pass=123456&quot;</span></span><br></pre></td></tr></table></figure>



<p>设置用户代理字符串：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl URL --user-agent <span class="string">&quot;Mozilla/5.0&quot;</span></span><br><span class="line">curl URL -A <span class="string">&quot;Mozilla/5.0&quot;</span></span><br></pre></td></tr></table></figure>



<p>进行 HTTP 或者 FTP 的登录认证（可以指定密码，也可以不指定密码在后续操作中输入密码）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u user:<span class="built_in">pwd</span> https://getiot.tech</span><br><span class="line">curl -u user https://getiot.tech</span><br></pre></td></tr></table></figure>



<p>只打印响应头部信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -I https://getiot.tech</span><br></pre></td></tr></table></figure>



<p>下载远程文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O https://static.getiot.tech/flag-of-china.png</span><br></pre></td></tr></table></figure>



<p>下载远程文件，并重命名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o test.png https://static.getiot.tech/flag-of-china.png</span><br></pre></td></tr></table></figure>



<p>下载远程文件，并显示下载进度：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -# -O https://static.getiot.tech/flag-of-china.png</span><br></pre></td></tr></table></figure>



<p>下载并执行 nvm 的安装脚本（<code>-o-</code> 选项指定将下载的数据输出到标准输出，而不是保存为文件，这意味着下载的内容会被直接传输到管道）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash</span><br></pre></td></tr></table></figure>





<h1 id="Linux-wget-命令-网络文件下载工具"><a href="#Linux-wget-命令-网络文件下载工具" class="headerlink" title="Linux wget 命令 - 网络文件下载工具"></a>Linux wget 命令 - 网络文件下载工具</h1><h2 id="介绍-179"><a href="#介绍-179" class="headerlink" title="介绍"></a>介绍</h2><p><strong>wget</strong> 是一个用于从 web 下载文件的 Linux 命令行工具。支持 HTTP、HTTPS 和 FTP 协议，可以使用 HTTP 代理。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget [option]... [URL]...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><p>启动参数</p>
<ul>
<li><code>-V</code>, <code>--version</code> ：显示版本信息后退出。</li>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息后退出。</li>
<li><code>-b</code>, <code>--background</code> ：启动后转入后台执行。</li>
<li><code>-e</code>, <code>--execute=COMMAND</code> ：执行 .wgetrc 格式的命令（wgetrc 格式参见 &#x2F;etc&#x2F;wgetrc 或 ~&#x2F;.wgetrc）。</li>
</ul>
</li>
<li><p>记录和输入文件参数</p>
<ul>
<li><code>-o</code>, <code>--output-file=FILE</code> ：把记录写到 FILE 文件中。</li>
<li><code>-a</code>, <code>--append-output=FILE</code> ：把记录追加到 FILE 文件中。</li>
<li><code>-d</code>, <code>--debug</code> ：打印调试输出。</li>
<li><code>-q</code>, <code>–quiet</code> ：安静模式（没有输出）。</li>
<li><code>-v</code>, <code>--verbose</code> ：冗长模式（这是缺省设置）。</li>
<li><code>-nv</code>, <code>--non-verbose</code> ：关闭冗长模式，但不是安静模式。</li>
<li><code>-i</code>, <code>--input-file=FILE</code> ：下载在 FILE 文件中出现的 URLs。</li>
<li><code>-F</code>, <code>--force-html</code> ：把输入文件当作 HTML 格式文件对待。</li>
<li><code>-B</code>, <code>--base=URL</code> ：将 URL 作为在 <code>-i</code> 参数指定的文件中出现的相对链接的前缀。</li>
<li><code>--sslcertfile=FILE</code> ：可选客户端证书。</li>
<li><code>--sslcertkey=KEYFILE</code> ：可选客户端证书的 KEYFILE。</li>
<li><code>--egd-file=FILE</code> ：指定 EGD socket 的文件名。</li>
</ul>
</li>
<li><p>下载参数</p>
<ul>
<li><code>--bind-address=ADDRESS</code> ：指定本地使用地址（主机名或 IP，当本地有多个 IP 或名字时使用）。</li>
<li><code>-t</code>, <code>--tries=NUMBER</code> ：设定最大尝试链接次数（0 表示无限制）。</li>
<li><code>-O</code>, <code>--output-document=FILE</code> ：把文档写到 FILE 文件中。</li>
<li><code>-nc</code>, <code>--no-clobber</code> ：不要覆盖存在的文件或使用 .# 前缀。</li>
<li><code>-c</code>, <code>--continue</code> ：接着下载没下载完的文件。</li>
<li><code>--progress=TYPE</code> ：设定进程条标记。</li>
<li><code>-N</code>, <code>--timestamping</code> ：不要重新下载文件除非比本地文件新。</li>
<li><code>-S</code>, <code>--server-response</code> ：打印服务器的回应。</li>
<li><code>--spider</code> ：不下载任何东西。</li>
<li><code>-T</code>, <code>--timeout=SECONDS</code> ：设定响应超时的秒数。</li>
<li><code>-w</code>, <code>--wait=SECONDS</code> ：两次尝试之间间隔 SECONDS 秒。</li>
<li><code>--waitretry=SECONDS</code> ：在重新链接之间等待 1…SECONDS 秒。</li>
<li><code>--random-wait</code> ：在下载之间等待 0…2*WAIT 秒。</li>
<li><code>-Y</code>, <code>--proxy=on/off</code> ：打开或关闭代理。</li>
<li><code>-Q</code>, <code>--quota=NUMBER</code> ：设置下载的容量限制。</li>
<li><code>--limit-rate=RATE</code> ：限定下载输率。</li>
</ul>
</li>
<li><p>目录参数</p>
<ul>
<li><code>-nd</code>, <code>--no-directories</code> ：不创建目录。</li>
<li><code>-x</code>, <code>--force-directories</code> ：强制创建目录。</li>
<li><code>-nH</code>, <code>--no-host-directories</code> ：不创建主机目录。</li>
<li><code>-P</code>, <code>--directory-prefix=PREFIX</code> ：将文件保存到目录 <code>PREFIX/…</code>。</li>
<li><code>--cut-dirs=NUMBER</code> ：忽略 NUMBER 层远程目录。</li>
</ul>
</li>
<li><p>HTTP 选项参数</p>
<ul>
<li><code>--http-user=USER</code> ：设定 HTTP 用户名为 USER。</li>
<li><code>--http-passwd=PASS</code> ：设定 http 密码为 PASS。</li>
<li><code>-C</code>, <code>--cache=on/off</code> ：允许&#x2F;不允许服务器端的数据缓存（一般情况下允许）。</li>
<li><code>-E</code>, <code>--html-extension</code> ：将所有 text&#x2F;html 文档以 .html 扩展名保存。</li>
<li><code>--ignore-length</code> ：忽略 <code>Content-Length</code> 头域。</li>
<li><code>--header=STRING</code> ：在 headers 中插入字符串 STRING。</li>
<li><code>--proxy-user=USER</code> ：设定代理的用户名为 USER。</li>
<li><code>--proxy-passwd=PASS</code> ：设定代理的密码为 PASS。</li>
<li><code>--referer=URL</code> ：在 HTTP 请求中包含 <code>Referer: URL</code> 头。</li>
<li><code>-s</code>, <code>--save-headers</code> ：保存 HTTP 头到文件。</li>
<li><code>-U</code>, <code>--user-agent=AGENT</code> ：设定代理的名称为 AGENT 而不是 Wget&#x2F;VERSION。</li>
<li><code>--no-http-keep-alive</code> ：关闭 HTTP 活动链接（永久链接）。</li>
<li><code>--cookies=off</code> ：不使用 cookies。</li>
<li><code>--load-cookies=FILE</code> ：在开始会话前从文件 FILE 中加载 cookie。</li>
<li><code>--save-cookies=FILE</code> ：在会话结束后将 cookies 保存到 FILE 文件中。</li>
</ul>
</li>
<li><p>FTP 选项参数</p>
<ul>
<li><code>-nr</code>, <code>–dont-remove-listing</code> ：不移走 .listing 文件。</li>
<li><code>-g</code>, <code>--glob=on/off</code> ：打开或关闭文件名的 globbing 机制。</li>
<li><code>--passive-ftp</code> ：使用被动传输模式（缺省值）。</li>
<li><code>--active-ftp</code> ：使用主动传输模式。</li>
<li><code>--retr-symlinks</code> ：在递归的时候，将链接指向文件（而不是目录）。</li>
</ul>
</li>
<li><p>递归下载参数</p>
<ul>
<li><code>-r</code>, <code>--recursive</code> ：递归下载。</li>
<li><code>-l</code>, <code>--level=NUMBER</code> ：最大递归深度（inf 或 0 代表无穷）。</li>
<li><code>--delete-after</code> ：在现在完毕后局部删除文件。</li>
<li><code>-k</code>, <code>--convert-links</code> ：转换非相对链接为相对链接。</li>
<li><code>-K</code>, <code>--backup-converted</code> ：在转换文件 X 之前，将之备份为 X.orig。</li>
<li><code>-m</code>, <code>--mirror</code> ：等价于 <code>-r -N -l inf -nr</code>。</li>
<li><code>-p</code>, <code>--page-requisites</code> ：下载显示 HTML 文件的所有图片。</li>
</ul>
</li>
<li><p>递归下载中的包含和不包含</p>
<p>（accept&#x2F;reject）</p>
<ul>
<li><code>-A</code>, <code>--accept=LIST</code> ：分号分隔的被接受扩展名的列表。</li>
<li><code>-R</code>, <code>--reject=LIST</code> ：分号分隔的不被接受的扩展名的列表。</li>
<li><code>-D</code>, <code>--domains=LIST</code> ：分号分隔的被接受域的列表。</li>
<li><code>--exclude-domains=LIST</code> ：分号分隔的不被接受的域的列表。</li>
<li><code>--follow-ftp</code> ：跟踪 HTML 文档中的 FTP 链接。</li>
<li><code>--follow-tags=LIST</code> ：分号分隔的被跟踪的 HTML 标签的列表。</li>
<li><code>-G</code>, <code>--ignore-tags=LIST</code> ：分号分隔的被忽略的 HTML 标签的列表。</li>
<li><code>-H</code>, <code>--span-hosts</code> ：当递归时转到外部主机。</li>
<li><code>-L</code>, <code>--relative</code> ：仅仅跟踪相对链接。</li>
<li><code>-I</code>, <code>--include-directories=LIST</code> ：允许目录的列表。</li>
<li><code>-X</code>, <code>--exclude-directories=LIST</code> ：不被包含目录的列表。</li>
<li><code>-np</code>, <code>--no-parent</code> ：不要追溯到父目录。</li>
</ul>
</li>
</ul>
<h2 id="示例-180"><a href="#示例-180" class="headerlink" title="示例"></a>示例</h2><p><strong>下载单个文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/getiot/helloworld/archive/refs/tags/v1.0.zip</span><br></pre></td></tr></table></figure>



<p><strong>下载并以指定文件名保存</strong>（wget 默认会以最后一个符号 <code>/</code> 后面的字符来命名下载文件）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O helloworld.zip https://github.com/getiot/helloworld/archive/refs/tags/v1.0.zip</span><br></pre></td></tr></table></figure>



<p><strong>限速下载</strong>（wget 默认会占用全部可能的宽带下载，当需要下载大文件时，就有必要进行限速）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --limit-rate=300k https://github.com/getiot/helloworld/archive/refs/tags/v1.0.zip</span><br></pre></td></tr></table></figure>



<p><strong>断点续传</strong>（使用 -c 选项可以在重新启动 wget 时继续接着下载，而不是重新下载一个文件）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c https://github.com/getiot/helloworld/archive/refs/tags/v1.0.zip</span><br></pre></td></tr></table></figure>



<p><strong>后台下载</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -b https://github.com/getiot/helloworld/archive/refs/tags/v1.0.zip</span><br><span class="line"></span><br><span class="line">Continuing <span class="keyword">in</span> background, pid 1840.</span><br><span class="line">Output will be written to `wget-log<span class="string">&#x27;.</span></span><br></pre></td></tr></table></figure>



<p>对于下载非常大的文件的时候，我们可以使用 <code>-b</code> 选项进行后台下载，输出记录在 wget-log 文件，可以使用以下命令查看下载进度：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f wget-log</span><br></pre></td></tr></table></figure>



<p><strong>伪装代理名称下载</strong>（有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求，可以通过 <code>--user-agent</code> 选项参数伪装）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --user-agent=<span class="string">&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16&quot;</span> https://github.com/getiot/helloworld/archive/refs/tags/v1.0.zip</span><br></pre></td></tr></table></figure>



<p><strong>增加重试次数</strong>（wget 默认重试 20 次连接下载文件）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --tries=40 https://github.com/getiot/helloworld/archive/refs/tags/v1.0.zip</span><br></pre></td></tr></table></figure>



<p><strong>下载多个文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -i filelist.txt</span><br></pre></td></tr></table></figure>



<p>filelist.txt 文件记录下载链接文件，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; filelist.txt</span><br><span class="line">https://github.com/getiot/helloworld/archive/refs/tags/v1.0.zip</span><br><span class="line">https://github.com/getiot/helloworld/archive/refs/tags/v2.0.zip</span><br><span class="line">https://github.com/getiot/helloworld/archive/refs/tags/v3.0.zip</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p><strong>镜像网站</strong>（下载整个网站到本地）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --mirror -p --convert-links -P ./LOCAL &lt;URL&gt;</span><br></pre></td></tr></table></figure>



<p>说明：</p>
<ul>
<li><code>--miror</code> 开启镜像下载。</li>
<li><code>-p</code> 下载所有为 html 页面显示正常的文件。</li>
<li><code>--convert-links</code> 下载后，转换成本地的链接。</li>
<li><code>-P ./LOCAL</code> 保存所有文件和目录到本地指定目录。</li>
</ul>
<p><strong>过滤指定格式下载</strong>（下载一个网站，但不希望下载图片）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --reject=gif &lt;URL&gt;</span><br></pre></td></tr></table></figure>



<p><strong>把下载信息存入日志文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -o download.log &lt;URL&gt;</span><br></pre></td></tr></table></figure>



<p><strong>限制总下载文件大小</strong>（如果下载的文件超过 5M 则退出下载，该选项只对递归下载有效）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -Q5m -i filelist.txt</span><br></pre></td></tr></table></figure>



<p><strong>下载指定格式文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -r -A.pdf &lt;URL&gt;</span><br></pre></td></tr></table></figure>



<p>可以在以下情况使用该功能：</p>
<ul>
<li>下载一个网站的所有图片。</li>
<li>下载一个网站的所有视频。</li>
<li>下载一个网站的所有 PDF 文件。</li>
</ul>
<p><strong>FTP 下载</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --ftp-user=USERNAME --ftp-password=PASSWORD &lt;URL&gt;</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ping-命令-测试网络连接状态"><a href="#Linux-ping-命令-测试网络连接状态" class="headerlink" title="Linux ping 命令 - 测试网络连接状态"></a>Linux ping 命令 - 测试网络连接状态</h1><h2 id="介绍-180"><a href="#介绍-180" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ping</strong> 是一个非常常用的计算机网络测试工具，用于测试数据包能否透过 IP 协议到达特定主机，从而判断网络的连通性。无论是 Linux、Windows、macOS 还是嵌入式 RTOS 都会提供 ping 命令。ping 的运作原理是向目标主机传出一个 ICMP 的请求回显数据包，并等待接收回显回应数据包。程序会按时间和成功响应的次数估算丢失数据包率（丢包率）和数据包往返时间（网络时延，Round-trip delay time）。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping [options] &lt;destination&gt;</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>&lt;destination&gt;</code>：IP 地址或 DNS 域名。</li>
<li><code>-a</code>：使用听得见的（audible）ping。</li>
<li><code>-A</code>：使用自适应（adaptive）ping。</li>
<li><code>-B</code>：粘性源地址（sticky source address）。</li>
<li><code>-c &lt;count&gt;</code>：在 <code>&lt;count&gt;</code> 个回复后停止。</li>
<li><code>-D</code>：打印时间戳。</li>
<li><code>-d</code>：使用 <code>SO_DEBUG</code> 套接字选项。</li>
<li><code>-f</code>：flood ping。</li>
<li><code>-h</code>：打印帮助信息。</li>
<li><code>-I &lt;interface&gt;</code>：指定网卡接口名称或 IP 地址。</li>
<li><code>-i &lt;interval&gt;</code>：指定发送每个数据包之间的时间间隔（秒数）。</li>
<li><code>-L</code>：抑制组播（multicast）数据包的环回（loopback）。</li>
<li><code>-l &lt;preload&gt;</code>：在等待回复时发送 <code>&lt;preload&gt;</code> 个包数。</li>
<li><code>-m &lt;mark&gt;</code>：标记发出的数据包。</li>
<li><code>-M &lt;pmtud opt&gt;</code>：定义 mtu 发现，可以是 <code>&lt;do|dont|want&gt;</code> 之一。</li>
<li><code>-n</code>：没有 DNS 名称解析。</li>
<li><code>-O</code>：报告未完成的答复。</li>
<li><code>-p &lt;pattern&gt;</code>：填充字节的内容。</li>
<li><code>-q</code>：安静的输出。</li>
<li><code>-Q &lt;tclass&gt;</code>：使用服务质量 <code>&lt;tclass&gt;</code> 位。</li>
<li><code>-s &lt;size&gt;</code>：使用 <code>&lt;size&gt;</code> 作为要发送的数据字节数。</li>
<li><code>-S &lt;size&gt;</code>：使用 <code>&lt;size&gt;</code> 作为 <code>SO_SNDBUF</code> 套接字选项的值。</li>
<li><code>-t &lt;ttl&gt;</code>：定义生存时间。</li>
<li><code>-U</code>：打印用户到用户（user-to-user）的延迟（latency）。</li>
<li><code>-v</code>：详细输出。</li>
<li><code>-V</code>：打印版本信息并退出。</li>
<li><code>-w &lt;deadline&gt;</code>：回复等待 <code>&lt;deadline&gt;</code> 秒。</li>
<li><code>-W &lt;timeout&gt;</code>：等待响应的时间。</li>
</ul>
<p><strong>IPv4 专用选项</strong>：</p>
<ul>
<li><code>-4</code>：使用 IPv4。</li>
<li><code>-b</code>：允许 ping 广播。</li>
<li><code>-R</code>：记录路由。</li>
<li><code>-T &lt;timestamp&gt;</code>：定义时间戳，可以是 <code>&lt;tsonly|tsandaddr|tsprespec&gt;</code> 之一。</li>
</ul>
<p><strong>IPv6 专用选项</strong>：</p>
<ul>
<li><code>-6</code>：使用 IPv6。</li>
<li><code>-F &lt;flowlabel&gt;</code>：定义流标签，默认为随机。</li>
<li><code>-N &lt;nodeinfo opt&gt;</code>：使用 icmp6 节点信息查询。</li>
</ul>
<h2 id="示例-181"><a href="#示例-181" class="headerlink" title="示例"></a>示例</h2><p>测试本机与「人人都懂物联网」网站的连通情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping getiot.tech</span><br></pre></td></tr></table></figure>



<p>测试本机与 192.168.0.2 设备的网络连通情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping 192.168.0.2</span><br></pre></td></tr></table></figure>



<p>指定网卡进行 ping 测试（网卡名称可通过 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/ifconfig/">ifconfig</a> 命令查看）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping -I eth0 192.168.0.2</span><br></pre></td></tr></table></figure>



<p>测试 1000 次</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping -c 1000 192.168.0.2</span><br></pre></td></tr></table></figure>



<p>以时间间隔 2 秒测试 1000 次</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping -i 2 -c 1000 192.168.0.2</span><br></pre></td></tr></table></figure>





<h1 id="Linux-dig-命令-域名查询工具"><a href="#Linux-dig-命令-域名查询工具" class="headerlink" title="Linux dig 命令 - 域名查询工具"></a>Linux dig 命令 - 域名查询工具</h1><h2 id="介绍-181"><a href="#介绍-181" class="headerlink" title="介绍"></a>介绍</h2><p><strong>dig</strong>（英文全拼：domain information groper）是一个用来灵活探测 DNS 的工具。它会打印出受请求的 DNS 域名服务器的回应。</p>
<p>多数 DNS 管理员利用 dig 作为 DNS 问题的故障诊断，因为它灵活性好、易用、输出清晰。虽然通常情况下 dig 使用命令行参数，但它也可以按批处理模式从文件读取搜索请求。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dig [选项] [参数]</span><br></pre></td></tr></table></figure>



<p>详细语法格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dig [@server] [-b address] [-c class] [-f filename] [-k filename] [-m]</span><br><span class="line">    [-p port#] [-q name] [-t <span class="built_in">type</span>] [-v] [-x addr] [-y [hmac:]name:key]</span><br><span class="line">    [[-4] | [-6]] [name] [<span class="built_in">type</span>] [class] [queryopt...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>@&lt;server&gt;</code> ：指定进行域名解析的域名服务器。</li>
<li><code>-b &lt;address&gt;</code> ：设置所要询问地址的源 IP 地址。这必须是主机网络接口上的某一合法的地址。当主机具有多个IP地址，指定使用本机的哪个IP地址向域名服务器发送域名查询请求。</li>
<li><code>-c &lt;class&gt;</code> ：缺省查询类（IN for internet）由选项 -c 重设。class 可以是任何合法类，比如查询 Hesiod 记录的 HS 类或查询 CHAOSNET 记录的 CH 类。</li>
<li><code>-f &lt;filename&gt;</code> ：使 dig 在批处理模式下运行，通过从文件 filename 读取一系列搜索请求加以处理。文件包含许多查询；每行一个。文件中的每一项都应该以和使用命令行接口对 dig 的查询相同的方法来组织。</li>
<li><code>-k &lt;filename&gt;</code> ：要签署由 dig 发送的 DNS 查询以及对它们使用事务签名（TSIG）的响应，用 选项 -k 指定 TSIG 密钥文件。</li>
<li><code>-p &lt;port&gt;</code> ：如果需要查询一个非标准的端口号，则使用 -p 选项。port 是 dig 将发送其查询的端口号，而不是标准的 DNS 端口号 53。该选项可用于测试已在非标准端口号上配置成侦听查询的域名服务器。</li>
<li><code>-t &lt;type&gt;</code> ：设置查询类型为 type。可以是 BIND9 支持的任意有效查询类型。缺省查询类型是 A，除非提供 -x 选项来指示一个逆向查询。通过指定 AXFR 的 type 可以请求一个区域传输。当需要增量区域传输（IXFR）时，type 设置为 ixfr&#x3D;N。增量区域传输将包含自从区域的 SOA 记录中的序列号改为 N 之后对区域所做的更改。</li>
<li><code>-x &lt;addr&gt;</code> ：逆向查询（将地址映射到名称）可以通过 -x 选项加以简化。addr 是一个 以小数点为界的 IPv4 地址或冒号为界的 IPv6 地址。当使用这个选项时，无需提供 name、class 和 type 参数。dig 自动运行类似 <code>11.12.13.10.in-addr.arpa</code> 的域名查询，并分别设置查询类型和类为 PTR 和 IN。</li>
<li><code>-y [hmac:]name:key</code> ：您可以通过命令行上的 -y 选项指定 TSIG 密钥；name 是 TSIG 密码的名称，key 是实际的密码。密码是 64 位加密字符串，通常由 dnssec-keygen（8）生成。当在多用户系统上使用选项 -y 时应该谨慎，因为密码在 ps（1）的输出或 shell 的历史文件中可能是可见的。当同时使用 dig 和 TSCG 认证时，被查询的名称服务器需要知道密码和解码规则。在 BIND 中，通过提供正确的密码和 named.conf 中的服务器声明实现。</li>
<li><code>-4</code> ：只使用 IPv4。</li>
<li><code>-6</code> ：只使用 IPv6。</li>
<li><code>-h</code> ：显示指令帮助信息。</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li>主机（name）：指定要查询域名主机。</li>
<li>查询类型（type）：指定 DNS 查询的类型。</li>
<li>查询类（class）：指定查询 DNS 的 class。</li>
<li>查询选项（queryopt）：指定查询选项。使用不同的查询选项会影响搜索方式和结果显示，每个查询选项被带前缀（+）的关键字标识，通常前缀是求反关键字含义的字符串 no，其他关键字分配各选项的值（比如超时时间间隔），它们的格式形如 +keyword&#x3D;value。</li>
</ul>
<p><strong>查询选项</strong>：</p>
<ul>
<li><code>+[no]tcp</code> ：查询域名服务器时使用 [不使用] TCP。缺省行为是使用 UDP，除非是 AXFR 或 IXFR 请求，才使用 TCP 连接。</li>
<li><code>+[no]vc</code> ：查询名称服务器时使用 [不使用] TCP。+[no]tcp 的备用语法提供了向下兼容。 vc 代表虚电路。</li>
<li><code>+[no]ignore</code> ：忽略 UDP 响应的中断，而不是用 TCP 重试。缺省情况运行 TCP 重试。</li>
<li><code>+domain=somename</code> ：设定包含单个域 somename 的搜索列表，好像被 &#x2F;etc&#x2F;resolv.conf 中的域伪指令指定，并且启用搜索列表处理，好像给定了 +search 选项。</li>
<li><code>+[no]search</code> ：使用 [不使用] 搜索列表 或 resolv.conf 中的域伪指令（如果有的话）定义的搜索列表。缺省情况不使用搜索列表。</li>
<li><code>+[no]defname</code> ：不建议看作 +[no]search 的同义词。</li>
<li><code>+[no]aaonly</code> ：该选项不做任何事。它用来提供对设置成未实现解析器标志的 dig 的旧版本的兼容性。</li>
<li><code>+[no]adflag</code> ：在查询中设置 [不设置] AD（真实数据）位。目前 AD 位只在响应中有标准含义，而查询中没有，但是出于完整性考虑在查询中这种性能可以设置。</li>
<li><code>+[no]cdflag</code> ：在查询中设置 [不设置] CD（检查禁用）位。它请求服务器不运行响应信息的 DNSSEC 合法性。</li>
<li><code>+[no]recursive</code> ：切换查询中的 RD（要求递归）位设置。在缺省情况下设置该位，也就是说 dig 正常情形下发送递归查询。当使用 查询选项 +nssearch 或 +trace 时，递归自动禁用。</li>
<li><code>+[no]nssearch</code> ：这个选项被设置时，dig 试图寻找包含待搜名称的网段的权威域名服务器，并显示网段中每台域名服务器的 SOA 记录。</li>
<li><code>+[no]trace</code> ：切换为待查询名称从根名称服务器开始的代理路径跟踪。缺省情况不使用跟踪。一旦启用跟踪，dig 使用迭代查询解析待查询名称。它将按照从根服务器的参照，显示来自每台使用解析查询的服务器的应答。</li>
<li><code>+[no]cmd</code> ：设定在输出中显示指出 dig 版本及其所用的查询选项的初始注释。缺省情况下显示注释。</li>
<li><code>+[no]short</code> ：提供简要答复。缺省值是以冗长格式显示答复信息。</li>
<li><code>+[no]identify</code> ：当启用 +short 选项时，显示 [或不显示] 提供应答的 IP 地址和端口号。如果请求简短格式应答，缺省情况不显示提供应答的服务器的源地址和端口号。</li>
<li><code>+[no]comments</code> ：切换输出中的注释行显示。缺省值是显示注释。</li>
<li><code>+[no]stats</code> ：该查询选项设定显示统计信息：查询进行时，应答的大小等等。缺省显示查询统计信息。</li>
<li><code>+[no]qr</code> ：显示 [不显示] 发送的查询请求。缺省不显示。</li>
<li><code>+[no]question</code> ：当返回应答时，显示 [不显示] 查询请求的问题部分。缺省作为注释显示问题部分。</li>
<li><code>+[no]answer</code> ：显示 [不显示] 应答的回答部分。缺省显示。</li>
<li><code>+[no]authority</code> ：显示 [不显示] 应答的权限部分。缺省显示。</li>
<li><code>+[no]additional</code> ：显示 [不显示] 应答的附加部分。缺省显示。</li>
<li><code>+[no]all</code> ：设置或清除所有显示标志。</li>
<li><code>+time=T</code> ：为查询设置超时时间为 T 秒。缺省是5秒。如果将 T 设置为小于1的数，则以1秒作为查询超时时间。</li>
<li><code>+tries=A</code> ：设置向服务器发送 UDP 查询请求的重试次数为 A，代替缺省的 3 次。如果把 A 小于或等于 0，则采用 1 为重试次数。</li>
<li><code>+ndots=D</code> ：出于完全考虑，设置必须出现在名称 D 的点数。缺省值是使用在 &#x2F;etc&#x2F;resolv.conf 中的 ndots 语句定义的，或者是 1，如果没有 ndots 语句的话。带更少点数的名称 被解释为相对名称，并通过搜索列表中的域或文件 &#x2F;etc&#x2F;resolv.conf 中的域伪指令进行搜索。</li>
<li><code>+bufsize=B</code> ：设置使用 EDNS0 的 UDP 消息缓冲区大小为 B 字节。缓冲区的最大值和最小值分别为 65535 和 0。超出这个范围的值自动舍入到最近的有效值。</li>
<li><code>+[no]multiline</code> ：以详细的多行格式显示类似 SOA 的记录，并附带可读注释。缺省值是每单个行上显示一条记录，以便于计算机解析 dig 的输出。</li>
</ul>
<h2 id="示例-182"><a href="#示例-182" class="headerlink" title="示例"></a>示例</h2><p>不加任何参数，可以显示 internet 上的13个根域服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dig</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt;</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 61518</span></span><br><span class="line"><span class="string">;; flags: qr rd ra; QUERY: 1, ANSWER: 13, AUTHORITY: 0, ADDITIONAL: 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">; EDNS: version: 0, flags:; udp: 65494</span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;.				IN	NS</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ANSWER SECTION:</span></span><br><span class="line"><span class="string">.			203341	IN	NS	j.root-servers.net.</span></span><br><span class="line"><span class="string">.			203341	IN	NS	b.root-servers.net.</span></span><br><span class="line"><span class="string">.			203341	IN	NS	i.root-servers.net.</span></span><br><span class="line"><span class="string">.			203341	IN	NS	h.root-servers.net.</span></span><br><span class="line"><span class="string">.			203341	IN	NS	k.root-servers.net.</span></span><br><span class="line"><span class="string">.			203341	IN	NS	a.root-servers.net.</span></span><br><span class="line"><span class="string">.			203341	IN	NS	g.root-servers.net.</span></span><br><span class="line"><span class="string">.			203341	IN	NS	m.root-servers.net.</span></span><br><span class="line"><span class="string">.			203341	IN	NS	c.root-servers.net.</span></span><br><span class="line"><span class="string">.			203341	IN	NS	l.root-servers.net.</span></span><br><span class="line"><span class="string">.			203341	IN	NS	f.root-servers.net.</span></span><br><span class="line"><span class="string">.			203341	IN	NS	e.root-servers.net.</span></span><br><span class="line"><span class="string">.			203341	IN	NS	d.root-servers.net.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; Query time: 36 msec</span></span><br><span class="line"><span class="string">;; SERVER: 127.0.0.53#53(127.0.0.53)</span></span><br><span class="line"><span class="string">;; WHEN: 四 4月 15 08:12:52 CST 2021</span></span><br><span class="line"><span class="string">;; MSG SIZE  rcvd: 239</span></span><br></pre></td></tr></table></figure>



<p>查询 getiot.tech 域名的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dig getiot.tech</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; getiot.tech</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 37046</span></span><br><span class="line"><span class="string">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">; EDNS: version: 0, flags:; udp: 65494</span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;getiot.tech.			IN	A</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ANSWER SECTION:</span></span><br><span class="line"><span class="string">getiot.tech.		600	IN	A	42.192.64.149</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; Query time: 340 msec</span></span><br><span class="line"><span class="string">;; SERVER: 127.0.0.53#53(127.0.0.53)</span></span><br><span class="line"><span class="string">;; WHEN: 四 4月 15 08:11:33 CST 2021</span></span><br><span class="line"><span class="string">;; MSG SIZE  rcvd: 56</span></span><br></pre></td></tr></table></figure>



<p>查询 getiot.tech 域名的信息，进行简短输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dig getiot.tech +short</span><br><span class="line">42.192.64.149</span><br></pre></td></tr></table></figure>



<p>跟踪域名解析过程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dig getiot.tech +trace</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; getiot.tech +trace</span><br><span class="line">;; global options: +cmd</span><br><span class="line">.			6919	IN	NS	d.root-servers.net.</span><br><span class="line">.			6919	IN	NS	e.root-servers.net.</span><br><span class="line">.			6919	IN	NS	f.root-servers.net.</span><br><span class="line">.			6919	IN	NS	l.root-servers.net.</span><br><span class="line">.			6919	IN	NS	c.root-servers.net.</span><br><span class="line">.			6919	IN	NS	m.root-servers.net.</span><br><span class="line">.			6919	IN	NS	g.root-servers.net.</span><br><span class="line">.			6919	IN	NS	a.root-servers.net.</span><br><span class="line">.			6919	IN	NS	k.root-servers.net.</span><br><span class="line">.			6919	IN	NS	h.root-servers.net.</span><br><span class="line">.			6919	IN	NS	i.root-servers.net.</span><br><span class="line">.			6919	IN	NS	b.root-servers.net.</span><br><span class="line">.			6919	IN	NS	j.root-servers.net.</span><br><span class="line">;; Received 262 bytes from 127.0.0.53#53(127.0.0.53) <span class="keyword">in</span> 0 ms</span><br><span class="line">......</span><br></pre></td></tr></table></figure>





<h1 id="Linux-iperf-命令-网络带宽测试工具"><a href="#Linux-iperf-命令-网络带宽测试工具" class="headerlink" title="Linux iperf 命令 - 网络带宽测试工具"></a>Linux iperf 命令 - 网络带宽测试工具</h1><h2 id="介绍-182"><a href="#介绍-182" class="headerlink" title="介绍"></a>介绍</h2><p><strong>iperf</strong> 是一个 Linux 网络性能测试命令行工具。可用于测试 TCP 和 UDP 带宽质量，例如最大 TCP 带宽等多种参数特性，报告带宽、延迟抖动和数据包丢失。因此，我们常常利用 iperf 工具来来测试一些网络设备的性能，如路由器、防火墙、交换机等。</p>
<p>Linux 系统通常默认不安装 iperf 工具，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install iperf</span><br></pre></td></tr></table></figure>



<p>另外还有一个 iperf3 工具，和 iperf 的区别是它不支持双工模式测试。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iperf [-s|-c host] [options]</span><br><span class="line">iperf [-h|--<span class="built_in">help</span>] [-v|--version]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-f</code>, <code>--format [abkmgBKMG]</code>：格式化带宽数输出。每个字母分别对应：adaptive、bits、Bytes、Kbits、Mbits、Gbits、KBytes、MBytes、GBytes，默认参数是 a，即自适应。值得注意的是，在计算字节 byte 时，Kilo &#x3D; 1024，Mega &#x3D; 1024^2，Giga &#x3D; 1024^3。通常在网络中，Kilo &#x3D; 1000，Mega &#x3D; 1000^2，Giga &#x3D; 1000^3，所以 iperf 也按此来计算比特（位）。如果这些困扰了你，那么请使用 <code>-f b</code> 参数，然后亲自计算一下。</li>
<li><code>-i</code>, <code>--interval</code>：设置每次报告之间的时间间隔，单位为秒。如果设置为非零值，就会按照此时间间隔输出测试报告。默认值为零。</li>
<li><code>-l</code>, <code>--len n[kmKM]</code>：设置读写缓冲区的长度。TCP 方式默认为 8KB，UDP 方式默认为 1470 字节。</li>
<li><code>-m</code>, <code>--print_mss</code>：输出 TCP 的 MSS 值（MSS 全称是 maximum segment size，通过 <code>TCP_MAXSEG</code> 支持）。通常情况下，MSS 值比 MTU 值小 40 字节。</li>
<li><code>-p</code>, <code>--port</code>：设置端口，与服务器端的监听端口一致。默认使用 5001 端口。</li>
<li><code>-u</code>, <code>--udp</code>：使用 UDP 方式而不是 TCP 方式。</li>
<li><code>-w</code>, <code>--window n[kmKM]</code>：设置套接字缓冲区为指定大小。对于 TCP 方式，此设置为 TCP 窗口大小。对于 UDP 方式，此设置为接受 UDP 数据包的缓冲区大小，限制可以接受数据包的最大值。</li>
<li><code>-B</code>, <code>--bind host</code>：绑定到主机的多个地址中的一个。对于客户端来说，这个参数设置了出栈接口。对于服务器端来说，这个参数设置入栈接口。这个参数只用于具有多网络接口的主机。在 iperf 的 UDP 模式下，此参数用于绑定和加入一个多播组。使用范围在 224.0.0.0 至 239.255.255.255 的多播地址。</li>
<li><code>-C</code>, <code>--compatibility</code>：与低版本的 iperf 使用时，可以使用兼容模式。不需要两端同时使用兼容模式，但是强烈推荐两端同时使用兼容模式。某些情况下，使用某些数据流可以引起1.7版本的服务器端崩溃或引起非预期的连接尝试。</li>
<li><code>-M</code>, <code>--mss</code>：ip 头减去 40 字节。在以太网中，MSS 值为 1460 字节（MTU 值为 1500 字节）。</li>
<li><code>-N</code>, <code>--nodelay</code>：设置 TCP 无延迟选项，禁用 Nagle’s 运算法则。通常情况此选项对于交互程序，例如 telnet，是禁用的。</li>
<li><code>-V</code>, <code>--ipv6_domain</code>：绑定一个 IPv6 地址。 注意，在 1.6.3 或更高版本中，指定 IPv6 地址不需要使用 <code>-B</code> 参数绑定，在 1.6 之前的版本则需要。在大多数操作系统中，将响应 IPv4 客户端映射的 IPv4 地址。</li>
<li><code>-h</code>, <code>--help</code>：显示命令行参考并退出。</li>
<li><code>-v</code>, <code>--version</code>：显示版本信息和编译信息并退出。</li>
</ul>
<p><strong>服务器端专用选项</strong>：</p>
<ul>
<li><code>-s</code>, <code>--server</code>：iperf 服务器模式 。</li>
<li><code>-D</code>：Unix 平台下 iperf 作为后台守护进程运行。在 Win32 平台下，iperf 将作为服务运行。</li>
<li><code>-R</code>：卸载 iperf 服务（如果它在运行），仅用于 Windows 系统。</li>
<li><code>-o</code>：重定向输出到指定文件，仅用于 Windows 系统。</li>
<li><code>-c</code>, <code>--client host</code>：如果 iperf 运行在服务器模式，并且用 <code>-c</code> 参数指定一个主机，那么 <code>iperf</code> 将只接受指定主机的连接。此参数不能工作于 UDP 模式。</li>
<li><code>-P</code>, <code>--parallel</code>：服务器关闭之前保持的连接数。默认是 0，这意味着永远接受连接。</li>
</ul>
<p><strong>客户端专用选项</strong>：</p>
<ul>
<li><code>-b</code>, <code>--bandwidth n[kmgKMG]</code>：UDP 模式使用的带宽，单位 bits&#x2F;sec。此选项与 -u 选项相关。默认值是 1 Mbit&#x2F;sec。</li>
<li><code>-c</code>, <code>--client host</code>：运行 iperf 的客户端模式，连接到指定的 iperf 服务器端。</li>
<li><code>-d</code>, <code>--dualtest</code>：运行双测试模式。这将使服务器端反向连接到客户端，使用 <code>-L</code> 参数中指定的端口（或默认使用客户端连接到服务器端的端口）。如果你想要一个交互的测试，请尝试 <code>-r</code> 参数。</li>
<li><code>-n</code>, <code>--num n[kmKM]</code>：传送的缓冲器数量。通常情况，iperf 按照 10 秒钟发送数据。<code>-n</code> 参数跨越此限制，按照指定次数发送指定长度的数据，而不论该操作耗费多少时间。参考 <code>-l</code> 与 <code>-t</code> 选项。</li>
<li><code>-r</code>, <code>--tradeoff</code>：往复测试模式。当客户端到服务器端的测试结束时，服务器端通过 <code>-l</code> 选项指定的端口（或默认为客户端连接到服务器端的端口），反向连接至客户端。当客户端连接终止时，反向连接随即开始。如果需要同时进行双向测试，请尝试 <code>-d</code> 参数。</li>
<li><code>-t</code>, <code>--time</code>：设置传输的总时间。iperf 在指定的时间内，重复的发送指定长度的数据包。默认是 10 秒钟。参考 <code>-l</code> 与 <code>-n</code> 选项。</li>
<li><code>-L</code>, <code>--listenport</code>：指定服务端反向连接到客户端时使用的端口。默认使用客户端连接至服务端的端口。</li>
<li><code>-P</code>, <code>--parallel</code>：指定客户端与服务端之间使用的线程数，默认是 1 线程。需要客户端与服务器端同时使用此参数。</li>
<li><code>-S</code>, <code>--tos</code>：出栈数据包的服务类型，不过许多路由器都忽略 TOS 字段。你可以指定这个值，使用以 “0x” 开始的 16 进制数，或以 “0” 开始的 8 进制数或 10 进制数。例如，十六进制 ‘0x10’ &#x3D; 八进制 ‘020’ &#x3D; 十进制 ‘16’。</li>
<li><code>-T</code>, <code>--ttl</code>：出栈多播数据包的 TTL 值。这本质上就是数据通过路由器的跳数。默认是 1，链接本地。</li>
<li><code>-F</code>：使用特定的数据流测量带宽，例如指定的文件。</li>
</ul>
<h2 id="示例-183"><a href="#示例-183" class="headerlink" title="示例"></a>示例</h2><h3 id="UDP-模式"><a href="#UDP-模式" class="headerlink" title="UDP 模式"></a>UDP 模式</h3><p>启动 UDP 服务器端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iperf -u -s</span><br></pre></td></tr></table></figure>



<p>启动 UDP 客户端，以 100Mbps 为数据发送速率，测试时间为 60 秒。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iperf -u -c 192.168.0.1 -b 100M -t 60</span><br></pre></td></tr></table></figure>



<p>在 UDP 模式下，以 100M 为数据发送速率，进行上下行带宽测试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iperf -u -c 192.168.0.1 -b 100M -d -t 60</span><br></pre></td></tr></table></figure>



<p>在 UDP 模式下，客户端同时向服务器端发起 30 个连接线程，以 5Mbps 为数据发送速率。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iperf -u -c 192.168.0.1 -b 5M -P 30 -t 60</span><br></pre></td></tr></table></figure>



<h3 id="TCP-模式"><a href="#TCP-模式" class="headerlink" title="TCP 模式"></a>TCP 模式</h3><p>启动 TCP 服务器端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iperf -s</span><br></pre></td></tr></table></figure>



<p>启动 TCP 客户端，连接到 192.168.0.1 服务器，进行上传带宽测试，测试时间为 60 秒。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iperf -c 192.168.0.1 -t 60</span><br></pre></td></tr></table></figure>



<p>在 TCP 模式下，进行上下行带宽测试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iperf -c 192.168.0.1 -d -t 60</span><br></pre></td></tr></table></figure>



<p>在 TCP 模式下，客户端同时向服务器端发起 30 个连接线程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iperf -c 192.168.0.1 -P 30 -t 60</span><br></pre></td></tr></table></figure>





<h1 id="Linux-speedtest-命令-网络速度测试工具"><a href="#Linux-speedtest-命令-网络速度测试工具" class="headerlink" title="Linux speedtest 命令 - 网络速度测试工具"></a>Linux speedtest 命令 - 网络速度测试工具</h1><h2 id="介绍-183"><a href="#介绍-183" class="headerlink" title="介绍"></a>介绍</h2><p><strong>speedtest</strong> 是一个测试网络速度的命令行工具，可在本地测量 Internet 连接性能指标，例如下载、上传、延迟和数据包丢失等，无需依赖 Web 浏览器。</p>
<p>speedtest 命令由 <a target="_blank" rel="noopener" href="https://github.com/sivel/speedtest-cli">speedtest-cli</a> 软件包提供，使用 Python 语言编写，因此你可以使用 pip 进行安装，在 Debian&#x2F;Ubuntu 系统上也可以使用 apt 进行安装。</p>
<ul>
<li>Ubuntu</li>
<li>Python</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install speedtest-cli</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">speedtest [OPTION]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>--no-download</code>：不进行下载测试。</li>
<li><code>--no-upload</code>：不执行上传测试。</li>
<li><code>--single</code>：仅使用单个连接而不是多个连接（模拟了典型的文件传输）。</li>
<li><code>--bytes</code>：以字节而不是位显示值。不影响 <code>--share</code> 生成的图像，也不影响 <code>--json</code> 或 <code>--csv</code> 的输出。</li>
<li><code>--share</code>：在 speedtest.net 网站上生成网速测试结果的图片并提供 URL，使用 <code>--csv</code> 选项时不显示。</li>
<li><code>--simple</code>：抑制详细输出，仅显示基本信息。</li>
<li><code>--csv</code>：抑制详细输出，仅以 CSV 格式显示基本信息。速度以位&#x2F;秒为单位列出，不受 <code>--bytes</code> 影响。</li>
<li><code>--csv-delimiter CSV_DELIMITER</code>：在 CSV 输出中使用的单字符分隔符。 默认是逗号 “,”。</li>
<li><code>--csv-header</code>：打印 CSV 标题。</li>
<li><code>--json</code>：抑制详细输出，仅以 JSON 格式显示基本信息。速度以位&#x2F;秒为单位列出，不受 <code>--bytes</code> 影响。</li>
<li><code>--list</code>：根据距离排序显示 speedtest.net 的测试服务器列表。</li>
<li><code>--server SERVER</code>：指定列表中的服务器 ID 作为测试服务器。</li>
<li><code>--exclude EXCLUDE</code>：从选择中排除服务器。</li>
<li><code>--mini MINI</code>：Speedtest Mini 服务器的 URL。</li>
<li><code>--source SOURCE</code>：绑定的源 IP 地址。</li>
<li><code>--timeout TIMEOUT</code>：HTTP 超时（以秒为单位），默认为 10 秒。</li>
<li><code>--secure</code>：与 speedtest.net 运营的服务器通信时，使用 HTTPS 而不是 HTTP。</li>
<li><code>--no-pre-allocate</code>：不要预先分配上传数据，默认情况下启用预分配以提高上传性能。如果要支持内存不足的系统，请使用此选项以避免 MemoryError。</li>
<li><code>--version</code>：显示版本信息并退出。</li>
<li><code>-h, --help</code>：显示帮助信息并退出。</li>
</ul>
<h2 id="示例-184"><a href="#示例-184" class="headerlink" title="示例"></a>示例</h2><p>直接执行 <strong><code>speedtest</code></strong> 命令使用默认参数测试，稍等片刻即可看到结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ speedtest</span><br><span class="line">Retrieving speedtest.net configuration...</span><br><span class="line">Testing from China Telecom (61.144.49.139)...</span><br><span class="line">Retrieving speedtest.net server list...</span><br><span class="line">Selecting best server based on ping...</span><br><span class="line">Hosted by HKBN (Hong Kong) [134.49 km]: 76.016 ms</span><br><span class="line">Testing download speed................................................................................</span><br><span class="line">Download: 11.15 Mbit/s</span><br><span class="line">Testing upload speed......................................................................................................</span><br><span class="line">Upload: 109.55 Mbit/s</span><br></pre></td></tr></table></figure>



<p>列出所有测试服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ speedtest --list</span><br><span class="line">Retrieving speedtest.net configuration...</span><br><span class="line">33250) CTM Broadband (Macau, Macau) [106.48 km]</span><br><span class="line">37639) CMHK Broadband (Hong Kong, Hong Kong) [129.25 km]</span><br><span class="line">28912) fdcservers.net (Hong Kong, Hong Kong) [134.49 km]</span><br><span class="line">59303) HKBN (Hong Kong, Hong Kong) [134.49 km]</span><br><span class="line">60177) Club SIM by HKT (Hong Kong, Hong Kong) [134.49 km]</span><br><span class="line">61296) HKIX (Hong Kong, Hong Kong) [134.49 km]</span><br><span class="line">11711) Taiwan Mobile (Tainan, Taiwan) [709.09 km]</span><br><span class="line">40728) SEEDNET (Tainan, Taiwan) [709.09 km]</span><br><span class="line">32319) TNIC (Tainan, Taiwan) [713.48 km]</span><br><span class="line">18458) Chunghwa Mobile (Kaohsiung, Taiwan) [720.41 km]</span><br></pre></td></tr></table></figure>



<p>指定测试服务器 ID（37639），并生成网速测试结果的图片：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ speedtest-cli --server=37639 --share</span><br><span class="line">Retrieving speedtest.net configuration...</span><br><span class="line">Testing from China Telecom (61.144.49.139)...</span><br><span class="line">Retrieving speedtest.net server list...</span><br><span class="line">Retrieving information <span class="keyword">for</span> the selected server...</span><br><span class="line">Hosted by CMHK Broadband (Hong Kong) [129.25 km]: 308.478 ms</span><br><span class="line">Testing download speed................................................................................</span><br><span class="line">Download: 1.46 Mbit/s</span><br><span class="line">Testing upload speed......................................................................................................</span><br><span class="line">Upload: 2.77 Mbit/s</span><br><span class="line">Share results: http://www.speedtest.net/result/15645788944.png</span><br></pre></td></tr></table></figure>



<p>网速测试结果图片如下：</p>
<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/speedtest-20231218.png" alt="img"></p>
<h1 id="Linux-traceroute-命令-路由追踪显示路径"><a href="#Linux-traceroute-命令-路由追踪显示路径" class="headerlink" title="Linux traceroute 命令 - 路由追踪显示路径"></a>Linux traceroute 命令 - 路由追踪显示路径</h1><h2 id="介绍-184"><a href="#介绍-184" class="headerlink" title="介绍"></a>介绍</h2><p><strong>traceroute</strong> 命令用于跟踪、显示 IP 信息包至某个网络主机的路由。</p>
<p>也就是说，通过 traceroute 命令就可以知道信息（数据包）从你的计算机到互联网另一端的主机是走的什么路径。当然，每次数据包由某一同样的出发点（source）到达某一同样的目的地（destination）走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。</p>
<p>traceroute 的工作原理是通过发送一系列的 ICMP（Internet Control Message Protocol）或 UDP（User Datagram Protocol）数据包，默认发送的数据包大小是40字节，然后观察每个数据包在网络中的传输情况，从而确定路径和测量每一跳的延迟。</p>
<p>一条路径上的每个设备 traceroute 要测 3 次，输出结果中包括每次测试的时间（ms）和设备的名称（如有的话）及其 IP 地址。如果探测的回答来自不同的网关，那么命令会显示各个响应系统的地址。如果在 3 秒的超时时间间隔内没有来自探测的应答，那么将对该探测输出 *（星号）。</p>
<p>注：</p>
<p><strong>traceroute</strong> 命令可以用来做网络测试、测量和管理。它应主要用于手动故障隔离。由于 traceroute 命令增加了网络负载，因此不应该在正常操作期间或从自动化脚本中使用此命令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">traceroute [-46dFITUnreAV] [-f first_ttl] [-g gate,...]</span><br><span class="line">           [-i device] [-m max_ttl] [-p port] [-s src_addr]</span><br><span class="line">           [-q nqueries] [-N squeries] [-t tos]</span><br><span class="line">           [-l flow_label] [-w waittimes] [-z sendwait] [-UL] [-D]</span><br><span class="line">           [-P proto] [--sport=port] [-M method] [-O mod_options]</span><br><span class="line">           [--mtu] [--back]</span><br><span class="line">           host [packet_len]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-m &lt;max_ttl&gt;</code>：设置用于输出探测信息包的最大存活时间（最大的跳跃数）。缺省值为 30 个跳跃（TCP 连接也使用相同的缺省值）。</li>
<li><code>-f &lt;first_ttl&gt;</code>：设置第一个检测数据包的存活数值 TTL 的大小。</li>
<li><code>-g &lt;gate,...&gt;</code>：设置来源路由网关，最多可设置 8 个。</li>
<li><code>-i &lt;device&gt;</code>：使用指定的网络接口送出数据包。</li>
<li><code>-p &lt;port&gt;</code>：设置用于探测的基本 UDP 端口号，缺省值为 33434。</li>
<li><code>-s &lt;src_addr&gt;</code>：设置本地主机送出数据包的 IP 地址。</li>
<li><code>-r</code>：忽略普通的 Routing Table，直接将数据包送到远端主机上。</li>
<li><code>-t &lt;tos&gt;</code>：设置检测数据包的 TOS（服务类型）数值。</li>
<li><code>-w &lt;waittimes&gt;</code>：设置等待远端主机回报的时间。</li>
<li><code>-n</code>：直接使用 IP 地址而非主机名称。</li>
<li><code>-v</code>：详细显示指令的执行过程。</li>
</ul>
<h2 id="示例-185"><a href="#示例-185" class="headerlink" title="示例"></a>示例</h2><p>显示到主机 <strong>getiot.tech</strong> 的路由：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ traceroute -i eth0 -m 10 getiot.tech</span><br><span class="line">traceroute to getiot.tech (42.192.64.149), 10 hops max, 60 byte packets</span><br><span class="line"> 1  _gateway (192.168.1.1)  11.565 ms  11.502 ms  11.487 ms</span><br><span class="line"> 2  172.16.0.1 (172.16.0.1)  17.092 ms  17.371 ms  17.357 ms</span><br><span class="line"> 3  221.179.83.37 (221.179.83.37)  18.690 ms *  18.954 ms</span><br><span class="line"> 4  120.196.243.21 (120.196.243.21)  20.673 ms 120.196.243.1 (120.196.243.1)  20.989 ms 120.196.243.21 (120.196.243.21)  19.925 ms</span><br><span class="line"> 5  120.196.199.130 (120.196.199.130)  24.335 ms 120.196.199.114 (120.196.199.114)  24.569 ms 120.196.199.122 (120.196.199.122)  23.758 ms</span><br><span class="line"> 6  120.241.50.2 (120.241.50.2)  24.762 ms 120.241.50.6 (120.241.50.6)  13.892 ms  12.839 ms</span><br><span class="line"> 7  * * *</span><br><span class="line"> 8  * * *</span><br><span class="line"> 9  * * *</span><br><span class="line">10  * * *</span><br></pre></td></tr></table></figure>





<h1 id="Linux-trippy-命令-网络调试分析工具"><a href="#Linux-trippy-命令-网络调试分析工具" class="headerlink" title="Linux trippy 命令 - 网络调试分析工具"></a>Linux trippy 命令 - 网络调试分析工具</h1><h2 id="介绍-185"><a href="#介绍-185" class="headerlink" title="介绍"></a>介绍</h2><p><strong>trippy</strong> 是一个命令行工具（别名 <strong>trip</strong>），支持 Linux、Windows、macOS 等平台，可以代替 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/traceroute/">traceroute</a> 查看互联网通信的路径，分析网络状况。</p>
<p>trippy 使用 Rust 语言实现，使用前需要安装，安装方法如下：</p>
<ul>
<li>Cargo</li>
<li>Snap</li>
<li>Homebrew</li>
<li>WinGet</li>
<li>Scoop</li>
<li>Pacman</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo install trippy</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trip [OPTIONS] [TARGETS]...</span><br></pre></td></tr></table></figure>



<p>注：trip 是 trippy 的软链接，因此可以用 trip 代替 trippy。</p>
<h2 id="示例-186"><a href="#示例-186" class="headerlink" title="示例"></a>示例</h2><p>具有默认参数的基本用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trip example.com</span><br></pre></td></tr></table></figure>



<p>注意：在 Linux 运行需要使用 sudo 提权。输出结果如下：</p>
<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/trippy-getiot-20231217.png" alt="img"></p>
<p>不需要提升特权的跟踪：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trip example.com --unprivileged</span><br></pre></td></tr></table></figure>



<p>使用 udp（或 tcp 或 icmp）协议：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trip example.com -p udp</span><br></pre></td></tr></table></figure>



<p>指定追踪的最低轮转时间为 250 毫秒，宽限期为 50 毫秒：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trip example.com -i 250ms -g 50ms</span><br></pre></td></tr></table></figure>



<p>使用自定义的第一个 TTL 和最大 TTL 值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trip example.com --first-ttl 2 --max-ttl 10</span><br></pre></td></tr></table></figure>



<p>使用自定义目标端口443进行 tcp 跟踪：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trip example.com -p tcp -P 443</span><br></pre></td></tr></table></figure>



<p>使用自定义源端口 5000 跟踪 udp：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trip example.com -p udp -S 5000</span><br></pre></td></tr></table></figure>





<h1 id="Linux-mtr-命令-网络诊断路由跟踪"><a href="#Linux-mtr-命令-网络诊断路由跟踪" class="headerlink" title="Linux mtr 命令 - 网络诊断路由跟踪"></a>Linux mtr 命令 - 网络诊断路由跟踪</h1><h2 id="介绍-186"><a href="#介绍-186" class="headerlink" title="介绍"></a>介绍</h2><p><strong>mtr</strong>（英文全拼：my traceroute）是一个用于网络诊断和网络性能测量的命令行工具，它在单个网络诊断工具中结合了 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/traceroute/">traceroute</a> 和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/ping/">ping</a> 程序的功能，提供了更全面的网络路径跟踪和性能统计。</p>
<p><code>mtr</code> 命令的主要应用场景包括：</p>
<ul>
<li>在网络上跟踪数据包的路径，类似于 <code>traceroute</code>。</li>
<li>连续地测量目标主机的网络性能，类似于 <code>ping</code>。</li>
<li>提供目标主机到每个中间节点的网络延迟、丢包率等信息。</li>
</ul>
<p>当 mtr 启动时，它会通过发送故意设置低 TTL 的数据包来调查运行 mtr 的主机与 HOSTNAME 之间的网络连接。它继续发送低 TTL 的数据包，并记录中间路由器的响应时间。这允许 mtr 打印到 HOSTNAME 的互联网路由的响应百分比和响应时间。数据包丢失或响应时间突然增加通常表明链接不良（或只是过载）。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mtr [options] HOSTNAME</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-r</code>：已报告模式显示。</li>
<li><code>-c</code>：发送多少个数据包。</li>
<li><code>-n</code>：不用主机解释。</li>
<li><code>--report</code>：结果显示，并不动态显示。</li>
<li><code>-s</code>：用来指定 ping 数据包的大小。</li>
</ul>
<h2 id="示例-187"><a href="#示例-187" class="headerlink" title="示例"></a>示例</h2><p>使用报告模式显示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mtr -r getiot.tech</span><br></pre></td></tr></table></figure>



<p>设置每秒发送数据包数量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mtr -r -c 30 getiot.tech</span><br></pre></td></tr></table></figure>



<p>数指定 ping 数据包的大小：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mtr -r -c 30 -s getiot.tech</span><br></pre></td></tr></table></figure>





<h1 id="Linux-nload-命令-实时监控网络流量"><a href="#Linux-nload-命令-实时监控网络流量" class="headerlink" title="Linux nload 命令 - 实时监控网络流量"></a>Linux nload 命令 - 实时监控网络流量</h1><h2 id="介绍-187"><a href="#介绍-187" class="headerlink" title="介绍"></a>介绍</h2><p><strong>nload</strong> 是一个用于监测网络流量的命令行工具，它以图形化的方式显示实时的网络使用情况。使用该命令，可在命令行界面通过图形化方式实时显示网络流量，包括上传和下载速率、总流量等数据。</p>
<p>使用前请确保你的系统上已经安装 nload 工具，在 Debian&#x2F;Ubuntu 系统上可使用如下命令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install nload</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nload [options] [devices]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><p><code>-a</code>：这个好像是全部数据的刷新时间周期，单位是秒，默认是 300。</p>
</li>
<li><p><code>-i &lt;网络接口&gt;</code>：进入网卡的流量图的显示比例最大值设置，默认 10240 kBit&#x2F;s。</p>
</li>
<li><p><code>-m</code>：不显示流量图，只显示统计数据。</p>
</li>
<li><p><code>-o</code>：出去网卡的流量图的显示比例最大值设置，默认 10240 kBit&#x2F;s。</p>
</li>
<li><p><code>-t &lt;刷新时间&gt;</code>：显示数据的刷新时间间隔，单位是毫秒，默认 500。</p>
</li>
<li><p><code>-K &lt;速率因子&gt;</code>： 设置速率的因子，用于调整显示的速率。</p>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-u &lt;速率单位&gt;</span><br></pre></td></tr></table></figure>

<p>：设置右边 Curr、Avg、Min、Max 的数据单位，默认是自动变的。注意大小写单位不同！</p>
<ul>
<li><code>h|b|k|m|g</code> —— h: auto，b: Bit&#x2F;s，k: kBit&#x2F;s，m: MBit&#x2F;s 等；</li>
<li><code>H|B|K|M|G</code> —— H: auto，B: Byte&#x2F;s，K: kByte&#x2F;s，M: MByte&#x2F;s 等。</li>
</ul>
</li>
<li><p><code>-U</code>：设置右边 TTL 的数据单位，默认是自动变的。注意大小写单位不同（与 <code>-u</code> 相同）！</p>
</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li><code>devices</code>：自定义监控的网卡，默认是全部监控的，使用左右键切换。</li>
</ul>
<h2 id="示例-188"><a href="#示例-188" class="headerlink" title="示例"></a>示例</h2><p>实时监测默认网络接口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nload</span><br></pre></td></tr></table></figure>



<p>注意：默认情况下，<code>nload</code> 会实时监测第一个找到的网络接口的上传和下载速率。</p>
<p>监测指定的网络接口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nload -i eth0</span><br></pre></td></tr></table></figure>



<p>设置速率的显示单位（以 <code>Kbps</code> 为单位）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nload -u Kbps</span><br></pre></td></tr></table></figure>



<p>调整速率的因子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nload -K 1024</span><br></pre></td></tr></table></figure>



<p>设置每隔2秒更新一次显示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nload -t 2</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ifstat-命令-网络接口流量监控"><a href="#Linux-ifstat-命令-网络接口流量监控" class="headerlink" title="Linux ifstat 命令 - 网络接口流量监控"></a>Linux ifstat 命令 - 网络接口流量监控</h1><h2 id="介绍-188"><a href="#介绍-188" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ifstat</strong>（英文全拼：network interfaces status）是一个统计网络接口活动状态的工具。</p>
<p>通常 ifstat 工具系统中并不默认安装，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install ifstat</span><br></pre></td></tr></table></figure>



<p>类似命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/iostat/">iostat</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/vmstat/">vmstat</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifstat [选项]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-l</code> ：监测环路网络接口（lo）。缺省情况下，ifstat 监测活动的所有非环路网络接口。</li>
<li><code>-a</code> ：监测能检测到的所有网络接口的状态信息。</li>
<li><code>-z</code> ：隐藏流量是无的接口，例如那些接口虽然启动了但是未用的。</li>
<li><code>-i</code> ：指定要监测的接口。</li>
<li><code>-s</code> ：等于加 <code>-d snmp:[comm@][#]host[/nn]]</code> 参数，通过 SNMP 查询一个远程主机。</li>
<li><code>-d</code> ：指定一个驱动来收集状态信息。</li>
<li><code>-n</code> ：关闭显示周期性出现的头部信息。</li>
<li><code>-t</code> ：在每一行的开头加一个时间戳。</li>
<li><code>-T</code> ：报告所有监测接口的全部带宽。</li>
<li><code>-w</code> ：用指定的列宽，而不是为了适应接口名称的长度而去自动放大列宽。</li>
<li><code>-W</code> ：如果内容比终端窗口的宽度还要宽就自动换行。</li>
<li><code>-S</code> ：在同一行保持状态更新（不滚动不换行）注：如果不喜欢屏幕滚动则此项非常方便，与 bmon 的显示方式类似。</li>
<li><code>-b</code> ：用 kbits&#x2F;s 显示带宽而不是 kbytes&#x2F;s。</li>
<li><code>-q</code> ：安静模式，不打印警告信息。</li>
<li><code>-h</code> ：显示帮助信息。</li>
<li><code>-v</code> ：显示版本信息。</li>
</ul>
<h2 id="示例-189"><a href="#示例-189" class="headerlink" title="示例"></a>示例</h2><p>监测所有网络接口的全部带宽，并添加时间戳</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ifstat -tT</span><br><span class="line">  Time         enp0s25              Total</span><br><span class="line">HH:MM:SS   KB/s <span class="keyword">in</span>  KB/s out   KB/s <span class="keyword">in</span>  KB/s out</span><br><span class="line">13:09:19     16.72      8.26     16.72      8.26</span><br><span class="line">13:09:20     38.55     15.45     38.55     15.45</span><br><span class="line">13:09:21     72.30     16.30     72.30     16.30</span><br><span class="line">13:09:22     23.47      3.16     23.47      3.16</span><br><span class="line">13:09:23      1.09      0.20      1.09      0.20</span><br><span class="line">13:09:24      0.62      0.12      0.62      0.12</span><br></pre></td></tr></table></figure>





<h1 id="Linux-iftop-命令-实时流量监控工具"><a href="#Linux-iftop-命令-实时流量监控工具" class="headerlink" title="Linux iftop 命令 - 实时流量监控工具"></a>Linux iftop 命令 - 实时流量监控工具</h1><h2 id="介绍-189"><a href="#介绍-189" class="headerlink" title="介绍"></a>介绍</h2><p><strong>iftop</strong> 是一个能够提供网络带宽实时监控的工具（类似于 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/top/">top</a> 命令实时监测进程状态）。</p>
<p>iftop 通过测量每个连接进入和进出的数据包的大小从而达到监控网络的目的。即它通过捕获网卡进入和进出的流量，然后对其求和从而得到正确的网络带宽数据。iftop 必须使用超级管理员权限运行，因为需要监控所有网络流量。如果没有指定接口，iftop 将监听在外部接口（使用 libcap 和 libncurses）的第一个接口上。</p>
<p>通常，iftop 工具系统中并不默认安装，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install iftop</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iftop [选项]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-i &lt;interface&gt;</code> ：设定监测的网卡。</li>
<li><code>-B</code> ：以 bytes&#x2F;sec 为单位显示流量（默认是 bits&#x2F;sec）。</li>
<li><code>-n</code> ：使 host 信息默认直接都显示 IP 地址。</li>
<li><code>-N</code> ：使端口信息默认直接都显示端口号。</li>
<li><code>-F &lt;net/mask&gt;</code> ：显示特定网段的进出流量。</li>
<li><code>-p</code> ：以混杂模式运行。</li>
<li><code>-P</code> ：启用端口显示。</li>
<li><code>-b</code> ：不以流量图形条显示。</li>
<li><code>-f &lt;filter&gt; &lt;code&gt;</code> ：过滤 IP 包。</li>
<li><code>-m &lt;limit&gt;</code> ：设置界面最上边的刻度的最大值（刻度分五个大段显示）。</li>
<li><code>-h</code> ：显示帮助信息。</li>
</ul>
<h2 id="示例-190"><a href="#示例-190" class="headerlink" title="示例"></a>示例</h2><p>不带任何选项，直接运行 iftop</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> iftop</span><br></pre></td></tr></table></figure>



<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/iftop_snapshot.png" alt="img"></p>
<p>窗口说明：</p>
<ul>
<li>默认使用第一个网络接口（比如 eth0）；</li>
<li>默认显示 rates 的三列数据分别表示：最近2秒、10秒和40秒的平均流量；</li>
<li>peak 指网络速率的尖峰值（最大）；</li>
<li>cum 表示累积流量 cumulative，在交互界面时按下 <code>T</code> 键就可以看到“主机对”之间累计的网络数据流量。</li>
</ul>
<p>网络监测时不进行 DNS 反解析，直接显示 IP，从而可以节省一定的带宽</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> iftop -n</span><br></pre></td></tr></table></figure>



<p>监测指定网卡</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> iftop -i eth0</span><br></pre></td></tr></table></figure>



<p>设置显示刻度最大值为 100M</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> iftop -m 100M</span><br></pre></td></tr></table></figure>



<p>显示特定网段的进出流量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> iftop -F 10.10.1.0/24</span><br><span class="line">$ <span class="built_in">sudo</span> iftop -F 10.10.1.0/255.255.255.0</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ntop-命令-网络流量分析工具"><a href="#Linux-ntop-命令-网络流量分析工具" class="headerlink" title="Linux ntop 命令 - 网络流量分析工具"></a>Linux ntop 命令 - 网络流量分析工具</h1><h2 id="介绍-190"><a href="#介绍-190" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ntop</strong> 是一个网络流量监控工具，用于实时显示网络流量和连接信息。它提供了一个基于 Web 的用户界面，可以通过浏览器查看网络统计数据。</p>
<p>提示</p>
<p>ntop 目前已被 <strong><a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/ntopng/">ntopng</a></strong> 取代，可在其官网 <a target="_blank" rel="noopener" href="https://www.ntop.org/">https://www.ntop.org</a> 了解更多信息。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ntop [options]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-h &lt;主机&gt;</code>： 指定 <code>ntop</code> 监听的主机地址。</li>
<li><code>-p &lt;端口&gt;</code>： 指定 <code>ntop</code> 使用的端口号。</li>
<li><code>-u &lt;用户名&gt;</code>： 指定 Web 界面的用户名。</li>
<li><code>-P &lt;密码&gt;</code>： 指定 Web 界面的密码。</li>
<li><code>-i &lt;网络接口&gt;</code>： 指定要监控的网络接口。</li>
</ul>
<h2 id="示例-191"><a href="#示例-191" class="headerlink" title="示例"></a>示例</h2><p>启动 ntop 监听默认端口（3000），启动后可通过 <a target="_blank" rel="noopener" href="http://localhost:3000/">http://localhost:3000</a> 访问 Web 界面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ntop</span><br></pre></td></tr></table></figure>



<p>指定监听的主机和端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ntop -h 192.168.1.2 -p 8080</span><br></pre></td></tr></table></figure>



<p>启动 ntop 并设置 Web 界面的用户名和密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ntop -u myuser -P mypassword</span><br></pre></td></tr></table></figure>



<p>指定要监控的网络接口（例如 <code>eth0</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ntop -i eth0</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ntopng-命令-网络流量监控分析"><a href="#Linux-ntopng-命令-网络流量监控分析" class="headerlink" title="Linux ntopng 命令 - 网络流量监控分析"></a>Linux ntopng 命令 - 网络流量监控分析</h1><h2 id="介绍-191"><a href="#介绍-191" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ntopng</strong> 是 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/ntop/">ntop</a> 的下一代版本，它是一个用于监控网络流量的工具。相较于 ntop，ntopng 提供了一个更现代化和交互式的 Web 界面，以及支持更多的功能和详细的统计信息，包括网络流量、协议使用情况、主机信息等。</p>
<p>使用前请确保你的系统上已经安装 ntopng 工具，在 Debian&#x2F;Ubuntu 系统上可通过 apt 进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install ntopng</span><br></pre></td></tr></table></figure>



<p>ntopng 是一个开源软件，你可以在 <a target="_blank" rel="noopener" href="https://github.com/ntop/ntopng">GitHub</a> 找到它。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ntopng [filename]</span><br><span class="line">ntopng [options]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><p><code>-n, --dns-mode &lt;mode&gt;</code>：设置 DNS 地址解析模式。</p>
</li>
<li><p><code>-i, --interface &lt;interface|pcap&gt;</code>：设置输入接口名称（通过数字或符号）、视图或 pcap 文件路径。</p>
</li>
<li><p><code>-d, --data-dir &lt;path&gt;</code>：指定数据目录（该目录必须是可写的），默认为 &#x2F;var&#x2F;lib&#x2F;ntopng。</p>
</li>
<li><p><code>-t, --install-dir &lt;path&gt;</code>：指定安装目录，应在自定义目录下安装 ntopng 时需要设置。</p>
</li>
<li><p><code>-e, --daemon</code>：以守护进程方式运行。</p>
</li>
<li><p><code>-1, --httpdocs-dir &lt;path&gt;</code>：HTTP 文件根目录，默认为 httpdocs。</p>
</li>
<li><p><code>-2, --scripts-dir &lt;path&gt;</code>：脚本目录，默认为 scripts。</p>
</li>
<li><p><code>-3, --callbacks-dir &lt;path&gt;</code>：回调目录，默认为 scripts&#x2F;callbacks。</p>
</li>
<li><p><code>-4, --prefs-dir &lt;path&gt;</code>：用于序列化和反序列化包含运行时首选项的文件的 Preferences 目录，默认为 &#x2F;var&#x2F;lib&#x2F;ntopng。</p>
</li>
<li><p><code>-5, --pcap-dir &lt;path&gt;</code>：用于以 PCAP 格式进行连续流量记录的存储目录，默认为 &#x2F;var&#x2F;lib&#x2F;ntopng。</p>
</li>
<li><p><code>-u, --no-promisc</code>：不要将接口设置为混杂模式。</p>
</li>
<li><p><code>-w, --http-port &lt;[addr:]port&gt;</code>：设置 HTTP 服务地址和端口，设置为 0 表示禁用 http 服务器。地址可以是 IPv4（例如 192.168.1.1）或 IPv6（例如 <code>[3ffe:2a00:100:7031::1]</code>）。注意，需要用方括号将 IPv6 地址括起来。然后在环回地址上的侦听端口之前添加一个不带 addr 的 <code>:</code>，默认端口为 3000。</p>
<p>例如，下面几种表示方法都是合法的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-w :3000</span><br><span class="line">-w 192.168.1.1:3001</span><br><span class="line">-w [3ffe:2a00:100:7031::1]:3002</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>-W, --https-port &lt;[:]https_port&gt;</code>：设置 HTTPS 端口，类似于 <code>-w</code> 选项。</p>
</li>
<li><p><code>-m, --local-networks &lt;local nets&gt;</code>：本地网络列表，默认为 192.168.1.0&#x2F;24。</p>
</li>
<li><p><code>-p, --ndpi-protocols &lt;file&gt;.protos</code>：指定 nDPI 协议文件，例如 protos.txt。</p>
</li>
<li><p><code>-r, --redis &lt;fmt&gt;</code>：连接 Redis 数据库，<code>&lt;fmt&gt;</code> 格式为 <code>[h[:port[:pwd]]][@db-id]</code>。其中 <code>h</code> 表示主机地址，<code>port</code> 表示端口号（默认为 6379），<code>pwd</code> 表示登录密码，<code>db-id</code> 表示数据库 ID（默认为 0）。另外，在 Linux 系统中，<code>&lt;fmt&gt;</code> 还可以是 Redis 的 socket 文件路径。</p>
<p>例如，下面几种表示方法都是合法的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-r @2</span><br><span class="line">-r 129.168.1.3</span><br><span class="line">-r 129.168.1.3:6379@3</span><br><span class="line">-r 129.168.1.3:6379:nt0pngPwD@0</span><br><span class="line">-r /var/run/redis/redis.sock</span><br><span class="line">-r /var/run/redis/redis.sock@2</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>-g, --core-affinity &lt;cpu core ids&gt;</code>：将捕获&#x2F;处理线程绑定到特定的 CPU 核心（指定为逗号分隔列表）。</p>
</li>
<li><p><code>-U, --user &lt;sys user&gt;</code>：使用指定用户（而不是 ntopng 用户）运行 <code>ntopng</code>。</p>
</li>
<li><p><code>-N, --instance-name &lt;name&gt;</code>：为该 ntopng 实例分配一个名称。</p>
</li>
<li><p><code>-v, --verbose &lt;level&gt;</code>：详细信息等级 <code>[0 (min).. 6 (debug)]</code>。</p>
</li>
<li><p><code>-V, --version</code>：显示版本信息。</p>
</li>
<li><p><code>--print-ndpi-protocols</code>：打印 nDPI 协议列表。</p>
</li>
<li><p><code>--ignore-vlans</code>：忽略流量中的 VLAN 标记。</p>
</li>
<li><p><code>--simulate-vlans</code>：模拟 VLAN 流量（仅限调试）。</p>
</li>
<li><p><code>-h, --help</code>：显示帮助信息。</p>
</li>
</ul>
<h2 id="示例-192"><a href="#示例-192" class="headerlink" title="示例"></a>示例</h2><p>以默认方式启动 ntopng：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ntopng</span><br></pre></td></tr></table></figure>



<p>启动后可通过 <a target="_blank" rel="noopener" href="http://localhost:3000/">http://localhost:3000</a> 访问 Web 界面：</p>
<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/ntopng-web.png" alt="img"></p>
<p>指定端口启动 ntopng：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ntopng -w 3001</span><br></pre></td></tr></table></figure>



<p>执行 <code>ntopng -h</code> 会在末尾列出接口设备及编号，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ntopng -h</span><br><span class="line">...</span><br><span class="line">Available interfaces (-i &lt;interface index&gt;):</span><br><span class="line">   1. wlp0s20f3</span><br><span class="line">   2. lo</span><br><span class="line">   3. any</span><br><span class="line">   4. enp44s0</span><br><span class="line">   5. docker0</span><br><span class="line">   6. bluetooth-monitor</span><br><span class="line">   7. nflog</span><br><span class="line">   8. nfqueue</span><br><span class="line">   9. bluetooth0</span><br></pre></td></tr></table></figure>



<p>只监控第一个网卡设备的流量（即 wlp0s20f3）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ntopng -i 1</span><br></pre></td></tr></table></figure>



<p>以 pcap 文件作为输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ntopng -i traffic.pcap</span><br></pre></td></tr></table></figure>



<p>或者通过管道输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/traffic.pcap | <span class="built_in">sudo</span> ntopng -i -</span><br></pre></td></tr></table></figure>





<h1 id="Linux-nmap-命令-网络扫描探测工具"><a href="#Linux-nmap-命令-网络扫描探测工具" class="headerlink" title="Linux nmap 命令 - 网络扫描探测工具"></a>Linux nmap 命令 - 网络扫描探测工具</h1><h2 id="介绍-192"><a href="#介绍-192" class="headerlink" title="介绍"></a>介绍</h2><p><strong>nmap</strong>（英文全拼：Network Mapper）是一个开源的网络探测工具和安全&#x2F;端口扫描器，由 Fyodor 编写并维护。它的设计目标是快速地扫描大型网络，当然用它扫描单个主机也没有问题。由于品质卓越、使用灵活，nmap 已经成为渗透测试人员必备的工具之一。</p>
<p>在实现原理方面，nmap 以新颖的方式使用原始 IP 报文来发现网络上有哪些主机，这些主机提供什么服务（应用程序名和版本），这些服务运行在什么操作系统（包括版本信息），它们使用什么类型的报文过滤器&#x2F;防火墙，以及一堆其它功能。</p>
<p>虽然 nmap 通常用于安全审核，但许多系统管理员和网络管理员也用它来做一些日常的工作，比如查看整个网络的信息、管理服务升级计划，以及监视主机和服务的运行。</p>
<p>nmap 输出的是扫描目标的列表（端口号、协议、服务名称和状态。），以及每个目标的补充信息，至于是哪些信息则依赖于所使用的选项。其中，状态可能是 open、filtered、closed 或者 unfiltered 中的一种或两种组合。</p>
<ul>
<li>open（开放的）意味着目标机器上的应用程序正在该端口监听连接&#x2F;报文。</li>
<li>filtered（被过滤的）意味着防火墙、过滤器或者其它网络障碍阻止了该端口被访问，nmap 无法得知它是 open 还是 closed 的。</li>
<li>closed（关闭的）端口没有应用程序在它上面监听，但是他们随时可能开放。</li>
<li>当端口对 nmap 的探测做出响应，但是 nmap 无法确定它们是关闭还是开放时，这些端口就被认为是 unfiltered（未被过滤的）。</li>
</ul>
<p>如果 nmap 报告状态组合 open|filtered 和 closed|filtered 时，那说明 nmap 无法确定该端口处于两个状态中的哪一个状态。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap [Scan Type(s)] [Options] &#123;target specification&#125;</span><br><span class="line">nmap [扫描类型...] [选项] &#123;扫描目标说明&#125;</span><br></pre></td></tr></table></figure>



<p>其中 Target（扫描目标）可以传入主机名称、IP 地址或网络。</p>
<p><strong>选项</strong>：</p>
<ul>
<li><code>-sS</code>：TCP SYN 扫描（又称半开放或隐身扫描）。</li>
<li><code>-P0</code>：允许你关闭 ICMP pings。</li>
<li><code>-sV</code>：打开系统版本检测。</li>
<li><code>-O</code>：尝试识别远程操作系统。</li>
<li><code>-A</code>：同时打开操作系统指纹和版本检测。</li>
<li><code>-v</code>：详细输出扫描情况。</li>
</ul>
<h2 id="示例-193"><a href="#示例-193" class="headerlink" title="示例"></a>示例</h2><p>扫描出指定 IP（域名）其对外开放的服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmap getiot.tech</span><br><span class="line">Starting Nmap 7.80 ( https://nmap.org ) at 2022-10-30 23:13 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> getiot.tech (42.192.64.149)</span><br><span class="line">Host is up (0.058s latency).</span><br><span class="line">Not shown: 997 filtered ports</span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">80/tcp  open  http</span><br><span class="line">443/tcp open  https</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 1 IP address (1 host up) scanned <span class="keyword">in</span> 6.72 seconds</span><br></pre></td></tr></table></figure>



<p>判断目标 IP（域名）是否开放指定端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -p 80 getiot.tech</span><br></pre></td></tr></table></figure>



<p>扫描指定网络中的所有在线主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sP 192.168.3.*</span><br><span class="line">nmap -sP 192.168.3.0/24</span><br></pre></td></tr></table></figure>



<p>扫描指定网络中的所有在线主机的指定端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -p 22,80,443 192.168.3.0/24</span><br></pre></td></tr></table></figure>



<p>扫描指定网段中在线主机的指定端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -p 22,80,443 192.168.3.30-100</span><br></pre></td></tr></table></figure>



<p>扫描指定网段，但是排除某个 IP 地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap 192.168.3.30-100 --exclude 192.168.3.30.66</span><br></pre></td></tr></table></figure>



<p>扫描多个地址时排除文件里的 IP 地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ex.txt </span><br><span class="line">192.168.3.30.66</span><br><span class="line">192.168.3.30.88</span><br><span class="line"></span><br><span class="line">nmap 172.17.120.11-14 --excludefile ex.txt</span><br></pre></td></tr></table></figure>



<p>在某段子网上查找未占用的 IP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -T4 -sP 192.168.3.0/24 &amp;&amp; egrep “00:00:00:00:00:00″ /proc/net/arp</span><br></pre></td></tr></table></figure>



<p>服务版本识别（-sV），nmap 可以在进行端口扫描的时候检测服务端软件的版本信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sV 192.168.3.66 -p 80</span><br></pre></td></tr></table></figure>



<p>操作系统检测（-O），nmap 还能识别目标主机的操作系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -O 192.168.3.66</span><br></pre></td></tr></table></figure>



<p>找到目标主机开放了哪些 UDP 端口。为提高扫描速度，我们仅扫描 53 端口（DNS）和 161 端口（SNMP）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sU 192.168.3.66 -p 53,161</span><br></pre></td></tr></table></figure>



<p>启用 nmap 的 -6 选项即可扫描 IPv6 的目标主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -6 fe80::a00:27ff:fe43:1518</span><br></pre></td></tr></table></figure>



<p>在局域网上扫找 Conficker 蠕虫病毒</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -PN -T4 -p139,445 -n -v –script=smb-check-vulns –script-args safe=1 192.168.3.1-254</span><br></pre></td></tr></table></figure>



<p>扫描网络上的恶意接入点（rogue APs）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -A -p1-85,113,443,8080-8100 -T4 –min-hostgroup 50 –max-rtt-timeout 2000 –initial-rtt <span class="built_in">timeout</span> 300 –max-retries 3 –host-timeout 20m –max-scan-delay 1000 -oA wapscan 192.168.3.0/24</span><br></pre></td></tr></table></figure>



<p>使用诱饵扫描方法来扫描主机端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sS 192.168.3.12 -D 192.168.3.20</span><br></pre></td></tr></table></figure>



<p>显示网络上共有多少台 Linux 及 Win 设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -F -O 192.168.3.0-255 | grep <span class="string">&quot;Running: &quot;</span> &gt; /tmp/os; <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(cat /tmp/os | grep Linux \| wc -l)</span> Linux device(s)&quot;</span>; <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(cat /tmp/os | grep Windows | wc -l)</span> Window(s) device&quot;</span></span><br></pre></td></tr></table></figure>





<h1 id="Linux-netcat-命令-多功能网络工具"><a href="#Linux-netcat-命令-多功能网络工具" class="headerlink" title="Linux netcat 命令 - 多功能网络工具"></a>Linux netcat 命令 - 多功能网络工具</h1><h2 id="介绍-193"><a href="#介绍-193" class="headerlink" title="介绍"></a>介绍</h2><p><strong><code>netcat</code></strong>（别名：<strong><code>nc</code></strong>）是 Linux 下的一个多功能的网络工具，可用于与 TCP 或 UDP 相关的各种任务，例如创建连接和侦听、执行端口扫描，以及处理 IPv4 和 IPv6 等。与 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/telnet/">telnet</a> 不同，netcat 可以精细地编写脚本，并将错误消息分隔到标准错误中，而不是将错误消息发送到标准输出。</p>
<p>netcat 命令通常用于以下任务：</p>
<ul>
<li>简单 TCP 代理</li>
<li>基于 HTTP 客户机和服务器的 shell 脚本</li>
<li>网络守护进程测试</li>
<li>适用于 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/ssh/">ssh</a> 的 SOCKS 或 HTTP <code>ProxyCommand</code></li>
</ul>
<p>netcat&#x2F;nc 命令由 netcat 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install netcat</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc [-46bCDdFhklNnrStUuvZz] [-I length] [-i interval] [-M ttl] [-m minttl] [-O length] [-P proxy_username]</span><br><span class="line">        [-p source_port] [-q seconds] [-s <span class="built_in">source</span>] [-T keyword] [-V rtable] [-W recvlimit] [-w <span class="built_in">timeout</span>] [-X proxy_protocol]</span><br><span class="line">        [-x proxy_address[:port]] [destination] [port]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-4</code>：强制 <code>nc</code> 仅使用 IPv4 地址。</li>
<li><code>-6</code>：强制 <code>nc</code> 仅使用 IPv6 地址。</li>
<li><code>-b bufsize</code>：为读取操作指定缓冲区大小。缺省值为 <code>1024</code> 字节。</li>
<li><code>-D</code>：启用对套接字的调试。</li>
<li><code>-d</code>：不尝试从 <code>stdin</code> 进行读取。</li>
<li><code>-E</code>：使用独占绑定来侦听 TCP 或 UDP 套接字。在没有 <code>-l</code> 选项的情况下单独使用此选项是错误的。此选项与 <code>-U</code> 选项结合使用时，不会产生任何影响。</li>
<li><code>-e program</code>：接受连接或建立连接之后执行外部程序。在执行之前，<code>stdin</code>, <code>stdout</code>, <code>stderr</code> 会重定向到网络描述符。仅有一个端口可供该选项使用。此选项与 <code>-R</code>、<code>-k</code> 或 <code>-i</code> 选项结合使用是错误的。</li>
<li><code>-F</code>：在 <code>stdin</code> 上看到 <code>EOF</code> 后，不要关闭网络套接字以进行写入。</li>
<li><code>-h</code>：输出 <code>nc</code> 帮助。</li>
<li><code>-I bufsize</code>：设置接收（输入）套接字缓冲区大小。此选项与 <code>-U</code> 选项结合使用时，不会产生任何影响。</li>
<li><code>-i interval</code>：指定发送和接收的文本行之间的延迟时间 interval。以秒为单位指定时间间隔，可能包含小数。此选项还会导致与多个端口的连接之间产生延迟时间，因而也会影响端口扫描模式。</li>
<li><code>-k</code>：强制 <code>nc</code> 在其当前连接关闭后侦听另一连接。在没有 <code>-l</code> 选项的情况下单独使用此选项是错误的。此选项与 <code>-e</code> 选项结合使用是错误的。</li>
<li><code>-L timeout</code>：在关闭时逗留（Linger on close）－在网络描述符关闭后直到指定的超时时间（以秒为单位），等待消息发送。</li>
<li><code>-l</code>：侦听传入连接，而不是启动到远程主机的连接。此选项与 <code>-s</code> 或 <code>-z</code> 选项结合使用是错误的。如果 <code>-l</code> 选项与通配符套接字（未指定任何 IP 地址或主机名）一起使用，但不与 <code>-4/-6</code> 选项一起使用，则既可接受 IPv4 连接也可接受 IPv6 连接。</li>
<li><code>-m byte_count</code>：接收至少 <code>byte_count</code> 字节后退出。当与 <code>-l</code> 选项结合使用时，<code>byte_count</code> 会与从客户机接收的字节数进行比较。<code>byte_count</code> 必须大于 <code>0</code>，而小于 <code>INT_MAX</code>。</li>
<li><code>-N file</code>：在 UDP 端口扫描模式下指定文件。此文件的内容用作每个发出的 UDP 包的有效载荷。在没有 <code>-u</code> 和 <code>-z</code> 选项的情况下单独使用此选项是错误的。</li>
<li><code>-n</code>：不对任何地址、主机名或端口执行任何命名或服务查找操作。使用此选项意味着 hostname 和 port 参数被限制为数字值。除了对参数施加限制外，与 <code>-v</code> 选项一起使用时，所有地址和端口都将以数字形式输出。此选项与 <code>-U</code> 选项结合使用时，不会产生任何影响。</li>
<li><code>-O bufsize</code>：设置发送（输出）套接字缓冲区大小。此选项与 <code>-U</code> 选项结合使用时，不会产生任何影响。</li>
<li><code>-P proxy_username</code>：指定提供给要求验证的代理服务器的一个用户名（proxy_username）。如果未指定 proxy_username，则不会尝试进行验证。目前仅 <code>HTTP CONNECT</code> 代理支持代理验证。此选项与 <code>-l</code> 选项结合使用是错误的。</li>
<li><code>-p port</code>：未与 <code>-l</code> 选项结合使用时，根据特权限制和可用性指定 <code>nc</code> 应使用的源端口。与 <code>-l</code> 选项结合使用时，设置侦听端口。仅当未指定全局端口参数时，此选项可与 <code>-l</code> 选项结合使用。</li>
<li><code>-q timeout</code>：在 <code>stdin</code> 上接收到 <code>EOF</code> 后，等待指定的秒数，然后退出。</li>
<li><code>-R addr/port[/proto]</code>：对指定的 host 和 port 执行端口重定向。接受连接后，<code>nc</code> 会连接到远程 host&#x2F;port，并在客户机与远程主机之间传递所有数据。重定向规范的 proto（协议）部分可以是 <code>tcp</code> 或 <code>udp</code>。如果未指定 proto，<code>redirector</code> 将使用与服务器相同的协议。此选项与 <code>-z</code> 选项结合使用是错误的。</li>
<li><code>-r</code>：在由 port_list 参数指定的所有端口中随机（而非按顺序）选择目标端口。此选项与 <code>-l</code> 选项结合使用是错误的。</li>
<li><code>-s source_ip_address</code>：指定用于发送数据包的接口的 IP。此选项与 <code>-l</code> 选项结合使用是错误的。</li>
<li><code>-S sla-prop</code>：指定为套接字创建的 MAC 流的属性。sla-prop 以属性的 ‘name&#x3D;value’ 逗号分隔列表的形式提供。当前支持的属性名称为 <code>maxbw</code>、<code>priority</code> 和 <code>inherit</code>。<code>maxbw</code> 和 <code>priority</code> 来自 flowadm(1M) 中定义的属性，表示流的最大带宽和优先级。<code>maxbw</code> 的允许值为整数加上可选的后缀（缺省为 Mega）。<code>priority</code> 的值可以为 ‘high’、’medium’ 和 ‘low’。在创建流时，必须至少指定 <code>maxbw</code> 和 <code>priority</code> 之一。<code>inherit</code> 的值可以为 ‘on’ 和 ‘off’，缺省值为 ‘off’。缺省情况下，接受的&#x2F;新的套接字（由 accept 返回）不会继承侦听器套接字的属性。当将其设置为 ‘on’ 时，新的套接字将继承侦听器套接字的属性。当需要对新套接字实施属性时，这对于 <code>-l</code> 选项很有用。此选项需要 <code>SYS_FLOW_CONFIG</code> 特权。此选项还要求指定 IP 地址或主机名。</li>
<li><code>-T dscp</code>：为连接指定区分服务代码点。对于 IPv4，此选项指定 IP 服务类型（Type of Service, ToS）IP 标题字段，参数的有效值为字符串标记 <code>lowdelay</code>、<code>throughput</code>、<code>reliability</code> 或前面带有 <code>0x</code> 的 8 位十六进制值。对于 IPv6（通信流量类），只能使用十六进制值。</li>
<li><code>-t</code>：使 <code>nc</code> 将 <em>RFC 854</em> <code>DON&#39;T</code> 和 <code>WON&#39;T</code> 响应发送到 <em>RFC 854</em> <code>DO</code> 及 <code>WILL</code> 请求。这样就可以使用 <code>nc</code> 编写 <code>telnet</code> 会话脚本。</li>
<li><code>-U</code>：指定使用 Unix 域套接字。如果不与 <code>-l</code>、<code>nc</code> 一起指定此选项，则它将变成 <code>AF_UNIX</code> 客户机。如果与 <code>-l</code> 选项一起指定此选项，则会创建 <code>AF_UNIX</code> 服务器。使用此选项要求必须向 <code>nc</code> 提供单个有效的 Unix 域路径参数，而不是提供主机名或端口。</li>
<li><code>-u</code>：使用 UDP，而不是缺省选项 TCP。</li>
<li><code>-v</code>：指定详细输出。</li>
<li><code>-w timeout</code>：如果连接和 <code>stdin</code> 空闲超过了 timeout 秒，则无提示地关闭连接。缺省设置是没有超时。此选项对客户机模式下的连接建立阶段或服务器模式下的等待连接过程没有任何影响。</li>
<li><code>-X proxy_protocol</code>：与代理服务器通信时，使用该指定协议。受支持的协议为 <code>4</code>（SOCKS v.4）、<code>5</code>（SOCKS v.5）和 <code>connect</code>（HTTP 代理）。如果未指定协议，则使用 SOCKS v. 5。此选项与 <code>-l</code> 选项结合使用是错误的。</li>
<li><code>-x proxy_address[:port]</code>：使用 proxy_address 和 port 上的代理请求到 hostname 的连接。如果未指定 port，则使用代理协议的已知端口（SOCKS 为 1080，HTTP 为 3128）。此选项与 <code>-l</code> 选项结合使用是错误的。此选项不适用于 IPv6 地址的数字表示形式。</li>
<li><code>-Z</code>：在侦听模式下，使用 <code>SO_ALLZONES</code> 套接字选项绑定到所有区域中的地址&#x2F;端口。此选项需要 <code>SYS_NET_CONFIG</code> 特权。</li>
<li><code>-z</code>：执行端口扫描。对于 TCP 端口（缺省），尝试在不发送数据的情况下执行连接扫描（完整三路信号握手）。对于 UDP（<code>-u</code>），缺省情况下会发送空 UDP 包。要指定 UDP 有效载荷，可以使用 <code>-N</code> 选项。UDP 扫描模式具有估计能力，如果它没有接收到否定响应（”ICMP Destination Port Unreachable”（无法访问 ICMP 目标端口）消息），它会考虑打开一个端口。对于这种模式，使用 <code>-w</code> 选项设置的超时时间将用来等待来自远程节点的 ICMP 消息或数据。通过 <code>-v</code>，接收到的任何数据都会作为十六进制字节转储到 <code>stderr</code>。由于大多数操作系统会限制发送 ICMP 消息（以响应输入包）的速率，所以有必要在执行 UDP 扫描时使用 <code>-i</code>，否则结果会不可靠。此选项与 <code>-l</code> 选项结合使用是错误的。</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li><p><code>hostname</code> 指定主机名。</p>
<p>hostname 可以是数字 IP 地址或者符号主机名（除非已指定 <code>-n</code> 选项）。通常，除非已指定 <code>-l</code> 选项或者使用了 <code>-U</code>（在此情况下，参数是一个路径），否则必须指定 hostname。如果随 <code>-l</code> 选项指定了 hostname 参数，则还必须给定 port 参数，并且 <code>nc</code> 会尝试绑定到该地址和端口。如果没有随 <code>-l</code> 选项指定 hostname 参数，则 <code>nc</code> 会尝试在给定 port 的通配符套接字上侦听。</p>
</li>
<li><p><code>path</code> 指定路径名。</p>
</li>
<li><p><code>port &lt;port_list&gt;</code> 指定端口。</p>
<p><code>port_list</code> 可以指定为单个整数、范围或两者的组合。请以 <code>nn-mm</code> 形式指定范围。<code>port_list</code> 至少必须有一个成员，但可以有多个以逗号分隔的端口&#x2F;范围。</p>
<p>通常，除非已指定 <code>-U</code> 选项（在此情况下，必须指定 Unix 域套接字路径，而不指定 hostname），否则必须指定目标端口。</p>
<p>将包含多个端口的端口列表与 <code>-e</code> 选项结合使用是错误的。</p>
</li>
</ul>
<h2 id="示例-194"><a href="#示例-194" class="headerlink" title="示例"></a>示例</h2><p>打开到 <code>host.example.com</code> 的端口 42 的 TCP 连接，使用端口 3141 作为源端口，超时为 5 秒：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -p 3141 -w 5 host.example.com 42</span><br></pre></td></tr></table></figure>



<p>打开到 <code>host.example.com</code> 的端口 7777 的 TCP 连接，对套接字设置最大 50Mbps 的带宽：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -M maxbw=50M host.example.com 7777</span><br></pre></td></tr></table></figure>



<p>打开到 <code>host.example.com</code> 的端口 53 的 UDP 连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -u host.example.com 53</span><br></pre></td></tr></table></figure>



<p>打开到 <code>host.example.com</code> 的端口 42 的 TCP 连接，使用 <code>10.1.2.3</code> 作为连接的本地端的 IP：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -s 10.1.2.3 host.example.com 42</span><br></pre></td></tr></table></figure>



<p>将一个包含端口和端口范围的列表用于针对各种端口的端口扫描：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -z host.example.com 21-25,53,80,110-120,443</span><br></pre></td></tr></table></figure>



<p>在某个 Unix 域套接字上创建连接并侦听：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -lU /var/tmp/dsocket</span><br></pre></td></tr></table></figure>



<p>在关联端口为 8888 的 UDP 套接字上创建连接并侦听：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -u -l -p 8888</span><br></pre></td></tr></table></figure>



<p>这等效于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -u -l 8888</span><br></pre></td></tr></table></figure>



<p>在关联端口为 2222 的 TCP 套接字上创建连接并侦听，并且只绑定到地址 <code>127.0.0.1</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -l 127.0.0.1 2222</span><br></pre></td></tr></table></figure>



<p>在关联端口 2222 上创建 TCP 套接字并进行侦听，并在侦听器和连接的套接字上创建高优先级的 MAC 流：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -l -M priority=high,inherit=on host.example.com 2222</span><br></pre></td></tr></table></figure>





<h1 id="Linux-nc-命令-netcat-的别名"><a href="#Linux-nc-命令-netcat-的别名" class="headerlink" title="Linux nc 命令 - netcat 的别名"></a>Linux nc 命令 - netcat 的别名</h1><p><strong><code>nc</code></strong> 命令是 <strong><code>netcat</code></strong> 的别名，它是 Linux 下的一个多功能的网络工具，详细用法见 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/netcat/">netcat 命令</a>。</p>
<h1 id="Linux-nethogs-命令-按进程监控网络流量"><a href="#Linux-nethogs-命令-按进程监控网络流量" class="headerlink" title="Linux nethogs 命令 - 按进程监控网络流量"></a>Linux nethogs 命令 - 按进程监控网络流量</h1><h2 id="介绍-194"><a href="#介绍-194" class="headerlink" title="介绍"></a>介绍</h2><p><strong>NetHogs</strong> 是一个开源的小型 net top 工具，它可以按进程实时监控网络带宽使用率。</p>
<p>和其他按协议或按子网分解流量的工具不同，NetHogs 是按进程对带宽进行分组的，并且不依赖于加载的特殊内核模块。因此，如果突然出现大量网络流量，你可以启动 NetHogs 并立即查看是哪个 PID 导致了这种情况，如果是某种旋转进程（spinning process），就可以将其终止。</p>
<p>使用前请确保你的系统上已经安装 nethogs 工具，在 Debian&#x2F;Ubuntu 系统上可通过 apt 进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install nethogs</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nethogs [options] [devices]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-V</code>：打印版本信息。</li>
<li><code>-h</code>：打印帮助信息。</li>
<li><code>-d</code>：延迟更新刷新率（以秒为单位），用于控制界面的更新速度。默认值为 1。</li>
<li><code>-v</code>：设置显示模式（0 &#x3D; KB&#x2F;s，1 &#x3D; total KB，2 &#x3D; total B，3 &#x3D; total MB）。默认值为 0。</li>
<li><code>-c</code>：限制刷新次数，默认为 0（无限制）。</li>
<li><code>-t</code>：追踪模式（tracemode）。</li>
<li><code>-p</code>：混杂模式的嗅探器（不推荐）。</li>
<li><code>-s</code>：按照发送的流量排序。</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li><code>devices</code>：要监控的网络设备。默认使用 <code>eth0</code>。</li>
</ul>
<p><strong>交互命令</strong>：</p>
<p>当 nethogs 运行时，还可以通过键盘快捷键进行交互。</p>
<ul>
<li><code>m</code>：在 kb&#x2F;s, kb, b, mb 几种显示模式之间循环切换。</li>
<li><code>r</code>：按 received 接收流量排序。</li>
<li><code>s</code>：按 sent 发送流量排序。</li>
<li><code>q</code>：退出。</li>
</ul>
<h2 id="示例-195"><a href="#示例-195" class="headerlink" title="示例"></a>示例</h2><p>以默认方式启动 nethogs 程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> nethogs</span><br></pre></td></tr></table></figure>



<p>设置每 5 秒刷新一次：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> nethogs -d 5 </span><br></pre></td></tr></table></figure>



<p>指定要监视的网络设备（例如 <code>eth0</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> nethogs eth0</span><br></pre></td></tr></table></figure>



<p>同时监视两个网络设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> nethogs eth0 eth1</span><br></pre></td></tr></table></figure>



<p>使用追踪模式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> nethogs -t </span><br></pre></td></tr></table></figure>



<p>提示</p>
<p>在基于 Debian 的系统（例如 Ubuntu）下要执行 nethogs 需要 root 权限，因此 <code>sudo</code> 是必须的。而基于 RedHat 系统则不需要。</p>
<h1 id="Linux-tcptrack-命令-TCP连接跟踪工具"><a href="#Linux-tcptrack-命令-TCP连接跟踪工具" class="headerlink" title="Linux tcptrack 命令 - TCP连接跟踪工具"></a>Linux tcptrack 命令 - TCP连接跟踪工具</h1><h2 id="介绍-195"><a href="#介绍-195" class="headerlink" title="介绍"></a>介绍</h2><p><strong>tcptrack</strong> 是一个用于实时监视 TCP 连接的命令行工具。它可用于实时监视系统中活动的 TCP 连接，显示源和目标 IP 地址、端口以及连接的状态，并以图形化的方式显示每个连接的实时流量统计信息。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcptrack [ -dfhvp ] [ -r seconds ] -i interface [ filter expression ]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-d</code>：仅跟踪 tcptrack 启动后启动的连接，不要尝试检测已有连接。</li>
<li><code>-f</code>：启用快速平均重新计算。TCPTrack 将使用运行平均值来计算连接的平均速度，这将使用更多内存和 CPU 时间，但结果更接近实时情况。在快速模式下每秒重新计算平均值的次数是编译时设置，默认为每秒 10 次。</li>
<li><code>-i [interface]</code>：嗅探来自指定网络接口的数据包。</li>
<li><code>-T [pcap file]</code>：从指定 pcap 文件中读取数据包，而不是从网络中嗅探。这个选项对于测试很有用。</li>
<li><code>-p</code>：不要将被嗅探的接口置于混杂模式。</li>
<li><code>-r [seconds]</code>：等待 seconds 秒后从显示屏上删除关闭的连接，默认为 2 秒。</li>
<li><code>-h</code>：显示帮助信息。</li>
<li><code>-v</code>：显示版本信息。</li>
</ul>
<p><strong>交互命令</strong>：</p>
<p>当 tcptrack 运行时，还可以通过键盘快捷键进行交互。</p>
<ul>
<li><code>p</code>：暂停&#x2F;取消暂停显示。不会将新连接添加到显示屏中，并且所有当前显示的连接将保留在显示屏中。</li>
<li><code>s</code>：循环切换排序选项，包括：未排序（unsorted）、按速率排序（sorted by rate）、按总字节排序（sorted by total bytes）。</li>
<li><code>q</code>：退出 tcptrack 程序。</li>
</ul>
<p><strong>过滤表达式</strong>：</p>
<p>tcptrack 还可以将 pcap 过滤器表达式作为参数。过滤器表达式的格式与 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/tcpdump/">tcpdump</a> 和其他基于 libpcap 的嗅探器的格式相同。</p>
<h2 id="示例-196"><a href="#示例-196" class="headerlink" title="示例"></a>示例</h2><p>监视 eth0 网络接口的 TCP 连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> tcptrack -i eth0</span><br></pre></td></tr></table></figure>



<p>使用 pcap 过滤器表达式，仅显示来自主机 10.45.165.2 的连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> tcptrack -i eth0 src or dst 10.45.165.2</span><br></pre></td></tr></table></figure>



<p>仅显示 Web 流量（指定 80 端口）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> tcptrack -i eth0 port 80</span><br></pre></td></tr></table></figure>





<h1 id="Linux-tcpdump-命令-数据包捕获分析工具"><a href="#Linux-tcpdump-命令-数据包捕获分析工具" class="headerlink" title="Linux tcpdump 命令 - 数据包捕获分析工具"></a>Linux tcpdump 命令 - 数据包捕获分析工具</h1><h2 id="介绍-196"><a href="#介绍-196" class="headerlink" title="介绍"></a>介绍</h2><p><strong>tcpdump</strong> 命令是 Linux 系统中的一个网络数据包截获分析工具，支持针对网络层、协议、主机、网络或端口的过滤，并提供 and、or、not 等逻辑语句帮助过滤无用的信息。</p>
<p>tcpdump 命令通常默认不安装，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install tcpdump</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump [-adeflnNOpqStvx]</span><br><span class="line">        [-c &lt;count&gt;] [-<span class="built_in">dd</span>] [-ddd] [-F &lt;file&gt;]</span><br><span class="line">        [-i &lt;interface&gt;] [-r &lt;file&gt;]</span><br><span class="line">        [-s &lt;snaplen&gt;] [-tt] [-T &lt;<span class="built_in">type</span>&gt;]</span><br><span class="line">        [-vv] [-w &lt;file&gt;]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code> ：尝试将网络和广播地址转换成名称。</li>
<li><code>-c &lt;数据包数目&gt;</code> ：收到指定的数据包数目后，就停止进行倾倒操作。</li>
<li><code>-d</code> ：把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出。</li>
<li><code>-dd</code> ：把编译过的数据包编码转换成 C 语言的格式，并倾倒到标准输出。</li>
<li><code>-ddd</code> ：把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出。</li>
<li><code>-e</code> ：在每列倾倒资料上显示连接层级的文件头。</li>
<li><code>-f</code> ：用数字显示网际网络地址。</li>
<li><code>-F &lt;表达文件&gt;</code> ：指定内含表达方式的文件。</li>
<li><code>-i &lt;网络界面&gt;</code> ：使用指定的网络截面送出数据包。</li>
<li><code>-l</code> ：使用标准输出列的缓冲区。</li>
<li><code>-n</code> ：不把主机的网络地址转换成名字。</li>
<li><code>-N</code> ：不列出域名。</li>
<li><code>-O</code> ：不将数据包编码最佳化。</li>
<li><code>-p</code> ：不让网络界面进入混杂模式。</li>
<li><code>-q</code> ：快速输出，仅列出少数的传输协议信息。</li>
<li><code>-r &lt;数据包文件&gt;</code> ：从指定的文件读取数据包数据。</li>
<li><code>-s &lt;数据包大小&gt;</code> ：设置每个数据包的大小。</li>
<li><code>-S</code> ：用绝对而非相对数值列出 TCP 关联数。</li>
<li><code>-t</code> ：在每列倾倒资料上不显示时间戳记。</li>
<li><code>-tt</code> ：在每列倾倒资料上显示未经格式化的时间戳记。</li>
<li><code>-T &lt;数据包类型&gt;</code> ：强制将表达方式所指定的数据包转译成设置的数据包类型。</li>
<li><code>-v</code> ：详细显示指令执行过程。</li>
<li><code>-vv</code> ：更详细显示指令执行过程。</li>
<li><code>-x</code> ：用十六进制字码列出数据包资料。</li>
<li><code>-w &lt;数据包文件&gt;</code> ：把数据包数据写入指定的文件。</li>
</ul>
<h2 id="示例-197"><a href="#示例-197" class="headerlink" title="示例"></a>示例</h2><p>提示：运行 tcpdump 需要超级用户（root）权限，普通用户执行下列命令时需要加上 sudo 提权，否则会收到一条错误消息：“You don’t have permission to capture on that device”。</p>
<p>显示所有网络数据包信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump</span><br></pre></td></tr></table></figure>



<p>打印 tcpdump 所有可用网络接口（包括以太网口、Wi-Fi、蓝牙等）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -D</span><br></pre></td></tr></table></figure>



<p>捕获来自所有接口的所有数据包（<code>any</code> 表示捕获所有活动的接口）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i any</span><br></pre></td></tr></table></figure>



<p>默认情况下，tcpdump 会对 IP 地址执行反向 DNS 解析，并将端口号转换为名称。使用 <code>-n</code> 选项可禁用翻译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -n</span><br></pre></td></tr></table></figure>



<p>提示：跳过 DNS 查找可避免生成 DNS 流量，并使输出更具可读性。建议每次调用 tcpdump 时都使用 <code>-n</code> 选项。</p>
<p>捕获 10 个数据包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -c 10</span><br></pre></td></tr></table></figure>



<p>以精简模式显示 10 个数据包信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -c 10 -q</span><br></pre></td></tr></table></figure>



<p>以详细模式显示 10 个数据包信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -c 10 -vv</span><br></pre></td></tr></table></figure>



<p>仅捕获 UDP 数据包（将该协议指定为过滤器）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -n udp</span><br></pre></td></tr></table></figure>



<p>仅捕获指定端口（如 51180）的数据包（使用 <code>port</code> 限定符）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -n port 51180</span><br></pre></td></tr></table></figure>



<p>仅捕获指定主机相关的数据包（使用 <code>host</code> 限定符）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -n host 192.168.1.100</span><br></pre></td></tr></table></figure>



<p>提示：使用 <code>net</code> 限定符可以过滤指定的 IP 范围</p>
<p>仅捕获来自 192.168.1.100 的主机的传入数据包（使用 <code>src</code> 指定源地址，<code>dst</code> 指定目的地址）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -n src host 192.168.1.100</span><br></pre></td></tr></table></figure>



<p>捕获所有发送到 80 端口的数据包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -n dst port 80</span><br></pre></td></tr></table></figure>



<p>对于复杂的过滤条件，可以使用 <code>and</code>（<code>&amp;&amp;</code>）、<code>or</code>（<code>||</code>）和 <code>not</code>（<code>!</code>）运算符进行组合。</p>
<p>例如：捕获来自某个源IP地址 192.168.1.100 的所有 HTTP 通信</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -n src 192.168.1.100 and tcp port 80</span><br></pre></td></tr></table></figure>



<p>以及 HTTPS 通信</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -n <span class="string">&#x27;host 192.168.1.100 and (tcp port 80 or tcp port 443)&#x27;</span></span><br></pre></td></tr></table></figure>



<p>提示：为避免使用特殊字符时解析错误，可将过滤器括在单引号内。</p>
<p>捕获源 IP 地址 192.168.1.100 除 SSH 以外的所有流量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -n src 192.168.1.100 and not dst port 22</span><br></pre></td></tr></table></figure>



<p>将捕获的网络数据包信息保存到文件中（使用重定向操作符 <code>&gt;</code> 和 <code>&gt;&gt;</code> 将其重定向到文件）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -n -i any &gt; file.out</span><br></pre></td></tr></table></figure>



<p>如果你想在保存到文件的同时在终端观看数据，可以借助 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/tee/">tee</a> 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -n -l | <span class="built_in">tee</span> file.out</span><br></pre></td></tr></table></figure>



<p>注意：上面命令中的 <code>-l</code> 选项告诉 tcpdump 缓冲输出。如果不使用此选项时，那么在生成新行时，输出将不会显示在屏幕上。</p>
<p>将捕获的网络数据包导出到文件（使用 <code>-w</code> 选项）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -n -w data.pcap</span><br></pre></td></tr></table></figure>



<p>提示：你可以根据需要命名文件，但是使用 <code>.pcap</code> 扩展名（数据包捕获）是一种常见的约定。</p>
<p>注意：使用 <code>-w</code> 选项时，tcpdump 的输出不显示在屏幕上，并将原始数据包写入到一个二进制文件，而非文本文件，这一点和重定向保存到文件不同。</p>
<p>如果想要查看 pcap 文件的内容，请使用 <code>-r</code> 选项，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -r data.pcap</span><br></pre></td></tr></table></figure>



<p>如果想要捕获一段时间内的数据包，可以与 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/timeout/">timeout</a> 命令配合使用。例如捕获 5 分钟的网络数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">timeout</span> 300 tcpdump -n -w data.pcap</span><br></pre></td></tr></table></figure>





<h1 id="Linux-tcpreplay-命令-重放网络数据包工具"><a href="#Linux-tcpreplay-命令-重放网络数据包工具" class="headerlink" title="Linux tcpreplay 命令 - 重放网络数据包工具"></a>Linux tcpreplay 命令 - 重放网络数据包工具</h1><h2 id="介绍-197"><a href="#介绍-197" class="headerlink" title="介绍"></a>介绍</h2><p><strong>tcpreplay</strong> 是一个用于在网络中重放和编辑 pcap 文件的命令行工具。它可以用来测试网络设备的性能、网络分析、入侵检测系统（IDS）的测试和验证等。tcpreplay 工具允许用户将先前捕获的网络流量重放到网络中，以模拟真实的流量。通过组合不同的选项参数，可以灵活地模拟各种网络条件和负载。</p>
<p>tcpreplay 命令由 <a target="_blank" rel="noopener" href="https://tcpreplay.appneta.com/">tcpreplay</a> 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install tcpreplay</span><br></pre></td></tr></table></figure>



<p>安装完成后，系统会增加 <code>tcpreplay</code>、<code>tcprewrite</code>、<code>tcpreplay-edit</code>、<code>tcpprep</code>、<code>tcpbridge</code>、<code>tcpliveplay</code>、<code>tcpcapinfo</code> 等几个命令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpreplay [ -&lt;flag&gt; [&lt;val&gt;] | --&lt;name&gt;[&#123;=| &#125;&lt;val&gt;] ]... &lt;pcap_file(s)&gt;</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-i, --intf1=str</code>：指定回放流量的网络接口（多网卡系统必须指定）。</li>
<li><code>-I, --intf2=str</code>：辅助流量输出接口（可选）。</li>
<li><code>-T, --timer=str</code>：选择数据包计时模式。可以是 <code>select</code>、<code>ioport</code>、<code>gtod</code> 或 <code>nano</code>。</li>
<li><code>--maxsleep=num</code>：数据包之间休眠时间不超过 <code>num</code> 毫秒。</li>
<li><code>-v, --verbose</code>：通过 tcpdump 将解码后的数据包打印到标准输出 <code>STDOUT</code>。</li>
<li><code>-A, --decode=str</code>：传递给 tcpdump 解码器的参数（需要 <code>-v</code> 选项）。</li>
<li><code>-K, --preload-pcap</code>：发送前将数据包预加载到 RAM 中。</li>
<li><code>-l, --loop=num</code>：指定回放流量的次数。默认是 1 次。</li>
<li><code>-L, --limit=num</code>：指定回放数据包的数量（需要大于 1）。</li>
<li><code>-x, --multiplier=str</code>：将回放速度修改为指定倍数。</li>
<li><code>-p, --pps=str</code>：以指定的 packets&#x2F;sec 速度（每秒包数）回放数据包。</li>
<li><code>-M, --mbps=str</code>：以指定的 Mbps 速度（带宽）回放数据包。</li>
<li><code>-t, --topspeed</code>：尽可能快地回放数据包。</li>
<li><code>-o, --oneatatime</code>：根据每个用户输入，一次重放一个数据包。</li>
</ul>
<h2 id="示例-198"><a href="#示例-198" class="headerlink" title="示例"></a>示例</h2><p>将 example.pcap 文件中的流量重放到 <code>eth0</code> 接口上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpreplay -i eth0 example.pcap</span><br></pre></td></tr></table></figure>



<p>将 example.pcap 文件中的流量在 <code>eth0</code> 接口上重放 5 次：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpreplay -i eth0 -l 5 example.pcap</span><br></pre></td></tr></table></figure>



<p>根据 pcap 文件中的时间戳来重放流量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpreplay -i eth0 -t example.pcap</span><br></pre></td></tr></table></figure>



<p>以 10 Mbps 的速度重放流量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpreplay -i eth0 --mbps=10 example.pcap</span><br></pre></td></tr></table></figure>



<p>以每秒 1000 包的速度重放流量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpreplay -i eth0 --pps=1000 example.pcap</span><br></pre></td></tr></table></figure>



<p>只重放前 100 个包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpreplay -i eth0 -L 100 example.pcap</span><br></pre></td></tr></table></figure>



<h2 id="资源链接"><a href="#资源链接" class="headerlink" title="资源链接"></a>资源链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/appneta/tcpreplay">tcpreplay 代码仓库</a></li>
<li><a target="_blank" rel="noopener" href="https://tcpreplay.appneta.com/">tcpreplay 项目主页</a></li>
</ul>
<h1 id="Linux-ethr-命令-网络性能测试工具"><a href="#Linux-ethr-命令-网络性能测试工具" class="headerlink" title="Linux ethr 命令 - 网络性能测试工具"></a>Linux ethr 命令 - 网络性能测试工具</h1><h2 id="介绍-198"><a href="#介绍-198" class="headerlink" title="介绍"></a>介绍</h2><p><strong>Ethr</strong> 是一个用 golang 编写的跨平台网络性能测量工具。该项目的目标是提供本机工具，用于跨多种协议（如 TCP、UDP、HTTP、HTTPS 和跨多个平台）对带宽、连接、数据包、延迟、丢失进行全面的网络性能测量。</p>
<p>Ethr 从现有的开源网络性能工具中获取灵感，并以这些想法为基础。对于带宽测量，它类似于 iPerf3，用于 TCP 和 UDP 流量。iPerf3 有更多选项可用于执行限制测试，更丰富的功能集，而 Ethr 支持多线程，允许它扩展到 1024 甚至更高数量的连接，多个客户端与单个服务器通信等。用于延迟测量，它类似于 Windows 上的 latte 或 Linux 上的 sockperf。</p>
<p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/Microsoft/Ethr">https://github.com/Microsoft/Ethr</a></p>
<p><strong>安装</strong>：</p>
<p>有多种方式安装 ethr 工具</p>
<ul>
<li><p>直接下载安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/microsoft/ethr/releases/latest/download/ethr_linux.zip</span><br><span class="line">unzip ethr_linux.zip</span><br></pre></td></tr></table></figure>



<p>解压缩后将 ethr 放到 <code>$PATH</code> 中任一路径即可，比如 &#x2F;usr&#x2F;local&#x2F;bin&#x2F; 目录。</p>
</li>
<li><p>源码编译安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Microsoft/ethr.git</span><br><span class="line"><span class="built_in">cd</span> ethr</span><br><span class="line">go build</span><br></pre></td></tr></table></figure>


</li>
<li><p>Docker 镜像安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t microsoft/ethr .</span><br><span class="line">docker run -e GOOS=linux -v $(<span class="built_in">pwd</span>):/out microsoft/ethr make build-docker</span><br></pre></td></tr></table></figure>


</li>
<li><p>go get 安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/Microsoft/ethr</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="示例-199"><a href="#示例-199" class="headerlink" title="示例"></a>示例</h2><p>查看帮助</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ethr -h</span><br></pre></td></tr></table></figure>



<p>启动服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ethr -s</span><br></pre></td></tr></table></figure>



<p>启动带文本 UI 的服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ethr -s -ui</span><br></pre></td></tr></table></figure>



<p>启动客户端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ethr -c &lt;server ip&gt;</span><br></pre></td></tr></table></figure>



<p>更多示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Start server</span></span><br><span class="line">ethr -s</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start client for default (bandwidth) test measurement using 1 thread</span></span><br><span class="line">ethr -c localhost</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start bandwidth test using 8 threads</span></span><br><span class="line">ethr -c localhost -n 8</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start connections/s test using 64 threads to server 10.1.0.11</span></span><br><span class="line">ethr -c 10.1.0.11 -t c -n 64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run Ethr server on port 9999</span></span><br><span class="line">ethr -s -port 9999</span><br><span class="line"></span><br><span class="line"><span class="comment"># Measure TCP connection setup latency to ethr server on port 9999</span></span><br><span class="line"><span class="comment"># Assuming Ethr server is running on server with IP address: 10.1.1.100</span></span><br><span class="line">ethr -c 10.1.1.100 -p tcp -t pi -d 0 -4 -port 9999</span><br><span class="line"></span><br><span class="line"><span class="comment"># Measure TCP connection setup latency to www.github.com at port 443</span></span><br><span class="line">ethr -x www.github.com:443 -p tcp -t pi -d 0 -4</span><br><span class="line"></span><br><span class="line"><span class="comment"># Measure TCP connection setup latency to www.github.com at port 443</span></span><br><span class="line"><span class="comment"># Note: Here port 443 is driven automatically from https</span></span><br><span class="line">ethr -x https://www.github.com -p tcp -t pi -d 0 -4</span><br><span class="line"></span><br><span class="line"><span class="comment"># Measure ICMP ping latency to www.github.com</span></span><br><span class="line"><span class="built_in">sudo</span> ethr -x www.github.com -p icmp -t pi -d 0 -4</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run measurement similar to mtr on Linux</span></span><br><span class="line"><span class="built_in">sudo</span> ethr -x www.github.com -p icmp -t mtr -d 0 -4</span><br><span class="line"></span><br><span class="line"><span class="comment"># Measure packets/s over UDP by sending small 1-byte packets</span></span><br><span class="line">ethr -c 172.28.192.1 -p udp -t p -d 0</span><br></pre></td></tr></table></figure>





<h1 id="Linux-iptables-命令-配置-Linux-防火墙"><a href="#Linux-iptables-命令-配置-Linux-防火墙" class="headerlink" title="Linux iptables 命令 - 配置 Linux 防火墙"></a>Linux iptables 命令 - 配置 Linux 防火墙</h1><h2 id="介绍-199"><a href="#介绍-199" class="headerlink" title="介绍"></a>介绍</h2><p><strong>iptables</strong> 是 Linux 系统常用的防火墙软件，是 netfilter 项目的一部分。可以直接配置，也可以通过许多前端和图形界面配置。实际上，iptables 只是一个应用层的网络配置工具，它需要内核的支持才能正常工作。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 [规则号] &lt;-i/o 网卡名&gt; </span><br><span class="line">         -p 协议名 &lt;-s 源IP/源子网&gt; </span><br><span class="line">         --sport 源端口 &lt;-d 目标IP/目标子网&gt; </span><br><span class="line">         --dport 目标端口 </span><br><span class="line">         -j 动作</span><br></pre></td></tr></table></figure>



<h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>规则链名包括(也被称为五个钩子函数（hook functions）)：</p>
<ul>
<li><strong><code>INPUT</code> 链</strong> ：处理输入数据包。</li>
<li><strong><code>OUTPUT</code> 链</strong> ：处理输出数据包。</li>
<li><strong><code>FORWARD</code> 链</strong> ：处理转发数据包。</li>
<li><strong><code>PREROUTING</code> 链</strong> ：用于目标地址转换（DNAT）。</li>
<li><strong><code>POSTOUTING</code> 链</strong> ：用于源地址转换（SNAT）。</li>
</ul>
<h3 id="防火墙的策略"><a href="#防火墙的策略" class="headerlink" title="防火墙的策略"></a>防火墙的策略</h3><p>防火墙策略一般分为两种，一种叫“通”策略，一种叫“堵”策略，通策略，默认门是关着的，必须要定义谁能进。堵策略则是，大门是洞开的，但是你必须有身份认证，否则不能进。所以我们要定义，让进来的进来，让出去的出去，所以通，是要全通，而堵，则是要选择。当我们定义的策略的时候，要分别定义多条功能，其中：定义数据包中允许或者不允许的策略，filter 过滤的功能，而定义地址转换的功能的则是 nat 选项。为了让这些功能交替工作，我们制定出了“表”这个定义，来定义、区分各种不同的工作功能和处理方式。</p>
<p>我们现在用的比较多个功能有 3 个：</p>
<ol>
<li>filter 定义允许或者不允许的，只能做在 3 个链上：<code>INPUT</code>、<code>FORWARD</code>、<code>OUTPUT</code>。</li>
<li>nat 定义地址转换的，也只能做在 3 个链上：<code>PREROUTING</code>、<code>OUTPUT</code>、<code>POSTROUTING</code>。</li>
<li>mangle 功能用于修改报文原数据，是 5 个链都可以做：<code>PREROUTING</code>、<code>INPUT</code>、<code>FORWARD</code>、<code>OUTPUT</code>、<code>POSTROUTING</code>。</li>
</ol>
<p>我们修改报文原数据就是来修改 TTL 的。能够实现将数据包的元数据拆开，在里面做标记&#x2F;修改内容的。而防火墙标记，其实就是靠 mangle 来实现的。</p>
<p>iptables&#x2F;netfilter（这款软件）是工作在用户空间的，它可以让规则进行生效的，本身不是一种服务，而且规则是立即生效的。而我们 iptables 现在被做成了一个服务，可以进行启动、停止的。启动，则将规则直接生效，停止，则将规则撤销。</p>
<p>iptables 还支持自己定义链。但是自己定义的链，必须是跟某种特定的链关联起来的。在一个关卡设定，指定当有数据的时候专门去找某个特定的链来处理，当那个链处理完之后，再返回。接着在特定的链中继续检查。</p>
<p>注意：规则的次序非常关键，<strong>谁的规则越严格，应该放的越靠前</strong>，而检查规则的时候，是按照从上往下的方式进行检查的。</p>
<p>表名包括：</p>
<ul>
<li><strong>raw</strong> ：高级功能，如：网址过滤。</li>
<li><strong>mangle</strong> ：数据包修改（QOS），用于实现服务质量。</li>
<li><strong>nat</strong> ：地址转换，用于网关路由器。</li>
<li><strong>filter</strong> ：包过滤，用于防火墙规则。</li>
</ul>
<p>动作包括：</p>
<ul>
<li><strong>ACCEPT</strong> ：接收数据包。</li>
<li><strong>DROP</strong> ：丢弃数据包。</li>
<li><strong>REDIRECT</strong> ：重定向、映射、透明代理。</li>
<li><strong>SNAT</strong> ：源地址转换。</li>
<li><strong>DNAT</strong> ：目标地址转换。</li>
<li><strong>MASQUERADE</strong> ：IP伪装（NAT），用于ADSL。</li>
<li><strong>LOG</strong> ：日志记录。</li>
<li><strong>SEMARK</strong> : 添加SEMARK标记以供网域内强制访问控制（MAC）</li>
</ul>
<h2 id="示例-200"><a href="#示例-200" class="headerlink" title="示例"></a>示例</h2><p><strong>1、使用命令 iptables -L 测试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> iptables -L</span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br></pre></td></tr></table></figure>



<p><strong>2、对 NAT 表做转发设定</strong></p>
<p>实际上，网关使用 iptables 的一个很重要的目的就是为了实现私网穿透，因此，需要设置 DNAT 和 SNAT 规则。DNAT（Destination Network Address Translation，目的地址转换）通常被叫做目的映射，而 SNAT（Source Network Address Translation，源地址转换）通常被称为源映射。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> iptables -t nat -A POSTROUTING -s 192.168.3.1 -o eth0 -j SNAT --to-source 6.24.34.22</span><br><span class="line">$ <span class="built_in">sudo</span> iptables -t nat -A PREROUTING -i eth0 -d 6.24.34.22 -p udp --dport 8507 -j DNAT --to-destination 192.168.3.1:10012</span><br></pre></td></tr></table></figure>



<p>设置 NAT 转发规则后，可以通过如下命令查看规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> iptables -L -n -t nat</span><br><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">DNAT       udp  --  0.0.0.0/0            6.24.34.22           udp dpt:8507 to:192.168.3.1:10012</span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">SNAT       all  --  192.168.3.1          0.0.0.0/0            to:6.24.34.22</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ufw-命令-防火墙配置管理工具"><a href="#Linux-ufw-命令-防火墙配置管理工具" class="headerlink" title="Linux ufw 命令 - 防火墙配置管理工具"></a>Linux ufw 命令 - 防火墙配置管理工具</h1><h2 id="介绍-200"><a href="#介绍-200" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ufw</strong>（英文全拼：Uncomplicated Firewall）命令用于管理 Linux 系统防火墙服务。由于 Linux 系统早期使用的 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/iptables/">iptables</a> 防火墙完全基于命令行工作，操作参数及配置方法特别复杂，因此 Ubuntu 系统率先发布了这款基于 iptables 之上的全新、简单防火墙服务管理工具。ufw 支持图形化界面操作，弥补了 iptables 防火墙只支持命令行配置的缺点，使用起来简单很多。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ufw &lt;COMMAND&gt;</span><br></pre></td></tr></table></figure>



<p><strong>命令</strong>：</p>
<ul>
<li><code>enable</code>：启动防火墙。</li>
<li><code>disable</code>：关闭防火墙。</li>
<li><code>default ARG</code>：设置默认策略。</li>
<li><code>logging LEVEL</code>：设置日志等级为 <code>LEVEL</code>。</li>
<li><code>allow ARGS</code>：添加允许通过规则。</li>
<li><code>deny ARGS</code>：添加禁止通过规则。</li>
<li><code>reject ARGS</code>：添加拒绝规则。</li>
<li><code>limit ARGS</code>：添加限制规则。</li>
<li><code>delete RULE|NUM</code>：删除规则。</li>
<li><code>insert NUM RULE</code>：在 <code>NUM</code> 处插入规则。</li>
<li><code>route RULE</code>：添加路由规则。</li>
<li><code>route delete RULE|NUM</code>：删除路由规则。</li>
<li><code>route insert NUM RULE</code>：在 <code>NUM</code> 处插入路由规则。</li>
<li><code>reload</code>：重新加载防火墙配置。</li>
<li><code>reset</code>：重置配置防火墙。</li>
<li><code>status</code>：查看防火墙状态。</li>
<li><code>status numbered</code>：将防火墙状态显示为规则编号列表。</li>
<li><code>status verbose</code>：显示详细的防火墙状态。</li>
<li><code>show ARG</code>：显示防火墙报告。</li>
<li><code>version</code>：显示版本信息。</li>
</ul>
<p>Application profile 命令：</p>
<ul>
<li><code>app list</code>：列出应用程序配置文件（application profiles）。</li>
<li><code>app info PROFILE</code>：显示 <code>PROFILE</code> 的信息。</li>
<li><code>app update PROFILE</code>：更新 <code>PROFILE</code>。</li>
<li><code>app default ARG</code>：设置默认的应用程序策略（application policy）。</li>
</ul>
<h2 id="示例-201"><a href="#示例-201" class="headerlink" title="示例"></a>示例</h2><p>查看防火墙状态及所有规则（需要 root 权限）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw status</span><br></pre></td></tr></table></figure>



<p>查看防火墙状态、规则及其编号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw status numbered</span><br></pre></td></tr></table></figure>



<p>启动 UFW 防火墙管理工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure>



<p>禁用 UFW 防火墙管理工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw <span class="built_in">disable</span></span><br></pre></td></tr></table></figure>



<p>开放 UDP 端口 1234、开放 TCP 端口 1234（可同时开放）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow 1234/udp</span><br><span class="line"><span class="built_in">sudo</span> ufw allow 1234/tcp</span><br></pre></td></tr></table></figure>



<p>删除上面设置的规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw delete allow 1234/udp</span><br><span class="line"><span class="built_in">sudo</span> ufw delete allow 1234/tcp</span><br></pre></td></tr></table></figure>



<p>通过编号（例如 2）删除特定规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw delete 2</span><br></pre></td></tr></table></figure>



<p>重启 UFW 防火墙管理工具（更新规则后可能需要执行）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw reload</span><br></pre></td></tr></table></figure>



<p>重置 UFW 防火墙策略：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw reset</span><br></pre></td></tr></table></figure>



<p>显示 UFW 防火墙的报告信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw show raw</span><br></pre></td></tr></table></figure>





<h1 id="Linux-nfsstat-命令-显示-NFS-统计信息"><a href="#Linux-nfsstat-命令-显示-NFS-统计信息" class="headerlink" title="Linux nfsstat 命令 - 显示 NFS 统计信息"></a>Linux nfsstat 命令 - 显示 NFS 统计信息</h1><h2 id="介绍-201"><a href="#介绍-201" class="headerlink" title="介绍"></a>介绍</h2><p><strong>nfsstat</strong>（英文全拼：NFS statistics）命令用于显示关于 NFS 客户机和服务器活动的统计信息。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nfsstat [OPTION]...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-s</code> ：仅列出 NFS 服务器端状态。</li>
<li><code>-c</code> ：仅列出 NFS 客户端状态。</li>
<li><code>-n</code> ：仅列出 NFS 状态，默认显示 nfs 客户端和服务器的状态。</li>
<li><code>-m</code> ：打印以加载的 nfs 文件系统状态。</li>
<li><code>-r</code> ：仅打印 rpc 状态。</li>
</ul>
<h2 id="示例-202"><a href="#示例-202" class="headerlink" title="示例"></a>示例</h2><p>显示关于客户机发送和拒绝的 RPC 和 NFS 调用数目的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nfsstat -c</span><br></pre></td></tr></table></figure>



<p>显示和打印与客户机 NFS 调用相关的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nfsstat -cn</span><br></pre></td></tr></table></figure>



<p>显示和打印客户机和服务器的与 RPC 调用相关的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nfsstat -r</span><br></pre></td></tr></table></figure>



<p>显示关于服务器接收和拒绝的 RPC 和 NFS 调用数目的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nfsstat -s</span><br></pre></td></tr></table></figure>





<h1 id="Linux-pppd-命令-点对点协议守护进程"><a href="#Linux-pppd-命令-点对点协议守护进程" class="headerlink" title="Linux pppd 命令 - 点对点协议守护进程"></a>Linux pppd 命令 - 点对点协议守护进程</h1><h2 id="介绍-202"><a href="#介绍-202" class="headerlink" title="介绍"></a>介绍</h2><p><strong>pppd</strong>（英文全拼：Point-to-Point Protocol Daemon）是 Linux 系统中用于建立和管理 PPP（点对点协议）连接的守护进程。pppd 支持多种身份验证方法，包括 PAP 和 CHAP 等。</p>
<p>提示</p>
<p>PPP 是一种用于在两个计算机之间建立点对点连接的协议，通常用于拨号连接、DSL 连接和串行线路连接。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pppd [ options ]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>&lt;device&gt;</code> ：通过指定的设备进行通信。</li>
<li><code>&lt;speed&gt;</code> ：将波特率设置为 <code>speed</code>（一个十进制数字）。</li>
<li><code>&lt;loc&gt;:&lt;rem&gt;</code> ：设置本地和&#x2F;或远程接口 IP 地址。两者都可以省略，但冒号是必需的。IP 地址可以通过主机名来指定，也可以通过十进制点记法来指定，例如 <code>:10.1.2.3</code>。缺省本地地址是系统的第一个 IP 地址，除非提供了 <code>noipdefault</code> 选项。</li>
<li><code>asyncmap &lt;n&gt;</code> ：将 async 字符映射设置为 <code>n</code>（十六进制）。映射描述了哪些控制字符无法通过串行线路成功接收。</li>
<li><code>auth</code> ：在允许发送或接收网络数据包之前要求对等方证明自己的身份。</li>
<li><code>call &lt;name&gt;</code>：从文件 <code>/etc/ppp/peers/name</code> 中读取额外的选项。即使 pppd 不是由 root 运行，这个文件也可以包含诸如 <code>noauth</code> 之类的特权选项。注意，<code>name</code> 字符串不能以 <code>/</code> 开头，也不能包含 <code>..</code>。</li>
<li><code>connect &lt;script&gt;</code> ：使用由 <code>script</code> 指定的可执行文件或 shell 命令来设置串行线路。</li>
<li><code>crtscts</code> ：使用硬件流量控制（即 RTS&#x2F;CTS）来控制串行端口上的数据流。</li>
<li><code>defaultroute</code> ：当 IPCP 协商成功完成时，向系统路由表添加一个缺省路由（使用对等方作为网关）。当 PPP 连接断开时，将删除此条目。如果指定了 <code>nodefaultroute</code> 选项，则此选项为特权选项。</li>
<li><code>file &lt;name&gt;</code> ：从文件 <code>name</code> 读取选项。如果此选项在命令行上或 <code>$HOME/.ppprc</code> 中使用，则该文件必须能够由调用 <code>pppd</code> 的用户读取。</li>
<li><code>modem</code> ：使用调制解调器控制线路。此选项为缺省选项。</li>
<li><code>mru &lt;n&gt;</code> ：将最大接收单元（Maximum Receive Unit, MRU）值设置为 <code>n</code>。pppd 要求对等方发送的包不要超过 n 个字节。最小 MRU 值为 128。缺省 MRU 值为 1500。对于慢速链路，建议使用值 296（40 字节的 TCP&#x2F;IP 标头 + 256 字节的数据）。对于 IPv6，MRU 必须至少为 1280。</li>
<li><code>mtu &lt;n&gt;</code> ：将最大传输单元（Maximum Transmit Unit, MTU）值设置为 <code>n</code>。除非对等方通过 MRU 协商请求一个较小的值，否则，pppd 将要求内核联网代码通过 PPP 网络接口发送的数据包不要超过 n 个字节。对于 IPv6，MTU 必须至少为 1280。</li>
</ul>
<h2 id="示例-203"><a href="#示例-203" class="headerlink" title="示例"></a>示例</h2><p>使用名为 provider 的配置文件来建立拨号连接（配置文件通常存储在 <code>/etc/ppp/peers</code> 目录中）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pppd call provider</span><br></pre></td></tr></table></figure>



<p>建立连接时显示详细调试信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pppd call provider debug</span><br></pre></td></tr></table></figure>



<p>建立连接时提供用户名和密码进行认证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pppd call provider user your_username password your_password</span><br></pre></td></tr></table></figure>



<p>指定串行端口和波特率来建立 PPP 连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pppd /dev/ttyS0 115200</span><br></pre></td></tr></table></figure>



<p>使用 CHAP 认证方式建立连接（配置信息通常存储在 <code>/etc/ppp/chap-secrets</code> 文件）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pppd call provider chap-secrets</span><br></pre></td></tr></table></figure>



<p>使用 PAP 认证方式建立连接（配置信息通常存储在 <code>/etc/ppp/pap-secrets</code> 文件）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pppd call provider pap-secrets</span><br></pre></td></tr></table></figure>





<h1 id="Linux-nm-connection-editor-命令-图形界面网络设置"><a href="#Linux-nm-connection-editor-命令-图形界面网络设置" class="headerlink" title="Linux nm-connection-editor 命令 - 图形界面网络设置"></a>Linux nm-connection-editor 命令 - 图形界面网络设置</h1><h2 id="介绍-203"><a href="#介绍-203" class="headerlink" title="介绍"></a>介绍</h2><p><strong>nm-connection-editor</strong>（英文全拼：network connection editor for NetworkManager）是一个基于 GTK 的应用程序，可用来添加、删除和修改 NetworkManager 存储的网络连接。</p>
<p>注意，运行 nm-connection-editor 的前提是 NetworkManager 必须正在运行。</p>
<h2 id="示例-204"><a href="#示例-204" class="headerlink" title="示例"></a>示例</h2><p>启动 nm-connection-editor 图形配置工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nm-connection-editor</span><br></pre></td></tr></table></figure>



<p>这将打开类似如下窗口：</p>
<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/nm-connection-editor.png" alt="img"></p>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/nmcli/">nmcli</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/nmtui/">nmtui</a>。</p>
<h1 id="Linux-nmcli-命令-网络管理配置工具"><a href="#Linux-nmcli-命令-网络管理配置工具" class="headerlink" title="Linux nmcli 命令 - 网络管理配置工具"></a>Linux nmcli 命令 - 网络管理配置工具</h1><h2 id="介绍-204"><a href="#介绍-204" class="headerlink" title="介绍"></a>介绍</h2><p><strong>nmcli</strong> 是 NetworkManager 网络管理客户端附带的一个命令行工具。使用 nmcli 命令，可以完成网络设备上的所有配置，并写入配置文件中。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli [OPTIONS] OBJECT &#123; COMMAND | <span class="built_in">help</span> &#125;</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a, --ask</code>：询问缺少的参数。</li>
<li><code>-c, --colors auto|yes|no</code>：是否在输出中使用颜色。</li>
<li><code>-e, --escape yes|no</code>：转义值中的列分隔符。</li>
<li><code>-f, --fields &lt;字段,...&gt;|all|common</code>：指定要输出的字段。</li>
<li><code>-g, --get-values &lt;字段,...&gt;|all|common</code>：组合选项 <code>-m tabular -t -f</code> 的快捷方式。</li>
<li><code>-h, --help</code>：显示帮助信息。</li>
<li><code>-m, --mode tabular|multiline</code>：输出模式。</li>
<li><code>-o, --overview</code>：概览模式。</li>
<li><code>-p, --pretty</code>：以美化模式输出。</li>
<li><code>-s, --show-secrets</code>：允许显示密码。</li>
<li><code>-t, --terse</code>：以简洁模式输出。</li>
<li><code>-v, --version</code>：显示版本信息。</li>
<li><code>-w, --wait &lt;秒数&gt;</code>：设定操作完成的等待超时。</li>
</ul>
<p><strong>对象</strong>：</p>
<ul>
<li><code>g[eneral]</code>：NetworkManager 的常规状态和操作。</li>
<li><code>n[etworking]</code>：整体网络控制。</li>
<li><code>r[adio]</code>：NetworkManager 切换开关。</li>
<li><code>c[onnection]</code>：NetworkManager 的连接。</li>
<li><code>d[evice]</code>：NetworkManager 管理的设备。</li>
<li><code>a[gent]</code>：NetworkManager 的私密代理或 polkit 代理。</li>
<li><code>m[onitor]</code>：监视 NetworkManager 更改。</li>
</ul>
<p>提示</p>
<p>对象名可以是单个字母的缩写，也可以是任意字母的组合。例如 <code>connection</code> 对象，写成 <code>c</code>、<code>con</code>、<code>connection</code> 是等效的。</p>
<h2 id="示例-205"><a href="#示例-205" class="headerlink" title="示例"></a>示例</h2><h3 id="查看连接"><a href="#查看连接" class="headerlink" title="查看连接"></a>查看连接</h3><p>显示连接列表及其名称、UUID、类型和支持设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli connection show</span><br></pre></td></tr></table></figure>



<p>显示活动的连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli connection show -active</span><br></pre></td></tr></table></figure>



<p>显示指定一个网络连接配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli connection show <span class="string">&quot;lan eth0&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="查看和操作设备"><a href="#查看和操作设备" class="headerlink" title="查看和操作设备"></a>查看和操作设备</h3><p>显示所有网络设备及其状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli device</span><br></pre></td></tr></table></figure>



<p>等效于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli device status</span><br></pre></td></tr></table></figure>



<p>查看所有网络设备的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli device show</span><br></pre></td></tr></table></figure>



<p>查看指定网络设备的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli device show <span class="string">&quot;eth0&quot;</span></span><br></pre></td></tr></table></figure>



<p>断开网络接口上的连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli device disconnect ifname eth0</span><br></pre></td></tr></table></figure>



<h3 id="创建、配置和删除连接"><a href="#创建、配置和删除连接" class="headerlink" title="创建、配置和删除连接"></a>创建、配置和删除连接</h3><p>定义一个名字为 default 的新连接，它将使用 DHCP 通过 <code>eth0</code> 设备的以太网自动连接 ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli connection add con-name <span class="string">&quot;default&quot;</span> <span class="built_in">type</span> ethernet ifname eth0</span><br></pre></td></tr></table></figure>



<p>关闭自动连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli connection modify <span class="string">&quot;default&quot;</span> connection.autoconnect no</span><br></pre></td></tr></table></figure>



<p>添加 DNS：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli connection modify <span class="string">&quot;default&quot;</span> ipv4.dns 8.8.8.8</span><br></pre></td></tr></table></figure>



<p>启用 default 连接配置（激活连接）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli connection up <span class="string">&quot;default&quot;</span></span><br></pre></td></tr></table></figure>



<p>删除 default 连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli connection delete <span class="string">&quot;default&quot;</span></span><br></pre></td></tr></table></figure>



<p>重启服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli connection reload</span><br></pre></td></tr></table></figure>



<h3 id="Wi-Fi-操作"><a href="#Wi-Fi-操作" class="headerlink" title="Wi-Fi 操作"></a>Wi-Fi 操作</h3><p>显示附近的 Wi-Fi 网络：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli device wifi list</span><br></pre></td></tr></table></figure>



<p>连接到 Wi-Fi 网络：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli device wifi connect &lt;SSID_或_BSSID&gt; password &lt;密码&gt;</span><br></pre></td></tr></table></figure>



<p>连接到隐藏的 Wi-Fi 网络：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli device wifi connect &lt;SSID_或_BSSID&gt; password &lt;密码&gt; hidden <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>



<p>连接到 <code>wlan1</code> 网络接口上的 Wi-Fi：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli device wifi connect &lt;SSID_或_BSSID&gt; password &lt;密码&gt; ifname wlan1 &lt;profile_name&gt;</span><br></pre></td></tr></table></figure>



<p>关闭 Wi-Fi：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli radio wifi off</span><br></pre></td></tr></table></figure>



<h3 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h3><p>nmcli 命令有很多子命令，可通过如下方式查看命令及其子命令的帮助信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmcli <span class="built_in">help</span></span><br><span class="line">$ nmcli connection <span class="built_in">help</span></span><br><span class="line">$ nmcli connection add <span class="built_in">help</span></span><br></pre></td></tr></table></figure>





<h1 id="Linux-nmtui-命令-文本界面网络设置"><a href="#Linux-nmtui-命令-文本界面网络设置" class="headerlink" title="Linux nmtui 命令 - 文本界面网络设置"></a>Linux nmtui 命令 - 文本界面网络设置</h1><h2 id="介绍-205"><a href="#介绍-205" class="headerlink" title="介绍"></a>介绍</h2><p><strong>nmtui</strong> 是 NetworkManager 网络管理客户端附带的一个命令行工具。它是一个基于 Curses 的 TUI（Text User Interface）应用程序，用于与 NetworkManager 交互。启动 nmtui 时，系统会提示用户选择要执行的活动，除非将其指定为第一个参数。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmtui [OPTIONS]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-h, --help</code>：显示帮助信息。</li>
</ul>
<p>nmtui 支持以下三种活动：</p>
<ul>
<li><code>edit</code>：显示连接编辑器，支持添加、修改、查看和删除连接。它提供与 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/nm-connection-editor/"><code>nm-connection-editor</code></a> 类似的功能。</li>
<li><code>connect</code>：显示可用连接的列表，以及激活或停用它们的选项。它提供与 <code>nm-applet</code> 类似的功能。</li>
<li><code>hostname</code>：设置系统主机名。</li>
</ul>
<p>与上述活动相对应，<code>nmtui</code> 还附带了名为 <code>nmtui-edit</code>、<code>nmtui-connect</code> 和 <code>nmtui-hostname</code> 的二进制文件，用于跳过活动的选择。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmtui-edit     等效于  nmtui edit  &#123;name | <span class="built_in">id</span>&#125;</span><br><span class="line">nmtui-connect  等效于  nmtui connect  &#123;name | uuid | device | SSID&#125;</span><br><span class="line">nmtui-hostname 等效于  nmtui hostname</span><br></pre></td></tr></table></figure>



<h2 id="示例-206"><a href="#示例-206" class="headerlink" title="示例"></a>示例</h2><p>通过命令行启动 nmtui 程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nmtui</span><br></pre></td></tr></table></figure>



<p>可以看到如下字符窗口，你可以根据提示通过键盘操作。</p>
<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/nmtui-screenshot.png" alt="img"></p>
<h1 id="Linux-socat-命令-双向数据传输工具"><a href="#Linux-socat-命令-双向数据传输工具" class="headerlink" title="Linux socat 命令 - 双向数据传输工具"></a>Linux socat 命令 - 双向数据传输工具</h1><h2 id="介绍-206"><a href="#介绍-206" class="headerlink" title="介绍"></a>介绍</h2><p><strong>socat</strong>（英文全拼：Socket CAT）是 Linux 下的一个多功能的网络工具，其功能与有瑞士军刀之称的 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/netcat/">Netcat</a> 类似，可以看作是 Netcat 的加强版。socat 的主要特点就是在两个数据流之间建立通道，这些数据通道包含文件、管道、设备（终端或调制解调器等）、Socket、SSL、SOCKS4 客户端或代理 CONNECT。</p>
<p>socat 支持众多协议和链接方式，如 IP、TCP、 UDP、IPv6、PIPE、EXEC、System、Open、Proxy、Openssl、Socket 等。支持广播和多播、抽象 Unix sockets、Linux tun&#x2F;tap、GNU readline 和 PTY，并提供了分叉、记录和进程间通信的不同模式。</p>
<p>项目网址：<a target="_blank" rel="noopener" href="http://www.dest-unreach.org/socat/">http://www.dest-unreach.org/socat/</a></p>
<p>socat 命令由 socat 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install socat</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat [options] &lt;address&gt; &lt;address&gt;</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-V</code> ：显示版本信息及特性。</li>
<li><code>-h|-?</code> ：显示帮助信息，包括选项（options）和地址（addresses）。</li>
<li><code>-hh</code> ：与 -h 类似，但会列出所有通用的地址选项名称。</li>
<li><code>-hhh</code> ：与 -hh 类似，但会列出所有可用的地址选项名称。</li>
<li><code>-d[ddd]</code> ：增加详细程度（最多使用 4 次，建议使用 2 次）。</li>
<li><code>-D</code> ：在循环之前分析文件描述符。</li>
<li><code>-ly[facility]</code> ：将日志输出到 syslog 系统日志（默认使用守护进程）。</li>
<li><code>-lf&lt;logfile&gt;</code> ：将日志输出到文件。</li>
<li><code>-ls</code> ：将日志输出到标准错误 stderr（如果没有指定其他日志，则默认使用 stderr）。</li>
<li><code>-lm[facility]</code> ：混合日志模式（初始化期间使用标准错误 stderr，之后使用系统日志 syslog）。</li>
<li><code>-lp&lt;progname&gt;</code> ：设置用于日志记录的程序名称。</li>
<li><code>-lu</code> ：使用微秒记录日志时间戳。</li>
<li><code>-lh</code> ：在日志信息中添加主机名称。</li>
<li><code>-v</code> ：详细的数据流量，文本格式。</li>
<li><code>-x</code> ：详细数据流量，十六进制格式。</li>
<li><code>-b&lt;size_t&gt;</code> ：设置数据缓冲区大小（默认 8192）。</li>
<li><code>-s</code> ：马虎模式（出错时继续执行）。</li>
<li><code>-t&lt;timeout&gt;</code> ：在关闭第二个频道之前等待几秒钟。</li>
<li><code>-T&lt;timeout&gt;</code> ：总的不活动（inactivity ）超时时间（以秒为单位）。</li>
<li><code>-u</code> ：单向模式（从左到右）。</li>
<li><code>-U</code> ：单向模式（从右到左）。</li>
<li><code>-g</code> ：不检查选项组。</li>
<li><code>-L &lt;lockfile&gt;</code> ：尝试获取锁，否则失败。</li>
<li><code>-W &lt;lockfile&gt;</code> ：尝试获取锁，否则等待。</li>
<li><code>-4</code> ：如果未明确指定版本，则首选 IPv4。prefer IPv4 if version is not explicitly specified</li>
<li><code>-6</code> ：如果未明确指定版本，则首选 IPv6。prefer IPv6 if version is not explicitly specified</li>
</ul>
<p><strong>参数</strong>：address 参数用于提供数据通道的必要信息，不同类型的数据通道有不同的地址参数。下列列出几种模式：</p>
<ul>
<li><code>-</code> <code>STDIN</code> <code>STDOUT</code> ：表示标准输入输出，可以就用一个横杠代替。</li>
<li><code>/var/log/syslog</code> ：也可以是任意路径，如果是相对路径要使用 <code>./</code>，打开一个文件作为数据流。</li>
<li><code>TCP:127.0.0.1:1080</code> ：建立一个 TCP 连接作为数据流，TCP 也可以替换为 UDP。</li>
<li><code>TCP-LISTEN:12345</code> ：建立 TCP 监听端口，TCP 也可以替换为 UDP。</li>
<li><code>EXEC:/bin/bash</code> ：执行一个程序作为数据流。</li>
</ul>
<h2 id="示例-207"><a href="#示例-207" class="headerlink" title="示例"></a>示例</h2><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>通过 socat 读取一个本地的文件，并在终端显示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat - /etc/sysctl.conf</span><br></pre></td></tr></table></figure>



<p>通过 socat 将一段文本写入一个本地文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello GetIoT.tech&quot;</span> | socat - /tmp/hello.txt</span><br></pre></td></tr></table></figure>



<h3 id="虚拟串口"><a href="#虚拟串口" class="headerlink" title="虚拟串口"></a>虚拟串口</h3><p>创建两个可以相互通信的 Linux 虚拟串口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ socat -d -d PTY PTY</span><br><span class="line">2026/07/15 05:29:51 socat[1533] N PTY is /dev/pts/0</span><br><span class="line">2026/07/15 05:29:51 socat[1533] N PTY is /dev/pts/1</span><br><span class="line">2026/07/15 05:29:51 socat[1533] N starting data transfer loop with FDs [5,5] and [7,7]</span><br></pre></td></tr></table></figure>



<p>当前产生的虚拟串口为 <code>/dev/pts/0</code> 和 <code>/dev/pts/1</code>，如果想要虚拟的串口一直有效，必须使 socat 一直运行。</p>
<p>可以给 address 字段添加额外参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat -d -d pty,raw,<span class="built_in">echo</span>=0 pty,raw,<span class="built_in">echo</span>=0</span><br></pre></td></tr></table></figure>



<p>接着就可以使用 minicom 打开串口终端进行测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">minicom -D /dev/pts/0 -b 9600    <span class="comment"># 打开一个串口终端</span></span><br><span class="line">minicom -D /dev/pts/1 -b 9600    <span class="comment"># 打开另一个串口终端</span></span><br></pre></td></tr></table></figure>



<p>在 minicom 命令中输入指令，在另一个 minicom 终端就能接收到了。</p>
<h3 id="TCP-通信"><a href="#TCP-通信" class="headerlink" title="TCP 通信"></a>TCP 通信</h3><p>创建服务器端，侦听 2222 端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat – tcp4-listen:2222</span><br></pre></td></tr></table></figure>



<p>查看 2222 端口是否打开</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -pantu | grep :2222</span><br></pre></td></tr></table></figure>



<p>客户端连接到服务器端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat tcp:192.168.1.110:2222</span><br></pre></td></tr></table></figure>



<p>服务端和客户端就能相互通信了</p>
<h3 id="网络管理-1"><a href="#网络管理-1" class="headerlink" title="网络管理"></a>网络管理</h3><p>连接远程端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat - TCP:192.168.1.252:3306</span><br></pre></td></tr></table></figure>



<p>监听一个新端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat TCP-LISTEN:7000 -</span><br></pre></td></tr></table></figure>



<h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p>在实际生产中我们经常会遇到到一个场景就是，用一台机器作为转发服务器，连接 AB 两个网段，将转发服务器的某个端口上的流量转发到 B 网段的某台机器的某个端口，这样 A 网段的服务器就可以通过访问转发服务器上的端口访问到 B 网段的服务器端口。</p>
<p>这样的场景一般在和客户建立专线的连接时候经常用到，一般也可以采用 iptables 做转发，但是比较复杂。socat 可以很轻松的完成这个功能，但是 socat 不支持端口段转发，只适用于单端口或者少量端口。</p>
<h4 id="转发-TCP"><a href="#转发-TCP" class="headerlink" title="转发 TCP"></a>转发 TCP</h4><p>监听 192.168.1.252 网卡的 15672 端口，并将请求转发至 172.17.0.15 的 15672 端口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat -d -d -lf /var/log/socat.log TCP4-LISTEN:15672,<span class="built_in">bind</span>=192.168.1.252,reuseaddr,fork TCP4:172.17.0.15:15672</span><br></pre></td></tr></table></figure>



<p>参数说明：</p>
<ul>
<li>前面两个连续的 <code>-d</code> <code>-d</code> 代表调试信息的输出级别。</li>
<li><code>-lf /var/log/socat.log</code> 指定输出信息的文件保存位置。</li>
<li><code>TCP4-LISTEN:15672</code> 在本地建立一个 TCP IPv4 协议的监听端口，也就是转发端口。这里是 15672，请根据实际情况改成你自己需要转发的端口。</li>
<li><code>bind</code> 指定监听绑定的 IP 地址。</li>
<li><code>reuseaddr</code> 设置本地端口可重复使用。</li>
<li><code>fork TCP4:172.17.0.15:15672</code> 指的是要转发到的服务器 IP 和端口，这里是 172.17.0.15 的 15672 端口。</li>
</ul>
<h4 id="转发-UDP"><a href="#转发-UDP" class="headerlink" title="转发 UDP"></a>转发 UDP</h4><p>转发 UDP 和 TCP 类似，只要把 TCP4 改成 UDP4 就行了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat -d -d -lf /var/log/socat.log UDP4-LISTEN:123,<span class="built_in">bind</span>=192.168.1.252,reuseaddr,fork UDP4:172.17.0.15:123</span><br></pre></td></tr></table></figure>



<h4 id="NAT-映射"><a href="#NAT-映射" class="headerlink" title="NAT 映射"></a>NAT 映射</h4><p>在一个 NAT 网络环境中，也是可以通过 socat 将内部机器端口映射到公网上的。</p>
<p>在外部公网机器上执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat tcp-listen:1234 tcp-listen:3389</span><br></pre></td></tr></table></figure>



<p>在内部私网机器上执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat tcp:outerhost:1234 tcp:192.168.1.34:3389</span><br></pre></td></tr></table></figure>



<p>这样，外部机器上的 3389 就映射在内网 192.168.1.34 的 3389 端口上，实现私网穿透。</p>
<h3 id="文件传递"><a href="#文件传递" class="headerlink" title="文件传递"></a>文件传递</h3><h4 id="文件传送"><a href="#文件传送" class="headerlink" title="文件传送"></a>文件传送</h4><p>将文件 demo.tar.gz 使用 2000 端口从 192.168.1.252 传到 192.168.1.253，文件传输完毕后会自动退出。</p>
<p>在 192.168.1.252 上执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat -u open:demo.tar.gz tcp-listen:2000,reuseaddr</span><br></pre></td></tr></table></figure>



<p>在 192.168.1.253 上执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat -u tcp:192.168.1.252:2000 open:demo.tar.gz,create</span><br></pre></td></tr></table></figure>



<h4 id="读写分流功能"><a href="#读写分流功能" class="headerlink" title="读写分流功能"></a>读写分流功能</h4><p>socat 具有一个独特的读写分流功能，比如：可以实现一个假的 Web Server，客户端连过来之后就把 read.html 里面的内容传过去，同时把客户端的数据保存到 write.txt 里面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat open:read.html\!\!open:write.txt,create,append tcp-listen:8000,reuseaddr,fork</span><br></pre></td></tr></table></figure>



<p>注意：!! 符号用于合并读写流，前面的用于读，后面的用于写。由于 ! 在 Shell 中是特殊字符，所以这里在命令行中使用 \ 对其进行了转义。</p>
<h3 id="本地域套接字"><a href="#本地域套接字" class="headerlink" title="本地域套接字"></a>本地域套接字</h3><p>监听一个 Unix Socket</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat unix-listen:/tmp/unix.socket -</span><br></pre></td></tr></table></figure>



<p>向本地 Unix Socket 发送数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;test&quot;</span> | socat - unix-connect:/tmp/unix.sock</span><br></pre></td></tr></table></figure>



<p>监听本地 Unix Datagram Socket</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat unix-recvfrom:/tmp/unix.dg.sock -</span><br></pre></td></tr></table></figure>



<p>向本地 Unix Datagram Socket 发送数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;test&quot;</span> | socat - unix-sendto:/tmp/unix.dg.sock</span><br></pre></td></tr></table></figure>



<h3 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h3><p>在目标机上弄一个 shell 代理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat TCP-LISTEN:12345 EXEC:/bin/bash</span><br></pre></td></tr></table></figure>



<p>将本地的 UNIX 域套接字转成 TCP socket 供局域网内的机器使用（当有多个 TCP 连上来那就 fork 一个去连接 UNIX 域套接字）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat TCP-LISTEN:12345,reuseaddr,fork UNIX-CONNECT:/data/deCOREIDPS/unix.domain</span><br></pre></td></tr></table></figure>



<p>将本地的 80 端口转到远程服务器的 80 端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat TCP-LISTEN:80,fork TCP:www.getiot.tech:80</span><br></pre></td></tr></table></figure>





<h1 id="Linux-wvdial-命令-PPP-拨号工具"><a href="#Linux-wvdial-命令-PPP-拨号工具" class="headerlink" title="Linux wvdial 命令 - PPP 拨号工具"></a>Linux wvdial 命令 - PPP 拨号工具</h1><h2 id="介绍-207"><a href="#介绍-207" class="headerlink" title="介绍"></a>介绍</h2><p><strong>wvdial</strong> 是一个智能的 PPP 拨号工具，这意味着它会拨打调制解调器并启动 PPP 连接到互联网。wvdial 类似于 chat 程序，不同之处在于它使用启发式方法来猜测如何拨号和登录您的服务器，而不是强迫您编写登录脚本。这里 PPP 的作用是与拨入方协商传输数据的方法并维持该连接。</p>
<p>wvdial 命令由 wvdial 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install wvdial</span><br></pre></td></tr></table></figure>



<p>当 wvdial 启动时，它首先从 &#x2F;etc&#x2F;wvdial.conf 和 ~&#x2F;.wvdialrc 加载其配置，其中包含有关调制解调器端口、速度和初始化字符串等基本信息，以及有关 Internet 服务提供商 (ISP) 的信息，例如：电话号码、您的用户名和密码。然后它会初始化您的调制解调器并拨打服务器并等待连接（来自调制解调器的 CONNECT 字符串）。它理解并响应典型的连接问题（如忙和无拨号）。</p>
<p>连接后的任何时候，如果 wvdial 看到来自服务器的 PPP 序列，它就会启动 PPP。 否则，它会尝试通过执行以下操作来说服服务器启动 PPP：</p>
<ul>
<li>响应它看到的任何登录名&#x2F;密码提示；</li>
<li>解释“选择以下之一”风格的菜单；</li>
<li>最终，发送单词“ppp”（一个常见的终端服务器命令）。</li>
</ul>
<p>如果这些尝试都失败了，wvdial 只会运行 pppd 命令，并希望一切顺利。它将启动连接，然后耐心等待您按 Ctrl + C 删除链接。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wvdial [ OPTIONS ] [ SECTION ] ...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-c</code>, <code>--chat</code> ：在 pppd 中运行 wvdial 作为聊天替换，而不是让 wvdial 协商连接然后调用 pppd 的更正常的方法。</li>
<li><code>-C</code>, <code>--config=CONFIGFILE</code> ：使用 <code>CONFIGFILE</code> 作为配置文件运行 wvdial，而不是 &#x2F;etc&#x2F;wvdial.conf。该选项主要用在当您希望为每个用户单独添加配置，或者想避免在系统范围的配置文件中包含拨号信息（用户名、密码、电话卡号码等）的时候。</li>
<li><code>-n</code>, <code>--no-syslog</code> ：不要将调试信息输出到 syslog 守护进程（仅与 –chat 一起使用时有效）。</li>
<li><code>--help</code> ：显示帮助信息。</li>
<li><code>--version</code> ：显示版本信息。</li>
</ul>
<p><strong>参数</strong>：</p>
<p>参数 <code>SECTION</code> 是配置文件（类似 windows 里的 ini 文件）中的某一段，一个 wvdial.conf 配置文件可以有好多个 section，每一个 section 由一些变量组成，可以使用 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/wvdialconf/">wvdialconf</a> 命令自动生成配置文件。</p>
<p>wvdial 通常在没有命令行选项的情况下运行，在这种情况下，它从 &#x2F;etc&#x2F;wvdial.conf 的 <code>[Dialer Defaults]</code> 部分读取其配置。关于配置文件的详细说明，可以通过 <code>man wvdial.conf</code> 命令获取。下面是一个 wvdial.conf 配置文件的示例：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Dialer Defaults]</span></span><br><span class="line"><span class="attr">Modem</span> = /dev/ttyS2</span><br><span class="line"><span class="attr">Baud</span> = <span class="number">57600</span></span><br><span class="line"><span class="attr">Init</span> = ATZ</span><br><span class="line"><span class="attr">Init2</span> = AT S11=<span class="number">50</span></span><br><span class="line"><span class="attr">Phone</span> = <span class="number">555</span>-<span class="number">4242</span></span><br><span class="line"><span class="attr">Username</span> = apenwarr</span><br><span class="line"><span class="attr">Password</span> = my-password</span><br><span class="line"></span><br><span class="line"><span class="section">[Dialer phone2]</span></span><br><span class="line"><span class="attr">Phone</span> = <span class="number">555</span>-<span class="number">4243</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Dialer shh]</span></span><br><span class="line"><span class="attr">Init3</span> = ATM0</span><br><span class="line"></span><br><span class="line"><span class="section">[Dialer pulse]</span></span><br><span class="line">Dial <span class="attr">Command</span> = ATDP</span><br></pre></td></tr></table></figure>



<h2 id="示例-208"><a href="#示例-208" class="headerlink" title="示例"></a>示例</h2><p>从 &#x2F;etc&#x2F;wvdial.conf 配置文件中读取 <code>[Dialer phone2]</code> 的选项参数进行拨号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wvdial phone2</span><br></pre></td></tr></table></figure>



<p>提示：该命令将首先读取 <code>[Dialer Defaults]</code> 部分的默认选项（如果有），然后再从 <code>[Dialer phone2]</code> 部分中找到的覆盖默认选项的所有选项。可以在命令行中指定 &#x2F;etc&#x2F;wvdial.conf 的一个或多个 SECTION。如果指定了多个部分，则将按照给定的顺序处理它们，每个部分将覆盖它之前的所有部分。</p>
<p>例如，下面命令将先从 <code>[Dialer Defaults]</code> 部分读取默认选项，然后使用在 <code>[Dialer phone2]</code> 部分中找到的选项覆盖任何或所有选项，然后是 <code>[Dialer pulse]</code> 部分，最后是 <code>[Dialer shh]</code> 部分。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wvdial phone2 pulse shh</span><br></pre></td></tr></table></figure>



<p>使用这种方法，就可以轻松地配置 wvdial 以在不同的 Internet 提供商、调制解调器初始化字符串、帐户名称等之间切换，而无需一遍又一遍地指定相同的配置信息。</p>
<h1 id="Linux-wvdialconf-命令-配置调制解调器"><a href="#Linux-wvdialconf-命令-配置调制解调器" class="headerlink" title="Linux wvdialconf 命令 - 配置调制解调器"></a>Linux wvdialconf 命令 - 配置调制解调器</h1><h2 id="介绍-208"><a href="#介绍-208" class="headerlink" title="介绍"></a>介绍</h2><p><strong>wvdialconf</strong> 命令用于为 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/wvdial/">wvdial</a> 生成一个配置文件，默认为 &#x2F;etc&#x2F;wvdial.conf。通常在首次安装 wvdial 工具，还没有配置文件时使用。</p>
<p>wvdialconf 会检测 Linux 系统当前接入的调制解调器，获取最大波特率和初始化字符串信息，并根据这些信息生成或更新 wvdial 配置文件。</p>
<p>注意：wvdialconf 是完全非交互式的。意味着您仍然需要编辑 &#x2F;etc&#x2F;wvdial.conf 以指定 Internet 帐户的电话号码、登录名和密码，才能让 wvdial 正常工作。</p>
<h2 id="示例-209"><a href="#示例-209" class="headerlink" title="示例"></a>示例</h2><p>插入 modem，执行下面命令生成 wvdial 配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> wvdialconf</span><br></pre></td></tr></table></figure>



<p>或者指定文件名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> wvdialconf /etc/wvdial.conf</span><br></pre></td></tr></table></figure>



<p>执行完成后，会生成 <code>/etc/wvdial.conf</code> 文件，内容如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Dialer Defaults]</span></span><br><span class="line"><span class="attr">Init2</span> = ATQ0 V1 E1 S0=<span class="number">0</span> &amp;C1 &amp;D2 +FCLASS=<span class="number">0</span></span><br><span class="line">Modem <span class="attr">Type</span> = Analog Modem</span><br><span class="line"><span class="comment">; Phone = &lt;Target Phone Number&gt;</span></span><br><span class="line"><span class="attr">ISDN</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">; Username = &lt;Your Login Name&gt;</span></span><br><span class="line"><span class="attr">Init1</span> = ATZ</span><br><span class="line"><span class="comment">; Password = &lt;Your Password&gt;</span></span><br><span class="line"><span class="attr">Modem</span> = /dev/ttyUSB2</span><br><span class="line"><span class="attr">Baud</span> = <span class="number">9600</span></span><br></pre></td></tr></table></figure>





<h1 id="Linux-networkctl-命令-查询控制网络状态"><a href="#Linux-networkctl-命令-查询控制网络状态" class="headerlink" title="Linux networkctl 命令 - 查询控制网络状态"></a>Linux networkctl 命令 - 查询控制网络状态</h1><h2 id="介绍-209"><a href="#介绍-209" class="headerlink" title="介绍"></a>介绍</h2><p><strong>networkctl</strong>（英文全拼：network control）用于查询和控制 Linux 网络子系统，比如查看网络设备及其连接状态的摘要。</p>
<p>networkctl 是新版本 systemd 命令集中的命令之一，对应 systemd-networkd 服务。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">networkctl [OPTIONS...] COMMAND [LINK...]</span><br></pre></td></tr></table></figure>



<p><strong>命令</strong>：</p>
<ul>
<li><code>list [PATTERN...]</code> ：列出存在的连接及其状态。若未指定连接(LINK)则显示所有连接， 否则仅显示指定的连接。</li>
<li><code>status [PATTERN...]</code> ：显示连接的各种信息，包括类型、状态、内核模块、MAC 地址、IP 地址、DNS 服务器等等。</li>
<li><code>lldp [PATTERN...]</code> ：显示已发现的 LLDP（Link Layer Discovery Protocol）邻居。若未指定连接，则显示所有连接上发现的邻居，否则仅显示指定连接上发现的邻居。</li>
<li><code>label</code> ：显示以数字形式表示的地址标签，可用于地址选择。</li>
<li><code>delete DEVICES...</code> ：删除虚拟网卡设备。</li>
<li><code>renew DEVICES...</code> ：更新动态配置。</li>
<li><code>reconfigure DEVICES...</code> ：重新配置接口。</li>
<li><code>reload</code> ：重新加载 .network 和 .netdev 文件。</li>
</ul>
<p><strong>选项</strong>：</p>
<ul>
<li><code>--no-pager</code> ：不将程序的输出内容（通过 pipe）给分页程序。</li>
<li><code>--no-legend</code> ：不输出列标题，也就是不在输出列表的头部和尾部显示字段的名称。</li>
<li><code>-a</code>, <code>--all</code> ：显示所有连接的状态。</li>
<li><code>-s</code>, <code>--stats</code> ：显示详细的链接统计信息。</li>
<li><code>-l</code>, <code>--full</code> ：不要省略输出。</li>
<li><code>-n</code>, <code>--lines=INTEGER</code> ：要显示的日记数目。</li>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息。</li>
<li><code>--version</code> ：显示 systemd 软件包的版本信息。</li>
</ul>
<h2 id="示例-210"><a href="#示例-210" class="headerlink" title="示例"></a>示例</h2><p>列出所有连接及其状态，相当于 <code>networkctl list</code> 或 <code>networkctl -a</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ networkctl</span><br><span class="line">IDX LINK TYPE     OPERATIONAL SETUP</span><br><span class="line">  1 lo   loopback carrier     unmanaged</span><br><span class="line">  2 eth0 ether    routable    unmanaged</span><br><span class="line">  3 eth1 ether    no-carrier  unmanaged</span><br><span class="line">  4 ppp0 ppp      routable    unmanaged</span><br><span class="line"></span><br><span class="line">4 links listed.</span><br></pre></td></tr></table></figure>



<p>显示连接的状态信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ networkctl status</span><br><span class="line">*   State: routable</span><br><span class="line">  Address: 192.168.31.223 on eth0</span><br><span class="line">           10.106.236.134 on ppp0</span><br><span class="line">           fe80::a897:4bff:fe16:c0a6 on eth0</span><br><span class="line">  Gateway: 192.168.30.1 on eth0</span><br></pre></td></tr></table></figure>



<p>显示网络接口 eth0 的各种信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ networkctl status eth0</span><br><span class="line">* 2: eth0</span><br><span class="line">             Link File: n/a</span><br><span class="line">          Network File: n/a</span><br><span class="line">                  Type: ether</span><br><span class="line">                 State: routable (unmanaged)</span><br><span class="line">                  Path: platform-30be0000.ethernet</span><br><span class="line">                Driver: fec</span><br><span class="line">            HW Address: aa:97:4b:16:c0:a6</span><br><span class="line">                   MTU: 1500 (min: 68, max: 1500)</span><br><span class="line">  Queue Length (Tx/Rx): 3/3</span><br><span class="line">      Auto negotiation: <span class="built_in">yes</span></span><br><span class="line">                 Speed: 100Mbps</span><br><span class="line">                Duplex: full</span><br><span class="line">                  Port: mii</span><br><span class="line">               Address: 192.168.31.223</span><br><span class="line">                        fe80::a897:4bff:fe16:c0a6</span><br><span class="line">               Gateway: 192.168.30.1</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ss-命令-显示套接字统计信息"><a href="#Linux-ss-命令-显示套接字统计信息" class="headerlink" title="Linux ss 命令 - 显示套接字统计信息"></a>Linux ss 命令 - 显示套接字统计信息</h1><h2 id="介绍-210"><a href="#介绍-210" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ss</strong>（英文全拼：socket statistics）命令用于获取 socket 统计信息，其输出的结果类似于 netstat 输出的内容，但能显示更多、更详细的 TCP 连接状态的信息，而且比 netstat 更快速高效。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ss [options] [ FILTER ]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息。</li>
<li><code>-V</code>, <code>--version</code> ：显示版本信息。</li>
<li><code>-n</code>, <code>--numeric</code> ：不解析服务名称。</li>
<li><code>-r</code>, <code>--resolve</code> ：解析主机名。</li>
<li><code>-a</code>, <code>--all</code> ：显示所有套接字（sockets）。</li>
<li><code>-l</code>, <code>--listening</code> ：显示监听状态的套接字。</li>
<li><code>-o</code>, <code>--options</code> ：显示计时器信息。</li>
<li><code>-e</code>, <code>--extended</code> ：显示详细的套接字信息。</li>
<li><code>-m</code>, <code>--memory</code> ：显示套接字的内存使用情况。</li>
<li><code>-p</code>, <code>--processes</code> ：显示使用套接字的进程。</li>
<li><code>-i</code>, <code>--info</code> ：显示 TCP 内部信息。</li>
<li><code>-s</code>, <code>--summary</code> ：显示套接字使用概况。</li>
<li><code>-4</code>, <code>--ipv4</code> ：仅显示 IPv4 的套接字。</li>
<li><code>-6</code>, <code>--ipv6</code> ：仅显示 IPv6 的套接字。</li>
<li><code>-0</code>, <code>--packet</code> ：显示 PACKET 套接字。</li>
<li><code>-t</code>, <code>--tcp</code> ：仅显示 TCP 套接字。</li>
<li><code>-u</code>, <code>--udp</code> ：仅显示 UCP 套接字。</li>
<li><code>-d</code>, <code>--dccp</code> ：仅显示 DCCP 套接字。</li>
<li><code>-w</code>, <code>--raw</code> ：仅显示 RAW 套接字。</li>
<li><code>-x</code>, <code>--unix</code> ：仅显示 UNIX 套接字。</li>
<li><code>-f</code>, <code>--family=FAMILY</code> ：显示 FAMILY 类型的套接字，FAMILY 可选 unix、inet、inet6、link、netlink、vsock、xdp。</li>
<li><code>-A</code>, <code>--query=QUERY</code>, <code>--socket=QUERY</code> ：QUERY 可选 all、inet、tcp、udp、raw、unix、packet、netlink 等。</li>
<li><code>-D</code>, <code>--diag=FILE</code> ：将原始 TCP 套接字信息转储到文件 FILE。</li>
<li><code>-F</code>, <code>--filter=FILE</code> ：从文件 FILE 中读取过滤器信息。</li>
</ul>
<p><strong>参数</strong>：<code>FILTER</code>（可选），过滤器表达式。</p>
<h2 id="示例-211"><a href="#示例-211" class="headerlink" title="示例"></a>示例</h2><p>显示所有 TCP 套接字</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ss -t -a</span><br></pre></td></tr></table></figure>



<p>显示所有带有进程 SELinux 安全上下文的 TCP 套接字</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ss -t -a -Z</span><br></pre></td></tr></table></figure>



<p>显示所有 UDP 套接字</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ss -u -a</span><br></pre></td></tr></table></figure>



<p>显示所有已建立的 ssh 连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ss -o state established &#x27;( dport = :ssh or sport = :ssh )&#x27;</span><br></pre></td></tr></table></figure>



<p>查找所有连接到 X 服务器的本地进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ss -x src /tmp/.X11-unix/*</span><br></pre></td></tr></table></figure>



<p>列出我们的 apache 到网络 193.233.7&#x2F;24 的状态为 FIN-WAIT-1 的所有 tcp 套接字并查看它们的计时器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ss -o state fin-wait-1 &#x27;( sport = :http or sport = :https )&#x27; dst 193.233.7/24</span><br></pre></td></tr></table></figure>



<p>列出所有套接字表中所有状态的套接字（但 TCP 除外）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ss -a -A &#x27;all,!tcp&#x27;</span><br></pre></td></tr></table></figure>





<h1 id="Linux-lsusb-命令-列出-USB-设备信息"><a href="#Linux-lsusb-命令-列出-USB-设备信息" class="headerlink" title="Linux lsusb 命令 - 列出 USB 设备信息"></a>Linux lsusb 命令 - 列出 USB 设备信息</h1><h2 id="介绍-211"><a href="#介绍-211" class="headerlink" title="介绍"></a>介绍</h2><p><strong>lsusb</strong> 命令用于显示当前主机的 USB 设备列表，以及 USB 设备的详细信息。</p>
<p>lsusb 命令由 usbutils 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install usbutils</span><br></pre></td></tr></table></figure>



<p>lsusb 命令是一个学习 USB 驱动开发，认识 USB 设备的助手，推荐大家使用！</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsusb [ options ]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-v</code> ：显示 USB 设备的详细信息。</li>
<li><code>-s [[bus]:][devnum]</code> ：仅显示指定的总线和（或）设备号的设备。</li>
<li><code>-d [vendor]:[product]</code> ：仅显示指定厂商和产品编号的设备。</li>
<li><code>-D device</code> ：显示指定 device 的信息，而不使用预设的 &#x2F;dev&#x2F;bus&#x2F;usb 目录。</li>
<li><code>-t</code> ：以树状结构显示物理 USB 设备的层次，可与 <code>v</code> 选项一起使用以显示详细信息。</li>
<li><code>-V</code> ：显示命令的版本信息。</li>
</ul>
<h2 id="示例-212"><a href="#示例-212" class="headerlink" title="示例"></a>示例</h2><p>插入 usb 鼠标后执行 lsusb 查看当前设备列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lsusb</span><br><span class="line">Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub</span><br><span class="line">Bus 003 Device 005: ID 0424:2840 Standard Microsystems Corp.</span><br><span class="line">Bus 003 Device 004: ID 10c4:ea71 Cygnal Integrated Products, Inc.</span><br><span class="line">Bus 003 Device 002: ID 0424:2806 Standard Microsystems Corp. USB2806 Smart Hub</span><br><span class="line">Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br><span class="line">Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub</span><br><span class="line">Bus 001 Device 006: ID 1c4f:0034 SiGma Micro Usb Mouse</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br></pre></td></tr></table></figure>



<p>说明：</p>
<ul>
<li><strong>Bus 004</strong> 表示第四个 usb 主控制器（机器上总共有四个 usb 主控制器，可以通过命令 <code>lspci | grep USB</code> 查看）。</li>
<li><strong>Device 006</strong> 表示系统给 usb 鼠标分配的设备号（devnum），同时也可以看到该鼠标是插入到了第一个 usb 主控制器。</li>
<li><strong>ID 1c4f:0034</strong> 表示 usb 设备的 ID（这个 ID 由芯片制造商设置，可以唯一表示该设备）。可在 <code>/sys/devices/pci0000:00/0000:[&lt;bus&gt;]:][&lt;slot&gt;][.[&lt;func&gt;]/usbx/x-x/</code> 目录下查看 devnum、idVendor、idProduct 等信息。</li>
</ul>
<p>以树状形式查看 USB 设备列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lsusb -t</span><br><span class="line">/:  Bus 04.Port 1: Dev 1, Class=root_hub, Driver=xhci-hcd/1p, 5000M</span><br><span class="line">/:  Bus 03.Port 1: Dev 1, Class=root_hub, Driver=xhci-hcd/1p, 480M</span><br><span class="line">    |__ Port 1: Dev 2, If 0, Class=Hub, Driver=hub/7p, 480M</span><br><span class="line">        |__ Port 5: Dev 4, If 1, Class=Vendor Specific Class, Driver=cp210x, 12M</span><br><span class="line">        |__ Port 5: Dev 4, If 2, Class=Vendor Specific Class, Driver=cp210x, 12M</span><br><span class="line">        |__ Port 5: Dev 4, If 0, Class=Vendor Specific Class, Driver=cp210x, 12M</span><br><span class="line">        |__ Port 5: Dev 4, If 3, Class=Vendor Specific Class, Driver=cp210x, 12M</span><br><span class="line">        |__ Port 7: Dev 5, If 0, Class=Vendor Specific Class, Driver=, 480M</span><br><span class="line">/:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=xhci-hcd/1p, 5000M</span><br><span class="line">/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=xhci-hcd/1p, 480M</span><br><span class="line">    |__ Port 1: Dev 7, If 0, Class=Human Interface Device, Driver=usbhid, 1.5M</span><br></pre></td></tr></table></figure>



<p>每一行末尾的数字表示 USB 类型的传输速率，例如：</p>
<ul>
<li>12M 意味着 USB 1.0&#x2F;1.1 的速率是 12Mbit&#x2F;s</li>
<li>480M 意味着 USB 2.0 的速率是 480Mbit&#x2F;s</li>
<li>5000M 意味着 USB 3.0 的速率是 5Gbit&#x2F;s</li>
</ul>
<h1 id="Linux-lspci-命令-列出-PCI-设备信息"><a href="#Linux-lspci-命令-列出-PCI-设备信息" class="headerlink" title="Linux lspci 命令 - 列出 PCI 设备信息"></a>Linux lspci 命令 - 列出 PCI 设备信息</h1><h2 id="介绍-212"><a href="#介绍-212" class="headerlink" title="介绍"></a>介绍</h2><p><strong>lspci</strong> 命令用于显示当前主机的所有 PCI 总线信息，以及所有已连接的 PCI 设备信息。</p>
<p>lspci 命令由 pciutils 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install pciutils</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lspci [options]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><p><code>-n</code> ：以数字方式显示 PCI 生产厂商和设备代码。</p>
</li>
<li><p><code>-t</code> ：以树状结构显示 PCI 设备的层次关系，包括所有的总线、桥、设备以及它们之间的联接。</p>
</li>
<li><p><code>-b</code> ：以总线为中心的视图。显示所有 IRQ 号和记忆体地址，就像 PCI 总线上的卡看到的一样，而不是系统内核看到的内容。</p>
</li>
<li><p><code>-d [&lt;vendor&gt;]:[&lt;device&gt;]</code> ：仅显示给定厂商和设备的信息。这两个 ID 都以十六进制表示，可以忽略或者以「<code>*</code>」代替（意味著所有值）。</p>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-s [[&lt;bus&gt;]:][&lt;slot&gt;][.[&lt;func&gt;]]</span><br></pre></td></tr></table></figure>

<p>：仅显示指定总线、插槽上的设备和设备上的功能块信息。设备地址的任何部分都可以忽略，或以「</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*</span><br></pre></td></tr></table></figure>

<p>」代替（意味著所有值）。所有数字都是十六进制，例如：</p>
<ul>
<li>「<code>0:</code>」指的是在0号总线上的所有设备；</li>
<li>「<code>0</code>」指的是在任意总线上0号设备的所有功能块；</li>
<li>「<code>0.3</code>」选择 了所有总线上0号设备的第三个功能块；</li>
<li>「<code>.4</code>」则是只列出每一设备上的第四个功能块。</li>
</ul>
</li>
<li><p><code>-i &lt;file&gt;</code> ：指定 PCI 编号列表文件，而不使用默认的文件。</p>
</li>
<li><p><code>-p &lt;dir&gt;</code> ：指定包含 PCI 总线信息的目录，而不使用预设的目录 &#x2F;proc&#x2F;bus&#x2F;pci。</p>
</li>
<li><p><code>-m</code> ：以机器可读方式显示 PCI 设备信息。</p>
</li>
<li><p><code>-M</code> ：使用总线映射模式，这种模式对总线进行全面地扫描以查明总线上的所有设备，包括配置错误的桥之后的设备。请注意，此操作只应在调试时使用，并可能造成系统崩溃（只在设备有错误的时候，但是不幸的是它们存在），此命令只有 root 可以使用。同时，在不直接接触硬件的 PCI 访问模式中使用 <code>-M</code> 参数没有意义，因为显示的结果（排除 lspci 中的 bug 的影响）与普通的列表模式相同。</p>
</li>
<li><p><code>-x</code> ：以十六进制显示 PCI 配置空间（configuration space）的前64个字节映像（标准头部信息）。此参数对调试驱动和 lspci 本身很有用。</p>
</li>
<li><p><code>-v</code> ：使得 lspci 以冗余模式显示所有设备的详细信息。</p>
</li>
<li><p><code>-vv</code> ：使得 lspci 以过冗余模式显示更详细的信息（事实上是 PCI 设备能给出的所有东西）。这些数据的确切意义没有在此手册页中解释，如果你想知道更多，请参照 &#x2F;usr&#x2F;include&#x2F;linux&#x2F;pci.h 或者 PCI 规范。</p>
</li>
</ul>
<h2 id="示例-213"><a href="#示例-213" class="headerlink" title="示例"></a>示例</h2><p>不必添加任何选项，就能够显示出目前的硬件配备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation Haswell-ULT DRAM Controller (rev 0b)</span><br><span class="line">00:02.0 VGA compatible controller: Intel Corporation Haswell-ULT Integrated Graphics Controller (rev 0b)</span><br><span class="line">00:03.0 Audio device: Intel Corporation Haswell-ULT HD Audio Controller (rev 0b)</span><br><span class="line">00:14.0 USB controller: Intel Corporation 8 Series USB xHCI HC (rev 04)</span><br><span class="line">00:16.0 Communication controller: Intel Corporation 8 Series HECI <span class="comment">#0 (rev 04)</span></span><br><span class="line">00:19.0 Ethernet controller: Intel Corporation Ethernet Connection I218-V (rev 04)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p>查看一般详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lspci -v</span><br><span class="line">00:00.0 Host bridge: Intel Corporation Haswell-ULT DRAM Controller (rev 0b)</span><br><span class="line">        Subsystem: Lenovo Haswell-ULT DRAM Controller</span><br><span class="line">        Flags: bus master, fast devsel, latency 0</span><br><span class="line">        Capabilities: &lt;access denied&gt;</span><br><span class="line">        Kernel driver <span class="keyword">in</span> use: hsw_uncore</span><br><span class="line"></span><br><span class="line">00:02.0 VGA compatible controller: Intel Corporation Haswell-ULT Integrated Graphics Controller (rev 0b) (prog-if 00 [VGA controller])</span><br><span class="line">        Subsystem: Lenovo Haswell-ULT Integrated Graphics Controller</span><br><span class="line">        Flags: bus master, fast devsel, latency 0, IRQ 49</span><br><span class="line">        Memory at d0000000 (64-bit, non-prefetchable) [size=4M]</span><br><span class="line">        Memory at c0000000 (64-bit, prefetchable) [size=256M]</span><br><span class="line">        I/O ports at 5000 [size=64]</span><br><span class="line">        Expansion ROM at 000c0000 [virtual] [disabled] [size=128K]</span><br><span class="line">        Capabilities: &lt;access denied&gt;</span><br><span class="line">        Kernel driver <span class="keyword">in</span> use: i915</span><br><span class="line">        Kernel modules: i915</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p>查看网卡详细信息（-s 后面接的是每个设备的总线、插槽与相关函数功能）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lspci -s 00:19.0 -vv</span><br><span class="line">00:19.0 Ethernet controller: Intel Corporation Ethernet Connection I218-V (rev 04)</span><br><span class="line">        Subsystem: Lenovo Ethernet Connection I218-V</span><br><span class="line">        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx+</span><br><span class="line">        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-</span><br><span class="line">        Latency: 0</span><br><span class="line">        Interrupt: pin A routed to IRQ 44</span><br><span class="line">        Region 0: Memory at d0700000 (32-bit, non-prefetchable) [size=128K]</span><br><span class="line">        Region 1: Memory at d073e000 (32-bit, non-prefetchable) [size=4K]</span><br><span class="line">        Region 2: I/O ports at 5080 [size=32]</span><br><span class="line">        Capabilities: &lt;access denied&gt;</span><br><span class="line">        Kernel driver <span class="keyword">in</span> use: e1000e</span><br><span class="line">        Kernel modules: e1000e</span><br></pre></td></tr></table></figure>



<p>查看网卡的厂商和设备代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lspci -nn | grep Eth</span><br><span class="line">00:19.0 Ethernet controller [0200]: Intel Corporation Ethernet Connection I218-V [8086:1559] (rev 04)</span><br></pre></td></tr></table></figure>





<h1 id="Linux-lshw-命令-列出硬件配置详细信息"><a href="#Linux-lshw-命令-列出硬件配置详细信息" class="headerlink" title="Linux lshw 命令 - 列出硬件配置详细信息"></a>Linux lshw 命令 - 列出硬件配置详细信息</h1><h2 id="介绍-213"><a href="#介绍-213" class="headerlink" title="介绍"></a>介绍</h2><p><strong>lshw</strong>（英文全拼：list hardware）命令用于检查硬件组件及其核心配置。它能为我们提供内存配置、固件版本、主板配置信息、CPU 版本和速度、cache 信息、总线速度等硬件信息。</p>
<p>lshw 不仅是一个可以查看硬件信息的工具，它还可以用来做一些硬件的 benchmark，用于评估计算机硬件的性能特征。lshw 工具其实就是读取 &#x2F;proc 里面的一些文件来显示相关的信息，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/proc/cpuinfo  <span class="comment"># 显示CPU信息</span></span><br><span class="line">/proc/bus/pci  <span class="comment"># 显示pci信息</span></span><br><span class="line">/proc/scsi     <span class="comment"># 显示scsi信息</span></span><br><span class="line">/proc/net/dev  <span class="comment"># 显示网络设备信息</span></span><br><span class="line">/proc/kcore    <span class="comment"># 从内存映像读取相关信息</span></span><br><span class="line">/proc/ide      <span class="comment"># 显示IDE设备信息</span></span><br><span class="line">/proc/devices</span><br><span class="line">/proc/mounts</span><br><span class="line">/proc/fstab</span><br></pre></td></tr></table></figure>



<p>lshw 工具适用于所有 Linux 发行版，包括 Redhat、Centos、Ubuntu、Debian、Arch Linux 等。如果您的系统没有 lshw 命令，例如在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install lshw</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lshw [-format] [-options ...]</span><br></pre></td></tr></table></figure>



<p><strong>格式</strong>：</p>
<ul>
<li><code>-html</code> ：将硬件设备树输出为 HTML 格式</li>
<li><code>-xml</code> ：将硬件设备树输出为 XML 格式</li>
<li><code>-json</code> ：将硬件设备树输出为 JSON 格式</li>
<li><code>-short</code> ：输出硬件路径</li>
<li><code>-businfo</code> ：输出显示总线信息的设备列表，详细说明 SCSI、USB、IDE 和 PCI 地址</li>
</ul>
<p><strong>选项</strong>：</p>
<ul>
<li><code>-c | -C | -class CLASS</code> ：仅显示给定的硬件类别信息，可以使用 <code>lshw -short</code> 或 <code>lshw -businfo</code> 找到 class。</li>
<li><code>-enable TEST</code> ：启动一个测试（如 pci、isapnp、cpuid 等）</li>
<li><code>-disable TEST</code> ：关闭一个测试（如 pci、isapnp、cpuid 等）</li>
<li><code>-quiet</code> ：不显示状态</li>
<li><code>-sanitize</code> ：清理输出（删除敏感信息，如序列号等）</li>
<li><code>-numeric</code> ：输出数字 ID（适用于 PCI 和 USB 等）</li>
<li><code>-notime</code> ：从输出中排除经常改变的属性（如时间戳）</li>
</ul>
<h2 id="示例-214"><a href="#示例-214" class="headerlink" title="示例"></a>示例</h2><p>显示硬件设备列表，输出包括设备路径（path）、类别（class）以及简单描述：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">debian@npi:~$ <span class="built_in">sudo</span> lshw -short</span><br><span class="line">H/W path  Device  Class      Description</span><br><span class="line">========================================</span><br><span class="line">                  system     Seeed NPi STM32MP157C Board</span><br><span class="line">/0                bus        Motherboard</span><br><span class="line">/0/0              processor  cpu</span><br><span class="line">/0/1              processor  cpu</span><br><span class="line">/0/2              memory     429MiB System memory</span><br><span class="line">/1        usb1    bus        EHCI Host Controller</span><br><span class="line">/2        usb2    bus        Generic Platform OHCI controller</span><br><span class="line">/3        usb0    network    Ethernet interface</span><br><span class="line">/4        eth0    network    Ethernet interface</span><br><span class="line">/5        wlan0   network    Ethernet interface</span><br></pre></td></tr></table></figure>



<p>显示硬件设备列表，输出包括总线信息、SCSI、USB、IDE、PCI 地址以及简单描述：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">debian@npi:~$ <span class="built_in">sudo</span> lshw -businfo</span><br><span class="line">Bus info  Device  Class      Description</span><br><span class="line">========================================</span><br><span class="line">                  system     Seeed NPi STM32MP157C Board</span><br><span class="line">                  bus        Motherboard</span><br><span class="line">cpu@0             processor  cpu</span><br><span class="line">cpu@1             processor  cpu</span><br><span class="line">                  memory     429MiB System memory</span><br><span class="line">usb@1     usb1    bus        EHCI Host Controller</span><br><span class="line">usb@2     usb2    bus        Generic Platform OHCI controller</span><br><span class="line">          usb0    network    Ethernet interface</span><br><span class="line">          eth0    network    Ethernet interface</span><br><span class="line">          wlan0   network    Ethernet interface</span><br></pre></td></tr></table></figure>



<p>显示内存相关硬件信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">debian@npi:~$ <span class="built_in">sudo</span> lshw -C memory</span><br><span class="line">[10404.990958] [dhd-wlan0] wl_run_escan : LEGACY_SCAN <span class="built_in">sync</span> ID: 51, bssidx: 0</span><br><span class="line">  *-memory</span><br><span class="line">       description: System memory</span><br><span class="line">       physical <span class="built_in">id</span>: 2</span><br><span class="line">       size: 429MiB</span><br></pre></td></tr></table></figure>



<p>显示网卡相关硬件信息，并删除敏感信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">debian@npi:~$ <span class="built_in">sudo</span> lshw -c network -sanitize</span><br><span class="line">  *-network:0</span><br><span class="line">       description: Ethernet interface</span><br><span class="line">       physical <span class="built_in">id</span>: 3</span><br><span class="line">       logical name: usb0</span><br><span class="line">       serial: [REMOVED]</span><br><span class="line">       capabilities: ethernet physical</span><br><span class="line">       configuration: broadcast=<span class="built_in">yes</span> driver=g_ether driverversion=29-May-2008 firmware=49000000.usb-otg ip=[REMOVED] <span class="built_in">link</span>=no multicast=<span class="built_in">yes</span></span><br><span class="line">  *-network:1</span><br><span class="line">       description: Ethernet interface</span><br><span class="line">       physical <span class="built_in">id</span>: 4</span><br><span class="line">       logical name: eth0</span><br><span class="line">       serial: [REMOVED]</span><br><span class="line">       size: 10Mbit/s</span><br><span class="line">       capacity: 1Gbit/s</span><br><span class="line">       capabilities: ethernet physical tp mii 10bt 10bt-fd 100bt 100bt-fd 1000bt 1000bt-fd autonegotiation</span><br><span class="line">       configuration: autonegotiation=on broadcast=<span class="built_in">yes</span> driver=st_gmac driverversion=Jan_2016 duplex=half <span class="built_in">link</span>=no multicast=<span class="built_in">yes</span> port=MII speed=10Mbit/s</span><br><span class="line">  *-network:2</span><br><span class="line">       description: Ethernet interface</span><br><span class="line">       physical <span class="built_in">id</span>: 5</span><br><span class="line">       logical name: wlan0</span><br><span class="line">       serial: [REMOVED]</span><br><span class="line">       capabilities: ethernet physical</span><br><span class="line">       configuration: broadcast=<span class="built_in">yes</span> driver=wl driverversion=0 ip=[REMOVED] multicast=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure>





<h1 id="Linux-spi-config-命令-配置-SPI-接口"><a href="#Linux-spi-config-命令-配置-SPI-接口" class="headerlink" title="Linux spi-config 命令 - 配置 SPI 接口"></a>Linux spi-config 命令 - 配置 SPI 接口</h1><h2 id="介绍-214"><a href="#介绍-214" class="headerlink" title="介绍"></a>介绍</h2><p><strong>spi-config</strong> 命令用于在用户空间查询或设置 SPI 总线配置。</p>
<p>spi-config 命令由 spi-tools 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install spi-tools</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spi-config [options...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-d</code>, <code>--device=DEVICE</code> ：使用指定的 spidev 字符设备</li>
<li><code>-q</code>, <code>--query</code> ：打印当前的配置</li>
<li><code>-m</code>, <code>--mode=[0-3]</code> ：设置 SPI 模式</li>
<li><code>-l</code>, <code>--lsb={0,1}</code> ：设置数据传输方式为 LSB first (1) 或者 MSB first (0)</li>
<li><code>-b</code>, <code>--bits=[7...]</code> ：设置每个字（word）的位数</li>
<li><code>-s</code>, <code>--speed=FREQUENCY</code> ：设置时钟频率（单位 Hz）</li>
<li><code>-r</code>, <code>--spirdy={0,1}</code> ：设置 SPI READY 模式标志</li>
<li><code>-s</code>, <code>--wait</code> ：阻塞，保持文件描述符打开</li>
<li><code>-h</code>, <code>--help</code> ：查看帮助并退出</li>
<li><code>-v</code>, <code>--version</code> ：查看版本信息并退出</li>
</ul>
<p><strong>SPI 模式</strong>：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>mode 0</td>
<td>low iddle level, sample on leading edge.</td>
</tr>
<tr>
<td>mode 1</td>
<td>low iddle level, sample on trailing edge.</td>
</tr>
<tr>
<td>mode 2</td>
<td>high iddle level, sample on leading edge.</td>
</tr>
<tr>
<td>mode 3</td>
<td>high iddle level, sample on trailing edge.</td>
</tr>
</tbody></table>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/spi-pipe/">spi-pipe</a></p>
<h2 id="示例-215"><a href="#示例-215" class="headerlink" title="示例"></a>示例</h2><p>查询 &#x2F;dev&#x2F;spidev0.0 设备当前配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spi-config --device=/dev/spidev0.0 -q</span><br></pre></td></tr></table></figure>



<p>修改时钟频率为1MHz</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spi-config --device=/dev/spidev0.0 --speed=1000000</span><br></pre></td></tr></table></figure>



<p>设置配置并保持设备开启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spi-config --<span class="built_in">wait</span> -d /dev/spidev0.0 -s 1000000 &amp; PID=$!</span><br></pre></td></tr></table></figure>



<p>注：<code>$!</code> 是 Shell 最后运行的后台进程的 PID</p>
<p>关闭之前打开的设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> <span class="variable">$PID</span></span><br></pre></td></tr></table></figure>





<h1 id="Linux-spi-pipe-命令-SPI-数据传输工具"><a href="#Linux-spi-pipe-命令-SPI-数据传输工具" class="headerlink" title="Linux spi-pipe 命令 - SPI 数据传输工具"></a>Linux spi-pipe 命令 - SPI 数据传输工具</h1><h2 id="介绍-215"><a href="#介绍-215" class="headerlink" title="介绍"></a>介绍</h2><p><strong>spi-pipe</strong> 命令用于在用户空间进行全双工 SPI 通讯测试。</p>
<p>spi-pipe 命令由 spi-tools 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install spi-tools</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spi-pipe [options...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-d</code>, <code>--device=DEVICE</code> ：使用指定的 spidev 字符设备</li>
<li><code>-s</code>, <code>--speed=&lt;int&gt;</code> ：设置目标 SPI 传输速度</li>
<li><code>-b</code>, <code>--blocksize=&lt;int&gt;</code> ：设置要传输的块大小（单位字节）</li>
<li><code>-n</code>, <code>--number=&lt;int&gt;</code> ：设置要传输的块数（-1表示连续传输）</li>
<li><code>-h</code>, <code>--help</code> ：查看帮助并退出</li>
<li><code>-v</code>, <code>--version</code> ：查看版本信息并退出</li>
</ul>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/spi-config/">spi-config</a></p>
<h2 id="示例-216"><a href="#示例-216" class="headerlink" title="示例"></a>示例</h2><p>同时发送和接收</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">command-1 | spi-pipe --device=/dev/spidev0.0 | command-2</span><br></pre></td></tr></table></figure>



<p>注意：<em>command-1</em>, <em>command-2</em> 和 <strong>spi-pipe</strong> 需要在三个不同的进程中同时运行。</p>
<p>将数据发送到 SPI 连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">command-1 | spi-pipe --device=/dev/spidev0.0</span><br></pre></td></tr></table></figure>



<p>从 SPI 连接中接收数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spi-pipe --device=/dev/spidev0.0 &lt; /dev/zero | command-2</span><br></pre></td></tr></table></figure>



<p>提示：使用 <code>command-2 &lt; /dev/spidev0.0</code> 命令也可以接收数据（数据始终为 0），但是使用 <strong>spi-pipe</strong> 可以控制发送到设备的内容。</p>
<p>从 SPI 连接读取 40 个 4 字节的块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spi-pipe --device=/dev/spidev0.0 -b 4 -n 40 &lt; /dev/zero | command-2</span><br></pre></td></tr></table></figure>





<h1 id="Linux-i2cdetect-命令-扫描-I2C-设备地址"><a href="#Linux-i2cdetect-命令-扫描-I2C-设备地址" class="headerlink" title="Linux i2cdetect 命令 - 扫描 I2C 设备地址"></a>Linux i2cdetect 命令 - 扫描 I2C 设备地址</h1><h2 id="介绍-216"><a href="#介绍-216" class="headerlink" title="介绍"></a>介绍</h2><p><strong>i2cdetect</strong> 命令用于在 Linux 系统用户空间扫描 I2C 总线上的设备。</p>
<p>i2cdetect 命令由 i2c-tools 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install i2c-tools</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i2cdetect [-y] [-a] [-q|-r] I2CBUS [first last]</span><br><span class="line">i2cdetect -F I2CBUS</span><br><span class="line">i2cdetect -V</span><br><span class="line">i2cdetect -l</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-y</code>：关闭交互模式</li>
<li><code>-a</code>：强制扫描非常规地址（不推荐）</li>
<li><code>-q</code>：使用 SMBus 的 “quick write” 命令进行探测（不推荐）</li>
<li><code>-r</code>：使用 SMBus 的 “receive byte” 命令进行探测（不推荐）</li>
<li><code>-F</code>：显示适配器实现的功能列表并退出</li>
<li><code>-V</code>：显示版本信息并退出</li>
<li><code>-l</code>：输出已安装 I2C 总线的列表</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li><code>I2CBUS</code>：I2C 总线数字序号，对应于 <code>i2cdetect -l</code> 扫描的序号。</li>
</ul>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2cdump/">i2cdump</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2cget/">i2cget</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2cset/">i2cset</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2ctransfer/">i2ctransfer</a>、sensors-detect、i2c-stub-from-dump</p>
<h2 id="示例-217"><a href="#示例-217" class="headerlink" title="示例"></a>示例</h2><p>查看系统已安装的 I2C 总线列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@npi:~# i2cdetect -l</span><br><span class="line">i2c-1   i2c         STM32F7 I2C(0x5c002000)         I2C adapter</span><br><span class="line">i2c-2   i2c         STM32F7 I2C(0x40012000)         I2C adapter</span><br><span class="line">i2c-0   i2c         STM32F7 I2C(0x40013000)         I2C adapter</span><br></pre></td></tr></table></figure>



<p>查看 i2c-0 实现的功能列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@npi:~# i2cdetect -F 0</span><br><span class="line">Functionalities implemented by /dev/i2c-0:</span><br><span class="line">I2C                              <span class="built_in">yes</span></span><br><span class="line">SMBus Quick Command              <span class="built_in">yes</span></span><br><span class="line">SMBus Send Byte                  <span class="built_in">yes</span></span><br><span class="line">SMBus Receive Byte               <span class="built_in">yes</span></span><br><span class="line">SMBus Write Byte                 <span class="built_in">yes</span></span><br><span class="line">SMBus Read Byte                  <span class="built_in">yes</span></span><br><span class="line">SMBus Write Word                 <span class="built_in">yes</span></span><br><span class="line">SMBus Read Word                  <span class="built_in">yes</span></span><br><span class="line">SMBus Process Call               <span class="built_in">yes</span></span><br><span class="line">SMBus Block Write                <span class="built_in">yes</span></span><br><span class="line">SMBus Block Read                 <span class="built_in">yes</span></span><br><span class="line">SMBus Block Process Call         <span class="built_in">yes</span></span><br><span class="line">SMBus PEC                        <span class="built_in">yes</span></span><br><span class="line">I2C Block Write                  <span class="built_in">yes</span></span><br><span class="line">I2C Block Read                   <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>





<h1 id="Linux-i2cdump-命令-显示-I2C-设备的寄存器内容"><a href="#Linux-i2cdump-命令-显示-I2C-设备的寄存器内容" class="headerlink" title="Linux i2cdump 命令 - 显示 I2C 设备的寄存器内容"></a>Linux i2cdump 命令 - 显示 I2C 设备的寄存器内容</h1><h2 id="介绍-217"><a href="#介绍-217" class="headerlink" title="介绍"></a>介绍</h2><p><strong>i2cdump</strong> 命令用于在 Linux 系统用户空间读取连接到系统的 I2C 设备的数据，并以可读的格式显示 I2C 设备的寄存器内容。I2C（Inter-Integrated Circuit）是一种串行通信协议，常用于连接各种外设和传感器。<code>i2cdump</code> 命令支持对不同类型的 I2C 设备进行读取。</p>
<p>i2cdump 命令由 i2c-tools 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install i2c-tools</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i2cdump [-f] [-r first-last] [-y] [-a] I2CBUS ADDRESS [MODE [BANK [BANKREG]]]</span><br><span class="line">i2cdump -V</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-f</code>：即使设备繁忙，也强制访问该设备。默认情况下，i2cdump 将拒绝访问已在内核驱动程序控制下的设备。注意，使用此标志是危险的，因为它可能会严重混淆相关的内核驱动程序，还可能导致 i2cdump 返回无效结果。因此，只有在你知道自己在做什么的情况下才可以使用，风险自负。</li>
<li><code>-r first-last</code>：限制正在访问的寄存器的范围。此选项仅适用于模式 b、w、c 和 W。对于模式 W，第一个必须是偶数，最后一个必须是奇数。</li>
<li><code>-y</code>：禁用交互模式。默认情况下，i2cdump 将等待用户的确认，然后再访问 I2C 总线。当使用该标志时，将直接执行操作，这主要是为了在脚本中使用。</li>
<li><code>-a</code>：允许使用 0x00 - 0x02 和 0x78 - 0x7f 之间的地址。一般不建议使用。</li>
<li><code>-V</code>：显示版本信息并退出。</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li><p><code>I2CBUS</code>：I2C 总线数字序号，对应于 <code>i2cdetect -l</code> 扫描的序号。</p>
</li>
<li><p><code>ADDRESS</code>：是一个整数，范围 0x03 - 0x77，或 0x00 - 0x7f（如果使用 <code>-a</code> 选项）。</p>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MODE</span><br></pre></td></tr></table></figure>

<p>：模式支持以下任意一种：</p>
<ul>
<li><code>b</code>（byte，默认）</li>
<li><code>w</code>（word）</li>
<li><code>W</code>（word on even register addresses）</li>
<li><code>s</code>（SMBus block）</li>
<li><code>i</code>（I2C block）</li>
<li><code>c</code>（consecutive byte）</li>
</ul>
</li>
</ul>
<p>另外，还可以将 <code>p</code> 附加到模式参数（<code>i</code> 和 <code>W</code> 除外）以启用 PEC。如果省略 <code>MODE</code> 参数，i2cdump 默认使用不带 PEC 的字节访问。</p>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2cdetect/">i2cdetect</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2cget/">i2cget</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2cset/">i2cset</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2ctransfer/">i2ctransfer</a>、sensors-detect、i2c-stub-from-dump</p>
<h2 id="示例-218"><a href="#示例-218" class="headerlink" title="示例"></a>示例</h2><p>1、使用默认读取方法（字节模式），将 I2C 总线 9（i2c-9）上地址 0x50 设备的全部内容倾倒出来（需要用户确认）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i2cdump 9 0x50</span><br></pre></td></tr></table></figure>



<p>2、使用 I2C 块读取模式，将 I2C 总线 9（i2c-9）上地址 0x50 设备的全部内容倾倒出来（无需用户确认）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i2cdump -y 9 0x50 i</span><br></pre></td></tr></table></figure>



<p>如果设备是 EEPROM，那么输出通常与前面示例的输出相同。</p>
<p>3、使用默认读取方法（字节模式），将 I2C 总线 1（i2c-1）上地址 0x2d 设备的寄存器 0x00 至 0x3f 的内容倾倒出来（需要用户确认）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i2cdump -r 0x00-0x3f 1 0x2d</span><br></pre></td></tr></table></figure>



<p>4、使用启用了错误检查的 SMBus 块读取模式，将 I2C 总线 0（i2c-0）上地址 0x69 的 SMBus 设备的寄存器的内容倾倒出来（需要用户确认）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i2cdump 0 0x69 sp</span><br></pre></td></tr></table></figure>





<h1 id="Linux-i2cget-命令-从-I2C-设备读取数据"><a href="#Linux-i2cget-命令-从-I2C-设备读取数据" class="headerlink" title="Linux i2cget 命令 - 从 I2C 设备读取数据"></a>Linux i2cget 命令 - 从 I2C 设备读取数据</h1><h2 id="介绍-218"><a href="#介绍-218" class="headerlink" title="介绍"></a>介绍</h2><p><strong>i2cget</strong> 是 Linux 系统中的一个命令行工具，用于从 I2C 设备中读取数据。</p>
<p>I2C（Inter-Integrated Circuit）是一种串行通信协议，常用于连接各种外设和传感器。<code>i2cget</code> 允许用户以不同的格式从指定的 I2C 设备和寄存器地址中读取数据，支持读取不同类型的数据，如字节、字、块等；并提供不同的输出格式，包括字节、字和其他格式。</p>
<p>i2cget 命令由 i2c-tools 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install i2c-tools</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i2cget [-f] [-y] [-a] i2cbus chip-address [data-address [mode]]</span><br><span class="line">i2cget -V</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-f</code>：即使设备繁忙，也强制访问该设备。注意这是危险操作，只有在你知道自己在做什么的情况下才可以使用，风险自负。</li>
<li><code>-y</code>：关闭交互模式。</li>
<li><code>-a</code>：允许使用非常规地址（0x00 - 0x02 和 0x78 - 0x7f 之间的地址），一般不建议使用。</li>
<li><code>-V</code>：显示版本信息并退出。</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li><p><code>i2cbus</code>：I2C 总线数字序号，对应于 <code>i2cdetect -l</code> 扫描的序号。</p>
</li>
<li><p><code>chip-address</code>：指定 I2C 设备的地址，默认是 0x08 到 0x77 之间的整数。</p>
</li>
<li><p><code>data-address</code>：指定要读取的设备上的寄存器地址，是 0x00 到 0xFF 之间的整数。如果省略，则将读取当前活动的寄存器（如果所用芯片支持）。</p>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mode</span><br></pre></td></tr></table></figure>

<p>：模式支持以下任意一种：</p>
<ul>
<li><code>b</code>（byte，默认）</li>
<li><code>w</code>（word）</li>
<li><code>c</code>（consecutive byte）</li>
</ul>
</li>
</ul>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2cdetect/">i2cdetect</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2cdump/">i2cdump</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2cset/">i2cset</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2ctransfer/">i2ctransfer</a>、sensors-detect、i2c-stub-from-dump</p>
<h2 id="示例-219"><a href="#示例-219" class="headerlink" title="示例"></a>示例</h2><p>获取 I2C 总线 1（i2c-1）上地址 0x2d 设备的寄存器 0x11 的值（需要用户确认）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i2cget 1 0x2d 0x11</span><br></pre></td></tr></table></figure>



<p>获取 I2C 总线 1（i2c-1）上地址 0x48 设备的 16 位寄存器 0x00 的值（需要用户确认）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i2cget 1 0x48 0x00 w</span><br></pre></td></tr></table></figure>





<h1 id="Linux-i2cset-命令-向-I2C-设备写入数据"><a href="#Linux-i2cset-命令-向-I2C-设备写入数据" class="headerlink" title="Linux i2cset 命令 - 向 I2C 设备写入数据"></a>Linux i2cset 命令 - 向 I2C 设备写入数据</h1><h2 id="介绍-219"><a href="#介绍-219" class="headerlink" title="介绍"></a>介绍</h2><p><strong>i2cset</strong> 是 Linux 系统中的一个命令行工具，用于向 I2C 设备写入数据。</p>
<p>I2C（Inter-Integrated Circuit）是一种串行通信协议，常用于连接各种外设和传感器。<code>i2cset</code> 允许用户以不同的格式向指定的 I2C 设备和寄存器地址中写入数据，支持多种输入格式，包括字节、字和其他格式。</p>
<p>i2cset 命令由 i2c-tools 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install i2c-tools</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i2cset [-f] [-y] [-m mask] [-r] [-a] i2cbus chip-address data-address [value] ...  [mode]</span><br><span class="line">i2cset -V</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-f</code>：即使设备繁忙，也强制访问该设备。注意这是危险操作，只有在你知道自己在做什么的情况下才可以使用，风险自负。</li>
<li><code>-y</code>：关闭交互模式。</li>
<li><code>-m mask</code>：掩码参数 mask（如果指定）描述了哪些位值将实际写入数据地址。掩码中设置为 1 的位是从值中获取的，而设置为 0 的位将从数据地址中读取，从而由操作保留。</li>
<li><code>-r</code>：写入后立即读回，并将结果与写入的值进行比较。这曾经是默认行为。</li>
<li><code>-a</code>：允许使用非常规地址（0x00 - 0x02 和 0x78 - 0x7f 之间的地址），一般不建议使用。</li>
<li><code>-V</code>：显示版本信息并退出。</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li><p><code>i2cbus</code>：I2C 总线数字序号，对应于 <code>i2cdetect -l</code> 扫描的序号。</p>
</li>
<li><p><code>chip-address</code>：指定 I2C 设备的地址，默认是 0x08 到 0x77 之间的整数。</p>
</li>
<li><p><code>data-address</code>：指定要读取的设备上的寄存器地址，是 0x00 到 0xFF 之间的整数。如果省略，则将读取当前活动的寄存器（如果所用芯片支持）。</p>
</li>
<li><p><code>value</code>： 要写入芯片上该位置的值。如果省略此参数，则发出短写入（short write）。</p>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mode</span><br></pre></td></tr></table></figure>

<p>：模式支持以下任意一种：</p>
<ul>
<li><code>b</code>（byte，默认）</li>
<li><code>w</code>（word）</li>
<li><code>c</code>（consecutive byte）</li>
</ul>
</li>
</ul>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2cdetect/">i2cdetect</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2cdump/">i2cdump</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2cget/">i2cget</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2ctransfer/">i2ctransfer</a>、sensors-detect、i2c-stub-from-dump</p>
<h2 id="示例-220"><a href="#示例-220" class="headerlink" title="示例"></a>示例</h2><p>将值 0x42 写入总线 1（i2c-1）上地址为 0x2d 的 I2C 设备的 8 位寄存器 0x11 中（需要用户确认）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i2cset 1 0x2d 0x11 0x42</span><br></pre></td></tr></table></figure>



<p>立即清除总线 1（i2c-1）上地址为 0x2d 的 I2C 设备的 8 位寄存器 0x11 的 3 个最低有效位（无需用户确认）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i2cset -y -m 0x07 1 0x2d 0x11 0x00</span><br></pre></td></tr></table></figure>



<p>将值 0x5000 写入总线 1（i2c-1）上地址为 0x48 的 I2C 设备的 16 位寄存器 0x02 中（需要用户确认）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i2cset 1 0x48 0x02 0x5000 w</span><br></pre></td></tr></table></figure>





<h1 id="Linux-i2ctransfer-命令-执行-I2C-数据传输操作"><a href="#Linux-i2ctransfer-命令-执行-I2C-数据传输操作" class="headerlink" title="Linux i2ctransfer 命令 - 执行 I2C 数据传输操作"></a>Linux i2ctransfer 命令 - 执行 I2C 数据传输操作</h1><h2 id="介绍-220"><a href="#介绍-220" class="headerlink" title="介绍"></a>介绍</h2><p><strong>i2ctransfer</strong> 是 Linux 系统中的一个命令行工具，用于创建 I2C 消息并将它们作为一次传输合并发送到 I2C 总线。同时，<code>i2ctransfer</code> 也可以用于读取消息，将接收到的缓冲区的内容将打印到标准输出，每条读取消息打印一行。</p>
<p>i2ctransfer 命令由 i2c-tools 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install i2c-tools</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i2ctransfer [-f] [-y] [-v] [-a] i2cbus desc [data] [desc [data]] ...</span><br><span class="line">i2ctransfer -V</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-f</code>：即使设备繁忙，也强制访问该设备。注意这是危险操作，只有在你知道自己在做什么的情况下才可以使用，风险自负。</li>
<li><code>-y</code>：关闭交互模式。</li>
<li><code>-v</code>：开启详细输出模式。</li>
<li><code>-a</code>：允许使用非常规地址（0x00 - 0x02 和 0x78 - 0x7f 之间的地址），一般不建议使用。</li>
<li><code>-V</code>：显示版本信息并退出。</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li><p><code>i2cbus</code>：I2C 总线数字序号，对应于 <code>i2cdetect -l</code> 扫描的序号。</p>
</li>
<li><p><code>desc</code>：一个或多个 desc 块，用于描述读写属性、消息大小以及设备地址等信息。块的数量受到 Linux 内核的限制，并由 <code>I2C_RDWR_IOCTL_MAX_MSGS</code> 定义（从内核 v4.10 开始为 42）。</p>
<p>desc 块的组成如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;r|w&#125;&lt;length_of_message&gt;[@address]</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>data</code>：要传输的数据。</p>
</li>
</ul>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2cdetect/">i2cdetect</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2cdump/">i2cdump</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2cget/">i2cget</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/i2cset/">i2cset</a>、sensors-detect、i2c-stub-from-dump</p>
<h2 id="示例-221"><a href="#示例-221" class="headerlink" title="示例"></a>示例</h2><p>在总线 0 上，访问地址 0x50 的 EEPROM 设备，从偏移量 0x64 读取 8 个字节（第一个消息写入一个字节以将内存指针设置为 0x64，第二个消息从同一芯片读取数据）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i2ctransfer 0 w1@0x50 0x64 r8</span><br></pre></td></tr></table></figure>



<p>对于同一个 EEPROM，在偏移量 0x42 处写入 0xff 0xfe … 0xf0（一条写入消息；第一个字节将内存指针设置为 0x42，0xff 是第一个数据字节，所有后续数据字节减一）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i2ctransfer 0 w17@0x50 0x42 0xff-</span><br></pre></td></tr></table></figure>





<h1 id="Linux-stty-命令-配置终端行属性"><a href="#Linux-stty-命令-配置终端行属性" class="headerlink" title="Linux stty 命令 - 配置终端行属性"></a>Linux stty 命令 - 配置终端行属性</h1><h2 id="介绍-221"><a href="#介绍-221" class="headerlink" title="介绍"></a>介绍</h2><p><strong>stty</strong>（英文全拼：set tty）命令用于显示和修改终端命令行（terminal line）的相关设置。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stty</span> [选项] [参数]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code> ：以容易阅读的方式打印当前的所有配置。</li>
<li><code>-g</code> ：以 stty 可读方式打印当前的所有配置。</li>
<li><code>-F</code>, <code>--file=&lt;DEVICE&gt;</code> ：打开并使用指定的文件，而不是使用标准输入。</li>
<li><code>--help</code> ：显示帮助信息并退出。</li>
<li><code>--version</code> ：输出版本信息并退出。</li>
</ul>
<h2 id="示例-222"><a href="#示例-222" class="headerlink" title="示例"></a>示例</h2><p>查看当前注册终端的设置情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stty</span> -a</span><br></pre></td></tr></table></figure>



<p>在命令行下禁止输出大写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stty</span> iuclc     <span class="comment"># 开启</span></span><br><span class="line"><span class="built_in">stty</span> -iuclc    <span class="comment"># 恢复</span></span><br></pre></td></tr></table></figure>



<p>在命令行下禁止输出小写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stty</span> olcuc     <span class="comment"># 开启</span></span><br><span class="line"><span class="built_in">stty</span> -olcuc    <span class="comment"># 恢复</span></span><br></pre></td></tr></table></figure>



<p>屏蔽显示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stty</span> -<span class="built_in">echo</span>   <span class="comment"># 禁止回显</span></span><br><span class="line"><span class="built_in">stty</span> <span class="built_in">echo</span>    <span class="comment"># 打开回显</span></span><br></pre></td></tr></table></figure>



<p>忽略回车符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stty</span> igncr     <span class="comment"># 开启</span></span><br><span class="line"><span class="built_in">stty</span> -igncr    <span class="comment"># 恢复</span></span><br></pre></td></tr></table></figure>



<p>打印出终端的行数和列数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stty</span> size</span><br></pre></td></tr></table></figure>



<p>修改文件结束符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stty</span> eof <span class="string">&#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>



<p>系统默认是 Ctrl+D 来表示文件的结束，通过上述命令，将改变为使用字符 c</p>
<p>另外，stty 命令也常用于串口调试，比如查看串口设备参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stty</span> -F <span class="string">&quot;/dev/ttymxc1&quot;</span> -a</span><br></pre></td></tr></table></figure>



<p>设置串口设备波特率为 115200</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stty</span> -F <span class="string">&quot;/dev/ttymxc1&quot;</span> 115200</span><br></pre></td></tr></table></figure>



<p>在使用串口时，我们通常会关心如下一些参数：</p>
<ul>
<li>speed：波特率</li>
<li>cs8：8位数据位</li>
<li>parenb：偶校验</li>
<li>parodd：奇校验</li>
<li>cstopb：2位停止位</li>
<li>crtscts：硬件流控</li>
</ul>
<p>如果上述参数前面有 <code>-</code> 号，则表示未设置状态，比如设置硬件流控</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stty</span> -F <span class="string">&quot;/dev/ttymxc1&quot;</span> -crtscts  <span class="comment"># 去掉流控</span></span><br><span class="line"><span class="built_in">stty</span> -F <span class="string">&quot;/dev/ttymxc1&quot;</span> crtscts   <span class="comment"># 增加流控</span></span><br></pre></td></tr></table></figure>



<p>禁止 XOFF 信号（相当于 Ctrl + S，对应 ASCII 码 0x13）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stty</span> -ixon</span><br></pre></td></tr></table></figure>





<h1 id="Linux-minicom-命令-串口调试工具"><a href="#Linux-minicom-命令-串口调试工具" class="headerlink" title="Linux minicom 命令 - 串口调试工具"></a>Linux minicom 命令 - 串口调试工具</h1><h2 id="介绍-222"><a href="#介绍-222" class="headerlink" title="介绍"></a>介绍</h2><p><strong>Minicom</strong> 是 Linux 下一款常用的命令行串口调试工具。其功能与 Windows 下的超级终端相似，可以通过串口控制外部的硬件设备，通常用于对嵌入式设备进行管理。</p>
<p>Linux 发行版通常不预装 minicom 工具，用户可自行安装，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install minicom</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">minicom [options] [configuration]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-b</code>, <code>--baudrate</code> ：设置波特率（忽略 config 中的值）</li>
<li><code>-D</code>, <code>--device</code> ：指定串口设备（忽略 config 中的值）</li>
<li><code>-s</code>, <code>--setup</code> ：进入设置模式</li>
<li><code>-o</code>, <code>--noinit</code> ：启动时不要初始化 modem 和 lockfiles</li>
<li><code>-w</code>, <code>--wrap</code> ：打开换行显示</li>
<li><code>-H</code>, <code>--displayhex</code> ：以十六进制显示输出</li>
<li><code>-z</code>, <code>--statline</code> ：尝试使用终端的状态栏</li>
<li><code>-7</code>, <code>--7bit</code> ：强制使用7位模式</li>
<li><code>-8</code>, <code>--8bit</code> ：强制使用8位模式</li>
<li><code>-c</code>, <code>--color=on/off</code> ：开启或关闭 ANSI 风格颜色用法</li>
<li><code>-a</code>, <code>--attrib=on/off</code> ：开启或关闭高亮属性</li>
<li><code>-t</code>, <code>--term=TERM</code> ：覆盖 TERM 环境变量</li>
<li><code>-S</code>, <code>--script=SCRIPT</code> ：启动时运行脚本</li>
<li><code>-p</code>, <code>--ptty=TTYP</code> ：连接到伪终端（pseudo terminal）</li>
<li><code>-C</code>, <code>--capturefile=FILE</code> ：捕获终端并保存到文件</li>
<li>configuration ：指定 minicom 配置文件启动</li>
</ul>
<h2 id="示例-223"><a href="#示例-223" class="headerlink" title="示例"></a>示例</h2><p>打开指定的串口终端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> minicom -D /dev/ttyUSB0</span><br></pre></td></tr></table></figure>



<p>打开指定的串口终端，并以 ANSI 颜色风格显示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> minicom -D /dev/ttyUSB0 -c on</span><br></pre></td></tr></table></figure>



<p>打开指定的串口终端，并将内容保存到文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> minicom -D /dev/ttyUSB0 -C output.txt</span><br></pre></td></tr></table></figure>



<p>设置串口终端参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> minicom -s</span><br></pre></td></tr></table></figure>



<p>配置完成后，选“Save setup as..”将该配置保存为指定名称，例如“stm32”</p>
<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/minicom_configuration.png" alt="img"></p>
<p>保存，在 &#x2F;etc&#x2F;minicom 目录下将会生成 minirc.stm32 文件。</p>
<p>之后我们就可以通过配置文件启动串口终端了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> minicom stm32</span><br></pre></td></tr></table></figure>



<p>在 minicom 终端中，按 CTRL+A，再按 Z 将会打开配置窗口，按 X 可退出该串口终端。</p>
<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/minicom_command_summary.png" alt="img"></p>
<p>提示：minicom 使用前缀按键 Ctrl-A，即执行特殊操作时，都需要先按 Ctrl+A，再按某个按键使用对应的功能。比如：</p>
<ul>
<li>按 Z 键查看帮助；</li>
<li>按 X 或 Q 键退出窗口；</li>
<li>按 W 键打开或关闭换行功能；</li>
<li>按 N 键打开或关闭时间戳显示；</li>
</ul>
<p>如果串口有输出，但无法输入，通常是由于开启了硬件流控导致的。按 CTRL-A Z 进入设置页，按 O 键选择 “cOnfigure Minicom” 项，再选择 “Serial port setup” 项，按 F 键关闭 Hardware Flow Control。</p>
<p>有时候窗口打印数据较多，我们需要暂停输出，以便于查看。按 Ctrl+A 即可暂停输出。Ctrl+A 是 mimicom 的特殊功能前缀按键，但还有另一个很实用的作用，就是暂停屏幕输出。</p>
<p>如果设备端支持的话，按下 Ctrl+A，再按 S，即可向设备端发送文件；按 Ctrl+A，再按 R，可接收文件。</p>
<h1 id="Linux-microcom-命令-串口通信工具"><a href="#Linux-microcom-命令-串口通信工具" class="headerlink" title="Linux microcom 命令 - 串口通信工具"></a>Linux microcom 命令 - 串口通信工具</h1><h2 id="介绍-223"><a href="#介绍-223" class="headerlink" title="介绍"></a>介绍</h2><p><strong>microcom</strong> 是一个用于与串行调制解调器通信的命令。</p>
<p>我们可以把 microcom 理解为是一个在终端命令行运行的串口调试助手，在调试串口时非常有用，例如调试 AT 指令。</p>
<p>如果您的设备使用 Busybox，可以在 busybox&#x2F;miscutils&#x2F;microcom.c 中找到源代码，编译添加到文件系统中，就可以使用 microcom 命令了。如果您使用 Linux 发行版，比如 Debian&#x2F;Ubuntu 可以使用如下命令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install microcom</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microcom [-d DELAY] [-t TIMEOUT] [-s SPEED] [-X] TTY</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-d &lt;DELAY&gt;</code> ：表示延时时间。</li>
<li><code>-t &lt;TIMEOUT&gt;</code> ：表示超时时间，超多少时间就自动退出（单位为 ms）。</li>
<li><code>-s &lt;SPEED&gt;</code> ：表示传输速度，波特率的意思，这个根据自己的情况而定。</li>
<li><code>-X</code> ：从 stdin 禁用 <code>NUL</code> 和 <code>Ctrl-X</code> 的特殊含义。</li>
</ul>
<p><strong>参数</strong>：指定串口设备 TTY（如 &#x2F;dev&#x2F;ttyS0）。</p>
<h2 id="示例-224"><a href="#示例-224" class="headerlink" title="示例"></a>示例</h2><p>将要测试串口与 PC 端连接，在 PC 端开启串口调试工具，波特率设置为 115200。</p>
<p>接着在设备端运行如下命令，打开 &#x2F;dev&#x2F;ttymxc1 串口设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microcom -s 115200 /dev/ttymxc1</span><br></pre></td></tr></table></figure>



<p>此时，在设备终端中输入的字符，将在 PC 端的窗口中显示；反过来，在 PC 端输入的字符，也会在设备端的 microcom 中显示。通过该方法，可以验证串口设备是否正常工作。</p>
<p>如果您通过串口连接了支持 AT 指令的模块，就可以用 microcom 工具向模块发送 AT 指令。不过，直接在键盘输入 AT 指令有些麻烦，我们可以将 AT 指令写在文件中，再重定向到 microcom，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">microcom -s 115200 /dev/ttymxc1 &lt; at.txt</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> at.txt | microcom -s 115200 /dev/ttymxc1</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f at.txt | microcom -s 115200 /dev/ttymxc1</span><br></pre></td></tr></table></figure>



<p>按 Ctrl + X 退出。</p>
<h1 id="Linux-xrandr-命令-管理显示输出设置"><a href="#Linux-xrandr-命令-管理显示输出设置" class="headerlink" title="Linux xrandr 命令 - 管理显示输出设置"></a>Linux xrandr 命令 - 管理显示输出设置</h1><h2 id="介绍-224"><a href="#介绍-224" class="headerlink" title="介绍"></a>介绍</h2><p><strong>xrandr</strong> 是用于与 X RandR 扩展进行交互的命令行工具。它允许对 X server 进行实时配置（即无需重新启动即可使配置生效），xrandr 提供了显示模式（如分辨率、刷新率等）的自动检测，以及动态配置输出（如调整大小、旋转、移动屏幕等）的功能。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xrandr [options]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-q</code>, <code>--query</code> ：查询</li>
<li><code>-s &lt;size&gt;/&lt;width&gt;x&lt;height&gt;</code> ：设置分辨率</li>
<li><code>-r &lt;rate&gt;</code> ：设置刷新率</li>
<li><code>-o</code>, <code>--output &lt;output&gt;</code> ：指定输出模式</li>
</ul>
<h2 id="示例-225"><a href="#示例-225" class="headerlink" title="示例"></a>示例</h2><p>显示系统支持的所有分辨率</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xrandr</span><br><span class="line">Screen 0: minimum 0 x 0, current 1920 x 1080, maximum 32768 x 32768</span><br><span class="line">default connected primary 1920x1080+0+0 507mm x 285mm</span><br><span class="line">   1920x1080      0.00*</span><br></pre></td></tr></table></figure>



<p>将屏幕恢复到原来的分辨率</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xrandr -s 0</span><br></pre></td></tr></table></figure>



<p>设置具体分辨率</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xrandr -s 1024x768</span><br></pre></td></tr></table></figure>



<p>旋转屏幕</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xrandr -o left     <span class="comment"># 向左旋转90度</span></span><br><span class="line">xrandr -o right    <span class="comment"># 向右旋转90度</span></span><br><span class="line">xrandr -o inverted <span class="comment"># 上下翻转</span></span><br><span class="line">xrandr -o normal   <span class="comment"># 回到正常角度</span></span><br></pre></td></tr></table></figure>



<p>由于出错的硬件或驱动，xrandr 可能未能检测出显示器所有有效的分辨率。那么我们可以在 xrandr 里为显示器添加所需的分辨率。</p>
<p>首先，新建一种 xrandr 模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xrandr --newmode <span class="string">&#x27;1024x768_60&#x27;</span> 65.00 1024 1048 1184 1344 768 771 777 806 -hsync -vsync</span><br></pre></td></tr></table></figure>



<p>然后，把这个模式添加到当前的输出设备（假设为 DisplayPort-1）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xrandr --addmode DisplayPort-1 1024x768_60</span><br></pre></td></tr></table></figure>



<p>最后，把 DisplayPort-1 的分辨率指定为刚刚添加的新模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xrandr --output  DisplayPort-1 --mode 1024x768_60</span><br></pre></td></tr></table></figure>



<p>删除 xrandr 模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xrandr --rmmode 1024x768_60</span><br></pre></td></tr></table></figure>





<h1 id="Linux-mmc-命令-管理-MMC-SD-卡"><a href="#Linux-mmc-命令-管理-MMC-SD-卡" class="headerlink" title="Linux mmc 命令 - 管理 MMC&#x2F;SD 卡"></a>Linux mmc 命令 - 管理 MMC&#x2F;SD 卡</h1><h2 id="介绍-225"><a href="#介绍-225" class="headerlink" title="介绍"></a>介绍</h2><p>在 Linux 系统中，<strong><code>mmc</code></strong> 命令通常用于处理嵌入式系统中的存储设备，如 SD 卡或 eMMC（嵌入式多媒体卡）。通常用于与嵌入式存储设备进行交互，进行初始化、分区、读写操作等。</p>
<p>mmc 命令由 mmc-utils 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt install mmc-utils</span></span><br></pre></td></tr></table></figure>



<p>信息</p>
<p>mmc-utils 是一个用于管理 MMC（MultiMediaCard）和 eMMC（embedded MultiMediaCard）设备的工具包。其中，mmc 命令是 mmc-utils 工具包中的一部分，用于执行与 MMC 设备相关的操作。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mmc [&lt;<span class="built_in">command</span>&gt; [&lt;args&gt;]] [--<span class="built_in">help</span>]</span><br><span class="line">mmc [&lt;<span class="built_in">command</span>&gt;] --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>



<h2 id="示例-226"><a href="#示例-226" class="headerlink" title="示例"></a>示例</h2><p>显示 <code>/dev/mmcblk0</code> 存储设备的 Extended CSD 寄存器信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mmc extcsd <span class="built_in">read</span> /dev/mmcblk0</span><br></pre></td></tr></table></figure>



<p>擦除整个 <code>/dev/mmcblk0</code> 存储设备的数据块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mmc erase /dev/mmcblk0</span><br></pre></td></tr></table></figure>



<p>启用 <code>/dev/mmcblk0</code> 存储设备的引导分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mmc bootpart <span class="built_in">enable</span> 1 /dev/mmcblk0</span><br></pre></td></tr></table></figure>



<p>从 <code>/dev/mmcblk0</code> 存储设备的地址 <code>0x1000</code> 处读取 <code>0x800</code> 字节的数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mmc <span class="built_in">read</span> /dev/mmcblk0 0x1000 0x800</span><br></pre></td></tr></table></figure>



<p>从 rpmb 设备读取 2 个 256 字节的块到 <code>/tmp/block</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mmc rpmb read-block /dev/mmcblk0rpmb 0x02 2 /tmp/block</span><br></pre></td></tr></table></figure>





<h1 id="Linux-gpiodetect-命令-检测-GPIO-控制器"><a href="#Linux-gpiodetect-命令-检测-GPIO-控制器" class="headerlink" title="Linux gpiodetect 命令 - 检测 GPIO 控制器"></a>Linux gpiodetect 命令 - 检测 GPIO 控制器</h1><h2 id="介绍-226"><a href="#介绍-226" class="headerlink" title="介绍"></a>介绍</h2><p><strong>gpiodetect</strong> 命令用于列出系统上存在的所有 gpiochip，以及它们的名称、标签和 GPIO lines。</p>
<p>gpiodetect 命令由 <a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/">libgpiod</a> 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gpiod</span><br></pre></td></tr></table></figure>



<p>实际上，从 Linux 4.8 开始，不再推荐使用 sysfs 接口（&#x2F;sys&#x2F;class&#x2F;gpio）操作 GPIO，而是建议在用户空间使用字符设备进行操作，libgpiod 就是一个用于操作 GPIO 字符设备的库，同时提供了一些工具，方便开发者进行调试。</p>
<p>libgpiod 包含一系列命令，除了 gpiodetect，还有 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpioinfo/">gpioinfo</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpioget/">gpioget</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpioset/">gpioset</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpiofind/">gpiofind</a> 和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpiomon/">gpiomon</a> 命令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpiodetect [OPTIONS]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-h</code>, <code>--help</code> ：查看帮助并退出</li>
<li><code>-v</code>, <code>--version</code> ：查看版本信息并退出</li>
</ul>
<h2 id="示例-227"><a href="#示例-227" class="headerlink" title="示例"></a>示例</h2><p>查看树莓派 4B 系统上的 gpiochip 信息（非 root 用户需添加 sudo）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pi@raspberry:~$ <span class="built_in">sudo</span> gpiodetect</span><br><span class="line">gpiochip0 [pinctrl-bcm2711] (58 lines)</span><br><span class="line">gpiochip1 [raspberrypi-exp-gpio] (8 lines)</span><br></pre></td></tr></table></figure>



<p>三列数据分别是 gpiochip 的名称（name）、标签（label）和行数（lines）。</p>
<h1 id="Linux-gpiofind-命令-查找指定名称的-GPIO-引脚"><a href="#Linux-gpiofind-命令-查找指定名称的-GPIO-引脚" class="headerlink" title="Linux gpiofind 命令 - 查找指定名称的 GPIO 引脚"></a>Linux gpiofind 命令 - 查找指定名称的 GPIO 引脚</h1><h2 id="介绍-227"><a href="#介绍-227" class="headerlink" title="介绍"></a>介绍</h2><p><strong>gpiofind</strong> 命令用于通过名称找到对应的 gpiochip 及行内偏移量。</p>
<p>gpiofind 命令由 <a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/">libgpiod</a> 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gpiod</span><br></pre></td></tr></table></figure>



<p>实际上，从 Linux 4.8 开始，不再推荐使用 sysfs 接口（&#x2F;sys&#x2F;class&#x2F;gpio）操作 GPIO，而是建议在用户空间使用字符设备进行操作，libgpiod 就是一个用于操作 GPIO 字符设备的库，同时提供了一些工具，方便开发者进行调试。</p>
<p>libgpiod 包含一系列命令，除了 gpiofind，还有 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpiodetect/">gpiodetect</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpioinfo/">gpioinfo</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpioget/">gpioget</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpioset/">gpioset</a> 和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpiomon/">gpiomon</a> 命令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpiofind [OPTIONS] &lt;name&gt;</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-h</code>, <code>--help</code> ：查看帮助并退出</li>
<li><code>-v</code>, <code>--version</code> ：查看版本信息并退出</li>
</ul>
<p><strong>参数</strong>：GPIO line 的名称 name</p>
<h2 id="示例-228"><a href="#示例-228" class="headerlink" title="示例"></a>示例</h2><p>查找树莓派 4B 系统上名为 “BT_ON” 的 GPIO line（非 root 用户需添加 sudo）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pi@raspberry:~$ <span class="built_in">sudo</span> gpiofind <span class="string">&quot;BT_ON&quot;</span></span><br><span class="line">gpiochip1 0</span><br></pre></td></tr></table></figure>



<p>输出的 gpiochip 及行内偏移量可作为 gpioget 和 gpioset 的输入，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpiofind <span class="string">&quot;BT_ON&quot;</span> | xargs gpioget</span><br></pre></td></tr></table></figure>



<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpioget `gpiofind <span class="string">&quot;BT_ON&quot;</span>`</span><br></pre></td></tr></table></figure>





<h1 id="Linux-gpioget-命令-获取-GPIO-引脚的当前值"><a href="#Linux-gpioget-命令-获取-GPIO-引脚的当前值" class="headerlink" title="Linux gpioget 命令 - 获取 GPIO 引脚的当前值"></a>Linux gpioget 命令 - 获取 GPIO 引脚的当前值</h1><h2 id="介绍-228"><a href="#介绍-228" class="headerlink" title="介绍"></a>介绍</h2><p><strong>gpioget</strong> 命令用于读取指定 GPIO line 的值。</p>
<p>gpioget 命令由 <a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/">libgpiod</a> 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gpiod</span><br></pre></td></tr></table></figure>



<p>实际上，从 Linux 4.8 开始，不再推荐使用 sysfs 接口（&#x2F;sys&#x2F;class&#x2F;gpio）操作 GPIO，而是建议在用户空间使用字符设备进行操作，libgpiod 就是一个用于操作 GPIO 字符设备的库，同时提供了一些工具，方便开发者进行调试。</p>
<p>libgpiod 包含一系列命令，除了 gpioget，还有 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpioset/">gpioset</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpiodetect/">gpiodetect</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpioinfo/">gpioinfo</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpiofind/">gpiofind</a> 和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpiomon/">gpiomon</a> 命令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpioget [OPTIONS] &lt;chip name/number&gt; &lt;offset 1&gt; &lt;offset 2&gt; ...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-l</code>, <code>--active-low</code> ：设置低电平为有效电平</li>
<li><code>-B</code>, <code>--bias=[as-is|disable|pull-down|pull-up]</code> ：设置 bias（默认使用 <code>as-is</code>）</li>
<li><code>-h</code>, <code>--help</code> ：查看帮助并退出</li>
<li><code>-v</code>, <code>--version</code> ：查看版本信息并退出</li>
</ul>
<p><strong>参数</strong>：指定 gpiochip 和 offset（行内偏移量），可同时指定多个 line。</p>
<h2 id="示例-229"><a href="#示例-229" class="headerlink" title="示例"></a>示例</h2><p>查看树莓派 4B 系统上 gpiochip1 的 line 信息（非 root 用户需添加 sudo）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pi@raspberry:~$ <span class="built_in">sudo</span> gpioinfo gpiochip1</span><br><span class="line">gpiochip1 - 8 lines:</span><br><span class="line">        line   0:      <span class="string">&quot;BT_ON&quot;</span>       unused   input  active-high</span><br><span class="line">        line   1:      <span class="string">&quot;WL_ON&quot;</span>       unused   input  active-high</span><br><span class="line">        line   2: <span class="string">&quot;PWR_LED_OFF&quot;</span> <span class="string">&quot;led1&quot;</span> output active-low [used]</span><br><span class="line">        line   3: <span class="string">&quot;GLOBAL_RESET&quot;</span> unused output active-high</span><br><span class="line">        line   4: <span class="string">&quot;VDD_SD_IO_SEL&quot;</span> <span class="string">&quot;vdd-sd-io&quot;</span> output active-high [used]</span><br><span class="line">        line   5:   <span class="string">&quot;CAM_GPIO&quot;</span>       unused  output  active-high</span><br><span class="line">        line   6:  <span class="string">&quot;SD_PWR_ON&quot;</span> <span class="string">&quot;sd_vcc_reg&quot;</span>  output  active-high [used]</span><br><span class="line">        line   7:    <span class="string">&quot;SD_OC_N&quot;</span>       unused   input  active-high</span><br></pre></td></tr></table></figure>



<p>读取 gpiochip1 的 line 0（也就是 BT_ON）的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pi@raspberry:~$ <span class="built_in">sudo</span> gpioget gpiochip1 0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>



<p>注意：只能读取 unused 状态的 line 值。</p>
<h1 id="Linux-gpioinfo-命令-显示-GPIO-控制器和引脚信息"><a href="#Linux-gpioinfo-命令-显示-GPIO-控制器和引脚信息" class="headerlink" title="Linux gpioinfo 命令 - 显示 GPIO 控制器和引脚信息"></a>Linux gpioinfo 命令 - 显示 GPIO 控制器和引脚信息</h1><h2 id="介绍-229"><a href="#介绍-229" class="headerlink" title="介绍"></a>介绍</h2><p><strong>gpioinfo</strong> 命令用于列出指定 gpiochip 的所有 line，以及它们的名称、使用者、方向、活动状态和其他标志。</p>
<p>gpioinfo 命令由 <a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/">libgpiod</a> 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gpiod</span><br></pre></td></tr></table></figure>



<p>实际上，从 Linux 4.8 开始，不再推荐使用 sysfs 接口（&#x2F;sys&#x2F;class&#x2F;gpio）操作 GPIO，而是建议在用户空间使用字符设备进行操作，libgpiod 就是一个用于操作 GPIO 字符设备的库，同时提供了一些工具，方便开发者进行调试。</p>
<p>libgpiod 包含一系列命令，除了 gpioinfo，还有 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpiodetect/">gpiodetect</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpioget/">gpioget</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpioset/">gpioset</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpiofind/">gpiofind</a> 和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpiomon/">gpiomon</a> 命令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpioinfo [OPTIONS] &lt;gpiochip&gt; ...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-h</code>, <code>--help</code> ：查看帮助并退出</li>
<li><code>-v</code>, <code>--version</code> ：查看版本信息并退出</li>
</ul>
<p><strong>参数</strong>：指定 gpiochip，如 gpiochip0、gpiochip1，可同时输入多个参数。如果没有参数，则查询所有 gpiochip 的所有 line 的信息。</p>
<h2 id="示例-230"><a href="#示例-230" class="headerlink" title="示例"></a>示例</h2><p>查看树莓派 4B 系统上所有 gpiochip 的所有 line 的信息（非 root 用户需添加 sudo）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pi@raspberry:~$ <span class="built_in">sudo</span> gpioinfo</span><br><span class="line">gpiochip0 - 58 lines:</span><br><span class="line">        line   0:     <span class="string">&quot;ID_SDA&quot;</span>       unused   input  active-high</span><br><span class="line">        line   1:     <span class="string">&quot;ID_SCL&quot;</span>       unused   input  active-high</span><br><span class="line">        line   2:       <span class="string">&quot;SDA1&quot;</span>       unused   input  active-high</span><br><span class="line">        line   3:       <span class="string">&quot;SCL1&quot;</span>       unused   input  active-high</span><br><span class="line">        ......</span><br><span class="line">gpiochip1 - 8 lines:</span><br><span class="line">        line   0:      <span class="string">&quot;BT_ON&quot;</span>       unused  output  active-high</span><br><span class="line">        line   1:      <span class="string">&quot;WL_ON&quot;</span>       unused  output  active-high</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure>



<p>只查看树莓派 4B 系统上 gpiochip1 的 line 信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pi@raspberry:~$ <span class="built_in">sudo</span> gpioinfo gpiochip1</span><br><span class="line">gpiochip1 - 8 lines:</span><br><span class="line">        line   0:      <span class="string">&quot;BT_ON&quot;</span>       unused  output  active-high</span><br><span class="line">        line   1:      <span class="string">&quot;WL_ON&quot;</span>       unused  output  active-high</span><br><span class="line">        line   2: <span class="string">&quot;PWR_LED_OFF&quot;</span> <span class="string">&quot;led1&quot;</span> output active-low [used]</span><br><span class="line">        line   3: <span class="string">&quot;GLOBAL_RESET&quot;</span> unused output active-high</span><br><span class="line">        line   4: <span class="string">&quot;VDD_SD_IO_SEL&quot;</span> <span class="string">&quot;vdd-sd-io&quot;</span> output active-high [used]</span><br><span class="line">        line   5:   <span class="string">&quot;CAM_GPIO&quot;</span>       unused  output  active-high</span><br><span class="line">        line   6:  <span class="string">&quot;SD_PWR_ON&quot;</span> <span class="string">&quot;sd_vcc_reg&quot;</span>  output  active-high [used]</span><br><span class="line">        line   7:    <span class="string">&quot;SD_OC_N&quot;</span>       unused   input  active-high</span><br></pre></td></tr></table></figure>



<p>每个 line 所列出的四列数据分别表示 line 的名称（如果没有设定则显示 unnamed）、使用情况（如果未被使用则显示 unused）、方向（input 或者 output）和有效电平（active-low 或者 active-high）。</p>
<h1 id="Linux-gpiomon-命令-监控-GPIO-引脚的状态变化"><a href="#Linux-gpiomon-命令-监控-GPIO-引脚的状态变化" class="headerlink" title="Linux gpiomon 命令 - 监控 GPIO 引脚的状态变化"></a>Linux gpiomon 命令 - 监控 GPIO 引脚的状态变化</h1><h2 id="介绍-230"><a href="#介绍-230" class="headerlink" title="介绍"></a>介绍</h2><p><strong>gpiomon</strong> 命令用于等待指定 GPIO line 上的事件，或指定要监视的事件。</p>
<p>gpiomon 命令由 <a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/">libgpiod</a> 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gpiod</span><br></pre></td></tr></table></figure>



<p>实际上，从 Linux 4.8 开始，不再推荐使用 sysfs 接口（&#x2F;sys&#x2F;class&#x2F;gpio）操作 GPIO，而是建议在用户空间使用字符设备进行操作，libgpiod 就是一个用于操作 GPIO 字符设备的库，同时提供了一些工具，方便开发者进行调试。</p>
<p>libgpiod 包含一系列命令，除了 gpiomon，还有 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpiodetect/">gpiodetect</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpioinfo/">gpioinfo</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpioget/">gpioget</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpioset/">gpioset</a> 和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpiofind/">gpiofind</a> 命令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpiomon [OPTIONS] &lt;chip name/number&gt; &lt;offset 1&gt; &lt;offset 2&gt; ...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-l</code>, <code>--active-low</code> ：设置低电平为有效电平</li>
<li><code>-B</code>, <code>--bias=[as-is|disable|pull-down|pull-up]</code> ：设置 bias（默认使用 <code>as-is</code>）</li>
<li><code>-n</code>, <code>--num-events=NUM</code> ：处理完 <code>NUM</code> 个事件后退出</li>
<li><code>-s</code>, <code>--silent</code> ：不打印事件信息</li>
<li><code>-r</code>, <code>--rising-edge</code> ：只处理上升沿事件</li>
<li><code>-f</code>, <code>--falling-edge</code> ：只处理下降沿事件</li>
<li><code>-b</code>, <code>--line-buffered</code> ：将标准输出设置为行缓冲</li>
<li><code>-F</code>, <code>--format=FMT</code> ：指定输出格式（<code>%o</code> 为 GPIO 行内偏移量，<code>%e</code> 为事件类型，<code>%s</code> 为事件时间戳秒数部分，<code>%n</code> 为事件时间戳纳秒部分）</li>
<li><code>-h</code>, <code>--help</code> ：查看帮助并退出</li>
<li><code>-v</code>, <code>--version</code> ：查看版本信息并退出</li>
</ul>
<h2 id="示例-231"><a href="#示例-231" class="headerlink" title="示例"></a>示例</h2><p>等待三次 GPIO（gpiochip0 line1）的上升沿事件，然后退出（非 root 用户需添加 sudo）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> gpiomon --num-events=3 --rising-edge gpiochip0 1</span><br><span class="line">event:  RISING EDGE offset: 3 timestamp: [    1151.814356387]</span><br><span class="line">event:  RISING EDGE offset: 3 timestamp: [    1151.815449803]</span><br><span class="line">event:  RISING EDGE offset: 3 timestamp: [    1152.091556803]</span><br></pre></td></tr></table></figure>



<p>等待单次下降沿事件，并按指定格式输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> gpiomon --format=<span class="string">&quot;%e %o %s %n&quot;</span> --falling-edge gpiochip0 1</span><br><span class="line">0 1 1156 615459801</span><br></pre></td></tr></table></figure>



<p>同时等待多个 line 上的事件，并在处理完第一个事件后退出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> gpiomon --silent --num-events=1 gpiochip0 2 3 5</span><br></pre></td></tr></table></figure>





<h1 id="Linux-gpioset-命令-设置-GPIO-引脚的值"><a href="#Linux-gpioset-命令-设置-GPIO-引脚的值" class="headerlink" title="Linux gpioset 命令 - 设置 GPIO 引脚的值"></a>Linux gpioset 命令 - 设置 GPIO 引脚的值</h1><h2 id="介绍-231"><a href="#介绍-231" class="headerlink" title="介绍"></a>介绍</h2><p><strong>gpioset</strong> 命令用于设置指定的 GPIO line 的值。</p>
<p>gpioset 命令由 <a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/">libgpiod</a> 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install gpiod</span><br></pre></td></tr></table></figure>



<p>实际上，从 Linux 4.8 开始，不再推荐使用 sysfs 接口（&#x2F;sys&#x2F;class&#x2F;gpio）操作 GPIO，而是建议在用户空间使用字符设备进行操作，libgpiod 就是一个用于操作 GPIO 字符设备的库，同时提供了一些工具，方便开发者进行调试。</p>
<p>libgpiod 包含一系列命令，除了 gpioset，还有 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpioget/">gpioget</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpiodetect/">gpiodetect</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpioinfo/">gpioinfo</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpiofind/">gpiofind</a> 和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/gpiomon/">gpiomon</a> 命令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpioset [OPTIONS] &lt;chip name/number&gt; &lt;offset1&gt;=&lt;value1&gt; &lt;offset2&gt;=&lt;value2&gt; ...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-l</code>, <code>--active-low</code> ：设置低电平为有效电平</li>
<li><code>-B</code>, <code>--bias=[as-is|disable|pull-down|pull-up]</code> ：设置 bias（默认使用 <code>as-is</code>）</li>
<li><code>-D</code>, <code>--drive=[push-pull|open-drain|open-source]</code> ：设置驱动模式（默认使用 <code>push-pull</code>）</li>
<li><code>-m</code>, <code>--mode=[exit|wait|time|signal]</code> ：设置完成后的动作模式</li>
<li><code>-s</code>, <code>--sec=SEC</code> ：当使用 <code>--mode=time</code> 选项时，指定等到的时间（单位：秒）</li>
<li><code>-u</code>, <code>--usec=USEC</code> ：当使用 <code>--mode=time</code> 选项时，指定等到的时间（单位：微秒）</li>
<li><code>-b</code>, <code>--background</code> ：设置完成后与控制终端分离</li>
<li><code>-h</code>, <code>--help</code> ：查看帮助并退出</li>
<li><code>-v</code>, <code>--version</code> ：查看版本信息并退出</li>
</ul>
<p><strong>参数</strong>：指定 gpiochip 和 offset（行内偏移量），以及对应的 value，可同时指定多个 line。</p>
<h2 id="示例-232"><a href="#示例-232" class="headerlink" title="示例"></a>示例</h2><p>查看树莓派 4B 系统上 gpiochip1 的 line 信息（非 root 用户需添加 sudo）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@raspberry:~$ sudo gpioinfo gpiochip1</span><br><span class="line">gpiochip1 - 8 lines:</span><br><span class="line">        line   0:      &quot;BT_ON&quot;       unused   input  active-high</span><br><span class="line">        line   1:      &quot;WL_ON&quot;       unused   input  active-high</span><br><span class="line">        line   2: &quot;PWR_LED_OFF&quot; &quot;led1&quot; output active-low [used]</span><br><span class="line">        line   3: &quot;GLOBAL_RESET&quot; unused output active-high</span><br><span class="line">        line   4: &quot;VDD_SD_IO_SEL&quot; &quot;vdd-sd-io&quot; output active-high [used]</span><br><span class="line">        line   5:   &quot;CAM_GPIO&quot;       unused  output  active-high</span><br><span class="line">        line   6:  &quot;SD_PWR_ON&quot; &quot;sd_vcc_reg&quot;  output  active-high [used]</span><br><span class="line">        line   7:    &quot;SD_OC_N&quot;       unused   input  active-high</span><br></pre></td></tr></table></figure>



<p>读取 gpiochip1 的 line 0（也就是 BT_ON）的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@raspberry:~$ sudo gpioget gpiochip1 0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>



<p>设置 gpiochip1 的 line 0 的值为 0（低电平）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@raspberry:~$ sudo gpioset gpiochip1 0=0</span><br></pre></td></tr></table></figure>



<p>再次读取 gpiochip1 的 line 0 的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@raspberry:~$ sudo gpioget gpiochip1 0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>





<h1 id="Linux-udevadm-命令-管理设备事件和属性"><a href="#Linux-udevadm-命令-管理设备事件和属性" class="headerlink" title="Linux udevadm 命令 - 管理设备事件和属性"></a>Linux udevadm 命令 - 管理设备事件和属性</h1><h2 id="介绍-232"><a href="#介绍-232" class="headerlink" title="介绍"></a>介绍</h2><p><strong>udevadm</strong>（英文全拼：udev administrator）是一个 udev 管理工具，可用于查询 udev 数据库中的设备信息，也可以从 sysfs 文件系统中查询到设备的属性以辅助创建 udev 规则。</p>
<p>udevadm 后接一个子命令和命令指定选项，以控制 udev 运行的行为、处理内核事件、控制事件队列，并且提供简单的调试机制。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">udevadm [--debug] [--version] [--<span class="built_in">help</span>]</span><br><span class="line">udevadm info [options] [devpath]</span><br><span class="line">udevadm trigger [options] [devpath]</span><br><span class="line">udevadm settle [options]</span><br><span class="line">udevadm control option</span><br><span class="line">udevadm monitor [options]</span><br><span class="line">udevadm <span class="built_in">test</span> [options] devpath</span><br><span class="line">udevadm test-builtin [options] <span class="built_in">command</span> devpath</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><p><code>--debug</code> ：显示调试信息。</p>
</li>
<li><p><code>--version</code> ：显示版本信息。</p>
</li>
<li><p><code>--help</code> ：显示帮助信息。</p>
</li>
<li><p>info</p>
<p>子命令 —— 查询 udev 数据库中的设备信息。</p>
<ul>
<li><code>-q</code>, <code>--query=TYPE</code> ：从数据库中查询指定类型的设备，需要使用 <code>--path</code> 和 <code>--name</code> 选项指定设备。合法的 TYPE 类型包括：设备名（name），链接（symlink），路径（path），属性（property）。</li>
<li><code>-p</code>, <code>--path=DEVPATH</code> ：指定设备的路径。</li>
<li><code>-n</code>, <code>--name=FILE</code> ：指定设备节点或者链接。</li>
<li><code>-a</code>, <code>--attribute-walk</code> ：打印指定设备的所有 sysfs 记录的属性，以用 udev 规则来匹配特殊的设备。该选项打印链上的所有设备信息，最大可能到 sys 目录。</li>
<li><code>-d</code>, <code>--device-id-of-file=FILE</code> ：打印主&#x2F;从设备号。</li>
<li><code>-e</code>, <code>--export-db</code> ：输出 udev 数据库中的内容。</li>
</ul>
</li>
<li><p>trigger</p>
<p>子命令 —— 接收内核发送来的设备事件，主要用于重放 coldplug 事件信息。</p>
<ul>
<li><code>-v</code>, <code>--verbose</code> ：输出将要被触发的设备列表。</li>
<li><code>-n</code>, <code>--dry-run</code> ：不真的触发事件。</li>
<li><code>-t</code>, <code>--type=TYPE</code> ：触发一个特殊的设备，合法的类型有 devices 和 subsystem，默认为 devices。</li>
<li><code>-c</code>, <code>--action=ACTION</code> ：被触发的事件，默认是 change。</li>
<li><code>-s</code>, <code>--subsystem-match=SUBSYSTEM</code> ：触发匹配子系统的设备事件，这个选项可以被多次指定，并且支持 shell 模式匹配。</li>
<li><code>-a</code>, <code>--attr-match=ATTRIBUTE=VALUE</code> ：触发匹配 sysfs 属性的设备事件，如果属性值和属性一起指定，属性的值可以使用 shell 模式匹配；如果没有指定值，会重新确认现有属性。（这个选项可以被多次指定）</li>
<li><code>-A</code>, <code>--attr-nomatch=ATTRIBUTE=VALUE</code> ：不要触发匹配属性的设备事件，如果可以使用模式匹配，也可以多次指定。</li>
<li><code>-p</code>, <code>--property-match=PROPERTY=VALUE</code> ：匹配与属性吻合的设备，可以多次指定支持模式匹配。</li>
<li><code>-g</code>, <code>--tag-match=PROPERTY</code> ：匹配与标签吻合的设备，可以多次指定。</li>
<li><code>-y</code>, <code>--sysname-match=NAME</code> ：匹配与 sys 设备名相同的设备，可以多次指定支持模式匹配。</li>
</ul>
</li>
<li><p>settle</p>
<p>子命令 —— 查看 udev 事件队列，如果所有事件全部处理完就退出。</p>
<ul>
<li><code>-t</code>, <code>--timeout=SECONDS</code> ：等待事件队列变空的最大等待时间，默认是120 秒，如果为 0 则立即退出。</li>
<li><code>-E</code>, <code>--exit-if-exists=FILE</code> ：如果文件存在就退出。</li>
</ul>
</li>
<li><p>monitor</p>
<p>子命令 —— 监听内核事件和 udev 发送的 events 事件，可以通过比较内核或者 udev 事件的时间戳来分析事件时序。</p>
<ul>
<li><code>-k</code>, <code>--kernel</code> ：输出内核事件。</li>
<li><code>-u</code>, <code>--udev</code> ：输出 udev 规则执行时的 udev 事件。</li>
<li><code>-p</code>, <code>--property</code> ：输出事件的属性。</li>
<li><code>-s</code>, <code>--subsystem-match=string[/string]</code> ：通过子系统或者设备类型过滤事件，只有匹配了子系统值的 udev 设备事件通过。</li>
<li><code>-t</code>, <code>--tag-match=string</code> ：通过属性过滤事件，只有匹配了标签的 udev 事件通过。</li>
</ul>
</li>
<li><p><strong>test</strong> 子命令 —— 模拟一个 udev 事件，打印出 debug 信息。</p>
</li>
</ul>
<p>提示：内核在启动时已经检测到了系统的硬件设备，并把硬件设备信息通过 sysfs 内核虚拟文件系统导出。udev 扫描 sysfs 文件系统，根据硬件设备信息生成热插拔（hotplug）事件，udev 再读取这些事件，生成对应的硬件设备文件。由于没有实际的硬件插拔动作，所以这一过程被称为 coldplug。</p>
<h2 id="示例-233"><a href="#示例-233" class="headerlink" title="示例"></a>示例</h2><p>查询块设备 &#x2F;dev&#x2F;sdc1 的路径信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ udevadm info -q path -n /dev/sdc1</span><br><span class="line">/devices/pci0000:00/0000:00:14.0/usb2/2-1/2-1:1.0/host4/target4:0:0/4:0:0:0/block/sdc/sdc1</span><br></pre></td></tr></table></figure>



<p>查询 RTC 设备的所有信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ udevadm info --query=all --name=/dev/rtc</span><br><span class="line">P: /devices/platform/i2c@4/i2c-4/4-006f/rtc/rtc0</span><br><span class="line">N: rtc0</span><br><span class="line">L: -100</span><br><span class="line">S: rtc</span><br><span class="line">E: DEVPATH=/devices/platform/i2c@4/i2c-4/4-006f/rtc/rtc0</span><br><span class="line">E: DEVNAME=/dev/rtc0</span><br><span class="line">E: MAJOR=252</span><br><span class="line">E: MINOR=0</span><br><span class="line">E: SUBSYSTEM=rtc</span><br><span class="line">E: USEC_INITIALIZED=5168933</span><br><span class="line">E: DEVLINKS=/dev/rtc</span><br></pre></td></tr></table></figure>



<p>不重启设备直接 reload udev 规则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">udevadm control --reload-rules &amp;&amp; udevadm trigger</span><br></pre></td></tr></table></figure>





<h1 id="Linux-modpoll-命令-Modbus-测试工具"><a href="#Linux-modpoll-命令-Modbus-测试工具" class="headerlink" title="Linux modpoll 命令 - Modbus 测试工具"></a>Linux modpoll 命令 - Modbus 测试工具</h1><h2 id="介绍-233"><a href="#介绍-233" class="headerlink" title="介绍"></a>介绍</h2><p><strong>modpoll</strong> 是一个基于 libmodbus 库的 Modbus 主站仿真工具，支持基于串行链路的 Modbus RTU、Modbus ASCII 和基于以太网的 Modbus TCP 协议。</p>
<p>如果您的系统没有 modpoll 命令，可以通过如下命令下载获得。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://www.modbusdriver.com/downloads/modpoll.tgz</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modpoll [OPTIONS] SERIALPORT|HOST [WRITEVALUES...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-m ascii</code> ：Modbus ASCII 协议。</li>
<li><code>-m rtu</code> ：Modbus RTU 协议（如果 SERIALPORT 参数包含 &#x2F; 则默认为该模式）。</li>
<li><code>-m tcp</code> ：MODBUS TCP 协议（如果 SERIALPORT 参数不包含 &#x2F; 则默认为该模式）。</li>
<li><code>-m udp</code> ：MODBUS UDP 协议。</li>
<li><code>-m enc</code> ：基于 TCP 的封装 Modbus RTU（Encapsulated Modbus RTU over TCP）。</li>
<li><code>-a #</code> ：从站地址（串行链路取值范围 1-247，TCP 取值范围 0-255，默认值为 1）。</li>
<li><code>-r #</code> ：起始地址（取值范围 1-65536，默认为 100）。</li>
<li><code>-c #</code> ：要读取的值的数量（1-125，默认值为 1），写入可选（使用 -c 1 强制 FC5 或 FC6）。</li>
<li><code>-t 0</code> ：离散输出（线圈）数据类型。</li>
<li><code>-t 1</code> ：离散输入数据类型。</li>
<li><code>-t 3</code> ：16 位输入寄存器数据类型。</li>
<li><code>-t 3:hex</code> ：16 位输入寄存器数据类型（以十六进制显示）。</li>
<li><code>-t 3:int</code> ：输入寄存器表中的 32 位整数数据类型。</li>
<li><code>-t 3:mod</code> ：输入寄存器表中的 32 位模块 10000 数据类型。</li>
<li><code>-t 3:float</code> ：输入寄存器表中的 32 位浮点数据类型。</li>
<li><code>-t 4</code> ：16 位输出（保持）寄存器数据类型（默认）。</li>
<li><code>-t 4:hex</code> ：16 位输出（保持）寄存器数据类型（以十六进制显示）。</li>
<li><code>-t 4:int</code> ：输出（保持）寄存器表中的 32 位整数数据类型。</li>
<li><code>-t 4:mod</code> ：输出（保持）寄存器表中的 32 位模块 10000 类型。</li>
<li><code>-t 4:float</code> ：输出（保持）寄存器表中的 32 位浮点数据类型。</li>
<li><code>-i</code> ：从站设备以大端字节序操作 32 位整数。</li>
<li><code>-f</code> ：从站设备以大端字节序操作 32 位浮点数。</li>
<li><code>-e</code> ：使用 Daniel&#x2F;Enron 单寄存器 32 位模式（暗示 -i 和 -f）。</li>
<li><code>-0</code> ：第一个引用（起始地址）是 0（PDU 寻址）而不是 1。</li>
<li><code>-1</code> ：只轮询一次，否则以设定的轮询间隔循环执行。</li>
<li><code>-l #</code> ：以毫秒为单位的轮询时间（默认为 1000）。</li>
<li><code>-o #</code> ：以秒为单位的超时（0.01 - 10.0，默认为 1.0 秒）。</li>
<li><code>-h</code> ：显示帮助信息。</li>
</ul>
<p>以下选项仅适用 MODBUS&#x2F;TCP, UDP 和 RTU over TCP：</p>
<ul>
<li><code>-p #</code> ：IP 协议端口号（默认为 502）</li>
</ul>
<p>以下选项仅适用 Modbus ASCII 和 Modbus RTU：</p>
<ul>
<li><code>-b #</code> ：波特率（例如 9600, 19200, …），默认为 19200。</li>
<li><code>-d #</code> ：数据位（ASCII 协议为 7 或 8，RTU 协议为 8)。</li>
<li><code>-s #</code> ：停止位（1 或 2，默认为 1）。</li>
<li><code>-p none</code> ：无校验。</li>
<li><code>-p even</code> ：偶校验（默认）。</li>
<li><code>-p odd</code> ：奇校验。</li>
<li><code>-4 #</code> ：RS-485 模式，传输时开启 RTS，之后还有 # 毫秒。</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li><code>SERIALPORT</code> ：串口设备，在 Windows 下如 COM1、COM2 等，在 Linux 下如 &#x2F;dev&#x2F;ttyS0、&#x2F;dev&#x2F;ttyS1 等。</li>
<li><code>HOST</code> ：主机名或 IP 地址。</li>
<li><code>WRITEVALUES</code> ：对于 Modbus 写入命令，需要在此依次填入数据域的数据，以空格分隔。</li>
</ul>
<h2 id="示例-234"><a href="#示例-234" class="headerlink" title="示例"></a>示例</h2><p>通过 Modbus RTU 从 ID 为 3 的从站设备中读取 500 地址开始的连续 10 个保持寄存器的值。（串口 COM1，波特率 9600，无奇偶校验）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modpoll -b 9600 -p none -m rtu -a 3 -r 500 -c 10 COM1</span><br></pre></td></tr></table></figure>



<p>通过 Modbus TCP 从 10.0.0.100 设备读取 100 地址开始的连续 5 个浮点数值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modpoll -t4:<span class="built_in">float</span> -r 100 -c 5 -1 10.0.0.100</span><br></pre></td></tr></table></figure>



<p>通过 Modbus TCP 往 10.0.0.100 设备 1201 地址写保持寄存器，值为 1234。（使用 FC 16 功能码）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modpoll -r 1201 10.0.0.100 1234</span><br></pre></td></tr></table></figure>



<p>通过 Modbus TCP 往 10.0.0.100 设备 1201 地址写保持寄存器，值为 1234。（使用 FC 6 功能码）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modpoll -r 1201 -c 1 10.0.0.100 1234</span><br></pre></td></tr></table></figure>



<p>通过 Modbus RTU 执行一次「写单个线圈」命令，开启 1 号继电器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modpoll -m rtu -1 -a 1 -r 1 -c 1 -b 9600 -p none -t 0 /dev/ttyUSB1 1</span><br></pre></td></tr></table></figure>



<p>通过 Modbus RTU 执行一次「写单个线圈」命令，关闭 1 号继电器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modpoll -m rtu -1 -a 1 -r 1 -c 1 -b 9600 -p none -t 0 /dev/ttyUSB1 0</span><br></pre></td></tr></table></figure>



<p>通过 Modbus RTU 循环执行「读线圈状态」命令，读取 1 号继电器状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modpoll -m rtu -a 1 -r 1 -c 1 -b 9600 -p none -t 0 /dev/ttyUSB1</span><br></pre></td></tr></table></figure>





<h1 id="Linux-usb-modeswitch-命令-切换-USB-设备模式"><a href="#Linux-usb-modeswitch-命令-切换-USB-设备模式" class="headerlink" title="Linux usb_modeswitch 命令 - 切换 USB 设备模式"></a>Linux usb_modeswitch 命令 - 切换 USB 设备模式</h1><h2 id="介绍-234"><a href="#介绍-234" class="headerlink" title="介绍"></a>介绍</h2><p><strong>usb_modeswitch</strong> 命令用于控制“多状态” USB 设备的模式，它基于 libusb1&#x2F;libusbx 库开发。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usb_modeswitch [&lt;params&gt;] [-c filename]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-h</code>, <code>--help</code>：显示帮助信息。</li>
<li><code>-e</code>, <code>--version</code>：打印版本信息并退出。</li>
<li><code>-j</code>, <code>--find-mbim</code>：返回带 MBIM 接口的配置号（config no.）。</li>
<li><code>-v</code>, <code>--default-vendor NUM</code>：原始模式的供应商 ID（必填）。</li>
<li><code>-p</code>, <code>--default-product NUM</code>：原始模式的产品 ID（必填）。</li>
<li><code>-V</code>, <code>--target-vendor NUM</code>：目标模式供应商 ID（可选）。</li>
<li><code>-P</code>, <code>--target-product NUM</code>：目标模式产品 ID（可选）。</li>
<li><code>-C</code>, <code>--target-class NUM</code>：目标模式设备类（可选）。</li>
<li><code>-b</code>, <code>--bus-num NUM</code>：设备的系统总线号（用于硬 ID）。</li>
<li><code>-g</code>, <code>--device-num NUM</code>：系统设备号（用于硬 ID）。</li>
<li><code>-m</code>, <code>--message-endpoint NUM</code>：将消息传输定向到那里（可选）。</li>
<li><code>-M</code>, <code>--message-content &lt;msg&gt;</code>：要发送的消息（十六进制数字作为字符串）。</li>
<li><code>-2</code>, <code>--message-content2 &lt;msg&gt;</code>：要发送的附加消息（推荐 -n）。</li>
<li><code>-3</code>, <code>--message-content3 &lt;msg&gt;</code>：要发送的附加消息（推荐 -n）。</li>
<li><code>-w</code>, <code>--release-delay NUM</code>：在释放接口之前等待 NUM 毫秒。</li>
<li><code>-n</code>, <code>--need-response</code>：已过时，无效（始终开启）。</li>
<li><code>-r</code>, <code>--response-endpoint NUM</code>：从那里读取响应（可选）。</li>
<li><code>-K</code>, <code>--std-eject</code>：发送标准 EJECT 序列。</li>
<li><code>-d</code>, <code>--detach-only</code>：分离活动驱动程序，无进一步操作。</li>
<li><code>-H</code>, <code>--huawei-mode</code>：应用一个特殊的程序。</li>
<li><code>-J</code>, <code>--huawei-new-mode</code>：应用一个特殊的程序。</li>
<li><code>-X</code>, <code>--huawei-alt-mode</code>：应用一个特殊的程序。</li>
<li><code>-S</code>, <code>--sierra-mode</code>：应用一个特殊的程序。</li>
<li><code>-O</code>, <code>--sony-mode</code>：应用一个特殊的程序。</li>
<li><code>-G</code>, <code>--gct-mode</code>：应用一个特殊的程序。</li>
<li><code>-N</code>, <code>--sequans-mode</code>：应用一个特殊的程序。</li>
<li><code>-A</code>, <code>--mobileaction-mode</code>：应用一个特殊的程序。</li>
<li><code>-T</code>, <code>--kobil-mode</code>：应用一个特殊的程序。</li>
<li><code>-L</code>, <code>--cisco-mode</code>：应用一个特殊的程序。</li>
<li><code>-B</code>, <code>--qisda-mode</code>：应用一个特殊的程序。</li>
<li><code>-E</code>, <code>--quanta-mode</code>：应用一个特殊的程序。</li>
<li><code>-F</code>, <code>--pantech-mode NUM</code>：应用一个特殊的程序，需要传入 NUM 参数。</li>
<li><code>-Z</code>, <code>--blackberry-mode</code>：应用一个特殊的程序。</li>
<li><code>-U</code>, <code>--option-mode</code>：应用一个特殊的程序。</li>
<li><code>-R</code>, <code>--reset-usb</code>：在所有其他操作后重置设备。</li>
<li><code>-Q</code>, <code>--quiet</code>：不显示进度或错误消息。</li>
<li><code>-W</code>, <code>--verbose</code>：打印所有设置和调试输出。</li>
<li><code>-D</code>, <code>--sysmode</code>：具体结果和系统日志消息。</li>
<li><code>-s</code>, <code>--check-success &lt;seconds&gt;</code>：带超时的切换结果检查。</li>
<li><code>-I</code>, <code>--inquire</code>：已过时，没有影响。</li>
<li><code>-c</code>, <code>--config-file &lt;filename&gt;</code>：从文件加载长配置。</li>
<li><code>-t</code>, <code>--stdinput</code>：从标准输入读取长配置。</li>
<li><code>-f</code>, <code>--long-config &lt;text&gt;</code>：从字符串中获取长配置。</li>
<li><code>-i</code>, <code>--interface NUM</code>：选择初始 USB 接口（默认 0）。</li>
<li><code>-u</code>, <code>--configuration NUM</code>：选择 USB 配置。</li>
<li><code>-a</code>, <code>--altsetting NUM</code>：选择备用 USB 接口设置。</li>
</ul>
<h2 id="示例-235"><a href="#示例-235" class="headerlink" title="示例"></a>示例</h2><p>执行 <code>lsusb</code> 扫描 USB 设备，查看目标设备的信息，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Bus 003 Device 006: ID 0bda:1a2b Realtek Semiconductor Corp. DISK</span><br></pre></td></tr></table></figure>



<p>操作设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usb_modeswitch -KW -v 0bda -p 1a2b</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ppsctl-命令-管理-PPS-信号"><a href="#Linux-ppsctl-命令-管理-PPS-信号" class="headerlink" title="Linux ppsctl 命令 - 管理 PPS 信号"></a>Linux ppsctl 命令 - 管理 PPS 信号</h1><h2 id="介绍-235"><a href="#介绍-235" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ppsctl</strong> 命令是 pps-tools 软件包中的一部分，用于管理和配置 PPS 信号。它提供对 PPS 信号进行测试和调试的功能，允许用户查看和调整与 PPS 相关的参数。</p>
<p>提示</p>
<p>pps-tools 软件包提供了与 PPS（Pulse-Per-Second，脉冲每秒）信号相关的工具，该软件包提供了 ppscheck、ppsctl、ppsfind、ppsldisc、ppstest、ppswatch 等命令。</p>
<p>关于 LinuxPPS 命令和 API 接口的详细介绍可查阅 <a target="_blank" rel="noopener" href="http://linuxpps.org/">http://linuxpps.org</a> 上的 Wiki 文档。</p>
<p><strong>安装</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install pps-tools</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ppsctl [-bBfFac] &lt;ppsdev&gt;</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-b</code>：绑定内核 PPS 消费者。</li>
<li><code>-B</code>：解除绑定内核 PPS 消费者。</li>
<li><code>-f</code>：设置内核 NTP PPS 标志。</li>
<li><code>-F</code>：取消设置内核 NTP PPS 标志。</li>
<li><code>-a</code>：使用 assert edge。</li>
<li><code>-c</code>：使用 clear edge（默认）。</li>
</ul>
<h2 id="示例-236"><a href="#示例-236" class="headerlink" title="示例"></a>示例</h2><p>启动 PPS 输入设备进行时间同步：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ppsctl /dev/pps0</span><br></pre></td></tr></table></figure>



<p>检查同步状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ppstest /dev/pps0</span><br></pre></td></tr></table></figure>





<h1 id="Linux-hexdump-命令-查看二进制文件"><a href="#Linux-hexdump-命令-查看二进制文件" class="headerlink" title="Linux hexdump 命令 - 查看二进制文件"></a>Linux hexdump 命令 - 查看二进制文件</h1><h2 id="介绍-236"><a href="#介绍-236" class="headerlink" title="介绍"></a>介绍</h2><p><strong>hexdump</strong> 命令通常用于查看二进制文件，可以将二进制文件转换为 ASCII、八进制、十进制、十六进制格式进行查看。</p>
<p>注：hexdump 有一个缩写命令 hd，下面所有命令中都可以用 hd 替换 hexdump。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump [OPTIONS...] [FILES...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong></p>
<ul>
<li><code>-b</code> ：每个字节显示为八进制。一行共16个字节，一行开始以十六进制显示偏移值。</li>
<li><code>-c</code> ：每个字节显示为 ASCII 字符。</li>
<li><code>-C</code> ：每个字节显示为十六进制和相应的 ASCII 字符。标准十六进制 + ascii 码显示，十六进制显示偏移量，每行16个字符，每字符两位显示，不足补0，结尾显示当前16位数据的 ascii 码值，以 <code>|</code> 框住。</li>
<li><code>-d</code> ：双字节十进制显示，十六进制显示偏移量，每行8组（16字节）每组5位，不足补零，列间以空格分隔，以无符号十进制数值显示。</li>
<li><code>-e &lt;format_string&gt;</code> ：指定格式字符串，格式字符串包含在一对单引号中。</li>
<li><code>-f &lt;format_file&gt;</code> ：根据 format_file 中的格式进行输出，忽略 format_file 中空行及以 <code>#</code> 开始的行会。</li>
<li><code>-n &lt;length&gt;</code> ：只显示前面 length 个字节的数据。</li>
<li><code>-o</code> ：双字节八进制显示。十六进制显示偏移量，每行8组数据，每数据占两字节，6列，不足补零，以空格分隔。</li>
<li><code>-s &lt;offset&gt;</code> ：跳过从开始的 offset 个字节，默认输入十进制，以 0x 或 0X 开始按16进制处理，否则如以 0 开始按八进制处理，如果以 b&#x2F;k&#x2F;m 结尾，则原数值乘以 512&#x2F;1024&#x2F;1048576。</li>
<li><code>-v</code> ：显示所有数据，如果不包含这一选项，对于同上一行完全相同的数据，hexdump 会以 * 代替显示。</li>
<li><code>-x</code> ：两位十六进制显示，十六进制显示偏移量，每行8组数据，每数据占两字节，4列，不足补零，以空格分隔。</li>
</ul>
<p><strong>格式</strong>：</p>
<p>-e 选项指定格式字符串，格式字符串包含在一对单引号中，格式字符串形如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a/b &quot;format1&quot; &quot;format2&quot;&#x27;</span></span><br></pre></td></tr></table></figure>



<p>每个格式字符串由三部分组成，每个由空格分隔，第一个形如 a&#x2F;b，b 表示对每 b 个输入字节应用 format1 格式，a 表示对每 a 个输入字节应用 format2 格式，一般 a&gt;b，且 b 只能为 1、2、4，另外 a 可以省略，省略则 a&#x3D;1。format1 和 format2 中可以使用类似 printf 的格式字符串，如：</p>
<ul>
<li><code>%02d</code> ：两位十进制</li>
<li><code>%03x</code> ：三位十六进制</li>
<li><code>%02o</code> ：两位八进制</li>
<li><code>%c</code> ：单个字符等</li>
</ul>
<p>还有一些特殊的用法：</p>
<ul>
<li><code>%_ad</code> ：标记下一个输出字节的序号，用十进制表示</li>
<li><code>%_ax</code> ：标记下一个输出字节的序号，用十六进制表示</li>
<li><code>%_ao</code> ：标记下一个输出字节的序号，用八进制表示</li>
<li><code>%_p</code> ：对不能以常规字符显示的用 <code>.</code> 代替</li>
</ul>
<p>同一行如果要显示多个格式字符串，则可以跟多个 -e 选项。</p>
<h2 id="示例-237"><a href="#示例-237" class="headerlink" title="示例"></a>示例</h2><p>假设有文件 test.txt，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> test.txt </span><br><span class="line">ABCDEFG</span><br><span class="line">HIJKLMN</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>



<p>以八进制显示文件里面的字符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexdump -b test.txt </span><br><span class="line">0000000 101 102 103 104 105 106 107 012 110 111 112 113 114 115 116 012</span><br><span class="line">0000010 061 062 063 064 065 066 067 012                                </span><br><span class="line">0000018</span><br></pre></td></tr></table></figure>



<p>第一列是十六进制表示的偏移值，最后一个 0x18 即表示 test.txt 文件共 24 个字节。每一行显示16个字节，每行后面有一个换行符 <code>\n</code>（八进制为 012）。</p>
<p>再以 ASCII 码显示，这样更清晰：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexdump -c test.txt </span><br><span class="line">0000000   A   B   C   D   E   F   G  \n   H   I   J   K   L   M   N  \n</span><br><span class="line">0000010   1   2   3   4   5   6   7  \n                                </span><br><span class="line">0000018</span><br></pre></td></tr></table></figure>



<p>显示十六进制和相应的 ASCII 字符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexdump -C test.txt </span><br><span class="line">00000000  41 42 43 44 45 46 47 0a  48 49 4a 4b 4c 4d 4e 0a  |ABCDEFG.HIJKLMN.|</span><br><span class="line">00000010  31 32 33 34 35 36 37 0a                           |1234567.|</span><br><span class="line">00000018</span><br></pre></td></tr></table></figure>



<p>只查看前3个字节内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexdump -C -n 3 test.txt </span><br><span class="line">00000000  41 42 43                                          |ABC|</span><br><span class="line">00000003</span><br></pre></td></tr></table></figure>



<p>查看偏移16个字节后的3个字节内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexdump -C -n 3 -s 16 test.txt </span><br><span class="line">00000010  31 32 33                                          |123|</span><br><span class="line">00000013</span><br></pre></td></tr></table></figure>



<p>在嵌入式开发中，hexdump 命令也很有用，比如查看 eeprom 中的数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C /sys/bus/i2c/devices/3-0054/eeprom</span><br></pre></td></tr></table></figure>



<p>或者查看设备树节点的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C /proc/device-tree/soc@0/compatible</span><br></pre></td></tr></table></figure>





<h1 id="Linux-memtester-命令-测试内存稳定性和完整性"><a href="#Linux-memtester-命令-测试内存稳定性和完整性" class="headerlink" title="Linux memtester 命令 - 测试内存稳定性和完整性"></a>Linux memtester 命令 - 测试内存稳定性和完整性</h1><h2 id="介绍-237"><a href="#介绍-237" class="headerlink" title="介绍"></a>介绍</h2><p><strong>memtester</strong>（英文全拼：memory tester）是 Linux 下的一款内存测试工具，可用于内存压力测试及查找内存子系统故障。</p>
<p>memtester 运行在用户空间下，是一款用于<strong>测试内存正确性</strong>的命令行实用工具，适用于大多数平台。可以在 32 位或 64 位的类 Unix 操作系统编译和运行（当然也包括 macOS）。这款工具主要面向硬件开发人员，从 4.1.0 版本开始，memtester 可以指定起始物理内存地址进行测试。</p>
<p>memtester 工具主要是捕获内存错误和一直处于很高或者很低的坏位，其测试的主要项目有随机值、异或比较、减法、乘法、除法、与或运算等等。通过给定测试内存的大小和次数，可以对系统现有的内存进行上面项目的测试。通过指定物理地址，memtester 还可以用于测试内存映射 I&#x2F;O 设备和类似设备。需要注意的是，内存区域在测试过程中会被覆盖，因此要特别小心，如果指定为系统或其他应用程序分配的内存，将可能导致它们崩溃。</p>
<p>如果你的系统没有 memtester 工具，请先安装，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install memtester</span><br></pre></td></tr></table></figure>



<p>项目官网：<a target="_blank" rel="noopener" href="http://pyropus.ca/software/memtester/">http://pyropus.ca/software/memtester</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">memtester [-p PHYSADDR [-d DEVICE]] &lt;MEMORY&gt; [ITERATIONS]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-p PHYSADDR</code> ：测试从给定的物理地址 PHYSADDR 起始的特定内存区域（以十六进制表示），通过映射 -d 选项指定的设备。</li>
<li><code>-d DEVICE</code> ：指定设备，默认为 &#x2F;dev&#x2F;mem 设备。</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li><code>MEMORY</code> ：需要分配和测试的内存大小，默认以兆字节为单位，可以通过后缀 B、K、M 或 G 分别表示字节、千字节、兆字节或千兆字节。</li>
<li><code>ITERATIONS</code> ：循环测试次数（默认为无限次）。</li>
</ul>
<h2 id="示例-238"><a href="#示例-238" class="headerlink" title="示例"></a>示例</h2><p>提示：因为系统运行和本工具运行都需要内存，所以不能把所有的内存都测试到，可以先用 free 命令查看系统剩余多少内存空间再测试。</p>
<p>测试 300M 内存 10 次</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">memtester 300M 10</span><br></pre></td></tr></table></figure>



<p>测试结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">memtester version 4.3.0 (64-bit)</span><br><span class="line">Copyright (C) 2001-2012 Charles Cazabon.</span><br><span class="line">Licensed under the GNU General Public License version 2 (only).</span><br><span class="line"></span><br><span class="line">pagesize is 4096</span><br><span class="line">pagesizemask is 0xfffffffffffff000</span><br><span class="line">want 300MB (314572800 bytes)</span><br><span class="line">got  300MB (314572800 bytes), trying mlock ...locked.</span><br><span class="line">Loop 1/10:</span><br><span class="line">  Stuck Address       : ok</span><br><span class="line">  Random Value        : ok</span><br><span class="line">  Compare XOR         : ok</span><br><span class="line">  Compare SUB         : ok</span><br><span class="line">  Compare MUL         : ok</span><br><span class="line">  Compare DIV         : ok</span><br><span class="line">  Compare OR          : ok</span><br><span class="line">  Compare AND         : ok</span><br><span class="line">  Sequential Increment: ok</span><br><span class="line">  Solid Bits          : ok</span><br><span class="line">  Block Sequential    : ok</span><br><span class="line">  Checkerboard        : ok</span><br><span class="line">  Bit Spread          : ok</span><br><span class="line">  Bit Flip            : ok</span><br><span class="line">  Walking Ones        : ok</span><br><span class="line">  Walking Zeroes      : ok</span><br><span class="line"></span><br><span class="line">Loop 2/10:</span><br><span class="line">  ......</span><br><span class="line">  </span><br><span class="line">Loop 10/10:</span><br><span class="line">  Stuck Address       : ok         </span><br><span class="line">  Random Value        : ok</span><br><span class="line">  Compare XOR         : ok</span><br><span class="line">  Compare SUB         : ok</span><br><span class="line">  Compare MUL         : ok</span><br><span class="line">  Compare DIV         : ok</span><br><span class="line">  Compare OR          : ok</span><br><span class="line">  Compare AND         : ok</span><br><span class="line">  Sequential Increment: ok</span><br><span class="line">  Solid Bits          : ok         </span><br><span class="line">  Block Sequential    : ok         </span><br><span class="line">  Checkerboard        : ok         </span><br><span class="line">  Bit Spread          : ok         </span><br><span class="line">  Bit Flip            : ok         </span><br><span class="line">  Walking Ones        : ok         </span><br><span class="line">  Walking Zeroes      : ok         </span><br><span class="line">  8-bit Writes        : ok</span><br><span class="line">  16-bit Writes       : ok</span><br><span class="line"></span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>



<p>结果全部为 ok 则说明内存工作正常。</p>
<h1 id="Linux-seq-命令-生成数字序列"><a href="#Linux-seq-命令-生成数字序列" class="headerlink" title="Linux seq 命令 - 生成数字序列"></a>Linux seq 命令 - 生成数字序列</h1><h2 id="介绍-238"><a href="#介绍-238" class="headerlink" title="介绍"></a>介绍</h2><p><strong>seq</strong>（英文全拼：sequence）命令用于产生一串序列化的数字，即从某个数到另外一个数之间的所有整数。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">seq</span> [OPTION]... LAST</span><br><span class="line"><span class="built_in">seq</span> [OPTION]... FIRST LAST</span><br><span class="line"><span class="built_in">seq</span> [OPTION]... FIRST INCREMENT LAST</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-f</code>, <code>--format=FORMAT</code> ：使用 printf 样式的浮点格式。</li>
<li><code>-s</code>, <code>--separator=STRING</code> ：使用指定字符串分隔数字（默认使用：<code>\n</code>）。</li>
<li><code>-w</code>, <code>--equal-width</code> ：在列前添加 0 使得宽度相同。</li>
<li><code>--help</code> ：显示帮助信息并退出。</li>
<li><code>--version</code> ：输出版本信息并退出。</li>
</ul>
<p><strong>参数</strong>：<code>FIRST</code> 为首数，<code>INCREMENT</code> 为增量，<code>LAST</code> 为尾数。</p>
<h2 id="示例-239"><a href="#示例-239" class="headerlink" title="示例"></a>示例</h2><p>指定格式输出 9-11 的整数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">seq</span> -f<span class="string">&quot;%3g&quot;</span> 9 11</span><br><span class="line">  9</span><br><span class="line"> 10</span><br><span class="line"> 11</span><br></pre></td></tr></table></figure>



<p>指定输出等宽数字</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">seq</span> -w 98 2 102</span><br><span class="line">098</span><br><span class="line">100</span><br><span class="line">102</span><br></pre></td></tr></table></figure>





<h1 id="Linux-cyclictest-命令-测试-CPU-负载和响应时间"><a href="#Linux-cyclictest-命令-测试-CPU-负载和响应时间" class="headerlink" title="Linux cyclictest 命令 - 测试 CPU 负载和响应时间"></a>Linux cyclictest 命令 - 测试 CPU 负载和响应时间</h1><h2 id="介绍-239"><a href="#介绍-239" class="headerlink" title="介绍"></a>介绍</h2><p><strong>cyclictest</strong> 是一个用于测试 Linux 内核实时性的命令行程序，是 rt-tests 下的一个测试工具，也是 rt-tests 下使用最广泛的测试工具，一般用来测试 Linux 内核的延迟。</p>
<p>cyclictest 命令由 rt-tests 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install rt-tests</span><br></pre></td></tr></table></figure>



<p>代码仓库：<a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/utils/rt-tests/rt-tests">https://git.kernel.org/pub/scm/utils/rt-tests/rt-tests</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cyclictest &lt;options&gt;</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>, <code>--affinity[=PROC-SET]</code>：指示 CPU 亲和性，即在处理器 N 上运行线程，例如 <code>-a 0,1,2</code>、<code>-a 0-2</code>、<code>-a 0-2,4</code> 都可以，<code>!</code> 表示否定，如 <code>-a !2-4</code> 表示绑定在 2-4 以外的所有 CPU 核上。</li>
<li><code>-A</code>, <code>--align=USEC</code>：以微秒为单位将测量线程唤醒与特定偏移量对齐。</li>
<li><code>-b</code>, <code>--breaktrace=USEC</code>：调试选项，用于控制实施抢占补丁中的延迟跟踪器。当延时大于 USEC 指定的值时，发送停止跟踪。USEC 单位为 μs。</li>
<li><code>-c</code>, <code>--clock=CLOCK</code>：选择时钟。0 为线性增长时钟，1 为墙上时间时钟。当设置 <code>-s</code> 选项时，该选项失效。</li>
<li><code>-C</code>, <code>--context</code>：上下文切换。调试相关，和 <code>-b</code> 选项一起用的。</li>
<li><code>-d</code>, <code>--distance=DIST</code>：当多个线程时，设置间隔（睡眠时间）的增量 distance。interval (线程n) &#x3D; interval (线程n-1) + DIST。当该选项设置为 0 时，即 DIST&#x3D;0 时，所有线程都会在同一时间醒来，不过这违背了cyclictest 的初衷，它是想测试每时每刻系统响应速度，而不是一瞬间把系统爆掉。</li>
<li><code>-E</code>, <code>--event</code>：调试相关，和 <code>-b</code> 选项联合使用。</li>
<li><code>-f</code>, <code>--ftrace</code>：调试相关，和 <code>-b</code> 选项联合使用。</li>
<li><code>-h</code>, <code>--histogram=US</code>：输出直方图到 stdout。指定要跟踪的最大的延迟数值。</li>
<li><code>--histfile=&lt;path&gt;</code>：输出直方图到文件。</li>
<li><code>-H</code>：同 <code>-h</code> 选项，同时该选项还会输出多一列数据在最右边，表示求和，当只有一个线程时，<code>-H</code> 等价于 <code>-h</code>。</li>
<li><code>-i</code>, <code>--interval=INTV</code>：设置第一个线程的间隔（睡眠时间），默认 1000us。</li>
<li><code>-l</code>, <code>--loops=LOOPS</code>：默认为 0，表示无止境测下去。</li>
<li><code>-m</code>, <code>--mlockall</code>：锁定当前和未来的内存分配以阻止被 page out（页调出）。</li>
<li><code>-M</code>, <code>--refresh_on_max</code>：延迟更新屏幕直到达到新的最大延迟（对于在低带宽连接上运行循环测试很有用）。</li>
<li><code>-n</code>, <code>--nanosleep</code>：使用 clock_nanosleep 代替 posix interval timer。</li>
<li><code>-N</code>, <code>--nsecs</code>：用纳秒为单位显示结果，而不是默认的微秒。</li>
<li><code>-o</code>, <code>--oscope=RED</code>：示波器模式。</li>
<li><code>-O</code>, <code>--traceopt=TRACING_OPTION</code>：跟踪选项相关。</li>
<li><code>-p</code>, <code>--prio=PRIO</code>：设置第一个线程的优先级。Priority(n) &#x3D; max (Priority(n-1)-1, 0)</li>
<li><code>-q</code>, <code>--quiet</code>：静默模式，只输出概述信息。适用于自动化测试的时候，在脚本中使用这个选项。</li>
<li><code>-r</code>, <code>--relative</code>：使用相对时间。默认绝对时间。官方手册不建议使用。</li>
<li><code>-s</code>, <code>--system</code>：使用 sys_nanosleep 和 sys_setitimer 取代 posix timer。但是 <code>-s</code> 选项只应该在一个线程时使用，因为 itimer 每个进程只有一个，而不是每个线程都有。该选项可以结合 <code>-n</code> 选项一起使用，这样就不会受限于只对一个线程使用了。</li>
<li><code>-S</code>, <code>--smp</code>：为 SMP 系统上的标准测试设置选项。等效于使用选项 <code>-t -a -n</code> 以及在所有线程中保持任何指定的优先级相等。</li>
<li><code>-t</code>, <code>--threads[=NUM]</code>：该选项用来指定线程数。没有指定该选项时，默认 1 个线程。指定了该选项但又没有指定数字时，会开启 CPU 核心个数个线程。</li>
<li><code>-T</code>, <code>--tracer=TRACEFUNC</code>：跟踪器相关。</li>
<li><code>-v</code>, <code>--verbose</code>：输出统计信息。结合 <code>-l</code> 使用。</li>
<li><code>-D</code>, <code>--duration=TIME</code>：运行时间，默认单位 s，可以使用 “m h d” 代表分钟、小时、天。</li>
<li><code>-w</code>, <code>--wakeup</code>：唤醒追踪，配合 <code>-b</code> 选项。</li>
<li><code>-W</code>, <code>--wakeuprt</code>：实时线程唤醒追踪，配合 <code>-b</code> 选项。</li>
<li><code>-y</code>, <code>--policy=NAME</code>：设置调度策略。可选 other、normal、batch、idle、fifo、rr 策略。</li>
</ul>
<h2 id="示例-240"><a href="#示例-240" class="headerlink" title="示例"></a>示例</h2><p>运行 5 个线程，线程优先级 80，无限循环</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cyclictest -t 5 -p 80 -n</span><br></pre></td></tr></table></figure>



<p>运行 1 个线程（使用 clock_nanosleep），线程优先级 80，间隔 10000 微秒，10000 次循环，无负载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cyclictest -t1 -p 80 -n -i 10000 -l 10000</span><br></pre></td></tr></table></figure>



<p>运行 1 个线程（使用 posix interval timer）线程优先级 80，间隔 10000 微秒，10000 次循环，无负载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cyclictest -t1 -p 80 -i 10000 -l 10000</span><br></pre></td></tr></table></figure>



<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>下面是 cyclictest 测试示例运行时的打印信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> cyclictest -t 5 -p 80</span><br><span class="line"><span class="comment"># /dev/cpu_dma_latency set to 0us</span></span><br><span class="line">policy: fifo: loadavg: 1.85 1.89 3.04 1/2760 1556268           </span><br><span class="line"></span><br><span class="line">T: 0 (1556027) P:80 I:1000 C:  14957 Min:      1 Act:    2 Avg:    2 Max:     258</span><br><span class="line">T: 1 (1556028) P:80 I:1500 C:   9971 Min:      1 Act:    2 Avg:    2 Max:     365</span><br><span class="line">T: 2 (1556029) P:80 I:2000 C:   7478 Min:      1 Act:    7 Avg:    3 Max:     388</span><br><span class="line">T: 3 (1556030) P:80 I:2500 C:   5982 Min:      1 Act:    4 Avg:    2 Max:      39</span><br><span class="line">T: 4 (1556031) P:80 I:3000 C:   4985 Min:      1 Act:    3 Avg:    3 Max:     224</span><br></pre></td></tr></table></figure>



<p>输出字段说明如下表所示：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>T</code></td>
<td>线程序号，括号里面是 PID</td>
</tr>
<tr>
<td><code>P</code></td>
<td>线程优先级</td>
</tr>
<tr>
<td><code>C</code></td>
<td>计数器（线程的时间间隔每达到一次，计数器加 1）</td>
</tr>
<tr>
<td><code>I</code></td>
<td>时间间隔，单位是微秒（us）</td>
</tr>
<tr>
<td><code>Min</code></td>
<td>最小延时，单位是微秒（us）</td>
</tr>
<tr>
<td><code>Act</code></td>
<td>最近一次的延时，单位是微秒（us）</td>
</tr>
<tr>
<td><code>Avg</code></td>
<td>平均延时，单位是微秒（us）</td>
</tr>
<tr>
<td><code>Max</code></td>
<td>最大延时，单位是微秒（us）</td>
</tr>
</tbody></table>
<h1 id="Linux-strace-命令-跟踪系统调用和信号"><a href="#Linux-strace-命令-跟踪系统调用和信号" class="headerlink" title="Linux strace 命令 - 跟踪系统调用和信号"></a>Linux strace 命令 - 跟踪系统调用和信号</h1><h2 id="介绍-240"><a href="#介绍-240" class="headerlink" title="介绍"></a>介绍</h2><p><strong>strace</strong>（英文全拼：system trace）是 Linux 系统中一个功能强大的调试、分析、诊断工具，可以对系统调用和信号传递的跟踪结果进行分析，从而解决问题。在调试应用程序时，strace 是一个很好的工具，并且经常被工程师用来检查操作系统及其程序中可能出现的某些问题。</p>
<p>Linux 系统中进程不能直接访问硬件设备，当进程需要读取磁盘文件或接收网络数据时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。而 strace 命令则可以跟踪到一个进程产生的系统调用数据 —— 包括参数，返回值，执行消耗时间等信息。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strace [ -dffhiqrtttTvxx ] [ -a column ] [ -e <span class="built_in">expr</span> ] ... [ -o file ] [ -p pid ] ... [ -s strsize ] [ -u username ] [ <span class="built_in">command</span> [ args ... ] ]</span><br><span class="line">strace -c [ -e <span class="built_in">expr</span> ] ... [ -O overhead ] [ -S sortby ] [ <span class="built_in">command</span> [ args ... ] ]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-c</code>：统计每一系统调用的所执行的时间，次数和出错的次数等。</li>
<li><code>-d</code>：输出 strace 关于标准错误的调试信息。</li>
<li><code>-f</code>：跟踪由 fork 调用所产生的子进程。</li>
<li><code>-ff</code>：如果提供 <code>-o filename</code>，则所有进程的跟踪结果输出到相应的 filename.pid 中，pid 是各进程的进程号。</li>
<li><code>-F</code>：尝试跟踪 vfork 调用。在 <code>-f</code> 时，vfork 不被跟踪。</li>
<li><code>-h</code>：输出简要的帮助信息。</li>
<li><code>-i</code>：输出系统调用的入口指针。</li>
<li><code>-q</code>：禁止输出关于脱离的消息。</li>
<li><code>-r</code>：打印出每一个系统调用的相对时间。</li>
<li><code>-t</code>：在输出中的每一行前加上时间信息。</li>
<li><code>-tt</code>：在输出中的每一行前加上时间信息，微秒级。</li>
<li><code>-ttt</code>：微秒级输出，以秒了表示时间。</li>
<li><code>-T</code>：显示每一调用所耗的时间。</li>
<li><code>-v</code>：输出所有的系统调用。一些调用关于环境变量、状态、输入输出等调用由于使用频繁，默认不输出。</li>
<li><code>-V</code>：输出 strace 的版本信息。</li>
<li><code>-x</code>：以十六进制形式输出非标准字符串。</li>
<li><code>-xx</code>：所有字符串以十六进制形式输出。</li>
<li><code>-a column</code>：设置返回值的输出位置，默认为 40。</li>
<li><code>-e expr</code>：指定一个表达式，用来控制如何跟踪。格式为 <code>[qualifier=][!]value1[,value2]...</code>，qualifier 只能是 trace、abbrev、verbose、raw、signal、read、write 其中之一，value 是用来限定的符号或数字，默认的 qualifier 是 trace。感叹号是否定符号，例如 <code>-eopen</code> 等价于 <code>-e trace=open</code>，表示只跟踪 open 调用，而 <code>-etrace!=open</code> 表示跟踪除了 open 以外的其他调用，有两个特殊的符号 all 和 none。</li>
<li><code>-e trace=set</code>：只跟踪指定的系统调用。例如 -e trace&#x3D;open,close,rean,write 表示只跟踪这四个系统调用，默认的为 set&#x3D;all。</li>
<li><code>-e trace=file</code>：只跟踪有关文件操作的系统调用。</li>
<li><code>-e trace=process</code>：只跟踪有关进程控制的系统调用。</li>
<li><code>-e trace=network</code>：跟踪与网络有关的所有系统调用。</li>
<li><code>-e strace=signal</code>：跟踪所有与系统信号有关的系统调用。</li>
<li><code>-e trace=ipc</code>：跟踪所有与进程通讯有关的系统调用。</li>
<li><code>-e abbrev=set</code>：设定 strace 输出的系统调用的结果集。-v 等与 abbrev&#x3D;none，默认为 abbrev&#x3D;all。</li>
<li><code>-e raw=set</code>：将指定的系统调用的参数以十六进制显示。</li>
<li><code>-e signal=set</code>：指定跟踪的系统信号，默认为 all。如 signal&#x3D;!SIGIO（或者 signal&#x3D;!io），表示不跟踪 SIGIO 信号。</li>
<li><code>-e read=set</code>：输出从指定文件中读出的数据，例如 <code>-e read=3,5</code>。</li>
<li><code>-e write=set</code>：输出写入到指定文件中的数据。</li>
<li><code>-o filename</code>：将 strace 的输出写入文件 filename。</li>
<li><code>-p pid</code>：跟踪指定的进程 pid。</li>
<li><code>-s strsize</code>：指定输出的字符串的最大长度，默认为 32。文件名一直全部输出。</li>
<li><code>-u username</code>：以 username 的 UID 和 GID 执行被跟踪的命令。</li>
</ul>
<h2 id="示例-241"><a href="#示例-241" class="headerlink" title="示例"></a>示例</h2><p>跟踪 46725 进程的所有系统调用（<code>-e trace=all</code>），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在 output.txt 文件里面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ strace -o output.txt -T -tt -e trace=all -p 46725</span><br></pre></td></tr></table></figure>



<p>启动和调试 hello 程序，同时跟踪其 fork 和 vfork 出来的进程，并将记录结果存在 hello-strace.txt 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ strace -f -F -o hello-strace.txt ./hello</span><br></pre></td></tr></table></figure>



<p>hello-strace.txt 文件的内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">execve(<span class="string">&quot;/usr/bin/hello&quot;</span>, [<span class="string">&quot;hello&quot;</span>], 0x7ffd2d9b6ff0 /* 72 vars */) = 0</span><br><span class="line">brk(NULL)                               = 0x557a46673000</span><br><span class="line">arch_prctl(0x3001 /* ARCH_??? */, 0x7ffd1d54a690) = -1 EINVAL (无效的参数)</span><br><span class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe67e2b7000</span><br><span class="line">access(<span class="string">&quot;/etc/ld.so.preload&quot;</span>, R_OK)      = -1 ENOENT (没有那个文件或目录)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<p>查看在 configure 脚本里面执行的程序（需要监视的系统调用是 execve），只记录 execve 的调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ strace -f -o configure-strace.txt -e execve ./configure</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ltrace-命令-跟踪程序的库调用"><a href="#Linux-ltrace-命令-跟踪程序的库调用" class="headerlink" title="Linux ltrace 命令 - 跟踪程序的库调用"></a>Linux ltrace 命令 - 跟踪程序的库调用</h1><h2 id="介绍-241"><a href="#介绍-241" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ltrace</strong>（英文全拼：library call tracer）是一个用于跟踪进程调用库函数的命令行工具。它可以显示应用程序运行时调用的共享库函数，并输出它们的参数和返回值。以帮助调试应用程序，了解其运行时行为。</p>
<p>ltrace 基于 ptrace 实现，而 ptrace 能够用来跟踪系统调用，ltrace 打开 elf 文件时会对其进行分析。由于在 elf 文件中，出于动态连接的需要，需要在 elf 文件中保存函数的符号以供连接器使用，因此 ltrace 就能跟踪到库函数的调用。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ltrace [option ...] [<span class="built_in">command</span> [arg ...]]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a, --align &lt;column&gt;</code>：对齐具体某个列的返回值。</li>
<li><code>-c</code>：统计每个库函数的调用次数和时间，并在程序退出时打印摘要。</li>
<li><code>-D, --debug &lt;mask&gt;</code>：打印调试信息。</li>
<li><code>-e &lt;filter&gt;</code>：指定要跟踪的事件，例如特定函数。</li>
<li><code>-f</code>：跟踪子进程。</li>
<li><code>-l, --library &lt;library_pattern&gt;</code>：只打印某个库中的调用。</li>
<li><code>-o, --output &lt;filename&gt;</code>：将输出保存到指定的文件中。</li>
<li><code>-p &lt;pid&gt;</code>：指定要跟踪的进程 ID。</li>
<li><code>-s &lt;size&gt;</code>：限制参数和返回值的显示大小。</li>
<li><code>-S</code>：显示系统调用（system calls）以及库调用（library calls）。</li>
<li><code>-T</code>：显示每个函数调用的耗时。</li>
</ul>
<h2 id="示例-242"><a href="#示例-242" class="headerlink" title="示例"></a>示例</h2><p>最基本应用，不带任何参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ltrace ./a.out </span><br></pre></td></tr></table></figure>



<p>输出调用时间开销：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ltrace -T ./a.out </span><br></pre></td></tr></table></figure>



<p>显示系统调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ltrace -S ./a.out </span><br></pre></td></tr></table></figure>



<p>计算时间和调用，并在程序退出时打印摘要：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ltrace -c ./a.out </span><br></pre></td></tr></table></figure>



<p>只跟踪 <code>malloc</code> 和 <code>free</code> 函数的调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ltrace -e malloc,free ./a.out</span><br></pre></td></tr></table></figure>





<h1 id="Linux-timeout-命令-限制命令执行时间"><a href="#Linux-timeout-命令-限制命令执行时间" class="headerlink" title="Linux timeout 命令 - 限制命令执行时间"></a>Linux timeout 命令 - 限制命令执行时间</h1><h2 id="介绍-242"><a href="#介绍-242" class="headerlink" title="介绍"></a>介绍</h2><p><strong>timeout</strong> 是一个 Linux 系统中的命令，用于在指定时间内运行命令，并在超时时终止该命令的执行。对于需要控制命令执行时间的情况非常有用，特别是在 Shell 脚本或批处理任务中。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">timeout</span> [选项] 停留时间 命令 [参数]...</span><br></pre></td></tr></table></figure>



<p>停留时间的后缀 s 代表秒（默认值），m 代表分，h 代表小时，d 代表天。如果不添加任何单位，默认是秒。如果持续时间为 0，则禁用关联的超时。</p>
<p><strong>选项</strong>：</p>
<ul>
<li><code>--preserve-status</code>：退出时返回值与所运行命令的返回值保持相同，即使命令超时也这样设置。</li>
<li><code>--foreground</code>：当 timeout 不是直接从 shell 命令行开始运行时，允许所运行的命令从 TTY 读取输入并获取 TTY 信号；在此模式下，所运行的命令的子进程不会受超时的影响。。</li>
<li><code>-k, --kill-after=持续时间</code>：如果所运行命令在初始信号发出后再经过所指定持续时间以后仍然在运行，则对其发送 KILL 信号。</li>
<li><code>-s, --signal=信号</code>：指定超时发生时要发送的信号；所指定的信号可以是如“HUP”这样的名称，或是一个数字；请参见“kill -l”以获取可用信号列表。</li>
<li><code>-v, --verbose</code>：对任何超时后发送的信号，向标准错误输出诊断信息。</li>
<li><code>--help</code>：显示此帮助信息并退出。</li>
<li><code>--version</code>：显示版本信息并退出。</li>
</ul>
<h2 id="示例-243"><a href="#示例-243" class="headerlink" title="示例"></a>示例</h2><p>运行 <code>command_to_run</code> 命令，并在 5 秒后终止它的执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">timeout</span> 5s command_to_run</span><br></pre></td></tr></table></figure>



<p>运行命令一分钟，如果命令没有结束，将在10秒后终止命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">timeout</span> -k 10s 1m command_to_run</span><br></pre></td></tr></table></figure>





<h1 id="Linux-declare-命令-声明变量和属性"><a href="#Linux-declare-命令-声明变量和属性" class="headerlink" title="Linux declare 命令 - 声明变量和属性"></a>Linux declare 命令 - 声明变量和属性</h1><h2 id="介绍-243"><a href="#介绍-243" class="headerlink" title="介绍"></a>介绍</h2><p>在 Linux 中，<strong><code>declare</code></strong> 命令主要用于声明变量的属性，尤其是在 Shell 脚本编程中。它有几个用途，包括声明变量的类型、属性和设置变量的值。declare 命令若不带任何参数选项，则会显示所有 Shell 变量及其值。</p>
<p>需要注意的是，<code>declare</code> 命令在交互式 shell 中可能不如在脚本中常见，因为它通常用于在脚本中显式声明变量的属性。在交互式 shell 中，通常直接使用简单的变量赋值语句。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">declare</span> [-aAfFgilnrtux] [-p] [名称[=值] ...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-f</code>：限制动作或显示为仅函数名称和定义。</li>
<li><code>-F</code>：限制仅显示函数名称（以及调试时显示行号和源文件名）。</li>
<li><code>-g</code>：当用于 shell 函数内时创建全局变量，否则忽略。</li>
<li><code>-p</code>：显示每个 NAME 变量的属性和值。</li>
</ul>
<p>设定属性的选项：</p>
<ul>
<li><code>-a</code>：使 NAME 成为下标数组（如果支持）。</li>
<li><code>-A</code>：使 NAME 成为关联数组（如果支持）</li>
<li><code>-i</code>：使 NAME 带有 <code>integer</code>（整数）属性。</li>
<li><code>-l</code>：将 NAME 在赋值时转为小写。</li>
<li><code>-n</code>：使 NAME 成为指向一个以其值为名称的变量的引用。</li>
<li><code>-r</code>：将 NAME 变为只读。</li>
<li><code>-t</code>：使 NAME 带有 <code>trace</code>（追踪）属性。</li>
<li><code>-u</code>：将每个 NAME 在赋值时转为大写。</li>
<li><code>-x</code>：将 NAME 导出。</li>
</ul>
<h2 id="示例-244"><a href="#示例-244" class="headerlink" title="示例"></a>示例</h2><p>声明一个普通的变量，并给它赋予一个初始值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">declare</span> variable_name=value</span><br></pre></td></tr></table></figure>



<p>声明一个只读变量（一旦设置，该变量的值将不能被修改）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">declare</span> -r readonly_variable=value</span><br></pre></td></tr></table></figure>



<p>声明一个整数变量（<code>declare</code> 会尝试将变量的值作为整数处理）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">declare</span> -i integer_variable=value</span><br></pre></td></tr></table></figure>



<p>声明一个数组变量，并初始化数组元素：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">declare</span> -a array_variable=(value1 value2 value3)</span><br></pre></td></tr></table></figure>



<p>声明一个关联数组（Associative Array），关联数组使用字符串作为索引：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">declare</span> -A associative_array_variable</span><br></pre></td></tr></table></figure>



<p>声明一个函数，显示函数的定义：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">declare</span> -f function_name</span><br></pre></td></tr></table></figure>



<p>显示变量或函数的属性，包括类型、值等信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">declare</span> -p variable_name</span><br><span class="line"><span class="built_in">declare</span> -f function_name</span><br></pre></td></tr></table></figure>



<p>取消变量的某些属性，比如取消只读属性：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">declare</span> +属性 variable_name</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ps-命令-显示当前运行的进程"><a href="#Linux-ps-命令-显示当前运行的进程" class="headerlink" title="Linux ps 命令 - 显示当前运行的进程"></a>Linux ps 命令 - 显示当前运行的进程</h1><h2 id="介绍-244"><a href="#介绍-244" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ps</strong>（英文全拼：process status）是 Linux 系统中非常常用的一个命令，用于查看当前运行的进程状态，类似于 Windows 的任务管理器。通过 ps 命令，我们可以获取进程的 ID、父进程 ID、优先级、执行时间、CPU 使用情况等关键信息。</p>
<h3 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps [选项]</span><br></pre></td></tr></table></figure>



<h3 id="选项参数"><a href="#选项参数" class="headerlink" title="选项参数"></a>选项参数</h3><p>ps 命令的选项参数非常多，可以分为 simple、list、output、threads、misc 五大类，可以通过如下命令查看详细说明。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps --<span class="built_in">help</span> &lt;simple|list|output|threads|misc|all&gt;</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">ps --<span class="built_in">help</span> &lt;s|l|o|t|m|a&gt;</span><br></pre></td></tr></table></figure>



<p>下面列出比较常用的一些选项参数：</p>
<p><strong>简单的进程选择（simple）</strong></p>
<ul>
<li><code>-A</code>：列出所有的进程。</li>
<li><code>-e</code>：此选项的效果和指定”A”选项相同。</li>
<li><code>-a</code>：选择由终端（tty）启动的所有进程。</li>
<li><code>r</code>：只选择运行中的进程。</li>
<li><code>T</code>：只选择当前终端启动的进程。</li>
<li><code>x</code>：脱离终端控制的进程。</li>
</ul>
<p><strong>通过列表选择进程（list）</strong></p>
<ul>
<li><code>-C &lt;cmdlist&gt;</code>：cmdlist 可以是一个或多个进程名称，中间使用逗号分隔。</li>
<li><code>-G, --Group &lt;GID&gt;</code>：通过组 ID 或组名称选择进程。</li>
<li><code>-p, p, --pid &lt;PID&gt;</code>：根据进程 ID 选择进程。</li>
<li><code>--ppid &lt;PID&gt;</code>：根据父进程 ID 选择进程。</li>
<li><code>-u, U, --user &lt;UID&gt;</code>：根据用户 ID 或用户名称选择进程。</li>
</ul>
<p><strong>输出格式控制（output）</strong></p>
<ul>
<li><code>-f</code>：显示 UID、PPIP、C 与 STIME 栏目，f 代表 full format。</li>
<li><code>-o, o, --format &lt;format&gt;</code>：用户定义的格式，format 是列名，可以输出多个列，中间使用逗号分隔。</li>
</ul>
<p><strong>多线程进程（threads）</strong></p>
<ul>
<li><code>H</code>：显示进程层次结构。</li>
<li><code>-L</code>：可能使用 LWP 和 NLWP 色谱柱。</li>
<li><code>-T</code>：可能带有 SPID 列。</li>
</ul>
<p><strong>其他（misc）</strong></p>
<ul>
<li><code>-w</code>：显示加宽可以显示较多信息</li>
</ul>
<p>ps 命令有两种展示风格：</p>
<table>
<thead>
<tr>
<th></th>
<th><code>ps -ef</code> 命令</th>
<th><code>ps aux</code> 命令</th>
</tr>
</thead>
<tbody><tr>
<td>展示风格</td>
<td>System V 风格</td>
<td>BSD 风格</td>
</tr>
<tr>
<td>指令名称</td>
<td>显示带全路径的进程名</td>
<td>会截断 command 列</td>
</tr>
</tbody></table>
<h2 id="示例-245"><a href="#示例-245" class="headerlink" title="示例"></a>示例</h2><h3 id="查看进程（System-V-风格）"><a href="#查看进程（System-V-风格）" class="headerlink" title="查看进程（System V 风格）"></a>查看进程（System V 风格）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps -ef | <span class="built_in">head</span></span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 09:19 ?        00:00:03 /sbin/init splash</span><br><span class="line">root         2     0  0 09:19 ?        00:00:00 [kthreadd]</span><br><span class="line">root         4     2  0 09:19 ?        00:00:00 [kworker/0:0H]</span><br><span class="line">root         6     2  0 09:19 ?        00:00:00 [mm_percpu_wq]</span><br><span class="line">root         7     2  0 09:19 ?        00:00:00 [ksoftirqd/0]</span><br><span class="line">root         8     2  0 09:19 ?        00:00:40 [rcu_sched]</span><br><span class="line">root         9     2  0 09:19 ?        00:00:00 [rcu_bh]</span><br><span class="line">root        10     2  0 09:19 ?        00:00:00 [migration/0]</span><br><span class="line">root        11     2  0 09:19 ?        00:00:00 [watchdog/0]</span><br></pre></td></tr></table></figure>



<p>列表含义：</p>
<ul>
<li><code>UID</code> ：程序被该 UID 所拥有</li>
<li><code>PID</code> ：就是这个程序的进程 ID</li>
<li><code>PPID</code> ：是其上级父进程的 ID</li>
<li><code>C</code> ：表示 CPU 使用的资源百分比</li>
<li><code>STIME</code> ：表示进程启动时间</li>
<li><code>TTY</code> ：登入者的终端机位置</li>
<li><code>TIME</code> ：使用掉的 CPU 时间</li>
<li><code>CMD</code> ：所下达的指令为何</li>
</ul>
<h3 id="查看进程（BSD-风格）"><a href="#查看进程（BSD-风格）" class="headerlink" title="查看进程（BSD 风格）"></a>查看进程（BSD 风格）</h3><p><code>ps aux</code> 表示显示所有包含其他使用者的行程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps aux | <span class="built_in">head</span></span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.0 185576  6164 ?        Ss   09:19   0:03 /sbin/init splash</span><br><span class="line">root         2  0.0  0.0      0     0 ?        S    09:19   0:00 [kthreadd]</span><br><span class="line">root         4  0.0  0.0      0     0 ?        I&lt;   09:19   0:00 [kworker/0:0H]</span><br><span class="line">root         6  0.0  0.0      0     0 ?        I&lt;   09:19   0:00 [mm_percpu_wq]</span><br><span class="line">root         7  0.0  0.0      0     0 ?        S    09:19   0:00 [ksoftirqd/0]</span><br><span class="line">root         8  0.1  0.0      0     0 ?        I    09:19   0:41 [rcu_sched]</span><br><span class="line">root         9  0.0  0.0      0     0 ?        I    09:19   0:00 [rcu_bh]</span><br><span class="line">root        10  0.0  0.0      0     0 ?        S    09:19   0:00 [migration/0]</span><br><span class="line">root        11  0.0  0.0      0     0 ?        S    09:19   0:00 [watchdog/0]</span><br></pre></td></tr></table></figure>



<p>列表含义：</p>
<ul>
<li><p><code>USER</code> ：进程拥有者。</p>
</li>
<li><p><code>PID</code> ：进程 ID。</p>
</li>
<li><p><code>%CPU</code> ：进程占用的 CPU 使用率。</p>
</li>
<li><p><code>%MEM</code> ：进程占用的内存使用率。</p>
</li>
<li><p><code>VSZ</code> ：进程占用的虚拟内存大小（Virtual Memory Size）。注意：VSZ 表示进程占用的全部地址空间，共享库、预分配内存、交换分区等都包含在里面，因此 VSZ 远远大于实际的占用的内存空间。</p>
</li>
<li><p><code>RSS</code> ：进程占用的物理内存大小（Resident Set Size）。注意：RSS 表示进程实际占用的物理内存，它包含共享库，但不包含在交换分区的空间。随着程序的运行，RSS 也会跟着增长，VSZ 将是它的上限。</p>
</li>
<li><p><code>TTY</code> ：终端的次要装置号码（minor device number of tty）。<code>?</code> 是表示这些进程是由系统启动的，不属于任何 TTY；tty1-tty6 是本机登录用户启动的程序，pts&#x2F;0 之类的则表示为由网络连接进主机的程序。</p>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STAT</span><br></pre></td></tr></table></figure>

<p>：进程的状态，Linux 的进程有以下 5 种状态：</p>
<ul>
<li><code>D</code> ：不可中断 uninterruptible sleep（usually IO）</li>
<li><code>R</code> ：运行 runnable（on run queue）</li>
<li><code>S</code> ：中断 sleeping</li>
<li><code>T</code> ：停止 traced or stopped</li>
<li><code>Z</code> ：僵死 a defunct (“zombie”) process</li>
<li>注：其他状态还包括 <code>W</code>（无驻留页），<code>&lt;</code>（高优先级进程），<code>N</code>（低优先级进程），<code>L</code>（内存锁页）。</li>
</ul>
</li>
<li><p><code>START</code> ：进程开始时间。</p>
</li>
<li><p><code>TIME</code> ：进程执行时间，统计该进程消耗 CPU 的时间。</p>
</li>
<li><p><code>COMMAND</code> ：启动进程的命令。</p>
</li>
</ul>
<h3 id="显示指定用户信息"><a href="#显示指定用户信息" class="headerlink" title="显示指定用户信息"></a>显示指定用户信息</h3><p>例如显示由 root 用户创建的所有进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps -u root</span><br></pre></td></tr></table></figure>



<h3 id="列出一个进程创建的所有线程"><a href="#列出一个进程创建的所有线程" class="headerlink" title="列出一个进程创建的所有线程"></a>列出一个进程创建的所有线程</h3><p>下面列出了由进程号为 pid 的进程创建的所有线程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps -T -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>



<p>输出信息可能如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    PID    SPID TTY          TIME CMD</span><br><span class="line">3057403 3057403 ?        00:06:01 chrome</span><br><span class="line">3057403 3057478 ?        00:00:00 chrome:disk<span class="variable">$0</span></span><br><span class="line">3057403 3057495 ?        00:00:01 chrome:gdrv0</span><br><span class="line">3057403 3057556 ?        00:00:00 GpuWatchdog</span><br><span class="line">3057403 3057557 ?        00:00:00 ThreadPoolServi</span><br><span class="line">3057403 3057558 ?        00:00:13 ThreadPoolForeg</span><br><span class="line">3057403 3057559 ?        00:05:35 Chrome_ChildIOT</span><br><span class="line">3057403 3057562 ?        00:14:22 VizCompositorTh</span><br><span class="line">3057403 3057571 ?        00:00:00 chrome:disk<span class="variable">$0</span></span><br><span class="line">3057403 3075540 ?        00:00:00 MemoryInfra</span><br><span class="line">3057403 3103487 ?        00:00:00 ThreadPoolSingl</span><br><span class="line">3057403 3103488 ?        00:00:00 ThreadPoolSingl</span><br><span class="line">3057403 3822403 ?        00:00:00 ThreadPoolForeg</span><br></pre></td></tr></table></figure>



<p>其中，字段 <code>SPID</code> 为线程 ID，<code>CMD</code> 为线程名称。</p>
<h3 id="根据进程名查找进程号"><a href="#根据进程名查找进程号" class="headerlink" title="根据进程名查找进程号"></a>根据进程名查找进程号</h3><p>例如查找 mysqld 的进程号（PID）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -C mysqld</span><br></pre></td></tr></table></figure>



<p>此时输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> PID TTY          TIME CMD</span><br><span class="line">1834 ?        00:00:28 mysqld</span><br></pre></td></tr></table></figure>



<p>PID 列为进程号，如果只想输出 PID，可以加上 <code>-o</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -C mysqld -o pid=</span><br></pre></td></tr></table></figure>



<h3 id="根据进程号查找进程名"><a href="#根据进程号查找进程名" class="headerlink" title="根据进程号查找进程名"></a>根据进程号查找进程名</h3><p>例如查找 PID 为 1834 的进程名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -p 1834</span><br></pre></td></tr></table></figure>



<p>此时输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> PID TTY          TIME CMD</span><br><span class="line">1834 ?        00:00:28 mysqld</span><br></pre></td></tr></table></figure>



<p>CMD 列为进程名称，如果只想输出进程名，可以加上 <code>-o</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps -p 1834 -o cmd=</span><br><span class="line">/usr/sbin/mysqld</span><br><span class="line">$ ps -p 1834 -o <span class="built_in">comm</span>=</span><br><span class="line">mysqld</span><br></pre></td></tr></table></figure>





<h1 id="Linux-top-命令-实时显示进程和系统状态"><a href="#Linux-top-命令-实时显示进程和系统状态" class="headerlink" title="Linux top 命令 - 实时显示进程和系统状态"></a>Linux top 命令 - 实时显示进程和系统状态</h1><h2 id="介绍-245"><a href="#介绍-245" class="headerlink" title="介绍"></a>介绍</h2><p><strong>top</strong> 命令用于动态实时显示 Linux 进程的状态。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -hv|-bcEHiOSs1 -d secs -n max -u|U user -p pid -o fld -w [cols]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-b</code> ：以批处理模式操作</li>
<li><code>-c</code> ：显示完整的治命令</li>
<li><code>-d</code> ：屏幕刷新间隔时间</li>
<li><code>-I</code> ：忽略失效过程</li>
<li><code>-s</code> ：保密模式</li>
<li><code>-S</code> ：累积模式</li>
<li><code>-i &lt;secs&gt;</code> ：设置间隔时间</li>
<li><code>-u &lt;user&gt;</code> ：指定用户名</li>
<li><code>-p &lt;pid&gt;</code> ：指定进程</li>
<li><code>-n &lt;max&gt;</code> ：循环显示的次数</li>
</ul>
<p><strong>输出说明</strong>：</p>
<p>执行 top 命令后，会在终端输出系统进程状态信息，头部信息大致如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top - 18:34:11 up  9:14,  2 <span class="built_in">users</span>,  load average: 0.93, 0.87, 0.72</span><br><span class="line">Tasks: 322 total,   1 running, 264 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  3.4 us,  1.1 sy,  0.0 ni, 95.3 <span class="built_in">id</span>,  0.1 wa,  0.0 hi,  0.1 si,  0.0 st</span><br><span class="line">KiB Mem :  8029784 total,   130760 free,  4012508 used,  3886516 buff/cache</span><br><span class="line">KiB Swap:  7931900 total,  7923452 free,     8448 used.  3191432 avail Mem </span><br></pre></td></tr></table></figure>



<p>对于服务器来说，重点关注：</p>
<ul>
<li><code>load average</code> ：平均负载，后面3个值分别为当前1分钟、5分钟、15分钟的平均负载，最大值等于 CPU 核心数。</li>
<li><code>KiB Mem</code> ：该行数据显示内存总大小、空闲内存、已使用内存，以及用于缓存的内存大小。</li>
<li><code>KiB Swap</code> ：该行数据显示交换分区的情况。</li>
</ul>
<p>接着输出一个进程列表，表头栏目如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br></pre></td></tr></table></figure>



<p>每列的含义如下：</p>
<ul>
<li><code>PID</code> ：进程 ID</li>
<li><code>USER</code> ：进程所有者</li>
<li><code>PR</code> ：进程优先级</li>
<li><code>NI</code> ：nice 值（负值表示高优先级，正值表示低优先级）</li>
<li><code>VIRT</code> ：进程使用的虚拟内存总量（同 VSZ），单位 kb。VIRT &#x3D; SWAP + RES</li>
<li><code>RES</code> ：进程使用的、未被换出的物理内存大小（同 RSS），单位 kb。RES &#x3D; CODE + DATA</li>
<li><code>SHR</code> ：共享内存大小，单位 kb</li>
<li><code>S</code> ：进程状态。D &#x3D; 不可终端的睡眠状态，R &#x3D; 运行，S &#x3D; 睡眠，T &#x3D; 跟踪&#x2F;停止，Z &#x3D; 僵尸进程</li>
<li><code>%CPU</code> ：上次更新到现在的 CPU 时间占用百分比</li>
<li><code>%MEM</code> ：进程使用的物理内存百分比</li>
<li><code>TIME+</code> ：进程使用的 CPU 时间总计，单位 1&#x2F;100 秒</li>
<li><code>COMMAND</code> ：进程名称（命令名&#x2F;命令行）</li>
</ul>
<p><strong>交互子命令</strong>：</p>
<p>另外，top 还支持交互子命令，在 top 运行窗口按下面按键，会调整显示效果。</p>
<ul>
<li><code>M</code> ：根据驻留内存大小进行排序</li>
<li><code>P</code> ：根据CPU使用百分比大小进行排序</li>
<li><code>T</code> ：根据时间&#x2F;累计时间进行排序</li>
<li><code>H</code> ：将线程查看模式切换为开或关</li>
<li><code>1</code> ：显示每个逻辑 CPU 的状况</li>
<li><code>h</code> ：显示帮助画面，给出一些简短的命令总结说明</li>
<li><code>k</code> ：终止一个进程</li>
<li><code>i</code> ：忽略闲置和僵死进程，这是一个开关式命令</li>
<li><code>r</code> ：重新安排一个进程的优先级别</li>
<li><code>S</code> ：切换到累计模式</li>
<li><code>s</code> ：改变两次刷新之间的延迟时间（单位为 s），如果有小数，就换算成 ms（输入 0 值则系统将不断刷新，默认值是 5s）</li>
<li><code>f</code> 或者 <code>F</code> ：从当前显示中添加或者删除项目</li>
<li><code>o</code> 或者 <code>O</code> ：改变显示项目的顺序</li>
<li><code>l</code> ：切换显示平均负载和启动时间信息</li>
<li><code>m</code> ：切换显示内存信息</li>
<li><code>t</code> ：切换显示进程和 CPU 状态信息</li>
<li><code>c</code> ：切换显示命令名称和完整命令行</li>
<li><code>w</code> ：将当前设置写入 ~&#x2F;.toprc 文件中</li>
</ul>
<p>最后，按 <code>q</code> 或 <code>CTRL+C</code> 可退出程序。</p>
<h2 id="示例-246"><a href="#示例-246" class="headerlink" title="示例"></a>示例</h2><p>显示进程信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>



<p>显示完整命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -c</span><br></pre></td></tr></table></figure>



<p>以批处理模式显示程序信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -b</span><br></pre></td></tr></table></figure>



<p>以累积模式显示程序信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -S</span><br></pre></td></tr></table></figure>



<p>设置信息更新次数（更新十次后退出）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -n 10</span><br></pre></td></tr></table></figure>



<p>设置信息更新时间（更新周期为3秒）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -d 3</span><br></pre></td></tr></table></figure>



<p>显示指定的进程信息（显示进程号为 pid 的进程信息，CPU、内存占用率等）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>



<p>实时显示 Linux 系统各个线程运行情况（你也可以在 top 运行时按“H”键将线程查看模式切换为开或关）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -H</span><br></pre></td></tr></table></figure>



<p>列出进程号为 PID 的进程创建的所有线程（也可以使用 <code>ps -T -p &lt;pid&gt;</code> 命令查看）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -H -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>



<p>通过进程名（而不是 PID）列出该进程创建的所有线程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -Hp $(pgrep -f &lt;process_name&gt;)</span><br></pre></td></tr></table></figure>





<h1 id="Linux-htop-命令-交互式进程查看器"><a href="#Linux-htop-命令-交互式进程查看器" class="headerlink" title="Linux htop 命令 - 交互式进程查看器"></a>Linux htop 命令 - 交互式进程查看器</h1><h2 id="介绍-246"><a href="#介绍-246" class="headerlink" title="介绍"></a>介绍</h2><p><strong>htop</strong> 是 Linux 系统中的一个互动的进程查看器，可动态实时显示 Linux 进程的状态，依赖于 ncurses 库。</p>
<p>htop 的功能类似于 top 命令，但它更加人性化，允许用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。</p>
<p><strong>安装</strong>：</p>
<p>htop 命令由 htop 软件包提供，在 Debian&#x2F;Ubuntu 系统上可以使用如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install htop</span><br></pre></td></tr></table></figure>



<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -hv|-bcEHiOSs1 -d secs -n max -u|U user -p pid -o fld -w [cols]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-C</code>, <code>--no-color</code>：使用单色配色方案。</li>
<li><code>-d</code>, <code>--delay=DELAY</code>：设置更新之间的延迟，以十分之一秒为单位。</li>
<li><code>-h</code>, <code>--help</code>：显示帮助信息。</li>
<li><code>-s</code>, <code>--sort-key=COLUMN</code>：按 COLUMN 排序（尝试 –sort-key&#x3D;help 列表）。</li>
<li><code>-t</code>, <code>--tree</code>：默认显示树视图。</li>
<li><code>-u</code>, <code>--user=USERNAME</code>：仅显示指定用户的进程。</li>
<li><code>-p</code>, <code>--pid=PID,[,PID,PID...]</code>：仅显示给定的 PID。</li>
<li><code>-v</code>, <code>--version</code>：打印版本信息。</li>
</ul>
<h2 id="示例-247"><a href="#示例-247" class="headerlink" title="示例"></a>示例</h2><p>显示进程信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">htop</span><br></pre></td></tr></table></figure>



<p>交互界面如下：</p>
<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/linux-htop-command.png" alt="img"></p>
<p>在上图中将输出的界面划分成了四个区域，其中：</p>
<ul>
<li>上左区：显示了 CPU、物理内存和交换分区的信息；</li>
<li>上右区：显示了任务数量、平均负载和连接运行时间等信息；</li>
<li>进程区域：显示出当前系统中的所有进程；</li>
<li>操作提示区：显示了当前界面中 F1-F10 功能键中定义的快捷功能。</li>
</ul>
<p><strong>功能键说明</strong></p>
<ul>
<li><code>F1</code>：显示帮助信息；</li>
<li><code>F2</code>：配置界面中的显示信息；</li>
<li><code>F3</code>：进程搜索；</li>
<li><code>F4</code>：进程过滤器；</li>
<li><code>F5</code>：显示进程树；</li>
<li><code>F6</code>：排序；</li>
<li><code>F7</code>：减小 nice 值；</li>
<li><code>F8</code>：增加 nice 值；</li>
<li><code>F9</code>：杀掉指定进程；</li>
<li><code>F10</code>：退出 htop。</li>
</ul>
<p>除了 F1-F10，htop 中还有很多有用的功能键：</p>
<ul>
<li>空格键：用于标记选中的进程，用于实现对多个进程同时操作；</li>
<li><code>U</code>：取消所有选中的进程；</li>
<li><code>s</code>：显示光标所在进程执行的系统调用；</li>
<li><code>l</code>：显示光标所在进程的文件列表;</li>
<li><code>I</code>：对排序的结果进行反转显示；</li>
<li><code>a</code>：绑定进程到指定的 CPU；</li>
<li><code>u</code>：显示指定用户的进程；</li>
<li><code>M</code>：按照内存使用百分比排序，对应 MEM% 列；</li>
<li><code>P</code>：按照 CPU 使用百分比排序，对应 CPU% 列；</li>
<li><code>T</code>：按照进程运行的时间排序，对应 TIME+ 列；</li>
<li><code>K</code>：隐藏内核线程；</li>
<li><code>H</code>：隐藏用户线程；</li>
<li><code>#</code>：快速定位光标到 PID 所指定的进程上。</li>
</ul>
<h1 id="Linux-kill-命令-终止进程"><a href="#Linux-kill-命令-终止进程" class="headerlink" title="Linux kill 命令 - 终止进程"></a>Linux kill 命令 - 终止进程</h1><h2 id="介绍-247"><a href="#介绍-247" class="headerlink" title="介绍"></a>介绍</h2><p><strong>kill</strong> 命令用于删除执行中的程序或任务。</p>
<p>kill 的工作原理是将指定的信息发送至指定程序，预设的信息为 <code>SIGTERM(15)</code>，可将指定程序终止。若仍无法终止该程序，可使用 <code>SIGKILL(9)</code> 信息尝试强制删除程序。程序或任务的编号（PID）可利用 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/ps/">ps</a> 或 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/jobs/">jobs</a> 命令查看。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> [options] &lt;pid&gt; [...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>：当处理当前进程时，不限制命令名和进程号的对应关系。</li>
<li><code>-l [signal]</code>：列出信号名称（若不加 <code>[signal]</code> 选项，则 <code>-l</code> 参数会列出全部的信号名称）。</li>
<li><code>-p</code>：指定 kill 命令只打印相关进程的进程号，而不发送任何信号。</li>
<li><code>-s &lt;signal&gt;</code>：指定要送出的信号（亦可采用 <code>-&lt;signal&gt;</code> 写法）。</li>
<li><code>-u</code>：指定用户。</li>
</ul>
<p><strong>参数</strong>：程序的 PID 或是 PGID，也可以是工作编号。</p>
<h2 id="示例-248"><a href="#示例-248" class="headerlink" title="示例"></a>示例</h2><p>列出所有可用信号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1	64) SIGRTMAX</span><br></pre></td></tr></table></figure>



<p>常用的信号有：</p>
<ul>
<li>1 (HUP)：重新加载进程</li>
<li>9 (KILL)：杀死一个进程</li>
<li>15 (TERM)：正常停止一个进程</li>
</ul>
<p>杀死 PID 为 12345 的进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> 12345</span><br></pre></td></tr></table></figure>



<p>强制杀死 PID 为 12345 进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -KILL 12345</span><br></pre></td></tr></table></figure>



<p>信号的指定可以使用 <code>-9</code>、<code>-SIGKILL</code> 或 <code>-KILL</code>，三种方式是等效的。</p>
<p>杀死指定用户所有进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -9 $(ps -ef | grep guest) <span class="comment"># 方法1：过滤出 guest 用户进程</span></span><br><span class="line">$ <span class="built_in">kill</span> -u guest                  <span class="comment"># 方法2</span></span><br></pre></td></tr></table></figure>





<h1 id="Linux-pkill-命令-根据名称终止进程"><a href="#Linux-pkill-命令-根据名称终止进程" class="headerlink" title="Linux pkill 命令 - 根据名称终止进程"></a>Linux pkill 命令 - 根据名称终止进程</h1><h2 id="介绍-248"><a href="#介绍-248" class="headerlink" title="介绍"></a>介绍</h2><p><strong>pkill</strong> 用于杀死一个进程，类似于 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/killall/">killall</a> 命令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkill [选项]  name</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-o</code> 仅向找到的最小（起始）进程号发送信号</li>
<li><code>-n</code> 仅向找到的最大（结束）进程号发送信号</li>
<li><code>-P</code> 指定父进程号发送信号</li>
<li><code>-g</code> 指定进程组</li>
<li><code>-t</code> 指定开启进程的终端</li>
</ul>
<p><strong>参数</strong>：进程名 name</p>
<h2 id="示例-249"><a href="#示例-249" class="headerlink" title="示例"></a>示例</h2><p>结束 php-fpm 进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pkill -9 php-fpm</span><br></pre></td></tr></table></figure>





<h1 id="Linux-killall-命令-终止指定名称的所有进程"><a href="#Linux-killall-命令-终止指定名称的所有进程" class="headerlink" title="Linux killall 命令 - 终止指定名称的所有进程"></a>Linux killall 命令 - 终止指定名称的所有进程</h1><h2 id="介绍-249"><a href="#介绍-249" class="headerlink" title="介绍"></a>介绍</h2><p><strong>killall</strong> 命令用于杀死指定名字的所有进程。与 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/kill/">kill</a> 命令不同，killall 不需要事先查找进程 PID，直接对进程对名字进行操作，更加方便。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">killall [选项]  name</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-e | --exact</code>：进程需要和名字完全相符</li>
<li><code>-I | --ignore-case</code>：忽略大小写</li>
<li><code>-g | --process-group</code>：结束进程组</li>
<li><code>-i | --interactive</code>：结束之前询问</li>
<li><code>-l | --list</code>：列出所有的信号名称</li>
<li><code>-q | --quite</code>：进程没有结束时，不输出任何信息</li>
<li><code>-r | --regexp</code>：将进程名模式解释为扩展的正则表达式。</li>
<li><code>-s | --signal</code>：发送指定信号</li>
<li><code>-u | --user</code>：结束指定用户的进程</li>
<li><code>-v | --verbose</code>：显示详细执行过程</li>
<li><code>-w | --wait</code>：等待所有的进程都结束</li>
<li><code>-V |--version</code>：显示版本信息</li>
<li><code>--help</code>：显示帮助信息</li>
</ul>
<p><strong>参数</strong>：进程名 name</p>
<h2 id="示例-250"><a href="#示例-250" class="headerlink" title="示例"></a>示例</h2><p>结束所有的 php-fpm 进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ killall -9 php-fpm</span><br></pre></td></tr></table></figure>





<h1 id="Linux-ipcs-命令-显示系统-IPC-资源信息"><a href="#Linux-ipcs-命令-显示系统-IPC-资源信息" class="headerlink" title="Linux ipcs 命令 - 显示系统 IPC 资源信息"></a>Linux ipcs 命令 - 显示系统 IPC 资源信息</h1><h2 id="介绍-250"><a href="#介绍-250" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ipcs</strong> 命令用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipcs [resource ...] [output-format]</span><br><span class="line">ipcs [resource] -i &lt;<span class="built_in">id</span>&gt;</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-i, --<span class="built_in">id</span> &lt;<span class="built_in">id</span>&gt;  打印由 <span class="built_in">id</span> 标识的资源的详细信息</span><br><span class="line">-h, --<span class="built_in">help</span>     显示此帮助并退出</span><br><span class="line">-V, --version  输出版本信息并退出</span><br></pre></td></tr></table></figure>



<p><strong>资源选项</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-m, --shmems      共享内存段</span><br><span class="line">-q, --queues      消息队列</span><br><span class="line">-s, --semaphores  信号量</span><br><span class="line">-a, --all         全部(默认)</span><br></pre></td></tr></table></figure>



<p><strong>输出格式</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-t, --<span class="keyword">time</span>        显示附加、脱离和更改时间</span><br><span class="line">-p, --pid         显示 PID 的创建者和最后操作</span><br><span class="line">-c, --creator     显示创建者和拥有者</span><br><span class="line">-l, --limits      显示资源限制</span><br><span class="line">-u, --summary     显示状态摘要</span><br><span class="line">    --human       以易读格式显示大小</span><br><span class="line">-b, --bytes       以字节数显示大小</span><br></pre></td></tr></table></figure>



<h2 id="示例-251"><a href="#示例-251" class="headerlink" title="示例"></a>示例</h2><p>显示所有的 IPC 设施：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipcs -a</span><br></pre></td></tr></table></figure>



<p>显示所有的消息队列（Message Queue）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipcs -q</span><br></pre></td></tr></table></figure>



<p>显示所有的信号量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipcs -s</span><br></pre></td></tr></table></figure>



<p>显示所有的共享内存：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipcs -m</span><br></pre></td></tr></table></figure>



<p>显示 IPC 设施的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipcs -q -i &lt;<span class="built_in">id</span>&gt;</span><br></pre></td></tr></table></figure>



<p>提示</p>
<p>id 对应 shmid、semid、msgid 等。<code>-q</code> 对应设施的类型（队列），查看信号量详细情况使用 <code>-s</code>，查看共享内存使用 <code>-m</code>。</p>
<p>显示 IPC 设施（共享内存）的限制大小：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipcs -m -l</span><br><span class="line">ipcs -s -l</span><br><span class="line">ipcs -q -l</span><br></pre></td></tr></table></figure>



<p>显示 IPC 设施的权限关系：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipcs -c</span><br><span class="line">ipcs -m -c</span><br><span class="line">ipcs -q -c</span><br><span class="line">ipcs -s -c</span><br></pre></td></tr></table></figure>



<p>显示最近访问过 IPC 设施的进程 ID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipcs -p</span><br><span class="line">ipcs -m -p</span><br><span class="line">ipcs -q -p</span><br></pre></td></tr></table></figure>



<p>显示 IPC 设施的最后操作时间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipcs -t</span><br><span class="line">ipcs -q -t</span><br><span class="line">ipcs -m -t</span><br><span class="line">ipcs -s -t</span><br></pre></td></tr></table></figure>



<p>显示 IPC 设施的当前状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipcs -u </span><br></pre></td></tr></table></figure>





<h1 id="Linux-jobs-命令-列出当前作业"><a href="#Linux-jobs-命令-列出当前作业" class="headerlink" title="Linux jobs 命令 - 列出当前作业"></a>Linux jobs 命令 - 列出当前作业</h1><h2 id="介绍-251"><a href="#介绍-251" class="headerlink" title="介绍"></a>介绍</h2><p><strong>jobs</strong> 命令用于查看当前终端（tty）的任务列表及任务状态，包括后台运行的任务。</p>
<p>该命令可以显示任务号及其对应的进程号。其中，任务号是以普通用户的角度进行的，而进程号则是从系统管理员的角度来看的。一个任务可以对应于一个或者多个进程号。</p>
<p>在 Linux 系统中执行某些操作时候，有时需要将当前任务暂停调至后台（CTRL+Z），或有时需要将后台暂停的任务重启开启并调至前台，这一系列的操作将会使用到 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/jobs/">jobs</a>、<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/bg/">bg</a> 和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/fg/">fg</a> 三个命令以及快捷键来完成。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">jobs</span> [选项] [参数]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-l</code>：显示进程号</li>
<li><code>-p</code>：仅任务对应的显示进程号</li>
<li><code>-n</code>：显示任务状态的变化</li>
<li><code>-r</code>：仅输出运行状态（running）的任务</li>
<li><code>-s</code>：仅输出停止状态（stoped）的任务</li>
</ul>
<p><strong>参数</strong>：指定要显示的任务识别号</p>
<h2 id="示例-252"><a href="#示例-252" class="headerlink" title="示例"></a>示例</h2><p>打开终端，此时任务列表为空，执行 jobs 不会有任何输出。假设当前目录下有一张 GetIoT.png 图片，执行如下命令将其打开，以创建一个任务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ eog GetIoT.png</span><br></pre></td></tr></table></figure>



<p>该任务将占用当前终端，按 CTRL+Z 键暂停任务，查看当前任务列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">[1]+  已停止               eog GetIoT.png</span><br></pre></td></tr></table></figure>



<p>加 <code>-l</code> 显示进程号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">jobs</span> -l</span><br><span class="line">[1]+ 22702 停止                  eog GetIoT.png</span><br></pre></td></tr></table></figure>



<p>输出信息的第1列表示任务编号，第2列表示任务所对应的进程号，第3列表示任务的运行状态，第4列表示启动任务的命令。</p>
<p>此时任务进入处于停止状态，执行 bg 将任务从后台启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">bg</span></span><br><span class="line">[1]+ eog GetIoT.png &amp;</span><br></pre></td></tr></table></figure>



<p>再次查看任务列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">jobs</span> -l</span><br><span class="line">[1]+ 22702 运行中               eog GetIoT.png &amp;</span><br></pre></td></tr></table></figure>



<p>执行 fg 将任务调到前台：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">fg</span></span><br><span class="line">eog GetIoT.png</span><br></pre></td></tr></table></figure>



<p>按 CTRL+C 终止程序。</p>
<h1 id="Linux-bg-命令-将作业置于后台运行"><a href="#Linux-bg-命令-将作业置于后台运行" class="headerlink" title="Linux bg 命令 - 将作业置于后台运行"></a>Linux bg 命令 - 将作业置于后台运行</h1><h2 id="介绍-252"><a href="#介绍-252" class="headerlink" title="介绍"></a>介绍</h2><p><strong>bg</strong> 命令用于将作业放到后台运行，使前台可以执行其他任务。该命令的运行效果与在指令后面添加符号 <code>&amp;</code> 的效果是相同的，都是将其放到系统后台执行。与 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/fg/">fg</a> 命令一样，若任务列表中只有一个，则使用该命令时，可以省略任务号。</p>
<p>提示：程序正在前台运行，可以使用 <code>Ctrl + Z</code> 把程序暂停，<code>Ctrl + C</code> 终止程序。</p>
<h2 id="示例-253"><a href="#示例-253" class="headerlink" title="示例"></a>示例</h2><p>参考 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/jobs/">jobs 使用示例</a></p>
<h1 id="Linux-fg-命令-将作业置于前台运行"><a href="#Linux-fg-命令-将作业置于前台运行" class="headerlink" title="Linux fg 命令 - 将作业置于前台运行"></a>Linux fg 命令 - 将作业置于前台运行</h1><h2 id="介绍-253"><a href="#介绍-253" class="headerlink" title="介绍"></a>介绍</h2><p><strong>fg</strong> 命令用于将后台任务（在后台运行的或者在后台挂起的任务）放到前台终端运行。与 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/bg/">bg</a> 命令一样，若后台任务中只有一个，则使用该命令时，可以省略任务号。</p>
<p>提示：程序正在前台运行，可以使用 <code>Ctrl + Z</code> 把程序暂停，<code>Ctrl + C</code> 终止程序。</p>
<h2 id="示例-254"><a href="#示例-254" class="headerlink" title="示例"></a>示例</h2><p>参考 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/jobs/">jobs 使用示例</a></p>
<h1 id="Linux-nohup-命令-后台运行程序"><a href="#Linux-nohup-命令-后台运行程序" class="headerlink" title="Linux nohup 命令 - 后台运行程序"></a>Linux nohup 命令 - 后台运行程序</h1><h2 id="介绍-254"><a href="#介绍-254" class="headerlink" title="介绍"></a>介绍</h2><p><strong>nohup</strong>（英文全拼：no hang up）命令用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。</p>
<p>在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录的 nohup.out 文件不可写，输出重定向到 <code>$HOME/nohup.out</code> 文件中。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> COMMAND [ARG]...</span><br></pre></td></tr></table></figure>



<p><strong>参数</strong>：</p>
<ul>
<li><code>COMMAND</code>：要执行的命令。</li>
<li><code>Arg</code>：一些参数，可以指定输出文件。</li>
</ul>
<h2 id="示例-255"><a href="#示例-255" class="headerlink" title="示例"></a>示例</h2><p>假设当前目录下有 getiot.sh 脚本文件，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ 1 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;getiot.tech&quot;</span></span><br><span class="line">    <span class="built_in">sleep</span> 1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>



<p>在后台执行当前目录下的 getiot.sh 脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">nohup</span> ./getiot.sh &amp;</span><br></pre></td></tr></table></figure>



<p>在终端如果看到以下输出说明运行成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appending output to nohup.out</span><br></pre></td></tr></table></figure>



<p>此时，会在当前目录看到生成了 nohup.out 文件，每隔一秒会输出一行 “getiot.tech” 到 nohup.out 文件。</p>
<p>在后台执行当前目录下的 getiot.sh 脚本，并重定向输入到 getiot.log 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> ./getiot.sh &gt; getiot.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>



<p><strong>2&gt;&amp;1</strong> 解释：将标准错误 2 重定向到标准输出 &amp;1 ，标准输出 &amp;1 再被重定向输入到 getiot.log 文件中。</p>
<p>在 Linux 系统中，执行一个 shell 命令行时通常会自动打开三个标准文件：</p>
<ul>
<li>0 – stdin（standard input，标准输入）</li>
<li>1 – stdout（standard output，标准输出）</li>
<li>2 – stderr（standard error，标准错误输出）</li>
</ul>
<p>如果需要终止运行程序，可以使用 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/ps/">ps</a> 或 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/jobs/">jobs</a> 命令查找到 nohup 运行命令的 PID，然后使用 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/kill/">kill</a> 命令来删除即可。</p>
<h1 id="Linux-lsof-命令-列出打开的文件和进程"><a href="#Linux-lsof-命令-列出打开的文件和进程" class="headerlink" title="Linux lsof 命令 - 列出打开的文件和进程"></a>Linux lsof 命令 - 列出打开的文件和进程</h1><h2 id="介绍-255"><a href="#介绍-255" class="headerlink" title="介绍"></a>介绍</h2><p><strong>lsof</strong>（英文全拼：list open files）命令用于查看进程开打的文件、打开文件的进程、进程打开的端口（TCP、UDP），甚至可用于找回&#x2F;恢复删除的文件。</p>
<p>lsof 是十分方便的系统监视工具，因为 lsof 命令需要访问核心内存和各种文件，所以需要 root 权限才能使用所有功能。</p>
<p>在 Linux 环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议（TCP）和用户数据报协议（UDP）套接字等，系统在后台都为其分配了一个文件描述符，该文件描述符为应用程序与操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过 lsof 工具能够查看这个列表，对系统监测以及排错有很大帮助。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof [options] [names]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code> ：列出打开文件存在的进程。</li>
<li><code>-c &lt;进程名&gt;</code> ：列出指定进程所打开的文件。</li>
<li><code>-g</code> ：列出 GID 号进程详情。</li>
<li><code>-d &lt;文件号&gt;</code> ：列出占用该文件号的进程。</li>
<li><code>+d &lt;目录&gt;</code> ：列出目录下被打开的文件。</li>
<li><code>+D &lt;目录&gt;</code> ：递归列出目录下被打开的文件。</li>
<li><code>-n &lt;目录&gt;</code> ：列出使用 NFS 的文件。</li>
<li><code>-i &lt;条件&gt;</code> ：列出符合条件的进程。</li>
<li><code>-p &lt;进程号&gt;</code> ：列出指定进程号所打开的文件。</li>
<li><code>-u</code> ：列出 UID 号进程详情。</li>
<li><code>-h</code> ：显示帮助信息。</li>
<li><code>-v</code> ：显示版本信息。</li>
</ul>
<h2 id="示例-256"><a href="#示例-256" class="headerlink" title="示例"></a>示例</h2><p>直接输入 lsof 查看文件的进程信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof</span><br></pre></td></tr></table></figure>



<p>列出 GID 号进程详情</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -g</span><br></pre></td></tr></table></figure>



<p>列出目录下被打开的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof +d /root</span><br></pre></td></tr></table></figure>



<p>递归列出目录下被打开的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof +D /home/getiot</span><br></pre></td></tr></table></figure>



<p>列出使用 NFS 的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -n /srv/nfs/</span><br></pre></td></tr></table></figure>





<h1 id="Linux-nice-命令-设置进程优先级"><a href="#Linux-nice-命令-设置进程优先级" class="headerlink" title="Linux nice 命令 - 设置进程优先级"></a>Linux nice 命令 - 设置进程优先级</h1><h2 id="介绍-256"><a href="#介绍-256" class="headerlink" title="介绍"></a>介绍</h2><p><strong>nice</strong> 命令用于指定 Linux 系统进程的调度优先级，即以更改过的优先序来执行程序。如果未指定程序，则会印出目前的排程优先序。nice 值的范围是 [-20, 19]，其中 -20 是最高优先级，19 是最低优先级。Linux 进程的默认 nice 值为 0。</p>
<p>优先级（priority）是操作系统用来决定 CPU 调度的一个重要参数，Linux 使用 Round-Robin 算法来处理 CPU 调度，优先级越高，所可能获得的 CPU 时间就越多。</p>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/renice/">renice</a>, <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/chrt/">chrt</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nice</span> [OPTION] [COMMAND [ARG]...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-n</code>, <code>--adjustment=N</code>：在优先级数值上加上数字 N（默认为 10）。</li>
<li><code>--help</code>：显示此帮助信息并退出。</li>
<li><code>--version</code>：显示版本信息并退出。</li>
</ul>
<h2 id="示例-257"><a href="#示例-257" class="headerlink" title="示例"></a>示例</h2><p>以指定进程优先级启动 vim 程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nice</span> -n 19 vim</span><br></pre></td></tr></table></figure>



<p>通过 ps 命令查看 vim 进程的 nice 值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps -efl</span><br><span class="line">F S UID          PID    PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD</span><br><span class="line">...</span><br><span class="line">0 S rudy     2768147 1831616  0  99  19 -  6985 do_sel 17:20 pts/14   00:00:00 vim</span><br></pre></td></tr></table></figure>



<p>字段说明：</p>
<ul>
<li><code>NI</code> 是优先值，是用户层面的概念；</li>
<li><code>PR</code> 是进程的实际优先级，是给内核（kernel）看（用）的。</li>
</ul>
<h1 id="Linux-renice-命令-改变运行中进程的优先级"><a href="#Linux-renice-命令-改变运行中进程的优先级" class="headerlink" title="Linux renice 命令 - 改变运行中进程的优先级"></a>Linux renice 命令 - 改变运行中进程的优先级</h1><h2 id="介绍-257"><a href="#介绍-257" class="headerlink" title="介绍"></a>介绍</h2><p><strong>renice</strong> 命令用于修改 Linux 系统中正在运行的进程的调度优先级。该命令默认是以进程 PID 指定程序调整其优先权，你也可以指定程序群组或用户名称调整优先权等级，并修改所有隶属于该程序群组或用户的程序的优先级。</p>
<p>注意：只有系统管理员可以改变其他用户程序的优先权，也仅有系统管理员可以设置负数等级。</p>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/nice/">nice</a>, <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/chrt/">chrt</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">renice [-n] priority [-g|-p|-u] identifier...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-n</code>, <code>--priority &lt;数字&gt;</code>：指定 nice 增量。</li>
<li><code>-p</code>, <code>--pid &lt;id&gt;</code>：将参数解释为进程 ID（默认）。</li>
<li><code>-g</code>, <code>--pgrp &lt;id&gt;</code>：将参数解释为进程组 ID。</li>
<li><code>-u</code>, <code>--user &lt;name&gt;|&lt;id&gt;</code>：将参数解释为 用户名 或 用户 ID。</li>
<li><code>-h</code>, <code>--help</code>：显示此帮助信息并退出。</li>
<li><code>-V</code>, <code>--version</code>：显示版本信息并退出。</li>
</ul>
<h2 id="示例-258"><a href="#示例-258" class="headerlink" title="示例"></a>示例</h2><p>修改指定进程（使用 PID 号）的调度优先级为 5</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">renice 5 -p &lt;PID&gt;</span><br></pre></td></tr></table></figure>



<p>将指定进程（使用 PID 号）的调度优先级加 1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">renice +1 -p &lt;PID&gt;</span><br></pre></td></tr></table></figure>





<h1 id="Linux-chrt-命令-查看或设置进程的调度策略"><a href="#Linux-chrt-命令-查看或设置进程的调度策略" class="headerlink" title="Linux chrt 命令 - 查看或设置进程的调度策略"></a>Linux chrt 命令 - 查看或设置进程的调度策略</h1><h2 id="介绍-258"><a href="#介绍-258" class="headerlink" title="介绍"></a>介绍</h2><p><strong>chrt</strong>（英文全拼：change real-time）是 Linux 系统中操作进程&#x2F;线程实时属性的命令，可用于查看和设置进程&#x2F;线程的调度策略。</p>
<p>Linux 内核有三种常见调度策略：</p>
<ul>
<li><code>SCHED_OTHER</code> 分时调度策略（默认调度策略）；</li>
<li><code>SCHED_FIFO</code> 实时调度策略，先到先服务；</li>
<li><code>SCHED_RR</code> 实时调度策略，时间片轮转（RR 是 round-robin 的缩写）。</li>
</ul>
<p>在 Linux 系统中，所有优先级值在 0-99 范围内的，都是实时进程。因此，0-99 优先级也被称为实时进程优先级，而 100-139 范围内的则是非实时进程。</p>
<p>相关命令：<a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/nice/">nice</a>, <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/renice/">renice</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chrt [options] [prio] [pid | <span class="built_in">command</span> [arg]...]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>, <code>--all-tasks</code>：设置或检索给定 PID 的所有任务（线程）的调度属性。</li>
<li><code>-m</code>, <code>--max</code>：显示最小和最大有效优先级，然后退出。</li>
<li><code>-p</code>, <code>--pid</code>：操作一个已存在的 PID，不启动一个新的任务。</li>
<li><code>-v</code>, <code>--verbose</code>：显示详细状态信息。</li>
<li><code>-h</code>, <code>--help</code>：显示帮助信息。</li>
<li><code>-V</code>, <code>--version</code>：打印版本信息。</li>
</ul>
<p><strong>调度策略</strong>：</p>
<ul>
<li><code>-o</code>, <code>--other</code>：设置策略调度策略为 <code>SCHED_OTHER</code>。</li>
<li><code>-f</code>, <code>--fifo</code>：设置调度策略为 <code>SCHED_FIFO</code>。</li>
<li><code>-r</code>, <code>--rr</code>：设置调度策略为 <code>SCHED_RR</code>（当未指定策略时，默认设置为该策略）。</li>
<li><code>-b</code>, <code>--batch</code>：设置调度策略为 <code>SCHED_BATCH</code>（自 2.6.16 起支持），优先级参数必须设置为零。</li>
<li><code>-i</code>, <code>--idle</code>：设置调度策略为 <code>SCHED_IDLE</code>（自 2.6.23 起支持），优先级参数必须设置为零。</li>
<li><code>-d</code>, <code>--deadline</code>：设置调度策略为 <code>SCHED_DEADLINE</code>（自 3.14 起支持），优先级参数必须设置为零。</li>
</ul>
<p><strong>调度选项</strong>：</p>
<ul>
<li><code>-T</code>, <code>--sched-runtime &lt;nanoseconds&gt;</code>：指定 <code>SCHED_DEADLINE</code> 策略的运行时参数。</li>
<li><code>-P</code>, <code>--sched-period &lt;nanoseconds&gt;</code>：指定 <code>SCHED_DEADLINE</code> 策略的周期参数。</li>
<li><code>-D</code>, <code>--sched-deadline &lt;nanoseconds&gt;</code>：指定 <code>SCHED_DEADLINE</code> 策略的截止时间参数。</li>
<li><code>-R</code>, <code>--reset-on-fork</code>：将 <code>SCHED_RESET_ON_FORK</code> 标志添加到 <code>SCHED_FIFO</code> 或 <code>SCHED_RR</code> 调度策略（自 2.6.31 起支持）。</li>
</ul>
<h2 id="示例-259"><a href="#示例-259" class="headerlink" title="示例"></a>示例</h2><p>查看 Linux 系统最小和最大的优先级：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chrt -m</span><br><span class="line">SCHED_OTHER 最小/最大优先级	: 0/0</span><br><span class="line">SCHED_FIFO 最小/最大优先级	: 1/99</span><br><span class="line">SCHED_RR 最小/最大优先级	: 1/99</span><br><span class="line">SCHED_BATCH 最小/最大优先级	: 0/0</span><br><span class="line">SCHED_IDLE 最小/最大优先级	: 0/0</span><br><span class="line">SCHED_DEADLINE 最小/最大优先级	: 0/0</span><br></pre></td></tr></table></figure>



<p>查看 PID 为 137619 的进程调度信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chrt -p 137619</span><br><span class="line">pid 137619 当前的调度策略︰ SCHED_OTHER</span><br><span class="line">pid 137619 的当前调度优先级：0</span><br></pre></td></tr></table></figure>



<p>将 PID 为 137619 的进程设置为 <code>SCHED_RR</code> 实时调度，且优先级为 30：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chrt -r -p 30 137619</span><br></pre></td></tr></table></figure>



<p>将 PID 为 137619 的进程设置为默认的 <code>SCHED_OTHER</code> 调度策略：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chrt -o -p 0 137619</span><br></pre></td></tr></table></figure>



<p>借助 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/pidof/"><code>pidof</code></a> 和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/xargs/"><code>xargs</code></a> 命令可以直接使用进程名称查询 PID，并传递给 chrt 命令。例如将 rviz2 进程优先级设置为 10：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pidof rviz2 | <span class="built_in">sudo</span> xargs chrt -r -p 10</span><br></pre></td></tr></table></figure>





<h1 id="Linux-taskset-命令-设置进程的-CPU-亲和性"><a href="#Linux-taskset-命令-设置进程的-CPU-亲和性" class="headerlink" title="Linux taskset 命令 - 设置进程的 CPU 亲和性"></a>Linux taskset 命令 - 设置进程的 CPU 亲和性</h1><h2 id="介绍-259"><a href="#介绍-259" class="headerlink" title="介绍"></a>介绍</h2><p><strong>taskset</strong>（英文全拼：task set）命令用于绑定 Linux 进程与 CPU 核心。一般情况下，一个程序启动后，其进程会在 CPU 核心之间切换执行，在系统的调度下，每个进程平均公平地分配到一定量的计算资源。有时候，运维人员想将某个进程与指定 CPU 核心进行绑定操作，以提高性能，这就需要用到 taskset 命令。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskset [options] mask <span class="built_in">command</span> [argument...]</span><br><span class="line">taskset [options] -p [mask] pid</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a</code>, <code>--all-tasks</code>：设置或检索给定 PID 的所有任务（线程）的 CPU 关联性。</li>
<li><code>-c</code>, <code>--cpu-list</code>：将掩码解释为处理器的数字列表而不是位掩码。数字以逗号分隔，并且可能包含范围。例如：0,5,8-11。</li>
<li><code>-p</code>, <code>--pid</code>：对现有 PID 进行操作并且不启动新任务。</li>
<li><code>-V</code>, <code>--version</code>：显示版本信息并退出。</li>
<li><code>-h</code>, <code>--help</code>：显示帮助信息并退出。</li>
</ul>
<h2 id="示例-260"><a href="#示例-260" class="headerlink" title="示例"></a>示例</h2><p>查询进程 7589 当前使用的 CPU 核心信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ taskset -pc 7589</span><br><span class="line">pid 7589<span class="string">&#x27;s current affinity list: 0-7</span></span><br></pre></td></tr></table></figure>



<p>设置进程 7589 只可运行在编号为 7 的 CPU 核心之上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ taskset -pc 7 7589 </span><br><span class="line">pid 7589<span class="string">&#x27;s current affinity list: 0-7</span></span><br><span class="line"><span class="string">pid 7589&#x27;</span>s new affinity list: 7</span><br></pre></td></tr></table></figure>



<p>设置进程 7589 只可运行在编号为 6 和 7 的 CPU 核心之上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ taskset -pc 6-7 7589 </span><br><span class="line">pid 7589<span class="string">&#x27;s current affinity list: 0-7</span></span><br><span class="line"><span class="string">pid 7589&#x27;</span>s new affinity list: 6,7</span><br></pre></td></tr></table></figure>



<p>启动 simple_viewer 程序并限定其只能在 CPU 核心 0、1、2、3 上运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskset -c 0-3 ./simple_viewer -<span class="built_in">type</span> A1 -pcap test.pcap</span><br></pre></td></tr></table></figure>



<p>启动后可借助 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/pgrep/">pgrep</a> 命令查看该进程 ID，查询当前使用的 CPU 核心信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskset -pc $(pgrep simple_viewer)</span><br></pre></td></tr></table></figure>





<h1 id="Linux-pidof-命令-获取进程的-PID"><a href="#Linux-pidof-命令-获取进程的-PID" class="headerlink" title="Linux pidof 命令 - 获取进程的 PID"></a>Linux pidof 命令 - 获取进程的 PID</h1><h2 id="介绍-260"><a href="#介绍-260" class="headerlink" title="介绍"></a>介绍</h2><p><strong>pidof</strong> 命令用于查找 Linux 系统中指定名称的进程的进程号（PID），功能类似 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/pgrep/">pgrep</a> 和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/ps/">ps</a>。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pidof [options] &lt;program-name&gt;</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-c</code>：仅显示具有相同“root”目录的进程号。</li>
<li><code>-d &lt;sep&gt;</code>：使用提供的字符作为输出分隔符。</li>
<li><code>-n</code>：避免在网络共享上使用 stat 系统函数。</li>
<li><code>-o &lt;pid&gt;</code>：指定不显示的进程号。</li>
<li><code>-q</code>：安静模式，不显示输出。</li>
<li><code>-s</code>：仅返回一个进程号。</li>
<li><code>-x</code>：显示由脚本开启的进程。</li>
<li><code>-z</code>：列出僵尸进程和 I&#x2F;O 等待进程。可能会导致 pidof 挂起。</li>
<li><code>-h</code>：显示帮助信息。</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li><code>program-name</code>：指定要查找的进程名称。</li>
</ul>
<h2 id="示例-261"><a href="#示例-261" class="headerlink" title="示例"></a>示例</h2><p>查询 apache2 进程的 PID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pidof apache2 </span><br><span class="line">232746 232745 232744 232743 232742 2157</span><br></pre></td></tr></table></figure>



<p>以逗号分隔：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pidof -d <span class="string">&#x27;,&#x27;</span>  apache2 </span><br><span class="line">232746,232745,232744,232743,232742,2157</span><br></pre></td></tr></table></figure>



<p>只返回一个进程号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pidof -s apache2 </span><br><span class="line">232746</span><br></pre></td></tr></table></figure>





<h1 id="Linux-pgrep-命令-根据名称查找进程-ID"><a href="#Linux-pgrep-命令-根据名称查找进程-ID" class="headerlink" title="Linux pgrep 命令 - 根据名称查找进程 ID"></a>Linux pgrep 命令 - 根据名称查找进程 ID</h1><h2 id="介绍-261"><a href="#介绍-261" class="headerlink" title="介绍"></a>介绍</h2><p><strong>pgrep</strong>（英文全拼：process global regular expression print）是 Linux 系统中用于检索进程 PID 的命令。与 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/pidof/">pidof</a> 命令必须准确输入服务名称不同，pgrep 命令通过正则表达式进行检索，因此用户只需要输入服务名称中的一部分即可进行搜索操作，对于不记得全名的服务程序特别好用。</p>
<p>pgrep 常用于通过进程名快速定位正在运行的进程，尤其在脚本或命令行中很有用。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pgrep [options] &lt;pattern&gt;</span><br></pre></td></tr></table></figure>



<p>说明：<em>pattern</em> 指定用于匹配进程名称或命令行的扩展正则表达式。简单地，你可以把它当作进程名。</p>
<p><strong>选项</strong>：</p>
<ul>
<li><code>-d, --delimiter &lt;string&gt;</code>：指定输出分隔符。</li>
<li><code>-l, --list-name</code>：显示 PID 和进程名。</li>
<li><code>-a, --list-full</code>：显示 PID 和完整的命令行信息。</li>
<li><code>-v, --inverse</code>：反向匹配。</li>
<li><code>-w, --lightweight</code>：显示所有线程的 TID。</li>
<li><code>-c, --count</code>：显示匹配进程的数量。</li>
<li><code>-f, --full</code>：使用完整的进程名称来匹配。</li>
<li><code>-g, --pgroup &lt;PGID,...&gt;</code>：匹配列出的进程组 ID。</li>
<li><code>-G, --group &lt;GID,...&gt;</code>：匹配真实的组 ID。</li>
<li><code>-i, --ignore-case</code>：不区分大小写匹配。</li>
<li><code>-n, --newest</code>：仅显示最新的匹配进程。</li>
<li><code>-o, --oldest</code>：仅显示最老的匹配进程。</li>
<li><code>-P, --parent &lt;PPID,...&gt;</code>：仅匹配给定父进程的子进程。</li>
<li><code>-s, --session &lt;SID,...&gt;</code>：匹配会话 ID。</li>
<li><code>-t, --terminal &lt;tty,...&gt;</code>：通过控制终端进行匹配。</li>
<li><code>-u, --euid &lt;ID,...&gt;</code>：通过有效 ID（EUID）进行匹配，即仅显示指定用户运行的进程。</li>
<li><code>-U, --uid &lt;ID,...&gt;</code>：根据真实 ID（UID）进行匹配。</li>
<li><code>-x, --exact</code>：与命令名称完全匹配。</li>
<li><code>-F, --pidfile &lt;file&gt;</code>：从文件中读取 PID。</li>
<li><code>-L, --logpidfile</code>：如果 PID 文件未锁定则失败。</li>
<li><code>-r, --runstates &lt;state&gt;</code>：匹配运行状态 [D,S,Z,…]。</li>
<li><code>--ns &lt;PID&gt;</code>：匹配与 <code>&lt;pid&gt;</code> 属于同一命名空间的进程。</li>
<li><code>--nslist &lt;ns,...&gt;</code>：列出 <code>--ns</code> 选项将考虑哪些命名空间，可用命名空间包括 ipc、mnt、net、pid、user、uts。</li>
<li><code>-h, --help</code>：显示帮助信息。</li>
<li><code>-V, --version</code>：显示程序版本。</li>
</ul>
<h2 id="示例-262"><a href="#示例-262" class="headerlink" title="示例"></a>示例</h2><p>显示所有包含 <code>firefox</code> 进程名的进程 PID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pgrep firefox</span><br></pre></td></tr></table></figure>



<p>显示所有包含 <code>firefox</code> 进程名的进程 PID 和进程名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pgrep -l firefox</span><br></pre></td></tr></table></figure>



<p>显示所有包含 <code>firefox</code> 进程名的进程 PID 和完整的命令行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pgrep -a firefox</span><br></pre></td></tr></table></figure>



<p>仅显示指定用户运行的包含 <code>firefox</code> 进程名的进程 PID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pgrep -u rudy firefox</span><br></pre></td></tr></table></figure>





<h1 id="Linux-xargs-命令-构建并执行命令行参数"><a href="#Linux-xargs-命令-构建并执行命令行参数" class="headerlink" title="Linux xargs 命令 - 构建并执行命令行参数"></a>Linux xargs 命令 - 构建并执行命令行参数</h1><h2 id="介绍-262"><a href="#介绍-262" class="headerlink" title="介绍"></a>介绍</h2><p><strong>xargs</strong>（英文全拼： eXtended ARGuments）是 Linux 系统给命令传递参数的一个过滤器，也是组合多个命令的一个工具，一般是和管道一起使用。</p>
<p>简单来说，使用 xargs 命令能够捕获一个命令的输出，然后传递给另外一个命令。因此，通过它就可以将多个命令串联起来，这在 Linux 命令行中非常重要，有着独特的作用。</p>
<p>在输入方面，xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xargs [options] [<span class="built_in">command</span> [initial-arguments]]</span><br><span class="line">somecommand | xargs [options] [<span class="built_in">command</span> [initial-arguments]]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-a file</code>：从文件中读入，而不是从标准输入（stdin）读入。</li>
<li><code>-e eof-str</code>：注意有的时候可能会是 <code>-E</code>，<code>eof-str</code> 必须是一个以空格分隔的标志，当 xargs 分析到含有 <code>eof-str</code> 这个标志的时候就停止。</li>
<li><code>-p, --interactive</code>：当每次执行的时候都要询问用户，输入 y 或 Y 后才执行。</li>
<li><code>-n max-args</code>：每个命令行最多使用 <code>max-args</code> 个参数。</li>
<li><code>-t, --verbose</code>：表示先打印命令，然后再执行。</li>
<li><code>-I replace-str</code>：将初始参数中出现的 <code>replace-str</code> 替换为从标准输入读取的名称。</li>
<li><code>-i</code>：同 <code>-I</code>。</li>
<li><code>-r, --no-run-if-empty</code>：当 xargs 的输入为空的时候则停止 xargs，不用再去执行了。</li>
<li><code>-s max-chars</code>：命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。</li>
<li><code>-L max-lines</code>：从标准输入一次读取 <code>max-lines</code> 行送给 command 命令。</li>
<li><code>-l</code>：同 <code>-L</code>。</li>
<li><code>-d delim</code>：分隔符，默认的 xargs 分隔符是回车，argument 的分隔符是空格，这里修改的是 xargs 的分隔符。</li>
<li><code>-x, --exit</code>：如果超出大小（请参阅 <code>-s</code> 选项），则退出。</li>
<li><code>-P max-procs</code>：一次最多运行 <code>max-procs</code> 个进程； 默认值为 1。如果设为 0，xargs 将一次运行尽可能多的进程。</li>
</ul>
<h2 id="示例-263"><a href="#示例-263" class="headerlink" title="示例"></a>示例</h2><p>大多数时候，xargs 命令都是和管道一起使用的。但是，它也可以单独使用。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xargs</span><br><span class="line">hello (Ctrl + D)</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>



<p>由于 xargs 后面的命令默认是 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/echo/"><code>echo</code></a>，因此当输入 xargs 按下回车以后，命令行就会等待用户输入，作为标准输入。你可以输入任意内容，然后按下 <code>Ctrl + D</code> 键结束，此时 echo 命令就会把前面的输入打印出来。</p>
<p>当然，单独使用时 xargs 后面可以带上其他命令，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xargs find -name</span><br><span class="line">*.md</span><br></pre></td></tr></table></figure>



<p>当输入命令 <code>xargs find -name</code> 以后，命令行会等待用户输入所要搜索的文件。此时输入 <code>*.md</code>，表示搜索当前目录下的所有 Markdown 文件，然后按下 <code>Ctrl + D</code> 键结束输入。此时会输出所有 .md 文件，该命令相当执行 <code>find -name *.md</code>。</p>
<p>下面再看使用 xargs 和管道打印 Hello World（将管道左侧的标准输入，转为命令行参数，传递给 echo 命令）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> | xargs <span class="built_in">echo</span></span><br></pre></td></tr></table></figure>



<p>使用 xargs 和管道创建目录（等效于 <code>mkdir one two three</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;one two three&quot;</span> | xargs <span class="built_in">mkdir</span></span><br></pre></td></tr></table></figure>





<h1 id="Linux-aplay-命令-播放音频文件"><a href="#Linux-aplay-命令-播放音频文件" class="headerlink" title="Linux aplay 命令 - 播放音频文件"></a>Linux aplay 命令 - 播放音频文件</h1><h2 id="介绍-263"><a href="#介绍-263" class="headerlink" title="介绍"></a>介绍</h2><p><strong>aplay</strong> 是 Linux 系统中用于播放音频文件的命令行工具。它是 ALSA（Advanced Linux Sound Architecture）项目的一部分，用于与音频设备进行交互。</p>
<p>aplay 支持大多数音频文件格式，如 WAV、MP3、OGG 等。理论上，只要有相应的 ALSA 插件支持就可以播放。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aplay [options] [filename [filename]] ...</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-l, --list-devices</code>：列出所有声卡和数字音频设备。</li>
<li><code>-L, --list-pcms</code>：列出所有 PCM 设备名称。</li>
<li><code>-D, --device=NAME</code>：按名称选择 PCM 设备。</li>
<li><code>-q, --quiet</code>：安静模式。</li>
<li><code>-t, --file-type TYPE</code>：指定文件类型（如 voc、wav、raw 或 au）。</li>
<li><code>-c, --channels=#</code>：指定音频文件的通道数。</li>
<li><code>-f, --format=FORMAT</code>：指定音频文件的采样格式（不区分大小写）。</li>
<li><code>-r, --rate=#</code>：指定音频文件的采样率。</li>
<li><code>-d, --duration=#</code>：<code>#</code> 秒后中断。</li>
<li><code>-s, --samples=#</code>：每个通道采样 <code>#</code> 次后中断。</li>
<li><code>-v, --verbose</code>：显示 PCM 结构和设置（累计）。</li>
<li><code>-i, --interactive</code>：允许来自 stdin 的交互操作。</li>
<li><code>-h, --help</code>：显示帮助信息。</li>
<li><code>--version</code>： 显示版本信息。</li>
</ul>
<p>备注</p>
<p>支持的采样格式有：<code>S8</code> <code>U8</code> <code>S16_LE</code> <code>S16_BE</code> <code>U16_LE</code> <code>U16_BE</code> <code>S24_LE</code> <code>S24_BE</code> <code>U24_LE</code> <code>U24_BE</code> <code>S32_LE</code> <code>S32_BE</code> <code>U32_LE</code> <code>U32_BE</code> <code>FLOAT_LE</code> <code>FLOAT_BE</code> <code>FLOAT64_LE</code> <code>FLOAT64_BE</code> <code>IEC958_SUBFRAME_LE</code> <code>IEC958_SUBFRAME_BE</code> <code>MU_LAW</code> <code>A_LAW</code> <code>IMA_ADPCM</code> <code>MPEG</code> <code>GSM</code> <code>SPECIAL</code> <code>S24_3LE</code> <code>S24_3BE</code> <code>U24_3LE</code> <code>U24_3BE</code> <code>S20_3LE</code> <code>S20_3BE</code> <code>U20_3LE</code> <code>U20_3BE</code> <code>S18_3LE</code> <code>S18_3BE</code> <code>U18_3LE</code>。</p>
<p>需要注意的是，并非所有硬件都完全支持这些格式。</p>
<p>此外，一些常用的格式有快捷方式：</p>
<ul>
<li><code>-f cd</code>（16 bit little endian, 44100, stereo）等效于 <code>-f S16_LE -c2 -r44100</code></li>
<li><code>-f cdr</code>（16 bit big endian, 44100, stereo）等效于 <code>-f S16_BE -c2 -f44100</code></li>
<li><code>-f dat</code>（16 bit little endian, 48000, stereo）等效于 <code>-f S16_LE -c2 -r48000</code></li>
</ul>
<p>如果没有指定采样格式，默认使用 <code>U8</code>。</p>
<h2 id="示例-264"><a href="#示例-264" class="headerlink" title="示例"></a>示例</h2><p>播放名为 sample.wav 的音频文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aplay sample.wav</span><br></pre></td></tr></table></figure>



<p>指定使用硬件设备 <code>hw:0,0</code> 进行播放：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aplay -D hw:0,0 sample.wav</span><br></pre></td></tr></table></figure>



<p>指定音频文件的格式为 CD 质量（16位，立体声），通道数为 2，采样率为 44100 Hz：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aplay -f <span class="built_in">cd</span> -c 2 -r 44100 sample.wav</span><br></pre></td></tr></table></figure>



<p>使用原始文件类型进行播放，并指定采样率、通道数和数据格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aplay -t raw -r 44100 -c 2 -f S16_LE sample.raw</span><br></pre></td></tr></table></figure>



<p>从标准输入读取数据进行播放：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> sample.wav | aplay -</span><br></pre></td></tr></table></figure>





<h1 id="Linux-arecord-命令-录制音频文件"><a href="#Linux-arecord-命令-录制音频文件" class="headerlink" title="Linux arecord 命令 - 录制音频文件"></a>Linux arecord 命令 - 录制音频文件</h1><h2 id="介绍-264"><a href="#介绍-264" class="headerlink" title="介绍"></a>介绍</h2><p><strong>arecord</strong> 是 Linux 系统中用于录制音频文件的命令行工具，它可以通过 ALSA 驱动从音频输入设备录制音频，并保存为音频文件。arecord 是 ALSA（Advanced Linux Sound Architecture）项目的一部分。</p>
<p>arecord 支持大多数音频文件格式，如 WAV、MP3、OGG 等，录制完成后可以将录音保存为相应格式。arecord 还支持基本的录音效果，如混响等。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arecord [options] [filename]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-l, --list-devices</code>：列出所有声卡和数字音频设备。</li>
<li><code>-L, --list-pcms</code>：列出所有 PCM 设备名称。</li>
<li><code>-D, --device=NAME</code>：按名称选择 PCM 设备。</li>
<li><code>-q, --quiet</code>：安静模式。</li>
<li><code>-t, --file-type TYPE</code>：指定文件类型（如 voc、wav、raw 或 au）。</li>
<li><code>-c, --channels=#</code>：指定音频文件的通道数。</li>
<li><code>-f, --format=FORMAT</code>：指定音频文件的采样格式（不区分大小写）。</li>
<li><code>-r, --rate=#</code>：指定音频文件的采样率。</li>
<li><code>-d, --duration=#</code>：<code>#</code> 秒后中断。</li>
<li><code>-s, --samples=#</code>：每个通道采样 <code>#</code> 次后中断。</li>
<li><code>-v, --verbose</code>：显示 PCM 结构和设置（累计）。</li>
<li><code>-i, --interactive</code>：允许来自 stdin 的交互操作。</li>
<li><code>-h, --help</code>：显示帮助信息。</li>
<li><code>--version</code>： 显示版本信息。</li>
</ul>
<h2 id="示例-265"><a href="#示例-265" class="headerlink" title="示例"></a>示例</h2><p>录制 wav 格式音频，输入设备为 <code>hw:0.0</code>，录制时间为 5 秒，采样率为 44100Hz（CD 音质），保存为 sample.wav：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arecord -D hw:0.0 -d 5 -r 44100 -f <span class="built_in">cd</span> sample.wav</span><br></pre></td></tr></table></figure>





<h1 id="Linux-amixer-命令-ALSA-音频控制"><a href="#Linux-amixer-命令-ALSA-音频控制" class="headerlink" title="Linux amixer 命令 - ALSA 音频控制"></a>Linux amixer 命令 - ALSA 音频控制</h1><h2 id="介绍-265"><a href="#介绍-265" class="headerlink" title="介绍"></a>介绍</h2><p><strong>amixer</strong> 是 Linux 系统中的一个命令行工具，用于调整音频设置，包括音量、音频输入和输出设备等。它是 ALSA（Advanced Linux Sound Architecture）项目的一部分。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">amixer [-option] [cmd]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-c</code>, <code>--card N</code> ：选择声卡卡号。</li>
<li><code>-D</code>, <code>--device N</code> ：选择声卡设备，默认为 ‘default’。</li>
<li><code>-d</code>, <code>--debug</code> ：调试模式。</li>
<li><code>-n</code>, <code>--nocheck</code> ：不执行范围检查。</li>
<li><code>-q</code>, <code>--quiet</code> ：安静模式。</li>
<li><code>-i</code>, <code>--inactive</code> ：也显示不活动的控件。</li>
<li><code>-a</code>, <code>--abstract L</code> ：选择抽象级别（none 或 basic）。</li>
<li><code>-s</code>, <code>--stdin</code> ：从标准输入顺序读取和执行命令。</li>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息。</li>
<li><code>-v</code>, <code>--version</code> ：打印版本信息。</li>
</ul>
<p><strong>命令</strong>：</p>
<ul>
<li><code>scontrols</code> ：显示所有混音器简单控件。</li>
<li><code>scontents</code> ：显示所有混音器简单控件的内容（默认命令）。</li>
<li><code>sset sID P</code> ：为一个混音器简单控件设置内容。</li>
<li><code>sget sID</code> ：获取一个混音器简单控件的内容。</li>
<li><code>controls</code> ：显示指定声卡的所有控件。</li>
<li><code>contents</code> ：显示指定声卡的所有控件的内容。</li>
<li><code>cset cID P</code> ：为一个控件设置控件内容。set control contents for one control</li>
<li><code>cget cID</code> ：获取一个控件的控件内容。</li>
</ul>
<h2 id="示例-266"><a href="#示例-266" class="headerlink" title="示例"></a>示例</h2><p>列出可用的音频控制元素：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">amixer controls</span><br></pre></td></tr></table></figure>



<p>获取 <code>Master</code> 通道的音量信息（显示当前音量）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">amixer sget Master</span><br></pre></td></tr></table></figure>



<p>将 <code>Master</code> 通道的音量设置为最大值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">amixer sset Master 100%</span><br></pre></td></tr></table></figure>



<p>调整 PCM 通道的音量（设置为 80%）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">amixer sset PCM 80%</span><br></pre></td></tr></table></figure>



<p>获取 PCM 通道的音量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">amixer sget PCM</span><br></pre></td></tr></table></figure>



<p>切换 <code>Master</code> 通道的静音状态（静音&#x2F;取消静音）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">amixer sset Master toggle</span><br></pre></td></tr></table></figure>



<p>设置 PCM 通道的控制参数（设置 <code>numid</code> 为 3 的控制参数为 2）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">amixer cset numid=3 2</span><br></pre></td></tr></table></figure>



<p>获取 PCM 通道的控制参数（获取 <code>numid</code> 为 3 的控制参数）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">amixer cget numid=3</span><br></pre></td></tr></table></figure>



<p>指定音频卡设备为 <code>hw:0</code>，并将 <code>Master</code> 通道的音量设置为 50%：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">amixer -D hw:0 sset Master 50%</span><br></pre></td></tr></table></figure>





<h1 id="Linux-alsamixer-命令-ALSA-混音器控制"><a href="#Linux-alsamixer-命令-ALSA-混音器控制" class="headerlink" title="Linux alsamixer 命令 - ALSA 混音器控制"></a>Linux alsamixer 命令 - ALSA 混音器控制</h1><h2 id="介绍-266"><a href="#介绍-266" class="headerlink" title="介绍"></a>介绍</h2><p><strong>alsamixer</strong> 是 Linux 系统中的一个命令行工具，用于调整 ALSA（Advanced Linux Sound Architecture）音频设置，例如调整音频设备的音量、通道、输入输出等参数。和 <a target="_blank" rel="noopener" href="https://getiot.tech/linux-command/amixer/">amixer</a> 不同，alsamixer 提供一个交互式的文本界面。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alsamixer [options]</span><br></pre></td></tr></table></figure>



<p><strong>选项</strong>：</p>
<ul>
<li><code>-h</code>, <code>--help</code> ：显示帮助信息。</li>
<li><code>-c, --card &lt;card number or identification&gt;</code>：如果你有多个声卡，请选择要使用的声卡。声卡编号从 0（默认）开始。</li>
<li><code>-D, --device &lt;device identification&gt;</code>：选择要控制的混音器设备（mixer device）。</li>
<li><code>-V, --view &lt;mode&gt;</code>：选择起始视图模式，播放（playback）、捕捉（capture）或全部（all）。</li>
<li><code>-g, --no-color</code>：切换颜色的使用。</li>
</ul>
<p><strong>交互操作</strong>：</p>
<ul>
<li>左右箭头键：选择不同的控制元素。</li>
<li>上下箭头键：调整所选控制元素的值。</li>
<li>M 键：静音&#x2F;取消静音。</li>
<li>Esc 键：退出 alsamixer。</li>
</ul>
<h2 id="示例-267"><a href="#示例-267" class="headerlink" title="示例"></a>示例</h2><p>启动 alsamixer 程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alsamixer</span><br></pre></td></tr></table></figure>



<p>可以看到类似如下界面：</p>
<p><img src="/./Image/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.assets/alsamixer-screenshot.png" alt="img"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chaoqijiang.github.io">棨</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chaoqijiang.github.io/2025/07/27/Linux%20%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/">https://chaoqijiang.github.io/2025/07/27/Linux 命令大全/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://chaoqijiang.github.io" target="_blank">柊</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/protected/">protected</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post-share"><div class="social-share" data-image="/Image/avatar.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/04/windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8dhcpsrv%E5%AE%9E%E7%8E%B0dhcp%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="windows环境下使用dhcpsrv实现dhcp服务器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">windows环境下使用dhcpsrv实现dhcp服务器</div></div><div class="info-2"><div class="info-item-1">windows环境下使用dhcpsrv实现dhcp服务器</div></div></div></a><a class="pagination-related" href="/2025/08/26/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Redis学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Redis学习笔记</div></div><div class="info-2"><div class="info-item-1">Redis学习笔记</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/05/04/Armbian%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8RNDIS%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E4%B8%8A%E7%BD%91/" title="Armbian系统使用RNDIS协议进行上网"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-04</div><div class="info-item-2">Armbian系统使用RNDIS协议进行上网</div></div><div class="info-2"><div class="info-item-1">Armbian系统使用RNDIS协议进行上网</div></div></div></a><a class="pagination-related" href="/2022/08/18/Linux%E6%A1%88%E4%BE%8B/" title="Linux基础案例"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-18</div><div class="info-item-2">Linux基础案例</div></div><div class="info-2"><div class="info-item-1">Linux案例学习笔记。</div></div></div></a><a class="pagination-related" href="/2022/08/18/Linux%E5%9F%BA%E7%A1%80/" title="Linux基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-18</div><div class="info-item-2">Linux基础</div></div><div class="info-2"><div class="info-item-1">Linux基础学习笔记。</div></div></div></a><a class="pagination-related" href="/2024/01/14/Linux%E7%B3%BB%E7%BB%9F%E6%9F%A5%E8%AF%A2%E8%AE%BE%E5%A4%87%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF/" title="Linux系统查询设备的详细信息"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-14</div><div class="info-item-2">Linux系统查询设备的详细信息</div></div><div class="info-2"><div class="info-item-1">Linux系统下查询设备的详细信息</div></div></div></a><a class="pagination-related" href="/0202/01/26/Linux%E9%83%A8%E7%BD%B2Tomcat/" title="Linux部署Tomcat"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 0202-01-26</div><div class="info-item-2">Linux部署Tomcat</div></div><div class="info-2"><div class="info-item-1">Linux部署Tomcat</div></div></div></a><a class="pagination-related" href="/2024/01/31/linux%E4%B8%8B%E9%80%9A%E8%BF%87CURL%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0%E5%8A%9F%E8%83%BD/" title="linux下通过CURL实现自动签到功能"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-31</div><div class="info-item-2">linux下通过CURL实现自动签到功能</div></div><div class="info-2"><div class="info-item-1">linux下通过CURL实现自动签到功能</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/Image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">棨</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:chaoqijiang@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8"><span class="toc-number">1.</span> <span class="toc-text">Linux 命令大全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">1.0.1.</span> <span class="toc-text">文件管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.0.2.</span> <span class="toc-text">磁盘管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.0.3.</span> <span class="toc-text">进程管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-number">1.0.4.</span> <span class="toc-text">系统管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86"><span class="toc-number">1.0.5.</span> <span class="toc-text">网络管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">1.0.6.</span> <span class="toc-text">设备管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7"><span class="toc-number">1.0.7.</span> <span class="toc-text">系统监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.0.8.</span> <span class="toc-text">系统服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-number">1.0.9.</span> <span class="toc-text">包管理工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-number">1.0.10.</span> <span class="toc-text">开发工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">1.0.11.</span> <span class="toc-text">调试工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">1.0.12.</span> <span class="toc-text">实用工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9F%B3%E8%A7%86%E9%A2%91"><span class="toc-number">1.0.13.</span> <span class="toc-text">音视频</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%B8%AE%E5%8A%A9"><span class="toc-number">1.0.14.</span> <span class="toc-text">命令帮助</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-apt-%E5%91%BD%E4%BB%A4-APT%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-number">2.</span> <span class="toc-text">Linux apt 命令 - APT软件包管理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-apt-get-%E5%91%BD%E4%BB%A4-APT%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-number">3.</span> <span class="toc-text">Linux apt-get 命令 - APT软件包管理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">3.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-apt-config-%E5%91%BD%E4%BB%A4-%E7%AE%A1%E7%90%86-APT-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">Linux apt-config 命令 - 管理 APT 配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">4.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-apt-cache-%E5%91%BD%E4%BB%A4-%E6%9F%A5%E8%AF%A2%E8%BD%AF%E4%BB%B6%E5%8C%85%E4%BF%A1%E6%81%AF"><span class="toc-number">5.</span> <span class="toc-text">Linux apt-cache 命令 - 查询软件包信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">5.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">5.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-dpkg-%E5%91%BD%E4%BB%A4-%E7%AE%A1%E7%90%86-Debian-%E8%BD%AF%E4%BB%B6%E5%8C%85"><span class="toc-number">6.</span> <span class="toc-text">Linux dpkg 命令 - 管理 Debian 软件包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">6.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">6.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-dnf-%E5%91%BD%E4%BB%A4-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-number">7.</span> <span class="toc-text">Linux dnf 命令 - 软件包管理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-5"><span class="toc-number">7.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">7.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-yum-%E5%91%BD%E4%BB%A4-%E7%AE%A1%E7%90%86-RPM-%E8%BD%AF%E4%BB%B6%E5%8C%85"><span class="toc-number">8.</span> <span class="toc-text">Linux yum 命令 - 管理 RPM 软件包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-6"><span class="toc-number">8.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-6"><span class="toc-number">8.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-pkg-%E5%91%BD%E4%BB%A4-%E7%AE%A1%E7%90%86-FreeBSD-%E8%BD%AF%E4%BB%B6%E5%8C%85"><span class="toc-number">9.</span> <span class="toc-text">Linux pkg 命令 - 管理 FreeBSD 软件包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-7"><span class="toc-number">9.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-7"><span class="toc-number">9.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-flatpak-%E5%91%BD%E4%BB%A4-%E7%AE%A1%E7%90%86-Flatpak-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">10.</span> <span class="toc-text">Linux flatpak 命令 - 管理 Flatpak 应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-8"><span class="toc-number">10.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-8"><span class="toc-number">10.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-snap-%E5%91%BD%E4%BB%A4-%E7%AE%A1%E7%90%86-Snap-%E5%BA%94%E7%94%A8%E5%8C%85"><span class="toc-number">11.</span> <span class="toc-text">Linux snap 命令 - 管理 Snap 应用包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-9"><span class="toc-number">11.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-9"><span class="toc-number">11.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-man-%E5%91%BD%E4%BB%A4-%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C%E9%A1%B5"><span class="toc-number">12.</span> <span class="toc-text">Linux man 命令 - 查看命令手册页</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-10"><span class="toc-number">12.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-10"><span class="toc-number">12.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-info-%E5%91%BD%E4%BB%A4-%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%96%87%E6%A1%A3"><span class="toc-number">13.</span> <span class="toc-text">Linux info 命令 - 查看命令和程序的文档</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-11"><span class="toc-number">13.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-11"><span class="toc-number">13.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-whatis-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E5%91%BD%E4%BB%A4%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E"><span class="toc-number">14.</span> <span class="toc-text">Linux whatis 命令 - 显示命令简要说明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-12"><span class="toc-number">14.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-12"><span class="toc-number">14.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-whereis-%E5%91%BD%E4%BB%A4-%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4%E7%9A%84%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6"><span class="toc-number">15.</span> <span class="toc-text">Linux whereis 命令 - 查找命令的路径和相关文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-13"><span class="toc-number">15.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-13"><span class="toc-number">15.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-which-%E5%91%BD%E4%BB%A4-%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%8C%E6%95%B4%E8%B7%AF%E5%BE%84"><span class="toc-number">16.</span> <span class="toc-text">Linux which 命令 - 查找命令的完整路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-14"><span class="toc-number">16.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-14"><span class="toc-number">16.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-command-%E5%91%BD%E4%BB%A4-%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">17.</span> <span class="toc-text">Linux command 命令 - 执行外部命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-15"><span class="toc-number">17.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-15"><span class="toc-number">17.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ascii-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E7%9A%84-ASCII-%E7%A0%81"><span class="toc-number">18.</span> <span class="toc-text">Linux ascii 命令 - 显示字符的 ASCII 码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-16"><span class="toc-number">18.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-16"><span class="toc-number">18.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-convert-%E5%91%BD%E4%BB%A4-%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7"><span class="toc-number">19.</span> <span class="toc-text">Linux convert 命令 - 图像格式转换工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-17"><span class="toc-number">19.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-17"><span class="toc-number">19.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-qrencode-%E5%91%BD%E4%BB%A4-%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">20.</span> <span class="toc-text">Linux qrencode 命令 - 生成二维码的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-18"><span class="toc-number">20.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-18"><span class="toc-number">20.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-dos2unix-%E5%91%BD%E4%BB%A4-%E8%BD%AC%E6%8D%A2%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">21.</span> <span class="toc-text">Linux dos2unix 命令 - 转换文本文件格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-19"><span class="toc-number">21.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-19"><span class="toc-number">21.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ronn-%E5%91%BD%E4%BB%A4-%E8%BD%AC%E6%8D%A2-Markdown-%E4%B8%BA-man-%E9%A1%B5"><span class="toc-number">22.</span> <span class="toc-text">Linux ronn 命令 - 转换 Markdown 为 man 页</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-20"><span class="toc-number">22.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-20"><span class="toc-number">22.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-cwebp-%E5%91%BD%E4%BB%A4-%E5%B0%86%E5%9B%BE%E5%83%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA-WebP-%E6%A0%BC%E5%BC%8F"><span class="toc-number">23.</span> <span class="toc-text">Linux cwebp 命令 - 将图像转换为 WebP 格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-21"><span class="toc-number">23.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-21"><span class="toc-number">23.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-dwebp-%E5%91%BD%E4%BB%A4-%E5%B0%86-WebP-%E5%9B%BE%E5%83%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%B6%E4%BB%96%E6%A0%BC%E5%BC%8F"><span class="toc-number">24.</span> <span class="toc-text">Linux dwebp 命令 - 将 WebP 图像转换为其他格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-22"><span class="toc-number">24.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-22"><span class="toc-number">24.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-pv-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%9B%E5%BA%A6"><span class="toc-number">25.</span> <span class="toc-text">Linux pv 命令 - 显示数据传输进度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-23"><span class="toc-number">25.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-23"><span class="toc-number">25.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-redshift-%E5%91%BD%E4%BB%A4-%E6%8A%A4%E7%9C%BC%E8%89%B2%E6%B8%A9%E8%B0%83%E8%8A%82%E5%B7%A5%E5%85%B7"><span class="toc-number">26.</span> <span class="toc-text">Linux redshift 命令 - 护眼色温调节工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-24"><span class="toc-number">26.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-24"><span class="toc-number">26.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ptp4l-%E5%91%BD%E4%BB%A4-PTP-%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5"><span class="toc-number">27.</span> <span class="toc-text">Linux ptp4l 命令 - PTP 时间同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-25"><span class="toc-number">27.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-25"><span class="toc-number">27.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-phc2sys-%E5%91%BD%E4%BB%A4-%E5%90%8C%E6%AD%A5-PTP-%E6%97%B6%E9%92%9F%E4%B8%8E%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F"><span class="toc-number">28.</span> <span class="toc-text">Linux phc2sys 命令 - 同步 PTP 时钟与系统时钟</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-26"><span class="toc-number">28.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-26"><span class="toc-number">28.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-phc-ctl-%E5%91%BD%E4%BB%A4-%E7%AE%A1%E7%90%86-PTP-%E7%A1%AC%E4%BB%B6%E6%97%B6%E9%92%9F"><span class="toc-number">29.</span> <span class="toc-text">Linux phc_ctl 命令 - 管理 PTP 硬件时钟</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-27"><span class="toc-number">29.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-27"><span class="toc-number">29.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-pmc-%E5%91%BD%E4%BB%A4-%E7%AE%A1%E7%90%86-PTP-%E7%BD%91%E7%BB%9C"><span class="toc-number">30.</span> <span class="toc-text">Linux pmc 命令 - 管理 PTP 网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-28"><span class="toc-number">30.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-28"><span class="toc-number">30.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-gpsd-%E5%91%BD%E4%BB%A4-%E7%AE%A1%E7%90%86-GPS-%E6%8E%A5%E6%94%B6%E5%99%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">31.</span> <span class="toc-text">Linux gpsd 命令 - 管理 GPS 接收器服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-29"><span class="toc-number">31.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-29"><span class="toc-number">31.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-cgps-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA-GPS-%E4%BF%A1%E6%81%AF%E5%92%8C%E4%BD%8D%E7%BD%AE"><span class="toc-number">32.</span> <span class="toc-text">Linux cgps 命令 - 显示 GPS 信息和位置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-30"><span class="toc-number">32.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-30"><span class="toc-number">32.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-gpsmon-%E5%91%BD%E4%BB%A4-%E7%9B%91%E6%8E%A7-GPS-%E6%95%B0%E6%8D%AE%E5%92%8C%E7%8A%B6%E6%80%81"><span class="toc-number">33.</span> <span class="toc-text">Linux gpsmon 命令 - 监控 GPS 数据和状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-31"><span class="toc-number">33.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-31"><span class="toc-number">33.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-gpspipe-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA-GPS-%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">34.</span> <span class="toc-text">Linux gpspipe 命令 - 显示 GPS 数据流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-32"><span class="toc-number">34.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-32"><span class="toc-number">34.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-debootstrap-%E5%91%BD%E4%BB%A4-%E5%88%9B%E5%BB%BA-Debian-%E5%9F%BA%E7%A1%80%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">35.</span> <span class="toc-text">Linux debootstrap 命令 - 创建 Debian 基础文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-33"><span class="toc-number">35.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-33"><span class="toc-number">35.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-capinfos-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA-pcap-%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">36.</span> <span class="toc-text">Linux capinfos 命令 - 显示 pcap 文件信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-34"><span class="toc-number">36.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-34"><span class="toc-number">36.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-editcap-%E5%91%BD%E4%BB%A4-%E7%BC%96%E8%BE%91%E5%92%8C%E8%BD%AC%E6%8D%A2-pcap-%E6%96%87%E4%BB%B6"><span class="toc-number">37.</span> <span class="toc-text">Linux editcap 命令 - 编辑和转换 pcap 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-35"><span class="toc-number">37.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-35"><span class="toc-number">37.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-mergecap-%E5%91%BD%E4%BB%A4-%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA-pcap-%E6%96%87%E4%BB%B6"><span class="toc-number">38.</span> <span class="toc-text">Linux mergecap 命令 - 合并多个 pcap 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-36"><span class="toc-number">38.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-36"><span class="toc-number">38.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-jq-%E5%91%BD%E4%BB%A4-JSON-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">39.</span> <span class="toc-text">Linux jq 命令 - JSON 数据处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-37"><span class="toc-number">39.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-37"><span class="toc-number">39.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-gcc-%E5%91%BD%E4%BB%A4-GNU-C-%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">40.</span> <span class="toc-text">Linux gcc 命令 - GNU C 编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-38"><span class="toc-number">40.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-38"><span class="toc-number">40.2.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E7%BC%96%E8%AF%91"><span class="toc-number">40.2.1.</span> <span class="toc-text">阶段编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">40.2.2.</span> <span class="toc-text">使用静态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="toc-number">40.2.3.</span> <span class="toc-text">使用共享库</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ldd-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E4%BE%9D%E8%B5%96%E5%BA%93"><span class="toc-number">41.</span> <span class="toc-text">Linux ldd 命令 - 显示可执行文件的依赖库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-39"><span class="toc-number">41.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-39"><span class="toc-number">41.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ldconfig-%E5%91%BD%E4%BB%A4-%E6%9B%B4%E6%96%B0%E5%85%B1%E4%BA%AB%E5%BA%93%E7%BC%93%E5%AD%98"><span class="toc-number">42.</span> <span class="toc-text">Linux ldconfig 命令 - 更新共享库缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-40"><span class="toc-number">42.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-40"><span class="toc-number">42.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-objdump-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">43.</span> <span class="toc-text">Linux objdump 命令 - 显示目标文件信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-41"><span class="toc-number">43.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-41"><span class="toc-number">43.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-readelf-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA-ELF-%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">44.</span> <span class="toc-text">Linux readelf 命令 - 显示 ELF 文件信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-42"><span class="toc-number">44.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-42"><span class="toc-number">44.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-size-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">45.</span> <span class="toc-text">Linux size 命令 - 显示目标文件的大小</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-43"><span class="toc-number">45.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-43"><span class="toc-number">45.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-nm-%E5%91%BD%E4%BB%A4-%E5%88%97%E5%87%BA%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-number">46.</span> <span class="toc-text">Linux nm 命令 - 列出目标文件的符号表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-44"><span class="toc-number">46.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-44"><span class="toc-number">46.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%AF%B4%E6%98%8E"><span class="toc-number">46.3.</span> <span class="toc-text">符号说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-install-%E5%91%BD%E4%BB%A4-%E5%A4%8D%E5%88%B6%E5%B9%B6%E5%AE%89%E8%A3%85%E6%96%87%E4%BB%B6"><span class="toc-number">47.</span> <span class="toc-text">Linux install 命令 - 复制并安装文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-45"><span class="toc-number">47.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-45"><span class="toc-number">47.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-cat-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-number">48.</span> <span class="toc-text">Linux cat 命令 - 显示文件内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-46"><span class="toc-number">48.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-46"><span class="toc-number">48.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-zcat-%E5%91%BD%E4%BB%A4-%E6%9F%A5%E7%9C%8B%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-number">49.</span> <span class="toc-text">Linux zcat 命令 - 查看压缩文件内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-47"><span class="toc-number">49.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-47"><span class="toc-number">49.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-echo-%E5%91%BD%E4%BB%A4-%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AE%B9"><span class="toc-number">50.</span> <span class="toc-text">Linux echo 命令 - 输出字符串内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-48"><span class="toc-number">50.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-48"><span class="toc-number">50.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-chmod-%E5%91%BD%E4%BB%A4-%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="toc-number">51.</span> <span class="toc-text">Linux chmod 命令 - 改变文件权限</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-49"><span class="toc-number">51.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-49"><span class="toc-number">51.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-chown-%E5%91%BD%E4%BB%A4-%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E6%89%80%E6%9C%89%E8%80%85"><span class="toc-number">52.</span> <span class="toc-text">Linux chown 命令 - 改变文件所有者</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-50"><span class="toc-number">52.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-50"><span class="toc-number">52.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-less-%E5%91%BD%E4%BB%A4-%E5%88%86%E9%A1%B5%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6"><span class="toc-number">53.</span> <span class="toc-text">Linux less 命令 - 分页查看文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-51"><span class="toc-number">53.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-51"><span class="toc-number">53.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-more-%E5%91%BD%E4%BB%A4-%E5%88%86%E9%A1%B5%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6"><span class="toc-number">54.</span> <span class="toc-text">Linux more 命令 - 分页查看文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-52"><span class="toc-number">54.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-52"><span class="toc-number">54.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-diff-%E5%91%BD%E4%BB%A4-%E6%AF%94%E8%BE%83%E6%96%87%E4%BB%B6%E5%B7%AE%E5%BC%82"><span class="toc-number">55.</span> <span class="toc-text">Linux diff 命令 - 比较文件差异</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-53"><span class="toc-number">55.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-53"><span class="toc-number">55.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-patch-%E5%91%BD%E4%BB%A4-%E5%BA%94%E7%94%A8%E6%96%87%E4%BB%B6%E8%A1%A5%E4%B8%81"><span class="toc-number">56.</span> <span class="toc-text">Linux patch 命令 - 应用文件补丁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-54"><span class="toc-number">56.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-54"><span class="toc-number">56.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-find-%E5%91%BD%E4%BB%A4-%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95"><span class="toc-number">57.</span> <span class="toc-text">Linux find 命令 - 查找文件或目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-55"><span class="toc-number">57.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-55"><span class="toc-number">57.2.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%90%8D%E7%A7%B0%E6%9F%A5%E6%89%BE-%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6"><span class="toc-number">57.2.1.</span> <span class="toc-text">按名称查找&#x2F;搜索文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6"><span class="toc-number">57.2.2.</span> <span class="toc-text">按文件扩展名查找文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%B1%BB%E5%9E%8B%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6"><span class="toc-number">57.2.3.</span> <span class="toc-text">按类型查找文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%A4%A7%E5%B0%8F%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6"><span class="toc-number">57.2.4.</span> <span class="toc-text">按大小查找文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E6%97%A5%E6%9C%9F%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6"><span class="toc-number">57.2.5.</span> <span class="toc-text">按日期查找文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E6%9D%83%E9%99%90%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6"><span class="toc-number">57.2.6.</span> <span class="toc-text">按权限查找文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E6%89%80%E6%9C%89%E8%80%85%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6"><span class="toc-number">57.2.7.</span> <span class="toc-text">按所有者查找文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%B9%B6%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">57.2.8.</span> <span class="toc-text">查找并删除文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-grep-%E5%91%BD%E4%BB%A4-%E6%90%9C%E7%B4%A2%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9"><span class="toc-number">58.</span> <span class="toc-text">Linux grep 命令 - 搜索文本内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-56"><span class="toc-number">58.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-56"><span class="toc-number">58.2.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E8%BF%9B%E7%A8%8B"><span class="toc-number">58.2.1.</span> <span class="toc-text">查找进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-number">58.2.2.</span> <span class="toc-text">查找文件内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-read-%E5%91%BD%E4%BB%A4-%E8%AF%BB%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5"><span class="toc-number">59.</span> <span class="toc-text">Linux read 命令 - 读取用户输入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-57"><span class="toc-number">59.1.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">59.1.1.</span> <span class="toc-text">语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-57"><span class="toc-number">59.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-umask-%E5%91%BD%E4%BB%A4-%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E6%8E%A9%E7%A0%81"><span class="toc-number">60.</span> <span class="toc-text">Linux umask 命令 - 设置文件权限掩码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-58"><span class="toc-number">60.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-58"><span class="toc-number">60.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-touch-%E5%91%BD%E4%BB%A4-%E5%88%9B%E5%BB%BA%E6%88%96%E6%9B%B4%E6%96%B0%E6%96%87%E4%BB%B6"><span class="toc-number">61.</span> <span class="toc-text">Linux touch 命令 - 创建或更新文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-59"><span class="toc-number">61.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-59"><span class="toc-number">61.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-cp-%E5%91%BD%E4%BB%A4-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95"><span class="toc-number">62.</span> <span class="toc-text">Linux cp 命令 - 复制文件或目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-60"><span class="toc-number">62.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-60"><span class="toc-number">62.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-rm-%E5%91%BD%E4%BB%A4-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95"><span class="toc-number">63.</span> <span class="toc-text">Linux rm 命令 - 删除文件或目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-61"><span class="toc-number">63.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-61"><span class="toc-number">63.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-mv-%E5%91%BD%E4%BB%A4-%E7%A7%BB%E5%8A%A8%E6%88%96%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6"><span class="toc-number">64.</span> <span class="toc-text">Linux mv 命令 - 移动或重命名文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-62"><span class="toc-number">64.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-62"><span class="toc-number">64.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-vim-%E5%91%BD%E4%BB%A4-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">65.</span> <span class="toc-text">Linux vim 命令 - 文本编辑器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-63"><span class="toc-number">65.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-63"><span class="toc-number">65.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-file-%E5%91%BD%E4%BB%A4-%E8%AF%86%E5%88%AB%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">66.</span> <span class="toc-text">Linux file 命令 - 识别文件类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-64"><span class="toc-number">66.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-64"><span class="toc-number">66.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-tee-%E5%91%BD%E4%BB%A4-%E8%AF%BB%E5%8F%96%E5%B9%B6%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6"><span class="toc-number">67.</span> <span class="toc-text">Linux tee 命令 - 读取并输出到文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-65"><span class="toc-number">67.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-65"><span class="toc-number">67.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-wc-%E5%91%BD%E4%BB%A4-%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-number">68.</span> <span class="toc-text">Linux wc 命令 - 统计文件内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-66"><span class="toc-number">68.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-66"><span class="toc-number">68.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-awk-%E5%91%BD%E4%BB%A4-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-number">69.</span> <span class="toc-text">Linux awk 命令 - 文本处理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-67"><span class="toc-number">69.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-67"><span class="toc-number">69.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-sed-%E5%91%BD%E4%BB%A4-%E6%B5%81%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">70.</span> <span class="toc-text">Linux sed 命令 - 流编辑器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-68"><span class="toc-number">70.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-68"><span class="toc-number">70.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-head-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8"><span class="toc-number">71.</span> <span class="toc-text">Linux head 命令 - 显示文件头部</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-69"><span class="toc-number">71.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-69"><span class="toc-number">71.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-tail-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%B0%BE%E9%83%A8"><span class="toc-number">72.</span> <span class="toc-text">Linux tail 命令 - 显示文件尾部</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-70"><span class="toc-number">72.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-70"><span class="toc-number">72.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-tar-%E5%91%BD%E4%BB%A4-%E5%8E%8B%E7%BC%A9%E6%88%96%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6"><span class="toc-number">73.</span> <span class="toc-text">Linux tar 命令 - 压缩或解压缩文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-71"><span class="toc-number">73.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-71"><span class="toc-number">73.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-xz-%E5%91%BD%E4%BB%A4-%E5%8E%8B%E7%BC%A9%E6%88%96%E8%A7%A3%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6"><span class="toc-number">74.</span> <span class="toc-text">Linux xz 命令 - 压缩或解压缩文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-72"><span class="toc-number">74.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-72"><span class="toc-number">74.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-mc-%E5%91%BD%E4%BB%A4-%E5%AD%97%E7%AC%A6%E7%95%8C%E9%9D%A2%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">75.</span> <span class="toc-text">Linux mc 命令 - 字符界面文件管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-73"><span class="toc-number">75.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-73"><span class="toc-number">75.2.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E5%88%97%E8%A1%A8%E6%98%BE%E7%A4%BA%E6%A0%BC%E5%BC%8F"><span class="toc-number">75.2.1.</span> <span class="toc-text">切换列表显示格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%A6%E4%B8%80%E4%B8%AA%E9%9D%A2%E6%9D%BF%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="toc-number">75.2.2.</span> <span class="toc-text">设置另一个面板的目录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-zip-%E5%91%BD%E4%BB%A4-%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E4%B8%BA-zip-%E6%A0%BC%E5%BC%8F"><span class="toc-number">76.</span> <span class="toc-text">Linux zip 命令 - 压缩文件为 zip 格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-74"><span class="toc-number">76.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-74"><span class="toc-number">76.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-unzip-%E5%91%BD%E4%BB%A4-%E8%A7%A3%E5%8E%8B%E7%BC%A9-zip-%E6%96%87%E4%BB%B6"><span class="toc-number">77.</span> <span class="toc-text">Linux unzip 命令 - 解压缩 zip 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-75"><span class="toc-number">77.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-75"><span class="toc-number">77.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-chattr-%E5%91%BD%E4%BB%A4-%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="toc-number">78.</span> <span class="toc-text">Linux chattr 命令 - 改变文件属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-76"><span class="toc-number">78.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-76"><span class="toc-number">78.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ln-%E5%91%BD%E4%BB%A4-%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5"><span class="toc-number">79.</span> <span class="toc-text">Linux ln 命令 - 创建文件链接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-77"><span class="toc-number">79.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-77"><span class="toc-number">79.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-locate-%E5%91%BD%E4%BB%A4-%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6"><span class="toc-number">80.</span> <span class="toc-text">Linux locate 命令 - 快速查找文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-78"><span class="toc-number">80.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-78"><span class="toc-number">80.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ls-%E5%91%BD%E4%BB%A4-%E5%88%97%E5%87%BA%E7%9B%AE%E5%BD%95%E5%86%85%E5%AE%B9"><span class="toc-number">81.</span> <span class="toc-text">Linux ls 命令 - 列出目录内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-79"><span class="toc-number">81.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-79"><span class="toc-number">81.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-lsblk-%E5%91%BD%E4%BB%A4-%E5%88%97%E5%87%BA%E5%9D%97%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF"><span class="toc-number">82.</span> <span class="toc-text">Linux lsblk 命令 - 列出块设备信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-80"><span class="toc-number">82.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-80"><span class="toc-number">82.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-blkid-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E5%9D%97%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF"><span class="toc-number">83.</span> <span class="toc-text">Linux blkid 命令 - 显示块设备信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-81"><span class="toc-number">83.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-81"><span class="toc-number">83.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-cd-%E5%91%BD%E4%BB%A4-%E5%88%87%E6%8D%A2%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95"><span class="toc-number">84.</span> <span class="toc-text">Linux cd 命令 - 切换当前目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-82"><span class="toc-number">84.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-82"><span class="toc-number">84.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-df-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">85.</span> <span class="toc-text">Linux df 命令 - 显示磁盘使用情况</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-83"><span class="toc-number">85.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-83"><span class="toc-number">85.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-dirs-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E6%A0%88"><span class="toc-number">86.</span> <span class="toc-text">Linux dirs 命令 - 显示当前目录栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-84"><span class="toc-number">86.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-84"><span class="toc-number">86.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-pushd-%E5%91%BD%E4%BB%A4-%E5%B0%86%E7%9B%AE%E5%BD%95%E5%8E%8B%E5%85%A5%E7%9B%AE%E5%BD%95%E6%A0%88"><span class="toc-number">87.</span> <span class="toc-text">Linux pushd 命令 - 将目录压入目录栈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-popd-%E5%91%BD%E4%BB%A4-%E6%81%A2%E5%A4%8D%E7%9B%AE%E5%BD%95%E6%A0%88%E9%A1%B6%E9%83%A8%E7%9B%AE%E5%BD%95"><span class="toc-number">88.</span> <span class="toc-text">Linux popd 命令 - 恢复目录栈顶部目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-du-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%A4%A7%E5%B0%8F"><span class="toc-number">89.</span> <span class="toc-text">Linux du 命令 - 显示文件和目录大小</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-85"><span class="toc-number">89.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-85"><span class="toc-number">89.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-mkdir-%E5%91%BD%E4%BB%A4-%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95"><span class="toc-number">90.</span> <span class="toc-text">Linux mkdir 命令 - 创建目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-86"><span class="toc-number">90.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-86"><span class="toc-number">90.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-pwd-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="toc-number">91.</span> <span class="toc-text">Linux pwd 命令 - 显示当前工作目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-87"><span class="toc-number">91.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-87"><span class="toc-number">91.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-mount-%E5%91%BD%E4%BB%A4-%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">92.</span> <span class="toc-text">Linux mount 命令 - 挂载文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-88"><span class="toc-number">92.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-88"><span class="toc-number">92.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-umount-%E5%91%BD%E4%BB%A4-%E5%8D%B8%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">93.</span> <span class="toc-text">Linux umount 命令 - 卸载文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-89"><span class="toc-number">93.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-89"><span class="toc-number">93.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-eject-%E5%91%BD%E4%BB%A4-%E5%BC%B9%E5%87%BA%E5%8F%AF%E7%A7%BB%E5%8A%A8%E4%BB%8B%E8%B4%A8"><span class="toc-number">94.</span> <span class="toc-text">Linux eject 命令 - 弹出可移动介质</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-90"><span class="toc-number">94.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-90"><span class="toc-number">94.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-stat-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%8A%B6%E6%80%81"><span class="toc-number">95.</span> <span class="toc-text">Linux stat 命令 - 显示文件或文件系统状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-91"><span class="toc-number">95.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-91"><span class="toc-number">95.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-tree-%E5%91%BD%E4%BB%A4-%E4%BB%A5%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E6%98%BE%E7%A4%BA%E7%9B%AE%E5%BD%95"><span class="toc-number">96.</span> <span class="toc-text">Linux tree 命令 - 以树形结构显示目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-92"><span class="toc-number">96.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-92"><span class="toc-number">96.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-fdisk-%E5%91%BD%E4%BB%A4-%E7%AE%A1%E7%90%86%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-number">97.</span> <span class="toc-text">Linux fdisk 命令 - 管理磁盘分区表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-93"><span class="toc-number">97.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-93"><span class="toc-number">97.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-sfdisk-%E5%91%BD%E4%BB%A4-%E7%AE%A1%E7%90%86%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-number">98.</span> <span class="toc-text">Linux sfdisk 命令 - 管理磁盘分区表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-94"><span class="toc-number">98.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-94"><span class="toc-number">98.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-parted-%E5%91%BD%E4%BB%A4-%E7%AE%A1%E7%90%86%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA"><span class="toc-number">99.</span> <span class="toc-text">Linux parted 命令 - 管理磁盘分区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-95"><span class="toc-number">99.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-95"><span class="toc-number">99.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-fsck-%E5%91%BD%E4%BB%A4-%E6%A3%80%E6%9F%A5%E5%92%8C%E4%BF%AE%E5%A4%8D%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">100.</span> <span class="toc-text">Linux fsck 命令 - 检查和修复文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-96"><span class="toc-number">100.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-96"><span class="toc-number">100.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-sync-%E5%91%BD%E4%BB%A4-%E5%90%8C%E6%AD%A5%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%AD%98"><span class="toc-number">101.</span> <span class="toc-text">Linux sync 命令 - 同步文件系统缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-97"><span class="toc-number">101.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-97"><span class="toc-number">101.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-rsync-%E5%91%BD%E4%BB%A4-%E8%BF%9C%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7"><span class="toc-number">102.</span> <span class="toc-text">Linux rsync 命令 - 远程数据同步工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-98"><span class="toc-number">102.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-98"><span class="toc-number">102.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-mkfs-%E5%91%BD%E4%BB%A4-%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">103.</span> <span class="toc-text">Linux mkfs 命令 - 创建文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-99"><span class="toc-number">103.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-99"><span class="toc-number">103.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-dd-%E5%91%BD%E4%BB%A4-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6%E5%92%8C%E8%BD%AC%E6%8D%A2"><span class="toc-number">104.</span> <span class="toc-text">Linux dd 命令 - 数据复制和转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-100"><span class="toc-number">104.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-100"><span class="toc-number">104.2.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%B5%8B%E8%AF%95"><span class="toc-number">104.2.1.</span> <span class="toc-text">读写测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-swapon-%E5%91%BD%E4%BB%A4-%E5%90%AF%E7%94%A8%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4"><span class="toc-number">105.</span> <span class="toc-text">Linux swapon 命令 - 启用交换空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-101"><span class="toc-number">105.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-101"><span class="toc-number">105.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-swapoff-%E5%91%BD%E4%BB%A4-%E7%A6%81%E7%94%A8%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4"><span class="toc-number">106.</span> <span class="toc-text">Linux swapoff 命令 - 禁用交换空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-102"><span class="toc-number">106.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-102"><span class="toc-number">106.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-chronyd-%E5%91%BD%E4%BB%A4-Chrony-%E6%9C%8D%E5%8A%A1%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">107.</span> <span class="toc-text">Linux chronyd 命令 - Chrony 服务守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-103"><span class="toc-number">107.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-103"><span class="toc-number">107.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-chronyc-%E5%91%BD%E4%BB%A4-Chrony-%E6%9C%8D%E5%8A%A1%E4%BA%A4%E4%BA%92%E5%B7%A5%E5%85%B7"><span class="toc-number">108.</span> <span class="toc-text">Linux chronyc 命令 - Chrony 服务交互工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-104"><span class="toc-number">108.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-104"><span class="toc-number">108.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-free-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">109.</span> <span class="toc-text">Linux free 命令 - 显示内存使用情况</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-105"><span class="toc-number">109.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-105"><span class="toc-number">109.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-pmap-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">110.</span> <span class="toc-text">Linux pmap 命令 - 显示进程内存映射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-106"><span class="toc-number">110.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-106"><span class="toc-number">110.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-vmstat-%E5%91%BD%E4%BB%A4-%E7%BB%9F%E8%AE%A1%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%83%85%E5%86%B5"><span class="toc-number">111.</span> <span class="toc-text">Linux vmstat 命令 - 统计虚拟内存情况</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-107"><span class="toc-number">111.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-107"><span class="toc-number">111.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-iostat-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA-I-O-%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">112.</span> <span class="toc-text">Linux iostat 命令 - 显示 I&#x2F;O 统计信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-108"><span class="toc-number">112.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-108"><span class="toc-number">112.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-dmidecode-%E5%91%BD%E4%BB%A4-%E8%AF%BB%E5%8F%96-DMI-%E4%BF%A1%E6%81%AF"><span class="toc-number">113.</span> <span class="toc-text">Linux dmidecode 命令 - 读取 DMI 信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-109"><span class="toc-number">113.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-109"><span class="toc-number">113.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-smartctl-%E5%91%BD%E4%BB%A4-%E7%AE%A1%E7%90%86-SMART-%E7%A3%81%E7%9B%98"><span class="toc-number">114.</span> <span class="toc-text">Linux smartctl 命令 - 管理 SMART 磁盘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-110"><span class="toc-number">114.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-110"><span class="toc-number">114.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-numactl-%E5%91%BD%E4%BB%A4-%E8%AE%BE%E7%BD%AE-NUMA-%E7%AD%96%E7%95%A5"><span class="toc-number">115.</span> <span class="toc-text">Linux numactl 命令 - 设置 NUMA 策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-111"><span class="toc-number">115.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-111"><span class="toc-number">115.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-export-%E5%91%BD%E4%BB%A4-%E5%AF%BC%E5%87%BA%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">116.</span> <span class="toc-text">Linux export 命令 - 导出环境变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-112"><span class="toc-number">116.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-112"><span class="toc-number">116.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-unset-%E5%91%BD%E4%BB%A4-%E5%8F%96%E6%B6%88%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">117.</span> <span class="toc-text">Linux unset 命令 - 取消环境变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-113"><span class="toc-number">117.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-113"><span class="toc-number">117.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-env-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">118.</span> <span class="toc-text">Linux env 命令 - 显示环境变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-114"><span class="toc-number">118.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-114"><span class="toc-number">118.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-printenv-%E5%91%BD%E4%BB%A4-%E6%89%93%E5%8D%B0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">119.</span> <span class="toc-text">Linux printenv 命令 - 打印环境变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-115"><span class="toc-number">119.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-115"><span class="toc-number">119.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-passwd-%E5%91%BD%E4%BB%A4-%E6%9B%B4%E6%94%B9%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81"><span class="toc-number">120.</span> <span class="toc-text">Linux passwd 命令 - 更改用户密码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-116"><span class="toc-number">120.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-116"><span class="toc-number">120.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-useradd-%E5%91%BD%E4%BB%A4-%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%94%A8%E6%88%B7"><span class="toc-number">121.</span> <span class="toc-text">Linux useradd 命令 - 添加新用户</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-117"><span class="toc-number">121.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-117"><span class="toc-number">121.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-userdel-%E5%91%BD%E4%BB%A4-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7"><span class="toc-number">122.</span> <span class="toc-text">Linux userdel 命令 - 删除用户</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-118"><span class="toc-number">122.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-118"><span class="toc-number">122.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-usermod-%E5%91%BD%E4%BB%A4-%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E5%B1%9E%E6%80%A7"><span class="toc-number">123.</span> <span class="toc-text">Linux usermod 命令 - 修改用户属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-119"><span class="toc-number">123.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-119"><span class="toc-number">123.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-groupadd-%E5%91%BD%E4%BB%A4-%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-number">124.</span> <span class="toc-text">Linux groupadd 命令 - 添加用户组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-120"><span class="toc-number">124.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-120"><span class="toc-number">124.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-groupdel-%E5%91%BD%E4%BB%A4-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-number">125.</span> <span class="toc-text">Linux groupdel 命令 - 删除用户组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-121"><span class="toc-number">125.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-121"><span class="toc-number">125.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-groupmod-%E5%91%BD%E4%BB%A4-%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-number">126.</span> <span class="toc-text">Linux groupmod 命令 - 修改用户组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-122"><span class="toc-number">126.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-122"><span class="toc-number">126.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-adduser-%E5%91%BD%E4%BB%A4-%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%94%A8%E6%88%B7"><span class="toc-number">127.</span> <span class="toc-text">Linux adduser 命令 - 添加新用户</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-123"><span class="toc-number">127.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-123"><span class="toc-number">127.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-deluser-%E5%91%BD%E4%BB%A4-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7"><span class="toc-number">128.</span> <span class="toc-text">Linux deluser 命令 - 删除用户</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-124"><span class="toc-number">128.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-124"><span class="toc-number">128.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-addgroup-%E5%91%BD%E4%BB%A4-%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-number">129.</span> <span class="toc-text">Linux addgroup 命令 - 添加用户组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-125"><span class="toc-number">129.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-125"><span class="toc-number">129.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-delgroup-%E5%91%BD%E4%BB%A4-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-number">130.</span> <span class="toc-text">Linux delgroup 命令 - 删除用户组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-126"><span class="toc-number">130.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-126"><span class="toc-number">130.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-uptime-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4"><span class="toc-number">131.</span> <span class="toc-text">Linux uptime 命令 - 显示系统运行时间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-127"><span class="toc-number">131.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-127"><span class="toc-number">131.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-time-%E5%91%BD%E4%BB%A4-%E7%BB%9F%E8%AE%A1%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4"><span class="toc-number">132.</span> <span class="toc-text">Linux time 命令 - 统计命令执行时间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-128"><span class="toc-number">132.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-128"><span class="toc-number">132.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-date-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA-%E8%AE%BE%E7%BD%AE%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">133.</span> <span class="toc-text">Linux date 命令 - 显示&#x2F;设置日期时间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-129"><span class="toc-number">133.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-129"><span class="toc-number">133.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-dmesg-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E5%86%85%E6%A0%B8%E6%B6%88%E6%81%AF"><span class="toc-number">134.</span> <span class="toc-text">Linux dmesg 命令 - 显示内核消息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-130"><span class="toc-number">134.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-130"><span class="toc-number">134.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-uname-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF"><span class="toc-number">135.</span> <span class="toc-text">Linux uname 命令 - 显示系统信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-131"><span class="toc-number">135.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-131"><span class="toc-number">135.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-hwclock-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA-%E8%AE%BE%E7%BD%AE%E7%A1%AC%E4%BB%B6%E6%97%B6%E9%92%9F"><span class="toc-number">136.</span> <span class="toc-text">Linux hwclock 命令 - 显示&#x2F;设置硬件时钟</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-132"><span class="toc-number">136.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-132"><span class="toc-number">136.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-screen-%E5%91%BD%E4%BB%A4-%E5%A4%9A%E7%AA%97%E5%8F%A3%E7%BB%88%E7%AB%AF"><span class="toc-number">137.</span> <span class="toc-text">Linux screen 命令 - 多窗口终端</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-133"><span class="toc-number">137.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-133"><span class="toc-number">137.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-fbset-%E5%91%BD%E4%BB%A4-%E5%B8%A7%E7%BC%93%E5%86%B2%E8%AE%BE%E7%BD%AE"><span class="toc-number">138.</span> <span class="toc-text">Linux fbset 命令 - 帧缓冲设置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-134"><span class="toc-number">138.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-134"><span class="toc-number">138.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-insmod-%E5%91%BD%E4%BB%A4-%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="toc-number">139.</span> <span class="toc-text">Linux insmod 命令 - 加载内核模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-135"><span class="toc-number">139.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-135"><span class="toc-number">139.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-lsmod-%E5%91%BD%E4%BB%A4-%E5%88%97%E5%87%BA%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97"><span class="toc-number">140.</span> <span class="toc-text">Linux lsmod 命令 - 列出加载模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-136"><span class="toc-number">140.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-136"><span class="toc-number">140.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-rmmod-%E5%91%BD%E4%BB%A4-%E7%A7%BB%E9%99%A4%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="toc-number">141.</span> <span class="toc-text">Linux rmmod 命令 - 移除内核模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-137"><span class="toc-number">141.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-137"><span class="toc-number">141.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-modinfo-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%9D%97%E4%BF%A1%E6%81%AF"><span class="toc-number">142.</span> <span class="toc-text">Linux modinfo 命令 - 显示模块信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-138"><span class="toc-number">142.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-138"><span class="toc-number">142.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-modprobe-%E5%91%BD%E4%BB%A4-%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97"><span class="toc-number">143.</span> <span class="toc-text">Linux modprobe 命令 - 自动加载模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-139"><span class="toc-number">143.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-139"><span class="toc-number">143.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-depmod-%E5%91%BD%E4%BB%A4-%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96"><span class="toc-number">144.</span> <span class="toc-text">Linux depmod 命令 - 处理模块依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-140"><span class="toc-number">144.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-140"><span class="toc-number">144.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-neofetch-%E5%91%BD%E4%BB%A4-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E5%B1%95%E7%A4%BA"><span class="toc-number">145.</span> <span class="toc-text">Linux neofetch 命令 - 系统信息展示</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-141"><span class="toc-number">145.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-141"><span class="toc-number">145.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-who-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7"><span class="toc-number">146.</span> <span class="toc-text">Linux who 命令 - 显示当前登录用户</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-142"><span class="toc-number">146.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-142"><span class="toc-number">146.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-whoami-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7"><span class="toc-number">147.</span> <span class="toc-text">Linux whoami 命令 - 显示当前用户</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-143"><span class="toc-number">147.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-143"><span class="toc-number">147.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-whois-%E5%91%BD%E4%BB%A4-%E6%9F%A5%E8%AF%A2%E5%9F%9F%E5%90%8D%E4%BF%A1%E6%81%AF"><span class="toc-number">148.</span> <span class="toc-text">Linux whois 命令 - 查询域名信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-144"><span class="toc-number">148.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-144"><span class="toc-number">148.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-watch-%E5%91%BD%E4%BB%A4-%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-number">149.</span> <span class="toc-text">Linux watch 命令 - 重复执行命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-145"><span class="toc-number">149.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-145"><span class="toc-number">149.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-su-%E5%91%BD%E4%BB%A4-%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD"><span class="toc-number">150.</span> <span class="toc-text">Linux su 命令 - 切换用户身份</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-146"><span class="toc-number">150.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-146"><span class="toc-number">150.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-sudo-%E5%91%BD%E4%BB%A4-%E4%BB%A5%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7%E6%89%A7%E8%A1%8C"><span class="toc-number">151.</span> <span class="toc-text">Linux sudo 命令 - 以超级用户执行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-147"><span class="toc-number">151.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-147"><span class="toc-number">151.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-id-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E7%94%A8%E6%88%B7-ID-%E4%BF%A1%E6%81%AF"><span class="toc-number">152.</span> <span class="toc-text">Linux id 命令 - 显示用户 ID 信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-148"><span class="toc-number">152.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-148"><span class="toc-number">152.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-type-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E5%91%BD%E4%BB%A4%E7%B1%BB%E5%9E%8B"><span class="toc-number">153.</span> <span class="toc-text">Linux type 命令 - 显示命令类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-149"><span class="toc-number">153.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-149"><span class="toc-number">153.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-history-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E5%91%BD%E4%BB%A4%E5%8E%86%E5%8F%B2"><span class="toc-number">154.</span> <span class="toc-text">Linux history 命令 - 显示命令历史</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-150"><span class="toc-number">154.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-150"><span class="toc-number">154.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-last-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E7%99%BB%E5%BD%95%E8%AE%B0%E5%BD%95"><span class="toc-number">155.</span> <span class="toc-text">Linux last 命令 - 显示登录记录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-151"><span class="toc-number">155.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-151"><span class="toc-number">155.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-lscpu-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA-CPU-%E6%9E%B6%E6%9E%84%E4%BF%A1%E6%81%AF"><span class="toc-number">156.</span> <span class="toc-text">Linux lscpu 命令 - 显示 CPU 架构信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-152"><span class="toc-number">156.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-152"><span class="toc-number">156.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-chsh-%E5%91%BD%E4%BB%A4-%E6%9B%B4%E6%94%B9%E7%99%BB%E5%BD%95-Shell"><span class="toc-number">157.</span> <span class="toc-text">Linux chsh 命令 - 更改登录 Shell</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-153"><span class="toc-number">157.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-153"><span class="toc-number">157.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-chroot-%E5%91%BD%E4%BB%A4-%E6%94%B9%E5%8F%98%E6%A0%B9%E7%9B%AE%E5%BD%95"><span class="toc-number">158.</span> <span class="toc-text">Linux chroot 命令 - 改变根目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-154"><span class="toc-number">158.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-154"><span class="toc-number">158.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-getconf-%E5%91%BD%E4%BB%A4-%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%8F%98%E9%87%8F"><span class="toc-number">159.</span> <span class="toc-text">Linux getconf 命令 - 查询系统配置变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-155"><span class="toc-number">159.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-155"><span class="toc-number">159.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-crontab-%E5%91%BD%E4%BB%A4-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%A1%A8"><span class="toc-number">160.</span> <span class="toc-text">Linux crontab 命令 - 定时任务表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-156"><span class="toc-number">160.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-156"><span class="toc-number">160.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-reboot-%E5%91%BD%E4%BB%A4-%E9%87%8D%E5%90%AF%E7%B3%BB%E7%BB%9F"><span class="toc-number">161.</span> <span class="toc-text">Linux reboot 命令 - 重启系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-157"><span class="toc-number">161.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-157"><span class="toc-number">161.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-poweroff-%E5%91%BD%E4%BB%A4-%E5%85%B3%E9%97%AD%E7%B3%BB%E7%BB%9F%E7%94%B5%E6%BA%90"><span class="toc-number">162.</span> <span class="toc-text">Linux poweroff 命令 - 关闭系统电源</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-158"><span class="toc-number">162.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-158"><span class="toc-number">162.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-shutdown-%E5%91%BD%E4%BB%A4-%E7%B3%BB%E7%BB%9F%E5%85%B3%E6%9C%BA%E5%91%BD%E4%BB%A4"><span class="toc-number">163.</span> <span class="toc-text">Linux shutdown 命令 - 系统关机命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-159"><span class="toc-number">163.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-159"><span class="toc-number">163.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-systemctl-%E5%91%BD%E4%BB%A4-%E7%B3%BB%E7%BB%9F%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">164.</span> <span class="toc-text">Linux systemctl 命令 - 系统和服务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-160"><span class="toc-number">164.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-160"><span class="toc-number">164.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-timedatectl-%E5%91%BD%E4%BB%A4-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E6%8E%A7%E5%88%B6"><span class="toc-number">165.</span> <span class="toc-text">Linux timedatectl 命令 - 时间日期控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-161"><span class="toc-number">165.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-161"><span class="toc-number">165.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-nproc-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E5%8F%AF%E7%94%A8%E5%A4%84%E7%90%86%E5%99%A8%E6%95%B0"><span class="toc-number">166.</span> <span class="toc-text">Linux nproc 命令 - 显示可用处理器数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-162"><span class="toc-number">166.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-162"><span class="toc-number">166.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-lsb-release-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA-LSB-%E4%BF%A1%E6%81%AF"><span class="toc-number">167.</span> <span class="toc-text">Linux lsb_release 命令 - 显示 LSB 信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-163"><span class="toc-number">167.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-163"><span class="toc-number">167.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-sysctl-%E5%91%BD%E4%BB%A4-%E8%AF%BB%E5%8F%96-%E8%AE%BE%E7%BD%AE%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0"><span class="toc-number">168.</span> <span class="toc-text">Linux sysctl 命令 - 读取&#x2F;设置内核参数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-164"><span class="toc-number">168.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-164"><span class="toc-number">168.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-locale-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE"><span class="toc-number">169.</span> <span class="toc-text">Linux locale 命令 - 显示区域设置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-165"><span class="toc-number">169.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-165"><span class="toc-number">169.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-setcap-%E5%91%BD%E4%BB%A4-%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90"><span class="toc-number">170.</span> <span class="toc-text">Linux setcap 命令 - 设置文件特殊权限</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-166"><span class="toc-number">170.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E9%99%90"><span class="toc-number">170.2.</span> <span class="toc-text">权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-166"><span class="toc-number">170.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-getcap-%E5%91%BD%E4%BB%A4-%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90"><span class="toc-number">171.</span> <span class="toc-text">Linux getcap 命令 - 查看文件的特殊权限</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-167"><span class="toc-number">171.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-167"><span class="toc-number">171.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-arp-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E5%92%8C%E4%BF%AE%E6%94%B9-ARP-%E7%BC%93%E5%AD%98"><span class="toc-number">172.</span> <span class="toc-text">Linux arp 命令 - 显示和修改 ARP 缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-168"><span class="toc-number">172.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-168"><span class="toc-number">172.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ifconfig-%E5%91%BD%E4%BB%A4-%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4"><span class="toc-number">173.</span> <span class="toc-text">Linux ifconfig 命令 - 网络接口配置命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-169"><span class="toc-number">173.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-169"><span class="toc-number">173.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ip-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E6%88%96%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87"><span class="toc-number">174.</span> <span class="toc-text">Linux ip 命令 - 显示或设置网络设备</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-170"><span class="toc-number">174.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-170"><span class="toc-number">174.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-route-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E6%88%96%E6%93%8D%E4%BD%9C-IP-%E8%B7%AF%E7%94%B1%E8%A1%A8"><span class="toc-number">175.</span> <span class="toc-text">Linux route 命令 - 显示或操作 IP 路由表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-171"><span class="toc-number">175.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-171"><span class="toc-number">175.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ethtool-%E5%91%BD%E4%BB%A4-%E6%9F%A5%E8%AF%A2%E8%AE%BE%E7%BD%AE%E7%BD%91%E5%8D%A1%E5%8F%82%E6%95%B0"><span class="toc-number">176.</span> <span class="toc-text">Linux ethtool 命令 - 查询设置网卡参数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-172"><span class="toc-number">176.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-172"><span class="toc-number">176.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-netstat-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E7%BD%91%E7%BB%9C%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">177.</span> <span class="toc-text">Linux netstat 命令 - 显示网络统计信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-173"><span class="toc-number">177.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-173"><span class="toc-number">177.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-nslookup-%E5%91%BD%E4%BB%A4-%E6%9F%A5%E8%AF%A2-DNS-%E5%9F%9F%E5%90%8D%E5%92%8C-IP"><span class="toc-number">178.</span> <span class="toc-text">Linux nslookup 命令 - 查询 DNS 域名和 IP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-174"><span class="toc-number">178.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-174"><span class="toc-number">178.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-telnet-%E5%91%BD%E4%BB%A4-%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%8D%8F%E8%AE%AE%E5%91%BD%E4%BB%A4"><span class="toc-number">179.</span> <span class="toc-text">Linux telnet 命令 - 远程登录协议命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-175"><span class="toc-number">179.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-175"><span class="toc-number">179.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ssh-%E5%91%BD%E4%BB%A4-%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE"><span class="toc-number">180.</span> <span class="toc-text">Linux ssh 命令 - 远程登录安全协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-176"><span class="toc-number">180.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-176"><span class="toc-number">180.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E"><span class="toc-number">180.3.</span> <span class="toc-text">配置说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-177"><span class="toc-number">180.4.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ftp-%E5%91%BD%E4%BB%A4-%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">181.</span> <span class="toc-text">Linux ftp 命令 - 文件传输协议客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-177"><span class="toc-number">181.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-178"><span class="toc-number">181.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-curl-%E5%91%BD%E4%BB%A4-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%BC%A0%E8%BE%93%E5%B7%A5%E5%85%B7"><span class="toc-number">182.</span> <span class="toc-text">Linux curl 命令 - 网络请求传输工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-178"><span class="toc-number">182.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-179"><span class="toc-number">182.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-wget-%E5%91%BD%E4%BB%A4-%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7"><span class="toc-number">183.</span> <span class="toc-text">Linux wget 命令 - 网络文件下载工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-179"><span class="toc-number">183.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-180"><span class="toc-number">183.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ping-%E5%91%BD%E4%BB%A4-%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81"><span class="toc-number">184.</span> <span class="toc-text">Linux ping 命令 - 测试网络连接状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-180"><span class="toc-number">184.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-181"><span class="toc-number">184.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-dig-%E5%91%BD%E4%BB%A4-%E5%9F%9F%E5%90%8D%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7"><span class="toc-number">185.</span> <span class="toc-text">Linux dig 命令 - 域名查询工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-181"><span class="toc-number">185.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-182"><span class="toc-number">185.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-iperf-%E5%91%BD%E4%BB%A4-%E7%BD%91%E7%BB%9C%E5%B8%A6%E5%AE%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">186.</span> <span class="toc-text">Linux iperf 命令 - 网络带宽测试工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-182"><span class="toc-number">186.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-183"><span class="toc-number">186.2.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-%E6%A8%A1%E5%BC%8F"><span class="toc-number">186.2.1.</span> <span class="toc-text">UDP 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E6%A8%A1%E5%BC%8F"><span class="toc-number">186.2.2.</span> <span class="toc-text">TCP 模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-speedtest-%E5%91%BD%E4%BB%A4-%E7%BD%91%E7%BB%9C%E9%80%9F%E5%BA%A6%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">187.</span> <span class="toc-text">Linux speedtest 命令 - 网络速度测试工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-183"><span class="toc-number">187.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-184"><span class="toc-number">187.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-traceroute-%E5%91%BD%E4%BB%A4-%E8%B7%AF%E7%94%B1%E8%BF%BD%E8%B8%AA%E6%98%BE%E7%A4%BA%E8%B7%AF%E5%BE%84"><span class="toc-number">188.</span> <span class="toc-text">Linux traceroute 命令 - 路由追踪显示路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-184"><span class="toc-number">188.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-185"><span class="toc-number">188.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-trippy-%E5%91%BD%E4%BB%A4-%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">189.</span> <span class="toc-text">Linux trippy 命令 - 网络调试分析工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-185"><span class="toc-number">189.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-186"><span class="toc-number">189.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-mtr-%E5%91%BD%E4%BB%A4-%E7%BD%91%E7%BB%9C%E8%AF%8A%E6%96%AD%E8%B7%AF%E7%94%B1%E8%B7%9F%E8%B8%AA"><span class="toc-number">190.</span> <span class="toc-text">Linux mtr 命令 - 网络诊断路由跟踪</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-186"><span class="toc-number">190.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-187"><span class="toc-number">190.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-nload-%E5%91%BD%E4%BB%A4-%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F"><span class="toc-number">191.</span> <span class="toc-text">Linux nload 命令 - 实时监控网络流量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-187"><span class="toc-number">191.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-188"><span class="toc-number">191.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ifstat-%E5%91%BD%E4%BB%A4-%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7"><span class="toc-number">192.</span> <span class="toc-text">Linux ifstat 命令 - 网络接口流量监控</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-188"><span class="toc-number">192.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-189"><span class="toc-number">192.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-iftop-%E5%91%BD%E4%BB%A4-%E5%AE%9E%E6%97%B6%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7"><span class="toc-number">193.</span> <span class="toc-text">Linux iftop 命令 - 实时流量监控工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-189"><span class="toc-number">193.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-190"><span class="toc-number">193.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ntop-%E5%91%BD%E4%BB%A4-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">194.</span> <span class="toc-text">Linux ntop 命令 - 网络流量分析工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-190"><span class="toc-number">194.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-191"><span class="toc-number">194.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ntopng-%E5%91%BD%E4%BB%A4-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7%E5%88%86%E6%9E%90"><span class="toc-number">195.</span> <span class="toc-text">Linux ntopng 命令 - 网络流量监控分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-191"><span class="toc-number">195.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-192"><span class="toc-number">195.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-nmap-%E5%91%BD%E4%BB%A4-%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E6%8E%A2%E6%B5%8B%E5%B7%A5%E5%85%B7"><span class="toc-number">196.</span> <span class="toc-text">Linux nmap 命令 - 网络扫描探测工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-192"><span class="toc-number">196.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-193"><span class="toc-number">196.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-netcat-%E5%91%BD%E4%BB%A4-%E5%A4%9A%E5%8A%9F%E8%83%BD%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7"><span class="toc-number">197.</span> <span class="toc-text">Linux netcat 命令 - 多功能网络工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-193"><span class="toc-number">197.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-194"><span class="toc-number">197.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-nc-%E5%91%BD%E4%BB%A4-netcat-%E7%9A%84%E5%88%AB%E5%90%8D"><span class="toc-number">198.</span> <span class="toc-text">Linux nc 命令 - netcat 的别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-nethogs-%E5%91%BD%E4%BB%A4-%E6%8C%89%E8%BF%9B%E7%A8%8B%E7%9B%91%E6%8E%A7%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F"><span class="toc-number">199.</span> <span class="toc-text">Linux nethogs 命令 - 按进程监控网络流量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-194"><span class="toc-number">199.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-195"><span class="toc-number">199.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-tcptrack-%E5%91%BD%E4%BB%A4-TCP%E8%BF%9E%E6%8E%A5%E8%B7%9F%E8%B8%AA%E5%B7%A5%E5%85%B7"><span class="toc-number">200.</span> <span class="toc-text">Linux tcptrack 命令 - TCP连接跟踪工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-195"><span class="toc-number">200.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-196"><span class="toc-number">200.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-tcpdump-%E5%91%BD%E4%BB%A4-%E6%95%B0%E6%8D%AE%E5%8C%85%E6%8D%95%E8%8E%B7%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">201.</span> <span class="toc-text">Linux tcpdump 命令 - 数据包捕获分析工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-196"><span class="toc-number">201.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-197"><span class="toc-number">201.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-tcpreplay-%E5%91%BD%E4%BB%A4-%E9%87%8D%E6%94%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%B7%A5%E5%85%B7"><span class="toc-number">202.</span> <span class="toc-text">Linux tcpreplay 命令 - 重放网络数据包工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-197"><span class="toc-number">202.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-198"><span class="toc-number">202.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E9%93%BE%E6%8E%A5"><span class="toc-number">202.3.</span> <span class="toc-text">资源链接</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ethr-%E5%91%BD%E4%BB%A4-%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">203.</span> <span class="toc-text">Linux ethr 命令 - 网络性能测试工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-198"><span class="toc-number">203.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-199"><span class="toc-number">203.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-iptables-%E5%91%BD%E4%BB%A4-%E9%85%8D%E7%BD%AE-Linux-%E9%98%B2%E7%81%AB%E5%A2%99"><span class="toc-number">204.</span> <span class="toc-text">Linux iptables 命令 - 配置 Linux 防火墙</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-199"><span class="toc-number">204.1.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="toc-number">204.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">204.1.2.</span> <span class="toc-text">工作机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-number">204.1.3.</span> <span class="toc-text">防火墙的策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-200"><span class="toc-number">204.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ufw-%E5%91%BD%E4%BB%A4-%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-number">205.</span> <span class="toc-text">Linux ufw 命令 - 防火墙配置管理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-200"><span class="toc-number">205.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-201"><span class="toc-number">205.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-nfsstat-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA-NFS-%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">206.</span> <span class="toc-text">Linux nfsstat 命令 - 显示 NFS 统计信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-201"><span class="toc-number">206.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-202"><span class="toc-number">206.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-pppd-%E5%91%BD%E4%BB%A4-%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">207.</span> <span class="toc-text">Linux pppd 命令 - 点对点协议守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-202"><span class="toc-number">207.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-203"><span class="toc-number">207.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-nm-connection-editor-%E5%91%BD%E4%BB%A4-%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE"><span class="toc-number">208.</span> <span class="toc-text">Linux nm-connection-editor 命令 - 图形界面网络设置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-203"><span class="toc-number">208.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-204"><span class="toc-number">208.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-nmcli-%E5%91%BD%E4%BB%A4-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7"><span class="toc-number">209.</span> <span class="toc-text">Linux nmcli 命令 - 网络管理配置工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-204"><span class="toc-number">209.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-205"><span class="toc-number">209.2.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">209.2.1.</span> <span class="toc-text">查看连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E8%AE%BE%E5%A4%87"><span class="toc-number">209.2.2.</span> <span class="toc-text">查看和操作设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E3%80%81%E9%85%8D%E7%BD%AE%E5%92%8C%E5%88%A0%E9%99%A4%E8%BF%9E%E6%8E%A5"><span class="toc-number">209.2.3.</span> <span class="toc-text">创建、配置和删除连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Wi-Fi-%E6%93%8D%E4%BD%9C"><span class="toc-number">209.2.4.</span> <span class="toc-text">Wi-Fi 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%B8%AE%E5%8A%A9"><span class="toc-number">209.2.5.</span> <span class="toc-text">查看帮助</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-nmtui-%E5%91%BD%E4%BB%A4-%E6%96%87%E6%9C%AC%E7%95%8C%E9%9D%A2%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE"><span class="toc-number">210.</span> <span class="toc-text">Linux nmtui 命令 - 文本界面网络设置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-205"><span class="toc-number">210.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-206"><span class="toc-number">210.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-socat-%E5%91%BD%E4%BB%A4-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%B7%A5%E5%85%B7"><span class="toc-number">211.</span> <span class="toc-text">Linux socat 命令 - 双向数据传输工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-206"><span class="toc-number">211.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-207"><span class="toc-number">211.2.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">211.2.1.</span> <span class="toc-text">文件操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E4%B8%B2%E5%8F%A3"><span class="toc-number">211.2.2.</span> <span class="toc-text">虚拟串口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E9%80%9A%E4%BF%A1"><span class="toc-number">211.2.3.</span> <span class="toc-text">TCP 通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-1"><span class="toc-number">211.2.4.</span> <span class="toc-text">网络管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91"><span class="toc-number">211.2.5.</span> <span class="toc-text">端口转发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91-TCP"><span class="toc-number">211.2.5.1.</span> <span class="toc-text">转发 TCP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91-UDP"><span class="toc-number">211.2.5.2.</span> <span class="toc-text">转发 UDP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NAT-%E6%98%A0%E5%B0%84"><span class="toc-number">211.2.5.3.</span> <span class="toc-text">NAT 映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%92"><span class="toc-number">211.2.6.</span> <span class="toc-text">文件传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81"><span class="toc-number">211.2.6.1.</span> <span class="toc-text">文件传送</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E6%B5%81%E5%8A%9F%E8%83%BD"><span class="toc-number">211.2.6.2.</span> <span class="toc-text">读写分流功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">211.2.7.</span> <span class="toc-text">本地域套接字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%8A%9F%E8%83%BD"><span class="toc-number">211.2.8.</span> <span class="toc-text">其它功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-wvdial-%E5%91%BD%E4%BB%A4-PPP-%E6%8B%A8%E5%8F%B7%E5%B7%A5%E5%85%B7"><span class="toc-number">212.</span> <span class="toc-text">Linux wvdial 命令 - PPP 拨号工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-207"><span class="toc-number">212.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-208"><span class="toc-number">212.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-wvdialconf-%E5%91%BD%E4%BB%A4-%E9%85%8D%E7%BD%AE%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83%E5%99%A8"><span class="toc-number">213.</span> <span class="toc-text">Linux wvdialconf 命令 - 配置调制解调器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-208"><span class="toc-number">213.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-209"><span class="toc-number">213.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-networkctl-%E5%91%BD%E4%BB%A4-%E6%9F%A5%E8%AF%A2%E6%8E%A7%E5%88%B6%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81"><span class="toc-number">214.</span> <span class="toc-text">Linux networkctl 命令 - 查询控制网络状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-209"><span class="toc-number">214.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-210"><span class="toc-number">214.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ss-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">215.</span> <span class="toc-text">Linux ss 命令 - 显示套接字统计信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-210"><span class="toc-number">215.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-211"><span class="toc-number">215.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-lsusb-%E5%91%BD%E4%BB%A4-%E5%88%97%E5%87%BA-USB-%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF"><span class="toc-number">216.</span> <span class="toc-text">Linux lsusb 命令 - 列出 USB 设备信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-211"><span class="toc-number">216.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-212"><span class="toc-number">216.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-lspci-%E5%91%BD%E4%BB%A4-%E5%88%97%E5%87%BA-PCI-%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF"><span class="toc-number">217.</span> <span class="toc-text">Linux lspci 命令 - 列出 PCI 设备信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-212"><span class="toc-number">217.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-213"><span class="toc-number">217.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-lshw-%E5%91%BD%E4%BB%A4-%E5%88%97%E5%87%BA%E7%A1%AC%E4%BB%B6%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="toc-number">218.</span> <span class="toc-text">Linux lshw 命令 - 列出硬件配置详细信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-213"><span class="toc-number">218.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-214"><span class="toc-number">218.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-spi-config-%E5%91%BD%E4%BB%A4-%E9%85%8D%E7%BD%AE-SPI-%E6%8E%A5%E5%8F%A3"><span class="toc-number">219.</span> <span class="toc-text">Linux spi-config 命令 - 配置 SPI 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-214"><span class="toc-number">219.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-215"><span class="toc-number">219.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-spi-pipe-%E5%91%BD%E4%BB%A4-SPI-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%B7%A5%E5%85%B7"><span class="toc-number">220.</span> <span class="toc-text">Linux spi-pipe 命令 - SPI 数据传输工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-215"><span class="toc-number">220.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-216"><span class="toc-number">220.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-i2cdetect-%E5%91%BD%E4%BB%A4-%E6%89%AB%E6%8F%8F-I2C-%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80"><span class="toc-number">221.</span> <span class="toc-text">Linux i2cdetect 命令 - 扫描 I2C 设备地址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-216"><span class="toc-number">221.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-217"><span class="toc-number">221.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-i2cdump-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA-I2C-%E8%AE%BE%E5%A4%87%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AE%B9"><span class="toc-number">222.</span> <span class="toc-text">Linux i2cdump 命令 - 显示 I2C 设备的寄存器内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-217"><span class="toc-number">222.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-218"><span class="toc-number">222.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-i2cget-%E5%91%BD%E4%BB%A4-%E4%BB%8E-I2C-%E8%AE%BE%E5%A4%87%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">223.</span> <span class="toc-text">Linux i2cget 命令 - 从 I2C 设备读取数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-218"><span class="toc-number">223.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-219"><span class="toc-number">223.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-i2cset-%E5%91%BD%E4%BB%A4-%E5%90%91-I2C-%E8%AE%BE%E5%A4%87%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">224.</span> <span class="toc-text">Linux i2cset 命令 - 向 I2C 设备写入数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-219"><span class="toc-number">224.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-220"><span class="toc-number">224.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-i2ctransfer-%E5%91%BD%E4%BB%A4-%E6%89%A7%E8%A1%8C-I2C-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%93%8D%E4%BD%9C"><span class="toc-number">225.</span> <span class="toc-text">Linux i2ctransfer 命令 - 执行 I2C 数据传输操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-220"><span class="toc-number">225.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-221"><span class="toc-number">225.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-stty-%E5%91%BD%E4%BB%A4-%E9%85%8D%E7%BD%AE%E7%BB%88%E7%AB%AF%E8%A1%8C%E5%B1%9E%E6%80%A7"><span class="toc-number">226.</span> <span class="toc-text">Linux stty 命令 - 配置终端行属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-221"><span class="toc-number">226.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-222"><span class="toc-number">226.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-minicom-%E5%91%BD%E4%BB%A4-%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">227.</span> <span class="toc-text">Linux minicom 命令 - 串口调试工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-222"><span class="toc-number">227.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-223"><span class="toc-number">227.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-microcom-%E5%91%BD%E4%BB%A4-%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%B7%A5%E5%85%B7"><span class="toc-number">228.</span> <span class="toc-text">Linux microcom 命令 - 串口通信工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-223"><span class="toc-number">228.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-224"><span class="toc-number">228.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-xrandr-%E5%91%BD%E4%BB%A4-%E7%AE%A1%E7%90%86%E6%98%BE%E7%A4%BA%E8%BE%93%E5%87%BA%E8%AE%BE%E7%BD%AE"><span class="toc-number">229.</span> <span class="toc-text">Linux xrandr 命令 - 管理显示输出设置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-224"><span class="toc-number">229.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-225"><span class="toc-number">229.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-mmc-%E5%91%BD%E4%BB%A4-%E7%AE%A1%E7%90%86-MMC-SD-%E5%8D%A1"><span class="toc-number">230.</span> <span class="toc-text">Linux mmc 命令 - 管理 MMC&#x2F;SD 卡</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-225"><span class="toc-number">230.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-226"><span class="toc-number">230.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-gpiodetect-%E5%91%BD%E4%BB%A4-%E6%A3%80%E6%B5%8B-GPIO-%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">231.</span> <span class="toc-text">Linux gpiodetect 命令 - 检测 GPIO 控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-226"><span class="toc-number">231.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-227"><span class="toc-number">231.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-gpiofind-%E5%91%BD%E4%BB%A4-%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E5%90%8D%E7%A7%B0%E7%9A%84-GPIO-%E5%BC%95%E8%84%9A"><span class="toc-number">232.</span> <span class="toc-text">Linux gpiofind 命令 - 查找指定名称的 GPIO 引脚</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-227"><span class="toc-number">232.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-228"><span class="toc-number">232.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-gpioget-%E5%91%BD%E4%BB%A4-%E8%8E%B7%E5%8F%96-GPIO-%E5%BC%95%E8%84%9A%E7%9A%84%E5%BD%93%E5%89%8D%E5%80%BC"><span class="toc-number">233.</span> <span class="toc-text">Linux gpioget 命令 - 获取 GPIO 引脚的当前值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-228"><span class="toc-number">233.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-229"><span class="toc-number">233.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-gpioinfo-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA-GPIO-%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E5%BC%95%E8%84%9A%E4%BF%A1%E6%81%AF"><span class="toc-number">234.</span> <span class="toc-text">Linux gpioinfo 命令 - 显示 GPIO 控制器和引脚信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-229"><span class="toc-number">234.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-230"><span class="toc-number">234.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-gpiomon-%E5%91%BD%E4%BB%A4-%E7%9B%91%E6%8E%A7-GPIO-%E5%BC%95%E8%84%9A%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96"><span class="toc-number">235.</span> <span class="toc-text">Linux gpiomon 命令 - 监控 GPIO 引脚的状态变化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-230"><span class="toc-number">235.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-231"><span class="toc-number">235.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-gpioset-%E5%91%BD%E4%BB%A4-%E8%AE%BE%E7%BD%AE-GPIO-%E5%BC%95%E8%84%9A%E7%9A%84%E5%80%BC"><span class="toc-number">236.</span> <span class="toc-text">Linux gpioset 命令 - 设置 GPIO 引脚的值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-231"><span class="toc-number">236.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-232"><span class="toc-number">236.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-udevadm-%E5%91%BD%E4%BB%A4-%E7%AE%A1%E7%90%86%E8%AE%BE%E5%A4%87%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="toc-number">237.</span> <span class="toc-text">Linux udevadm 命令 - 管理设备事件和属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-232"><span class="toc-number">237.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-233"><span class="toc-number">237.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-modpoll-%E5%91%BD%E4%BB%A4-Modbus-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">238.</span> <span class="toc-text">Linux modpoll 命令 - Modbus 测试工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-233"><span class="toc-number">238.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-234"><span class="toc-number">238.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-usb-modeswitch-%E5%91%BD%E4%BB%A4-%E5%88%87%E6%8D%A2-USB-%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%BC%8F"><span class="toc-number">239.</span> <span class="toc-text">Linux usb_modeswitch 命令 - 切换 USB 设备模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-234"><span class="toc-number">239.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-235"><span class="toc-number">239.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ppsctl-%E5%91%BD%E4%BB%A4-%E7%AE%A1%E7%90%86-PPS-%E4%BF%A1%E5%8F%B7"><span class="toc-number">240.</span> <span class="toc-text">Linux ppsctl 命令 - 管理 PPS 信号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-235"><span class="toc-number">240.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-236"><span class="toc-number">240.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-hexdump-%E5%91%BD%E4%BB%A4-%E6%9F%A5%E7%9C%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">241.</span> <span class="toc-text">Linux hexdump 命令 - 查看二进制文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-236"><span class="toc-number">241.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-237"><span class="toc-number">241.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-memtester-%E5%91%BD%E4%BB%A4-%E6%B5%8B%E8%AF%95%E5%86%85%E5%AD%98%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%92%8C%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">242.</span> <span class="toc-text">Linux memtester 命令 - 测试内存稳定性和完整性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-237"><span class="toc-number">242.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-238"><span class="toc-number">242.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-seq-%E5%91%BD%E4%BB%A4-%E7%94%9F%E6%88%90%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97"><span class="toc-number">243.</span> <span class="toc-text">Linux seq 命令 - 生成数字序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-238"><span class="toc-number">243.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-239"><span class="toc-number">243.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-cyclictest-%E5%91%BD%E4%BB%A4-%E6%B5%8B%E8%AF%95-CPU-%E8%B4%9F%E8%BD%BD%E5%92%8C%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4"><span class="toc-number">244.</span> <span class="toc-text">Linux cyclictest 命令 - 测试 CPU 负载和响应时间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-239"><span class="toc-number">244.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-240"><span class="toc-number">244.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-number">244.3.</span> <span class="toc-text">输出格式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-strace-%E5%91%BD%E4%BB%A4-%E8%B7%9F%E8%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E4%BF%A1%E5%8F%B7"><span class="toc-number">245.</span> <span class="toc-text">Linux strace 命令 - 跟踪系统调用和信号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-240"><span class="toc-number">245.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-241"><span class="toc-number">245.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ltrace-%E5%91%BD%E4%BB%A4-%E8%B7%9F%E8%B8%AA%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BA%93%E8%B0%83%E7%94%A8"><span class="toc-number">246.</span> <span class="toc-text">Linux ltrace 命令 - 跟踪程序的库调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-241"><span class="toc-number">246.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-242"><span class="toc-number">246.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-timeout-%E5%91%BD%E4%BB%A4-%E9%99%90%E5%88%B6%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4"><span class="toc-number">247.</span> <span class="toc-text">Linux timeout 命令 - 限制命令执行时间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-242"><span class="toc-number">247.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-243"><span class="toc-number">247.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-declare-%E5%91%BD%E4%BB%A4-%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="toc-number">248.</span> <span class="toc-text">Linux declare 命令 - 声明变量和属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-243"><span class="toc-number">248.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-244"><span class="toc-number">248.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ps-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">249.</span> <span class="toc-text">Linux ps 命令 - 显示当前运行的进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-244"><span class="toc-number">249.1.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95"><span class="toc-number">249.1.1.</span> <span class="toc-text">命令语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E5%8F%82%E6%95%B0"><span class="toc-number">249.1.2.</span> <span class="toc-text">选项参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-245"><span class="toc-number">249.2.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%EF%BC%88System-V-%E9%A3%8E%E6%A0%BC%EF%BC%89"><span class="toc-number">249.2.1.</span> <span class="toc-text">查看进程（System V 风格）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%EF%BC%88BSD-%E9%A3%8E%E6%A0%BC%EF%BC%89"><span class="toc-number">249.2.2.</span> <span class="toc-text">查看进程（BSD 风格）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9A%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-number">249.2.3.</span> <span class="toc-text">显示指定用户信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B"><span class="toc-number">249.2.4.</span> <span class="toc-text">列出一个进程创建的所有线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E8%BF%9B%E7%A8%8B%E5%90%8D%E6%9F%A5%E6%89%BE%E8%BF%9B%E7%A8%8B%E5%8F%B7"><span class="toc-number">249.2.5.</span> <span class="toc-text">根据进程名查找进程号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E8%BF%9B%E7%A8%8B%E5%8F%B7%E6%9F%A5%E6%89%BE%E8%BF%9B%E7%A8%8B%E5%90%8D"><span class="toc-number">249.2.6.</span> <span class="toc-text">根据进程号查找进程名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-top-%E5%91%BD%E4%BB%A4-%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BA%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%B3%BB%E7%BB%9F%E7%8A%B6%E6%80%81"><span class="toc-number">250.</span> <span class="toc-text">Linux top 命令 - 实时显示进程和系统状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-245"><span class="toc-number">250.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-246"><span class="toc-number">250.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-htop-%E5%91%BD%E4%BB%A4-%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%BF%9B%E7%A8%8B%E6%9F%A5%E7%9C%8B%E5%99%A8"><span class="toc-number">251.</span> <span class="toc-text">Linux htop 命令 - 交互式进程查看器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-246"><span class="toc-number">251.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-247"><span class="toc-number">251.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-kill-%E5%91%BD%E4%BB%A4-%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="toc-number">252.</span> <span class="toc-text">Linux kill 命令 - 终止进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-247"><span class="toc-number">252.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-248"><span class="toc-number">252.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-pkill-%E5%91%BD%E4%BB%A4-%E6%A0%B9%E6%8D%AE%E5%90%8D%E7%A7%B0%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="toc-number">253.</span> <span class="toc-text">Linux pkill 命令 - 根据名称终止进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-248"><span class="toc-number">253.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-249"><span class="toc-number">253.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-killall-%E5%91%BD%E4%BB%A4-%E7%BB%88%E6%AD%A2%E6%8C%87%E5%AE%9A%E5%90%8D%E7%A7%B0%E7%9A%84%E6%89%80%E6%9C%89%E8%BF%9B%E7%A8%8B"><span class="toc-number">254.</span> <span class="toc-text">Linux killall 命令 - 终止指定名称的所有进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-249"><span class="toc-number">254.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-250"><span class="toc-number">254.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-ipcs-%E5%91%BD%E4%BB%A4-%E6%98%BE%E7%A4%BA%E7%B3%BB%E7%BB%9F-IPC-%E8%B5%84%E6%BA%90%E4%BF%A1%E6%81%AF"><span class="toc-number">255.</span> <span class="toc-text">Linux ipcs 命令 - 显示系统 IPC 资源信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-250"><span class="toc-number">255.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-251"><span class="toc-number">255.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-jobs-%E5%91%BD%E4%BB%A4-%E5%88%97%E5%87%BA%E5%BD%93%E5%89%8D%E4%BD%9C%E4%B8%9A"><span class="toc-number">256.</span> <span class="toc-text">Linux jobs 命令 - 列出当前作业</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-251"><span class="toc-number">256.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-252"><span class="toc-number">256.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-bg-%E5%91%BD%E4%BB%A4-%E5%B0%86%E4%BD%9C%E4%B8%9A%E7%BD%AE%E4%BA%8E%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="toc-number">257.</span> <span class="toc-text">Linux bg 命令 - 将作业置于后台运行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-252"><span class="toc-number">257.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-253"><span class="toc-number">257.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-fg-%E5%91%BD%E4%BB%A4-%E5%B0%86%E4%BD%9C%E4%B8%9A%E7%BD%AE%E4%BA%8E%E5%89%8D%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="toc-number">258.</span> <span class="toc-text">Linux fg 命令 - 将作业置于前台运行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-253"><span class="toc-number">258.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-254"><span class="toc-number">258.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-nohup-%E5%91%BD%E4%BB%A4-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">259.</span> <span class="toc-text">Linux nohup 命令 - 后台运行程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-254"><span class="toc-number">259.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-255"><span class="toc-number">259.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-lsof-%E5%91%BD%E4%BB%A4-%E5%88%97%E5%87%BA%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">260.</span> <span class="toc-text">Linux lsof 命令 - 列出打开的文件和进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-255"><span class="toc-number">260.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-256"><span class="toc-number">260.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-nice-%E5%91%BD%E4%BB%A4-%E8%AE%BE%E7%BD%AE%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">261.</span> <span class="toc-text">Linux nice 命令 - 设置进程优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-256"><span class="toc-number">261.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-257"><span class="toc-number">261.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-renice-%E5%91%BD%E4%BB%A4-%E6%94%B9%E5%8F%98%E8%BF%90%E8%A1%8C%E4%B8%AD%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">262.</span> <span class="toc-text">Linux renice 命令 - 改变运行中进程的优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-257"><span class="toc-number">262.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-258"><span class="toc-number">262.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-chrt-%E5%91%BD%E4%BB%A4-%E6%9F%A5%E7%9C%8B%E6%88%96%E8%AE%BE%E7%BD%AE%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-number">263.</span> <span class="toc-text">Linux chrt 命令 - 查看或设置进程的调度策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-258"><span class="toc-number">263.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-259"><span class="toc-number">263.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-taskset-%E5%91%BD%E4%BB%A4-%E8%AE%BE%E7%BD%AE%E8%BF%9B%E7%A8%8B%E7%9A%84-CPU-%E4%BA%B2%E5%92%8C%E6%80%A7"><span class="toc-number">264.</span> <span class="toc-text">Linux taskset 命令 - 设置进程的 CPU 亲和性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-259"><span class="toc-number">264.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-260"><span class="toc-number">264.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-pidof-%E5%91%BD%E4%BB%A4-%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E7%9A%84-PID"><span class="toc-number">265.</span> <span class="toc-text">Linux pidof 命令 - 获取进程的 PID</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-260"><span class="toc-number">265.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-261"><span class="toc-number">265.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-pgrep-%E5%91%BD%E4%BB%A4-%E6%A0%B9%E6%8D%AE%E5%90%8D%E7%A7%B0%E6%9F%A5%E6%89%BE%E8%BF%9B%E7%A8%8B-ID"><span class="toc-number">266.</span> <span class="toc-text">Linux pgrep 命令 - 根据名称查找进程 ID</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-261"><span class="toc-number">266.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-262"><span class="toc-number">266.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-xargs-%E5%91%BD%E4%BB%A4-%E6%9E%84%E5%BB%BA%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">267.</span> <span class="toc-text">Linux xargs 命令 - 构建并执行命令行参数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-262"><span class="toc-number">267.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-263"><span class="toc-number">267.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-aplay-%E5%91%BD%E4%BB%A4-%E6%92%AD%E6%94%BE%E9%9F%B3%E9%A2%91%E6%96%87%E4%BB%B6"><span class="toc-number">268.</span> <span class="toc-text">Linux aplay 命令 - 播放音频文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-263"><span class="toc-number">268.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-264"><span class="toc-number">268.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-arecord-%E5%91%BD%E4%BB%A4-%E5%BD%95%E5%88%B6%E9%9F%B3%E9%A2%91%E6%96%87%E4%BB%B6"><span class="toc-number">269.</span> <span class="toc-text">Linux arecord 命令 - 录制音频文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-264"><span class="toc-number">269.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-265"><span class="toc-number">269.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-amixer-%E5%91%BD%E4%BB%A4-ALSA-%E9%9F%B3%E9%A2%91%E6%8E%A7%E5%88%B6"><span class="toc-number">270.</span> <span class="toc-text">Linux amixer 命令 - ALSA 音频控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-265"><span class="toc-number">270.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-266"><span class="toc-number">270.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-alsamixer-%E5%91%BD%E4%BB%A4-ALSA-%E6%B7%B7%E9%9F%B3%E5%99%A8%E6%8E%A7%E5%88%B6"><span class="toc-number">271.</span> <span class="toc-text">Linux alsamixer 命令 - ALSA 混音器控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-266"><span class="toc-number">271.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-267"><span class="toc-number">271.2.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/12/Hexo%E6%96%B0%E5%A2%9E%E5%88%86%E7%B1%BB%E6%A0%87%E7%AD%BE%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E8%AF%A6%E8%A7%A3/" title="Hexo 新增分类、标签与自定义页面详解">Hexo 新增分类、标签与自定义页面详解</a><time datetime="2025-10-12T05:46:03.000Z" title="发表于 2025-10-12 13:46:03">2025-10-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E9%80%9A%E7%94%A8%E8%93%9D%E5%9B%BE/" title="高可用高并发后端架构通用蓝图">高可用高并发后端架构通用蓝图</a><time datetime="2025-10-08T15:42:00.000Z" title="发表于 2025-10-08 23:42:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%9F%E6%88%90/" title="AI提示词_学习笔记生成">AI提示词_学习笔记生成</a><time datetime="2025-10-08T15:15:00.000Z" title="发表于 2025-10-08 23:15:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E8%AF%95%E9%A2%98%E7%94%9F%E6%88%90/" title="AI提示词_试题生成">AI提示词_试题生成</a><time datetime="2025-10-08T15:15:00.000Z" title="发表于 2025-10-08 23:15:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/Golang_swag/" title="Golang swag 库">Golang swag 库</a><time datetime="2025-10-08T15:07:00.000Z" title="发表于 2025-10-08 23:07:00">2025-10-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/Image/topImage.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By 棨</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>