<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Golang swag 库 | 柊</title><meta name="author" content="棨"><meta name="copyright" content="棨"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#59b9c6"><meta name="description" content="Go swag 从入门到实践，带你一步步掌握如何自动生成 API 文档。从安装、使用注解到理解其工作原理，再到常见问题的解决，让你轻松应对团队协作中的文档需求。">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang swag 库">
<meta property="og:url" content="https://chaoqijiang.github.io/2025/10/08/Golang_swag/index.html">
<meta property="og:site_name" content="柊">
<meta property="og:description" content="Go swag 从入门到实践，带你一步步掌握如何自动生成 API 文档。从安装、使用注解到理解其工作原理，再到常见问题的解决，让你轻松应对团队协作中的文档需求。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chaoqijiang.github.io/Image/avatar.png">
<meta property="article:published_time" content="2025-10-08T15:07:00.000Z">
<meta property="article:modified_time" content="2025-10-08T15:08:57.945Z">
<meta property="article:author" content="棨">
<meta property="article:tag" content="AI">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="protected">
<meta property="article:tag" content="swag">
<meta property="article:tag" content="三方库">
<meta property="article:tag" content="使用教程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chaoqijiang.github.io/Image/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Golang swag 库",
  "url": "https://chaoqijiang.github.io/2025/10/08/Golang_swag/",
  "image": "https://chaoqijiang.github.io/Image/avatar.png",
  "datePublished": "2025-10-08T15:07:00.000Z",
  "dateModified": "2025-10-08T15:08:57.945Z",
  "author": [
    {
      "@type": "Person",
      "name": "棨",
      "url": "https://chaoqijiang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chaoqijiang.github.io/2025/10/08/Golang_swag/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#59b9c6')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 24
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":30,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#165e83","bgDark":"#507ea4","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Golang swag 库',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/Image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴/归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/Image/topImage.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/Image/Logo.ico" alt="Logo"><span class="site-name">柊</span></a><a class="nav-page-title" href="/"><span class="site-name">Golang swag 库</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴/归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Golang swag 库</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-08T15:07:00.000Z" title="发表于 2025-10-08 23:07:00">2025-10-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-08T15:08:57.945Z" title="更新于 2025-10-08 23:08:57">2025-10-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/Golang/">Golang</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">14.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>52分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Go-swag-从入门到实践"><a href="#Go-swag-从入门到实践" class="headerlink" title="Go swag 从入门到实践"></a>Go swag 从入门到实践</h1><p><strong>第1章：我们为什么需要 API 文档？—— 问题的起源</strong></p>
<ul>
<li>核心内容：讲解在团队协作和项目开发中，一份清晰的 API 文档是多么重要，以及手动维护文档的痛点。</li>
</ul>
<p><strong>第2章：Swag 是什么？—— 会写注释就会写文档的“魔法”</strong></p>
<ul>
<li>核心内容：介绍 <code>swag</code> 这个工具，把它比作一个能自动帮你把代码注释“翻译”成漂亮网页文档的“魔法师”。</li>
</ul>
<p><strong>第3-章：快速上手：三步生成你的第一个 API 文档</strong></p>
<ul>
<li>核心内容：通过一个最简单的 “Hello, World” 级别的 Go Web 项目，手把手带你完成安装、添加注释、生成并查看文档的全过程。</li>
</ul>
<p><strong>第4章：Swag 的“魔法咒语”：常用注解（Annotations）详解</strong></p>
<ul>
<li>核心内容：详细拆解 <code>swag</code> 的核心——注解语法，学习如何描述 API 的名称、参数、返回值等关键信息。</li>
</ul>
<p><strong>第5章：揭秘 Swag：它是如何工作的？</strong></p>
<ul>
<li>核心内容：简单说明 <code>swag</code> 的工作原理，让你明白它并不是真的“魔法”，而是一个代码解析和文件生成工具。</li>
</ul>
<p><strong>第6章：避坑指南：使用 Swag 的注意事项</strong></p>
<ul>
<li>核心内容：总结一些新手在使用 <code>swag</code> 时容易犯的错误和需要注意的地方，让你少走弯路。</li>
</ul>
<p><strong>第7章：总结与下一步</strong></p>
<ul>
<li>核心内容：回顾本次学习的重点，并为你指出接下来可以继续学习的方向。</li>
</ul>
<hr>
<h2 id="第1章：我们为什么需要-API-文档？——-问题的起源"><a href="#第1章：我们为什么需要-API-文档？——-问题的起源" class="headerlink" title="第1章：我们为什么需要 API 文档？—— 问题的起源"></a><strong>第1章：我们为什么需要 API 文档？—— 问题的起源</strong></h2><p>嘿，同学！在学习任何一个新工具，尤其是像 <code>swag</code> 这样的“自动化”工具之前，我们必须先搞清楚一个最根本的问题：<strong>我们到底遇到了什么麻烦，以至于需要一个新工具来拯救我们？</strong></p>
<p>只有理解了“痛点”，我们才能真正明白这个工具的价值。</p>
<h3 id="1-1-一个生活中的场景：去餐厅吃饭"><a href="#1-1-一个生活中的场景：去餐厅吃饭" class="headerlink" title="1.1 一个生活中的场景：去餐厅吃饭"></a><strong>1.1 一个生活中的场景：去餐厅吃饭</strong></h3><p>想象一下，你走进一家装修精美的餐厅，准备享用大餐。你（<strong>客户端</strong>，比如手机 App 或网页）坐下来，服务员递给你一本菜单（<strong>API 文档</strong>）。</p>
<p>这本菜单上写得清清楚楚：</p>
<ul>
<li><strong>有什么菜？</strong>（宫保鸡丁、鱼香肉丝……）</li>
<li><strong>每道菜需要什么？</strong>（比如，“牛排”这道菜，你需要告诉服务员要“七分熟”还是“全熟”。）</li>
<li><strong>这道菜上上来是什么样的？</strong>（菜单上的图片告诉你，这道菜有主食、有蔬菜沙拉。）</li>
</ul>
<p>你通过菜单，知道了这家餐厅的厨房（<strong>服务端&#x2F;后端</strong>）能为你做什么。你点了一份“七分熟的牛排”，服务员把这个请求告诉了后厨。后厨一通操作，最后把一份完美的牛排端到你面前。</p>
<p>整个过程非常顺利，因为你们之间有一份清晰的“沟通契约”——<strong>菜单</strong>。</p>
<br>

<blockquote>
<p><strong>关键概念：API</strong><br>在软件开发中，<strong>API</strong> (Application Programming Interface，应用程序编程接口) 就扮演着“菜单”的角色。它定义了不同的软件部分之间如何沟通。后端程序员（厨师）开发好功能后，提供一份 API“菜单”，前端程序员（顾客）或其他服务就知道如何调用这些功能了。</p>
</blockquote>
<hr>
<h3 id="1-2-软件开发中的“餐厅故事”：小明与小红的协作"><a href="#1-2-软件开发中的“餐厅故事”：小明与小红的协作" class="headerlink" title="1.2 软件开发中的“餐厅故事”：小明与小红的协作"></a><strong>1.2 软件开发中的“餐厅故事”：小明与小红的协作</strong></h3><p>现在，我们把场景切换到一家软件公司。</p>
<ul>
<li><strong>小明</strong>：后端工程师，我们的“厨师”。他负责开发服务器的功能，比如“用户注册”、“获取商品列表”等。</li>
<li><strong>小红</strong>：前端工程师，我们的“顾客”。她负责开发用户能直接看到的网页或 App 界面。</li>
</ul>
<p>有一天，产品经理要求做一个“用户注册”的功能。</p>
<p><strong>小明（厨师）</strong> 在后端吭哧吭哧写好了代码，实现了一个功能：只要别人给他一个<code>用户名</code>和<code>密码</code>，他就能在数据库里创建一个新用户，并返回“注册成功”或“用户已存在”的消息。</p>
<p>现在问题来了，小明怎么告诉<strong>小红（顾客）</strong> 这个功能该怎么用呢？</p>
<p>小红心里有一堆问题，就像你看菜单时一样：</p>
<ol>
<li><p><strong>我该访问哪个地址才能找到你这个“注册”功能？</strong> （就像餐厅的门牌号和几号桌）</p>
<blockquote>
<p><em>专业术语叫：<strong>Endpoint</strong> 或 <strong>URL</strong></em></p>
</blockquote>
</li>
<li><p><strong>我该用什么方法来请求？是 GET 还是 POST？</strong> （就像你是要“点餐”还是只是“看看菜单”）</p>
</li>
<li><p><strong>我需要提供哪些信息给你？</strong> 是 <code>username</code> 和 <code>password</code> 吗？还是 <code>user</code> 和 <code>pwd</code>？这些信息是放在哪里给你？</p>
<blockquote>
<p><em>专业术语叫：<strong>请求参数 (Request Parameters)</strong></em></p>
</blockquote>
</li>
<li><p><strong>你处理完后，会返回给我什么？</strong> 是返回一个简单的字符串 <code>&quot;注册成功&quot;</code>，还是一个包含更多信息的复杂结构（比如 JSON 对象）？成功和失败时返回的样子一样吗？</p>
<blockquote>
<p><em>专业术语叫：<strong>响应体 (Response Body)</strong></em></p>
</blockquote>
</li>
</ol>
<p>你看，如果这些信息沟通不清楚，小红就完全没法开始工作。她可能会因为一个参数名写错（比如把 <code>username</code> 写成了 <code>user</code>），而调试大半天，最后发现是小明没告诉她。</p>
<p>于是，最原始的“API 文档”诞生了。可能是一份 Word 文档，一个 Wiki 页面，甚至是聊天记录。小明在里面写清楚上面所有问题的答案，然后发给小红。</p>
<hr>
<h3 id="1-3-手动维护文档的“噩梦”"><a href="#1-3-手动维护文档的“噩梦”" class="headerlink" title="1.3 手动维护文档的“噩梦”"></a><strong>1.3 手动维护文档的“噩梦”</strong></h3><p>一开始，一切看起来都还不错。小明把文档写好，小红照着开发，项目顺利上线。</p>
<p>但软件是不断迭代的。不久后，产品经理又提了新需求：“注册时，除了用户名和密码，还需要用户提供一个<code>邮箱(email)</code>”。</p>
<p><strong>小明（厨师）</strong> 立刻修改了他的代码，现在“注册”功能需要三个参数了：<code>username</code>, <code>password</code>, <code>email</code>。他急着下班，或者 只是 忘了，<strong>没有去更新那份 Word 文档</strong>。</p>
<p><strong>灾难发生了！</strong></p>
<p>几天后，小红发现所有新用户都注册不了了。她查了半天代码，看不出问题，最后跑去问小明。小明一拍脑袋：“哎呀！我加了个 <code>email</code> 参数，忘了和你说，也忘了更新文档了！”</p>
<p>这就是手动维护 API 文档的<strong>核心痛点</strong>：</p>
<ol>
<li><strong>容易忘记更新</strong>：代码是“唯一真实”的，文档是“副本”。程序员改了代码后，很容易忘记或懒得去同步修改那个独立的文档。</li>
<li><strong>文档与代码不一致</strong>：这是最致命的。一份过时的、错误的文档比没有文档更可怕，因为它会误导使用者，浪费大量调试时间。</li>
<li><strong>费时费力</strong>：写文档本身就是一件枯燥的工作。每次修改代码，都要去找到对应的文档位置进行修改，效率极低。</li>
<li><strong>格式不统一</strong>：张三写的文档喜欢用表格，李四写的喜欢用列表。团队里没有统一的、美观的、易于阅读的 API 文档格式。</li>
</ol>
<p><strong>想一想</strong>：如果餐厅的菜单更新不及时，厨师新加了一道菜，或者某道菜的做法变了（比如“宫保鸡丁”现在默认加辣了），但菜单上还是老样子，顾客点餐时会发生多少误会和麻烦？</p>
<hr>
<h3 id="1-4-问题的总结与解决思路"><a href="#1-4-问题的总结与解决思路" class="headerlink" title="1.4 问题的总结与解决思路"></a><strong>1.4 问题的总结与解决思路</strong></h3><p>好了，到现在我们已经把问题搞得很清楚了：</p>
<ol>
<li>团队协作需要清晰的 API 文档（菜单）。</li>
<li>手动维护这份文档（菜单）非常痛苦，且极易出错。</li>
</ol>
<p>那么，有没有一种理想的方法，能够让“菜单”和“厨房里的菜谱”永远保持同步呢？</p>
<p><strong>当然有！</strong></p>
<p>我们能不能找到一种方法，让<strong>代码自己来描述自己</strong>？然后用一个工具，自动读取这些描述，生成一份永远不会过时、格式优美、交互友好的网页版“菜单”？</p>
<p>这，就是 <code>swag</code> 准备为我们做的事情。它就是那个能自动根据厨师的菜谱（代码注释），打印出精美菜单（API 文档网页）的“魔法打印机”。</p>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a><strong>本章小结</strong></h3><ul>
<li><strong>API 是什么？</strong> 它是软件不同部分之间沟通的桥梁，就像餐厅的菜单，定义了你能请求什么，以及会得到什么。</li>
<li><strong>为什么需要 API 文档？</strong> 因为它是指导开发者如何正确使用 API 的说明书，是团队协作的基石。</li>
<li><strong>手动维护文档有什么问题？</strong> 容易过时、与代码不一致、耗费时间、格式混乱。</li>
<li><strong>我们的目标是什么？</strong> 找到一种自动化的方式，让代码和文档永远保持同步。</li>
</ul>
<p>现在，你是不是已经深刻理解了我们即将学习的 <code>swag</code> 是为了解决什么问题而存在的？带着这个问题，我们下一章就来正式认识一下这位“魔法师”！</p>
<hr>
<h2 id="第2章：Swag-是什么？——-会写注释就会写文档的“魔法”"><a href="#第2章：Swag-是什么？——-会写注释就会写文档的“魔法”" class="headerlink" title="第2章：Swag 是什么？—— 会写注释就会写文档的“魔法”"></a><strong>第2章：Swag 是什么？—— 会写注释就会写文档的“魔法”</strong></h2><p>上一章我们聊了手动维护 API 文档的种种痛苦，并且提出了一个美好的设想：能不能让代码自己来解释自己，然后有个工具自动帮我们生成文档？</p>
<p>现在，揭晓答案的时刻到了！<code>swag</code> 就是来实现这个美好设想的工具。</p>
<h3 id="2-1-Swag-的自我介绍"><a href="#2-1-Swag-的自我介绍" class="headerlink" title="2.1 Swag 的自我介绍"></a><strong>2.1 Swag 的自我介绍</strong></h3><p>你可以把 <code>swag</code> 想象成一位非常聪明的“文档翻译官”。</p>
<p>它本身不是一个重量级的大软件，而是一个 Go 语言的工具库。它的核心工作流程非常简单：</p>
<ol>
<li><strong>阅读你的代码</strong>：它会去扫描你项目里的 Go 代码文件。</li>
<li><strong>寻找特殊注释</strong>：它不会关心你所有的代码逻辑，只关心那些你按照特定格式写的“特殊注释”（我们后面会叫它<strong>注解</strong>，英文是 Annotation）。</li>
<li><strong>翻译成文档</strong>：它把这些“特殊注释”翻译成一种标准化的 API 描述文件（叫做 OpenAPI&#x2F;Swagger 规范文件）。</li>
<li><strong>生成网页</strong>：最后，它利用这个标准文件，为你生成一套漂亮、可交互的 HTML 网页，也就是我们最终看到的 API 文档。</li>
</ol>
<blockquote>
<p><strong>一句话总结</strong>：<code>swag</code> 是一个 Go 工具，它能将你代码里的<strong>特定注释</strong>，自动转换成<strong>交互式 API 文档</strong>。</p>
</blockquote>
<hr>
<h3 id="2-2-回到我们的“餐厅”比喻"><a href="#2-2-回到我们的“餐厅”比喻" class="headerlink" title="2.2 回到我们的“餐厅”比喻"></a><strong>2.2 回到我们的“餐厅”比喻</strong></h3><p>还记得小明和小红的故事吗？小明是厨师（后端），小红是顾客（前端）。</p>
<p>在没有 <code>swag</code> 的世界里，小明（厨师）除了要写好自己的菜谱（代码），还得额外花时间去手写一份菜单（Word 文档），并且要时刻记着菜谱一改，菜单也要跟着改，心力交瘁。</p>
<p>现在有了 <code>swag</code> 这个“魔法打印机”，情况完全不同了：</p>
<ol>
<li><p><strong>在菜谱上做笔记</strong>：小明现在不用写单独的菜单了。他只需要在自己的“宫保鸡丁”菜谱（代码文件）旁边，用“魔法荧光笔”（<code>swag</code> 的注解语法）直接写下笔记。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是我的做菜代码...</span></span><br><span class="line"><span class="comment">// @菜名: 宫保鸡丁</span></span><br><span class="line"><span class="comment">// @描述: 一道经典的川味菜肴，酸甜可口。</span></span><br><span class="line"><span class="comment">// @需要食材: 鸡丁, 花生, 辣椒</span></span><br><span class="line"><span class="comment">// @返回样式: &#123; &quot;status&quot;: &quot;成功&quot;, &quot;dish&quot;: &quot;宫保鸡丁一份&quot; &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GongBaoJiDingHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...复杂的炒菜过程...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>一键打印</strong>：当小明写完代码和这些笔记后，他只要在电脑上敲一个命令（比如 <code>swag init</code>），这个“魔法打印机”就会“嗡嗡嗡”地工作起来。</p>
</li>
<li><p><strong>生成精美菜单</strong>：<code>swag</code> 会自动扫描所有菜谱上的“魔法笔记”，然后“duang”的一下，生成一份图文并茂、格式精美的网页菜单，直接交给小红。</p>
</li>
</ol>
<p>从此以后，小明只需要关心他的代码（菜谱）。只要菜谱里的做法或所需食材（API 参数）变了，他顺手改一下旁边的笔记，再敲一下命令，小红看到的菜单就自动更新了！</p>
<p><strong>代码和文档，从此实现了完美的同步！</strong> 这就是 <code>swag</code> 的核心价值。</p>
<hr>
<h3 id="2-3-最终的文档长什么样？——-Swagger-UI"><a href="#2-3-最终的文档长什么样？——-Swagger-UI" class="headerlink" title="2.3 最终的文档长什么样？—— Swagger UI"></a><strong>2.3 最终的文档长什么样？—— Swagger UI</strong></h3><p>你可能会好奇，<code>swag</code> 生成的文档到底是什么样的？仅仅是把注释搬到网页上吗？</p>
<p>远不止如此！<code>swag</code> 实际上是遵循一个业界非常流行的标准，叫做 <strong>OpenAPI 规范</strong>（它的前身就是大名鼎鼎的 <strong>Swagger 规范</strong>）。</p>
<p>你可以理解为，<code>swag</code> 先是把你的注释翻译成了一份“标准数据文件”（一个 <code>json</code> 或 <code>yaml</code> 文件），这份文件以一种通用的格式描述了你所有的 API。</p>
<p>然后，一个叫做 <strong>Swagger UI</strong> 的工具会读取这份标准文件，并把它渲染成一个非常酷的交互式网页。</p>
<p>它有什么特点呢？</p>
<ul>
<li><strong>清晰的列表</strong>：把你所有的 API 按照模块（比如“用户管理”、“商品管理”）分门别类地列出来。</li>
<li><strong>详细的信息</strong>：点开任何一个 API，你都能看到它的 URL、请求方法（GET&#x2F;POST 等）、详细描述、所有参数的说明（参数名、类型、是否必需等）以及返回数据的格式。</li>
<li><strong>在线调试功能（杀手级功能！）</strong>：这是最棒的部分！在文档页面上，你可以直接填写参数，然后点击一个 “Try it out” 或 “Execute” 按钮，<strong>直接调用这个 API</strong>！你不用写任何代码，就能立刻测试后端接口是否正常工作，返回的数据对不对。这对前端的小红来说，简直是天大的福音！</li>
</ul>
<p><strong>想一想</strong>：这就像在餐厅的电子菜单上，你不仅能看到菜品的图片和介绍，旁边还有一个“试吃”按钮。你点一下，服务员就会立刻给你端上一小份样品尝尝。这体验是不是太棒了？</p>
<hr>
<h3 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a><strong>本章小结</strong></h3><ul>
<li><strong>Swag 是什么？</strong> 一个能把 Go 代码中的“特殊注释”自动生成为 API 文档的工具。</li>
<li><strong>它的工作原理？</strong> 读取代码注释 -&gt; 生成遵循 OpenAPI 规范的中间文件 -&gt; 利用 Swagger UI 渲染成交互式网页。</li>
<li><strong>它的核心价值？</strong> <strong>让文档与代码保持同步</strong>，彻底解决手动维护文档的痛点，实现“代码即文档”。</li>
<li><strong>最终产出物？</strong> 一个美观、清晰、且支持<strong>在线调试</strong>的 API 文档网站。</li>
</ul>
<p>好了，现在我们已经知道了 <code>swag</code> 是什么，以及它为什么这么神奇。是不是已经跃跃欲试，想亲手生成一份自己的 API 文档了？</p>
<p>下一章，我们就来动手实践！准备好你的 Go 环境，我们要开始写代码了！</p>
<p>准备好了吗？让我们开始搭建你的第一个自动化 API 文档！</p>
<hr>
<h2 id="第3章：快速上手：三步生成你的第一个-API-文档"><a href="#第3章：快速上手：三步生成你的第一个-API-文档" class="headerlink" title="第3章：快速上手：三步生成你的第一个 API 文档"></a><strong>第3章：快速上手：三步生成你的第一个 API 文档</strong></h2><p>理论说再多，不如亲手敲一遍代码。这一章，我们会像拼乐高一样，一步步搭建一个最简单的 Go Web 项目，并用 <code>swag</code> 为它生成一份漂亮的 API 文档。</p>
<p>整个过程可以清晰地分为三步：<strong>搭建项目 -&gt; 添加注解 -&gt; 生成文档</strong>。</p>
<h3 id="第零步：环境准备（磨刀不误砍柴工）"><a href="#第零步：环境准备（磨刀不误砍柴工）" class="headerlink" title="第零步：环境准备（磨刀不误砍柴工）"></a><strong>第零步：环境准备（磨刀不误砍柴工）</strong></h3><p>在开始之前，请确保你的电脑已经安装好了 Go 语言环境。你可以在终端（命令行工具）里输入以下命令来检查：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure>

<p>如果你能看到类似 <code>go version go1.18 linux/amd64</code> 这样的输出，就说明环境没问题。</p>
<p>接下来，创建一个新的项目文件夹，并进入这个文件夹。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> my-swag-app</span><br><span class="line"><span class="built_in">cd</span> my-swag-app</span><br></pre></td></tr></table></figure>

<p>然后，初始化 Go 的模块管理，这会生成一个 <code>go.mod</code> 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod init my-swag-app</span><br></pre></td></tr></table></figure>

<h3 id="第一步：安装-Swag-与搭建基础项目"><a href="#第一步：安装-Swag-与搭建基础项目" class="headerlink" title="第一步：安装 Swag 与搭建基础项目"></a><strong>第一步：安装 Swag 与搭建基础项目</strong></h3><p><strong>1. 安装 Swag 命令行工具</strong></p>
<p><code>swag</code> 主要包含两部分：一个是能生成文档的<strong>命令行工具</strong>，另一个是能在我们网页里展示文档页面的<strong>代码库</strong>。我们先来安装命令行工具。</p>
<p>在终端里运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install github.com/swaggo/swag/cmd/swag@latest</span><br></pre></td></tr></table></figure>

<p>安装成功后，你可以通过 <code>swag -v</code> 命令来验证。如果能看到版本号，就说明成功了。</p>
<p><strong>2. 搭建一个简单的 Web 服务器</strong></p>
<p>为了演示，我们将使用一个非常流行的 Go Web 框架 <code>Gin</code>，因为它简单快捷。同时，我们还需要 <code>gin-swagger</code> 和 <code>files</code> 这两个库，它们是 <code>swag</code> 的好搭档，用来在 <code>Gin</code> 项目里展示文档页面。</p>
<p>安装这三个库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br><span class="line">go get -u github.com/swaggo/gin-swagger</span><br><span class="line">go get -u github.com/swaggo/files</span><br></pre></td></tr></table></figure>

<p>接下来，在你的项目文件夹 <code>my-swag-app</code> 中，创建一个 <code>main.go</code> 文件，然后把下面的代码复制进去。这是一个最基础的、不包含任何 <code>swag</code> 注解的 Web 服务器。</p>
<p><strong><code>main.go</code> (初始版本)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 创建路由引擎</span></span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 定义一个 API 路由</span></span><br><span class="line">	<span class="comment">// 当用户访问 /hello?name=张三 时，会调用 PingHandler 函数</span></span><br><span class="line">	r.GET(<span class="string">&quot;/hello&quot;</span>, PingHandler)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 3. 启动服务，监听在 8080 端口</span></span><br><span class="line">	r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PingHandler 是这个 API 的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PingHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 从 URL 查询参数中获取 &quot;name&quot; 的值，如果没有，则默认为 &quot;Guest&quot;</span></span><br><span class="line">	name := c.DefaultQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Guest&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 返回一个 JSON 响应</span></span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong, &quot;</span> + name,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，你可以运行这个程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure>

<p>然后在浏览器或 Postman 等工具中访问 <code>http://localhost:8080/hello?name=Coder</code>，你会看到返回结果：<code>{&quot;message&quot;:&quot;pong, Coder&quot;}</code>。</p>
<p>很好！我们的基础项目已经跑起来了。</p>
<h3 id="第二步：添加“魔法咒语”——-编写-Swag-注解-Annotation"><a href="#第二步：添加“魔法咒语”——-编写-Swag-注解-Annotation" class="headerlink" title="第二步：添加“魔法咒语”—— 编写 Swag 注解 (Annotation)"></a><strong>第二步：添加“魔法咒语”—— 编写 Swag 注解 (Annotation)</strong></h3><p>现在，我们要开始对代码“施法”了。<code>swag</code> 的注解本质上就是一种特殊格式的注释，它总是以 <code>@</code> 符号开头。</p>
<p>我们将为我们的项目添加两种注解：</p>
<ol>
<li><strong>全局注解</strong>：写在 <code>main</code> 函数的上方，用来描述整个项目的基本信息，比如标题、版本号、API 的基础路径等。</li>
<li><strong>API 注解</strong>：写在具体的 <code>Handler</code> 函数（处理请求的函数）上方，用来描述这一个 API 的所有细节。</li>
</ol>
<p>现在，请用下面的代码<strong>完整替换</strong>你的 <code>main.go</code> 文件。仔细看新增的那些注释。</p>
<p><strong><code>main.go</code> (添加注解后)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 引入 swag 必需的库</span></span><br><span class="line">	_ <span class="string">&quot;my-swag-app/docs&quot;</span> <span class="comment">// 注意这里的路径！ `my-swag-app` 是你的 go.mod 里的模块名</span></span><br><span class="line">	swaggerFiles <span class="string">&quot;github.com/swaggo/files&quot;</span></span><br><span class="line">	ginSwagger <span class="string">&quot;github.com/swaggo/gin-swagger&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// @title           我的第一个 Swag API</span></span><br><span class="line"><span class="comment">// @version         1.0</span></span><br><span class="line"><span class="comment">// @description     这是一个使用 Gin 和 Swag 构建的示例服务.</span></span><br><span class="line"><span class="comment">// @termsOfService  http://swagger.io/terms/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @contact.name   API Support</span></span><br><span class="line"><span class="comment">// @contact.url    http://www.swagger.io/support</span></span><br><span class="line"><span class="comment">// @contact.email  support@swagger.io</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @license.name  Apache 2.0</span></span><br><span class="line"><span class="comment">// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @host      localhost:8080</span></span><br><span class="line"><span class="comment">// @BasePath  /</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @schemes http</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// API 路由</span></span><br><span class="line">	r.GET(<span class="string">&quot;/hello&quot;</span>, PingHandler)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 文档路由</span></span><br><span class="line">	<span class="comment">// 访问 http://localhost:8080/swagger/index.html 就可以看到文档了</span></span><br><span class="line">	r.GET(<span class="string">&quot;/swagger/*any&quot;</span>, ginSwagger.WrapHandler(swaggerFiles.Handler))</span><br><span class="line"></span><br><span class="line">	r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PingHandler 回复一个问候</span></span><br><span class="line"><span class="comment">// @Summary      Ping example</span></span><br><span class="line"><span class="comment">// @Description  这是一个 &quot;ping&quot; API 的示例，它会带上你的名字进行回复.</span></span><br><span class="line"><span class="comment">// @Tags         示例API</span></span><br><span class="line"><span class="comment">// @Accept       json</span></span><br><span class="line"><span class="comment">// @Produce      json</span></span><br><span class="line"><span class="comment">// @Param        name   query      string  false  &quot;你的名字&quot; default(Guest)</span></span><br><span class="line"><span class="comment">// @Success      200    &#123;object&#125;   map[string]string</span></span><br><span class="line"><span class="comment">// @Router       /hello [get]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PingHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	name := c.DefaultQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Guest&quot;</span>)</span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong, &quot;</span> + name,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码讲解</strong>：</p>
<ul>
<li><strong>全局注解（<code>main</code> 函数上方）</strong>：<ul>
<li><code>@title</code>, <code>@version</code>, <code>@description</code>: 定义了文档的标题、版本和描述。</li>
<li><code>@host</code>: 告诉 <code>swag</code> 我们的服务地址是什么，这在在线调试时非常重要。</li>
<li><code>@BasePath</code>: API 的基础路径，我们这里是根路径 <code>/</code>。</li>
</ul>
</li>
<li><strong>API 注解（<code>PingHandler</code> 函数上方）</strong>：<ul>
<li><code>@Summary</code>: API 的一句话简介，会显示在列表里。</li>
<li><code>@Description</code>: 更详细的描述。</li>
<li><code>@Tags</code>: API 的分组标签，方便管理。</li>
<li><code>@Accept</code>&#x2F;<code>@Produce</code>: 定义这个 API 接收和返回的数据格式（这里是 <code>json</code>）。</li>
<li><code>@Param</code>: <strong>非常重要</strong>！用来定义参数。格式是：<code>参数名</code> <code>参数位置</code> <code>数据类型</code> <code>是否必需</code> <code>注释</code> <code>其他属性</code>。<ul>
<li><code>name query string false &quot;你的名字&quot;</code> 的意思是：有一个名叫 <code>name</code> 的参数，它在 <code>query</code>（URL <code>?</code> 后面）里，类型是 <code>string</code>，不是必需的 (<code>false</code>)，注释是 “你的名字”。</li>
</ul>
</li>
<li><code>@Success</code>: 定义成功响应。格式是：<code>HTTP状态码</code> <code>{返回数据结构}</code> <code>注释</code>。我们这里 <code>200</code> 表示成功，返回一个键值都是字符串的 map。</li>
<li><code>@Router</code>: 定义路由路径和 HTTP 方法。格式是：<code>路径</code> <code>[HTTP方法]</code>。</li>
</ul>
</li>
</ul>
<h3 id="第三步：生成并查看文档"><a href="#第三步：生成并查看文档" class="headerlink" title="第三步：生成并查看文档"></a><strong>第三步：生成并查看文档</strong></h3><p>万事俱备，只欠东风！现在，我们在项目根目录下（<code>my-swag-app</code> 文件夹）打开终端，运行 <code>swag</code> 的初始化命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swag init</span><br></pre></td></tr></table></figure>

<p>执行后，你会看到类似这样的输出：<br><code>create docs.go</code><br><code>create swagger.json</code><br><code>create swagger.yaml</code></p>
<p>同时，你的项目文件夹里会多出一个 <code>docs</code> 文件夹，里面就装着 <code>swag</code> 帮我们生成的文档资源。</p>
<p><strong>最后一步，让我们的程序跑起来！</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure>

<p>服务启动后，打开你的浏览器，访问这个神奇的地址：</p>
<p><strong><a target="_blank" rel="noopener" href="http://localhost:8080/swagger/index.html">http://localhost:8080/swagger/index.html</a></strong></p>
<p><strong>见证奇迹的时刻！</strong> 你会看到一个漂亮的 API 文档页面，上面清晰地列出了我们刚刚定义的 “Ping example” API。你可以点开它，看到所有详细信息，甚至可以在页面上输入你的名字，点击 “Try it out”，然后 “Execute”，亲身体验在线调试的快感！</p>
<hr>
<h3 id="本章小结-2"><a href="#本章小结-2" class="headerlink" title="本章小结"></a><strong>本章小结</strong></h3><p>恭喜你！你已经成功地使用 <code>swag</code> 生成了你的第一个 API 文档。我们来回顾一下这个核心流程：</p>
<ol>
<li><strong>安装工具</strong>：安装 <code>swag</code> 命令行工具和相关的 Go 库 (<code>gin-swagger</code>, <code>files</code>)。</li>
<li><strong>编写注解</strong>：在 <code>main</code> 函数上写<strong>全局注解</strong>，在处理函数上写<strong>API 注解</strong>。</li>
<li><strong>生成文档</strong>：运行 <code>swag init</code> 命令，生成 <code>docs</code> 文件夹。</li>
<li><strong>集成与运行</strong>：在代码中添加文档路由，然后运行程序，访问 <code>/swagger/index.html</code> 查看。</li>
</ol>
<p>这个流程会成为你未来工作的日常。每当你修改了 API 的逻辑或参数，你只需要：<br><strong>修改代码&#x2F;注解 -&gt; 重新运行 <code>swag init</code> -&gt; 重启你的服务</strong><br>你的文档就永远和代码保持同步了！</p>
<p>现在你已经掌握了基本操作，但你可能对 <code>@Param</code>、<code>@Success</code> 等注解的具体写法还有很多疑问。别担心，下一章，我们将深入学习这些“魔法咒语”的详细语法和更多用法。</p>
<p>你已经学会了如何“让 <code>swag</code> 跑起来”，现在是时候深入理解它背后的“语法规则”了。只有掌握了这些规则，你才能随心所欲地生成任何你想要的文档。</p>
<p>这一章，我们就来详细拆解 <code>swag</code> 的核心——注解（Annotations），也就是我们之前说的“魔法咒语”。</p>
<hr>
<h2 id="第4章：Swag-的“魔法咒语”：常用注解（Annotations）详解"><a href="#第4章：Swag-的“魔法咒语”：常用注解（Annotations）详解" class="headerlink" title="第4章：Swag 的“魔法咒语”：常用注解（Annotations）详解"></a><strong>第4章：Swag 的“魔法咒语”：常用注解（Annotations）详解</strong></h2><p>把注解想象成你在填写一份非常详细的“API 注册表”。这份表单上的每一项（比如“名称”、“功能”、“所需材料”等），都对应一个 <code>@</code> 开头的注解。<code>swag</code> 工具就是一个严格的“审查员”，它会读取你填写的这份表单，并据此生成最终的文档。</p>
<p>我们将注解分为几大类来学习：<strong>API 身份信息</strong>、<strong>请求信息</strong>、<strong>响应信息</strong>和<strong>路由信息</strong>。</p>
<h3 id="4-1-API-的“身份证”：我是谁，我做什么？"><a href="#4-1-API-的“身份证”：我是谁，我做什么？" class="headerlink" title="4.1 API 的“身份证”：我是谁，我做什么？"></a><strong>4.1 API 的“身份证”：我是谁，我做什么？</strong></h3><p>这类注解用来描述 API 的基本信息，让别人一眼就能看懂它的用途。</p>
<ul>
<li><p><strong><code>@Summary</code></strong></p>
<ul>
<li><p><strong>用途</strong>：API 的一句话摘要，是它的“标题”。通常在文档列表中显示。</p>
</li>
<li><p><strong>语法</strong>：<code>@Summary 任意描述性文字</code></p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Summary 获取单个用户信息</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>@Description</code></strong></p>
<ul>
<li><p><strong>用途</strong>：API 的详细描述。可以写多行，用来解释更复杂的业务逻辑或注意事项。</p>
</li>
<li><p><strong>语法</strong>：<code>@Description 更详细的说明，可以换行。</code></p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Description 根据用户ID获取用户的详细信息，包括姓名、年龄和注册日期。</span></span><br><span class="line"><span class="comment">// @Description 注意：如果用户ID不存在，将返回404错误。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>@Tags</code></strong></p>
<ul>
<li><p><strong>用途</strong>：为 API 分组。在文档页面上，相同 <code>Tags</code> 的 API 会被归类到一起，非常利于管理。</p>
</li>
<li><p><strong>语法</strong>：<code>@Tags 标签名1,标签名2</code> (多个标签用逗号隔开)</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Tags 用户管理</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>@ID</code></strong></p>
<ul>
<li><p><strong>用途</strong>：为操作设置一个唯一的标识符。在某些高级应用（如生成客户端代码）中会用到，通常可以省略。</p>
</li>
<li><p><strong>语法</strong>：<code>@ID 操作的唯一ID</code></p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @ID GetUserByID</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-2-“顾客”需要提供什么？——-定义请求参数-Param"><a href="#4-2-“顾客”需要提供什么？——-定义请求参数-Param" class="headerlink" title="4.2 “顾客”需要提供什么？—— 定义请求参数 @Param"></a><strong>4.2 “顾客”需要提供什么？—— 定义请求参数 <code>@Param</code></strong></h3><p>这是最重要、也是最复杂的注解之一。它告诉使用者，调用这个 API 需要提供哪些数据。</p>
<ul>
<li><p><strong><code>@Param</code></strong></p>
<ul>
<li><strong>用途</strong>：定义一个请求参数。每个参数都需要单独写一行 <code>@Param</code> 注解。</li>
<li><strong>语法</strong>：<code>@Param 参数名 参数位置 数据类型 是否必需 &quot;注释&quot; [其他属性]</code></li>
<li><strong>参数详解</strong>：<ol>
<li><strong>参数名 (Parameter Name)</strong>：例如 <code>userID</code>、<code>username</code>。</li>
<li><strong>参数位置 (Parameter In)</strong>：参数从哪里来？<ul>
<li><code>query</code>：URL 中 <code>?</code> 后面的参数，如 <code>/users?id=123</code>。</li>
<li><code>path</code>：URL 路径中的一部分，如 <code>/users/123</code> (需要配合 Gin 的 <code>:id</code> 格式)。</li>
<li><code>header</code>：HTTP 请求头里的参数，如 <code>Authorization</code> Token。</li>
<li><code>body</code>：整个 HTTP 请求体，通常用于 POST&#x2F;PUT 请求，用来传递复杂的 JSON 数据。</li>
<li><code>formData</code>：表单数据，用于 <code>application/x-www-form-urlencoded</code> 或 <code>multipart/form-data</code> 格式的提交。</li>
</ul>
</li>
<li><strong>数据类型 (Data Type)</strong>：参数的类型，如 <code>string</code>、<code>int</code>、<code>boolean</code>、<code>file</code> 等。</li>
<li><strong>是否必需 (Required)</strong>：<code>true</code> 或 <code>false</code>。</li>
<li><strong>注释 (Comment)</strong>：用双引号括起来的参数描述。</li>
<li><strong>其他属性 (Attributes)</strong>：可选，用于提供更多约束，如 <code>default(Guest)</code>、<code>enums(male,female)</code>、<code>maxLength(10)</code> 等。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong><code>@Param</code> 示例大合集</strong></p>
<p><strong>1. <code>query</code> 参数（最常见）</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Param   page  query     int  false  &quot;页码&quot; default(1)</span></span><br><span class="line"><span class="comment">// @Param   size  query     int  false  &quot;每页大小&quot; default(10)</span></span><br></pre></td></tr></table></figure>

<p><strong>2. <code>path</code> 参数</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Summary 获取单个用户信息</span></span><br><span class="line"><span class="comment">// @Param   id   path      int  true   &quot;用户ID&quot;</span></span><br><span class="line"><span class="comment">// @Router /users/&#123;id&#125; [get]</span></span><br><span class="line"><span class="comment">// Gin 路由应该这样写: r.GET(&quot;/users/:id&quot;, GetUser)</span></span><br></pre></td></tr></table></figure>

<p><em>注意：<code>@Router</code> 里的路径 <code>{id}</code> 必须和 <code>@Param</code> 里的 <code>id</code> 对应。</em></p>
<p><strong>3. <code>body</code> 参数（用于提交 JSON）</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Summary 创建一个新用户</span></span><br><span class="line"><span class="comment">// @Accept  json</span></span><br><span class="line"><span class="comment">// @Param   user body      models.User  true   &quot;用户信息&quot;</span></span><br><span class="line"><span class="comment">// @Router /users [post]</span></span><br><span class="line"><span class="comment">// 这里的 `models.User` 是你项目里定义的一个 Go 结构体 (struct)，我们稍后会讲。</span></span><br></pre></td></tr></table></figure>

<p><em><code>@Accept</code> 注解用来声明此 API 接收的数据格式。</em></p>
</li>
</ul>
<hr>
<h3 id="4-3-“厨师”会返回什么？——-定义响应-Success-Failure"><a href="#4-3-“厨师”会返回什么？——-定义响应-Success-Failure" class="headerlink" title="4.3 “厨师”会返回什么？—— 定义响应 @Success &amp; @Failure"></a><strong>4.3 “厨师”会返回什么？—— 定义响应 <code>@Success</code> &amp; <code>@Failure</code></strong></h3><p>这两个注解用来告诉使用者，API 调用成功或失败时，会返回什么样的数据。</p>
<ul>
<li><p><strong>语法</strong>：<code>@Success/@Failure HTTP状态码 {返回类型} 数据模型 &quot;注释&quot;</code></p>
</li>
<li><p><strong>参数详解</strong>：</p>
<ol>
<li><strong>HTTP状态码 (HTTP Status Code)</strong>：如 <code>200</code> (成功)、<code>400</code> (错误请求)、<code>404</code> (未找到)、<code>500</code> (服务器内部错误)。</li>
<li><strong>返回类型 (Response Type)</strong>：通常是 <code>object</code> (单个对象) 或 <code>array</code> (对象数组)。</li>
<li><strong>数据模型 (Data Model)</strong>：<ul>
<li>可以是基础类型，如 <code>string</code>, <code>int</code>。</li>
<li>可以是 <code>map[string]string</code> 这样的简单集合。</li>
<li><strong>最常用的是</strong>：指向你项目中定义的 Go 结构体，如 <code>models.User</code> 或 <code>[]models.User</code> (表示用户数组)。</li>
</ul>
</li>
<li><strong>注释 (Comment)</strong>：对这个响应的描述。</li>
</ol>
</li>
<li><p><strong><code>@Success</code> &amp; <code>@Failure</code> 示例</strong></p>
<p><strong>1. 返回简单消息</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Success 200 &#123;object&#125; map[string]string &quot;&#123;&quot;message&quot;: &quot;操作成功&quot;&#125;&quot;</span></span><br><span class="line"><span class="comment">// @Failure 400 &#123;object&#125; map[string]string &quot;&#123;&quot;error&quot;: &quot;无效的输入&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 返回一个复杂对象（结构体）</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Success 200 &#123;object&#125; models.User &quot;成功返回用户信息&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 返回一个对象数组</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Success 200 &#123;array&#125; models.User &quot;成功返回用户列表&quot;</span></span><br></pre></td></tr></table></figure>

<p><em><code>@Produce</code> 注解用来声明此 API 返回的数据格式，通常是 <code>application/json</code>。</em></p>
</li>
</ul>
<hr>
<h3 id="4-4-API-的“门牌号”-——-定义路由-Router"><a href="#4-4-API-的“门牌号”-——-定义路由-Router" class="headerlink" title="4.4 API 的“门牌号” —— 定义路由 @Router"></a><strong>4.4 API 的“门牌号” —— 定义路由 <code>@Router</code></strong></h3><p>这个注解至关重要，它把所有信息和具体的 URL 路径、HTTP 方法绑定在了一起。</p>
<ul>
<li><p><strong><code>@Router</code></strong></p>
<ul>
<li><p><strong>用途</strong>：定义 API 的路由路径和请求方法。</p>
</li>
<li><p><strong>语法</strong>：<code>@Router /path/to/resource [http_method]</code></p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Router /users [post]        // 创建用户</span></span><br><span class="line"><span class="comment">// @Router /users/&#123;id&#125; [get]      // 获取单个用户</span></span><br><span class="line"><span class="comment">// @Router /users/&#123;id&#125; [put]      // 更新单个用户</span></span><br><span class="line"><span class="comment">// @Router /users/&#123;id&#125; [delete]   // 删除单个用户</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-5-综合实战：定义一个完整的-CRUD"><a href="#4-5-综合实战：定义一个完整的-CRUD" class="headerlink" title="4.5 综合实战：定义一个完整的 CRUD"></a><strong>4.5 综合实战：定义一个完整的 CRUD</strong></h3><p>现在，让我们把所有学到的注解整合起来，为一个 <code>User</code> 模型定义一个完整的创建和查询 API。</p>
<p><strong>首先，创建一个 <code>models</code> 文件夹，并在其中创建 <code>user.go</code> 文件</strong></p>
<p><strong><code>models/user.go</code></strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment">// User 代表一个用户模型</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="type">int</span>    <span class="string">`json:&quot;id&quot; example:&quot;1&quot;`</span></span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot; example:&quot;John Doe&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot; example:&quot;30&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>这里的 <code>json:&quot;...&quot;</code> 是 Go 的结构体标签，用于序列化为 JSON。<code>example:&quot;...&quot;</code> 是 <code>swag</code> 的注解，用于在文档中生成示例值。</em></p>
<p><strong>然后，修改你的 <code>main.go</code>，添加新的路由和处理函数</strong></p>
<p><strong><code>main.go</code> (片段)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... import 部分省略 ...</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;my-swag-app/models&quot;</span> <span class="comment">// 引入你的模型包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 全局注解部分省略 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GetUserByID 根据ID获取用户信息</span></span><br><span class="line"><span class="comment">// @Summary      获取单个用户</span></span><br><span class="line"><span class="comment">// @Description  根据给定的用户ID返回用户数据</span></span><br><span class="line"><span class="comment">// @Tags         用户管理</span></span><br><span class="line"><span class="comment">// @Produce      json</span></span><br><span class="line"><span class="comment">// @Param        id   path      int  true  &quot;用户 ID&quot;</span></span><br><span class="line"><span class="comment">// @Success      200  &#123;object&#125;  models.User</span></span><br><span class="line"><span class="comment">// @Failure      404  &#123;object&#125;  map[string]string</span></span><br><span class="line"><span class="comment">// @Router       /users/&#123;id&#125; [get]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserByID</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实际项目中这里应该是查询数据库的逻辑</span></span><br><span class="line">    <span class="comment">// 我们这里为了演示，直接返回一个假数据</span></span><br><span class="line">    id := c.Param(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> id == <span class="string">&quot;1&quot;</span> &#123;</span><br><span class="line">        user := models.User&#123;ID: <span class="number">1</span>, Name: <span class="string">&quot;John Doe&quot;</span>, Age: <span class="number">30</span>&#125;</span><br><span class="line">        c.JSON(http.StatusOK, user)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.JSON(http.StatusNotFound, gin.H&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;User not found&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateUser 创建一个新用户</span></span><br><span class="line"><span class="comment">// @Summary      创建用户</span></span><br><span class="line"><span class="comment">// @Description  从请求体中接收用户信息并创建一个新用户</span></span><br><span class="line"><span class="comment">// @Tags         用户管理</span></span><br><span class="line"><span class="comment">// @Accept       json</span></span><br><span class="line"><span class="comment">// @Produce      json</span></span><br><span class="line"><span class="comment">// @Param        user   body      models.User  true  &quot;用户信息&quot;</span></span><br><span class="line"><span class="comment">// @Success      201    &#123;object&#125;  models.User</span></span><br><span class="line"><span class="comment">// @Failure      400    &#123;object&#125;  map[string]string</span></span><br><span class="line"><span class="comment">// @Router       /users [post]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateUser</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user models.User</span><br><span class="line">    <span class="comment">// 将请求体中的 JSON 绑定到 user 结构体</span></span><br><span class="line">    <span class="keyword">if</span> err := c.ShouldBindJSON(&amp;user); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实际项目中这里是存入数据库的逻辑</span></span><br><span class="line">    <span class="comment">// 我们这里为了演示，假装设置一个ID并返回</span></span><br><span class="line">    user.ID = <span class="number">2</span> </span><br><span class="line">    c.JSON(http.StatusCreated, user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户管理 API 路由组</span></span><br><span class="line">    userRoutes := r.Group(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        userRoutes.GET(<span class="string">&quot;/:id&quot;</span>, GetUserByID)</span><br><span class="line">        userRoutes.POST(<span class="string">&quot;&quot;</span>, CreateUser)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.GET(<span class="string">&quot;/swagger/*any&quot;</span>, ginSwagger.WrapHandler(swaggerFiles.Handler))</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>操作步骤：</strong></p>
<ol>
<li>保存以上代码。</li>
<li>在终端运行 <code>swag init</code>。</li>
<li>运行 <code>go run main.go</code>。</li>
<li>访问 <code>http://localhost:8080/swagger/index.html</code>。</li>
</ol>
<p>你会看到一个新的 “用户管理” 分组，里面包含了我们刚刚定义的两个 API。点开 “创建用户” (<code>POST /users</code>)，你会发现它的请求体部分已经为你生成了一个包含 <code>name</code> 和 <code>age</code> 的 JSON 示例，这就是 <code>@Param</code> 引用 <code>models.User</code> 结构体的强大之处！</p>
<hr>
<h3 id="本章小结-3"><a href="#本章小结-3" class="headerlink" title="本章小结"></a><strong>本章小结</strong></h3><p>我们详细学习了 <code>swag</code> 最核心的几类注解：</p>
<ul>
<li><strong>身份注解</strong>：<code>@Summary</code>, <code>@Description</code>, <code>@Tags</code>，用于描述 API 的基本信息。</li>
<li><strong>请求注解</strong>：<code>@Param</code>，用于定义输入的参数，是功能最强大的注解。</li>
<li><strong>响应注解</strong>：<code>@Success</code>, <code>@Failure</code>，用于定义不同情况下的输出。</li>
<li><strong>路由注解</strong>：<code>@Router</code>，用于将所有信息与 URL 和 HTTP 方法绑定。</li>
</ul>
<p>掌握了这些，你就掌握了 <code>swag</code> 的 80%。剩下的就是不断练习，熟悉各种参数位置 (<code>query</code>, <code>path</code>, <code>body</code> 等) 和数据类型 (基础类型、自定义结构体、数组) 的组合使用。</p>
<p>接下来，我们将简单聊聊 <code>swag</code> 到底是怎么工作的，揭开它神秘的“魔法”面纱。</p>
<p>到现在为止，你已经掌握了 <code>swag</code> 的使用方法，能够熟练地通过写注释来生成漂亮的 API 文档了。对你来说，<code>swag</code> 可能还像一个神奇的“黑盒子”：我写了注释，敲了命令，漂亮的网页就出来了。</p>
<p>这一章，我们就来打开这个“黑盒子”，用最简单的方式看一看它内部的构造。理解了它的工作原理，你不仅能更好地使用它，还能在遇到问题时，更快地找到原因。</p>
<hr>
<h2 id="第5章：揭秘-Swag：它是如何工作的？"><a href="#第5章：揭秘-Swag：它是如何工作的？" class="headerlink" title="第5章：揭秘 Swag：它是如何工作的？"></a><strong>第5章：揭秘 Swag：它是如何工作的？</strong></h2><p><code>swag</code> 并不是真的有什么“魔法”，它本质上是一个<strong>代码解析器</strong>和<strong>文件生成器</strong>的组合。它的整个工作流程，就像一个高度自动化的工厂流水线。</p>
<p>让我们把 <code>swag init</code> 这个命令的执行过程拆解成三个主要步骤：</p>
<h3 id="步骤一：扫描与解析（流水线的第一站：原材料检验）"><a href="#步骤一：扫描与解析（流水线的第一站：原材料检验）" class="headerlink" title="步骤一：扫描与解析（流水线的第一站：原材料检验）"></a><strong>步骤一：扫描与解析（流水线的第一站：原材料检验）</strong></h3><p>当你运行 <code>swag init</code> 时，<code>swag</code> 工具首先会像一个勤劳的机器人，开始扫描你项目中的所有 <code>.go</code> 文件。</p>
<p>但它不是漫无目的地扫描，它的目标非常明确：<strong>寻找那些以 <code>// @</code> 开头的特殊注释行</strong>。</p>
<p>在这个过程中，它利用了 Go 语言自带的一个强大工具包——<code>go/ast</code> (Abstract Syntax Tree，抽象语法树)。</p>
<ul>
<li><p><strong>什么是抽象语法树（AST）？</strong><br>你可以把它想象成对你代码的一种“结构化解剖”。<code>go/ast</code> 包能够把你的 Go 代码文本，转换成一个程序能够理解的、树状的数据结构。在这棵“树”上，每个节点都代表了代码的一部分，比如一个函数声明、一个变量定义、或者一行注释。</p>
<p><strong>生活中的类比：</strong><br>这就像一位语法老师在分析一个句子：“勤劳的小明（主语）昨天（状语）高兴地（状语）完成了（谓语）家庭作业（宾语）。”<br>老师并不是把这句话当成一串无意义的文字，而是解析出了它的语法结构。</p>
<p><code>swag</code> 就是这样一位“语法老师”，它能准确地识别出：“哦，这行注释 <code>// @Summary 获取用户信息</code> 是挂在 <code>GetUserByID</code> 这个函数声明节点上面的！”</p>
</li>
</ul>
<p>通过这种方式，<code>swag</code> 就能把注解和它们所描述的函数精确地关联起来。</p>
<h3 id="步骤二：翻译与整合（流水线的第二站：加工与组装）"><a href="#步骤二：翻译与整合（流水线的第二站：加工与组装）" class="headerlink" title="步骤二：翻译与整合（流水线的第二站：加工与组装）"></a><strong>步骤二：翻译与整合（流水线的第二站：加工与组装）</strong></h3><p><code>swag</code> 找到了所有的注解和它们对应的代码结构后，就开始了“翻译”工作。</p>
<p>它的目标是生成一份遵循 <strong>OpenAPI 3.0 规范</strong>（或旧版的 Swagger 2.0）的 <code>swagger.json</code> 或 <code>swagger.yaml</code> 文件。</p>
<ul>
<li><strong>什么是 OpenAPI 规范？</strong><br>它是一个用来描述 RESTful API 的国际标准格式。你可以把它理解成 API 界的“普通话”。这份规范用 JSON 或 YAML 格式，极其严谨地定义了描述一个 API 所需的全部元素：路径、操作（GET&#x2F;POST）、参数、请求体、响应、数据模型等等。<br>全世界有成千上百的工具都认识这门“普通话”，比如 Postman、Swagger UI 等。</li>
</ul>
<p><code>swag</code> 的翻译工作就是把 <code>swag</code> 自定义的注解格式，转换成 OpenAPI 规范的标准格式。</p>
<ul>
<li><code>// @Summary 获取用户信息</code>  -&gt;  会被翻译成 JSON 中 <code>summary</code> 字段。</li>
<li><code>// @Param id path int true &quot;用户ID&quot;</code> -&gt; 会被翻译成 <code>parameters</code> 数组中的一个对象，里面详细定义了 <code>name: &quot;id&quot;</code>, <code>in: &quot;path&quot;</code>, <code>required: true</code>, <code>schema: { &quot;type&quot;: &quot;integer&quot; }</code> 等等。</li>
<li><code>// @Success 200 {object} models.User</code> -&gt; 会被翻译成 <code>responses</code> 对象下的 <code>200</code> 字段，并且会去解析 <code>models.User</code> 这个结构体，把它也转换成 OpenAPI 规范里的 <code>schemas</code> 定义。</li>
</ul>
<p>所有 API 的信息都被翻译和整合后，最终形成一个巨大的、结构化的 <code>swagger.json</code> 文件。这个文件才是 <code>swag</code> 的<strong>核心产物</strong>。</p>
<p>你可以打开你项目 <code>docs</code> 目录下的 <code>swagger.json</code> 文件看一看，虽然内容很多，但仔细观察，你就能找到和你写的注解一一对应的字段。</p>
<h3 id="步骤三：打包与呈现（流水线的最后一站：包装与上架）"><a href="#步骤三：打包与呈现（流水线的最后一站：包装与上架）" class="headerlink" title="步骤三：打包与呈现（流水线的最后一站：包装与上架）"></a><strong>步骤三：打包与呈现（流水线的最后一站：包装与上架）</strong></h3><p><code>swag</code> 生成了标准的 <code>swagger.json</code> 文件，但这个 JSON 文件是给机器看的，对人类并不友好。所以，还需要最后一步：<strong>展示</strong>。</p>
<p>这一步其实主要由两个我们之前安装的库来完成：</p>
<ol>
<li><p><strong><code>github.com/swaggo/files</code></strong><br>这个库里内置了 <strong>Swagger UI</strong> 的所有静态资源文件（HTML, CSS, JavaScript）。Swagger UI 是一个开源项目，它的唯一工作就是读取 OpenAPI 规范文件（比如我们的 <code>swagger.json</code>），并把它渲染成我们看到的那个漂亮的、可交互的网页。</p>
</li>
<li><p><strong><code>github.com/swaggo/gin-swagger</code></strong><br>这是一个适配器（Adapter），它的作用是把 Swagger UI 和 Gin 框架无缝地结合起来。我们在 <code>main.go</code> 里写的那行代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/swagger/*any&quot;</span>, ginSwagger.WrapHandler(swaggerFiles.Handler))</span><br></pre></td></tr></table></figure>

<p>它的意思就是：创建一个路由 <code>/swagger/</code>，当用户访问这个地址时，就由 <code>gin-swagger</code> 这个“中间人”来处理。它会负责加载 <code>swaggo/files</code> 里的 HTML 页面，并把我们生成的 <code>docs/swagger.json</code> 文件的内容喂给这个页面。</p>
</li>
</ol>
<p>于是，当你在浏览器里访问 <code>http://localhost:8080/swagger/index.html</code> 时：</p>
<ol>
<li>Gin 框架匹配到路由，请求被 <code>gin-swagger</code> 接管。</li>
<li><code>gin-swagger</code> 返回 Swagger UI 的主 HTML 页面。</li>
<li>浏览器加载这个 HTML 页面，页面里的 JavaScript 代码会去请求 <code>/swagger/doc.json</code> (这是 <code>gin-swagger</code> 自动配置的另一个内部路由)。</li>
<li><code>gin-swagger</code> 读取我们项目里 <code>docs/swagger.json</code> 文件的内容，并返回给浏览器。</li>
<li>Swagger UI 的 JavaScript 拿到 JSON 数据后，动态地在页面上渲染出所有的 API 列表、参数输入框、示例等等。</li>
</ol>
<p>至此，整个流程全部完成！</p>
<hr>
<h2 id="本章小结-4"><a href="#本章小结-4" class="headerlink" title="本章小结"></a><strong>本章小结</strong></h2><p>现在，我们再回头看 <code>swag</code>，它是不是清晰多了？</p>
<ul>
<li><p><strong><code>swag init</code> 命令做了什么？</strong></p>
<ol>
<li><strong>解析 (Parse)</strong>：使用 <code>go/ast</code> 解析 Go 源代码，找到 <code>@</code> 注解和它们关联的函数。</li>
<li><strong>生成 (Generate)</strong>：将解析到的信息，翻译成标准的 <code>swagger.json</code> 和 <code>swagger.yaml</code> 文件，并存放在 <code>docs</code> 目录。</li>
<li><strong>创建入口 (Create Entrypoint)</strong>：生成一个 <code>docs/docs.go</code> 文件，这个文件里包含了生成的 JSON&#x2F;YAML 数据，并注册自己，让 <code>gin-swagger</code> 这样的库能找到它。</li>
</ol>
</li>
<li><p><strong>程序运行时发生了什么？</strong></p>
<ol>
<li><code>gin-swagger</code> 负责创建一个路由。</li>
<li><code>swaggo/files</code> 提供了 Swagger UI 的静态页面。</li>
<li>当用户访问文档页时，<code>gin-swagger</code> 把 <code>docs/swagger.json</code> 的内容提供给 Swagger UI 的前端页面进行渲染。</li>
</ol>
</li>
</ul>
<p>理解了这个原理，你就能明白为什么每次修改了注解之后，都必须<strong>重新运行 <code>swag init</code></strong>。因为 <code>swagger.json</code> 文件不会自动更新，你必须手动触发这个“翻译和生成”的过程。</p>
<p>好了，原理我们已经搞懂了。在学习的最后，我将为你总结一些新手常遇到的“坑”以及一些最佳实践，帮助你在未来的使用中少走弯路。</p>
<p>好的，同学！我们已经到达了学习之旅的尾声。</p>
<p>你现在已经知道了 <code>swag</code> 是什么，怎么用，以及它背后的工作原理。可以说，你已经从一个“小白”成长为一名合格的 <code>swag</code> 使用者了。</p>
<p>但在实际的开发道路上，我们总会遇到一些小石子、小水坑。这一章，作为老师，我将把我的一些经验传授给你，帮你提前识别并绕开这些常见的“坑”，让你的 <code>swag</code> 之旅更加顺畅。</p>
<hr>
<h2 id="第6章：避坑指南：使用-Swag-的注意事项"><a href="#第6章：避坑指南：使用-Swag-的注意事项" class="headerlink" title="第6章：避坑指南：使用 Swag 的注意事项"></a><strong>第6章：避坑指南：使用 Swag 的注意事项</strong></h2><p>这一章更像是一份“温馨提示清单”。当你遇到问题时，不妨回来查阅一下，很可能答案就在这里。</p>
<h3 id="1-忘了这一步，一切都白费：swag-init"><a href="#1-忘了这一步，一切都白费：swag-init" class="headerlink" title="1. 忘了这一步，一切都白费：swag init"></a><strong>1. 忘了这一步，一切都白费：<code>swag init</code></strong></h3><ul>
<li><strong>现象</strong>：我明明在代码里改了注解，为什么刷新文档页面一点变化都没有？</li>
<li><strong>原因</strong>：这是99%的新手都会犯的错误。<code>swag</code> 不会实时监控你的代码变化。文档页面依赖的是 <code>docs</code> 目录下的 <code>swagger.json</code> 文件，而这个文件只有在你运行 <code>swag init</code> 命令时才会被更新。</li>
<li><strong>黄金法则</strong>：<strong>每次修改完任何 <code>@</code> 注解后，都必须重新在项目根目录下执行 <code>swag init</code> 命令。</strong></li>
<li><strong>进阶技巧</strong>：可以结合一些文件监控工具（如 <code>air</code>、<code>fresh</code> 等），配置成在 <code>.go</code> 文件保存时自动执行 <code>swag init</code>，实现自动化。</li>
</ul>
<hr>
<h3 id="2-神秘的-import"><a href="#2-神秘的-import" class="headerlink" title="2. 神秘的 import _ &quot;...&quot;"></a><strong>2. 神秘的 <code>import _ &quot;...&quot;</code></strong></h3><ul>
<li><p><strong>现象</strong>：我运行了 <code>swag init</code>，<code>docs</code> 目录也生成了，程序也能跑，但访问文档页时一片空白，或者提示 “Failed to load API definition.”。</p>
</li>
<li><p><strong>原因</strong>：<code>swag</code> 在生成 <code>docs/docs.go</code> 文件时，会使用一个 <code>init()</code> 函数来注册生成的 swagger 规范。为了让你的主程序能够执行到这个 <code>init()</code> 函数，你必须在你的 <code>main.go</code>（或者程序的入口文件）里匿名导入（<code>import _ &quot;...&quot;</code>）这个 <code>docs</code> 包。</p>
</li>
<li><p><strong>正确姿势</strong>：确保你的 <code>main.go</code> 中有下面这行代码，并且路径正确。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;my-swag-app/docs&quot;</span> </span><br><span class="line"><span class="comment">// &quot;my-swag-app&quot; 是你 go.mod 文件里定义的模块名</span></span><br></pre></td></tr></table></figure>

<p>匿名导入的 <code>_</code> 意味着：我不需要使用这个包里的任何变量或函数，我只是想让你这个包的代码被加载，从而执行它的 <code>init()</code> 函数。</p>
</li>
</ul>
<hr>
<h3 id="3-结构体（Struct）无法正确解析"><a href="#3-结构体（Struct）无法正确解析" class="headerlink" title="3. 结构体（Struct）无法正确解析"></a>3. 结构体（Struct）无法正确解析</h3><ul>
<li><p><strong>现象</strong>：我在 <code>@Success</code> 或 <code>@Param</code> 中引用了一个自定义的结构体，比如 <code>models.User</code>，但是在文档页面上，这个模型（Model）的字段显示不出来，或者是空的。</p>
</li>
<li><p><strong>原因与解决方案</strong>：</p>
<ol>
<li><p><strong>没有写 <code>json</code> 标签</strong>：<code>swag</code> 默认通过 <code>json:&quot;...&quot;</code> 标签来识别字段名。请确保你的结构体字段都有这个标签。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID <span class="type">int</span> <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字段是私有的</strong>：Go 语言中，首字母小写的字段是包内私有的，<code>swag</code> 无法在外部解析它们。请确保所有需要展示在文档中的字段名<strong>首字母大写</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="type">int</span> <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID <span class="type">int</span> <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用了其他包的结构体</strong>：如果你的结构体引用了来自其他第三方库的结构体，<code>swag</code> 可能无法解析它。解决方法是创建一个新的、你自己的结构体（有时称为 DTO - Data Transfer Object），只包含你需要的字段，然后在你的处理函数中进行数据转换。</p>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-Param-和-Router-的路径参数不匹配"><a href="#4-Param-和-Router-的路径参数不匹配" class="headerlink" title="4. @Param 和 @Router 的路径参数不匹配"></a><strong>4. <code>@Param</code> 和 <code>@Router</code> 的路径参数不匹配</strong></h3><ul>
<li><p><strong>现象</strong>：定义了路径参数，但在文档里无法正确渲染，或者在线调试时参数没有传递。</p>
</li>
<li><p><strong>原因</strong>：<code>@Param</code> 注解中定义的路径参数名，必须和 <code>@Router</code> 注解中的占位符完全一致。</p>
</li>
<li><p><strong>正确姿势</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Param   userID   path      int  true  &quot;用户 ID&quot;</span></span><br><span class="line"><span class="comment">// @Router /users/&#123;userID&#125; [get] </span></span><br><span class="line"><span class="comment">// 这里都是 userID，保持一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误姿势</span></span><br><span class="line"><span class="comment">// @Param   id   path      int  true  &quot;用户 ID&quot;</span></span><br><span class="line"><span class="comment">// @Router /users/&#123;userID&#125; [get] </span></span><br><span class="line"><span class="comment">// 一个是 id，一个是 userID，不匹配，会出错</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="5-全局注解（main-函数上方）到底写在哪？"><a href="#5-全局注解（main-函数上方）到底写在哪？" class="headerlink" title="5. 全局注解（main 函数上方）到底写在哪？"></a><strong>5. 全局注解（<code>main</code> 函数上方）到底写在哪？</strong></h3><ul>
<li><strong>规定</strong>：<code>swag</code> 会扫描整个项目来寻找 API 注解（写在 <code>Handler</code> 函数上的），但<strong>全局注解只会寻找 <code>main</code> 包</strong>（也就是包含 <code>func main()</code> 的那个文件）里的注释。</li>
<li><strong>最佳实践</strong>：始终将 <code>@title</code>, <code>@version</code>, <code>@host</code> 等全局注解写在 <code>main.go</code> 文件中 <code>main</code> 函数的上方。不要把它们放在其他文件里，否则 <code>swag</code> 会找不到。</li>
</ul>
<hr>
<h3 id="6-文档部署到服务器上访问不了？——-host-和-BasePath-的重要性"><a href="#6-文档部署到服务器上访问不了？——-host-和-BasePath-的重要性" class="headerlink" title="6. 文档部署到服务器上访问不了？—— @host 和 @BasePath 的重要性"></a><strong>6. 文档部署到服务器上访问不了？—— <code>@host</code> 和 <code>@BasePath</code> 的重要性</strong></h3><ul>
<li><p><strong>现象</strong>：文档在本地 <code>localhost:8080</code> 访问完全正常，但部署到服务器上（比如 <code>api.mydomain.com/v1</code>）之后，在线调试功能 (“Try it out”) 点击 “Execute” 没反应，或者请求的地址不对。</p>
</li>
<li><p><strong>原因</strong>：<code>swag</code> 文档页面里的调试工具，会根据 <code>@host</code> 和 <code>@BasePath</code> 来拼接最终的请求 URL。如果你这里写的是 <code>localhost:8080</code>，那无论你在哪里访问这个文档，它都会往 <code>localhost:8080</code> 发请求。</p>
</li>
<li><p><strong>部署时的正确配置</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @host      api.mydomain.com</span></span><br><span class="line"><span class="comment">// @BasePath  /v1</span></span><br></pre></td></tr></table></figure>

<p>这样配置后，<code>swag</code> 生成的文档在调用 <code>/users/{id}</code> 这个 API 时，就会正确地请求 <code>http://api.mydomain.com/v1/users/{id}</code>。</p>
</li>
<li><p><strong>动态配置</strong>：在不同的环境（开发、测试、生产）中，<code>host</code> 可能会不同。你可以考虑使用 <code>swag</code> 的一些高级功能，或者编写脚本，在持续集成&#x2F;持续部署（CI&#x2F;CD）流程中动态地修改这些注解或生成的 <code>swagger.json</code> 文件。</p>
</li>
</ul>
<hr>
<h3 id="本章小结-5"><a href="#本章小结-5" class="headerlink" title="本章小结"></a><strong>本章小结</strong></h3><p>我们总结了几个最常见的新手问题和注意事项：</p>
<ol>
<li><strong>改完注解，必跑 <code>swag init</code></strong>。</li>
<li><strong>检查 <code>main.go</code> 是否有 <code>import _ &quot;...&quot;</code></strong>。</li>
<li><strong>结构体字段必须首字母大写，并有 <code>json</code> 标签</strong>。</li>
<li><strong><code>@Param</code> 和 <code>@Router</code> 的路径参数名要一致</strong>。</li>
<li><strong>全局注解写在 <code>main</code> 函数之上</strong>。</li>
<li><strong>部署时，正确配置 <code>@host</code> 和 <code>@BasePath</code></strong>。</li>
</ol>
<p>记住这些，可以帮你节省大量的调试时间。现在，我们来进行最后的内容总结，并展望一下未来。</p>
<p>经过前面六个章节的学习和实践，你已经从一个对 <code>swag</code> 毫无概念的小白，成长为一名能够独立使用它来为 Go 项目生成专业 API 文档的开发者了。</p>
<p>现在，让我们一起花几分钟时间，回顾一下我们走过的路，并看看前方的风景。</p>
<hr>
<h2 id="第7章：总结与下一步"><a href="#第7章：总结与下一步" class="headerlink" title="第7章：总结与下一步"></a><strong>第7章：总结与下一步</strong></h2><h3 id="7-1-我们的学习回顾（我们学到了什么？）"><a href="#7-1-我们的学习回顾（我们学到了什么？）" class="headerlink" title="7.1 我们的学习回顾（我们学到了什么？）"></a><strong>7.1 我们的学习回顾（我们学到了什么？）</strong></h3><p>让我们像看电影回放一样，快速过一遍本次学习的核心要点：</p>
<ul>
<li><p><strong>问题的起源（第1章）</strong>：我们明白了为什么需要 API 文档，以及手动维护文档是多么痛苦。这是我们学习 <code>swag</code> 的根本动机——<strong>自动化，让代码与文档同步</strong>。</p>
</li>
<li><p><strong>Swag 的真面目（第2章）</strong>：我们认识了 <code>swag</code>，知道它是一个能将 Go 代码中的<strong>特殊注释</strong>，自动转换为<strong>交互式 API 网页</strong>的“魔法”工具。这个网页不仅好看，还能在线调试。</p>
</li>
<li><p><strong>第一次亲密接触（第3章）</strong>：我们亲手实践了 <code>swag</code> 的三步走核心流程：<strong>安装工具 -&gt; 添加注解 -&gt; 运行 <code>swag init</code> 生成文档</strong>。你成功生成了人生中第一个由代码自动生成的 API 文档！</p>
</li>
<li><p><strong>“魔法咒语”大全（第4章）</strong>：我们深入学习了 <code>swag</code> 的各种注解，如 <code>@Summary</code>, <code>@Tags</code>, <code>@Param</code>, <code>@Success</code>, <code>@Router</code> 等，并学会了如何使用它们来精确描述一个 API 的方方面面，包括如何引用自定义的结构体。</p>
</li>
<li><p><strong>揭开魔法的面纱（第5章）</strong>：我们探究了 <code>swag</code> 的工作原理，了解到它并非魔法，而是一个<strong>代码解析器</strong> + <strong>OpenAPI 规范生成器</strong>。这个过程让我们知其然，更知其所以然。</p>
</li>
<li><p><strong>前人的智慧（第6章）</strong>：我们总结了新手在使用 <code>swag</code> 时最容易遇到的几个“坑”，比如忘记运行 <code>swag init</code>、匿名导入路径错误等，为未来的实战扫清了障碍。</p>
</li>
</ul>
<p>到此，你已经构建起了一个关于 <code>swag</code> 的完整知识体系。恭喜你，你已经掌握了一项能极大提升开发效率和团队协作质量的实用技能！</p>
<hr>
<h3 id="7-2-知识的延伸（接下来可以学什么？）"><a href="#7-2-知识的延伸（接下来可以学什么？）" class="headerlink" title="7.2 知识的延伸（接下来可以学什么？）"></a><strong>7.2 知识的延伸（接下来可以学什么？）</strong></h3><p>学习永无止境。当你熟练掌握了 <code>swag</code> 的基础用法后，你可能还想探索更多，这里我为你指出几个可以继续深入的方向：</p>
<ol>
<li><p><strong>深入 OpenAPI 规范</strong>：<br><code>swag</code> 只是一个生成器，它所遵循的 <strong>OpenAPI 规范</strong>才是 API 描述领域的核心。花一点时间去阅读 OpenAPI 3.0 的官方文档，你会对 API 设计有更深刻的理解，也能解锁 <code>swag</code> 注解中更多高级的用法（比如定义安全策略 <code>Security</code>、组件 <code>Components</code> 等）。</p>
</li>
<li><p><strong>探索更复杂的注解</strong>：<br>我们这次学习主要覆盖了最常用的注解。<code>swag</code> 还支持更多高级注解，例如：</p>
<ul>
<li><code>@Security</code>: 用于定义 API 的认证方式，比如 JWT Token, API Key, OAuth2 等。</li>
<li><code>@Accept</code> &#x2F; <code>@Produce</code>: 除了 <code>json</code>，还支持 <code>xml</code>, <code>html</code>, <code>plain</code> 等多种格式。</li>
<li><code>@Example</code>: 为请求体或响应体提供更具体的示例。</li>
</ul>
</li>
<li><p><strong>自动化 <code>swag init</code></strong>：<br>在实际项目中，每次修改都手动运行 <code>swag init</code> 还是有些繁琐。你可以研究一下如何将其集成到你的开发流程中。比如使用 <code>air</code> 这个 Go 的热重载工具，在配置文件中添加一条命令，让它在监控到 <code>.go</code> 文件变化时，自动帮你执行 <code>swag init</code>。</p>
</li>
<li><p><strong>尝试其他 Go Web 框架</strong>：<br>我们这次课程用的是 <code>Gin</code> 框架。<code>swag</code> 社区也为其他流行的 Go 框架提供了适配器，比如 <code>Echo</code>, <code>Fiber</code>, <code>Chi</code> 等。你可以尝试在不同的框架中使用 <code>swag</code>，加深理解。</p>
</li>
</ol>
<hr>
<h3 id="7-3-最后的叮嘱"><a href="#7-3-最后的叮嘱" class="headerlink" title="7.3 最后的叮嘱"></a><strong>7.3 最后的叮嘱</strong></h3><p>同学，工具是为人服务的。<code>swag</code> 的价值不仅仅在于生成一份漂亮的文档，更在于它背后所倡导的一种**“文档驱动”<strong>或</strong>“代码即文档”**的开发理念。</p>
<p>养成在写代码的同时，就写好注解的习惯，这会让你未来的自己和你的同事都感激不尽。一份清晰、准确、永远与代码同步的 API 文档，是专业软件项目中不可或缺的一环。</p>
<p>希望这次学习笔记能真正帮助到你。如果在未来的学习和工作中遇到任何问题，随时都可以回来复习。</p>
<p><strong>现在，合上笔记，去你的项目中，开始享受 <code>swag</code> 带来的便捷和快乐吧！</strong></p>
<p><strong>祝你编程愉快！</strong></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="Swagger-注解参考与实战模板（Swag-for-Go）"><a href="#Swagger-注解参考与实战模板（Swag-for-Go）" class="headerlink" title="Swagger 注解参考与实战模板（Swag for Go）"></a>Swagger 注解参考与实战模板（Swag for Go）</h2><blockquote>
<p>适用于 <code>github.com/swaggo/swag</code> + <code>github.com/swaggo/gin-swagger</code><br>文件可直接放入项目 <code>/docs/</code> 目录供开发参考。</p>
</blockquote>
<hr>
<h3 id="一、常用注解说明表（带调用示例）"><a href="#一、常用注解说明表（带调用示例）" class="headerlink" title="一、常用注解说明表（带调用示例）"></a>一、常用注解说明表（带调用示例）</h3><table>
<thead>
<tr>
<th>注解名</th>
<th>作用</th>
<th>常用位置</th>
<th>说明</th>
<th>示例注解</th>
<th>API 调用示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>@Summary</strong></td>
<td>接口简要描述</td>
<td>函数顶部</td>
<td>展示在 Swagger UI 接口列表中</td>
<td><code>// @Summary 获取用户信息</code></td>
<td>——</td>
</tr>
<tr>
<td><strong>@Description</strong></td>
<td>接口详细描述</td>
<td>函数顶部</td>
<td>可多行描述细节、约束等</td>
<td><code>// @Description 根据用户ID查询详细资料</code></td>
<td>——</td>
</tr>
<tr>
<td><strong>@Tags</strong></td>
<td>接口分组</td>
<td>函数顶部</td>
<td>Swagger 左侧菜单分组</td>
<td><code>// @Tags 用户管理</code></td>
<td>——</td>
</tr>
<tr>
<td><strong>@Accept</strong></td>
<td>接收类型</td>
<td>函数顶部</td>
<td><code>json</code>, <code>multipart/form-data</code>, <code>x-www-form-urlencoded</code> 等</td>
<td><code>// @Accept json</code></td>
<td>——</td>
</tr>
<tr>
<td><strong>@Produce</strong></td>
<td>响应类型</td>
<td>函数顶部</td>
<td><code>json</code>, <code>xml</code>, <code>plain</code> 等</td>
<td><code>// @Produce json</code></td>
<td>——</td>
</tr>
<tr>
<td><strong>@Param (query)</strong></td>
<td>URL 查询参数</td>
<td>函数顶部</td>
<td><code>@Param name query string true &quot;用户名&quot;</code>，<code>true</code>为必填，<code>false</code>为可选</td>
<td><code>// @Param name query string true &quot;用户名&quot;</code></td>
<td><code>GET /api/user?name=Tom</code></td>
</tr>
<tr>
<td><strong>@Param (path)</strong></td>
<td>路径参数</td>
<td>函数顶部</td>
<td>URL 占位符参数（REST 风格），必填（一般必须为 <code>true</code>，因为路径里必须有值）</td>
<td><code>// @Param id path int true &quot;用户ID&quot;</code></td>
<td><code>GET /api/user/123</code></td>
</tr>
<tr>
<td><strong>@Param (header)</strong></td>
<td>Header 参数</td>
<td>函数顶部</td>
<td>适合传 Token 或版本号，<code>true</code>为必填，<code>false</code>为可选</td>
<td><code>// @Param Authorization header string true &quot;Bearer Token&quot;</code></td>
<td><code>curl -H &quot;Authorization: Bearer XXX&quot; ...</code></td>
</tr>
<tr>
<td><strong>@Param (formData)</strong></td>
<td>表单参数</td>
<td>函数顶部</td>
<td>用于 <code>POST</code> 的表单数据，<code>true</code>为必填，<code>false</code>为可选</td>
<td><code>// @Param username formData string true &quot;用户名&quot;</code></td>
<td><code>POST /login  (username=Tom&amp;password=123)</code></td>
</tr>
<tr>
<td><strong>@Param (file)</strong></td>
<td>文件上传参数</td>
<td>函数顶部</td>
<td><code>multipart/form-data</code>，<code>true</code>为必填，<code>false</code>为可选</td>
<td><code>// @Param file formData file true &quot;上传文件&quot;</code></td>
<td><code>curl -F &quot;file=@avatar.png&quot; /upload/avatar</code></td>
</tr>
<tr>
<td><strong>@Param (body)</strong></td>
<td>JSON 请求体</td>
<td>函数顶部</td>
<td>用于 POST&#x2F;PUT 请求体，<code>true</code>为必填，<code>false</code>为可选</td>
<td><code>// @Param data body User true &quot;用户信息&quot;</code></td>
<td><code>POST /user {&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:18}</code></td>
</tr>
<tr>
<td><strong>@Param (cookie)</strong></td>
<td>Cookie 参数</td>
<td>函数顶部</td>
<td>从 cookie 读取数据，<code>true</code>为必填，<code>false</code>为可选</td>
<td><code>// @Param session cookie string false &quot;Session ID&quot;</code></td>
<td><code>Cookie: session=abcd1234</code></td>
</tr>
<tr>
<td><strong>@Success</strong></td>
<td>成功返回</td>
<td>函数顶部</td>
<td>定义返回结构体与 HTTP 码</td>
<td><code>// @Success 200 {object} User &quot;返回用户信息&quot;</code></td>
<td>响应体：<code>{&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;}</code></td>
</tr>
<tr>
<td><strong>@Failure</strong></td>
<td>失败返回</td>
<td>函数顶部</td>
<td>描述错误信息结构体</td>
<td><code>// @Failure 400 {object} ErrorResponse &quot;参数错误&quot;</code></td>
<td>响应体：<code>{&quot;code&quot;:400,&quot;msg&quot;:&quot;invalid&quot;}</code></td>
</tr>
<tr>
<td><strong>@Router</strong></td>
<td>路由定义</td>
<td>函数顶部</td>
<td>指定接口路径与方法</td>
<td><code>// @Router /user/{id} [get]</code></td>
<td><code>GET /user/123</code></td>
</tr>
<tr>
<td><strong>@Security</strong></td>
<td>鉴权机制</td>
<td>函数顶部</td>
<td>对应 securityDefinitions</td>
<td><code>// @Security ApiKeyAuth</code></td>
<td><code>curl -H &quot;Authorization: Bearer TOKEN&quot; ...</code></td>
</tr>
<tr>
<td><strong>@Deprecated</strong></td>
<td>废弃标记</td>
<td>函数顶部</td>
<td>标记接口为过时</td>
<td><code>// @Deprecated</code></td>
<td>——</td>
</tr>
</tbody></table>
<hr>
<h3 id="二、-Param-类型详细表（含请求示例）"><a href="#二、-Param-类型详细表（含请求示例）" class="headerlink" title="二、@Param 类型详细表（含请求示例）"></a>二、@Param 类型详细表（含请求示例）</h3><table>
<thead>
<tr>
<th>类型</th>
<th>用途</th>
<th>数据类型</th>
<th>示例注解</th>
<th>API 请求示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>query</code></td>
<td>URL 参数</td>
<td>string&#x2F;int&#x2F;bool</td>
<td><code>@Param user_id query int true &quot;用户ID&quot;</code></td>
<td><code>/user?user_id=1</code></td>
</tr>
<tr>
<td><code>path</code></td>
<td>路径参数</td>
<td>string&#x2F;int</td>
<td><code>@Param id path int true &quot;用户ID&quot;</code></td>
<td><code>/user/1</code></td>
</tr>
<tr>
<td><code>header</code></td>
<td>请求头</td>
<td>string</td>
<td><code>@Param Authorization header string true &quot;Token&quot;</code></td>
<td><code>curl -H &quot;Authorization: Bearer abc&quot;</code></td>
</tr>
<tr>
<td><code>formData</code></td>
<td>表单数据</td>
<td>string&#x2F;int</td>
<td><code>@Param username formData string true &quot;用户名&quot;</code></td>
<td><code>curl -d &quot;username=Tom&quot;</code></td>
</tr>
<tr>
<td><code>formData(file)</code></td>
<td>上传文件</td>
<td>file</td>
<td><code>@Param file formData file true &quot;上传头像&quot;</code></td>
<td><code>curl -F &quot;file=@a.png&quot;</code></td>
</tr>
<tr>
<td><code>body</code></td>
<td>JSON 请求体</td>
<td>object</td>
<td><code>@Param data body User true &quot;用户信息&quot;</code></td>
<td><code>curl -X POST -d &#39;{&quot;name&quot;:&quot;Tom&quot;}&#39;</code></td>
</tr>
<tr>
<td><code>cookie</code></td>
<td>Cookie</td>
<td>string</td>
<td><code>@Param session cookie string false &quot;Session ID&quot;</code></td>
<td><code>Cookie: session=abcd</code></td>
</tr>
</tbody></table>
<h3 id="三、-Success-Failure-的-类型-参数"><a href="#三、-Success-Failure-的-类型-参数" class="headerlink" title="三、@Success &#x2F; @Failure 的 {类型} 参数"></a>三、<code>@Success</code> &#x2F; <code>@Failure</code> 的 <code>{类型}</code> 参数</h3><h4 id="Success-Failure-的-类型-参数支持哪些格式？"><a href="#Success-Failure-的-类型-参数支持哪些格式？" class="headerlink" title="@Success &#x2F; @Failure 的 {类型} 参数支持哪些格式？"></a><code>@Success</code> &#x2F; <code>@Failure</code> 的 <code>{类型}</code> 参数支持哪些格式？</h4><p>在 <code>swaggo</code>（<code>github.com/swaggo/swag</code>）中，<code>@Success</code> &#x2F; <code>@Failure</code> 注解的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Success &lt;HTTP状态码&gt; &#123;&lt;类型&gt;&#125; &lt;数据模型&gt; &quot;&lt;描述&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>其中 <code>{&lt;类型&gt;}</code> 是用于 <strong>描述响应数据结构的</strong>，常见取值如下：</p>
<table>
<thead>
<tr>
<th><code>{类型}</code></th>
<th>含义</th>
<th>适用场景</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>object对象</strong></td>
<td>返回的是结构体对象（JSON 对象）</td>
<td>最常见，接口返回 JSON 时通常是这个</td>
<td><code>// @Success 200 {object} models.LoginResp</code></td>
</tr>
<tr>
<td><strong>array数组</strong></td>
<td>返回的是数组（JSON 数组）</td>
<td>列表、分页等场景</td>
<td><code>// @Success 200 {array} models.UserResp</code></td>
</tr>
<tr>
<td><strong>string字符串</strong></td>
<td>返回纯文本字符串</td>
<td>错误提示、状态文本等</td>
<td><code>// @Failure 500 {string} string &quot;内部错误&quot;</code></td>
</tr>
<tr>
<td><strong>integer整型</strong></td>
<td>返回纯数值（整数）</td>
<td>简单的状态码或数量</td>
<td><code>// @Success 200 {integer} int &quot;成功状态码&quot;</code></td>
</tr>
<tr>
<td><strong>number数字</strong></td>
<td>返回浮点数</td>
<td>例如温度、坐标等</td>
<td><code>// @Success 200 {number} float64 &quot;测量值&quot;</code></td>
</tr>
<tr>
<td><strong>boolean布尔</strong></td>
<td>返回 true&#x2F;false 布尔值</td>
<td>状态检查类接口</td>
<td><code>// @Success 200 {boolean} bool &quot;是否在线&quot;</code></td>
</tr>
<tr>
<td><strong>file文件</strong></td>
<td>返回文件（二进制流）</td>
<td>文件下载接口</td>
<td><code>// @Success 200 {file} file &quot;导出的Excel文件&quot;</code></td>
</tr>
</tbody></table>
<hr>
<h4 id="如果你的接口返回-JSON-——-应该用-object-或-array-，而不是-string"><a href="#如果你的接口返回-JSON-——-应该用-object-或-array-，而不是-string" class="headerlink" title="如果你的接口返回 JSON —— 应该用 {object} 或 {array}，而不是 {string}"></a>如果你的接口返回 JSON —— 应该用 <code>{object}</code> 或 <code>{array}</code>，而不是 <code>{string}</code></h4><p>这是最关键的一点：</p>
<blockquote>
<p>⚠️ 即使你的响应是 “JSON 字符串格式”，也应该写 <code>{object}</code>，因为 swagger 的目的不是展示原始传输内容，而是展示数据结构。</p>
</blockquote>
<p>举例说明：</p>
<p>假设接口返回：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ok&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;user_id&quot;</span><span class="punctuation">:</span> <span class="number">123</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Tom&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>你应该写成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// @Success 200 &#123;object&#125; models.CommonResp &quot;请求成功&quot;</span><br></pre></td></tr></table></figure>

<p>而不是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ❌ 错误：这样 swagger 只会认为是纯文本</span><br><span class="line">// @Success 200 &#123;string&#125; string &quot;返回JSON字符串&quot;</span><br></pre></td></tr></table></figure>

<p>因为 <code>{string}</code> 告诉 swagger：返回的是纯文本，而 swagger UI 就不会解析字段结构，也不会显示字段说明。</p>
<hr>
<h4 id="几个常见的写法对比表"><a href="#几个常见的写法对比表" class="headerlink" title="几个常见的写法对比表"></a>几个常见的写法对比表</h4><table>
<thead>
<tr>
<th>返回内容</th>
<th>推荐写法</th>
<th>错误写法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>JSON 对象（结构体）</td>
<td><code>{object} models.Resp</code></td>
<td><code>{string} string</code></td>
<td>应描述结构体，而非字符串</td>
</tr>
<tr>
<td>JSON 数组</td>
<td><code>{array} models.Item</code></td>
<td><code>{string} string</code></td>
<td>swagger 会显示为数组元素类型</td>
</tr>
<tr>
<td>普通字符串</td>
<td><code>{string} string</code></td>
<td><code>{object}</code></td>
<td>简单文本响应</td>
</tr>
<tr>
<td>文件流</td>
<td><code>{file} file</code></td>
<td><code>{object}</code></td>
<td>特殊响应类型（下载）</td>
</tr>
</tbody></table>
<hr>
<h4 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// @Summary 登录接口</span><br><span class="line">// @Description 用户通过账号密码登录</span><br><span class="line">// @Tags 用户</span><br><span class="line">// @Accept json</span><br><span class="line">// @Produce json</span><br><span class="line">// @Param data body models.LoginReq true &quot;登录请求体&quot;</span><br><span class="line">// @Success 200 &#123;object&#125; models.LoginResp &quot;登录成功&quot;</span><br><span class="line">// @Failure 400 &#123;object&#125; models.ErrorResp &quot;请求错误&quot;</span><br><span class="line">// @Failure 500 &#123;string&#125; string &quot;服务器内部错误&quot;</span><br><span class="line">// @Router /api/v1/login [post]</span><br><span class="line">func Login(c *gin.Context) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="小结一句话记住："><a href="#小结一句话记住：" class="headerlink" title="小结一句话记住："></a>小结一句话记住：</h4><table>
<thead>
<tr>
<th>返回类型</th>
<th>对应 swagger 类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Go 结构体 &#x2F; map</td>
<td><code>{object}</code></td>
<td>最常用</td>
</tr>
<tr>
<td>Go 切片 &#x2F; 数组</td>
<td><code>{array}</code></td>
<td>✅</td>
</tr>
<tr>
<td>Go stringGo 字符串</td>
<td><code>{string}</code></td>
<td>✅</td>
</tr>
<tr>
<td>Go int &#x2F; int64Go int &#x2F; int64 整数 &#x2F; 整数 64</td>
<td><code>{integer}</code></td>
<td>✅</td>
</tr>
<tr>
<td>Go float32 &#x2F; float64</td>
<td><code>{number}</code></td>
<td>✅</td>
</tr>
<tr>
<td>Go boolGo 布尔</td>
<td><code>{boolean}</code></td>
<td>✅</td>
</tr>
<tr>
<td>文件下载</td>
<td><code>{file}</code></td>
<td>✅</td>
</tr>
</tbody></table>
<hr>
<h3 id="三、结构体定义示例"><a href="#三、结构体定义示例" class="headerlink" title="三、结构体定义示例"></a>三、结构体定义示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type User struct &#123;</span><br><span class="line">    ID   int    `json:&quot;id&quot; example:&quot;1&quot;`</span><br><span class="line">    Name string `json:&quot;name&quot; example:&quot;Tom&quot;`</span><br><span class="line">    Age  int    `json:&quot;age&quot; example:&quot;25&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ErrorResponse struct &#123;</span><br><span class="line">    Code int    `json:&quot;code&quot; example:&quot;400&quot;`</span><br><span class="line">    Msg  string `json:&quot;msg&quot; example:&quot;参数错误&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="四、接口模板（全部注解示例）"><a href="#四、接口模板（全部注解示例）" class="headerlink" title="四、接口模板（全部注解示例）"></a>四、接口模板（全部注解示例）</h3><h4 id="获取用户信息（GET-Path）"><a href="#获取用户信息（GET-Path）" class="headerlink" title="获取用户信息（GET + Path）"></a>获取用户信息（GET + Path）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// @Summary 获取用户信息</span><br><span class="line">// @Description 通过用户ID获取详细信息</span><br><span class="line">// @Tags 用户管理</span><br><span class="line">// @Accept json</span><br><span class="line">// @Produce json</span><br><span class="line">// @Param id path int true &quot;用户ID&quot;</span><br><span class="line">// @Param token header string false &quot;访问令牌&quot;</span><br><span class="line">// @Success 200 &#123;object&#125; User &quot;用户信息&quot;</span><br><span class="line">// @Failure 400 &#123;object&#125; ErrorResponse &quot;参数错误&quot;</span><br><span class="line">// @Failure 404 &#123;object&#125; ErrorResponse &quot;用户不存在&quot;</span><br><span class="line">// @Router /user/&#123;id&#125; [get]</span><br><span class="line">func GetUser(c *gin.Context) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">// 调用示例：</span><br><span class="line">// GET ./user/123</span><br><span class="line">// Header: Authorization: Bearer TOKEN</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="创建用户（POST-Body）"><a href="#创建用户（POST-Body）" class="headerlink" title="创建用户（POST + Body）"></a>创建用户（POST + Body）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// @Summary 创建新用户</span><br><span class="line">// @Description 使用 JSON 提交用户数据</span><br><span class="line">// @Tags 用户管理</span><br><span class="line">// @Accept json</span><br><span class="line">// @Produce json</span><br><span class="line">// @Param data body User true &quot;用户信息&quot;</span><br><span class="line">// @Success 201 &#123;object&#125; User &quot;创建成功&quot;</span><br><span class="line">// @Failure 400 &#123;object&#125; ErrorResponse &quot;参数错误&quot;</span><br><span class="line">// @Router /user [post]</span><br><span class="line">func CreateUser(c *gin.Context) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">// 调用示例：</span><br><span class="line">// POST ./user</span><br><span class="line">// Body: &#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:25&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="用户登录（POST-FormData）"><a href="#用户登录（POST-FormData）" class="headerlink" title="用户登录（POST + FormData）"></a>用户登录（POST + FormData）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// @Summary 用户登录</span><br><span class="line">// @Description 表单提交方式登录</span><br><span class="line">// @Tags 登录认证</span><br><span class="line">// @Accept x-www-form-urlencoded</span><br><span class="line">// @Produce json</span><br><span class="line">// @Param username formData string true &quot;用户名&quot;</span><br><span class="line">// @Param password formData string true &quot;密码&quot;</span><br><span class="line">// @Success 200 &#123;string&#125; string &quot;登录成功&quot;</span><br><span class="line">// @Failure 401 &#123;object&#125; ErrorResponse &quot;用户名或密码错误&quot;</span><br><span class="line">// @Router /login [post]</span><br><span class="line">func Login(c *gin.Context) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">// 调用示例：</span><br><span class="line">// POST ./login</span><br><span class="line">// Body: username=Tom&amp;password=123456</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="上传头像（POST-File）"><a href="#上传头像（POST-File）" class="headerlink" title="上传头像（POST + File）"></a>上传头像（POST + File）</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Summary 上传头像</span></span><br><span class="line"><span class="comment">// @Description 上传用户头像文件</span></span><br><span class="line"><span class="comment">// @Tags 文件上传</span></span><br><span class="line"><span class="comment">// @Accept multipart/form-data</span></span><br><span class="line"><span class="comment">// @Produce json</span></span><br><span class="line"><span class="comment">// @Param user_id formData int true &quot;用户ID&quot;</span></span><br><span class="line"><span class="comment">// @Param file formData file true &quot;头像文件&quot;</span></span><br><span class="line"><span class="comment">// @Success 200 &#123;string&#125; string &quot;上传成功&quot;</span></span><br><span class="line"><span class="comment">// @Failure 400 &#123;object&#125; ErrorResponse &quot;文件无效&quot;</span></span><br><span class="line"><span class="comment">// @Router /upload/avatar [post]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UploadAvatar</span><span class="params">(c *gin.Context)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用示例：</span></span><br><span class="line"><span class="comment">// curl -F &quot;user_id=1&quot; -F &quot;file=@avatar.png&quot; ./upload/avatar</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="带鉴权接口（Header-Security）"><a href="#带鉴权接口（Header-Security）" class="headerlink" title="带鉴权接口（Header + Security）"></a>带鉴权接口（Header + Security）</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Summary 获取当前用户资料</span></span><br><span class="line"><span class="comment">// @Description 需要登录并携带 Bearer Token</span></span><br><span class="line"><span class="comment">// @Tags 用户资料</span></span><br><span class="line"><span class="comment">// @Security ApiKeyAuth</span></span><br><span class="line"><span class="comment">// @Accept json</span></span><br><span class="line"><span class="comment">// @Produce json</span></span><br><span class="line"><span class="comment">// @Param Authorization header string true &quot;Bearer Token&quot;</span></span><br><span class="line"><span class="comment">// @Success 200 &#123;object&#125; User &quot;用户信息&quot;</span></span><br><span class="line"><span class="comment">// @Failure 401 &#123;object&#125; ErrorResponse &quot;未授权&quot;</span></span><br><span class="line"><span class="comment">// @Router /profile [get]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetProfile</span><span class="params">(c *gin.Context)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用示例：</span></span><br><span class="line"><span class="comment">// GET ./profile</span></span><br><span class="line"><span class="comment">// Header: Authorization: Bearer eyJhbGci...</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Cookie-示例接口"><a href="#Cookie-示例接口" class="headerlink" title="Cookie 示例接口"></a>Cookie 示例接口</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Summary 检查用户会话</span></span><br><span class="line"><span class="comment">// @Description 根据 Cookie 中的 session 判断是否登录</span></span><br><span class="line"><span class="comment">// @Tags 登录认证</span></span><br><span class="line"><span class="comment">// @Accept json</span></span><br><span class="line"><span class="comment">// @Produce json</span></span><br><span class="line"><span class="comment">// @Param session cookie string false &quot;Session ID&quot;</span></span><br><span class="line"><span class="comment">// @Success 200 &#123;string&#125; string &quot;Session 有效&quot;</span></span><br><span class="line"><span class="comment">// @Failure 401 &#123;string&#125; string &quot;未登录&quot;</span></span><br><span class="line"><span class="comment">// @Router /session/check [get]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckSession</span><span class="params">(c *gin.Context)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用示例：</span></span><br><span class="line"><span class="comment">// GET ./session/check</span></span><br><span class="line"><span class="comment">// Cookie: session=abc123</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="五、Swagger-安全认证定义示例（在-docs-init-go-中）"><a href="#五、Swagger-安全认证定义示例（在-docs-init-go-中）" class="headerlink" title="五、Swagger 安全认证定义示例（在 docs&#x2F;init.go 中）"></a>五、Swagger 安全认证定义示例（在 docs&#x2F;init.go 中）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// @securityDefinitions.apikey ApiKeyAuth</span><br><span class="line">// @in header</span><br><span class="line">// @name Authorization</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h3><table>
<thead>
<tr>
<th>常见场景</th>
<th>推荐注解组合</th>
<th>示例路径</th>
</tr>
</thead>
<tbody><tr>
<td>GET 查询</td>
<td><code>@Param query/path</code> + <code>@Success</code></td>
<td><code>/user/{id}</code></td>
</tr>
<tr>
<td>POST 创建</td>
<td><code>@Param body</code> + <code>@Accept json</code></td>
<td><code>/user</code></td>
</tr>
<tr>
<td>表单提交</td>
<td><code>@Param formData</code> + <code>@Accept x-www-form-urlencoded</code></td>
<td><code>/login</code></td>
</tr>
<tr>
<td>文件上传</td>
<td><code>@Param file formData file</code> + <code>@Accept multipart/form-data</code></td>
<td><code>/upload/avatar</code></td>
</tr>
<tr>
<td>认证接口</td>
<td><code>@Security ApiKeyAuth</code> + <code>@Param header</code></td>
<td><code>/profile</code></td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chaoqijiang.github.io">棨</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chaoqijiang.github.io/2025/10/08/Golang_swag/">https://chaoqijiang.github.io/2025/10/08/Golang_swag/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://chaoqijiang.github.io" target="_blank">柊</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">使用教程</a><a class="post-meta__tags" href="/tags/AI/">AI</a><a class="post-meta__tags" href="/tags/protected/">protected</a><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/%E4%B8%89%E6%96%B9%E5%BA%93/">三方库</a><a class="post-meta__tags" href="/tags/swag/">swag</a></div><div class="post-share"><div class="social-share" data-image="/Image/avatar.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/10/06/Golang_validator/" title="Golang validator 库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Golang validator 库</div></div><div class="info-2"><div class="info-item-1">主要讲解如何在Go中使用validator库进行数据验证。通过一系列章节，你将学会如何使用validator库来确保你的数据符合预期。从基本的验证规则到自定义的验证函数，再到处理错误信息的高级技巧，本教程将带你一步步深入学习。validator 是一个非常强大的库，它可以帮助你确保你的数据在进入程序之前就已经是干净、合规的。让我们一起开始这段学习之旅吧！</div></div></div></a><a class="pagination-related" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%9F%E6%88%90/" title="AI提示词_学习笔记生成"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">AI提示词_学习笔记生成</div></div><div class="info-2"><div class="info-item-1">AI提示词，用于引导AI生成学习笔记，根据提示的设定，对没有基础背景背景的小白生成学习笔记。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/10/06/Golang_validator/" title="Golang validator 库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-06</div><div class="info-item-2">Golang validator 库</div></div><div class="info-2"><div class="info-item-1">主要讲解如何在Go中使用validator库进行数据验证。通过一系列章节，你将学会如何使用validator库来确保你的数据符合预期。从基本的验证规则到自定义的验证函数，再到处理错误信息的高级技巧，本教程将带你一步步深入学习。validator 是一个非常强大的库，它可以帮助你确保你的数据在进入程序之前就已经是干净、合规的。让我们一起开始这段学习之旅吧！</div></div></div></a><a class="pagination-related" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%9F%E6%88%90/" title="AI提示词_学习笔记生成"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-08</div><div class="info-item-2">AI提示词_学习笔记生成</div></div><div class="info-2"><div class="info-item-1">AI提示词，用于引导AI生成学习笔记，根据提示的设定，对没有基础背景背景的小白生成学习笔记。</div></div></div></a><a class="pagination-related" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E8%AF%95%E9%A2%98%E7%94%9F%E6%88%90/" title="AI提示词_试题生成"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-08</div><div class="info-item-2">AI提示词_试题生成</div></div><div class="info-2"><div class="info-item-1">AI提示词，用于根据提示信息生成对应的试题，帮助学习者检验理解深度。</div></div></div></a><a class="pagination-related" href="/2024/02/28/HTTP%20%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%97%E8%A1%A8/" title="HTTP 状态码列表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-28</div><div class="info-item-2">HTTP 状态码列表</div></div><div class="info-2"><div class="info-item-1">HTTP 状态码列表</div></div></div></a><a class="pagination-related" href="/2023/12/11/%E9%A1%B9%E7%9B%AE%E6%80%9D%E8%B7%AF_%E8%BF%9C%E7%A8%8B%E9%94%AE%E7%9B%98/" title="项目思路_远程（WIFI）键盘"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-11</div><div class="info-item-2">项目思路_远程（WIFI）键盘</div></div><div class="info-2"><div class="info-item-1">AI提示词，用于根据提示信息生成对应的试题，帮助学习者检验理解深度。</div></div></div></a><a class="pagination-related" href="/2025/10/08/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E9%80%9A%E7%94%A8%E8%93%9D%E5%9B%BE/" title="高可用高并发后端架构通用蓝图"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-08</div><div class="info-item-2">高可用高并发后端架构通用蓝图</div></div><div class="info-2"><div class="info-item-1">高可用高并发后端架构通用蓝图，涵盖从客户端到服务端的每一个环节。本章作为架构设计的起点，将介绍整个架构的核心原则和基本结构。</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/Image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">棨</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:chaoqijiang@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Go-swag-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.</span> <span class="toc-text">Go swag 从入门到实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-API-%E6%96%87%E6%A1%A3%EF%BC%9F%E2%80%94%E2%80%94-%E9%97%AE%E9%A2%98%E7%9A%84%E8%B5%B7%E6%BA%90"><span class="toc-number">1.1.</span> <span class="toc-text">第1章：我们为什么需要 API 文档？—— 问题的起源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%80%E4%B8%AA%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9A%E5%8E%BB%E9%A4%90%E5%8E%85%E5%90%83%E9%A5%AD"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 一个生活中的场景：去餐厅吃饭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E2%80%9C%E9%A4%90%E5%8E%85%E6%95%85%E4%BA%8B%E2%80%9D%EF%BC%9A%E5%B0%8F%E6%98%8E%E4%B8%8E%E5%B0%8F%E7%BA%A2%E7%9A%84%E5%8D%8F%E4%BD%9C"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 软件开发中的“餐厅故事”：小明与小红的协作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%89%8B%E5%8A%A8%E7%BB%B4%E6%8A%A4%E6%96%87%E6%A1%A3%E7%9A%84%E2%80%9C%E5%99%A9%E6%A2%A6%E2%80%9D"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 手动维护文档的“噩梦”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 问题的总结与解决思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.5.</span> <span class="toc-text">本章小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0%EF%BC%9ASwag-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%80%94%E2%80%94-%E4%BC%9A%E5%86%99%E6%B3%A8%E9%87%8A%E5%B0%B1%E4%BC%9A%E5%86%99%E6%96%87%E6%A1%A3%E7%9A%84%E2%80%9C%E9%AD%94%E6%B3%95%E2%80%9D"><span class="toc-number">1.2.</span> <span class="toc-text">第2章：Swag 是什么？—— 会写注释就会写文档的“魔法”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Swag-%E7%9A%84%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 Swag 的自我介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%9B%9E%E5%88%B0%E6%88%91%E4%BB%AC%E7%9A%84%E2%80%9C%E9%A4%90%E5%8E%85%E2%80%9D%E6%AF%94%E5%96%BB"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 回到我们的“餐厅”比喻</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%9C%80%E7%BB%88%E7%9A%84%E6%96%87%E6%A1%A3%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7%EF%BC%9F%E2%80%94%E2%80%94-Swagger-UI"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 最终的文档长什么样？—— Swagger UI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-1"><span class="toc-number">1.2.4.</span> <span class="toc-text">本章小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%EF%BC%9A%E4%B8%89%E6%AD%A5%E7%94%9F%E6%88%90%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA-API-%E6%96%87%E6%A1%A3"><span class="toc-number">1.3.</span> <span class="toc-text">第3章：快速上手：三步生成你的第一个 API 文档</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E9%9B%B6%E6%AD%A5%EF%BC%9A%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87%EF%BC%88%E7%A3%A8%E5%88%80%E4%B8%8D%E8%AF%AF%E7%A0%8D%E6%9F%B4%E5%B7%A5%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">第零步：环境准备（磨刀不误砍柴工）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%AE%89%E8%A3%85-Swag-%E4%B8%8E%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.3.2.</span> <span class="toc-text">第一步：安装 Swag 与搭建基础项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E6%B7%BB%E5%8A%A0%E2%80%9C%E9%AD%94%E6%B3%95%E5%92%92%E8%AF%AD%E2%80%9D%E2%80%94%E2%80%94-%E7%BC%96%E5%86%99-Swag-%E6%B3%A8%E8%A7%A3-Annotation"><span class="toc-number">1.3.3.</span> <span class="toc-text">第二步：添加“魔法咒语”—— 编写 Swag 注解 (Annotation)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E7%94%9F%E6%88%90%E5%B9%B6%E6%9F%A5%E7%9C%8B%E6%96%87%E6%A1%A3"><span class="toc-number">1.3.4.</span> <span class="toc-text">第三步：生成并查看文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-2"><span class="toc-number">1.3.5.</span> <span class="toc-text">本章小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0%EF%BC%9ASwag-%E7%9A%84%E2%80%9C%E9%AD%94%E6%B3%95%E5%92%92%E8%AF%AD%E2%80%9D%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%EF%BC%88Annotations%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.4.</span> <span class="toc-text">第4章：Swag 的“魔法咒语”：常用注解（Annotations）详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-API-%E7%9A%84%E2%80%9C%E8%BA%AB%E4%BB%BD%E8%AF%81%E2%80%9D%EF%BC%9A%E6%88%91%E6%98%AF%E8%B0%81%EF%BC%8C%E6%88%91%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 API 的“身份证”：我是谁，我做什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E2%80%9C%E9%A1%BE%E5%AE%A2%E2%80%9D%E9%9C%80%E8%A6%81%E6%8F%90%E4%BE%9B%E4%BB%80%E4%B9%88%EF%BC%9F%E2%80%94%E2%80%94-%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0-Param"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 “顾客”需要提供什么？—— 定义请求参数 @Param</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E2%80%9C%E5%8E%A8%E5%B8%88%E2%80%9D%E4%BC%9A%E8%BF%94%E5%9B%9E%E4%BB%80%E4%B9%88%EF%BC%9F%E2%80%94%E2%80%94-%E5%AE%9A%E4%B9%89%E5%93%8D%E5%BA%94-Success-Failure"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 “厨师”会返回什么？—— 定义响应 @Success &amp; @Failure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-API-%E7%9A%84%E2%80%9C%E9%97%A8%E7%89%8C%E5%8F%B7%E2%80%9D-%E2%80%94%E2%80%94-%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1-Router"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 API 的“门牌号” —— 定义路由 @Router</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E7%BB%BC%E5%90%88%E5%AE%9E%E6%88%98%EF%BC%9A%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84-CRUD"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.5 综合实战：定义一个完整的 CRUD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-3"><span class="toc-number">1.4.6.</span> <span class="toc-text">本章小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0%EF%BC%9A%E6%8F%AD%E7%A7%98-Swag%EF%BC%9A%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">第5章：揭秘 Swag：它是如何工作的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%80%EF%BC%9A%E6%89%AB%E6%8F%8F%E4%B8%8E%E8%A7%A3%E6%9E%90%EF%BC%88%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AB%99%EF%BC%9A%E5%8E%9F%E6%9D%90%E6%96%99%E6%A3%80%E9%AA%8C%EF%BC%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">步骤一：扫描与解析（流水线的第一站：原材料检验）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%BA%8C%EF%BC%9A%E7%BF%BB%E8%AF%91%E4%B8%8E%E6%95%B4%E5%90%88%EF%BC%88%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AB%99%EF%BC%9A%E5%8A%A0%E5%B7%A5%E4%B8%8E%E7%BB%84%E8%A3%85%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">步骤二：翻译与整合（流水线的第二站：加工与组装）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%89%EF%BC%9A%E6%89%93%E5%8C%85%E4%B8%8E%E5%91%88%E7%8E%B0%EF%BC%88%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E7%AB%99%EF%BC%9A%E5%8C%85%E8%A3%85%E4%B8%8E%E4%B8%8A%E6%9E%B6%EF%BC%89"><span class="toc-number">1.5.3.</span> <span class="toc-text">步骤三：打包与呈现（流水线的最后一站：包装与上架）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-4"><span class="toc-number">1.6.</span> <span class="toc-text">本章小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0%EF%BC%9A%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E4%BD%BF%E7%94%A8-Swag-%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.7.</span> <span class="toc-text">第6章：避坑指南：使用 Swag 的注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BF%98%E4%BA%86%E8%BF%99%E4%B8%80%E6%AD%A5%EF%BC%8C%E4%B8%80%E5%88%87%E9%83%BD%E7%99%BD%E8%B4%B9%EF%BC%9Aswag-init"><span class="toc-number">1.7.1.</span> <span class="toc-text">1. 忘了这一步，一切都白费：swag init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A5%9E%E7%A7%98%E7%9A%84-import"><span class="toc-number">1.7.2.</span> <span class="toc-text">2. 神秘的 import _ &quot;...&quot;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88Struct%EF%BC%89%E6%97%A0%E6%B3%95%E6%AD%A3%E7%A1%AE%E8%A7%A3%E6%9E%90"><span class="toc-number">1.7.3.</span> <span class="toc-text">3. 结构体（Struct）无法正确解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Param-%E5%92%8C-Router-%E7%9A%84%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E4%B8%8D%E5%8C%B9%E9%85%8D"><span class="toc-number">1.7.4.</span> <span class="toc-text">4. @Param 和 @Router 的路径参数不匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%A8%E5%B1%80%E6%B3%A8%E8%A7%A3%EF%BC%88main-%E5%87%BD%E6%95%B0%E4%B8%8A%E6%96%B9%EF%BC%89%E5%88%B0%E5%BA%95%E5%86%99%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="toc-number">1.7.5.</span> <span class="toc-text">5. 全局注解（main 函数上方）到底写在哪？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%96%87%E6%A1%A3%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86%EF%BC%9F%E2%80%94%E2%80%94-host-%E5%92%8C-BasePath-%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">1.7.6.</span> <span class="toc-text">6. 文档部署到服务器上访问不了？—— @host 和 @BasePath 的重要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-5"><span class="toc-number">1.7.7.</span> <span class="toc-text">本章小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0%EF%BC%9A%E6%80%BB%E7%BB%93%E4%B8%8E%E4%B8%8B%E4%B8%80%E6%AD%A5"><span class="toc-number">1.8.</span> <span class="toc-text">第7章：总结与下一步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%88%91%E4%BB%AC%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%9B%9E%E9%A1%BE%EF%BC%88%E6%88%91%E4%BB%AC%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%89"><span class="toc-number">1.8.1.</span> <span class="toc-text">7.1 我们的学习回顾（我们学到了什么？）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E7%9F%A5%E8%AF%86%E7%9A%84%E5%BB%B6%E4%BC%B8%EF%BC%88%E6%8E%A5%E4%B8%8B%E6%9D%A5%E5%8F%AF%E4%BB%A5%E5%AD%A6%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%89"><span class="toc-number">1.8.2.</span> <span class="toc-text">7.2 知识的延伸（接下来可以学什么？）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%9C%80%E5%90%8E%E7%9A%84%E5%8F%AE%E5%98%B1"><span class="toc-number">1.8.3.</span> <span class="toc-text">7.3 最后的叮嘱</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-number">2.</span> <span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Swagger-%E6%B3%A8%E8%A7%A3%E5%8F%82%E8%80%83%E4%B8%8E%E5%AE%9E%E6%88%98%E6%A8%A1%E6%9D%BF%EF%BC%88Swag-for-Go%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">Swagger 注解参考与实战模板（Swag for Go）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E%E8%A1%A8%EF%BC%88%E5%B8%A6%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">一、常用注解说明表（带调用示例）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-Param-%E7%B1%BB%E5%9E%8B%E8%AF%A6%E7%BB%86%E8%A1%A8%EF%BC%88%E5%90%AB%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">二、@Param 类型详细表（含请求示例）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81-Success-Failure-%E7%9A%84-%E7%B1%BB%E5%9E%8B-%E5%8F%82%E6%95%B0"><span class="toc-number">2.1.3.</span> <span class="toc-text">三、@Success &#x2F; @Failure 的 {类型} 参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Success-Failure-%E7%9A%84-%E7%B1%BB%E5%9E%8B-%E5%8F%82%E6%95%B0%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%A0%BC%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">@Success &#x2F; @Failure 的 {类型} 参数支持哪些格式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E-JSON-%E2%80%94%E2%80%94-%E5%BA%94%E8%AF%A5%E7%94%A8-object-%E6%88%96-array-%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF-string"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">如果你的接口返回 JSON —— 应该用 {object} 或 {array}，而不是 {string}</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%99%E6%B3%95%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">几个常见的写法对比表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BE%8B%E5%AD%90"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">完整例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%AE%B0%E4%BD%8F%EF%BC%9A"><span class="toc-number">2.1.3.5.</span> <span class="toc-text">小结一句话记住：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.1.4.</span> <span class="toc-text">三、结构体定义示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%8E%A5%E5%8F%A3%E6%A8%A1%E6%9D%BF%EF%BC%88%E5%85%A8%E9%83%A8%E6%B3%A8%E8%A7%A3%E7%A4%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">2.1.5.</span> <span class="toc-text">四、接口模板（全部注解示例）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%EF%BC%88GET-Path%EF%BC%89"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">获取用户信息（GET + Path）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%EF%BC%88POST-Body%EF%BC%89"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">创建用户（POST + Body）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%EF%BC%88POST-FormData%EF%BC%89"><span class="toc-number">2.1.5.3.</span> <span class="toc-text">用户登录（POST + FormData）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E5%A4%B4%E5%83%8F%EF%BC%88POST-File%EF%BC%89"><span class="toc-number">2.1.5.4.</span> <span class="toc-text">上传头像（POST + File）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E9%89%B4%E6%9D%83%E6%8E%A5%E5%8F%A3%EF%BC%88Header-Security%EF%BC%89"><span class="toc-number">2.1.5.5.</span> <span class="toc-text">带鉴权接口（Header + Security）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie-%E7%A4%BA%E4%BE%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.5.6.</span> <span class="toc-text">Cookie 示例接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81Swagger-%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E5%AE%9A%E4%B9%89%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9C%A8-docs-init-go-%E4%B8%AD%EF%BC%89"><span class="toc-number">2.1.6.</span> <span class="toc-text">五、Swagger 安全认证定义示例（在 docs&#x2F;init.go 中）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%B0%8F%E7%BB%93"><span class="toc-number">2.1.7.</span> <span class="toc-text">六、小结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/12/Hexo%E6%96%B0%E5%A2%9E%E5%88%86%E7%B1%BB%E6%A0%87%E7%AD%BE%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E8%AF%A6%E8%A7%A3/" title="Hexo 新增分类、标签与自定义页面详解">Hexo 新增分类、标签与自定义页面详解</a><time datetime="2025-10-12T05:46:03.000Z" title="发表于 2025-10-12 13:46:03">2025-10-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E9%80%9A%E7%94%A8%E8%93%9D%E5%9B%BE/" title="高可用高并发后端架构通用蓝图">高可用高并发后端架构通用蓝图</a><time datetime="2025-10-08T15:42:00.000Z" title="发表于 2025-10-08 23:42:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%9F%E6%88%90/" title="AI提示词_学习笔记生成">AI提示词_学习笔记生成</a><time datetime="2025-10-08T15:15:00.000Z" title="发表于 2025-10-08 23:15:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E8%AF%95%E9%A2%98%E7%94%9F%E6%88%90/" title="AI提示词_试题生成">AI提示词_试题生成</a><time datetime="2025-10-08T15:15:00.000Z" title="发表于 2025-10-08 23:15:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/Golang_swag/" title="Golang swag 库">Golang swag 库</a><time datetime="2025-10-08T15:07:00.000Z" title="发表于 2025-10-08 23:07:00">2025-10-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/Image/topImage.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By 棨</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>