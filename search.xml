<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AI提示词_学习笔记生成</title>
    <url>/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[学习笔记生成你是一位耐心、善于解释的教师，擅长为完全没有专业背景的小白生成学习笔记。请遵循以下要求：
【读者定位】

完全没有专业背景，但懂最基础概念（如程序结构、变量、函数，或电路、电压、电流等基础概念，视领域而定）。

【任务说明】

学习主题：{填写领域主题，例如“RabbitMQ”或“模拟电子元件”}
学习目标：{填写希望掌握的核心内容，例如“消息队列基础、队列、交换机、消息发布订阅”}

【生成流程】

生成学习笔记大纲

按章节或小节列出学习顺序

每个章节用一句话说明要讲解的核心内容

大纲必须考虑小白的理解顺序，由浅入深

示例大纲格式：
第1章：XXX是什么？（一句话解释）第2章：XXX的基本使用方法第3章：XXX的高级应用第4章：练习与复习


确认大纲

在生成完整内容前，请把大纲输出给我确认
待我确认大纲无误后，再生成详细内容


生成详细内容

每章内容应包括：
简单易懂的语言解释概念
类比或生活中的例子
示例或练习题（例如代码示例、电路练习等）
章节小结或关键点总结


风格要求：
口语化、易懂
条理清晰，章节分明
鼓励思考，适当提出问题让读者自问自答





]]></content>
      <categories>
        <category>AI提示词</category>
      </categories>
      <tags>
        <tag>使用教程</tag>
        <tag>AI</tag>
        <tag>protected</tag>
      </tags>
  </entry>
  <entry>
    <title>AI提示词_试题生成</title>
    <url>/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E8%AF%95%E9%A2%98%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[试题生成你是一位耐心且富有创造力的教师，擅长为学习者设计检验知识掌握程度的练习题和提问。请遵循以下要求：
【读者定位】

学习者已经掌握部分知识，但需要通过练习来检验理解深度。
假设学习者已经熟悉基础概念，但可能对复杂应用或细节理解不足。

【任务说明】

学习领域：{填写领域，例如“RabbitMQ”或“模拟电子元件”}
已掌握内容：{填写你已经掌握的知识点，例如“队列、交换机、基本消息发布与订阅”}
目标：生成一份检验学习者掌握程度的练习题或提问，帮助发现理解的薄弱环节。

【题目要求】

题型多样：
选择题（多选&#x2F;单选）
填空题
简答题
实操题或小实验题（例如代码编写、电路设计、配置操作）


每题应有清晰的题目描述，必要时提供上下文或示例
尽量设计由浅入深的题目，既考基础知识，也涉及实际应用
对每题给出参考答案或解析，说明正确思路和关键点
鼓励思考，不只是死记硬背
如果适用，题目可以带有实际操作步骤或小实验指导

【输出格式】
按题型分类，例如：一、选择题
XXX？A. …B. …C. …D. …正确答案：B解析：…
二、填空题
XXX正确答案：…
三、简答题
XXX参考答案：…
四、实操题&#x2F;小实验
XXX指导步骤：…参考答案：…
]]></content>
      <categories>
        <category>AI提示词</category>
      </categories>
      <tags>
        <tag>使用教程</tag>
        <tag>AI</tag>
        <tag>protected</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang swag 库</title>
    <url>/2025/10/08/Golang_swag/</url>
    <content><![CDATA[Go swag 从入门到实践第1章：我们为什么需要 API 文档？—— 问题的起源

核心内容：讲解在团队协作和项目开发中，一份清晰的 API 文档是多么重要，以及手动维护文档的痛点。

第2章：Swag 是什么？—— 会写注释就会写文档的“魔法”

核心内容：介绍 swag 这个工具，把它比作一个能自动帮你把代码注释“翻译”成漂亮网页文档的“魔法师”。

第3-章：快速上手：三步生成你的第一个 API 文档

核心内容：通过一个最简单的 “Hello, World” 级别的 Go Web 项目，手把手带你完成安装、添加注释、生成并查看文档的全过程。

第4章：Swag 的“魔法咒语”：常用注解（Annotations）详解

核心内容：详细拆解 swag 的核心——注解语法，学习如何描述 API 的名称、参数、返回值等关键信息。

第5章：揭秘 Swag：它是如何工作的？

核心内容：简单说明 swag 的工作原理，让你明白它并不是真的“魔法”，而是一个代码解析和文件生成工具。

第6章：避坑指南：使用 Swag 的注意事项

核心内容：总结一些新手在使用 swag 时容易犯的错误和需要注意的地方，让你少走弯路。

第7章：总结与下一步

核心内容：回顾本次学习的重点，并为你指出接下来可以继续学习的方向。


第1章：我们为什么需要 API 文档？—— 问题的起源嘿，同学！在学习任何一个新工具，尤其是像 swag 这样的“自动化”工具之前，我们必须先搞清楚一个最根本的问题：我们到底遇到了什么麻烦，以至于需要一个新工具来拯救我们？
只有理解了“痛点”，我们才能真正明白这个工具的价值。
1.1 一个生活中的场景：去餐厅吃饭想象一下，你走进一家装修精美的餐厅，准备享用大餐。你（客户端，比如手机 App 或网页）坐下来，服务员递给你一本菜单（API 文档）。
这本菜单上写得清清楚楚：

有什么菜？（宫保鸡丁、鱼香肉丝……）
每道菜需要什么？（比如，“牛排”这道菜，你需要告诉服务员要“七分熟”还是“全熟”。）
这道菜上上来是什么样的？（菜单上的图片告诉你，这道菜有主食、有蔬菜沙拉。）

你通过菜单，知道了这家餐厅的厨房（服务端&#x2F;后端）能为你做什么。你点了一份“七分熟的牛排”，服务员把这个请求告诉了后厨。后厨一通操作，最后把一份完美的牛排端到你面前。
整个过程非常顺利，因为你们之间有一份清晰的“沟通契约”——菜单。



关键概念：API在软件开发中，API (Application Programming Interface，应用程序编程接口) 就扮演着“菜单”的角色。它定义了不同的软件部分之间如何沟通。后端程序员（厨师）开发好功能后，提供一份 API“菜单”，前端程序员（顾客）或其他服务就知道如何调用这些功能了。


1.2 软件开发中的“餐厅故事”：小明与小红的协作现在，我们把场景切换到一家软件公司。

小明：后端工程师，我们的“厨师”。他负责开发服务器的功能，比如“用户注册”、“获取商品列表”等。
小红：前端工程师，我们的“顾客”。她负责开发用户能直接看到的网页或 App 界面。

有一天，产品经理要求做一个“用户注册”的功能。
小明（厨师） 在后端吭哧吭哧写好了代码，实现了一个功能：只要别人给他一个用户名和密码，他就能在数据库里创建一个新用户，并返回“注册成功”或“用户已存在”的消息。
现在问题来了，小明怎么告诉小红（顾客） 这个功能该怎么用呢？
小红心里有一堆问题，就像你看菜单时一样：

我该访问哪个地址才能找到你这个“注册”功能？ （就像餐厅的门牌号和几号桌）

专业术语叫：Endpoint 或 URL


我该用什么方法来请求？是 GET 还是 POST？ （就像你是要“点餐”还是只是“看看菜单”）

我需要提供哪些信息给你？ 是 username 和 password 吗？还是 user 和 pwd？这些信息是放在哪里给你？

专业术语叫：请求参数 (Request Parameters)


你处理完后，会返回给我什么？ 是返回一个简单的字符串 &quot;注册成功&quot;，还是一个包含更多信息的复杂结构（比如 JSON 对象）？成功和失败时返回的样子一样吗？

专业术语叫：响应体 (Response Body)



你看，如果这些信息沟通不清楚，小红就完全没法开始工作。她可能会因为一个参数名写错（比如把 username 写成了 user），而调试大半天，最后发现是小明没告诉她。
于是，最原始的“API 文档”诞生了。可能是一份 Word 文档，一个 Wiki 页面，甚至是聊天记录。小明在里面写清楚上面所有问题的答案，然后发给小红。

1.3 手动维护文档的“噩梦”一开始，一切看起来都还不错。小明把文档写好，小红照着开发，项目顺利上线。
但软件是不断迭代的。不久后，产品经理又提了新需求：“注册时，除了用户名和密码，还需要用户提供一个邮箱(email)”。
小明（厨师） 立刻修改了他的代码，现在“注册”功能需要三个参数了：username, password, email。他急着下班，或者 只是 忘了，没有去更新那份 Word 文档。
灾难发生了！
几天后，小红发现所有新用户都注册不了了。她查了半天代码，看不出问题，最后跑去问小明。小明一拍脑袋：“哎呀！我加了个 email 参数，忘了和你说，也忘了更新文档了！”
这就是手动维护 API 文档的核心痛点：

容易忘记更新：代码是“唯一真实”的，文档是“副本”。程序员改了代码后，很容易忘记或懒得去同步修改那个独立的文档。
文档与代码不一致：这是最致命的。一份过时的、错误的文档比没有文档更可怕，因为它会误导使用者，浪费大量调试时间。
费时费力：写文档本身就是一件枯燥的工作。每次修改代码，都要去找到对应的文档位置进行修改，效率极低。
格式不统一：张三写的文档喜欢用表格，李四写的喜欢用列表。团队里没有统一的、美观的、易于阅读的 API 文档格式。

想一想：如果餐厅的菜单更新不及时，厨师新加了一道菜，或者某道菜的做法变了（比如“宫保鸡丁”现在默认加辣了），但菜单上还是老样子，顾客点餐时会发生多少误会和麻烦？

1.4 问题的总结与解决思路好了，到现在我们已经把问题搞得很清楚了：

团队协作需要清晰的 API 文档（菜单）。
手动维护这份文档（菜单）非常痛苦，且极易出错。

那么，有没有一种理想的方法，能够让“菜单”和“厨房里的菜谱”永远保持同步呢？
当然有！
我们能不能找到一种方法，让代码自己来描述自己？然后用一个工具，自动读取这些描述，生成一份永远不会过时、格式优美、交互友好的网页版“菜单”？
这，就是 swag 准备为我们做的事情。它就是那个能自动根据厨师的菜谱（代码注释），打印出精美菜单（API 文档网页）的“魔法打印机”。
本章小结
API 是什么？ 它是软件不同部分之间沟通的桥梁，就像餐厅的菜单，定义了你能请求什么，以及会得到什么。
为什么需要 API 文档？ 因为它是指导开发者如何正确使用 API 的说明书，是团队协作的基石。
手动维护文档有什么问题？ 容易过时、与代码不一致、耗费时间、格式混乱。
我们的目标是什么？ 找到一种自动化的方式，让代码和文档永远保持同步。

现在，你是不是已经深刻理解了我们即将学习的 swag 是为了解决什么问题而存在的？带着这个问题，我们下一章就来正式认识一下这位“魔法师”！

第2章：Swag 是什么？—— 会写注释就会写文档的“魔法”上一章我们聊了手动维护 API 文档的种种痛苦，并且提出了一个美好的设想：能不能让代码自己来解释自己，然后有个工具自动帮我们生成文档？
现在，揭晓答案的时刻到了！swag 就是来实现这个美好设想的工具。
2.1 Swag 的自我介绍你可以把 swag 想象成一位非常聪明的“文档翻译官”。
它本身不是一个重量级的大软件，而是一个 Go 语言的工具库。它的核心工作流程非常简单：

阅读你的代码：它会去扫描你项目里的 Go 代码文件。
寻找特殊注释：它不会关心你所有的代码逻辑，只关心那些你按照特定格式写的“特殊注释”（我们后面会叫它注解，英文是 Annotation）。
翻译成文档：它把这些“特殊注释”翻译成一种标准化的 API 描述文件（叫做 OpenAPI&#x2F;Swagger 规范文件）。
生成网页：最后，它利用这个标准文件，为你生成一套漂亮、可交互的 HTML 网页，也就是我们最终看到的 API 文档。


一句话总结：swag 是一个 Go 工具，它能将你代码里的特定注释，自动转换成交互式 API 文档。


2.2 回到我们的“餐厅”比喻还记得小明和小红的故事吗？小明是厨师（后端），小红是顾客（前端）。
在没有 swag 的世界里，小明（厨师）除了要写好自己的菜谱（代码），还得额外花时间去手写一份菜单（Word 文档），并且要时刻记着菜谱一改，菜单也要跟着改，心力交瘁。
现在有了 swag 这个“魔法打印机”，情况完全不同了：

在菜谱上做笔记：小明现在不用写单独的菜单了。他只需要在自己的“宫保鸡丁”菜谱（代码文件）旁边，用“魔法荧光笔”（swag 的注解语法）直接写下笔记。
// 这是我的做菜代码...// @菜名: 宫保鸡丁// @描述: 一道经典的川味菜肴，酸甜可口。// @需要食材: 鸡丁, 花生, 辣椒// @返回样式: &#123; &quot;status&quot;: &quot;成功&quot;, &quot;dish&quot;: &quot;宫保鸡丁一份&quot; &#125;func GongBaoJiDingHandler(w http.ResponseWriter, r *http.Request) &#123;    // ...复杂的炒菜过程...&#125;

一键打印：当小明写完代码和这些笔记后，他只要在电脑上敲一个命令（比如 swag init），这个“魔法打印机”就会“嗡嗡嗡”地工作起来。

生成精美菜单：swag 会自动扫描所有菜谱上的“魔法笔记”，然后“duang”的一下，生成一份图文并茂、格式精美的网页菜单，直接交给小红。


从此以后，小明只需要关心他的代码（菜谱）。只要菜谱里的做法或所需食材（API 参数）变了，他顺手改一下旁边的笔记，再敲一下命令，小红看到的菜单就自动更新了！
代码和文档，从此实现了完美的同步！ 这就是 swag 的核心价值。

2.3 最终的文档长什么样？—— Swagger UI你可能会好奇，swag 生成的文档到底是什么样的？仅仅是把注释搬到网页上吗？
远不止如此！swag 实际上是遵循一个业界非常流行的标准，叫做 OpenAPI 规范（它的前身就是大名鼎鼎的 Swagger 规范）。
你可以理解为，swag 先是把你的注释翻译成了一份“标准数据文件”（一个 json 或 yaml 文件），这份文件以一种通用的格式描述了你所有的 API。
然后，一个叫做 Swagger UI 的工具会读取这份标准文件，并把它渲染成一个非常酷的交互式网页。
它有什么特点呢？

清晰的列表：把你所有的 API 按照模块（比如“用户管理”、“商品管理”）分门别类地列出来。
详细的信息：点开任何一个 API，你都能看到它的 URL、请求方法（GET&#x2F;POST 等）、详细描述、所有参数的说明（参数名、类型、是否必需等）以及返回数据的格式。
在线调试功能（杀手级功能！）：这是最棒的部分！在文档页面上，你可以直接填写参数，然后点击一个 “Try it out” 或 “Execute” 按钮，直接调用这个 API！你不用写任何代码，就能立刻测试后端接口是否正常工作，返回的数据对不对。这对前端的小红来说，简直是天大的福音！

想一想：这就像在餐厅的电子菜单上，你不仅能看到菜品的图片和介绍，旁边还有一个“试吃”按钮。你点一下，服务员就会立刻给你端上一小份样品尝尝。这体验是不是太棒了？

本章小结
Swag 是什么？ 一个能把 Go 代码中的“特殊注释”自动生成为 API 文档的工具。
它的工作原理？ 读取代码注释 -&gt; 生成遵循 OpenAPI 规范的中间文件 -&gt; 利用 Swagger UI 渲染成交互式网页。
它的核心价值？ 让文档与代码保持同步，彻底解决手动维护文档的痛点，实现“代码即文档”。
最终产出物？ 一个美观、清晰、且支持在线调试的 API 文档网站。

好了，现在我们已经知道了 swag 是什么，以及它为什么这么神奇。是不是已经跃跃欲试，想亲手生成一份自己的 API 文档了？
下一章，我们就来动手实践！准备好你的 Go 环境，我们要开始写代码了！
准备好了吗？让我们开始搭建你的第一个自动化 API 文档！

第3章：快速上手：三步生成你的第一个 API 文档理论说再多，不如亲手敲一遍代码。这一章，我们会像拼乐高一样，一步步搭建一个最简单的 Go Web 项目，并用 swag 为它生成一份漂亮的 API 文档。
整个过程可以清晰地分为三步：搭建项目 -&gt; 添加注解 -&gt; 生成文档。
第零步：环境准备（磨刀不误砍柴工）在开始之前，请确保你的电脑已经安装好了 Go 语言环境。你可以在终端（命令行工具）里输入以下命令来检查：
go version

如果你能看到类似 go version go1.18 linux/amd64 这样的输出，就说明环境没问题。
接下来，创建一个新的项目文件夹，并进入这个文件夹。
mkdir my-swag-appcd my-swag-app

然后，初始化 Go 的模块管理，这会生成一个 go.mod 文件。
go mod init my-swag-app

第一步：安装 Swag 与搭建基础项目1. 安装 Swag 命令行工具
swag 主要包含两部分：一个是能生成文档的命令行工具，另一个是能在我们网页里展示文档页面的代码库。我们先来安装命令行工具。
在终端里运行：
go install github.com/swaggo/swag/cmd/swag@latest

安装成功后，你可以通过 swag -v 命令来验证。如果能看到版本号，就说明成功了。
2. 搭建一个简单的 Web 服务器
为了演示，我们将使用一个非常流行的 Go Web 框架 Gin，因为它简单快捷。同时，我们还需要 gin-swagger 和 files 这两个库，它们是 swag 的好搭档，用来在 Gin 项目里展示文档页面。
安装这三个库：
go get -u github.com/gin-gonic/gingo get -u github.com/swaggo/gin-swaggergo get -u github.com/swaggo/files

接下来，在你的项目文件夹 my-swag-app 中，创建一个 main.go 文件，然后把下面的代码复制进去。这是一个最基础的、不包含任何 swag 注解的 Web 服务器。
main.go (初始版本)
package mainimport (	&quot;github.com/gin-gonic/gin&quot;	&quot;net/http&quot;)func main() &#123;	// 1. 创建路由引擎	r := gin.Default()	// 2. 定义一个 API 路由	// 当用户访问 /hello?name=张三 时，会调用 PingHandler 函数	r.GET(&quot;/hello&quot;, PingHandler)		// 3. 启动服务，监听在 8080 端口	r.Run(&quot;:8080&quot;)&#125;// PingHandler 是这个 API 的处理函数func PingHandler(c *gin.Context) &#123;	// 从 URL 查询参数中获取 &quot;name&quot; 的值，如果没有，则默认为 &quot;Guest&quot;	name := c.DefaultQuery(&quot;name&quot;, &quot;Guest&quot;)		// 返回一个 JSON 响应	c.JSON(http.StatusOK, gin.H&#123;		&quot;message&quot;: &quot;pong, &quot; + name,	&#125;)&#125;

现在，你可以运行这个程序：
go run main.go

然后在浏览器或 Postman 等工具中访问 http://localhost:8080/hello?name=Coder，你会看到返回结果：{&quot;message&quot;:&quot;pong, Coder&quot;}。
很好！我们的基础项目已经跑起来了。
第二步：添加“魔法咒语”—— 编写 Swag 注解 (Annotation)现在，我们要开始对代码“施法”了。swag 的注解本质上就是一种特殊格式的注释，它总是以 @ 符号开头。
我们将为我们的项目添加两种注解：

全局注解：写在 main 函数的上方，用来描述整个项目的基本信息，比如标题、版本号、API 的基础路径等。
API 注解：写在具体的 Handler 函数（处理请求的函数）上方，用来描述这一个 API 的所有细节。

现在，请用下面的代码完整替换你的 main.go 文件。仔细看新增的那些注释。
main.go (添加注解后)
package mainimport (	&quot;github.com/gin-gonic/gin&quot;	&quot;net/http&quot;		// 引入 swag 必需的库	_ &quot;my-swag-app/docs&quot; // 注意这里的路径！ `my-swag-app` 是你的 go.mod 里的模块名	swaggerFiles &quot;github.com/swaggo/files&quot;	ginSwagger &quot;github.com/swaggo/gin-swagger&quot;)// @title           我的第一个 Swag API// @version         1.0// @description     这是一个使用 Gin 和 Swag 构建的示例服务.// @termsOfService  http://swagger.io/terms/// @contact.name   API Support// @contact.url    http://www.swagger.io/support// @contact.email  support@swagger.io// @license.name  Apache 2.0// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html// @host      localhost:8080// @BasePath  /// @schemes httpfunc main() &#123;	r := gin.Default()	// API 路由	r.GET(&quot;/hello&quot;, PingHandler)	// 文档路由	// 访问 http://localhost:8080/swagger/index.html 就可以看到文档了	r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler))	r.Run(&quot;:8080&quot;)&#125;// PingHandler 回复一个问候// @Summary      Ping example// @Description  这是一个 &quot;ping&quot; API 的示例，它会带上你的名字进行回复.// @Tags         示例API// @Accept       json// @Produce      json// @Param        name   query      string  false  &quot;你的名字&quot; default(Guest)// @Success      200    &#123;object&#125;   map[string]string// @Router       /hello [get]func PingHandler(c *gin.Context) &#123;	name := c.DefaultQuery(&quot;name&quot;, &quot;Guest&quot;)	c.JSON(http.StatusOK, gin.H&#123;		&quot;message&quot;: &quot;pong, &quot; + name,	&#125;)&#125;

代码讲解：

全局注解（main 函数上方）：
@title, @version, @description: 定义了文档的标题、版本和描述。
@host: 告诉 swag 我们的服务地址是什么，这在在线调试时非常重要。
@BasePath: API 的基础路径，我们这里是根路径 /。


API 注解（PingHandler 函数上方）：
@Summary: API 的一句话简介，会显示在列表里。
@Description: 更详细的描述。
@Tags: API 的分组标签，方便管理。
@Accept&#x2F;@Produce: 定义这个 API 接收和返回的数据格式（这里是 json）。
@Param: 非常重要！用来定义参数。格式是：参数名 参数位置 数据类型 是否必需 注释 其他属性。
name query string false &quot;你的名字&quot; 的意思是：有一个名叫 name 的参数，它在 query（URL ? 后面）里，类型是 string，不是必需的 (false)，注释是 “你的名字”。


@Success: 定义成功响应。格式是：HTTP状态码 {返回数据结构} 注释。我们这里 200 表示成功，返回一个键值都是字符串的 map。
@Router: 定义路由路径和 HTTP 方法。格式是：路径 [HTTP方法]。



第三步：生成并查看文档万事俱备，只欠东风！现在，我们在项目根目录下（my-swag-app 文件夹）打开终端，运行 swag 的初始化命令：
swag init

执行后，你会看到类似这样的输出：create docs.gocreate swagger.jsoncreate swagger.yaml
同时，你的项目文件夹里会多出一个 docs 文件夹，里面就装着 swag 帮我们生成的文档资源。
最后一步，让我们的程序跑起来！
go run main.go

服务启动后，打开你的浏览器，访问这个神奇的地址：
http://localhost:8080/swagger/index.html
见证奇迹的时刻！ 你会看到一个漂亮的 API 文档页面，上面清晰地列出了我们刚刚定义的 “Ping example” API。你可以点开它，看到所有详细信息，甚至可以在页面上输入你的名字，点击 “Try it out”，然后 “Execute”，亲身体验在线调试的快感！

本章小结恭喜你！你已经成功地使用 swag 生成了你的第一个 API 文档。我们来回顾一下这个核心流程：

安装工具：安装 swag 命令行工具和相关的 Go 库 (gin-swagger, files)。
编写注解：在 main 函数上写全局注解，在处理函数上写API 注解。
生成文档：运行 swag init 命令，生成 docs 文件夹。
集成与运行：在代码中添加文档路由，然后运行程序，访问 /swagger/index.html 查看。

这个流程会成为你未来工作的日常。每当你修改了 API 的逻辑或参数，你只需要：修改代码&#x2F;注解 -&gt; 重新运行 swag init -&gt; 重启你的服务你的文档就永远和代码保持同步了！
现在你已经掌握了基本操作，但你可能对 @Param、@Success 等注解的具体写法还有很多疑问。别担心，下一章，我们将深入学习这些“魔法咒语”的详细语法和更多用法。
你已经学会了如何“让 swag 跑起来”，现在是时候深入理解它背后的“语法规则”了。只有掌握了这些规则，你才能随心所欲地生成任何你想要的文档。
这一章，我们就来详细拆解 swag 的核心——注解（Annotations），也就是我们之前说的“魔法咒语”。

第4章：Swag 的“魔法咒语”：常用注解（Annotations）详解把注解想象成你在填写一份非常详细的“API 注册表”。这份表单上的每一项（比如“名称”、“功能”、“所需材料”等），都对应一个 @ 开头的注解。swag 工具就是一个严格的“审查员”，它会读取你填写的这份表单，并据此生成最终的文档。
我们将注解分为几大类来学习：API 身份信息、请求信息、响应信息和路由信息。
4.1 API 的“身份证”：我是谁，我做什么？这类注解用来描述 API 的基本信息，让别人一眼就能看懂它的用途。

@Summary

用途：API 的一句话摘要，是它的“标题”。通常在文档列表中显示。

语法：@Summary 任意描述性文字

示例：
// @Summary 获取单个用户信息


@Description

用途：API 的详细描述。可以写多行，用来解释更复杂的业务逻辑或注意事项。

语法：@Description 更详细的说明，可以换行。

示例：
// @Description 根据用户ID获取用户的详细信息，包括姓名、年龄和注册日期。// @Description 注意：如果用户ID不存在，将返回404错误。


@Tags

用途：为 API 分组。在文档页面上，相同 Tags 的 API 会被归类到一起，非常利于管理。

语法：@Tags 标签名1,标签名2 (多个标签用逗号隔开)

示例：
// @Tags 用户管理


@ID

用途：为操作设置一个唯一的标识符。在某些高级应用（如生成客户端代码）中会用到，通常可以省略。

语法：@ID 操作的唯一ID

示例：
// @ID GetUserByID




4.2 “顾客”需要提供什么？—— 定义请求参数 @Param这是最重要、也是最复杂的注解之一。它告诉使用者，调用这个 API 需要提供哪些数据。

@Param

用途：定义一个请求参数。每个参数都需要单独写一行 @Param 注解。
语法：@Param 参数名 参数位置 数据类型 是否必需 &quot;注释&quot; [其他属性]
参数详解：
参数名 (Parameter Name)：例如 userID、username。
参数位置 (Parameter In)：参数从哪里来？
query：URL 中 ? 后面的参数，如 /users?id=123。
path：URL 路径中的一部分，如 /users/123 (需要配合 Gin 的 :id 格式)。
header：HTTP 请求头里的参数，如 Authorization Token。
body：整个 HTTP 请求体，通常用于 POST&#x2F;PUT 请求，用来传递复杂的 JSON 数据。
formData：表单数据，用于 application/x-www-form-urlencoded 或 multipart/form-data 格式的提交。


数据类型 (Data Type)：参数的类型，如 string、int、boolean、file 等。
是否必需 (Required)：true 或 false。
注释 (Comment)：用双引号括起来的参数描述。
其他属性 (Attributes)：可选，用于提供更多约束，如 default(Guest)、enums(male,female)、maxLength(10) 等。




@Param 示例大合集
1. query 参数（最常见）
// @Param   page  query     int  false  &quot;页码&quot; default(1)// @Param   size  query     int  false  &quot;每页大小&quot; default(10)

2. path 参数
// @Summary 获取单个用户信息// @Param   id   path      int  true   &quot;用户ID&quot;// @Router /users/&#123;id&#125; [get]// Gin 路由应该这样写: r.GET(&quot;/users/:id&quot;, GetUser)

注意：@Router 里的路径 {id} 必须和 @Param 里的 id 对应。
3. body 参数（用于提交 JSON）
// @Summary 创建一个新用户// @Accept  json// @Param   user body      models.User  true   &quot;用户信息&quot;// @Router /users [post]// 这里的 `models.User` 是你项目里定义的一个 Go 结构体 (struct)，我们稍后会讲。

@Accept 注解用来声明此 API 接收的数据格式。



4.3 “厨师”会返回什么？—— 定义响应 @Success &amp; @Failure这两个注解用来告诉使用者，API 调用成功或失败时，会返回什么样的数据。

语法：@Success/@Failure HTTP状态码 {返回类型} 数据模型 &quot;注释&quot;

参数详解：

HTTP状态码 (HTTP Status Code)：如 200 (成功)、400 (错误请求)、404 (未找到)、500 (服务器内部错误)。
返回类型 (Response Type)：通常是 object (单个对象) 或 array (对象数组)。
数据模型 (Data Model)：
可以是基础类型，如 string, int。
可以是 map[string]string 这样的简单集合。
最常用的是：指向你项目中定义的 Go 结构体，如 models.User 或 []models.User (表示用户数组)。


注释 (Comment)：对这个响应的描述。


@Success &amp; @Failure 示例
1. 返回简单消息
// @Success 200 &#123;object&#125; map[string]string &quot;&#123;&quot;message&quot;: &quot;操作成功&quot;&#125;&quot;// @Failure 400 &#123;object&#125; map[string]string &quot;&#123;&quot;error&quot;: &quot;无效的输入&quot;&#125;&quot;

2. 返回一个复杂对象（结构体）
// @Success 200 &#123;object&#125; models.User &quot;成功返回用户信息&quot;

3. 返回一个对象数组
// @Success 200 &#123;array&#125; models.User &quot;成功返回用户列表&quot;

@Produce 注解用来声明此 API 返回的数据格式，通常是 application/json。



4.4 API 的“门牌号” —— 定义路由 @Router这个注解至关重要，它把所有信息和具体的 URL 路径、HTTP 方法绑定在了一起。

@Router

用途：定义 API 的路由路径和请求方法。

语法：@Router /path/to/resource [http_method]

示例：
// @Router /users [post]        // 创建用户// @Router /users/&#123;id&#125; [get]      // 获取单个用户// @Router /users/&#123;id&#125; [put]      // 更新单个用户// @Router /users/&#123;id&#125; [delete]   // 删除单个用户




4.5 综合实战：定义一个完整的 CRUD现在，让我们把所有学到的注解整合起来，为一个 User 模型定义一个完整的创建和查询 API。
首先，创建一个 models 文件夹，并在其中创建 user.go 文件
models/user.go
package models// User 代表一个用户模型type User struct &#123;    ID   int    `json:&quot;id&quot; example:&quot;1&quot;`    Name string `json:&quot;name&quot; example:&quot;John Doe&quot;`    Age  int    `json:&quot;age&quot; example:&quot;30&quot;`&#125;

这里的 json:&quot;...&quot; 是 Go 的结构体标签，用于序列化为 JSON。example:&quot;...&quot; 是 swag 的注解，用于在文档中生成示例值。
然后，修改你的 main.go，添加新的路由和处理函数
main.go (片段)
// ... import 部分省略 ...import &quot;my-swag-app/models&quot; // 引入你的模型包// ... 全局注解部分省略 ...// GetUserByID 根据ID获取用户信息// @Summary      获取单个用户// @Description  根据给定的用户ID返回用户数据// @Tags         用户管理// @Produce      json// @Param        id   path      int  true  &quot;用户 ID&quot;// @Success      200  &#123;object&#125;  models.User// @Failure      404  &#123;object&#125;  map[string]string// @Router       /users/&#123;id&#125; [get]func GetUserByID(c *gin.Context) &#123;    // 实际项目中这里应该是查询数据库的逻辑    // 我们这里为了演示，直接返回一个假数据    id := c.Param(&quot;id&quot;)    if id == &quot;1&quot; &#123;        user := models.User&#123;ID: 1, Name: &quot;John Doe&quot;, Age: 30&#125;        c.JSON(http.StatusOK, user)        return    &#125;    c.JSON(http.StatusNotFound, gin.H&#123;&quot;error&quot;: &quot;User not found&quot;&#125;)&#125;// CreateUser 创建一个新用户// @Summary      创建用户// @Description  从请求体中接收用户信息并创建一个新用户// @Tags         用户管理// @Accept       json// @Produce      json// @Param        user   body      models.User  true  &quot;用户信息&quot;// @Success      201    &#123;object&#125;  models.User// @Failure      400    &#123;object&#125;  map[string]string// @Router       /users [post]func CreateUser(c *gin.Context) &#123;    var user models.User    // 将请求体中的 JSON 绑定到 user 结构体    if err := c.ShouldBindJSON(&amp;user); err != nil &#123;        c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)        return    &#125;    // 实际项目中这里是存入数据库的逻辑    // 我们这里为了演示，假装设置一个ID并返回    user.ID = 2     c.JSON(http.StatusCreated, user)&#125;func main() &#123;    // ...    r := gin.Default()    // 用户管理 API 路由组    userRoutes := r.Group(&quot;/users&quot;)    &#123;        userRoutes.GET(&quot;/:id&quot;, GetUserByID)        userRoutes.POST(&quot;&quot;, CreateUser)    &#125;    r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler))    // ...    r.Run(&quot;:8080&quot;)&#125;

操作步骤：

保存以上代码。
在终端运行 swag init。
运行 go run main.go。
访问 http://localhost:8080/swagger/index.html。

你会看到一个新的 “用户管理” 分组，里面包含了我们刚刚定义的两个 API。点开 “创建用户” (POST /users)，你会发现它的请求体部分已经为你生成了一个包含 name 和 age 的 JSON 示例，这就是 @Param 引用 models.User 结构体的强大之处！

本章小结我们详细学习了 swag 最核心的几类注解：

身份注解：@Summary, @Description, @Tags，用于描述 API 的基本信息。
请求注解：@Param，用于定义输入的参数，是功能最强大的注解。
响应注解：@Success, @Failure，用于定义不同情况下的输出。
路由注解：@Router，用于将所有信息与 URL 和 HTTP 方法绑定。

掌握了这些，你就掌握了 swag 的 80%。剩下的就是不断练习，熟悉各种参数位置 (query, path, body 等) 和数据类型 (基础类型、自定义结构体、数组) 的组合使用。
接下来，我们将简单聊聊 swag 到底是怎么工作的，揭开它神秘的“魔法”面纱。
到现在为止，你已经掌握了 swag 的使用方法，能够熟练地通过写注释来生成漂亮的 API 文档了。对你来说，swag 可能还像一个神奇的“黑盒子”：我写了注释，敲了命令，漂亮的网页就出来了。
这一章，我们就来打开这个“黑盒子”，用最简单的方式看一看它内部的构造。理解了它的工作原理，你不仅能更好地使用它，还能在遇到问题时，更快地找到原因。

第5章：揭秘 Swag：它是如何工作的？swag 并不是真的有什么“魔法”，它本质上是一个代码解析器和文件生成器的组合。它的整个工作流程，就像一个高度自动化的工厂流水线。
让我们把 swag init 这个命令的执行过程拆解成三个主要步骤：
步骤一：扫描与解析（流水线的第一站：原材料检验）当你运行 swag init 时，swag 工具首先会像一个勤劳的机器人，开始扫描你项目中的所有 .go 文件。
但它不是漫无目的地扫描，它的目标非常明确：寻找那些以 // @ 开头的特殊注释行。
在这个过程中，它利用了 Go 语言自带的一个强大工具包——go/ast (Abstract Syntax Tree，抽象语法树)。

什么是抽象语法树（AST）？你可以把它想象成对你代码的一种“结构化解剖”。go/ast 包能够把你的 Go 代码文本，转换成一个程序能够理解的、树状的数据结构。在这棵“树”上，每个节点都代表了代码的一部分，比如一个函数声明、一个变量定义、或者一行注释。
生活中的类比：这就像一位语法老师在分析一个句子：“勤劳的小明（主语）昨天（状语）高兴地（状语）完成了（谓语）家庭作业（宾语）。”老师并不是把这句话当成一串无意义的文字，而是解析出了它的语法结构。
swag 就是这样一位“语法老师”，它能准确地识别出：“哦，这行注释 // @Summary 获取用户信息 是挂在 GetUserByID 这个函数声明节点上面的！”


通过这种方式，swag 就能把注解和它们所描述的函数精确地关联起来。
步骤二：翻译与整合（流水线的第二站：加工与组装）swag 找到了所有的注解和它们对应的代码结构后，就开始了“翻译”工作。
它的目标是生成一份遵循 OpenAPI 3.0 规范（或旧版的 Swagger 2.0）的 swagger.json 或 swagger.yaml 文件。

什么是 OpenAPI 规范？它是一个用来描述 RESTful API 的国际标准格式。你可以把它理解成 API 界的“普通话”。这份规范用 JSON 或 YAML 格式，极其严谨地定义了描述一个 API 所需的全部元素：路径、操作（GET&#x2F;POST）、参数、请求体、响应、数据模型等等。全世界有成千上百的工具都认识这门“普通话”，比如 Postman、Swagger UI 等。

swag 的翻译工作就是把 swag 自定义的注解格式，转换成 OpenAPI 规范的标准格式。

// @Summary 获取用户信息  -&gt;  会被翻译成 JSON 中 summary 字段。
// @Param id path int true &quot;用户ID&quot; -&gt; 会被翻译成 parameters 数组中的一个对象，里面详细定义了 name: &quot;id&quot;, in: &quot;path&quot;, required: true, schema: { &quot;type&quot;: &quot;integer&quot; } 等等。
// @Success 200 {object} models.User -&gt; 会被翻译成 responses 对象下的 200 字段，并且会去解析 models.User 这个结构体，把它也转换成 OpenAPI 规范里的 schemas 定义。

所有 API 的信息都被翻译和整合后，最终形成一个巨大的、结构化的 swagger.json 文件。这个文件才是 swag 的核心产物。
你可以打开你项目 docs 目录下的 swagger.json 文件看一看，虽然内容很多，但仔细观察，你就能找到和你写的注解一一对应的字段。
步骤三：打包与呈现（流水线的最后一站：包装与上架）swag 生成了标准的 swagger.json 文件，但这个 JSON 文件是给机器看的，对人类并不友好。所以，还需要最后一步：展示。
这一步其实主要由两个我们之前安装的库来完成：

github.com/swaggo/files这个库里内置了 Swagger UI 的所有静态资源文件（HTML, CSS, JavaScript）。Swagger UI 是一个开源项目，它的唯一工作就是读取 OpenAPI 规范文件（比如我们的 swagger.json），并把它渲染成我们看到的那个漂亮的、可交互的网页。

github.com/swaggo/gin-swagger这是一个适配器（Adapter），它的作用是把 Swagger UI 和 Gin 框架无缝地结合起来。我们在 main.go 里写的那行代码：
r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler))

它的意思就是：创建一个路由 /swagger/，当用户访问这个地址时，就由 gin-swagger 这个“中间人”来处理。它会负责加载 swaggo/files 里的 HTML 页面，并把我们生成的 docs/swagger.json 文件的内容喂给这个页面。


于是，当你在浏览器里访问 http://localhost:8080/swagger/index.html 时：

Gin 框架匹配到路由，请求被 gin-swagger 接管。
gin-swagger 返回 Swagger UI 的主 HTML 页面。
浏览器加载这个 HTML 页面，页面里的 JavaScript 代码会去请求 /swagger/doc.json (这是 gin-swagger 自动配置的另一个内部路由)。
gin-swagger 读取我们项目里 docs/swagger.json 文件的内容，并返回给浏览器。
Swagger UI 的 JavaScript 拿到 JSON 数据后，动态地在页面上渲染出所有的 API 列表、参数输入框、示例等等。

至此，整个流程全部完成！

本章小结现在，我们再回头看 swag，它是不是清晰多了？

swag init 命令做了什么？

解析 (Parse)：使用 go/ast 解析 Go 源代码，找到 @ 注解和它们关联的函数。
生成 (Generate)：将解析到的信息，翻译成标准的 swagger.json 和 swagger.yaml 文件，并存放在 docs 目录。
创建入口 (Create Entrypoint)：生成一个 docs/docs.go 文件，这个文件里包含了生成的 JSON&#x2F;YAML 数据，并注册自己，让 gin-swagger 这样的库能找到它。


程序运行时发生了什么？

gin-swagger 负责创建一个路由。
swaggo/files 提供了 Swagger UI 的静态页面。
当用户访问文档页时，gin-swagger 把 docs/swagger.json 的内容提供给 Swagger UI 的前端页面进行渲染。



理解了这个原理，你就能明白为什么每次修改了注解之后，都必须重新运行 swag init。因为 swagger.json 文件不会自动更新，你必须手动触发这个“翻译和生成”的过程。
好了，原理我们已经搞懂了。在学习的最后，我将为你总结一些新手常遇到的“坑”以及一些最佳实践，帮助你在未来的使用中少走弯路。
好的，同学！我们已经到达了学习之旅的尾声。
你现在已经知道了 swag 是什么，怎么用，以及它背后的工作原理。可以说，你已经从一个“小白”成长为一名合格的 swag 使用者了。
但在实际的开发道路上，我们总会遇到一些小石子、小水坑。这一章，作为老师，我将把我的一些经验传授给你，帮你提前识别并绕开这些常见的“坑”，让你的 swag 之旅更加顺畅。

第6章：避坑指南：使用 Swag 的注意事项这一章更像是一份“温馨提示清单”。当你遇到问题时，不妨回来查阅一下，很可能答案就在这里。
1. 忘了这一步，一切都白费：swag init
现象：我明明在代码里改了注解，为什么刷新文档页面一点变化都没有？
原因：这是99%的新手都会犯的错误。swag 不会实时监控你的代码变化。文档页面依赖的是 docs 目录下的 swagger.json 文件，而这个文件只有在你运行 swag init 命令时才会被更新。
黄金法则：每次修改完任何 @ 注解后，都必须重新在项目根目录下执行 swag init 命令。
进阶技巧：可以结合一些文件监控工具（如 air、fresh 等），配置成在 .go 文件保存时自动执行 swag init，实现自动化。


2. 神秘的 import _ &quot;...&quot;
现象：我运行了 swag init，docs 目录也生成了，程序也能跑，但访问文档页时一片空白，或者提示 “Failed to load API definition.”。

原因：swag 在生成 docs/docs.go 文件时，会使用一个 init() 函数来注册生成的 swagger 规范。为了让你的主程序能够执行到这个 init() 函数，你必须在你的 main.go（或者程序的入口文件）里匿名导入（import _ &quot;...&quot;）这个 docs 包。

正确姿势：确保你的 main.go 中有下面这行代码，并且路径正确。
import _ &quot;my-swag-app/docs&quot; // &quot;my-swag-app&quot; 是你 go.mod 文件里定义的模块名

匿名导入的 _ 意味着：我不需要使用这个包里的任何变量或函数，我只是想让你这个包的代码被加载，从而执行它的 init() 函数。



3. 结构体（Struct）无法正确解析
现象：我在 @Success 或 @Param 中引用了一个自定义的结构体，比如 models.User，但是在文档页面上，这个模型（Model）的字段显示不出来，或者是空的。

原因与解决方案：

没有写 json 标签：swag 默认通过 json:&quot;...&quot; 标签来识别字段名。请确保你的结构体字段都有这个标签。
// 错误示例type User struct &#123;    ID int&#125;// 正确示例type User struct &#123;    ID int `json:&quot;id&quot;`&#125;

字段是私有的：Go 语言中，首字母小写的字段是包内私有的，swag 无法在外部解析它们。请确保所有需要展示在文档中的字段名首字母大写。
// 错误示例type User struct &#123;    id int `json:&quot;id&quot;`&#125;// 正确示例type User struct &#123;    ID int `json:&quot;id&quot;`&#125;

引用了其他包的结构体：如果你的结构体引用了来自其他第三方库的结构体，swag 可能无法解析它。解决方法是创建一个新的、你自己的结构体（有时称为 DTO - Data Transfer Object），只包含你需要的字段，然后在你的处理函数中进行数据转换。





4. @Param 和 @Router 的路径参数不匹配
现象：定义了路径参数，但在文档里无法正确渲染，或者在线调试时参数没有传递。

原因：@Param 注解中定义的路径参数名，必须和 @Router 注解中的占位符完全一致。

正确姿势：
// @Param   userID   path      int  true  &quot;用户 ID&quot;// @Router /users/&#123;userID&#125; [get] // 这里都是 userID，保持一致// 错误姿势// @Param   id   path      int  true  &quot;用户 ID&quot;// @Router /users/&#123;userID&#125; [get] // 一个是 id，一个是 userID，不匹配，会出错


5. 全局注解（main 函数上方）到底写在哪？
规定：swag 会扫描整个项目来寻找 API 注解（写在 Handler 函数上的），但全局注解只会寻找 main 包（也就是包含 func main() 的那个文件）里的注释。
最佳实践：始终将 @title, @version, @host 等全局注解写在 main.go 文件中 main 函数的上方。不要把它们放在其他文件里，否则 swag 会找不到。


6. 文档部署到服务器上访问不了？—— @host 和 @BasePath 的重要性
现象：文档在本地 localhost:8080 访问完全正常，但部署到服务器上（比如 api.mydomain.com/v1）之后，在线调试功能 (“Try it out”) 点击 “Execute” 没反应，或者请求的地址不对。

原因：swag 文档页面里的调试工具，会根据 @host 和 @BasePath 来拼接最终的请求 URL。如果你这里写的是 localhost:8080，那无论你在哪里访问这个文档，它都会往 localhost:8080 发请求。

部署时的正确配置：
// @host      api.mydomain.com// @BasePath  /v1

这样配置后，swag 生成的文档在调用 /users/{id} 这个 API 时，就会正确地请求 http://api.mydomain.com/v1/users/{id}。

动态配置：在不同的环境（开发、测试、生产）中，host 可能会不同。你可以考虑使用 swag 的一些高级功能，或者编写脚本，在持续集成&#x2F;持续部署（CI&#x2F;CD）流程中动态地修改这些注解或生成的 swagger.json 文件。



本章小结我们总结了几个最常见的新手问题和注意事项：

改完注解，必跑 swag init。
检查 main.go 是否有 import _ &quot;...&quot;。
结构体字段必须首字母大写，并有 json 标签。
@Param 和 @Router 的路径参数名要一致。
全局注解写在 main 函数之上。
部署时，正确配置 @host 和 @BasePath。

记住这些，可以帮你节省大量的调试时间。现在，我们来进行最后的内容总结，并展望一下未来。
经过前面六个章节的学习和实践，你已经从一个对 swag 毫无概念的小白，成长为一名能够独立使用它来为 Go 项目生成专业 API 文档的开发者了。
现在，让我们一起花几分钟时间，回顾一下我们走过的路，并看看前方的风景。

第7章：总结与下一步7.1 我们的学习回顾（我们学到了什么？）让我们像看电影回放一样，快速过一遍本次学习的核心要点：

问题的起源（第1章）：我们明白了为什么需要 API 文档，以及手动维护文档是多么痛苦。这是我们学习 swag 的根本动机——自动化，让代码与文档同步。

Swag 的真面目（第2章）：我们认识了 swag，知道它是一个能将 Go 代码中的特殊注释，自动转换为交互式 API 网页的“魔法”工具。这个网页不仅好看，还能在线调试。

第一次亲密接触（第3章）：我们亲手实践了 swag 的三步走核心流程：安装工具 -&gt; 添加注解 -&gt; 运行 swag init 生成文档。你成功生成了人生中第一个由代码自动生成的 API 文档！

“魔法咒语”大全（第4章）：我们深入学习了 swag 的各种注解，如 @Summary, @Tags, @Param, @Success, @Router 等，并学会了如何使用它们来精确描述一个 API 的方方面面，包括如何引用自定义的结构体。

揭开魔法的面纱（第5章）：我们探究了 swag 的工作原理，了解到它并非魔法，而是一个代码解析器 + OpenAPI 规范生成器。这个过程让我们知其然，更知其所以然。

前人的智慧（第6章）：我们总结了新手在使用 swag 时最容易遇到的几个“坑”，比如忘记运行 swag init、匿名导入路径错误等，为未来的实战扫清了障碍。


到此，你已经构建起了一个关于 swag 的完整知识体系。恭喜你，你已经掌握了一项能极大提升开发效率和团队协作质量的实用技能！

7.2 知识的延伸（接下来可以学什么？）学习永无止境。当你熟练掌握了 swag 的基础用法后，你可能还想探索更多，这里我为你指出几个可以继续深入的方向：

深入 OpenAPI 规范：swag 只是一个生成器，它所遵循的 OpenAPI 规范才是 API 描述领域的核心。花一点时间去阅读 OpenAPI 3.0 的官方文档，你会对 API 设计有更深刻的理解，也能解锁 swag 注解中更多高级的用法（比如定义安全策略 Security、组件 Components 等）。

探索更复杂的注解：我们这次学习主要覆盖了最常用的注解。swag 还支持更多高级注解，例如：

@Security: 用于定义 API 的认证方式，比如 JWT Token, API Key, OAuth2 等。
@Accept &#x2F; @Produce: 除了 json，还支持 xml, html, plain 等多种格式。
@Example: 为请求体或响应体提供更具体的示例。


自动化 swag init：在实际项目中，每次修改都手动运行 swag init 还是有些繁琐。你可以研究一下如何将其集成到你的开发流程中。比如使用 air 这个 Go 的热重载工具，在配置文件中添加一条命令，让它在监控到 .go 文件变化时，自动帮你执行 swag init。

尝试其他 Go Web 框架：我们这次课程用的是 Gin 框架。swag 社区也为其他流行的 Go 框架提供了适配器，比如 Echo, Fiber, Chi 等。你可以尝试在不同的框架中使用 swag，加深理解。



7.3 最后的叮嘱同学，工具是为人服务的。swag 的价值不仅仅在于生成一份漂亮的文档，更在于它背后所倡导的一种**“文档驱动”或“代码即文档”**的开发理念。
养成在写代码的同时，就写好注解的习惯，这会让你未来的自己和你的同事都感激不尽。一份清晰、准确、永远与代码同步的 API 文档，是专业软件项目中不可或缺的一环。
希望这次学习笔记能真正帮助到你。如果在未来的学习和工作中遇到任何问题，随时都可以回来复习。
现在，合上笔记，去你的项目中，开始享受 swag 带来的便捷和快乐吧！
祝你编程愉快！
附录Swagger 注解参考与实战模板（Swag for Go）
适用于 github.com/swaggo/swag + github.com/swaggo/gin-swagger文件可直接放入项目 /docs/ 目录供开发参考。


一、常用注解说明表（带调用示例）


注解名
作用
常用位置
说明
示例注解
API 调用示例



@Summary
接口简要描述
函数顶部
展示在 Swagger UI 接口列表中
// @Summary 获取用户信息
——


@Description
接口详细描述
函数顶部
可多行描述细节、约束等
// @Description 根据用户ID查询详细资料
——


@Tags
接口分组
函数顶部
Swagger 左侧菜单分组
// @Tags 用户管理
——


@Accept
接收类型
函数顶部
json, multipart/form-data, x-www-form-urlencoded 等
// @Accept json
——


@Produce
响应类型
函数顶部
json, xml, plain 等
// @Produce json
——


@Param (query)
URL 查询参数
函数顶部
@Param name query string true &quot;用户名&quot;，true为必填，false为可选
// @Param name query string true &quot;用户名&quot;
GET /api/user?name=Tom


@Param (path)
路径参数
函数顶部
URL 占位符参数（REST 风格），必填（一般必须为 true，因为路径里必须有值）
// @Param id path int true &quot;用户ID&quot;
GET /api/user/123


@Param (header)
Header 参数
函数顶部
适合传 Token 或版本号，true为必填，false为可选
// @Param Authorization header string true &quot;Bearer Token&quot;
curl -H &quot;Authorization: Bearer XXX&quot; ...


@Param (formData)
表单参数
函数顶部
用于 POST 的表单数据，true为必填，false为可选
// @Param username formData string true &quot;用户名&quot;
POST /login  (username=Tom&amp;password=123)


@Param (file)
文件上传参数
函数顶部
multipart/form-data，true为必填，false为可选
// @Param file formData file true &quot;上传文件&quot;
curl -F &quot;file=@avatar.png&quot; /upload/avatar


@Param (body)
JSON 请求体
函数顶部
用于 POST&#x2F;PUT 请求体，true为必填，false为可选
// @Param data body User true &quot;用户信息&quot;
POST /user {&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:18}


@Param (cookie)
Cookie 参数
函数顶部
从 cookie 读取数据，true为必填，false为可选
// @Param session cookie string false &quot;Session ID&quot;
Cookie: session=abcd1234


@Success
成功返回
函数顶部
定义返回结构体与 HTTP 码
// @Success 200 {object} User &quot;返回用户信息&quot;
响应体：{&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;}


@Failure
失败返回
函数顶部
描述错误信息结构体
// @Failure 400 {object} ErrorResponse &quot;参数错误&quot;
响应体：{&quot;code&quot;:400,&quot;msg&quot;:&quot;invalid&quot;}


@Router
路由定义
函数顶部
指定接口路径与方法
// @Router /user/{id} [get]
GET /user/123


@Security
鉴权机制
函数顶部
对应 securityDefinitions
// @Security ApiKeyAuth
curl -H &quot;Authorization: Bearer TOKEN&quot; ...


@Deprecated
废弃标记
函数顶部
标记接口为过时
// @Deprecated
——



二、@Param 类型详细表（含请求示例）


类型
用途
数据类型
示例注解
API 请求示例



query
URL 参数
string&#x2F;int&#x2F;bool
@Param user_id query int true &quot;用户ID&quot;
/user?user_id=1


path
路径参数
string&#x2F;int
@Param id path int true &quot;用户ID&quot;
/user/1


header
请求头
string
@Param Authorization header string true &quot;Token&quot;
curl -H &quot;Authorization: Bearer abc&quot;


formData
表单数据
string&#x2F;int
@Param username formData string true &quot;用户名&quot;
curl -d &quot;username=Tom&quot;


formData(file)
上传文件
file
@Param file formData file true &quot;上传头像&quot;
curl -F &quot;file=@a.png&quot;


body
JSON 请求体
object
@Param data body User true &quot;用户信息&quot;
curl -X POST -d &#39;{&quot;name&quot;:&quot;Tom&quot;}&#39;


cookie
Cookie
string
@Param session cookie string false &quot;Session ID&quot;
Cookie: session=abcd


三、@Success &#x2F; @Failure 的 {类型} 参数@Success &#x2F; @Failure 的 {类型} 参数支持哪些格式？在 swaggo（github.com/swaggo/swag）中，@Success &#x2F; @Failure 注解的语法如下：
@Success &lt;HTTP状态码&gt; &#123;&lt;类型&gt;&#125; &lt;数据模型&gt; &quot;&lt;描述&gt;&quot;

其中 {&lt;类型&gt;} 是用于 描述响应数据结构的，常见取值如下：



{类型}
含义
适用场景
示例



object对象
返回的是结构体对象（JSON 对象）
最常见，接口返回 JSON 时通常是这个
// @Success 200 {object} models.LoginResp


array数组
返回的是数组（JSON 数组）
列表、分页等场景
// @Success 200 {array} models.UserResp


string字符串
返回纯文本字符串
错误提示、状态文本等
// @Failure 500 {string} string &quot;内部错误&quot;


integer整型
返回纯数值（整数）
简单的状态码或数量
// @Success 200 {integer} int &quot;成功状态码&quot;


number数字
返回浮点数
例如温度、坐标等
// @Success 200 {number} float64 &quot;测量值&quot;


boolean布尔
返回 true&#x2F;false 布尔值
状态检查类接口
// @Success 200 {boolean} bool &quot;是否在线&quot;


file文件
返回文件（二进制流）
文件下载接口
// @Success 200 {file} file &quot;导出的Excel文件&quot;



如果你的接口返回 JSON —— 应该用 {object} 或 {array}，而不是 {string}这是最关键的一点：

⚠️ 即使你的响应是 “JSON 字符串格式”，也应该写 {object}，因为 swagger 的目的不是展示原始传输内容，而是展示数据结构。

举例说明：
假设接口返回：
&#123;  &quot;code&quot;: 200,  &quot;msg&quot;: &quot;ok&quot;,  &quot;data&quot;: &#123;    &quot;user_id&quot;: 123,    &quot;name&quot;: &quot;Tom&quot;  &#125;&#125;

你应该写成：
// @Success 200 &#123;object&#125; models.CommonResp &quot;请求成功&quot;

而不是：
// ❌ 错误：这样 swagger 只会认为是纯文本// @Success 200 &#123;string&#125; string &quot;返回JSON字符串&quot;

因为 {string} 告诉 swagger：返回的是纯文本，而 swagger UI 就不会解析字段结构，也不会显示字段说明。

几个常见的写法对比表


返回内容
推荐写法
错误写法
说明



JSON 对象（结构体）
{object} models.Resp
{string} string
应描述结构体，而非字符串


JSON 数组
{array} models.Item
{string} string
swagger 会显示为数组元素类型


普通字符串
{string} string
{object}
简单文本响应


文件流
{file} file
{object}
特殊响应类型（下载）



完整例子// @Summary 登录接口// @Description 用户通过账号密码登录// @Tags 用户// @Accept json// @Produce json// @Param data body models.LoginReq true &quot;登录请求体&quot;// @Success 200 &#123;object&#125; models.LoginResp &quot;登录成功&quot;// @Failure 400 &#123;object&#125; models.ErrorResp &quot;请求错误&quot;// @Failure 500 &#123;string&#125; string &quot;服务器内部错误&quot;// @Router /api/v1/login [post]func Login(c *gin.Context) &#123;    // ...&#125;


小结一句话记住：


返回类型
对应 swagger 类型
备注



Go 结构体 &#x2F; map
{object}
最常用


Go 切片 &#x2F; 数组
{array}
✅


Go stringGo 字符串
{string}
✅


Go int &#x2F; int64Go int &#x2F; int64 整数 &#x2F; 整数 64
{integer}
✅


Go float32 &#x2F; float64
{number}
✅


Go boolGo 布尔
{boolean}
✅


文件下载
{file}
✅



三、结构体定义示例type User struct &#123;    ID   int    `json:&quot;id&quot; example:&quot;1&quot;`    Name string `json:&quot;name&quot; example:&quot;Tom&quot;`    Age  int    `json:&quot;age&quot; example:&quot;25&quot;`&#125;type ErrorResponse struct &#123;    Code int    `json:&quot;code&quot; example:&quot;400&quot;`    Msg  string `json:&quot;msg&quot; example:&quot;参数错误&quot;`&#125;


四、接口模板（全部注解示例）获取用户信息（GET + Path）// @Summary 获取用户信息// @Description 通过用户ID获取详细信息// @Tags 用户管理// @Accept json// @Produce json// @Param id path int true &quot;用户ID&quot;// @Param token header string false &quot;访问令牌&quot;// @Success 200 &#123;object&#125; User &quot;用户信息&quot;// @Failure 400 &#123;object&#125; ErrorResponse &quot;参数错误&quot;// @Failure 404 &#123;object&#125; ErrorResponse &quot;用户不存在&quot;// @Router /user/&#123;id&#125; [get]func GetUser(c *gin.Context) &#123; ... &#125;// 调用示例：// GET ./user/123// Header: Authorization: Bearer TOKEN


创建用户（POST + Body）// @Summary 创建新用户// @Description 使用 JSON 提交用户数据// @Tags 用户管理// @Accept json// @Produce json// @Param data body User true &quot;用户信息&quot;// @Success 201 &#123;object&#125; User &quot;创建成功&quot;// @Failure 400 &#123;object&#125; ErrorResponse &quot;参数错误&quot;// @Router /user [post]func CreateUser(c *gin.Context) &#123; ... &#125;// 调用示例：// POST ./user// Body: &#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:25&#125;


用户登录（POST + FormData）// @Summary 用户登录// @Description 表单提交方式登录// @Tags 登录认证// @Accept x-www-form-urlencoded// @Produce json// @Param username formData string true &quot;用户名&quot;// @Param password formData string true &quot;密码&quot;// @Success 200 &#123;string&#125; string &quot;登录成功&quot;// @Failure 401 &#123;object&#125; ErrorResponse &quot;用户名或密码错误&quot;// @Router /login [post]func Login(c *gin.Context) &#123; ... &#125;// 调用示例：// POST ./login// Body: username=Tom&amp;password=123456


上传头像（POST + File）// @Summary 上传头像// @Description 上传用户头像文件// @Tags 文件上传// @Accept multipart/form-data// @Produce json// @Param user_id formData int true &quot;用户ID&quot;// @Param file formData file true &quot;头像文件&quot;// @Success 200 &#123;string&#125; string &quot;上传成功&quot;// @Failure 400 &#123;object&#125; ErrorResponse &quot;文件无效&quot;// @Router /upload/avatar [post]func UploadAvatar(c *gin.Context) &#123; ... &#125;// 调用示例：// curl -F &quot;user_id=1&quot; -F &quot;file=@avatar.png&quot; ./upload/avatar


带鉴权接口（Header + Security）// @Summary 获取当前用户资料// @Description 需要登录并携带 Bearer Token// @Tags 用户资料// @Security ApiKeyAuth// @Accept json// @Produce json// @Param Authorization header string true &quot;Bearer Token&quot;// @Success 200 &#123;object&#125; User &quot;用户信息&quot;// @Failure 401 &#123;object&#125; ErrorResponse &quot;未授权&quot;// @Router /profile [get]func GetProfile(c *gin.Context) &#123; ... &#125;// 调用示例：// GET ./profile// Header: Authorization: Bearer eyJhbGci...


Cookie 示例接口// @Summary 检查用户会话// @Description 根据 Cookie 中的 session 判断是否登录// @Tags 登录认证// @Accept json// @Produce json// @Param session cookie string false &quot;Session ID&quot;// @Success 200 &#123;string&#125; string &quot;Session 有效&quot;// @Failure 401 &#123;string&#125; string &quot;未登录&quot;// @Router /session/check [get]func CheckSession(c *gin.Context) &#123; ... &#125;// 调用示例：// GET ./session/check// Cookie: session=abc123


五、Swagger 安全认证定义示例（在 docs&#x2F;init.go 中）// @securityDefinitions.apikey ApiKeyAuth// @in header// @name Authorization


六、小结


常见场景
推荐注解组合
示例路径



GET 查询
@Param query/path + @Success
/user/{id}


POST 创建
@Param body + @Accept json
/user


表单提交
@Param formData + @Accept x-www-form-urlencoded
/login


文件上传
@Param file formData file + @Accept multipart/form-data
/upload/avatar


认证接口
@Security ApiKeyAuth + @Param header
/profile


]]></content>
      <categories>
        <category>技术</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>使用教程</tag>
        <tag>AI</tag>
        <tag>protected</tag>
        <tag>Golang</tag>
        <tag>三方库</tag>
        <tag>swag</tag>
      </tags>
  </entry>
  <entry>
    <title>Office操作指南</title>
    <url>/2024/04/22/Office%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[快捷操作f4：重做上一次的动作
截取指定的文本从绝对地址中截取文件名在Excel中，你可以使用函数MID和FIND来从绝对地址中截取文件名。假设你的绝对地址保存在单元格A1中，下面是截取文件名的公式：
复制代码=MID(A1, FIND(&quot;*&quot;, SUBSTITUTE(A1, &quot;\&quot;, &quot;*&quot;, LEN(A1)-LEN(SUBSTITUTE(A1, &quot;\&quot;, &quot;&quot;)))) + 1, LEN(A1) - FIND(&quot;*&quot;, SUBSTITUTE(A1, &quot;\&quot;, &quot;*&quot;, LEN(A1)-LEN(SUBSTITUTE(A1, &quot;\&quot;, &quot;&quot;)))))

通过上述公式，你就可以从绝对地址中提取文件名了。请确保在使用时将单元格引用替换为实际的绝对地址。
后续有多少数据，都显示标题（首行或首列）
打开你的Excel表格。
滚动到你想保持可视的第一行标题行的正下方。
点击菜单栏中的“视图”选项卡。
在“窗口”组中，点击“冻结窗格”按钮，然后选择“冻结首行”。

这样设置后，当你向下滚动查看数据时，第一行标题会始终停留在屏幕顶部。
另外，如果你希望在打印时每页都显示这些标题行，你需要进行以下操作：

转到“页面布局”标签页。
点击“页面设置”组中的“打印标题”按钮，这将打开“页面设置”对话框。
在“页面设置”对话框中，找到“工作表”选项卡。
在“顶端标题行”输入框旁的按钮上点击，然后在工作表中选择你想要作为顶端标题重复出现的那一行（通常是第一行）。
点击“确定”保存设置。

通过以上步骤，无论是编辑状态下滚动查看还是打印输出时，第一行标题都会保持可见。
限制某一列只能输入某几个值
选择你想要设置限制的列。如果你只想限制一列中的某些单元格，也可以直接选择这些单元格。
转到“数据”选项卡。
在“数据工具”组中，点击“数据验证”按钮（可能显示为“数据验证”或“数据有效性”取决于你的Excel版本）。
在弹出的“数据验证”对话框中，首先确保“设置”选项卡是激活状态。
在“允许”下拉列表中，选择“序列”。
在“来源”框中，输入你允许填写的值，各值之间用逗号隔开。例如，如果你希望该列只能输入“是”或“否”，则输入“是,否”（不带引号）。
如果需要，你可以在“输入信息”或“出错警告”标签页中设置提示信息，当用户尝试输入数据时，这些信息会显示为帮助或警告。比如，你可以在“输入信息”中写“请输入’是’或’否’”以指导用户正确输入。
点击“确定”完成设置。

现在，当你或他人尝试在该列输入除指定值之外的内容时，Excel会显示警告，并阻止输入，除非更改成允许的值之一。
限制某一列不允许重复在Excel中，要限制某一列输入的值不能重复，即实现唯一性验证，可以通过数据验证功能来完成。以下是具体的操作步骤：

选择你想要防止出现重复值的整列或特定单元格范围。

转到“数据”选项卡。

在“数据工具”组中，点击“数据验证”按钮（可能显示为“数据验证”或“数据有效性”取决于你的Excel版本）。

在弹出的“数据验证”对话框中，确保当前选中的是“设置”选项卡。

在“允许”下拉菜单中，选择“自定义”。

在“公式”框中，输入以下公式（假设你选择的是A列，要根据实际情况调整列字母）:
Code
1=COUNTIF($A:$A,A1)&lt;2

这个公式的意思是检查当前单元格（如A1）的值在整个A列中是否出现少于2次，也就是保证了唯一性。

点击“确定”应用设置。


完成上述设置后，如果有人尝试在该列输入一个已经存在的值，Excel会显示错误警告，阻止输入重复值。
请注意，这种设置是在数据输入时进行验证，对于已经存在于列中的重复值不会自动删除或标记。如果需要检查并处理已有的重复数据，你可能需要使用“条件格式”突出显示重复项，或者使用“数据”选项卡下的“删除重复项”功能来清理数据。
标记某一列中重复的数据在Excel中，若想将重复的单元格设置为特定的样式以便于识别，可以使用“条件格式”功能。以下是设置步骤：

选择范围：首先，选择你想要检查重复值并设置样式的单元格区域。如果你希望对整个列应用此格式，可以点击列标题（如A列就点击A），或者拖拽选择整个列。
应用条件格式：
转到“开始”选项卡，在“样式”组中点击“条件格式”按钮。
在下拉菜单中，选择“突出显示单元格规则”。
接着，从子菜单中选择“重复值”。


设置格式：
会出现一个对话框，询问你如何标记重复值。在这里，你可以选择预设的格式样式，比如浅红填充色深红色文本、绿色填充色等。
如果你不满意预设样式，可以点击“自定义格式…”按钮来自定义填充颜色、字体颜色、边框等。
选择好格式后，点击“确定”。



完成以上步骤后，Excel会自动将选定范围内所有重复的单元格按照你设定的格式进行高亮显示，便于你快速识别和处理这些重复数据。
假设每一行数据由第1列第二列联合起来做主键，请问如何在这个基础上保证数据不会重复？在Excel中，虽然没有直接建立联合主键的功能像数据库那样，但你可以通过数据验证的自定义公式来间接实现基于两列数据联合的唯一性检查。以下是一个示例步骤，假设你要确保A列和B列的组合值是唯一的：

选择范围：选择你想要应用数据验证的起始单元格，以及你想要这个规则应用到的所有相应单元格。例如，如果你想从第二行开始应用规则，可以选择A2:B最后一行。

应用数据验证：

转到“数据”选项卡，在“数据工具”组中点击“数据验证”按钮。
在弹出的“数据验证”对话框中，选择“设置”标签页。
在“允许”下拉菜单中选择“自定义”。


输入自定义公式：

在“公式”框中输入以下自定义公式（这里以A列和B列为例，根据你的实际列调整）:
Code
1=AND(COUNTIFS(A:A,A2,B:B,B2)=1,COUNTIFS(B:B,B2,A:A,A2)=1)

这个公式会检查当前行的A列和B列组合是否在A列和B列的其他任何地方出现过。



完成设置：

点击“确定”应用数据验证规则。



请注意，这个方法适用于手动数据输入时的即时验证。如果你的数据集很大或者经常需要批量导入数据，这种方法可能不够高效，因为Excel不会主动去检查整个数据集的唯一性，而是在用户尝试输入数据时才进行验证。对于这种情况，你可能需要先使用Excel的“删除重复项”功能检查并处理已有的重复数据，或者在数据输入前通过编程手段（如VBA宏）来实现更复杂的校验逻辑。
]]></content>
      <categories>
        <category>Office</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>Office</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang validator 库</title>
    <url>/2025/10/06/Golang_validator/</url>
    <content><![CDATA[Golang validator 库概览第1章：为什么需要“数据检查员”？—— validator 库简介

（本章核心：用一个生活中的例子，让你明白为什么程序里需要一个专门检查数据的工具。）

第2章：上岗第一天！—— validator 的基本使用

（本章核心：手把手带你完成最简单的“检查”任务，让你对 validator 的工作流程有个整体印象。）

第3-1章：检查员的“规则手册”—— 常用验证标签（上）

（本章核心：学习最常用的检查规则，比如“不能为空”、“必须是邮箱格式”、“长度必须达标”等。）

第3-2章：检查员的“规则手册”—— 常用验证标签（下）

（本章核心：继续学习更多实用的检查规则，比如数字大小比较、多选一等，让你的检查能力变得更强。）

第4章：“检查不通过！”—— 如何看懂并处理错误信息

（本章核心：学习当数据不符合规则时，如何获取、理解并展示友好的错误提示。）

第5章：制定你自己的“特殊规则”—— 自定义验证函数

（本章核心：学习当 validator 自带规则不够用时，如何创建一条完全属于你自己的、独一无二的检查规则。）

第6章：经验之谈 —— 使用 validator 的注意事项与技巧

（本章核心：总结一些高手们在实际工作中会注意的小细节和最佳实践，帮你避免踩坑。）

第7章：实战演练 —— 用户注册信息校验

（本章核心：将前面学到的所有知识串联起来，完成一个完整的、贴近真实场景的练习。


第1章：为什么需要“数据检查员”？—— validator 库简介同学你好！在我们开始学习具体的代码之前，我想先问你一个问题：你有没有在网上注册账号或者填写表格的经历？
一定有吧！比如你在注册一个新邮箱时，如果密码栏你没填，系统会提示“密码不能为空”；如果你输入的邮箱地址不带@符号，它会说“请输入有效的邮箱格式”。
这个过程，其实就是 数据校验（Data Validation）。
生活中的“数据检查”我们来把这个场景具体化一下：
想象一下，你正在一个重要的网站上填写一份个人信息登记表。这张表上有几个栏目：

姓名: （必填）
年龄: （必填，且必须是 18 岁以上）
邮箱: （必填，且格式必须正确，比如 xxx@example.com）
个人简介: （选填，但如果填写，长度不能超过 200 字）

当你填完点击“提交”时，网站后台的程序就像一个一丝不苟的办事员。它会拿起你的表格，一项一项地检查：

“姓名填了吗？嗯，填了，通过。”
“年龄是 25，大于 18，通过。”
“邮箱是 my-email@qq.com，格式正确，通过。”
“个人简介写了 150 个字，没超过 200，通过。”

所有检查都通过后，这位“办事员”才会满意地盖上“合格”的章，把你的信息存入数据库。如果任何一项不合格，他就会把表格退给你，并告诉你哪里填错了。
程序世界的“数据检查”：又长又麻烦的 if-else在我们的 Go 程序里，我们当然也需要这样一位“办事员”。否则，用户提交了乱七八糟的数据，比如年龄填了-5岁，或者邮箱写成了“我的邮箱”，那我们的程序可能就会出问题，甚至崩溃。
在没有 validator 库之前，我们是怎么实现这个“办事员”的呢？通常是这样的：
假设我们用一个结构体 User 来表示用户提交的信息：
// User 结构体，用来存放用户注册信息type User struct &#123;    Name    string    Age     int    Email   string    Intro   string&#125;

为了检查一个 User 对象里的数据是否合格，我们可能会写一个充满 if-else 的函数：
import (    &quot;errors&quot;    &quot;strings&quot;)// 手动检查用户信息的函数func validateUserManually(user User) error &#123;    // 1. 检查姓名是不是空的    if user.Name == &quot;&quot; &#123;        return errors.New(&quot;姓名不能为空&quot;)    &#125;    // 2. 检查年龄是不是小于18岁    if user.Age &lt; 18 &#123;        return errors.New(&quot;年龄必须年满18周岁&quot;)    &#125;    // 3. 检查邮箱格式是不是正确 (一个非常简化的检查)    if !strings.Contains(user.Email, &quot;@&quot;) &#123;        return errors.New(&quot;请输入有效的邮箱格式&quot;)    &#125;        // 4. 检查个人简介长度    if len(user.Intro) &gt; 200 &#123;        return errors.New(&quot;个人简介不能超过200个字符&quot;)    &#125;    // 所有检查都通过了，返回 nil (表示没有错误)    return nil&#125;

思考一下： 上面这段代码有什么问题？
乍一看好像没问题，功能也实现了。但想象一下，如果 User 结构体有 30 个字段需要检查呢？那我们的 validateUserManually 函数是不是会变得超级长、超级复杂？每次新增或修改一个检查规则，都要小心翼翼地去改动那一大堆 if-else，非常容易出错，而且代码看起来一点也不优雅。
我们的“超级检查员”登场：validator 库为了解决这种“体力活”，社区里的大神们就开发了 validator 库。
validator 就像一个高度自动化、自带规则手册的“超级检查员”。我们不再需要手写一大堆 if-else，而是用一种更简单、更直观的方式，直接在我们的结构体上“贴标签”（在 Go 语言里这叫 Tag），告诉检查员每个字段需要遵守什么规则。
同样是上面的 User 结构体，用了 validator 之后会变成这样（先混个眼熟，下一章我们就来写）：
type User struct &#123;    Name    string `validate:&quot;required&quot;`    Age     int    `validate:&quot;required,gte=18&quot;`    Email   string `validate:&quot;required,email&quot;`    Intro   string `validate:&quot;lte=200&quot;`&#125;

你看，规则（required 表示必填，gte=18 表示大于等于18，email 表示邮箱格式）直接写在了字段的后面。代码是不是瞬间清爽了很多？
当我们把一个 User 对象交给 validator 时，它会自动读取这些“标签”，然后一次性帮我们把所有的规则都检查一遍。我们只需要处理最终的检查结果就行了。
validator 库的好处：

代码更整洁： 验证规则和数据结构定义在一起，一目了然。
开发效率高： 大量内置的常用规则（比如判空、邮箱、URL、IP地址等）开箱即用，不用自己重复造轮子。
易于维护： 修改规则只需要改动标签，而不用去动复杂的逻辑代码。
功能强大： 支持自定义规则，满足各种刁钻的检查需求。

本章小结好了，第一章的内容就是这么多。我们没有写任何实际能运行的代码，但我们搞清楚了一个最重要的问题：为什么需要 validator？

数据校验是什么？ 它是保证我们程序接收到的数据是正确、有效、符合预期的“守门员”。
为什么它很重要？ 它可以防止“垃圾数据”进入我们的系统，保证程序的稳定和安全。
传统方式的痛点？ 手写 if-else 来做校验，在字段多、规则复杂时，会变得冗长、混乱且难以维护。
validator 库的价值？ 它提供了一种声明式、自动化的方式来完成数据校验，让我们的代码更简洁、开发效率更高。

现在你已经知道了我们为什么需要这位“检查员”，下一章，我们就正式带它上岗，亲手写下第一段 validator 的代码，看看它到底是怎么工作的！
没问题，我们继续！
上一章我们理解了“为什么”，现在我们来解决“怎么做”的问题。准备好，我们要让这位“检查员”正式上岗了！

第2章：上岗第一天！—— validator 的基本使用在这一章，我们的目标非常简单：完成一次最基本的“数据检查”任务。我们会经历从“请人”（安装库）到“下达指令”（编写代码）再到“看报告”（检查结果）的全过程。
第一步：招聘检查员（安装 validator 库）在 Go 语言中，“招聘”一个外部库，就是用一个命令把它下载到你的电脑里。
打开你的终端（命令行工具），输入下面的命令然后回车：
go get github.com/go-playground/validator/v10

看到一些下载信息滚动，最后没有报红色的错误，就说明我们的“检查员”已经成功“入职”了！v10 是它的版本号，目前这是最稳定和推荐的版本。
第二步：给他一本“规则手册”（定义带标签的结构体）我们的检查员很厉害，但他不是神，他不知道你的数据需要遵守什么规则。所以，我们需要给他一本“规则手册”。在 validator 里，这本手册就是带有 validate 标签的结构体。
我们还是用上一章的 User 例子，但为了简单起见，这次我们只检查一个字段：Name。
package mainimport (    &quot;fmt&quot;    &quot;github.com/go-playground/validator/v10&quot;)// User 结构体，我们的“规则手册”type User struct &#123;    // 我们给 Name 字段贴上了一个叫 `validate` 的标签    // 标签里的 &quot;required&quot; 就是一条规则，意思是“这个字段是必填的，不能为空”    Name string `validate:&quot;required&quot;`    Age  int    // 这个字段没有标签，validator 会忽略它&#125;

看这里！ validate:&quot;required&quot; 就是我们给检查员下的指令。

validate：这是告诉 validator 库：“嘿，看这里，这个字段有检查规则！”
&quot;required&quot;：这就是具体的规则，意思是“必须有值”（不能是空字符串、0、nil 等）。

第三步：让他开始工作（创建实例并执行校验）“手册”准备好了，现在我们要创建一个“检查员”实例，然后把需要检查的数据交给他。
我们来看一个完整的、可以运行的例子：
package mainimport (    &quot;fmt&quot;    &quot;github.com/go-playground/validator/v10&quot;)// User 结构体，定义了验证规则type User struct &#123;    Name string `validate:&quot;required&quot;`    Age  int    // Age 字段没有规则，所以不会被检查&#125;func main() &#123;    // 1. 创建一个 validator “检查员”实例    validate := validator.New()    // --- 场景一：提供一份合格的数据 ---    fmt.Println(&quot;--- 场景一：合格数据 ---&quot;)    userOK := User&#123;        Name: &quot;Alice&quot;, // Name 字段有值        Age:  25,    &#125;    // 2. 把 userOK 交给检查员，让他按照结构体里的标签规则进行检查    err := validate.Struct(userOK)    // 3. 查看检查报告    if err != nil &#123;        // 如果 err 不是 nil，说明有错误，检查不通过！        fmt.Printf(&quot;数据校验失败, 错误: %v\n&quot;, err)    &#125; else &#123;        // 如果 err 是 nil，说明没错误，检查通过！        fmt.Println(&quot;数据校验成功!&quot;)    &#125;    fmt.Println(&quot;\n--- 场景二：提供一份不合格的数据 ---&quot;)    // --- 场景二：提供一份不合格的数据 ---    userFail := User&#123;        Name: &quot;&quot;, // Name 字段是空的，不符合 &quot;required&quot; 规则        Age:  30,    &#125;    // 2. 同样地，把 userFail 交给检查员检查    err = validate.Struct(userFail)    // 3. 查看检查报告    if err != nil &#123;        fmt.Printf(&quot;数据校验失败, 错误: %v\n&quot;, err)    &#125; else &#123;        fmt.Println(&quot;数据校验成功!&quot;)    &#125;&#125;

自己动手试试：把上面这段代码保存为一个 main.go 文件，然后在终端里进入到这个文件所在的目录，运行 go run main.go，看看会输出什么？
你应该会看到类似下面的结果：
--- 场景一：合格数据 ---数据校验成功!--- 场景二：不合格的数据 ---数据校验失败, 错误: Key: &#x27;User.Name&#x27; Error:Field validation for &#x27;Name&#x27; failed on the &#x27;required&#x27; tag

结果分析：

在场景一中，userOK 里的 Name 字段是 “Alice”，不为空，符合 required 规则，所以 validate.Struct() 返回的 err 是 nil，程序打印“数据校验成功!”。
在场景二中，userFail 里的 Name 字段是空字符串 &quot;&quot;，违反了 required 规则，所以 validate.Struct() 返回了一个具体的错误信息，程序打印了“数据校验失败”和那串有点难懂的错误。

想一想：那个错误信息 Key: &#39;User.Name&#39; Error:Field validation for &#39;Name&#39; failed on the &#39;required&#39; tag 是什么意思？虽然它看起来有点“程序员化”，但仔细读读，它其实在告诉我们：User 结构体的 Name 字段，在 required 这个规则上，验证失败了。（别担心这个错误信息太丑，我们在后面的章节会学习如何把它变得更友好！）
本章小结恭喜你！你已经成功让 validator 帮你完成了第一次检查工作。我们来回顾一下核心的三个步骤：

准备工作：通过 go get 安装库。
定义规则：在结构体的字段后面，使用 validate 标签来声明验证规则（例如 validate:&quot;required&quot;）。
执行校验：
通过 validator.New() 创建一个校验器实例。
调用 validate.Struct(你的结构体实例) 来执行校验。
检查返回的 error 是否为 nil，nil 代表成功，非 nil 代表失败。



现在你已经掌握了 validator 最基本的工作流程。但是，一个只会检查“不能为空”的检查员能力还远远不够。下一章，我们将为他的“规则手册”增加更多、更强大的规则，让他能应对更复杂的检查任务！
好的，我们马上进入第三章！
我们的检查员已经学会了最基本的一招——required（不能为空）。但这显然不够用，就像一个交通警察只会检查司机有没有系安全带一样，他还需要学会检查是否超速、是否闯红灯等等。
现在，我们就来给他的“规则手册”增加几页，让他学会更多强大的检查技巧！由于规则比较多，我们把它分成上下两部分来学习。

第3-1章：检查员的“规则手册”—— 常用验证标签（上）在这一章，我们主要学习一些最常用、最基础的验证规则，它们主要和长度、大小、格式有关。
规则一：关于“长度”的检查在网站注册时，我们经常看到“用户名长度必须在6到20个字符之间”这样的提示。这就是对长度的限制。

min=x：最小长度&#x2F;个数不能小于 x。
max=x：最大长度&#x2F;个数不能超过 x。
len=x：长度&#x2F;个数必须正好等于 x。

这些规则不仅能用在字符串上，还能用在数组、切片等有“长度”概念的东西上。
示例：
type User struct &#123;    Username string `validate:&quot;min=3,max=20&quot;` // 用户名长度在3到20之间    UserType string `validate:&quot;len=5&quot;`      // 用户类型必须是5个字符，比如 &quot;admin&quot;    Hobbies  []string `validate:&quot;max=5&quot;`    // 兴趣爱好最多只能选5个&#125;

重点：如何组合多个规则？
你可能已经注意到了 validate:&quot;min=3,max=20&quot;。如果一个字段需要同时满足多个规则怎么办？很简单，用逗号 , 把它们隔开就行了！ 这句话的意思就是，Username 字段必须同时满足最小长度为3 和 最大长度为20。
规则二：关于“数字大小”的检查这个规则非常直观，就是我们数学里学过的 &gt;、&gt;=、&lt;、&lt;=。

gt=x：必须 大于 x (Greater Than)
gte=x：必须 大于或等于 x (Greater Than or Equal)
lt=x：必须 小于 x (Less Than)
lte=x：必须 小于或等于 x (Less Than or Equal)

示例：
type Product struct &#123;    Price    float64 `validate:&quot;gt=0&quot;`  // 价格必须大于0    Quantity int     `validate:&quot;gte=1&quot;` // 库存数量必须大于等于1    Rating   int     `validate:&quot;min=1,max=5&quot;` // 评分在1到5星之间 (这里用min/max更合适)&#125;

思考一下： 为什么评分用 min=1,max=5 而不是 gte=1,lte=5？对于整数来说，这两种写法效果是一样的！min/max 通常用于描述长度、数量，而 gte/lte 用于描述数值的范围，但在这里它们可以通用。这说明规则的选择有时也很灵活。
规则三：关于“特定格式”的检查validator 最强大的功能之一，就是它内置了很多对通用格式的检查，我们不需要自己用复杂的方法去判断。

email：必须是有效的邮箱格式。
url：必须是有效的 URL 链接格式。
ip：必须是有效的 IP 地址格式（包括 IPv4 和 IPv6）。

示例：
type ContactInfo struct &#123;    Email   string `validate:&quot;required,email&quot;` // 必填，且必须是邮箱格式    Website string `validate:&quot;url&quot;`            // 选填，但如果填了，必须是URL格式&#125;

你看，检查一个复杂的邮箱格式，我们只需要写上 email 这五个字母就行了，是不是超级方便？
实战演练：组合使用好了，我们已经学了好几个新规则了。现在我们把它们组合起来，创建一个更真实的“用户注册表单”结构体，并进行校验。
package mainimport (    &quot;fmt&quot;    &quot;github.com/go-playground/validator/v10&quot;)// RegisterForm 定义了一个用户注册表单的结构和它的验证规则type RegisterForm struct &#123;    Username string   `validate:&quot;required,min=3,max=20&quot;`    Age      int      `validate:&quot;required,gte=18,lte=120&quot;`    Email    string   `validate:&quot;required,email&quot;`    Tags     []string `validate:&quot;max=5&quot;`&#125;func main() &#123;    validate := validator.New()    // --- 场景一：一份填写完美的表单 ---    fmt.Println(&quot;--- 场景一：完美表单 ---&quot;)    formOK := RegisterForm&#123;        Username: &quot;Jack&quot;,        Age:      25,        Email:    &quot;jack@example.com&quot;,        Tags:     []string&#123;&quot;music&quot;, &quot;sports&quot;&#125;,    &#125;    err := validate.Struct(formOK)    if err == nil &#123;        fmt.Println(&quot;表单校验通过！&quot;)    &#125;    // --- 场景二：一份问题百出的表单 ---    fmt.Println(&quot;\n--- 场景二：问题表单 ---&quot;)    formFail := RegisterForm&#123;        Username: &quot;Li&quot;, // 太短，不满足 min=3        Age:      16,   // 太小，不满足 gte=18        Email:    &quot;this-is-not-an-email&quot;, // 格式错误        Tags:     []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;&#125;, // 标签太多，不满足 max=5    &#125;    err = validate.Struct(formFail)    if err != nil &#123;        // 这里我们先简单打印错误，下一章会学习如何处理它        fmt.Printf(&quot;表单校验失败: %v\n&quot;, err)    &#125;&#125;

运行结果：
--- 场景一：完美表单 ---表单校验通过！--- 场景二：问题表单 ---表单校验失败: Key: &#x27;RegisterForm.Username&#x27; Error:Field validation for &#x27;Username&#x27; failed on the &#x27;min&#x27; tag

注意： 在场景二中，虽然表单有多个错误，但 validator 默认只要发现一个错误就会停止并返回。我们会在后面的章节学习如何一次性获取所有错误。目前你只需要知道，只要 err 不是 nil，就代表数据有问题。
本章小结太棒了！我们给检查员的“规则手册”增加了厚厚的一叠。来总结一下今天学到的核心规则：

组合规则：用逗号 , 分隔，表示“并且”的关系。
长度规则：
min=x (最小长度)
max=x (最大长度)
len=x (固定长度)


数值规则：
gt=x (大于 &gt;)
gte=x (大于等于 &gt;=)
lt=x (小于 &lt;)
lte=x (小于等于 &lt;=)


格式规则：
email (邮箱格式)
url (链接格式)
ip (IP地址格式)



这些规则已经能覆盖我们日常开发中 80% 的校验需求了。但这还不是全部！在下一节课，我们会学习更多高级和有趣的规则，比如“二选一”、“密码确认”等场景，让我们的检查员变得更加智能！
当然！我们的检查员已经掌握了基础技能，现在是时候让他学习一些更酷、更智能的“高级招式”了。

第3-2章：检查员的“规则手册”—— 常用验证标签（下）在上一节，我们学习了关于长度、数字和基本格式的规则。这一节，我们将接触一些更灵活、更强大的规则，它们能处理一些更复杂的场景，比如“多选一”或者“两个字段必须相等”。
规则四：多选一（从固定选项里选）想象一下，你有一个表示“订单状态”的字段，它的值只能是“待处理”、“处理中”或“已发货”这三种之一，绝不能是其他任何值。这时 oneof 规则就派上用场了。

oneof=value1 value2 value3：字段的值必须是后面列出的值之一。

请注意： 多个选项之间是用 空格 分隔的，而不是逗号！
示例：
type Order struct &#123;    Status string `validate:&quot;oneof=pending processing shipped&quot;` // 状态只能是这三个字符串之一    Color  string `validate:&quot;oneof=&#x27;red blue&#x27; &#x27;green yellow&#x27;&quot;` // 如果选项本身包含空格，可以用单引号 &#x27; &#x27; 括起来&#125;

规则五：字段间的比较（跨字段验证）这是个非常实用的功能！最经典的场景就是“注册时，确认密码必须和密码一致”。

eqfield=FieldName：当前字段的值必须 等于 FieldName 字段的值。
nefield=FieldName：当前字段的值必须 不等于 FieldName 字段的值。

示例：
type SignUpForm struct &#123;    Password        string `validate:&quot;required,min=8&quot;`    ConfirmPassword string `validate:&quot;required,eqfield=Password&quot;` // 此字段必须和 Password 字段的值相等        OldPassword     string `validate:&quot;required,min=8&quot;`    NewPassword     string `validate:&quot;required,min=8,nefield=OldPassword&quot;` // 新密码不能和旧密码一样&#125;

有了这个，我们再也不用在代码里手动写 if form.Password != form.ConfirmPassword 这样的逻辑了！
规则六：深入检查（校验切片或数组中的每一个元素）这个规则超级重要！假设你有一个订单，订单里包含一个商品列表（一个切片），你需要确保列表里的 每一个 商品都符合规定（比如商品名不能为空，价格必须大于0）。这时候就要用 dive 规则了。

dive：告诉检查员，“请深入到这个数组&#x2F;切片&#x2F;map 的内部，对里面的每一个元素都进行检查”。

dive 规则本身不带参数，它需要和内部元素的结构体标签配合使用。
示例：让我们来看一个完整的订单校验场景。
// 首先，定义列表里单个元素的规则type Item struct &#123;    SKU   string  `validate:&quot;required&quot;`       // 商品编号必填    Price float64 `validate:&quot;required,gt=0&quot;`  // 价格必填且大于0&#125;// 然后，在订单结构体里使用 divetype Order struct &#123;    OrderID string `validate:&quot;required&quot;`    // 1. required: 订单必须有商品，Items 列表不能为空    // 2. min=1: 列表里至少要有一个商品    // 3. dive: 请深入到 Items 列表内部，对每一个 Item 对象进行校验    //    (校验规则就是 Item 结构体上定义的那些标签)    Items   []Item `validate:&quot;required,min=1,dive&quot;`&#125;

思考一下： 如果 Items 字段的标签是 validate:&quot;required&quot; 而没有 dive，会发生什么？validator 只会检查 Items 这个切片本身是不是 nil，但它完全不会关心切片里面的 Item 对象的 SKU 和 Price 是否合法。dive 就像一个指令，告诉检查员：“打开这个包裹，检查里面的每个小盒子！”
实战演练：一个复杂的订单校验我们来把刚刚学的 dive 和 oneof 结合起来，写一个完整的例子。
package mainimport (    &quot;fmt&quot;    &quot;github.com/go-playground/validator/v10&quot;)type Item struct &#123;    Name  string `validate:&quot;required&quot;`    Price int    `validate:&quot;gt=0&quot;`&#125;type PurchaseOrder struct &#123;    UserEmail string `validate:&quot;required,email&quot;`    // 订单类型只能是 &#x27;online&#x27; 或 &#x27;store&#x27;    Type      string `validate:&quot;required,oneof=online store&quot;`    // 商品列表不能为空，且列表里的每个 Item 都要符合规则    Items     []Item `validate:&quot;required,min=1,dive&quot;`&#125;func main() &#123;    validate := validator.New()    // --- 场景一：一个合法的订单 ---    fmt.Println(&quot;--- 场景一：合法订单 ---&quot;)    orderOK := PurchaseOrder&#123;        UserEmail: &quot;customer@test.com&quot;,        Type:      &quot;online&quot;,        Items: []Item&#123;            &#123;Name: &quot;Laptop&quot;, Price: 1200&#125;,            &#123;Name: &quot;Mouse&quot;, Price: 25&#125;,        &#125;,    &#125;    err := validate.Struct(orderOK)    if err == nil &#123;        fmt.Println(&quot;订单校验通过！&quot;)    &#125;    // --- 场景二：一个非法的订单 (商品价格为0) ---    fmt.Println(&quot;\n--- 场景二：非法订单 ---&quot;)    orderFail := PurchaseOrder&#123;        UserEmail: &quot;customer@test.com&quot;,        Type:      &quot;store&quot;,        Items: []Item&#123;            &#123;Name: &quot;Keyboard&quot;, Price: 60&#125;,            &#123;Name: &quot;USB Cable&quot;, Price: 0&#125;, // 这里的 Price 不满足 &quot;gt=0&quot;        &#125;,    &#125;    err = validate.Struct(orderFail)    if err != nil &#123;        fmt.Printf(&quot;订单校验失败: %v\n&quot;, err)    &#125;&#125;

运行结果：
--- 场景一：合法订单 ---订单校验通过！--- 场景二：非法订单 ---订单校验失败: Key: &#x27;PurchaseOrder.Items[1].Price&#x27; Error:Field validation for &#x27;Price&#x27; failed on the &#x27;gt&#x27; tag

看到那个错误信息 PurchaseOrder.Items[1].Price 了吗？它非常精确地告诉我们：是 PurchaseOrder 结构体的 Items 字段里的、索引为 1 的那个元素的 Price 字段，在 gt 规则上校验失败了！这就是 dive 的强大之处。
本章小结我们的检查员又学会了三项强大的技能，变得更加全能了：

多选一：oneof=value1 value2 (注意是空格分隔)，确保值在一个给定的集合内。
跨字段比较：
eqfield=FieldName (等于另一个字段)
nefield=FieldName (不等于另一个字段)


深入校验：dive，用于校验切片&#x2F;数组&#x2F;map中的每一个元素，必须和元素自身的结构体标签配合使用。

到目前为止，你已经掌握了 validator 90% 以上的常用功能！你已经可以应对绝大多数的数据校验场景了。
不过，我们一直看到那个不太友好的错误信息。如果数据校验失败了，我们总不能把 Key: &#39;PurchaseOrder.Items[1].Price&#39; ... 这样一长串东西直接展示给用户看吧？下一章，我们就来解决这个问题，学习如何优雅地处理和翻译这些错误信息。
好的，我们继续！
到目前为止，我们的“检查员”工作完成得非常出色，总能准确地发现问题。但是，他写的“错误报告”实在是太“专业”了，就像医生写的病历一样，普通人（用户）根本看不懂。
Key: &#39;User.Name&#39; Error:Field validation for &#39;Name&#39; failed on the &#39;required&#39; tag
把这个给用户看，用户估计会一脸茫然。所以，这一章我们的任务就是学会当一个“翻译官”，把这些专业的错误报告翻译成用户能看懂的友好提示，比如“用户名不能为空”。

第4章：“检查不通过！”—— 如何看懂并处理错误信息当 validate.Struct() 返回的 error 不为 nil 时，就表示校验失败了。这个 error 对象里其实包含了非常丰富的错误信息，我们需要学会如何把它解析出来。
第一步：拆开“错误”这个大包裹validator 返回的错误不是一个普通的 error，它是一个特殊类型 validator.ValidationErrors。我们可以把它想象成一个装满了“具体错误项”的包裹。我们需要先把它从通用的 error 类型里“拆”出来。
这在 Go 语言里叫做 类型断言。你可以这么理解：我们拿到一个盒子（error），我们猜测（或者说我们确定）里面装的是苹果（validator.ValidationErrors），于是我们就尝试把它当成苹果拿出来。
err := validate.Struct(someStruct)if err != nil &#123;    // 这里进行类型断言    validationErrors, ok := err.(validator.ValidationErrors)    if !ok &#123;        // 如果 ok 是 false，说明这不是一个校验错误，可能是别的意外，直接打印        fmt.Println(&quot;An unexpected error:&quot;, err)        return    &#125;    // 如果 ok 是 true，说明类型断言成功！    // validationErrors 就是我们想要的、包含了所有校验失败信息的对象    fmt.Println(&quot;恭喜，我们成功拆开了错误包裹！&quot;)    // 接下来就可以处理 validationErrors 了&#125;

第二步：遍历每一个“错误项”一个表单提交过来，可能同时有好几个字段都不合格（比如用户名太短，并且邮箱格式也不对）。validationErrors 其实是一个切片（可以理解为列表），里面装着每一个字段的具体错误信息。所以，我们可以用一个 for 循环来遍历它。
里面的每一项都是一个 validator.FieldError 对象，它包含了关于单个字段校验失败的所有细节。
我们来看一个 FieldError 包含了哪些有用的信息（我们只挑最重要的几个）：

.Field(): 返回字段的 名称 (比如 Name, Age)。
.Tag(): 返回导致失败的那个 规则标签 (比如 required, min, email)。
.Value(): 返回导致失败的那个 不合法的值 (比如空字符串 &quot;&quot;，不合法的邮箱地址 abcde)。
.Param(): 返回规则标签的 参数 (比如规则是 min=6，那 .Param() 返回的就是 6)。

示例：把错误信息“说人话”
结合上面的知识，我们来写一个例子，把专业的错误报告翻译成对用户友好的提示。
package mainimport (    &quot;fmt&quot;    &quot;github.com/go-playground/validator/v10&quot;)type User struct &#123;    Username string `validate:&quot;required,min=3&quot;`    Email    string `validate:&quot;required,email&quot;`    Age      int    `validate:&quot;gte=18&quot;`&#125;func main() &#123;    validate := validator.New()    user := User&#123;        Username: &quot;a&quot;,    // 违反 min=3        Email:    &quot;test&quot;, // 违反 email        Age:      17,     // 违反 gte=18    &#125;    err := validate.Struct(user)    if err != nil &#123;        // 进行类型断言        validationErrors, ok := err.(validator.ValidationErrors)        if !ok &#123;            fmt.Println(err)            return        &#125;        // 遍历所有错误        for _, fieldError := range validationErrors &#123;            // 根据不同的字段和规则，生成不同的错误信息            switch fieldError.Field() &#123;            case &quot;Username&quot;:                if fieldError.Tag() == &quot;required&quot; &#123;                    fmt.Println(&quot;用户名是必填的！&quot;)                &#125; else if fieldError.Tag() == &quot;min&quot; &#123;                    // 使用 Param() 获取参数                    fmt.Printf(&quot;用户名长度不能小于 %s 个字符！\n&quot;, fieldError.Param())                &#125;            case &quot;Email&quot;:                if fieldError.Tag() == &quot;required&quot; &#123;                    fmt.Println(&quot;邮箱是必填的！&quot;)                &#125; else if fieldError.Tag() == &quot;email&quot; &#123;                    fmt.Println(&quot;邮箱格式不正确！&quot;)                &#125;            case &quot;Age&quot;:                if fieldError.Tag() == &quot;gte&quot; &#123;                    fmt.Printf(&quot;年龄必须大于或等于 %s 岁！\n&quot;, fieldError.Param())                &#125;            &#125;        &#125;    &#125;&#125;

运行结果：你会看到，这次的输出非常清晰友好！
用户名长度不能小于 3 个字符！邮箱格式不正确！年龄必须大于或等于 18 岁！

（注意：错误的顺序可能每次不一样，因为 validator 内部是并发校验的）
思考一下： 上面的 switch-case 和 if-else 是不是还是有点繁琐？如果结构体变得非常复杂，这里的代码也会变得很长。
是的，这只是最基础的错误处理方式。在真实的项目中，大家通常会结合“翻译库”（如 go-i18n）或者自己写一个“错误消息映射表”（map），来把 fieldError.Tag() 自动映射成对应的错误消息，这样代码会更优雅。但原理都是一样的：遍历 validationErrors，获取每一个 FieldError，然后根据它的 .Field() 和 .Tag() 来生成消息。
本章小结这一章是 validator 从“能用”到“好用”的关键一步。我们学会了如何处理它返回的错误：

核心概念：校验失败返回的 error 实际上是 validator.ValidationErrors 类型，它是一个包含了所有错误详情的集合。
关键步骤：
使用 类型断言 err.(validator.ValidationErrors) 来拆开错误包裹。
使用 for 循环 遍历 validationErrors 切片。


信息提取：在循环中，从 FieldError 对象中提取关键信息：
.Field() 获取字段名。
.Tag() 获取失败的规则。
.Param() 获取规则的参数。


最终目的：根据提取出的信息，组合成用户能看懂的、友好的错误提示。

现在，你不仅能让检查员发现问题，还能让他用清晰的语言把问题报告出来。这已经非常接近一个专业的开发者了！
不过，如果检查员自带的“规则手册”里没有我们想要的规则怎么办？比如，我想检查一个字段“必须是有效的中国手机号码”，validator 可没有内置这个规则。别担心，下一章，我们就来学习终极技巧：给他编写一本属于我们自己的“独家规则手册”！
第5章：制定你自己的“特殊规则”—— 自定义验证函数这一章，我们将学习 validator 的终极技巧：创建并注册一个我们自己写的验证函数。这让 validator 的能力可以无限扩展，去适应任何奇特的业务需求。
这听起来可能有点复杂，但其实是一个非常清晰的三步流程：

编写规则：写一个符合 validator 要求的函数。
登记规则：把我们写的函数告诉 validator 实例，并给它起一个名字（也就是标签名）。
使用规则：像使用 required 一样，在结构体里使用我们自己起的名字。

第一步：编写规则（定义一个验证函数）一个自定义验证函数有固定的格式，就像填表一样，你必须按照它的模板来写：
func(fl validator.FieldLevel) bool


它必须是一个函数。
它只接收一个参数，类型是 validator.FieldLevel。
它必须返回一个 bool 类型的值 (true 表示验证通过，false 表示验证失败)。

validator.FieldLevel 是什么？你可以把它想象成检查员在检查某个具体字段时，拿到的“工作台”。这个工作台上放着关于这个字段的所有信息，比如它的值、它的类型、它的名字等等。
我们最常用的就是通过 fl.Field().String() 来获取这个字段 作为字符串的值。
示例：创建一个检查“手机号”的函数我们来写一个函数，规则是：手机号必须是 11 位，并且以 ‘1’ 开头。（这是一个简化的规则，真实的手机号校验会更复杂，通常使用正则表达式，但原理是相通的）。
import (    &quot;github.com/go-playground/validator/v10&quot;    &quot;strings&quot;    &quot;unicode/utf8&quot;)// isValidMobile 是我们的自定义验证函数func isValidMobile(fl validator.FieldLevel) bool &#123;    // 1. 从 &quot;工作台&quot; (fl) 上获取字段的值，并转为字符串    mobile := fl.Field().String()    // 2. 编写我们的检查逻辑    // 规则1：长度必须是 11 位    if utf8.RuneCountInString(mobile) != 11 &#123;        return false // 不通过    &#125;    // 规则2：必须以 &#x27;1&#x27; 开头    if !strings.HasPrefix(mobile, &quot;1&quot;) &#123;        return false // 不通过    &#125;    // 3. 所有规则都满足了    return true // 通过！&#125;

第二步：登记规则（注册自定义函数）我们写好了规则，但检查员还不知道它的存在。我们需要在创建 validator 实例后，把它“登记”到检查员的规则手册里，并给它起一个响亮的名字（标签）。
这个登记动作通过 validate.RegisterValidation() 函数完成。
// 1. 创建检查员实例validate := validator.New()// 2. 登记我们的新规则// 第一个参数是我们要起的 &quot;标签名&quot;，比如叫 &quot;is-valid-mobile&quot;// 第二个参数是我们上面写的函数 isValidMobileerr := validate.RegisterValidation(&quot;is-valid-mobile&quot;, isValidMobile)if err != nil &#123;    // 如果注册失败，一般是标签名有问题，程序应该中止    panic(&quot;Failed to register validation&quot;)&#125;

现在，检查员的规则手册里就多了一页，标题是 is-valid-mobile，内容就是我们 isValidMobile 函数里的逻辑。
第三步：使用规则（在结构体里贴上新标签）一旦注册成功，我们就可以像使用任何内置标签一样，使用我们自己的 is-valid-mobile 标签了！
type UserProfile struct &#123;    Name   string `validate:&quot;required&quot;`    Mobile string `validate:&quot;required,is-valid-mobile&quot;` // 看！我们用上了自己的规则！&#125;

实战演练：完整的自定义校验流程下面是一个可以完整运行的例子，把上面三步串联了起来。
package mainimport (    &quot;fmt&quot;    &quot;github.com/go-playground/validator/v10&quot;    &quot;strings&quot;    &quot;unicode/utf8&quot;)// UserProfile 结构体使用了我们的自定义标签type UserProfile struct &#123;    Name   string `validate:&quot;required&quot;`    Mobile string `validate:&quot;required,is-valid-mobile&quot;`&#125;// 我们的自定义验证函数func isValidMobile(fl validator.FieldLevel) bool &#123;    mobile := fl.Field().String()    if utf8.RuneCountInString(mobile) != 11 &#123;        return false    &#125;    if !strings.HasPrefix(mobile, &quot;1&quot;) &#123;        return false    &#125;    return true&#125;func main() &#123;    // 1. 创建 validator 实例    validate := validator.New()    // 2. 注册我们的自定义函数    validate.RegisterValidation(&quot;is-valid-mobile&quot;, isValidMobile)    // --- 场景一：合法的手机号 ---    fmt.Println(&quot;--- 场景一：合法手机号 ---&quot;)    profileOK := UserProfile&#123;Name: &quot;Bob&quot;, Mobile: &quot;13800138000&quot;&#125;    err := validate.Struct(profileOK)    if err == nil &#123;        fmt.Println(&quot;校验通过！&quot;)    &#125;    // --- 场景二：非法的手机号 (太短) ---    fmt.Println(&quot;\n--- 场景二：非法手机号 ---&quot;)    profileFail := UserProfile&#123;Name: &quot;Charlie&quot;, Mobile: &quot;12345&quot;&#125;    err = validate.Struct(profileFail)    if err != nil &#123;        // 我们同样可以处理这个自定义规则的错误        validationErrors := err.(validator.ValidationErrors)        for _, fieldError := range validationErrors &#123;            if fieldError.Field() == &quot;Mobile&quot; &amp;&amp; fieldError.Tag() == &quot;is-valid-mobile&quot; &#123;                fmt.Println(&quot;手机号码格式不正确，必须是11位且以1开头！&quot;)            &#125;        &#125;    &#125;&#125;

运行结果：
--- 场景一：合法手机号 ---校验通过！--- 场景二：非法手机号 ---手机号码格式不正确，必须是11位且以1开头！

本章小结太厉害了！你已经掌握了 validator 最核心、最灵活的用法。我们来回顾一下自定义校验的“三部曲”：

定义函数：创建一个函数，签名必须是 func(fl validator.FieldLevel) bool，并在函数体内实现你的校验逻辑。
注册函数：使用 validate.RegisterValidation(&quot;your-tag-name&quot;, yourFunction) 将函数和标签名绑定，并注册到 validator 实例中。
使用标签：在你的结构体 validate 标签中，像使用内置标签一样使用你自定义的 your-tag-name。

有了这个能力，再也没有 validator 无法完成的校验任务了。从现在起，你可以为你的项目量身定做任何你需要的“检查规则”。
到这里，validator 的主要功能我们已经全部学完了。接下来的章节，我们会聊一些经验之谈和最佳实践，帮助你在真实项目中用得更稳、更好。最后再通过一个完整的实战练习来巩固所有知识。

第6章：经验之谈 —— 使用 validator 的注意事项与技巧这一章我们不学新功能，而是围绕“如何更好地使用”展开。
技巧一：校验器实例，全局单例就够了你在前面的例子中可能注意到了，我们每次都是在 main 函数里用 validator.New() 创建一个新的校验器实例。在小程序里这样做没问题，但在一个大的Web应用里，每次处理一个请求就创建一个新的实例，是一种浪费。
validator 的实例是 并发安全 的，这意味着在多个协程（goroutine，你可以简单理解为多个任务同时进行）中共享同一个实例是完全安全的。
最佳实践：在你的项目中，只创建一个全局的 validator 实例，然后在所有需要校验的地方重复使用它。如果需要注册自定义验证，也在程序启动时一次性完成注册。
package mainimport &quot;github.com/go-playground/validator/v10&quot;// 在包级别（全局）创建一个 Validator 实例var validate *validator.Validate// init 函数在包被导入时自动执行，是进行初始化的好地方func init() &#123;    validate = validator.New()    // 如果有自定义验证，也在这里一次性注册好    // validate.RegisterValidation(&quot;my-tag&quot;, myValidationFunc)&#125;// 你的业务函数可以直接使用这个全局的 validate 实例func HandleUserRegistration(user User) &#123;    err := validate.Struct(user)    if err != nil &#123;        // ... 处理错误    &#125;    // ...&#125;

这样做的好处是：

性能更好：避免了重复创建对象的开销。
管理方便：所有自定义规则的注册都集中在一个地方，清晰明了。

技巧二：校验单个变量，而不仅仅是结构体我们一直都在用 validate.Struct() 来校验整个结构体。但有时，你可能只想校验一个独立的变量。比如，你想确认某个函数接收的字符串参数 email 是不是合法的邮箱格式。
validator 提供了 validate.Var() 方法来满足这个需求。
示例：
package mainimport (    &quot;fmt&quot;    &quot;github.com/go-playground/validator/v10&quot;)func main() &#123;    validate := validator.New()    // --- 场景一：校验一个合法的邮箱字符串 ---    emailOK := &quot;test@example.com&quot;    // 第一个参数是变量本身，第二个参数是应用在它身上的规则    err := validate.Var(emailOK, &quot;required,email&quot;)    if err == nil &#123;        fmt.Println(&quot;emailOK 是一个合法的邮箱地址！&quot;)    &#125;    // --- 场景二：校验一个非法的 IP 地址字符串 ---    ipFail := &quot;127.0.0&quot;    err = validate.Var(ipFail, &quot;ip&quot;)    if err != nil &#123;        fmt.Printf(&quot;ipFail 不是一个合法的 IP 地址: %v\n&quot;, err)    &#125;&#125;

validate.Var() 非常适合用在那些不方便或不需要定义一个完整结构体的零散校验场景中。
技巧三：注意 required 与 omitempty 的区别这是一个新手很容易混淆的地方。

required：必须存在。字段不能是其类型的“零值”（比如 int 的 0，string 的 &quot;&quot;，指针或切片的 nil）。如果不存在，就报错。
omitempty：如果有值，才校验。omit 是忽略的意思。这个标签告诉 validator：“如果这个字段是零值，那就跳过它，别管它后面的其他规则了。但如果它有值，那就请继续检查后面的规则。”

一个经典的例子：更新用户信息假设用户只想更新他的昵称，提交的 JSON 数据可能只包含 nickname 字段，而 email 字段是空的。
type UserUpdateForm struct &#123;    // 如果 nickname 不为空，则必须满足最小长度为2    Nickname string `validate:&quot;omitempty,min=2&quot;`    // 如果 email 不为空，则必须是 email 格式    Email    string `validate:&quot;omitempty,email&quot;`&#125;// 场景一：用户只更新昵称form1 := UserUpdateForm&#123;Nickname: &quot;NewName&quot;&#125;// 校验会通过，因为 Email 是空字符串，`omitempty` 使 `email` 规则被跳过。// 场景二：用户更新了一个错误的邮箱form2 := UserUpdateForm&#123;Email: &quot;not-an-email&quot;&#125;// 校验会失败，因为 Email 不为空，所以 `email` 规则被触发且校验失败。// 场景三：用户啥也没填form3 := UserUpdateForm&#123;&#125;// 校验会通过，因为两个字段都是空，所有规则都被 `omitempty` 跳过了。

记住这个组合：omitempty 经常和其它规则一起使用，用于“可选字段”的校验，非常实用！
技巧四：校验嵌套结构体如果你的结构体里包含了另一个结构体，validator 默认是不会自动深入进去校验的。你需要明确告诉它。
和 dive 校验切片&#x2F;数组类似，对于嵌套的结构体，你只需要在字段上加上 dive 标签，或者简单地加上 required（或其他任何标签）来触发校验。更规范的方式是在嵌套的结构体字段上直接进行校验。
type Address struct &#123;    Street string `validate:&quot;required&quot;`    City   string `validate:&quot;required&quot;`&#125;type User struct &#123;    Name    string  `validate:&quot;required&quot;`    // Address 字段本身是必填的（不能是nil），    // 并且需要对 Address 内部的字段进行校验    Address Address `validate:&quot;required&quot;` &#125;

更正与修改:实际上，对于嵌套结构体，validator 默认就会递归地进行校验。你只需要确保在外层结构体验证时，内层结构体的字段也已经定义了标签。上面的validate:&quot;required&quot;是针对Address这个结构体本身不能是零值，而它内部的Street和City的required标签会在校验User时被自动检查。
为了更清晰地表达“请深入校验”，通常可以直接写 validate:&quot;&quot; 配合内部的标签，或者如果该嵌套结构体本身是可选的指针类型，则可以使用dive。
type UserWithOptionalAddress struct &#123;    Name    string   `validate:&quot;required&quot;`    // 如果 Address 字段存在（不是nil），则深入校验其内部    Address *Address `validate:&quot;omitempty,dive&quot;`&#125;


对于struct类型，validator会自动深入。
对于*struct（指针）、[]struct（切片）等，使用dive来告诉校验器需要深入检查。

本章小结这一章我们没有学习新标签，而是修炼了“内功”，让使用 validator 的方式更加地道和高效：

全局单例：整个应用共享一个 validator 实例，在 init 函数中初始化和注册规则。
校验单个变量：使用 validate.Var() 来校验零散的变量。
可选字段校验：omitempty 是处理“非必填但有值时需满足规则”场景的利器。
嵌套结构体：对于指针、切片、数组或 map 里的结构体，记得使用 dive 来进行深度校验。

掌握了这些技巧，你就可以自信地在任何规模的项目中使用 validator 库了。理论学习已经足够，下一章，我们将把目前学到的所有知识融会贯通，完成一个最终的实战演练！
好的，激动人心的时刻到了！
我们已经学习了 validator 的方方面面，从基础概念到高级技巧。现在是时候把所有知识碎片拼接到一起，像在真实项目中那样，完成一个完整的、有挑战性的任务了。

第7章：实战演练 —— 用户注册信息校验演练目标：我们要创建一个用户注册的后端校验逻辑。这个逻辑需要能够接收一个模拟的用户注册表单，并使用 validator 对其进行全面的校验。最后，将专业的校验错误翻译成对用户友好的提示信息列表。
需求清单：

用户名 (Username):
必填。
长度在 4 到 20 个字符之间。
不能包含 “admin” 这个词（这是个自定义规则！）。


密码 (Password):
必填。
长度至少为 8 个字符。


确认密码 (ConfirmPassword):
必填。
必须和 Password 字段的值一致。


邮箱 (Email):
必填。
必须是有效的邮箱格式。


年龄 (Age):
非必填。
但如果填写了，必须年满 18 周岁。


兴趣爱好 (Hobbies):
非必填。
但如果填写了，最多只能选择 5 个。
每个兴趣爱好的字符串本身不能为空（深入校验！）。



错误处理要求：将所有校验失败的信息收集起来，格式化成一个清晰的 map[string]string，其中 key 是字段名，value 是友好的错误提示。
好了，需求明确，我们开始动手吧！
第一步：定义结构体和自定义验证函数根据需求清单，我们需要先设计我们的 RegisterForm 结构体，并为 “不能包含 admin” 这个特殊需求编写一个自定义验证函数。
package mainimport (	&quot;fmt&quot;	&quot;github.com/go-playground/validator/v10&quot;	&quot;strings&quot;)// 1. 定义我们的注册表单结构体，并贴上所有需要的标签type RegisterForm struct &#123;	Username        string   `validate:&quot;required,min=4,max=20,no-admin&quot;`	Password        string   `validate:&quot;required,min=8&quot;`	ConfirmPassword string   `validate:&quot;required,eqfield=Password&quot;`	Email           string   `validate:&quot;required,email&quot;`	Age             int      `validate:&quot;omitempty,gte=18&quot;`	Hobbies         []string `validate:&quot;omitempty,max=5,dive,required&quot;`&#125;// 2. 编写自定义验证函数 `noAdmin`func noAdmin(fl validator.FieldLevel) bool &#123;	// 判断字段值（转为小写后）是否包含 &quot;admin&quot;	return !strings.Contains(strings.ToLower(fl.Field().String()), &quot;admin&quot;)&#125;

代码解析：

Username: 我们用了一个自定义标签 no-admin，准备稍后注册它。
Age: 使用 omitempty,gte=18，完美实现了“可选但填了就要大于等于18”的需求。
Hobbies: omitempty 表示整个爱好列表可以不填。max=5 限制列表长度。dive 表示要深入列表内部。最后的 required 是应用在 dive 之后的，意思是列表里的 每个字符串 都不能为空。

第二步：初始化校验器并注册自定义规则我们遵循最佳实践，把校验器和自定义规则的注册放在一起。
// 在这个文件中，我们直接在 main 函数里初始化// 在真实项目中，这部分代码应该在程序的初始化阶段（如 init 函数）func setupValidator() *validator.Validate &#123;	validate := validator.New()	// 注册 &quot;no-admin&quot; 标签对应的验证函数	err := validate.RegisterValidation(&quot;no-admin&quot;, noAdmin)	if err != nil &#123;		panic(&quot;Failed to register custom validation&quot;)	&#125;	return validate&#125;

第三步：编写校验和错误翻译的核心逻辑这是本次实战的核心。我们将创建一个函数，它接收一个 RegisterForm，返回一个 map 形式的错误信息。
// translateErrors 函数负责执行校验并翻译错误func translateErrors(validate *validator.Validate, form interface&#123;&#125;) map[string]string &#123;	err := validate.Struct(form)	if err == nil &#123;		return nil // 如果没有错误，返回 nil	&#125;	// 类型断言，获取 ValidationErrors	validationErrors, ok := err.(validator.ValidationErrors)	if !ok &#123;		// 如果不是校验错误，返回一个通用错误		return map[string]string&#123;&quot;error&quot;: &quot;An unexpected error occurred&quot;&#125;	&#125;	// 创建一个 map 用于存放翻译后的错误信息	errorMap := make(map[string]string)	for _, fieldError := range validationErrors &#123;		// 使用 switch-case 为每个字段和规则生成友好的消息		field := fieldError.Field()		tag := fieldError.Tag()		switch field &#123;		case &quot;Username&quot;:			switch tag &#123;			case &quot;required&quot;:				errorMap[field] = &quot;用户名是必填项。&quot;			case &quot;min&quot;:				errorMap[field] = &quot;用户名长度不能少于4个字符。&quot;			case &quot;max&quot;:				errorMap[field] = &quot;用户名长度不能超过20个字符。&quot;			case &quot;no-admin&quot;:				errorMap[field] = &quot;用户名不能包含 &#x27;admin&#x27;。&quot;			&#125;		case &quot;Password&quot;:			if tag == &quot;min&quot; &#123;				errorMap[field] = &quot;密码长度不能少于8个字符。&quot;			&#125;		case &quot;ConfirmPassword&quot;:			if tag == &quot;eqfield&quot; &#123;				errorMap[field] = &quot;两次输入的密码不一致。&quot;			&#125;		case &quot;Email&quot;:			if tag == &quot;email&quot; &#123;				errorMap[field] = &quot;请输入有效的邮箱地址。&quot;			&#125;		case &quot;Age&quot;:			if tag == &quot;gte&quot; &#123;				errorMap[field] = &quot;必须年满18周岁。&quot;			&#125;		case &quot;Hobbies&quot;:			if tag == &quot;max&quot; &#123;				errorMap[field] = &quot;最多只能选择5个兴趣爱好。&quot;			&#125; else if tag == &quot;required&quot; &#123;				// 这个 required 是 dive 之后的，说明是列表内的元素有问题				errorMap[field] = &quot;兴趣爱好不能为空字符串。&quot;			&#125;		&#125;	&#125;	return errorMap&#125;

第四步：整合与测试现在，我们把所有部分组合在 main 函数里，并创建几个测试用例来看看我们的成果。
func main() &#123;	// 1. 初始化校验器	validate := setupValidator()	// --- 测试用例 1: 一个问题百出的表单 ---	fmt.Println(&quot;--- 测试用例 1: 问题表单 ---&quot;)	badForm := RegisterForm&#123;		Username:        &quot;adm&quot;,                  // 太短，且包含&#x27;adm&#x27;(我们的小写检查会发现) -&gt; 修正：太短		Password:        &quot;123&quot;,                  // 太短		ConfirmPassword: &quot;456&quot;,                  // 与密码不一致		Email:           &quot;test@&quot;,                // 格式错误		Age:             16,                     // 年龄太小		Hobbies:         []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;&#125;, // 太多爱好	&#125;	errors := translateErrors(validate, badForm)	if errors != nil &#123;		fmt.Println(&quot;校验失败，错误信息如下：&quot;)		for field, msg := range errors &#123;			fmt.Printf(&quot;- %s: %s\n&quot;, field, msg)		&#125;	&#125;	// --- 测试用例 2: 另一个问题表单，包含自定义规则失败 ---	fmt.Println(&quot;\n--- 测试用例 2: 用户名含 admin ---&quot;)	adminForm := RegisterForm&#123;		Username:        &quot;super-admin-user&quot;,		Password:        &quot;12345678&quot;,		ConfirmPassword: &quot;12345678&quot;,		Email:           &quot;admin@test.com&quot;,	&#125;	errors = translateErrors(validate, adminForm)	if errors != nil &#123;		fmt.Println(&quot;校验失败，错误信息如下：&quot;)		for field, msg := range errors &#123;			fmt.Printf(&quot;- %s: %s\n&quot;, field, msg)		&#125;	&#125;	// --- 测试用例 3: 一个完美的表单 ---	fmt.Println(&quot;\n--- 测试用例 3: 完美表单 ---&quot;)	goodForm := RegisterForm&#123;		Username:        &quot;gooduser&quot;,		Password:        &quot;password123&quot;,		ConfirmPassword: &quot;password123&quot;,		Email:           &quot;good@user.com&quot;,		Age:             25,		Hobbies:         []string&#123;&quot;coding&quot;, &quot;reading&quot;&#125;,	&#125;	errors = translateErrors(validate, goodForm)	if errors == nil &#123;		fmt.Println(&quot;表单校验通过，可以进行注册！&quot;)	&#125;&#125;

预期运行结果：
--- 测试用例 1: 问题表单 ---校验失败，错误信息如下：- Username: 用户名长度不能少于4个字符。- Password: 密码长度不能少于8个字符。- ConfirmPassword: 两次输入的密码不一致。- Email: 请输入有效的邮箱地址。- Age: 必须年满18周岁。- Hobbies: 最多只能选择5个兴趣爱好。--- 测试用例 2: 用户名含 admin ---校验失败，错误信息如下：- Username: 用户名不能包含 &#x27;admin&#x27;。--- 测试用例 3: 完美表单 ---表单校验通过，可以进行注册！

本章总结与复习恭喜你！你已经成功地将我们前面六章学到的所有知识点融会贯通，解决了一个非常贴近真实项目的需求。
我们再回顾一下这个过程中用到的所有知识点：

基本使用：validator.New() 创建实例，validate.Struct() 执行校验。
常用标签：required, min, max, eqfield, email, gte。
高级标签：omitempty, dive。
自定义规则：自己写了 noAdmin 函数，并通过 RegisterValidation 注册了 no-admin 标签。
错误处理：通过类型断言获取 ValidationErrors，遍历它，并根据 Field() 和 Tag() 将错误信息翻译成用户友好的 map。
最佳实践：将校验器的创建和注册逻辑封装起来。

通过这个实战，你应该对 validator 库的强大和便捷有了非常深刻的理解。它几乎是所有 Go Web 开发和 API 开发项目中的必备工具。希望这份学习笔记能成为你未来项目开发中的好帮手！
课程到此结束，继续探索和练习吧！
附录Go Validator 常用校验标签总览（含用途说明）


作用描述
校验标签（可直接复制）
适用类型
含义说明
示例



判断是否等于指定值
eq
所有类型
等于指定值
eq=100 → 值必须等于100


判断是否不等于指定值
ne
所有类型
不等于指定值
ne=0 → 值不能等于0


判断是否大于指定值或长度
gt
数字、字符串、切片、数组
大于指定值&#x2F;长度
gt=10 → 数字&gt;10；长度&gt;10


判断是否大于等于指定值或长度
gte
数字、字符串、切片、数组
大于等于指定值&#x2F;长度
gte=1 → 值≥1


判断是否小于指定值或长度
lt
数字、字符串、切片、数组
小于指定值&#x2F;长度
lt=5 → 数字&lt;5；长度&lt;5


判断是否小于等于指定值或长度
lte
数字、字符串、切片、数组
小于等于指定值&#x2F;长度
lte=100 → 值≤100


判断长度是否等于指定值
len
字符串、切片、数组
长度等于指定值
len=6 → 长度必须为6


判断是否达到最小值或最小长度
min
数字、字符串、切片、数组
最小值&#x2F;长度下限
min=3 → 值或长度≥3


判断是否超过最大值或最大长度
max
数字、字符串、切片、数组
最大值&#x2F;长度上限
max=10 → 值或长度≤10


判断值是否在给定集合内
oneof
所有类型
值必须是给定选项之一
oneof=red green blue


强制字段必须有值
required
所有类型
不可为零值或空值
required


允许字段为空时跳过其他校验
omitempty
所有类型
为空则跳过后续校验
omitempty,gte=1,lte=10


校验邮箱格式
email
字符串
必须为合法邮箱
email


校验URL格式
url
字符串
必须为合法URL
url


校验URI格式
uri
字符串
必须为合法URI
uri


校验是否为IPv4或IPv6地址
ip
字符串
IPv4 或 IPv6 地址
ip


校验是否为IPv4地址
ipv4
字符串
IPv4 地址格式
ipv4


校验是否为IPv6地址
ipv6
字符串
IPv6 地址格式
ipv6


校验是否为合法UUID（任意版本）
uuid
字符串
UUID v1~v5
uuid


校验是否为UUID v4
uuid4
字符串
仅限 UUID v4
uuid4


校验时间格式
datetime
字符串
指定格式的时间字符串
datetime=2006-01-02


校验是否只包含字母
alpha
字符串
仅允许字母字符
alpha


校验是否只包含字母和数字
alphanum
字符串
仅允许字母和数字
alphanum


校验是否仅包含数字字符
numeric
字符串
仅数字（可字符串形式）
numeric


校验布尔格式
boolean
字符串
“true”&#x2F;“false”&#x2F;“1”&#x2F;“0”
boolean


校验是否包含指定子串
contains
字符串
必须包含指定内容
contains=@


校验是否不包含指定子串
excludes
字符串
不得包含指定内容
excludes=admin


校验是否以指定前缀开头
startswith
字符串
必须以指定前缀开头
startswith=ABC


校验是否以指定后缀结尾
endswith
字符串
必须以指定后缀结尾
endswith=.com


校验是否为Base64格式
base64
字符串
Base64 字符串
base64


校验是否为十六进制字符串
hexadecimal
字符串
十六进制格式
hexadecimal


校验是否为颜色的十六进制格式
hexcolor
字符串
#RRGGBB 或 #RGB
hexcolor


校验是否为RGB格式
rgb
字符串
rgb(255,255,255) 格式
rgb


校验是否为RGBA格式
rgba
字符串
rgba(255,255,255,1) 格式
rgba


校验是否不包含任意给定字符
excludesall
字符串
不允许出现指定字符集合
excludesall=!@#


校验是否不包含特定Unicode符号
excludesrune
字符串
不允许包含特定字符
excludesrune=你


校验路径是否为文件
file
文件路径
必须是存在的文件
file


校验路径是否为目录
dir
文件路径
必须是存在的目录
dir


比较当前字段是否等于另一个字段
eqfield
同结构体内字段
当前字段等于指定字段
eqfield=Password


比较当前字段是否不等于另一个字段
nefield
同结构体内字段
当前字段不等于指定字段
nefield=Username


比较当前字段是否大于另一个字段
gtfield
同结构体内字段
大于指定字段
gtfield=MinAge


比较当前字段是否大于等于另一个字段
gtefield
同结构体内字段
大于等于指定字段
gtefield=MinAge


比较当前字段是否小于另一个字段
ltfield
同结构体内字段
小于指定字段
ltfield=MaxAge


比较当前字段是否小于等于另一个字段
ltefield
同结构体内字段
小于等于指定字段
ltefield=MaxAge


正则匹配自定义规则
regexp
字符串
匹配指定正则表达式
regexp=^[A-Z]{3}[0-9]{4}$


条件必填：若其他字段存在
required_with
同结构体内字段
若指定字段存在，则本字段必填
required_with=Email


条件必填：若其他字段存在任意
required_with_all
同结构体内字段
若任意一个字段存在，则必填
required_with_all=Phone Email


条件必填：若其他字段不存在
required_without
同结构体内字段
若指定字段不存在，则必填
required_without=Email


条件排除：若某字段存在
excluded_with
同结构体内字段
若指定字段存在，则本字段不得存在
excluded_with=Password


切片唯一性校验
unique
切片、数组
所有元素必须唯一
unique


]]></content>
      <categories>
        <category>技术</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>使用教程</tag>
        <tag>AI</tag>
        <tag>protected</tag>
        <tag>Golang</tag>
        <tag>三方库</tag>
        <tag>validator</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 状态码列表</title>
    <url>/2024/02/28/HTTP%20%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[HTTP 状态码列表


分类
代码
名称
说明
常见场景举例



1xx (临时响应)
100
Continue (继续)
请求者应当继续提出请求。服务器已收到请求的第一部分，正在等待其余部分。
客户端在发送大型请求体之前，询问服务器是否愿意接受请求。



101
Switching Protocols (切换协议)
请求者已要求服务器切换协议，服务器已确认并准备切换。
WebSockets连接建立。



102
Processing (处理中)
WebDAV协议扩展，表示服务器已接收并正在处理请求，但尚未有响应可用。
WebDAV操作，如耗时较长的文件复制。


2xx (成功)
200
OK (成功)
服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。
网页加载、API请求成功。



201
Created (已创建)
请求成功并且服务器创建了新的资源。
用户注册、创建新文章。



202
Accepted (已接受)
服务器已接受请求，但尚未处理。
异步任务处理（如发送邮件、生成报告）。



203
Non-Authoritative Information (非授权信息)
服务器已成功处理了请求，但返回的信息可能来自另一来源（如缓存）。
代理服务器返回缓存数据。



204
No Content (无内容)
服务器成功处理了请求，但没有返回任何内容。
删除资源、成功更新但无需返回数据。



205
Reset Content (重置内容)
服务器成功处理了请求，但没有返回任何内容。要求用户代理（浏览器）重置文档视图。
提交表单后清空表单内容。



206
Partial Content (部分内容)
服务器成功处理了部分 GET 请求。
视频流播放、文件断点续传。



207
Multi-Status (多状态)
WebDAV协议扩展，在响应体中包含多个响应代码。
WebDAV批量操作。



208
Already Reported (已报告)
WebDAV协议扩展，在一个DAV集合中，已经报告过内部成员的状态，避免重复报告。
WebDAV深度查询。


3xx (重定向)
300
Multiple Choices (多种选择)
针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
提供不同格式的资源选择。



301
Moved Permanently (永久移动)
请求的网页已永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。
网站域名更改、URL结构调整。



302
Found (临时移动)
服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
临时页面重定向、负载均衡。



303
See Other (查看其他位置)
请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
POST请求成功后，重定向到结果页面。



304
Not Modified (未修改)
自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。
客户端使用缓存，通过If-Modified-Since或If-None-Match验证资源未修改。



305
Use Proxy (使用代理)
请求者只能使用代理访问请求的网页。
较少使用，存在安全隐患。



307
Temporary Redirect (临时重定向)
服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。与302类似，但强制客户端使用相同的HTTP方法。
临时维护页面重定向。



308
Permanent Redirect (永久重定向)
请求的网页已永久移动到新位置。与301类似，但强制客户端使用相同的HTTP方法。
域名迁移、API版本升级。


4xx (客户端错误)
400
Bad Request (错误请求)
服务器不理解请求的语法。
请求参数错误、请求体格式不正确。



401
Unauthorized (未授权)
请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。
访问受保护资源未提供或提供了错误的认证信息。



403
Forbidden (禁止)
服务器拒绝请求。客户端没有访问权限。
尝试访问无权访问的目录或文件。



404
Not Found (未找到)
服务器找不到请求的网页。
访问不存在的URL。



405
Method Not Allowed (方法禁用)
禁用请求中指定的方法。
对不支持GET的API接口使用了POST请求。



406
Not Acceptable (不接受)
无法使用请求的内容特性响应请求的网页。服务器根据请求的Accept头部无法生成客户端可接受的响应。
客户端只接受JSON，但服务器只能提供XML。



407
Proxy Authentication Required (需要代理授权)
此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
在需要代理认证的环境中。



408
Request Timeout (请求超时)
服务器等候请求时发生超时。
客户端在服务器设定的时间内未发送完整请求。



409
Conflict (冲突)
服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。
并发修改同一资源、资源已存在。



410
Gone (已删除)
如果请求的资源已永久删除，服务器就会返回此响应。
资源已下线且不会再恢复。



411
Length Required (需要有效长度)
服务器不接受不含有效内容长度标头字段的请求。
POST或PUT请求缺少Content-Length头部。



412
Precondition Failed (未满足前提条件)
服务器未满足请求者在请求中设置的其中一个前提条件。
乐观锁并发控制，If-Match条件失败。



413
Payload Too Large (请求实体过大)
服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
上传文件超出服务器配置的最大大小。



414
URI Too Long (请求的 URI 过长)
请求的 URI（通常为网址）过长，服务器无法处理。
包含过多查询参数的URL。



415
Unsupported Media Type (不支持的媒体类型)
请求的格式不受请求页面的支持。
POST请求的Content-Type与服务器期望的不符。



416
Range Not Satisfiable (请求范围不符合要求)
如果页面无法提供请求的范围，则服务器会返回此状态代码。
请求文件范围超出实际文件大小。



417
Expectation Failed (未满足期望值)
服务器未满足”期望”请求标头字段的要求。
Expect头部指示的期望条件未被满足。



421
Misdirected Request (请求被错误重定向)
请求被定向到无法产生响应的服务器。
HTTP&#x2F;2中，客户端向错误的服务器发送请求。



422
Unprocessable Entity (不可处理的实体)
请求格式正确，但由于语义错误而无法遵循。
API表单验证失败。



423
Locked (已锁定)
资源的访问被锁定。
WebDAV中，尝试修改被锁定的资源。



424
Failed Dependency (失败的依赖)
WebDAV协议扩展，表示由于前一个请求失败，此请求无法执行。
依赖于另一个失败的操作。



426
Upgrade Required (需要升级)
客户端应该切换到TLS&#x2F;1.0等协议。
服务器要求客户端升级连接协议。



428
Precondition Required (需要前提条件)
服务器要求在请求中包含条件头部（如If-Match或If-Unmodified-Since）。
强制客户端在更新资源时提供Etag。



429
Too Many Requests (请求过多)
用户在给定时间内发送了太多请求（频率限制）。
API限流。



431
Request Header Fields Too Large (请求头字段过大)
服务器不接受请求，因为一个或多个头部字段过大。
请求头部包含过多的Cookie或自定义头部。



451
Unavailable For Legal Reasons (因法律原因不可用)
服务器拒绝访问该资源，因为该资源因法律原因被审查。
受政府审查的网站内容。


5xx (服务器错误)
500
Internal Server Error (服务器内部错误)
服务器遇到错误，无法完成请求。
服务器代码异常、未捕获的错误。



501
Not Implemented (尚未实施)
服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。
访问了尚未实现的API端点。



502
Bad Gateway (错误网关)
服务器作为网关或代理，从上游服务器收到无效响应。
反向代理（如Nginx）与后端服务通信失败。



503
Service Unavailable (服务不可用)
服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。
服务器过载、维护模式。



504
Gateway Timeout (网关超时)
服务器作为网关或代理，但是没有及时从上游服务器收到请求。
反向代理等待后端服务响应超时。



505
HTTP Version Not Supported (HTTP 版本不受支持)
服务器不支持请求中所用的 HTTP 协议版本。
客户端使用了过时或不支持的HTTP版本。



506
Variant Also Negotiates (变体也协商)
服务器存在内部配置错误：它用于透明内容协商的透明代理本身被配置为参与协商。
较少见的服务器配置错误。



507
Insufficient Storage (存储空间不足)
WebDAV协议扩展，表示服务器无法存储完成请求所需的表示。
服务器磁盘空间不足。



508
Loop Detected (检测到循环)
WebDAV协议扩展，服务器在处理请求时检测到无限循环。
某些WebDAV操作中检测到循环依赖。



510
Not Extended (未扩展)
请求需要对服务器进行进一步的扩展才能实现。
客户端未能满足服务器的某个强制扩展。



511
Network Authentication Required (需要网络身份验证)
客户端需要进行网络身份验证才能获得访问权限。
公共Wi-Fi登录页面重定向。


]]></content>
      <categories>
        <category>HTTP</category>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>protected</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Openwrt获取到了ipv6地址，但无法使用</title>
    <url>/2023/02/28/Openwrt%E8%8E%B7%E5%8F%96%E5%88%B0%E4%BA%86ipv6%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%BD%86%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[Openwrt获取到了ipv6地址，但无法使用获取到了ipv6地址，但经测试无法使用ipv6的地址，而且ping具有v4&#x2F;v6双栈响应的网站，显示的目标ip是ipv4。
解决办法开启ipv6 转发和修改防火墙策略
# 修改/etc/sysctl.conf，将以下内容加进去,大意说接收广播并开启IPv6转发net.ipv6.conf.default.forwarding=2net.ipv6.conf.all.forwarding=2net.ipv6.conf.default.accept_ra=2net.ipv6.conf.all.accept_ra=2net.ipv6.conf.default.accept_dad=2net.ipv6.conf.all.accept_dad=2net.ipv6.conf.default.dad_transmits=2net.ipv6.conf.all.dad_transmits=2# 因为OpenWRT默认的防火墙配置不会管IPv6的nat表需要在/etc/firewall.user添加防火墙规则：# set up firewallip6tables -P INPUT ACCEPTip6tables -P OUTPUT ACCEPTip6tables -A OUTPUT -p tcp -j ACCEPTip6tables -A OUTPUT -p udp -j ACCEPT# input rulesip6tables -A INPUT -p ipv6-crypt -j ACCEPTip6tables -A INPUT -p ipv6-auth -j ACCEPTip6tables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPTip6tables -A INPUT -m state --state NEW -j ACCEPTip6tables -A INPUT -m state --state INVALID -j DROP# allow DHCPv6ip6tables -A INPUT -p udp --sport 547 --dport 546 -j ACCEPTip6tables -A INPUT -p udp --sport 500 --dport 500 -j ACCEPTip6tables -A INPUT -p udp --sport 4500 --dport 4500 -j ACCEPT# allow ipv6-icmp related packetip6tables -A INPUT -p ipv6-icmp --icmpv6-type router-solicitation -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type packet-too-big -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type time-exceeded -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type parameter-problem -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type echo-request -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type echo-reply -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type 130 -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type 131 -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type 132 -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type router-solicitation -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type router-advertisement -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type neighbour-solicitation -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type neighbour-advertisement -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type 141 -j ACCEPTip6tables -A INPUT -p ipv6-icmp --icmpv6-type 142 -j ACCEPTip6tables -A INPUT -p ipv6-icmp --icmpv6-type 143 -j ACCEPTip6tables -A INPUT -p ipv6-icmp --icmpv6-type 148 -j ACCEPTip6tables -A INPUT -p ipv6-icmp --icmpv6-type 149 -j ACCEPTip6tables -A INPUT -p ipv6-icmp --icmpv6-type 151 -j ACCEPTip6tables -A INPUT -p ipv6-icmp --icmpv6-type 152 -j ACCEPTip6tables -A INPUT -p ipv6-icmp --icmpv6-type 153 -j ACCEPTip6tables -A INPUT -j DROP

来源https://blog.csdn.net/a735131232/article/details/117004464
测试网址：
https://www.test-ipv6.com/
IPv6地址查询工具 (zxinc.org)
]]></content>
      <categories>
        <category>OpenWRT</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>OpenWRT</tag>
      </tags>
  </entry>
  <entry>
    <title>UnRaid使用指南</title>
    <url>/2024/10/04/UnRaid%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[设置中文
切换到 TOOLS 选项卡中，找到Language，点击进入后，输入如下URL： https://gitee.com/wsh-feiyu/language-templates/raw/master/limetech/lang-zh_CN.xml，然后点击INSTALL。


输入这个项目的汉化插件：https://github.com/seanzhang98/unraid_zh_CN_Beta
由于github访问困难，可以对这个文件做镜像，比如使用gitee：https://gitee.com/wsh-feiyu/language-templates/raw/master/limetech/lang-zh_CN.xml


点击完成INSTALL按钮之后，页面可能没有反应，可以按下F5刷新一下。当出现 简体中文后，语言包安装成功。



进入 SETTINGS设置页面，找到 Display Settings，点进去。



修改显示语言为 简体中文




然后下拉页面，点击APPLY更改，然后再次下拉点击完成按钮。



至此，中文设置完成。




安装应用商店配置网络代理（需要借助clash）
使用ssh或web界面的终端打开命令窗口

编辑/root/.wgetrc这个文件（这个文件可能不存在）

在其中写入如下代码：（建议使用ssh客户端进行）

use_proxy=yes
http_proxy=http://[你的clash设备IP]:[端口默认7890]
https_proxy=http://[你的clash设备IP]:[端口默认7890]
wait=10

如：

use_proxy=yes
http_proxy=http://192.168.172.216:7897
https_proxy=http://192.168.172.216:7897
wait=10
   2. &gt; 这段的含义就是，让unraid的wget走代理，因为下载安装是用的wget服务（根据我搜索了大量的文章，看了很多大佬的解决方法，最终确认，这个是管用的，我是6.11.5版本。**其他的修改profile的，直接在/usr/local/sbin/emhttp &amp;加proxy的，都不管用**）4. 编辑完保存，**不需要重启**，现在去APPS下点击install，已经可以安装市场了。5. 如果安装还是失败,测试指定的代理能否正常工作:   1. 先使用 `curl -x http://192.168.172.216:7897 www.google.com `测试代理是否正常`-x` 选项指定要使用的代理服务器，后面跟的是代理的URL（包括地址和端口）。例如，`-x http://192.168.172.216:7897` 表示通过指定的代理访问后面的URL。6. 此时,应用商店就能正常访问了.   1. ![image-20241004125236849](/Image/unraid使用指南.assets/image-20241004125236849.png)      ## 设置开机启动   因为unraid是从U盘启动的，重启后刚刚编辑的root/.wgetrc这个文件就没了，所以要编辑/boot/config/go这个文件，写入以下代码即可   ```text   echo &quot;use_proxy=yes&quot; &gt;&gt; /root/.wgetrc   echo &quot;http_proxy=http://[你的clash设备IP]:[端口默认7890]&quot; &gt;&gt; /root/.wgetrc   echo &quot;https_proxy=http://[你的clash设备IP]:[端口默认7890]&quot; &gt;&gt; /root/.wgetrc   echo &quot;wait=10&quot; &gt;&gt; /root/.wgetrc



这段的含义就是U盘引导开机的时候，在root里面写入一个.wgetrc的文件，就是把上面的代码开机的时候新建写入一遍。


Fatal error during checkPluginlnProgress SweetAlert:Unexpected 2nd argument (function (isConfirm) {if (isConfirm) {hidePluginPending(pluginURL);if($(“.selectedMenu”).data(“category”)&#x3D;&#x3D; “action centre”){var postFunction &#x3D;”actionCentre”} else {var postFunction&#x3D;”OpenSidebarAndRefreshDisplay”
port=7897tunnel=1proxy=http://192.168.172.216





主界面中硬盘顺序
似乎：

sda为U盘（系统）
sdb为距离开机按键最远的一块硬盘
sdc、sdd依次

能正确读取到硬盘SN码，换完硬盘需要手动保存硬盘序列号和盘位关系。
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>UnRaid</tag>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>Windwos环境下F键的功能介绍</title>
    <url>/2023/02/28/Windwos%E7%8E%AF%E5%A2%83%E4%B8%8BF%E9%94%AE%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[F键的功能
f1可以帮你在困境中寻找帮助
可以唤出帮助页


f2可以在你懒得动右手中指时助你快速重命名
windows中可以快速的进行重命名操作


f3可以在你懒得动右手食指时助你搜遍文件夹
windows中可以打开搜索框进行搜索


f4和alt放在一起可以让电脑自动做你要做的工作
这个组合键可以强制关闭选定的窗口&#x2F;程序


f5可以陪伴你度过无聊的等待时光
可以对当前的页面进行刷新


f6可以在你懒得翻历史记录时助你搜到爱看的
f7可以在浏览器中切换使用文本光标浏览网页
f8可以在电脑启动时进入启动高级菜单选项（看电脑）
f9可以在windows media player降低音量 excel里计算
f10＋shift&#x3D;鼠标右键
Windows中可以用这个快捷键实现当前选项&#x2F;界面的右键操作


f11可以让你看片看的更爽
浏览器中可以使用这个键进入全屏模式


f12可以进入开发者工具
浏览器中快速打开开发者工具。



]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>WiFiDuck_修改成为连接到指定的WiFi</title>
    <url>/2024/03/29/WiFiDuck_%E4%BF%AE%E6%94%B9%E6%88%90%E4%B8%BA%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84WiFi/</url>
    <content><![CDATA[需求
原始项目为创建一个AP热点，需修改成连接现有WiFi的模式，然后其他设备访问这个设备的ip的形式使用。
由于esp8266的异步库不支持ipv6，因此需要通过nginx来对现有设备的进行代理，以实现在外部通过ipv6的形式进行访问

修改步骤修改网页文件并编译
注释掉原有的创建热点的代码：位于webserver.cpp中的 void begin()方法中

WiFi.softAP(settings::getSSID(), settings::getPassword(), settings::getChannelNum());
debugf(&quot;Started Access Point \&quot;%s\&quot;:\&quot;%s\&quot;\n&quot;, settings::getSSID(), settings::getPassword());
2. 在注释掉的位置新增连接到指定WiFi的代码：   - ```     WiFi.begin(&quot;SSID&quot;, &quot;PASSWORD&quot;);

- `SSID`需要修改成要连接的WiFi的名称
- `PASSWORD`需要修改成指定WiFi的密码




修改 script.js文件（需要去官方下载web源码）

注释掉其中的这个代码

ws = new WebSocket(&quot;ws://192.168.4.1/ws&quot;);
2. 新增如下代码   - ```     ws = new WebSocket(&quot;ws://IP+端口/ws&quot;);

- `IP+端口`的值为nginx服务器的地址，或者为设备本身的ip地址






使用 python webconverter.py命令将网页文件转换为所需的字节数组

将生成的字节数组替换到项目中对应位置，然后重新编译项目并上传


创建nginx配置块server &#123;        listen 9898;        location / &#123;            proxy_pass 设备实际ip+端口;            proxy_set_header Host $host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_set_header X-Forwarded-Proto $scheme;        &#125;                location /ws &#123;			# 开启 WebSocket 代理支持			proxy_set_header Upgrade $http_upgrade;			proxy_set_header Connection &quot;upgrade&quot;;			# 设置 WebSocket 代理目标			proxy_pass http://设备实际IP+端口/ws;			# 其他可能需要的代理设置			proxy_redirect off;			proxy_set_header Host $host;			proxy_set_header X-Real-IP $remote_addr;			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;						# 需要增加以下配置 不然websocker会短时间就断连			proxy_read_timeout 3600s;  # 增加读取超时时间			proxy_send_timeout 3600s;  # 增加发送超时时间			proxy_http_version 1.1;    # 必须使用HTTP/1.1或以上版本，以支持WebSocket			keepalive_timeout 3600s;  # 保持连接活跃超时时间，防止空闲连接被关闭		&#125;    &#125;

]]></content>
      <categories>
        <category>ESP8266</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>WiFiDuck</tag>
        <tag>ESP8266</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础教程</title>
    <url>/2024/02/29/Java%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[Java概述Java技术体系平台Java SE（Java Standard Edition）：标准版支持面向桌面级应用的Java平台，提供了完整的Java核心


Java EE（Java Enterprise Edition）：企业版为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet、Jsp等，主要针对于Web应用程序开发。版本以前称为J2EE


Java ME（Java Micro Edition）：小型版支持Java程序运行在移动终端(手机、PDA) 上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME


Java 重要特点
Java 语言是面向对象的(oop)。

Java 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证。

Java 语言是跨平台性的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]

Java 语言是解释型的[了解]
解释性语言：javascript,PHP, java 编译性语言: c &#x2F; c++
区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行, 编译性语言, 编译后的代码, 可以直接被机器执行。

Java内置了多线程的支持。

Java是动态的。基本组成单元是类，类是在运行的时候动态装载的，可以在环境中动态的维护程序和类库。（在面向对象时就区分了编译类型和运行类型）


Java的运行机制及运行过程JVM Java虚拟机 Java virtual machine
JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在 JDK 中。
对于不同的平台，有不同的虚拟机。
Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”。（即运行环境相等）

JDK Java开发工具包 Java Development KitJDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。


JRE Java运行环境 Java Runtime Environment包括 Java 虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序， 计算机中只需要安装 JRE 即可。


JDK、JRE 和 JVM 的包含关系
JDK &#x3D; JRE + 开发工具集（例如 Javac,java 编译工具等)
JRE &#x3D; JVM + Java SE 标准类库（java 核心类库）
如果只想运行开发好的 .class 文件 只需要 JRE

Java 开发注意事项和细节
Java源文件以.java为扩展名。源文件的基本组成部分是类(class) 。
Java应用程序的执行入口是main()方法。它有固定的书写格式:public static void main(String[] args) {..}
Java语言对大小写敏感。
Java方法由一条条语句构成，每个语句以”；“结束。
大括号都是成对出现的，缺一不可。 [习惯，先写{}再写代码]
一个源文件中最多只能有一个public类。 其它类的个数不限。
如果源文件包含一个public类，则文件名必须按该类名命名!
一个源文件中最多只能有一个public类。其它类的个数不限，也可以将main方法写在非public类中，然后指定运行非public类，这样入口方法就是非public的main方法

Java中常用的转义字符
\t ：一个制表位，实现对齐的功能
\n ：换行符
\\ ：一个\
\“ :一个”
\‘ ：一个’
\r :一个回车 （光标回到当前行的第一个字符）

Java注释（comment）Java 中的注释类型
单行注释 &#x2F;&#x2F;
多行注释 &#x2F;* *&#x2F;
文档注释 &#x2F;** *&#x2F;

使用细节
被注释的文字，不会被 JVM（java 虚拟机）解释执行
多行注释里面不允许有多行注释嵌

文档注释注释内容可以被JDK提供的工具Javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。一般写在类。


生成文档注释javadoc -d 文件名 -xx -yy zzz.java //文件名指存放的位置，xx、yy指参数，可以通过javadoc -help进行查看，

Java 代码规范
类、方法的注释，要以Javadoc的方式来写。
非Java Doc的注释，往往是给代码的维护者看的，着重告述读者为什么这样写，如何修改，注意什么问题等
使用tab操作， 实现缩进,默认整体向右边移动，时候用shift+ tab整体向左移
运算符和&#x3D;两边习惯性各加一个空格。比如:2 + 4 * 5 + 345 - 89
源文件使用utf-8编码
行宽度不要超过80字符
代码编写次行风格和行尾风格。

路径相对路径从当前目录开始定位，形成一个路径，含义是相对于现在这个目录，我指定的在哪里。在不同目录下该路径的含义不同。如：
..\abc2				//指向上一个文件夹中的abc2文件。	..表示返回上一级

绝对路径从根目录开始定位，只要是在这个计算机内就能保证路径指向的唯一性。如：
D;\hurr\test

Windows下简单的DOS命令
查看当前目录是有什么内容
dir D:\hurriedlu\test
切换到其他目录下
cd D:\Programs
切换到上一级目录 (使用相对路径)
cd ..
切换到根目录
cd \
查看指定的目录下所有的子级目录
tree
清屏
cls
退出 DOS
exit




Java中的变量同c、c++一样，每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间(字节)。


在Java中，整个数据类型可分为两大类：

基本数据类型和引用数据类型。
基本数据类型


数据类型
标识符
默认值
存储大小(字节)
数据范围



整型
byte
0
1
-128~127


整型
short
0
2
-32768~32767


整型
int
0
4
-2147483648~2147483647


整型
long
0L&#x2F;0l
8
-2^63~2^63-1


实型
float
0.0F&#x2F;0.0f
4
32位IEEEE 754单精度范围


实型
double
0.0&#x2F;0.0D&#x2F;0.0d
8
64位IEEEE 754双精度范围


逻辑
boolean
false
1bit
true或false


字符
char
空
2
Unicode的字符范围: ‘\u0000’ (即为0)到’\uffff’ (即为65,535)


同c、c++有些许不同，虽然要求任何变量在使用前必须初始化，但变量在定义的时候已经有初值了。（c中只有全局变量才有初值）
使用细节
Java中各整数类型都有固定的范围和字段长度，不受操作系统的影响，保证了可移植性。

整形变量默认为int型，声明long型需要在后面加上l或者L。

同c、c++有些许不同，虽然要求任何变量在使用前必须初始化，但变量在定义的时候已经有初值了。（c中只有全局变量才有初值）

注意数据范围，小心溢出。

对于浮点型而言，其中的数值不是准确的，存储的仅是近似值。因此，在比较浮点型数据中，一般的方法是将两个数相减，如果差值小于精度的要求，就认为是相等的。如下：
double num1 = 2.7;double num2 = 8.1/3;if(Math.abs(num1-num2)&lt;0.00001)    System.out.println(&quot;两个数相等&quot;);
字符常量是用单引号括起来的单个字符，因为使用的是Unicode编码，因此可以存储汉字，且占用空间是2个字节。

在Java中char是可以进行运算的，和c相同，当成一个整数。


类型转换自动类型转换Java在赋值和运算时，精度小的类型会自动转换为精度大的数据类型，这就是自动类型转换。


```**char -&gt; int -&gt; long -&gt; float -&gt; double**
**byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double**##### 自动类型转换中需要注意的细节1. 有多种类型的数据混合运算时，系统首先自动将所有数据转换成（精度）容量最大的那种数据类型，然后再进行计算。2. 当我们把精度(容量)大的数据类型赋值给精度(容量)小的数据类型时，就会报错，反之就会进行自动类型转换。3. (byte, short)和char之间不会相互自动转换。4. byte, short, char 他们三者可以计算，在计算时首先转换为int类型（自动）。5. boolean不参与转换。6. 自动提升原则：表达式结果的类型自动提升为操作数中最大的类型。#### 强制类型转换
自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符 ( )，但可能造成
**精度降低或溢出**，格外要注意。##### 强制类型转换细节1. 当需要对精度（容量）大的转换为小的的时候，就需要使用到强制转换。2. 强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级。   ```java   int x = (int)10 * 3.5 + 5 * 1.5;		//42.5   int y = (int)(10 * 3.5 + 5 * 1.5); 		//42

char类型可以保存int的常量值，但不能保存int的变量值，需要强转。（即以字符形式存储整型值）
char c1 = 100; //okint m = 100; //okchar c2 = m; //错误char c3 = (char)m; //okSystem.out.println(c3);//100对应的字符
byte和short，char类型在进行运算时，当做int类型处理。


引用类型每种编程语言都有自己操作内存中元素的方式，例如在 C 和 C++ 里是通过指针，而在 Java 中则是通过“引用”。


在 Java 中一切都被视为了对象，但是我们操作的标识符实际上是对象的一个引用（reference）。


通过将这个叫“引用”的标识符指向某个对象，之后便可以通过这个引用来实现操作对象了。


最常用的引用类型就是String，它可以很方便的存储字符串。


对于引用在后面面向对象的时候会详细的讲，这里只需要直到引用类型不能直接&#x3D;&#x3D;来判断值是否相同。
基本数据类型与String类型的转换基本数据类型转String基本类型+&quot;&quot;;	//基本类型加上一个空串就行

String转基本类型通过基本类型的包装类调用parseXX方法即可。
Integer.parseInt(&quot;123&quot;);Double.parseDouble(&quot;123.1&quot; );Float.parseFloat(&quot;123.45&quot;) ;Short.parseShort(&quot;12&quot; ); Long.parseLong(&quot;12345&quot; );Boolean.parseBoolean(&quot;true&quot;);Byte.parseByte(&quot;12&quot;);

注意事项
在将 String 类型转成基本数据类型时，比如我们可以把 “123” , 转成一 个整数，但是不能把 “hello”转换成整数。
对于格式不正确的转换，会直接抛出异常，程序停止。
不同于c，会从头开始转换，直到不能转换为止，如123abc可以转换成整数123，但这在Java中是不可以的。

Java中常用编码简介ASCII码最通用的单字节编码系统，等同于国际标准ISO/IEC 646 。


传统ASCII码规定了128个字符，只占用了一个字节中的后七位


扩展ASCII码扩展了128给，即一个字节八个位全都有使用。扩展ASCII码允许将每个字符的第8 位用于确定附加的128 个特殊符号字符、外来语字母和图形符号。


Unicode 编码
Unicode的好处: 每一个符号都给予一 个独一无二的编码，使用Unicode没有乱码的问题。
Unicode的缺点:一个英文字母和一个汉字都占用2个字节，这对于存储空间来说是浪费。
2的16次方是65536，所以最多编码是65536个字符。
Unicode码兼容ASCII码。编码0- 127的字符是与ASCII的编码一样，比如’a’ 在ASCII码是0x61，在Unicode码是0x0061,都对应97。

UTF-8编码
UTF-8是在互联网上使用最广的一种Unicode的实现方式(改进)。
UTF-8 是一种变长的编码方式。它可以使用1-6个字节表示一个符号， 根据不同的符号而变化字节长度。
使用大小可变的编码字母占1个字节，汉字占3个字节。

Java中的加号整个表达式从左往右进行运算，当运算符两边是数值时进行数值上的相加，当读到有非数值的时候，从此刻开始直到整个表达式结束，+号的作用变成了连接。如下：

System.out.println(100 + 98); //198System.out.println(&quot;100&quot; + 98)//10098System.out.println(100 + 3 + &quot;hello&quot;);//103helloSystem.out.println(&quot;hello&quot; + 100 +3); //hello1003
运算符与C++中的运算符类似，此处不再详细笔记。如有不同则会在后期添加

赋值运算符：&#x3D;
算数运算符：+ - * &#x2F; %
关系运算符：&gt; &lt; &gt;&#x3D; &lt;&#x3D; !&#x3D; &#x3D;&#x3D;
逻辑运算符（短路符，即一旦确定值后直接结束）： &amp;&amp; ||
（非短路，会全部运算完）&amp; | !

自增自减符：++ –
三元运算符： 条件表达式?表达式1：表达式2；
下标运算符：[]
类型转换：（）
其他运算符：new instanceof 位运算符 访问成员运算符

instanceof用于检查是否是类的对象。常用于后面的多态的向下转型。先判断这个对象引用的运行类型是否属于某个子类，是的话就可以进行向下转型。

标识符的命名标识符概念
Java 对各种变量、方法和类等命名时使用的字符序列称为标识符
凡是自己可以起名字的地方都叫标识符int num1 &#x3D; 90;

标识符的命名规则(必须遵守)与c++相同
由26个英文字母大小写，0-9，_或$组成。汉字也行，但不推荐。
数字不可以开头。
不可以使用关键字和保留字，但能包含关键字和保留字。
Java中严格区分大小写， 长度无限制。
标识符不能包含空格。

标识符命名规范
包名：多单词组成时所有字母都小写：aaa.bbb.ccc
类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰]
变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小驼峰， 简称 驼峰法]
常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ

后面我们学习到 类，包，接口，等时，我们的命名规范要这样遵守,更加详细的看文档。
Java中的位运算&amp;按位与：对应的两位全为1，结果为1

|按位或：对应位有1为1

^按位异或：对应位相异为一

~按位取反

&gt;&gt;算术右移 ：低位溢出，符号位不变，并用符号位补溢出的高位。

&lt;&lt;算术左移 ：符号位不变,低位补 0

&gt;&gt;&gt;逻辑右移：也叫无符号右移，运算规则是: 低位溢出，高位补 0

注意，没有逻辑左移！！！关键字关键字的定义和特点 (不用背) 定义：被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词） 特点：关键字中所有字母都为小写。
用于定义数据类型的关键字：
class
interface
enum
byte
short
int 
long
float
double
char
boolean
void

用于定义数据类型值的关键字
true
false
null

用于定义流程控制的关键字
if
else
switch
case
default
while
do
for
break
continue
return

用于定义访问权限修饰符的关键字
private
protected
public

定义类、函数、变量修饰符的关键字
abstract
final
static
synchronized

定义类与类之间关系的关键字
extends
implements

用于建立实例及引用实例、判断实例的关键字
new
this
super
instanceof

用于异常处理的关键字
try
catch
finally
throw
throws

用于包的关键字
package
import

其他修饰符关键字
native
strictfp
transient
volatile
assert

保留字现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留 字 byValue、cast、future、 generic、 inner、 operator、 outer、 rest、 var 、 goto 、const。

键盘输入语句
导入该类的所在包,  java.util.Scanner。
创建该类对象（声明变量）。
调用里面的功能。

常用的语句如下：
Scanner scanner = new Scanner(System.in);	//定义方法int num = scanner.nextInt();				//读取int类型double d = scanner.nextDouble();			//读取浮点型String s = scanner.next();					//读取字符串
数组、排序和查找数组的定义一维数组声明数组的元素类型 [] 数组名;数组的元素类型  数组名 [];
分配元素数组名 = new 数组元素的类型[个数];
同时进行声明和分配元素int num[] = new [10];//定义了一个int类型的一维数组，有10个元素，下标范围0-9
二维数组声明数组的元素类型 [][] 数组名;数组的元素类型 数组名[][];
分配元素数组名 = new 数组元素的类型[个数][个数];
同时进行声明和分配元素int num[][] = new [10][12];//定义了一个int类型的一维数组，有10个元素，下标范围0-9
数组的遍历一维数组不利用方法int num[] = new int[10];for (int i = 0; i &lt; num.length; i++) &#123;    System.out.println(num[i] + &#x27; &#x27;);&#125;
利用方法int num[] = new int[10];System.out.println(Arrays.toString(num));//利用数组类里面的toString方法，直接将整个数组转换成字符串的形式
二维数组不利用方法int arr[][] = new int[10][10];for (int i = 0; i &lt; arr.length; i++) &#123;    for (int j = 0; j &lt; arr[i].length; j++) &#123;        System.out.print(arr[i][j] + &quot; &quot;);    &#125;&#125;
利用方法int arr[][] = new int[10][10];for (int i = 0; i &lt; arr.length; i++) &#123;    System.out.println(Arrays.toString(arr[i]));&#125;
与c的不同之处
首先就是定义的方法不同。
其次就是，在二维数组中，在c里面可以以一维的方式进行访问（即第二行第一列等于第一行+1），但在java中不行。
java中的二维数组相当于：我定义了一个一维数组，里面存放了指向一个一维数组的地址。
因此，在Java中，二维数组可以不再是矩形的了，每一行的空间都可以单独的定义。比如这样：

int arr[][] = new int[10][];arr[2]=new int[112];arr[1]=new int[10];arr[2]=new int[13];

因为可以Java的特性，导致了数组的列数可能不统一，且每一行都能获取到当前行有多少列
有一点和C是一样的，就是数组一旦分配了就不能在更改长度，只能对该一维数组重新定义，然后把老的数组里面的值复制到新数组。
有一点和新版本的C是相似的，就是允许在运行的过程中分配空间，而不是在编译的时候就需要确定好。（c98以前的标准不允许）

程序控制结构在Java中，也分为三大流程控制：顺序控制 分支控制 循环控制。对应的语句和c也一样，此处不在进行笔记，不同的地方后期补足。
增强for循环语法for(暂存变量:数组名)&#123;    System.out.println(暂存变量);&#125;//需要注意暂存变量的类型需要与数组中元素的类型相同。在每次循环中会自动的将数组中的元素一次赋值给 
使用样例如下：
int nums[] = &#123;1,3,9&#125;;for(int i:nums)&#123;  System.out.print(i+&quot; &quot;);&#125;String s[] = &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;;for(String t:s)&#123;  System.out.print(t+&quot; &quot;);&#125;//运行结果：1 3 9 a b c 
面向对象：类与对象的关系
把需要的属性和方法抽象出来就形成了类，将类实例化后形成对象，形成对象后可以为其个性化。


类是抽象的，概念的，代表一类事物,比如人类,猫类.., 即它是数据类型。
对象是具体的，实际的，代表一个具体事物, 即 是实例
类是对象的模板，对象是类的一个个体，对应一个实

属性、成员变量（字段）基本介绍从概念或叫法上看： 成员变量 &#x3D; 属性 &#x3D; field(字段) （即 成员变量是用来表示属性的)。
属性是类的一个组成部分，可以是是基本数据类型,也可是引用类型(对象，数组)。
注意事项
属性的定义语法同变量
属性的定义类型可以为任意类型，包含基本类型或引用类型
属性如果不赋值，有默认值，规则和数组、变量一致。

对象创建对象
先声明再创建

1. Cat cat ; //声明对象 cat 2. cat = new Cat();

直接创建

Cat cat = new Cat();
访问对象的属性cat.name;	//对象名.属性名;
对象的细节类和对象的内存分配机制Java 内存的结构分析
栈： 一般存放基本数据类型(局部变量)。
堆： 存放对象(Cat cat , 数组等)。
方法区：常量池(常量，比如字符串)， 类加载信息

Java 创建对象流程的简单分析
先加载 Person 类信息(属性和方法信息, 只会加载一次。
在堆中分配空间（地址），进行默认初始化(看规则)
把地址赋给一个引用类型的变量，就指向对象
进行指定初始化， 比如 p.name &#x3D;”jack”

对象在内存中存在形式
程序运行时，会将整个类加载到”方法区“（只加载一次）。
当将类实例化成对象的时候，会按照方法区的类在堆中开辟一个空间，如果其中引用了字符串之类的，会将位于常量池的字符串的地址写入堆中对应的位置，如果是普通类型，会分配空间并使空间清零。
在栈中创建一个对象的引用变量，并将堆中的地址写入栈中。

成员方法基本介绍在某些情况下，我们要需要定义成员方法(简称方法)。比如人类:除了有一些属性外( 年龄，姓名..),我们人类还有一 些行为比如:可以说话、跑步..,通过学习，还可以做算术题。这时就要用成员方法才能完成。

方法，也称为函数。

方法的调用机制原理
当程序执行到方法的时候，就会开辟一个独立空间。
当方法执行完毕，或者执行到return语句时，就会返回到调用方法的地方继续执行（类似于中断）。
当整个main方法（栈）执行完毕，整个程序退出。


和C++一样，每个函数的空间独立，其中的局部变量的生存期和作用域都不会超出这个函数的空间

成员方法的意义
提高代码的复用性。
可以将实现的细节封装起来，然后供其他用户来调用

成员方法的定义：访问修饰符 返回数据类型 方法名（形参列表..） &#123;//方法体语句;return 返回值;&#125;

形参列表：表示成员方法输入 cal(int n) ， getSum(int num1, int num2)。
返回数据类型：表示成员方法输出, void 表示没有返回值。
方法主体：表示为了实现某一功能代码块。
return：返回一定的值，如在方法中计算得到的值，或者状态。该语句不是必须的 。

方法的细节
一个方法最多有一个返回值，如需返回多个可以借助数组或者类。
返回类型可以为任意类型，包含基本类型或引用类型(数组，对象)。
如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值; 而且要求返回值类型必须和 return 的 值类型一致或兼容。
如果方法是 void，则方法体中可以没有 return 语句，或者 只写 return ;
方法名遵循驼峰命名法，最好见名知义，表达出该功能的意思即可。
一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开，比如getSum(int n1,int n2)。
参数类型可以为任意类型，包含基本类型或引用类型，比如printArr(int[][] map[] [] )。
调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数! [getSum]
方法定义时的参数称为形式参数，简称形参;方法调用时的传入参数称为实际参数，简称实参，实参和形参的类型要一致或兼容、 个数、顺序必须致! 
方法体里面写完成功能的具体的语包，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法!即:方法不能嵌套定义。[演示]
传入方法的并不是原来的元素，而是其中的值。对于普通类型来说，因为传进去的是直接的值，相当于拷贝一份进去，因此不会影响到原来变量的地址；但对引用类型来说，传入的是一个地址，针对地址的修改会直接影响到原来的值。（好像与C++中有些不太一样，String是引用类型，但如果传到函数中并对其进行修改，回到main中再输出还是修改之前值）。
当方法是static的时候，表示这是一个静态的方法，可以不用实例化成对象，直接通过类名.方法名进行调用。具体细节后面说。

可变参数基本概念java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。 就可以通过可变参数实现。

简单的说就是当成一个不定长的数组，传入的一瞬间为这堆数开辟一个空间放进去，并把首地址传入。

基本语法访问修饰符 返回类型 方法名(数据类型... 形参名) &#123; &#125;public int fun(int ... nums)&#123;  int sum=0;  for(int i=0;i&lt;nums.length;i++)  &#123;    sum+=nums[i];  &#125;  return sum;&#125;
作用域基本使用面向对象中，变量作用域是非常重要的。


在java编程中，主要的变量就是属性(成员变量)和局部变量。
我们说的局部变量-般是指在成员方法中定义的变量。 [举例Cat类: cry]
java中作用域的分类全局变量:也就是属性，作用域为整个类体；局部变量:也就是除了属性之外的其他变量，作用域为定义它的代码块中!
全局变量(属性)可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值。

注意事项和细节
属性和局部变量可以重名，访问时遵循就近原则。
在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名。
属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而销毁。即在一次方法调用过程中。
作用域范围不同全局变量&#x2F;属性:可以被本类使用，或其他类使用(通过对象调用)局部变量:只能在本类中对应的方法中使用
修饰符不同全局变量&#x2F;属性可以加修饰符局部变量不可以加修饰符

构造方法&#x2F;构造器基本介绍构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。

特点：
方法名和类名相同。
没有返回值。
在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。

基本语法[修饰符] 方法名(形参列表)&#123; 方法体; &#125; 
具体说明
构造器的修饰符可以默认， 也可以是 public protected private
构造器没有返回值。
方法名 和类名字必须一样。
参数列表 和 成员方法一样的规则。
构造器的调用, 由系统完成。
一个类可以定义多个不同的构造器，即构造器重载
构造器是完成对象的初始化，并不是创建对象
在创建对象时,系统自动的调用该类的构造方法
如果程序员没有定义构造器，系统会自动给类生成一 个默认无参构造器(也叫默认构造器)，比如Dog (){}, 可以使用javap指令反编译查看到
一旦定义了自己的构造器,默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下,即: Dog( ){ }

this什么是thisjava虚拟机会给每个对象分配this，代表当前对象。

简单的说，this存储的当前对象的地址，哪个对象调用this，this就代表哪个对象

this 的注意事项和使用细节
this 关键字可以用来访问本类的属性、方法、构造器。
this 用于区分当前类的属性和局部变量。
访问成员方法的语法：this.方法名(参数列表); 。
访问构造器语法：this(参数列表); 注意只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一 条语句)。
this 不能在类定义的外部使用，只能在类定义的方法中使用。

包包的作用
区分相同名称的类
当类较多的时候，可以很好的管理类。
控制访问范围。

包的存在类似于电脑的文件夹，采用树状结构存放其中的文件。同一个包中的类不能重名，但不同包之间可以有重名的类。

基本语法声明存在位置package 包名；

package net.hurr.test;
包的引入import 包名；

improt 包名;
作用使用该包下面的类，可以使用通配符*。如导入Scanner类：

import java.util.Scanner;import java.util.*;
建议使用前者，用哪个导哪个。

部分IDE如Idea回自动导，不需手写。

访问修饰符(访问权限)


访问级别
访问控制修饰符
同类
同包
子类
不同包



公开
public
√
√
√
√


保护
protected
√
√
√
×


默认（不写）

√
√
×
×


私有
private
√
×
×
×



public：对外公开，均可访问
protested：对子类和同一个包中的其他类公开
默认：仅对同一个包中的类公开
private：只有本类成员可以访问，不对外公开。

面向对象三大特征：封装、继承、多态。将共有的属性抽象出来，封装成一个个小单元，如果需要的新的功能与之前的有些区别，可以通过继承的方式增加属于自己的功能。有些功能可能之前写过了，但不太符合需求，可以通过重写的方式更新对应方法，或者做出来的可能会有好几种的用途，根据用途不同可以重载一下。重载和重写就是多态的具体实现方式。

封装将抽象出来的数据（属性）和对数据的操作（方法）打包封装在一起，数据就会被保护在内部（私有化），想要使用只能通过对应的暴露在外面的方法进行操作，这样可以检查操作的合法性。

封装的好处
隐藏实现的细节。
可以对数据进行验证，保证安全合法

继承
继承很好的解决了代码复用的问题。类似于函数但比函数功能更加丰富。

对于两个相似的类，可以抽出其中共有的属性和方法，将其封装成父类，然后通过继承的方式继承父类即可，对于有差异的地方可以在继承后的子类中添加。
语法

class 子类名 extends 父类名&#123;&#125;
继承的好处
提高了代码的复用性
提高了代码的扩展性和维护性

继承的细节
子类继承了所有的属性和方法，非私有的属性可以在子类中直接访问，私有的属性和方法只能通过父类提供的公共方法来访问使用。
子类没有继承父类的构造器，所以必须调用父类的构造器，以完成父类的初始化。
创建子类对象时，不管使用了子类的哪个构造器，默认情况下都会去调用父类的无参构造器完成父类的初始化。如果父类没有预留无参构造器，则在子类中必须手动选择父类的有参构造器，否则编译器会报错。
如果需要指定调用父类的某个构造器，需要显示的调用一下：super(参数列表)
super()在使用的时候，必须放在构造器的第一行（super() 只能在构造器中使用）
super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器中。
java的所有类都是Object类的子类，Object是所有类的基类。
父类的构造器的调用不限于直接父类，可以一直往上追溯到Object类。
子类最多继承一个父类，因为Java是单继承的，因此不存在c++中的二义性的问题。如果一个类需要继承多个类，可以将这几个类串联在一起。
不能滥用继承，子类和父类之间必须满足 is – a的逻辑关系。

继承的本质当子类对象创建成功后，建立的查找关系。当创建了一个子类的时候，所有的属性（包括父类中的）全部都在对象内，但由于访问权限的不同不一定都可以访问。

查找属性和方法时，先从子类（最低级）开始寻找，一直找到最高类Object类。这其中如果有父类存在这个方法或者属性但权限是私有不允许访问的，则就不会继续向上查找，并报private的异常。

super
super代表父类的引用，用于访问父类的属性、方法、构造器。
super只能在类内使用，即只能在子类中通过super直接访问上一级中的属性。如果在main中将子类实例化后，不能在main中通过super访问父类。
要注意的是，super不能串联使用。他只能穿透一层。即有重名的属性的化，只能访问离自己最近的那个重名的。
super类似于一个指针（虽然java中没有指针的功能），存储了父类的地址。

基本语法
访问父类的属性（不能访问父类的private的属性）
  super.属性名;


访问父类的方法（同样不能访问private）
 super.方法名;


访问父类的构造器：只能在第一行
 super(参数列表);



super带来的便利
调用父类的构造器。
当子类与父类中的成员重名的时候，为了访问父类的成员，可以通过super访问。但仅限于访问被直接掩盖的。
super的访问不限于直接父类，如果爷爷类和本类中有共同的成员，也可以访问到爷爷类的成员。如果多个基类都有同名的成员，使用super访问遵循就近原则。（即只能穿透一层）

super和this的比较


区别点
this
super



访问属性、方法
优先在本类中进行查找，
越过本类，直接在父类中进行查找


调用构造器
调用本类的构造器，必须放在构造器的首行
调用父类的构造器，必须放在构造器的首行


特殊
表示当前对象
子类访问父类的对象


换句话数，this和super类似，一个存储了本类的地址，另一个存储了父类的地址。可以通过这个“地址”来控制访问
方法重写&#x2F;覆盖：简单的说，重写（覆盖）就是子类的一个方法，和父类的某个方法的名称、参数均一样，我们就说子类的这个方法覆盖了父类的方法。（类似于重载）

方法覆盖的注意事项和使用细节
子类的方法的形参列表、方法名，要和父类的对应的方法完全一致。
子类的方法的返回值需要和父类中被覆盖的方法保持一样，或者是父类返回类型的子类。如父类返回是Object，子类的返回类型是String，要保证子类的返回值可以向上转型为父类。
被覆盖的方法不能是private，否则只是在其子类中新定义了一个方法，并没有对其覆盖。
子类的方法不能缩小父类方法的访问权限，如父类是protected，子类可以是public、protected，但不能是private。

方法的重写和重载的对比


名称
发生范围
方法名
形参列表
返回类型
修饰符



重载  (overload)
本类
必须一样
类型，个数或者顺序至少有一个不同。
无要求
无要求


重写  (override)
父子类
必须一样
相同
子类重写的方法，返回类型和父类返回的类型一致，或者是其子类
子类方法不能缩小父类方法的访问范围。


多态基本介绍
方法或对象具有多种形态。
多态是面向对象的第三大特征。
多态是建立在封装和继承的基础上的。

多态的具体体现1.方法的多态

重写和重载。

2、 对象的多态

一个对象的编译类型和运行类型可以不一致。
编译类型在定义对象时，就已经确定了，不能更改。
运行类型是可以变化的（向上转型、向下转型）
编译类型看&#x3D;左边，运行类型看&#x3D;右边。

多态的注意事项
多态的前提：两个对象（类）存在继承关系。
多态的向上转型：

多态的向下转型本质将向上转型后的父类重新指回子类。

语法子类类型 引用名 = （子类类型）父类类型;
特点
只能强转父类的引用，不能强转父类的对象。即对象是子类的，但是被父类引用了。
要求父类的引用必须指向的是当前目标类型的对象。
向下转型后，可以调用子类类型中所有的成员。

属性没有重写之说需要注意，如果出现一个父类的引用指向了子类出现了向上转型的情况，当通过父类调用子类方法的时候，是可以正常调用的；但如果通过父类调用属性，则调用的会是父类自身的属性。如下代码可见：

简单的说就是，属性没有重写之说，属性的值看编译类型。

对于向上转型后的引用来说，只有方法是转型成功的，属性只能看引用的类。如果非要访问可以通过向下转型进行访问。

package net.hurr.test;public class Test &#123;    public static void main(String[] args) &#123;//属性没有重写之说！属性的值看编译类型        Base base = new Sub();//向上转型        System.out.println(base.count);// ？ 看编译类型 10        base.f();        Sub sub = new Sub();        System.out.println(sub.count);//? 20        sub.f();    &#125;&#125;class Base &#123; //父类    int count = 10;//属性    public void f()    &#123;        System.out.println(&quot;Base&quot;);    &#125;&#125;class Sub extends Base &#123;//子类    int count = 20;//属性    public void f()    &#123;        System.out.println(&quot;Sub&quot;);    &#125;&#125;
如果确实需要在向上转型的同时访问子类的属性，可以手动的向下转型一下，如下代码：
package net.hurr.test;public class Test &#123;    public static void main(String[] args) &#123;//属性没有重写之说！属性的值看编译类型        Base base = new Sub();//向上转型        System.out.println(base.count);// ？ 看编译类型 10        base.f();        Sub sub = new Sub();        System.out.println(sub.count);//? 20        sub.f();        System.out.println(&quot;=================================&quot;);        System.out.println(((Sub)base).count);// 20        System.out.println(sub.count);//? 20    &#125;&#125;class Base &#123; //父类    int count = 10;//属性    public void f()    &#123;        System.out.println(&quot;Base&quot;);    &#125;&#125;class Sub extends Base &#123;//子类    int count = 20;//属性    public void f()    &#123;        System.out.println(&quot;Sub&quot;);    &#125;&#125;
Java的动态绑定机制
当调用对象方法的时候，该方法会和该对象的内存地址&#x2F;运行类型绑定。
当调用对象属性的时候，没有动态绑定机制，哪里声明，就在那里使用。

多态的应用多态数组将数组的定义类型定义为父类，里面保存的实际元素类型为子类对象。（利用向上转型的规则）

多态参数在某个方法中，传入的参数可以是父类的形参，在方法中通过instanceof进行类型判断，如果属于类型A，就执行类型A对应的语句，否则就执行另一种预设的语句。

常用于面对不同身份进行不同的操作。不需要对方法进行重载就能完成。

Object类详解（equals方法）equals与&#x3D;&#x3D;的区别：&#x3D;&#x3D;：

&#x3D;&#x3D;既可以判断基本类型，也可以贩毒案引用类型。
如果判断的是基本类型，判断的是值是否相等。
如果判断的是引用类型如String，则判断是否是同一个对象。（引用类型的本质是指针，&#x3D;&#x3D;只能简单的判断两个值是否相等

equals：

equals是Object类中的方法，只能判断引用类型。
默认判断的是地址是否相同，但在子类中常常重写这个方法。如在String中就重写了，可以判断字符串的值是否相等。

面向对象 中级部分类变量和类方法类变量类变量介绍如果一个类创建的所有对象都需要一个变量（如进行计数），就可以将这个变量设置在类内，并设置成静态变量。

类变量也叫静态变量/静态属性，是该类的所有对象共享的变量,任何一个该类的对象去访问它时,取到的都是相同的值，同样任何一个该类的对象去修改它时修改的也是同一个变量。而且，在类没有实例化成对象的情况下，也可以使用

类变量的定义（基本语法）访问修饰符 static 数据类型 变量名;class A&#123;  public static int n = 10;//这个就是类变量，他的关键字是static。&#125;public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(A.n);//虽然没有实例化，但还是一样可以访问。并且在访问的一瞬间，就会完成类的加载（只会加载一次）    &#125;&#125;
类变量的访问类名.类变量名
类变量使用时的注意事项和细节
什么时候需要用类变量：当我们需要让某个类的所有对象都共享一个变量时， 就可以考虑使用类变量(静态变量):比如:定义学生类，统计所有学生共交多少钱。
类变量与实例变量(普通属性)区别：类变量是该类的所有对象共享的，而实例变量是每个对象独享的。
加上static称为类变量或静态变量，否则称为实例变量&#x2F;普通变量&#x2F;非静态变量 。
类变量可以通过类名.类变量名或者对象名.类变量名来访问，但java设计者推荐我们使用类名.类变量名方式访问。[前提是 满足访问修饰符的访问权限和范围]。
实例变量不能通过类名类变量名方式访问。
类变量是在类加载时就初始化了,也就是说，即使你没有创建对象，只要类加载了，就可以使用类变量了。（在使用的一瞬间就会加载）
类变量的生命周期是随类的加载开始，随着类消亡而销毁。

类变量的内存布局```*在JDK7以前，类变量存储在方法区；在JDK8以后，则就存储在了堆中*### 类方法#### 基本介绍
类方法也叫静态方法，具体细节和上方的类变量类似
#### 基本语法```java访问修饰符 static 数据返回类型 方法名()&#123;  //语句体&#125;class A&#123;  public static void f()&#123;//静态方法    System.out.println(&quot;类A中的静态方法f()已被调用&quot;);  &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;      A.f();//调用了    &#125;&#125;
类方法的经典使用场景当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法提高开发效率。

类方法使用注意事项和细节
类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区:
类方法中无this的参数普通方法中隐含着this的参数

类方法可以通过类名调用，也可以通过对象名调用。

普通方法和对象有关，需要通过对象名调用，比如对象名.方法名(参数)，不能通过类名调用。

类方法中不允许使用和对象有关的关键字，比如this和super。 普通方法(成员方法)可以。

类方法(静态方法)中只能访问静态变量或静态方法.

普通成员方法，既可以访问非静态成员，也可以访问静态成员。


小结:静态方法， 只能访问静态的成员,非静态的方法，可以访问静态成员和非静态成员(必须遵守访问权限)
main方法语法main方法的形式: public static void main(String[] args)&#123;&#125;


main方法时虚拟机调用
java虚拟机需要调用类的main() 方法，所以该方法的访问权限必须是public
java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static
该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数
java 执行的程序参数1参数2参数3 [举例说明:]

java 运行的类名 第一个参数 第二个参数 第三个参数 ...

对应到args数组中：第一个元素，第二个元素，第三个元素...

注意事项
在 main()方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性。
但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。比如：

package net.hurr.test;public class MAIN &#123;    //静态的变量/属性    private static String name = &quot;Hello&quot;;    //非静态的变量/属性    private int n1 = 10000;    //静态方法    public static void hi() &#123;        System.out.println(&quot;MAIN 的 hi 方法&quot;);    &#125;    //非静态方法    public void cry() &#123;        System.out.println(&quot;MAIN 的 cry 方法&quot;);    &#125;    public static void main(String[] args) &#123;//可以直接使用 name//1. 静态方法 main 可以访问本类的静态成员        System.out.println(&quot;name=&quot; + name);        hi();//2. 静态方法 main 不可以访问本类的非静态成员//System.out.println(&quot;n1=&quot; + n1);//错误//cry();//3. 静态方法 main 要访问本类的非静态成员，需要先创建对象 , 再调用即可        MAIN MAIN = new MAIN();        System.out.println(MAIN.n1);//ok        MAIN.cry();    &#125;&#125;/*运行结果：name=HelloMAIN 的 hi 方法10000MAIN 的 cry 方法*/
代码块基本介绍代码化块又称为初始化块属于类中的成员[即是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过&#123;&#125;包围起来。

但和方法不同，没有方法名，没有返回，没有叁数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。

基本语法[修饰符]&#123;  //语句组；&#125;[;]
注意事项
修饰符可选，且只能是static
代码块可分为两大类，一是加上修饰符的静态代码块，二是没加修饰符的普通代码块&#x2F;非静态代码块
逻辑语句可以为任何逻辑语句，包括但不限于输入、输出、方法调用、循环、判断等
结尾的分号可以缺省

代码块的作用、注意事项、细节
相当于另一种形式的构造器（对原有构造器的补充），可以进行初始化操作

使用的场景：如果多个构造器中都有重复的语句，就可以将这些重复的语句抽取到块中，提高代码的复用性。

static代码块也叫静态代码块，作用是对类进行初始化。它随着类的加载而执行，并且只会执行一次。如果是普通代码块，则在创建（实例化）出一个对象的时候，就执行一次。

类什么时候会被加载：

创建对象实例的时候（new）
创建子类对象实例时，父类也会被加载
使用类的静态成员时


普通的代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次。如果只是使用类的静态成员时，普通代码块并不会执行。

创建一个对象时，在一个类的调用顺序是：

调用静态代码块和静态属性初始化（注意，静态代码块和静态属性初始化调用的优先级相等，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）。
调用普通代码块和普通属性的初始化（注意普通代码块和普通属性初始化调用的优先级相等，如果有多个普通代码块和多个普通变量初始化，则按他们定义的顺序调用）。
最后调用构造方法。（构造方法的优先级最低）


构造器的最前面隐藏了super()和调用普通代码块的语句。（先super后普通）。

创建一个子类对象时（继承关系），他们的静态代码块、静态属性初始化、普通代码块、普通属性初始化、构造方法的调用顺序如下：

父类的静态代码块和静态属性（按定义的顺序执行）；

子类的静态代码块和静态属性（按定义的顺序执行）；

父类的普通代码块和普通属性初始化；

父类的构造方法；

子类的普通代码块和普通属性初始化；

子类的构造方法；

个人理解：
将子类实例化的过程：
首先调用了子类的构造方法，因为构造方法第一条语句是super，因此会去调用父类的构造方法，父类的构造方法里也有一个super，有去寻找直接父类的父类直到Object为止。到达Object后，运行Object的静态代码块（因为加载类了），然后加载下一级的静态代码，一直到被实例化的子类为止。将子类加载完后，然后依次将各个类都进行实例化，此时首先运行Object类的普通代码块和构造方法（因为创建对象了），然后按照普通代码块和属性、构造方法的顺序，直到子类完成。（算是递归的思想？好像不太对，因为调用的不是自身）





小结:

static代码块是类加载时执行，只会执行一次。（因为类只会执行一次）
普通代码块是在创建对象时调用的，创建一次，调用一次。（每个对象各调用一次）
类加载的3种情况， 需要记住。（上面第四条）

样例样例1：无继承，两次调用类的静态属性，再实例化对象public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;···············&quot;);        System.out.println(&quot;第一次调用静态属性&quot;);        System.out.println(A.n1);        System.out.println(&quot;···············&quot;);        System.out.println(&quot;第二次调用静态属性&quot;);        System.out.println(A.n1);        System.out.println(&quot;···············&quot;);        System.out.println(&quot;第一次实例化对象&quot;);        A a = new A();    &#125;&#125;class A&#123;    public static int n1 = 100;//静态属性    public int n2 = 200;//普通属性    &#123;        System.out.println(&quot;普通代码块被执行&quot;);//普通代码块    &#125;    static&#123;        System.out.println(&quot;静态代码块被执行&quot;);//静态代码块    &#125;&#125;

运行结果如下：
···············第一次调用静态属性静态代码块被执行100···············第二次调用静态属性100···············第一次实例化对象普通代码块被执行

样例2 有继承，连续调用两次子类的静态属性，调用一次继承得到的父类的属性，然后将子类实例化成对象public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;···············&quot;);        System.out.println(&quot;第一次调用子类的静态属性&quot;);        System.out.println(B.n3);        System.out.println(&quot;···············&quot;);        System.out.println(&quot;第二次调用子类静态属性&quot;);        System.out.println(B.n3);        System.out.println(&quot;···············&quot;);        System.out.println(&quot;第一次调用父类静态属性&quot;);        System.out.println(B.n1);        System.out.println(&quot;···············&quot;);        System.out.println(&quot;第一次实例化对象&quot;);        B b = new B();    &#125;&#125;class A&#123;    public A()&#123;        System.out.println(&quot;类A的构造方法被调用&quot;);    &#125;    public static int n1 = 100;//静态属性    public int n2 = 200;//普通属性    &#123;        System.out.println(&quot;类A:普通代码块被执行&quot;);//普通代码块    &#125;    static&#123;        System.out.println(&quot;类A:静态代码块被执行&quot;);//静态代码块    &#125;&#125;class B extends A&#123;    public static int n3 = 300;    &#123;        System.out.println(&quot;类B:普通代码块被执行&quot;);//普通代码块    &#125;    static&#123;        System.out.println(&quot;类B:静态代码块被执行&quot;);//静态代码块    &#125;    public B ()&#123;        System.out.println(&quot;类B的构造方法被调用&quot;);    &#125;&#125;

运行结果：
···············第一次调用子类的静态属性类A:静态代码块被执行类B:静态代码块被执行300···············第二次调用子类静态属性300···············第一次调用父类静态属性100···············第一次实例化对象类A:普通代码块被执行类A的构造方法被调用类B:普通代码块被执行类B的构造方法被调用

样例3 三次继承继承，直接对子类进行实例化操作package net.hurr.test;public class Test &#123;    public static void main(String[] args) &#123;        C c = new C();    &#125;&#125;class A&#123;    public A()&#123;        System.out.println(&quot;类A的构造方法被调用&quot;);    &#125;    public static int n1 = 100;//静态属性    public int n2 = 200;//普通属性    &#123;        System.out.println(&quot;类A:普通代码块被执行&quot;);//普通代码块    &#125;    static&#123;        System.out.println(&quot;类A:静态代码块被执行&quot;);//静态代码块    &#125;&#125;class B extends A&#123;    public static int n3 = 300;    &#123;        System.out.println(&quot;类B:普通代码块被执行&quot;);//普通代码块    &#125;    static&#123;        System.out.println(&quot;类B:静态代码块被执行&quot;);//静态代码块    &#125;    public B ()&#123;        System.out.println(&quot;类B的构造方法被调用&quot;);    &#125;&#125;class C extends B&#123;    public static int n4 = 400;    &#123;        System.out.println(&quot;类C:普通代码块被执行&quot;);//普通代码块    &#125;    static&#123;        System.out.println(&quot;类C:静态代码块被执行&quot;);//静态代码块    &#125;    public C ()&#123;        System.out.println(&quot;类C的构造方法被调用&quot;);    &#125;&#125;

运行结果：
类A:静态代码块被执行类B:静态代码块被执行类C:静态代码块被执行类A:普通代码块被执行类A的构造方法被调用类B:普通代码块被执行类B的构造方法被调用类C:普通代码块被执行类C的构造方法被调用

单例设计模式什么是设计模式
静态方法和属性的使用。
设计模式是在大量的事件中总结和理论化之后优选的代码结构、编程风格以及解决问题的思考方式。设计模式类似于数学的公式，免得我们自己再思考和摸索。

单例模式单例，就是指单个实例。所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对于某个类只能存在一个对象实例，并且该类只提供一个获取其对象实例的方法。

单例模式有两种实现方式，一是饿汉式，二是懒汉式。具体特点在后面。

大致的实现步骤如下：

        1. 构造器私有化，防止直接new。
        2. 在类的内部创建一个对象
        3. 向外暴露一个静态的方法，以获取其创建的对象

饿汉式package net.hurr.test;public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;获取类A的对象&quot;);        //A a = new A();//不再能通过new的方式进行新建        A a = A.getA();//只能通过暴露的接口获取到对象。在获取的一瞬间对象就会被创建出来。        System.out.println(a);        A b = A.getA();        System.out.println(a == b);//不管怎么获取，获取到的都是同一个对象。    &#125;&#125;class A &#123;    private String name;    private String ID;    private static A a = new A();//饿汉式的特点：直接创建对象，不管是否有需求。为了能在静态方法中返回，需要设置成静态    private A() &#123;//私有化构造函数防止被new，除此之外和普通的构造函数一样。        System.out.println(&quot;类A的构造器被调用&quot;);        name = &quot;nono&quot;;        ID = &quot;00001&quot;;    &#125;    public static A getA() &#123;        return a;    &#125;    @Override    public String toString() &#123;        return &quot;name:&quot; + name + &quot;  ID:&quot; + ID;    &#125;&#125;

运行结果：
获取类A的对象类A的构造器被调用name:nono  ID:00001true

懒汉式package net.hurr.test;public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;获取类A的对象&quot;);        //A a = new A();//不再能通过new的方式进行新建        A a = A.getInstanceA();//只能通过暴露的接口获取到对象。在获取的一瞬间对象才会被创建出来。        System.out.println(a);        A b = A.getInstanceA();        System.out.println(a == b);//同样，不管怎么获取，获取到的都是同一个对象。    &#125;&#125;class A &#123;    private String name;    private String ID;    private static A a;//懒汉式特点：类加载的时候不会自动创建对象，只有在调用的时候才会创建    private A() &#123;//构造函数仍然是私有化的，防止被new，除此之外和普通的构造函数一样。        System.out.println(&quot;类A的构造器被调用&quot;);        name = &quot;nono&quot;;        ID = &quot;00001&quot;;    &#125;    public static A getInstanceA() &#123;//只有调用这个方法的时候，对象才会被创建出来，节省空间，但有可能会造成线程异常。比如在多线程访问时，多个线程都进来了但对象还没创建好，这时就会造成重复创建的问题。只会保留最后一个创建的对象        if(a == null) &#123;//如果还没有创建对象，就创建            a = new A();        &#125;        return a;    &#125;    @Override    public String toString() &#123;        return &quot;name:&quot; + name + &quot;  ID:&quot; + ID;    &#125;&#125;

运行结果：
获取类A的对象类A的构造器被调用name:nono  ID:00001true

饿汉式和懒汉式的区别
二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建。
饿汉式不存在线程安全问题，懒汉式存在线程安全问题。
饿汉式存在浪费资源的可能。因为如果一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。
在我们javaSE标准类中，java.lang.Runtime就是经典的单例模式。

final关键字基本介绍final中文意思:最后的，最终的。

final可以修饰类、属性、方法和局部变量。

在某些情况下，可能有以下需求，就会使用到final：

    1. 当不希望类被继承时，可以用final修饰；
    2. 当不希望父类的某个方法被子类覆盖/重写(override)时，可以用final关键字修饰；
    3. 当不希望类的的某个属性的值被修改，可以用final修饰；
    4. 当不希望某个局部变量被修改，可以使用final修饰；


简单的说，只要经过final修饰，只要本质还是原来的，就不允许修改。

使用方法(样例)：样例1 要求某一个类不能被其他类继承//如果要求下面的类A不能被其他类所继承，可以在前面加上final修饰final class A&#123;    public int a = 100;&#125;/*//此时就会报错class B extends A&#123; &#125;*/
样例2 要求类中的某个方法不能被子类修改（重写&#x2F;覆盖）class A&#123;    public int a = 100;    //如果希望某个类中的某个方法不被改写或覆盖，同样也可以用final修饰一下    public final void fun()&#123;        System.out.println(&quot;这是类A独有的方法，不允许被重写&quot;);    &#125;   &#125;class B extends A&#123;    /*    此时如果想要重写父类中的被final修饰了的方法是不可以的    public final void fun()&#123;        System.out.println(&quot;对类A的方法进行重写&quot;);    &#125;*/&#125;
样例3 要求类中的某个属性不能被修改（即设置成常量）class A &#123;    //如果希望某个类中的某个属性不被改写或覆盖，同样也可以用final修饰一下    //被final修饰的属性必须赋初值。赋初值的地方可以有三种。一是在定义时如a1，二是利用构造方法，三是利用代码块。    //需要注意的是，初始化的地方只能在三个里面选一个。    public final int a1 = 100;    public final int a2;    public final int a3;    &#123;        a3 = 300;    &#125;    /*    public void fun()&#123;//如果试图修改这个属性，就会报错。        a=1;    &#125;*/    public A()&#123;        a2 = 200;    &#125;&#125;class B extends A &#123;    int a = 200;//但子类可以对这个继承下来的属性进行重写    /*    public void fun() &#123;//如果不重写就试图修改这个属性，就会报错。        super.a = 1;    &#125;*/&#125;
样例4  要求类中的某个属性不能被修改，且这个属性是静态的class A &#123;    static final public int n1 = 100;//可以直接赋初值    static final public int n2 ;    //static final public int n3 ;//但不可以在普通代码块或者构造方法中初始化。因为这个两个的根本是对象，而静态是属于类的。    static &#123;        n2 = 200;//也可以在静态代码块中赋初值    &#125;    /*    &#123;        n3 = 300;    &#125;      public A()&#123;        n3 = 300;    &#125;*/&#125;
final使用注意事项和细节
final修饰的属性又叫常量，一般用XX_XX_XX来命名；&#x2F;&#x2F;即全大写，类似于c中define的标准

**final修饰的属性在定义时必须赋初值，并且以后不能再修改，赋值可以在如下位置之一 [选择一个位置赋初值即可，只能选择一个] **;①定义时:如public final double TAX RATE&#x3D;0.08②在构造器中③在代码块中。

如果final修饰的属性是静态的，则初始化的位置只能是①定义时②在静态代码块不能在构造器中赋值。

final类不能继承，但是可以实例化对象。

如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。

一般来说，如果一个类已经是final类了，就没必要再将方法修饰成final方法。（修饰成final方法的目的在于防止子类的重写，但final类就已经不允许有子类，不可能会在子类中对方法进行重写）

final不能修饰构造方法（构造器）。（因为子类不会继承父类的构造器）

final和static往往都会搭配使用，效率更高，不会导致类加载。因为底层的编译器对此做了优化。
我们知道，在类加载的时候会同时加载静态代码块，可以利用静态代码块来检查类是否被加载了。
比如以下代码，会在调用类A的静态属性之前，先将类进行加载，因为在输出100之前，会先输出 类A被加载了 ;
public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(A.n1);    &#125;&#125;class A &#123;    public static int n1 = 100;    static &#123;        System.out.println(&quot;类A被加载了&quot;);    &#125;&#125;
如果改成下方的样子,在属性前面加上一个final，类A就就不会被加载，会直接输出100；
public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(A.n1);    &#125;&#125;class A &#123;    public final static int n1 = 100;    static &#123;//此时调用n1的值的时候，类就不会加载了。        System.out.println(&quot;类A被加载了&quot;);    &#125;&#125;
各种包装类如Integer,Double,Float,Boolean,String等都是final类。


抽象类当父类的某些方法需要声明但又不确定如何实现时，就可以将其声明为抽象方法，那么这个类就是抽象类。

当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰的类就是抽象类。

抽象类的介绍
用abstract关键字类修饰一个类时，这个类就叫做抽象类。一旦类是抽象类，那么这个类就不能实例化，因为对编译器来说这个类并没有完成全部的功能。
访问修饰符 abstract 类名&#123;&#125;
用abstract关键字来修饰一个方法时，这个方法就是抽象方法。需要注意的是，抽象方法只有声明，没有方法体。如果需要定义抽象方法，则该对象所处的类一定要是抽象类。
访问修饰符 abstract 类名&#123;  访问修饰符 abstract 返回类型 方法名(参数列表);&#125;
抽象类的价值更多作用时在于设计，是设计者设计好后，让子类继承并实现抽象类。

抽象类在框架和设计模式中使用的比较多。


抽象类的使用样例样例1 abstract类，但没有抽象方法public class Test &#123;    public static void main(String[] args) &#123;        //A a = new A();//虽然其中没有任何成员，但依然不能实例化成对象。报错信息：&#x27;A&#x27; 为 abstract；无法实例化。    &#125;&#125;abstract class A &#123;//如果仅是抽象类没有抽象方法，可以不需要继承实现&#125;
样例2 abstract方法public class Test &#123;    public static void main(String[] args) &#123;        //A a = new A();//抽象类不能实例化成对象报错信息：&#x27;A&#x27; 为 abstract；无法实例化。        B b = new B();        System.out.println(b.sum(1, 2, 3));    &#125;&#125;abstract class A &#123;    public abstract int sum(int... num);//如果类中含有抽象方法，则类必须也是抽象类（加上abstract修饰符）&#125;class B extends A &#123;    public int sum(int... num) &#123;//抽象类中必须要有一个子类实现父类的抽象方法，不然会报错。如果没有抽象方法，可以不用继承        int sum = 0;        for (int i = 0; i &lt; num.length; i++) &#123;            sum += num[i];        &#125;        return sum;    &#125;&#125;
抽象类使用的注意事项和细节
抽象类不能被实例化。
抽象类不一定包含抽象方法。
一旦类包含了abstract方法则这个类必须声明为abstract。
abstract只能修饰类和方法，不能修饰属性和其它的。
抽象类可以有任意成员[抽象类本质还是类] ,比如:非抽象方法、构造器、静态属性等等。
抽象方法不能有主体，即不能实现。
如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类。


抽象方法不能使用private、 final和static来修饰， 因为这些关键字都是和重写相违背的。

抽象类最佳实践-模板设计模式基本介绍抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。

模板设计模式能解决的问题
当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。
编写一个抽象父类， 父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，就是一种模板模式。

案例：求 求和 过程中的时间，可以是求1+2+n的值，也可以是求1x2xn的值package net.hurr.test;public class Test &#123;    public static void main(String[] args) &#123;        A a = new A();        a.fun(1000000000);        System.out.println(&quot;.................................&quot;);        B b = new B();        b.fun(1000000000);    &#125;&#125;abstract class Template &#123;    public void fun(long n) &#123;        long strat = System.currentTimeMillis();//获取现在的时间，（精确到毫秒）        job(n);//大体的公式放在这，具体的实现细节由子类完成        long end = System.currentTimeMillis();//获取现在的时间，（精确到毫秒）        System.out.println(&quot;消耗的时间为 &quot; + (end - strat));    &#125;    public abstract void job(long n);//中间需要进行一些运算，但目前还不知道运算的过程，所以设置成抽象类，由子类进行计算&#125;class A extends Template &#123;    public void job(long n) &#123;//子类完成具体的实现过程        long sum = 0;        for (long i = 1; i &lt;= n; i++) &#123;            sum += i;        &#125;    &#125;&#125;class B extends Template &#123;    public void job(long n) &#123;//而且可以个性化        long sum = 1;        for (long i = 1; i &lt;= n; i++) &#123;            sum *= i;        &#125;    &#125;&#125;

运行结果：
消耗的时间为 316……………………………消耗的时间为 719

接口基本介绍接口就是给出一些没有实现的方法,封装到一 起，到某个类要使用的时候，在根据具体情况把这些方法写出来。

语法//定义接口 访问修饰符 interface 接口名 &#123;   //接口内的方法，修饰符默认带有public 和 abstract （对于方法）。不可以是别的   void start();   void stop();&#125;//将接口应用到某个类某个类class 类名 implements 接口 [,接口2 ,接口3...]&#123;	自己属性:	自己方法;  //类似于继承了抽象类，必须实现接口中定义的所有方法&#125;//某个类通过接口调用其他的类class 类名 &#123;    public void work(UsbInterface usbInterface)&#123;//方法名正常，就是形参变成了定义的接口。编译器会自动调用类的对应实现的方法。如下方样例所示。类似于抽象类和向上转型的集合？系统会自动调用，不需要自己声明了        usbInterface.start();//        usbInterface.stop();    &#125;&#125;
样例1 接口入门package net.hurr.Interface_;public class Test &#123;    public static void main(String[] args) &#123;        Computer computer = new Computer();        Phone phone = new Phone();        Camera camera = new Camera();        computer.work(phone);        computer.work(camera);    &#125;&#125;interface UsbInterface &#123;//定义了一个接口，使用该接口的类必须实现其中定义的方法    void start();//默认自带了abstractb和public关键字，所以自己加不加都行。    void stop();&#125;class Phone implements UsbInterface &#123;//被接口规范了的类    @Override    public void start() &#123;//按照接口中定义的声明，实现具体的方法        System.out.println(&quot;手机开始工作&quot;);    &#125;    @Override    public void stop() &#123;        System.out.println(&quot;手机停止工作&quot;);    &#125;&#125;class Camera implements UsbInterface &#123;    @Override    public void start() &#123;        System.out.println(&quot;相机开始工作&quot;);    &#125;    @Override    public void stop() &#123;        System.out.println(&quot;相机停止工作&quot;);    &#125;&#125;class Computer &#123;    public void work(UsbInterface usbInterface) &#123;//调用被 UsbInterface 接口所规范的类        usbInterface.start();        usbInterface.stop();    &#125;&#125;

运行结果
手机开始工作手机停止工作相机开始工作相机停止工作

样例2 一个方法实现多个接口（被多个接口所约束）package net.hurr.Interface_;public class Test &#123;    public static void main(String[] args) &#123;        A a = new A();        InterfacrTest1 interfacrTest1 = new InterfacrTest1();//用于接口测试的类1        InterfacrTest2 interfacrTest2 = new InterfacrTest2();//用于接口测试的类2        interfacrTest1.work1(a);        System.out.println(&quot;...........&quot;);        interfacrTest2.work2(a);    &#125;&#125;interface MyInterface1 &#123;//定义了一个接口，使用该接口的类必须实现其中定义的方法    void fun();//默认自带了abstractb和public关键字，所以自己加不加都行。    void t();&#125;interface MyInterface2 &#123;    void fun();    void fun(String s);&#125;class A implements MyInterface1, MyInterface2 &#123;    public void fun() &#123;        System.out.println(&quot;重名的fun被执行&quot;);    &#125;    public void fun(String s) &#123;        System.out.println(&quot;参数名不同的fun被执行，内容是：&quot; + s);    &#125;    public void t()&#123;        System.out.println(&quot;未重名的t被执行&quot;);    &#125;&#125;class InterfacrTest1 &#123;    public void work1(MyInterface1 myInterface1) &#123;        myInterface1.fun();        myInterface1.t();    &#125;&#125;class InterfacrTest2 &#123;    public void work2(MyInterface2 myInterface2) &#123;        myInterface2.fun();        myInterface2.fun(&quot;参数不同的fun在测试&quot;);        //myInterface2.t();//虽然一个类能被多个接口所规范，但每个接口只能调用该接口自己声明的内容    &#125;&#125;

运行结果
重名的fun被执行未重名的t被执行………..重名的fun被执行参数名不同的fun被执行，内容是：参数不同的fun在测试

样例3 接口的继承package net.hurr.Interface_;public class Test &#123;    public static void main(String[] args) &#123;        A a = new A();        InterfacrTest1 interfacrTest1 = new InterfacrTest1();//用于接口测试的类1        InterfacrTest2 interfacrTest2 = new InterfacrTest2();//用于接口测试的类2        interfacrTest1.work1(a);        System.out.println(&quot;...................&quot;);        interfacrTest2.work2(a);    &#125;&#125;interface MyInterface1 &#123;//定义了一个接口，使用该接口的类必须实现其中定义的方法    void t();&#125;interface MyInterface2 extends MyInterface1&#123;    void fun();&#125;class A implements MyInterface2 &#123;    public void fun() &#123;        System.out.println(&quot;fun被执行&quot;);    &#125;    public void t()&#123;        System.out.println(&quot;t被执行&quot;);    &#125;&#125;class InterfacrTest1 &#123;    public void work1(MyInterface1 myInterface1) &#123;        //myInterface1.fun();//因为在接口1中，并没有这个方法        myInterface1.t();    &#125;&#125;class InterfacrTest2 &#123;    public void work2(MyInterface2 myInterface2) &#123;        myInterface2.fun();        myInterface2.t();//接口的子类一样可以调用父类的方法    &#125;&#125;

运行结果：
t被执行……………….fun被执行t被执行

样例4 带属性和方法体的接口package net.hurr.Interface_;public class Test &#123;    public static void main(String[] args) &#123;        A a = new A();        InterfaceTest interfaceTest = new InterfaceTest();//实例化用户测试的函数        System.out.println(&quot;通过接口调用的..............................&quot;);        interfaceTest.work1(a);        System.out.println(&quot;通过对象调用的..............................&quot;);        interfaceTest.work2(a);    &#125;&#125;interface MyInterface1 &#123;//定义了一个接口，使用该接口的类必须实现其中定义的方法    void t();    default void fun() &#123;//可以理解为switch里面的default？可以被重写，如果没被重写就实现这个方法        System.out.println(&quot;接口中可以带有语句&quot;);    &#125;    //也可以带有属性。属性好像自带了public static final关键字？    // 在idea中如果写上这个三个关键字会变成灰色，鼠标移上去会提示  修饰符 &#x27;final/static/public&#x27; 对于接口字段是冗余的    // 可以通过接口名直接调用,但不能修改    int n1 = 100;    //protected int n2 = 200;会报错 此处不允许使用修饰符 &#x27;protected&#x27;。&#125;class A implements MyInterface1&#123;    public void t()&#123;        System.out.println(&quot;接口中的t()的实现&quot;);    &#125;    public void test()&#123;//被接口规范的方法可以含有接口中没被声明的方法        System.out.println(MyInterface1.n1);        //MyInterface1.n1++;//不能修改，会提示  无法将值赋给 final 变量 &#x27;n1&#x27;    &#125;&#125;class InterfaceTest&#123;    void work1(MyInterface1 myInterface1)&#123;        myInterface1.t();//接口中声明的        myInterface1.fun();//接口中带有方法体的        //myInterface1.test();//接口中没有声明的类是不可以被接口调用的    &#125;    void work2(A a)&#123;        a.t();//接口中被声明的方法也可以通过对象名的方式进行调用        a.test();//单独的方法自然也是可以被调用的    &#125;&#125;

运行结果：
通过接口调用的…………………………接口中的t()的实现接口中可以带有语句通过对象调用的…………………………接口中的t()的实现100

package net.hurr.Interface_;public class Test &#123;    public static void main(String[] args) &#123;        Computer computer = new Computer();        Phone phone = new Phone();        Camera camera = new Camera();        A a = new A();        computer.work(phone);        computer.work(camera);              //new UsbInterface();//与抽象类类似，接口也不允许被实例化。&#x27;UsbInterface&#x27; 为 abstract；无法实例化        System.out.println(&quot;在main()中调用接口中的属性&quot; + UsbInterface.n);//通过接口名直接调用接口里面的属性        //UsbInterface.n = 200;接口里面的属性自带了static和final关键字        computer.test2(phone);        computer.test1(a);    &#125;&#125;interface UsbInterface &#123;//定义了一个接口，使用该接口的类必须实现其中定义的方法    void start();//默认自带了abstractb和public关键字，所以自己加不加都行。    void stop();    default void fun() &#123;//可以理解为switch里面的default？可以被重写，如果没被重写就实现这个方法        System.out.println(&quot;接口中带有语句&quot;);    &#125;    public int n = 100;//也可以带有属性。属性好像自带了static和final关键字？可以通过接口名直接调用&#125;interface T extends UsbInterface &#123;//同时接口好像还可以被继承？    void test();&#125;class Phone implements UsbInterface &#123;//被接口规范了的类    @Override    public void start() &#123;//按照接口中定义的声明，实现具体的方法        System.out.println(&quot;手机开始工作...&quot;);    &#125;    @Override    public void stop() &#123;        System.out.println(&quot;手机停止工作&quot;);    &#125;    @Override    public void fun() &#123;        System.out.println(&quot;Phone:接口中的类可以被重写&quot;);    &#125;&#125;class Camera implements UsbInterface &#123;    @Override    public void start() &#123;        System.out.println(&quot;相机开始工作&quot;);    &#125;    @Override    public void stop() &#123;        System.out.println(&quot;相机停止工作&quot;);    &#125;&#125;class Computer &#123;    public void work(UsbInterface usbInterface) &#123;        usbInterface.start();        usbInterface.stop();    &#125;    public void test1(T t) &#123;        t.test();    &#125;    /*    public void test2(T t) &#123;//同样也符合继承的规范：子类继承了所有的父类        t.fun();    &#125;*/    public void test2(UsbInterface usbInterface) &#123;//但运行被调用的类也必须得是由子类规范过的类，不兼容父类规范的类        usbInterface.fun();    &#125;&#125;class A implements T &#123;    @Override    public void start() &#123;    &#125;    @Override    public void stop() &#123;    &#125;    @Override    public void test() &#123;        System.out.println(&quot;类A:通过被继承的接口来规定一个类&quot;);    &#125;&#125;

运行结果：
手机开始工作…手机停止工作相机开始工作相机停止工作在main()中调用接口中的属性100Phone:重写接口中已有的类类A:通过被继承的接口来规定一个类

接口是更加抽象的抽象的类，抽象类里的方法可以有方法体，接口里的所有方法都没有方法体[jdk7.0] 。接口体现了程序设计的多态和高内聚低偶合的设计思想。

特别说明: Jdk8.0后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现。

与抽象类类似，接口也不允许被实例化。

注意事项和细节
接口不能被实例化。
接口中所有的方法都是 public 方法, 接口中抽象方法，可以不用 abstract 修饰。
一个普通类实现接口,就必须将该接口的所有方法都实现,可以使用 alt+enter 来解决。
抽象类去实现接口时，可以不实现接口的抽象方法。
一个类同时可以实现多个接口。
接口中的属性只能是final的，而且是public static final修饰符。比如:int a&#x3D;1;实际上是public static final int a&#x3D;1; (必须初始化)。
接口中属性的访问形式:接口名.属性名。
接口不能继承其它的类，但是可以继承多个别的接口。
接口的修饰符只能是public和默认，这点和类的修饰符是一样的。（默认的在接口中会被看作是public？）

接口与继承类的区别当子类继承了父类，就自动的拥有了父类的所有功能；如果子类需要扩展功能，可以通过 实现接口 的方式扩展。

可以把 实现接口 理解为对java单继承机制的一种补充。

继承的价值主要在于解决了代码的复用性和可维护性；		接口的价值注意在于设计，设计好各种规范（方法），让其他类去实现这些方法。

接口比继承更加灵活，继承满足是是某个（is a），而接口只需要满足像一个...(like a)的关系。

接口在一定的程度上实现了代码的解耦（接口规范性+动态绑定）

接口的多态性接口类型的变量 可以指向 实现了该接口的对象实例。（如在上方的样例1 中，类computer就可以接收实现了UsbInterface usbInterface接口的类，并通过该接口调用在接口中声明的所有方法与属性）。

利用接口的多态可以实现一个接口的数组。比如：

package net.hurr.Interface_;public class Test &#123;    public static void main(String[] args) &#123;        I[] i = new I[2];//定义了一个接口数组i        i[0] = new A();//数组的第一个位置指向了一个A类的对象        i[1] = new B();//数组的第一个位置指向了一个B类的对象        i[0].f();//并且可以通过接口调用在接口中声明了的方法或属性        //i[1].t();//但不能调用类中私有的属性        ((A)i[0]).t();//如果要调用类中私有的方法或属性，也可以使用向下转型的套路。不过需要多一重括号？    &#125;&#125;interface I &#123;    void f();&#125;class A implements I &#123;    public void f() &#123;    &#125;    public void t() &#123;    &#125;&#125;//定义了一个类A，并实现了接口I的方法class B implements I &#123;    public void f() &#123;    &#125;&#125;//定义了一个类B，并实现了接口I的方法
同时接口的多态还具有传递性，可以相互继承。如语法样例1中的接口的继承。

接口多态中的二义性因为一个类可以同时进行继承和实现接口的功能，因此就会出现“二义性”

interface I &#123;    int x = 1;//等价于public static final int x = 1;&#125;class T&#123;    int x = 2;//普通属性&#125;class A extends T implements I &#123;   void f()&#123;       //System.out.println(x);//此时就会报错，因为编译器不知道是要哪个里面的x。报错信息：对 &#x27;x&#x27; 的引用不明确，&#x27;T.x&#x27; 和 &#x27;I.x&#x27; 均匹配       System.out.println(I.x);//因为接口里面的属性是静态的，所以可以通过接口名.属性名进行访问       System.out.println(super.x);//或者使用super关键字指定访问父类的x   &#125;&#125;
内部类基本介绍一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class)，嵌套其他类的类称为外部类(outer class)。

内部类是我们类的第五大成员[属性、方法、构造器、代码块、内部类]，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。

类的组成：

class Outer &#123;//外部类    //属性    private int n1 = 100;    //方法    public void m1() &#123;        System.out.println(&quot;m1()&quot;);    &#125;    //构造器    public Outer(int n1) &#123;        this.n1 = n1;    &#125;    public Outer() &#123;    &#125;    //代码块    &#123;        System.out.println(&quot;代码块&quot;);    &#125;    //内部类    class Inner &#123;    &#125;&#125;
内部类的分类定义在外部类的局部位置上（比如方法内）：局部内部类（有类名）、
匿名内部类（无类名）；
定义在外部类的成员位置上：成员内部类（非static）、静态内部类（static）；

局部内部类局部内部类是定义在外部类的局部位置，比如方法中或块中，并且有类名。

演示代码package net.hurr.innerclass_;public class InnerClass01 &#123;    public static void main(String[] args) &#123;        Outer outer = new Outer(100);        outer.m1();    &#125;&#125;class Outer &#123;    //属性    private int n1 = 100;    private int n3 = 300;    private void m2()&#123;&#125;    //方法    public void m1() &#123;        //局部内部类是定义在外部类的局部位置， 比如方法中，并且有类名。        class Inter&#123;//局部内部类，本质还是一个类，里面也可以有五大类            private int n2 = 200;            private int n1 = 1;            public void f1()&#123;                System.out.println(&quot;Outer:n3 = &quot;+n3);//可以直接访问外部类的所有成员， 包含私有的。                m2();//同样也可以访问到外部的方法            &#125;            public void f2()&#123;                System.out.println(&quot;Inter:n1 = &quot;+n1);//当重名发生时，遵守就近原则。              //外部类.this的含义：因为外部类不一定是静态的，因此直接可能不能访问到，加上this表示找的时这个类的对象。                System.out.println(&quot;Inter:Outer:n1 = &quot;+Outer.this.n1);//如果需要访问外部类的成员,可以同外部类名.this.成员名 的方式进行访问            &#125;        &#125;        //public class InnerTest&#123;&#125;//作为方法的一个成员，是不可以有访问权限的管理。但可以用final进行只读保护，就像其他方法成员一样        class InnerTest extends Inter&#123;&#125;//内部类也是可以被继承的（如果能访问到）        Inter inter = new Inter();//在作用域内内部类也可以实例化成对象        System.out.println(&quot;Inter n2:&quot;+inter.n2);//并通过对象访问其中的属性        inter.f1();//内部类的方法也可以通过对象调用        inter.f2();    &#125;    //构造器    public Outer(int n1) &#123;        this.n1 = n1;    &#125;&#125;

运行结果：
Inter n2:200Outer:n3 &#x3D; 300Inter:n1 &#x3D; 1Inter:Outer:n1 &#x3D; 100

匿名内部类匿名内部类时定义在外部类的局部位置，比如方法中或代码块中，且没有类名.

匿名内部类的本质还是类，而且是一个内部的类，他没有名字（有名字但不是开发者命名，是由系统自动生成）

基本语法new 类或接口(参数列表)&#123;  类体;&#125;
基于接口的匿名类 演示需求：使用接口来定义一个类，并用这个类创建一个对象

传统的方法是将新建一个类，但由于只需要使用一次，后面不会再用到，因此可以使用匿名内部类来简化以下编写的流程。

比如这样：

I tiger = new I()&#123;            @Override            public void cry() &#123;                System.out.println(&quot;老虎在叫....&quot;);            &#125;        &#125;;
在上方的片段中，tiger的编译类型是I，运行类型是匿名类。匿名类的命名规范为外部类名$编号
这个匿名的内部类一旦实例化成tiger后，就会直接抛弃，而对象名tiger，可以在生存期内无限次被使用。
具体实现代码
package net.hurr.innerclass_;//匿名内部类的使用public class InnerClass01 &#123;    public static void main(String[] args) &#123;        Outer outer = new Outer();        outer.method();    &#125;&#125;class Outer&#123;    private int n1 = 100;    public void method()&#123;        //基于接口的匿名内部类        //使用接口I，并创建一个对象。传统方式：写一个类，实现该接口，并创建对象。但由于这个类只会使用一次，且一会不会再使用。可以使用内部类来简化。如下所示        //此时tiger的编译类型是I；运行类型是匿名的内部类。        /*        下方这个匿名内部类约等于以下语句            class XXXX implements I&#123;                public void cry() &#123;                    System.out.println(&quot;老虎在叫&quot;);                &#125;            &#125;            而其中的XXXX就是系统分配的一个类名。具体的名字是:外部类名$编号。比如这里就是Other$01.         */        I tiger = new I()&#123;            @Override            public void cry() &#123;                System.out.println(&quot;老虎在叫....&quot;);            &#125;        &#125;;        tiger.cry();//通过将匿名对象实例化后的变量访问其中的方法        System.out.println(&quot;tiger的类名为 &quot;+tiger.getClass());    &#125;&#125;interface I&#123;//接口    void cry();&#125;class A&#123;    public A() &#123;    &#125;    public void test()&#123;    &#125;&#125;
基于类的匿名类基本构成：class Outer &#123;    public void method() &#123;        A a = new A(&quot;jack&quot;) &#123;//这就完成了一个基于类的匿名内部类。括号内的值会传给父类A的构造函数.相当于继承了A这个类，但没有重写任何方法。          	//内部匿名类的语句组;        &#125;;    &#125;&#125;class A &#123;    public A(String s) &#123;        System.out.println(&quot;传入的值为：&quot; + s);    &#125;&#125;
匿名类中不允许存在构造函数（因为创建完就丢弃，没有构造的意义）
匿名内部类的调用方式：
对象名.内部类的参数；
也可以不创建对象名直接调用，比如：
new A(&quot;Tom&quot;) &#123;    public void test() &#123;      System.out.println(&quot;不创建对象名直接调用&quot;);    &#125;&#125;.test();//new出来直接调用class A &#123;    public A(String s) &#123;      System.out.println(&quot;传入的值为：&quot; + s);    &#125;&#125;

匿名内部类通常会当作实参直接传递。如：
public class InnerClass01 &#123;    public static void main(String[] args) &#123;        fun(new I()&#123;//直接把创造出来的基于接口的匿名内部类的对象作为实参传入到定义好的方法中            public void show()&#123;//在匿名类中完成接口所定义的功能                System.out.println(&quot;这是一幅名画&quot;);            &#125;        &#125;);               &#125;    public static void fun(I i)&#123;//定义一个方法，可以使用符合这个接口的对象        i.show();    &#125;&#125;interface I&#123;//定义一个接口    void show();&#125; 
更改为传统的写法如下（硬编码）：
public class InnerClass01 &#123;    public static void main(String[] args) &#123;        fun(new C());    &#125;    public static void fun(I i)&#123;//定义一个方法，可以使用符合这个接口的对象        i.show();    &#125;&#125;interface I&#123;//定义一个接口    void show();&#125;class C implements I&#123;    public void show()&#123;        System.out.println(&quot;这是一幅名画&quot;);    &#125;&#125;

两者在功能上一模一样，都是输出一句&quot;这是一幅名画&quot;，但在写法上，传统的方法需要先定义一个类，而这个类很有可能只会被使用一次之后就不会再被使用，占地方，而且看代码的时候比较啰嗦。

前者适合只用一次的场景，后者更适合需要复用的场景。

全部实验样例如下：
package net.hurr.innerclass_;//匿名内部类的使用public class InnerClass01 &#123;    public static void main(String[] args) &#123;        Outer outer = new Outer();        outer.method();        outer.fun();    &#125;&#125;class Outer &#123;    private int n1 = 100;    //基于类的匿名内部类    public void method() &#123;        //a的编译类型：A;a的运行类型：匿名        //相当于继承了A这个类，但没有重写任何方法。        A a = new A(&quot;jack&quot;) &#123;            @Override            public void test() &#123;                System.out.println(&quot;匿名内部类重写了test方法&quot;);            &#125;            public int n = 20;            public void fun1() &#123;                System.out.println(&quot;在匿名内部类中的n被打印：&quot; + n);            &#125;        &#125;;        a.test();//运行时会动态绑定，根据实际的对象调用对应的方法        System.out.println(a.n);//但属性同样不参与动态绑定，只能按照编译类型调用        a.fun1();//但参与动态绑定的内部类回去找自身的变量而非找编译类型变量        new A(&quot;Tom&quot;) &#123;            public void test() &#123;                System.out.println(&quot;不创建对象名直接调用&quot;);            &#125;        &#125;.test();    &#125;    //基于抽象类的匿名类    public void fun() &#123;        Anima anima = new Anima() &#123;            public void eat() &#123;                System.out.println(&quot;在基于抽象类的匿名内部类中的eat（）&quot;);                return;            &#125;        &#125;;        anima.eat();    &#125;&#125;class A &#123;    public A(String s) &#123;        System.out.println(&quot;传入的值为：&quot; + s);    &#125;    public void test() &#123;        System.out.println(&quot;类A中的test（）&quot;);    &#125;    public int n = 10;    public void fun1() &#123;        System.out.println(&quot;在普通外部类中的n被打印：&quot; + n);    &#125;&#125;abstract class Anima &#123;    abstract void eat();&#125;

内部类的细节
匿名内部类的语法比较奇特，请大家注意，因为匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征，对前面代码分析可以看出这个特点，因此可以调用匿名内部类方法。
可以直接访问外部类的所有成员， 包含私有的。(私有的访问权限在于类内，而内部类就在类中，因此可以方法私有)
不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final 修饰，因为局部变量也可以使用final。
作用域:仅仅在定义它的方法或代码块中。（类似于网络中的内部网络。内部网络可以访问外网的资源，但外网不能主动联系内网从的成员，因为找不到，除非借助端口转发？）
局部内部类 的成员访向 外部类 的成员：当作自己的成员一样直接访问。
外部类 访向 局部内部类的成员：需要实例化一个内部类的变量，通过对象的名字去找他。前提是能找到（在作用域范围内）
外部其他类 不能直接访问到 局部内部类(因为局部内部类地位是一个局部变量)
如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员) 去访问。



局部内部类定义在方法中&#x2F;代码块
作用域在方法体或者代码块中
本质仍然是一个类


外部类成员内部类语法class Outer &#123;    class Inter &#123;    		public void say() &#123;            System.out.println(&quot;内部类的一个方法&quot;);        &#125;    &#125;&#125;
细节讨论
成员内部类就是一个成员，因此它的作用域和外部类的其他成员一样，为整个类体。

定义在外部类的成员位置。不能有static修饰。

它可以直接访问外部类的所有成员（包括私有的）。但如果反过来外部类的成员（和内部类平级的）想要访问内部类内的数据，需要先创建对象。（或者加static，和普通类一样）

它也可以添加访问修饰符，因为他的地位就是一个成员。

成员内部类的方法不能加static修饰,除非这个内部类已经是static的了。或者java版本升级到16以上。

如果想在类A中访问外部类B中的内部类C，可以有一下三种方式。（ABC三者的关系：A、B平级，B、C内部外部）如下代码所示。或者在外部类B中创建对应的方法，通过方法调用内部类实例化后的对象。
//1、靠实例化后的对象来创建一个内部类的对象class A&#123;    B b = new B();    B.C c = b.new C();//相当于把new C()当作是b的一个成员    B b1 = new B();    B.C c2 = b1.new C();    public void fun()&#123;        System.out.println(&quot;c=&quot;+c.hashCode());        System.out.println(&quot;c2=&quot;+c2.hashCode());    &#125;&#125;class B &#123;    static private int n1 = 100;    static protected String name = &quot;张三&quot;;    class C &#123;        public void say() &#123;            System.out.println(&quot;位于内部类的say()被执行，外部类的成员 n1 = &quot; + n1 + &quot; name = &quot; + name);        &#125;    &#125;&#125;//2、在外部类中，编写一个方法，返回内部类的对象class B &#123;    static private int n1 = 100;    static protected String name = &quot;张三&quot;;    class C &#123;        public void say() &#123;            System.out.println(&quot;位于内部类的say()被执行，外部类的成员 n1 = &quot; + n1 + &quot; name = &quot; + name);        &#125;    &#125;    public C getInterC()&#123;//在外部类中实例化并返回，同样需要借助外部类的对象        return new C();    &#125;&#125;//3、或者用静态的方法：

package net.hurr.Interface_;public class Test &#123;    public static void main(String[] args) &#123;        Outer outer = new Outer();        Outer.inter01.say();    &#125;&#125;class Outer &#123;    static private int n1 = 100;    static protected String name = &quot;张三&quot;;    static class Inter01 &#123;        static public void say() &#123;//需要注意的是，此处的成员内部类的方法不能加static修饰,除非这个内部类已经是static的了。或者java版本升级到16以上            //内部类可以访问外部类中所有的成员，包括私有的。            System.out.println(&quot;位于内部类的say()被执行，外部类的成员 n1 = &quot; + n1 + &quot; name = &quot; + name);        &#125;    &#125;    //需要注意，内部类不能被外面的类（不是外部类）直接实例化，因为找不到这个类。    static Inter01 inter = new Inter01();    class Inter02 &#123;        public void t() &#123;            System.out.println(&quot;t()&quot;);        &#125;    &#125;      Inter02 inter02 = new Inter02();    public void t()&#123;//创建一个跳板，其他类可以通过这个方法访问到内部类的数据        inter02.t();    &#125;&#125;

如果外部类和内部类的成员重名时，会遵循就近原则，会访问到重名的内部类的成员。如果内部类想要访问重名了的外部类的成员，需要使用“外部类名.this.成员”的语法进行访问。

class A&#123;    private int n = 100;    class B&#123;        private int n = 200;        public void fun()&#123;            System.out.println(&quot;直接访问n会访问到内部类的n，会输出200.：&quot;+n);            System.out.println(&quot;如果需要访问外部类的n，需要特殊处理，比如这样就能访问到外部的值：&quot;+A.this.n);        &#125;    &#125;&#125;
静态内部类静态内部类是定义在外部类的成员位置，并有static修饰。

特点
可以直接访问外部类的所有静态成员，包括私有，但不能访问非静态的成员。
可以添加任意的修饰符，因为地位就是一个成员。
作用域：和成员一样，为整个类体。

package net.hurr.Interface_;public class Test &#123;    public static void main(String[] args) &#123;        A a = new A();        a.fun();    &#125;&#125;class A &#123;    private int n1 = 100;    private static int n2 = 200;    static class B &#123;//静态内部类有static修饰        private int n3 = 300;        public void say() &#123;            System.out.println(&quot;可以直接访问静态成员（类外）或者类内的所有成员 n2 = &quot; + n2 + &quot;  n3 = &quot; + n3);            //System.out.println(n1);//但不能访问类外的非静态成员        &#125;        public static void t()&#123;            System.out.println(&quot;外部类可以直接访问静态内部类中的静态成员而不需要实例化&quot;);        &#125;    &#125;    public void fun()&#123;        new B().say();//作用域在整个类中，因为可以在类外访问内部类的成员。        // 需要注意的是虽然是静态的内部类，但还需要实例化之后才能访问。因为里面的方法不是静态的，只有类是静态的        B.t();//可以直接访问内部类的静态成员    &#125;&#125;

静态内部类可以直接访问所有外部类的成员；但外部类想要访问内部类的成员则需要先实例化成对象。或者内部类的成员也是静态的。
外部其他类想要使用静态内部类的方式为：

public class Test &#123;   public static void main(String[] args) &#123;       //1、外部类名.       new A.B().fun();//对于静态内部类的非静态成员需要先实例化成对象       A.B.t();//如果成员也是静态的，就可以直接访问   &#125;&#125;class A &#123;   static class B &#123;       void fun()&#123;           System.out.println(&quot;在其他类中访问了静态内部类中的普通变量&quot;);       &#125;       public static void  t()&#123;           System.out.println(&quot;在其他类中访问了静态内部类中的静态变量&quot;);       &#125;   &#125;&#125;

同样如果外部类和静态内部类重名时，仍然遵守就近原则。如果想访问外部对象，可以使用 外部类名.成员 的方式进行访问。
package net.hurr.Interface_;public class Test &#123;    public static void main(String[] args) &#123;        A a = new A();        A.B b = new A.B();        b.t();    &#125;&#125;class A &#123;    private static int n = 100;    static class B &#123;        int n = 200;        public void t() &#123;            System.out.println(&quot;就近原则，访问到内部类的成员&quot; + n);            System.out.println(&quot;访问外部则需要类名.成员名&quot; + A.n);//需要注意的是，外部的成员需要是静态的。        &#125;    &#125;&#125;

小结内部类共有四种，局部内部类、匿名内部类、成员内部类、静态内部类。前两者是在成员内部，后两者的存在地位就是普通类的一个成员（本质）。（重点是匿名内部类）


枚举和注解自定义枚举实现方法
将构造器私有化，防止被直接的new；
去掉set相关的方法，防止属性被修改；
在类的内部直接创建固定的对象；
在第三步的语句前加入final防止被修改；

class Season &#123;    private String name;    private String desc;    private Season(String name, String desc) &#123;        this.name = name;        this.desc = desc;    &#125;    //3、在类的内部直接创建固定的对象    public static final Season SPRING = new Season(&quot;春天&quot;,&quot;温暖&quot;);    public static final Season SUMMER = new Season(&quot;夏天&quot;,&quot;炎热&quot;);    public static final Season AUTUMN = new Season(&quot;秋天&quot;,&quot;凉爽&quot;);    public static final Season WINTER = new Season(&quot;冬天&quot;,&quot;寒冷&quot;);&#125;
自定义枚举的注意事项
样式类似于单例模式中的饿汉式；
不需要提供set方法，因为对象值通常都是只读的；
对枚举的对象或属性一般都使用final+static共同修饰，实现优化；（在使用的时候不会加载类，java8+）
枚举对象根据需要，可以有多个属性；（如上方的样例）

小结
构造器私有化；
本类内部创建一组对象；
对外暴露对象（通过为对象添加 public final static 修饰符） ；
可以提供 get 方法，但是不要提供 set；

enum关键字的枚举实现方法：
使用关键字 enum 替代 class；
public static final Season SPRING &#x3D; new Season(“春天”, “温暖”) 直接使用SPRING(“春天”, “温暖”) ；（常量名(实参列表)）
如果有多个常量(对象)， 使用 ,号间隔即可；（可能编译器只认一条语句？）
如果使用 enum 来实现枚举，要求将定义常量对象，写在最前面（与this或super的地位相同）；
如果我们使用的是无参构造器，创建常量对象，则可以省略 ()；

package net.hurr.chapter.enum_;public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(Season.SPRING);        System.out.println(Season.SUMMER);        System.out.println(Season.AUTUMN);        System.out.println(Season.WINTER);        System.out.println(Season.OTHER);    &#125;&#125;enum Season &#123;    //不再定义对象，直接使用常量名（实参列表）的方式进行说明）    SPRING(&quot;春天&quot;,&quot;温暖&quot;),    SUMMER(&quot;夏天&quot;,&quot;炎热&quot;),    AUTUMN(&quot;秋天&quot;,&quot;凉爽&quot;),    WINTER(&quot;冬天&quot;,&quot;寒冷&quot;),    OTHER;//若使用无参构造器，则可以不用加括号。    private String name;    private String desc;    private Season(String name, String desc) &#123;        this.name = name;        this.desc = desc;    &#125;    Season() &#123;    &#125;    @Override    public String toString() &#123;        return &quot;Season&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +                &quot;, desc=&#x27;&quot; + desc + &#x27;\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;

运行结果：
Season{name&#x3D;’春天’, desc&#x3D;’温暖’}Season{name&#x3D;’夏天’, desc&#x3D;’炎热’}Season{name&#x3D;’秋天’, desc&#x3D;’凉爽’}Season{name&#x3D;’冬天’, desc&#x3D;’寒冷’}Season{name&#x3D;’null’, desc&#x3D;’null’}

enum枚举的注意事项
当使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类, 而且是一个 final 类；（具体见javap反编译出的内容）

反编译结果：
Compiled from “Test.java”final class net.hurr.chapter.enum_.Season extends java.lang.Enum&lt;net.hurr.chapter.enum_.Season&gt; {public static final net.hurr.chapter.enum_.Season SPRING;public static final net.hurr.chapter.enum_.Season SUMMER;public static final net.hurr.chapter.enum_.Season AUTUMN;public static final net.hurr.chapter.enum_.Season WINTER;public static final net.hurr.chapter.enum_.Season OTHER;public static net.hurr.chapter.enum_.Season[] values();public static net.hurr.chapter.enum_.Season valueOf(java.lang.String);public java.lang.String toString();static {};}
具体代码：
enum Season {SPRING(“春天”,”温暖”),SUMMER(“夏天”,”炎热”),AUTUMN(“秋天”,”凉爽”),WINTER(“冬天”,”寒冷”),OTHER;&#x2F;&#x2F;若使用无参构造器，则可以不用加括号。private String name;private String desc;
private Season(String name, String desc) {this.name &#x3D; name;this.desc &#x3D; desc;}Season() {}@Overridepublic String toString() {return “Season{“ +“name&#x3D;’” + name + ‘&#39;‘ +“, desc&#x3D;’” + desc + ‘&#39;‘ +‘}’;}}


传统的 public static final Season2 SPRING &#x3D; new Season2(“春天”, “温暖”); 简化成 SPRING(“春天”, “温暖”)；（调用了有参构造器，由实参判断）

如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略；

当有多个枚举对象时，使用逗号间隔，最后有一个分号结尾；

枚举对象必须放在枚举类的行首；

如果直接输出toString（没有重写的情况下会继承父类的），则会输出常量名。如：
public class Test &#123;    public static void main(String[] args) &#123;        Gender a = Gender.BOY;        Gender b = Gender.BOY;        Gender c = Gender.GIRL;        System.out.println(a + &quot;  &quot; + b + &quot;  &quot; + c);      	System.out.println(a == b);    &#125;&#125;enum Gender &#123;    BOY, GIRL;&#125;/*运行结果：BOY  BOY  GIRLtrue*/
枚举类型只要常量名相同就是同一个。见上方代码，不管BOY被分给了几次，他们都是同一个。具体原理看自定义的枚举的实现方法，在枚举类每个名字不同的常量只有一个实例，调用不过是将这个实例的地址传给不同的对象。



enum的常用方法使用enum关键字的时候，会隐式的继承Enum类，这样我们就可以使用 Enum 类相关的方法。





方法名
详细描述



valueOf
将给定的字符串转换成枚举类型（或者说返回与字符串相同的枚举类型）。如果枚举类内没有匹配的字符串，会抛异常。语法：Season autumn &#x3D; Season.valueOf(“AUTUMN”);


values
隐藏方法，在源码中无法查看。返回一个数组，数组的内容是当前枚举类中的所有常量。数组类型为对应的枚举类


toString
得到当前枚举常量的名称。你可以通过重写这个方法未使得到的结果更易读。


equals
在枚举类型中可以直接使用”&#x3D;&#x3D;“来比较两个枚举常量是否相等。Enum提供的这个equals0方法，也是直接使用”等于“实现的。


hashCode
Enum实现了hashCode()来和equals())保持一致。 它也是不可变的。


getDeclanngClass
得到枚举常量所属枚举类型的Class对象。可以用它来判断两个枚举常量是否属千同-一个枚举类型。


name
得到当前枚举常量的名称。toString如果没有重写则同样输出当前常量的名字。


ordinal
得到当前枚举常量的次序。（从0开始编号，编号的顺序为当前常量在枚举类中的位置）


compareTo
比较两个枚举常量的大小(按照声明的顺序排列，即通过ordinal得到的数) 。返回当前枚举类型减去传入的类型之间相差的个数。等于0时表示两个枚举类型相176                    56 80等。


clonee
枚举类型不能被Clone。为了防止子类实现克隆方法，Enum实现了一个仅抛出CloneNotSupprtedException异常的不变Clone()


enum的注意事项
使用enum关键字后，就不能再继承其他类了，因为enum会隐式的继承Enum类，而Java中只有单继承，不支持多继承。、

除了不能继承其他的类外，enum类也不能被其他类继承

enum实现的枚举类的本质仍然还是一个类，因此是可以实现接口的，可以被接口所规范。使用时可以通过枚举出的对象.方法名。如下：
package net.hurr.chapter.enum_;public class Test &#123;    public static void main(String[] args) &#123;        E.TEST.play();    &#125;&#125;enum E implements I &#123;    TEST;    public void play()&#123;        System.out.println(&quot;播放音乐&quot;);    &#125;&#125;interface I&#123;    void play();&#125;

注解（Annotation）注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。

在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置等。

基本介绍使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素。

三个基本的 Annotation
@Override: 限定某个方法，是重写父类方法, 该注解只能用于方法；
@Deprecated: 用于表示某个程序元素(类, 方法等)已过时；
@SuppressWarnings: 抑制编译器警告

基本的 Annotation 应用案例@Override 注解的案例class A&#123;    private String s = &quot;AAA&quot;;    @Override//放在方法前    public String toString() &#123;        return s;    &#125;&#125;
@Override  放在方法的上一行，表示下面的方法重写了父类的方法。如果不加照样是重写的，但加上的话编译器就会去检查该方法是否真的重写了父类的方法，如果重写了，则编译通过；如果没有重写，则会编译报错。

它的价值就在于语法校验。

在源码中为：

@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125;
上方代码中的@interface 就表明了这是一个注解类。（注意这不是接口！！！）

@Override的使用说明
@Override表示指定重写父类的方法(从编译层面验证)， 如果父类没有对应方法，则会报错
如果不写@Override注解，而父类仍有public void fly00，仍然构成重写；
@Override只能修饰方法，不能修饰其它类，包，属性等等；
查看@Override注解源码为@ Target(ElementType.METHOD)说明只能修饰方法；
@Target是修饰注解的注解，称为元注解， 记住这个概念；

@Deprecated 注解的案例用于表示某个程序的元素（比如类、方法）已经过时。

只要在类前面加上这个注解，编译器在自动联想搜索的时候，就不会优先选中这个。但这并不代表不能用，还是可以选中的，只是不在第一位了，或者说不推荐使用了。而且选中之后会在使用该类的地方加上删除线。

他可以修饰构造器、字段（属性）、局部变量、方法、包、参数、类型。

他的用处就是做一个过渡，在版本升级的时候提示某些正在使用的东西在后期是会被淘汰的。

源码：

@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;    String since() default &quot;&quot;;    boolean forRemoval() default false;&#125;
@SuppressWarnings 注解的案例
当我们不希望看到这些警告的时候，可以使用 SuppressWarnings 注解来抑制警告信息
在{“”} 中，可以写入你希望抑制(不显示)警告信息
作用的范围与放置的位置有关。他只会作用于下方第一个对象。

可以指定的警告类型有：





关键字
用途



all
抑制所有警告


boxing
抑制与封装&#x2F;拆装作业相关的警告


cast
抑制与强制转型作业相关的警告


dep-ann
抑制与淘汰注释相关的警告


deprecation
抑制与淘汰的相关警告


fallthrough
抑制与switch陈述式中遗漏break相关的警告


finally
抑制与未传回finally区块相关的警告


hiding
抑制与隐藏变数的区域变数相关的警告


incomplete-switch
抑制与switch陈述式(enum case)中遗漏项目相关的警告


javadoc
抑制与javadoc相关的警告


nls
抑制与非nls字串文字相关的警告


null
抑制与空值分析相关的警告


rawtypes
抑制与使用raw类型相关的警告


resource
抑制与使用Closeable类型的资源相关的警告


restriction
抑制与使用不建议或禁止参照相关的警告


serial
抑制与可序列化的类别遗漏serialVersionUID栏位相关的警告


static-access
抑制与静态存取不正确相关的警告


static-method
抑制与可能宣告为static的方法相关的警告


super
抑制与置换方法相关但不含super呼叫的警告


synthetic-access
抑制与内部类别的存取未最佳化相关的警告


sync-override
抑制因为置换同步方法而遗漏同步化的警告


unchecked
抑制与未检查的作业相关的警告


unqualified-field-access
抑制与栏位存取不合格相关的警告


unused
抑制与未用的程式码及停用的程式码相关的警告


用法：在想要使用的对象的上一行，写上：

@SuppressWarnings(&quot;关键字&quot;)
如：让编译器忽略下方的类中所有的因未被使用所造成的警告：
@SuppressWarnings(&quot;unused&quot;)class A&#123;    public int n1 = 10;    private int i;    public void hi()&#123;    &#125;&#125;
JDK的元注解简单的说就是修饰注解的注解。


元注解的种类


注解类型
用途



Retention
指定注解的作用范围，三种 SOURCE,CLASS,RUNTIM


Target
指定注解可以在哪些地方使用


Documented
指定该注解是否会在 javadoc中体现


Inherited
子类会继承父类的注解


Retention注解只能用于修饰一个 Annotation （注解）定义, 用于指定该 Annotation 可以保留多长时间（或者说保留范围）, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值:


RetentionPolicy.SOURCE: 编译器使用后，直接丢弃这种策略的注释。简单的说就是只在源码阶段是生效的，往后的.class文件不保留；
RetentionPolicy.CLASS: 编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 不会保留注解。 这是默认值。简单的说就是上一个的扩展版，将注解保留至class文件1中；
RetentionPolicy.RUNTIME:编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注解. 程序可以 通过反射获取该注解。这是所有注解中保留范围最长的，当程序在运行的时候，jvm虚拟机仍然会去读取该注解，并作出相应的处理。

例如下方的Deprecated注解的源码，就有这个注解的存在

@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;    String since() default &quot;&quot;;    boolean forRemoval() default false;&#125;
其中的Retention的值为RetentionPolicy.RUNTIME，因此在javac编译的时候，就会提示一下信息：

注: Test.java使用或覆盖了已过时的 API。注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。

Target注解用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素。

@Target也包含一个名为value的成员变量。

比如下方的一个SupperssWarnings注解的一个源码

@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123;    String[] value();&#125;
可以看到其中就有Target注解的存在，正因为他的存在，所以这个SupperssWarnings注解就可以用于修饰TYPE（类型）, FIELD（字段/属性）, METHOD（方法）, PARAMETER（参数）, CONSTRUCTOR（构造器）, LOCAL_VARIABLE, MODULE这些类型。

Documented注解用于指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档。

即在生成文档时，可以看到该注解。

例如如下的Deprecated注解的源码，就有这个注解的存在

@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;    String since() default &quot;&quot;;    boolean forRemoval() default false;&#125;
异常基本概念将程序执行中发生的不正常的情况称为异常。
根据异常的发生情况可以分成两大类：运行时异常和编译时异常。
运行异常是指在运行阶段会触发的异常，比如数组越界、空间不足等情况。运行时异常编译器检查不出来。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。
对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。
而
编译异常是必须要处理的，不然通过不了编译。比如打开文件但文件不存在等情况
执行过程中所发生的异常事件可分为两大类：ERROR（错误）和Exception。
ERROR： Java虚拟机无法解决的严重问题。如: JVM系统内部错误、资源耗尽等严重情况。比如: StackOverflowError[栈溢出]和OOM(out of memory)，Error 是严重错误，程序会崩溃。

Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等，Exception 分为两大类:运行时异常[程序运行时，发生的异常]和编译时异常[编程时，编译器检查出的异常]。

异常处理当异常发生时，对异常的处理方式。

try - catch - finally
将捕获到的异常自行处理。


throws
发生异常后不处理，直接抛出，谁调用谁接收。



try - catch异常处理Java提供try和catch块来处理异常。try块用于包含可能出错的代码。catch块用于处理try块中发生的异常。可以根据需要在程序中有多个try...catch块。


基本语法try&#123;  //可能会出异常的代码&#125;catch(异常)&#123;  //出异常后会执行的代码。  //catch块可以有多个，&#125;finally&#123;  //不管异常是否发生，此处的代码都会被执行。如关闭连接、释放资源等。此块可以缺省不写。&#125;
样例try &#123;            String str = &quot;aaa&quot;;            int n = Integer.parseInt(str);            System.out.println(n);        &#125;        catch (Exception e) &#123;            System.out.println(&quot;异常信息为：&quot; + e.getMessage());        &#125;        System.out.println(&quot;程序继续执行&quot;);

运行结果：
异常信息为：For input string: “aaa”程序继续执行

try - catch的细节
如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块；如果存在finally块，还会执行finally块中的语句。

如果异常没有发生，则顺序执行try的代码块，不会进入到catch。如果存在finally块，还会执行finally块中的语句。

如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)则使用finally {}。需要注意的是，一旦有这个finally，哪怕 try或catch里面有return，也不会退出，而是执行finally语句块。虽然return暂时不会执行，但return后面的语句照样会被执行。如：
static int fun()&#123;  int i = 0;  try &#123;    int n1=2,n2=0;    int res = n1/n2;//出现异常    return i;  &#125;  catch (Exception e) &#123;    return ++i;//注意，此处的++i执行了，但并没有返回，因为下面的finally有返回了。  &#125;  finally &#123;    return ++i;//执行了并且返回了。  &#125;&#125;public static void main(String[] args) &#123;  System.out.println(fun());&#125;/*执行结果：2*/
如果finally中没有return退出语句，则还是会回到catch中执行对应的return。如：
 static int fun()&#123;        int i = 1;        try &#123;            i++;            int n1=2,n2=0;            int res = n1/n2;//制造异常        &#125;        catch (Exception e) &#123;            ++i;            return i;//执行到此i会被暂时保存，直到执行完finally为止。如果finally中没有结束程序，再回头将保存的给返回回去。        &#125;        finally &#123;            i++;            System.out.println(&quot;i = &quot; + i);        &#125;        return 0;    &#125;    public static void main(String[] args) &#123;        System.out.println(fun());    &#125;//执行结果：//i = 4//3
可以有多个catch语句捕获不同的异常(进行不同的业务处理)，要求父类异常在后，子类异常在前，比如(Exception 在后，NullPointerException 在前）。如果发生异常，只会匹配一个catch。


如：

public class Test &#123;    public static void main(String[] args) &#123;        try &#123;            Person person = new Person();            person = null;//空指针异常，NullPointerException            System.out.println(person.getName());            int n1 = 10, n2 = 0;            int res = n1 / n2;//算数异常，        &#125;        catch (NullPointerException e) &#123;            System.out.println(&quot;空指针异常：&quot; + e);        &#125;        catch (ArithmeticException e) &#123;            System.out.println(&quot;算术异常：&quot; + e);        &#125;        catch (Exception e) &#123;            System.out.println(&quot;其他异常&quot; + e);        &#125;    &#125;&#125;class Person &#123;    private String name = &quot;Jack&quot;;    public String getName() &#123;        return name;    &#125;&#125;

可以省略catch，直接进行try-finally配合使用，这种用法相当于没有捕获异常，因此程序会直接崩掉&#x2F;退出。比如发生异常后不进行处理，只负责关闭一些连接然后崩溃。因为没有处理异常，所以会被默认的throws抛出，层层上抛，直到JJVM机，然后JVM将异常信息打出来，并结束程序。

案例：利用try - catch使的用户输入的必须是整数，不是就重输Scanner scanner = new Scanner(System.in);        int num;        while (true)&#123;            try &#123;                num = Integer.parseInt(scanner.next());//如果输入的字符串不是纯整数，就会抛异常；                break;//只要抛异常就不会执行退出            &#125;            catch (NumberFormatException e) &#123;                System.out.println(&quot;输入有误，请重新输入&quot;);//检测到异常后输出提示信息让用户重新输入。            &#125;        &#125;
throws基本介绍和使用细节
如果个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。

在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。

对于编译异常，程序中必须处理，比如 try - catch 或者throws。
public void f2() throws Exception &#123;//针对编译异常必须要有对应的异常处理才能通过。可以抛出对应的FileNotFoundException异常或者对应异常的父类异常Exception        FileInputStream fileInputStream = new FileInputStream(&quot;D://test.txt&quot;);//这里创建了一个文件流，但因为不存在文件所以会报异常（编译异常）    &#125;
对于运行异常，程序中如果没有处理，默认就是throws的方式处理。知道throws到JVM虚拟机为止。JVM处理异常的功能就是，将异常打印出来，并中断运行。

子类重写父类的方法时，所抛出的异常类型要么和父类抛出的异常一致， 要么为父类抛出的异常的类型的子类型。或者说子类不能扩大父类的异常范围，也不能和父类没有关系。如：
class A&#123;    public void f() throws ArithmeticException&#123;    &#125;&#125;class B extends A&#123;    @Override    public void f() throws ArithmeticException &#123;//只能是父类类A中原函数抛出异常的子类或者他自己，不能比父类大，如Exception    &#125;&#125;
在throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必throws。

如果一个方法调用了另一个存在编译异常且直接throws抛出的方法，则在调用该方法的时候必须明确的处理。
哪怕只是抛出但并没有真正的触发
public void f1()&#123;        f2();//哪怕只是抛出但并没有真正的触发也得处理    &#125;      public void f2() throws FileNotFoundException &#123;    &#125;
public void f1()&#123;        try &#123;            f2();//对于调用的方法如果存在编译异常，则必须对这个异常进行显示(明确)的处理，再次throws抛出或者try        &#125;        catch (FileNotFoundException e) &#123;            throw new RuntimeException(e);//也可以捕获了再抛出        &#125;    &#125;    public void f2() throws FileNotFoundException &#123;//此处不做处理 直接抛出        //创建一个编译异常        FileInputStream fileInputStream = new FileInputStream(&quot;D://test.txt&quot;);    &#125;
或者在方法内就try - catch处理掉，或者捕获后再抛出：
public void f()&#123;        f2();//可以不处理    &#125;    public void f1()&#123;        try &#123;            f2();//也可以处理        &#125;        catch (Exception e) &#123;            System.out.println(e);        &#125;    &#125;    public void f2() &#123;//此处不做处理 直接抛出        //创建一个编译异常        try &#123;            FileInputStream fileInputStream = new FileInputStream(&quot;D://test.txt&quot;);        &#125;        catch (FileNotFoundException e) &#123;            throw new RuntimeException(e);//如果这样抛，也可以调用者也可以不用处理。        &#125;    &#125;
对于运行异常调用者可以不进行处理。因为存在默认的处理机制
public void f()&#123;        f2();//可以不处理，因为有默认的处理机制    &#125;    public void f1()&#123;        try &#123;            f2();//也可以处理一下        &#125;        catch (ArithmeticException e) &#123;            System.out.println(e);        &#125;    &#125;    public void f2() throws ArithmeticException&#123;//此处不做处理 直接抛出        int res = 10/0;    &#125;

自定义异常当程序中出现了某些&quot;错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息。

自定义异常的步骤
定义类自定义异常类名(程序员自己写)继承Exception或RuntimeException；
如果继承Exception，属于编译异常；
如果继承RuntimeException，属于运行异常（一般来说，继承RuntimeException，因为可以使用默认的异常处理机制）；

样例：要求：当我们接收Person对象年龄时，要求范围在18 - 120之间，否则抛出一个自定义异常(要求继承RuntimeException)并给出提示信息public class Test &#123;    public static void main(String[] args) &#123;        int age1 = 16;        if (!(age1 &gt;= 18 &amp;&amp; age1 &lt;= 120)) &#123;//设定一个范围            throw new AgeException(&quot;年龄需要在18-120之间&quot;);//通过构造器设置异常的信息        &#125;        System.out.println(&quot;年龄范围正常&quot;);    &#125;&#125;class AgeException extends RuntimeException &#123;//自定义一个异常类，因为要求是运行时异常，所以继承RuntimeException    public AgeException(String message) &#123;//类的构造函数        super(message);    &#125;&#125;

运行结果：
Exception in thread “main” net.hurr.exception_.AgeException: 年龄需要在18-120之间at net.hurr.exception_.Test.main(Test.java:10)

throw和throws的区别


名字
意义
位置
后面跟的东西



throws
异常处理的一种方式
方法的声明处
异常类型


throw
手动生成异常的关键字
方法体中
异常对象


常用类包装类针对八种基本定义相应的引用类型——包装类。

有了类的特点，就可以调用类中的方法。





基本数据类型
包装类
父类



boolean
Boolean



char
Character



byte
Byte
Number


short
Short
Number


int
Integer
Number


long
Long
Number


float
Float
Number


double
Double
Number


包装类与基本数据类型的转换
jdk5前的手动装箱和拆箱方式，装箱:基本类型-&gt;包装类型，反之，就是拆箱


jdk5以后(含jdk5)的自动装箱和拆箱方式
自动装箱底层调用的是valueOf方法，比如Integer.valueOf()



装箱和拆箱的演示//int &lt;---&gt; Integer//手动装箱int n1 = 100;Integer integer = new Integer(n1);Integer integer1 = Integer.valueOf(n1);//或者这样//手动装箱int i = integer.intValue();//jdk5（包括5）以后的自动装箱拆箱int n2 = 200;Integer integer2 = n2;//底层依然是Integer.valueOf(),本质仍然是手动装箱int n3 = integer2;//同样，底层也还是手动拆箱的intValue()//同理，其他的数据类型也可以这么玩char c = &#x27;A&#x27;;Character C = c;double d = new Double(20.2);
包装类型与String类型的相互转换//包装类 -&gt; StringInteger n = 100;//方式1：相当于生成一个新的串赋值给s1，而i的值不会变String s1 = n+&quot;&quot;;//方式2：比较传统，几乎所有包装类都有这个方法String s2 = n.toString();      String s3 = new Character(&#x27;a&#x27;).toString();//方式3 相当于转换了两次，i变成了obj，obj再到stringString s4 = String.valueOf(n);//String -&gt; 包装类String str = &quot;12345&quot;;Integer i1 = Integer.parseInt(str);Double d = Double.parseDouble(str);Integer i2 = new Integer(str);//利用Integer的构造方法
需要注意的是，当包装类与基本类型相比较的时候，比较的是值而非类型或地址。如：
int n1 = 100;Integer n2 = new Integer(100);System.out.println(n1 == n2);
执行之后会显示true。但Sting没有基本类型，所以如果这么比较，会是false
String s1 = &quot;A&quot;;        String s2 = new String(&quot;A&quot;);        System.out.println(s1 == s2);
String介绍
String对象用于保存字符串，也就是一组字符序列。
字符串常量对象是用双引号括起的字符序列。例如: “你好”、 “12.97”、 “boy”等。
字符串的字符使用Unicode字符编码，一个字符(不区分字母还是汉字)占两个字节。
String类较常用构造器(其它看手册):

String s1 = new String();String s2 = new String(String original);String s3 = new String(char[] a);String s4 = new String(char[] a,int startIndex,int count)//从字符数组中初始化，从第几位开始，获取几个
创建 String对象的方式
方式一:直接赋值String s1 &#x3D; “hurriedlu”;
方式二:调用构造器String s2 &#x3D; new String(“hurriedlu”);

两种创建 String对象的区别方式一：先从常量池查看是否有对应字符串的数据空间，如果有，直接指向;如果没有则重新创建，然后指向。
s1最终指向的是常量池的空间地址。        方式二：先在堆中创建空间，里面维护了value属性，指向常量池的对应字符串的空间。如果常量池没有”hsp”,重新创建，如果有，直接通过value指向。 s2最终指向的是堆中的空间地址。
简单的说，方式一的直接赋值相当于直接指向对应的空间，方式二通过构造函数的方式赋值相当于先创建一个对象，再由对象指向对应的空间。

String的父类和接口接口：Serializable（实现了这个接口说明这个类可以串行化，以便在网络中传输），Comparable（实现了这个接口说明这个类可以相互比较），CharSequence。
String的特性
String是一个final类， 代表不可变的字符序列，也就是说不能被其他类所继承并改写。
字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的。
String的底层还是数组，在String类中维护了一个可变长度的finial类型的value数组，字符串就存储在这个数组中。value一旦指向了某块地址，就不能再指向其他的地址（空间）了。但这块地址的值还是可以随便修改的。

常见的误区public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;========================================&quot;);        System.out.println(&quot;1：&quot;);        //1、求输出结果        String s1 = &quot;abc&quot;;        String s2 = &quot;abc&quot;;        System.out.println(s1.equals(s2));//T，因为equals函数是值比较        System.out.println(s1 == s2);//T,因为指向的是同一个常量池中的地址。        System.out.println(&quot;========================================&quot;);        System.out.println(&quot;2：&quot;);        //2、求输出结果        String s3 = &quot;hurr&quot;;        String s4 = new String(&quot;hurr&quot;);        System.out.println(s3.equals(s4));//T,因为是值比较        System.out.println(s3 == s4);//F,s3是直接指向常量池中的字符串，s4是指向堆中的一个对象，所以地址不同        System.out.println(s3 == s4.intern());//T,因为intern方法是返回常量池的地址，而s3也是常量池中的一个地址        System.out.println(s4 == s3.intern());//F,因为intern方法是返回常量池的地址，而s4是堆中一个对象的地址        System.out.println(&quot;========================================&quot;);        //3、问：以下语句创建了几个对象？        String s5 = &quot;hello&quot;;        s5 = &quot;World&quot;;        //一共创建了两个对象。字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的。        //因此，原来的仍然会保留，只是又新建了一个World的字符串，然后将s5指向了这个字符串。        //4、问：以下语句创建了几个对象？        String s6 = &quot;Hello&quot; + &quot;World&quot;;        //注意，只创建了一个。因为编译器在底层有一个优化，避免了两个字符串没有使用却要占地方，因此等价于String s6 = &quot;HelloWorld&quot;;        //5、问：以下语句创建了几个对象？        String s7 = &quot;Hello&quot;;        String s8 = &quot;World&quot;;        String s9 = s7 + s8;        //一共创建了三个。具体流程如下：        //1. 首先新建一个s9的对象；2. 在常量池中创建一个Hello；3. 在第二步创建的常量后面追加World；4. 将s9中的value指针指向第二步创建的常量。        System.out.println(&quot;========================================&quot;);        System.out.println(&quot;6：&quot;);        //6、问：以下语句的输出情况        String s10 = &quot;Hello&quot;;        String s11 = &quot;World&quot;;        String s12 = (s7 + s8).intern();        String s13 = &quot;HelloWorld&quot;;        System.out.println(s12 == s13);//T        System.out.println(s12.equals(s13));//T    &#125;&#125;
String 常用的方法String类是保存字符串常量的。每次更新都需要重新开辟空间，效率较低，因此java设计者还提供了StringBuilder和StringBuffer来增强String的功能，并提高效率。





方法名
作用



equals
比较两个字符串（String对象）的值是否相等。s1.equal(s2);


equalsIgnoreCase
比较两个字符串是否相等（忽略大小写）。s1.equalsIgnoreCase(s2);


length
返回字符串的长度。s1.length();














intern()
如果常量池已经包含一个等于此String的对象，就返回池中的字符串；否则将此String添加到池中，并返回此String对象的引用简单的说就是，返回常量池对应的字符串的地址，相当于返回用方式1新建出来的String对象。


equals &#x2F;&#x2F;区分大小写，判断内容是否相等equalslgnoreCase &#x2F;&#x2F;忽略大小写的判断内容是否相等length &#x2F;获取字符的个数，宇符串的长度indexOf &#x2F;&#x2F;获取字符在字符串中第1次出现的索引,索引从开始，如果找不到，返回-1lastIndexOf &#x2F;&#x2F;获取字符在字符串中最后1次出现的索引,索引从开始，如找不到，返回-1substring &#x2F;&#x2F;截取指定范围的子串trim &#x2F;&#x2F;去前后空格charAt:获取某索引处的字符，注意不能使用Str[index]这种方式
toUpperCasetoLowerCaseconcatreplace替换字符串中的字符split分割字符串，对于某些分割字符，我们需要转义比如| l\等案例: String poem &#x3D; “锄禾日当午,汗滴禾下土，谁知盘中餐,粒粒皆辛苦”:和文件路径.compareTo &#x2F;&#x2F;比较两个字符串的大小toCharArray &#x2F;&#x2F;转换成字符数组format &#x2F;&#x2F;格式字符串，%s宇符串%c字符%d整型%.2f浮点型案例，将一个人的信息格式化输出
StringBuffer
java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删。
很多方法与String相同，但StringBuffer是可变长度的。
StringBuffer是一个容器。

StringBuffer的特性
StringBuffer 的直接父类 是 AbstractStringBuilder；
StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化；
在父类中 AbstractStringBuilder 有属性 char[] value,不是 final，因此该 value 数组存放在堆中而不是常量池；
StringBuffer 是一个 final 类，不能被继承 ；
因为 StringBuffer 字符内容是存在 char[] value, 所有的变化(增加&#x2F;删除) 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String

String 和 StringBuffer的区别
String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址， 效率较低&#x2F;&#x2F;private final char value[];
StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次更新地址（只有在空间不够的时候才会更新，即不支持动态调整空间），效率较高&#x2F;&#x2F;char[] value; &#x2F;这个放在堆.

StringBuffer的构造器StringBuffer()构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符。简单的说就是，创建一个大小为 16 的char[]，用于存放字符内容。
StringBuffer(CharSequence seq)public java.lang StringBuilder(CharSequence seq)构造-一个字符串缓冲区，它包含与指定的CharSequence相同的字符。
StringBuffer(int capacity) &#x2F;&#x2F;capacity [容量]构造一个不带字符，但具有指定初始容量的字符串缓冲区。即对char[]大小进行指定和第一个构造器类似，简单的说就是可以指定初始空间的大小。
StringBuffer(String str)构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容。简单的说就是用已有的str对象创建一个StringBuffer对象，其空间大小为str字符串的长度+16.需要注意的是，如果str是一个空串，则会抛出空指针异常。因为在源码中需要先计算。如下代码所示
String str = null;StringBuffer s = new StringBuffer(str);
会抛出空指针异常。（java.lang.NullPointerException）因为在底层会先获取str的长度，而空串是没有长度的。

需要注意的是，如果用于初始化的数组
String 和 StringBuffer相互转换String 转 StringBuffer简单的说就是利用上方第四个构造器，创建一个StringBuffer对象；

String str = &quot;hurriedlu&quot;;StringBuffer stringBuffer = new StringBuffer(str);//注意，返回的只是一个利用str的值创建StringBuffer的对象，对他本身没有影响。
同样也可以利用追加的方式

StringBuffer stringBuffer1 = new StringBuffer();stringBuffer1 = stringBuffer1. append(str);//将str的值追加到新创的append里面。
StringBuffer 转 String同样也可以利于构造器进行转换
StringBuffer stringBuffer = new StringBuffer(&quot;Hurriedlu&quot;);String s1 = new String(stringBuffer);
利用StringBuffer的toString方法：
StringBuffer stringBuffer3 = new StringBuffer(&quot;Hurriedlu&quot;);String str = stringBuffer3.toString();
StringBuffer的常用方法
追加（增）
StringBuffer s = new StringBuffer(&quot;hello&quot;);s.append(&#x27;,&#x27;);s.append(&quot;worle&quot;);s.append(&quot;!&quot;).append(100).append(true).append(10.5);//append可以连，且返回值都是StringBuffer的类型。System.out.println(s);//hello,worle!100true10.5/*需要注意的是，如果追加的字符串是空，是null，则将null转换成字符串的“null”追加到后面。*/
删
StringBuffer s = new StringBuffer(&quot;helloworld&quot;);s.delete(5,10);//删除字符串序列中大于等于start,小于end的字符，小于10的字符。（序号从0起，左闭右开，类似于c++里面的迭代器）System.out.println(s);//hello
（替换）改
StringBuffer s = new StringBuffer(&quot;hello123world&quot;);s.replace(5,8,&quot;,&quot;);//同上面的删除功能，左闭右开，从0起，将区间内的文字替换成第三个参数System.out.println(s);//hello,world
查
StringBuffer s = new StringBuffer(&quot;123123123&quot;);int index = s.indexOf(&quot;2&quot;);//返回第一次出现实参数据的位置，此处返回1.因为序列是从0起System.out.println(index);
插
StringBuffer s = new StringBuffer(&quot;Hello,!&quot;);s.insert(6,&quot;World&quot;);//从0起，在第6个的位置插入参数2的数据,原来在参数1及后面的位置的数据自动后移System.out.println(s);//Hello,World!
长度
StringBuffer s = new StringBuffer(&quot;Hello&quot;);int len = s.length();//返回字符串的长度System.out.println(len);//5

StringBuilderStringBuilder一个可变的字符序列。此类提供一个与StringBuffer兼容的APl,但不保证同步(换句话说就是StringBuilder不是线程安全的)。该类被设计用作StringBuffer的一个简易替换，
用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类！因为在大多数实现中，它比StringBuffer要快。        在StringBuilder上的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据。
StringBuilder 常用方法StringBuilder和StringBuffer均代表可变的字符序列，方法是一样的，所以使用和StringBuffer一样。

StringBuilder的特点
StringBuilder 继承 AbstractStringBuilder 类；
实现了 Serializable ,说明 StringBuilder 对象是可以串行化(可以串行话说明对象可以网络传输，也可以保存到文件)
StringBuilder 是 final 类, 不能被继承；
StringBuilder 对象字符序列仍然是存放在其父类 AbstractStringBuilder 的 char[] value，因此，字符序列是存放在堆中的；
StringBuilder 的方法没有做互斥的处理,即没有 synchronized 关键字,因此最好只在单线程的情况下使用。

String、StringBuffer 和 StringBuilder的比较
StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样；
String:不可变字符序列，效率低，但是复用率高（因为字符串只会出现一次，后续的都会指向常量池中这唯一的一个）；
StringBuffer:可变字符序列、效率较高(增删)、线程安全；
StringBuilder: 可变字符序列、效率最高、线程不安全；
String使用注意说明:string s&#x3D;”a”; &#x2F;&#x2F;创建了一个字符串S +&#x3D; “b”; &#x2F;&#x2F;实际上原来的”a”字符串对象已经丢弃了（但还存在），现在又产生了一个字符串s+”b” (也就是” ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。结论:如果我们对String做大量修改，不要使用String

String、StringBuffer 和 StringBuilder 的应用场景
如果字符串存在大量的修改操作，-般使用StringBuffer或StringBuilder
如果字符事存在大量的修改操作，并在单线程的情况，使用StringBuilder
如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer
如果我们字符串很少修改，被多个对象引用，使用String,比如配置信息等

Math类Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。
Math常用的方法（均为静态方法）abs  求绝对值int n1 = Math.abs(-2);double n2 = Math.abs(-9.8);System.out.println(&quot;n1 = &quot; + n1 + &quot;   n2 = &quot; + n2);//n1 = 2   n2 = 9.8
pow 求幂（返回值为double）double s = Math.pow(2,3);//8.0，2的3次方
ceil 向上取整（返回大于等于该参数的最小整数，返回值依然是double）double s = Math.ceil(2.8);//3.0
floor 向下取整（返回小于等于该参数的最小整数，返回值依然是double）double s = Math.floor(2.8);//2.0
round 四舍五入（返回值为long，约等于Math.floor(该参数+0.5)？）long s = Math.round(2.8);//3
sqrt 求算数平方根（要求参数为大于等于0的非负数）double sqrt = Math.sqrt(9);//3.0
random 求随机数（返回一个大于等于0并且小于1之间的一个小数）double rand = Math.random()
扩展：求一个给定的范围之间的随机数（大于等于a , 小于等于b）
int n = (int)(a + Math.random() * (b - a + 1));
max , min 返回最大值和最小值int maxx = Math.max(2,3);//3int minn = Math.max(2,3);//2
Arrays该类的主要作用就是用于管理和操作数组（如排序、搜索等）
Arrays的常用方法toString    以字符串形式返回数组中的元素int arr[] = &#123;1,3,7,5&#125;;System.out.println(Arrays.toString(arr));//[1, 3, 7, 5]
sort排序（同c++一样，默认从小到大，也支持自定义）int arr[] = &#123;1, 3, 7, 5, -1&#125;;Arrays.sort(arr);System.out.println(Arrays.toString(arr));//[-1, 1, 3, 5, 7]
支持的数组类型：int,long,short,char,byte,float,double等。
同时，在Java中也支持sort的排序规则自定义（利用实现了Comparable接口的一个匿名内部类，要求实现 compare方法）。（ sort(T[] a , Comparator &lt;? super T&gt; c ) ）
Integer arr[] = &#123;1, 3, 7, 5, -1&#125;;//注意这里一定要是Integer,不能是int数组Arrays.sort(arr,new Comparator()&#123;  public int compare(Object o1,Object o2)&#123;    Integer i1 = (Integer) o1;    Integer i2 = (Integer) o2;    return i2-i1;  &#125;&#125;);System.out.println(Arrays.toString(arr));//[7, 5, 3, 1, -1]
binarySearch    通过二分搜索法进行查找，要求必须排好序Integer arr[] = &#123;1, 3, 7, 5, -1&#125;;//注意这里一定要是Integer,不能是int数组Arrays.sort(arr);//因为查找是基于二分的，所以要求序列有序.[-1, 1, 3, 5, 7]int index;//index = Arrays.binarySearch(arr, 5);//3index = Arrays.binarySearch(arr, 0);//-2//这个方法的一个特点就是，如果找不到，就返回这个数应该在的位置，并置为负数。简单的说就是返回左右指针相等的那个值的负数
copyOf    数组元素复制Integer arr[] = &#123;1, 3, 7, 5, -1&#125;;//注意这里一定要是Integer,不能是int数组Integer num[] = Arrays.copyOf(arr,arr.length);//从arr数组复制，复制arr.length个元素System.out.println(arr == num);//F，这是两个除了值一样其余完全不相干的数组System.out.println(Arrays.equals(arr,num));//T
fill 数组元素填充Integer arr[] = &#123;1, 3, 7, 5, -1&#125;;//注意这里一定要是Integer,不能是int数组Arrays.fill(arr,0);//全部填充System.out.println(Arrays.toString(arr));//[0, 0, 0, 0, 0]Arrays.fill(arr,1,3,2);//将数组arr中从下标1（包含）到3（不包含）的元素的值填充为2.System.out.println(Arrays.toString(arr));//[0, 2, 2, 0, 0]
equals 比较两个数组元素的内容是否完全一 致int arr1[] = &#123;1,2,3&#125;;int arr2[] = &#123;1,2,3&#125;;System.out.println(Arrays.equals(arr1,arr2));//T//需要注意两个数组的类型必须一样，哪怕一个是int一个是Integer都不行
asList 将一组值，转换成list
asList 方法，会将数组中的数据转成一个 List 集合
返回的 asList 编译类型 List（是接口）
asList 运行类型 java.util.Arrays#ArrayList, 是 Arrays 类的一个静态内部类 private static class ArrayList extends AbstractList implements RandomAccess, java.io.Serializable

Arrays项目：将自定义类型用sort的形式进行排序package net.hurr.annotation_;import java.util.Arrays;import java.util.Comparator;public class Test &#123;    public static void main(String[] args) &#123;        Book books[] = new Book[4];        books[0] = new Book();        books[0].setName(&quot;红楼梦&quot;);        books[0].setPricr(100.0);        books[1] = new Book();        books[1].setName(&quot;知音漫客&quot;);        books[1].setPricr(90.0);        books[2] = new Book();        books[2].setName(&quot;青年文摘&quot;);        books[2].setPricr(5.0);        books[3] = new Book();        books[3].setName(&quot;Java 从入门到入土&quot;);        books[3].setPricr(900.0);        Arrays.sort(books, new Comparator&lt;Book&gt;() &#123;            @Override            public int compare(Book o1, Book o2) &#123;                if (o2.getPricr() &gt; o1.getPricr()) &#123;                    return 1;                &#125;                else if (o2.getPricr() == o1.getPricr()) &#123;                    return 0;                &#125;                else &#123;                    return -1;                &#125;            &#125;        &#125;);        System.out.println(Arrays.toString(books));    &#125;&#125;class Book &#123;    private String name;    private Double pricr;    public Book(String name, Double pricr) &#123;        this.name = name;        this.pricr = pricr;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Double getPricr() &#123;        return pricr;    &#125;    public void setPricr(Double pricr) &#123;        this.pricr = pricr;    &#125;    public Book() &#123;    &#125;    @Override    public String toString() &#123;        return &quot;Book&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +                &quot;, pricr=&quot; + pricr +                &#x27;&#125;&#x27;;    &#125;&#125;//[Book&#123;name=&#x27;Java 从入门到入土&#x27;, pricr=900.0&#125;, Book&#123;name=&#x27;红楼梦&#x27;, pricr=100.0&#125;, Book&#123;name=&#x27;知音漫客&#x27;, pricr=90.0&#125;, Book&#123;name=&#x27;青年文摘&#x27;, pricr=5.0&#125;]
SystemSystem常用的方法exit    退出当前程序System.exit(-1);//括号中的参数代表一个状态，一般来说都写0，代表正常退出。反映在“进程已结束,退出代码0”
arraycopy :复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成数组的复制。
该方法的五个参数如下所示
@param    src    the source array .     源数组的地址@param    srcPos    starting position in the source array .        从源数组的第几个位置开始拷贝@param    dest    the destination array。    目标数组的地址@param    destPos    starting position in the destination data.    拷贝到目标数组的哪个位置@param    Length     the number of array elements to be copied。    从源数组拷贝多少个元素到目标数组。不能超过源数组长度

int num[] = &#123;1, 2, 3&#125;;int arr[] = new int[5];System.arraycopy(num, 0, arr, 0, 3);System.out.println(Arrays.toString(arr));//[1, 2, 3, 0, 0]
currentTimeMillens    返回当前时间距离1970-1-1的毫秒数System.out.println(System.currentTimeMillis());
gc    运行垃圾回收机制System.gc();
BigInteger 和 BigDecimal 类应用场景:

如果一个数非常大，大到长整型都装不下的时候，就可以利用 BigInteger 或 BigDecimald进行处理存储
BigInteger适合保存比较大的整型
BigDecimal适合保存精度更高的浮点型(小数)
在对大数进行加减乘除的时候，需要使用其对应的的方法处理，不能直接相加。

BigInteger 和 BigDecimald的常用方法add    加BigInteger bigInteger1 = new BigInteger(&quot;12312312312312312312312123123123&quot;);BigInteger bigInteger2 = new BigInteger(&quot;12312312312312312312312123123123&quot;);System.out.println(bigInteger1);bigInteger1 = bigInteger1.add(bigInteger2);System.out.println(bigInteger1);/*1231231231231231231231212312312324624624624624624624624246246246*/
subtract    减BigInteger bigInteger1 = new BigInteger(&quot;24624624624624624624624246246246&quot;);BigInteger bigInteger2 = new BigInteger(&quot;12312312312312312312312123123123&quot;);System.out.println(bigInteger1);bigInteger1 = bigInteger1.subtract(bigInteger2);System.out.println(bigInteger1);/*2462462462462462462462424624624612312312312312312312312123123123*/
multiply    乘BigInteger bigInteger1 = new BigInteger(&quot;12312312312312312312312123123123&quot;);BigInteger bigInteger2 = new BigInteger(&quot;12312312312312312312312123123123&quot;);System.out.println(bigInteger1);bigInteger1 = bigInteger1.multiply(bigInteger2);System.out.println(bigInteger1);/*12312312312312312312312123123123151593034475917358800237024411796154713271830424740055417273129*/
divide    除BigInteger bigInteger1 = new BigInteger(&quot;151593034475917358800237024411796154713271830424740055417273129&quot;);BigInteger bigInteger2 = new BigInteger(&quot;12312312312312312312312123123123&quot;);System.out.println(bigInteger1);bigInteger1 = bigInteger1.divide(bigInteger2);System.out.println(bigInteger1);/*15159303447591735880023702441179615471327183042474005541727312912312312312312312312312123123123*/
日期类第一代日期类 Date (java.util.Date)精确到毫秒，代表特定的瞬间

Date d1 = new Date(); //获取当前系统时间，即从1970年1月1日到现在经过了多少毫秒System.out.println(&quot;当前日期=&quot; + d1);//默认输出的日期格式为英文状态的星期 月份 天 时间 年份。即Sat May 28 17:21:19 CST 2022Date d2 = new Date(9234567); //通过指定毫秒数得到时间System.out.println(&quot;d2=&quot; + d2); //显示通过毫秒数创建的日期
SimpleDateFormat 格式化和解析日期Date d1 = new Date(); //获取当前系统时间System.out.println(d1);//因为默认的格式不便于读写，可以通过SimpleDateForma类对Date对象进行格式化//创建一个SimpleDateFormat对象，可以指定相应的格式。如年月日时分秒星期。SimpleDateFormat SDF = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss E a&quot;);System.out.println(SDF.format(d1));//格式化后输出当前的日期，2022年05月28日 18:03:01 周六 下午//2022年05月28日 05:30:02 周六




字母
日期或时间元素
表示
示例



G
Era标志符
Text
AD


y
年
Year
1996；96（四位&#x2F;两位）


M
月
Month
July；Jul；07


w
一年中的第几周
Number
27


W
一个月中的第几周
Number
2


D
一年中的第几天
Number
189


d
一个月中的第几天
Number
10


F
一个月中的第几个星期
Number
2


E
星期几
Text
周六


a
am&#x2F;pm标记
Text
PM；下午


H
小时（0-23）
Number
0


k
小时（1-24）
Number
24


K
am&#x2F;pm中的小时（0-11）
Number
0


h
am&#x2F;pm中的小时（1-12）
Number
12


m
分钟
Number
30


s
秒
Number
55


S
毫秒
Number
998


z
时区
Genera1 time zone
Pacific Standard Time; PST; GMT-08:00


Z
时区
RFC 822 time zone
-0800


第二代日期类，主要就是Calendar类(日历)。Calendar类是一个抽象类，它为特定瞬间与组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。

Calendar的说明
Calendar 是一个抽象类， 并且构造器是 private，如果需要创建对象，需要通过 getInstance() 来获取实例；
Calendar c = Calendar.getInstance();
提供大量的方法和字段，如果需要获取某个字段，可以参照如下格式；
c.get(Calendar.字段名);
Calendar 没有提供对应的格式化的类，因此需要自己组合来输出（灵活）；
Calendar c = Calendar.getInstance();System.out.println(&quot;年：&quot;+c.get(Calendar.YEAR));System.out.println(&quot;月：&quot;+(c.get(Calendar.MONTH)+1));//因为月是从0开始编号的System.out.println(&quot;日：&quot;+c.get(Calendar.DAY_OF_MONTH));System.out.println(&quot;时：&quot;+c.get(Calendar.HOUR));System.out.println(&quot;分：&quot;+c.get(Calendar.MINUTE));System.out.println(&quot;秒：&quot;+c.get(Calendar.SECOND));/*年：2022月：5日：28时：7分：57秒：43*/
如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR &#x3D;&#x3D;改成&#x3D;&gt; Calendar.HOUR_OF_DAY


第三代日期类JDK 1.0中包含了一个java.util.Date类,但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar也存在问题是:


可变性:像日期和时间这样的类应该是不可变的。
偏移性: Date中的年份是从1900开始的， 而月份都从0开始。
格式化:格式化只对Date有用，Calendar则不行。
此外，它们也不是线程安全的;不能处理闰秒等(每隔2天，多出1s)。

因此，在JDK8引入了新的类：
LocalDate(日期&#x2F;年月日)、LocalTime(时间&#x2F;时分秒)、LocalDateTime(日期时间&#x2F;年月日时分秒)
LocalDate只包含日期，可以获取日期字段LocalTime只包含时间，可以获取时间字段LocalDateTime包含日期+时间，可以获取日期和时间字段
LocalDateTime的常用方法以及通过DateTimeFormatter格式化输出//1、使用now返回当前的日期时间，返回值是一个LocalDateTime的对象LocalDateTime ldt = LocalDateTime.now();//LocalDate和LocalTime也有now方法，可以分别获取当前的日期和时间System.out.println(ldt);//2022-05-28T20:11:25.378881600//2、单独提取现在的年月日时分秒System.out.println(&quot;年：&quot;+ldt.getYear());System.out.println(&quot;月：&quot;+ldt.getMonth());System.out.println(&quot;日：&quot;+ldt.getDayOfMonth());System.out.println(&quot;时：&quot;+ldt.getHour());System.out.println(&quot;分：&quot;+ldt.getMinute());System.out.println(&quot;秒：&quot;+ldt.getSecond());//3、格式化显示：依靠DateTimeFormatter。整个过程类似于SimpleDateFormat,但还有更多的功能。具体见手册中DateTimeFormatter部分DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);System.out.println(dtf.format(LocalDateTime.now()));
Instant 时间戳类似于Date，提供了一系列和Date类转换的方式：
获取当前的时间戳Instant now = Instant.now();//利用Instant类的now方法（静态）获取当前的时间戳System.out.println(now);//2022-05-28T12:32:09.611215Z
Instant 转 DateDate date = Date.from(instant);
Date 转 Instant:Instant instant = date.tolnstant();
案例演示:Instant now &#x3D; Instant. now0;System. out.println(now);Date date &#x3D; Date. from(now);Instant instant &#x3D; date.tolnstant();
常用的LocalDateTime方法plus  过多少
集合集合解决了数组的一些局限性，比如：

长度开始时必须指定，而且一旦指定，不能更改；
保存的必须为同类型的元素；
使用数组进行增加&#x2F;删除元素比较麻烦；

集合的特点
可以动态保存任意多个对象（不限类型），使用比较方便；
提供了一系列方便的操作对象的方法: add、remove. set. get（增删改查）等；
使用集合添加,删除新元素简洁明了；

集合的框架体系集合主要分为两组，根据实现的接口不同分别是单列集合和双列集合，他们分别存储了一个元素或一个具有两个元素的键值对。
其中的单列集合Collection接口继承了Iterator类


实现了Collection 接口（单列）的子类的特点
collection实现子类可以存放多个元素，每个元素可以是0bject；
有些Collection的实现类，可以存放重复的元素，有些不可以；
有些Collection的实现类，有些是有序的(List，即存入的顺序和读取的顺序一致),有些不是有序(Set，即存入顺序和读出的顺序并不相同)；
Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的；

Collection 接口的常用方法(以ArrayList进行演示)
创建集合
List list = new ArrayList();//创建一个ArrayList集合，用List接口进行接收，本段演示均基于这个集合
add:添加单个元素
list.add(&quot;Hello&quot;);//只要是基于Object的对象都可以放入，换句话说就是可以放入所有的对象list.add(10);//放入基本数据类型会自动装箱成为一个对应包装类的对象list.add(true);System.out.println(&quot;list = &quot; + list);//list = [Hello, 10, true]
remove:删除指定元素
String s = (String)list.remove(0);//可以删除指定第几个（从0起），如果使用索引删除则返回被删除的对象System.out.println(s);//Helloboolean b = list.remove(new Integer(10));//如果删除的是指定的对象的话，返回的就是是否删除成功System.out.println(b);//trueb = list.remove(new Integer(11));//删除一个不存在的对象System.out.println(b);//falseSystem.out.println(&quot;list = &quot; + list);//list = [true]
contains:查找元素是否存在
if (list.contains(true)) &#123;//查找list里面是否存在一个true的对象，返回值为布尔型    System.out.println(&quot;存在&quot;);&#125;else&#123;    System.out.println(&quot;不存在&quot;);&#125;if (list.contains(false)) &#123;//查找list里面是否存在一个true的对象，返回值为布尔型    System.out.println(&quot;存在&quot;);&#125;else&#123;    System.out.println(&quot;不存在&quot;);&#125;//执行结果：//存在//不存在
size:获取元素个数
System.out.println(list.size());//获取当前list的个数，并输出出来，结果是1
isEmpty:判断是否为空
System.out.println(&quot;list集合是空的吗 &quot; + list.isEmpty());//判断集合是否为空//list集合是空的吗 false
clear:清空
list.clear();//清空整个集合的元素System.out.println(&quot;list集合是空的吗 &quot; + list.isEmpty());//然后再判断一下集合是否为空//list集合是空的吗 true
addAll:添加多个元素
ArrayList arrayList = new ArrayList();//临时创建一个集合并存入一些元素arrayList.add(&quot;hello&quot;);arrayList.add(&quot;hurriedlu&quot;);arrayList.add(100);list.addAll(arrayList);//只要是实现了Collection接口的对象都可以被添加进来。System.out.println(&quot;list = &quot; + list);//list = [hello, hurriedlu, 100]
containsAll:查找(判断)多个元素是否都存在，只要有一个元素不存在就返回false
//判断arrayList中所有的元素是否都存在，这个arrayList可以是任何实现了Collection接口的对象。System.out.println(list.containsAll(arrayList));//truelist.remove(new Integer(100));//删除掉一个元素再判断System.out.println(list.containsAll(arrayList));//false
removeAll：删除多个元素。只要有一个被删掉就返回true
list.add(&quot;hurriedlu&quot;);//添加一个存在的list.add(&quot;hurr&quot;);//添加一个之前不存在的// 删除和arrayList有关的元素，并输出一下结果.System.out.println(list.removeAll(arrayList));//true//看一下剩余的对象System.out.println(&quot;list = &quot; + list);//list = [hurr]





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>Java</tag>
        <tag>基础教程</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法与数据结构</title>
    <url>/2024/02/28/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[基础算法排序快速排序思想：基于分治。
确定分界点。在数组中随便找一个值，以划分出左右两堆数；

常见方法

直接取左边界，即q[ l ]；（边界不能是i）
直接取中间值，即q[ ( l + r ) &#x2F; 2 ]；
直接取右边界，即q[ r ]；（边界不能是j）
也可以直接随机一个值



调整区间。使得第一步确定的分界点x左边的区间全部 ≤ x，右边区间全部 ≥ x；


方法1，思想简单但需要额外空间。比较暴力，需要两个额外空间，但时间复杂度还好，是线性的
需要两个额外的数组 a[ ] , b[ ]；
扫描整个数组q[ l ~ r ]，若 q[ i ] &lt;&#x3D; x ，则将q [ i ] 存入a [] 数组，否则存入b[ ]数组；
先将数组a[ ]中的所有数据存取q[ ]，然后将数组b[ ]中的所有数据存入q[ ]；
方法2，时间复杂度空间复杂度都很好
需要两个额外的数组指针，设这两个指针为 i ， j，并将指针 i 指向数组的最左边，指针 j 指向数组的最右边。
判断指针 i 是否大于 x ，如果不大于，指针后移，直到找到第一个大于 x 的地方；
同理判断指针 j 是否小于 x ，如果小于，指针前移，直到找到第一个小于 x 的地方；
交换指针 i 和 j 指向空间的数据；
重复2 - 4步，直到指针 i j 相遇为止



递归处理左右两端，使得左右区间全部有序


实现代码：对数组进行排序模板void qsort(int nums[], int l, int r) &#123;    if (l &gt;= r)        return;    int x = nums[(l + r) / 2];    int i = l - 1;    int j = r + 1;    while (i &lt; j) &#123;        do &#123;            i++;        &#125; while (nums[i] &lt; x);        do &#123;            j--;        &#125; while (nums[j] &gt; x);        if (i &lt; j)            swap(nums[i], nums[j]);    &#125;    qsort(nums, l, j);    qsort(nums, j + 1, r);&#125;

C&#x2F;C++：#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;int n, nums[N];/// &lt;summary&gt;/// 快速排序，范围要求是左开右闭/// &lt;/summary&gt;/// &lt;param name=&quot;nums&quot;&gt;要排序的数组&lt;/param&gt;/// &lt;param name=&quot;l&quot;&gt;左边界（开始迭代器）&lt;/param&gt;/// &lt;param name=&quot;r&quot;&gt;右边界（结束迭代器）&lt;/param&gt;void qsort(int nums[], int l, int r) &#123;    if (l &gt;= r)//如果当左右边界相等的时候，证明已经递归到当前区域只有一个元素，也就表示当前区域已经有序了，可以直接退出        return;    int x = nums[(l + r) / 2];//随便选一个数当作分界点    int i = l - 1;//生成本轮循环的左边界（要求各多算一个）    int j = r + 1;//生成本轮循环的右边界（要求各多算一个）    while (i &lt; j) &#123;//开始本轮循环 要求左右边界不能碰面        do &#123;//必须要do while,先++后判断            i++;        &#125; while (nums[i] &lt; x);        do &#123;//同理 先--后判断            j--;        &#125; while (nums[j] &gt; x);        if (i &lt; j)//可能会有越界的行为，因此在交换前需要先判断            swap(nums[i], nums[j]);    &#125;    qsort(nums, l, j);//递归循环左边界，分界点一定要是j而不能是i    qsort(nums, j + 1, r);//递归循环右边界&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 0; i &lt; n; i++) &#123;        scanf(&quot;%d&quot;, &amp;nums[i]);    &#125;    qsort(nums, 0, n - 1);    for (int i = 0; i &lt; n; i++) &#123;        printf(&quot;%d &quot;, nums[i]);    &#125;    return 0;&#125;

Javapackage sort;import java.util.ArrayList;import java.util.Arrays;import java.util.Scanner;public class Main &#123;    private static final int N = 100000;    public static int n;    public static int num[] = new int[N];    public static void qsort(int nums[],int l,int r)&#123;        if (l &gt;= r)//如果当左右边界相等的时候，证明已经递归到当前区域只有一个元素，也就表示当前区域已经有序了，可以直接退出            return;        int x = nums[(l + r) / 2];//随便选一个数当作分界点        int i = l - 1;//生成本轮循环的左边界（要求各多算一个）        int j = r + 1;//生成本轮循环的右边界（要求各多算一个）        while (i &lt; j) &#123;//开始本轮循环 要求左右边界不能碰面            do &#123;//必须要do while,先++后判断                i++;            &#125; while (nums[i] &lt; x);            do &#123;//同理 先--后判断                j--;            &#125; while (nums[j] &gt; x);            if (i &lt; j)//可能会有越界的行为，因此在交换前需要先判断            &#123;                int t = nums[i];                nums[i] = nums[j];                nums[j] = t;            &#125;        &#125;        qsort(nums, l, j);//递归循环左边界，分界点一定要是j而不能是i        qsort(nums, j + 1, r);//递归循环右边界    &#125;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        n = scanner.nextInt();        for (int i = 0;i &lt; n;i++)&#123;            num[i] = scanner.nextInt();        &#125;        qsort(num, 0, n - 1);        //System.out.println(Arrays.toString(num));        for (int i = 0;i &lt; n;i++)&#123;            System.out.print(num[i] + &quot; &quot;);        &#125;    &#125;&#125;

归并排序思想：依然是分治但具体实现的方式与快排不相同

确定in数。
递归排序左右两边
归并。把两个有序的数组合并成一个数组

实现代码：对数组进行排序模板void merge_sort(int q[], int l, int r)&#123;    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);    int k = 0, i = l, j = mid + 1;    while (i &lt;= mid &amp;&amp; j &lt;= r)        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];        else tmp[k ++ ] = q[j ++ ];    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];&#125;

C&#x2F;C++#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;int n, nums[N], tmp[N];//数据长度，数据，辅助数组/// &lt;summary&gt;/// 归并排序/// &lt;/summary&gt;/// &lt;param name=&quot;nums&quot;&gt;要排序的数组&lt;/param&gt;/// &lt;param name=&quot;l&quot;&gt;左边界&lt;/param&gt;/// &lt;param name=&quot;r&quot;&gt;右边界&lt;/param&gt;void mergeSort(int nums[], int l, int r) &#123;    if (l &gt;= r)//当当前区域只有一个甚至一个元素都没有的时候，这个区域就有序了，可以退出了        return;    int mid = l + r &gt;&gt; 1;//算出整个数据的中间位置    //开始递归排序左右两边          mergeSort(nums, l, mid);    mergeSort(nums, mid + 1, r);    //开始归并到辅助数组    int k = 0;//存储当前进度    int i = l, j = mid + 1;//两个区域的首地址    while (i &lt;= mid &amp;&amp; j &lt;= r) &#123;        if (nums[i] &lt; nums[j])            tmp[k++] = nums[i++];        else            tmp[k++] = nums[j++];    &#125;    //进行扫尾，将剩余元素全部直接接到辅助数组的末尾    while (i &lt;= mid)        tmp[k++] = nums[i++];    while (j &lt;= r)        tmp[k++] = nums[j++];    //将辅助数组中的数据复制到原始数组中    for (int i = l, j = 0; i &lt;= r; i++, j++) &#123;        nums[i] = tmp[j];    &#125;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 0; i &lt; n; i++) &#123;        scanf(&quot;%d&quot;, &amp;nums[i]);    &#125;    mergeSort(nums, 0, n - 1);    for (int i = 0; i &lt; n; i++) &#123;        printf(&quot;%d &quot;, nums[i]);    &#125;    return 0;&#125;

应用第K个数&#x2F;第K小的数（快排+二分）
第k个数给定一个长度为 n 的整数数列，以及一个整数 k，请用快速选择算法求出数列从小到大排序后的第 k 个数。
输入格式第一行包含两个整数 n 和 k。
第二行包含 n 个整数（所有整数均在 1∼10^9^ 范围内），表示整数数列。
输出格式输出一个整数，表示数列的第 k 小数。
数据范围1≤n≤1000001≤k≤n
输入样例：5 32 4 1 5 3

输出样例：3
思路
首先这个数是否存在比较好判断（如果k大于n，直接报错即可），并且此题目保证了k ≤ n
在快排的时候，每次快排完成都可以使key左边的都比key小，右边的都比key大。因此，key的位置x就是整个序列中第x小的数。
快排完事之后递归之前，计算一下key的位置，看是否大于de

实现代码#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, k, num[N];int findKth(int num[], int l, int r, int k)&#123;    //基础的快排部分    if (l &gt;= r)        return num[l];    int key = num[l + r &gt;&gt; 1];    int i = l - 1;    int j = r + 1;    while (i &lt; j)    &#123;        do i++; while (num[i] &lt; key);        do j--; while (num[j] &gt; key);        if (i &lt; j) swap(num[i], num[j]);    &#125;    //快排之后得出一个序列，key左边的都比key小，右边的都比key大。此时，key这个数的位置，就是key在序列中的位置    int lcnt = j - l + 1;//计算出key的位置。位置等于k的位置减去左边界    if (k &lt;= lcnt)//如果要找到数在key的位置的前面，或者就是key        return findKth(num, l, j, k);//递归查找左边界到key这段距离    else//否则答案的位置就在key的右侧（不包括key）。递归查找key下一个位置到右边界的区间        return findKth(num, j + 1, r, k - lcnt);//假设要查找第7小的数，已经找到第5小的了，只需要在第六小开始的位置找出第2小的就行&#125;int main()&#123;    scanf_s(&quot;%d%d&quot;, &amp;n, &amp;k);    for (int i = 0; i &lt; n; i++) scanf_s(&quot;%d&quot;, &amp;num[i]);    cout &lt;&lt; findKth(num, 0, n - 1, k) &lt;&lt; endl;    return 0;&#125;

小结
虽然快排和归并都是nlgn级别的复杂度，但这是在宏观上的量级，在使用的时候，一般来说快排比归并快了两到三倍。

二分整数二分思想：本质是找边界给定一个区间，在这个区间上定义了某种性质，使得这个性质在整个范围的右半边是满足的，在左半边是不满足的；（即利用这个性质可以将整个范围一分为二）


```![image-20220628124834662](./Image/Other/image-20220628124834662.png)查找边界1：1. 首先还是计算出mid的值，mid = (l+r) / 2;2. 检查获取到的mid的值 if ( check( mid )  ) 看是否成立   1. 若为true，则表示mid的位置可能是答案，因此范围缩小至 [ mid , r ]；因此更新方式为  l = mid ;   2. 若为false，则表示在答案在 l 到 mid - 1 （因为是整数二分，数是离散的）; 因此更新方式为 r = mid -1;查找边界2：1. 首先还是计算出mid的值，mid = (l+r) / 2;2. 检查获取到的mid的值 if ( check( mid )  ) 看是否成立   1. 若为true，则表示mid的位置可能是答案，因此范围缩小至 [ l , mid ]；因此更新方式为  r = mid ;   2. 若为false，则表示在答案在 [ mid+1 , r ]  ; 因此更新方式为 l = mid + 1;简单的说就是根据查找边界的不同，mid的更新是下取整还是上取整。#### 模板```c整数二分算法模板 —— 模板题 AcWing 789. 数的范围bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质//前边界// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch_1(int l, int r)&#123;    while (l &lt; r)    &#123;        int mid = l + r &gt;&gt; 1;        if (check(mid)) r = mid;    // check()判断mid是否满足性质        else l = mid + 1;    &#125;    return l;//如果保证必然有解，可以输出，否则需要判断一下当前的l的位置是否是要找的数&#125;//后边界// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：int bsearch_2(int l, int r)&#123;    while (l &lt; r)    &#123;        int mid = l + r + 1 &gt;&gt; 1;//对mid进行上取整        if (check(mid)) l = mid;        else r = mid - 1;    &#125;    return l;&#125;

模板的使用说明
如果说要查找的数是唯一的，或者随便一个等值的，则两个模板随便一个就行。
如果需要查找的数（或者相关的数据）是这些个等值的数列的第一个，则需要用第一个模板（mid下取整），反之需要用第二个模板。

例题
数的范围给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。
对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。
如果数组中不存在该元素，则返回 -1。
输入格式第一行包含整数 n 和 q，表示数组长度和询问个数。
第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。
接下来 q 行，每行包含一个整数 k，表示一个询问元素。
输出格式共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。
如果数组中不存在该元素，则返回 -1。
数据范围1≤n≤1000001≤q≤100001≤k≤10000
输入样例：6 31 2 2 3 3 4345

输出样例：3 45 5-1 -1
实现代码#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;//数据量int n, m, x, num[N];//升序排序序列的长度，询问次数，询问的元素的值，存储序列的数组/// &lt;summary&gt;/// 基于循环的二分查找，用于查找这个区间的左边界。/// &lt;/summary&gt;/// &lt;param name=&quot;l&quot;&gt;要查找的序列的起始位置&lt;/param&gt;/// &lt;param name=&quot;r&quot;&gt;要查找的序列的结束位置（长度）&lt;/param&gt;/// &lt;param name=&quot;x&quot;&gt;要查找的值&lt;/param&gt;/// &lt;returns&gt;查找到的下标&lt;/returns&gt;int find1(int l, int r, int x)&#123;    while (l &lt; r)//只要左边界与右边界不相等，就证明这个范围内的数不止一个，可以继续循环    &#123;        int mid = l + r &gt;&gt; 1;//计算mid，下取整        if (num[mid] &gt;= x)//如果mid的值大于等于查找的值，就证明答案可能在左边界到mid的位置            r = mid;//缩小右边界，因为mid的位置可能是答案，所以r = mid        else//如果不满足条件，就证明答案在mid的右边，并且mid的位置不会是答案            l = mid + 1;//因此缩小左边界，到全部都是可能是答案的新的左边界    &#125;    if (num[l] == x)//循环完事，检查一下找到的数据是否满足要求        return l;//满足，就输出要求的下标    else        return -1;//不满足，证明没有找到，直接输出-1.&#125;/// &lt;summary&gt;/// 基于递归的二分查找，用于查找这个区间的左边界/// &lt;param name=&quot;l&quot;&gt;要查找的序列的起始位置&lt;/param&gt;/// &lt;param name=&quot;r&quot;&gt;要查找的序列的结束位置（长度）&lt;/param&gt;/// &lt;param name=&quot;x&quot;&gt;要查找的值&lt;/param&gt;/// &lt;returns&gt;查找到的下标&lt;/returns&gt;int find3(int l, int r, int x)&#123;    if (l == r)        if (num[l] == x)            return l;        else            return -1;    int mid = l + r &gt;&gt; 1;    if (num[mid] &gt;= x)        find3(l, mid, x);    else        find3(mid + 1, r, x);&#125;/// &lt;summary&gt;/// 基于循环的二分查找，用于查找这个区间的右边界。/// &lt;/summary&gt;/// &lt;param name=&quot;l&quot;&gt;要查找的序列的起始位置&lt;/param&gt;/// &lt;param name=&quot;r&quot;&gt;要查找的序列的结束位置（长度）&lt;/param&gt;/// &lt;param name=&quot;x&quot;&gt;要查找的值&lt;/param&gt;/// &lt;returns&gt;查找到的下标&lt;/returns&gt;int find2(int l, int r, int x)&#123;    while (l &lt; r)    &#123;        int mid = l + r + 1 &gt;&gt; 1;//查找右边界的时候需要上取整        if (num[mid] &lt;= x)//查找右边界，如果说答案大于等于mid的位置，就收缩左边界到mid            l = mid;        else            r = mid - 1;//否则就证明答案在小于mid的位置，收缩右边界    &#125;    if (num[l] == x)        return l;    else        return -1;&#125;/// &lt;summary&gt;/// 基于循环的循环查找，用于查找这个区间的右边界。/// &lt;/summary&gt;/// &lt;param name=&quot;l&quot;&gt;要查找的序列的起始位置&lt;/param&gt;/// &lt;param name=&quot;r&quot;&gt;要查找的序列的结束位置（长度）&lt;/param&gt;/// &lt;param name=&quot;x&quot;&gt;要查找的值&lt;/param&gt;/// &lt;returns&gt;查找到的下标&lt;/returns&gt;int find4(int l, int r, int x)&#123;    if (l == r)        if (num[l] == x)            return l;        else            return -1;    int mid = l + r + 1 &gt;&gt; 1;    if (num[mid] &lt;= x)        find4(mid, r, x);    else        find4(l, mid - 1, x);&#125;int main()&#123;    scanf_s(&quot;%d%d&quot;, &amp;n, &amp;m);//获取序列的长度和询问的次数    for (int i = 0; i &lt; n; i++)//读入序列    &#123;        scanf_s(&quot;%d&quot;, &amp;num[i]);    &#125;    while (m--)//开始询问    &#123;        scanf_s(&quot;%d&quot;, &amp;x);//读入询问的数值        cout &lt;&lt; find3(0, n - 1, x) &lt;&lt; &quot; &quot; &lt;&lt; find4(0, n - 1, x) &lt;&lt; endl;//调用函数运算并直接输出    &#125;    return 0;&#125;

浮点二分同上面的整数二分类似，而且更加简单，因为不用考虑边界问题。如下例题：利用二分的方法求出一个数的三次方根。
为什么可行：

首先一个数的三次方根是必然存在的
其次三次方是具有单调性的（偶数次方也可以二分，二分的左边界是0）


数的三次方根给定一个浮点数 n，求它的三次方根。
输入格式共一行，包含一个浮点数 n。
输出格式共一行，包含一个浮点数，表示问题的解。
注意，结果保留 6 位小数。
数据范围−10000 ≤ n ≤ 10000
输入样例：1000.00

输出样例：10.000000
#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;double n;/// &lt;summary&gt;/// 利用二分查找找出一个数的三次方根/// &lt;/summary&gt;/// &lt;param name=&quot;n&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;double binarySearch(double n)&#123;    double l = -10000, r = 10000;//设置左右边界    while (fabs(l - r) &gt;= 0.0000001)//算出的精度要比要求的精度多至少1位，因为存在四舍五入。    &#123;        double mid = (l + r) / 2;//获取mid的值        if (mid * mid * mid &gt;= n)//判断计算出来的值是大了还是小了            r = mid;//如果大了，就证明答案在mid左边，收缩右边界        else            l = mid;//否则就在mid的右边，收缩左边界    &#125;    //因为浮点数不是精确的数，不存在绝对边界，因此不需要边界判断    return l;//因为必然有解，所以可以直接返回&#125;int main()&#123;    scanf(&quot;%lf&quot;, &amp;n);//读入    printf(&quot;%.6lf&quot;, binarySearch(n));//计算并输出    return 0;&#125;

用二分法求算数根的好处：
精度可以做到非常高，而用pow()函数进行求解的话最高精度只能做到小数点后六位。
效率高，二分的时间复杂度是logn

高精度大整数：一个长度在10^6^的数；
普通数：数值小于10^9^的一个数；
大整数的实现（存储）：把大整数的每一位都存入到数组中，利用数组进行逐位存储 。
整个大整数的运算是一种模拟的体现，通过模拟我们手动运算的方法实现的。
两个大整数相加具体实现思想：
将两个大数均以倒序的形式存储到数组中，以便实现运算过程的进位问题。如一个数是“123456789“，则在存储的时候，下标为0的位置存储的是”9“，下标为1的位置存储的是”8“，下标为8的位置存储的是”1“
设一个临时遍历 t，并置初值为0，用于存储每一位相加后的值。
从下标0到数组长度-1开始，逐位读取并相加两个数组的当前位置（如果有）
将两个数相加完成后的值模除10（对10取余）后存入到答案数组，然后t除以10去掉已经存入答案的值后，剩余的值进入下轮循环继续参与运算

实现代码模板
//高精度加法 —— 模板题 AcWing 791. 高精度加法// C = A + B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; add(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;    vector&lt;int&gt;C;    int t = 0;    for (int i = 0; i &lt; A.size() || i &lt; B.size(); i++) &#123;        if (i &lt; A.size()) t += A[i];        if (i &lt; B.size()) t += B[i];        C.push_back(t % 10);        t = t / 10;    &#125;    if (t != 0 )        C.push_back(t);    return C;&#125;

使用stl库#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; add(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;//之所以用引用是因为引用传入的是一个地址，如果不加引用符号则需要把A、B全部复制一遍    vector&lt;int&gt;C;    int t = 0;//进位辅助的临时变量，只需要在开始置0即可    for (int i = 0; i &lt; A.size() || i &lt; B.size(); i++) &#123;        if (i &lt; A.size()) t += A[i];//要是没超过A的位置，或者说是当运行和到这一位的时候，A数组中仍然有值，就加上A[i]；        if (i &lt; B.size()) t += B[i];//同理        C.push_back(t % 10);//将临时变量模除10后存入答案数组，因为是10进制运算所以这个地方要模除10        t = t / 10;//将存入的值删除后，剩余的值继续参与下轮循环    &#125;    if (t != 0 )//要是t不空 证明还有进位没有存入到答案数组        C.push_back(t);    return C;&#125;int main() &#123;    string a, b;//利用string实现大数的一个读入    vector&lt;int&gt;A, B;//之所以用vector容器，是因为vector有一个size属性比较方便，且没有位数的限制    cin &gt;&gt; a &gt;&gt; b;//读入a,b    //逆序存入    for (int i = a.size() - 1; i &gt;= 0; i--)        A.push_back(a[i] - &#x27;0&#x27;);//逆序存入到vector数组    for (int i = b.size() - 1; i &gt;= 0; i--)        B.push_back(b[i] - &#x27;0&#x27;);//逆序存入到vector数组    auto C = add(A, B);//c++11的新东西，auto。    for (int i = C.size() - 1; i &gt;= 0; i--)//因为是倒序存入，因此在读出的时候也需要倒序        printf(&quot;%d&quot;, C[i]);    return 0;&#125;

使用普通的char数组完成#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 1e6 + 10;char A[N], B[N], C[N];char * add(char A[], char B[],int lenA,int lenB) &#123;      int k = 0;    int t = 0;//辅助的临时变量，只需要在开始置0即可    //const int lenA = sizeof(A) / sizeof(char);//存储A数组的长度，后面用的时候可以不用在计算了。因为不涉及到修改，就设置成const属性   // const int lenB = sizeof(B) / sizeof(char);//同理    for (int i = 0; i &lt; lenA || i &lt; lenB; i++) &#123;        if (i &lt; lenA) t = t + A[i];//要是没超过A的位置，或者说是当运行和到这一位的时候，A数组中仍然有值，就加上A[i]。、        if (i &lt; lenB) t = t + B[i];//同理        C[i] = t % 10;        k++;        t = t / 10;//将存入的值删除后，剩余的值继续参与下轮循环    &#125;    if (t != 0)//要是t不空 证明还有进位没有存入到答案数组        C[k++] = t;//因为最多就有1位的进位    return C;&#125;int main() &#123;    string a, b;//利用string实现大数的一个读入    cin &gt;&gt; a &gt;&gt; b;//读入a,b    int k = 0;//倒序存储时记录长度的辅助变量    //逆序存入    for (int i = a.size() - 1; i &gt;= 0; i--)        A[k++] = a[i] - &#x27;0&#x27;;//之间将字符转成值存入，后续就可以不用再转换了    k = 0;//辅助变量置0以便下次使用    for (int i = b.size() - 1; i &gt;= 0; i--)        B[k++] = b[i] - &#x27;0&#x27;;    add(A, B,a.size(),b.size());//c++11的新东西，auto。    bool flag = false;//一个标志位，用于去除先导的0    for (int i = sizeof(C) / sizeof(char) - 1; i &gt;= 0; i--)//因为是倒序存入，因此在读出的时候也需要倒序    &#123;        if (flag || C[i] != 0) &#123;            printf(&quot;%d&quot;, C[i]);            flag = true;        &#125;    &#125;    return 0;&#125;

两个大整数相减具体实现思想
同大整数加法类似，都是逆序输入两个数；不同之处在于进行减法运算的时候最好进行一下判断，可以避免很大的麻烦。因为题目已经声明两个数都是正整数，因此不需要判断是否存在负数的情况。如果需要的话在输入输出阶段判断一下即可。因为任意的两个数相减都可以转换成两个数 绝对值的相加或相减；
如果大数A 小于 大数B 的话，A - B 可以转换成 （A - B) * -1;
在减法函数中，需要一个辅助标志位 t ，表示上一位数在运算过程中是否发生进位的行为，并且临时存储当前位的运算结果
将t进行修正后存入答案数组。修正方法：若 t &gt;&#x3D; 0，则直接存入，否则将t + 10 存入答案（因为是十进制）
判断t是否小于0（上一步只是相加但并未改变t） ，如果是，将 t 置 1 表示发生了进位，否则置0。
循环4，5步直到算出答案。此时答案可能存在前导0，因此需要删除。此时存在一个例外的情况就是，如果答案只有1位，哪怕这位是0也不能删除。因此条件为：如果答案位数大于1，且答案的最高位为0，就可以删除最高位。
倒序输出答案。根据第2步的判断，要不要在输出前加一个负号。

实现代码使用stl库#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;//C = A - Bvector&lt;int&gt; sub(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;//之所以用引用是因为引用传入的是一个地址，如果不加引用符号则需要把A、B全部复制一遍    vector&lt;int&gt;C;    int t = 0;//减法运算过程的借位标识符。有借位值为1，否则为0.    for (int i = 0; i &lt; A.size(); i++)//在进入这个函数的时候已经确保了A一定是大于等于B的，因此长度上以A为准即可    &#123;        t = A[i] - t;//获取被减数。如果有借位先将借位偿还        if (i &lt; B.size())//判断一下B是否有这一位，只有存在这一位的情况才需减去            t = t - B[i];//算出 被减数 减去 减数 后的值        /*if(t &gt;= 0)//如果够减,直接将答案存入        &#123;            C.push_back(t);            t = 0;        &#125;        else        &#123;            C.push_back(t+10);            t = 1;        &#125;        */        //判断是否需要进位的语句也可以写成如下样式        C.push_back((t + 10) % 10);        if (t &lt; 0)            t = 1;        else            t = 0;    &#125;    //减法运算后的结果可能存在前导0的情况，需要去除前导0    while (C.size() &gt; 1 &amp;&amp; C.back() == 0)//如果答案只有一位，哪怕这位是0也需要保留。如果位数大于1位，并且最高位为0，则最高位需要弹出    &#123;        C.pop_back();    &#125;    return C;&#125;//比较两个大整数的大小 ， 是否存在 A &gt;= Bbool cmp(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;    if (A.size() != B.size())//如果位数不同，可以根据位数进行判断        return A.size() &gt; B.size();    else//如果位数相同，则从最高位依次与下一位相比较        for (int i = A.size() - 1; i &gt;= 0; i--)//因为是逆序存储，因此判断的时候也需要逆序判断            if (A[i] != B[i])                return A[i] &gt; B[i];    //如果全部判断完都没有判断出大小，则证明两个数相等。    return true;&#125;int main() &#123;    //注意：题目声明了a b 两个数均为正整数，不存在负数的情况。如果没有声明，则需要在读入后进行一次判断，判断两个数的首位是否存在负号。如果存在则需要加一个标记。    //任意两个数相减都可以转换为两个数的绝对值相加或相减，因此如果存在负数只需要在输入输出的时候特判一下即可    string a, b;//利用string实现大数的一个读入    vector&lt;int&gt;A, B;//之所以用vector容器，是因为vector有一个size属性比较方便，且没有位数的限制    cin &gt;&gt; a &gt;&gt; b;//读入a,b    //逆序存入    for (int i = a.size() - 1; i &gt;= 0; i--)        A.push_back(a[i] - &#x27;0&#x27;);//逆序存入到vector数组    for (int i = b.size() - 1; i &gt;= 0; i--)        B.push_back(b[i] - &#x27;0&#x27;);//逆序存入到vector数组    //因为题目中有“计算结果可能为负数”，即表示，A可能小于B,因此需要判断一下    //3 - 5 可以转换为 (5 - 3) * -1 。    if (cmp(A, B))    &#123;        auto C = sub(A, B);//c++11的新东西，auto。        for (int i = C.size() - 1; i &gt;= 0; i--)//因为是倒序存入，因此在读出的时候也需要倒序            printf(&quot;%d&quot;, C[i]);    &#125;    else    &#123;        auto C = sub(B, A);        printf(&quot;-&quot;);//如果A小于B，则证明结果是负数，需要提前打出负号，并将运算改为B-A        for (int i = C.size() - 1; i &gt;= 0; i--)//因为是倒序存入，因此在读出的时候也需要倒序            printf(&quot;%d&quot;, C[i]);    &#125;    return 0;&#125;

一个大整数与一个普通整数相乘具体实现思想同大整数相加的原理类似，但实现想法相比实际笔算有些许的不同。设大数A有5位，依次是A[0]，A[1]，...，A[4]；小整数为b，答案C[0] = A[0] x b，C[1] = A[1] x b；因为是十进制的相乘，每一位数最大值是9，因此需要一个进位辅助 t ，将每一位中大于9的部分进行暂存，并在下一位运算的过程中继续参与运算，直到t空为止。



首先逆序读入；
特判一下b是否等于0，如果等于0则直接结束运算并输出一个0；
大整数的每一位依次乘上小整数，并将结果存入辅助进位的变量t，将t模除10后写入对应的答案位；
t除以10去除写入答案的值，然后继续第3步直到大整数A的每一位都运算完成；
继续将t写入答案，然后除以10，直到t &#x3D; 0为止；
逆序输出答案；

实现代码模板vector&lt;int&gt; mul(vector&lt;int&gt; A, int b) &#123;    vector&lt;int&gt; C;    int t = 0;//存储进位的辅助变量    //如果大数A没有循环完，则每次都将大数A与小数b进行相乘    //当大数循环完，但t中还有数没有写到答案中，则依然继续循环，但不再进行大数与小数的相乘    //当大数循环完，t也被清空了，就结束循环    //根据之前的程序设计，是否在此处进行前导零的删除    for (int i = 0; i &lt; A.size() || t != 0; i++) &#123;        if(i &lt; A.size())            t += A[i] * b;        C.push_back(t % 10);        t /= 10;    &#125;    	//如果没有进行特判，则在退出之前需要删除多余的前导0.（当其中小数是0时就会出现多余的前导0）	  return C;&#125;

使用stl库#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt; A, int b) &#123;    vector&lt;int&gt; C;    int t = 0;//存储进位的辅助变量    for (int i = 0; i &lt; A.size(); i++) &#123;        t += A[i] * b;        C.push_back(t % 10);        t /= 10;    &#125;    while (t) &#123;//把剩余进位继续写入        C.push_back(t % 10);        t /= 10;    &#125;    //注意 可能存在前导0的情况，需要处理掉,或者检测到b = 0 的时候，直接输出一个0.    return C;&#125;int main() &#123;    string a;    int b;    cin &gt;&gt; a &gt;&gt; b;    //这里做了下特判，因为出现多余的0的情况只在b是0的时候，当我们检测到其中一个除数是0的时候，可以直接输出0。    if (b == 0) &#123;        printf(&quot;0&quot;);        return 0;    &#125;    vector&lt;int&gt;A;    for (int i = a.size() - 1; i &gt;= 0; i--) &#123;//逆序读入        A.push_back(a[i] - &#x27;0&#x27;);    &#125;    vector&lt;int&gt; C = mul(A, b);    for (int i = C.size() - 1; i &gt;= 0; i--)//再次逆序输出        printf(&quot;%d&quot;, C[i]);    return 0;&#125;

一个大整数与一个普通整数相除具体实现思想除法比较特殊，是从最高位开始算的， 整个过程模拟笔算，



把前一位的余数*10+这一位的余数，然后除以除数，把能除的部分写入到商（答案）中，
接着把上一步得到的数模除一下除数，留下本次的余数，并参与到下次的运算。
运算结束可以根据需求反转一下
去除前导0，结束运算

实现代码模板//大数A，小数b，余数rvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r) &#123;    vector&lt;int&gt; C;//商    r = 0;//余数 引用传回      for(int i = A.size()-1; i &gt;= 0; i--)&#123;        r = r * 10 + A[i];        C.push_back(r / b);        r %= b;    &#125;       reverse(C.begin(),C.end());      //去除前导0    while(C.size()&gt;1 &amp;&amp; C.back() == 0)        C.pop_back();      return C;&#125;

使用stl库#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;//大数A，小数b，余数rvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r) &#123;    vector&lt;int&gt; C;//商    r = 0;//余数 引用传回      /*    除法比较特殊，是从最高位开始算的    整个过程模拟笔算    把前一位的余数*10+这一位的余数，然后除以除数，把能除的部分写入到商（答案）中    然后把上一步得到的数模除一下除数，留下本次的余数，并参与到下次的运算。    */    for(int i = A.size()-1; i &gt;= 0; i--)&#123;        r = r * 10 + A[i];        C.push_back(r / b);        r %= b;    &#125;        //因为除法相比于其他的运算是反过来的，是从最高位开始运算的，这里需要反转一下    //否则就是输出的时候反过来输出。但这带来了一个新的问题：先导0很难去除    //所以还是反转一下比较好，这样好去除先导0，并且输出可以不用另外更改    reverse(C.begin(),C.end());//        //去除前导0    while(C.size()&gt;1 &amp;&amp; C.back() == 0)        C.pop_back();      return C;&#125;int main() &#123;    string a;    int b;    cin &gt;&gt; a &gt;&gt; b;    vector&lt;int&gt;A;    for (int i = a.size() - 1; i &gt;= 0; i--) &#123;//逆序读入        A.push_back(a[i] - &#x27;0&#x27;);    &#125;      int r;    vector&lt;int&gt; C = div(A, b, r);    for (int i = C.size() - 1; i &gt;= 0; i--)//再次逆序输出        printf(&quot;%d&quot;, C[i]);    cout &lt;&lt; endl &lt;&lt; r &lt;&lt;endl;    return 0;&#125;

前缀和与差分前缀和（一维）简介有一个长度为n的数组a，为：a[1]，a[2]，a[3]，…，a[n]；
对应的前缀和数组为：s[1]，s[2]，…，s[n]；s[ i ] &#x3D; a[ 1 ] + a[ 2 ] + … + a[ i ]
作用快速的求出数组中一段数的和。


使用前缀和进行计算可以将时间复杂度由原来的 O( n ) 降低到 O( 1 )；


计算方法前缀和预处理s[ i ] = s[ i - 1 ] + a[ i ];


使用前缀和a[ l ] ~ a[ r ]的和 = S[r] - S[ l - 1 ]


时间复杂度前缀和数组在预处理阶段是 O(n)，在使用的时候是 O(1)
注意事项
在使用前缀和的时候，一般使得数组下标从1起，空出开头的一个，方便计算。

模板S[i] = a[1] + a[2] + ... a[i]a[l] + ... + a[r] = S[r] - S[l - 1]

例题：795.前缀和
输入一个长度为 n 的整数序列。
接下来再输入 m 个询问，每个询问输入一对 l,r。
对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。
输入格式第一行包含两个整数 n 和 m。
第二行包含 n 个整数，表示整数数列。
接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。
输出格式共 m 行，每行输出一个询问的结果。
数据范围1 ≤ l ≤ r ≤ n1 ≤ n,m ≤ 100000−1000 ≤ 数列中元素的值 ≤ 1000
输入样例：5 32 1 3 6 41 21 32 4

输出样例：3610
#include &lt;iostream&gt;using namespace std;const int N = 1e6+10;int n,m,l,r;int nums[N],s[N];//输入的数组，对应的前缀和数组int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i ++ )&#123;        scanf(&quot;%d&quot;, &amp;nums[i]);        s[i] = s[i - 1] + nums[i];//输入的同时对前缀和进行一个初始化    &#125;    while(m--)&#123;        scanf(&quot;%d%d&quot;, &amp;l, &amp;r);        printf(&quot;%d\n&quot;,s[r] - s[l - 1]);//利用前缀和公式直接求出指定区间的和,区间和的计算      &#125;      return 0;&#125;

前缀和（二维）用于快速的求出一个子矩阵内的和。
原理和一维的前缀和相同，这里不再赘述。
前缀和矩阵的预处理公式s[ i, j ] = s[ i - 1, j ] + s[ i , j - 1 ] - s[ i - 1 , j - 1 ] + a[ i , j ]


区间和的计算s[x2,y2]  - s[x2,y1-1] - s[x1-1,y2-1 ] + s[x1-1,y1-1]



模板S[i, j] = 第i行j列格子左上部分所有元素的和以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]

例题：796. 子矩阵的和
输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。
对于每个询问输出子矩阵中所有数的和。
输入格式第一行包含三个整数 n，m，q。
接下来 n 行，每行包含 m 个整数，表示整数矩阵。
接下来 q 行，每行包含四个整数 x1,y1,x2,y2，表示一组询问。
输出格式共 qq 行，每行输出一个询问的结果。
数据范围1 ≤ n, m ≤ 10001 ≤ q ≤ 2000001 ≤ x1 ≤ x2 ≤n1 ≤ y1 ≤ y2 ≤m−1000 ≤ 矩阵内元素的值 ≤ 1000
输入样例：3 4 31 7 2 43 6 2 82 1 2 31 1 2 22 1 3 41 3 3 4

输出样例：172721
#include &lt;iostream&gt;using namespace std;const int N = 1010;int nums[N][N], s[N][N];int n, m, q;int main()&#123;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q);    for (int i = 1; i &lt;= n; i++) &#123;        for (int j = 1; j &lt;= m; j++) &#123;            scanf(&quot;%d&quot;, &amp;nums[i][j]);            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + nums[i][j];        &#125;    &#125;    while (q--) &#123;        int x1, y1, x2, y2;        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;        cout &lt;&lt; s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1] &lt;&lt; endl;    &#125;    return 0;&#125;

差分（前缀和的逆运算）差分就是给你一个前缀和数组，让你根据数组还原出原来的数组
对于一维数据来说，就是设给定一个前缀和数组s[n]，然后假想一个数组b，使得s数组是b数组的前缀和，此时，b就成为s的差分，s是b的前缀和；
对于二维数据，也是类似的，给定一个原数组a[i,j]，构造一个b矩阵b[i,j]，使得a数组是b数组的前缀和。
对于差分算法来说，都可以不用考虑构造的问题，假定初始数组都是0即可，对于原有的数据视为插入即可。
差分的作用对于一维数据来说，给定一个数组，要求在数组中指定的区域（l，r）中每个数都加上一个指定的数c。如果次数较多，可以使用 差分 算法实现。差分算法的实现要求是首先用O(n)的时间构造出一个辅助数组（不是必须的），之后的所有操作就可以在O(1)内完成，最后在用O(n)的时间算出全部。


一维差分思路
假定原数组a[n]全部是0，此时辅助的差分数组b内也全部都是0。
将输入的数据视为插入。就是说，可以看作进行了n次的插入操作。如a[1]是2的话，可以看作进行了如下的操作：原数组的[1,1] + a[1] ； 原数组的[n,n] + a[n]。此时，就规避了构造的问题。
此时，就可以总结出一个规律：想对一个区间全部加上一个数，就可以进行b[l] + c ; b[r + 1] - c;实现。
按照1到3的思路来说，原数组a[i]就没有存在的需要，只需要一个差分数组b[i]即可。输入原数组的时候，可以视为进行了插入操作，即b[i] +&#x3D; c , b[i + 1] -&#x3D; c;在全部输入完成后，只需要对着辅助数组求一遍前缀和即可还原为原数组的数据。如b[i] +&#x3D; b[i-1]；

模板给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c

例题 ：797. 差分
输入一个长度为 n 的整数序列。
接下来输入 m 个操作，每个操作包含三个整数 l,r,c 表示将序列中 [l,r] 之间的每个数加上 c。
请你输出进行完所有操作后的序列。
输入格式第一行包含两个整数 n 和 m。
第二行包含 n 个整数，表示整数序列。
接下来 m 行，每行包含三个整数 l，r，c 表示一个操作。
输出格式共一行，包含 n 个整数，表示最终序列。
数据范围1 ≤ n,m ≤ 1000001 ≤ l ≤ r ≤ n−1000 ≤ c≤1000−1000 ≤ 整数序列中元素的值 ≤ 1000
输入样例：6 31 2 2 1 2 11 3 13 5 11 6 1

输出样例：3 4 5 3 4 2
#include &lt;iostream&gt;using namespace std;const int N = 1e6+10;int b[N];//差分数组int n,m;void insert(int l,int r,int c)&#123;    b[l] += c;    b[r+1] -= c;&#125;int main()&#123;    int c;      scanf(&quot;%d%d&quot;, &amp;n, &amp;m);      for (int i = 1; i &lt;= n; i ++ )&#123;        scanf(&quot;%d&quot;, &amp;c);        insert(i,i,c);//把原数组视为逐个插入    &#125;      //多轮插入    while (m -- )&#123;        int l,r;        scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c);//读入每轮的范围及数值        insert(l,r,c);//插入    &#125;      //整合并输出    for (int i = 1; i &lt;= n; i ++ )    &#123;        b[i] += b[i-1];        printf(&quot;%d &quot;,b[i]);    &#125;      return 0;&#125;

二维差分对于一维差分来说，是给一段距离加上一个值；


而对于二维差分来说，是给一个子矩阵加上一个值；


操作的时间复杂度来说，由原先的整个子矩阵变成了四个点，由O(n) 下降到 O(1)


思路
不考虑构造，假定初始a[i,j]都是0，同样b[i,j]也就都为0了。对于a[i，j]中原有的数据，依次遍历插入即可；
对于插入方法来说，
一维插入方法是：b[l] +&#x3D; c; b[r+1] -&#x3D; c;
二维的插入方法是：（设要插入的子矩阵的左上角坐标为：x1,y1，右下角的坐标为：x2,y2）
b[x1 , y1] +&#x3D; c; &#x2F;&#x2F;先将从子矩阵左上角到整个大矩阵的右下角所有的值都加上c
b[x2 + 1 , y1] -&#x3D; c;  &#x2F;&#x2F;然后将子矩阵左下角到整个大矩阵右下角所有的值减去c
b[x1 , y2 + 1] -&#x3D; c;  &#x2F;&#x2F;接着将子矩阵右上角到整个大矩阵右下角所有的值减去c
b[x2+1 , y2+1] +&#x3D; c;  &#x2F;&#x2F;因为第2、3步的操作导致了子矩阵右下角到整个大矩阵右下角所有的值减去两遍c，因此需要补回一个。




最后输出的时候求一下b数组的前缀和就可以了。

模板给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c位运算 —— 模板题 AcWing 801. 二进制中1的个数求n的第k位数字: n &gt;&gt; k &amp; 1返回n的最后一位1：lowbit(n) = n &amp; -n

例题
输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c 其中 (x1,y1)和 (x2,y2)表示一个子矩阵的左上角坐标和右下角坐标。
每个操作都要将选中的子矩阵中的每个元素的值加上 c。
请你将进行完所有操作后的矩阵输出。
输入格式第一行包含整数 n,m,q。
接下来 n 行，每行包含 m 个整数，表示整数矩阵。
接下来 q 行，每行包含 5 个整数 x1,y1,x2,y2,c 表示一个操作。
输出格式共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。
数据范围1 ≤ n,m ≤ 10001 ≤ q ≤ 1000001 ≤ x1 ≤ x2 ≤ n1 ≤ y1 ≤ y2 ≤ m−1000 ≤ c ≤ 1000−1000 ≤ 矩阵内元素的值 ≤ 1000
输入样例：3 4 31 2 2 13 2 2 11 1 1 11 1 2 2 11 3 2 3 23 1 3 4 1

输出样例：2 3 4 14 3 4 12 2 2 2

#include &lt;iostream&gt;using namespace std;const int N = 1010;int b[N][N];int n,m,q;//二维差分的核心void insert(int x1,int y1,int x2,int y2,int c)&#123; b[x1][y1] += c; b[x1][y2+1] -= c; b[x2+1][y1] -= c; b[x2+1][y2+1] += c;&#125;int main()&#123; int c,x1,x2,y1,y2; scanf(&quot;%d%d%d&quot;,&amp;n ,&amp;m ,&amp;q); //将原数组的数据视为插入，依次进行读取处理 for(int i = 1; i &lt;= n; i++)&#123;     for(int j = 1; j &lt;= m; j++)&#123;         scanf(&quot;%d&quot;,&amp;c);         insert(i,j,i,j,c);     &#125; &#125; //开始多轮修改 while(q--)&#123;     scanf(&quot;%d%d%d%d%d&quot;,&amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;c);     insert(x1,y1,x2,y2,c); &#125; //修改完成后，根据差分数组b进行一次前缀和的运算，并且输出出来 for(int i = 1; i &lt;= n; i++)&#123;     for(int j = 1; j&lt;= m; j++)&#123;         b[i][j] = b[i][j] + b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];         printf(&quot;%d &quot;, b[i][j]);//直接输出     &#125;     printf(&quot;\n&quot;); &#125; return 0;&#125;
双指针算法介绍简单的说双指针算法就是有两个指针来进行操作的算法。
两个指针可以指向不同的序列，可以指向相同序列中不同的位置 。
双指针算法的应用范围非常广，有时甚至都意识不到。比如常见的快排、归并排序都应用到了双指针的思想。
模板一般的写法就一种情况：
for(int i = 0, j = 0; i &lt; n; i++)&#123;  	while(j &lt; i &amp;&amp; check(i,j))    &#123;      	j++;    &#125;    	//每个题目的具体逻辑&#125;

简单的说 双指针算法的核心思想就是，将原始的双重循环O( n ^ n  )的算法，通过某种性质优化到一重循环O(n)
样例1：给定一个字符串 将其转换成一个个单词输出
给定一个字符串 将其转换成一个个单词输出。保证字符串首字符不是空格，且单词之间的分隔符是空格
如：abc def ghi
输出：
abc	def	ghi


#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; char str[1000]; gets(str); int n = strlen(str); //利用双指针算法算出当前单词的结束位置 for(int i = 0; str[i]; i++)&#123;     int j = i;     while(j &lt; n &amp;&amp; str[j] != &#x27; &#x27;)//只要j没到终点，且当前j是非空格（分界符）         j++;//直到j指向分界符     //往下就是这道题的具体逻辑     for(; i &lt; j; i++)&#123;         cout &lt;&lt; str[i];     &#125;     cout &lt;&lt; endl ; &#125; return 0; &#125;
样例2：799. 最长连续不重复子序列实现思路
有两个指针i，j，j 在前 i 在后。i每次后移增加新的数据
每次增加完，检查 j 到 i 之间有没有重复数据，如果有，则 j 指针后移（j指针只能后移，因为序列是有序的，不可能存在前一个区间内有重复数字，新加入一个数后区间内重复数字消失了，只有一种情况就是新增加的数导致了区间内有重复的数据），直到整个区间内没有重复数字位置。（具体操作见后面）
计算已有的记录和当前区间的长度，如果当前的更长就更新记录
检查方法：类似于哈希，哈希公式就是数值本身。即f( x ) &#x3D; x ;

具体题目及代码
给定一个长度为 nn 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。
输入格式第一行包含整数 n。
第二行包含 n 个整数（均在 0∼105 范围内），表示整数序列。
输出格式共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。
数据范围1 ≤ n ≤ 105
输入样例：51 2 2 3 5

输出样例：3

#include &lt;iostream&gt;using namespace std;const int N = 1e6+10;int a[N];//读入的数据int s[N];//当前i到j之间，每一个数出现的次数int n;int main()&#123; cin&gt;&gt;n; for (int i = 0; i &lt; n; i ++ )     scanf(&quot;%d&quot;, &amp;a[i]); int res;//答案，或者说是最长的记录 for(int i = 0, j = 0; i &lt; n; i++)&#123;     s[a[i]]++;//i指针后移后，将新的数对应的地方++，表示多了这一个数     //条件1：j&lt;=i可以不用写，因为当j &gt; i的时候，区间里就没有数了，此时一定满足没有重复数的要求。     //条件2：新加入的数是a[i]，因此判断当前是否有不止一个的数。     //如果i指针当前指向的数不止一个，即表明j到i之间的数存在重复，且重复的位置是新入的i指针指向的位置。（因为在上一次循环已经排除了重复，最坏的可能就是上一轮中 i 和 j 都指向他自己     //假定重复的值是j指向的位置，只需要将s中j指向的个数--，然后j指针后移，直到j到i的区间内不存在重复即可     while(j &lt;= i &amp;&amp; s[a[i]]&gt;1)     &#123;         s[a[j]] -- ;//         j ++ ;     &#125;     res = max(res,i - j + 1);//此时计算一下j到i之间有多少个数，并将这个数与已有的记录进行比较，如果大于就更新一下。 &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;
他人题解
AcWing 799. 最长连续不重复子序列-从暴力到双指针的详细过程    原题链接    简单作者：    bbk ,  2020-10-27 20:55:03 ,  所有人可见 ,  阅读 1836
给定一个长度为n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。输入格式:第一行包含整数n。第二行包含n个整数（均在0~100000范围内），表示整数序列。输出格式:共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。数据范围:1≤n≤1000001≤n≤100000输入样例:：
51 2 2 3 5
输出样例：
3
思路：暴力法：当然可以用暴力法：对每个 i 和 j 都遍历一遍，对每个 i 和 j 都check一下中间的数据是否满足给定的条件。这样的时间复杂度是O(n^2)；数据稍微大点就会超时。代码如下：
for (int i = 0; i &lt; n; i++)for (int j = 0; j &lt;= i; j++)  if (check(v1,j, i) == 0)//检查 i 和 j 之间是否有重复的数字      res = max(res, i - j + 1);//check函数int check(vector&lt;int&gt;&amp; v1, int l, int r)&#123;for (int i = l+1; i &lt;=r ; i++)  for (int j = l; j &lt; i; j++)      if (v1[i] == v1[j])          return 1;return 0;&#125;

双指针法一：仔细考虑暴力法就会发现，暴力法在解题时有很多地方是重复计算了 ( i 指针在 j 指针的后面，i是遍历的整个数组的，j 是遍历 0 到 i 的)：
比如 j &#x3D; 0，i &#x3D; 5，此时发现 i，j 是满足题解条件的；那么后面的 j &#x3D; 1到5，i &#x3D; 5 就不用计算了，肯定是满足条件的。
所以引出了双指针法：还是上面的例子，双指针法就是说，既然发现 j &#x3D; 0，i &#x3D; 5满足题解条件，那就不用计算 j &#x3D; 1到5，i &#x3D; 5了，直接计算 j &#x3D; 1，i &#x3D; 6，如果不满足条件，那就计算 j &#x3D; 2，i &#x3D; 6，然后接着计算。
这样就是 i 和 j 指针都是从前移到后，也就是计算2n次。时间复杂度是O(2n)。
核心代码如下：（但是还会超时）。
for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i++){while (j &lt;&#x3D; i){if (check(v1, j, i) &#x3D;&#x3D; 0){res &#x3D; max(res, i - j + 1);break;}elsej++;}}
&#x2F;&#x2F;找得到重复的数返回1int check(vector&amp; v1, int l, int r){for (int i &#x3D; l + 1; i &lt;&#x3D; r; i++)for (int j &#x3D; l; j &lt; i; j++){if (v1[i] &#x3D;&#x3D; v1[j])return 1;}return 0;}
双指针法二（最终版）：但是上面代码还是超时，为什么呢？因为check函数写的不好，循环太多，直接是暴力计算找重复数字的，显然不好。
所以引出一个新的check方法：对于寻找是否有重复数字，一般用hash，没人用暴力。所以用hash就可以计算。
但是这道题还有一种计算方法：
用一个辅助数组S保存原数组V1每个元素存在的次数，和hash类似。比如说 V1 &#x3D; {1,2, 2, 3, 5 }。那 S就是 {0,1,2,1,0,1 }。S[V1[i]]表示的是V1[i]的个数。此处我们用S数组只保存 j 和 i 指针之间的数的个数。
算法思路： 如果j &#x3D; 0，i &#x3D; 5，此时检查S数组元素都是 &lt;&#x3D;1的。那下一步的情况就是 i 。i之后将S数组更新，只需要检查S[v1[i]]元素是不是比1大即可，因为随着 i 的递增，S数组中变化的只有S[v1[i]]元素。如果检查S[v1[i]]元素发现该元素比 1 大。那说明 j 指针和 i 指针之间有某个元素出现了两次。所以 i 指针保持不动， j 指针往后移动( j 指针不可能往前移动的，上次j指针往后移动就是因为 j 和 i之间有重复元素，这一往前移动肯定有重复元素)。j 指针往后移动之前需要先更新S数组，即进行 S[v1[j]]– 操作。然后 j 指针再往后移动。移动之后只需要检查 i 指针对应的S[v1[i]]元素是否大于1即可。（因为 j 指针移动之后只有两种情况，1.重复元素刚好没了，则S[v1[i]]肯定&#x3D;&#x3D;1；2.重复元素还在，那S[v1[i]]&#x3D;&#x3D;2，需要 j 继续往后移动 )。等S[v1[i]]&#x3D;&#x3D;1 时，说明 j 和 i 之间已经没有重复元素了，可以更新res值，然后 i++。
核心代码：
for (int i = 0,j = 0; i &lt; n; i++)&#123;S[v1[i]]++;while ( S[v1[i]] &gt; 1) --S[v1[j++]];res = max(res, i - j + 1);&#125;

代码实现：
#include&lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define N  100010using namespace std;int main()&#123;int n;cin &gt;&gt; n;vector&lt;int&gt; v1(n,0);for (int i = 0; i &lt; n; i++)  cin &gt;&gt; v1[i];vector&lt;int&gt; S(N,0);int res = 0;for (int i = 0,j = 0; i &lt; n; i++)&#123;  S[v1[i]]++;  while ( S[v1[i]] &gt; 1) --S[v1[j++]];  res = max(res, i - j + 1);&#125;cout &lt;&lt; res;return 0;&#125;

作者：bbk链接：https://www.acwing.com/solution/content/23474/来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

样例3：800. 数组元素的目标和
给定两个升序排序的有序数组 AA 和 BB，以及一个目标值 xx。
数组下标从 00 开始。
请你求出满足 A[i]+B[j]&#x3D;xA[i]+B[j]&#x3D;x 的数对 (i,j)(i,j)。
数据保证有唯一解。
输入格式第一行包含三个整数 n,m,xn,m,x，分别表示 AA 的长度，BB 的长度以及目标值 xx。
第二行包含 nn 个整数，表示数组 AA。
第三行包含 mm 个整数，表示数组 BB。
输出格式共一行，包含两个整数 ii 和 jj。
数据范围数组长度不超过 105105。同一数组内元素各不相同。1≤数组元素≤1091≤数组元素≤109
输入样例：4 5 61 2 4 73 4 6 8 9

输出样例：1 1
实现思路首先，因为两个数组的解是唯一的，不存在多种配对的问题。

首先让i指针指向a数组开头（即a数组中最小的数）
然后让j指针指向b数组的结尾（即b数组中最大的数）
此时可以发现，i不动，j前移；i与j指针指向的数相加的结果必然是从大到小的。
因此，利用这个性质，使得j不停的前移，直到两个指针指向的数的和小于等于要求的值
此时，j停止移动，判断i与j指向的数是否相等，相等就输出，不等就进入下轮循环，i指针后移，j指针不动，直到匹配为止

代码#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, m, x;int a[N], b[N];int main()&#123;    //读入数据    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;x);    for (int i = 0; i &lt; n; i++)        scanf(&quot;%d&quot;, &amp;a[i]);    for (int i = 0; i &lt; m; i++)        scanf(&quot;%d&quot;, &amp;b[i]);    /*    *利用双指针开始配对    * 首先让i指针指向a数组开头（即a数组中最小的数）    * 然后让j指针指向b数组的结尾（即b数组中最大的数）    * 此时可以发现，i不动，j前移；i与j指针指向的数相加的结果必然是从大到小的。    * 因此，利用这个性质，使得j不停的前移，直到两个指针指向的数的和小于等于要求的值    * 此时，j停止移动，判断i与j指向的数是否相等，相等就输出，不等就进入下轮循环，i指针后移，j指针不动，直到匹配为止    */    for (int i = 0, j = m - 1; i &lt; n; i++) &#123;        while (j &gt;= 0 &amp;&amp; b[j] + a[i] &gt; x)            j--;        if (a[i] + sb[j] == x) &#123;            printf(&quot;%d %d\n&quot;, i, j);            break;        &#125;    &#125;    return 0;&#125;

样例4：2816. 判断子序列
给定一个长度为 n 的整数序列 a1,a2,…,an 以及一个长度为 m 的整数序列 b1,b2,…,bm。
请你判断 a 序列是否为 b 序列的子序列。
子序列指序列的一部分项按原有次序排列而得的序列，例如序列 {a1,a3,a5} 是序列 {a1,a2,a3,a4,a5} 的一个子序列。
输入格式第一行包含两个整数 n,m。
第二行包含 n 个整数，表示 a1,a2,…,an。
第三行包含 m 个整数，表示 b1,b2,…,bm。
输出格式如果 a 序列是 b 序列的子序列，输出一行 Yes。
否则，输出 No。
数据范围1≤n≤m≤10^5^−10^9^ ≤ ai , bi ≤ 10^9^
输入样例：3 51 3 51 2 3 4 5

输出样例：Yes
实现思路读入序列后，设两个指针分别指向两个序列的起始位置，若两指针指向的值相等，则两个序列的指针都后移一个；若不等，则子序列的不移动，长序列的继续后移，进行判断，直到两个序列中任意一个到达终点为止。此时判断子序列有没有走完，如果走完了说明就是子序列，否则就不是子序列。


实现代码#include &lt;iostream&gt;using namespace std;const int N = 1e5+10;int a[N],b[N];int n,m;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 0; i &lt; n; i ++ )        scanf(&quot;%d&quot;, &amp;a[i]);    for (int i = 0; i &lt; m; i ++ )        scanf(&quot;%d&quot;, &amp;b[i]);          int i = 0, j = 0;      while(i &lt; n  &amp;&amp; j &lt; m)&#123;//指针不能到头        if(a[i] == b[j])//如果匹配的话子序列的指针后移            i++;        j++;//不管是否匹配长序列都回后移，    &#125;//直到子序列到头达成匹配或者长序列到头匹配失败退出      if(i == n)//此时判断子序列的指针有没有到头，以判断是否是子序列        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;    else        cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;    return 0;&#125;

位运算lowbit( x )：返回x的最后一位1eg:
x = 1010B		lowbit( x ) = 10B;


x = 101000B	lowbit( x ) = 1000B;


实现方法x &amp; -x


int lowbit(int x)&#123;   return x &amp; -x; &#125;

实现原理数在c中是以补码的形式存在的，而负数的补码是正数取反+1。


设x的二进制数是：			1010 . . . 100 . . . 0
则x取反后的二进制是：	0101 . . . 011 . . . 1
取反后+1的结果等于：	  0101 . . . 100 . . . 0
因此，在c中将一个数取反+1后再和这个数相与的结果就是，0101 . . . 100 . . . 0 ，前面因为取反和原数不一样，因此在与的过程中全部变0，后面因为一样就全部保留了。
常用地方求一个数的二进制中1的个数(奇偶校验？)


例题：801. 二进制中1的个数
给定一个长度为 n 的数列，请你求出数列中每个数的二进制表示中 1 的个数。
输入格式第一行包含整数 n。
第二行包含 n 个整数，表示整个数列。
输出格式共一行，包含 n 个整数，其中的第 ii 个数表示数列中的第 i 个数的二进制表示中 1 的个数。
数据范围1 ≤ n ≤ 100000,0 ≤ 数列中元素的值 ≤ 10^9^
输入样例：51 2 3 4 5

输出样例：1 1 2 1 2

代码#include &lt;iostream&gt;using namespace std;int lowbit(int x)&#123;return x &amp; -x; &#125;int main()&#123; int n, x, res = 0; scanf(&quot;%d&quot;, &amp;n); while (n -- )&#123;     scanf(&quot;%d&quot;, &amp;x);     while(x)&#123;         x -= lowbit(x);//每次减去最后一个1         res++;//减一个计数器+1     &#125;     printf(&quot;%d &quot;,res);     res = 0; &#125; return 0;&#125;
离散化（特指整数的有序的离散化）暂时回避
区间合并
给定 n 个区间 [li,ri][li,ri]，要求合并所有有交集的区间。
注意如果在端点处相交，也算有交集。
输出合并完成后的区间个数。
例如：[1,3][1,3] 和 [2,6][2,6] 可以合并为一个区间 [1,6][1,6]。
输入格式第一行包含整数 n。
接下来 n 行，每行包含两个整数 l 和 r。
输出格式共一行，包含一个整数，表示合并区间完成后的区间个数。
数据范围1 ≤ n ≤ 100000−10^9^ ≤ li ≤ ri ≤ 10^9^
输入样例：51 22 45 67 87 9

输出样例：3
解题思路
我们知道区间的开头和结尾，可以开一个数组存下来
将所有区间进行排序，排序规则为左端点降序
依次检查每个区间的右端点，如果左端点超过已有记录，就证明是一个新的区间，res++;
如果右区间超过但左区间小于等于记录，就证明区间是连续的，刷新一下右端点即可
输出res

代码#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 100010;typedef pair&lt;int, int&gt; PII;int n, l, r;vector&lt;PII&gt; nums;//利用vector数组进行存储所有区间的左右端点，方便后续的排序//sort的仿函数可写可不写，因为默认就是根据pair的键值（第一个值，左端点）进行升序排序的bool MyCom(PII x, PII y) &#123;    if (x.first &lt; y.first)        return true;    else        return false;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 0; i &lt; n; i++) &#123;        scanf(&quot;%d%d&quot;, &amp;l, &amp;r);        nums.push_back(&#123; l,r &#125;);//依次读入区间    &#125;    //进行排序，要求左端点升序排序    //sort(nums.begin(),nums.end(),MyCom);    sort(nums.begin(), nums.end());    //给记录设置一个区间，要求这个区间比题目要求的所有的区间都要小    l = r = -1e9 - 10;    int res = 0;//区间个数，初始化成0    for (int i = 0; i &lt; n; i++) &#123;        //如果区间左端点大于已有区间的右端点，证明两个区间不连续，区间数++，刷新区间        if (r &lt; nums[i].first) &#123;            l = nums[i].first;            r = nums[i].second;            res++;        &#125;        //能到这里就证明，当前区间的左端点一定是小于等于记录的右端点，证明是连续的，只需要更新右端点即可        else if (r &lt; nums[i].second)        &#123;            r = nums[i].second;        &#125;    &#125;    cout &lt;&lt; res &lt;&lt; endl;//输出答案    return 0;&#125;

数据结构链表与邻接表：树与图的存储使用数组来模拟链表的存在，虽然会造成内存泄漏，但可以大幅提高速度。
因为c++中的new是非常耗时间的，因此在竞赛或者笔试的时候，不要使用传统的结构体链表。(一般的数据范围都在10^5以上，如果new的话必定会超时)
单链表例题
实现一个单链表，链表初始为空，支持三种操作：

向链表头插入一个数；
删除第 k 个插入的数后面的数；
在第 k 个插入的数后插入一个数。

现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。
注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。
输入格式第一行包含整数 M，表示操作次数。
接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：

H x，表示向链表头插入一个数 x。
D k，表示删除第 kk 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。
I k x，表示在第 kk 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。

输出格式共一行，将整个链表从头到尾输出。
数据范围1≤M≤100000所有操作保证合法。
输入样例：10H 9I 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6

输出样例：6 4 6 5
思路类似于传统的结构体链表，不过改成用数组来模拟（变成静态链表）
分别开辟一个数组e，存储每个节点的数据；ne，存储每个节点的加一个节点的地址。e与ne数组的联系在于下标，换句话说就是，e[i] 与 ne[i] 是一组的。以及变量head，存储头节点的位置；idx，存储使用了多少个节点（idx始终指向第一个未被使用的节点）
当程序运行的时候需要进行初始化，将head置为-1，idx置为0。
对于头节点的插入操作，只需要简单的：
void insert_head(int x)&#123;  	e[idx] = x;//将数据读入到节点		ne[idx] = head;//将下一个节点的指针置为头指针指向的位置		head = idx ++;//将头指针指向新插入的节点，并且数量++&#125;

对于指定位置的插入，也很简单，可以在O(1)的时间内完成
void insert(int k,int x)&#123;		e[idx] = x;//同样读入到节点		ne[idx] = ne[k];//将新节点的next指针指向第k个位置原本指向的位置		ne[k] = idx ++;//将第k个位置的指针指向新加入的节点，同时idx++便于下一步操作&#125;

对于删除来说，就不需要再考虑空间的事了，可以直接的进行p-&gt;next &#x3D; p-&gt;next-&gt;next的操作
void del(int k)&#123;		ne[k] = ne[ne[k]];&#125;

但需要注意的是，如果要删除的节点是头节点，则需要这么做
void del_head()&#123;		head = ne[head];&#125;

对于模拟链表的遍历，和传统链表也很相似：
void display()&#123;  	//i从头节点开始，直到遇到-1（head的初始化值）为止，i的下一位是ne[i]		for(int i = head; i != -1 ; i = ne[i])        printf(&quot;%d &quot;,e[i]);&#125;

实现代码需要注意的是，k需要-1.因为题是从1起，而数组是从0起
#include &lt;iostream&gt;using namespace std;const int N = 100010;//head 头节点的下标//e[i] 节点i的值//ne[i] 节点i的next指针是多少//idx  存储当前已经用了多少int head, e[N], ne[N], idx;//初始化void init()&#123;    head = -1;//-1表示空    idx = 0;&#125;//将x插入到头节点void add_to_head(int x)&#123;    //idx存储了最新的节点可用的下标是什么    e[idx] = x;//将x输入到e中新的节点    ne[idx] = head;//将新的节点的指针指向head；    head = idx;//将head的指针指向到新插入的头节点的位置    idx++;//将idx的值++，方便下次使用&#125;//将x插入到下标为k的节点的后面void add(int k,int x)&#123;    e[idx] = x;    ne[idx] = ne[k];    ne[k] = idx;    idx++;&#125;//将下标是k的点的后一个点删掉void remove(int k)&#123;    ne[k] = ne[ne[k]];&#125;int main()&#123;    int m;    scanf(&quot;%d&quot;, &amp;m);    init();    while(m--)&#123;        char op;        int k,x;        //scanf(&quot;%c&quot;,&amp;op);        cin&gt;&gt;op;        if(op == &#x27;H&#x27;)        &#123;            //scanf(&quot;%d&quot;,&amp;x);            cin&gt;&gt;x;            add_to_head(x);        &#125;        else if(op == &#x27;D&#x27;)        &#123;            //scanf(&quot;%d&quot;, &amp;k);            cin&gt;&gt;k;            if(k == 0)//特判一下删除头节点的情况                head = ne[head];            else                remove(k - 1);        &#125;        else        &#123;            //scanf(&quot;%d%d&quot;, &amp;k, &amp;x);            cin&gt;&gt;k&gt;&gt;x;            add(k - 1,x);        &#125;          &#125;    for(int i = head; i != -1 ; i = ne[i])        printf(&quot;%d &quot;,e[i]);      return 0;&#125;

双链表与单链表类似，只不过多了一个指针
例题
实现一个双链表，双链表初始为空，支持 55 种操作：

在最左侧插入一个数；
在最右侧插入一个数；
将第 k 个插入的数删除；
在第 k 个插入的数左侧插入一个数；
在第 k 个插入的数右侧插入一个数

现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。
注意:题目中第 k 个插入的数并不是指当前链表的第 kk 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。
输入格式第一行包含整数 M，表示操作次数。
接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：

L x，表示在链表的最左端插入数 x。
R x，表示在链表的最右端插入数 x。
D k，表示将第 k 个插入的数删除。
IL k x，表示在第 k 个插入的数左侧插入一个数。
IR k x，表示在第 k 个插入的数右侧插入一个数。

输出格式共一行，将整个链表从左到右输出。
数据范围1≤M≤100000所有操作保证合法。
输入样例：10R 7D 1L 3IL 2 10D 3IL 2 7L 8R 9IL 4 7IR 2 2

输出样例：8 7 7 3 2 9
思路和单链表类似，一个存储数据的数组e[N]，一个存储当前节点的左侧的数组l[N]，当前节点的右侧的数组r[N]，和下一个节点的地址idx。
首先对数组进行初始化：一共有两个节点，下标分别是0和1，链表的最右边节点的下标是1，即 r[0] = 1；然后将最左边的节点设为0，即l[1] = 0
对于插入到节点右侧的数据，可以进行如下操作：

将数据写入到新的节点


e[idx] &#x3D; x;


将新创建的节点入队
l[idx] &#x3D; k , r[idx] &#x3D; r[k];


然后使得前后节点接受新插入的节点
l[r[k]] &#x3D; idx  , r[k] &#x3D; idx;


最后，idx++，为下次插入做准备

对于插入到节点左侧的数据，可以视为对指定节点的前一个节点进行尾插操作，可以对上方教程进行复用

insert(l[k],x);

对于删除指定节点，可以直接修改前后指针即可。

&#x2F;&#x2F;第k个节点右边的左侧不再是k，而是k之前的节点
l[r[k]] = l[k];
- ```  //同理，第k个节点左边的右侧不再是k，而是k右边的节点。


r[l[k]] = r[k];
#### 实现代码```c/*注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。*/#include &lt;iostream&gt;using namespace std;const int N = 1e5+10;int e[N],l[N],r[N],idx;//初始化void init()&#123;    r[0] = 1;//链表的最右边是1    l[1] = 0;//最左边是0    idx = 2;//起始节点&#125;//在第k个节点的右边插入一个元素void insert(int k,int x)&#123;    //将数据写入新的节点    e[idx] = x;    //将新的节点连入链接    l[idx] = k;//新节点的左边是指定的位置    r[idx] = r[k];//新节点的右边是指定位置的右边    //将原链接指向新的节点    l[r[k]] = idx;//第k个节点后一个节点的左边变成新插入的节点    r[k] = idx;//第k个节点的右边变成新插入的节点    idx ++;&#125;//在第k个节点的左边插入一个节点void insert_front(int k,int x)&#123;    //第k个节点的左边，可以视作 l[k] ，因此可以写作：    insert(l[k],x);&#125;//删除第k个节点void remove(int k)&#123;    //第k个节点右边的左侧不再是k，而是k之前的节点    l[r[k]] = l[k];    //同理，第k个节点左边的右侧不再是k，而是k右边的节点。    r[l[k]] = r[k];&#125;int main()&#123;    init();      int m;    cin&gt;&gt;m;    string op;    int k,x;    while(m--)    &#123;        cin &gt;&gt; op;//读入每行的开头        //一次根据开头判断要干的事        if(op == &quot;L&quot;)//最左端插入，相当于在头节点的右侧插入        &#123;            cin &gt;&gt; x;            insert(0, x);        &#125;        else if(op == &quot;R&quot;)//最右端插入，相当于在尾节点的左侧插入        &#123;            cin &gt;&gt; x;            insert_front(1, x );        &#125;        else if(op == &quot;D&quot;)        &#123;            cin &gt;&gt; k;            remove(k + 1);        &#125;        else if(op == &quot;IL&quot;)        &#123;            cin &gt;&gt; k &gt;&gt; x;            insert_f(k + 1, x);        &#125;        else if(op == &quot;IR&quot;)        &#123;            cin &gt;&gt; k &gt;&gt; x;            insert(k + 1,x);        &#125;              &#125;    for(int i = r[0]; i != 1; i = r[i])        printf(&quot;%d &quot;,e[i]);      return 0;&#125;





栈与队列：单调队列、单调栈模拟栈例题
实现一个栈，栈初始为空，支持四种操作：

push x – 向栈顶插入一个数 x；
pop – 从栈顶弹出一个数；
empty – 判断栈是否为空；
query – 查询栈顶元素。

现在要对栈进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。
输入格式第一行包含整数 M，表示操作次数。
接下来 M 行，每行包含一个操作命令，操作命令为 push x，pop，empty，query 中的一种。
输出格式对于每个 empty 和 query 操作都要输出一个查询结果，每个结果占一行。
其中，empty 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示栈顶元素的值。
数据范围1≤M≤1000001≤x≤10^9^所有操作保证合法。
输入样例：10push 5querypush 6popquerypopemptypush 4queryempty

输出样例：55YES4NO
思路首先用数组模拟一个栈，对栈的所有操作都可以转换成如下的操作：

入栈：stk[++ tt] &#x3D; x;
出栈：tt –;
判断是否为空：if(tt &gt; 0) 不空 else 空
栈顶元素stk[tt]

其中：stk数组就是模拟栈的数组，tt为栈顶元素的指针
实现代码#include &lt;iostream&gt;using namespace std;const int N = 1e5+10;//模拟栈的数组，栈顶指针（栈顶下标）int stk[N], tt = 0;//入栈void push(int x)&#123;    stk[++ tt] = x;&#125;//出栈（弹出）int pop()&#123;    tt --;    return stk[tt];&#125;//判断栈是否为空，空为真bool empty()&#123;    if(tt &gt; 0)        return false;    else         return true;&#125;//查看栈顶元素int query()&#123;    return stk[tt];&#125;int main()&#123;    int m, x;    string op;    cin &gt;&gt; m;    while(m--)    &#123;        cin &gt;&gt; op;        if(op == &quot;push&quot;)        &#123;            cin &gt;&gt; x;            push(x);        &#125;        else if(op == &quot;pop&quot;)        &#123;            pop();        &#125;        else if(op == &quot;empty&quot;)        &#123;            if(empty())                cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;            else                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;        &#125;        else if(op == &quot;query&quot;)        &#123;            cout &lt;&lt; query() &lt;&lt;endl;        &#125;          &#125;      return 0;&#125;

模拟队列例题
实现一个队列，队列初始为空，支持四种操作：

push x – 向队尾插入一个数 x；
pop – 从队头弹出一个数；
empty – 判断队列是否为空；
query – 查询队头元素。

现在要对队列进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。
输入格式第一行包含整数 M，表示操作次数。
接下来 M 行，每行包含一个操作命令，操作命令为 push x，pop，empty，query 中的一种。
输出格式对于每个 empty 和 query 操作都要输出一个查询结果，每个结果占一行。
其中，empty 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示队头元素的值。
数据范围1≤M≤1000001≤x≤10^9^所有操作保证合法。
输入样例：10push 6emptyquerypopemptypush 3push 4popquerypush 6

输出样例：NO6YES4
思路和模拟栈类似，相比模拟栈多了一个队头指针，出队的时候用队头指针的后移实现；判断队空是由队头指针是否大于队尾指针实现。
实现代码#include &lt;iostream&gt;using namespace std;const int N = 1e5+10;//模拟队列的数组，队头，队尾int q[N], hh = 1, tt = 0;//需要注意的是，下标为0的地方是闲置不用的，模拟栈不需要考虑这点，但队列需要。//因此，队列在空的情况下队头指针是大于队尾指针的（）//入队void push(int x)&#123;    q[++ tt] = x;//先后移队尾指针，然后再将数据写入到队尾指针指向的位置&#125;//出队void pop()&#123;    hh ++;//队头指针后移&#125;//判断队列是否为空bool empty()&#123;    if(hh &gt; tt)//只要出现队头大于队尾的情况，就是空的。队头等于队尾的时候表示还有一个元素        return true;    else        return false;&#125;//查看队头元素int query()&#123;    return q[hh];&#125;int main()&#123;    int m, x;    string op;    cin &gt;&gt; m;    while(m --)    &#123;        cin &gt;&gt; op;        if(op == &quot;push&quot;)        &#123;            cin &gt;&gt; x;            push(x);        &#125;        else if(op == &quot;pop&quot;)        &#123;            pop();        &#125;        else if(op == &quot;empty&quot;)        &#123;            if(empty())                cout &lt;&lt; &quot;YES&quot; &lt;&lt;endl;            else                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;        &#125;        else if(op == &quot;query&quot;)        &#123;            cout &lt;&lt; query() &lt;&lt; endl;        &#125;          &#125;        return 0;&#125;

单调栈例题
给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。
输入格式第一行包含整数 N，表示数列长度。
第二行包含 N 个整数，表示整数数列。
输出格式共一行，包含N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。
数据范围1≤N≤10^5^1≤数列中元素≤10^9^
输入样例：53 4 2 7 5

输出样例：-1 3 -1 2 2
思路要求是左边第一个小的数（也可以是左&#x2F;右边 第一个 最大&#x2F;小的数），可以利用栈的特性实现。

判断当前栈是否为空，如果不为空判断栈顶元素是否比输入的数小（或者大），不满足就出栈，直到栈空。
再次判断栈是否为空，如果不是空的，那么栈顶元素就是需要的了。如果栈空了，就证明没匹配到，输出-1
不管上面如何，将输入的数入栈，供下个数使用。

实现代码#include &lt;iostream&gt;using namespace std;const int N = 1e5+10;int n, stk[N], tt;int main()&#123;    cin &gt;&gt; n;      for(int i = 0; i &lt; n; i++)    &#123;        int x;        cin &gt;&gt; x;        while(tt != 0 &amp;&amp; stk[tt] &gt;= x)//如果栈不为空，同时栈顶元素大于等于当前的元素，那么栈顶元素就不会用到了，可以出栈了            tt --;        if(tt != 0)//如果栈仍然不为空，那么当前的栈顶的元素就是需要的数，直接输出            cout &lt;&lt; stk[tt] &lt;&lt; &quot; &quot;;        else            cout &lt;&lt; -1 &lt;&lt; &quot; &quot;;                  stk[++ tt] = x;//把元素入栈    &#125;      return 0;&#125;

单调队列（滑动窗口）例题
给定一个大小为 n≤10^6^ 的数组。
有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。
你只能在窗口中看到 k 个数字。
每次滑动窗口向右移动一个位置。
以下是一个例子：
该数组为 [1 3 -1 -3 5 3 6 7]，kk 为 33。



窗口位置
最小值
最大值



[1 3 -1] -3 5 3 6 7
-1
3


1 [3 -1 -3] 5 3 6 7
-3
3


1 3 [-1 -3 5] 3 6 7
-3
5


1 3 -1 [-3 5 3] 6 7
-3
5


1 3 -1 -3 [5 3 6] 7
3
6


1 3 -1 -3 5 [3 6 7]
3
7


你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。
输入格式输入包含两行。
第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。
第二行有 n 个整数，代表数组的具体数值。
同行数据之间用空格隔开。
输出格式输出包含两个。
第一行输出，从左至右，每个位置滑动窗口中的最小值。
第二行输出，从左至右，每个位置滑动窗口中的最大值。
输入样例：8 31 3 -1 -3 5 3 6 7

输出样例：-1 -3 -3 -3 3 33 3 5 5 6 7
实现代码#include &lt;iostream&gt;using namespace std;const int N = 1e6+10;//原始数据，单调队列int a[N],q[N];int main()&#123;    int n, k;    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);      for(int i = 0; i &lt; n; i ++)        scanf(&quot;%d&quot;,&amp;a[i]);      int hh = 0, tt = -1;    for(int i = 0; i &lt; n; i++)    &#123;        //判断队头是否已经滑出窗口        //因为窗口只会后移一位，因此不需要循环        if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh])            hh ++;              while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i])            tt --;              q[++ tt] = i;              if(i &gt;= k - 1)            printf(&quot;%d &quot;, a[q[hh]]);              &#125;      puts(&quot;&quot;);        hh = 0, tt = -1;    for(int i = 0; i &lt; n; i++)    &#123;        //判断队头是否已经滑出窗口        //因为窗口只会后移一位，因此不需要循环        if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh])            hh ++;              while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i])            tt --;              q[++ tt] = i;              if(i &gt;= k - 1)            printf(&quot;%d &quot;, a[q[hh]]);              &#125;      puts(&quot;&quot;);        return 0;&#125;

他人题解1
解题思路（以最大值为例）：
由于我们需要求出的是滑动窗口的最大值。
如果当前的滑动窗口中有两个下标 i 和 j ，其中i在j的左侧（i&lt;j），并且i对应的元素不大于j对应的元素（nums[i]≤nums[j]），则：
当滑动窗口向右移动时，只要 i 还在窗口中，那么 j 一定也还在窗口中。这是由于 i 在 j 的左侧所保证的。
因此，由于 nums[j] 的存在，nums[i] 一定不会是滑动窗口中的最大值了，我们可以将nums[i]永久地移除。
因此我们可以使用一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组nums中对应的值是严格单调递减的。
当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。
为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果新元素大于等于队尾元素，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。
由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。
窗口向右移动的时候。因此我们还需要不断从队首弹出元素保证队列中的所有元素都是窗口中的，因此当队头元素在窗口的左边的时候，弹出队头。
#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;using namespace std;const int N = 1000010;int a[N];int main()&#123; int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];//读入数据 deque&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) &#123;     while(q.size() &amp;&amp; q.back() &gt; a[i]) //新进入窗口的值小于队尾元素，则队尾出队列         q.pop_back();     q.push_back(a[i]);//将新进入的元素入队     if(i - k &gt;= 1 &amp;&amp; q.front() == a[i - k])//若队头是否滑出了窗口，队头出队          q.pop_front();     if(i &gt;= k)//当窗口形成，输出队头对应的值         cout &lt;&lt; q.front() &lt;&lt;&quot; &quot;; &#125; q.clear(); cout &lt;&lt; endl; //最大值亦然 for(int i = 1; i &lt;= n; i++) &#123;     while(q.size() &amp;&amp; q.back() &lt; a[i]) q.pop_back();     q.push_back(a[i]);     if(i - k &gt;= 1 &amp;&amp; a[i - k] == q.front()) q.pop_front();      if(i &gt;= k) cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;; &#125;&#125;作者：Hasity链接：https://www.acwing.com/solution/content/97229/来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
他人题解2
思路：
最小值和最大值分开来做，两个for循环完全类似，都做以下四步：
解决队首已经出窗口的问题;解决队尾与当前元素a[i]不满足单调性的问题;将当前元素下标加入队尾;如果满足条件则输出结果;需要注意的细节：
上面四个步骤中一定要先3后4，因为有可能输出的正是新加入的那个元素;队列中存的是原数组的下标，取值时要再套一层，a[q[]];算最大值前注意将hh和tt重置;此题用cout会超时，只能用printf;hh从0开始，数组下标也要从0开始。
# include &lt;iostream&gt;using namespace std;const int N = 1000010;int a[N], q[N], hh, tt = -1;int main()&#123; int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; ++ i) &#123;     scanf(&quot;%d&quot;, &amp;a[i]);     if (i - k + 1 &gt; q[hh]) ++ hh;                  // 若队首出窗口，hh加1     while (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) -- tt;    // 若队尾不单调，tt减1     q[++ tt] = i;                                  // 下标加到队尾     if (i + 1 &gt;= k) printf(&quot;%d &quot;, a[q[hh]]);       // 输出结果 &#125; cout &lt;&lt; endl; hh = 0; tt = -1;                                   // 重置！ for (int i = 0; i &lt; n; ++ i) &#123;     if (i - k + 1 &gt; q[hh]) ++ hh;     while (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) -- tt;     q[++ tt] = i;     if (i + 1 &gt;= k) printf(&quot;%d &quot;, a[q[hh]]); &#125; return 0;&#125;
kmpTrie并查集堆Hash表[li,ri]:
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>算法</tag>
        <tag>基础算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>消除B站广告屏蔽插件的提示信息</title>
    <url>/2024/03/12/%E6%B6%88%E9%99%A4B%E7%AB%99%E5%B9%BF%E5%91%8A%E5%B1%8F%E8%94%BD%E6%8F%92%E4%BB%B6%E7%9A%84%E6%8F%90%E7%A4%BA%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[由于chrome用了某些插件, 所以在访问b站的时候出现了如下某些提示：
检测到您的页面展示可能受到浏览器插件影响，建议您将当前页面加入插件白名单，以保障您的浏览体验～

解决办法：
其一：去掉广告屏蔽器
其二：干掉这个横幅

在广告屏蔽插件中新建一个规则，内容为：

www.bilibili.com##.adblock-tips 

]]></content>
      <categories>
        <category>广告屏蔽</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>广告屏蔽</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>排序的总类 思想 效率</title>
    <url>/2022/09/08/%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%B1%BB_%E6%80%9D%E6%83%B3_%E6%95%88%E7%8E%87/</url>
    <content><![CDATA[准备随机数生成C++中没有自带的random函数，要实现随机数的生成就需要使用rand()和srand()。
不过，由于rand()的内部实现是用线性同余法做的，所以生成的并不是真正的随机数，而是在一定范围内可看为随机的伪随机数。
rand（）rand()会返回一随机数值, 范围在0至RAND_MAX 间。RAND_MAX定义在stdlib.h, 其值为2147483647。
参考代码#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;int main()&#123;    for (int i = 0; i &lt; 10; i++)    &#123;        cout &lt;&lt; rand()%100&lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;//在100中产生随机数， 但是因为没有随机种子所以，下一次运行也是这个数，因此就要引出srand



srand（）srand()可用来设置rand()产生随机数时的随机数种子。通过设置不同的种子，我们可以获取不同的随机数序列。
可以利用srand((int)(time(NULL))的方法，利用系统时钟，产生不同的随机数种子。不过要调用time()，需要加入头文件&lt; ctime &gt;。
参考代码#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;using namespace std;int main()&#123;    srand((int)time(0));  // 产生随机种子  把0换成NULL也行    for (int i = 0; i &lt; 10; i++)    &#123;        cout &lt;&lt; rand()%100&lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;



为了使用方便可以使用宏定义来替换rand函数（或者srand）
#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#define random(x) rand()%(x)using namespace std;int main()&#123;    srand((int)time(0));  // 产生随机种子  把0换成NULL也行    for (int i = 0; i &lt; 10; i++)    &#123;        cout &lt;&lt; random(100) &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;





其他的随机数的范围通式产生一定范围随机数的通用表示公式是：
要取得[0,n) 就是rand（）%n   表示 从0到n-1的数
要取得[a,b)的随机整数，使用(rand() % (b-a))+ a; 
要取得[a,b]的随机整数，使用(rand() % (b-a+1))+ a; 
要取得(a,b]的随机整数，使用(rand() % (b-a))+ a + 1; 
通用公式:a + rand() % n；其中的a是起始值，n是整数的范围。 
要取得a到b之间的随机整数，另一种表示：a + (int)b * rand() &#x2F; (RAND_MAX + 1)。 
要取得0～1之间的浮点数，可以使用rand() &#x2F; double(RAND_MAX)。
来源https://www.cnblogs.com/xiaokang01/p/9786751.html
显示计算机当前的时间冒泡排序思想
比较相邻元素，如果第一个比第二个大，就进行交换，使得最大的数（或者最小的数）在最后
继续第一步，总共需要进行 n - 1 次的循环，就可以实现排序完成

效率及特点
双重循环，因此时间复杂度是 n^2^
因为前后两个数是通过大于 或者 小于 的方法进行比较，因此排序具有稳定性。即如果两个数相等，排完序后两个数的前后关系不会改变。
可以进行优化，如果当前循环内没有进行交换，则认为数组已经是有序的了，可以停止排序直接退出。

实现代码/// &lt;summary&gt;/// 冒泡排序/// &lt;/summary&gt;/// &lt;param name=&quot;arr&quot;&gt;要排序的数组&lt;/param&gt;/// &lt;param name=&quot;len&quot;&gt;数组的长度&lt;/param&gt;void bubbleSort(int arr[], int len)&#123;        for (int i = 0; i &lt; len - 1; i++)    &#123;        for (int j = 0; j &lt; len - i - 1; j++)        &#123;            //如果当前元素比后一个元素的值大（或者小），就进行交换，循环一遍后使得最大的元素到达最后            if (arr[j] &gt; arr[j + 1])            &#123;                swap(arr[j], arr[j + 1]);            &#125;        &#125;    &#125;&#125;



优化后的版本
/// &lt;summary&gt;/// 优化过的冒泡排序/// &lt;/summary&gt;/// &lt;param name=&quot;arr&quot;&gt;数组名&lt;/param&gt;/// &lt;param name=&quot;len&quot;&gt;数组长度&lt;/param&gt;void bubbleSort_s(int arr[], int len)&#123;    bool flag ;    for (int i = 0; i &lt; len - 1; i++)    &#123;        flag = true;        for (int j = 0; j &lt; len - i - 1; j++)        &#123;            //如果当前元素比后一个元素的值大（或者小），就进行交换，循环一遍后使得最大的元素到达最后            if (arr[j] &gt; arr[j + 1])            &#123;                swap(arr[j], arr[j + 1]);                flag = false;//如果发生排序，则证明数列还不一定是有序的            &#125;        &#125;        if (flag == true)//如果这个循环中没有进行过交换，则认为数列已经有序，可以退出        &#123;            break;        &#125;    &#125;&#125;



选择排序思想
在当前数列中设第一位是最小值
将最小值的与当前数列的每一位元素进行比较，达到最小值是整个未排序的数列中最小的元素。
将最小值与数列的第一位进行交换，使得每次循环后，最小的在最前面。

效率和特点
和冒泡类似，都是双重循环，因此时间复杂度是n^2^。
不好继续优化，对于全是同一个数的数列来说不能像冒泡排序一样循环一遍后直接退出。
节省空间？因为对于结构体数组来说，每次判断只需要存储下标。
需要注意的是选择排序是不稳定的，可能出现两个相等的数前后的位置关系发生改变。

实现代码/// &lt;summary&gt;/// 选择排序/// &lt;/summary&gt;/// &lt;param name=&quot;arr&quot;&gt;要排序的数组名&lt;/param&gt;/// &lt;param name=&quot;len&quot;&gt;数组长度&lt;/param&gt;void selectSort(int arr[], int len)&#123;    int minn;//设定一个最小值    for (int i = 0; i &lt; len; i++)    &#123;        minn = i;// 设当前数列的第一个数是整个数列最小的数（或者最大的数）。只存储下标，方便交换        for (int j = i; j &lt; len; j++)        &#123;            if (arr[j] &lt; arr[minn])//如果当前的数比数列的第一个要小，则更新下标值.通过更改这个对比实现升序降序的选择。                minn = j;        &#125;        swap(arr[minn], arr[i]);//将当前数列的最小值与第一个互换，保证每次循环中最小的值在最前面    &#125;&#125;





插入排序思想
每次循环后使数组后移一位，然后将最小值或最大值插入到整个数列中第一个比他小的位置。

效率和特点
双重循环，n^2^
稳定。
最优情况：数列相等或者顺序符合要求，只会比较n - 1次
最坏情况：数列完全逆序，需要2(1 + 2 + .. + n-1)次的比较和移动(即 n^2^ - n)。

实现代码/// &lt;summary&gt;/// 插入排序/// &lt;/summary&gt;/// &lt;param name=&quot;arr&quot;&gt;数组名&lt;/param&gt;/// &lt;param name=&quot;len&quot;&gt;数组长度&lt;/param&gt;void insertSort(int arr[], int len)&#123;    int key;    for (int i = 1; i &lt; len; i++)    &#123;        key = arr[i];        int j = i - 1;        while ((j &gt;= 0) &amp;&amp; (key &lt; arr[j]))//只要j大于0并且关键字始终小于当前元素，就不停的后移        &#123;            arr[j + 1] = arr[j];//数组中的数 每次都后移一位            j--;        &#125;        arr[j + 1] = key;//把最小的值插入到前面    &#125;&#125;



快速排序思想
从数列中挑出一个元素，称为 “基准”（pivot）。可以是第一个元素，也可以是最后一个元素，或者中间的任意一个元素
重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

效率及特点
时间复杂度只有nlogn，因为是二叉树形式的递归

实现代码void quickSort(int arr[], int l, int r)&#123;    //如果左右边界相等了，就证明当前数列中只有一个元素，可以认为当前数列是有序的    if (l &gt;= r)        return;    int x = arr[l + r &gt;&gt; 1];//对数组取中间元素的值作为分界值    int i = l - 1;//生成本轮循环的左边界    int j = r + 1;//生成本轮循环的右边界    //使得分界值左边所有元素都小于分界值，右边所有元素都大于分界值。    while (i &lt; j)//开始本轮循环 要求左右边界不能碰面    &#123;        do &#123;            i++;        &#125; while (arr[i] &lt; x);//从头开始，寻找第一个值大于等于分界值的元素        do &#123;            j--;        &#125; while (arr[j] &gt; x);//从后往前，寻找第一个值小于等于分界值的元素        if (i &lt; j)//如果左指针比右指针小，就交换两个元素。可能会有越界的行为，因此在交换前需要先判断            swap(arr[i], arr[j]);    &#125;    //从分界点开始递归排序    quickSort(arr, l, j);    quickSort(arr, j + 1, r);&#125;









归并排序思想​		整个算法是基于基于分治的，先对要排序的数列求出中间值，然后以中间值为界限，将左右两边依次递归的进行排序，直到序列中只有一个元素为止。
​		在归并中，有两个指针分别指向左右两个序列的起始位置，依次判断当前指针指向的数的大小，并按要求将指定的数存入临时数组，此过程可以保证排序的稳定性。
​		当归并完成后，依次对两个数列进行“扫尾”的操作，将剩下的没有进行归并的数全部依次存入临时数组。
​		最后将临时数组返回或者复制到答案数组中。
效率及特点
虽然时间复杂度都是nlogn，但在对1e7的数量级的0-100的随机数进行排序的时候发现，归并排序只需要4秒钟，快排需要8秒。（排序数据相同，没修改过随机种子）。需要注意的是，用于归并的辅助数组一定要在归并函数外面定义，如果定义在内部会导致巨量的内存及时间的浪费（13秒，2G）
相比快排具有稳定性。
基于分治的思想

实现代码void mergeSort(int nums[], int l, int r)&#123;    //int* tmp = (int*)malloc((r - l) * sizeof(int));    if (l &gt;= r)        return;    int mid = l + r &gt;&gt; 1;    mergeSort(nums, l, mid);    mergeSort(nums, mid + 1, r);    int k = 0;    int i = l, j = mid + 1;    while (i &lt;= mid &amp;&amp; j &lt;= r)    &#123;        if (nums[i] &lt; nums[j])            tmp[k++] = nums[i++];        else            tmp[k++] = nums[j++];    &#125;    //进行扫尾操作    while (i &lt;= mid)        tmp[k++] = nums[i++];    while (j &lt;= r)        tmp[k++] = nums[j++];    for (int i = l, j = 0; i &lt;= r; i++, j++)    &#123;        nums[i] = tmp[j];    &#125;&#125;

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>第二代身份证号码的编码规则及校验</title>
    <url>/2023/06/25/%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E7%A0%81%E7%9A%84%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99%E5%8F%8A%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[身份证号码的编码规则及校验身份证号码的编码规则身份证号码共18位，由17位本体码和1位校验码组成。

前6位是地址码，表示登记户口时所在地的行政区划代码，依照《中华人民共和国行政区划代码》国家标准（GB&#x2F;T2260）的规定执行；
7到14位是出生年月日，采用YYYYMMDD格式；
15到17位是顺序码，表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编订的顺序号，顺序码的奇数分配给男性，偶数分配给女性，即第17位奇数表示男性，偶数表示女性；
第18位是校验码，采用ISO 7064:1983, MOD 11-2校验字符系统，计算规则下一章节说明。

一代身份证与二代身份证的区别在于：

一代身份证是15位，二代身份证是18位；
一代身份证出生年月日采用YYMMDD格式，二代身份证出生年月日采用YYYYMMDD格式；
一代身份证无校验码，二代身份证有校验码。

校验码计算规则身份证号码中各个位置上的号码字符值应满足下列公式的校验：$$\sum_{i&#x3D;1}^{18}(a\pmb{i} * W\pmb{i})\equiv(mod\ 11)$$

i表示号码字符从右至左包括校验码字符在内的位置序号；

ai 表示第i位置上的号码字符值， a1 是身份证号码第18位校验码；

Wi位置上的加权因子，加权因子计算公式：$$W\pmb{i}&#x3D;2^{i-1}(mod\ 11)$$


样例以370683198901117657这个身份证号为例，根据上述公式进行校验



i
18
17
16
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1



ai
3
7
0
6
8
3
1
9
8
9
0
1
1
1
7
6
5
7


Wi
7
9
10
5
8
4
2
1
6
3
7
9
10
5
8
4
2
1


ai*Wi
21
63
0
30
64
12
2
9
48
27
0
9
10
5
56
24
10
7


将每一位的ai*Wi相加，得到和为390，
将390模除11，得到余数5。根据下方对照表得到对应的数为7，与身份证最后一位相符，至此验证成功。



余数
0
1
2
3
4
5
6
7
8
9
10



对照值
1
0
X
9
8
7
6
5
4
3
2


实际应用在金融行业软件系统中，对于身份证号码的采集、校验用途甚广。

身份证号码前6位，可采集客户户籍所在地，只需将国家标准GB&#x2F;T 2260中定义的行政区划代码导入数据库，程序中进行映射即可；但需要注意的是，行政区划代码每隔几年会修订一次，从笔者手上的2007版来看，共经历了1982年、1984年、1986年、1988年、1991年、1995年、1999年、2002年、2007年九次修订，所以要预留更新机制；
身份证号码7到14位，可采集客户的出生日期、年龄、生日；
身份证号码17位，可采集客户的性别，奇数表示男性，偶数表示女性；
身份证号码的验证渠道，不管验证成功与否，往往都是收费的，比如银行渠道、公安部渠道，在发往这些渠道验证之前，先对其进行长度、正则表达式、校验码的验证，能够适当提高收费验证的成功率，节省成本支出；而且也可以提升用户体验，在用户输入错误时及时反馈而不必等待验证渠道结果的返回。

下面，就以实际代码为例，说明身份证号码校验的方法。首先，给出身份证号码的正则表达式：
/** * 18位二代身份证号码的正则表达式 */public static final String REGEX_ID_NO_18 = &quot;^&quot;        + &quot;\\d&#123;6&#125;&quot; // 6位地区码        + &quot;(18|19|([23]\\d))\\d&#123;2&#125;&quot; // 年YYYY        + &quot;((0[1-9])|(10|11|12))&quot; // 月MM        + &quot;(([0-2][1-9])|10|20|30|31)&quot; // 日DD        + &quot;\\d&#123;3&#125;&quot; // 3位顺序码        + &quot;[0-9Xx]&quot; // 校验码        + &quot;$&quot;;/** * 15位一代身份证号码的正则表达式 */public static final String REGEX_ID_NO_15 = &quot;^&quot;        + &quot;\\d&#123;6&#125;&quot; // 6位地区码        + &quot;\\d&#123;2&#125;&quot; // 年YYYY        + &quot;((0[1-9])|(10|11|12))&quot; // 月MM        + &quot;(([0-2][1-9])|10|20|30|31)&quot; // 日DD        + &quot;\\d&#123;3&#125;&quot;// 3位顺序码        + &quot;$&quot;;

校验身份证号码：
/** * 校验身份证号码 *  * &lt;p&gt; * 适用于18位的二代身份证号码 * &lt;/p&gt; *  * @param IDNo18 身份证号码 * @return true - 校验通过&lt;br&gt; *         false - 校验不通过 * @throws IllegalArgumentException  *             如果身份证号码为空或长度不为18位或不满足身份证号码组成规则 *             &lt;i&gt;6位地址码+ *             出生年月日YYYYMMDD+3位顺序码 *             +0~9或X(x)校验码&lt;/i&gt; */public static boolean checkIDNo(String IDNo18) &#123;    // 校验身份证号码的长度    if (!checkStrLength(IDNo18, 18)) &#123;        throw new IllegalArgumentException();    &#125;    // 匹配身份证号码的正则表达式    if (!regexMatch(IDNo18, REGEX_ID_NO_18)) &#123;        throw new IllegalArgumentException();    &#125;    // 校验身份证号码的验证码    return validateCheckNumber(IDNo18);&#125;/** * 校验字符串长度 *  * @param inputString 字符串 * @param len 预期长度 * @return true - 校验通过&lt;br&gt; *         false - 校验不通过 */private static boolean checkStrLength(String inputString, int len) &#123;    if (inputString == null || inputString.length() != len) &#123;        return false;    &#125;    return true;&#125;/** * 匹配正则表达式 *  * @param inputString 字符串 * @param regex 正则表达式 * @return true - 校验通过&lt;br&gt; *         false - 校验不通过 */private static boolean regexMatch(String inputString, String regex) &#123;    return inputString.matches(regex);&#125;/** * 校验码校验 * &lt;p&gt; * 适用于18位的二代身份证号码 * &lt;/p&gt; *  * @param IDNo18 身份证号码 * @return true - 校验通过&lt;br&gt; *         false - 校验不通过 */private static boolean validateCheckNumber(String IDNo18) &#123;    // 加权因子    int[] W = &#123; 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 &#125;;    char[] IDNoArray = IDNo18.toCharArray();    int sum = 0;    for (int i = 0; i &lt; W.length; i++) &#123;        sum += Integer.parseInt(String.valueOf(IDNoArray[i])) * W[i];    &#125;    // 校验位是X，则表示10    if (IDNoArray[17] == &#x27;X&#x27; || IDNoArray[17] == &#x27;x&#x27;) &#123;        sum += 10;    &#125; else &#123;        sum += Integer.parseInt(String.valueOf(IDNoArray[17]));    &#125;    // 如果除11模1，则校验通过    return sum % 11 == 1;&#125;

计算校验码
/** * 计算身份证号码的校验码 * &lt;p&gt; * 适用于18位的二代身份证号码，身份证号码由17位本体码和1位校验码组成 * &lt;/p&gt; *  * @param masterNumber 本体码 * @return 身份证号码 * @throws IllegalArgumentException  *             如果本体码为空或长度不为17位或不满足本体码组成规则 *             &lt;i&gt;6位地址码+ *             出生年月日YYYYMMDD+3位顺序码&lt;/i&gt; */public static String computeIDNoCheckNumber(String masterNumber) &#123;    // 校验本体码的长度    if (!checkStrLength(masterNumber, 17)) &#123;        throw new IllegalArgumentException();    &#125;    // 匹配本体码的正则表达式    if (!regexMatch(masterNumber, REGEX_MASTER_NUMBER)) &#123;        throw new IllegalArgumentException();    &#125;    // 计算校验码    String checkNumber = computeCheckNumber(masterNumber);    // 返回本体码+校验码=完整的身份证号码    return masterNumber + checkNumber;&#125;/** * 计算校验码 * &lt;p&gt; * 适用于18位的二代身份证号码 * &lt;/p&gt; *  * @param masterNumber 本体码 * @return 校验码 */private static String computeCheckNumber(String masterNumber) &#123;    // 加权因子    int[] W = &#123; 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 &#125;;    char[] masterNumberArray = masterNumber.toCharArray();    int sum = 0;    for (int i = 0; i &lt; W.length; i++) &#123;        sum += Integer.parseInt(String.valueOf(masterNumberArray[i])) * W[i];    &#125;    // 根据同余定理得到的校验码数组    String[] checkNumberArray = &#123; &quot;1&quot;, &quot;0&quot;, &quot;X&quot;, &quot;9&quot;, &quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;, &quot;4&quot;,            &quot;3&quot;, &quot;2&quot; &#125;;    // 得到校验码    String checkNumber = checkNumberArray[sum % 11];    // 返回校验码    return checkNumber;&#125;

虽然15位的一代身份证已经停用，但是难免有需要用到将15位的一代身份证升级为18位的二代身份证的情形，代码示例如下：
/** * 15位一代身份证号码升级18位二代身份证号码 * &lt;p&gt; * 为15位的一代身份证号码增加年份的前2位和最后1位校验码 * &lt;/p&gt; *  * @param IDNo15 15位的一代身份证号码 * @return 18位的二代身份证号码 */public static String updateIDNo15to18(String IDNo15) &#123;    // 校验身份证号码的长度    if (!checkStrLength(IDNo15, 15)) &#123;        throw new IllegalArgumentException();    &#125;    // 匹配身份证号码的正则表达式    if (!regexMatch(IDNo15, REGEX_ID_NO_15)) &#123;        throw new IllegalArgumentException();    &#125;    // 得到本体码，因一代身份证皆为19XX年生人，年份中增加19，组成4位    String masterNumber = IDNo15.substring(0, 6) + &quot;19&quot; + IDNo15.substring(6);    // 计算校验码    String checkNumber = computeCheckNumber(masterNumber);    // 返回本体码+校验码=完整的身份证号码    return masterNumber + checkNumber;&#125;







最后 来个合集
package com.godson.util;import java.math.BigInteger;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * ISO7064工具类 * &lt;p&gt; * 使用ISO7064规范中定义的校验字符系统进行字符串的校验以及生成校验字符 * &lt;/p&gt; *  */public class ISO7064Util &#123;    /**     * ISO7064规范中定义的校验字符系统     * &lt;p&gt;     * &lt;li&gt;ISO 7064, MOD 11-2使用 &#123;@link #ISO_7064_MOD_11_2&#125;表示     * &lt;/li&gt;     * &lt;li&gt;ISO 7064, MOD 37-2使用&#123;@link #ISO_7064_MOD_37_2&#125;表示&lt;/li&gt;     * &lt;li&gt;ISO 7064, MOD 97-10使用&#123;@link #ISO_7064_MOD_97_10&#125;     * 表示&lt;/li&gt;     * &lt;li&gt;     * ISO 7064, MOD 661-26使用 &#123;@link #ISO_7064_MOD_661_26&#125;表示     * &lt;/li&gt;     * &lt;li&gt;ISO 7064, MOD 1271-36使用     * &#123;@link #ISO_7064_MOD_1271_36&#125;表示&lt;/li&gt;     * &lt;li&gt;ISO 7064, MOD 11,10使用     * &#123;@link #ISO_7064_MOD_11_HYBRID_10&#125;表示&lt;/li&gt;     * &lt;li&gt;ISO 7064, MOD 27,26使用     * &#123;@link #ISO_7064_MOD_27_HYBRID_26&#125;表示&lt;/li&gt;     * &lt;li&gt;ISO 7064, MOD 37,36使用     * &#123;@link #ISO_7064_MOD_37_HYBRID_36&#125;表示&lt;/li&gt;     */    public enum Designation &#123;        /** ISO 7064, MOD 11-2 */        ISO_7064_MOD_11_2,        /** ISO 7064, MOD 37-2 */        ISO_7064_MOD_37_2,        /** ISO 7064, MOD 97-10 */        ISO_7064_MOD_97_10,        /** ISO 7064, MOD 661-26 */        ISO_7064_MOD_661_26,        /** ISO 7064, MOD 1271-36 */        ISO_7064_MOD_1271_36,        /** ISO 7064, MOD 11,10 */        ISO_7064_MOD_11_HYBRID_10,        /** ISO 7064, MOD 27,26 */        ISO_7064_MOD_27_HYBRID_26,        /** ISO 7064, MOD 37,36 */        ISO_7064_MOD_37_HYBRID_36    &#125;    /**     * 计算校验字符     *      * @param withoutCheckCharacterString 不含校验字符的字符串     * @param designation 校验字符系统     * @return 校验字符     * @throws IllegalArgumentException     *             如果字符串不匹配对应校验字符系统的正则表达式     */    public static String computeCheckCharacter(            String withoutCheckCharacterString, Designation designation) &#123;        // 检查字符串是否匹配对应校验字符系统的正则表达式        if (!RegexMatcher.withoutCheckCharacterStringIsMatch(                withoutCheckCharacterString, designation)) &#123;            throw new IllegalArgumentException();        &#125;        // 计算校验字符        return CheckCharacterComputor.compute(withoutCheckCharacterString,                designation);    &#125;    /**     * 校验字符串     *      * @param withCheckCharacterString 含校验字符的字符串     * @param designation 校验字符系统     * @return true - 校验通过&lt;br&gt;     *         false-校验不通过     * @throws IllegalArgumentException     *             如果字符串不匹配对应校验字符系统的正则表达式     */    public static boolean checkString(String withCheckCharacterString,            Designation designation) &#123;        // 检查字符串是否匹配对应校验字符系统的正则表达式        if (!RegexMatcher.withCheckCharacterStringIsMatch(                withCheckCharacterString, designation)) &#123;            throw new IllegalArgumentException();        &#125;        // 校验字符串        return CheckCharacterSystemValidator.validate(withCheckCharacterString,                designation);    &#125;    /**     * 正则表达式匹配器     * &lt;p&gt;     * 检查字符串是否匹配对应校验字符系统的正则表达式     * &lt;/p&gt;     * &lt;table border=&quot;1&quot;&gt;     * &lt;tr&gt;     * &lt;th&gt;系统名称&lt;/th&gt;     * &lt;th&gt;适用范围&lt;/th&gt;     * &lt;th&gt;校验码数目及类型&lt;/th&gt;     * &lt;/tr&gt;     * &lt;tr&gt;     * &lt;td&gt;ISO 7064, MOD 11-2&lt;/td&gt;     * &lt;td&gt;数字&lt;/td&gt;     * &lt;td&gt;1位数字或附加符X&lt;/td&gt;     * &lt;/tr&gt;     * &lt;tr&gt;     * &lt;td&gt;ISO 7064, MOD 37-2&lt;/td&gt;     * &lt;td&gt;字母数字&lt;/td&gt;     * &lt;td&gt;1位数字或字母或附加符*&lt;/td&gt;     * &lt;/tr&gt;     * &lt;tr&gt;     * &lt;td&gt;ISO 7064, MOD 97-10&lt;/td&gt;     * &lt;td&gt;数字&lt;/td&gt;     * &lt;td&gt;2位数字&lt;/td&gt;     * &lt;/tr&gt;     * &lt;tr&gt;     * &lt;td&gt;ISO 7064, MOD 661-26&lt;/td&gt;     * &lt;td&gt;字母&lt;/td&gt;     * &lt;td&gt;2位字母&lt;/td&gt;     * &lt;/tr&gt;     * &lt;tr&gt;     * &lt;td&gt;ISO 7064, MOD 1271-36&lt;/td&gt;     * &lt;td&gt;字母数字&lt;/td&gt;     * &lt;td&gt;2位数字或字母&lt;/td&gt;     * &lt;/tr&gt;     * &lt;tr&gt;     * &lt;td&gt;ISO 7064, MOD 11,10&lt;/td&gt;     * &lt;td&gt;数字&lt;/td&gt;     * &lt;td&gt;1位数字&lt;/td&gt;     * &lt;/tr&gt;     * &lt;tr&gt;     * &lt;td&gt;ISO 7064, MOD 27,26&lt;/td&gt;     * &lt;td&gt;字母&lt;/td&gt;     * &lt;td&gt;1位字母&lt;/td&gt;     * &lt;/tr&gt;     * &lt;tr&gt;     * &lt;td&gt;ISO 7064, MOD 37,36&lt;/td&gt;     * &lt;td&gt;字母数字&lt;/td&gt;     * &lt;td&gt;1位数字或字母&lt;/td&gt;     * &lt;/tr&gt;     * &lt;/table&gt;     */    private static class RegexMatcher &#123;        /**         * 检查不含校验字符的字符串是否匹配对应校验字符系统的正则表达式         *          * @param withoutCheckCharacterString 不含校验字符的字符串         * @param designation 校验字符系统         * @return true - 匹配&lt;br&gt;         *         false - 不匹配         */        static boolean withoutCheckCharacterStringIsMatch(                String withoutCheckCharacterString, Designation designation) &#123;            return regexMatch(withoutCheckCharacterString,                    REGEX_MAPPING_WITHOUT_CHECK_CHARACTER_STRING                            .get(designation));        &#125;        /**         * 检查有校验字符的字符串是否匹配对应校验字符系统的正则表达式         *          * @param withCheckCharacterString 含校验字符的字符串         * @param designation 校验字符系统         * @return true - 匹配&lt;br&gt;         *         false - 不匹配         */        static boolean withCheckCharacterStringIsMatch(                String withCheckCharacterString, Designation designation) &#123;            return regexMatch(withCheckCharacterString,                    REGEX_MAPPING_WITH_CHECK_CHARACTER_STRING.get(designation));        &#125;        /** 数字正则表达式 */        static final String REGEX_NUMBERIC_STRINGS = &quot;^[0-9]+$&quot;;        /** 含补充校验字符X的数字正则表达式 */        static final String REGEX_NUMBERIC_STRINGS_WITH_SUPPLEMENTARY_CHECK_CHARACTER = &quot;^[0-9]+[0-9X]$&quot;;        /** 字母正则表达式 */        static final String REGEX_ALPHABETIC_STRINGS = &quot;^[A-Z]+$&quot;;        /** 字母数字正则表达式 */        static final String REGEX_ALPHANUMBERIC_STRINGS = &quot;^[0-9A-Z]+$&quot;;        /** 含补充校验字符*的字母数字表达式 */        static final String REGEX_ALPHANUMBERIC_STRINGS_WITH_SUPPLEMENTARY_CHECK_CHARACTER = &quot;^[0-9A-Z]+[0-9A-Z*]$&quot;;        /** 校验字符系统对应的正则表达式（不含校验字符） */        @SuppressWarnings(&quot;serial&quot;)        static final Map&lt;Designation, String&gt; REGEX_MAPPING_WITHOUT_CHECK_CHARACTER_STRING = new HashMap&lt;Designation, String&gt;() &#123;            &#123;                put(Designation.ISO_7064_MOD_11_2, REGEX_NUMBERIC_STRINGS);                put(Designation.ISO_7064_MOD_37_2, REGEX_ALPHANUMBERIC_STRINGS);                put(Designation.ISO_7064_MOD_97_10, REGEX_NUMBERIC_STRINGS);                put(Designation.ISO_7064_MOD_661_26, REGEX_ALPHABETIC_STRINGS);                put(Designation.ISO_7064_MOD_1271_36,                        REGEX_ALPHANUMBERIC_STRINGS);                put(Designation.ISO_7064_MOD_11_HYBRID_10,                        REGEX_NUMBERIC_STRINGS);                put(Designation.ISO_7064_MOD_27_HYBRID_26,                        REGEX_ALPHABETIC_STRINGS);                put(Designation.ISO_7064_MOD_37_HYBRID_36,                        REGEX_ALPHANUMBERIC_STRINGS);            &#125;        &#125;;        /** 校验字符系统对应的正则表达式（含校验字符） */        @SuppressWarnings(&quot;serial&quot;)        static final Map&lt;Designation, String&gt; REGEX_MAPPING_WITH_CHECK_CHARACTER_STRING = new HashMap&lt;Designation, String&gt;() &#123;            &#123;                put(Designation.ISO_7064_MOD_11_2,                        REGEX_NUMBERIC_STRINGS_WITH_SUPPLEMENTARY_CHECK_CHARACTER);                put(Designation.ISO_7064_MOD_37_2,                        REGEX_ALPHANUMBERIC_STRINGS_WITH_SUPPLEMENTARY_CHECK_CHARACTER);                put(Designation.ISO_7064_MOD_97_10, REGEX_NUMBERIC_STRINGS);                put(Designation.ISO_7064_MOD_661_26, REGEX_ALPHABETIC_STRINGS);                put(Designation.ISO_7064_MOD_1271_36,                        REGEX_ALPHANUMBERIC_STRINGS);                put(Designation.ISO_7064_MOD_11_HYBRID_10,                        REGEX_NUMBERIC_STRINGS);                put(Designation.ISO_7064_MOD_27_HYBRID_26,                        REGEX_ALPHABETIC_STRINGS);                put(Designation.ISO_7064_MOD_37_HYBRID_36,                        REGEX_ALPHANUMBERIC_STRINGS);            &#125;        &#125;;        static boolean regexMatch(String inputString, String regex) &#123;            Pattern pattern = Pattern.compile(regex);            Matcher matcher = pattern.matcher(inputString);            return matcher.matches();        &#125;    &#125;    /** 适用于数字的校验字符系统的数值对应表 */    private static final String[] NUMBERIC_STRINGS = &#123; &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;,            &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;X&quot; &#125;;    /** 适用于字母的校验字符系统的数值对应表 */    private static final String[] ALPHABETIC_STRINGS = &#123; &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;,            &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;,            &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot; &#125;;    /** 适用于字母数字的校验字符系统的数值对应表 */    private static final String[] ALPHANUMBERIC_STRINGS = &#123; &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;,            &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;,            &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;,            &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;*&quot; &#125;;    /**     * 校验字符系统验证器     */    private static class CheckCharacterSystemValidator &#123;        static boolean validate(String inputString, Designation designation) &#123;            switch (designation) &#123;                case ISO_7064_MOD_11_2:                case ISO_7064_MOD_37_2:                case ISO_7064_MOD_97_10:                case ISO_7064_MOD_661_26:                case ISO_7064_MOD_1271_36:                    return validatePureSystem(inputString, designation);                case ISO_7064_MOD_11_HYBRID_10:                case ISO_7064_MOD_27_HYBRID_26:                case ISO_7064_MOD_37_HYBRID_36:                    return validateHybridSystem(inputString, designation);                default:                    return false;            &#125;        &#125;        /**         * 纯系统校验         */        static boolean validatePureSystem(String inputString,                Designation designation) &#123;            int M = 0; // 模数            int r = 0; // 基数            List&lt;String&gt; mapping = null;            switch (designation) &#123;                case ISO_7064_MOD_11_2:                    M = 11;                    r = 2;                    mapping = Arrays.asList(NUMBERIC_STRINGS);                    break;                case ISO_7064_MOD_37_2:                    M = 37;                    r = 2;                    mapping = Arrays.asList(ALPHANUMBERIC_STRINGS);                    break;                case ISO_7064_MOD_97_10:                    M = 97;                    r = 10;                    mapping = Arrays.asList(NUMBERIC_STRINGS);                    break;                case ISO_7064_MOD_661_26:                    M = 661;                    r = 26;                    mapping = Arrays.asList(ALPHABETIC_STRINGS);                    break;                case ISO_7064_MOD_1271_36:                    M = 1271;                    r = 36;                    mapping = Arrays.asList(ALPHANUMBERIC_STRINGS);                    break;                default:                    return false;            &#125;            char[] strArray = inputString.toCharArray();            int S = 0;            int n = strArray.length;            for (int i = 1; i &lt;= n; i++) &#123;                // 注意这里不要使用Math的pow方法                S += mapping.indexOf(String.valueOf(strArray[i - 1]))                        * BigInteger.valueOf(r).pow(n - i)                                .mod(BigInteger.valueOf(M)).intValue();            &#125;            return S % M == 1;        &#125;        /**         * 混合系统校验         */        static boolean validateHybridSystem(String inputString,                Designation designation) &#123;            int M = 0; // 模数1            List&lt;String&gt; mapping = null;            switch (designation) &#123;                case ISO_7064_MOD_11_HYBRID_10:                    M = 10;                    mapping = Arrays.asList(NUMBERIC_STRINGS);                    break;                case ISO_7064_MOD_27_HYBRID_26:                    M = 26;                    mapping = Arrays.asList(ALPHABETIC_STRINGS);                    break;                case ISO_7064_MOD_37_HYBRID_36:                    M = 36;                    mapping = Arrays.asList(ALPHANUMBERIC_STRINGS);                    break;                default:                    return false;            &#125;            int Mplus1 = M + 1; // 模数2            char[] strArray = inputString.toCharArray();            int S = M + mapping.indexOf(String.valueOf(strArray[0]));            int P = 0;            for (int i = 1; i &lt; strArray.length; i++) &#123;                P = ((S % M == 0 ? M : S % M) * 2) % Mplus1;                S = P + mapping.indexOf(String.valueOf(strArray[i]));            &#125;            return S % M == 1;        &#125;    &#125;    /**     * 校验字符生成器     */    private static class CheckCharacterComputor &#123;        static String compute(String inputString, Designation designation) &#123;            switch (designation) &#123;                case ISO_7064_MOD_11_2:                case ISO_7064_MOD_37_2:                    return polynomialMethod4PureSystemWith1CheckChar(                            inputString, designation);                case ISO_7064_MOD_97_10:                case ISO_7064_MOD_661_26:                case ISO_7064_MOD_1271_36:                    return polynomialMethod4PureSystemWith2CheckChar(                            inputString, designation);                case ISO_7064_MOD_11_HYBRID_10:                case ISO_7064_MOD_27_HYBRID_26:                case ISO_7064_MOD_37_HYBRID_36:                    return recursiveMethod4HybridSystemWith1CheckChar(                            inputString, designation);                default:                    return null;            &#125;        &#125;        /**         * 通过多项式法计算纯系统一位校验字符         */        static String polynomialMethod4PureSystemWith1CheckChar(String str,                Designation designation) &#123;            int M = 0; // 模数            int r = 0; // 基数            List&lt;String&gt; mapping = null;            switch (designation) &#123;                case ISO_7064_MOD_11_2:                    M = 11;                    r = 2;                    mapping = Arrays.asList(NUMBERIC_STRINGS);                    break;                case ISO_7064_MOD_37_2:                    M = 37;                    r = 2;                    mapping = Arrays.asList(ALPHANUMBERIC_STRINGS);                    break;                default:                    break;            &#125;            char[] strArray = str.toCharArray();            int S = 0;            int n = strArray.length + 1;            for (int i = n; i &gt;= 2; i--) &#123;                // 注意这里不要使用Math的pow方法                S += mapping.indexOf(String.valueOf(strArray[n - i]))                        * BigInteger.valueOf(r).pow(i - 1)                                .mod(BigInteger.valueOf(M)).intValue();            &#125;            return mapping.get((M + 1 - S % M) % M);        &#125;        /**         * 通过多项式法计算纯系统二位校验字符         */        static String polynomialMethod4PureSystemWith2CheckChar(String str,                Designation designation) &#123;            int M = 0; // 模数            int r = 0; // 基数            List&lt;String&gt; mapping = null;            switch (designation) &#123;                case ISO_7064_MOD_97_10:                    M = 97;                    r = 10;                    mapping = Arrays.asList(NUMBERIC_STRINGS);                    break;                case ISO_7064_MOD_661_26:                    M = 661;                    r = 26;                    mapping = Arrays.asList(ALPHABETIC_STRINGS);                    break;                case ISO_7064_MOD_1271_36:                    M = 1271;                    r = 36;                    mapping = Arrays.asList(ALPHANUMBERIC_STRINGS);                    break;                default:                    break;            &#125;            char[] strArray = str.toCharArray();            int S = 0;            int n = strArray.length + 2;            for (int i = n; i &gt;= 3; i--) &#123;                // 注意这里不要使用Math的pow方法                S += mapping.indexOf(String.valueOf(strArray[n - i]))                        * BigInteger.valueOf(r).pow(i - 1)                                .mod(BigInteger.valueOf(M)).intValue();            &#125;            return mapping.get(((M + 1 - S % M) % M) / r)                    + mapping.get(((M + 1 - S % M) % M) % r);        &#125;        /**         * 通过递归法法计算混合系统一位校验字符         */        static String recursiveMethod4HybridSystemWith1CheckChar(                String inputString, Designation designation) &#123;            int M = 0; // 模数1            List&lt;String&gt; mapping = null;            switch (designation) &#123;                case ISO_7064_MOD_11_HYBRID_10:                    M = 10;                    mapping = Arrays.asList(NUMBERIC_STRINGS);                    break;                case ISO_7064_MOD_27_HYBRID_26:                    M = 26;                    mapping = Arrays.asList(ALPHABETIC_STRINGS);                    break;                case ISO_7064_MOD_37_HYBRID_36:                    M = 36;                    mapping = Arrays.asList(ALPHANUMBERIC_STRINGS);                    break;                default:                    break;            &#125;            int Mplus1 = M + 1; // 模数2            char[] strArray = inputString.toCharArray();            int S = 0;            int P = M;            int n = strArray.length + 1;            for (int i = n; i &gt;= 2; i--) &#123;                S = P + mapping.indexOf(String.valueOf(strArray[n - i]));                P = ((S % M == 0 ? M : S % M) * 2) % Mplus1;            &#125;            return mapping.get((M + 1 - P % M) % M);        &#125;    &#125;&#125;





算法设想
由一个字母作为开头，用于区分物品大类别。该字母区分大小写，对于字母的转换公式为：
如果这个字母是大写的，则分别对应1、2、3、…、26；
如果这个字母是大写的，则分别对应27、28、29、…、52。


第二位是一个字母，与第一位一样，区分大小写，用于表明小类别。包括不限于：（具体对应规则待定）
单片机相关
芯片
贴片原件
电池
电路板


第三位到第五位为纯数字。从001起，截止999。
第六到第十位比较特殊：
对于收纳盒指示而言，这五位可以缺省。
对于物品来说，这五位不可缺省，范围是00001-99999。
对于第五位和第六位之间使用连字符-作为连接，但这一位只作为区分，不参与校验运算。


第六位&#x2F;第十一位为校验码，用于校验数据。

样例
对于外部收纳部分：AA001X
对于物品部分：AA001X-00001

校验方法与身份证校验类似，字母位要转换成对应的数字然后参与运算。
]]></content>
      <categories>
        <category>程序片段</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>编码规则</tag>
        <tag>程序片段</tag>
      </tags>
  </entry>
  <entry>
    <title>One-KVM Docker应用扩展</title>
    <url>/2024/01/14/%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E_One-KVM%20Docker%E5%BA%94%E7%94%A8%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[One-KVM Docker应用扩展总览：
安装OpenWRT（Docker版）
安装Casaos
安装Docker玩客云内部储存空间为8G，如果要使用Docker应用请注意储存空间使用情况。
本文所写Docker应用无需额外设置都可以与PiKVM共存，不必为此修改PiKVM配置文件。
#解决docker无法启动报错的问题，系统使用默认nftables代替了iptables，下面两行将iptables命令替换为原始版本的iptablessudo update-alternatives --set iptables /usr/sbin/iptables-legacysudo update-alternatives --set ip6tables /usr/sbin/ip6tables-legacy#安装Dockerapt install docker.io

安装docker-compose#!/bin/bash# 定义安装函数install_docker_compose() &#123;    # 获取系统类型和架构    OS_NAME=$(uname -s | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;)    OS_ARCH=$(uname -m)    # 特定架构的处理    if [ &quot;$OS_ARCH&quot; == &quot;x86_64&quot; ]; then        OS_ARCH=&quot;amd64&quot;    elif [ &quot;$OS_ARCH&quot; == &quot;armv7l&quot; ]; then        OS_ARCH=&quot;armv7&quot;    elif [ &quot;$OS_ARCH&quot; == &quot;aarch64&quot; ]; then        OS_ARCH=&quot;arm64&quot;    else        echo &quot;不支持的架构: $OS_ARCH&quot;        exit 1    fi    # 构建下载 URL    DOWNLOAD_URL=&quot;https://mirror.ghproxy.com/https://github.com/docker/compose/releases/download/$(curl -s https://api.github.com/repos/docker/compose/releases/latest | jq &#x27;.tag_name&#x27; | tr -d &#x27;&quot;&#x27;)/docker-compose-$&#123;OS_NAME&#125;-$&#123;OS_ARCH&#125;&quot;    # 下载并安装 Docker Compose    echo &quot;正在下载 Docker Compose...&quot;    sudo curl -L $&#123;DOWNLOAD_URL&#125; -o /usr/local/bin/docker-compose        # 添加执行权限    sudo chmod +x /usr/local/bin/docker-compose    # 测试安装    echo &quot;Docker Compose 安装完成。版本信息：&quot;    docker-compose version&#125;# 定义卸载函数uninstall_docker_compose() &#123;    # 卸载 Docker Compose    echo &quot;正在卸载 Docker Compose...&quot;    sudo rm -f /usr/local/bin/docker-compose    echo &quot;Docker Compose 已卸载。&quot;&#125;# 主逻辑case &quot;$1&quot; in    install)        install_docker_compose        ;;    uninstall)        uninstall_docker_compose        ;;    *)        echo &quot;使用方法: $0 &#123;install|uninstall&#125;&quot;        ;;esac

添加执行权限：chmod +x docker_compose_manager.sh
.&#x2F;docker_compose_manager.sh install
.&#x2F;docker_compose_manager.sh uninstall
玩客云安装OpenWRT（Docker版）系统环境：Armbian 22.11.0-trunk Jammy Linux onecloud 5.10.149-meson
Docker版本：Docker version 24.0.5, build 24.0.5-0ubuntu1~22.04.1
OpenWRT默认账号和密码：root&#x2F;root
效果演示![img](.&#x2F;Image&#x2F;One-KVM Docker应用扩展.assets&#x2F;1705214673188-6.png)
![img](.&#x2F;Image&#x2F;One-KVM Docker应用扩展.assets&#x2F;1705214673170-1.png)
安装命令#打开网卡混杂模式ip link set eth0 promisc on#subnet为玩客云所在网段，gateway为主路由地址docker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 -o parent=eth0 macnet#Docker换源nano /etc/docker/daemon.json&#123;&quot;registry-mirrors&quot;:[&quot;https://hub-mirror.c.163.com/&quot;,&quot;https://docker.mirrors.ustc.edu.cn/&quot;]&#125;#拉取OpenWRT的Docker镜像docker pull dreamwsbg/openwrt:9.0docker run -d --name=&quot;openwrt&quot; --restart unless-stopped --network macnet --privileged dreamwsbg/openwrt:9.0 /sbin/init#进入容器内部docker exec -it openwrt bash#修改添加OpenWRT网络设置（括号记得删掉）nano /etc/config/networkoption ipaddr &#x27;192.168.1.5&#x27; （oenpwrt地址）option gateway &#x27;192.168.1.1&#x27; (网关)option broadcast &#x27;192.168.1.255&#x27;option dns &#x27;192.168.1.1&#x27; (dns)#使网络修改生效 /etc/init.d/network restart 

![img](.&#x2F;Image&#x2F;One-KVM Docker应用扩展.assets&#x2F;1705214673170-2.png)
解决一些问题OpenWRT ttyd设置接口”未指定”即可使用网页终端
![img](.&#x2F;Image&#x2F;One-KVM Docker应用扩展.assets&#x2F;1705214673170-3.png)
安装Casaos效果演示![img](.&#x2F;Image&#x2F;One-KVM Docker应用扩展.assets&#x2F;1705214673171-4.png)
![img](.&#x2F;Image&#x2F;One-KVM Docker应用扩展.assets&#x2F;1705214673171-5.png)
安装命令CasaOS官网：CasaOS - A simple, easy-to-use, elegant open-source personal cloud system
建议先按照此文章开始部分提前安装好Docker，因为脚本自带的Docker安装程序没有修改iptables会导致Docker安装失败。
curl -fsSL https://get.casaos.io | sudo bash

参考资料【2023.10.13】玩客云docker下刷openwrt-迅雷玩客云、京东云等各种云设备-恩山无线论坛
玩客云刷Armbian，安装docker+CasaOS+OpenWrt
]]></content>
      <categories>
        <category>玩客云</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>玩客云</tag>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title>项目思路_远程（WIFI）键盘</title>
    <url>/2023/12/11/%E9%A1%B9%E7%9B%AE%E6%80%9D%E8%B7%AF_%E8%BF%9C%E7%A8%8B%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[思想使用esp8266作为主控方案，将通过wifi + ipv6的形式实现远程输入。借助ch9328芯片，使其与主控通过ttl通信，并将串口传来的数据转换成usb键盘的键值传给计算机。
应用场景借助WIFI实现远程控制主机。
大致流程使用ddns的方式将获取到的ipv6地址绑定到域名，并监听指定的端口。当有其他应用访问这个端口的时候，解析访问的资源。访问格式如下： 域名:端口/访问方式（协议 明文，两个字母）/要传输的内容（base64编码）。
获取请求的地址：

String path = server.uri(); // 获取请求的路径
- 获取路径  - ```c++    String path = &quot;/jp/hello&quot;; // 假设这就是请求路径    int lastSlashIndex = path.lastIndexOf(&#x27;/&#x27;); //获取最后一个/的位置    int secondLastSlashIndex = path.lastIndexOf(&#x27;/&#x27;, lastSlashIndex - 1); // 获取倒数第二个/的位置    String secondLastSegment = path.substring(secondLastSlashIndex + 1, lastSlashIndex); // 从倒数第二个斜杠后一位开始，一直截取到最后一个斜杠，将截取出的信息写入到secondLastSegment字符串中    String lastSegment = path.substring(lastSlashIndex + 1);//截取最后一个斜杠到最后的位置，    Serial.println(secondLastSegment); // 输出 jp    Serial.println(lastSegment); // 输出 hello





当获取到协议和编码后，将编码进行解码，获取其中的数据，按照协议的内容进行处理功能点
当协议部分是jp的时候，内容中的部分可以直接输入到计算机
当协议部分是passwd的时候，内容部分经过aes解密后设置成下次解密时的密钥。相当于设置密码。
注意，设置密码时解密的密钥为一个特定的值（写死）
当执行设置密码后，将解密后的值写入到指定的文件中（覆盖）


每次运行的时候，都从指定位置读取密码文件.
若不存在，则使用默认的密码：123456
若存在，则使用文件中指定的密码。密码文件中的所有内容均为密码



功能的部分代码
base64解码

要解码一个经过Base64编码的字符串，你可以使用Base64库或者函数来完成。以下是一个示例代码，使用Arduino ESP8266的base64库来解码字符串：
#include &lt;Base64.h&gt;String encodedString = &quot;cnVub29iaQ==&quot;;String decodedString = base64::decode(encodedString);Serial.println(decodedString);

在上面的示例中，我们使用了ESP8266的Base64库来解码字符串。首先，我们将经过Base64编码的字符串赋值给encodedString。然后，使用base64::decode()函数对字符串进行解码，并将解码后的结果赋值给decodedString。最后，使用Serial.println()函数将解码后的字符串打印出来。
请确保在你的Arduino开发环境中正确安装了ESP8266的Base64库。



AES解密

如果解密内容和解密密码随时会变化，你可以将解密密码作为一个变量，以便在需要时进行修改。你可以 在代码中定义一个变量来存储解密密码，并在每次解密之前更新它。
以下是一个示例代码，演示如何使用变量来存储解密密码：
#include &lt;AESLib.h&gt;String encryptedString = &quot;U2FsdGVkX1+Td5IhADeOWSntJwhcWAwE/F35ZrmRCL0=&quot;;String decryptedString;AES aes;String decryptionKey = &quot;1234&quot;; // 解密密码，可以随时修改void setup() &#123;  Serial.begin(115200);  byte iv[] = &#123;0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F&#125;; // 初始化向量  byte key[decryptionKey.length() + 1]; // 创建解密密码字节数组  decryptionKey.getBytes(key, decryptionKey.length() + 1); // 将解密密码字符串转换为字节数组  aes.set_key(key, decryptionKey.length()); // 设置解密密码  aes.set_iv(iv, sizeof(iv)); // 设置初始化向量  decryptedString = aes.decrypt(encryptedString); // 解密字符串  Serial.println(decryptedString);&#125;void loop() &#123;  // 你的其他代码&#125;

在上面的示例中，我们定义了一个变量decryptionKey来存储解密密码。你可以随时修改这个变量的值，以改变解密密码。在setup()函数中，我们将解密密码转换为字节数组，并使用aes.set_key()函数将 其设置为解密密钥。
关于初始化向量（IV），它是在AES加密中用于增加加密强度的参数。IV是一个固定长度的字节数组，必须与加密时使用的IV相匹配。在解密过程中，使用相同的IV可以确保正确解密数据。在示例代码中，我们使 用了一个固定的IV，你可以根据需要进行更改。
请注意，示例代码只是一个参考，具体的实现可能会因为你使用的库或平台而有所不同。确保根据你的需 求和使用的AES库的要求进行相应的修改。




将结果发送到ch9328
参考wifi badusb中的keyboard.cpp：

以下是代码中的一些重要部分：

makeReport 函数：该函数用于创建键盘输入报告。它接受多个参数，包括修饰键和按键的值，并返回一个报告对象。

begin 函数：该函数用于初始化 ESP8266 的键盘控制。它设置了引脚模式、波特率等，并发送复位信号。

setLocale 函数：该函数用于设置键盘的区域设置。它接受一个 hid_locale_t 类型的指针作为参数，并将其赋值给 locale  变量。

send 函数：该函数用于发送键盘输入报告到串口。

pressKey 函数：该函数用于模拟按下一个按键。它接受按键的值和修饰键的值作为参数，并在先前的报告中找到一个空闲的位置来存储按键信息。

pressModifier 函数：该函数用于模拟按下修饰键。它接受修饰键的值作为参数，并在先前的报告中设置相应的修饰键位。

press 函数：该函数用于模拟按下一个字符。它接受一个字符指针作为参数，并根据当前的键盘区域设置转换字符为相应的键值和 修饰键，并调用 pressKey 函数发送按键信息。

write 函数：该函数用于模拟按下一个字符串。它接受一个字符串指针作为参数，并调用 press 函数模拟按下每个字符，并在最后释放按键。


这些函数和变量的组合可以用于控制 ESP8266 作为一个键盘设备，模拟按键操作。

bito&gt; 假设我要将字符a传输到计算机，这段代码应该怎么工作？
bito response&gt;根据您提供的代码，如果您想将字符 ‘a’ 传输到计算机，可以按照以下步骤进行操作：

调用 begin() 函数来初始化 ESP8266 的键盘控制。

调用 press() 函数，并将字符 ‘a’ 作为参数传入。该函数会根据当前的键盘区域设置将字符转换为相应的键值和修饰键，并模拟 按下该按键。

如果需要，可以调用其他按键函数，例如 pressModifier() 来模拟按下修饰键。

最后，调用 release() 函数来释放所有按键，确保没有按键被持续按下。


完整的示例代码如下：
#include &quot;keyboard.h&quot;void setup() &#123;  keyboard::begin();&#125;void loop() &#123;  // 模拟按下字符 &#x27;a&#x27;  keyboard::press(&#x27;a&#x27;);  // 模拟释放所有按键  keyboard::release();  // 延时一段时间，以便观察效果  delay(1000);&#125;

在上述示例中，setup() 函数会在程序开始时调用一次，用于初始化键盘控制。然后，loop() 函数会不断循环执行，每次循环都会 模拟按下字符 ‘a’ 并释放所有按键。之后会延时1秒，以便观察效果。

bito&gt; 假设我想传输 shift + ctrl + r到计算机，我应该如何调用？
bito response&gt;要模拟传输 Shift + Ctrl + R 到计算机，您可以按照以下步骤调用相关函数：
#include &quot;keyboard.h&quot;void setup() &#123;  keyboard::begin();&#125;void loop() &#123;  // 模拟按下 Shift、Ctrl 和 R 键  keyboard::pressModifier(KEY_LEFT_SHIFT);  keyboard::pressModifier(KEY_LEFT_CTRL);  keyboard::press(&#x27;r&#x27;);  // 模拟释放所有按键  keyboard::release();  // 延时一段时间，以便观察效果  delay(1000);&#125;

在上述示例中，setup() 函数用于初始化键盘控制，而 loop() 函数则用于循环执行按键操作。
首先，我们调用 pressModifier() 函数两次，分别传入 KEY_LEFT_SHIFT 和 KEY_LEFT_CTRL 作为参数，以模拟按下 Shift 和 Ctrl 键。
然后，我们调用 press() 函数，并传入字符 ‘r’ 作为参数，以模拟按下 R 键。
最后，我们调用 release() 函数来释放所有按键，确保没有按键被持续按下。
请注意，具体的修饰键值（如 KEY_LEFT_SHIFT 和 KEY_LEFT_CTRL）可能会根据您的键盘设置和操作系统有所不同。您可以根据需要进行调整。

bito&gt; 也就是说，如果我想按下ctrl、shift、alt、insert之类的功能键，我需要调用pressModifier()方法；如果我想按下英文字母、 空格、数字，我就调用press()方法；同时，在没有调用release()方法之前，每调用一次pressModifier()、press()方法，就相当与按下对应的键不松手，直到调用release()方法后，全部统一松手，对吗？
bito response&gt;是的，您的理解是正确的。

如果您想按下功能键（如Ctrl、Shift、Alt等），可以使用 pressModifier() 方法来模拟按下这些键。每次调用 pressModifier() 方法，都会将相应的修饰键添加到先前的报告中，表示按下该键。在调用 release() 方法之前，这些修饰键会一直保持按下状态。

如果您想按下英文字母、空格、数字等普通键，可以使用 press() 方法来模拟按下这些键。每次调用 press() 方法，都会将相应的键值添加到先前的报告中，表示按下该键。在调用 release() 方法之前，这些普通键会一直保持按下状态。


最后，当您调用 release() 方法时，所有之前按下的键（无论是修饰键还是普通键）都会被释放，相当于将所有键松开。
请注意，为了模拟按键操作的连续性，您可以在每次按下和释放之间添加适当的延时，以确保操作的顺序和持续时间符合预期。

bito&gt; 能不能告诉我，键盘上114个按键，我应该调用哪个按键才能实现分别按下？
bito response&gt;键盘上的114个按键可以使用不同的键值常量来表示。以下是一些常见的键值常量示例：

字母键：’a’, ‘b’, ‘c’, … ‘z’
数字键：’0’, ‘1’, ‘2’, … ‘9’
功能键：KEY_F1, KEY_F2, KEY_F3, … KEY_F12
修饰键：KEY_LEFT_CTRL, KEY_RIGHT_CTRL, KEY_LEFT_SHIFT, KEY_RIGHT_SHIFT, KEY_LEFT_ALT, KEY_RIGHT_ALT, KEY_LEFT_GUI, KEY_RIGHT_GUI
特殊键：KEY_ENTER, KEY_ESC, KEY_BACKSPACE, KEY_TAB, KEY_SPACE, KEY_INSERT, KEY_DELETE, KEY_HOME, KEY_END, KEY_PAGE_UP, KEY_PAGE_DOWN, KEY_ARROW_UP, KEY_ARROW_DOWN, KEY_ARROW_LEFT, KEY_ARROW_RIGHT

您可以根据需要调用相应的键值常量来模拟按下不同的按键。例如，要按下字母 ‘a’，您可以使用 keyboard::press(&#39;a&#39;)；要按下Shift键，您可以使用 keyboard::pressModifier(KEY_LEFT_SHIFT)。
请注意，具体的键值常量可能会根据您的键盘设置和操作系统有所不同。您可以参考键盘库的文档或查阅相关资料，以获取完整的键值常量列表，并根据您的需要进行调用。

bito&gt; 功能键、修饰键、特殊键需要通过pressModifier()实现按下，其余的通过press()按下，对吗？
bito response&gt;是的，您的理解是正确的。

功能键（如F1、F2等）、修饰键（如Ctrl、Shift、Alt等）和特殊键（如Enter、Esc、Backspace等）需要使用 pressModifier() 方法来模拟按下。

其他普通键（如字母键、数字键、符号键等）可以使用 press() 方法来模拟按下。


通过调用适当的函数，您可以按照需求模拟按下不同类型的键。请确保在按下和释放键之间适当地调用 release() 方法，以便在完成 按键操作后将键释放。
请注意，键盘库中的函数和键值常量可能会根据库的实现和键盘设置有所不同。建议查阅相关文档或参考库的示例代码以了解准确的函数和键值常量。

bito&gt; 也就是说，我通过write(“hello”, 5)的形式调用，相当于将hello分解成五个字母，然后逐个输入 到计算机是吗？
bito response&gt;是的，您的理解是正确的。通过调用 write(&quot;hello&quot;, 5) 方法，将字符串 “hello” 分解为五个字母， 并逐个输入到计算机中。
在 write(const char* str, size_t len) 方法中的循环中，每次迭代都会调用 write(&amp;str[i]) 方 法，其中 &amp;str[i] 表示字符串中的一个字母。这样，循环会逐个处理字符串中的每个字母，并将其模拟输入到计算机中。
因此，write(&quot;hello&quot;, 5) 的效果等同于逐个按下字符 ‘h’、’e’、’l’、’l’、’o’，即将字符串 “hello” 分解为五个字母，并逐个输入到计算机中。





9238接收到数据后，转换成usb键值传给主机。

]]></content>
      <categories>
        <category>项目思路</category>
        <category>ESP8266</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>protected</tag>
        <tag>ESP8266</tag>
        <tag>项目思路</tag>
        <tag>CH9328</tag>
      </tags>
  </entry>
  <entry>
    <title>One-KVM使用指南</title>
    <url>/2024/01/14/%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E_One-KVM%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[One-KVM使用指南介绍One-KVM是基于玩客云硬件和PiKVM软件的远控设备。通过移植PiKVM该软件至玩客云设备上，实现了极高的性价比，不到百元功能即可接近甚至超越部分昂贵的商业设备。
该设备在于帮助用户通过得到控制设备的HDMI 画面和鼠标键盘，去远程管理服务器、工作站或个人PC等。 和基于软件的远程管理方式不同，你无需在被控电脑安装任何软件，做到无侵入式控制。
当前您使用的PiKVM内部版本号为0.4，有中文界面，支持网页与VNC同时远控、BIOS级控制、USB键鼠模拟、远程挂载镜像（MSD）、网络远程唤醒（WOL）、网页终端，文本粘贴和中英文识别（OCR）等特性。



功能
One-KVM
TinyPilot 社区版本
PiKVMv3版本



HTML5界面
简体中文
英文
英文


BIOS级访问
√
√
√


视频捕捉
√
√
√


音频捕捉
×
√
√


鼠键捕获
√
√
√


从剪贴板粘贴
√
√
√


OCR识别
√
×
√


基于密码的身份验证
√
需升级Pro
√


LAN唤醒
√
需升级Pro
√


从WebUI更新
×
√
×


VNC支持
√
×
√


挂载虚拟驱动器
√
需升级Pro
√


ATX开关机
√
×
√


WiFi
×
√
√


串行接口
×
×
√


视频流格式
MJPEG
MJPEG, H.264
MJPEG, H.264


视频分辨率
1920x1080
1920x1080
1920x1080


开始使用将HDMI转USB采集卡插入玩客云主机网口旁USB口，HDMI视频线插入采集卡HDMI端，USB双公线插入玩客云主机HDMI口旁USB口，插入网线，接入电源。
被控机端，讲HDMI视频线和USB双公线接入对应接口即可。

提醒：玩客云USB设备插反会导致PiKVM所有远控功能无法使用。
帮助：部分低功耗设备在未接通电源时可能通过USB双公线从玩客云取电并启动至异常状态，再接通电源也无法启动。要解决此问题，您可以 剥开USB双公线剪断红色5V细电线。
玩客云主机前面板灯在系统极低负载时为红色，在系统启动和使用PiKVM时（有负载时）会不同颜色交替闪烁，这是正常的。
玩客云主机默认上网方式为DCHP，启动后在浏览器访问网络新增IP即可。由于软件自签SSL证书不被信任，请无视风险继续访问。




提示： 默认WEB和VNC账号密码都为admin且同步，root用户密码为1234，所有端口皆为服务默认端口。
帮助：排障指南　　
网页视频黑屏提示无No Singal，请检查硬件是否正确连接或松动；
网页端黑屏无任何画面或彩色竖条，请检查是否有被控机HDMI信号输入；
进系统画面显示正常，bios界面黑屏或渲染异常，请在BIOS界面开启CMS兼容模式；
画面显示片刻黑屏，刷新网页重复此现象，请使用火狐浏览器或修改kvmd主配置文件使用yuyv格式。
如果以上情况都不符合请尝试重启玩客云自动复位。
如果要使用ATX控制物理开关机功能请连接好开机线（目前成品深色引出线接9pin中的开机负极，浅色引出线接开机针脚正极，如黑白、褐红，橙黄对应负极和正极），延长线不分颜色直接使用。


其他文档目录（可在此查阅其他文档）：https://p1b237lu9xm.feishu.cn/drive/folder/IsOifWmMKlzYpRdWfcocI7jdnQA
Github地址：https://github.com/mofeng-git/One-KVM （欢迎点个Star）
QQ交流群：569514148 （One-KVM交流群）
]]></content>
      <categories>
        <category>玩客云</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>玩客云</tag>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title>One-KVM FAQ和故障排除</title>
    <url>/2024/01/14/%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E_One-KVM%20FAQ%E5%92%8C%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/</url>
    <content><![CDATA[One-KVM FAQ和故障排除说明如果你遇到任何问题，你可以检查这个页面，它会列出常见的错误。如果这仍然没有帮助你，欢迎你提出问题或加入我们的交流群寻求进一步的帮助。
Github地址：https://github.com/mofeng-git/One-KVM （欢迎点个Star）
QQ交流群：569514148 （One-KVM交流群）
常见问题玩客云上的PiKVM支持哪些功能？不支持哪些功能？


功能
One-KVM
TinyPilot 社区版本
PiKVMv3版本



HTML5界面
简体中文
英文
英文


BIOS级访问
√
√
√


视频捕捉
√
√
√


音频捕捉
×
√
√


鼠键捕获
√
√
√


从剪贴板粘贴
√
√
√


OCR识别
√
×
√


基于密码的身份验证
√
需升级Pro
√


LAN唤醒
√
需升级Pro
√


从WebUI更新
×
√
×


VNC支持
√
×
√


挂载虚拟驱动器
√
需升级Pro
√


ATX开关机
√
×
√


WiFi
×
√
√


串行接口
×
×
√


视频流格式
MJPEG
MJPEG, H.264
MJPEG, H.264


视频分辨率
1920x1080
1920x1080
1920x1080


PiKVM官方的功能说明文档在哪？ 如果您需要对功能进行高级配置，非常建议查阅官方文档，官方项目文档的的FAQ和功能配置讲解非常详细，包含示例易于上手。官方文档（英文）：PiKVM Handbook。
能进去网页但网页黑屏如何解决？网页视频黑屏提示无No Singal，请检查采集卡硬件是否受支持、是否正确连接、是否松动；

网页端黑屏无任何画面或是彩色竖条，请检查是否有被控机HDMI信号输入；

进系统画面显示正常，BIOS界面黑屏或渲染异常，请在BIOS界面开启CMS兼容模式；

网页画面显示片刻黑屏，刷新网页重复此现象，请使用火狐浏览器或修改kvmd主配置文件使用yuyv格式。

如果以上情况都不符合请尝试重启玩客云自动复位。

为什么网页视频感觉非常卡顿？视频流输出配置中采用了yuyv格式。mjpeg格式可以实现1080p30帧或720p60帧，但占用带宽非常大（峰值50mbps左右），yuyv格式更加稳定但帧率较低（1080p5fps或720p10fps、峰值10mbps左右）。在浏览器中使用mjpeg视频流非常容易黑屏，仅火狐浏览器使用mjpeg格式的视频流不会出现黑屏现象。

**提示使用体验的方法**：使用mjpeg格式，选择火狐浏览器，使用720p60帧或1080p30帧，右上角sysytem调整至最大帧率。针对1080p屏幕1080p画质远控请全屏使用，720p请点击网页视频右上角的“•”自动缩放画面与原画面分辨率相同。演示图为3终端720p60fps演示效果：

![img](.&#x2F;Image&#x2F;One-KVM FAQ和故障排除.assets&#x2F;1705214473639-4.png)
如何在公网中访问局域网的One-KVM？如果您的路由器有公网IP地址，您可以直接使用端口映射转发443端口。在其他情况下，您可以使用内网穿透服务（如Tailscale），只需几个简单的命令即可在One-KVM上配置。

如何修改软件端口和账户密码？修改端口请编辑 /etc/kvmd/nginx/目录下的conf后缀文件将相关端口修改所需端口（443是网页运行的端口），然后运行systemctl restart kvmd kvmd-nginx 生效。

修改账号密码示例：

   #添加用户 请将silentwind替换为你的用户名kvmd-htpasswd set silentwind#输入密码#删除用户kvmd-htpasswd del admin#列出所有用户kvmd-htpasswd list#重启服务，使修改立刻生效systemctl restart kvmd kvmd-nginx

如何给One-KVM设置静态IP？使用终端图形化工具armbain-config。

示例：armbain-config  Network--&gt;IP--&gt;eth0--&gt;Static

![img](.&#x2F;Image&#x2F;One-KVM FAQ和故障排除.assets&#x2F;1705214473631-1.png)
我可以使用One-KVM进行游戏或是刷剧吗？不能，因HDMI-USB采集卡的视频帧率（最高1080p30fps）无法满足游戏要求，且没有音频。

One-KVM可以传输4K视频吗？对于USB采集设备将原视频画面采样到更小的分辨率以满足USB 2.0带宽限制，因此源可能是4k，但网友视频流不会。4K的实时视频无论如何都不适合通过网络。

光标&#x2F;视频延迟来自哪里？这是将图像传输到浏览器或VNC客户端的过程：采集设备-&gt;压缩-&gt;网络-&gt;解压-&gt;渲染，延迟大概100-200ms。

我可以在移动设备上使用One-KVM上吗？是的，但WEB界面可能无法正常操控，所以在移动设备上推荐使用VNC应用程序，请注意不要使用不兼容的RealVNC。

如何添加自己的SSL证书？如果您有证书（制作证书超出了PiKVM的范围-请参考OpenSSL留档或使用Let&#39;s Encrypt），请替换 /etc/kvmd/nginx/ssl中的密钥，必要时编辑 /etc/kvmd/nginx/ssl.conf并重新启动kvmd-nginx服务。

当我尝试访问 One-KVM 主页时，提示 500 错误?可能原因：错误的 YAML 语法或者硬件外设不满足。可执行systemctl status kvmd kvmd-otg或是kvmd --run查看详细报错信息。

如何为多个 One-KVM 使用不同的主机名？使用 SSH 会话或 Web 终端，如果您不是 root，请使用命切换为 root 再执行命名`hostnamectl set-hostname onecloud`，然后重新启动 pikvm服务。

![img](.&#x2F;Image&#x2F;One-KVM FAQ和故障排除.assets&#x2F;1705214473632-2.png)
为什么我的机器不能再通过按下重置键的方式刷机了？脚本通过覆盖分区的方式跳过了UBoot线刷检测，如需使用其他系统则需重新短接主板刷机或使用烧录好系统的U盘通过U盘启动。

网页视频窗口提示”Janus WebSocket“连接失败如何解决？此事件发生概率为2%，为偶发性事件，难以复现，无法解决，建议重装软件。
为什么网页视频会有无法消除的黑边且模糊无比？非硬件和软件原因，请检查你的被控机系统设置。
![img](.&#x2F;Image&#x2F;One-KVM FAQ和故障排除.assets&#x2F;1705214473632-3.jpeg)
]]></content>
      <categories>
        <category>玩客云</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>玩客云</tag>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title>One-KVM启用MSD、WOL功能</title>
    <url>/2024/01/14/%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E_One-KVM%E5%90%AF%E7%94%A8MSD%E3%80%81WOL%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[One-KVM启用MSD、WOL功能启用MSDMSD（Mass Storage Drive），即大容量储存设备，可以实现远程上传文件，挂载镜像等功能。
分区使用玩客云EMMC空间作者在安装篇的网盘的链接中提供了包含此软件的系统镜像，刷入U盘后将U盘插到玩客云网口旁的USB口插电启动，连接ssh（root&#x2F;1234）输入gparted即可启动磁盘分区软件。
如果没有打开软件界面请检查你的ssh终端是否支持X11转发功能。
在打开的Gparted界面右键 &#x2F;dev&#x2F;mmcblp1p2 选择 Resize&#x2F;Move 来调整分区，在Free space following框中输入新建分区的大小（可输入4096），再将分出来的空闲空间格式化为ext4格式，最后点击主界面选项卡下的绿底√应用应用刚才的选择即可。


应用补丁
#拔掉U盘重启进入EMMC系统添加分区nano /etc/fstab#在文件末尾添加如下挂载/dev/mmcblk1p3 /var/lib/kvmd/msd  ext4  nodev,nosuid,noexec,ro,errors=remount-ro,data=journal,X-kvmd.otgmsd-root=/var/lib/kvmd/msd,X-kvmd.otgmsd-user=kvmd  0 0#如果使用的0.3版本（非一键脚本安装），请执行命令应用补丁 cd ~/fruity-pikvm &amp;&amp; sudo ./msd-patch.shmount /dev/mmcblk1p3#开启MSD功能，到/etc/kvmd/override.yaml修改msd选项为otgnano /etc/kvmd/override.yamlsystemctl restart kvmd-otg kvmd

使用TF卡（SD卡）建议不要使用杂牌储存卡（部分杂牌储存卡反应为Windows正常、Linux能识别但无法访问和读写）。
#查看TF卡位置fdisk -l#将其格式化为ext4文件格式（将sdx替换为你的设备地址）mkfs.ext4 /dev/sdxnano /etc/fstab#在文件末尾添加如下挂载（将sdx替换为你的设备地址）/dev/sdx  /var/lib/kvmd/msd  ext4  nodev,nosuid,noexec,ro,errors=remount-ro,data=journal,X-kvmd.otgmsd-root=/var/lib/kvmd/msd,X-kvmd.otgmsd-user=kvmd  0 0#如果使用的0.3版本（非一键脚本安装），请执行命令应用补丁 cd ~/fruity-pikvm &amp;&amp; sudo ./msd-patch.sh#挂载分区（将sdx替换为你的设备地址），如失败报错请检查设备地址和挂载内容是否出错mount /dev/sdx#开启MSD功能，到/etc/kvmd/override.yaml修改msd选项为otgnano /etc/kvmd/override.yamlsystemctl restart kvmd-otg kvmd

启用WOLWOL（Wake On LAN），即网络唤醒，在被控机支持的情况下（部分机器可能默认关闭，开启教程可参考网络唤醒WOL（Wake On LAN） - 知乎 (zhihu.com)），可以通过网络唤醒设备开机，实现机器开停自由。更详细的介绍和配置可查阅官方教程。
首先在获取被控机网卡的MAC地址记录下来（格式为linux小写），然后编辑 &#x2F;etc&#x2F;kvmd&#x2F;override.yaml 添加如下内容，完成后重启服务 systemctl restart kvmd （请注意格式缩进，否则会导致服务启动失败）。
gpio:    drivers:        wol_server1:            type: wol            mac: 2c:56:dc:db:7c:1e    scheme:        wol_server1:            driver: wol_server1            pin: 0            mode: output            switch: false    view:        table:            - [&quot;#设备名称&quot;, &quot;wol_server1|网络唤醒&quot;]


]]></content>
      <categories>
        <category>玩客云</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>玩客云</tag>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title>One-KVM安装完整教程</title>
    <url>/2024/01/14/%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E_One-KVM%E5%AE%89%E8%A3%85%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[One-KVM安装完整教程
介绍One-KVM是基于玩客云硬件和PiKVM软件的远控设备。KVM over IP可以远程管理服务器或工作站，无论操作系统或是否安装了操作系统。 相较于购买向日葵控控（￥7？？）或树莓派开发板，50多的矿渣玩客云 + HDMI转USB采集卡的组合（不包含其他工具）运行PiKVM同样可以实现很好的效果。



功能
One-KVM
TinyPilot 社区版本
PiKVMv3版本



HTML5界面
简体中文
英文
英文


BIOS级访问
√
√
√


视频捕捉
√
√
√


音频捕捉
×
√
√


鼠键捕获
√
√
√


从剪贴板粘贴
√
√
√


OCR识别
√
×
√


基于密码的身份验证
√
需升级Pro
√


LAN唤醒
√
需升级Pro
√


从WebUI更新
×
√
×


VNC支持
√
×
√


挂载虚拟驱动器
√
需升级Pro
√


ATX开关机
√
×
√


WiFi
×
√
√


串行接口
×
×
√


视频流格式
MJPEG
MJPEG, H.264
MJPEG, H.264


视频分辨率
1920x1080
1920x1080
1920x1080


运行效果

开始安装准备工具必备硬件：玩客云（含电源和USB刷机线），HDMI转USB采集卡（推荐MS2109型号），网线和HDMI线
可选硬件：TF卡（扩展储存） TTL转USB适配器（调试工具）
镜像工具文件链接：https://pan.baidu.com/s/166-2Y8PBF4SbHXFkGmFJYg?pwd=o9aj



采集卡硬件兼容性列表







型号&#x2F;方案
USB接口
Linux支持
PiKVM支持
使用情况


MS2109
USB2.0
√
√
推荐


MS2130
USB3.0
√
√
配置过剩


MS2131
USB3.0
√
√
配置过剩


腾飞 TFDGK05
USB2.0
√
×
&#x2F;


迈拓矩阵 MT-UH02
USB2.0
×
×
&#x2F;


仓库介绍先简单介绍一下One-KVM项目，目前有三个仓库：
One-KVM：提供一键PiKVM安装脚本，目前只支持Armbian_22.11.0-trunk_Onecloud_jammy_legacy_5.10.149系统，后续会加入Build-Armbian分支基础镜像的完全支持；
One-KVM-docker：提供PiKVM docker镜像，目前只有pikvm-ch9329_amd64容器，后续会加入常见架构容器支持；
Build-Armbian：提供适用与PiKVM的基础系统镜像和One-KVM成品固件镜像，目前已经开始第一版镜像已完成，One-KVM_Armbian_20.12_Aml-s812_jammy_current_5.9.0-rc7_minimal_240110以开始内测，后续将完善细节。
对应的，PiKVM有三种安装方式：脚本安装，直刷One-KVM镜像，docker镜像部署。
方式一：脚本安装使用 https://github.com/hzyitc/armbian-onecloud/releases/download/ci-20221026-074131-UTC/Armbian_22.11.0-trunk_Onecloud_jammy_legacy_5.10.149.burn.img.xz 线刷镜像刷入玩客云EMMC，SSH登录配置好密码。
玩客云刷机教程请自行百度，这里不再赘述。
注意：作者只测试过此镜像可正常运行PiKVM，其他版本的镜像可能存在运行问题（不限于不包含UVC驱动，无所需Python版本，OTG拔插死机），不确定是否适用于此教程，如有问题请自行解决。
提示：Amlogic USB Burning Tool建议使用 v2.1.3及以下版本，不要使用高版本软件（下图是反面教材）。
刷机短接时不需要一直短接，在烧录软件识别到并加载到1%可以松手耐心等待刷机成功了。

进入Armbian系统处理好设置密码等基础操作后就可以使用使用一键安装脚本安装PiKVM了。
git clone https://github.com/mofeng-git/One-KVM.gitcd One-KVM  &amp;&amp; bash ./install.sh#对于国内网络环境，可以尝试以下命令wget https://mirror.ghproxy.com/https://github.com/mofeng-git/One-KVM/archive/refs/heads/main.zip -o One-KVM-main.zipunzip One-KVM-main.zipcd One-KVM-main  &amp;&amp; bash ./install.sh


方式二：直刷One-KVM镜像带burn后缀的为线刷镜像，可使用USB_Burning_Tool线刷至玩客云。不带burn后缀的为U盘&#x2F;SD卡启动镜像，直接写入U盘&#x2F;SD卡即可。镜像为开箱即用，刷好后启动设备就可以开始用One-KVM了。
方式三：docker镜像部署目前支持仅有pikvm-ch9329_amd64，后续将支持更多控制方式和处理器架构。使用示例：
docker run -itd -p443:443 -p80:80 --name pikvm-docker --device=/dev/ttyUSB0:/dev/kvmd-hid --device=/dev/video0:/dev/kvmd-video pikvm-ch9329:0.61

开始使用按图连接好设备（网口旁接USB采集卡，HDMI旁边的为OTG口接USB双公线，可以直接用刷机线），访问玩客云IP，默认账号密码 admin&#x2F;admin，即可开始使用！
至于如何MSD功能、VNC远控和ATX开关机控制请查看作者其他文章。

其他感谢名单：
H_xiaoming测试适配OTG正常可用镜像、*0蓝蓝0*提供开机卡线刷检测解决办法、fairybl关于MSD和线刷检测的其他解决方案、浩龙的电子嵌入式之路的充电，以及其他开源项目、各位大佬和网友的讨论交流。
更新日志：
当前One-KVM版本号：V0.5
Github地址：https://github.com/mofeng-git/One-KVM （欢迎点个Star）
V0.5：通过锁定CPU频率修复ustreamer mjpeg视频流异常的问题；屏蔽主程序找不到温度传感器的报错；优化中文翻译；优化安装流程
V0.4：实现了ATX开关机物理控制功能；初步建立了使用文档；优化了安装流程。
V0.3：制作了简体中文补丁；实现了MSD功能在EMMC和TF卡上的使用；实现了WOL和中文OCR功能；优化了安装流程。
V0.2：解决了OTG拔插死机问题；初步实现了MSD功能；解决了开机卡线刷检测；优化了安装流程。
V0.1：PiKVM在玩客云上初步运行。
参考项目

GitHub - pikvm&#x2F;pikvm: Open and inexpensive DIY IP-KVM based on Raspberry Pi
GitHub - hzyitc&#x2F;armbian-onecloud: Armbian for onecloud. 玩客云用armbian
GitHub - jacobbar&#x2F;fruity-pikvm: Install Pi-KVM on debian SBCs such as Orange Pi, Banana Pi, Mango Pi debian SBCs such as Orange Pi, Banana Pi, Mango Pi, etc (github.com)

]]></content>
      <categories>
        <category>玩客云</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>玩客云</tag>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title>One-KVM实现物理开关机控制功能</title>
    <url>/2024/01/14/%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E_One-KVM%E5%AE%9E%E7%8E%B0%E7%89%A9%E7%90%86%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8E%A7%E5%88%B6%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[One-KVM实现物理开关机控制功能介绍这个教程是比较粗糙的版本，在新旧版玩客云上测试通过，操作无差别，适合DIY玩家参考。通过使用玩客云红外接口预留的GPIO接口连接主板9PIN中的开机针脚实现物理控制开机、关机和强制关机的功能。
教程物理控制开关机只需要一个GPIO接口（两者都是3.3V），不能占用宝贵的WiFi模块引脚，led用处也不小，最后选择测试红外控制引脚（应该没人会同时使用PiKVM和红外遥控功能吧）。
硬件改动：
整个操作并不复杂，首先需要在玩客云主板的红外模块预留接口焊上两根引线（接在图中GPIO-420和GND位置），然后接驳开机线（GPIO接开机引脚正极，GND接开机引脚负极）。




软件改动对于One-KVM V0.4用户
一键脚本已经配置好了，硬件连接好之后即可使用此功能。
对于One-KVM V0.3用户
请下载https://github.com/mofeng-git/One-KVM patch目录下的short_press_gpio420和long_press_gpio420两个shell脚本文件，然后上传至玩客云&#x2F;usr&#x2F;bin目录下。
#给kvmd程序执行这两个脚本的权限echo kvmd ALL=\(ALL\) NOPASSWD: /usr/bin/long_press_gpio420,/usr/bin/short_press_gpio420 &gt;&gt;  /etc/sudoers

然后编辑 &#x2F;etc&#x2F;kvmd&#x2F;override.yaml 文件添加如下内容（注意缩进和格式，否则会报错）。
gpio:    drivers:        short_press:            type: cmd            cmd: [/usr/bin/sudo, short_press_gpio420]        long_press:            type: cmd            cmd: [/usr/bin/sudo, long_press_gpio420]    scheme:        short_button:            driver: short_press            pin: 0            mode: output            switch: false        long_button:            driver: long_press            pin: 0            mode: output            switch: false    view:        header:            title: ATX        table:                            - [&quot;#电源管理&quot;]            - []            - [&quot;#短按（开/关机）:&quot;, short_button|按下]            - [&quot;#长按（强制关机）:&quot;, long_button|按下]


#最后重启kvmd服务就可以看到修改生效了。systemctl restart kvmd 



提示：对于DIY玩家，您也可以使用尝试PiKVM自带的GPIO驱动方式进行控制（作者采用的调用bash脚本），作者使用的引脚对于系统位置是gpio-420，对于PiKVM位置是gpiochip1 pin7，PiKVM源代码默认为gpiochip0需要手动修改。

]]></content>
      <categories>
        <category>玩客云</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>玩客云</tag>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title>高可用高并发后端架构通用蓝图</title>
    <url>/2025/10/08/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E9%80%9A%E7%94%A8%E8%93%9D%E5%9B%BE/</url>
    <content><![CDATA[核心设计原则在深入细节之前，整个架构遵循以下几个核心原则：

无单点（No Single Point of Failure）: 系统中任何一个组件的故障都不会导致整个系统瘫痪。所有服务和数据存储都必须是集群化的或有冗余备份。
水平扩展（Horizontal Scaling &#x2F; Scale-Out）: 当负载增加时，可以通过简单地增加更多服务器节点来提升系统的处理能力，而不是升级单个服务器的硬件（垂直扩展）。
服务拆分与隔离（Decoupling &amp; Isolation）: 将庞大的单体应用拆分为更小、更专注的服务。服务之间的故障不会相互影响，可以独立部署和扩展。
异步化（Asynchronous Communication）: 对于非核心、耗时的操作，采用消息队列进行异步处理，可以削峰填谷，提高系统的响应速度和吞吐量。
数据分片与多副本（Sharding &amp; Replication）: 对海量数据进行分片存储以分散压力，同时为数据创建多个副本以保证高可用和容灾。


架构笔记：一次请求的旅程概览1. 客户端与网络接入层 (Client &amp; Edge)这是用户请求的起点，也是系统抵御外部风险和加速内容分发的第一道防线。

核心职责:
解析域名，将用户流量导向正确的入口。
缓存静态资源（图片、JS、CSS），减少对后端服务器的请求。
抵御网络攻击（如DDoS、SQL注入）。


高可用&#x2F;高并发策略:
DNS 负载均衡: 配置多个IP地址，DNS服务可以根据负载或地理位置返回一个最优的IP。
CDN (内容分发网络): 将静态资源分发到全球各地的边缘节点，用户就近访问，极大提升加载速度并分担源站压力。
WAF (Web应用防火墙): 在流量进入系统前进行过滤和清洗。


主流技术: Cloudflare, AWS CloudFront, Akamai, F5, 各大云厂商的DNS&#x2F;WAF服务。

2. 流量接入层 (Traffic Ingress)流量穿过边缘网络后，到达我们自己数据中心的入口。

核心职责:
作为所有内部服务的统一入口。
SSL&#x2F;TLS 卸载（解密HTTPS流量）。
将请求根据URL路径、域名等规则，均匀地转发到后端的API网关集群。


高可用&#x2F;高并发策略:
负载均衡器集群: 使用至少两台负载均衡器组成集群（例如，通过 Keepalived + VIP 实现主备切换），避免单点故障。
健康检查 (Health Checks): 负载均衡器会持续检查后端网关节点的健康状况，自动剔除故障节点，将流量转发到健康节点。
四层&#x2F;七层负载均衡: L4（TCP&#x2F;UDP）转发速度快，L7（HTTP）可以根据请求内容做更智能的路由。


主流技术: Nginx, HAProxy, F5 BIG-IP, 各大云厂商的负载均衡器（ALB&#x2F;NLB）。

3. API网关层 (API Gateway)网关是微服务架构的“门面”，处理所有服务的通用横切关注点。

核心职责:
路由: 将请求精确地路由到对应的后端业务服务。
认证与授权: 校验用户身份（Token&#x2F;JWT），确保用户有权限访问该API。
限流与熔断: 防止突发流量冲垮后端服务，当某个服务不可用时快速失败（熔断），避免雪崩效应。
日志、监控、协议转换等。


高可用&#x2F;高并发策略:
无状态与集群部署: 网关本身是无状态的，可以轻松地水平扩展多个节点。
服务发现: 网关从服务注册中心动态获取后端服务的地址列表，实现自动的服务上下线感知。
熔断降级: 集成Hystrix, Sentinel等库，实现对下游服务的保护。


主流技术: Kong, Spring Cloud Gateway, Zuul, Traefik。

4. 业务服务层 (Application Services)这是实现核心业务逻辑的地方。

核心职责: 处理具体的业务请求，如订单处理、用户管理、商品查询等。
高可用&#x2F;高并发策略:
微服务化: 将复杂的业务拆分成多个独立的服务，每个服务都可以独立部署、扩展和容错。
无状态服务: 将会话状态等信息存储在外部的缓存或数据库中，使得任何一个服务节点都可以处理任意用户的请求，为水平扩展奠定基础。
容器化与编排: 使用 Docker 将服务打包成镜像，通过 Kubernetes (K8s) 等平台进行自动化部署、扩缩容和故障自愈。


主流技术:
服务框架: Spring Boot (Java), Django&#x2F;Flask (Python), Express (Node.js), Go-kit&#x2F;Gin (Go)。
服务治理: Spring Cloud (Java), Istio (Service Mesh)。
容器编排: Kubernetes, Docker Swarm。



5. 数据与状态层 (Data &amp; State)这是系统的心脏，数据的可靠性和性能直接决定了整个系统的质量。

缓存集群 (Cache Cluster):
职责: 缓存热点数据，降低对数据库的访问压力，提升响应速度。
HA&#x2F;HC策略: 使用 Redis Sentinel&#x2F;Cluster 或 Memcached 集群。通过数据分片分散存储压力，通过主从复制&#x2F;多副本保证数据可用性。


消息队列集群 (Message Queue Cluster):
职责: 服务间解耦、异步处理、流量削峰。例如，用户下单后，将“生成订单”、“扣减库存”、“发送通知”等消息放入队列，由下游服务异步消费。
HA&#x2F;HC策略: 使用 Kafka, RabbitMQ, RocketMQ 等集群。Topic&#x2F;Queue可以有多个分区（Partition）以支持高并发读写，数据有多副本保证不丢失。


数据库集群 (Database Cluster):
职责: 持久化存储核心业务数据。
HA&#x2F;HC策略:
读写分离 (Read&#x2F;Write Splitting): 采用主从（Master-Slave）架构，主库负责写，多个从库负责读，分散读取压力。
分库分表 (Sharding): 当单表数据量过大时，将数据水平拆分到多个库或多个表中。
高可用切换: 使用MHA, Galera Cluster, 或云数据库的HA方案实现主库故障时自动切换。


主流技术: MySQL, PostgreSQL, TiDB (分布式数据库)。


对象存储&#x2F;搜索引擎:
职责: 对象存储 (S3, MinIO) 用于存储图片、视频等非结构化大文件。搜索引擎 (Elasticsearch, Solr) 提供复杂的全文检索功能。
HA&#x2F;HC策略: 这些系统天生就是分布式的，通过增加节点即可线性扩展，数据自动分片和复制。



6. 运维与可观测性 (Operations &amp; Observability)这是保证系统稳定运行的“眼睛”和“大脑”。

集中式日志系统 (Centralized Logging):
职责: 收集所有服务节点的日志，提供统一的查询和分析界面，便于快速定位问题。
技术栈: ELK (Elasticsearch, Logstash, Kibana) 或 EFK (Elasticsearch, Fluentd, Kibana)。


监控与告警系统 (Monitoring &amp; Alerting):
职责: 持续收集系统各项性能指标（CPU, 内存, QPS, 延迟等），通过仪表盘进行可视化展示，并在指标异常时自动告警。
技术栈: Prometheus + Grafana (事实标准), Zabbix。


分布式追踪系统 (Distributed Tracing &#x2F; APM):
职责: 跟踪一个请求在多个微服务之间的完整调用链，帮助分析性能瓶颈和排查分布式系统中的复杂问题。
技术栈: SkyWalking, Jaeger, Zipkin。



通过以上六层的协同工作，我们构建了一个具有弹性、容错和高性能的后端系统，能够从容应对高并发的挑战，并保证在部分组件失效时，核心服务依然可用。

第一章：客户端与网络接入层 (Client &amp; Network Access Layer)1.1 本章定位：系统的“护城河”与“先锋部队”这是整个系统架构的最外层，是用户请求到达我们应用的第一站。你可以把它想象成一座城堡的护城河与城墙。它的核心目标有两个：

加速 (Acceleration): 让合法的、常规的请求尽可能快地得到响应。
防御 (Defense): 将非法的、恶意的攻击流量阻挡在外，保护内部核心服务的安全和稳定。

在高并发场景下，如果这一层设计不当，海量请求和潜在攻击会瞬间冲垮后端的服务器，谈高可用就无从说起。因此，这一层是实现高可用、高并发的第一道防线。

1.2 核心组件详解A. DNS (Domain Name System) - 智能交通调度员
核心职责:将人类易于记忆的域名（如 www.example.com）解析成机器能够识别的IP地址（如 93.184.216.34）。这是互联网的“电话簿”。

如何实现高可用与高并发:

DNS 负载均衡 (DNS Load Balancing):
机制: 一个域名可以配置解析到多个不同的IP地址。当用户发起DNS查询时，DNS服务器会根据预设的策略（如轮询、加权轮询）返回其中一个IP。这样，来自不同用户的请求就会被自然地分发到不同的服务器入口，实现了最基础的负载均衡。
高可用价值: 如果其中一个IP地址对应的服务器集群发生故障，我们可以从DNS解析记录中移除该IP。用户的后续请求就会被解析到其他健康的IP上，实现了数据中心级别的故障转移。


智能DNS解析 (GeoDNS &#x2F; Latency-based Routing):
机制: 更高级的DNS服务（通常由专业DNS提供商或云厂商提供）可以判断DNS查询请求来自哪个地理位置或哪个运营商网络。然后，它会返回一个物理距离最近、访问延迟最低的服务器IP地址。
高并发价值: 将用户流量“就近”引入，极大地提升了访问速度和用户体验，同时也分散了不同区域的流量，避免单一入口的拥堵。




技术实现与选型:

基础：Bind9 (自建)
云服务商：AWS Route 53, Google Cloud DNS, 阿里云DNS
专业DNS服务商：Cloudflare DNS, DNSPod



B. CDN (Content Delivery Network) - 分布式前哨仓库
核心职责:缓存网站的静态资源（如图片、视频、JavaScript文件、CSS文件等），并将其分发到全球各地靠近用户的“边缘节点”（Edge Nodes &#x2F; PoPs）上。

如何实现高可用与高并发:

极大降低源站负载 (Offloading Traffic):
机制: 当用户第一次请求一个静态资源时，CDN边缘节点会从我们的源站服务器拉取该资源并缓存起来。后续所有对该资源的请求，都将直接由CDN边缘节点响应，不再需要访问我们的源站。
高并发价值: 网站流量中通常有70%-80%是静态资源。将这部分流量剥离出去，意味着我们的后端服务器只需要处理剩余20%-30%的动态API请求。这使得后端服务可以专注于核心业务逻辑，承载远超以往的并发量。


天然的分布式与高可用:
机制: CDN服务商在全球拥有成百上千的节点。这些节点本身就是高可用的。如果某个节点或区域出现故障，流量会自动被路由到其他健康的节点。
高可用价值: 它不仅缓存了内容，实际上也为我们的静态资源提供了一个极其强大的、分布式的冗余系统。即使我们的源站短暂宕机，只要CDN缓存未过期，用户依然可以访问网站的静态部分。


加速访问，提升用户体验:
机制: 用户总是从物理距离最近的CDN节点获取资源，减少了网络传输的延迟（RTT - Round-Trip Time）。
价值: 更快的加载速度意味着更低的用户流失率，这在高并发系统中至关重要。




技术实现与选型:

云服务商：AWS CloudFront, Google Cloud CDN, Azure CDN, 阿里云CDN, 腾讯云CDN
专业CDN服务商：Cloudflare, Akamai, Fastly



C. WAF (Web Application Firewall) - 智能安全卫士
核心职责:部署在Web服务器之前，对HTTP&#x2F;HTTPS请求进行检测和过滤，防御常见的Web应用攻击，如SQL注入、跨站脚本（XSS）、DDoS攻击等。

如何实现高可用:

保障服务的可用性 (Protecting Availability):
机制: WAF是保障可用性的关键组件。分布式拒绝服务（DDoS）攻击的目的就是通过海量的垃圾流量耗尽服务器的带宽、CPU或内存资源，导致正常用户无法访问。WAF能够识别并清洗这些恶意流量，只放行合法的请求。
高可用价值: 如果没有WAF，在高并发时期，一次小规模的DDoS攻击就可能导致整个系统瘫痪。WAF确保了后端服务的“存活权”。


防止数据泄露和篡改:
机制: 通过防御SQL注入等攻击，WAF防止了数据库被拖库或恶意修改，间接保护了系统的稳定和数据的完整性，这也是高可用的一个方面（系统能正确提供服务）。




技术实现与选型:

通常与CDN服务集成在一起，如Cloudflare的WAF功能。
云服务商：AWS WAF, 阿里云WAF等。
硬件&#x2F;软件：F5 BIG-IP ASM, ModSecurity (开源)。




1.3 本章总结在这一层，我们通过DNS的智能调度，将用户流量导向最合适的数据中心入口；通过CDN，将绝大部分静态资源请求“拦截”在全球各地的边缘节点，极大地减轻了后端压力；最后通过WAF，清洗掉恶意攻击流量。
架构图中的流程:
[ 用户 ] --- 1. DNS查询 ---&gt; [ DNS服务器 ]   |                                 | 2. 返回最优IP (CDN节点/WAF入口)   |                                 |   +----- 3. 发起HTTP/HTTPS请求 ---&gt; [ CDN / WAF 全球边缘节点 ]                                       |                                       | 4. a) 如果是静态资源 -&gt; 直接从CDN缓存返回                                       | b) 如果是动态API请求 -&gt; 清洗过滤后，转发到下一层...                                       |                                       V                                  (流量接入层)

当流量安全、稳定地穿过这第一道防线后，它将抵达我们数据中心的正式入口——流量接入层。我们将在下一章详细探讨。
第二章：流量接入层 (Traffic Ingress Layer)2.1 本章定位：系统的“总接待”与“安检口”如果说第一章是“城墙”和“护城河”，那么这一层就是城堡的唯一主城门和卫兵。所有外部请求，无论好坏，最终都会汇聚于此。它的核心职责是：

统一入口 (Unified Entry Point): 成为所有后端服务的唯一流量入口，避免将内部服务直接暴露在公网上，增强安全性。
分发与均衡 (Distribution &amp; Balancing): 将海量的并发请求，稳定、高效、均匀地分发给后端的多个处理单元（通常是API网关集群）。
协议处理 (Protocol Handling): 集中处理一些网络层面的通用任务，如HTTPS解密，让后端服务可以更专注于业务逻辑。

这一层是实现后端服务水平扩展和高可用的基础。如果这里的负载均衡器宕机，那么整个系统就与外界“失联”了。

2.2 核心组件详解A. 负载均衡器 (Load Balancer, LB)这是本层的核心组件，通常是一个集群而非单个设备。

核心职责:监听来自公网的特定端口（如80, 443），并将收到的请求根据预设的策略转发给后端服务器池（Server Pool）中的一个健康节点。

如何实现高可用与高并发:

高可用 - 消除单点故障 (HA Cluster):

机制: 负载均衡器本身绝不能是单点。在生产环境中，至少会部署两台负载均衡器，构成**主备（Active-Passive）或主主（Active-Active）**集群。
Keepalived + VIP (Virtual IP) 是一种常见的开源实现方案。集群共享一个虚拟的IP地址（VIP）。正常情况下，VIP由主（Master）节点持有，所有流量都经过它。Keepalived会通过VRRP协议在主备节点间发送心跳包。一旦主节点宕机，备（Backup）节点会立即检测到心跳丢失，并在几秒内接管VIP。对于客户端来说，它们访问的IP地址从未改变，故障切换是透明的。
高可用价值: 确保了流量入口的7x24小时可用。即使一台LB物理机宕机、重启或进行维护，服务也不会中断。


高并发 - 水平扩展后端 (Horizontal Scaling):

机制: 负载均衡器后面可以连接任意数量的后端服务器（比如API网关节点）。当并发量上升时，我们只需要向服务器池中添加新的节点，LB就会自动将流量分发给它们。
负载均衡算法 (Balancing Algorithms):
轮询 (Round Robin): 按顺序依次分发，简单公平。
加权轮询 (Weighted Round Robin): 按权重分配，适用于服务器性能不一的场景。
最少连接 (Least Connections): 将请求发给当前连接数最少的服务器，适合处理长连接。
IP哈希 (IP Hash): 根据客户端IP地址计算哈希值，确保来自同一客户端的请求总是发往同一台后端服务器。这对于需要维持会话状态（Session Stickiness）的场景很有用。


高并发价值: 负载均衡器是实现后端服务无缝水平扩展的关键。它将单个服务的处理能力从“一台服务器的上限”扩展到了“整个集群的综合处理能力”。


健康检查 (Health Checks):

机制: 负载均衡器会以固定的频率，主动向后端服务器池中的每个节点发送“探测”请求（比如一个HTTP GET请求或一个TCP连接请求）。
如果服务器返回了预期的健康状态码（如HTTP 200），则认为该节点健康。
如果服务器超时未响应或返回错误状态，LB会将其标记为“不健康”，并自动停止向该节点转发新的流量。当节点恢复后，健康检查通过，LB会再次将其加入到服务池中。
高可用价值: 这是实现自动故障转移 (Automatic Failover) 的核心机制。它能实时、自动地隔离故障节点，保证用户的请求总是被发送到能够正常处理的服务器上，极大提升了系统的健壮性。





B. SSL&#x2F;TLS 卸载 (SSL&#x2F;TLS Offloading)
核心职责:我们现在的Web服务普遍使用HTTPS来加密传输内容，保障数据安全。HTTPS的加解密过程（特别是握手阶段）会消耗大量的CPU资源。SSL卸载就是将这个加解密的工作集中在负载均衡器上完成。

如何实现高并发:

降低后端服务CPU消耗:
机制: 外部请求 (Client --HTTPS--&gt; LB) 到达LB后，LB负责解密，然后以普通的HTTP协议将请求转发给内部的后端服务器 (LB --HTTP--&gt; Backend Server)。返回的响应也是同理。
高并发价值: 这意味着后端的成百上千个业务服务节点不再需要各自消耗CPU资源去处理加解密。它们可以把宝贵的计算资源全部用于执行核心业务逻辑，从而提升整体的应用处理性能和吞吐量。


简化证书管理:
机制: 所有的SSL&#x2F;TLS证书只需要在负载均衡器这一层进行部署和更新，而不需要在每一个后端服务节点上都去管理证书。
价值: 简化了运维，降低了因证书过期或配置错误导致服务不可用的风险。




技术实现与选型:

软件负载均衡器: Nginx, HAProxy, LVS (Linux Virtual Server)
硬件负载均衡器: F5 BIG-IP, A10 Networks
云服务商: AWS (ALB&#x2F;NLB&#x2F;ELB), Google Cloud Load Balancing, 阿里云SLB




2.3 本章总结在流量接入层，我们通过一个高可用的负载均衡器集群，为整个后端系统提供了一个稳定、统一的入口。它利用健康检查机制实现了后端服务的自动故障转移，通过负载均衡算法将高并发流量均匀地分发出去，并通过SSL卸载为后端服务减负。
架构图中的流程:
            (从第一层: CDN/WAF)                    |                    V[ Internet ] --&gt; [ VIP: 123.45.67.89 ]                    |         +--------------------------+         |     高可用负载均衡器集群     |         |                          |         | [ LB 1 (Master) ] &lt;---&gt; [ LB 2 (Backup) ] -- 心跳检测 --         +--------------------------+                    |                    | 1. SSL/TLS 解密                    | 2. 根据负载均衡算法选择一个后端节点                    | 3. 健康检查，确保节点存活                    |                    V     (转发到下一层: API网关集群的某个节点)

现在，解密后的、干净的、被均匀分发的流量，即将进入微服务架构的“咽喉”——API网关层。我们将在下一章探讨它的作用。
第三章：API网关层 (API Gateway Layer)3.1 本章定位：微服务的“智能门面”与“中央管制塔”如果说流量接入层是城堡的“主城门”，那么API网关层就是城门后的中央广场和卫队长。所有进入城堡的请求都会在这里进行身份核查、登记，并被指引到正确的目的地（具体的业务服务）。它不是简单地转发流量，而是进行了大量的**应用层（L7）**处理。
核心职责：

统一门面 (Unified Facade): 为外部客户端（Web、App、第三方服务）提供一个单一、稳定、规范的API入口，隐藏内部微服务的复杂性和部署细节。
横切关注点处理 (Cross-Cutting Concerns): 集中处理所有或大部分微服务都需要的通用功能，如认证、授权、限流、日志记录等，避免在每个微服务中重复实现。
请求路由与编排 (Routing &amp; Orchestration): 精确地将请求路由到下游的某个或某些微服务，甚至可以将多个微服务的调用结果聚合成一个单一的响应。

这一层是保障微服务架构安全、稳定、可治理的核心。没有它，成百上千的微服务将如一盘散沙，难以管理和保护。

3.2 核心组件与策略详解A. 动态路由 (Dynamic Routing)
核心职责:根据请求的特征（如URL路径、HTTP方法、Header头等），将其转发到正确的后端微服务实例。例如，将 /users/... 的请求路由到用户服务，将 /orders/... 的请求路由到订单服务。

如何实现高可用:

服务发现 (Service Discovery):
机制: API网关本身并不知道后端服务的具体IP地址和端口。相反，它会与一个服务注册中心 (Service Registry) 集成（如 Nacos, Consul, Eureka）。
每个微服务实例在启动时，会主动向注册中心“报到”（注册），并定时发送心跳来表明自己还活着。
API网关会从注册中心订阅服务列表。当有新的服务实例上线或旧的实例下线（因宕机或主动关闭）时，注册中心会实时通知网关。
高可用价值: 这是实现动态、自动化的服务伸缩和故障转移的关键。当订单服务从3个实例扩容到5个时，网关能立刻感知到并开始向新实例转发流量。当某个实例因故障心跳停止时，网关也会立刻将其从路由列表中移除，避免将请求发往一个“死”的服务。整个过程无需人工干预。





B. 安全屏障 (Security Shield)
核心职责:作为所有内部服务的安全前哨，保护它们免受未授权的访问。

高可用策略:

认证 (Authentication):
机制: 集中处理用户身份验证。客户端的请求通常会携带一个身份凭证（如 JWT Token, API Key）。API网关负责校验这个凭证的合法性、有效性。只有通过验证的请求才会被放行到后端服务。
价值: 将认证逻辑从所有业务服务中剥离出来，简化了业务服务的开发。更重要的是，它确保了任何一个内部服务都不会被匿名或非法请求直接访问。


授权 (Authorization):
机制: 在认证通过后，网关还可以进一步检查该用户是否有权限执行当前的操作。例如，检查用户角色是否是“管理员”才能访问某个管理API。
价值: 实现了更细粒度的访问控制，进一步增强了系统的安全性。





C. 流量管制 (Traffic Control)
核心职责:保护后端服务免受突发流量或恶意攻击的冲击，防止系统因过载而崩溃（即“雪崩效应”）。

如何实现高可用与高并发:

限流 (Rate Limiting):
机制: 对特定的API、用户或IP地址设置请求速率上限（如每秒100次请求）。当请求速率超过阈值时，网关会直接拒绝多余的请求（通常返回 429 Too Many Requests 错误）。
高并发价值: 这是一种主动的自我保护机制。它可以防止某个用户或恶意脚本的滥用导致整个服务不可用，确保系统在极限负载下仍能为大部分用户提供有保障的服务。常用的算法有令牌桶、漏桶算法。


熔断 (Circuit Breaking):
机制: 网关会持续监控对下游某个微服务的调用情况（如错误率、响应延迟）。当发现该服务的错误率超过设定的阈值时（比如10秒内失败率达到50%），网关会“熔断”对此服务的调用。
在接下来的一个时间窗口内（如30秒），所有发往该服务的请求都会被网关立即失败 (Fail Fast)，直接返回一个错误，而不再真正去调用那个可能已经崩溃的服务。
时间窗口过后，熔断器会进入“半开”状态，尝试放行少量请求。如果这些请求成功，则关闭熔断器，恢复正常调用；如果依然失败，则继续保持熔断。
高可用价值:
防止雪崩效应: 避免了对一个已知故障服务的无效、重复调用，这些调用会消耗网关自身的线程和连接资源。
给下游服务恢复时间: 停止发送流量，让故障服务有机会重启或恢复。
快速失败: 让上游调用方能迅速得到失败响应，而不是长时间等待超时，提升了用户体验。




降级 (Degradation):
机制: 在系统负载过高或非核心服务出现问题时，为了保住核心功能，会有策略地关闭或简化一些次要功能。这种策略可以在网关层实现，例如，当检测到系统压力大时，网关可以返回一个静态的、默认的响应，而不是去调用后端的推荐服务。
高可用价值: 舍卒保车，确保在极端情况下，系统核心功能依然可用。






3.3 本章总结API网关是微服务架构的“守护神”。它通过与服务注册中心联动，实现了服务的动态路由和自动故障转移。通过集中的认证授权，构筑了坚实的安全防线。更重要的是，它利用限流、熔断、降级等“保险丝”机制，在面对高并发和下游故障时，能有效保护整个系统的稳定性，防止连锁反应导致的全面崩溃。
架构图中的流程:
          (从第二层: 负载均衡器)                  |                  V      +-----------------------+      +-----------------------+      |     API Gateway 1     |      |     API Gateway 2     | ...      +-----------------------+      +-----------------------+               |    ^                            ^               |    | 2. 订阅服务列表             |               |    +--------------------------+ |               |                               | |               v 1. 请求进入                    | V      +----------------------------------------+ |      | 3. 安全: 认证/授权                       | |      | 4. 流量控制: 限流/熔断                   | |      | 5. 根据请求路径，查找服务地址              | |      +----------------------------------------+ |               |                                 |               |         (服务注册中心)             |               v         Nacos/Consul            |+----------------------+                         || [用户服务实例列表]     | &lt;-------------------------+| [订单服务实例列表]     |+----------------------+               |               V   (转发到下一层: 具体的业务服务集群)

现在，经过层层校验和管制的请求，终于到达了真正处理业务逻辑的地方——业务服务层。我们将在下一章探讨如何设计这一层来实现高可用。
第四章：业务服务层 (Application Services Layer)4.1 本章定位：系统的“大脑”与“功能单元”这一层是整个架构的核心价值所在。无论是用户注册、商品浏览、下单支付，还是后台的数据分析，所有的业务功能都在这里实现。它不再是单一的庞然大物，而是一个由多个自治、专注、可独立部署的服务组成的集群。
核心设计目标：

高内聚，低耦合 (High Cohesion, Low Coupling): 每个服务只做一件事并把它做好。服务之间通过定义良好的API进行通信，互不了解对方的内部实现。
弹性与可扩展性 (Elasticity &amp; Scalability): 能够根据业务负载的变化，自动、快速地增加或减少服务实例的数量，以最高效的方式利用资源。
故障隔离 (Fault Isolation): 一个服务的故障不应该导致整个系统的瘫痪。故障的影响范围应被限制在服务内部或其直接调用方。

这一层的设计直接决定了系统能否在业务快速发展的同时，保持技术上的灵活性和稳定性。

4.2 核心组件与策略详解A. 微服务化 (Microservices)
核心职责:将一个庞大的单体应用（Monolith）按照业务边界（Domain Boundary）拆分成多个更小、更独立的服务。例如，一个电商系统可以拆分为：用户服务、商品服务、订单服务、支付服务、库存服务等。

如何实现高可用与高并发:

独立部署与扩展 (Independent Deployment &amp; Scaling):
机制: 每个微服务都可以独立地进行开发、测试、部署和升级。例如，在“双十一”大促期间，我们可以只针对“订单服务”和“商品服务”进行大规模扩容（比如扩容到100个实例），而“用户服务”（主要是登录，压力相对较小）可能只需要10个实例。
高并发价值: 实现了资源的精细化、按需分配。我们可以把计算资源集中在最需要的地方，从而以更低的成本支撑更高的并发量。而在单体应用中，我们只能对整个应用进行扩容，即使只有10%的代码是性能瓶颈，也必须为另外90%的非瓶颈代码付出同样的扩容成本。


故障隔离 (Fault Isolation):
机制: 如果“推荐服务”因为一个内存泄漏的BUG而频繁崩溃，它不会影响到核心的“订单服务”或“支付服务”的运行。最坏的情况只是用户暂时看不到商品推荐。
高可用价值: 这大大提高了整个系统的健壮性。故障的影响被“防火墙”隔离在了单个服务的边界内，避免了“一颗老鼠屎坏了一锅汤”的情况。


技术栈异构 (Technology Heterogeneity):
机制: 不同的服务可以根据其业务特点选择最适合的技术栈。例如，可以用Java&#x2F;Spring Boot来编写复杂的业务逻辑服务，用Python&#x2F;Django来做数据分析服务，用Go来写需要高性能网络I&#x2F;O的中间件服务。
价值: 允许团队使用最合适的工具解决问题，有助于提升开发效率和系统性能。





B. 无状态服务 (Stateless Service)
核心职责:这是实现无缝水平扩展的基石。无状态服务指的是，服务本身不存储任何与特定请求或会话相关的状态信息。对于任何一个请求，集群中的任意一个实例处理的结果都应该是一样的。

如何实现高可用与高并发:

机制: 那么状态信息（如用户的登录会话、购物车内容）存到哪里去呢？答案是：外部化存储。通常我们会把这些状态存放在一个共享的、高性能的外部系统中，如**分布式缓存（Redis）**或数据库。
高可用&#x2F;高并发价值:
任意扩展: 因为每个实例都不包含独一无二的数据，所以我们可以随时增加新的实例来分担流量，也可以随时下线任何一个实例而不用担心数据丢失。
请求自由路由: 负载均衡器可以把同一个用户的连续请求发送到不同的服务实例上，这极大简化了负载均衡策略。
快速故障恢复: 如果一个实例宕机，Kubernetes等编排工具可以立刻启动一个新实例来替代它。由于状态在外部，新实例可以立即投入工作，无缝衔接。





C. 容器化与编排 (Containerization &amp; Orchestration)
核心职责:提供一种标准化的、与环境无关的应用打包、分发和运行方式，并自动化地管理这些应用的生命周期。

如何实现高可用与高并发:

Docker - 标准化打包:
机制: Docker将应用及其所有依赖（库、配置文件等）打包成一个轻量、可移植的“容器”镜像。这个镜像可以在任何支持Docker的机器上以完全相同的方式运行，解决了“在我电脑上明明是好的”这一经典问题。
价值: 实现了环境一致性，极大地简化了部署流程，是实现快速、可靠的持续集成&#x2F;持续部署（CI&#x2F;CD）的基础。


Kubernetes (K8s) - 自动化编排:
机制: Kubernetes是一个容器编排平台，你可以把它看作是管理成千上万个容器的“操作系统”。我们只需要向K8s声明我们期望的状态（例如，“我需要我的订单服务运行10个副本”），K8s就会自动地完成剩下的一切。
高可用价值:
自愈 (Self-healing): K8s会持续监控所有容器的健康状况。如果一个容器崩溃了，K8s会自动在另一台健康的物理机上重新启动一个新的容器来替代它。
自动扩缩容 (Auto-scaling): 我们可以配置策略，让K8s根据CPU或内存的使用率，自动增加或减少服务的副本数量（即容器实例数）。当流量高峰来临时，系统自动扩容；当流量低谷时，自动缩容，节省成本。
滚动更新 (Rolling Update): 在发布新版本时，K8s可以逐个地替换旧的容器实例，而不是一次性全部停止。这保证了应用在更新过程中服务不中断。








4.3 本章总结业务服务层是高可用架构的“血肉”。通过微服务化，我们将系统拆分为灵活、自治的单元；通过无状态设计，我们为这些单元的自由伸缩奠定了基础；最终，通过Docker和Kubernetes，我们获得了强大的自动化运维能力，包括自愈、自动扩缩容和零停机发布。这三者结合，共同构建了一个既能应对高并发冲击，又能在故障面前快速恢复的弹性服务集群。
架构图中的流程:
            (从第三层: API网关)                    |                    V+-------------------------------------------------------------+|               Kubernetes Cluster (多台物理/虚拟机)             ||                                                             ||   +--------------+      +--------------+      +--------------+  ||   | 订单服务 Pod 1 |      | 订单服务 Pod 2 | ...  | 订单服务 Pod N |  |  &lt;- 自动扩缩容|   +--------------+      +--------------+      +--------------+  ||         ^                                                     ||         | Service A (e.g., Order Service)                     ||         |                                                     ||   +--------------+      +--------------+                      ||   | 用户服务 Pod 1 |      | 用户服务 Pod 2 | ...                  |  &lt;- 故障自愈|   +--------------+      +--------------+                      ||         ^                                                     ||         | Service B (e.g., User Service)                      ||         |                                                     ||   +-----+--------+                                            ||   |  ... 其他服务  |                                            ||   +--------------+                                            ||                                                             |+-------------------------------------------------------------+         |           |            |         |           |            | (读写数据/状态)         V           V            V      (下一层: 数据与状态层 - 缓存/消息队列/数据库)

业务逻辑处理完毕后，不可避免地需要与数据打交道。下一章，我们将深入探讨架构的“地基”——数据与状态层，看看如何让数据存储也实现高可用和高并发。
第五章：数据与状态层 (Data &amp; State Layer)5.1 本章定位：系统的“中央银行”与“记忆中心”这一层是所有业务数据的最终归宿和状态信息的管理者。它负责持久化存储（Durability）核心数据，并提供高性能的数据访问（Performance）。在分布式系统中，数据的**一致性（Consistency）和可用性（Availability）**是这一层永恒的主题。
核心设计挑战：

高可用性: 即使部分存储节点发生硬件故障、网络分区，数据也不能丢失，并且服务应尽可能保持可用。
高性能&#x2F;高并发: 必须能够支撑上层成千上万个服务实例同时进行的高并发读写请求。
可扩展性: 当数据量或访问量增长时，必须有能力平滑地扩展存储容量和吞吐能力。

这一层的设计往往是整个架构中最昂贵、最复杂的部分，但也是决定系统质量上限的关键。

5.2 核心组件与策略详解A. 缓存集群 (Cache Cluster) - 高速公路的“快车道”
核心职责:在内存中存储那些被频繁读取但不经常修改的数据（即“热点数据”），例如商品信息、用户配置、首页内容等。其目的是减少对后端慢速存储（如关系型数据库）的直接访问。

如何实现高可用与高并发:

读写分离与数据冗余 (Replication):
机制: 使用主从（Master-Slave）架构。写操作只在主节点进行，然后异步地复制到多个从节点。读操作可以由所有的从节点来分担。
高并发价值: 极大地提升了读性能，因为可以水平扩展多个从节点来应对海量的读取请求。
高可用价值: 当主节点宕机时，可以从从节点中选举一个新的主节点（例如通过 Redis Sentinel 机制），实现自动故障转移，保证写入服务在短时间内恢复。


数据分片 (Sharding):
机制: 当单个Redis实例的内存容量或QPS达到瓶颈时，需要将数据分散到多个实例中。Redis Cluster 方案通过哈希槽（hash slots）的方式，自动将不同的key-value映射到不同的物理节点上。客户端请求任何一个节点，如果数据不在该节点，它会被透明地重定向到正确的节点。
高并发&#x2F;高扩展性价值: 打破了单机内存和CPU的限制，使得缓存集群的容量和吞吐能力可以理论上无限地水平扩展。




缓存使用模式:

Cache-Aside (旁路缓存): 最常用的模式。读：先读缓存，没有则读数据库，然后写回缓存。写：先更新数据库，然后删除缓存。
Read-Through &#x2F; Write-Through: 缓存作为唯一的数据源对应用透明，由缓存服务自身负责与数据库的同步。


技术选型: Redis, Memcached


B. 消息队列集群 (Message Queue Cluster) - 系统的“减震器”与“耦合器”
核心职责:提供一个异步通信的中间层，主要用于服务解耦、流量削峰、异步处理。

如何实现高可用与高并发:

异步处理 (Asynchronous Processing):
机制: 对于一些非核心、耗时的操作，主流程不必等待其完成。例如，用户下单后，订单服务只需成功写入数据库并向MQ发送一条“订单创建成功”的消息，就可以立即向上游返回成功响应。至于后续的扣减库存、发送通知邮件&#x2F;短信、增加用户积分等操作，都由下游的订阅者服务异步地去消费这条消息来完成。
高并发价值: 极大地缩短了核心链路的响应时间，显著提升了用户体验和系统的吞吐量。


流量削峰 (Traffic Shaping &#x2F; Peak Shaving):
机制: 在秒杀、大促等场景下，瞬间的流量洪峰可能会冲垮数据库。MQ此时可以作为一个巨大的“蓄水池”。前端应用以其最大能力将请求写入MQ，而后端的消费者服务则以自己平稳的处理速率（如每秒1000个订单）从MQ中拉取并处理。
高并发价值: 它将瞬时的高峰流量“拉平”成一段时间内的平稳流量，保护了后端脆弱的存储系统，是应对流量脉冲的“核武器”。


高可用与数据持久化:
机制: 现代MQ（如 Kafka, RocketMQ）天生就是分布式集群。数据（消息）被写入到Topic的不同分区（Partition）中，每个分区都有多个副本（Replicas）分布在不同的物理机（Broker）上。
高可用价值: 即使某个Broker宕机，存储在其上的分区副本依然在其他Broker上可用，保证了消息不丢失和服务不中断。




技术选型: Kafka (高吞吐量，日志场景), RocketMQ (金融级可靠性), RabbitMQ (功能灵活，成熟稳定)


C. 数据库集群 (Database Cluster) - 数据的“金库”
核心职责:作为系统最核心、最权威的数据存储，保证数据的ACID特性（原子性、一致性、隔离性、持久性）。

如何实现高可用与高并发:

读写分离 (Read&#x2F;Write Splitting):
机制: 与缓存类似，采用主从复制架构。一个主库（Master）负责所有写操作（INSERT, UPDATE, DELETE），多个从库（Slaves）同步主库的数据，并对外提供读服务（SELECT）。应用层或数据库中间件会根据SQL语句的类型，将写请求路由到主库，读请求路由到从库。
高并发价值: 大部分应用的读写比远大于1（例如10:1）。通过水平扩展从库数量，可以线性提升系统的读性能。


分库分表 (Sharding):
机制: 当单一数据库或单一数据表的容量或写入并发量达到极限时，需要进行水平拆分。
分库: 将不同业务的数据存到不同的数据库中（如用户库、订单库）。
分表: 将一张大表（如订单表）按照某种规则（如用户ID哈希取模、按时间范围）水平拆分到多张物理表中。这些物理表可以分布在同一个数据库，也可以分布在不同的数据库中。


高并发&#x2F;高扩展性价值: 这是解决数据库写入瓶颈和存储容量瓶颈的终极方案。它将压力分散到多个物理节点上，实现了数据库的水平扩展。


高可用架构:
机制:
主从+自动切换: 使用MHA (Master High Availability) 或 Orchestrator 等工具监控主库状态，一旦主库宕机，能自动在几秒到几十秒内将一个从库提升为新主库，并让其他从库指向新主。
多主同步&#x2F;分布式数据库: 采用 Galera Cluster, Percona XtraDB Cluster (PXC) 等方案实现多节点同时可写，或者直接采用原生分布式数据库如 TiDB, CockroachDB。


高可用价值: 确保了数据库服务的连续性，将RTO（恢复时间目标）降到最低。




技术选型:

关系型: MySQL, PostgreSQL
数据库中间件: ShardingSphere, MyCAT
分布式数据库: TiDB, CockroachDB, Google Spanner
NoSQL: MongoDB, Cassandra (适用于特定场景)




5.3 本章总结数据与状态层是架构中最需要精雕细琢的部分。我们通过引入缓存集群作为高速挡箭牌，保护了数据库；通过消息队列实现了系统的削峰和解耦；并通过数据库的读写分离、分库分表和高可用架构，确保了核心数据存储的性能、可扩展性和永不宕机。这三者共同构成了坚实可靠的数据基座。
架构图中的交互:
     (从第四层: 业务服务层)             |             |  (高频读/状态存储)+------------+-------------+|                          |V                          V[ Cache Cluster ]         [ Message Queue Cluster ] &lt;--- (异步/削峰) --- [业务服务层](e.g., Redis)             (e.g., Kafka)  ^   |                      |   ^  |   | (低频读/核心写)      |   | (异步消费)  |   |                      V   |  |   +------&gt; [ DB Proxy / Middleware ] ----&gt; [ Database Cluster ]  |                 (e.g., ShardingSphere)       (e.g., MySQL主从/分片)  |                                                  ^  +--------------------------------------------------+                (缓存未命中时回源)

至此，一个完整的业务请求流程已经走完。但是，系统要能长期稳定运行，还需要一双“眼睛”来时刻监控它。下一章，我们将探讨最后的支撑体系——运维与可观测性。
第六章：运维与可观测性 (Operations &amp; Observability)6.1 本章定位：系统的“神经网络”与“健康监护中心”这一层不直接处理用户的业务请求，但它像一个无处不在的神经网络，渗透到架构的每一个角落。它的核心职责是**“让不可见变为可见”**，确保我们能够实时、清晰地了解系统内部正在发生的一切，并在问题发生时（甚至在发生前）提供足够的信息来进行预警、定位和解决。
可观测性的三大支柱：

日志 (Logging): 回答 “发生了什么？”。记录离散的、具体的事件。
指标 (Metrics): 回答 “情况怎么样？”。聚合的、可量化的数据，用于衡量系统健康状况和趋势。
追踪 (Tracing): 回答 “为什么会这样？”。记录单个请求在分布式系统中的完整调用链路，用于诊断性能瓶颈和错误根源。

这一层是提升团队运维效率、保障系统SLA（服务等级协议）、实现快速故障恢复的基石。

6.2 核心组件与策略详解A. 集中式日志系统 (Centralized Logging)
核心职责:在微服务架构中，日志散落在成百上千个服务实例的文件系统中，手动排查问题如同大海捞针。集中式日志系统的任务就是将所有这些分散的日志**收集（Collect）、聚合（Aggregate）、存储（Store）起来，并提供一个统一的搜索（Search）和分析（Analyze）**界面。

典型工作流 (ELK&#x2F;EFK Stack):

数据采集 (Shipper): 在每个业务服务器节点上部署一个轻量级的日志采集代理（Agent），如 Filebeat 或 Fluentd。这个代理负责监听本地的日志文件（如 app.log, nginx_access.log），并将新增的日志行实时发送出去。
数据处理与转发 (Processor): （可选但常用）采集到的原始日志通常是无格式的文本。它们会被发送到一个中间处理层，如 Logstash 或 Fluentd，在这里进行解析（Parsing）（如将一行文本解析成JSON结构，提取出时间、日志级别、请求ID等字段）、过滤（Filtering）和丰富（Enriching）（如根据IP地址添加地理位置信息）。
数据存储与索引 (Storage &amp; Indexing): 处理干净的、结构化的日志数据最终被发送到 Elasticsearch 集群中。Elasticsearch 会对这些数据进行索引，以提供毫秒级的全文搜索能力。
数据可视化与查询 (Visualization): 运维和开发人员通过 Kibana 的Web界面，可以像使用Google一样，方便地查询、筛选、聚合日志，并创建各种仪表盘来监控日志趋势（如错误日志数量的变化）。


高可用价值:

故障排查效率提升几个数量级: 当用户报告问题时，开发人员可以通过一个唯一的请求ID（Trace ID），在Kibana中一键搜出这个请求经过的所有服务的全部相关日志。
实时告警: 可以基于日志内容设置告警。例如，当某个服务的错误日志（ERROR level）在5分钟内超过100条时，自动通过钉钉、Slack或邮件通知相关人员。



B. 监控与告警系统 (Monitoring &amp; Alerting)
核心职责:持续地、周期性地采集系统的聚合指标（Metrics），并将其可视化，同时基于这些指标设置告警规则。

典型工作流 (Prometheus + Grafana Stack):

指标暴露 (Exposition): 应用程序（或通过中间件&#x2F;exporter）需要以一种标准格式（如Prometheus的文本格式）通过一个HTTP端点（如 /metrics）暴露出自身的内部状态指标。例如：当前活跃请求数、API平均响应时间、JVM内存使用率、数据库连接池状态等。
指标拉取 (Scraping): Prometheus Server 会定期（如每15秒）主动地从这些端点“拉取”指标数据，并将其存储在自己的时序数据库（TSDB）中。
查询与告警 (Querying &amp; Alerting): Prometheus 提供了强大的查询语言（PromQL），可以对收集到的指标进行复杂的查询和聚合。Alertmanager 组件则负责根据预设的告警规则（如“CPU使用率连续5分钟超过80%”）进行去重、分组，并将告警发送到指定的通知渠道。
可视化 (Visualization): Grafana 是一个开源的可视化平台，它可以连接到Prometheus作为数据源，通过配置丰富的图表、仪表盘，将枯燥的指标数据以直观、美观的方式展示出来。


高可用价值:

宏观健康度概览: 通过仪表盘，运维人员可以一目了然地看到整个集群的健康状况，快速发现异常波动。
趋势分析与容量规划: 长期存储的指标数据可以用于分析业务增长趋势，为未来的扩容提供数据支持。
主动发现问题: 告警系统能够在问题影响到最终用户之前，就通知相关人员介入处理，实现“预防胜于治疗”。



C. 分布式追踪系统 (Distributed Tracing &#x2F; APM)
核心职责:当一个请求跨越多个微服务时，追踪系统能够将这个请求在每个服务内部的耗时、调用关系串联起来，形成一个完整的**调用链（Trace）**视图。


典型工作流 (SkyWalking &#x2F; Jaeger):


数据埋点 (Instrumentation): 通过在应用程序中引入一个Agent或SDK（通常是无侵入的字节码增强技术），自动地在服务调用的入口和出口进行“埋点”。当一个请求进入服务A时，Agent会生成一个唯一的 Trace ID 和一个 Span ID。当服务A调用服务B时，它会通过HTTP Header或RPC元数据将Trace ID和父Span ID传递给服务B。
数据上报 (Reporting): 每个服务中的Agent会将各自的Span信息（包含服务名、接口名、开始&#x2F;结束时间、标签、日志等）异步地上报给追踪系统的收集器（Collector）。
数据处理与存储 (Processing &amp; Storage): 收集器接收到来自各个服务的Span数据，将属于同一个Trace ID的Span组合起来，构建出完整的调用链拓扑关系，并将其存储起来（通常使用Elasticsearch或Cassandra）。
数据展示 (UI): 追踪系统提供一个Web UI，开发人员可以根据Trace ID查询，或者根据服务、接口等维度查找慢请求或错误请求，并查看其详细的甘特图，清晰地看到每个环节的耗时。


高可用价值:

性能瓶颈定位: 当一个API响应缓慢时，通过调用链视图可以一目了然地看到是哪个下游服务的调用慢，还是哪个数据库查询慢，或是服务内部的某个方法耗时长。
分布式系统错误分析: 可以清晰地看到错误是在哪个服务节点上首次发生的，以及它是如何影响到上游服务的。
服务依赖关系可视化: 追踪系统可以根据收集到的数据，自动生成整个系统的服务依赖拓扑图，帮助理解复杂的系统结构。




6.3 本章总结运维与可观测性是保障高可用架构“名副其实”的最后一块拼图，也是最关键的一块。集中式日志提供了事后追溯的详细线索，监控告警提供了宏观实时的健康心跳，而分布式追踪则提供了深入微观世界的性能“手术刀”。这三者结合，为我们构建了一个强大的、立体化的“作战指挥室”，使得我们有能力驾驭复杂、庞大的分布式系统，确保其持续稳定、高效地运行。
至此，我们已经完整地走完了构建一个高可用、高并发后端架构的六个核心章节。从外到内，从请求的入口到数据的存储，再到全方位的监控，每一层都环环相扣，共同支撑起一个强大而有弹性的系统。
]]></content>
      <categories>
        <category>技术</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>protected</tag>
        <tag>杂谈</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>高通410随身wifi刷机教程</title>
    <url>/2023/06/18/%E9%AB%98%E9%80%9A410%E9%9A%8F%E8%BA%ABwifi%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[前言本教程适用于基于高通410的cpu随身wifi。
基本样式
如果需要刷openwrt和Debian，只有纸盒系和类纸盒的uz801、sp970，其它型号不能刷。（不确定 没尝试过）
常见问题简单说几个常见问题: 

SIM卡要插对；
天线别弄掉了（弄掉了再插回去）；
板子所处位置的信号不能太差，台式电脑建议用后面主板的USB口，有些电脑前置USB口容易供电不足；
很多软件问题可以重启或者更换电脑就能解决；
刷机前最好先备份；
拿到板子后插卡确认能否识别sim卡以及数据wifi功能是否正常，然后撬开外壳确定自己的板子是什么型号。

准备工作​	工具文件可能被系统报毒删除，所以以win10为例，建议新建一个随身WiFi文件夹，然后在Windows安全中心一病毒和威胁防护一病毒威胁防护设置一管理设置一排除项一添加排除项，把文件夹添加进去，然后把刷机文件下载到这里，就不会被系统删除了，其它杀毒软件也可以类似这样设置。
安装驱动需要提前安装高通的驱动：高通板子刷机需要安装9008驱动和adb驱动，打开并安装文件里的9008driver

把板子插上电脑，等待板子完全开机后，输入命令: adb devices
如果显示有设备连接就说明adb正常 (有些板子adb功能没有打开，可以在本版块搜索开启方法)（比如直接9008刷入其他刷完的包）
进入9008的方法需要9008刷机时再开启此端口。
adb命令进入adb reboot edl

通过按键进入按住板子的恢复键，插入电脑一两秒后听到叮咚一声再松手，在设备管理器里看到端口有9008就表示成功了。（不是所有按键都可以进入9008，进入不了参考下一条方法）
其他方法可以尝试短接usb数据针脚（d+ d-）插入电脑再松开。
成功进入后可以在端口中找到9008字样的设备。

备份这一步非常重要！不建议拿到板子后直接刷的rom包，应该先备份好当前的rom，之后再刷。只要硬件没坏都能救活。
如果自己的板子系统是阉割版的，比如没有热点和网络共享等，可以刷一下别的设备的system包，其它情况不太需要刷别的文件。
备份主要有三个过程：备份基带、Miko loader制作救砖包（全量备份）、
备份固件-miko安装Miko找到miko文件夹，双击miko安装，直接默认就行了，记住安装路径，安装完成后把文件夹内的loader复制到miko的安装目录，替换掉原来的loader.exe。接着创建loader的快捷方式到桌面。
loader备份让板子进入9008模式，打开loader，按照图片数字顺序一步步来。


点read；
点partition backup；
双击下面double click to open save folder；
选好救砖包生成的路径：点load partition structure；
点击全选按钮选中所有的分区；
点read full image就能制作刷机救砖包，大概5分钟以内。

保存好这个名为.bin的单文件，后期救砖需要它
刷机&#x2F;救砖方法图片也标注了顺序，分别点flash，emmc block0，flasher，double click….， flash!

备份固件-QPT用Qualcomm Premium Tool（QPT）备份全部分区文件。
激活QPT（只需要激活一次）打开它的文件夹，有个提示先注册的程序，注意要把电脑音量调低!。然后点开它后可能会提示安装一些东西，同意就行了，没有的话不用管，弹出窗口点击GenerateKey,生成的key放在你知道的文件夹内。

打开Qualcomm Premium Tool程序，左上菜单栏找到help-active,选择刚才生成的key就能激活这个软件了。

备份按照前面介绍的方法使板子进入9008模式，在Qualcomm Premium Tool按照图片数字一步一步进行。
注意，如果前面Miko备份完，记得拔掉棒子再次进入9008后再进行备份。


Qualcomm选项卡
partition子选项卡
scan单选按钮
Do job按钮
backup单选按钮
backup ALL复选框
Do job按钮

备份的文件保存好，后续可能有用
如果需要刷写某些分区，点击scan识别分区后，点write, 再选要刷如果需要刷写某些分区，点击扫描识别分区后，点写，再选要刷的分区，点Do job后选择分区文件，就能完成刷写该分区。的分区，点做好后选择分区文件，就能完成刷写该分区。
备份基带（需要进行root操作）前提
在设备管理器中的端口（COM和LPT）中可以看到9091或901D字样的设备



通用串行总线设备中看到ADB interface字样的设备（或者在最开头的几个选项卡中）




root备份qcn和root。需要先进行root,简单点的办法就是安装magisk,再刷一下修补过的boot文件就有root了。当然我更建议自己修补boot,不用等别人做好，出问题的概率也更小。
下面是如何自己动手获得root权限:

首先安装ardc,这是一个投屏软件，解决板子没有屏幕无法操作的问题，它的操作逻辑是鼠标左键为点击功能，右键为返回。

安装完ardc后先别打开，检查一下任务管理器中，有adb或者android debug bridge程序在后台的话记得停掉，再把板子插到电脑上正常启动，打开ardc等待画面变化，成功后会停在深蓝色界面，然后把鼠标箭头移到此界面，右键点击两下，如果没有出现桌面，需要安装一个第三方桌面启动器，把我提供的apk文件里的launcher从电脑直接托到ardc界面就会自动给板子安装。




等五秒后在主界面点一下鼠标右键，应该会出现选择主屏幕应用选择，点launcher和始终。




然后就能看到板子的系统界面了，接着安装es文件管理器和magisk,也是直接拖到ardc界面自动安装，装好后点开文件管理器，进入下载文件夹，把之前Qualcomm备份的boot文件直接托到这里，就会复制过来了(几秒钟，点下面的刷新就会显示出来) 





退出es,点开magisk,找到图片提示的位置




安装&gt;下一步&gt;选择并修补一个文件，选择刚才复制过来的boot,然后开始，等待它修补完成，退出并来到es文件管理器，进入下载，发现修补好的boot文件名太长了，长按后重命名为magiskboot.img。再点击ardc菜单最后一个&gt;&gt;;弹出的cmd这里(实际就是这个软件也集成了adb功能，这里直接使用它的)




输入命令: 
adb pull /sdcard/Download/magiskboot.img D:/xxx

这里D:&#x2F;xxx换成你自己的路径(斜杠朝左还是朝右都可以)，接着按回车就会把magiskboot.img导出到你的电脑上的指定位置。

再输入命令: 
adb reboot bootloader

板子会重启到fastboot模式，然后输入命令: 
fastboot flash boot 

后再按个空格键，接着把电脑上 上一步备份的boot文件magiskboot.img拖到这里，会自动生成文件路径名成文件路径名。




再按回车等待几秒完成后输入命令:
fastboot reboot

板子重启后打开magisk (可能得多等会)，看到下面四个图标，第二个就是超级用户，那么root就完成了。





备份
下面是备份qcn的工作，依然在ARDC的&gt;&gt;这里的cmd后输入命令: 
adb shell su

然后会显示shell申请权限，点永久就行了，接着在magisk的超级用户里看看shell授权成功与否。




关掉ardc，同时在任务管理器里如果发现adb还在后台也要关掉，然后打开星海svip这个软件 (免安装)，如果打开时提示缺少库文件，安装我提供的微软软件包，装好后最好重启一下电脑就能打开星海了，以后如果操作没问题，这个软件还是报错的就重启电脑选择高通，再点联机会出现设备信息，找到高通强开1（如果不行也可以试试强开2），点一键执行，在设备管理器上查看是否有端口901D（如果开启失败可以尝试手动开启，文件夹里有命令代码）





接着备份qcn，一键执行，选择qcn文件生成路径，正常情况就能备份qcn成功，如果不行就检查901d端口或者重启电脑，备份的qcn一般在500多k，远小于这个大小的应该是备份失败了，建议再来一次。





注意事项高通工具的备份和miko的备份的不同：

miko它是把所有的分区全部备份成一个单个的文件
高通的这个备份它是把每一个分区备份成单独的文件

两者两种方式备份出来的文件数量有区别，但本质上来说备份的是同一个东西。
高通的这个工具备份出来的这个分区文件是可以用其他工具来打开并且提取里面的内容的
而miko的呢不行。
同样的在还原的时候，因为刷完Debian以后所有的分区都会被改动掉，所以用高通的工具去还原会发现对应不上分区。所以得用miko的工具来还原。
刷机androidAndroid，一般情况刷回自己的包就用Miko loader这个软件，比较简单。刷单个分区，可以用Qualcomm工具，前面都已经介绍；
或者进fastboot模式，用命令刷分区，比如刷system分区，命令就是fastboot flash system 加上分区路径 (和前面刷boot一样，直接拖到这里，如果失败，把文件放到adb目录下，把分区路径换成分区文件名system.img也能刷，效果更好)
Debian刷机过程作者网址有介绍，001b 001c sp970 uz801作者给了boot和firmware文件用来替换。如果刷后不识别手机卡，可以这样试试看：	参考了酷友lkiuyu 的动态，刷回安卓，恢复出厂设置，再root后用星海擦写基带 (擦写基带在fastboot模式下)，接着写入自己的qcn (写入qcn也要开启901d端口)，才能装Debian，boot要替换成作者提供的001c的，别用自己的。firmware需要替换成自己备份的 (把Qualcomm工具备份的NON-HLS.bin用diskgenius的虚拟磁盘打开并提取出来，接着用winscp登录Debian后把它复制到&#x2F;home&#x2F;user下，再ssh登录Debian，sudo -i获得权限，再用命令cp -rf &#x2F;home&#x2F;user&#x2F;你提取的基带文件&#x2F;*&#x2F;usr&#x2F;lib&#x2F;firmware&#x2F;，完成替换，重启板子基带应该就能用了。
项目地址：
大致步骤如下：

重启到fastboot模式

//使用adb连接到设备
adb devices

//重启到fastboot
adb reboot fastboot
   - 重启完事后可以在设备管理器中ADB相关的设备里面有个`Fastboot interface`字样的设备。出现这个设备的时候就证明设备已经重启到fastboot模式下了。2. 解压Debian文件夹中的 `base-generic.zip` 文件，进入解压出来的文件夹中   - ![image-20230618215120258](./Image/随身WiFi刷机教程.assets/image-20230618215120258.png)3. 点击地址栏，删除其中的内容，然后输入 `cmd` 打开cmd4. 在cmd的命令提示符中输入`flash.bat`，然后回车执行。   - ![image-20230618215310151](./Image/随身WiFi刷机教程.assets/image-20230618215310151.png)5. 中途会提示按任意键继续，根据提示按下任意一个键进行下一步。中途可能会听到设备弹出后再插入的提示音。继续按空格即可。6. 回到上一级，解压 `debian.zip` 文件，并进入解压出来的文件夹中   - ![image-20230618215517226](./Image/随身WiFi刷机教程.assets/image-20230618215517226.png)7. 再次清空地址栏，输入cmd，打开cmd窗口。8. 继续flash.bat，回车运行。   - ![image-20230618215614847](./Image/随身WiFi刷机教程.assets/image-20230618215614847.png)9. 继续按照提示按下任意按键。这回可能就需要一段时间了，因为正在推送系统到设备。   ## OpenWrtOpenWrt刷机就简单多了，进入fastboot模式打开脚本自动刷原作者仍只提供了001b版本，其它型号直接在本版块搜索，有不少酷友编译。如果遇到问题可以到我另一个动态看看解决办法。最后说一下，Debian和openwrt都有adb功能，刷这些系统都可以进fastboot模式刷，不用回到安卓。# Linux相关## 刷完初次进入linux时的准备工作检查`网络适配器`中是否存在一个基于远程NDIS的Internet共享…如果不存在，且在`其他设备`中存在一个名叫 `RNDIS`的设备，则右键点击这个设备，选择`更新驱动程序`，选择`浏览我的电脑以查找驱动程序`，接着 `让我从计算机上的可用驱动程序列表中选取`，拉到最下面找到 `网络适配器`，在厂商一栏中找到 `MicroSoft`，右侧的型号栏目中选择 `基于远程NDIS的Internet共享设备`。## 基础的系统配置1. 登录系统：初始用户：`user`，初始密码`1`2. 连接WIFI   ```bash   sudo nmtui



会显示一个蓝色背景的界面，使用上下光标键移动，选择 Activate a connection（回车），选择要连接的WiFi，回车，输入wifi密码，回车。
连上以后wifi名的左侧会多一个*号，同时右侧会有一个 Deactivate断开的选项。
按tab键将光标移动到back，回车，选择 Quit回车，回到ssh界面。
使用 sudo ifconfig命令就能看到一个连上WiFi以后得到的ip地址。
接下来就能使用这个ip地址进行登录。此时棒子就可以不插在电脑上，插在任意一个具有供电能力的设备上都能连接上了。

配置root用户密码
sudo passwd root

接下来要输入设置的密码。注意输入密码的时候是不可见的。

切换到root用户
sudo su



允许root用户远程登录，重启服务或系统后生效
echo &quot;PermitRootLogin yes&quot; &gt;&gt; /etc/ssh/sshd_config



修复mobian源并安装基础软件（逐行复制并执行）
apt updateapt install curl -yecho &quot;deb http://repo.mobian-project.org/ bookworm main non-free&quot; &gt; /etc/apt/sources.list.d/mobian.listcurl -s https://repo.mobian.org/mobian.gpg &gt; /etc/apt/trusted.gpg.d/mobian.gpgapt updateapt install vim wget git cron dnsutils unzip lrzsz fdisk gdisk exfat-fuse exfat-utils -y

可能需要一段时间，耐心等待即可。

配置系统时间
dpkg-reconfigure tzdata

选6 亚洲
然后选70 上海（亚洲 上海），需要按回车显示下一页，直到70 shanghai的选项出现，才能输入70.

配置ll命令
echo &quot;alias ll=&#x27;ls $LS_OPTIONS -alh&#x27;&quot; &gt;&gt; ~/.bashrc



修改vi配置
echo -e &quot;if has(&#x27;mouse&#x27;)\nset mouse-=a\nendif&quot; &gt; .vimrc



修改usb为主动模式
vi /usr/sbin/mobian-usb-gadget

把下面这行添加到[ setup() { ]的下一行
echo host &gt; /sys/kernel/debug/usb/ci_hdrc.0/role
然后:wq保存退出
注意，此条命令一旦执行，棒子再插到电脑上就不会显示成设备了，而是作为一个独立的主机存在。

重启设备
reboot

挂载u盘、配置开启启动、安装软件由于后续所有操作都直接用root用户登陆后操作，删掉已经没用的自带用户user
userdel -r user



挂载u盘
创建用于挂载的目录
mkdir /udisk



插上U盘，查看是否已经识别到
fdisk -l

可以看到Disk开头的文本，默认是挂载在/dev/sda目录中。
也有可能是sdb，一定要区分好

清理磁盘分区并新建（如果是大于2T的移动硬盘，下一条命令中的fdisk换成gdisk）
fdisk /dev/sda

然后按下如下字母执行操作

d   #删除分区

可以多按几下，直到出现 No partition is defined yet提示没有任何分区为止。


n   #新建分区，一路回车

如果提示yes or no，输入y然后回车


w   #保存更改

如果提示yes or no，输入y然后回车




再用 fdisk -l命令查看，可以发现插入的存储设备挂载的目录可能发生了变化。记住这个目录，后面要用.
比如 &#x2F;dev&#x2F;sda1

格式化分区
ext4性能好安全性高但不兼容windows，exfat性能差安全性差但兼容windows
mkfs.ext4 /dev/sda1或mkfs.exfat /dev/sda1

二者选其一执行。推荐ext4格式。
注意，如果存储设备是金士顿的这类写入速度很慢的设备，则此过程可能会很久，甚至卡死。

挂载
#挂载mount /dev/sda1 /udisk#mount /dev/sdb1 /hdisk#授权chmod 777 /udisk

配置开机行为
创建启动脚本
touch /etc/rc.localecho &#x27;#!/bin/sh -e&#x27; &gt; /etc/rc.localecho &quot;exit 0&quot; &gt;&gt; /etc/rc.local



给权限
chmod +x /etc/rc.local



重载systemd配置管理器
systemctl daemon-reload



启动守护进程
systemctl start rc-local



修改启动脚本
vi /etc/rc.local

将下方代码块中的内容复制到vi编辑器中。注意复制之前需要删除原有的数据。注意#开头的中文注释需要删除掉，因为可能会乱码
#!/bin/sh -e#等待2秒等待设备彻底启动完成sleep 2#开机自动挂载硬盘，可以修改成fstab？mount /dev/sda1 /udisk &amp;#等待5秒等待挂载完毕sleep 3#如果不安装接下来的miniDLNA，则这部分的内容不需要复制#清空minidlna缓存minidlnad -R#等待3秒等待清空完成sleep 2#启动dlnasystemctl start minidlna &amp;#如果不安装接下来的aria2，则这部分的内容不需要复制#启动aria2aria2c -D --conf-path=/etc/aria2/aria2.conf &amp;#可以试图把ddns的脚本粘贴到这里面exit 0

安装软件samba共享
安装samba
apt install samba samba-common-bin -y



修改配置文件
vi /etc/samba/smb.conf

将下方代码块中的内容复制到配置文件中。进入vi编辑器后要删除掉所有原来的数据。
[global]   workgroup = WORKGROUP   log file = /var/log/samba/log.%m   max log size = 1000   panic action = /usr/share/samba/panic-action %d   passdb backend = tdbsam   obey pam restrictions = yes   unix password sync = yes   security = user   passwd program = /usr/bin/passwd %u   passwd chat = *Enter\snew\s*\spassword:* %n\n *Retype\snew\s*\spassword:* %n\n *password\supdated\ssuccessfully* .   pam password change = yes   map to guest = bad user   load printers = no[samba]   browseable = yes   valid users = root   #samba共享的目录   path = /udisk   writable = yes   public = no   guest ok = no



配置samba用户，输入密码
smbpasswd -a root



重启samba服务
samba restart

注意事项与说明
samba用于局域网间共享文件
samba虽然也有端口号，也有协议，但没办法映射外网，是没有办法跨网段的，只能在当前网段中使用。

aria2下载器
新建下载目录并给权限
#分配文件夹mkdir /udisk/download#授权chmod 777 /udisk/download



安装aria2
apt install aria2 -y



创建aria2配置目录
mkdir /etc/aria2



创建aria2会话文件
touch /etc/aria2/aria2.session



创建aria2配置文件
vi /etc/aria2/aria2.conf

将下方代码块中的内容复制到vi编辑器中。注意配置信息不可以是别的，或者需要再修改一下，否则可能无法下载
#下载地址dir=/udisk/downloaddisk-cache=32Mcontinue=truefile-allocation=nonemax-concurrent-downloads=5max-connection-per-server=5max-overall-download-limit=0max-download-limit=0max-overall-upload-limit=0max-upload-limit=0disable-ipv6=truemin-split-size=10Msplit=10input-file=/etc/aria2/aria2.sessionsave-session=/etc/aria2/aria2.sessionsave-session-interval=60enable-rpc=truerpc-allow-origin-all=truerpc-listen-all=truefollow-torrent=true#peer-id-prefix=-TR2770-user-agent=Transmission/2.77bt-seed-unverified=truebt-save-metadata=truebt-enable-lpd=truebt-max-open-files=100bt-max-peers=60bt-min-crypto-level=plainbt-require-crypto=truelisten-port=65298dht-listen-port=65298seed-ratio=1seed-time=120rpc-secret=test123bt-tracker=udp://tracker.opentrackr.org:1337/announce,udp://9.rarbg.com:2810/announce,udp://tracker.openbittorrent.com:6969/announce,http://tracker.openbittorrent.com:80/announce,https://opentracker.i2p.rocks:443/announce,udp://tracker.torrent.eu.org:451/announce,udp://open.stealth.si:80/announce,udp://exodus.desync.com:6969/announce,udp://tracker2.dler.org:80/announce,udp://tracker.tiny-vps.com:6969/announce,udp://tracker.moeking.me:6969/announce,udp://tracker.dler.org:6969/announce,udp://tracker.0x.tf:6969/announce,udp://open.demonii.com:1337/announce,udp://movies.zsw.ca:6969/announce,udp://fe.dealclub.de:6969/announce,udp://explodie.org:6969/announce,udp://chouchou.top:8080/announce,udp://bt2.archive.org:6969/announce,udp://bt.oiyo.tk:6969/announce

注意事项开机自启在之前已经配置过来，这里不需要再配置了。
#####手动启动aria2aria2c -D –conf-path&#x3D;&#x2F;etc&#x2F;aria2&#x2F;aria2.conf &amp;
通过aria2.net调用，或者自建aria2 webuihttp://aria2.net/
使用端口6800
lamp环境与filerun 网页云盘注意，此教程只适合arrch64架构的设备，而且部分已经过时，需要注意

安装需要的软件
apt install apache2 php mariadb-server php-mysql php-mbstring php-curl php-gd php-imagick ffmpeg -y



编辑虚拟站点配置
vim /etc/apache2/sites-enabled/000-default.conf

将下方代码块中的内容复制到配置文件中。进入vi编辑器后要删除掉所有原来的数据。
&lt;VirtualHost *:80&gt;        DocumentRoot /var/www/html        ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log        CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined&lt;/VirtualHost&gt;



修改数据库编码
vi /etc/mysql/mariadb.conf.d/50-server.cnf

在[mysqld]字段的添加或修改如下部分
init_connect=&#x27;SET collation_connection = utf8mb4_unicode_ci&#x27;init_connect=&#x27;SET NAMES utf8mb4&#x27;character-set-server=utf8mb4collation-server=utf8mb4_unicode_ciskip-character-set-client-handshake



vi /etc/mysql/mariadb.conf.d/50-client.cnf

在[client]字段的修改如下部分
default-character-set=utf8mb4



vi /etc/mysql/mariadb.conf.d/50-mysql-clients.cnf

在[mysql]字段下修改如下部分
default-character-set=utf8mb4



重启数据库并初始化
#重启数据库systemctl restart mariadb#设置开机自启systemctl enable mariadb#初始化mysql_secure_installation#会提示输入密码，当前没有密码，直接回车即可#问是否切换到的时候输入n表示不切换#询问是否修改密码还是n，不在这里修改#是否移除匿名用户，输入y。Remove anonymous#然后接下来的三个询问都输入y，直到退出

进入数据库	
mysql -uroot -p#由于没有密码直接回车就能进入USE mysql;#这里输入要设置的密码，替换到下方的test123ALTER USER root@localhost IDENTIFIED VIA mysql_native_password USING PASSWORD(&#x27;test123&#x27;);FLUSH PRIVILEGES;#查看配置有没有生效，不打也可以show variables like &quot;%character%&quot;;show variables like &quot;%collation%&quot;;EXIT;#重启数据库systemctl restart mariadb



配置filerun运行环境：
注意不要cd切目录，保持再root用户登录后的初始目录中。

用pscp传输【loader-wizard.php】，【ioncube_loader_lin_7.4.so】，【00-ioncube.ini】，【FileRun_20220519_PHP73-74.zip】
在putty的目录中输入cmd，调出cmd命令框，然后在其中输入下方的几个命令，将文件传输到棒子
pscp loader-wizard.php root@192.168.123.131:/root/pscp ioncube_loader_lin_7.4.so root@192.168.123.131:/root/pscp 00-ioncube.ini root@192.168.123.131:/root/pscp FileRun_20220519_PHP73-74.zip root@192.168.123.131:/root/

或者直接用其他方式将这些文件上传到棒子的/root目录下。

将三个文件放到对应的目录下
mv loader-wizard.php /var/www/html/loader-wizard.phpmv ioncube_loader_lin_7.4.so /usr/lib/php/20210902/ioncube_loader_lin_7.4.somv 00-ioncube.ini /etc/php/8.1/apache2/conf.d/00-ioncube.inisystemctl restart apache2



访问http:&#x2F;&#x2F;设备的IP&#x2F;loader-wizard.php。如果看到绿色的框内容为：
Loader InstalledThe ionCube Loader version 11.0.1 for PHP 7.4 is already installed and encoded files should run without problems.


如果是红色的框则证明之前的操作有问题
那么运行环境就配置好了

删掉无用的文件
rm -rf /var/www/html/*



部署filerun文件包
mkdir 11 &amp;&amp; mv FileRun* 11 &amp;&amp; unzip -d 11 11/FileRun* &amp;&amp; rm 11/FileRun* &amp;&amp; mv 11/* /var/www/html &amp;&amp; rm -rf ~/11mkdir /var/www/html/userfile



设置filerun时区
echo &#x27;&lt;?php date_default_timezone_set(&quot;Asia/Shanghai&quot;); ?&gt;&#x27; &gt; /var/www/html/customizables/config.php



给权限，设置自启
chmod -R 777 /var/www/html/chmod -R 777 /udisksystemctl enable apache2



访问http:&#x2F;&#x2F;你的IP&#x2F;，开始配置


配置Fire RUN
next下一步

再next。应该都是绿色的OK字样。

输入完对应信息，next。
然后就会给一个初始用户。

使用初始用户登录进去

进入之后点击左侧下面的Control panel。

修改密码

输入主目录

汉化

退出再登录，就能看到中文的选项了


此时汉化完成

其他配置



注意事项可以使用FRP或者端口映射的形式进行外网访问。
默认端口80，可以修改
miniDLNA
安装软件包
apt install minidlna -y



修改配置文件
echo &#x27;media_dir=/udisk&#x27; &gt; /etc/minidlna.confecho &#x27;port=8200&#x27; &gt;&gt; /etc/minidlna.confecho &#x27;friendly_name=WiFi-410&#x27; &gt;&gt; /etc/minidlna.conf echo &#x27;inotify=yes&#x27; &gt;&gt; /etc/minidlna.conf



禁用自启
systemctl disable minidlna

后期会在脚本中启动，防止磁盘挂载失败导致认不到视频文件

启动minidlna
systemctl start minidlna


如果dlna认不到新加入的视频，重启一下系统，拔掉棒子再插上就行了


移动硬盘优化防止移动硬盘休眠
crontab -e*&#x2F;3 * * * * echo “1” &gt; &#x2F;udisk&#x2F;download&#x2F;.no-hiberfil
救砖（刷回原始包）Miko
Debian项目WIKIhttps://www.kancloud.cn/handsomehacker/openstick/2636505
概述关于 OpenStick针对于msm8916芯片的4G网卡的逆向工程和Mainline Linux移植。旨在实现一个廉价的带4G功能的ARM64单板电脑（性能其实和树莓派zero2、树莓派3b差不多）。提供完全可用的Debian发行版镜像和刷机方法。另外还会提供emcp扩容等高级玩法。支持电路板丝印为UFI001B、UFI001C、SP970、UZ801开头的4G无线网卡。本项目仅用于学习交流之用，请勿用于商业用途，本刷机包完全免费开源，欢迎举报倒卖的行为。
本教程的所有内容仅供参考，本人及文章作者不对任何刷机和改造设备的行为负责。也没有任何义务处理砖机。
设备具体配置虽然都在网上能查到，但是放在这里还是方便一点。

msm8916 主控 Cortex-A53 * 4 on 0.9GHZ
512MB内存+4GB储存的拆机二手emcp
WCN3620 &amp; WCN3680b
pm8916 PMIC

各外设对应GPIO


型号
red led
green led
blue led
按键



ufi001b&#x2F;c
gpio22
gpio21
gpio20
gpio37


sp970
gpio9
gpio10
gpio28
gpio107


uz801
gpio7
gpio8
gpio6
gpio23


UFI-16-V3
gpio8
(pmic) gpio4
gpio32
gpio49



设备支持情况这意味着主线内核(5.15 和 5.10)的对于设备的驱动程度



功能
支持状况



arm64
支持


KVM 虚拟化
支持


PSCI
支持（v1.0）


自适应emcp空间
支持


WIFI (WCN3620)
支持


WIFI (WCN3680b)
支持


蓝牙
支持


4G 流量
支持


短信
支持


USB HOST
支持


USB DEVICE
支持


Venus 视频解码器
支持


Venus 视频编码器
不支持


GPS
未验证


通话
未验证



注 : SP970与UZ801由于sim切卡gpio尚不明确，暂不支持与modem有关的功能（modem固件是正确的，如果你的机器是硬改实现切卡的可能modem能使用，未测试）。
SP970 V3 机型可能与SP970 V10的wifi芯片不太一样，刷入可能会导致wifi不稳定等问题。
UZ801在安卓下切卡后可能再刷机能使用modem，具体原因未知。
不同批次的相同版型可能存在cpu后缀的差异，使用不了modem的朋友短期内的解决方案只有自行提取modem firmware，未来可以通过独立modem固件分区的方法来实现兼容不同后缀的soc(感谢酷安 @fanxueke)。
HandsomeMod与Debian固件中使用的modem firmware信息如下所示，缺失的机型会在短时间内补充。




板型
SOC后缀



UFI001B
0VV


UFI001C
0VV


UFIW001
0VV


投稿与奉献欢迎各位大佬将自己的玩法或建议以markdown格式发到邮箱**handsomeyingyan@gmail.com**,或者私信（酷安、CSDN @handsomehacker）我们会尽快校对和更新文档，让更多的人看到：p
奉献者感谢所有为项目发展而奉献的朋友，排名不分先后。

HandsomeHacker
fanxueke （酷安 @fanxueke ）
魂梦九霄 （酷安 @魂梦九霄 ）
l305197437 (酷安 @l305197437 )
lilyok123 (酷安 @lilyok123 )
Zy143L (酷安 @Zy143L)

项目相关链接维护项目不易，欢迎star与关注！！HandsomeHacker的CSDN博客OpenStick 项目主页(github)HandsomeMod 项目主页
赞助如果你觉得本项目对你有帮助，欢迎赞助，帮助我们的项目发展的更好！
开始折腾首先你需要在Openstick项目的release中得到最新的Debian或HandsomeMod(可能会鸽)刷机包。然后准备好fastboot与adb工具,windows版本会在release中提供，linux直接使用包管理器中提供的版本即可。
Linux 下的刷机
不同的Linux发行版可能存在差异，这里以2022年2月8日的ArchLinux为例。
如果你的设备之前刷过base.zip，则可以将设备置于fastboot模式后从第4步开始。
ufi001b&#x2F;c之外的版型请使用更为通用的base-generic.zip，然后使用本机型的boot.img替换debian.zip中的boot.img


解压base.zip压缩包。
将你的设备置于fastboot模式
执行其中的flash.sh
当完成后解压&lt;系统名称&gt;.zip压缩包。
执行其中的flash.sh
enjoy!

Windows 下的刷机
作者的windows环境变量里有adb和fastboot，可能需要根据实际情况对脚本进行适当调整。
如果你的设备之前刷过base.zip，则可以将设备置于fastboot模式后从第4步开始。
ufi001b&#x2F;c之外的版型请使用更为通用的base-generic.zip，然后使用本机型的boot.img替换debian.zip中的boot.img


解压base.zip压缩包。
将你的设备置于fastboot模式
执行其中的flash.bat
当完成后解压&lt;系统名称&gt;.zip压缩包。
执行其中的flash.bat
enjoy!

Windows 下的常见驱动问题
[注] 部分翻译自postmarketOS wiki - Windows FAQ

如果你的设备被识别为adb 设备如果在启动OpenStick后，只有adb可以连接而rndis在设备管理器中没有出现，则可以将这个设备的驱动更新为Composite USB Device 即可,(Windows 7 下为“Android Composite USB Device”)。
安装RNDIS驱动
Windows 10 下的驱动位置




Windows 7 下的驱动位置 （感谢酷安 @l305197437）





基础使用这里记录一些基础使用的教程，仅供参考
Debian基础使用基本信息
Debian 11 bulleye 稳定版
Linux Kernel 5.15 LTS
装了一些bookworm的包（modemman ager）和mobian的fork，暂时不知道会给后续更新带来什么影响。
开机默认启动rndis与adbd，可以通过adb与ssh连接（ip地址为192.168.68.1）
默认配置了modem连接，插卡即有网。
默认hostname为openstick
默认用户名 user 密码 1
内核支持挂无线网卡和uvc摄像头，docker与anbox。

连接到OpenStick支持使用任何支持openssh协议的工具以及adb来连接到OpenStick的shell。

在windows下很多带颜色的字符会在adb下显示不出来，建议使用ssh进行连接。
adb fork自安卓4.4 不支持adb install 等涉及安卓图形界面或软件管理的指令。

使用adb# 进入bash$ adb shell# 也可以通过reboot bootloader进入到fastboot模式$ adb reboot bootloader

使用ssh$ ssh user@192.168.68.1

开启wifi热点 (不依赖网桥的方法)
Debian 使用NetworkManager进行网络连接管理，这里使用nmtui进行设置。
该方法不能同时使用rndis与wifi热点，如需要同时使用可以参考rndis与wifi热点共存(debian)

sudo nmtui

之后的界面如下所示：
创建一个连接

创建wifi类型的连接
device输入wlan0，其他选项按照你的需求自行填写
设置ip地址,注意ip类型必须为shared，ip地址必须为192.168.68.1
输入以下指令激活这个连接，激活后usb rndis功能会失效。sudo nmcli con up test

要再次使用usb rndis，可以down掉这个连接sudo nmcli con down test

常见问题UFI001C&#x2F;SP970&#x2F;UZ801 刷入debian.zip后工作不正常debian.zip仅适用于ufi001b，若需要支持其他版型需要同时更新设备树与固件。在github的release中下载boot-&lt;机型&gt;.img与firmware-&lt;机型&gt;.zip两个文件后，解压firmware.zip后,插入OpenStick，在你的电脑上键入以下指令。（uz801仅需更新boot.img)

注：windows下的替换建议配合scp使用，windows下adb不支持通配符“ * ”

 # 假设cmd&amp;terminal的当前目录在firmware的解压文件夹下$ adb push ./* /lib/firmware$ adb reboot bootloader$ fastboot flash boot boot-&lt;机型&gt;.img$ fastboot reboot

初次开机执行apt时报错 E: Release file for http://mirrors.163.com/debian/dists/bullseye/InRelease is not valid yet (invalid for another 157d 16h 49min 2s). Updates for this repository will not be applied.E: Release file for http://security.debian.org/dists/bullseye-security/InRelease is not valid yet (invalid for another 209d 4h 12min 32s). Updates for this repository will not be applied.E: Release file for http://repo.mobian-project.org/dists/bullseye/InRelease is not valid yet (invalid for another 23d 19h 53min 31s). Updates for this repository will not be applied.

这是ntp服务没有及时同步时间所导致的，重启即可。
adb环境下用不了nmtui等带图形的应用例如执行nmtui时出现以下错误
root@openstick:/# nmtui     TERM environment variable needs set.

设置TERM环境变量即可
$ export TERM=linux

root用户使用ssh登录不了
感谢酷友@fanxueke的投稿。
不要尝试在你有内网穿透或是在公网有ip的设备上使用root登录，这将会造成很大的安全隐患。
root的默认密码与user一致（都是1），可以通过passwd root修改

安装nano编辑器（需插入SIM卡或连接wifi）sudo apt-get update``sudo apt-get install nano

编辑sshd_configsudo nano /etc/ssh/sshd_config

将34行#PermitRootLogin prohibit-password改为PermitRootLogin yes将58行#PasswordAuthentication yes的#去掉
重启OpenSticksudo reboot







rndis与wifi热点共存(debian)解决debian rndis与wifi热点共存的问题

感谢 lilyok123 (酷安 @lilyok123) 的投稿
原理：创建一个网桥，配置ip地址，并且将usb网卡与无线网卡设备加入到网桥中即可
注意事项：建议操作前将wifi连接到路由器上，操作时先将usb网络加入到网桥中，确保电脑能够正常 连接后，再将无线网卡加入到网桥中，万一操作失误还能从其它的网卡登录设备。否则估计得重新刷机了。

具体步骤第一步，输入命令nmtui，创建一个网桥

第二步,配置ip地址为192.168.68.1&#x2F;24（大佬默认是这个地址，如果更改网段需要修改dnsmsq.conf文件），配置名随意，设备名随意，这里都写br0

第三步，为网桥添加一个ETHERNET设备

第四步，ethernet设备需要填写为usb0（ifconfig命令看到的网卡名），配置名随意，这里起个名也是usb0

第五步，此时usb0的设备添加成功，保存退出

第六步，此时usb0配置文件如果没有生效，需要nmcli connection手动激活下，如无意外此时电脑能够正常访问随身wifi了。如果不成功通过另外的无线网卡登录看看配置是不是正确。

第七步，在第六步usb0的网桥确保正常后，可以为网桥添加无线网卡了，输入nmtui命令，选择刚刚的br0配置文件，选择edit编辑。

第八步，选择添加WLAN无线设备

第九步，配置热点的名称，密码等参数，配置文件随意，device需要添加ifconfig中的无线网卡名称。

第十步，保存配置，返回

最后一步，此时wlan0的配置文件没有生效，需要手动nncli connection切换下。

控制led行为OpenStick 存在三个led灯，默认blue表示wifi连接状态，red表示系统是否还处于正常运行状态。
可以通过 echo &lt;行为&gt; &gt; &#x2F;sys&#x2F;class&#x2F;led&#x2F;&lt;名字&gt;&#x2F;trigger 来修改led行为。可用的行为如下
root@openstick:/sys/class/leds/green:internet# cat trigger [none] usb-gadget usb-host rfkill-any rfkill-none kbd-scrolllock kbd-numlock kbd-capslock kbd-kanalock kbd-shiftlock kbd-altgrlock kbd-ctrllock kbd-altlock kbd-shiftllock kbd-shiftrlock kbd-ctrlllock kbd-ctrlrlock timer heartbeat cpu cpu0 cpu1 cpu2 cpu3 default-on panic mmc0 bluetooth-power hci0-power rfkill0 phy0rx phy0tx phy0assoc phy0radio rfkill1

例如把green led的行为定义为usb device模式的活动状态
root@openstick:/sys/class/leds/green:internet# echo usb-gadget &gt; trigger

写入该字符串后led行为立刻生效，重启失效
控制usb行为OpenStick 提供的所有系统都使用基于libusbgx的Gadget Controller (以下简称gc)来管理usb在device模式下的行为。
Debian默认通过&#x2F;usr&#x2F;sbin&#x2F;mobian-usb-network-config脚本启动rndis和adb两种usb复合设备，这也就意味着如果你的设备安装的是Debian，插入电脑默认会出现两个设备。
HandsomeMod 通过uci来调用gc，用户可以通过luci来控制gc。
在Debian中，rndis建立的usb0网络通过networkmanager进行管理，dnsmasq作为dhcp server分配ip地址。
你也可以通过以下指令（例子）来加入更多的功能（同时运行不同功能的种类是有限的，受限于硬件）。
注意：在windows下rndis必须为第一个加入gadget中的功能，且windows不支持动态更新gadget，只能在脚本中一次添加完所有的gadget。
以下指令需要root权限,重启后失效。
# 列出当前usb活动的devicegc -l# 加入一个串口设备# 有效的关键字为 serial ffs hid midi printer uvc mass rndis ecm acmgc -a serial# 删除指定串口设备 （X 为列表中的对应的config名称）gc -r serial.X# 清除所有的gadgetgc -c# 关闭gadgetgc -d# 开启gadgetgc -e

切换USB工作模式OpenStick没有usb-id脚，只能手动将usb切换为主模式来插入u盘等设备，你可以将以下语句加入 &#x2F;usr&#x2F;sbin&#x2F;mobian-usb-gadget setup()的最开头来实现开机切换，所有usb device功能将会失效。
echo host &gt; /sys/kernel/debug/usb/ci_hdrc.0/role

当然也可以通过把usb-typea头改为mircousb头，然后把vol up(fb)触点的gpio接到usb-id实现自动切换(需修改设备树)。
关于 Gadget ControllerGadget Controller 的开发时间有点短，可能不够成熟。。。欢迎star、提出issue和pull request来帮助我完善它~
lk bootloader基本使用这里只记录和平常的lk不大一样的地方
获取日志fastboot oem lk_logfastboot get_staged /dev/stdout

提取分区内容fastboot oem dump &lt;分区名&gt;fastboot get_staged &lt;文件名&gt;

进入edl模式fastboot oem reboot-edl



emali短信转发转载至酷安@魂梦九霄调用modemmanager的get-sms指令，可以将收到的短信转发到指定邮箱gitee源码
使用转发前请补全smtp.py开头的smtp信息python3 msg.py add 861234567890 text

添加发送到1234567890的内容为text的短信到暂存区
python3 msg.py send

将所有暂存区的短信发送
python3 msg.py clean

清除本地所有短信（暂存，已发送，接收）
python3 msg.py forward

将所有接收到的短信通过smtp邮件转发
高级玩法这里记录一些高级玩法，仅供参考。
emcp扩容这里只记录在linux下的扩容过程，windows应该类似，使用9008模式下的备份工具备份整个emcp上的内容即可（包含分区表）。高通的9008模式恢复时会将userdata分区自动扩充到所有可用的空间，所以理论上来说安卓系统也适合该方法备份（据部分用户反映安卓系统在扩容后的机器中无法使用）。

注意：方法仅供参考，不代表百分之百在你的环境中可用。

硬件按照原机搭配的emcp，可以确定emcp必须满足以下条件。

内置的内存必须是lpddr2 （不敢确定 我的机器大部分搭配的是lpddr2 msm8916支持lpddr3但可能需要不同的电压来驱动，即使电压一样也许需要使用不同的loader来初始化内存）
bga封装必须是bga162
符合规格的芯片会在焊接到位后上电进入9008(edl)模式，其他情况则会没有任何反应。

经过测试以下的芯片可以兼容UFI001B&#x2F;C机型

08emcp08-nl2cv100 (bga162 lpddr2 1g + 8g emmc)
kmk8x000vm-b412 (bga162 lpddr2 1g + 16g emmc)

软件推荐使用linux下的edl工具,安装之前默认你的环境中有python3及yay。
yay -S edl-git


不是Arch-based的发行版建议直接按照edl官方的方法安装。

之后长按机器上电，进入9008模式，输入以下指令备份emcp中的内容。
edl rl dumps --skip=userdata --genxml


如果长时间卡住，建议ctrl+c以后重试。
如果你的edl报例如no suitable loader found一类的错误，则可以尝试其他的loader初始化内存，edl提供了很多loader这里以红米2的loader为例(loader路径 不同的linux环境可能会有差异，仅供参考)。

$ edl rl dumps --skip=userdata --genxml  \--loader /usr/lib/python3.10/site-packages/edlclient-3.53-py3.10.egg/edlclient/../Loaders/xiaomi/007050e100000000_50838757eab7c632_fhprg_peek_wt88047.bin

换上新的emcp后，会出现9008设备，此时在备份文件夹里输入以下指令
$ edl qfil rawprogram0.xml patch0.xml


如果出错，同上，加入loader参数即可。

重启机器，灯光亮起即代表扩容成功。
$ edl reset

参考资料这里有些常见的emcp&amp;emmc型号，仅供参考(感谢 酷安@Zy143L 的整理)


编译内核（debian）这里介绍如何使用linux定制自己的内核，推荐的发行版是Ubuntu 20.04。
需要的软件包不同的发行版可能对软件包命名会有所不同，这里以Ubuntu 20.04的命名为例。

binfmt-support
qemu-user-static
gcc-10-aarch64-linux-gnu
kernel-package
fakeroot
simg2img
img2simg
mkbootimg
bison

生成内核debian软件包克隆linux内核,这里选择深度为1减少体积。
$ git clone https://github.com/OpenStick/linux --depth=1

开始编译
$ export CROSS_COMPILE=aarch64-linux-gnu-$ export ARCH=arm64$ make msm8916_defconfig$ make menuconfig$ make -j16

生成debian格式的软件包
$ fakeroot make-kpkg  --initrd --cross-compile aarch64-linux-gnu- --arch arm64  kernel_image kernel_headers

之后将生成的deb软件包(会在代码目录上层生成)，与arch/arm64/boot/Image.gz保留备用将rootfs.img转换成img格式并挂载
$ simg2img rootfs.img root.img$ sudo mount root.img /mnt

在chroot环境下，将前面生成的linux-image等deb安装包安装即可。注意要将安装完成后生成的boot/initrd.img取出备用（安装之前最好卸载原来的linux-image之类的软件包）。
$ sudo  mount --bind /proc /mnt/proc $ sudo  mount --bind /dev /mnt/dev$ sudo  mount --bind /dev/pts /mnt/dev/pts$ sudo  mount --bind /sys /mnt/sys$ sudo  chroot /mnt

安装完成后，解除所有挂载，将img再次转换为simg
$ img2simg root.img rootfs.img

生成boot.img取前面文件系统安装新内核后/boot/initrd.img**文件与内核编译阶段生成的Image.gz和arch/arm64/boot/dts/qcom/下对应设备的*.dtb备用将devicetree(dtb)附在Image.gz之后
cat Image.gz dtb &gt; kernel-dtb

生成boot.img
$ mkbootimg \             --base 0x80000000 \        --kernel_offset 0x00080000 \        --ramdisk_offset 0x02000000 \        --tags_offset 0x01e00000 \        --pagesize 2048 \        --second_offset 0x00f00000 \        --ramdisk initrd.img \        --cmdline &quot;earlycon root=PARTUUID=a7ab80e8-e9d1-e8cd-f157-93f69b1d141e console=ttyMSM0,115200 no_framebuffer=true rw&quot;\        --kernel kernel-dtb -o boot.img

之后将两个img文件分别刷入对应分区即可。
编译lk bootloader这里不再介绍lk2nd的编译，只介绍lk1st的编译方法。原理其实很简单，交叉编译后得到aboot之后使用dragonboard提供的密匙签名即可。

注意：不适用于开启secureboot的设备，如果你的设备不在支持列表之内，教程的有效性将得不到保证。
uz801和sp970由于某些原因在lk阶段点不亮led。
目前最为完美的机型是UFI001B&#x2F;C系列

克隆lk2nd项目
$  git clone https://github.com/OpenStick/lk2nd.git

进入lk2nd目录使用以下指令开始编译
make TOOLCHAIN_PREFIX=arm-none-eabi- lk1st-msm8916 -j8

之后会出现build-lk1st-msm8916目录，复制产物emmc_appsboot.mbn备用。
克隆签名工具qtestsign
$ git clone https://github.com/msm8916-mainline/qtestsign

将前面的emmc_appsboot.mbn放入qtestsign目录，之后输入以下指令。
$ ./qtestsign.py aboot emmc_appsboot.mbn

之后会生成emmc_appsboot-test-signed.mbn,刷入即可。
$ fastboot flash aboot emmc_appsboot-test-signed.mbn]]></content>
      <categories>
        <category>搞事情</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>刷机</tag>
        <tag>搞事情</tag>
        <tag>随身WiFi</tag>
      </tags>
  </entry>
</search>
