<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AI提示词_学习笔记生成</title>
    <url>/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[学习笔记生成你是一位耐心、善于解释的教师，擅长为完全没有专业背景的小白生成学习笔记。请遵循以下要求：
【读者定位】

完全没有专业背景，但懂最基础概念（如程序结构、变量、函数，或电路、电压、电流等基础概念，视领域而定）。

【任务说明】

学习主题：{填写领域主题，例如“RabbitMQ”或“模拟电子元件”}
学习目标：{填写希望掌握的核心内容，例如“消息队列基础、队列、交换机、消息发布订阅”}

【生成流程】

生成学习笔记大纲

按章节或小节列出学习顺序

每个章节用一句话说明要讲解的核心内容

大纲必须考虑小白的理解顺序，由浅入深

示例大纲格式：
第1章：XXX是什么？（一句话解释）第2章：XXX的基本使用方法第3章：XXX的高级应用第4章：练习与复习


确认大纲

在生成完整内容前，请把大纲输出给我确认
待我确认大纲无误后，再生成详细内容


生成详细内容

每章内容应包括：
简单易懂的语言解释概念
类比或生活中的例子
示例或练习题（例如代码示例、电路练习等）
章节小结或关键点总结


风格要求：
口语化、易懂
条理清晰，章节分明
鼓励思考，适当提出问题让读者自问自答





]]></content>
      <categories>
        <category>AI提示词</category>
      </categories>
      <tags>
        <tag>使用教程</tag>
        <tag>AI</tag>
        <tag>protected</tag>
      </tags>
  </entry>
  <entry>
    <title>AI提示词_试题生成</title>
    <url>/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E8%AF%95%E9%A2%98%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[试题生成你是一位耐心且富有创造力的教师，擅长为学习者设计检验知识掌握程度的练习题和提问。请遵循以下要求：
【读者定位】

学习者已经掌握部分知识，但需要通过练习来检验理解深度。
假设学习者已经熟悉基础概念，但可能对复杂应用或细节理解不足。

【任务说明】

学习领域：{填写领域，例如“RabbitMQ”或“模拟电子元件”}
已掌握内容：{填写你已经掌握的知识点，例如“队列、交换机、基本消息发布与订阅”}
目标：生成一份检验学习者掌握程度的练习题或提问，帮助发现理解的薄弱环节。

【题目要求】

题型多样：
选择题（多选&#x2F;单选）
填空题
简答题
实操题或小实验题（例如代码编写、电路设计、配置操作）


每题应有清晰的题目描述，必要时提供上下文或示例
尽量设计由浅入深的题目，既考基础知识，也涉及实际应用
对每题给出参考答案或解析，说明正确思路和关键点
鼓励思考，不只是死记硬背
如果适用，题目可以带有实际操作步骤或小实验指导

【输出格式】
按题型分类，例如：一、选择题
XXX？A. …B. …C. …D. …正确答案：B解析：…
二、填空题
XXX正确答案：…
三、简答题
XXX参考答案：…
四、实操题&#x2F;小实验
XXX指导步骤：…参考答案：…
]]></content>
      <categories>
        <category>AI提示词</category>
      </categories>
      <tags>
        <tag>使用教程</tag>
        <tag>AI</tag>
        <tag>protected</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基础教程</title>
    <url>/2023/12/01/Docker%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[01-Docker概述Docker简介Docker是基于Go语言实现的云开源项目。
Docker的主要目标是：Build, Ship and Run Any App, Anywhere，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP及其运行环境能做到一次镜像,处处运行。
传统虚拟机和容器传统虚拟机（virtual machine）：传统虚拟机技术基于安装在主操作系统上的虚拟机管理系统（如VirtualBox、VMware等），创建虚拟机（虚拟出各种硬件），在虚拟机上安装从操作系统，在从操作系统中安装部署各种应用。缺点：资源占用多、冗余步骤多、启动慢
Linux容器（Linux Container，简称LXC）：Linux容器是与系统其他部分分隔开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。
Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一的运行。

对比：



特性
容器
虚拟机



启动
秒级
分钟级


大小
一般为Mb
一般为Gb


速度
接近原生
比较慢


系统支持数量
单机支持上千个容器
一般几十个


Docker运行速度快的原因Docker有比虚拟机更少的抽象层：由于Docker不需要Hypervisor（虚拟机）实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在CPU、内存利用率上docker有明显优势。
Docker利用的是宿主机的内核，而不需要加载操作系统OS内核：当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较耗时耗资源的过程。当新建一个虚拟机时，虚拟机软件需要加载OS，返回新建过程是分钟级别的。而Docker由于直接利用宿主机的操作系统，则省略了返回过程，因此新建一个docker容器只需要几秒钟。
Docker容器的本质就是一个进程。
Docker软件Docker并非一个通用的容器工具，它依赖于已经存在并运行的Linux内核环境。（在Windows上安装Docker时需要依赖WLS，也即Windows下的Linux子系统）。
Docker实质上是在已经运行的Linux下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的Linux主机。
Docker的基本组成部分：

镜像（image）
容器（container）
仓库（repository）

Docker镜像Docker镜像就是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建多个容器。
Docker容器Docker利用容器独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。
Docker仓库Docker仓库是集中存放镜像文件的场所。仓库分为公开仓库和私有仓库两种。最大的公开仓库是Docker官方的Docker Hub：https://hub.docker.com/
Docker架构Docker是一个 C&#x2F;S（Client-Server） 结构的系统，后端是一个松耦合架构，众多模块各司其职。
Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从容器接收命令并管理运行在主机上的容器。

Docker运行的基本流程为：

用户是使用Docker Client 与 Docker Daemon 建立通信，并发送请求给后者
Docker Daemon 作为 Docker 架构的主体部分，首先提供 Docker Server 的功能使其可以接收 Docker Client 的请求
Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式存在
Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph Driver 将下载镜像以 Graph 的形式存储
当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境
当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Exec driver 来完成
Libcontainer 是一项独立的容器管理包，Network driver 以及 Exec driver 都是通过 Libcontainer 来实现具体对容器进行的操作


02-Docker安装与卸载CentOS安装Docker参考官网：https://docs.docker.com/engine/install/centos/
卸载旧版本如果之前安装过Docker，需要先卸载旧版本：
sudo yum remove docker \              docker-client \              docker-client-latest \              docker-common \              docker-latest \              docker-latest-logrotate \              docker-logrotate \              docker-engine


旧版本的Docker引擎包可能叫做：docker、docker-engine。


新版本的Docker引擎包叫做：docker-ce

配置yum资源库安装yum-config-manager：
# yum-util提供yum-config-manager功能 sudo yum install -y yum-utils

配置docker的资源库地址：
官方地址：（比较慢，不推荐）
# 在yum资源库中添加docker资源库sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo

阿里云镜像地址：
sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo


阿里云官网提供了很多资源镜像，镜像地址：https://mirrors.aliyun.com，进入之后可以选择自己需要的资源进行配置

创建缓存（可选）：
yum makecache fast

安装Docker引擎安装最新版本的Docker引擎、Docker客户端：
# docker-ce是Docker引擎，docker-ce-cli是客户端sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin

此时，默认安装的docker引擎、客户端都是最新版本。
如果要安装指定版本：
# 查询版本列表yum list docker-ce --showduplicates | sort -r# 指定版本安装17.09.0.ce版# sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-compose-pluginsudo yum install docker-ce-17.09.0.ce docker-ce-cli-17.09.0.ce containerd.io docker-compose-plugin

启动docker引擎如果没有启动Docker引擎，那么执行 docker version查看版本号时，只能看到 Client: Docker Engine（Docker引擎客户端）的版本号。
启动Docker引擎：
# 新版本的Docker就是一个系统服务，可以直接使用启动系统服务方式启动systemctl start docker# 此时查看docker版本，可以看到Server: Docker Engine（Docker引擎）版本号docker version

卸载Docker卸载Docker步骤：

关闭服务

systemctl stop docker



使用yum删除docker引擎

sudo yum remove docker-ce docker-ce-cli containerd.io



删除镜像、容器、卷、自定义配置等文件

sudo rm -rf /var/lib/dockersudo rm -rf /var/lib/containerd



运行HelloWorld测试运行HelloWorld：
docker run hello-world





03-Docker下载加速docker下载加速方式1：使用 网易数帆、阿里云等容器镜像仓库进行下载。
例如，下载网易数帆镜像中的mysql。（网易数帆的地址为 hub.c.163.com，网易数帆对dockerhub官方的镜像命名空间为 library）。
docker pull hub.c.163.com/library/mysql:latest

方式2：配置阿里云加速。
登录阿里云，进入 工作台 -&gt; 容器镜像服务 -&gt; 镜像工具 -&gt; 镜像加速器。
里面提供了一个加速器地址：https://xxxxx.mirror.aliyuncs.com，将该地址配置到docker中：
cd /etc/docker## 初次进来时没有/etc/docker/daemon.json文件，直接创建该文件即可vi /etc/docker/daemon.json

在daemon.json中写入以下内容：（即加速器地址）
&#123;  &quot;registry-mirrors&quot;: [&quot;https://xxxxx.mirror.aliyuncs.com&quot;]  &#125;

然后刷新配置、重启docker即可：
## centos6 的命令sudo chkconfig daemon-reloadsudo service docker restart## centos7 的命令sudo systemctl daemon-reloadsudo systemctl restart docker

使用方式2可以直接下载官方的镜像，且镜像tag为官方tag，不需要加上云服务商的地址。
例如：
docker pull mysql:latest





04-Docker常用命令启动类命令启动docker：
systemctl start docker

停止Docker：
systemctl stop docker

重启Docker：
systemctl restart docker

查看状态：
systemctl status docker

设置开机自启：
systemctl enable docker

帮助类命令查看Docker版本：
docker version

查看Docker概要信息：
docker info

查看Docker总体帮助文档：
docker --help

查看docker具体命令帮助文档：
docker 具体命令 --help

镜像命令列出本地主机上的镜像docker images

参数：

-a：列出所有镜像（含历史镜像）
-q：只显示镜像ID
-f：过滤

样例：
root@hurrubuntutest:~# docker imagesREPOSITORY                     TAG                            IMAGE ID       CREATED        SIZErustdesk/rustdesk-server-s6    latest                         57bf2e51c27b   46 hours ago   39.3MBlouislam/uptime-kuma           1.23.8                         db1d2f3df02a   4 days ago     434MBjgraph/drawio                  22.1.5                         c169fe2d8326   7 days ago     749MBmatrixdotorg/synapse           latest                         4c616e255858   8 days ago     439MBmatrixdotorg/synapse           v1.97.0                        8b677737da1f   8 days ago     439MBgotson/komga                   1.8.0                          e587682c2347   9 days ago     508MBsquidfunk/mkdocs-material      9.4.14                         e6ea3aaebf48   10 days ago    183MBlinuxserver/calibre-web        0.6.21                         afd08db699c8   11 days ago    744MBminio/minio                    RELEASE.2023-11-11T08-14-41Z   603e753a418c   3 weeks ago    147MBcorentinth/it-tools            2023.11.2-7d94e11              5d66a3cbe609   4 weeks ago    57.9MBmysql                          8.2.0                          a3b6608898d6   6 weeks ago    596MBrequarks/wiki                  2.5.300                        58e34147fec5   3 months ago   552MBhomeassistant/home-assistant   2023.8.0.dev20230723           a85caf565806   4 months ago   1.83GBzhaojun1998/zfile              4.1.5                          4be9b42156f9   6 months ago   348MBhello-world                    latest                         9c7a54a9a43c   7 months ago   13.3kBdeluan/navidrome               pr-2295                        3d6a1a800597   8 months ago   154MBfogforest/yesplaymusic         0.4.7                          6bcbc7a80953   9 months ago   101MB



说明：

REPOSITORY：镜像的仓库源
TAG：镜像的标签版本号
IMAGE ID：镜像ID
CREATED：镜像创建时间
SIZE：镜像大小

同一个仓库源可以有多个TAG版本，代表这个仓库源的不同个版本，使用REPOSITORY：TAG来定义不同的镜像。
如果不指定一个镜像的版本标签，例如使用ubuntu的时候，docker将默认使用ubuntu:latest镜像
在远程仓库中搜索镜像（默认取docker hub中搜索）
docker search 镜像名称

参数：

-f：过滤
--limit 数量：只展示前几项

下载镜像docker pull 镜像名称[:tag]

不加 tag 时，默认下载最新的镜像（即tag为latest）。
查看占据的空间查看镜像&#x2F;容器&#x2F;数据卷所占的空间：
docker system df

删除镜像docker rmi 镜像名称/ID

可以使用空格分隔，删除多个镜像：
docker rmi 镜像1 镜像2 镜像3

删除全部镜像：
docker rmi -f $(docker images -qa)

虚悬镜像仓库名、标签都是&lt;none&gt;的镜像，俗称虚悬镜像（dangling image）。
一般是构建的镜像的时候出了问题。
命令自动补全docker支持命令自动补全功能，当输入镜像名前几位时，可以按tab键自动补全镜像名称、tag等。
## 如果镜像中有ubuntu，查看输入ub按下tab是否可以补全docker run ub

如果按下tab时没有自动补全，可以按以下步骤操作：

检查是否安装了bash-completion（命令补全增强包）

## 检查有 /usr/share/bash-completion/bash_completion 这个文件ls /usr/share/bash-completion/bash_completion



如果有/usr/share/bash-completion目录，但是没有/usr/share/bash-completion/bash_completion文件（centos6为/etc/bash_completion文件），则需要安装bash-completion

yum -y install bash-completion



检查是否安装了docker的自动补全

## 检查/usr/share/bash-completion/completions文件夹下是否有docker开头的自动补全## docker安装完后会在该文件夹下生成自动补全文件docker## 如果安装了docker-compose，则该文件夹下还会有 docker-compose文件ll /usr/share/bash-completion/completions/docker*



如果已经安装了docker自动补全，使用source命令使其生效

source /usr/share/bash-completion/completions/docker



再次使用tab查看是否可以自动补全

## 如果镜像中有ubuntu，查看输入ub按下tab是否可以补全docker run ub



如果有报错，且报错中提示_get_comp_words_by_ref: command not found。说明bash-completion的配置文件没有生效，需要source一下

## 对于centos7，bash-completion安装的是2.x版本，配置文件为/usr/share/bash-completion/bash_completionsource /usr/share/bash-completion/bash_completion## 如果是centos6，自动安装的bash-completion最新版为1.x版本，配置文件为/etc/bash_completion## bash /etc/bash_completion



再次使用tab查看是否可以自动补全

## 如果镜像中有ubuntu，查看输入ub按下tab是否可以补全docker run ub





05-容器命令新建启动容器docker run [OPTIONS] IMAGE [COMMAND] [ARG...]

常用的参数：

--name：为容器指定一个名称
-d：后台运行容器并返回容器ID，也即启动守护式容器
-i：以交互模式（interactive）运行容器，通常与-t同时使用
-t：为容器重新分配一个伪输入终端（tty），通常与-i同时使用。也即启动交互式容器（前台有伪终端，等待交互）
-e：为容器添加环境变量
-P：随机端口映射。将容器内暴露的所有端口映射到宿主机随机端口（大写P）
-p：指定端口映射（小写p）

-p指定端口映射的几种不同形式：

-p hostPort:containerPort：端口映射，例如-p 8080:80
-p ip:hostPort:containerPort：配置监听地址，例如 -p 10.0.0.1:8080:80
-p ip::containerPort：随机分配端口，例如 -p 10.0.0.1::80
-p hostPort1:containerPort1 -p hostPort2:containerPort2：指定多个端口映射，例如-p 8080:80 -p 8888:3306

启动交互式容器以交互方式启动ubuntu镜像
## -i 交互模式## -t 分配一个伪输入终端tty## ubuntu 镜像名称## /bin/bash（或者bash） shell交互的接口docker run -it ubuntu /bin/bash


退出交互模式方式1：
## 在交互shell中exit即可退回宿主机exit;

方式2：使用快捷键ctrl + P + Q
方式1 退出后，容器会停止；
方式2 退出后容器依然正在运行。
启动守护式容器大部分情况下，我们系统docker容器服务时在后台运行的，可以通过-d指定容器的后台运行模式：
docker run -d 容器名

注意事项：
如果使用docker run -d ubuntu尝试启动守护式的ubuntu，会发现容器启动后就自动退出了。
因为Docker容器如果在后台运行，就必须要有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（例如top、tail），就会自动退出。
列出正在运行的容器列出所有正在运行的容器：
docker ps [OPTIONS]

常用参数：

-a：列出当前所有正在运行的容器+历史上运行过的容器
-l：显示最近创建的容器
-n：显示最近n个创建的容器
-q：静默模式，只显示容器编号

容器其他启停操作启动已经停止的容器docker start 容器ID或容器名

重启容器docker restart 容器ID或容器名

停止容器docker stop 容器ID或容器名

强制停止容器docker kill 容器ID或容器名

删除容器删除已经停止的容器：
docker rm 容器ID或容器名


删除容器是 docker rm，删除镜像是 docker rmi，注意区分。

强制删除正在运行的容器：
docker rm -f 容器ID或容器名

一次删除多个容器实例：
docker rm -f $&#123;docker ps -a -q&#125;## 或者docker ps -a -q | xargs docker rm

查看容器日志docker logs 容器ID或容器名

查看容器内运行的进程docker top 容器ID或容器名

查看容器内部细节docker inspect 容器ID或容器名

进入正在运行的容器进入正在运行的容器，并以命令行交互：
docker exec -it 容器ID bashShell

重新进入：
docker attach 容器ID

docker exec 和 docker attach 区别：

attach直接进入容器启动命令的终端，不会启动新的进程，用exit退出会导致容器的停止
exec是在容器中打开新的终端，并且可以启动新的进程，用exit退出不会导致容器的停止

如果有多个终端，都对同一个容器执行了 docker attach，就会出现类似投屏显示的效果。一个终端中输入输出的内容，在其他终端上也会同步的显示。
容器和宿主机文件拷贝容器内文件拷贝到宿主机：
docker cp 容器ID:容器内路径 目的主机路径

宿主机文件拷贝到容器中：
docker cp 主机路径 容器ID:容器内路径

导入和导出容器export：导出容器的内容流作为一个tar归档文件（对应import命令）；
import：从tar包中的内容创建一个新的文件系统再导入为镜像（对应export命令）；
示例：
## 导出## docker export 容器ID &gt; tar文件名docker export abc &gt; aaa.tar## 导入## cat tar文件 | docker import - 自定义镜像用户/自定义镜像名:自定义镜像版本号cat aaa.tar | docker import - test/mytest:1.0.1

将容器生成新镜像docker commit提交容器副本使之成为一个新的镜像。

docker 启动一个镜像容器后， 可以在里面执行一些命令操作，然后使用docker commit将新的这个容器快照生成一个镜像。

docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[tag]

Docker挂载主机目录，可能会出现报错：cannot open directory .: Perission denied。
解决方案：在命令中加入参数 --privileged=true。
CentOS7安全模块比之前系统版本加强，不安全的会先禁止，目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了。如果要开启，一般使用 --privileged=true，扩大容器的权限解决挂载没有权限的问题。也即使用该参数，容器内的root才拥有真正的root权限，否则容器内的root只是外部的一个普通用户权限。
容器数据卷卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过UnionFS，提供一些用于持续存储或共享数据。
特性：卷设计的目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。
特点：

数据卷可以在容器之间共享或重用数据
卷中的更改可以直接实施生效
数据卷中的更改不会包含在镜像的更新中
数据卷的生命周期一直持续到没有容器使用它为止

运行一个带有容器卷存储功能的容器实例：
docker run -it --privileged=true -v 宿主机绝对路径目录:容器内目录[rw | ro] 镜像名

可以使用docker inspect查看容器绑定的数据卷。
权限：

rw：读写 
ro：只读。如果宿主机写入内容，可以同步给容器内，容器内可以读取。

容器卷的继承：
## 启动一个容器docker run -it --privileged=true /tmp/test:/tmp/docker --name u1 ubuntu /bin/bash## 使用 --volumes-from 继承 u1的容器卷映射配置docker run -it --privileged=true --volumes-from u1 --name u2 ubuntu

所有命令示意图
06-Docker镜像镜像是什么镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好行程一个可交付的运行环境（包括代码、运行时需要的库、环境变量和配置文件等），这个打包好的运行环境就是image镜像文件。
只有通过镜像才能生成Docker容器示例（只有通过类才可以生成一个对象，镜像就相当于类，容器示例就相当于对象）
镜像的分层
根据图片中拉去的流程，可以得出一个结论：镜像是分层的。
Docker 镜像加载原理UnionFS - 联合文件系统Docker 中的文件存储驱动叫做 storage driver。
Docker 最早支持的stotage driver是 AUFS，它实际上由一层一层的文件系统组成，这种层级的文件系统叫UnionFS。
联合文件系统（UnionFS）：Union 文件系统，是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite serveral directories into a single virtual filesystem）。
Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像，类似Object）可以制作具体的应用镜像。
特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。
后来出现的docker版本中，除了AUFS，还支持OverlayFS、Btrfs、Device Mapper、VFS、ZFS等storage driver。
bootfs和rootfsdocker的镜像实际上是由一层一层的文件系统组成，这种层级的文件系统构成UnionFS。UnionFS是一种文件系统技术，它允许将多个不同的文件系统以层级的方式组合在一起，形成一个统一的文件系统。这种层级 结构使得Docker的镜像具有轻量、可扩展和可共享的特性。
bootfs（boot file system）主要包含 bootloader 和 kernel，bootloader主要是引导加载 kernel，Linux刚启动时会加载bootfs文件系统。
在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已经由 bootfs 转交给内核，此时系统也会卸载 bootfs。
rootfs（root file system），在bootfs之上，包含的就是典型Linux系统中的 /dev、/proc、/bin、/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu、CentOS等。
docker镜像底层层次：

对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接使用Host的Kernel，自己只需要提供rootfs就可以。所以，对于不同的Linux发行版，bootfs基本是一致的，rootfs会有差别，不同的发行版可以共用bootfs。
有差别的rootfs：

镜像分层Docker支持扩展现有镜像，创建新的镜像。新镜像是从base镜像一层一层叠加生成的。(类似于继承后得到一个子类)
例如：
## Version: 0.0.1FROM debian  ## 直接在debain base镜像上构建MAINTAINER mylinuxRUN apt-get update &amp;&amp; apt-get install -y emacs ## 安装emacsRUN apt-get install -y apache2 ## 安装apache2CMD [&quot;/bin/bash&quot;] ## 容器启动时运行bash

镜像创建过程：

镜像分层的优势镜像分层的一个最大好处就是共享资源，方便复制迁移，方便复用。
容器层当容器启动时，一个新的可写层将被加载到镜像的顶部，这一层通常被称为容器层，容器层之下的都叫镜像层。
所有对容器的改动，无论添加、删除、还是修改文件都只会发生在容器层中。
只有容器层是可写的，容器层下面的所有镜像层都是只读的。
如图：

07-nexus搭建docker私仓使用nexus创建docker私有仓库Nexus的安装请参考该文档：https://www.yuque.com/tmfl/pom/uumrx2
Nexus配置Docker仓库步骤；

nexus默认docker是失效的，需要 在security –&gt; Realms，将docker配置成Active 
在 Repository 的 Blob Store 中创建一个用于存放docker镜像的存储。内网没有S3的话，把Type配置为file就行。


S3：Simple Storage Service，简单对象存储服务，即云存储。


在 Repository 的 Repositories 中创建一个新的资源库，类型为 docker-hosted。

创建的 docker-hosted资源库的相关配置：

Name：指定该资源库的名称，例如就叫 docker-hosted
Online：默认勾选即可
HTTP：与下面的HTTPS，至少需要勾选其中一个选择框，并配置一个和nexus不同的端口号，例如 8881。将来docker客户端向镜像中心上传镜像时，需要向该端口号进行上传。
HTTPS：如果服务器可以开启https服务，则也可以勾选HTTPS，然后配置一个端口号，接收docker客户端上传上来的镜像。
Allow anonymous docker pull：允许匿名上传，默认不勾选
Enable docker V1 API：是否启用 docker早期V1版本的API，默认不勾选，即只启用V2 API：http://xxx.xxx.xxx.xxx:8881/v2/
Blob Store：选择上面创建的docker镜像的存储
Deployment Policy：是否允许重复上传同一个资源，默认允许

配置好之后，修改防火墙设置，开启刚刚配置的8881 端口：
vim /etc/sysconfig/iptables

添加：
-A INPUT -p tcp -m tcp --dport 8881 -j ACCEPT

重启iptables：
service iptables restart

docker客户端的镜像导出和导入镜像下载和导出：
## 下载镜像docker pull mysql:8.0.28## 将镜像导出成本地tar文件docker save -o mysql-8.0.28.tar mysql:8.0.28

镜像的导入：
## 将本地文件导入到docker镜像中（docker会自动解析出文件中的tag，无需手动指定）docker load &lt; mysql-8.0.28.tar

docker 客户端向私仓上传镜像配置docker允许接收http请求docker默认只接收https请求，而我们的nexus私仓如果配置的是HTTP接口的话，docker直接连会报错：
server gave HTTP response to HTTPS client

需要配置docker允许连接我们私仓的http。
vim /usr/lib/systemd/system/docker.service

在其中的ExecStart 选项后面，添加 --insecure-registry {docker 私有镜像库 IP} --ipv6=false。
例如：
[Service]##  前面的-H参数可能不同，不需要管，只需在最后面加上我们的私仓地址即可：--insecure-registry 192.168.x.xxx:8881 --ipv6=falseExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock --insecure-registry 192.168.x.xxx:8881 --ipv6=false

然后重启docker：
## centos6 的命令sudo chkconfig daemon-reloadsudo service docker restart## centos7 的命令sudo systemctl daemon-reloadsudo systemctl restart docker

也可以在/etc/docker/daemon.json 中进行配置：
&#123;    &quot;insecure-reigstries&quot;:[&quot;192.168.xxx.xxx:8881&quot;]&#125;

向私仓推送镜像
如果私仓不允许匿名上传镜像，则需要先进行登陆。（一般私仓都不允许匿名上传，nexus默认匿名上传也没有勾选）

## --username后面为nexus用户名，执行命令后会提示输入密码docker login --username=admin http://192.168.xxx.xxx:8881## 登录之后，会在 $HOME/.docker/config.json 中记录下登录的用户信息，之后便不需要再进行登陆操作## 如果要取消登录，则只需执行以下命令## docker logout http://192.168.xxx.xxx:8881



将要上传的镜像重新设置Tag。docker按照镜像名称区分上传的资源库。例如：mysql:8.0.28会被上传到docker官方dockerhub；tengyer/helloworld:lasted会被上传到dockerhub的tengyer命名空间中；registry.cn-hangzhou.aliyuncs.com/命名空间/镜像名称:[镜像版本号] 会上传到阿里云指定命名空间中；ccr.ccs.tencentyun.com/命名空间/hello-world：会上传到腾讯云指定命名空间中；hub.c.163.com/命名空间/hello-world：会上传到网易数帆指定命名空间中；所以，我们如果要上传到我们的私仓，需要将Tag修改为xxx.xxx.xxx.xxx:8881/命名空间/mysql:5.0.27格式：

## 将mysql:8.0.28复制出一个私仓格式的Tag## 该操作在 docker images中会多出一个复制出来的tag，但是ImageId和原始的相同## 加个official命名空间，方便区分这个镜像是从官方镜像下载下来的，不加命名空间也可以上传docker tag [ImageId] xxx.xxx.xxx.xxx:8881/official/mysql:8.0.28



将修改好Tag的镜像进行上传：

docker push xxx.xxx.xxx.xxx:8881/official/mysql:8.0.28





08-Registry搭建docker私仓Docker RegistryDocker Registry是官方提供的工具，用于构建私有镜像仓库。
环境搭建Docker Registry也是Docker Hub提供的一个镜像，可以直接拉取运行。
步骤：

拉取镜像

docker pull registry



启动Docker Registry

docker run -d -p 5000:5000 -v /app/myregistry/:/tmp/registry --privileged=true registry



验证（查看私服中的所有镜像）

curl http://192.168.xxx.xxx:5000/v2/_catalog

Registry会返回json格式的所有镜像目录  
向Registry私仓中上传镜像配置docker允许接收http请求（配置方式和上传到nexus私仓相同）。
修改/etc/docker/daemon.json，添加insecure-registries允许http：
&#123;    &quot;registry-mirros&quot;: [&quot;https://xxxx.mirror.aliyuncs.com&quot;],    &quot;insecure-registries&quot;: [&quot;192.168.xxx.xxx:5000&quot;]&#125;

然后重启docker：（新版本的docker会立即生效）
## centos6 的命令sudo chkconfig daemon-reloadsudo service docker restart## centos7 的命令sudo systemctl daemon-reloadsudo systemctl restart docker

推送到私仓步骤：

添加一个对应私仓地址的tag

docker tag lee/myubuntu:1.0.1 192.168.xxx.xxx:5000/lee/myubuntu:1.0.1



push到私仓

docker push 192.168.xxx.xxx:5000/lee/myubuntu:1.0.1



查看私仓中镜像目录验证

curl http://192.168.xxx.xxx:5000/v2/_catalog


拉取验证：
docker pull 192.169.xxx.xxx:5000/lee/myubuntu:1.0.1





09-Docker安装MysqlDocker 安装 Mysql以安装 Mysql 5.7为例：
docker pull mysql:5.7

Mysql 单机简单版 Mysql 5.7 安装简单的启动Mysql容器：
## 需要使用 -e 配置环境变量 MYSQL_ROOT_PASSWORD（mysql root用户的密码）docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7

简单版的Mysql会存在以下问题：

中文乱码
没有容器卷映射

启动docker容器后，可以正常的连接、创建数据库，创建表，插入数据。但是插入中文则会报错。
例如：
-- 创建db01数据库create database db01;-- 切换到db01;use db01;-- 创建表create table t1(id int, name varchar(20));-- 插入英文可以正常插入insert into t1 values(1, &#x27;abc&#x27;);-- 插入中文报错insert into t1 values(2, &#x27;张三&#x27;);

这是因为docker默认的字符集的问题，可以在mysql中使用以下命令查看数据库字符集：
show variables like &#x27;character%&#x27;;

返回的字符集中，character_set_database、character_set_server等都为latin1字符集，所以会报错。
而且因为启动容器时没有配置容器卷映射，当容器意外被删时，数据无法找回。
实际应用版 Mysql 5.7安装启动 Mysql 容器，并配置容器卷映射：
docker run -d -p 3306:3306 \           --privileged=true \           -v /app/mysql/log:/var/log/mysql \           -v /app/mysql/data:/var/lib/mysql \           -v /app/mysql/conf:/etc/mysql/conf.d \           -e MYSQL_ROOT_PASSWORD=root \           --name mysql \           mysql:5.7

在/app/mysql/conf下新建 my.cnf，通过容器卷同步给mysql实例，解决中文乱码问题：
[client]default_character_set=utf8[mysqld]collation_server = utf8_general_cicharacter_set_server = utf8

重启mysql容器，使得容器重新加载配置文件：
docker restart mysql

此时便解决了中文乱码（中文插入报错）问题。
而且因为启动时将容器做了容器卷映射，将mysql的配置（映射到/app/mysql/conf）、数据（映射到/app/mysql/data）、日志（映射到/app/mysql/log）都映射到了宿主机实际目录，所以即使删除了容器，也不会产生太大影响。只需要再执行一下启动Mysql容器命令，容器卷还按相同位置进行映射，所有的数据便都可以正常恢复。
Mysql 主从复制安装安装主服务器容器实例（端口号3307）：

启动容器实例

docker run -p 3307:3306 \           --name mysql-master \           --privileged=true \           -v /app/mysql-master/log:/var/log/mysql \           -v /app/mysql-master/data:/var/lib/mysql \           -v /app/mysql-master/conf:/etc/mysql \           -e MYSQL_ROOT_PASSWORD=root \           -d mysql:5.7



进入/app/mysql-master/conf，新建my.cnf配置文件：

[mysqld]### 设置server_id, 同一个局域网中需要唯一server_id=101### 指定不需要同步的数据库名称binlog-ignore-db=mysql### 开启二进制日志功能log-bin=mall-mysql-bin### 设置二进制日志使用内存大小（事务）binlog_cache_size=1M### 设置使用的二进制日志格式（mixed,statement,row）binlog_format=mixed### 二进制日志过期清理时间。默认值为0，表示不自动清理expire_logs_days=7### 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断### 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致slave_skip_errors=1062



重启容器实例

docker restart mysql-master



进入容器实例内

docker exec -it mysql-master /bin/bash



登录mysql，创建数据同步用户

-- 首先使用 mysql -uroot -p 登录mysql-- 创建数据同步用户create user &#x27;slave&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;-- 授权grant replication slave, replication client on *.* to &#x27;slave&#x27;@&#x27;%&#x27;;flush privileges;



安装从服务器容器实例（端口号3308）：

启动容器服务：

docker run -p 3308:3306 \           --name mysql-slave \           --privileged=true \           -v /app/mysql-slave/log:/var/log/mysql \           -v /app/mysql-slave/data:/var/lib/mysql \           -v /app/mysql-slave/conf:/etc/mysql \           -e MYSQL_ROOT_PASSWORD=root \           -d mysql:5.7



进入/app/mysql-slave/conf目录，创建my.cnf配置文件：

[mysqld]### 设置server_id, 同一个局域网内需要唯一server_id=102### 指定不需要同步的数据库名称binlog-ignore-db=mysql### 开启二进制日志功能，以备slave作为其它数据库实例的Master时使用log-bin=mall-mysql-slave1-bin### 设置二进制日志使用内存大小（事务）binlog_cache_size=1M### 设置使用的二进制日志格式（mixed,statement,row）binlog_format=mixed### 二进制日志过期清理时间。默认值为0，表示不自动清理expire_logs_days=7### 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断### 如：1062错误是指一些主键重复，1032是因为主从数据库数据不一致slave_skip_errors=1062### relay_log配置中继日志relay_log=mall-mysql-relay-bin### log_slave_updates表示slave将复制事件写进自己的二进制日志log_slave_updates=1### slave设置只读（具有super权限的用户除外）read_only=1



修改完配置需要重启slave容器实例

docker restart mysql-slave



在主数据库中查看主从同步状态：

进入主数据库容器：

docker exec -it mysql-master /bin/bash



进入Mysql

mysql -uroot -p



查看主从同步状态

show master status;


主要查看返回结果的文件名File、当前位置Position
进入从数据库容器，配置主从复制：

进入从数据库容器：

docker exec -it mysql-slave /bin/bash



进入数据库

mysql -uroot -p



配置从数据库所属的主数据库：

-- 格式：-- change master to master_host=&#x27;宿主机ip&#x27;,master_user=&#x27;主数据库配置的主从复制用户名&#x27;,master_password=&#x27;主数据库配置的主从复制用户密码&#x27;,master_port=宿主机主数据库端口,master_log_file=&#x27;主数据库主从同步状态的文件名File&#x27;,master_log_pos=主数据库主从同步状态的Position,master_connect_retry=连接失败重试时间间隔（秒）;change master to master_host=&#x27;192.168.xxx.xxx&#x27;,master_user=&#x27;slave&#x27;,master_password=&#x27;123456&#x27;,master_port=3307,master_log_file=&#x27;mall-mysql-bin.000001&#x27;,master_log_pos=769,master_connect_retry=30;



查看主从同步状态：

## \G 可以将横向的结果集表格转换成纵向展示。## slave status的字段比较多，纵向展示比友好show slave status \G;


除了展示刚刚配置的主数据库信息外，主要关注 Slave_IO_Running、Slave_SQL_Running。目前两个值应该都为 No，表示还没有开始。

开启主从同步：

start slave;



再次查看主从同步状态，Slave_IO_Running、Slave_SQL_Running都变为Yes。

主从复制测试：

在主数据库上新建库、使用库、新建表、插入数据

create database db01;use db01;create table t1 (id int, name varchar(20));insert into t1 values (1, &#x27;abc&#x27;);



在从数据库上使用库、查看记录

show databases;use db01;select * from t1;





10-Docker安装RedisDocker安装Redis以 Redis 6.0.8 为例：
docker pull redis:6.0.8

单机版安装简单版 Redis简单的启动Redis容器：
docker run -p 6379:6379 -d redis:6.0.8

简单版没有配置容器卷映射，当容器被删除时数据无法恢复。
实际应用版Redis配置文件、数据文件都和容器卷进行映射。
步骤：

宿主机创建目录/app/redis 
在/app/redis下创建文件redis.conf，主要修改以下几项配置

## 开启密码验证（可选）requirepass 123## 允许redis外地连接，需要注释掉绑定的IP## bind 127.0.0.1## 关闭保护模式（可选）protected-mode no## 注释掉daemonize yes，或者配置成 daemonize no。因为该配置和 docker run中的 -d 参数冲突，会导致容器一直启动失败daemonize no## 开启redis数据持久化， （可选）appendonly yes

即最后的配置文件为：  

启动docker容器：（因为要使用自定义的配置文件，所以需要指定容器运行的命令为redis-server 容器内配置文件路径）

docker run -d -p 6379:6379 --name redis --privileged=true \           -v /app/redis/redis.conf:/etc/redis/redis.conf \           -v /app/redis/data:/data \           redis:6.0.8 \           redis-server /etc/redis/redis.conf

集群存储算法分布式存储算法分布式存储的常见算法：

哈希取余算法分区
一致性哈希算法分区
哈希槽算法分区

哈希取余算法算法描述：hash(key) % N（其中，key是要存入Redis的键名，N是Redis集群的机器台数）。用户每次读写操作，都是根据传入的键名经过哈希运算，对机器台数取余决定该键存储在哪台服务器上。
优点：简单直接有效，只需要预估好数据规划好节点，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。
缺点：原来规划好的节点，如果进行了扩容或者缩容，导致节点有变动，映射关系需要重新进行计算。在服务器个数固定不变时没问题，如果需要弹性扩容或者故障停机的情况下，原来取模公式中的 N就会发生变化，此时经过取模运算的结果就会发生很大变化，导致根据公式获取的服务器变得不可控。
一致性哈希算法算法背景：一致性哈希算法是为了解决哈希取余算法中的分布式缓存数据变动和映射问题。当服务器个数发生变化时，尽量减少影响到客户端与服务器的映射关系。
算法描述：一致性哈希算法必然有个hash函数并按照算法产生Hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个Hash区间[0, 2^32 - 1]，这是一个线性空间。但是在这个算法中，我们通过适当的逻辑控制将它首尾相连（0 = 2^32），这样让它逻辑上形成了一个环形空间。
它也是按照使用取模的方式。前面的哈希取余算法是对节点个数进行取模，而一致性哈希算法是对 2^32取模。
简单来说，一致性Hash算法将整个哈希值空间组成一个虚拟的圆环。如假设某个哈希函数H的值空间为 0到2^32 - 1（即哈希值是一个32位无符号整形），整个哈希环如下图：整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4…….直到2^32 - 1，也就是说0点左侧的第一个点代表 2^32 - 1。0 和 2^32 - 1在零点钟方向重合，我们把这个由 2^32个点组成的圆环称为Hash环。

有了哈希环之后，还需要进行节点映射，将集群中各个IP节点映射到环上的某一个位置。
将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希。这样每台机器就能确定其在哈希环上的位置。
假如4个节点NodeA、B、C、D，经过IP地址的哈希函数计算（hash(ip)），使用IP地址哈希值后在环空间的位置如下：
key落到服务器的落键规则。当我们需要存储一个key键值对时，首先计算key的hash值（hash(key)），将这个key使用相同的函数hash，计算出哈希值并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储字该节点上。
假如我们有ObjectA、B、C、D四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性hash算法，数据A会被定位到NodeA上，B被定位到NodeB上，C被定位到NodeC上，D被定位到NodeD上。

假设NodeC宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重新定位到NodeD。
一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间的数据，其他不会受到影响。
即：假设NodeC宕机，只会影响到Hash定位到NodeB到NodeC之间的数据，并且这些数据会被转移到NodeD进行存储。

假如需要扩容增加一台节点NodeX，NodeX的hash(ip)位于NodeB和NodeC之间，那受到影响的就是NodeB 到 NodeX 之间的数据。重新将B到X的数据录入到X节点上即可，不会导致Hash取余全部数据重新洗牌的后果。

但是Hash环会存在数据倾斜问题。
一致性Hash算法在服务节点太少时，容易因为节点分布不均匀而造成数据倾斜（被缓存的对象都集中到某一台或某几台服务器）。
为了解决数据倾斜问题，一致性哈希算法引入了虚拟节点机制。
对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以先确定每个物理节点关联的虚拟节点数量，然后在IP或主机名后面加上编号。
例如，可以对NodeA节点虚拟出 NodeA#1、NodeA#2、NodeA#3，对NodeB虚拟出NodeB#1、NodeB#2、NodeB#3的节点，形成六个虚拟节点。

优点：加入和删除节点时，只会影响哈希环中顺时针方向相邻节点，对其他节点无影响。
缺点：数据的分布和节点的位置有关，因为这些节点不是均匀分布在哈希环上的，所以在数据进行存储时达不到均匀部分的效果。
哈希槽分区哈希槽分区是为了解决一致性哈希算法的数据倾斜问题。
哈希槽实质上就是一个数组，数组 [0, 2^14 - 1]形成的 hash slot空间。
目的是为了解决均匀分配的问题。在数据和节点之间又加入了一层，把这层称之为槽（slot），用于管理数据和节点之间的关系。就相当于节点上放的是槽，槽里面放的是数据。

槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。
哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配。
一个集群只能有 16394个槽，编号 0 - 16383（2^14 - 1）。这些槽会分配给集群中所有的主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点，集群会记录节点和槽的对应关系。
解决了节点和槽的关系后，接下来就需要对key求哈希值，然后对16384取余，根据余数决定key落到哪个槽里。
slot = CRC16(key) % 16384

以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。
Redis集群存储策略Redis集群使用的就是哈希槽。Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置在哪个槽，集群的每个节点负责一部分hash槽。
哈希槽数量16384（2^14）的决定原因：CRC16算法产生的hash值有 16bit，该算法可以产生 2^16 &#x3D; 65536个值。但是为了心跳方便和数据传输最大化，槽的数量只能有 2^14个。

如果槽位数量为65535个，那么发送心跳信息的消息头将达到 8k，发送的心跳包过于庞大。在消息头中最占空间的是 myslots[CLUSTER_SLOTS/8]。当槽位为65536时，这块的大小是 ：

65536 ÷ 8 ÷ 1024 = 8Kb

每秒中redis节点需要发送一定数量的ping消息作为心跳，如果槽位为65536，那么这个ping消息头就会太大浪费带宽。 

redis集群的主节点数量基本不可能超过1000个。集群节点越多，心跳包的消息体内携带的数据越多。如果节点超过1000个，也会导致网络拥堵。因此redis作者不建议redis cluster节点超过1000个。对于节点数在1000以内的redis cluster集群，16384个槽位足够了，没有必要扩展到65536个。 
槽位越小，节点少的情况下压缩比越高，容易传输。Redis主节点的配置信息中它锁负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中会对bitmap进行压缩，但是如果bitmap的填充率 slots / N（N为节点数）很高的话，bitmap的压缩率就很低。如果节点数很少，而哈希槽数很多的话，bitmap的压缩率就很低。


原文：正常的心跳数据包带有节点的完整配置，使得可以用幂等方式用旧的节点替换旧节点，以便更新旧的配置。这意味着它们包含原始节点的插槽配置，该节点使用 2k 的空间和 16k 的插槽，而不是使用 8k 的空间（使用65k的插槽）。同时，因为其他设计折衷，Redis集群的主节点不太可能扩展到1000个以上

Redis集群中内置了16384个哈希槽，redis会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在Redis集群中放置一个Key-Value时，redis先对key使用 CRC16 算法算出一个结果，然后把结果对 16384 取余，这样每个key都会对应一个编号在0-16383之间的哈希槽，也就是映射到某个节点上。

@Testpublic void test() &#123;    // import io.lettuce.core.cluster.SlotHash;    System.out.println(SlotHash.getSlot(&#x27;A&#x27;));  // 计算结果6373，存入上图的Node2    System.out.println(SlotHash.getSlot(&#x27;B&#x27;));  // 计算结果10374，存入上图的Node2    System.out.println(SlotHash.getSlot(&#x27;C&#x27;));  // 计算结果14503，存入上图的Node3    System.out.println(SlotHash.getSlot(&#x27;Hello&#x27;));  // 计算结果866，存入上图的Node1&#125;

3主3从Redis集群搭建使用docker搭建3主3从的Redis集群，每台主机都对应一台从机。启动6台redis容器
## 启动第1台节点## --net host 使用宿主机的IP和端口，默认## --cluster-enabled yes 开启redis集群## --appendonly yes 开启redis持久化## --port 6381 配置redis端口号docker run -d --name redis-node-1 --net host --privileged=true -v /app/redis-cluster/share/redis-node-1:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6381## 启动第2台节点docker run -d --name redis-node-2 --net host --privileged=true -v /app/redis-cluster/share/redis-node-2:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6382## 启动第3台节点docker run -d --name redis-node-3 --net host --privileged=true -v /app/redis-cluster/share/redis-node-3:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6383## 启动第4台节点docker run -d --name redis-node-4 --net host --privileged=true -v /app/redis-cluster/share/redis-node-4:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6384## 启动第5台节点docker run -d --name redis-node-5 --net host --privileged=true -v /app/redis-cluster/share/redis-node-5:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6385## 启动第6台节点docker run -d --name redis-node-6 --net host --privileged=true -v /app/redis-cluster/share/redis-node-6:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6386

构建主从关系：

进入节点1（或其中任意一个节点）:

docker exec -it redis-node-1 /bin/bash



构建主从关系：

## 宿主机IP:端口redis-cli --cluster create 192.168.xxx.xxx:6381 192.168.xxx.xxx:6382 192.168.xxx.xxx:6383 192.168.xxx.xxx:6384 192.168.xxx.xxx:6385 192.168.xxx.xxx:6386 --cluster-replicas 1



redis尝试自动进行主从节点分配 
因为我们的docker容器IP相同，所以会出现警告，可以直接忽略该警告

[WARNING] Some slaves are in the same host as their master



redis自动分配结果完成后，需要输入 Yes 确认配置信息：

M: f451eb48bbc0a7c31c7da022ffe80cc1696e0f37 192.168.xxx.xxx:6381   slots:[0-5460] (5461 slots) masterM: 05984211b8c38222a73abeff1d4e459c0fe1efbc 192.168.xxx.xxx:6382   slots:[5461-10922] (5462 slots) masterM: 1fc935c12b1d34a7df50aed643c195eb29bb3435 192.168.xxx.xxx:6383   slots:[10923-16383] (5461 slots) masterS: f8d0de47114bf33438747acd713cce4e412ae721 192.168.xxx.xxx:6384   replicates 1fc935c12b1d34a7df50aed643c195eb29bb3435S: de0b393c17e452d856f6de2b348e9ca4e5aa4002 192.168.xxx.xxx:6385   replicates f451eb48bbc0a7c31c7da022ffe80cc1696e0f37S: 0c0767e13a09ee48541738d4163592cd9842c143 192.168.xxx.xxx:6386   replicates 05984211b8c38222a73abeff1d4e459c0fe1efbcCan I set the above configuration? (type &#x27;yes&#x27; to accept):



输入Yes确认后，redis会向其他节点发送信息加入集群，并分配哈希槽：

&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join.....&gt;&gt;&gt; Performing Cluster Check (using node 192.168.xxx.xxx:6381)M: f451eb48bbc0a7c31c7da022ffe80cc1696e0f37 192.168.xxx.xxx:6381   slots:[0-5460] (5461 slots) master   1 additional replica(s)M: 1fc935c12b1d34a7df50aed643c195eb29bb3435 192.168.xxx.xxx:6383   slots:[10923-16383] (5461 slots) master   1 additional replica(s)M: 05984211b8c38222a73abeff1d4e459c0fe1efbc 192.168.xxx.xxx:6382   slots:[5461-10922] (5462 slots) master   1 additional replica(s)S: 0c0767e13a09ee48541738d4163592cd9842c143 192.168.xxx.xxx:6386   slots: (0 slots) slave   replicates 05984211b8c38222a73abeff1d4e459c0fe1efbcS: f8d0de47114bf33438747acd713cce4e412ae721 192.168.xxx.xxx:6384   slots: (0 slots) slave   replicates 1fc935c12b1d34a7df50aed643c195eb29bb3435S: de0b393c17e452d856f6de2b348e9ca4e5aa4002 192.168.xxx.xxx:6385   slots: (0 slots) slave   replicates f451eb48bbc0a7c31c7da022ffe80cc1696e0f37[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.


查看集群状态：

进入容器节点1（或集群中其他节点）：

docker exec -it redis-node-1 /bin/bash



使用redis-cli连接到6381节点：

redis-cli -p 6381



使用redis的相关命令查看集群状态：

cluster info

其中，分配的哈希槽数量 cluster_slots_assigned为16384，集群节点数量cluster_known_nodes为6 

查看集群节点信息

cluster nodes


Redis集群读写出错当使用 redis-cli连接redis集群时，需要添加 -c参数，否则可能会出现读写出错。
示例：

进入容器节点1

docker exec -it redis-node-1 /bin/bash



使用redis-cli连接，不加-c参数时

redis-cli -p 6381



此时向redis中添加键值对，可能会成功，也可能会失败

set k1 v1

报错：k1经过计算得到的哈希槽为12706，但是当前连接的redis-server为6381（即节点1），它的哈希槽为：[0,5460]（在创建构建主从关系时redis有提示，也可以通过 cluster nodes查看），所以会因为存不进去而报错。执行 set k2 v2可以成功，因为k2计算出的哈希槽在[0-5460]区间中。 

使用-c参数的redis-cli命令连接即可

redis-cli -p 6381 -c



此时可以正常的插入所有数据

set k1 v1

会有提示信息，哈希槽为12706，重定向到6383（即节点3，哈希槽[10923, 16383]）：  
集群信息检查检查查看集群信息：

进入容器节点1

docker exec -it redis-node-1 /bin/bash



进行集群信息检查

## 输入任意一台主节点地址都可以进行集群检查redis-cli --cluster check 192.168.xxx.xxx:6381


返回的检查结果：
当前集群中各个节点存储的key的数量192.168.xxx.xxx:6381 (f451eb48...) -&gt; 0 keys | 5461 slots | 1 slaves.192.168.xxx.xxx:6383 (1fc935c1...) -&gt; 1 keys | 5461 slots | 1 slaves.192.168.xxx.xxx:6382 (05984211...) -&gt; 0 keys | 5462 slots | 1 slaves.[OK] 1 keys in 3 masters.  0.00 keys per slot on average.主从机器信息&gt;&gt;&gt; Performing Cluster Check (using node 192.168.xxx.xxx:6381)M: f451eb48bbc0a7c31c7da022ffe80cc1696e0f37 192.168.xxx.xxx:6381   slots:[0-5460] (5461 slots) master   1 additional replica(s)M: 1fc935c12b1d34a7df50aed643c195eb29bb3435 192.168.xxx.xxx:6383   slots:[10923-16383] (5461 slots) master   1 additional replica(s)M: 05984211b8c38222a73abeff1d4e459c0fe1efbc 192.168.xxx.xxx:6382   slots:[5461-10922] (5462 slots) master   1 additional replica(s)S: 0c0767e13a09ee48541738d4163592cd9842c143 192.168.xxx.xxx:6386   slots: (0 slots) slave   replicates 05984211b8c38222a73abeff1d4e459c0fe1efbcS: f8d0de47114bf33438747acd713cce4e412ae721 192.168.xxx.xxx:6384   slots: (0 slots) slave   replicates 1fc935c12b1d34a7df50aed643c195eb29bb3435S: de0b393c17e452d856f6de2b348e9ca4e5aa4002 192.168.xxx.xxx:6385   slots: (0 slots) slave   replicates f451eb48bbc0a7c31c7da022ffe80cc1696e0f37[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.

主从扩容缩容主从扩容假如因为业务量激增，需要向当前3主3从的集群中再加入1主1从两个节点。
步骤：

启动2台新的容器节点

## 启动第7台节点docker run -d --name redis-node-7 --net host --privileged=true -v /app/redis-cluster/share/redis-node-7:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6387## 启动第8台节点docker run -d --name redis-node-8 --net host --privileged=true -v /app/redis-cluster/share/redis-node-8:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6388



进入6387（节点7）容器内部

docker exec -it redis-node-7 /bin/bash



将6387作为master加入集群

## redis-cli --cluster add-node 本节点地址 要加入的集群中的其中一个节点地址redis-cli --cluster add-node 192.168.xxx.xxx:6387 192.168.xxx.xxx:6381



检查当前集群状态

redis-cli --cluster check 192.168.xxx.xxx:6381

可以发现，6371节点已经作为master加入了集群，但是该节点没有被分配槽位。 

重新分配集群的槽位

redis-cli --cluster reshard 192.168.xxx.xxx:6381

redis经过槽位检查后，会提示需要分配的槽位数量：例如，我们现在是4台master，我们想要给node7分配4096个槽位，这样每个节点都是4096个槽位。输入4096后，会让输入要接收这些哈希槽的节点ID，填入node7的节点ID即可。（就是节点信息中很长的一串十六进制串）。然后会提示，询问要从哪些节点中拨出一部分槽位凑足4096个分给Node7。一般选择 all，即将之前的3个主节点的槽位都均一些给Node7，这样可以使得每个节点的槽位数相等均衡。输入all之后，redis会列出一个计划，内容是自动从前面的3台master中拨出一部分槽位分给Node7的槽位，需要确认一下分配的计划。输入yes确认后，redis便会自动重新洗牌，给Node7分配槽位。 
重新分配完成后，可以进行集群信息检查，查看分配结果：
redis-cli --cluster check 192.168.xxx.xxx:6381

可以发现重新洗牌后的槽位分配为：
节点1：[1365-5460]（供4096个槽位），，，分配前为[0-5460]（共5461个槽位）节点2：[6827-10922]（共4096个槽位），，，分配前为[5461-10922]（共5461个槽位）节点3：[12288-16383]（共4096个槽位），，，分配前为[10923-16383]（共5462个槽位）节点7：[0-1364],[5461-6826],[10923-12287]（共4096个槽位），从每个节点中匀出来了一部分给了节点7

因为可能有些槽位中已经存储了key，完全的重新洗牌重新分配的成本过高，所以redis选择从前3个节点中匀出来一部分给节点7
为主节点6387分配从节点6388：
redis-cli --cluster add-node 192.168.xxx.xxx:6388 192.168.xxx.xxx:6381 --cluster-slave --cluster-master-id node7节点的十六进制编号字符串

redis便会向6388发送消息，使其加入集群并成为6387的从节点。
检查集群当前状态
redis-cli --cluster check 192.168.xxx.xxx:6381

主从缩容假如业务高峰期过去，需要将4主4从重新缩容到3主3从。即从集群中移除node8和node7.
首先删除从节点6388：

进入容器节点1

docker exec -it redis-node-1 /bin/bash



检查容器状态，获取6388的节点编号

redis-cli --cluster check 192.168.xxx.xxx:6381



将6388从集群中移除

redis-cli --cluster del-node 192.168.xxx.xxx:6388 6388节点编号


对node7重新分配哈希槽：

对集群重新分配哈希槽

redis-cli --cluster reshard 192.168.xxx.xxx:6381



redis经过槽位检查后，会提示需要分配的槽位数量：

How many slots do you want to move (from 1 to 16384)?

如果我们想直接把node7的4096个哈希槽全部分给某个节点，可以直接输入4096。输入4096后，会让输入要接收这些哈希槽的节点ID。假如我们想把这4096个槽都分给Node1，直接输入node1节点的编号即可。然后会提示，询问要从哪些节点中拨出一部分槽位凑足4096个分给Node1。这里我们输入node7的节点编号，回车后输入done。 
node7上面没有了哈希槽，此时便可以将node7从集群中移除。（如果node7上面有哈希槽，直接从集群中移除会报错）
redis-cli --cluster del-node 192.168.xxx.xxx:6387 node7节点编号





11-DockerfileDockerfileDockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。
构建步骤：

编写Dockerfile文件
docker build命令构建镜像
docker run依据镜像运行容器实例

构建过程Dockerfile编写：

每条保留字指令都必须为大写字母，且后面要跟随至少一个参数
指令按照从上到下顺序执行
#表示注释
每条指令都会创建一个新的镜像层并对镜像进行提交

Docker引擎执行Docker的大致流程：

docker从基础镜像运行一个容器
执行一条指令并对容器做出修改
执行类似docker commit的操作提交一个新的镜像层
docker再基于刚提交的镜像运行一个新容器
执行Dockerfile中的下一条指令，直到所有指令都执行完成

Dockerfile保留字FROM基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板。Dockerfile第一条必须是FROM
## FROM 镜像名FROM hub.c.163.com/library/tomcat

MAINTAINER镜像维护者的姓名和邮箱地址
## 非必须MAINTAINER ZhangSan zs@163.com

RUN容器构建时需要运行的命令。
有两种格式：

shell格式

## 等同于在终端操作的shell命令## 格式：RUN &lt;命令行命令&gt;RUN yum -y install vim



exec格式

## 格式：RUN [&quot;可执行文件&quot; , &quot;参数1&quot;, &quot;参数2&quot;]RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;]  ## 等价于 RUN ./test.php dev offline



RUN是在docker build时运行
EXPOSE当前容器对外暴露出的端口。
## EXPOSE 要暴露的端口## EXPOSE &lt;port&gt;[/&lt;protocol] ....EXPOSE 3306 33060

WORKDIR指定在创建容器后， 终端默认登录进来的工作目录。
ENV CATALINA_HOME /usr/local/tomcatWORKDIR $CATALINA_HOME

USER指定该镜像以什么样的用户去执行，如果不指定，默认是root。（一般不修改该配置）
## USER &lt;user&gt;[:&lt;group&gt;]USER patrick

ENV用来在构建镜像过程中设置环境变量。
这个环境变量可以在后续的任何RUN指令或其他指令中使用
## 格式 ENV 环境变量名 环境变量值## 或者 ENV 环境变量名=值ENV MY_PATH /usr/mytest## 使用环境变量WORKDIR $MY_PATH

VOLUME容器数据卷，用于数据保存和持久化工作。类似于 docker run 的-v参数。
## VOLUME 挂载点## 挂载点可以是一个路径，也可以是数组（数组中的每一项必须用双引号）VOLUME /var/lib/mysql

ADD将宿主机目录下（或远程文件）的文件拷贝进镜像，且会自动处理URL和解压tar压缩包。
COPY类似ADD，拷贝文件和目录到镜像中。
将从构建上下文目录中&lt;源路径&gt;的文件目录复制到新的一层镜像内的&lt;目标路径&gt;位置。
COPY src destCOPY [&quot;src&quot;, &quot;dest&quot;]## &lt;src源路径&gt;：源文件或者源目录## &lt;dest目标路径&gt;：容器内的指定路径，该路径不用事先建好。如果不存在会自动创建

CMD指定容器启动后要干的事情。
有两种格式：

shell格式

## CMD &lt;命令&gt;CMD echo &quot;hello world&quot;



exec格式

## CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot; ...]CMD [&quot;catalina.sh&quot;, &quot;run&quot;]



参数列表格式

## CMD [&quot;参数1&quot;, &quot;参数2&quot; ....]，与ENTRYPOINT指令配合使用



Dockerfile中如果出现多个CMD指令，只有最后一个生效。CMD会被docker run之后的参数替换。
例如，对于tomcat镜像，执行以下命令会有不同的效果：
## 因为tomcat的Dockerfile中指定了 CMD [&quot;catalina.sh&quot;, &quot;run&quot;]## 所以直接docker run 时，容器启动后会自动执行 catalina.sh rundocker run -it -p 8080:8080 tomcat## 指定容器启动后执行 /bin/bash## 此时指定的/bin/bash会覆盖掉Dockerfile中指定的 CMD [&quot;catalina.sh&quot;, &quot;run&quot;]docker run -it -p 8080:8080 tomcat /bin/bash

CMD是在docker run时运行，而 RUN是在docker build时运行。
ENTRYPOINT用来指定一个容器启动时要运行的命令。
类似于CMD命令，但是ENTRYPOINT不会被docker run后面的命令覆盖，这些命令参数会被当做参数送给ENTRYPOINT指令指定的程序。
ENTRYPOINT可以和CMD一起用，一般是可变参数才会使用CMD，这里的CMD等于是在给ENTRYPOINT传参。
当指定了ENTRYPOINT后，CMD的含义就发生了变化，不再是直接运行期命令，而是将CMD的内容作为参数传递给ENTRYPOINT指令，它们两个组合会变成 &lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;。
例如：
FROM nginxENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;]  ## 定参CMD [&quot;/etc/nginx/nginx.conf&quot;] ## 变参

对于此Dockerfile，构建成镜像 nginx:test后，如果执行；

docker run nginx test，则容器启动后，会执行 nginx -c /etc/nginx/nginx.conf
docker run nginx:test /app/nginx/new.conf，则容器启动后，会执行 nginx -c /app/nginx/new.conf

构建镜像创建名称为Dockerfile的文件，示例：
FROM ubuntuMAINTAINER lee&lt;lee@xxx.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN apt-get updateRUN apt-get install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;install ifconfig cmd into ubuntu success .....&quot;CMD /bin/bash

编写完成之后，将其构建成docker镜像。
命令：
## 注意：定义的TAG后面有个空格，空格后面有个点## docker build -t 新镜像名字:TAG .docker build -t ubuntu:1.0.1 .

虚悬镜像虚悬镜像：仓库名、标签名都是 &lt;none&gt;的镜像，称为 dangling images（虚悬镜像）。
在构建或者删除镜像时可能由于一些错误导致出现虚悬镜像。
例如：
## 构建时候没有镜像名、tagdocker build .

列出docker中的虚悬镜像：
docker image ls -f dangling=true

虚悬镜像一般是因为一些错误而出现的，没有存在价值，可以删除：
## 删除所有的虚悬镜像docker image prune





12-Docker发布微服务搭建SpringBoot项目搭建一个简单的SpringBoot项目：

创建maven工程，pom为：

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.5.6&lt;/version&gt;    &lt;/parent&gt;    &lt;groupId&gt;org.study&lt;/groupId&gt;    &lt;artifactId&gt;test-docker&lt;/artifactId&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;modules&gt;        &lt;module&gt;docker_boot&lt;/module&gt;    &lt;/modules&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;    &lt;/properties&gt;&lt;/project&gt;



新建Module，pom为：

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;test-docker&lt;/artifactId&gt;        &lt;groupId&gt;org.study&lt;/groupId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;docker_boot&lt;/artifactId&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;



编写一个配置文件

server:  port: 6001



编写主启动类

package com.study;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @author tengyer 2022/05/06 16:34 */@SpringBootApplicationpublic class DockerBootApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DockerBootApplication.class, args);    &#125;&#125;



编写一个Controller

package com.study.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import java.util.UUID;/** * @author tengyer 2022/05/06 16:35 */@RestControllerpublic class OrderController &#123;    @Value(&quot;$&#123;server.port&#125;&quot;)    private String port;    @RequestMapping(&quot;/order/docker&quot;)    public String helloDocker() &#123;        return &quot;hello world \t&quot; + port + &quot;\t&quot; + UUID.randomUUID().toString();    &#125;    @RequestMapping(value = &quot;/order/index&quot;, method = RequestMethod.GET)    public String index() &#123;        return &quot;服务端口号：&quot; + &quot;\t&quot; + port + &quot;\t&quot; + UUID.randomUUID().toString();    &#125;&#125;


在Idea中运行没有问题时，将其使用maven的package打成jar包。
发布微服务项目到Docker容器
将项目jar包上传到服务器 
编写Dockerfile

FROM openjdk:8-oracleMAINTAINER lee## 在主机 /var/lib/docker目录下创建一个临时文件，并链接到容器的 /tmpVOLUME /tmp## 将jar包添加到容器中，并命名为 springboot_docker.jarADD docker_boot-1.0-SNAPSHOT.jar /springboot_docker.jar## 运行jar包RUN bash -c &#x27;touch /springboot_docker.jar&#x27;ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/springboot_docker.jar&quot;]## SpringBoot项目配置的端口号为6001，需要将6001暴露出去EXPOSE 6001



构建镜像

docker build -t springboot_docker:1.0 .



启动容器：

docker run -d -p 6001:6001 --name springboot springboot_docker:1.0





13-Docker网络Docker 网络docker安装并启动服务后，会在宿主机中添加一个虚拟网卡。
在Docker服务启动前，使用 ifconfig 或 ip addr 查看网卡信息：

ens33或eth0：本机网卡
lo：本机回环网络网卡
可能有virbr0（CentOS安装时如果选择的有相关虚拟化服务，就会多一个以网桥连接的私网地址的virbr0网卡，作用是为连接虚拟网卡提供NAT访问外网的功能。如果要移除该服务，可以使用 yum remove libvirt-libs.x86_64）

使用 systemctl start docker启动Docker服务后，会多出一个 docker0 网卡。
作用：

容器间的互联和通信以及端口映射
容器IP变动时候可以通过服务名直接网络通信而不受到影响

Docker容器的网络隔离，是通过Linux内核特性 namespace和 cgroup 实现的。
docker网络命令查看Docker网络模式：
docker network ls

如果没有修改过docker network，则默认有3个网络模式：

bridge
host
none

添加Docker网络：
docker network add xxx

删除Docker网络：
docker network rm xxx

查看网络元数据：
docker network inspect xxx

删除所有无效的网络：
docker network prune

Docker 网络模式Docker 的网络模式：



网络模式
简介
使用方式



bridge
为每一个容器分配、设置IP等，并将容器连接到一个docker0



虚拟网桥，默认为该模式
--network bridge



host
容器将不会虚拟出自己的网卡、配置自己的IP等，而是使用宿主机的IP和端口
--network host


none
容器有独立的 Network namespace，但并没有对齐进行任何网络设置，如分配 veth pari



和 网桥连接、IP等
--network none



container
新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP、端口范围等
--network container:NAME或者容器ID


查看某个容器的网络模式：
## 通过inspect获取容器信息，最后20行即为容器的网络模式信息docker inspect 容器ID | tail -n 20

docker0Docker 服务默认会创建一个docker0网桥（其上有一个docker0内部接口），该桥接网络的名称为 docker0，它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。
Docker默认指定了docker0接口的IP地址和子网掩码，让主机和容器之间可以通过网桥互相通信。
查看bridge网络的详细信息，并通过grep获取名称：
docker network inspect bridge | grep name

可以看到其名称为docker0。
bridge模式Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥（docker0），Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一个宿主机内的容器接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。
docker run的时候，没有指定--network的话，默认使用的网桥模式就是bridge，使用的就是docker0。在宿主机ifconfig就苦役看到docker0和自己create的network。
网桥docker0创建一对对等虚拟设备接口，一个叫veth，另一个叫eth0，成对匹配：
整个宿主机的网桥模式都是docker0，类似一个交换机有一堆接口，每个接口叫 veth，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫做 veth pair）。
每个容器实例内部也有一块网卡，容器内的网卡接口叫做eth0。
docker0上面的每个veth匹配某个容器实例内部的eth0，两两配对，一一匹配。

例如：
启动tomcat容器，进入tomcat容器后，执行 ip addr，可以看到其网卡信息：
1: lo ..................容器内的网卡为 eth0@符号后面就是宿主机上对应的veth网卡的编号2827: eth0@if28 ...............................

在宿主机执行 ip addr 查看宿主机网卡信息：
每个veth都有个编号：vethXXXXXX@符号后面对应就是容器内的eth0网卡编号2728: vethXXXXXX@if27  ................

host模式直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行 NAT 转换。
容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network space。
容器将不会虚拟出自己的网卡，而是直接使用宿主机的 IP 和端口。

如果在 docker run 命令中同时使用了 --network host 和 -p端口映射，例如：
docker run -p 8082:8080 --network host tomcat

那么会出现一个警告：
WARNING: Published ports are discarded when using host network mode

因为此时已经使用了host模式，本身就是直接使用的宿主机的IP和端口，此时的-p端口映射就没有了意义，也不会生效，端口号还是会以主机端口号为主。
正确做法是：不再进行-p端口映射，或者改用bridge模式
none模式禁用网络功能。
在none模式下，并不为docker容器进行任何网络配置。进入容器内，使用 ip addr查看网卡信息，只能看到 lo（本地回环网络127.0.0.1网卡）。
container模式新建的容器和已经存在的一个容器共享网络IP配置，而不是和宿主机共享。
新创建的容器不会创建自己的网卡、IP，而是和一个指定的容器共享IP、端口范围。两个容器除了网络共享，其他的如文件系统、进程列表依然是隔离的。

示例：
docker run -it --name alpine1 alpine /bin/sh## 指定和 alpine1 容器共享网络docker run -it --netrowk container:alpine1 --name alpine2 alpine /bin/sh

此时使用 ip addr查看两台容器的网络，会发现两台容器的eth0网卡内的IP等信息完全相同。
如果关掉了alpine1容器，因为alpine2的网络使用的alpine1共享网络，所以关掉alpin1后，alpine2的eth0网卡也随之消失了。
自定义网络容器间的互联和通信以及端口映射。
容器 IP 变动时候可以通过服务名直接网络通信而不受影响。（类似Eureka，通过服务名直接互相通信，而不是写死IP地址）。

docker中还有一个 --link 进行容器网络互联，但是已经被标记为过时的，可能会在将来的版本中移除这个功能。推荐使用自定义网络替换link。

自定义桥接网络（自定义网络默认使用的是桥接网络 bridge）：

新建自定义网络

docker network create tomcat_network



查看网络列表

docker network ls



创建容器时，指定加入我们自定义的网络中

docker run -d -p 8081:8080 --network tomcat_network --name tomcat1 tomcat:8.5-jdk8-correttodocker run -d -p 8082:8080 --network tomcat_network --name tomcat2 tomcat:8.5-jdk8-corretto



此时进入tomcat1中，使用ping命令测试连接tomcat2容器名，发现可以正常连通

## 安装ifconfig命令yum install -y net-tools## 安装ip addr命令yum install -y iproute## 安装ping命令yum install -y iputils## 直接ping容器名，不需要ping IP地址ping tomcat2


link连接示例：
## 启动一台mysql容器## --name 为容器指定一个别名docker run --name mysql-matomo -p 3308:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:8.0.28## 启动另一个容器，通过--link连接到mysql容器## --link 容器名称:本容器连接对方时的别名docker run -d -p 8888:80 --link mysql-matomo:db --name matomo matomo:4.9.0## 此时，在matomo容器中，便可以通过 db 这个hostname连接到mysql-matomo容器，而无须再通过ip## 连接地址：db:3306



14-Docker-compose容器编排Docker-composeDocker-Compose 是 Docker 官方的开源项目，负责实现对Docker容器集群的快速编排。
Docker-Compose可以管理多个Docker容器组成一个应用。需要定义一个yaml格式的配置文件 docker-compose.yml，配置好多个容器之间的调用关系，然后只需要一个命令就能同时启动&#x2F;关闭这些容器。
Docker建议我们每个容器中只运行一个服务，因为Docker容器本身占用资源极少，所以最好是将每个服务单独的分割开来。但是如果我们需要同时部署多个服务，每个服务单独构建镜像构建容器就会比较麻烦。所以 Docker 官方推出了 docker-compose 多服务部署的工具。
Compose允许用户通过一个单独的 docker-compose.yml 模板文件来定义一组相关联的应用容器为一个项目（project）。可以很容易的用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。
核心概念：

服务（service）：一个个应用容器实例
工程（project）：由一组关联的应用容器组成的一个完整业务单元，在docker-compose.yml中定义

Compose使用的三个步骤：

编写 Dockerfile 定义各个应用容器，并构建出对应的镜像文件
编写 docker-compose.yml，定义一个完整的业务单元，安排好整体应用中的各个容器服务
执行 docker-compose up 命令，其创建并运行整个应用程序，完成一键部署上线

安装Docker-ComposeDocker-Compose的版本需要和Docker引擎版本对应，可以参照官网上的对应关系。
安装Compose：
## 例如从github下载 2.5.0版本的docker-compose## 下载下来的文件放到 /usr/local/bin目录下，命名为 docker-composecurl -L https://github.com/docker/compose/releases/download/v2.5.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose## 添加权限chmod +x /usr/local/bin/docker-compose## 验证docker-compose version

卸载Compose：直接删除 usr/local/bin/docker-compose文件即可
常用命令执行命令时，需要在对应的docker-compose.yml文件所在目录下执行。
查看帮助：
docker-compose -h

创建并启动docker-compose服务：（类似 docker run）
docker-compose up## 后台运行docker-compose up -d

停止并删除容器、网络、卷、镜像：（类似 docker stop +  docker rm）
docker-compose down

进入容器实例内部：
docker-compose exec &lt;yml里面的服务id&gt; /bin/bash

展示当前docker-compose编排过的运行的所有容器：
docker-compose ps

展示当前docker-compose编排过的容器进程：
docker-compose top

查看容器输出日志：
docker-compose log &lt;yml里面的服务id&gt;

检查配置：
docker-compose config## 有问题才输出docker-compose config -q

重启服务：
docker-compose restart

启动服务：（类似 docker start）
docker-compose start

停止服务：
docker-compose stop

compose编排实例示例：
## docker-compose文件版本号version: &quot;3&quot;## 配置各个容器服务services:  microService:    image: springboot_docker:1.0    container_name: ms01  ## 容器名称，如果不指定，会生成一个服务名加上前缀的容器名    ports:      - &quot;6001:6001&quot;    volumes:      - /app/microService:/data    networks:      - springboot_network    depends_on:  ## 配置该容器服务所依赖的容器服务      - redis      - mysql  redis:    image: redis:6.0.8    ports:      - &quot;6379:6379&quot;    volumes:      - /app/redis/redis.conf:/etc/redis/redis.conf      - /app/redis/data:data    networks:      - springboot_network    command: redis-server /etc/redis/redis.conf  mysql:    image: mysql:5.7    environment:      MYSQL_ROOT_PASSWORD: &#x27;123456&#x27;      MYSQL_ALLOW_EMPTY_PASSWORD: &#x27;no&#x27;      MYSQL_DATABASE: &#x27;db_springboot&#x27;      MYSQL_USER: &#x27;springboot&#x27;      MYSQL_PASSWORD: &#x27;springboot&#x27;    ports:      - &quot;3306:3306&quot;    volumes:      - /app/mysql/db:/var/lib/mysql      - /app/mysql/conf/my.cnf:/etc/my.cnf      - /app/mysql/init:/docker-entrypoint-initdb.d    networks:      - springboot_network    command: --default-authentication-plugin=mysql_native_password ## 解决外部无法访问networks:  ## 创建 springboot_network 网桥网络  springboot_network:

编写完成docker-compose.yml后，进行语法检查：
## 进行语法检查docker-compose config -q

如果语法检查没有任何问题，进行创建、启动：
docker-compose up -d



15-Portainer轻量级图形化监控Portainer：Docker轻量级可视化工具Portainer是一款轻量级的应用，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。
Portainer分为开源社区版（CE版）和商用版（BE版&#x2F;EE版）。
安装Portainer也是一个Docker镜像，可以直接使用Docker运行。
## 旧版镜像地址为portainer/portainer，从2022年1月标记为过期## 新版镜像地址为portainer/portainer-ce## --restart=always 如果Docker引擎重启了，那么这个容器实例也会在Docker引擎重启后重启，类似开机自启docker run -d -p 8000:8000 -p 9000:9000 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.13.0-alpine

启动之后，便可以在浏览器中进行访问：http://xxx.xxx.xxx.xxx:9000
首次进来时，需要创建 admin 的用户名（默认admin）、密码（必须满足校验规则，例如portainer.io123）。
选择 local管理本地docker，即可看到本地Docker的详细信息，包括其中的镜像（images）、容器（containers）、网络（networks）、容器卷（volumes）、compose编排（stacks）等等。
16-CIG重量级监控  CIG
通过docker stats 命令可以很方便的查看当前宿主机上所有容器的CPU、内存、网络流量等数据，可以满足一些小型应用。但是 docker stats 统计结果只能是当前宿主机的全部容器，数据资料是实时的，没有地方存储、没有健康指标过线预警等功能。
CAdvisor（监控收集） + InfluxDB（存储数据） + Granfana（展示图表），合称 CIG。
CAdvisorCAdvisor是一个容器资源监控工具，包括容器的内存、CPU、网络IO、磁盘IO等监控，同时提供了一个Web页面用于查看容器的实时运行状态。
CAdvisor默认存储2分钟的数据，而且只是针对单物理机。不过CAdvisor提供了很多数据集成接口，支持 InfluxDB、Redis、Kafka、Elasticsearch等集成，可以加上对应配置将监控数据发往这些数据库存储起来。
CAdvisor主要功能：

展示Host和容器两个层次的监控数据
展示历史变化数据

InfluxDBInfluxDB是用Go语言编写的一个开源分布式时序、事件和指标数据库，无需外部依赖。
CAdvisor默认只在本机保存2分钟的数据，为了持久化存储数据和统一收集展示监控数据，需要将数据存储到InfluxDB中。InfluxDB是一个时序数据库，专门用于存储时序相关数据，很适合存储 CAdvisor 的数据。而且 CAdvisor本身已经提供了InfluxDB的集成方法，在启动容器时指定配置即可。
InfluxDB主要功能：

基于时间序列，支持与时间有关的相关函数（如最大、最小、求和等）
可度量性，可以实时对大量数据进行计算
基于事件，支持任意的事件数据

GranfanaGrafana是一个开源的数据监控分析可视化平台，支持多种数据源配置（支持的数据源包括InfluxDB、MySQL、Elasticsearch、OpenTSDB、Graphite等）和丰富的插件及模板功能，支持图表权限控制和报警。
Granfana主要功能：

灵活丰富的图形化选项
可以混合多种风格
支持白天和夜间模式
多个数据源

安装部署
编写docker-compose.yml服务编排文件

version: &#x27;3.1&#x27;volumes:  grafana_data: &#123;&#125;services:  influxdb:	## tutum/influxdb 相比influxdb多了web可视化视图。但是该镜像已被标记为已过时    image: tutum/influxdb:0.9    restart: always    environment:      - PRE_CREATE_DB=cadvisor    ports:      - &quot;8083:8083&quot;         ## 数据库web可视化页面端口      - &quot;8086:8086&quot;         ## 数据库端口    volumes:      - ./data/influxdb:/data  cadvisor:    image: google/cadvisor:v0.32.0    links:      - influxdb:influxsrv    command:      - -storage_driver=influxdb      - -storage_driver_db=cadvisor      - -storage_driver_host=influxsrv:8086    restart: always    ports:      - &quot;8080:8080&quot;    volumes:      - /:/rootfs:ro      - /var/run:/var/run:rw      - /sys:/sys:ro      - /var/lib/docker/:/var/lib/docker:ro  grafana:    image: grafana/grafana:8.5.2    user: &#x27;104&#x27;    restart: always    links:      - influxdb:influxsrv    ports:      - &quot;3000:3000&quot;    volumes:      - grafana_data:/var/lib/grafana    environment:      - HTTP_USER=admin      - HTTP_PASS=admin      - INFLUXDB_HOST=influxsrv      - INFLUXDB_PORT=8086



检查语法

docker-compose config -q



创建并启动容器

docker-compose up -d


容器启动之后：

在浏览器打开InfluxDB数据库的页面： http://xxx.xxx.xxx.xxx:8083，使用命令查看当前数据库中的数据库实例：

SHOW DATABASES

查看其中是否自动创建了我们在配置文件中配置的 cadvisor 数据库实例 

在浏览器打开CAdvisor页面：http://xxx.xxx.xxx.xxx8080/，查看当前docker中的cpu、内存、网络IO等统计信息 
在浏览器打开Grafana页面：http://xxx.xxx.xxx.xxx:3000/，默认用户名密码是：`admin`/`admin`。

Grafana配置添加数据源在Configuration（小齿轮）选项卡中，选择Data Sources，添加一个InfluxDB数据源：

name：自定义一个数据源名称，例如InfluxDB
Query Language：查询语言，默认InfluxQL即可
URL：根据compose中的容器服务名连接，http://influxdb:8086
database：我们在InfluxDB中创建的数据库实例，cadvisor
User：InfluxDB的默认用户，root
Password：root

保存并测试，可以连通即可
添加工作台
在Create（加号）选项卡中，选择创建 Dash Board工作台。右上角配置中可以配置创建出来的工作台的标题、文件夹等信息。 
在创建出来的工作台中，选择Add panel中的Add a new panel添加一个新的面板。 
在右上角Time series（时序图）位置可以切换展示的图表样式（柱状图、仪表盘、表格、饼图等等）
右侧边栏为该图表配置相关信息：标题、描述
图表下方可以配置该图表展示的数据的查询语句，例如： 
FROM：cpu_usage_total（Grafana会自动获取InfluxDB数据库中的元数据，可以直接选择对应表名）
WHERE：添加一个条件，container_name=cig-cadvisor-1
ALIAS：配置一个别名，CPU使用情况汇总%%  %%





]]></content>
      <categories>
        <category>Dockert</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>Docker</tag>
        <tag>基础教程</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP8266引脚说明</title>
    <url>/2023/06/07/ESP8266%E5%BC%95%E8%84%9A%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[引脚引脚图目前，ESP8266芯片的开发板种类繁多，在可访问的GPIOs数量、尺寸、外形规格等方面各不相同。
使用最广泛的ESP8266板是ESP-01，ESP8266-12E节点MCU套件，和MINI D1。 有关这些板的比较。
ESP8266-12E、12F


ESP8266 12-E 套件
ESP8266-01&#x2F;ESP8266-01S 引脚如果使用 ESP8266-01 板，可以使用以下 GPIO 关系图作为参考。

WeMos D1Mini
各种不同版本的ESP8266对比



ESP01
ESP-01D
ESP-01F
ESP-01M
ESP-01S
ESP-07
ESP-07S
ESP-12E
ESP-12F
ESP-12S



通信协议
完整的802.11b&#x2F;g&#x2F;n WiFi Soc模块











工作频段
2400 - 2483.5MHZ











芯片方案
ESP8266
ESP8285
ESP8285
ESP8285
ESP8266
ESP8266
ESP8266
ESP8266
ESP8266
ESP8266


天线形式
板载天线
外接天线
外接天线
板载天线
板载天线
IPEX座&#x2F;陶瓷天线
IPEX天线
板载天线
板载天线
板载天线


封装形式
DIP-8
DIP-6
SMD-18
DIP-18
DIP-8
SMD-16
SMD-16
SMD-22
SMD-22
SMD-16


串口速率
4Mbps











传输距离
50m
40m
50m
40m
50m
50m
100m
80m
81m
82m


供电电压
3.0V-3.6V，典型值3.3V











SPI Flash
8Mbit
16Mbit
8Mbit&#x2F;16Mbit
8Mbit&#x2F;17Mbit
8Mbit
8Mbit
32Mbit
32Mbit
32Mbit
32Mbit


io 口
2
3
9
11
2
9
9
11
9
9


模组认证
暂无
暂无
FCC&#x2F;CE
FCC&#x2F;CE&#x2F;SRRC&#x2F;REACH&#x2F;ROHs
ROHs
暂无
FCC&#x2F;CE&#x2F;SRRC&#x2F;REACH&#x2F;ROHs
暂无
FCC&#x2F;CE&#x2F;SRRC&#x2F;IC&#x2F;KCC&#x2F;NCC&#x2F; REACH&#x2F;TELEC&#x2F;ANATEL&#x2F;RoHS
FCC&#x2F;CE&#x2F;SRRC&#x2F; RoHs&#x2F;阿里飞燕认证


Modem Sleep
20mA
20mA
20mA
20mA
20mA
20mA
20mA
15mA
20mA
20mA


Light Sleep
2mA
2mA
2mA
2mA
2mA
2mA
0.9mA
2mA
2mA
2mA


Deep Sleep
20uA
20uA
20uA
20uA
20uA
20uA
10uA
20uA
20uA
20uA



使用引脚​	关于 ESP8266，需要注意的一件重要的事情是 GPIO 编号与板载上的标识并不匹配。例如，D0 对应于 GPIO16，D1 对应于 GPIO5。
​	下表显示了板载标识和 GPIO 编号上的标签之间的对应关系，以及项目中最好使用的引脚，以及哪些引脚需要谨慎。
​	以绿色突出显示的引脚可以使用。以下划线突出显示的可以使用，但需要注意，因为它们可能有意外行为，主要在启动时。不建议将带删除线突出显示的引脚用作输入或输出。



Label
GPIO
Input
Output
Notes



D0
GPIO16
无中断
无 Pwm 或 I2c 支持
HIGH at boot used to wake up from deep sleep


D1
GPIO5
OK
OK
常用作SCL（I2C）


D2
GPIO4
OK
OK
常用作SDA（I2C）


D3
GPIO0
上拉
OK
connected to FLASH button, boot fails if pulled LOW


D4
GPIO2
上拉
OK
HIGH at boot connected to on-board LED, boot fails if pulled LOW


D5
GPIO14
OK
OK
SPI (SCLK)


D6
GPIO12
OK
OK
SPI (MISO)


D7
GPIO13
OK
OK
SPI (MOSI)


D8
GPIO15
下拉
OK
SPI (CS) Boot fails if pulled HIGH


RX
GPIO3
OK
RX
HIGH at boot


TX
GPIO1
TX
OK
HIGH at boot debug output at boot, boot fails if pulled LOW


A0
ADC0
模拟引脚
X




连接到闪存芯片的 GPIOSGPIO6 到 GPIO11 通常连接到 ESP8266 板中的闪存芯片。因此，不建议使用这些引脚。
启动期间使用的引脚如果某些引脚被拉低或高，可以阻止 ESP8266 启动。以下列表显示了引导上的以下引脚的状态：

**GPIO16：**引脚在引导时高
GPIO0：如果拉低，启动失败
GPIO2： 引脚在引导时高， 启动失败， 如果拉低
GPIO15： 启动失败，如果拉高
GPIO3： 引脚在引导时高
GPIO1： 引脚在引导时高， 启动失败， 如果拉低
GPIO10： 引脚在引导时高
GPIO9： 引脚在引导时高

引脚在启动时高当 ESP8266 启动时，某些引脚输出 3.3V 信号。如果您有继电器或其他外设连接到这些 GPIOs，这可能有问题。以下 GPIOs 在启动时输出高信号：

GPIO16
GPIO3
GPIO1
GPIO10
GPIO9

此外，除 GPIO5 和 GPIO4 外，其他 GPIOs 可以在引导时输出低压信号，如果这些信号连接到晶体管或继电器，则可能会有问题。您可以阅读本文，其中调查每个 GPIO 在启动时的状态和行为。
如果要操作继电器，GPIO4 和 GPIO5 是使用 GPIOs 最安全的方式。
模拟输入ESP8266 仅支持一个 GPIO 中的模拟读取。GPIO 称为ADC0，通常在丝网上标记为A0。
如果使用 ESP8266 裸芯片，ADC0 引脚的最大输入电压为 0 到 1V。如果您使用的是 ESP8266 12-E NodeMCU 套件等开发板，则电压输入范围为 0 到 3.3V，因为这些板包含内部分压器。
板载 LED大多数 ESP8266 开发板都具有内置 LED。此 LED 通常连接到 GPIO2(D4)。发送高信号以将其关闭，发送低信号以将其打开。
RST 引脚当 RST 引脚拉低时，ESP8266 将复位。这与按板载重置按钮相同。
GPIO0当 GPIO0 被拉低时，它会将 ESP8266 设置到引导加载器模式。这与按下板载闪存&#x2F;引导按钮相同。
GPIO16GPIO16 可用于从深度睡眠中唤醒 ESP8266。要从深度睡眠中唤醒 ESP8266，GPIO16 应连接到 RST 引脚。
I2CESP8266没有硬件 I2C 引脚，但它可以在软件中实现。因此，您可以将任何 GPIOS 用作 I2C。通常，以下 GPIOS 用作 I2C 引脚：

GPIO5： SCL
GPIO4： SDA

SpiESP8266 中用作 SPI 的引脚包括：

GPIO12： MISO
GPIO13： MOSI
GPIO14： SCLK
GPIO15： CS

PWM 引脚ESP8266 允许所有 I&#x2F;O 引脚的软件 PWM。ESP8266 上的 PWM 信号具有 10 位分辨率。
中断引脚ESP8266 支持任何 GPIO 中的中断，GPIO16 除外。
]]></content>
      <categories>
        <category>ESP8266</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>ESP8266</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP8266相关案例笔记</title>
    <url>/2023/06/07/ESP8266%E7%9B%B8%E5%85%B3%E6%A1%88%E4%BE%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[ESP8266 相关案例笔记ESP8266的PWM(模拟输出)ESP8266 GPIOs 可以设置为输出 0V 或 3.3V，但它们不能输出其他任何电压。但是，可以使用脉冲宽度调制 （PWM） 输出”假”中电平电压，通过这个”假”中电平电压，可以产生不同级别的LED亮度。
如果 LED 的电压在”高”和”低”之间快速交替，则眼睛无法跟上 LED 开关的速度;你只会看到一些亮度的渐变。
这基本上就是PWM的工作原理——通过产生在高频率和低之间变化的输出。
50% 的占空比可产生 50% 的 LED 亮度，占空比为 0 表示 LED 完全关闭，占空比为 100 表示 LED 完全打开。改变占空比是产生不同亮度级别的方式。
产生PWM信号analogWrite(pin, value);

pin：输出的针脚(引脚 0 到 16都可以)
value： 应在 0 到PWMRANGE，默认情况下为 1023。当值为 0 时，该引脚上禁用 PWM。值 1023 对应于 100% 占空比

您可以通过调用以下功能更改PWMRANGE：
analogWriteRange(new_range);



默认情况下，ESP8266 PWM 频率为 1kHz。可以使用analogWriteFreq()函数来修改：
analogWriteFreq(new_frequency);



样例const int ledPin = 2; //设置LED的管脚为GPIO2void setup() &#123;  &#125;void loop() &#123;  //通过一个循环，改变指定引脚的PWM占空比，实现呼吸灯效果。    // 增加LED亮度  for(int dutyCycle = 0; dutyCycle &lt; 1023; dutyCycle++)&#123;       // 通过PWM改变LED亮度    analogWrite(ledPin, dutyCycle);    delay(5);  &#125;  // 降低LED亮度  for(int dutyCycle = 1023; dutyCycle &gt; 0; dutyCycle--)&#123;    // 通过PWM改变LED亮度    analogWrite(ledPin, dutyCycle);    delay(5);  &#125;&#125;





ESP8266 IPV6 DDNS所需库文件ddns24400.cpp/**   名字：ddns24400.cpp   功能：esp8266获取ipv6地址，可以提交到每步科技,dnspod,阿里云   作者：QQ:1336621774   时间：2021.06.19*/#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;PolledTimeout.h&gt;#include &lt;Arduino.h&gt;#include &quot;Arduino.h&quot;#include &lt;lwip/dns.h&gt;#include &lt;AddrList.h&gt;#include &lt;String.h&gt;#include &quot;ddns24400.h&quot;#include &lt;ArduinoJson.h&gt;#include &lt;WiFiClient.h&gt;#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt;#include &lt;WiFiClientSecureBearSSL.h&gt;WiFiClient afraidclient;HTTPClient afraidhttp;esp8266::polledTimeout::periodicMs showStatusOnSerialNow3(10000);esp8266::polledTimeout::periodicMs showStatusOnSerialNow4(10000);int IIPV6 = 0;String inIPV6 = &quot;0&quot;;String insIPV6 = &quot;0&quot;;int zipv6 = 0;DynamicJsonBuffer jsonBuffer;bool jiexi = false;void newIPV6() &#123; //获取当前网卡的IPV6地址数量  delay(5000);//延迟5秒以便于加载网卡IPV6信息  int I = 0;  for (auto a : addrList) &#123;    if (a.isV6() == 1 &amp;&amp; a.isLocal() == 0) &#123; //条件达成下，a.toString().c_str()获取的是公网ipv6      I++;    &#125;  &#125;  IIPV6 = I;&#125;String getIPV6() &#123;  int i = 0;  String aipv6;  String bipv6;  for (auto a : addrList) &#123;    if (a.isV6() == 1 &amp;&amp; a.isLocal() == 0) &#123; //条件达成下，a.toString().c_str()获取的是公网ipv6      if (i == 0) &#123;        aipv6 = a.toString().c_str();      &#125;      else      &#123;        bipv6 = a.toString().c_str();      &#125;      i++;    &#125;  &#125;  if (i != IIPV6) &#123;    return bipv6;  &#125; else &#123;    return aipv6;  &#125;&#125;String getcentersW(String str, String start, String finish) &#123;  int locStart = str.indexOf(start);  if (locStart == -1) return &quot;&quot;;  locStart += start.length();  int locFinish = str.indexOf(finish, locStart);  if (locFinish == -1) return &quot;&quot;;  return str.substring(locStart, locFinish);&#125;void freeafraid(String token) &#123;  if (showStatusOnSerialNow4) &#123;    String getipv6add = getIPV6();    getipv6add.trim();    if (getipv6add == &quot;&quot;) &#123;      Serial.println(&quot;未获取到IPv6，10秒后重新获取&quot;);      zipv6++;      if (zipv6 &gt; 6)      &#123;        ESP.reset();      &#125;      return;    &#125;    if (insIPV6 != getipv6add) &#123;      jiexi = false;      Serial.print(&quot;afraid开始解析\n&quot;);      String url = &quot;http://sync.afraid.org/u/&quot; + token + &quot;/update?myip=&quot; + getipv6add;      if (afraidhttp.begin(afraidclient, url)) &#123;        int httpCode = afraidhttp.GET();        if (httpCode &gt; 0) &#123;          if (httpCode == HTTP_CODE_OK) &#123;            if (afraidhttp.getString().startsWith(&quot;Updated &quot;)) &#123;              insIPV6 = getipv6add;              Serial.println(&quot;IPv6解析成功&quot;);              jiexi = true;            &#125; else if (afraidhttp.getString().startsWith(&quot;No IP&quot;)) &#123;              insIPV6 = getipv6add;              Serial.println(&quot;IPv6地址未变动，无需解析&quot;);              jiexi = true;            &#125; else if (afraidhttp.getString().startsWith(&quot;Error &quot;)) &#123;              Serial.println(&quot;Token错误，无法解析&quot;);            &#125; else &#123;              Serial.println(afraidhttp.getString());            &#125;          &#125; else &#123;            Serial.println(&quot;无法连接解析服务器，将在10秒后重试。&quot;);          &#125;        &#125; else &#123;          Serial.printf(&quot;[HTTP] GET... failed, error: %s\n&quot;, afraidhttp.errorToString(httpCode).c_str());        &#125;        afraidhttp.end();        afraidclient.stop();      &#125; else &#123;        Serial.println(&quot;无法连接解析服务器，将在10秒后重试。&quot;);      &#125;      afraidhttp.end();      afraidclient.stop();    &#125;  &#125;&#125;///////////////////////cloudflarevoid cf(String id, String key, String email, String domain, bool boo) &#123;  if (showStatusOnSerialNow3) &#123;    String getipv6add = getIPV6();    getipv6add.trim();    if (getipv6add == &quot;&quot;) &#123;      Serial.println(&quot;未获取到IPv6，10秒后重新获取&quot;);      zipv6++;      if (zipv6 &gt; 6)      &#123;        ESP.reset();      &#125;      return;    &#125;    std::unique_ptr&lt;BearSSL::WiFiClientSecure&gt;client(new BearSSL::WiFiClientSecure);    HTTPClient https;    client-&gt;setInsecure();//setFingerprint(fingerprint)    String DATAS = &quot;&quot;;    String YCAAAA = &quot;&quot;;    String BDAAAA = &quot;&quot;;    String CXWZDATA = &quot;&quot;;    if (insIPV6 != getipv6add) &#123;      jiexi = false;      if (https.begin(*client, &quot;https://api.cloudflare.com/client/v4/zones/&quot; + id + &quot;/dns_records?type=AAAA&amp;name=&quot; + domain + &quot;&amp;page=1&amp;per_page=100&amp;order=type&amp;direction=desc&amp;match=all&quot;)) &#123; // HTTPS        https.addHeader(&quot;X-Auth-Email&quot;, email);        https.addHeader(&quot;X-Auth-Key&quot;, key);        https.addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);        https.addHeader(&quot;Connection&quot;, &quot;close \r\n\r\n&quot;);        Serial.println(&quot;开始查询域名记录&quot;);        int httpCode = https.GET();        if (httpCode &gt; 0) &#123;          if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) &#123;            JsonObject&amp; root = jsonBuffer.parseObject(https.getString());            String re_id = root[&quot;result&quot;][0][&quot;id&quot;];            String AAAA = root[&quot;result&quot;][0][&quot;content&quot;];            re_id.trim();            if (re_id == &quot;&quot;) &#123;              return;            &#125;            YCAAAA = AAAA;            BDAAAA = getipv6add;            insIPV6 = getipv6add;            if (AAAA != getipv6add) &#123;              DATAS = re_id;            &#125;            else            &#123;              DATAS = &quot;&quot;;              Serial.println(&quot;IPv6地址未变动，无需解析&quot;);              jiexi = true;            &#125;          &#125;        &#125; else &#123;          Serial.println(&quot;查询出错，错误代码：&quot; + String(httpCode) + &quot;：&quot; + CXWZDATA);        &#125;        https.end();      &#125; else &#123;        Serial.printf(&quot;解析提交完成GET&quot;);      &#125;    &#125;//判断ipv6    else &#123;      DATAS = &quot;&quot;;      return;    &#125;    if (DATAS == &quot;&quot;) &#123;      return;    &#125;    YCAAAA.trim();    if (YCAAAA == &quot;&quot;) &#123;      return;    &#125;    Serial.println(&quot;域名IPv6：&quot; + YCAAAA);    Serial.println(&quot;本机IPv6：&quot; + BDAAAA);    delay(1000);    if (https.begin(*client, &quot;https://api.cloudflare.com/client/v4/zones/&quot; + id + &quot;/dns_records/&quot; + DATAS)) &#123; // HTTPS      https.addHeader(&quot;X-Auth-Email&quot;, email);      https.addHeader(&quot;X-Auth-Key&quot;, key);      https.addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);      https.addHeader(&quot;Connection&quot;, &quot;close \r\n\r\n&quot;);      Serial.println(&quot;开始提交AAAA解析&quot;);      int httpCode;      if (boo) &#123;        httpCode = https.PUT(&quot;&#123;\&quot;type\&quot;:\&quot;AAAA\&quot;,\&quot;name\&quot;:\&quot;&quot; + domain + &quot;\&quot;,\&quot;content\&quot;:\&quot;&quot; + BDAAAA + &quot;\&quot;,\&quot;ttl\&quot;:120,\&quot;proxied\&quot;:true&#125;&quot;);//true代理false不代理      &#125; else &#123;        httpCode = https.PUT(&quot;&#123;\&quot;type\&quot;:\&quot;AAAA\&quot;,\&quot;name\&quot;:\&quot;&quot; + domain + &quot;\&quot;,\&quot;content\&quot;:\&quot;&quot; + BDAAAA + &quot;\&quot;,\&quot;ttl\&quot;:120,\&quot;proxied\&quot;:false&#125;&quot;);//true代理false不代理      &#125;      CXWZDATA = &quot;&quot;;      if (httpCode &gt; 0) &#123;        if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) &#123;          JsonObject&amp; root = jsonBuffer.parseObject(https.getString());          String sensor = root[&quot;success&quot;];          if (sensor == &quot;true&quot;) &#123;            Serial.println(&quot;域名AAAA解析成功！&quot;);            jiexi = true;          &#125; else          &#123;            Serial.println(&quot;域名AAAA解析失败！&quot;);          &#125;        &#125;      &#125; else &#123;        Serial.println(&quot;解析出错，错误代码：&quot; + String(httpCode) + &quot;：&quot; + CXWZDATA);      &#125;      https.end();    &#125; else &#123;      //Serial.printf(&quot;解析提交完成POST&quot;);    &#125;  &#125;&#125;///////////////////////cloudflarevoid ddns24400::init()&#123;  newIPV6();&#125;String ddns24400::get()&#123;  return getIPV6();&#125;void ddns24400::afraid(std::string token)&#123;  freeafraid(token.c_str());&#125;bool ddns24400::isjiexi()&#123;  return jiexi;&#125;String ddns24400::getcenter(std::string str, std::string start, std::string finish) &#123;  return getcentersW(str.c_str(), start.c_str(), finish.c_str());&#125;void ddns24400::cloudflare(std::string id , std::string key , std::string email , std::string domain, bool boo)&#123;  cf(id.c_str(), key.c_str(), email.c_str(), domain.c_str(), boo);&#125;



ddns24400.h#include &lt;string&gt;#include &lt;String.h&gt;#ifndef ddns24400_h#define ddns24400_h#include &quot;Arduino.h&quot;class ddns24400&#123;  public:    void init();    String get();    bool isjiexi();    String getcenter(std::string str, std::string start, std::string finish);    void afraid(std::string token);    void cloudflare(std::string id , std::string key , std::string email , std::string domain, bool boo);  private:    int _pin;&#125;;#endif



使用方法
导入库

#include &quot;ddns24400.h&quot;
      2. 实例化出ddns24400库的对象   1. ```c      ddns24400 ddns;




在setup函数里面初始化ddns的对象

ddns.init();//初始化IPV6协议栈
Serial.println(ddns.get());//打印输出当前设备IPV6地址
      4. 在循环中不停调用ddns中的更新方法   1. ```c++      cloudflare(std::string id , std::string key , std::string email , std::string domain, bool boo);


参数说明：

id：cf中域名对应的区域ID
key：cf的api密钥
email：cf的邮箱地址
domain：参数为AAAA记录的域名
boo：false是不启用CDN，true是启用CDN





样例#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClient.h&gt;#include &quot;ddns24400.h&quot;const char* ssid = &quot;lnunicom_708&quot;;const char* password = &quot;707708709&quot;;ddns24400 ddns;WiFiServer server(80);void setup() &#123;  Serial.begin(115200);  delay(10);  //初始化ddns24400对象  ddns.init();  // 连接WiFi  Serial.println();  Serial.print(&quot;连接到WiFi网络：&quot;);  Serial.println(ssid);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.println(&quot;WiFi连接成功&quot;);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());  Serial.print(&quot;IPv6 address: &quot;);  Serial.println(ddns.get());      // 启动Web服务器  server.on(&quot;/&quot;, handleRoot);  server.begin();  Serial.println(&quot;HTTP server started&quot;);&#125;void loop() &#123;  server.handleClient();  ddns.cloudflare(&quot;37b6f49c472df17cafcd2cb72fc5179e&quot;,&quot;3d5d5b67195258bb65cfbcd7ec15048d13142&quot;,&quot;hurrkn@163.com&quot;,&quot;esp8266.198425.xyz&quot;,true);  //前两个参数为域名对应的区域ID和API密钥  //第三个参数为cf的邮箱地址  //第四个参数为AAAA记录的域名  //第五个参数false是不启用CDN，true是启用CDN。&#125;void handleRoot() &#123;  String ipv6 = ddns.get();  String html = &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;ESP8266 IPv6地址&lt;/h1&gt;&lt;p&gt;&quot;;  html += &quot;当前的IPv6地址：&quot; + ipv6 + &quot;&lt;/p&gt;&lt;p&gt;hello world, hurr&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;;  server.send(200, &quot;text/html&quot;, html);&#125;



ddns24400库的一些方法void init();作用初始化对象中的内容
String get();作用获取当前设备的ipv6公网地址。
bool isjiexi();作用判断是否解析成功。
String getcenter(std::string str, std::string start, std::string finish);void afraid(std::string token);void cloudflare(std::string id , std::string key , std::string email , std::string domain, bool boo);作用执行ddns
样例连接WiFi注意 依赖于 ESP8266WiFi.h 库。
#include &lt;ESP8266WiFi.h&gt;//导入库void setup() &#123;  // put your setup code here, to run once:  InitSystem();//初始化设置  ConnectToWiFi();//连接WiFi  &#125;void loop() &#123;  // put your main code here, to run repeatedly:  &#125;//连接WiFivoid ConnectToWiFi()&#123;  char ssid[] = &quot;01_0&quot;;//WiFi的SSID  char password[] = &quot;zero0000&quot;;//wifi的密码  WiFi.begin(ssid, password);//连接WiFi  //输出提示信息：只要没连上就通过串口发送.  while(WiFi.status() != WL_CONNECTED)  &#123;    delay(500);//等待500ms    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);//当连接成功后 串口输出一个换行，然后显示其他信息  Serial.println(&quot;Wifi connected&quot;);//输出wifi连接成功的提示信息  Serial.println(WiFi.localIP());//输出连接后分配到的ip地址。&#125;//初始化函数void InitSystem()&#123;  Serial.begin(115200);//设置串口的波特率  Serial.println(&quot;&quot;);//换行一下  Serial.println(&quot;&quot;);//换行一下  Serial.println(&quot;&quot;);//换行一下&#125;





使用引脚说明：
本样例基于ESP-01S模块。
已知：

板载LED的连接在GPIO2(D4)引脚上。
GPIO0(D3)引脚在启动后可以被作为输入使用。
如果此引脚在启动阶段被拉低，则表示进入烧录模式？



使用函数：

pinMode()：用于设置引脚是输入还是输出使用
digitalRead()：用于在设置对应引脚为输入模式的前提下读取指定引脚的电平。
参数可以是像D4一样的Label标记，也可以是表示GPIO的整数。
样例：digitalRead(0);    ： 读取GPIO0引脚的电平，返回一个整形数。




digitalWrite()：用于在设置对应引脚为输出模式的前提下设置指定引脚的电平。
一共两个参数：
第一个参数用于设置要操作的GPIO引脚号
第二个参数是设置电平
可以是0 或 1，也可以是LOW 或 HIGH





#include &lt;ESP8266WiFi.h&gt;//导入库void setup() &#123;  pinMode(2, OUTPUT);//设置GPIO 2 脚为输出模式  pinMode(0, INPUT);//设置GPIO 0 为输入模式  &#125;void loop() &#123;  // put your main code here, to run repeatedly:  //读取引脚的电平，返回值是整形  //也可以是HIGH 或 LOW。可能是内部有宏定义之类的东西？  if(digitalRead(0) == LOW)           //如果读取到指定的引脚为低电平，视为按钮被按下  &#123;            digitalWrite(2, 0);           //引脚置低，点亮板载LED  &#125;  else  &#123;    //同理设置参数的时候可以是0或1，也可以是HIGH 或 LOW    digitalWrite(2, HIGH);           //否则就熄灭LED  &#125;&#125;





访问Web说明：
访问百度的搜索引起
检查周围开启WiFi的设备的MAC地址/**********************************************************************程序名称/Program name     : ESP8266WiFiGeneric_AP_3程序目的/Purpose          : 用于演示ESP8266WiFiGeneric库中onSoftAPModeProbeRequestReceived 函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; #define ssid   &quot;TaichiMaker_WIFI&quot;  // 这里定义将要建立的WiFi名称。此处以&quot;TaichiMaker_WIFI&quot;为示例                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中#define password  &quot;12345678&quot;        // 这里定义将要建立的WiFi密码。此处以12345678为示例                                    // 您可以将自己想要使用的WiFi密码放入引号内                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息 WiFiEventHandler probeRequestReceivedHandler;//实例化WIFI事件对象 void onProbeRequestReceived(const WiFiEventSoftAPModeProbeRequestReceived&amp; evt)&#123;//设备在接入点模式下收到无线终端的探针请求时的回调函数  Serial.print(&quot;请求终端的mac地址: &quot;);  Serial.print(macToString(evt.mac));//调用macToString函数将mac转换成字符串  Serial.print(&quot;     请求终端的信号强度: &quot;);  Serial.println(evt.rssi);//调用macToString函数将mac转换成字符串&#125; void setup() &#123;  Serial.begin(115200);  WiFi.softAP(ssid, password);  // 此语句是重点。WiFi.softAP用于启动NodeMCU的AP接入点模式。                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。                                // 这两个参数具体内容在setup函数之前的位置进行定义。    Serial.println(&quot;&quot;);   Serial.print(&quot;Access Point: &quot;);    // 通过串口监视器输出信息  Serial.println(ssid);              // 告知用户NodeMCU所建立的WiFi名  Serial.print(&quot;Password: &quot;);          Serial.println(password);          // 告知用户NodeMCU所建立的WiFi密码  Serial.print(&quot;IP address: &quot;);      // 以及NodeMCU的IP地址  Serial.println(WiFi.softAPIP());   // 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址   // onSoftAPModeProbeRequestReceived函数的参数onProbeRequestReceived为事件处理回调函数。  // 也就是说，每当设备在接入点模式下收到无线终端的探针请求时，设备都会自动调用onStationConnected函数  probeRequestReceivedHandler = WiFi.onSoftAPModeProbeRequestReceived(onProbeRequestReceived);&#125; void loop() &#123;&#125;    String macToString(const unsigned char* mac) &#123;//字符串转换函数  char buf[20];  snprintf(buf, sizeof(buf), &quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;,mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);  return String(buf);&#125;



获取连入设备的MAC地址/**********************************************************************程序名称/Program name     : ESP8266WiFiGeneric_AP_1程序目的/Purpose          : 用于演示ESP8266WiFiGeneric库中onSoftAPModeStationConnected函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; #define ssid   &quot;TaichiMaker_WIFI&quot;  // 这里定义将要建立的WiFi名称。此处以&quot;TaichiMaker_WIFI&quot;为示例                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中#define password  &quot;12345678&quot;        // 这里定义将要建立的WiFi密码。此处以12345678为示例                                    // 您可以将自己想要使用的WiFi密码放入引号内                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息 WiFiEventHandler stationConnectedHandler;  //实例化WIFI事件对象 void setup() &#123;   Serial.begin(115200);         //打开串口  WiFi.softAP(ssid, password);  // 此语句是重点。WiFi.softAP用于启动NodeMCU的AP接入点模式。                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。                                // 这两个参数具体内容在setup函数之前的位置进行定义。    Serial.println(&quot;&quot;);   Serial.print(&quot;Access Point: &quot;);    // 通过串口监视器输出信息  Serial.println(ssid);              // 告知用户NodeMCU所建立的WiFi名  Serial.print(&quot;Password: &quot;);          Serial.println(password);          // 告知用户NodeMCU所建立的WiFi密码  Serial.print(&quot;IP address: &quot;);      // 以及NodeMCU的IP地址  Serial.println(WiFi.softAPIP());   // 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址   // onSoftAPModeStationConnected函数的参数onStationConnected为事件处理回调函数。  // 也就是说，每当有新的无线终端连接到ESP8266设备建立的WiFi后，设备都会自动调用onStationConnected函数  stationConnectedHandler = WiFi.onSoftAPModeStationConnected(onStationConnected); &#125; void loop()&#123;&#125; void onStationConnected(const WiFiEventSoftAPModeStationConnected&amp; evt) &#123;//接入点模式下有无线终端设备连接进来时的回调函数  Serial.print(&quot;无线终端设备的mac地址: &quot;);  Serial.println(macToString(evt.mac));//调用macToString函数将mac转换成字符串  Serial.print(&quot;无线终端设备的序号: &quot;);  Serial.println(evt.aid);  &#125; String macToString(const unsigned char* mac) &#123;  //字符串转换函数  char buf[20];  snprintf(buf, sizeof(buf), &quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;,mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);  return String(buf);&#125;





获取连接后又断开的设备的MAC地址/**********************************************************************程序名称/Program name     : ESP8266WiFiGeneric_AP_2程序目的/Purpose          : 用于演示ESP8266WiFiGeneric库中onSoftAPModeStationDisconnected函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; #define ssid   &quot;TaichiMaker_WIFI&quot;   // 这里定义将要建立的WiFi名称。此处以&quot;TaichiMaker_WIFI&quot;为示例                                    // 您可以将自己想要建立的WiFi名称填写入此处的双引号中#define password  &quot;12345678&quot;        // 这里定义将要建立的WiFi密码。此处以12345678为示例                                    // 您可以将自己想要使用的WiFi密码放入引号内                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息 WiFiEventHandler stationDisconnectedHandler;  //实例化WIFI事件对象 void setup() &#123;   Serial.begin(115200);  WiFi.softAP(ssid, password);  // 此语句是重点。WiFi.softAP用于启动NodeMCU的AP接入点模式。                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。                                // 这两个参数具体内容在setup函数之前的位置进行定义。    Serial.println(&quot;&quot;);   Serial.print(&quot;Access Point: &quot;);    // 通过串口监视器输出信息  Serial.println(ssid);              // 告知用户NodeMCU所建立的WiFi名  Serial.print(&quot;Password: &quot;);          Serial.println(password);          // 告知用户NodeMCU所建立的WiFi密码  Serial.print(&quot;IP address: &quot;);      // 以及NodeMCU的IP地址  Serial.println(WiFi.softAPIP());   // 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址   // onSoftAPModeStationDisconnected函数的参数onStationDisconnected为事件处理回调函数。  // 也就是说，每当有无线终端从ESP8266设备建立的WiFi连接断开后，设备都会自动调用onStationDisconnected函数  stationDisconnectedHandler = WiFi.onSoftAPModeStationDisconnected(onStationDisconnected);&#125; void loop()&#123;&#125; void onStationDisconnected(const WiFiEventSoftAPModeStationDisconnected&amp; evt) &#123;  //接入点模式下有无线终端设备断开连接时的回调函数  Serial.print(&quot;断开连接的无线终端是: &quot;);  Serial.println(macToString(evt.mac));//调用macToString函数将mac转换成字符串&#125; String macToString(const unsigned char* mac) &#123;//字符串转换函数  char buf[20];  snprintf(buf, sizeof(buf), &quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;,mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);  return String(buf);&#125;



读取系统供电电压//关键代码！！！//设置ADC模式为读取系统电压ADC_MODE(ADC_VCC);void setup() &#123;  // put your setup code here, to run once:  Serial.begin(115200);//初始化串口&#125;void loop() &#123;  // put your main code here, to run repeatedly:  Serial.print(&quot;当前电压为：&quot;);//打印电压信息到串口    Serial.println(ESP.getVcc());  delay(1000);&#125;



解决上电启动时输出乱码上电输出乱码是正常的，因为外部晶振选择是26M，请选择74880的波特率，按下复位键或把RST引脚拉低再拉高，可以看到启动信息。
使用esp8266 驱动ws2812的灯珠需要 Adafruit_NeoPixel 库。
#include &lt;Adafruit_NeoPixel.h&gt;#define PIN 5  // 定义连接ws2812灯带的引脚#define NUMPIXELS 16  // 定义灯带上的LED数量Adafruit_NeoPixel pixels = Adafruit_NeoPixel(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);void setup() &#123;  pixels.begin();  // 初始化ws2812灯带&#125;void loop() &#123;  for(int i=0; i&lt;NUMPIXELS; i++) &#123;    pixels.setPixelColor(i, pixels.Color(0,255,0));  // 设置每个LED的颜色    pixels.show();  // 更新灯带上的LED颜色    delay(50);  &#125;&#125;





pwm驱动设置pwm频率以及占空比void setup() &#123;      analogWriteFreq(90000);  //设置频率为90khz  analogWriteRange(1024);  //设置占空比范围  analogWrite(2, 500);     //在io2引脚上，实现占空比为500/1024的pwm波形。&#125;



使用pwm方式控制设备的工作。当按键按下时，指定的引脚会以0 20 40 60 80 100的占空比工作。
#include &lt;ESP8266WiFi.h&gt;#define BUTTON_PIN 0  // 按键连接的引脚#define PWM_PIN 5     // PWM输出的引脚int dutyCycle[] = &#123;0, 20, 40, 60, 80, 100&#125;;  // PWM的占空比int idx = 0;  void setup() &#123;  pinMode(BUTTON_PIN, INPUT_PULLUP);  // 设置按键引脚为输入  pinMode(PWM_PIN, OUTPUT);           // 设置PWM引脚为输出&#125;void loop() &#123;  if (digitalRead(BUTTON_PIN) == LOW) &#123;  //当按键按下    analogWrite(PWM_PIN, dutyCycle[idx]);  //设置指定的引脚的占空比    idx = (idx + 1) % 6; //循环dutyCycle数组    delay(500); // 延迟500ms  &#125;    &#125;  &#125;&#125;







ESP8266接收红外信号前置：具有vs1838b红外接收管，并将接收管的数据极连接到esp8266
样例程序/**  作者: Raikay (raikay.com)  时间: 2021/01/17  说明: NodeMcu使用红外接收头接收红外信号  NodeMcu -   VS1838B  3v3     -    VCC  GND     -    GND  D5      -    OUT**/#include &lt;Arduino.h&gt;#include &lt;IRrecv.h&gt;#include &lt;IRremoteESP8266.h&gt;#include &lt;IRac.h&gt;//#include &lt;IRtext.h&gt;#include &lt;IRutils.h&gt;// 定义接收信号的引脚GPIO14，即NodeMcu的D5const uint16_t kRecvPin = 5;//实例化IRrecv类的对象。// (接收引脚，接收信号大小，超时时间)IRrecv irrecv(kRecvPin, 1024, 50, true);// 存储结果decode_results results;void setup() &#123;  Serial.begin(115200);#if DECODE_HASH  // 过滤未知信号值  irrecv.setUnknownThreshold(12);#endif  irrecv.setTolerance(kTolerance);  // 启动接收器  irrecv.enableIRIn();&#125;void loop() &#123;  // 是否收到消息  if (irrecv.decode(&amp;results)) &#123;        // 接收到的编码    Serial.print(&quot;输出编码：&quot;);    serialPrintUint64(results.value, HEX);    Serial.println();        // 协议和编码    Serial.println(&quot;输出协议和编码：&quot;);    Serial.println(resultToHumanReadableBasic(&amp;results));    yield();    // 说明    String description = IRAcUtils::resultAcToString(&amp;results);    Serial.println(&quot;输出说明：&quot;);    if (description.length())    &#123;      Serial.println(&quot;Mesg Desc.: &quot; + description);    &#125; else    &#123;      Serial.println(&quot;Mesg Desc.: 无&quot;);    &#125;    // 原数据    Serial.println(&quot;输出原数据：&quot;);    Serial.println(resultToSourceCode(&amp;results));    Serial.println(&quot;------------------------分割线------------------------&quot;);    yield();  &#125;&#125;



程序输出样式输出编码：FF9A65输出协议和编码：Protocol  : NECCode      : 0xFF9A65 (32 Bits)输出说明：Mesg Desc.: 无输出原数据：uint16_t rawData[71] = &#123;8996, 4484,  578, 556,  554, 556,  576, 552,  578, 558,  552, 576,  556, 554,  576, 576,  532, 576,  556, 1686,  554, 1688,  578, 1666,  576, 1686,  576, 1664,  578, 1686,  558, 1686,  554, 1706,  558, 1686,  558, 572,  556, 576,  536, 1684,  578, 1688,  562, 566,  558, 1686,  556, 574,  556, 576,  534, 1686,  576, 1686,  558, 572,  556, 578,  532, 1704,  558, 578,  556, 1682,  558, 39922,  9016, 2242,  556&#125;;  // NEC FF9A65uint32_t address = 0x0;uint32_t command = 0x59;uint64_t data = 0xFF9A65;------------------------分割线------------------------



要点说明
实例化IRrecv类，之后的操作都需要这个类提供的方法

IRrecv irrecv(kRecvPin, 1024, 50, true);


decode_results

decode_results 是一个结构体，它用于存储红外接收器接收到的红外信号的解码结果。
使用 decode_results 结构体的目的是为了方便地存储和访问红外信号的解码结果。在使用 IRremoteESP8266 库进行红外信号接收时，我们需要创建一个 decode_results 对象，并将其作为参数传递给 IRrecv 对象的 decode 方法。当 decode 方法成功解码出一个红外信号时，它会将解码结果存储在 decode_results 对象中，我们可以通过访问该对象的不同字段来获取解码结果。
例如，在上面给出的示例代码中，我们创建了一个名为 results 的 decode_results 对象，并将其作为参数传递给了 irrecv.decode 方法。当该方法成功解码出一个红外信号时，它会将解码结果存储在 results 对象中。然后，我们可以通过访问 results.value 字段来获取解码出的红外命令数据，并将其打印到串口。

这个结构体包含了多个字段，用于存储不同类型的解码信息，例如红外信号的协议类型、命令数据、地址数据等。
下面是 decode_results 结构体中一些常用字段的说明：

decode_type：红外信号的协议类型，例如 NEC、SONY、RC5 等。
类型：decode_type_t


value：红外命令数据，通常是一个 32 位无符号整数。
uint32_t


address：红外地址数据，用于区分不同的设备。
uint16_t


command：红外命令数据，用于表示不同的命令。
repeat：是否为重复信号。
rawbuf：指向原始数据缓冲区的指针；
rawlen：原始数据缓冲区中的数据位数（即元素个数）；

您可以通过访问这些字段来获取解码结果中的相关信息。例如，您可以使用 results.decode_type 来获取红外信号的协议类型，使用 results.value 来获取红外命令数据。



setup函数中的if…endif

这段代码是用来设置 IRrecv 对象的未知阈值的。#if DECODE_HASH 和 #endif 是预处理器指令，它们用来检查 DECODE_HASH 符号是否已定义。如果 DECODE_HASH 符号已定义，则 irrecv.setUnknownThreshold(12) 语句会被编译并执行；否则，该语句会被忽略。
irrecv.setUnknownThreshold(12) 语句用来设置 IRrecv 对象的未知阈值为 12。未知阈值用来指定接收到的红外信号中最少需要包含多少个脉冲才能被视为有效信号。如果接收到的红外信号中包含的脉冲数量小于未知阈值，则该信号会被忽略。



irrecv.setTolerance(kTolerance);

irrecv.setTolerance(kTolerance) 是一个方法，它用于设置 IRrecv 对象的容差百分比。容差百分比用于指定红外接收器在解码红外信号时允许的最大误差范围。容差越大，红外接收器对红外信号的解码就越宽容，但也可能导致误解码的概率增加。
kTolerance 是一个常量，它定义了 IRrecv 对象的默认容差百分比。您可以在创建 IRrecv 对象时使用 irrecv.setTolerance(kTolerance) 方法来设置容差百分比。此外，您还可以在运行时使用 irrecv.setTolerance() 方法来动态更改容差百分比。
例如，如果您希望红外接收器对红外信号的解码更加严格，可以将容差百分比设置得更小；反之，如果您希望红外接收器对红外信号的解码更加宽容，可以将容差百分比设置得更大。

kTolerance

kTolerance 是一个常量，它定义了 IRrecv 对象的默认容差百分比。容差百分比用于指定红外接收器在解码红外信号时允许的最大误差范围。容差越大，红外接收器对红外信号的解码就越宽容，但也可能导致误解码的概率增加。
可以使用整型数来替换 kTolerance，以指定自定义的容差百分比。例如，您可以使用 irrecv.setTolerance(50) 来将容差百分比设置为 50%。
如果用整型数来替换，整型数的范围是0-100。表示容差百分比的取值范围为 0% 到 100%。







if (irrecv.decode(&amp;results))

if (irrecv.decode(&amp;results)) 是一个条件语句，它用于检查 irrecv 对象是否成功解码出一个红外信号。irrecv.decode(&amp;results) 是一个方法调用，它调用了 irrecv 对象的 decode 方法，并将 results 对象的地址作为参数传递给该方法。
当 decode 方法成功解码出一个红外信号时，它会将解码结果存储在 results 对象中，并返回 true。因此，如果 irrecv.decode(&amp;results) 返回 true，则表示成功解码出一个红外信号，此时可以在 if 语句的代码块中访问 results 对象来获取解码结果。




]]></content>
      <categories>
        <category>ESP8266</category>
        <category>案例笔记</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>ESP8266</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang swag 库</title>
    <url>/2025/10/08/Golang_swag/</url>
    <content><![CDATA[Go swag 从入门到实践第1章：我们为什么需要 API 文档？—— 问题的起源

核心内容：讲解在团队协作和项目开发中，一份清晰的 API 文档是多么重要，以及手动维护文档的痛点。

第2章：Swag 是什么？—— 会写注释就会写文档的“魔法”

核心内容：介绍 swag 这个工具，把它比作一个能自动帮你把代码注释“翻译”成漂亮网页文档的“魔法师”。

第3-章：快速上手：三步生成你的第一个 API 文档

核心内容：通过一个最简单的 “Hello, World” 级别的 Go Web 项目，手把手带你完成安装、添加注释、生成并查看文档的全过程。

第4章：Swag 的“魔法咒语”：常用注解（Annotations）详解

核心内容：详细拆解 swag 的核心——注解语法，学习如何描述 API 的名称、参数、返回值等关键信息。

第5章：揭秘 Swag：它是如何工作的？

核心内容：简单说明 swag 的工作原理，让你明白它并不是真的“魔法”，而是一个代码解析和文件生成工具。

第6章：避坑指南：使用 Swag 的注意事项

核心内容：总结一些新手在使用 swag 时容易犯的错误和需要注意的地方，让你少走弯路。

第7章：总结与下一步

核心内容：回顾本次学习的重点，并为你指出接下来可以继续学习的方向。


第1章：我们为什么需要 API 文档？—— 问题的起源嘿，同学！在学习任何一个新工具，尤其是像 swag 这样的“自动化”工具之前，我们必须先搞清楚一个最根本的问题：我们到底遇到了什么麻烦，以至于需要一个新工具来拯救我们？
只有理解了“痛点”，我们才能真正明白这个工具的价值。
1.1 一个生活中的场景：去餐厅吃饭想象一下，你走进一家装修精美的餐厅，准备享用大餐。你（客户端，比如手机 App 或网页）坐下来，服务员递给你一本菜单（API 文档）。
这本菜单上写得清清楚楚：

有什么菜？（宫保鸡丁、鱼香肉丝……）
每道菜需要什么？（比如，“牛排”这道菜，你需要告诉服务员要“七分熟”还是“全熟”。）
这道菜上上来是什么样的？（菜单上的图片告诉你，这道菜有主食、有蔬菜沙拉。）

你通过菜单，知道了这家餐厅的厨房（服务端&#x2F;后端）能为你做什么。你点了一份“七分熟的牛排”，服务员把这个请求告诉了后厨。后厨一通操作，最后把一份完美的牛排端到你面前。
整个过程非常顺利，因为你们之间有一份清晰的“沟通契约”——菜单。



关键概念：API在软件开发中，API (Application Programming Interface，应用程序编程接口) 就扮演着“菜单”的角色。它定义了不同的软件部分之间如何沟通。后端程序员（厨师）开发好功能后，提供一份 API“菜单”，前端程序员（顾客）或其他服务就知道如何调用这些功能了。


1.2 软件开发中的“餐厅故事”：小明与小红的协作现在，我们把场景切换到一家软件公司。

小明：后端工程师，我们的“厨师”。他负责开发服务器的功能，比如“用户注册”、“获取商品列表”等。
小红：前端工程师，我们的“顾客”。她负责开发用户能直接看到的网页或 App 界面。

有一天，产品经理要求做一个“用户注册”的功能。
小明（厨师） 在后端吭哧吭哧写好了代码，实现了一个功能：只要别人给他一个用户名和密码，他就能在数据库里创建一个新用户，并返回“注册成功”或“用户已存在”的消息。
现在问题来了，小明怎么告诉小红（顾客） 这个功能该怎么用呢？
小红心里有一堆问题，就像你看菜单时一样：

我该访问哪个地址才能找到你这个“注册”功能？ （就像餐厅的门牌号和几号桌）

专业术语叫：Endpoint 或 URL


我该用什么方法来请求？是 GET 还是 POST？ （就像你是要“点餐”还是只是“看看菜单”）

我需要提供哪些信息给你？ 是 username 和 password 吗？还是 user 和 pwd？这些信息是放在哪里给你？

专业术语叫：请求参数 (Request Parameters)


你处理完后，会返回给我什么？ 是返回一个简单的字符串 &quot;注册成功&quot;，还是一个包含更多信息的复杂结构（比如 JSON 对象）？成功和失败时返回的样子一样吗？

专业术语叫：响应体 (Response Body)



你看，如果这些信息沟通不清楚，小红就完全没法开始工作。她可能会因为一个参数名写错（比如把 username 写成了 user），而调试大半天，最后发现是小明没告诉她。
于是，最原始的“API 文档”诞生了。可能是一份 Word 文档，一个 Wiki 页面，甚至是聊天记录。小明在里面写清楚上面所有问题的答案，然后发给小红。

1.3 手动维护文档的“噩梦”一开始，一切看起来都还不错。小明把文档写好，小红照着开发，项目顺利上线。
但软件是不断迭代的。不久后，产品经理又提了新需求：“注册时，除了用户名和密码，还需要用户提供一个邮箱(email)”。
小明（厨师） 立刻修改了他的代码，现在“注册”功能需要三个参数了：username, password, email。他急着下班，或者 只是 忘了，没有去更新那份 Word 文档。
灾难发生了！
几天后，小红发现所有新用户都注册不了了。她查了半天代码，看不出问题，最后跑去问小明。小明一拍脑袋：“哎呀！我加了个 email 参数，忘了和你说，也忘了更新文档了！”
这就是手动维护 API 文档的核心痛点：

容易忘记更新：代码是“唯一真实”的，文档是“副本”。程序员改了代码后，很容易忘记或懒得去同步修改那个独立的文档。
文档与代码不一致：这是最致命的。一份过时的、错误的文档比没有文档更可怕，因为它会误导使用者，浪费大量调试时间。
费时费力：写文档本身就是一件枯燥的工作。每次修改代码，都要去找到对应的文档位置进行修改，效率极低。
格式不统一：张三写的文档喜欢用表格，李四写的喜欢用列表。团队里没有统一的、美观的、易于阅读的 API 文档格式。

想一想：如果餐厅的菜单更新不及时，厨师新加了一道菜，或者某道菜的做法变了（比如“宫保鸡丁”现在默认加辣了），但菜单上还是老样子，顾客点餐时会发生多少误会和麻烦？

1.4 问题的总结与解决思路好了，到现在我们已经把问题搞得很清楚了：

团队协作需要清晰的 API 文档（菜单）。
手动维护这份文档（菜单）非常痛苦，且极易出错。

那么，有没有一种理想的方法，能够让“菜单”和“厨房里的菜谱”永远保持同步呢？
当然有！
我们能不能找到一种方法，让代码自己来描述自己？然后用一个工具，自动读取这些描述，生成一份永远不会过时、格式优美、交互友好的网页版“菜单”？
这，就是 swag 准备为我们做的事情。它就是那个能自动根据厨师的菜谱（代码注释），打印出精美菜单（API 文档网页）的“魔法打印机”。
本章小结
API 是什么？ 它是软件不同部分之间沟通的桥梁，就像餐厅的菜单，定义了你能请求什么，以及会得到什么。
为什么需要 API 文档？ 因为它是指导开发者如何正确使用 API 的说明书，是团队协作的基石。
手动维护文档有什么问题？ 容易过时、与代码不一致、耗费时间、格式混乱。
我们的目标是什么？ 找到一种自动化的方式，让代码和文档永远保持同步。

现在，你是不是已经深刻理解了我们即将学习的 swag 是为了解决什么问题而存在的？带着这个问题，我们下一章就来正式认识一下这位“魔法师”！

第2章：Swag 是什么？—— 会写注释就会写文档的“魔法”上一章我们聊了手动维护 API 文档的种种痛苦，并且提出了一个美好的设想：能不能让代码自己来解释自己，然后有个工具自动帮我们生成文档？
现在，揭晓答案的时刻到了！swag 就是来实现这个美好设想的工具。
2.1 Swag 的自我介绍你可以把 swag 想象成一位非常聪明的“文档翻译官”。
它本身不是一个重量级的大软件，而是一个 Go 语言的工具库。它的核心工作流程非常简单：

阅读你的代码：它会去扫描你项目里的 Go 代码文件。
寻找特殊注释：它不会关心你所有的代码逻辑，只关心那些你按照特定格式写的“特殊注释”（我们后面会叫它注解，英文是 Annotation）。
翻译成文档：它把这些“特殊注释”翻译成一种标准化的 API 描述文件（叫做 OpenAPI&#x2F;Swagger 规范文件）。
生成网页：最后，它利用这个标准文件，为你生成一套漂亮、可交互的 HTML 网页，也就是我们最终看到的 API 文档。


一句话总结：swag 是一个 Go 工具，它能将你代码里的特定注释，自动转换成交互式 API 文档。


2.2 回到我们的“餐厅”比喻还记得小明和小红的故事吗？小明是厨师（后端），小红是顾客（前端）。
在没有 swag 的世界里，小明（厨师）除了要写好自己的菜谱（代码），还得额外花时间去手写一份菜单（Word 文档），并且要时刻记着菜谱一改，菜单也要跟着改，心力交瘁。
现在有了 swag 这个“魔法打印机”，情况完全不同了：

在菜谱上做笔记：小明现在不用写单独的菜单了。他只需要在自己的“宫保鸡丁”菜谱（代码文件）旁边，用“魔法荧光笔”（swag 的注解语法）直接写下笔记。
// 这是我的做菜代码...// @菜名: 宫保鸡丁// @描述: 一道经典的川味菜肴，酸甜可口。// @需要食材: 鸡丁, 花生, 辣椒// @返回样式: &#123; &quot;status&quot;: &quot;成功&quot;, &quot;dish&quot;: &quot;宫保鸡丁一份&quot; &#125;func GongBaoJiDingHandler(w http.ResponseWriter, r *http.Request) &#123;    // ...复杂的炒菜过程...&#125;

一键打印：当小明写完代码和这些笔记后，他只要在电脑上敲一个命令（比如 swag init），这个“魔法打印机”就会“嗡嗡嗡”地工作起来。

生成精美菜单：swag 会自动扫描所有菜谱上的“魔法笔记”，然后“duang”的一下，生成一份图文并茂、格式精美的网页菜单，直接交给小红。


从此以后，小明只需要关心他的代码（菜谱）。只要菜谱里的做法或所需食材（API 参数）变了，他顺手改一下旁边的笔记，再敲一下命令，小红看到的菜单就自动更新了！
代码和文档，从此实现了完美的同步！ 这就是 swag 的核心价值。

2.3 最终的文档长什么样？—— Swagger UI你可能会好奇，swag 生成的文档到底是什么样的？仅仅是把注释搬到网页上吗？
远不止如此！swag 实际上是遵循一个业界非常流行的标准，叫做 OpenAPI 规范（它的前身就是大名鼎鼎的 Swagger 规范）。
你可以理解为，swag 先是把你的注释翻译成了一份“标准数据文件”（一个 json 或 yaml 文件），这份文件以一种通用的格式描述了你所有的 API。
然后，一个叫做 Swagger UI 的工具会读取这份标准文件，并把它渲染成一个非常酷的交互式网页。
它有什么特点呢？

清晰的列表：把你所有的 API 按照模块（比如“用户管理”、“商品管理”）分门别类地列出来。
详细的信息：点开任何一个 API，你都能看到它的 URL、请求方法（GET&#x2F;POST 等）、详细描述、所有参数的说明（参数名、类型、是否必需等）以及返回数据的格式。
在线调试功能（杀手级功能！）：这是最棒的部分！在文档页面上，你可以直接填写参数，然后点击一个 “Try it out” 或 “Execute” 按钮，直接调用这个 API！你不用写任何代码，就能立刻测试后端接口是否正常工作，返回的数据对不对。这对前端的小红来说，简直是天大的福音！

想一想：这就像在餐厅的电子菜单上，你不仅能看到菜品的图片和介绍，旁边还有一个“试吃”按钮。你点一下，服务员就会立刻给你端上一小份样品尝尝。这体验是不是太棒了？

本章小结
Swag 是什么？ 一个能把 Go 代码中的“特殊注释”自动生成为 API 文档的工具。
它的工作原理？ 读取代码注释 -&gt; 生成遵循 OpenAPI 规范的中间文件 -&gt; 利用 Swagger UI 渲染成交互式网页。
它的核心价值？ 让文档与代码保持同步，彻底解决手动维护文档的痛点，实现“代码即文档”。
最终产出物？ 一个美观、清晰、且支持在线调试的 API 文档网站。

好了，现在我们已经知道了 swag 是什么，以及它为什么这么神奇。是不是已经跃跃欲试，想亲手生成一份自己的 API 文档了？
下一章，我们就来动手实践！准备好你的 Go 环境，我们要开始写代码了！
准备好了吗？让我们开始搭建你的第一个自动化 API 文档！

第3章：快速上手：三步生成你的第一个 API 文档理论说再多，不如亲手敲一遍代码。这一章，我们会像拼乐高一样，一步步搭建一个最简单的 Go Web 项目，并用 swag 为它生成一份漂亮的 API 文档。
整个过程可以清晰地分为三步：搭建项目 -&gt; 添加注解 -&gt; 生成文档。
第零步：环境准备（磨刀不误砍柴工）在开始之前，请确保你的电脑已经安装好了 Go 语言环境。你可以在终端（命令行工具）里输入以下命令来检查：
go version

如果你能看到类似 go version go1.18 linux/amd64 这样的输出，就说明环境没问题。
接下来，创建一个新的项目文件夹，并进入这个文件夹。
mkdir my-swag-appcd my-swag-app

然后，初始化 Go 的模块管理，这会生成一个 go.mod 文件。
go mod init my-swag-app

第一步：安装 Swag 与搭建基础项目1. 安装 Swag 命令行工具
swag 主要包含两部分：一个是能生成文档的命令行工具，另一个是能在我们网页里展示文档页面的代码库。我们先来安装命令行工具。
在终端里运行：
go install github.com/swaggo/swag/cmd/swag@latest

安装成功后，你可以通过 swag -v 命令来验证。如果能看到版本号，就说明成功了。
2. 搭建一个简单的 Web 服务器
为了演示，我们将使用一个非常流行的 Go Web 框架 Gin，因为它简单快捷。同时，我们还需要 gin-swagger 和 files 这两个库，它们是 swag 的好搭档，用来在 Gin 项目里展示文档页面。
安装这三个库：
go get -u github.com/gin-gonic/gingo get -u github.com/swaggo/gin-swaggergo get -u github.com/swaggo/files

接下来，在你的项目文件夹 my-swag-app 中，创建一个 main.go 文件，然后把下面的代码复制进去。这是一个最基础的、不包含任何 swag 注解的 Web 服务器。
main.go (初始版本)
package mainimport (	&quot;github.com/gin-gonic/gin&quot;	&quot;net/http&quot;)func main() &#123;	// 1. 创建路由引擎	r := gin.Default()	// 2. 定义一个 API 路由	// 当用户访问 /hello?name=张三 时，会调用 PingHandler 函数	r.GET(&quot;/hello&quot;, PingHandler)		// 3. 启动服务，监听在 8080 端口	r.Run(&quot;:8080&quot;)&#125;// PingHandler 是这个 API 的处理函数func PingHandler(c *gin.Context) &#123;	// 从 URL 查询参数中获取 &quot;name&quot; 的值，如果没有，则默认为 &quot;Guest&quot;	name := c.DefaultQuery(&quot;name&quot;, &quot;Guest&quot;)		// 返回一个 JSON 响应	c.JSON(http.StatusOK, gin.H&#123;		&quot;message&quot;: &quot;pong, &quot; + name,	&#125;)&#125;

现在，你可以运行这个程序：
go run main.go

然后在浏览器或 Postman 等工具中访问 http://localhost:8080/hello?name=Coder，你会看到返回结果：{&quot;message&quot;:&quot;pong, Coder&quot;}。
很好！我们的基础项目已经跑起来了。
第二步：添加“魔法咒语”—— 编写 Swag 注解 (Annotation)现在，我们要开始对代码“施法”了。swag 的注解本质上就是一种特殊格式的注释，它总是以 @ 符号开头。
我们将为我们的项目添加两种注解：

全局注解：写在 main 函数的上方，用来描述整个项目的基本信息，比如标题、版本号、API 的基础路径等。
API 注解：写在具体的 Handler 函数（处理请求的函数）上方，用来描述这一个 API 的所有细节。

现在，请用下面的代码完整替换你的 main.go 文件。仔细看新增的那些注释。
main.go (添加注解后)
package mainimport (	&quot;github.com/gin-gonic/gin&quot;	&quot;net/http&quot;		// 引入 swag 必需的库	_ &quot;my-swag-app/docs&quot; // 注意这里的路径！ `my-swag-app` 是你的 go.mod 里的模块名	swaggerFiles &quot;github.com/swaggo/files&quot;	ginSwagger &quot;github.com/swaggo/gin-swagger&quot;)// @title           我的第一个 Swag API// @version         1.0// @description     这是一个使用 Gin 和 Swag 构建的示例服务.// @termsOfService  http://swagger.io/terms/// @contact.name   API Support// @contact.url    http://www.swagger.io/support// @contact.email  support@swagger.io// @license.name  Apache 2.0// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html// @host      localhost:8080// @BasePath  /// @schemes httpfunc main() &#123;	r := gin.Default()	// API 路由	r.GET(&quot;/hello&quot;, PingHandler)	// 文档路由	// 访问 http://localhost:8080/swagger/index.html 就可以看到文档了	r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler))	r.Run(&quot;:8080&quot;)&#125;// PingHandler 回复一个问候// @Summary      Ping example// @Description  这是一个 &quot;ping&quot; API 的示例，它会带上你的名字进行回复.// @Tags         示例API// @Accept       json// @Produce      json// @Param        name   query      string  false  &quot;你的名字&quot; default(Guest)// @Success      200    &#123;object&#125;   map[string]string// @Router       /hello [get]func PingHandler(c *gin.Context) &#123;	name := c.DefaultQuery(&quot;name&quot;, &quot;Guest&quot;)	c.JSON(http.StatusOK, gin.H&#123;		&quot;message&quot;: &quot;pong, &quot; + name,	&#125;)&#125;

代码讲解：

全局注解（main 函数上方）：
@title, @version, @description: 定义了文档的标题、版本和描述。
@host: 告诉 swag 我们的服务地址是什么，这在在线调试时非常重要。
@BasePath: API 的基础路径，我们这里是根路径 /。


API 注解（PingHandler 函数上方）：
@Summary: API 的一句话简介，会显示在列表里。
@Description: 更详细的描述。
@Tags: API 的分组标签，方便管理。
@Accept&#x2F;@Produce: 定义这个 API 接收和返回的数据格式（这里是 json）。
@Param: 非常重要！用来定义参数。格式是：参数名 参数位置 数据类型 是否必需 注释 其他属性。
name query string false &quot;你的名字&quot; 的意思是：有一个名叫 name 的参数，它在 query（URL ? 后面）里，类型是 string，不是必需的 (false)，注释是 “你的名字”。


@Success: 定义成功响应。格式是：HTTP状态码 {返回数据结构} 注释。我们这里 200 表示成功，返回一个键值都是字符串的 map。
@Router: 定义路由路径和 HTTP 方法。格式是：路径 [HTTP方法]。



第三步：生成并查看文档万事俱备，只欠东风！现在，我们在项目根目录下（my-swag-app 文件夹）打开终端，运行 swag 的初始化命令：
swag init

执行后，你会看到类似这样的输出：create docs.gocreate swagger.jsoncreate swagger.yaml
同时，你的项目文件夹里会多出一个 docs 文件夹，里面就装着 swag 帮我们生成的文档资源。
最后一步，让我们的程序跑起来！
go run main.go

服务启动后，打开你的浏览器，访问这个神奇的地址：
http://localhost:8080/swagger/index.html
见证奇迹的时刻！ 你会看到一个漂亮的 API 文档页面，上面清晰地列出了我们刚刚定义的 “Ping example” API。你可以点开它，看到所有详细信息，甚至可以在页面上输入你的名字，点击 “Try it out”，然后 “Execute”，亲身体验在线调试的快感！

本章小结恭喜你！你已经成功地使用 swag 生成了你的第一个 API 文档。我们来回顾一下这个核心流程：

安装工具：安装 swag 命令行工具和相关的 Go 库 (gin-swagger, files)。
编写注解：在 main 函数上写全局注解，在处理函数上写API 注解。
生成文档：运行 swag init 命令，生成 docs 文件夹。
集成与运行：在代码中添加文档路由，然后运行程序，访问 /swagger/index.html 查看。

这个流程会成为你未来工作的日常。每当你修改了 API 的逻辑或参数，你只需要：修改代码&#x2F;注解 -&gt; 重新运行 swag init -&gt; 重启你的服务你的文档就永远和代码保持同步了！
现在你已经掌握了基本操作，但你可能对 @Param、@Success 等注解的具体写法还有很多疑问。别担心，下一章，我们将深入学习这些“魔法咒语”的详细语法和更多用法。
你已经学会了如何“让 swag 跑起来”，现在是时候深入理解它背后的“语法规则”了。只有掌握了这些规则，你才能随心所欲地生成任何你想要的文档。
这一章，我们就来详细拆解 swag 的核心——注解（Annotations），也就是我们之前说的“魔法咒语”。

第4章：Swag 的“魔法咒语”：常用注解（Annotations）详解把注解想象成你在填写一份非常详细的“API 注册表”。这份表单上的每一项（比如“名称”、“功能”、“所需材料”等），都对应一个 @ 开头的注解。swag 工具就是一个严格的“审查员”，它会读取你填写的这份表单，并据此生成最终的文档。
我们将注解分为几大类来学习：API 身份信息、请求信息、响应信息和路由信息。
4.1 API 的“身份证”：我是谁，我做什么？这类注解用来描述 API 的基本信息，让别人一眼就能看懂它的用途。

@Summary

用途：API 的一句话摘要，是它的“标题”。通常在文档列表中显示。

语法：@Summary 任意描述性文字

示例：
// @Summary 获取单个用户信息


@Description

用途：API 的详细描述。可以写多行，用来解释更复杂的业务逻辑或注意事项。

语法：@Description 更详细的说明，可以换行。

示例：
// @Description 根据用户ID获取用户的详细信息，包括姓名、年龄和注册日期。// @Description 注意：如果用户ID不存在，将返回404错误。


@Tags

用途：为 API 分组。在文档页面上，相同 Tags 的 API 会被归类到一起，非常利于管理。

语法：@Tags 标签名1,标签名2 (多个标签用逗号隔开)

示例：
// @Tags 用户管理


@ID

用途：为操作设置一个唯一的标识符。在某些高级应用（如生成客户端代码）中会用到，通常可以省略。

语法：@ID 操作的唯一ID

示例：
// @ID GetUserByID




4.2 “顾客”需要提供什么？—— 定义请求参数 @Param这是最重要、也是最复杂的注解之一。它告诉使用者，调用这个 API 需要提供哪些数据。

@Param

用途：定义一个请求参数。每个参数都需要单独写一行 @Param 注解。
语法：@Param 参数名 参数位置 数据类型 是否必需 &quot;注释&quot; [其他属性]
参数详解：
参数名 (Parameter Name)：例如 userID、username。
参数位置 (Parameter In)：参数从哪里来？
query：URL 中 ? 后面的参数，如 /users?id=123。
path：URL 路径中的一部分，如 /users/123 (需要配合 Gin 的 :id 格式)。
header：HTTP 请求头里的参数，如 Authorization Token。
body：整个 HTTP 请求体，通常用于 POST&#x2F;PUT 请求，用来传递复杂的 JSON 数据。
formData：表单数据，用于 application/x-www-form-urlencoded 或 multipart/form-data 格式的提交。


数据类型 (Data Type)：参数的类型，如 string、int、boolean、file 等。
是否必需 (Required)：true 或 false。
注释 (Comment)：用双引号括起来的参数描述。
其他属性 (Attributes)：可选，用于提供更多约束，如 default(Guest)、enums(male,female)、maxLength(10) 等。




@Param 示例大合集
1. query 参数（最常见）
// @Param   page  query     int  false  &quot;页码&quot; default(1)// @Param   size  query     int  false  &quot;每页大小&quot; default(10)

2. path 参数
// @Summary 获取单个用户信息// @Param   id   path      int  true   &quot;用户ID&quot;// @Router /users/&#123;id&#125; [get]// Gin 路由应该这样写: r.GET(&quot;/users/:id&quot;, GetUser)

注意：@Router 里的路径 {id} 必须和 @Param 里的 id 对应。
3. body 参数（用于提交 JSON）
// @Summary 创建一个新用户// @Accept  json// @Param   user body      models.User  true   &quot;用户信息&quot;// @Router /users [post]// 这里的 `models.User` 是你项目里定义的一个 Go 结构体 (struct)，我们稍后会讲。

@Accept 注解用来声明此 API 接收的数据格式。



4.3 “厨师”会返回什么？—— 定义响应 @Success &amp; @Failure这两个注解用来告诉使用者，API 调用成功或失败时，会返回什么样的数据。

语法：@Success/@Failure HTTP状态码 {返回类型} 数据模型 &quot;注释&quot;

参数详解：

HTTP状态码 (HTTP Status Code)：如 200 (成功)、400 (错误请求)、404 (未找到)、500 (服务器内部错误)。
返回类型 (Response Type)：通常是 object (单个对象) 或 array (对象数组)。
数据模型 (Data Model)：
可以是基础类型，如 string, int。
可以是 map[string]string 这样的简单集合。
最常用的是：指向你项目中定义的 Go 结构体，如 models.User 或 []models.User (表示用户数组)。


注释 (Comment)：对这个响应的描述。


@Success &amp; @Failure 示例
1. 返回简单消息
// @Success 200 &#123;object&#125; map[string]string &quot;&#123;&quot;message&quot;: &quot;操作成功&quot;&#125;&quot;// @Failure 400 &#123;object&#125; map[string]string &quot;&#123;&quot;error&quot;: &quot;无效的输入&quot;&#125;&quot;

2. 返回一个复杂对象（结构体）
// @Success 200 &#123;object&#125; models.User &quot;成功返回用户信息&quot;

3. 返回一个对象数组
// @Success 200 &#123;array&#125; models.User &quot;成功返回用户列表&quot;

@Produce 注解用来声明此 API 返回的数据格式，通常是 application/json。



4.4 API 的“门牌号” —— 定义路由 @Router这个注解至关重要，它把所有信息和具体的 URL 路径、HTTP 方法绑定在了一起。

@Router

用途：定义 API 的路由路径和请求方法。

语法：@Router /path/to/resource [http_method]

示例：
// @Router /users [post]        // 创建用户// @Router /users/&#123;id&#125; [get]      // 获取单个用户// @Router /users/&#123;id&#125; [put]      // 更新单个用户// @Router /users/&#123;id&#125; [delete]   // 删除单个用户




4.5 综合实战：定义一个完整的 CRUD现在，让我们把所有学到的注解整合起来，为一个 User 模型定义一个完整的创建和查询 API。
首先，创建一个 models 文件夹，并在其中创建 user.go 文件
models/user.go
package models// User 代表一个用户模型type User struct &#123;    ID   int    `json:&quot;id&quot; example:&quot;1&quot;`    Name string `json:&quot;name&quot; example:&quot;John Doe&quot;`    Age  int    `json:&quot;age&quot; example:&quot;30&quot;`&#125;

这里的 json:&quot;...&quot; 是 Go 的结构体标签，用于序列化为 JSON。example:&quot;...&quot; 是 swag 的注解，用于在文档中生成示例值。
然后，修改你的 main.go，添加新的路由和处理函数
main.go (片段)
// ... import 部分省略 ...import &quot;my-swag-app/models&quot; // 引入你的模型包// ... 全局注解部分省略 ...// GetUserByID 根据ID获取用户信息// @Summary      获取单个用户// @Description  根据给定的用户ID返回用户数据// @Tags         用户管理// @Produce      json// @Param        id   path      int  true  &quot;用户 ID&quot;// @Success      200  &#123;object&#125;  models.User// @Failure      404  &#123;object&#125;  map[string]string// @Router       /users/&#123;id&#125; [get]func GetUserByID(c *gin.Context) &#123;    // 实际项目中这里应该是查询数据库的逻辑    // 我们这里为了演示，直接返回一个假数据    id := c.Param(&quot;id&quot;)    if id == &quot;1&quot; &#123;        user := models.User&#123;ID: 1, Name: &quot;John Doe&quot;, Age: 30&#125;        c.JSON(http.StatusOK, user)        return    &#125;    c.JSON(http.StatusNotFound, gin.H&#123;&quot;error&quot;: &quot;User not found&quot;&#125;)&#125;// CreateUser 创建一个新用户// @Summary      创建用户// @Description  从请求体中接收用户信息并创建一个新用户// @Tags         用户管理// @Accept       json// @Produce      json// @Param        user   body      models.User  true  &quot;用户信息&quot;// @Success      201    &#123;object&#125;  models.User// @Failure      400    &#123;object&#125;  map[string]string// @Router       /users [post]func CreateUser(c *gin.Context) &#123;    var user models.User    // 将请求体中的 JSON 绑定到 user 结构体    if err := c.ShouldBindJSON(&amp;user); err != nil &#123;        c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)        return    &#125;    // 实际项目中这里是存入数据库的逻辑    // 我们这里为了演示，假装设置一个ID并返回    user.ID = 2     c.JSON(http.StatusCreated, user)&#125;func main() &#123;    // ...    r := gin.Default()    // 用户管理 API 路由组    userRoutes := r.Group(&quot;/users&quot;)    &#123;        userRoutes.GET(&quot;/:id&quot;, GetUserByID)        userRoutes.POST(&quot;&quot;, CreateUser)    &#125;    r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler))    // ...    r.Run(&quot;:8080&quot;)&#125;

操作步骤：

保存以上代码。
在终端运行 swag init。
运行 go run main.go。
访问 http://localhost:8080/swagger/index.html。

你会看到一个新的 “用户管理” 分组，里面包含了我们刚刚定义的两个 API。点开 “创建用户” (POST /users)，你会发现它的请求体部分已经为你生成了一个包含 name 和 age 的 JSON 示例，这就是 @Param 引用 models.User 结构体的强大之处！

本章小结我们详细学习了 swag 最核心的几类注解：

身份注解：@Summary, @Description, @Tags，用于描述 API 的基本信息。
请求注解：@Param，用于定义输入的参数，是功能最强大的注解。
响应注解：@Success, @Failure，用于定义不同情况下的输出。
路由注解：@Router，用于将所有信息与 URL 和 HTTP 方法绑定。

掌握了这些，你就掌握了 swag 的 80%。剩下的就是不断练习，熟悉各种参数位置 (query, path, body 等) 和数据类型 (基础类型、自定义结构体、数组) 的组合使用。
接下来，我们将简单聊聊 swag 到底是怎么工作的，揭开它神秘的“魔法”面纱。
到现在为止，你已经掌握了 swag 的使用方法，能够熟练地通过写注释来生成漂亮的 API 文档了。对你来说，swag 可能还像一个神奇的“黑盒子”：我写了注释，敲了命令，漂亮的网页就出来了。
这一章，我们就来打开这个“黑盒子”，用最简单的方式看一看它内部的构造。理解了它的工作原理，你不仅能更好地使用它，还能在遇到问题时，更快地找到原因。

第5章：揭秘 Swag：它是如何工作的？swag 并不是真的有什么“魔法”，它本质上是一个代码解析器和文件生成器的组合。它的整个工作流程，就像一个高度自动化的工厂流水线。
让我们把 swag init 这个命令的执行过程拆解成三个主要步骤：
步骤一：扫描与解析（流水线的第一站：原材料检验）当你运行 swag init 时，swag 工具首先会像一个勤劳的机器人，开始扫描你项目中的所有 .go 文件。
但它不是漫无目的地扫描，它的目标非常明确：寻找那些以 // @ 开头的特殊注释行。
在这个过程中，它利用了 Go 语言自带的一个强大工具包——go/ast (Abstract Syntax Tree，抽象语法树)。

什么是抽象语法树（AST）？你可以把它想象成对你代码的一种“结构化解剖”。go/ast 包能够把你的 Go 代码文本，转换成一个程序能够理解的、树状的数据结构。在这棵“树”上，每个节点都代表了代码的一部分，比如一个函数声明、一个变量定义、或者一行注释。
生活中的类比：这就像一位语法老师在分析一个句子：“勤劳的小明（主语）昨天（状语）高兴地（状语）完成了（谓语）家庭作业（宾语）。”老师并不是把这句话当成一串无意义的文字，而是解析出了它的语法结构。
swag 就是这样一位“语法老师”，它能准确地识别出：“哦，这行注释 // @Summary 获取用户信息 是挂在 GetUserByID 这个函数声明节点上面的！”


通过这种方式，swag 就能把注解和它们所描述的函数精确地关联起来。
步骤二：翻译与整合（流水线的第二站：加工与组装）swag 找到了所有的注解和它们对应的代码结构后，就开始了“翻译”工作。
它的目标是生成一份遵循 OpenAPI 3.0 规范（或旧版的 Swagger 2.0）的 swagger.json 或 swagger.yaml 文件。

什么是 OpenAPI 规范？它是一个用来描述 RESTful API 的国际标准格式。你可以把它理解成 API 界的“普通话”。这份规范用 JSON 或 YAML 格式，极其严谨地定义了描述一个 API 所需的全部元素：路径、操作（GET&#x2F;POST）、参数、请求体、响应、数据模型等等。全世界有成千上百的工具都认识这门“普通话”，比如 Postman、Swagger UI 等。

swag 的翻译工作就是把 swag 自定义的注解格式，转换成 OpenAPI 规范的标准格式。

// @Summary 获取用户信息  -&gt;  会被翻译成 JSON 中 summary 字段。
// @Param id path int true &quot;用户ID&quot; -&gt; 会被翻译成 parameters 数组中的一个对象，里面详细定义了 name: &quot;id&quot;, in: &quot;path&quot;, required: true, schema: { &quot;type&quot;: &quot;integer&quot; } 等等。
// @Success 200 {object} models.User -&gt; 会被翻译成 responses 对象下的 200 字段，并且会去解析 models.User 这个结构体，把它也转换成 OpenAPI 规范里的 schemas 定义。

所有 API 的信息都被翻译和整合后，最终形成一个巨大的、结构化的 swagger.json 文件。这个文件才是 swag 的核心产物。
你可以打开你项目 docs 目录下的 swagger.json 文件看一看，虽然内容很多，但仔细观察，你就能找到和你写的注解一一对应的字段。
步骤三：打包与呈现（流水线的最后一站：包装与上架）swag 生成了标准的 swagger.json 文件，但这个 JSON 文件是给机器看的，对人类并不友好。所以，还需要最后一步：展示。
这一步其实主要由两个我们之前安装的库来完成：

github.com/swaggo/files这个库里内置了 Swagger UI 的所有静态资源文件（HTML, CSS, JavaScript）。Swagger UI 是一个开源项目，它的唯一工作就是读取 OpenAPI 规范文件（比如我们的 swagger.json），并把它渲染成我们看到的那个漂亮的、可交互的网页。

github.com/swaggo/gin-swagger这是一个适配器（Adapter），它的作用是把 Swagger UI 和 Gin 框架无缝地结合起来。我们在 main.go 里写的那行代码：
r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler))

它的意思就是：创建一个路由 /swagger/，当用户访问这个地址时，就由 gin-swagger 这个“中间人”来处理。它会负责加载 swaggo/files 里的 HTML 页面，并把我们生成的 docs/swagger.json 文件的内容喂给这个页面。


于是，当你在浏览器里访问 http://localhost:8080/swagger/index.html 时：

Gin 框架匹配到路由，请求被 gin-swagger 接管。
gin-swagger 返回 Swagger UI 的主 HTML 页面。
浏览器加载这个 HTML 页面，页面里的 JavaScript 代码会去请求 /swagger/doc.json (这是 gin-swagger 自动配置的另一个内部路由)。
gin-swagger 读取我们项目里 docs/swagger.json 文件的内容，并返回给浏览器。
Swagger UI 的 JavaScript 拿到 JSON 数据后，动态地在页面上渲染出所有的 API 列表、参数输入框、示例等等。

至此，整个流程全部完成！

本章小结现在，我们再回头看 swag，它是不是清晰多了？

swag init 命令做了什么？

解析 (Parse)：使用 go/ast 解析 Go 源代码，找到 @ 注解和它们关联的函数。
生成 (Generate)：将解析到的信息，翻译成标准的 swagger.json 和 swagger.yaml 文件，并存放在 docs 目录。
创建入口 (Create Entrypoint)：生成一个 docs/docs.go 文件，这个文件里包含了生成的 JSON&#x2F;YAML 数据，并注册自己，让 gin-swagger 这样的库能找到它。


程序运行时发生了什么？

gin-swagger 负责创建一个路由。
swaggo/files 提供了 Swagger UI 的静态页面。
当用户访问文档页时，gin-swagger 把 docs/swagger.json 的内容提供给 Swagger UI 的前端页面进行渲染。



理解了这个原理，你就能明白为什么每次修改了注解之后，都必须重新运行 swag init。因为 swagger.json 文件不会自动更新，你必须手动触发这个“翻译和生成”的过程。
好了，原理我们已经搞懂了。在学习的最后，我将为你总结一些新手常遇到的“坑”以及一些最佳实践，帮助你在未来的使用中少走弯路。
好的，同学！我们已经到达了学习之旅的尾声。
你现在已经知道了 swag 是什么，怎么用，以及它背后的工作原理。可以说，你已经从一个“小白”成长为一名合格的 swag 使用者了。
但在实际的开发道路上，我们总会遇到一些小石子、小水坑。这一章，作为老师，我将把我的一些经验传授给你，帮你提前识别并绕开这些常见的“坑”，让你的 swag 之旅更加顺畅。

第6章：避坑指南：使用 Swag 的注意事项这一章更像是一份“温馨提示清单”。当你遇到问题时，不妨回来查阅一下，很可能答案就在这里。
1. 忘了这一步，一切都白费：swag init
现象：我明明在代码里改了注解，为什么刷新文档页面一点变化都没有？
原因：这是99%的新手都会犯的错误。swag 不会实时监控你的代码变化。文档页面依赖的是 docs 目录下的 swagger.json 文件，而这个文件只有在你运行 swag init 命令时才会被更新。
黄金法则：每次修改完任何 @ 注解后，都必须重新在项目根目录下执行 swag init 命令。
进阶技巧：可以结合一些文件监控工具（如 air、fresh 等），配置成在 .go 文件保存时自动执行 swag init，实现自动化。


2. 神秘的 import _ &quot;...&quot;
现象：我运行了 swag init，docs 目录也生成了，程序也能跑，但访问文档页时一片空白，或者提示 “Failed to load API definition.”。

原因：swag 在生成 docs/docs.go 文件时，会使用一个 init() 函数来注册生成的 swagger 规范。为了让你的主程序能够执行到这个 init() 函数，你必须在你的 main.go（或者程序的入口文件）里匿名导入（import _ &quot;...&quot;）这个 docs 包。

正确姿势：确保你的 main.go 中有下面这行代码，并且路径正确。
import _ &quot;my-swag-app/docs&quot; // &quot;my-swag-app&quot; 是你 go.mod 文件里定义的模块名

匿名导入的 _ 意味着：我不需要使用这个包里的任何变量或函数，我只是想让你这个包的代码被加载，从而执行它的 init() 函数。



3. 结构体（Struct）无法正确解析
现象：我在 @Success 或 @Param 中引用了一个自定义的结构体，比如 models.User，但是在文档页面上，这个模型（Model）的字段显示不出来，或者是空的。

原因与解决方案：

没有写 json 标签：swag 默认通过 json:&quot;...&quot; 标签来识别字段名。请确保你的结构体字段都有这个标签。
// 错误示例type User struct &#123;    ID int&#125;// 正确示例type User struct &#123;    ID int `json:&quot;id&quot;`&#125;

字段是私有的：Go 语言中，首字母小写的字段是包内私有的，swag 无法在外部解析它们。请确保所有需要展示在文档中的字段名首字母大写。
// 错误示例type User struct &#123;    id int `json:&quot;id&quot;`&#125;// 正确示例type User struct &#123;    ID int `json:&quot;id&quot;`&#125;

引用了其他包的结构体：如果你的结构体引用了来自其他第三方库的结构体，swag 可能无法解析它。解决方法是创建一个新的、你自己的结构体（有时称为 DTO - Data Transfer Object），只包含你需要的字段，然后在你的处理函数中进行数据转换。





4. @Param 和 @Router 的路径参数不匹配
现象：定义了路径参数，但在文档里无法正确渲染，或者在线调试时参数没有传递。

原因：@Param 注解中定义的路径参数名，必须和 @Router 注解中的占位符完全一致。

正确姿势：
// @Param   userID   path      int  true  &quot;用户 ID&quot;// @Router /users/&#123;userID&#125; [get] // 这里都是 userID，保持一致// 错误姿势// @Param   id   path      int  true  &quot;用户 ID&quot;// @Router /users/&#123;userID&#125; [get] // 一个是 id，一个是 userID，不匹配，会出错


5. 全局注解（main 函数上方）到底写在哪？
规定：swag 会扫描整个项目来寻找 API 注解（写在 Handler 函数上的），但全局注解只会寻找 main 包（也就是包含 func main() 的那个文件）里的注释。
最佳实践：始终将 @title, @version, @host 等全局注解写在 main.go 文件中 main 函数的上方。不要把它们放在其他文件里，否则 swag 会找不到。


6. 文档部署到服务器上访问不了？—— @host 和 @BasePath 的重要性
现象：文档在本地 localhost:8080 访问完全正常，但部署到服务器上（比如 api.mydomain.com/v1）之后，在线调试功能 (“Try it out”) 点击 “Execute” 没反应，或者请求的地址不对。

原因：swag 文档页面里的调试工具，会根据 @host 和 @BasePath 来拼接最终的请求 URL。如果你这里写的是 localhost:8080，那无论你在哪里访问这个文档，它都会往 localhost:8080 发请求。

部署时的正确配置：
// @host      api.mydomain.com// @BasePath  /v1

这样配置后，swag 生成的文档在调用 /users/{id} 这个 API 时，就会正确地请求 http://api.mydomain.com/v1/users/{id}。

动态配置：在不同的环境（开发、测试、生产）中，host 可能会不同。你可以考虑使用 swag 的一些高级功能，或者编写脚本，在持续集成&#x2F;持续部署（CI&#x2F;CD）流程中动态地修改这些注解或生成的 swagger.json 文件。



本章小结我们总结了几个最常见的新手问题和注意事项：

改完注解，必跑 swag init。
检查 main.go 是否有 import _ &quot;...&quot;。
结构体字段必须首字母大写，并有 json 标签。
@Param 和 @Router 的路径参数名要一致。
全局注解写在 main 函数之上。
部署时，正确配置 @host 和 @BasePath。

记住这些，可以帮你节省大量的调试时间。现在，我们来进行最后的内容总结，并展望一下未来。
经过前面六个章节的学习和实践，你已经从一个对 swag 毫无概念的小白，成长为一名能够独立使用它来为 Go 项目生成专业 API 文档的开发者了。
现在，让我们一起花几分钟时间，回顾一下我们走过的路，并看看前方的风景。

第7章：总结与下一步7.1 我们的学习回顾（我们学到了什么？）让我们像看电影回放一样，快速过一遍本次学习的核心要点：

问题的起源（第1章）：我们明白了为什么需要 API 文档，以及手动维护文档是多么痛苦。这是我们学习 swag 的根本动机——自动化，让代码与文档同步。

Swag 的真面目（第2章）：我们认识了 swag，知道它是一个能将 Go 代码中的特殊注释，自动转换为交互式 API 网页的“魔法”工具。这个网页不仅好看，还能在线调试。

第一次亲密接触（第3章）：我们亲手实践了 swag 的三步走核心流程：安装工具 -&gt; 添加注解 -&gt; 运行 swag init 生成文档。你成功生成了人生中第一个由代码自动生成的 API 文档！

“魔法咒语”大全（第4章）：我们深入学习了 swag 的各种注解，如 @Summary, @Tags, @Param, @Success, @Router 等，并学会了如何使用它们来精确描述一个 API 的方方面面，包括如何引用自定义的结构体。

揭开魔法的面纱（第5章）：我们探究了 swag 的工作原理，了解到它并非魔法，而是一个代码解析器 + OpenAPI 规范生成器。这个过程让我们知其然，更知其所以然。

前人的智慧（第6章）：我们总结了新手在使用 swag 时最容易遇到的几个“坑”，比如忘记运行 swag init、匿名导入路径错误等，为未来的实战扫清了障碍。


到此，你已经构建起了一个关于 swag 的完整知识体系。恭喜你，你已经掌握了一项能极大提升开发效率和团队协作质量的实用技能！

7.2 知识的延伸（接下来可以学什么？）学习永无止境。当你熟练掌握了 swag 的基础用法后，你可能还想探索更多，这里我为你指出几个可以继续深入的方向：

深入 OpenAPI 规范：swag 只是一个生成器，它所遵循的 OpenAPI 规范才是 API 描述领域的核心。花一点时间去阅读 OpenAPI 3.0 的官方文档，你会对 API 设计有更深刻的理解，也能解锁 swag 注解中更多高级的用法（比如定义安全策略 Security、组件 Components 等）。

探索更复杂的注解：我们这次学习主要覆盖了最常用的注解。swag 还支持更多高级注解，例如：

@Security: 用于定义 API 的认证方式，比如 JWT Token, API Key, OAuth2 等。
@Accept &#x2F; @Produce: 除了 json，还支持 xml, html, plain 等多种格式。
@Example: 为请求体或响应体提供更具体的示例。


自动化 swag init：在实际项目中，每次修改都手动运行 swag init 还是有些繁琐。你可以研究一下如何将其集成到你的开发流程中。比如使用 air 这个 Go 的热重载工具，在配置文件中添加一条命令，让它在监控到 .go 文件变化时，自动帮你执行 swag init。

尝试其他 Go Web 框架：我们这次课程用的是 Gin 框架。swag 社区也为其他流行的 Go 框架提供了适配器，比如 Echo, Fiber, Chi 等。你可以尝试在不同的框架中使用 swag，加深理解。



7.3 最后的叮嘱同学，工具是为人服务的。swag 的价值不仅仅在于生成一份漂亮的文档，更在于它背后所倡导的一种**“文档驱动”或“代码即文档”**的开发理念。
养成在写代码的同时，就写好注解的习惯，这会让你未来的自己和你的同事都感激不尽。一份清晰、准确、永远与代码同步的 API 文档，是专业软件项目中不可或缺的一环。
希望这次学习笔记能真正帮助到你。如果在未来的学习和工作中遇到任何问题，随时都可以回来复习。
现在，合上笔记，去你的项目中，开始享受 swag 带来的便捷和快乐吧！
祝你编程愉快！
附录Swagger 注解参考与实战模板（Swag for Go）
适用于 github.com/swaggo/swag + github.com/swaggo/gin-swagger文件可直接放入项目 /docs/ 目录供开发参考。


一、常用注解说明表（带调用示例）


注解名
作用
常用位置
说明
示例注解
API 调用示例



@Summary
接口简要描述
函数顶部
展示在 Swagger UI 接口列表中
// @Summary 获取用户信息
——


@Description
接口详细描述
函数顶部
可多行描述细节、约束等
// @Description 根据用户ID查询详细资料
——


@Tags
接口分组
函数顶部
Swagger 左侧菜单分组
// @Tags 用户管理
——


@Accept
接收类型
函数顶部
json, multipart/form-data, x-www-form-urlencoded 等
// @Accept json
——


@Produce
响应类型
函数顶部
json, xml, plain 等
// @Produce json
——


@Param (query)
URL 查询参数
函数顶部
@Param name query string true &quot;用户名&quot;，true为必填，false为可选
// @Param name query string true &quot;用户名&quot;
GET /api/user?name=Tom


@Param (path)
路径参数
函数顶部
URL 占位符参数（REST 风格），必填（一般必须为 true，因为路径里必须有值）
// @Param id path int true &quot;用户ID&quot;
GET /api/user/123


@Param (header)
Header 参数
函数顶部
适合传 Token 或版本号，true为必填，false为可选
// @Param Authorization header string true &quot;Bearer Token&quot;
curl -H &quot;Authorization: Bearer XXX&quot; ...


@Param (formData)
表单参数
函数顶部
用于 POST 的表单数据，true为必填，false为可选
// @Param username formData string true &quot;用户名&quot;
POST /login  (username=Tom&amp;password=123)


@Param (file)
文件上传参数
函数顶部
multipart/form-data，true为必填，false为可选
// @Param file formData file true &quot;上传文件&quot;
curl -F &quot;file=@avatar.png&quot; /upload/avatar


@Param (body)
JSON 请求体
函数顶部
用于 POST&#x2F;PUT 请求体，true为必填，false为可选
// @Param data body User true &quot;用户信息&quot;
POST /user {&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:18}


@Param (cookie)
Cookie 参数
函数顶部
从 cookie 读取数据，true为必填，false为可选
// @Param session cookie string false &quot;Session ID&quot;
Cookie: session=abcd1234


@Success
成功返回
函数顶部
定义返回结构体与 HTTP 码
// @Success 200 {object} User &quot;返回用户信息&quot;
响应体：{&quot;id&quot;:1,&quot;name&quot;:&quot;Tom&quot;}


@Failure
失败返回
函数顶部
描述错误信息结构体
// @Failure 400 {object} ErrorResponse &quot;参数错误&quot;
响应体：{&quot;code&quot;:400,&quot;msg&quot;:&quot;invalid&quot;}


@Router
路由定义
函数顶部
指定接口路径与方法
// @Router /user/{id} [get]
GET /user/123


@Security
鉴权机制
函数顶部
对应 securityDefinitions
// @Security ApiKeyAuth
curl -H &quot;Authorization: Bearer TOKEN&quot; ...


@Deprecated
废弃标记
函数顶部
标记接口为过时
// @Deprecated
——



二、@Param 类型详细表（含请求示例）


类型
用途
数据类型
示例注解
API 请求示例



query
URL 参数
string&#x2F;int&#x2F;bool
@Param user_id query int true &quot;用户ID&quot;
/user?user_id=1


path
路径参数
string&#x2F;int
@Param id path int true &quot;用户ID&quot;
/user/1


header
请求头
string
@Param Authorization header string true &quot;Token&quot;
curl -H &quot;Authorization: Bearer abc&quot;


formData
表单数据
string&#x2F;int
@Param username formData string true &quot;用户名&quot;
curl -d &quot;username=Tom&quot;


formData(file)
上传文件
file
@Param file formData file true &quot;上传头像&quot;
curl -F &quot;file=@a.png&quot;


body
JSON 请求体
object
@Param data body User true &quot;用户信息&quot;
curl -X POST -d &#39;{&quot;name&quot;:&quot;Tom&quot;}&#39;


cookie
Cookie
string
@Param session cookie string false &quot;Session ID&quot;
Cookie: session=abcd


三、@Success &#x2F; @Failure 的 {类型} 参数@Success &#x2F; @Failure 的 {类型} 参数支持哪些格式？在 swaggo（github.com/swaggo/swag）中，@Success &#x2F; @Failure 注解的语法如下：
@Success &lt;HTTP状态码&gt; &#123;&lt;类型&gt;&#125; &lt;数据模型&gt; &quot;&lt;描述&gt;&quot;

其中 {&lt;类型&gt;} 是用于 描述响应数据结构的，常见取值如下：



{类型}
含义
适用场景
示例



object对象
返回的是结构体对象（JSON 对象）
最常见，接口返回 JSON 时通常是这个
// @Success 200 {object} models.LoginResp


array数组
返回的是数组（JSON 数组）
列表、分页等场景
// @Success 200 {array} models.UserResp


string字符串
返回纯文本字符串
错误提示、状态文本等
// @Failure 500 {string} string &quot;内部错误&quot;


integer整型
返回纯数值（整数）
简单的状态码或数量
// @Success 200 {integer} int &quot;成功状态码&quot;


number数字
返回浮点数
例如温度、坐标等
// @Success 200 {number} float64 &quot;测量值&quot;


boolean布尔
返回 true&#x2F;false 布尔值
状态检查类接口
// @Success 200 {boolean} bool &quot;是否在线&quot;


file文件
返回文件（二进制流）
文件下载接口
// @Success 200 {file} file &quot;导出的Excel文件&quot;



如果你的接口返回 JSON —— 应该用 {object} 或 {array}，而不是 {string}这是最关键的一点：

⚠️ 即使你的响应是 “JSON 字符串格式”，也应该写 {object}，因为 swagger 的目的不是展示原始传输内容，而是展示数据结构。

举例说明：
假设接口返回：
&#123;  &quot;code&quot;: 200,  &quot;msg&quot;: &quot;ok&quot;,  &quot;data&quot;: &#123;    &quot;user_id&quot;: 123,    &quot;name&quot;: &quot;Tom&quot;  &#125;&#125;

你应该写成：
// @Success 200 &#123;object&#125; models.CommonResp &quot;请求成功&quot;

而不是：
// ❌ 错误：这样 swagger 只会认为是纯文本// @Success 200 &#123;string&#125; string &quot;返回JSON字符串&quot;

因为 {string} 告诉 swagger：返回的是纯文本，而 swagger UI 就不会解析字段结构，也不会显示字段说明。

几个常见的写法对比表


返回内容
推荐写法
错误写法
说明



JSON 对象（结构体）
{object} models.Resp
{string} string
应描述结构体，而非字符串


JSON 数组
{array} models.Item
{string} string
swagger 会显示为数组元素类型


普通字符串
{string} string
{object}
简单文本响应


文件流
{file} file
{object}
特殊响应类型（下载）



完整例子// @Summary 登录接口// @Description 用户通过账号密码登录// @Tags 用户// @Accept json// @Produce json// @Param data body models.LoginReq true &quot;登录请求体&quot;// @Success 200 &#123;object&#125; models.LoginResp &quot;登录成功&quot;// @Failure 400 &#123;object&#125; models.ErrorResp &quot;请求错误&quot;// @Failure 500 &#123;string&#125; string &quot;服务器内部错误&quot;// @Router /api/v1/login [post]func Login(c *gin.Context) &#123;    // ...&#125;


小结一句话记住：


返回类型
对应 swagger 类型
备注



Go 结构体 &#x2F; map
{object}
最常用


Go 切片 &#x2F; 数组
{array}
✅


Go stringGo 字符串
{string}
✅


Go int &#x2F; int64Go int &#x2F; int64 整数 &#x2F; 整数 64
{integer}
✅


Go float32 &#x2F; float64
{number}
✅


Go boolGo 布尔
{boolean}
✅


文件下载
{file}
✅



三、结构体定义示例type User struct &#123;    ID   int    `json:&quot;id&quot; example:&quot;1&quot;`    Name string `json:&quot;name&quot; example:&quot;Tom&quot;`    Age  int    `json:&quot;age&quot; example:&quot;25&quot;`&#125;type ErrorResponse struct &#123;    Code int    `json:&quot;code&quot; example:&quot;400&quot;`    Msg  string `json:&quot;msg&quot; example:&quot;参数错误&quot;`&#125;


四、接口模板（全部注解示例）获取用户信息（GET + Path）// @Summary 获取用户信息// @Description 通过用户ID获取详细信息// @Tags 用户管理// @Accept json// @Produce json// @Param id path int true &quot;用户ID&quot;// @Param token header string false &quot;访问令牌&quot;// @Success 200 &#123;object&#125; User &quot;用户信息&quot;// @Failure 400 &#123;object&#125; ErrorResponse &quot;参数错误&quot;// @Failure 404 &#123;object&#125; ErrorResponse &quot;用户不存在&quot;// @Router /user/&#123;id&#125; [get]func GetUser(c *gin.Context) &#123; ... &#125;// 调用示例：// GET ./user/123// Header: Authorization: Bearer TOKEN


创建用户（POST + Body）// @Summary 创建新用户// @Description 使用 JSON 提交用户数据// @Tags 用户管理// @Accept json// @Produce json// @Param data body User true &quot;用户信息&quot;// @Success 201 &#123;object&#125; User &quot;创建成功&quot;// @Failure 400 &#123;object&#125; ErrorResponse &quot;参数错误&quot;// @Router /user [post]func CreateUser(c *gin.Context) &#123; ... &#125;// 调用示例：// POST ./user// Body: &#123;&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:25&#125;


用户登录（POST + FormData）// @Summary 用户登录// @Description 表单提交方式登录// @Tags 登录认证// @Accept x-www-form-urlencoded// @Produce json// @Param username formData string true &quot;用户名&quot;// @Param password formData string true &quot;密码&quot;// @Success 200 &#123;string&#125; string &quot;登录成功&quot;// @Failure 401 &#123;object&#125; ErrorResponse &quot;用户名或密码错误&quot;// @Router /login [post]func Login(c *gin.Context) &#123; ... &#125;// 调用示例：// POST ./login// Body: username=Tom&amp;password=123456


上传头像（POST + File）// @Summary 上传头像// @Description 上传用户头像文件// @Tags 文件上传// @Accept multipart/form-data// @Produce json// @Param user_id formData int true &quot;用户ID&quot;// @Param file formData file true &quot;头像文件&quot;// @Success 200 &#123;string&#125; string &quot;上传成功&quot;// @Failure 400 &#123;object&#125; ErrorResponse &quot;文件无效&quot;// @Router /upload/avatar [post]func UploadAvatar(c *gin.Context) &#123; ... &#125;// 调用示例：// curl -F &quot;user_id=1&quot; -F &quot;file=@avatar.png&quot; ./upload/avatar


带鉴权接口（Header + Security）// @Summary 获取当前用户资料// @Description 需要登录并携带 Bearer Token// @Tags 用户资料// @Security ApiKeyAuth// @Accept json// @Produce json// @Param Authorization header string true &quot;Bearer Token&quot;// @Success 200 &#123;object&#125; User &quot;用户信息&quot;// @Failure 401 &#123;object&#125; ErrorResponse &quot;未授权&quot;// @Router /profile [get]func GetProfile(c *gin.Context) &#123; ... &#125;// 调用示例：// GET ./profile// Header: Authorization: Bearer eyJhbGci...


Cookie 示例接口// @Summary 检查用户会话// @Description 根据 Cookie 中的 session 判断是否登录// @Tags 登录认证// @Accept json// @Produce json// @Param session cookie string false &quot;Session ID&quot;// @Success 200 &#123;string&#125; string &quot;Session 有效&quot;// @Failure 401 &#123;string&#125; string &quot;未登录&quot;// @Router /session/check [get]func CheckSession(c *gin.Context) &#123; ... &#125;// 调用示例：// GET ./session/check// Cookie: session=abc123


五、Swagger 安全认证定义示例（在 docs&#x2F;init.go 中）// @securityDefinitions.apikey ApiKeyAuth// @in header// @name Authorization


六、小结


常见场景
推荐注解组合
示例路径



GET 查询
@Param query/path + @Success
/user/{id}


POST 创建
@Param body + @Accept json
/user


表单提交
@Param formData + @Accept x-www-form-urlencoded
/login


文件上传
@Param file formData file + @Accept multipart/form-data
/upload/avatar


认证接口
@Security ApiKeyAuth + @Param header
/profile


]]></content>
      <categories>
        <category>技术</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>使用教程</tag>
        <tag>AI</tag>
        <tag>protected</tag>
        <tag>Golang</tag>
        <tag>三方库</tag>
        <tag>swag</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP8266相关资料</title>
    <url>/2023/06/07/ESP8266%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[其他资料ESP8266获取flash大小、ID、模式ESP.getResetReason() —— 获取上次复位原因ESP.getFreeHeap() —— 获取可用堆大小ESP.getChipId() —— 获取芯片idESP.getCoreVersion() —— 获取核心库版本ESP.getSdkVersion() —— 以字符形式返回SDK版本ESP.getCpuFreqMHz() —— 获取cpu运行频率ESP.getSketchSize() —— 获取当前固件大小ESP.getFreeSketchSpace() —— 获取当前剩余可用固件空间ESP.getSketchMD5() —— 返回当前固件的MD5的小写字符串ESP.getFlashChipId() —— 获取闪存芯片idESP.getFlashChipSize() —— 获取sdk得到的闪存芯片大小ESP.getFlashChipRealSize() —— 获取闪存芯片真正大小ESP.getFlashChipSpeed() —— 获取闪存芯片运行频率
系统软复位ESP.restart() —— 软复位系统
ESP.cpp/* Esp.cpp - ESP8266-specific APIs Copyright (c) 2015 Ivan Grokhotkov. All rights reserved. This file is part of the esp8266 core for Arduino environment. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA */#include &quot;Esp.h&quot;#include &quot;flash_utils.h&quot;#include &quot;eboot_command.h&quot;#include &lt;memory&gt;#include &quot;interrupts.h&quot;#include &quot;MD5Builder.h&quot;#include &quot;umm_malloc/umm_malloc.h&quot;#include &quot;cont.h&quot;#include &quot;flash_hal.h&quot;#include &quot;coredecls.h&quot;#include &quot;umm_malloc/umm_malloc.h&quot;#include &lt;pgmspace.h&gt;#include &quot;reboot_uart_dwnld.h&quot;extern &quot;C&quot; &#123;#include &quot;user_interface.h&quot;extern struct rst_info resetInfo;&#125;//#define DEBUG_SERIAL Serial#ifndef PUYA_SUPPORT  #define PUYA_SUPPORT 1#endif/** * User-defined Literals *  usage: * *   uint32_t = test = 10_MHz; // --&gt; 10000000 */unsigned long long operator&quot;&quot; _kHz(unsigned long long x) &#123;    return x * 1000;&#125;unsigned long long operator&quot;&quot; _MHz(unsigned long long x) &#123;    return x * 1000 * 1000;&#125;unsigned long long operator&quot;&quot; _GHz(unsigned long long x) &#123;    return x * 1000 * 1000 * 1000;&#125;unsigned long long operator&quot;&quot; _kBit(unsigned long long x) &#123;    return x * 1024;&#125;unsigned long long operator&quot;&quot; _MBit(unsigned long long x) &#123;    return x * 1024 * 1024;&#125;unsigned long long operator&quot;&quot; _GBit(unsigned long long x) &#123;    return x * 1024 * 1024 * 1024;&#125;unsigned long long operator&quot;&quot; _kB(unsigned long long x) &#123;    return x * 1024;&#125;unsigned long long operator&quot;&quot; _MB(unsigned long long x) &#123;    return x * 1024 * 1024;&#125;unsigned long long operator&quot;&quot; _GB(unsigned long long x) &#123;    return x * 1024 * 1024 * 1024;&#125;EspClass ESP;void EspClass::wdtEnable(uint32_t timeout_ms)&#123;    (void) timeout_ms;    /// This API can only be called if software watchdog is stopped    system_soft_wdt_restart();&#125;void EspClass::wdtEnable(WDTO_t timeout_ms)&#123;    wdtEnable((uint32_t) timeout_ms);&#125;void EspClass::wdtDisable(void)&#123;    /// Please don&#x27;t stop software watchdog too long (less than 6 seconds),    /// otherwise it will trigger hardware watchdog reset.    system_soft_wdt_stop();&#125;void EspClass::wdtFeed(void)&#123;    system_soft_wdt_feed();&#125;void EspClass::deepSleep(uint64_t time_us, WakeMode mode)&#123;    system_deep_sleep_set_option(static_cast&lt;int&gt;(mode));    system_deep_sleep(time_us);    esp_suspend();&#125;void EspClass::deepSleepInstant(uint64_t time_us, WakeMode mode)&#123;    system_deep_sleep_set_option(static_cast&lt;int&gt;(mode));    system_deep_sleep_instant(time_us);    esp_suspend();&#125;//this calculation was taken verbatim from the SDK api reference for SDK 2.1.0.//Note: system_rtc_clock_cali_proc() returns a uint32_t, even though system_deep_sleep() takes a uint64_t.uint64_t EspClass::deepSleepMax()&#123;  //cali*(2^31-1)/(2^12)  return (uint64_t)system_rtc_clock_cali_proc()*(0x80000000-1)/(0x1000);&#125;/*Layout of RTC Memory is as follows:Ref: Espressif doc 2C-ESP8266_Non_OS_SDK_API_Reference, section 3.3.23 (system_rtc_mem_write)|&lt;------system data (256 bytes)-------&gt;|&lt;-----------------user data (512 bytes)---------------&gt;|SDK function signature:bool	system_rtc_mem_read	(        uint32	des_addr,        void	*	src_addr,        uint32	save_size)The system data section can&#x27;t be used by the user, so:des_addr must be &gt;=64 (i.e.: 256/4) and &lt;192 (i.e.: 768/4)src_addr is a pointer to datasave_size is the number of bytes to writeFor the method interface:offset is the user block number (block size is 4 bytes) must be &gt;= 0 and &lt;128data is a pointer to data, 4-byte alignedsize is number of bytes in the block pointed to by dataSame for writeNote: If the Updater class is in play, e.g.: the application uses OTA, the ebootcommand will be stored into the first 128 bytes of user data, then it will beretrieved by eboot on boot. That means that user data present there will be lost.Ref:- discussion in PR #5330.- https://github.com/esp8266/esp8266-wiki/wiki/Memory-Map#memmory-mapped-io-registers- Arduino/bootloaders/eboot/eboot_command.h RTC_MEM definition*/bool EspClass::rtcUserMemoryRead(uint32_t offset, uint32_t *data, size_t size)&#123;    if (offset * 4 + size &gt; 512 || size == 0) &#123;        return false;    &#125; else &#123;        return system_rtc_mem_read(64 + offset, data, size);    &#125;&#125;bool EspClass::rtcUserMemoryWrite(uint32_t offset, uint32_t *data, size_t size)&#123;    if (offset * 4 + size &gt; 512 || size == 0) &#123;        return false;    &#125; else &#123;        return system_rtc_mem_write(64 + offset, data, size);    &#125;&#125;void EspClass::reset(void)&#123;    __real_system_restart_local();&#125;void EspClass::restart(void)&#123;    system_restart();    esp_suspend();&#125;[[noreturn]] void EspClass::rebootIntoUartDownloadMode()&#123;  wdtDisable();  /* disable hardware watchdog */  CLEAR_PERI_REG_MASK(PERIPHS_HW_WDT, 0x1);  esp8266RebootIntoUartDownloadMode();&#125;uint16_t EspClass::getVcc(void)&#123;    esp8266::InterruptLock lock;    (void)lock;    return system_get_vdd33();&#125;uint32_t EspClass::getFreeHeap(void)&#123;    return umm_free_heap_size_lw();&#125;#if defined(UMM_INFO)uint32_t EspClass::getMaxFreeBlockSize(void)&#123;    return umm_max_block_size();&#125;#endifuint32_t EspClass::getFreeContStack()&#123;    return cont_get_free_stack(g_pcont);&#125;void EspClass::resetFreeContStack()&#123;    cont_repaint_stack(g_pcont);&#125;uint32_t EspClass::getChipId(void)&#123;    return system_get_chip_id();&#125;extern &quot;C&quot; uint32_t core_version;extern &quot;C&quot; const char* core_release;String EspClass::getCoreVersion()&#123;    if (core_release != NULL) &#123;        return String(core_release);    &#125;    char buf[12];    snprintf(buf, sizeof(buf), &quot;%08x&quot;, core_version);    return String(buf);&#125;const char * EspClass::getSdkVersion(void)&#123;    return system_get_sdk_version();&#125;uint8_t EspClass::getBootVersion(void)&#123;    return system_get_boot_version();&#125;uint8_t EspClass::getBootMode(void)&#123;    return system_get_boot_mode();&#125;uint32_t EspClass::getFlashChipId(void)&#123;    static uint32_t flash_chip_id = 0;    if (flash_chip_id == 0) &#123;        flash_chip_id = spi_flash_get_id();    &#125;    return flash_chip_id;&#125;uint8_t EspClass::getFlashChipVendorId(void)&#123;    return (getFlashChipId() &amp; 0x000000ff);&#125;uint32_t EspClass::getFlashChipRealSize(void)&#123;    return (1 &lt;&lt; ((spi_flash_get_id() &gt;&gt; 16) &amp; 0xFF));&#125;uint32_t EspClass::getFlashChipSize(void)&#123;#if FLASH_MAP_SUPPORT    return getFlashChipRealSize();#else    uint32_t data;    uint8_t * bytes = (uint8_t *) &amp;data;    // read first 4 byte (magic byte + flash config)    if(spi_flash_read(0x0000, &amp;data, 4) == SPI_FLASH_RESULT_OK) &#123;        return magicFlashChipSize((bytes[3] &amp; 0xf0) &gt;&gt; 4);    &#125;    return 0;#endif&#125;uint32_t EspClass::getFlashChipSpeed(void)&#123;    uint32_t data;    uint8_t * bytes = (uint8_t *) &amp;data;    // read first 4 byte (magic byte + flash config)    if(spi_flash_read(0x0000, &amp;data, 4) == SPI_FLASH_RESULT_OK) &#123;        return magicFlashChipSpeed(bytes[3] &amp; 0x0F);    &#125;    return 0;&#125;FlashMode_t EspClass::getFlashChipMode(void)&#123;    FlashMode_t mode = FM_UNKNOWN;    uint32_t data;    uint8_t * bytes = (uint8_t *) &amp;data;    // read first 4 byte (magic byte + flash config)    if(spi_flash_read(0x0000, &amp;data, 4) == SPI_FLASH_RESULT_OK) &#123;        mode = magicFlashChipMode(bytes[2]);    &#125;    return mode;&#125;#if !FLASH_MAP_SUPPORTuint32_t EspClass::magicFlashChipSize(uint8_t byte) &#123;    switch(byte &amp; 0x0F) &#123;        case 0x0: // 4 Mbit (512KB)            return (512_kB);        case 0x1: // 2 MBit (256KB)            return (256_kB);        case 0x2: // 8 MBit (1MB)            return (1_MB);        case 0x3: // 16 MBit (2MB)            return (2_MB);        case 0x4: // 32 MBit (4MB)            return (4_MB);        case 0x8: // 64 MBit (8MB)            return (8_MB);        case 0x9: // 128 MBit (16MB)            return (16_MB);        default: // fail?            return 0;    &#125;&#125;#endifuint32_t EspClass::magicFlashChipSpeed(uint8_t byte) &#123;    switch(byte &amp; 0x0F) &#123;        case 0x0: // 40 MHz            return (40_MHz);        case 0x1: // 26 MHz            return (26_MHz);        case 0x2: // 20 MHz            return (20_MHz);        case 0xf: // 80 MHz            return (80_MHz);        default: // fail?            return 0;    &#125;&#125;FlashMode_t EspClass::magicFlashChipMode(uint8_t byte) &#123;    FlashMode_t mode = (FlashMode_t) byte;    if(mode &gt; FM_DOUT) &#123;        mode = FM_UNKNOWN;    &#125;    return mode;&#125;/** * Infos from *  http://www.wlxmall.com/images/stock_item/att/A1010004.pdf *  http://www.gigadevice.com/product-series/5.html?locale=en_US *  http://www.elinux.org/images/f/f5/Winbond-w25q32.pdf */uint32_t EspClass::getFlashChipSizeByChipId(void) &#123;    uint32_t chipId = getFlashChipId();    /**     * Chip ID     * 00 - always 00 (Chip ID use only 3 byte)     * 17 - ? looks like 2^xx is size in Byte ?     //todo: find docu to this     * 40 - ? may be Speed ?                        //todo: find docu to this     * C8 - manufacturer ID     */    switch(chipId) &#123;        // GigaDevice        case 0x1740C8: // GD25Q64B            return (8_MB);        case 0x1640C8: // GD25Q32B            return (4_MB);        case 0x1540C8: // GD25Q16B            return (2_MB);        case 0x1440C8: // GD25Q80            return (1_MB);        case 0x1340C8: // GD25Q40            return (512_kB);        case 0x1240C8: // GD25Q20            return (256_kB);        case 0x1140C8: // GD25Q10            return (128_kB);        case 0x1040C8: // GD25Q12            return (64_kB);        // Winbond        case 0x1840EF: // W25Q128            return (16_MB);        case 0x1640EF: // W25Q32            return (4_MB);        case 0x1540EF: // W25Q16            return (2_MB);        case 0x1440EF: // W25Q80            return (1_MB);        case 0x1340EF: // W25Q40            return (512_kB);        // BergMicro        case 0x1640E0: // BG25Q32            return (4_MB);        case 0x1540E0: // BG25Q16            return (2_MB);        case 0x1440E0: // BG25Q80            return (1_MB);        case 0x1340E0: // BG25Q40            return (512_kB);        // XMC - Wuhan Xinxin Semiconductor Manufacturing Corp        case 0x164020: // XM25QH32B            return (4_MB);        default:            return 0;    &#125;&#125;/** * check the Flash settings from IDE against the Real flash size * @param needsEquals (return only true it equals) * @return ok or not */bool EspClass::checkFlashConfig(bool needsEquals) &#123;    if(needsEquals) &#123;        if(getFlashChipRealSize() == getFlashChipSize()) &#123;            return true;        &#125;    &#125; else &#123;        if(getFlashChipRealSize() &gt;= getFlashChipSize()) &#123;            return true;        &#125;    &#125;    return false;&#125;// These are defined in the linker script, and filled in by the elf2bin.py utilextern &quot;C&quot; uint32_t __crc_len;extern &quot;C&quot; uint32_t __crc_val;bool EspClass::checkFlashCRC() &#123;    // Dummy CRC fill    uint32_t z[2];    z[0] = z[1] = 0;    uint32_t firstPart = (uintptr_t)&amp;__crc_len - 0x40200000; // How many bytes to check before the 1st CRC val    // Start the checksum    uint32_t crc = crc32((const void*)0x40200000, firstPart);    // Pretend the 2 words of crc/len are zero to be idempotent    crc = crc32(z, 8, crc);    // Finish the CRC calculation over the rest of flash    crc = crc32((const void*)(0x40200000 + firstPart + 8), __crc_len - (firstPart + 8), crc);    return crc == __crc_val;&#125;String EspClass::getResetReason(void) &#123;    const __FlashStringHelper* buff;    switch(resetInfo.reason) &#123;        // normal startup by power on        case REASON_DEFAULT_RST:      buff = F(&quot;Power On&quot;); break;        // hardware watch dog reset        case REASON_WDT_RST:          buff = F(&quot;Hardware Watchdog&quot;); break;        // exception reset, GPIO status won’t change        case REASON_EXCEPTION_RST:    buff = F(&quot;Exception&quot;); break;        // software watch dog reset, GPIO status won’t change        case REASON_SOFT_WDT_RST:     buff = F(&quot;Software Watchdog&quot;); break;        // software restart ,system_restart , GPIO status won’t change        case REASON_SOFT_RESTART:     buff = F(&quot;Software/System restart&quot;); break;        // wake up from deep-sleep        case REASON_DEEP_SLEEP_AWAKE: buff = F(&quot;Deep-Sleep Wake&quot;); break;        // // external system reset        case REASON_EXT_SYS_RST:      buff = F(&quot;External System&quot;); break;        default:                      buff = F(&quot;Unknown&quot;); break;    &#125;    return String(buff);&#125;String EspClass::getResetInfo(void) &#123;    if (resetInfo.reason &gt;= REASON_WDT_RST &amp;&amp; resetInfo.reason &lt;= REASON_SOFT_WDT_RST) &#123;        char buff[200];        sprintf_P(buff, PSTR(&quot;Fatal exception:%d flag:%d (%s) epc1:0x%08x epc2:0x%08x epc3:0x%08x excvaddr:0x%08x depc:0x%08x&quot;),            resetInfo.exccause, resetInfo.reason, getResetReason().c_str(),            resetInfo.epc1, resetInfo.epc2, resetInfo.epc3, resetInfo.excvaddr, resetInfo.depc);        return String(buff);    &#125;    return getResetReason();&#125;struct rst_info * EspClass::getResetInfoPtr(void) &#123;    return &amp;resetInfo;&#125;bool EspClass::eraseConfig(void) &#123;    const size_t cfgSize = 0x4000;    size_t cfgAddr = ESP.getFlashChipSize() - cfgSize;    for (size_t offset = 0; offset &lt; cfgSize; offset += SPI_FLASH_SEC_SIZE) &#123;        if (!flashEraseSector((cfgAddr + offset) / SPI_FLASH_SEC_SIZE)) &#123;            return false;        &#125;    &#125;    return true;&#125;uint8_t *EspClass::random(uint8_t *resultArray, const size_t outputSizeBytes)&#123;  /**   * The ESP32 Technical Reference Manual v4.1 chapter 24 has the following to say about random number generation (no information found for ESP8266):   *   * &quot;When used correctly, every 32-bit value the system reads from the RNG_DATA_REG register of the random number generator is a true random number.   * These true random numbers are generated based on the noise in the Wi-Fi/BT RF system.   * When Wi-Fi and BT are disabled, the random number generator will give out pseudo-random numbers.   *   * When Wi-Fi or BT is enabled, the random number generator is fed two bits of entropy every APB clock cycle (normally 80 MHz).   * Thus, for the maximum amount of entropy, it is advisable to read the random register at a maximum rate of 5 MHz.   * A data sample of 2 GB, read from the random number generator with Wi-Fi enabled and the random register read at 5 MHz,   * has been tested using the Dieharder Random Number Testsuite (version 3.31.1).   * The sample passed all tests.&quot;   *   * Since ESP32 is the sequal to ESP8266 it is unlikely that the ESP8266 is able to generate random numbers more quickly than 5 MHz when run at a 80 MHz frequency.   * A maximum random number frequency of 0.5 MHz is used here to leave some margin for possibly inferior components in the ESP8266.   * It should be noted that the ESP8266 has no Bluetooth functionality, so turning the WiFi off is likely to cause RANDOM_REG32 to use pseudo-random numbers.   *   * It is possible that yield() must be called on the ESP8266 to properly feed the hardware random number generator new bits, since there is only one processor core available.   * However, no feeding requirements are mentioned in the ESP32 documentation, and using yield() could possibly cause extended delays during number generation.   * Thus only delayMicroseconds() is used below.   */  constexpr uint8_t cooldownMicros = 2;  static uint32_t lastCalledMicros = micros() - cooldownMicros;  uint32_t randomNumber = 0;  for(size_t byteIndex = 0; byteIndex &lt; outputSizeBytes; ++byteIndex)  &#123;    if(byteIndex % 4 == 0)    &#123;      // Old random number has been used up (random number could be exactly 0, so we can&#x27;t check for that)      uint32_t timeSinceLastCall = micros() - lastCalledMicros;      if(timeSinceLastCall &lt; cooldownMicros)        delayMicroseconds(cooldownMicros - timeSinceLastCall);      randomNumber = RANDOM_REG32;      lastCalledMicros = micros();    &#125;    resultArray[byteIndex] = randomNumber;    randomNumber &gt;&gt;= 8;  &#125;  return resultArray;&#125;uint32_t EspClass::random()&#123;  union &#123; uint32_t b32; uint8_t b8[4]; &#125; result;  random(result.b8, 4);  return result.b32;&#125;uint32_t EspClass::getSketchSize() &#123;    static uint32_t result = 0;    if (result)        return result;    image_header_t image_header;    uint32_t pos = APP_START_OFFSET;    if (spi_flash_read(pos, (uint32_t*) &amp;image_header, sizeof(image_header)) != SPI_FLASH_RESULT_OK) &#123;        return 0;    &#125;    pos += sizeof(image_header);#ifdef DEBUG_SERIAL    DEBUG_SERIAL.printf(&quot;num_segments=%u\r\n&quot;, image_header.num_segments);#endif    for (uint32_t section_index = 0;        section_index &lt; image_header.num_segments;        ++section_index)    &#123;        section_header_t section_header = &#123;0, 0&#125;;        if (spi_flash_read(pos, (uint32_t*) &amp;section_header, sizeof(section_header)) != SPI_FLASH_RESULT_OK) &#123;            return 0;        &#125;        pos += sizeof(section_header);        pos += section_header.size;#ifdef DEBUG_SERIAL        DEBUG_SERIAL.printf(&quot;section=%u size=%u pos=%u\r\n&quot;, section_index, section_header.size, pos);#endif    &#125;    result = (pos + 16) &amp; ~15;    return result;&#125;uint32_t EspClass::getFreeSketchSpace() &#123;    uint32_t usedSize = getSketchSize();    // round one sector up    uint32_t freeSpaceStart = (usedSize + FLASH_SECTOR_SIZE - 1) &amp; (~(FLASH_SECTOR_SIZE - 1));    uint32_t freeSpaceEnd = (uint32_t)FS_start - 0x40200000;#ifdef DEBUG_SERIAL    DEBUG_SERIAL.printf(&quot;usedSize=%u freeSpaceStart=%u freeSpaceEnd=%u\r\n&quot;, usedSize, freeSpaceStart, freeSpaceEnd);#endif    return freeSpaceEnd - freeSpaceStart;&#125;bool EspClass::updateSketch(Stream&amp; in, uint32_t size, bool restartOnFail, bool restartOnSuccess) &#123;  if(!Update.begin(size))&#123;#ifdef DEBUG_SERIAL    DEBUG_SERIAL.print(&quot;Update &quot;);    Update.printError(DEBUG_SERIAL);#endif    if(restartOnFail) ESP.restart();    return false;  &#125;  if(Update.writeStream(in) != size)&#123;#ifdef DEBUG_SERIAL    DEBUG_SERIAL.print(&quot;Update &quot;);    Update.printError(DEBUG_SERIAL);#endif    if(restartOnFail) ESP.restart();    return false;  &#125;  if(!Update.end())&#123;#ifdef DEBUG_SERIAL    DEBUG_SERIAL.print(&quot;Update &quot;);    Update.printError(DEBUG_SERIAL);#endif    if(restartOnFail) ESP.restart();    return false;  &#125;#ifdef DEBUG_SERIAL    DEBUG_SERIAL.println(&quot;Update SUCCESS&quot;);#endif    if(restartOnSuccess) ESP.restart();    return true;&#125;static const int FLASH_INT_MASK = ((B10 &lt;&lt; 8) | B00111010);bool EspClass::flashEraseSector(uint32_t sector) &#123;    int rc = spi_flash_erase_sector(sector);    return rc == 0;&#125;// Adapted from the old version of `flash_hal_write()` (before 3.0.0), which was used for SPIFFS to allow// writing from both unaligned u8 buffers and to an unaligned offset on flash.// Updated version re-uses some of the code from RTOS, replacing individual methods for block &amp; page// writes with just a single one// https://github.com/espressif/ESP8266_RTOS_SDK/blob/master/components/spi_flash/src/spi_flash.c// (if necessary, we could follow the esp-idf code and introduce flash chip drivers controling more than just writing methods?)// This is a generic writer that does not cross page boundaries.// Offset, data address and size *must* be 4byte aligned.static SpiFlashOpResult spi_flash_write_page_break(uint32_t offset, uint32_t *data, size_t size) &#123;    static constexpr uint32_t PageSize &#123; FLASH_PAGE_SIZE &#125;;    size_t size_page_aligned = PageSize - (offset % PageSize);    // most common case, we don&#x27;t cross a page and simply write the data    if (size &lt; size_page_aligned) &#123;        return spi_flash_write(offset, data, size);    &#125;    // otherwise, write the initial part and continue writing breaking each page interval    SpiFlashOpResult result = SPI_FLASH_RESULT_ERR;    if ((result = spi_flash_write(offset, data, size_page_aligned)) != SPI_FLASH_RESULT_OK) &#123;        return result;    &#125;    const auto last_page = (size - size_page_aligned) / PageSize;    for (uint32_t page = 0; page &lt; last_page; ++page) &#123;        if ((result = spi_flash_write(offset + size_page_aligned, data + (size_page_aligned &gt;&gt; 2), PageSize)) != SPI_FLASH_RESULT_OK) &#123;            return result;        &#125;        size_page_aligned += PageSize;    &#125;    // finally, the remaining data    return spi_flash_write(offset + size_page_aligned, data + (size_page_aligned &gt;&gt; 2), size - size_page_aligned);&#125;#if PUYA_SUPPORT// Special wrapper for spi_flash_write *only for PUYA flash chips*// Already handles paging, could be used as a `spi_flash_write_page_break` replacementstatic SpiFlashOpResult spi_flash_write_puya(uint32_t offset, uint32_t *data, size_t size) &#123;    if (data == nullptr) &#123;      return SPI_FLASH_RESULT_ERR;    &#125;    if (size % 4 != 0) &#123;      return SPI_FLASH_RESULT_ERR;    &#125;    // PUYA flash chips need to read existing data, update in memory and write modified data again.    static uint32_t *flash_write_puya_buf = nullptr;    if (flash_write_puya_buf == nullptr) &#123;        flash_write_puya_buf = (uint32_t*) malloc(FLASH_PAGE_SIZE);        // No need to ever free this, since the flash chip will never change at runtime.        if (flash_write_puya_buf == nullptr) &#123;            // Memory could not be allocated.            return SPI_FLASH_RESULT_ERR;        &#125;    &#125;    SpiFlashOpResult rc = SPI_FLASH_RESULT_OK;    uint32_t* ptr = data;    size_t bytesLeft = size;    uint32_t pos = offset;    while (bytesLeft &gt; 0 &amp;&amp; rc == SPI_FLASH_RESULT_OK) &#123;        size_t bytesNow = bytesLeft;        if (bytesNow &gt; FLASH_PAGE_SIZE) &#123;            bytesNow = FLASH_PAGE_SIZE;            bytesLeft -= FLASH_PAGE_SIZE;        &#125; else &#123;            bytesLeft = 0;        &#125;        rc = spi_flash_read(pos, flash_write_puya_buf, bytesNow);        if (rc != SPI_FLASH_RESULT_OK) &#123;            return rc;        &#125;        for (size_t i = 0; i &lt; bytesNow / 4; ++i) &#123;            flash_write_puya_buf[i] &amp;= *ptr;            ++ptr;        &#125;        rc = spi_flash_write(pos, flash_write_puya_buf, bytesNow);        pos += bytesNow;    &#125;    return rc;&#125;#endifstatic constexpr size_t Alignment &#123; 4 &#125;;template &lt;typename T&gt;static T aligned(T value) &#123;    static constexpr auto Mask = Alignment - 1;    return (value + Mask) &amp; ~Mask;&#125;template &lt;typename T&gt;static T alignBefore(T value) &#123;    return aligned(value) - Alignment;&#125;static bool isAlignedAddress(uint32_t address) &#123;    return (address &amp; (Alignment - 1)) == 0;&#125;static bool isAlignedSize(size_t size) &#123;    return (size &amp; (Alignment - 1)) == 0;&#125;static bool isAlignedPointer(const uint8_t *ptr) &#123;    return isAlignedAddress(reinterpret_cast&lt;uint32_t&gt;(ptr));&#125;size_t EspClass::flashWriteUnalignedMemory(uint32_t address, const uint8_t *data, size_t size) &#123;    auto flash_write = [](uint32_t address, uint8_t *data, size_t size) &#123;        return spi_flash_write(address, reinterpret_cast&lt;uint32_t *&gt;(data), size) == SPI_FLASH_RESULT_OK;    &#125;;    auto flash_read = [](uint32_t address, uint8_t *data, size_t size) &#123;        return spi_flash_read(address, reinterpret_cast&lt;uint32_t *&gt;(data), size) == SPI_FLASH_RESULT_OK;    &#125;;    constexpr size_t BufferSize &#123; FLASH_PAGE_SIZE &#125;;    alignas(alignof(uint32_t)) uint8_t buf[BufferSize];    size_t written = 0;    if (!isAlignedAddress(address)) &#123;        auto before_address = alignBefore(address);        auto offset = address - before_address;        auto wlen = std::min(Alignment - offset, size);        if (!flash_read(before_address, &amp;buf[0], Alignment)) &#123;            return 0;        &#125;#if PUYA_SUPPORT        if (getFlashChipVendorId() == SPI_FLASH_VENDOR_PUYA) &#123;            for (size_t i = 0; i &lt; wlen ; ++i) &#123;                buf[offset + i] &amp;= data[i];            &#125;        &#125; else &#123;#endif            memcpy(&amp;buf[offset], data, wlen);#if PUYA_SUPPORT        &#125;#endif        if (!flash_write(before_address, &amp;buf[0], Alignment)) &#123;            return 0;        &#125;        address += wlen;        data += wlen;        written += wlen;        size -= wlen;    &#125;    while (size &gt; 0) &#123;        auto len = std::min(size, BufferSize);        auto wlen = aligned(len);        if (wlen != len) &#123;            auto partial = wlen - Alignment;            if (!flash_read(address + partial, &amp;buf[partial], Alignment)) &#123;                return written;            &#125;        &#125;        memcpy(&amp;buf[0], data, len);        if (!flashWrite(address, reinterpret_cast&lt;const uint32_t *&gt;(&amp;buf[0]), wlen)) &#123;            return written;        &#125;        address += len;        data += len;        written += len;        size -= len;    &#125;    return written;&#125;bool EspClass::flashWrite(uint32_t address, const uint32_t *data, size_t size) &#123;    SpiFlashOpResult result;#if PUYA_SUPPORT    if (getFlashChipVendorId() == SPI_FLASH_VENDOR_PUYA) &#123;        result = spi_flash_write_puya(address, const_cast&lt;uint32_t *&gt;(data), size);    &#125;    else#endif    &#123;        result = spi_flash_write_page_break(address, const_cast&lt;uint32_t *&gt;(data), size);    &#125;    return result == SPI_FLASH_RESULT_OK;&#125;bool EspClass::flashWrite(uint32_t address, const uint8_t *data, size_t size) &#123;    if (data &amp;&amp; size) &#123;        if (!isAlignedAddress(address)         || !isAlignedPointer(data)         || !isAlignedSize(size))        &#123;            return flashWriteUnalignedMemory(address, data, size) == size;        &#125;        return flashWrite(address, reinterpret_cast&lt;const uint32_t *&gt;(data), size);    &#125;    return false;&#125;bool EspClass::flashRead(uint32_t address, uint8_t *data, size_t size) &#123;    size_t sizeAligned = size &amp; ~3;    size_t currentOffset = 0;    if ((uintptr_t)data % 4 != 0) &#123;        constexpr size_t BufferSize &#123; FLASH_PAGE_SIZE / sizeof(uint32_t) &#125;;        alignas(alignof(uint32_t)) uint32_t buf[BufferSize];        size_t sizeLeft = sizeAligned;        while (sizeLeft) &#123;            size_t willCopy = std::min(sizeLeft, BufferSize);            // We read to our aligned buffer and then copy to data            if (!flashRead(address + currentOffset, &amp;buf[0], willCopy))            &#123;                return false;            &#125;            memcpy(data + currentOffset, &amp;buf[0], willCopy);            sizeLeft -= willCopy;            currentOffset += willCopy;        &#125;    &#125; else &#123;        // Pointer is properly aligned, so use aligned read        if (!flashRead(address, reinterpret_cast&lt;uint32_t *&gt;(data), sizeAligned)) &#123;            return false;        &#125;        currentOffset = sizeAligned;    &#125;    if (currentOffset &lt; size) &#123;        uint32_t tempData;        if (spi_flash_read(address + currentOffset, &amp;tempData, sizeof(tempData)) != SPI_FLASH_RESULT_OK) &#123;            return false;        &#125;        memcpy(data + currentOffset, &amp;tempData, size - currentOffset);    &#125;    return true;&#125;bool EspClass::flashRead(uint32_t address, uint32_t *data, size_t size) &#123;    if ((uintptr_t)data % 4 != 0 || size % 4 != 0) &#123;        return false;    &#125;    return (spi_flash_read(address, data, size) == SPI_FLASH_RESULT_OK);&#125;String EspClass::getSketchMD5()&#123;    static String result;    if (result.length()) &#123;        return result;    &#125;    uint32_t lengthLeft = getSketchSize();    const size_t bufSize = 512;    std::unique_ptr&lt;uint8_t[]&gt; buf(new (std::nothrow) uint8_t[bufSize]);    uint32_t offset = 0;    if(!buf.get()) &#123;        return emptyString;    &#125;    MD5Builder md5;    md5.begin();    while( lengthLeft &gt; 0) &#123;        size_t readBytes = (lengthLeft &lt; bufSize) ? lengthLeft : bufSize;        if (!flashRead(offset, reinterpret_cast&lt;uint32_t *&gt;(buf.get()), (readBytes + 3) &amp; ~3)) &#123;            return emptyString;        &#125;        md5.add(buf.get(), readBytes);        lengthLeft -= readBytes;        offset += readBytes;    &#125;    md5.calculate();    result = md5.toString();    return result;&#125;void EspClass::setExternalHeap()&#123;#ifdef UMM_HEAP_EXTERNAL    if (!umm_push_heap(UMM_HEAP_EXTERNAL)) &#123;        panic();    &#125;#endif&#125;void EspClass::setIramHeap()&#123;#ifdef UMM_HEAP_IRAM    if (!umm_push_heap(UMM_HEAP_IRAM)) &#123;        panic();    &#125;#endif&#125;void EspClass::setDramHeap()&#123;#if defined(UMM_HEAP_EXTERNAL) &amp;&amp; !defined(UMM_HEAP_IRAM)    if (!umm_push_heap(UMM_HEAP_DRAM)) &#123;        panic();    &#125;#elif defined(UMM_HEAP_IRAM)    if (!umm_push_heap(UMM_HEAP_DRAM)) &#123;        panic();    &#125;#endif&#125;void EspClass::resetHeap()&#123;#if defined(UMM_HEAP_EXTERNAL) &amp;&amp; !defined(UMM_HEAP_IRAM)    if (!umm_pop_heap()) &#123;        panic();    &#125;#elif defined(UMM_HEAP_IRAM)    if (!umm_pop_heap()) &#123;        panic();    &#125;#endif&#125;

]]></content>
      <categories>
        <category>ESP8266</category>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>ESP8266</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang validator 库</title>
    <url>/2025/10/06/Golang_validator/</url>
    <content><![CDATA[Golang validator 库概览第1章：为什么需要“数据检查员”？—— validator 库简介

（本章核心：用一个生活中的例子，让你明白为什么程序里需要一个专门检查数据的工具。）

第2章：上岗第一天！—— validator 的基本使用

（本章核心：手把手带你完成最简单的“检查”任务，让你对 validator 的工作流程有个整体印象。）

第3-1章：检查员的“规则手册”—— 常用验证标签（上）

（本章核心：学习最常用的检查规则，比如“不能为空”、“必须是邮箱格式”、“长度必须达标”等。）

第3-2章：检查员的“规则手册”—— 常用验证标签（下）

（本章核心：继续学习更多实用的检查规则，比如数字大小比较、多选一等，让你的检查能力变得更强。）

第4章：“检查不通过！”—— 如何看懂并处理错误信息

（本章核心：学习当数据不符合规则时，如何获取、理解并展示友好的错误提示。）

第5章：制定你自己的“特殊规则”—— 自定义验证函数

（本章核心：学习当 validator 自带规则不够用时，如何创建一条完全属于你自己的、独一无二的检查规则。）

第6章：经验之谈 —— 使用 validator 的注意事项与技巧

（本章核心：总结一些高手们在实际工作中会注意的小细节和最佳实践，帮你避免踩坑。）

第7章：实战演练 —— 用户注册信息校验

（本章核心：将前面学到的所有知识串联起来，完成一个完整的、贴近真实场景的练习。


第1章：为什么需要“数据检查员”？—— validator 库简介同学你好！在我们开始学习具体的代码之前，我想先问你一个问题：你有没有在网上注册账号或者填写表格的经历？
一定有吧！比如你在注册一个新邮箱时，如果密码栏你没填，系统会提示“密码不能为空”；如果你输入的邮箱地址不带@符号，它会说“请输入有效的邮箱格式”。
这个过程，其实就是 数据校验（Data Validation）。
生活中的“数据检查”我们来把这个场景具体化一下：
想象一下，你正在一个重要的网站上填写一份个人信息登记表。这张表上有几个栏目：

姓名: （必填）
年龄: （必填，且必须是 18 岁以上）
邮箱: （必填，且格式必须正确，比如 xxx@example.com）
个人简介: （选填，但如果填写，长度不能超过 200 字）

当你填完点击“提交”时，网站后台的程序就像一个一丝不苟的办事员。它会拿起你的表格，一项一项地检查：

“姓名填了吗？嗯，填了，通过。”
“年龄是 25，大于 18，通过。”
“邮箱是 my-email@qq.com，格式正确，通过。”
“个人简介写了 150 个字，没超过 200，通过。”

所有检查都通过后，这位“办事员”才会满意地盖上“合格”的章，把你的信息存入数据库。如果任何一项不合格，他就会把表格退给你，并告诉你哪里填错了。
程序世界的“数据检查”：又长又麻烦的 if-else在我们的 Go 程序里，我们当然也需要这样一位“办事员”。否则，用户提交了乱七八糟的数据，比如年龄填了-5岁，或者邮箱写成了“我的邮箱”，那我们的程序可能就会出问题，甚至崩溃。
在没有 validator 库之前，我们是怎么实现这个“办事员”的呢？通常是这样的：
假设我们用一个结构体 User 来表示用户提交的信息：
// User 结构体，用来存放用户注册信息type User struct &#123;    Name    string    Age     int    Email   string    Intro   string&#125;

为了检查一个 User 对象里的数据是否合格，我们可能会写一个充满 if-else 的函数：
import (    &quot;errors&quot;    &quot;strings&quot;)// 手动检查用户信息的函数func validateUserManually(user User) error &#123;    // 1. 检查姓名是不是空的    if user.Name == &quot;&quot; &#123;        return errors.New(&quot;姓名不能为空&quot;)    &#125;    // 2. 检查年龄是不是小于18岁    if user.Age &lt; 18 &#123;        return errors.New(&quot;年龄必须年满18周岁&quot;)    &#125;    // 3. 检查邮箱格式是不是正确 (一个非常简化的检查)    if !strings.Contains(user.Email, &quot;@&quot;) &#123;        return errors.New(&quot;请输入有效的邮箱格式&quot;)    &#125;        // 4. 检查个人简介长度    if len(user.Intro) &gt; 200 &#123;        return errors.New(&quot;个人简介不能超过200个字符&quot;)    &#125;    // 所有检查都通过了，返回 nil (表示没有错误)    return nil&#125;

思考一下： 上面这段代码有什么问题？
乍一看好像没问题，功能也实现了。但想象一下，如果 User 结构体有 30 个字段需要检查呢？那我们的 validateUserManually 函数是不是会变得超级长、超级复杂？每次新增或修改一个检查规则，都要小心翼翼地去改动那一大堆 if-else，非常容易出错，而且代码看起来一点也不优雅。
我们的“超级检查员”登场：validator 库为了解决这种“体力活”，社区里的大神们就开发了 validator 库。
validator 就像一个高度自动化、自带规则手册的“超级检查员”。我们不再需要手写一大堆 if-else，而是用一种更简单、更直观的方式，直接在我们的结构体上“贴标签”（在 Go 语言里这叫 Tag），告诉检查员每个字段需要遵守什么规则。
同样是上面的 User 结构体，用了 validator 之后会变成这样（先混个眼熟，下一章我们就来写）：
type User struct &#123;    Name    string `validate:&quot;required&quot;`    Age     int    `validate:&quot;required,gte=18&quot;`    Email   string `validate:&quot;required,email&quot;`    Intro   string `validate:&quot;lte=200&quot;`&#125;

你看，规则（required 表示必填，gte=18 表示大于等于18，email 表示邮箱格式）直接写在了字段的后面。代码是不是瞬间清爽了很多？
当我们把一个 User 对象交给 validator 时，它会自动读取这些“标签”，然后一次性帮我们把所有的规则都检查一遍。我们只需要处理最终的检查结果就行了。
validator 库的好处：

代码更整洁： 验证规则和数据结构定义在一起，一目了然。
开发效率高： 大量内置的常用规则（比如判空、邮箱、URL、IP地址等）开箱即用，不用自己重复造轮子。
易于维护： 修改规则只需要改动标签，而不用去动复杂的逻辑代码。
功能强大： 支持自定义规则，满足各种刁钻的检查需求。

本章小结好了，第一章的内容就是这么多。我们没有写任何实际能运行的代码，但我们搞清楚了一个最重要的问题：为什么需要 validator？

数据校验是什么？ 它是保证我们程序接收到的数据是正确、有效、符合预期的“守门员”。
为什么它很重要？ 它可以防止“垃圾数据”进入我们的系统，保证程序的稳定和安全。
传统方式的痛点？ 手写 if-else 来做校验，在字段多、规则复杂时，会变得冗长、混乱且难以维护。
validator 库的价值？ 它提供了一种声明式、自动化的方式来完成数据校验，让我们的代码更简洁、开发效率更高。

现在你已经知道了我们为什么需要这位“检查员”，下一章，我们就正式带它上岗，亲手写下第一段 validator 的代码，看看它到底是怎么工作的！
没问题，我们继续！
上一章我们理解了“为什么”，现在我们来解决“怎么做”的问题。准备好，我们要让这位“检查员”正式上岗了！

第2章：上岗第一天！—— validator 的基本使用在这一章，我们的目标非常简单：完成一次最基本的“数据检查”任务。我们会经历从“请人”（安装库）到“下达指令”（编写代码）再到“看报告”（检查结果）的全过程。
第一步：招聘检查员（安装 validator 库）在 Go 语言中，“招聘”一个外部库，就是用一个命令把它下载到你的电脑里。
打开你的终端（命令行工具），输入下面的命令然后回车：
go get github.com/go-playground/validator/v10

看到一些下载信息滚动，最后没有报红色的错误，就说明我们的“检查员”已经成功“入职”了！v10 是它的版本号，目前这是最稳定和推荐的版本。
第二步：给他一本“规则手册”（定义带标签的结构体）我们的检查员很厉害，但他不是神，他不知道你的数据需要遵守什么规则。所以，我们需要给他一本“规则手册”。在 validator 里，这本手册就是带有 validate 标签的结构体。
我们还是用上一章的 User 例子，但为了简单起见，这次我们只检查一个字段：Name。
package mainimport (    &quot;fmt&quot;    &quot;github.com/go-playground/validator/v10&quot;)// User 结构体，我们的“规则手册”type User struct &#123;    // 我们给 Name 字段贴上了一个叫 `validate` 的标签    // 标签里的 &quot;required&quot; 就是一条规则，意思是“这个字段是必填的，不能为空”    Name string `validate:&quot;required&quot;`    Age  int    // 这个字段没有标签，validator 会忽略它&#125;

看这里！ validate:&quot;required&quot; 就是我们给检查员下的指令。

validate：这是告诉 validator 库：“嘿，看这里，这个字段有检查规则！”
&quot;required&quot;：这就是具体的规则，意思是“必须有值”（不能是空字符串、0、nil 等）。

第三步：让他开始工作（创建实例并执行校验）“手册”准备好了，现在我们要创建一个“检查员”实例，然后把需要检查的数据交给他。
我们来看一个完整的、可以运行的例子：
package mainimport (    &quot;fmt&quot;    &quot;github.com/go-playground/validator/v10&quot;)// User 结构体，定义了验证规则type User struct &#123;    Name string `validate:&quot;required&quot;`    Age  int    // Age 字段没有规则，所以不会被检查&#125;func main() &#123;    // 1. 创建一个 validator “检查员”实例    validate := validator.New()    // --- 场景一：提供一份合格的数据 ---    fmt.Println(&quot;--- 场景一：合格数据 ---&quot;)    userOK := User&#123;        Name: &quot;Alice&quot;, // Name 字段有值        Age:  25,    &#125;    // 2. 把 userOK 交给检查员，让他按照结构体里的标签规则进行检查    err := validate.Struct(userOK)    // 3. 查看检查报告    if err != nil &#123;        // 如果 err 不是 nil，说明有错误，检查不通过！        fmt.Printf(&quot;数据校验失败, 错误: %v\n&quot;, err)    &#125; else &#123;        // 如果 err 是 nil，说明没错误，检查通过！        fmt.Println(&quot;数据校验成功!&quot;)    &#125;    fmt.Println(&quot;\n--- 场景二：提供一份不合格的数据 ---&quot;)    // --- 场景二：提供一份不合格的数据 ---    userFail := User&#123;        Name: &quot;&quot;, // Name 字段是空的，不符合 &quot;required&quot; 规则        Age:  30,    &#125;    // 2. 同样地，把 userFail 交给检查员检查    err = validate.Struct(userFail)    // 3. 查看检查报告    if err != nil &#123;        fmt.Printf(&quot;数据校验失败, 错误: %v\n&quot;, err)    &#125; else &#123;        fmt.Println(&quot;数据校验成功!&quot;)    &#125;&#125;

自己动手试试：把上面这段代码保存为一个 main.go 文件，然后在终端里进入到这个文件所在的目录，运行 go run main.go，看看会输出什么？
你应该会看到类似下面的结果：
--- 场景一：合格数据 ---数据校验成功!--- 场景二：不合格的数据 ---数据校验失败, 错误: Key: &#x27;User.Name&#x27; Error:Field validation for &#x27;Name&#x27; failed on the &#x27;required&#x27; tag

结果分析：

在场景一中，userOK 里的 Name 字段是 “Alice”，不为空，符合 required 规则，所以 validate.Struct() 返回的 err 是 nil，程序打印“数据校验成功!”。
在场景二中，userFail 里的 Name 字段是空字符串 &quot;&quot;，违反了 required 规则，所以 validate.Struct() 返回了一个具体的错误信息，程序打印了“数据校验失败”和那串有点难懂的错误。

想一想：那个错误信息 Key: &#39;User.Name&#39; Error:Field validation for &#39;Name&#39; failed on the &#39;required&#39; tag 是什么意思？虽然它看起来有点“程序员化”，但仔细读读，它其实在告诉我们：User 结构体的 Name 字段，在 required 这个规则上，验证失败了。（别担心这个错误信息太丑，我们在后面的章节会学习如何把它变得更友好！）
本章小结恭喜你！你已经成功让 validator 帮你完成了第一次检查工作。我们来回顾一下核心的三个步骤：

准备工作：通过 go get 安装库。
定义规则：在结构体的字段后面，使用 validate 标签来声明验证规则（例如 validate:&quot;required&quot;）。
执行校验：
通过 validator.New() 创建一个校验器实例。
调用 validate.Struct(你的结构体实例) 来执行校验。
检查返回的 error 是否为 nil，nil 代表成功，非 nil 代表失败。



现在你已经掌握了 validator 最基本的工作流程。但是，一个只会检查“不能为空”的检查员能力还远远不够。下一章，我们将为他的“规则手册”增加更多、更强大的规则，让他能应对更复杂的检查任务！
好的，我们马上进入第三章！
我们的检查员已经学会了最基本的一招——required（不能为空）。但这显然不够用，就像一个交通警察只会检查司机有没有系安全带一样，他还需要学会检查是否超速、是否闯红灯等等。
现在，我们就来给他的“规则手册”增加几页，让他学会更多强大的检查技巧！由于规则比较多，我们把它分成上下两部分来学习。

第3-1章：检查员的“规则手册”—— 常用验证标签（上）在这一章，我们主要学习一些最常用、最基础的验证规则，它们主要和长度、大小、格式有关。
规则一：关于“长度”的检查在网站注册时，我们经常看到“用户名长度必须在6到20个字符之间”这样的提示。这就是对长度的限制。

min=x：最小长度&#x2F;个数不能小于 x。
max=x：最大长度&#x2F;个数不能超过 x。
len=x：长度&#x2F;个数必须正好等于 x。

这些规则不仅能用在字符串上，还能用在数组、切片等有“长度”概念的东西上。
示例：
type User struct &#123;    Username string `validate:&quot;min=3,max=20&quot;` // 用户名长度在3到20之间    UserType string `validate:&quot;len=5&quot;`      // 用户类型必须是5个字符，比如 &quot;admin&quot;    Hobbies  []string `validate:&quot;max=5&quot;`    // 兴趣爱好最多只能选5个&#125;

重点：如何组合多个规则？
你可能已经注意到了 validate:&quot;min=3,max=20&quot;。如果一个字段需要同时满足多个规则怎么办？很简单，用逗号 , 把它们隔开就行了！ 这句话的意思就是，Username 字段必须同时满足最小长度为3 和 最大长度为20。
规则二：关于“数字大小”的检查这个规则非常直观，就是我们数学里学过的 &gt;、&gt;=、&lt;、&lt;=。

gt=x：必须 大于 x (Greater Than)
gte=x：必须 大于或等于 x (Greater Than or Equal)
lt=x：必须 小于 x (Less Than)
lte=x：必须 小于或等于 x (Less Than or Equal)

示例：
type Product struct &#123;    Price    float64 `validate:&quot;gt=0&quot;`  // 价格必须大于0    Quantity int     `validate:&quot;gte=1&quot;` // 库存数量必须大于等于1    Rating   int     `validate:&quot;min=1,max=5&quot;` // 评分在1到5星之间 (这里用min/max更合适)&#125;

思考一下： 为什么评分用 min=1,max=5 而不是 gte=1,lte=5？对于整数来说，这两种写法效果是一样的！min/max 通常用于描述长度、数量，而 gte/lte 用于描述数值的范围，但在这里它们可以通用。这说明规则的选择有时也很灵活。
规则三：关于“特定格式”的检查validator 最强大的功能之一，就是它内置了很多对通用格式的检查，我们不需要自己用复杂的方法去判断。

email：必须是有效的邮箱格式。
url：必须是有效的 URL 链接格式。
ip：必须是有效的 IP 地址格式（包括 IPv4 和 IPv6）。

示例：
type ContactInfo struct &#123;    Email   string `validate:&quot;required,email&quot;` // 必填，且必须是邮箱格式    Website string `validate:&quot;url&quot;`            // 选填，但如果填了，必须是URL格式&#125;

你看，检查一个复杂的邮箱格式，我们只需要写上 email 这五个字母就行了，是不是超级方便？
实战演练：组合使用好了，我们已经学了好几个新规则了。现在我们把它们组合起来，创建一个更真实的“用户注册表单”结构体，并进行校验。
package mainimport (    &quot;fmt&quot;    &quot;github.com/go-playground/validator/v10&quot;)// RegisterForm 定义了一个用户注册表单的结构和它的验证规则type RegisterForm struct &#123;    Username string   `validate:&quot;required,min=3,max=20&quot;`    Age      int      `validate:&quot;required,gte=18,lte=120&quot;`    Email    string   `validate:&quot;required,email&quot;`    Tags     []string `validate:&quot;max=5&quot;`&#125;func main() &#123;    validate := validator.New()    // --- 场景一：一份填写完美的表单 ---    fmt.Println(&quot;--- 场景一：完美表单 ---&quot;)    formOK := RegisterForm&#123;        Username: &quot;Jack&quot;,        Age:      25,        Email:    &quot;jack@example.com&quot;,        Tags:     []string&#123;&quot;music&quot;, &quot;sports&quot;&#125;,    &#125;    err := validate.Struct(formOK)    if err == nil &#123;        fmt.Println(&quot;表单校验通过！&quot;)    &#125;    // --- 场景二：一份问题百出的表单 ---    fmt.Println(&quot;\n--- 场景二：问题表单 ---&quot;)    formFail := RegisterForm&#123;        Username: &quot;Li&quot;, // 太短，不满足 min=3        Age:      16,   // 太小，不满足 gte=18        Email:    &quot;this-is-not-an-email&quot;, // 格式错误        Tags:     []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;&#125;, // 标签太多，不满足 max=5    &#125;    err = validate.Struct(formFail)    if err != nil &#123;        // 这里我们先简单打印错误，下一章会学习如何处理它        fmt.Printf(&quot;表单校验失败: %v\n&quot;, err)    &#125;&#125;

运行结果：
--- 场景一：完美表单 ---表单校验通过！--- 场景二：问题表单 ---表单校验失败: Key: &#x27;RegisterForm.Username&#x27; Error:Field validation for &#x27;Username&#x27; failed on the &#x27;min&#x27; tag

注意： 在场景二中，虽然表单有多个错误，但 validator 默认只要发现一个错误就会停止并返回。我们会在后面的章节学习如何一次性获取所有错误。目前你只需要知道，只要 err 不是 nil，就代表数据有问题。
本章小结太棒了！我们给检查员的“规则手册”增加了厚厚的一叠。来总结一下今天学到的核心规则：

组合规则：用逗号 , 分隔，表示“并且”的关系。
长度规则：
min=x (最小长度)
max=x (最大长度)
len=x (固定长度)


数值规则：
gt=x (大于 &gt;)
gte=x (大于等于 &gt;=)
lt=x (小于 &lt;)
lte=x (小于等于 &lt;=)


格式规则：
email (邮箱格式)
url (链接格式)
ip (IP地址格式)



这些规则已经能覆盖我们日常开发中 80% 的校验需求了。但这还不是全部！在下一节课，我们会学习更多高级和有趣的规则，比如“二选一”、“密码确认”等场景，让我们的检查员变得更加智能！
当然！我们的检查员已经掌握了基础技能，现在是时候让他学习一些更酷、更智能的“高级招式”了。

第3-2章：检查员的“规则手册”—— 常用验证标签（下）在上一节，我们学习了关于长度、数字和基本格式的规则。这一节，我们将接触一些更灵活、更强大的规则，它们能处理一些更复杂的场景，比如“多选一”或者“两个字段必须相等”。
规则四：多选一（从固定选项里选）想象一下，你有一个表示“订单状态”的字段，它的值只能是“待处理”、“处理中”或“已发货”这三种之一，绝不能是其他任何值。这时 oneof 规则就派上用场了。

oneof=value1 value2 value3：字段的值必须是后面列出的值之一。

请注意： 多个选项之间是用 空格 分隔的，而不是逗号！
示例：
type Order struct &#123;    Status string `validate:&quot;oneof=pending processing shipped&quot;` // 状态只能是这三个字符串之一    Color  string `validate:&quot;oneof=&#x27;red blue&#x27; &#x27;green yellow&#x27;&quot;` // 如果选项本身包含空格，可以用单引号 &#x27; &#x27; 括起来&#125;

规则五：字段间的比较（跨字段验证）这是个非常实用的功能！最经典的场景就是“注册时，确认密码必须和密码一致”。

eqfield=FieldName：当前字段的值必须 等于 FieldName 字段的值。
nefield=FieldName：当前字段的值必须 不等于 FieldName 字段的值。

示例：
type SignUpForm struct &#123;    Password        string `validate:&quot;required,min=8&quot;`    ConfirmPassword string `validate:&quot;required,eqfield=Password&quot;` // 此字段必须和 Password 字段的值相等        OldPassword     string `validate:&quot;required,min=8&quot;`    NewPassword     string `validate:&quot;required,min=8,nefield=OldPassword&quot;` // 新密码不能和旧密码一样&#125;

有了这个，我们再也不用在代码里手动写 if form.Password != form.ConfirmPassword 这样的逻辑了！
规则六：深入检查（校验切片或数组中的每一个元素）这个规则超级重要！假设你有一个订单，订单里包含一个商品列表（一个切片），你需要确保列表里的 每一个 商品都符合规定（比如商品名不能为空，价格必须大于0）。这时候就要用 dive 规则了。

dive：告诉检查员，“请深入到这个数组&#x2F;切片&#x2F;map 的内部，对里面的每一个元素都进行检查”。

dive 规则本身不带参数，它需要和内部元素的结构体标签配合使用。
示例：让我们来看一个完整的订单校验场景。
// 首先，定义列表里单个元素的规则type Item struct &#123;    SKU   string  `validate:&quot;required&quot;`       // 商品编号必填    Price float64 `validate:&quot;required,gt=0&quot;`  // 价格必填且大于0&#125;// 然后，在订单结构体里使用 divetype Order struct &#123;    OrderID string `validate:&quot;required&quot;`    // 1. required: 订单必须有商品，Items 列表不能为空    // 2. min=1: 列表里至少要有一个商品    // 3. dive: 请深入到 Items 列表内部，对每一个 Item 对象进行校验    //    (校验规则就是 Item 结构体上定义的那些标签)    Items   []Item `validate:&quot;required,min=1,dive&quot;`&#125;

思考一下： 如果 Items 字段的标签是 validate:&quot;required&quot; 而没有 dive，会发生什么？validator 只会检查 Items 这个切片本身是不是 nil，但它完全不会关心切片里面的 Item 对象的 SKU 和 Price 是否合法。dive 就像一个指令，告诉检查员：“打开这个包裹，检查里面的每个小盒子！”
实战演练：一个复杂的订单校验我们来把刚刚学的 dive 和 oneof 结合起来，写一个完整的例子。
package mainimport (    &quot;fmt&quot;    &quot;github.com/go-playground/validator/v10&quot;)type Item struct &#123;    Name  string `validate:&quot;required&quot;`    Price int    `validate:&quot;gt=0&quot;`&#125;type PurchaseOrder struct &#123;    UserEmail string `validate:&quot;required,email&quot;`    // 订单类型只能是 &#x27;online&#x27; 或 &#x27;store&#x27;    Type      string `validate:&quot;required,oneof=online store&quot;`    // 商品列表不能为空，且列表里的每个 Item 都要符合规则    Items     []Item `validate:&quot;required,min=1,dive&quot;`&#125;func main() &#123;    validate := validator.New()    // --- 场景一：一个合法的订单 ---    fmt.Println(&quot;--- 场景一：合法订单 ---&quot;)    orderOK := PurchaseOrder&#123;        UserEmail: &quot;customer@test.com&quot;,        Type:      &quot;online&quot;,        Items: []Item&#123;            &#123;Name: &quot;Laptop&quot;, Price: 1200&#125;,            &#123;Name: &quot;Mouse&quot;, Price: 25&#125;,        &#125;,    &#125;    err := validate.Struct(orderOK)    if err == nil &#123;        fmt.Println(&quot;订单校验通过！&quot;)    &#125;    // --- 场景二：一个非法的订单 (商品价格为0) ---    fmt.Println(&quot;\n--- 场景二：非法订单 ---&quot;)    orderFail := PurchaseOrder&#123;        UserEmail: &quot;customer@test.com&quot;,        Type:      &quot;store&quot;,        Items: []Item&#123;            &#123;Name: &quot;Keyboard&quot;, Price: 60&#125;,            &#123;Name: &quot;USB Cable&quot;, Price: 0&#125;, // 这里的 Price 不满足 &quot;gt=0&quot;        &#125;,    &#125;    err = validate.Struct(orderFail)    if err != nil &#123;        fmt.Printf(&quot;订单校验失败: %v\n&quot;, err)    &#125;&#125;

运行结果：
--- 场景一：合法订单 ---订单校验通过！--- 场景二：非法订单 ---订单校验失败: Key: &#x27;PurchaseOrder.Items[1].Price&#x27; Error:Field validation for &#x27;Price&#x27; failed on the &#x27;gt&#x27; tag

看到那个错误信息 PurchaseOrder.Items[1].Price 了吗？它非常精确地告诉我们：是 PurchaseOrder 结构体的 Items 字段里的、索引为 1 的那个元素的 Price 字段，在 gt 规则上校验失败了！这就是 dive 的强大之处。
本章小结我们的检查员又学会了三项强大的技能，变得更加全能了：

多选一：oneof=value1 value2 (注意是空格分隔)，确保值在一个给定的集合内。
跨字段比较：
eqfield=FieldName (等于另一个字段)
nefield=FieldName (不等于另一个字段)


深入校验：dive，用于校验切片&#x2F;数组&#x2F;map中的每一个元素，必须和元素自身的结构体标签配合使用。

到目前为止，你已经掌握了 validator 90% 以上的常用功能！你已经可以应对绝大多数的数据校验场景了。
不过，我们一直看到那个不太友好的错误信息。如果数据校验失败了，我们总不能把 Key: &#39;PurchaseOrder.Items[1].Price&#39; ... 这样一长串东西直接展示给用户看吧？下一章，我们就来解决这个问题，学习如何优雅地处理和翻译这些错误信息。
好的，我们继续！
到目前为止，我们的“检查员”工作完成得非常出色，总能准确地发现问题。但是，他写的“错误报告”实在是太“专业”了，就像医生写的病历一样，普通人（用户）根本看不懂。
Key: &#39;User.Name&#39; Error:Field validation for &#39;Name&#39; failed on the &#39;required&#39; tag
把这个给用户看，用户估计会一脸茫然。所以，这一章我们的任务就是学会当一个“翻译官”，把这些专业的错误报告翻译成用户能看懂的友好提示，比如“用户名不能为空”。

第4章：“检查不通过！”—— 如何看懂并处理错误信息当 validate.Struct() 返回的 error 不为 nil 时，就表示校验失败了。这个 error 对象里其实包含了非常丰富的错误信息，我们需要学会如何把它解析出来。
第一步：拆开“错误”这个大包裹validator 返回的错误不是一个普通的 error，它是一个特殊类型 validator.ValidationErrors。我们可以把它想象成一个装满了“具体错误项”的包裹。我们需要先把它从通用的 error 类型里“拆”出来。
这在 Go 语言里叫做 类型断言。你可以这么理解：我们拿到一个盒子（error），我们猜测（或者说我们确定）里面装的是苹果（validator.ValidationErrors），于是我们就尝试把它当成苹果拿出来。
err := validate.Struct(someStruct)if err != nil &#123;    // 这里进行类型断言    validationErrors, ok := err.(validator.ValidationErrors)    if !ok &#123;        // 如果 ok 是 false，说明这不是一个校验错误，可能是别的意外，直接打印        fmt.Println(&quot;An unexpected error:&quot;, err)        return    &#125;    // 如果 ok 是 true，说明类型断言成功！    // validationErrors 就是我们想要的、包含了所有校验失败信息的对象    fmt.Println(&quot;恭喜，我们成功拆开了错误包裹！&quot;)    // 接下来就可以处理 validationErrors 了&#125;

第二步：遍历每一个“错误项”一个表单提交过来，可能同时有好几个字段都不合格（比如用户名太短，并且邮箱格式也不对）。validationErrors 其实是一个切片（可以理解为列表），里面装着每一个字段的具体错误信息。所以，我们可以用一个 for 循环来遍历它。
里面的每一项都是一个 validator.FieldError 对象，它包含了关于单个字段校验失败的所有细节。
我们来看一个 FieldError 包含了哪些有用的信息（我们只挑最重要的几个）：

.Field(): 返回字段的 名称 (比如 Name, Age)。
.Tag(): 返回导致失败的那个 规则标签 (比如 required, min, email)。
.Value(): 返回导致失败的那个 不合法的值 (比如空字符串 &quot;&quot;，不合法的邮箱地址 abcde)。
.Param(): 返回规则标签的 参数 (比如规则是 min=6，那 .Param() 返回的就是 6)。

示例：把错误信息“说人话”
结合上面的知识，我们来写一个例子，把专业的错误报告翻译成对用户友好的提示。
package mainimport (    &quot;fmt&quot;    &quot;github.com/go-playground/validator/v10&quot;)type User struct &#123;    Username string `validate:&quot;required,min=3&quot;`    Email    string `validate:&quot;required,email&quot;`    Age      int    `validate:&quot;gte=18&quot;`&#125;func main() &#123;    validate := validator.New()    user := User&#123;        Username: &quot;a&quot;,    // 违反 min=3        Email:    &quot;test&quot;, // 违反 email        Age:      17,     // 违反 gte=18    &#125;    err := validate.Struct(user)    if err != nil &#123;        // 进行类型断言        validationErrors, ok := err.(validator.ValidationErrors)        if !ok &#123;            fmt.Println(err)            return        &#125;        // 遍历所有错误        for _, fieldError := range validationErrors &#123;            // 根据不同的字段和规则，生成不同的错误信息            switch fieldError.Field() &#123;            case &quot;Username&quot;:                if fieldError.Tag() == &quot;required&quot; &#123;                    fmt.Println(&quot;用户名是必填的！&quot;)                &#125; else if fieldError.Tag() == &quot;min&quot; &#123;                    // 使用 Param() 获取参数                    fmt.Printf(&quot;用户名长度不能小于 %s 个字符！\n&quot;, fieldError.Param())                &#125;            case &quot;Email&quot;:                if fieldError.Tag() == &quot;required&quot; &#123;                    fmt.Println(&quot;邮箱是必填的！&quot;)                &#125; else if fieldError.Tag() == &quot;email&quot; &#123;                    fmt.Println(&quot;邮箱格式不正确！&quot;)                &#125;            case &quot;Age&quot;:                if fieldError.Tag() == &quot;gte&quot; &#123;                    fmt.Printf(&quot;年龄必须大于或等于 %s 岁！\n&quot;, fieldError.Param())                &#125;            &#125;        &#125;    &#125;&#125;

运行结果：你会看到，这次的输出非常清晰友好！
用户名长度不能小于 3 个字符！邮箱格式不正确！年龄必须大于或等于 18 岁！

（注意：错误的顺序可能每次不一样，因为 validator 内部是并发校验的）
思考一下： 上面的 switch-case 和 if-else 是不是还是有点繁琐？如果结构体变得非常复杂，这里的代码也会变得很长。
是的，这只是最基础的错误处理方式。在真实的项目中，大家通常会结合“翻译库”（如 go-i18n）或者自己写一个“错误消息映射表”（map），来把 fieldError.Tag() 自动映射成对应的错误消息，这样代码会更优雅。但原理都是一样的：遍历 validationErrors，获取每一个 FieldError，然后根据它的 .Field() 和 .Tag() 来生成消息。
本章小结这一章是 validator 从“能用”到“好用”的关键一步。我们学会了如何处理它返回的错误：

核心概念：校验失败返回的 error 实际上是 validator.ValidationErrors 类型，它是一个包含了所有错误详情的集合。
关键步骤：
使用 类型断言 err.(validator.ValidationErrors) 来拆开错误包裹。
使用 for 循环 遍历 validationErrors 切片。


信息提取：在循环中，从 FieldError 对象中提取关键信息：
.Field() 获取字段名。
.Tag() 获取失败的规则。
.Param() 获取规则的参数。


最终目的：根据提取出的信息，组合成用户能看懂的、友好的错误提示。

现在，你不仅能让检查员发现问题，还能让他用清晰的语言把问题报告出来。这已经非常接近一个专业的开发者了！
不过，如果检查员自带的“规则手册”里没有我们想要的规则怎么办？比如，我想检查一个字段“必须是有效的中国手机号码”，validator 可没有内置这个规则。别担心，下一章，我们就来学习终极技巧：给他编写一本属于我们自己的“独家规则手册”！
第5章：制定你自己的“特殊规则”—— 自定义验证函数这一章，我们将学习 validator 的终极技巧：创建并注册一个我们自己写的验证函数。这让 validator 的能力可以无限扩展，去适应任何奇特的业务需求。
这听起来可能有点复杂，但其实是一个非常清晰的三步流程：

编写规则：写一个符合 validator 要求的函数。
登记规则：把我们写的函数告诉 validator 实例，并给它起一个名字（也就是标签名）。
使用规则：像使用 required 一样，在结构体里使用我们自己起的名字。

第一步：编写规则（定义一个验证函数）一个自定义验证函数有固定的格式，就像填表一样，你必须按照它的模板来写：
func(fl validator.FieldLevel) bool


它必须是一个函数。
它只接收一个参数，类型是 validator.FieldLevel。
它必须返回一个 bool 类型的值 (true 表示验证通过，false 表示验证失败)。

validator.FieldLevel 是什么？你可以把它想象成检查员在检查某个具体字段时，拿到的“工作台”。这个工作台上放着关于这个字段的所有信息，比如它的值、它的类型、它的名字等等。
我们最常用的就是通过 fl.Field().String() 来获取这个字段 作为字符串的值。
示例：创建一个检查“手机号”的函数我们来写一个函数，规则是：手机号必须是 11 位，并且以 ‘1’ 开头。（这是一个简化的规则，真实的手机号校验会更复杂，通常使用正则表达式，但原理是相通的）。
import (    &quot;github.com/go-playground/validator/v10&quot;    &quot;strings&quot;    &quot;unicode/utf8&quot;)// isValidMobile 是我们的自定义验证函数func isValidMobile(fl validator.FieldLevel) bool &#123;    // 1. 从 &quot;工作台&quot; (fl) 上获取字段的值，并转为字符串    mobile := fl.Field().String()    // 2. 编写我们的检查逻辑    // 规则1：长度必须是 11 位    if utf8.RuneCountInString(mobile) != 11 &#123;        return false // 不通过    &#125;    // 规则2：必须以 &#x27;1&#x27; 开头    if !strings.HasPrefix(mobile, &quot;1&quot;) &#123;        return false // 不通过    &#125;    // 3. 所有规则都满足了    return true // 通过！&#125;

第二步：登记规则（注册自定义函数）我们写好了规则，但检查员还不知道它的存在。我们需要在创建 validator 实例后，把它“登记”到检查员的规则手册里，并给它起一个响亮的名字（标签）。
这个登记动作通过 validate.RegisterValidation() 函数完成。
// 1. 创建检查员实例validate := validator.New()// 2. 登记我们的新规则// 第一个参数是我们要起的 &quot;标签名&quot;，比如叫 &quot;is-valid-mobile&quot;// 第二个参数是我们上面写的函数 isValidMobileerr := validate.RegisterValidation(&quot;is-valid-mobile&quot;, isValidMobile)if err != nil &#123;    // 如果注册失败，一般是标签名有问题，程序应该中止    panic(&quot;Failed to register validation&quot;)&#125;

现在，检查员的规则手册里就多了一页，标题是 is-valid-mobile，内容就是我们 isValidMobile 函数里的逻辑。
第三步：使用规则（在结构体里贴上新标签）一旦注册成功，我们就可以像使用任何内置标签一样，使用我们自己的 is-valid-mobile 标签了！
type UserProfile struct &#123;    Name   string `validate:&quot;required&quot;`    Mobile string `validate:&quot;required,is-valid-mobile&quot;` // 看！我们用上了自己的规则！&#125;

实战演练：完整的自定义校验流程下面是一个可以完整运行的例子，把上面三步串联了起来。
package mainimport (    &quot;fmt&quot;    &quot;github.com/go-playground/validator/v10&quot;    &quot;strings&quot;    &quot;unicode/utf8&quot;)// UserProfile 结构体使用了我们的自定义标签type UserProfile struct &#123;    Name   string `validate:&quot;required&quot;`    Mobile string `validate:&quot;required,is-valid-mobile&quot;`&#125;// 我们的自定义验证函数func isValidMobile(fl validator.FieldLevel) bool &#123;    mobile := fl.Field().String()    if utf8.RuneCountInString(mobile) != 11 &#123;        return false    &#125;    if !strings.HasPrefix(mobile, &quot;1&quot;) &#123;        return false    &#125;    return true&#125;func main() &#123;    // 1. 创建 validator 实例    validate := validator.New()    // 2. 注册我们的自定义函数    validate.RegisterValidation(&quot;is-valid-mobile&quot;, isValidMobile)    // --- 场景一：合法的手机号 ---    fmt.Println(&quot;--- 场景一：合法手机号 ---&quot;)    profileOK := UserProfile&#123;Name: &quot;Bob&quot;, Mobile: &quot;13800138000&quot;&#125;    err := validate.Struct(profileOK)    if err == nil &#123;        fmt.Println(&quot;校验通过！&quot;)    &#125;    // --- 场景二：非法的手机号 (太短) ---    fmt.Println(&quot;\n--- 场景二：非法手机号 ---&quot;)    profileFail := UserProfile&#123;Name: &quot;Charlie&quot;, Mobile: &quot;12345&quot;&#125;    err = validate.Struct(profileFail)    if err != nil &#123;        // 我们同样可以处理这个自定义规则的错误        validationErrors := err.(validator.ValidationErrors)        for _, fieldError := range validationErrors &#123;            if fieldError.Field() == &quot;Mobile&quot; &amp;&amp; fieldError.Tag() == &quot;is-valid-mobile&quot; &#123;                fmt.Println(&quot;手机号码格式不正确，必须是11位且以1开头！&quot;)            &#125;        &#125;    &#125;&#125;

运行结果：
--- 场景一：合法手机号 ---校验通过！--- 场景二：非法手机号 ---手机号码格式不正确，必须是11位且以1开头！

本章小结太厉害了！你已经掌握了 validator 最核心、最灵活的用法。我们来回顾一下自定义校验的“三部曲”：

定义函数：创建一个函数，签名必须是 func(fl validator.FieldLevel) bool，并在函数体内实现你的校验逻辑。
注册函数：使用 validate.RegisterValidation(&quot;your-tag-name&quot;, yourFunction) 将函数和标签名绑定，并注册到 validator 实例中。
使用标签：在你的结构体 validate 标签中，像使用内置标签一样使用你自定义的 your-tag-name。

有了这个能力，再也没有 validator 无法完成的校验任务了。从现在起，你可以为你的项目量身定做任何你需要的“检查规则”。
到这里，validator 的主要功能我们已经全部学完了。接下来的章节，我们会聊一些经验之谈和最佳实践，帮助你在真实项目中用得更稳、更好。最后再通过一个完整的实战练习来巩固所有知识。

第6章：经验之谈 —— 使用 validator 的注意事项与技巧这一章我们不学新功能，而是围绕“如何更好地使用”展开。
技巧一：校验器实例，全局单例就够了你在前面的例子中可能注意到了，我们每次都是在 main 函数里用 validator.New() 创建一个新的校验器实例。在小程序里这样做没问题，但在一个大的Web应用里，每次处理一个请求就创建一个新的实例，是一种浪费。
validator 的实例是 并发安全 的，这意味着在多个协程（goroutine，你可以简单理解为多个任务同时进行）中共享同一个实例是完全安全的。
最佳实践：在你的项目中，只创建一个全局的 validator 实例，然后在所有需要校验的地方重复使用它。如果需要注册自定义验证，也在程序启动时一次性完成注册。
package mainimport &quot;github.com/go-playground/validator/v10&quot;// 在包级别（全局）创建一个 Validator 实例var validate *validator.Validate// init 函数在包被导入时自动执行，是进行初始化的好地方func init() &#123;    validate = validator.New()    // 如果有自定义验证，也在这里一次性注册好    // validate.RegisterValidation(&quot;my-tag&quot;, myValidationFunc)&#125;// 你的业务函数可以直接使用这个全局的 validate 实例func HandleUserRegistration(user User) &#123;    err := validate.Struct(user)    if err != nil &#123;        // ... 处理错误    &#125;    // ...&#125;

这样做的好处是：

性能更好：避免了重复创建对象的开销。
管理方便：所有自定义规则的注册都集中在一个地方，清晰明了。

技巧二：校验单个变量，而不仅仅是结构体我们一直都在用 validate.Struct() 来校验整个结构体。但有时，你可能只想校验一个独立的变量。比如，你想确认某个函数接收的字符串参数 email 是不是合法的邮箱格式。
validator 提供了 validate.Var() 方法来满足这个需求。
示例：
package mainimport (    &quot;fmt&quot;    &quot;github.com/go-playground/validator/v10&quot;)func main() &#123;    validate := validator.New()    // --- 场景一：校验一个合法的邮箱字符串 ---    emailOK := &quot;test@example.com&quot;    // 第一个参数是变量本身，第二个参数是应用在它身上的规则    err := validate.Var(emailOK, &quot;required,email&quot;)    if err == nil &#123;        fmt.Println(&quot;emailOK 是一个合法的邮箱地址！&quot;)    &#125;    // --- 场景二：校验一个非法的 IP 地址字符串 ---    ipFail := &quot;127.0.0&quot;    err = validate.Var(ipFail, &quot;ip&quot;)    if err != nil &#123;        fmt.Printf(&quot;ipFail 不是一个合法的 IP 地址: %v\n&quot;, err)    &#125;&#125;

validate.Var() 非常适合用在那些不方便或不需要定义一个完整结构体的零散校验场景中。
技巧三：注意 required 与 omitempty 的区别这是一个新手很容易混淆的地方。

required：必须存在。字段不能是其类型的“零值”（比如 int 的 0，string 的 &quot;&quot;，指针或切片的 nil）。如果不存在，就报错。
omitempty：如果有值，才校验。omit 是忽略的意思。这个标签告诉 validator：“如果这个字段是零值，那就跳过它，别管它后面的其他规则了。但如果它有值，那就请继续检查后面的规则。”

一个经典的例子：更新用户信息假设用户只想更新他的昵称，提交的 JSON 数据可能只包含 nickname 字段，而 email 字段是空的。
type UserUpdateForm struct &#123;    // 如果 nickname 不为空，则必须满足最小长度为2    Nickname string `validate:&quot;omitempty,min=2&quot;`    // 如果 email 不为空，则必须是 email 格式    Email    string `validate:&quot;omitempty,email&quot;`&#125;// 场景一：用户只更新昵称form1 := UserUpdateForm&#123;Nickname: &quot;NewName&quot;&#125;// 校验会通过，因为 Email 是空字符串，`omitempty` 使 `email` 规则被跳过。// 场景二：用户更新了一个错误的邮箱form2 := UserUpdateForm&#123;Email: &quot;not-an-email&quot;&#125;// 校验会失败，因为 Email 不为空，所以 `email` 规则被触发且校验失败。// 场景三：用户啥也没填form3 := UserUpdateForm&#123;&#125;// 校验会通过，因为两个字段都是空，所有规则都被 `omitempty` 跳过了。

记住这个组合：omitempty 经常和其它规则一起使用，用于“可选字段”的校验，非常实用！
技巧四：校验嵌套结构体如果你的结构体里包含了另一个结构体，validator 默认是不会自动深入进去校验的。你需要明确告诉它。
和 dive 校验切片&#x2F;数组类似，对于嵌套的结构体，你只需要在字段上加上 dive 标签，或者简单地加上 required（或其他任何标签）来触发校验。更规范的方式是在嵌套的结构体字段上直接进行校验。
type Address struct &#123;    Street string `validate:&quot;required&quot;`    City   string `validate:&quot;required&quot;`&#125;type User struct &#123;    Name    string  `validate:&quot;required&quot;`    // Address 字段本身是必填的（不能是nil），    // 并且需要对 Address 内部的字段进行校验    Address Address `validate:&quot;required&quot;` &#125;

更正与修改:实际上，对于嵌套结构体，validator 默认就会递归地进行校验。你只需要确保在外层结构体验证时，内层结构体的字段也已经定义了标签。上面的validate:&quot;required&quot;是针对Address这个结构体本身不能是零值，而它内部的Street和City的required标签会在校验User时被自动检查。
为了更清晰地表达“请深入校验”，通常可以直接写 validate:&quot;&quot; 配合内部的标签，或者如果该嵌套结构体本身是可选的指针类型，则可以使用dive。
type UserWithOptionalAddress struct &#123;    Name    string   `validate:&quot;required&quot;`    // 如果 Address 字段存在（不是nil），则深入校验其内部    Address *Address `validate:&quot;omitempty,dive&quot;`&#125;


对于struct类型，validator会自动深入。
对于*struct（指针）、[]struct（切片）等，使用dive来告诉校验器需要深入检查。

本章小结这一章我们没有学习新标签，而是修炼了“内功”，让使用 validator 的方式更加地道和高效：

全局单例：整个应用共享一个 validator 实例，在 init 函数中初始化和注册规则。
校验单个变量：使用 validate.Var() 来校验零散的变量。
可选字段校验：omitempty 是处理“非必填但有值时需满足规则”场景的利器。
嵌套结构体：对于指针、切片、数组或 map 里的结构体，记得使用 dive 来进行深度校验。

掌握了这些技巧，你就可以自信地在任何规模的项目中使用 validator 库了。理论学习已经足够，下一章，我们将把目前学到的所有知识融会贯通，完成一个最终的实战演练！
好的，激动人心的时刻到了！
我们已经学习了 validator 的方方面面，从基础概念到高级技巧。现在是时候把所有知识碎片拼接到一起，像在真实项目中那样，完成一个完整的、有挑战性的任务了。

第7章：实战演练 —— 用户注册信息校验演练目标：我们要创建一个用户注册的后端校验逻辑。这个逻辑需要能够接收一个模拟的用户注册表单，并使用 validator 对其进行全面的校验。最后，将专业的校验错误翻译成对用户友好的提示信息列表。
需求清单：

用户名 (Username):
必填。
长度在 4 到 20 个字符之间。
不能包含 “admin” 这个词（这是个自定义规则！）。


密码 (Password):
必填。
长度至少为 8 个字符。


确认密码 (ConfirmPassword):
必填。
必须和 Password 字段的值一致。


邮箱 (Email):
必填。
必须是有效的邮箱格式。


年龄 (Age):
非必填。
但如果填写了，必须年满 18 周岁。


兴趣爱好 (Hobbies):
非必填。
但如果填写了，最多只能选择 5 个。
每个兴趣爱好的字符串本身不能为空（深入校验！）。



错误处理要求：将所有校验失败的信息收集起来，格式化成一个清晰的 map[string]string，其中 key 是字段名，value 是友好的错误提示。
好了，需求明确，我们开始动手吧！
第一步：定义结构体和自定义验证函数根据需求清单，我们需要先设计我们的 RegisterForm 结构体，并为 “不能包含 admin” 这个特殊需求编写一个自定义验证函数。
package mainimport (	&quot;fmt&quot;	&quot;github.com/go-playground/validator/v10&quot;	&quot;strings&quot;)// 1. 定义我们的注册表单结构体，并贴上所有需要的标签type RegisterForm struct &#123;	Username        string   `validate:&quot;required,min=4,max=20,no-admin&quot;`	Password        string   `validate:&quot;required,min=8&quot;`	ConfirmPassword string   `validate:&quot;required,eqfield=Password&quot;`	Email           string   `validate:&quot;required,email&quot;`	Age             int      `validate:&quot;omitempty,gte=18&quot;`	Hobbies         []string `validate:&quot;omitempty,max=5,dive,required&quot;`&#125;// 2. 编写自定义验证函数 `noAdmin`func noAdmin(fl validator.FieldLevel) bool &#123;	// 判断字段值（转为小写后）是否包含 &quot;admin&quot;	return !strings.Contains(strings.ToLower(fl.Field().String()), &quot;admin&quot;)&#125;

代码解析：

Username: 我们用了一个自定义标签 no-admin，准备稍后注册它。
Age: 使用 omitempty,gte=18，完美实现了“可选但填了就要大于等于18”的需求。
Hobbies: omitempty 表示整个爱好列表可以不填。max=5 限制列表长度。dive 表示要深入列表内部。最后的 required 是应用在 dive 之后的，意思是列表里的 每个字符串 都不能为空。

第二步：初始化校验器并注册自定义规则我们遵循最佳实践，把校验器和自定义规则的注册放在一起。
// 在这个文件中，我们直接在 main 函数里初始化// 在真实项目中，这部分代码应该在程序的初始化阶段（如 init 函数）func setupValidator() *validator.Validate &#123;	validate := validator.New()	// 注册 &quot;no-admin&quot; 标签对应的验证函数	err := validate.RegisterValidation(&quot;no-admin&quot;, noAdmin)	if err != nil &#123;		panic(&quot;Failed to register custom validation&quot;)	&#125;	return validate&#125;

第三步：编写校验和错误翻译的核心逻辑这是本次实战的核心。我们将创建一个函数，它接收一个 RegisterForm，返回一个 map 形式的错误信息。
// translateErrors 函数负责执行校验并翻译错误func translateErrors(validate *validator.Validate, form interface&#123;&#125;) map[string]string &#123;	err := validate.Struct(form)	if err == nil &#123;		return nil // 如果没有错误，返回 nil	&#125;	// 类型断言，获取 ValidationErrors	validationErrors, ok := err.(validator.ValidationErrors)	if !ok &#123;		// 如果不是校验错误，返回一个通用错误		return map[string]string&#123;&quot;error&quot;: &quot;An unexpected error occurred&quot;&#125;	&#125;	// 创建一个 map 用于存放翻译后的错误信息	errorMap := make(map[string]string)	for _, fieldError := range validationErrors &#123;		// 使用 switch-case 为每个字段和规则生成友好的消息		field := fieldError.Field()		tag := fieldError.Tag()		switch field &#123;		case &quot;Username&quot;:			switch tag &#123;			case &quot;required&quot;:				errorMap[field] = &quot;用户名是必填项。&quot;			case &quot;min&quot;:				errorMap[field] = &quot;用户名长度不能少于4个字符。&quot;			case &quot;max&quot;:				errorMap[field] = &quot;用户名长度不能超过20个字符。&quot;			case &quot;no-admin&quot;:				errorMap[field] = &quot;用户名不能包含 &#x27;admin&#x27;。&quot;			&#125;		case &quot;Password&quot;:			if tag == &quot;min&quot; &#123;				errorMap[field] = &quot;密码长度不能少于8个字符。&quot;			&#125;		case &quot;ConfirmPassword&quot;:			if tag == &quot;eqfield&quot; &#123;				errorMap[field] = &quot;两次输入的密码不一致。&quot;			&#125;		case &quot;Email&quot;:			if tag == &quot;email&quot; &#123;				errorMap[field] = &quot;请输入有效的邮箱地址。&quot;			&#125;		case &quot;Age&quot;:			if tag == &quot;gte&quot; &#123;				errorMap[field] = &quot;必须年满18周岁。&quot;			&#125;		case &quot;Hobbies&quot;:			if tag == &quot;max&quot; &#123;				errorMap[field] = &quot;最多只能选择5个兴趣爱好。&quot;			&#125; else if tag == &quot;required&quot; &#123;				// 这个 required 是 dive 之后的，说明是列表内的元素有问题				errorMap[field] = &quot;兴趣爱好不能为空字符串。&quot;			&#125;		&#125;	&#125;	return errorMap&#125;

第四步：整合与测试现在，我们把所有部分组合在 main 函数里，并创建几个测试用例来看看我们的成果。
func main() &#123;	// 1. 初始化校验器	validate := setupValidator()	// --- 测试用例 1: 一个问题百出的表单 ---	fmt.Println(&quot;--- 测试用例 1: 问题表单 ---&quot;)	badForm := RegisterForm&#123;		Username:        &quot;adm&quot;,                  // 太短，且包含&#x27;adm&#x27;(我们的小写检查会发现) -&gt; 修正：太短		Password:        &quot;123&quot;,                  // 太短		ConfirmPassword: &quot;456&quot;,                  // 与密码不一致		Email:           &quot;test@&quot;,                // 格式错误		Age:             16,                     // 年龄太小		Hobbies:         []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;&#125;, // 太多爱好	&#125;	errors := translateErrors(validate, badForm)	if errors != nil &#123;		fmt.Println(&quot;校验失败，错误信息如下：&quot;)		for field, msg := range errors &#123;			fmt.Printf(&quot;- %s: %s\n&quot;, field, msg)		&#125;	&#125;	// --- 测试用例 2: 另一个问题表单，包含自定义规则失败 ---	fmt.Println(&quot;\n--- 测试用例 2: 用户名含 admin ---&quot;)	adminForm := RegisterForm&#123;		Username:        &quot;super-admin-user&quot;,		Password:        &quot;12345678&quot;,		ConfirmPassword: &quot;12345678&quot;,		Email:           &quot;admin@test.com&quot;,	&#125;	errors = translateErrors(validate, adminForm)	if errors != nil &#123;		fmt.Println(&quot;校验失败，错误信息如下：&quot;)		for field, msg := range errors &#123;			fmt.Printf(&quot;- %s: %s\n&quot;, field, msg)		&#125;	&#125;	// --- 测试用例 3: 一个完美的表单 ---	fmt.Println(&quot;\n--- 测试用例 3: 完美表单 ---&quot;)	goodForm := RegisterForm&#123;		Username:        &quot;gooduser&quot;,		Password:        &quot;password123&quot;,		ConfirmPassword: &quot;password123&quot;,		Email:           &quot;good@user.com&quot;,		Age:             25,		Hobbies:         []string&#123;&quot;coding&quot;, &quot;reading&quot;&#125;,	&#125;	errors = translateErrors(validate, goodForm)	if errors == nil &#123;		fmt.Println(&quot;表单校验通过，可以进行注册！&quot;)	&#125;&#125;

预期运行结果：
--- 测试用例 1: 问题表单 ---校验失败，错误信息如下：- Username: 用户名长度不能少于4个字符。- Password: 密码长度不能少于8个字符。- ConfirmPassword: 两次输入的密码不一致。- Email: 请输入有效的邮箱地址。- Age: 必须年满18周岁。- Hobbies: 最多只能选择5个兴趣爱好。--- 测试用例 2: 用户名含 admin ---校验失败，错误信息如下：- Username: 用户名不能包含 &#x27;admin&#x27;。--- 测试用例 3: 完美表单 ---表单校验通过，可以进行注册！

本章总结与复习恭喜你！你已经成功地将我们前面六章学到的所有知识点融会贯通，解决了一个非常贴近真实项目的需求。
我们再回顾一下这个过程中用到的所有知识点：

基本使用：validator.New() 创建实例，validate.Struct() 执行校验。
常用标签：required, min, max, eqfield, email, gte。
高级标签：omitempty, dive。
自定义规则：自己写了 noAdmin 函数，并通过 RegisterValidation 注册了 no-admin 标签。
错误处理：通过类型断言获取 ValidationErrors，遍历它，并根据 Field() 和 Tag() 将错误信息翻译成用户友好的 map。
最佳实践：将校验器的创建和注册逻辑封装起来。

通过这个实战，你应该对 validator 库的强大和便捷有了非常深刻的理解。它几乎是所有 Go Web 开发和 API 开发项目中的必备工具。希望这份学习笔记能成为你未来项目开发中的好帮手！
课程到此结束，继续探索和练习吧！
附录Go Validator 常用校验标签总览（含用途说明）


作用描述
校验标签（可直接复制）
适用类型
含义说明
示例



判断是否等于指定值
eq
所有类型
等于指定值
eq=100 → 值必须等于100


判断是否不等于指定值
ne
所有类型
不等于指定值
ne=0 → 值不能等于0


判断是否大于指定值或长度
gt
数字、字符串、切片、数组
大于指定值&#x2F;长度
gt=10 → 数字&gt;10；长度&gt;10


判断是否大于等于指定值或长度
gte
数字、字符串、切片、数组
大于等于指定值&#x2F;长度
gte=1 → 值≥1


判断是否小于指定值或长度
lt
数字、字符串、切片、数组
小于指定值&#x2F;长度
lt=5 → 数字&lt;5；长度&lt;5


判断是否小于等于指定值或长度
lte
数字、字符串、切片、数组
小于等于指定值&#x2F;长度
lte=100 → 值≤100


判断长度是否等于指定值
len
字符串、切片、数组
长度等于指定值
len=6 → 长度必须为6


判断是否达到最小值或最小长度
min
数字、字符串、切片、数组
最小值&#x2F;长度下限
min=3 → 值或长度≥3


判断是否超过最大值或最大长度
max
数字、字符串、切片、数组
最大值&#x2F;长度上限
max=10 → 值或长度≤10


判断值是否在给定集合内
oneof
所有类型
值必须是给定选项之一
oneof=red green blue


强制字段必须有值
required
所有类型
不可为零值或空值
required


允许字段为空时跳过其他校验
omitempty
所有类型
为空则跳过后续校验
omitempty,gte=1,lte=10


校验邮箱格式
email
字符串
必须为合法邮箱
email


校验URL格式
url
字符串
必须为合法URL
url


校验URI格式
uri
字符串
必须为合法URI
uri


校验是否为IPv4或IPv6地址
ip
字符串
IPv4 或 IPv6 地址
ip


校验是否为IPv4地址
ipv4
字符串
IPv4 地址格式
ipv4


校验是否为IPv6地址
ipv6
字符串
IPv6 地址格式
ipv6


校验是否为合法UUID（任意版本）
uuid
字符串
UUID v1~v5
uuid


校验是否为UUID v4
uuid4
字符串
仅限 UUID v4
uuid4


校验时间格式
datetime
字符串
指定格式的时间字符串
datetime=2006-01-02


校验是否只包含字母
alpha
字符串
仅允许字母字符
alpha


校验是否只包含字母和数字
alphanum
字符串
仅允许字母和数字
alphanum


校验是否仅包含数字字符
numeric
字符串
仅数字（可字符串形式）
numeric


校验布尔格式
boolean
字符串
“true”&#x2F;“false”&#x2F;“1”&#x2F;“0”
boolean


校验是否包含指定子串
contains
字符串
必须包含指定内容
contains=@


校验是否不包含指定子串
excludes
字符串
不得包含指定内容
excludes=admin


校验是否以指定前缀开头
startswith
字符串
必须以指定前缀开头
startswith=ABC


校验是否以指定后缀结尾
endswith
字符串
必须以指定后缀结尾
endswith=.com


校验是否为Base64格式
base64
字符串
Base64 字符串
base64


校验是否为十六进制字符串
hexadecimal
字符串
十六进制格式
hexadecimal


校验是否为颜色的十六进制格式
hexcolor
字符串
#RRGGBB 或 #RGB
hexcolor


校验是否为RGB格式
rgb
字符串
rgb(255,255,255) 格式
rgb


校验是否为RGBA格式
rgba
字符串
rgba(255,255,255,1) 格式
rgba


校验是否不包含任意给定字符
excludesall
字符串
不允许出现指定字符集合
excludesall=!@#


校验是否不包含特定Unicode符号
excludesrune
字符串
不允许包含特定字符
excludesrune=你


校验路径是否为文件
file
文件路径
必须是存在的文件
file


校验路径是否为目录
dir
文件路径
必须是存在的目录
dir


比较当前字段是否等于另一个字段
eqfield
同结构体内字段
当前字段等于指定字段
eqfield=Password


比较当前字段是否不等于另一个字段
nefield
同结构体内字段
当前字段不等于指定字段
nefield=Username


比较当前字段是否大于另一个字段
gtfield
同结构体内字段
大于指定字段
gtfield=MinAge


比较当前字段是否大于等于另一个字段
gtefield
同结构体内字段
大于等于指定字段
gtefield=MinAge


比较当前字段是否小于另一个字段
ltfield
同结构体内字段
小于指定字段
ltfield=MaxAge


比较当前字段是否小于等于另一个字段
ltefield
同结构体内字段
小于等于指定字段
ltefield=MaxAge


正则匹配自定义规则
regexp
字符串
匹配指定正则表达式
regexp=^[A-Z]{3}[0-9]{4}$


条件必填：若其他字段存在
required_with
同结构体内字段
若指定字段存在，则本字段必填
required_with=Email


条件必填：若其他字段存在任意
required_with_all
同结构体内字段
若任意一个字段存在，则必填
required_with_all=Phone Email


条件必填：若其他字段不存在
required_without
同结构体内字段
若指定字段不存在，则必填
required_without=Email


条件排除：若某字段存在
excluded_with
同结构体内字段
若指定字段存在，则本字段不得存在
excluded_with=Password


切片唯一性校验
unique
切片、数组
所有元素必须唯一
unique


]]></content>
      <categories>
        <category>技术</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>使用教程</tag>
        <tag>AI</tag>
        <tag>protected</tag>
        <tag>Golang</tag>
        <tag>三方库</tag>
        <tag>validator</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML常用标签</title>
    <url>/2024/03/12/HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[
加入连接：
&lt;a href=&quot;所要连接的相关地址&quot;&gt;写上你想写的字&lt;/a&gt;

在新窗口打开连接：
&lt;a href=&quot;相关地址&quot; target=&quot;_blank&quot;&gt;写上要写的字&lt;/a&gt;

移动字体(走马灯)：
已被废弃
&lt;marquee&gt;写上你想写的字&lt;/marquee&gt;

背景音乐：
不是标准标签
&lt;bgsound=&quot;背景音乐地址&quot; loop=infinite&gt;

字体加粗：
&lt;b&gt;写上你想写的字&lt;/b&gt;

字体斜体：
&lt;i&gt;写上你想写的字&lt;/i&gt;

字体下划线:
&lt;u&gt;写上你想写的字&lt;/u&gt;

字体删除线:
&lt;s&gt;写上你想写的字&lt;/s&gt;

字体加大:
&lt;big&gt;写上你想写的字&lt;/big&gt;

字体控制大小：
&lt;h1&gt;写上你想写的字&lt;/h1&gt;

(其中字体大小可从h1-h5,h1最大，h5最小)11)

更改字体颜色：
&lt;font color=&quot;#value&quot;&gt;写上你想写的字&lt;/font&gt;

(其中value值在000000与ffffff(16位进制)之间

消除连接的下划线：
&lt;a href=&quot;相关地址&quot; &gt;写上你想写的字&lt;/a&gt;

贴音乐：
&lt;embed src=&quot;音乐地址&quot; width=&quot;宽度&quot; height=&quot;高度&quot; autostart=false&gt;

贴flash:
&lt;embed src=&quot;flash地址&quot; width=&quot;宽度&quot; height=&quot;高度&quot;&gt;

贴影视文件：
&lt;img dynsrc=&quot;文件地址&quot; width=&quot;宽度&quot; height=&quot;高度&quot; start=mouseover&gt;

换行：
&lt;br&gt;

段落：
&lt;p&gt;段落&lt;/p&gt;

原始文字样式：
&lt;pre&gt;正文&lt;/pre&gt;

背景：
&lt;body background=&quot;背景图片地址&quot;&gt;

HTML视频代码
&lt;video src=&quot;视频地址&quot; width=&quot;100%&quot; height=&quot;100%&quot; controls=&quot;controls&quot; autoplay=&quot;&quot; x5nativepanel=&quot;&quot;&gt;&lt;/video&gt;

]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 状态码列表</title>
    <url>/2024/02/28/HTTP%20%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[HTTP 状态码列表


分类
代码
名称
说明
常见场景举例



1xx (临时响应)
100
Continue (继续)
请求者应当继续提出请求。服务器已收到请求的第一部分，正在等待其余部分。
客户端在发送大型请求体之前，询问服务器是否愿意接受请求。



101
Switching Protocols (切换协议)
请求者已要求服务器切换协议，服务器已确认并准备切换。
WebSockets连接建立。



102
Processing (处理中)
WebDAV协议扩展，表示服务器已接收并正在处理请求，但尚未有响应可用。
WebDAV操作，如耗时较长的文件复制。


2xx (成功)
200
OK (成功)
服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。
网页加载、API请求成功。



201
Created (已创建)
请求成功并且服务器创建了新的资源。
用户注册、创建新文章。



202
Accepted (已接受)
服务器已接受请求，但尚未处理。
异步任务处理（如发送邮件、生成报告）。



203
Non-Authoritative Information (非授权信息)
服务器已成功处理了请求，但返回的信息可能来自另一来源（如缓存）。
代理服务器返回缓存数据。



204
No Content (无内容)
服务器成功处理了请求，但没有返回任何内容。
删除资源、成功更新但无需返回数据。



205
Reset Content (重置内容)
服务器成功处理了请求，但没有返回任何内容。要求用户代理（浏览器）重置文档视图。
提交表单后清空表单内容。



206
Partial Content (部分内容)
服务器成功处理了部分 GET 请求。
视频流播放、文件断点续传。



207
Multi-Status (多状态)
WebDAV协议扩展，在响应体中包含多个响应代码。
WebDAV批量操作。



208
Already Reported (已报告)
WebDAV协议扩展，在一个DAV集合中，已经报告过内部成员的状态，避免重复报告。
WebDAV深度查询。


3xx (重定向)
300
Multiple Choices (多种选择)
针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
提供不同格式的资源选择。



301
Moved Permanently (永久移动)
请求的网页已永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。
网站域名更改、URL结构调整。



302
Found (临时移动)
服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
临时页面重定向、负载均衡。



303
See Other (查看其他位置)
请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
POST请求成功后，重定向到结果页面。



304
Not Modified (未修改)
自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。
客户端使用缓存，通过If-Modified-Since或If-None-Match验证资源未修改。



305
Use Proxy (使用代理)
请求者只能使用代理访问请求的网页。
较少使用，存在安全隐患。



307
Temporary Redirect (临时重定向)
服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。与302类似，但强制客户端使用相同的HTTP方法。
临时维护页面重定向。



308
Permanent Redirect (永久重定向)
请求的网页已永久移动到新位置。与301类似，但强制客户端使用相同的HTTP方法。
域名迁移、API版本升级。


4xx (客户端错误)
400
Bad Request (错误请求)
服务器不理解请求的语法。
请求参数错误、请求体格式不正确。



401
Unauthorized (未授权)
请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。
访问受保护资源未提供或提供了错误的认证信息。



403
Forbidden (禁止)
服务器拒绝请求。客户端没有访问权限。
尝试访问无权访问的目录或文件。



404
Not Found (未找到)
服务器找不到请求的网页。
访问不存在的URL。



405
Method Not Allowed (方法禁用)
禁用请求中指定的方法。
对不支持GET的API接口使用了POST请求。



406
Not Acceptable (不接受)
无法使用请求的内容特性响应请求的网页。服务器根据请求的Accept头部无法生成客户端可接受的响应。
客户端只接受JSON，但服务器只能提供XML。



407
Proxy Authentication Required (需要代理授权)
此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
在需要代理认证的环境中。



408
Request Timeout (请求超时)
服务器等候请求时发生超时。
客户端在服务器设定的时间内未发送完整请求。



409
Conflict (冲突)
服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。
并发修改同一资源、资源已存在。



410
Gone (已删除)
如果请求的资源已永久删除，服务器就会返回此响应。
资源已下线且不会再恢复。



411
Length Required (需要有效长度)
服务器不接受不含有效内容长度标头字段的请求。
POST或PUT请求缺少Content-Length头部。



412
Precondition Failed (未满足前提条件)
服务器未满足请求者在请求中设置的其中一个前提条件。
乐观锁并发控制，If-Match条件失败。



413
Payload Too Large (请求实体过大)
服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
上传文件超出服务器配置的最大大小。



414
URI Too Long (请求的 URI 过长)
请求的 URI（通常为网址）过长，服务器无法处理。
包含过多查询参数的URL。



415
Unsupported Media Type (不支持的媒体类型)
请求的格式不受请求页面的支持。
POST请求的Content-Type与服务器期望的不符。



416
Range Not Satisfiable (请求范围不符合要求)
如果页面无法提供请求的范围，则服务器会返回此状态代码。
请求文件范围超出实际文件大小。



417
Expectation Failed (未满足期望值)
服务器未满足”期望”请求标头字段的要求。
Expect头部指示的期望条件未被满足。



421
Misdirected Request (请求被错误重定向)
请求被定向到无法产生响应的服务器。
HTTP&#x2F;2中，客户端向错误的服务器发送请求。



422
Unprocessable Entity (不可处理的实体)
请求格式正确，但由于语义错误而无法遵循。
API表单验证失败。



423
Locked (已锁定)
资源的访问被锁定。
WebDAV中，尝试修改被锁定的资源。



424
Failed Dependency (失败的依赖)
WebDAV协议扩展，表示由于前一个请求失败，此请求无法执行。
依赖于另一个失败的操作。



426
Upgrade Required (需要升级)
客户端应该切换到TLS&#x2F;1.0等协议。
服务器要求客户端升级连接协议。



428
Precondition Required (需要前提条件)
服务器要求在请求中包含条件头部（如If-Match或If-Unmodified-Since）。
强制客户端在更新资源时提供Etag。



429
Too Many Requests (请求过多)
用户在给定时间内发送了太多请求（频率限制）。
API限流。



431
Request Header Fields Too Large (请求头字段过大)
服务器不接受请求，因为一个或多个头部字段过大。
请求头部包含过多的Cookie或自定义头部。



451
Unavailable For Legal Reasons (因法律原因不可用)
服务器拒绝访问该资源，因为该资源因法律原因被审查。
受政府审查的网站内容。


5xx (服务器错误)
500
Internal Server Error (服务器内部错误)
服务器遇到错误，无法完成请求。
服务器代码异常、未捕获的错误。



501
Not Implemented (尚未实施)
服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。
访问了尚未实现的API端点。



502
Bad Gateway (错误网关)
服务器作为网关或代理，从上游服务器收到无效响应。
反向代理（如Nginx）与后端服务通信失败。



503
Service Unavailable (服务不可用)
服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。
服务器过载、维护模式。



504
Gateway Timeout (网关超时)
服务器作为网关或代理，但是没有及时从上游服务器收到请求。
反向代理等待后端服务响应超时。



505
HTTP Version Not Supported (HTTP 版本不受支持)
服务器不支持请求中所用的 HTTP 协议版本。
客户端使用了过时或不支持的HTTP版本。



506
Variant Also Negotiates (变体也协商)
服务器存在内部配置错误：它用于透明内容协商的透明代理本身被配置为参与协商。
较少见的服务器配置错误。



507
Insufficient Storage (存储空间不足)
WebDAV协议扩展，表示服务器无法存储完成请求所需的表示。
服务器磁盘空间不足。



508
Loop Detected (检测到循环)
WebDAV协议扩展，服务器在处理请求时检测到无限循环。
某些WebDAV操作中检测到循环依赖。



510
Not Extended (未扩展)
请求需要对服务器进行进一步的扩展才能实现。
客户端未能满足服务器的某个强制扩展。



511
Network Authentication Required (需要网络身份验证)
客户端需要进行网络身份验证才能获得访问权限。
公共Wi-Fi登录页面重定向。


]]></content>
      <categories>
        <category>HTTP</category>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>protected</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP2 特点</title>
    <url>/2023/11/05/HTTP2%E7%89%B9%E7%82%B9/</url>
    <content><![CDATA[HTTP2
HTTP&#x2F;2（超文本传输协议第2版，最初命名为HTTP 2.0），简称为h2（基于TLS&#x2F;1.2或以上版本的加密连接）或h2c（非加密连接）， HTTP&#x2F;2 是 HTTP 协议的第二个主要版本，用于在 Web 服务器和客户端之间传输数据。
HTTP&#x2F;2 是 HTTP 协议自 1999 年 HTTP 1.1 的改进版 RFC 发布后的首个更新，主要基于 SPDY 协议。
多数主流浏览器已经在 2015 年底支持了该协议。
HTTP&#x2F;2是一种网络协议，是HTTP&#x2F;1.1的升级版，由IETF在2015年发布。HTTP&#x2F;2旨在提高Web性能，减少延迟，增加安全性，使Web应用更加快速、高效和可靠。


HTTP&#x2F;2 特点下面是 HTTP&#x2F;2 的一些特点和改进之处：

多路复用：HTTP&#x2F;2 允许同时发送多个请求和响应，而不是像 HTTP&#x2F;1.1 一样只能一个一个地处理。这样可以减少延迟，提高效率，提高网络吞吐量。
二进制传输：HTTP&#x2F;2 使用二进制协议，与 HTTP&#x2F;1.1 使用的文本协议不同。二进制协议可以更快地解析，更有效地传输数据，减少了传输过程中的开销和延迟。
头部压缩：HTTP&#x2F;2 使用 HPACK 算法对 HTTP 头部进行压缩，减少了头部传输的数据量，从而减少了网络延迟。
服务器推送：HTTP&#x2F;2 支持服务器推送，允许服务器在客户端请求之前推送资源，以提高性能。
改进的安全性：HTTP&#x2F;2 默认使用 TLS（Transport Layer Security）加密传输数据，提高了安全性。
兼容 HTTP&#x2F;1.1：HTTP&#x2F;2 可以与 HTTP&#x2F;1.1 共存，服务器可以同时支持 HTTP&#x2F;1.1 和 HTTP&#x2F;2。如果客户端不支持 HTTP&#x2F;2，服务器可以回退到 HTTP&#x2F;1.1。

总的来说，HTTP&#x2F;2在性能、安全性和可用性方面都有显著的改进，可以使 Web 应用更加快速、高效和可靠。
对数据传输采用多路复用，让多个请求合并在同一 TCP 连接内，如下图所示：

HTTP&#x2F;2 减少网络延迟，提高浏览器的页面加载速度：

HTTP&#x2F;2 使用二进制格式来传输数据，而不是像 HTTP&#x2F;1.1 一样使用文本格式。这提高了效率并降低了数据传输的延迟。

HTTP&#x2F;2 使用头部压缩来减少传输数据的大小。这有助于减少网络带宽的使用量，并提高页面加载速度。

HTTP&#x2F;2 允许服务器在不被请求的情况下主动向客户端发送数据。这有助于减少请求延迟，并提高页面加载速度。

]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>HTTP</tag>
        <tag>HTTP2</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP content-type</title>
    <url>/2023/11/05/HTTP_content_type/</url>
    <content><![CDATA[HTTP content-typeContent-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些 PHP 网页点击的结果却是下载一个文件或一张图片的原因。
Content-Type 标头告诉客户端实际返回的内容的内容类型。
语法格式：
Content-Type: text/html; charset=utf-8Content-Type: multipart/form-data; boundary=something

实例：

常见的媒体格式类型如下：

text&#x2F;html ： HTML格式
text&#x2F;plain ：纯文本格式
text&#x2F;xml ： XML格式
image&#x2F;gif ：gif图片格式
image&#x2F;jpeg ：jpg图片格式
image&#x2F;png：png图片格式

以application开头的媒体格式类型：

application&#x2F;xhtml+xml ：XHTML格式
application&#x2F;xml： XML数据格式
application&#x2F;atom+xml ：Atom XML聚合格式
application&#x2F;json： JSON数据格式
application&#x2F;pdf：pdf格式
application&#x2F;msword ： Word文档格式
application&#x2F;octet-stream ： 二进制流数据（如常见的文件下载）
application&#x2F;x-www-form-urlencoded ： &lt;form encType&#x3D;””&gt;中默认的encType，form表单数据被编码为key&#x2F;value格式发送到服务器（表单默认的提交数据的格式）

另外一种常见的媒体格式是上传文件之时使用的：

multipart&#x2F;form-data ： 需要在表单中进行文件上传时，就需要使用该格式


HTTP content-type 对照表


文件扩展名
Content-Type(Mime-Type)
文件扩展名
Content-Type(Mime-Type)



.*（ 二进制流，不知道下载文件类型）
application&#x2F;octet-stream
.tif
image&#x2F;tiff


.001
application&#x2F;x-001
.301
application&#x2F;x-301


.323
text&#x2F;h323
.906
application&#x2F;x-906


.907
drawing&#x2F;907
.a11
application&#x2F;x-a11


.acp
audio&#x2F;x-mei-aac
.ai
application&#x2F;postscript


.aif
audio&#x2F;aiff
.aifc
audio&#x2F;aiff


.aiff
audio&#x2F;aiff
.anv
application&#x2F;x-anv


.asa
text&#x2F;asa
.asf
video&#x2F;x-ms-asf


.asp
text&#x2F;asp
.asx
video&#x2F;x-ms-asf


.au
audio&#x2F;basic
.avi
video&#x2F;avi


.awf
application&#x2F;vnd.adobe.workflow
.biz
text&#x2F;xml


.bmp
application&#x2F;x-bmp
.bot
application&#x2F;x-bot


.c4t
application&#x2F;x-c4t
.c90
application&#x2F;x-c90


.cal
application&#x2F;x-cals
.cat
application&#x2F;vnd.ms-pki.seccat


.cdf
application&#x2F;x-netcdf
.cdr
application&#x2F;x-cdr


.cel
application&#x2F;x-cel
.cer
application&#x2F;x-x509-ca-cert


.cg4
application&#x2F;x-g4
.cgm
application&#x2F;x-cgm


.cit
application&#x2F;x-cit
.class
java&#x2F;*


.cml
text&#x2F;xml
.cmp
application&#x2F;x-cmp


.cmx
application&#x2F;x-cmx
.cot
application&#x2F;x-cot


.crl
application&#x2F;pkix-crl
.crt
application&#x2F;x-x509-ca-cert


.csi
application&#x2F;x-csi
.css
text&#x2F;css


.cut
application&#x2F;x-cut
.dbf
application&#x2F;x-dbf


.dbm
application&#x2F;x-dbm
.dbx
application&#x2F;x-dbx


.dcd
text&#x2F;xml
.dcx
application&#x2F;x-dcx


.der
application&#x2F;x-x509-ca-cert
.dgn
application&#x2F;x-dgn


.dib
application&#x2F;x-dib
.dll
application&#x2F;x-msdownload


.doc
application&#x2F;msword
.dot
application&#x2F;msword


.drw
application&#x2F;x-drw
.dtd
text&#x2F;xml


.dwf
Model&#x2F;vnd.dwf
.dwf
application&#x2F;x-dwf


.dwg
application&#x2F;x-dwg
.dxb
application&#x2F;x-dxb


.dxf
application&#x2F;x-dxf
.edn
application&#x2F;vnd.adobe.edn


.emf
application&#x2F;x-emf
.eml
message&#x2F;rfc822


.ent
text&#x2F;xml
.epi
application&#x2F;x-epi


.eps
application&#x2F;x-ps
.eps
application&#x2F;postscript


.etd
application&#x2F;x-ebx
.exe
application&#x2F;x-msdownload


.fax
image&#x2F;fax
.fdf
application&#x2F;vnd.fdf


.fif
application&#x2F;fractals
.fo
text&#x2F;xml


.frm
application&#x2F;x-frm
.g4
application&#x2F;x-g4


.gbr
application&#x2F;x-gbr
.
application&#x2F;x-


.gif
image&#x2F;gif
.gl2
application&#x2F;x-gl2


.gp4
application&#x2F;x-gp4
.hgl
application&#x2F;x-hgl


.hmr
application&#x2F;x-hmr
.hpg
application&#x2F;x-hpgl


.hpl
application&#x2F;x-hpl
.hqx
application&#x2F;mac-binhex40


.hrf
application&#x2F;x-hrf
.hta
application&#x2F;hta


.htc
text&#x2F;x-component
.htm
text&#x2F;html


.html
text&#x2F;html
.htt
text&#x2F;webviewhtml


.htx
text&#x2F;html
.icb
application&#x2F;x-icb


.ico
image&#x2F;x-icon
.ico
application&#x2F;x-ico


.iff
application&#x2F;x-iff
.ig4
application&#x2F;x-g4


.igs
application&#x2F;x-igs
.iii
application&#x2F;x-iphone


.img
application&#x2F;x-img
.ins
application&#x2F;x-internet-signup


.isp
application&#x2F;x-internet-signup
.IVF
video&#x2F;x-ivf


.java
java&#x2F;*
.jfif
image&#x2F;jpeg


.jpe
image&#x2F;jpeg
.jpe
application&#x2F;x-jpe


.jpeg
image&#x2F;jpeg
.jpg
image&#x2F;jpeg


.jpg
application&#x2F;x-jpg
.js
application&#x2F;x-javascript


.jsp
text&#x2F;html
.la1
audio&#x2F;x-liquid-file


.lar
application&#x2F;x-laplayer-reg
.latex
application&#x2F;x-latex


.lavs
audio&#x2F;x-liquid-secure
.lbm
application&#x2F;x-lbm


.lmsff
audio&#x2F;x-la-lms
.ls
application&#x2F;x-javascript


.ltr
application&#x2F;x-ltr
.m1v
video&#x2F;x-mpeg


.m2v
video&#x2F;x-mpeg
.m3u
audio&#x2F;mpegurl


.m4e
video&#x2F;mpeg4
.mac
application&#x2F;x-mac


.man
application&#x2F;x-troff-man
.math
text&#x2F;xml


.mdb
application&#x2F;msaccess
.mdb
application&#x2F;x-mdb


.mfp
application&#x2F;x-shockwave-flash
.mht
message&#x2F;rfc822


.mhtml
message&#x2F;rfc822
.mi
application&#x2F;x-mi


.mid
audio&#x2F;mid
.midi
audio&#x2F;mid


.mil
application&#x2F;x-mil
.mml
text&#x2F;xml


.mnd
audio&#x2F;x-musicnet-download
.mns
audio&#x2F;x-musicnet-stream


.mocha
application&#x2F;x-javascript
.movie
video&#x2F;x-sgi-movie


.mp1
audio&#x2F;mp1
.mp2
audio&#x2F;mp2


.mp2v
video&#x2F;mpeg
.mp3
audio&#x2F;mp3


.mp4
video&#x2F;mpeg4
.mpa
video&#x2F;x-mpg


.mpd
application&#x2F;vnd.ms-project
.mpe
video&#x2F;x-mpeg


.mpeg
video&#x2F;mpg
.mpg
video&#x2F;mpg


.mpga
audio&#x2F;rn-mpeg
.mpp
application&#x2F;vnd.ms-project


.mps
video&#x2F;x-mpeg
.mpt
application&#x2F;vnd.ms-project


.mpv
video&#x2F;mpg
.mpv2
video&#x2F;mpeg


.mpw
application&#x2F;vnd.ms-project
.mpx
application&#x2F;vnd.ms-project


.mtx
text&#x2F;xml
.mxp
application&#x2F;x-mmxp


.net
image&#x2F;pnetvue
.nrf
application&#x2F;x-nrf


.nws
message&#x2F;rfc822
.odc
text&#x2F;x-ms-odc


.out
application&#x2F;x-out
.p10
application&#x2F;pkcs10


.p12
application&#x2F;x-pkcs12
.p7b
application&#x2F;x-pkcs7-certificates


.p7c
application&#x2F;pkcs7-mime
.p7m
application&#x2F;pkcs7-mime


.p7r
application&#x2F;x-pkcs7-certreqresp
.p7s
application&#x2F;pkcs7-signature


.pc5
application&#x2F;x-pc5
.pci
application&#x2F;x-pci


.pcl
application&#x2F;x-pcl
.pcx
application&#x2F;x-pcx


.pdf
application&#x2F;pdf
.pdf
application&#x2F;pdf


.pdx
application&#x2F;vnd.adobe.pdx
.pfx
application&#x2F;x-pkcs12


.pgl
application&#x2F;x-pgl
.pic
application&#x2F;x-pic


.pko
application&#x2F;vnd.ms-pki.pko
.pl
application&#x2F;x-perl


.plg
text&#x2F;html
.pls
audio&#x2F;scpls


.plt
application&#x2F;x-plt
.png
image&#x2F;png


.png
application&#x2F;x-png
.pot
application&#x2F;vnd.ms-powerpoint


.ppa
application&#x2F;vnd.ms-powerpoint
.ppm
application&#x2F;x-ppm


.pps
application&#x2F;vnd.ms-powerpoint
.ppt
application&#x2F;vnd.ms-powerpoint


.ppt
application&#x2F;x-ppt
.pr
application&#x2F;x-pr


.prf
application&#x2F;pics-rules
.prn
application&#x2F;x-prn


.prt
application&#x2F;x-prt
.ps
application&#x2F;x-ps


.ps
application&#x2F;postscript
.ptn
application&#x2F;x-ptn


.pwz
application&#x2F;vnd.ms-powerpoint
.r3t
text&#x2F;vnd.rn-realtext3d


.ra
audio&#x2F;vnd.rn-realaudio
.ram
audio&#x2F;x-pn-realaudio


.ras
application&#x2F;x-ras
.rat
application&#x2F;rat-file


.rdf
text&#x2F;xml
.rec
application&#x2F;vnd.rn-recording


.red
application&#x2F;x-red
.rgb
application&#x2F;x-rgb


.rjs
application&#x2F;vnd.rn-realsystem-rjs
.rjt
application&#x2F;vnd.rn-realsystem-rjt


.rlc
application&#x2F;x-rlc
.rle
application&#x2F;x-rle


.rm
application&#x2F;vnd.rn-realmedia
.rmf
application&#x2F;vnd.adobe.rmf


.rmi
audio&#x2F;mid
.rmj
application&#x2F;vnd.rn-realsystem-rmj


.rmm
audio&#x2F;x-pn-realaudio
.rmp
application&#x2F;vnd.rn-rn_music_package


.rms
application&#x2F;vnd.rn-realmedia-secure
.rmvb
application&#x2F;vnd.rn-realmedia-vbr


.rmx
application&#x2F;vnd.rn-realsystem-rmx
.rnx
application&#x2F;vnd.rn-realplayer


.rp
image&#x2F;vnd.rn-realpix
.rpm
audio&#x2F;x-pn-realaudio-plugin


.rsml
application&#x2F;vnd.rn-rsml
.rt
text&#x2F;vnd.rn-realtext


.rtf
application&#x2F;msword
.rtf
application&#x2F;x-rtf


.rv
video&#x2F;vnd.rn-realvideo
.sam
application&#x2F;x-sam


.sat
application&#x2F;x-sat
.sdp
application&#x2F;sdp


.sdw
application&#x2F;x-sdw
.sit
application&#x2F;x-stuffit


.slb
application&#x2F;x-slb
.sld
application&#x2F;x-sld


.slk
drawing&#x2F;x-slk
.smi
application&#x2F;smil


.smil
application&#x2F;smil
.smk
application&#x2F;x-smk


.snd
audio&#x2F;basic
.sol
text&#x2F;plain


.sor
text&#x2F;plain
.spc
application&#x2F;x-pkcs7-certificates


.spl
application&#x2F;futuresplash
.spp
text&#x2F;xml


.ssm
application&#x2F;streamingmedia
.sst
application&#x2F;vnd.ms-pki.certstore


.stl
application&#x2F;vnd.ms-pki.stl
.stm
text&#x2F;html


.sty
application&#x2F;x-sty
.svg
text&#x2F;xml


.swf
application&#x2F;x-shockwave-flash
.tdf
application&#x2F;x-tdf


.tg4
application&#x2F;x-tg4
.tga
application&#x2F;x-tga


.tif
image&#x2F;tiff
.tif
application&#x2F;x-tif


.tiff
image&#x2F;tiff
.tld
text&#x2F;xml


.top
drawing&#x2F;x-top
.torrent
application&#x2F;x-bittorrent


.tsd
text&#x2F;xml
.txt
text&#x2F;plain


.uin
application&#x2F;x-icq
.uls
text&#x2F;iuls


.vcf
text&#x2F;x-vcard
.vda
application&#x2F;x-vda


.vdx
application&#x2F;vnd.visio
.vml
text&#x2F;xml


.vpg
application&#x2F;x-vpeg005
.vsd
application&#x2F;vnd.visio


.vsd
application&#x2F;x-vsd
.vss
application&#x2F;vnd.visio


.vst
application&#x2F;vnd.visio
.vst
application&#x2F;x-vst


.vsw
application&#x2F;vnd.visio
.vsx
application&#x2F;vnd.visio


.vtx
application&#x2F;vnd.visio
.vxml
text&#x2F;xml


.wav
audio&#x2F;wav
.wax
audio&#x2F;x-ms-wax


.wb1
application&#x2F;x-wb1
.wb2
application&#x2F;x-wb2


.wb3
application&#x2F;x-wb3
.wbmp
image&#x2F;vnd.wap.wbmp


.wiz
application&#x2F;msword
.wk3
application&#x2F;x-wk3


.wk4
application&#x2F;x-wk4
.wkq
application&#x2F;x-wkq


.wks
application&#x2F;x-wks
.wm
video&#x2F;x-ms-wm


.wma
audio&#x2F;x-ms-wma
.wmd
application&#x2F;x-ms-wmd


.wmf
application&#x2F;x-wmf
.wml
text&#x2F;vnd.wap.wml


.wmv
video&#x2F;x-ms-wmv
.wmx
video&#x2F;x-ms-wmx


.wmz
application&#x2F;x-ms-wmz
.wp6
application&#x2F;x-wp6


.wpd
application&#x2F;x-wpd
.wpg
application&#x2F;x-wpg


.wpl
application&#x2F;vnd.ms-wpl
.wq1
application&#x2F;x-wq1


.wr1
application&#x2F;x-wr1
.wri
application&#x2F;x-wri


.wrk
application&#x2F;x-wrk
.ws
application&#x2F;x-ws


.ws2
application&#x2F;x-ws
.wsc
text&#x2F;scriptlet


.wsdl
text&#x2F;xml
.wvx
video&#x2F;x-ms-wvx


.xdp
application&#x2F;vnd.adobe.xdp
.xdr
text&#x2F;xml


.xfd
application&#x2F;vnd.adobe.xfd
.xfdf
application&#x2F;vnd.adobe.xfdf


.xhtml
text&#x2F;html
.xls
application&#x2F;vnd.ms-excel


.xls
application&#x2F;x-xls
.xlw
application&#x2F;x-xlw


.xml
text&#x2F;xml
.xpl
audio&#x2F;scpls


.xq
text&#x2F;xml
.xql
text&#x2F;xml


.xquery
text&#x2F;xml
.xsd
text&#x2F;xml


.xsl
text&#x2F;xml
.xslt
text&#x2F;xml


.xwd
application&#x2F;x-xwd
.x_b
application&#x2F;x-x_b


.sis
application&#x2F;vnd.symbian.install
.sisx
application&#x2F;vnd.symbian.install


.x_t
application&#x2F;x-x_t
.ipa
application&#x2F;vnd.iphone


.apk
application&#x2F;vnd.android.package-archive
.xap
application&#x2F;x-silverlight-app


]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 新增分类、标签与自定义页面详解</title>
    <url>/2025/10/12/Hexo%E6%96%B0%E5%A2%9E%E5%88%86%E7%B1%BB%E6%A0%87%E7%AD%BE%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[本文介绍如何在 Hexo 博客中创建「分类（categories）」「标签（tags）」页面，以及如何扩展出一个「友情链接」等自定义页面。内容基于 Butterfly 主题实测整理。

一、Hexo 原生动态页面机制Hexo 本身内置 4 种可自动更新的动态页面：



页面类型
是否自动更新
说明



index（首页）
是
自动列出文章（分页）


archives（归档页）
是
自动按时间归档


categories（分类页）
是
自动根据文章头部的分类生成


tags（标签页）
是
自动根据文章头部的标签生成


这四类页面不需要你手动维护内容，Hexo 在生成站点时会自动扫描所有文章的 Front Matter（头部注解）并动态更新。

二、创建分类与标签页面在博客根目录执行：
hexo new page categorieshexo new page tags

系统会生成：
source/categories/index.mdsource/tags/index.md

修改内容如下：
categories 页面---title: 分类date: 2025-10-12 12:00:00type: categories---

tags 页面---title: 标签date: 2025-10-12 12:00:00type: tags---


注意：type: 必须写成 categories 与 tags，否则主题无法识别。

三、配置 Butterfly 菜单在 _config.butterfly.yml 中添加：
menu:  home: / || fa fa-home  archives: /archives/ || fa fa-archive  categories: /categories/ || fa fa-folder-open  tags: /tags/ || fa fa-tags  about: /about/ || fa fa-user

执行以下命令重新生成：
hexo cleanhexo ghexo s



访问：
http://localhost:4000/categories/
http://localhost:4000/tags/
即可看到页面。
四、关于自定义页面（例如友情链接）假设要新增一个“友情链接”页：
hexo new page links

生成文件：
source/links/index.md

默认内容为：
---title: 友情链接date: 2025-10-12 12:00:00---

此页面为 静态页面，你需要自己在 Markdown 中写内容：
# 友情链接- [我的 GitHub](https://github.com/hurri)- [Hexo 官网](https://hexo.io/)- [开源中国](https://www.oschina.net/)

Hexo 会在生成时将其转成静态 HTML，但不会自动更新。

五、让自定义页面实现“自动更新”通过 _data/links.yml 自动生成
Butterfly 支持通过数据文件方式维护友情链接。

新建文件：source/_data/links.yml
- name: 我的GitHub  link: https://github.com/hurri  avatar: https://avatars.githubusercontent.com/u/1234567  descr: 开发与分享- name: Hexo 官网  link: https://hexo.io/  avatar: https://hexo.io/icon.png  descr: 博客框架

编辑 source/links/index.md
---title: 友情链接date: 2025-10-12 12:00:00type: linklayout: links---

在 _config.butterfly.yml 中启用：
link:  enable: true  data: links.yml


这样每次你修改 _data/links.yml 并执行 hexo g，页面会自动更新，无需再编辑 Markdown。


六、总结对比


页面类型
来源
是否自动更新
更新方式



index &#x2F; archives &#x2F; categories &#x2F; tags
Hexo 内置生成器
自动
文章变化时自动生成


自定义静态页（如 links、about）
用户创建
手动
编辑 index.md


自定义带模板页
主题或插件
自动
从 _data/ 或逻辑渲染



七、推荐实践
分类 &#x2F; 标签 &#x2F; 归档页 → 用 type: 自动生成
友情链接 &#x2F; 导航页 → 用 _data/*.yml 文件维护
特殊展示页（项目展示、作品集） → 自定义 layout 模板

这样既能保持自动化，又能保持整洁可维护的结构。
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>Hexo</tag>
        <tag>Butterfly</tag>
        <tag>博客运维</tag>
      </tags>
  </entry>
  <entry>
    <title>MC010智能插座核心控制板引脚定义</title>
    <url>/2023/11/26/MC010%E6%99%BA%E8%83%BD%E6%8F%92%E5%BA%A7%E6%A0%B8%E5%BF%83%E6%8E%A7%E5%88%B6%E6%9D%BF%E5%BC%95%E8%84%9A%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[其中的模块电源板
控制小板

引脚定义


引脚号（橙色数字）
功能(参照esp12f)



1
vcc（3.3v）


2
gnd


3
空


4
空


5
空


6
txd


7
串联了一个2k的电阻到达GPIO12，并且经过一个3.3k的电阻下拉到地。控制继电器吸合


8
GPIO0


9
RST


10
RXD


11




按键
一边接地，一边经过一个1k电阻连接到GPIO13，同时被一个100k的电阻上拉到vcc





四个指示灯P1 P2 W1 W2
四个灯有一端全部连接至vcc
四个箭头所指的位置均是vcc



W1、W2分别串联了一个510r的电阻连接到GPIO4



P1 P2分别串联了一个2K的电阻然后连接到GPIO5





7引脚
经过一个2k的电阻到达GPIO12，同时被3.3k的电阻下拉到地



同时通过这个引脚控制外部继电器吸合。当此引脚为高电平时，继电器吸合，当此引脚为低电平的时候，继电器断开。



98 CD AC 3D 10 39
python esptool.py –baud 115200 –port COM6 read_flash 0x00000 0x100000 dump.bin
python 
esptool –chip esp8266 –baud 115200 –port COM6 read_flash 0x00000 0x100000 dump_1M.bin
esptool –chip esp8266 –baud 115200 –port COM6 read_flash 0x00000 0x200000 dump_2M.bin
esptool –chip esp8266 –baud 115200 –port COM6 read_flash 0x00000 0x400000 dump_4M.bin
esptool.py read_flash 0x0 0x1000 dump.bin
]]></content>
      <categories>
        <category>ESP8266</category>
        <category>智能插座</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>ESP8266</tag>
        <tag>智能插座</tag>
        <tag>魔改</tag>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux部署Tomcat</title>
    <url>/0202/01/26/Linux%E9%83%A8%E7%BD%B2Tomcat/</url>
    <content><![CDATA[部署Linux环境下安装Tomcat并运行已经打包成WAR格式的Java项目，可以按照以下步骤进行操作：

下载Tomcat：访问Apache Tomcat官方网站（https://tomcat.apache.org/）下载最新版本的Tomcat压缩包（通常是.tar.gz格式）。

解压Tomcat：在终端中，使用以下命令解压下载的Tomcat压缩包：
tar -zxvf apache-tomcat-&lt;version&gt;.tar.gz

这将解压缩Tomcat到当前目录下的一个新文件夹中。

移动Tomcat：将解压后的Tomcat文件夹移动到适当的位置，比如/opt目录：
sudo mv apache-tomcat-&lt;version&gt; /opt/tomcat

设置环境变量：打开终端配置文件（例如.bashrc或.bash_profile，或者全局配置文件 /etc/profile），并添加以下行来设置Tomcat的环境变量：
export CATALINA_HOME=/opt/tomcatexport PATH=$PATH:$CATALINA_HOME/bin

重新加载配置：执行以下命令以使环境变量生效：
source ~/.bashrc

启动Tomcat：使用以下命令启动Tomcat服务器：
catalina.sh start

或者使用下面的命令（如果你的系统使用的是systemd）：
systemctl start tomcat

部署WAR文件：将你的WAR文件复制到Tomcat的webapps目录下：
cp yourapp.war /opt/tomcat/webapps/

Tomcat自动解压WAR文件：Tomcat会自动解压WAR文件并将其部署为一个Web应用程序。你可以在/opt/tomcat/webapps目录中看到解压后的应用程序文件夹。

访问应用程序：使用浏览器访问应用程序。默认情况下，Tomcat会监听8080端口，所以你可以通过以下URL访问应用程序：
http://localhost:8080/yourapp

修改访问端口
配置Tomcat的Connector：打开Tomcat的配置文件server.xml，该文件位于Tomcat的conf目录下。找到类似以下的Connector配置：
&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;           connectionTimeout=&quot;20000&quot;           redirectPort=&quot;8443&quot; /&gt;

将port属性的值改为所需的值，比如80，即：
&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot;           connectionTimeout=&quot;20000&quot;           redirectPort=&quot;8443&quot; /&gt;

这将使Tomcat监听80端口，这是Web应用程序的默认HTTP端口。

重启Tomcat：保存并关闭server.xml文件，然后重启Tomcat服务器，以使配置更改生效。


直接访问应用程序不添加上下文路径要在Tomcat中直接访问应用程序而不需要添加上下文路径，你可以将应用程序部署为ROOT应用程序。这样，当你访问Tomcat时，应用程序将作为默认应用程序加载。
以下是步骤：

将WAR文件重命名为ROOT.war：将你的应用程序的WAR文件重命名为ROOT.war。

将ROOT.war文件复制到Tomcat的webapps目录下：执行以下命令将ROOT.war文件复制到Tomcat的webapps目录中：
cp yourapp.war /opt/tomcat/webapps/ROOT.war

删除现有的ROOT目录（如果存在）：如果在webapps目录下已经存在一个名为ROOT的目录，请删除它。可以使用以下命令删除目录：
rm -rf /opt/tomcat/webapps/ROOT

重启Tomcat：重启Tomcat服务器以使更改生效。


现在，当你访问Tomcat时，应用程序将作为默认应用程序加载，而无需添加上下文路径。你可以通过以下URL直接访问应用程序：
http://localhost:8080/

请确保在执行上述步骤时，你已经停止Tomcat服务器，并且没有其他应用程序正在使用ROOT上下文路径。
给Tomcat增加ssl证书实现https访问要给Tomcat增加SSL证书以实现HTTPS，你可以按照以下步骤进行操作：7

获取SSL证书：首先，你需要获取一个有效的SSL证书。你可以购买一个证书，或者使用免费的证书颁发机构（如Let’s Encrypt）来获取证书。

生成密钥库文件：使用Java的keytool工具生成一个密钥库文件（.keystore），其中包含你的SSL证书。打开命令行终端，并导航到Java的bin目录（通常在JDK安装目录的bin子目录中）。然后运行以下命令来生成密钥库文件：
keytool -genkey -alias mydomain -keyalg RSA -keystore /path/to/keystore.jks

在命令中，将/path/to/keystore.jks替换为你希望保存密钥库文件的路径和文件名。在生成过程中，你需要提供一些信息，如密钥库密码、组织名称、组织单位、城市、州&#x2F;省、国家&#x2F;地区和证书有效期等。

配置Tomcat的SSL连接器：打开Tomcat的配置文件server.xml，通常位于Tomcat的conf目录下。找到以下注释中的配置块：
&lt;!-- Define a SSL Coyote HTTP/1.1 Connector on port 8443 --&gt;&lt;!--&lt;Connector   protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;   port=&quot;8443&quot; maxThreads=&quot;200&quot;   scheme=&quot;https&quot; secure=&quot;true&quot; SSLEnabled=&quot;true&quot;   keystoreFile=&quot;$&#123;user.home&#125;/.keystore&quot; keystorePass=&quot;changeit&quot;   clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot;/&gt;--&gt;

将注释解除，并根据你的密钥库文件和密码进行配置。将keystoreFile和keystorePass属性的值分别设置为你生成的密钥库文件的路径和密码。

配置其他SSL连接器属性（可选）：你还可以根据需要配置其他SSL连接器属性，如ciphers、SSLProtocol等。这些属性可以用于进一步定制和优化SSL连接。

保存并关闭server.xml文件。

启动Tomcat：使用启动脚本或命令启动Tomcat服务器。Tomcat将加载配置的SSL连接器并使用SSL证书提供HTTPS服务。


一旦你完成了上述步骤，你的Tomcat服务器将配置为使用SSL证书提供HTTPS连接。你可以通过访问https://yourdomain.com:8443/来测试HTTPS连接，其中yourdomain.com是你的域名或服务器的IP地址，8443是你在配置文件中指定的SSL连接器端口。
请注意，上述步骤仅适用于使用Tomcat作为Web服务器的情况。如果你使用其他Web服务器（如Nginx或Apache）作为反向代理服务器，你需要参考相应服务器的文档来配置SSL证书。
]]></content>
      <categories>
        <category>Linux部署</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>Linux</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Openwrt获取到了ipv6地址，但无法使用</title>
    <url>/2023/02/28/Openwrt%E8%8E%B7%E5%8F%96%E5%88%B0%E4%BA%86ipv6%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%BD%86%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[Openwrt获取到了ipv6地址，但无法使用获取到了ipv6地址，但经测试无法使用ipv6的地址，而且ping具有v4&#x2F;v6双栈响应的网站，显示的目标ip是ipv4。
解决办法开启ipv6 转发和修改防火墙策略
# 修改/etc/sysctl.conf，将以下内容加进去,大意说接收广播并开启IPv6转发net.ipv6.conf.default.forwarding=2net.ipv6.conf.all.forwarding=2net.ipv6.conf.default.accept_ra=2net.ipv6.conf.all.accept_ra=2net.ipv6.conf.default.accept_dad=2net.ipv6.conf.all.accept_dad=2net.ipv6.conf.default.dad_transmits=2net.ipv6.conf.all.dad_transmits=2# 因为OpenWRT默认的防火墙配置不会管IPv6的nat表需要在/etc/firewall.user添加防火墙规则：# set up firewallip6tables -P INPUT ACCEPTip6tables -P OUTPUT ACCEPTip6tables -A OUTPUT -p tcp -j ACCEPTip6tables -A OUTPUT -p udp -j ACCEPT# input rulesip6tables -A INPUT -p ipv6-crypt -j ACCEPTip6tables -A INPUT -p ipv6-auth -j ACCEPTip6tables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPTip6tables -A INPUT -m state --state NEW -j ACCEPTip6tables -A INPUT -m state --state INVALID -j DROP# allow DHCPv6ip6tables -A INPUT -p udp --sport 547 --dport 546 -j ACCEPTip6tables -A INPUT -p udp --sport 500 --dport 500 -j ACCEPTip6tables -A INPUT -p udp --sport 4500 --dport 4500 -j ACCEPT# allow ipv6-icmp related packetip6tables -A INPUT -p ipv6-icmp --icmpv6-type router-solicitation -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type packet-too-big -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type time-exceeded -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type parameter-problem -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type echo-request -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type echo-reply -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type 130 -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type 131 -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type 132 -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type router-solicitation -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type router-advertisement -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type neighbour-solicitation -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type neighbour-advertisement -j ACCEPT ip6tables -A INPUT -p ipv6-icmp --icmpv6-type 141 -j ACCEPTip6tables -A INPUT -p ipv6-icmp --icmpv6-type 142 -j ACCEPTip6tables -A INPUT -p ipv6-icmp --icmpv6-type 143 -j ACCEPTip6tables -A INPUT -p ipv6-icmp --icmpv6-type 148 -j ACCEPTip6tables -A INPUT -p ipv6-icmp --icmpv6-type 149 -j ACCEPTip6tables -A INPUT -p ipv6-icmp --icmpv6-type 151 -j ACCEPTip6tables -A INPUT -p ipv6-icmp --icmpv6-type 152 -j ACCEPTip6tables -A INPUT -p ipv6-icmp --icmpv6-type 153 -j ACCEPTip6tables -A INPUT -j DROP

来源https://blog.csdn.net/a735131232/article/details/117004464
测试网址：
https://www.test-ipv6.com/
IPv6地址查询工具 (zxinc.org)
]]></content>
      <categories>
        <category>OpenWRT</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>OpenWRT</tag>
      </tags>
  </entry>
  <entry>
    <title>MIME类型及对照表</title>
    <url>/2023/11/05/MIME%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%AF%B9%E7%85%A7%E8%A1%A8/</url>
    <content><![CDATA[MIME 类型MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的标准，用来表示文档、文件或字节流的性质和格式。
MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。
浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理URL，因此 We b服务器在响应头中添加正确的 MIME 类型非常重要。如果配置不正确，浏览器可能会无法解析文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。
语法MIME 类型通用结构：
type/subtype

MIME 的组成结构非常简单，由类型与子类型两个字符串中间用 &#x2F; 分隔而组成，不允许有空格。type 表示可以被分多个子类的独立类别，subtype 表示细分后的每个类型。
MIME类型对大小写不敏感，但是传统写法都是小写。
两种主要的 MIME 类型在默认类型中扮演了重要的角色：

text&#x2F;plain 表示文本文件的默认值。
application&#x2F;octet-stream 表示所有其他情况的默认值。

常见的 MIME 类型
超文本标记语言文本 .html、.html：text&#x2F;html
普通文本 .txt： text&#x2F;plain
RTF 文本 .rtf： application&#x2F;rtf
GIF 图形 .gif： image&#x2F;gif
JPEG 图形 .jpeg、.jpg： image&#x2F;jpeg
au 声音文件 .au： audio&#x2F;basic
MIDI 音乐文件 mid、.midi： audio&#x2F;midi、audio&#x2F;x-midi
RealAudio 音乐文件 .ra、.ram： audio&#x2F;x-pn-realaudio
MPEG 文件 .mpg、.mpeg： video&#x2F;mpeg
AVI 文件 .avi： video&#x2F;x-msvideo
GZIP 文件 .gz： application&#x2F;x-gzip
TAR 文件 .tar： application&#x2F;x-tar




类型
描述
典型示例



text
表明文件是普通文本，理论上是人类可读
text/plain, text/html, text/css, text/javascript


image
表明是某种图像。不包括视频，但是动态图（比如动态gif）也使用image类型
image/gif, image/png, image/jpeg, image/bmp, image/webp, image/x-icon, image/vnd.microsoft.icon


audio
表明是某种音频文件
audio/midi, audio/mpeg, audio/webm, audio/ogg, audio/wav


video
表明是某种视频文件
video/webm, video/ogg


application
表明是某种二进制数据
application/octet-stream, application/pkcs12, application/vnd.mspowerpoint, application/xhtml+xml, application/xml, application/pdf


MIME 对照表


媒体类型
文件扩展名
说明



application&#x2F;msword
doc
微软 Office Word 格式（Microsoft Word 97 - 2004 document）


application&#x2F;vnd.openxmlformats-officedocument.wordprocessingml.document
docx
微软 Office Word 文档格式


application&#x2F;vnd.ms-excel
xls
微软 Office Excel 格式（Microsoft Excel 97 - 2004 Workbook


application&#x2F;vnd.openxmlformats-officedocument.spreadsheetml.sheet
xlsx
微软 Office Excel 文档格式


application&#x2F;vnd.ms-powerpoint
ppt
微软 Office PowerPoint 格式（Microsoft PowerPoint 97 - 2003 演示文稿）


application&#x2F;vnd.openxmlformats-officedocument.presentationml.presentation
pptx
微软 Office PowerPoint 文稿格式


application&#x2F;x-gzip
gz, gzip
GZ 压缩文件格式


application&#x2F;zip
zip, 7zip
ZIP 压缩文件格式


application&#x2F;rar
rar
RAR 压缩文件格式


application&#x2F;x-tar
tar, tgz
TAR 压缩文件格式


application&#x2F;pdf
pdf
PDF 是 Portable Document Format 的简称，即便携式文档格式


application&#x2F;rtf
rtf
RTF 是指 Rich Text Format，即通常所说的富文本格式


image&#x2F;gif
gif
GIF 图像格式


image&#x2F;jpeg
jpg, jpeg
JPG(JPEG) 图像格式


image&#x2F;jp2
jpg2
JPG2 图像格式


image&#x2F;png
png
PNG 图像格式


image&#x2F;tiff
tif, tiff
TIF(TIFF) 图像格式


image&#x2F;bmp
bmp
BMP 图像格式（位图格式）


image&#x2F;svg+xml
svg, svgz
SVG 图像格式


image&#x2F;webp
webp
WebP 图像格式


image&#x2F;x-icon
ico
ico 图像格式，通常用于浏览器 Favicon 图标


application&#x2F;kswps
wps
金山 Office 文字排版文件格式


application&#x2F;kset
et
金山 Office 表格文件格式


application&#x2F;ksdps
dps
金山 Office 演示文稿格式


application&#x2F;x-photoshop
psd
Photoshop 源文件格式


application&#x2F;x-coreldraw
cdr
Coreldraw 源文件格式


application&#x2F;x-shockwave-flash
swf
Adobe Flash 源文件格式


text&#x2F;plain
txt
普通文本格式


application&#x2F;x-javascript
js
Javascript 文件类型


text&#x2F;javascript
js
表示 Javascript 脚本文件


text&#x2F;css
css
表示 CSS 样式表


text&#x2F;html
htm, html, shtml
HTML 文件格式


application&#x2F;xhtml+xml
xht, xhtml
XHTML 文件格式


text&#x2F;xml
xml
XML 文件格式


text&#x2F;x-vcard
vcf
VCF 文件格式


application&#x2F;x-httpd-php
php, php3, php4, phtml
PHP 文件格式


application&#x2F;java-archive
jar
Java 归档文件格式


application&#x2F;vnd.android.package-archive
apk
Android 平台包文件格式


application&#x2F;octet-stream
exe
Windows 系统可执行文件格式


application&#x2F;x-x509-user-cert
crt, pem
PEM 文件格式


audio&#x2F;mpeg
mp3
mpeg 音频格式


audio&#x2F;midi
mid, midi
mid 音频格式


audio&#x2F;x-wav
wav
wav 音频格式


audio&#x2F;x-mpegurl
m3u
m3u 音频格式


audio&#x2F;x-m4a
m4a
m4a 音频格式


audio&#x2F;ogg
ogg
ogg 音频格式


audio&#x2F;x-realaudio
ra
Real Audio 音频格式


video&#x2F;mp4
mp4
mp4 视频格式


video&#x2F;mpeg
mpg, mpe, mpeg
mpeg 视频格式


video&#x2F;quicktime
qt, mov
QuickTime 视频格式


video&#x2F;x-m4v
m4v
m4v 视频格式


video&#x2F;x-ms-wmv
wmv
wmv 视频格式（Windows 操作系统上的一种视频格式）


video&#x2F;x-msvideo
avi
avi 视频格式


video&#x2F;webm
webm
webm 视频格式


video&#x2F;x-flv
flv
一种基于 flash 技术的视频格式


按照内容类型排列的 MIME 类型列表


类型&#x2F;子类型
扩展名



application&#x2F;envoy
evy


application&#x2F;fractals
fif


application&#x2F;futuresplash
spl


application&#x2F;hta
hta


application&#x2F;internet-property-stream
acx


application&#x2F;mac-binhex40
hqx


application&#x2F;msword
doc


application&#x2F;msword
dot


application&#x2F;octet-stream
*


application&#x2F;octet-stream
bin


application&#x2F;octet-stream
class


application&#x2F;octet-stream
dms


application&#x2F;octet-stream
exe


application&#x2F;octet-stream
lha


application&#x2F;octet-stream
lzh


application&#x2F;oda
oda


application&#x2F;olescript
axs


application&#x2F;pdf
pdf


application&#x2F;pics-rules
prf


application&#x2F;pkcs10
p10


application&#x2F;pkix-crl
crl


application&#x2F;postscript
ai


application&#x2F;postscript
eps


application&#x2F;postscript
ps


application&#x2F;rtf
rtf


application&#x2F;set-payment-initiation
setpay


application&#x2F;set-registration-initiation
setreg


application&#x2F;vnd.ms-excel
xla


application&#x2F;vnd.ms-excel
xlc


application&#x2F;vnd.ms-excel
xlm


application&#x2F;vnd.ms-excel
xls


application&#x2F;vnd.ms-excel
xlt


application&#x2F;vnd.ms-excel
xlw


application&#x2F;vnd.ms-outlook
msg


application&#x2F;vnd.ms-pkicertstore
sst


application&#x2F;vnd.ms-pkiseccat
cat


application&#x2F;vnd.ms-pkistl
stl


application&#x2F;vnd.ms-powerpoint
pot


application&#x2F;vnd.ms-powerpoint
pps


application&#x2F;vnd.ms-powerpoint
ppt


application&#x2F;vnd.ms-project
mpp


application&#x2F;vnd.ms-works
wcm


application&#x2F;vnd.ms-works
wdb


application&#x2F;vnd.ms-works
wks


application&#x2F;vnd.ms-works
wps


application&#x2F;winhlp
hlp


application&#x2F;x-bcpio
bcpio


application&#x2F;x-cdf
cdf


application&#x2F;x-compress
z


application&#x2F;x-compressed
tgz


application&#x2F;x-cpio
cpio


application&#x2F;x-csh
csh


application&#x2F;x-director
dcr


application&#x2F;x-director
dir


application&#x2F;x-director
dxr


application&#x2F;x-dvi
dvi


application&#x2F;x-gtar
gtar


application&#x2F;x-gzip
gz


application&#x2F;x-hdf
hdf


application&#x2F;x-internet-signup
ins


application&#x2F;x-internet-signup
isp


application&#x2F;x-iphone
iii


application&#x2F;x-javascript
js


application&#x2F;x-latex
latex


application&#x2F;x-msaccess
mdb


application&#x2F;x-mscardfile
crd


application&#x2F;x-msclip
clp


application&#x2F;x-msdownload
dll


application&#x2F;x-msmediaview
m13


application&#x2F;x-msmediaview
m14


application&#x2F;x-msmediaview
mvb


application&#x2F;x-msmetafile
wmf


application&#x2F;x-msmoney
mny


application&#x2F;x-mspublisher
pub


application&#x2F;x-msschedule
scd


application&#x2F;x-msterminal
trm


application&#x2F;x-mswrite
wri


application&#x2F;x-netcdf
cdf


application&#x2F;x-netcdf
nc


application&#x2F;x-perfmon
pma


application&#x2F;x-perfmon
pmc


application&#x2F;x-perfmon
pml


application&#x2F;x-perfmon
pmr


application&#x2F;x-perfmon
pmw


application&#x2F;x-pkcs12
p12


application&#x2F;x-pkcs12
pfx


application&#x2F;x-pkcs7-certificates
p7b


application&#x2F;x-pkcs7-certificates
spc


application&#x2F;x-pkcs7-certreqresp
p7r


application&#x2F;x-pkcs7-mime
p7c


application&#x2F;x-pkcs7-mime
p7m


application&#x2F;x-pkcs7-signature
p7s


application&#x2F;x-sh
sh


application&#x2F;x-shar
shar


application&#x2F;x-shockwave-flash
swf


application&#x2F;x-stuffit
sit


application&#x2F;x-sv4cpio
sv4cpio


application&#x2F;x-sv4crc
sv4crc


application&#x2F;x-tar
tar


application&#x2F;x-tcl
tcl


application&#x2F;x-tex
tex


application&#x2F;x-texinfo
texi


application&#x2F;x-texinfo
texinfo


application&#x2F;x-troff
roff


application&#x2F;x-troff
t


application&#x2F;x-troff
tr


application&#x2F;x-troff-man
man


application&#x2F;x-troff-me
me


application&#x2F;x-troff-ms
ms


application&#x2F;x-ustar
ustar


application&#x2F;x-wais-source
src


application&#x2F;x-x509-ca-cert
cer


application&#x2F;x-x509-ca-cert
crt


application&#x2F;x-x509-ca-cert
der


application&#x2F;ynd.ms-pkipko
pko


application&#x2F;zip
zip


audio&#x2F;basic
au


audio&#x2F;basic
snd


audio&#x2F;mid
mid


audio&#x2F;mid
rmi


audio&#x2F;mpeg
mp3


audio&#x2F;x-aiff
aif


audio&#x2F;x-aiff
aifc


audio&#x2F;x-aiff
aiff


audio&#x2F;x-mpegurl
m3u


audio&#x2F;x-pn-realaudio
ra


audio&#x2F;x-pn-realaudio
ram


audio&#x2F;x-wav
wav


image&#x2F;bmp
bmp


image&#x2F;cis-cod
cod


image&#x2F;gif
gif


image&#x2F;ief
ief


image&#x2F;jpeg
jpe


image&#x2F;jpeg
jpeg


image&#x2F;jpeg
jpg


image&#x2F;pipeg
jfif


image&#x2F;svg+xml
svg


image&#x2F;tiff
tif


image&#x2F;tiff
tiff


image&#x2F;x-cmu-raster
ras


image&#x2F;x-cmx
cmx


image&#x2F;x-icon
ico


image&#x2F;x-portable-anymap
pnm


image&#x2F;x-portable-bitmap
pbm


image&#x2F;x-portable-graymap
pgm


image&#x2F;x-portable-pixmap
ppm


image&#x2F;x-rgb
rgb


image&#x2F;x-xbitmap
xbm


image&#x2F;x-xpixmap
xpm


image&#x2F;x-xwindowdump
xwd


message&#x2F;rfc822
mht


message&#x2F;rfc822
mhtml


message&#x2F;rfc822
nws


text&#x2F;css
css


text&#x2F;h323
323


text&#x2F;html
htm


text&#x2F;html
html


text&#x2F;html
stm


text&#x2F;iuls
uls


text&#x2F;plain
bas


text&#x2F;plain
c


text&#x2F;plain
h


text&#x2F;plain
txt


text&#x2F;richtext
rtx


text&#x2F;scriptlet
sct


text&#x2F;tab-separated-values
tsv


text&#x2F;webviewhtml
htt


text&#x2F;x-component
htc


text&#x2F;x-setext
etx


text&#x2F;x-vcard
vcf


video&#x2F;mpeg
mp2


video&#x2F;mpeg
mpa


video&#x2F;mpeg
mpe


video&#x2F;mpeg
mpeg


video&#x2F;mpeg
mpg


video&#x2F;mpeg
mpv2


video&#x2F;quicktime
mov


video&#x2F;quicktime
qt


video&#x2F;x-la-asf
lsf


video&#x2F;x-la-asf
lsx


video&#x2F;x-ms-asf
asf


video&#x2F;x-ms-asf
asr


video&#x2F;x-ms-asf
asx


video&#x2F;x-msvideo
avi


video&#x2F;x-sgi-movie
movie


x-world&#x2F;x-vrml
flr


x-world&#x2F;x-vrml
vrml


x-world&#x2F;x-vrml
wrl


x-world&#x2F;x-vrml
wrz


x-world&#x2F;x-vrml
xaf


x-world&#x2F;x-vrml
xof


按照文件扩展名排列的 MIME 类型列表


扩展名
类型&#x2F;子类型




application&#x2F;octet-stream


323
text&#x2F;h323


acx
application&#x2F;internet-property-stream


ai
application&#x2F;postscript


aif
audio&#x2F;x-aiff


aifc
audio&#x2F;x-aiff


aiff
audio&#x2F;x-aiff


asf
video&#x2F;x-ms-asf


asr
video&#x2F;x-ms-asf


asx
video&#x2F;x-ms-asf


au
audio&#x2F;basic


avi
video&#x2F;x-msvideo


axs
application&#x2F;olescript


bas
text&#x2F;plain


bcpio
application&#x2F;x-bcpio


bin
application&#x2F;octet-stream


bmp
image&#x2F;bmp


c
text&#x2F;plain


cat
application&#x2F;vnd.ms-pkiseccat


cdf
application&#x2F;x-cdf


cer
application&#x2F;x-x509-ca-cert


class
application&#x2F;octet-stream


clp
application&#x2F;x-msclip


cmx
image&#x2F;x-cmx


cod
image&#x2F;cis-cod


cpio
application&#x2F;x-cpio


crd
application&#x2F;x-mscardfile


crl
application&#x2F;pkix-crl


crt
application&#x2F;x-x509-ca-cert


csh
application&#x2F;x-csh


css
text&#x2F;css


dcr
application&#x2F;x-director


der
application&#x2F;x-x509-ca-cert


dir
application&#x2F;x-director


dll
application&#x2F;x-msdownload


dms
application&#x2F;octet-stream


doc
application&#x2F;msword


dot
application&#x2F;msword


dvi
application&#x2F;x-dvi


dxr
application&#x2F;x-director


eps
application&#x2F;postscript


etx
text&#x2F;x-setext


evy
application&#x2F;envoy


exe
application&#x2F;octet-stream


fif
application&#x2F;fractals


flr
x-world&#x2F;x-vrml


gif
image&#x2F;gif


gtar
application&#x2F;x-gtar


gz
application&#x2F;x-gzip


h
text&#x2F;plain


hdf
application&#x2F;x-hdf


hlp
application&#x2F;winhlp


hqx
application&#x2F;mac-binhex40


hta
application&#x2F;hta


htc
text&#x2F;x-component


htm
text&#x2F;html


html
text&#x2F;html


htt
text&#x2F;webviewhtml


ico
image&#x2F;x-icon


ief
image&#x2F;ief


iii
application&#x2F;x-iphone


ins
application&#x2F;x-internet-signup


isp
application&#x2F;x-internet-signup


jfif
image&#x2F;pipeg


jpe
image&#x2F;jpeg


jpeg
image&#x2F;jpeg


jpg
image&#x2F;jpeg


js
application&#x2F;x-javascript


latex
application&#x2F;x-latex


lha
application&#x2F;octet-stream


lsf
video&#x2F;x-la-asf


lsx
video&#x2F;x-la-asf


lzh
application&#x2F;octet-stream


m13
application&#x2F;x-msmediaview


m14
application&#x2F;x-msmediaview


m3u
audio&#x2F;x-mpegurl


man
application&#x2F;x-troff-man


mdb
application&#x2F;x-msaccess


me
application&#x2F;x-troff-me


mht
message&#x2F;rfc822


mhtml
message&#x2F;rfc822


mid
audio&#x2F;mid


mny
application&#x2F;x-msmoney


mov
video&#x2F;quicktime


movie
video&#x2F;x-sgi-movie


mp2
video&#x2F;mpeg


mp3
audio&#x2F;mpeg


mpa
video&#x2F;mpeg


mpe
video&#x2F;mpeg


mpeg
video&#x2F;mpeg


mpg
video&#x2F;mpeg


mpp
application&#x2F;vnd.ms-project


mpv2
video&#x2F;mpeg


ms
application&#x2F;x-troff-ms


mvb
application&#x2F;x-msmediaview


nws
message&#x2F;rfc822


oda
application&#x2F;oda


p10
application&#x2F;pkcs10


p12
application&#x2F;x-pkcs12


p7b
application&#x2F;x-pkcs7-certificates


p7c
application&#x2F;x-pkcs7-mime


p7m
application&#x2F;x-pkcs7-mime


p7r
application&#x2F;x-pkcs7-certreqresp


p7s
application&#x2F;x-pkcs7-signature


pbm
image&#x2F;x-portable-bitmap


pdf
application&#x2F;pdf


pfx
application&#x2F;x-pkcs12


pgm
image&#x2F;x-portable-graymap


pko
application&#x2F;ynd.ms-pkipko


pma
application&#x2F;x-perfmon


pmc
application&#x2F;x-perfmon


pml
application&#x2F;x-perfmon


pmr
application&#x2F;x-perfmon


pmw
application&#x2F;x-perfmon


pnm
image&#x2F;x-portable-anymap


pot,
application&#x2F;vnd.ms-powerpoint


ppm
image&#x2F;x-portable-pixmap


pps
application&#x2F;vnd.ms-powerpoint


ppt
application&#x2F;vnd.ms-powerpoint


prf
application&#x2F;pics-rules


ps
application&#x2F;postscript


pub
application&#x2F;x-mspublisher


qt
video&#x2F;quicktime


ra
audio&#x2F;x-pn-realaudio


ram
audio&#x2F;x-pn-realaudio


ras
image&#x2F;x-cmu-raster


rgb
image&#x2F;x-rgb


rmi
audio&#x2F;mid


roff
application&#x2F;x-troff


rtf
application&#x2F;rtf


rtx
text&#x2F;richtext


scd
application&#x2F;x-msschedule


sct
text&#x2F;scriptlet


setpay
application&#x2F;set-payment-initiation


setreg
application&#x2F;set-registration-initiation


sh
application&#x2F;x-sh


shar
application&#x2F;x-shar


sit
application&#x2F;x-stuffit


snd
audio&#x2F;basic


spc
application&#x2F;x-pkcs7-certificates


spl
application&#x2F;futuresplash


src
application&#x2F;x-wais-source


sst
application&#x2F;vnd.ms-pkicertstore


stl
application&#x2F;vnd.ms-pkistl


stm
text&#x2F;html


svg
image&#x2F;svg+xml


sv4cpio
application&#x2F;x-sv4cpio


sv4crc
application&#x2F;x-sv4crc


swf
application&#x2F;x-shockwave-flash


t
application&#x2F;x-troff


tar
application&#x2F;x-tar


tcl
application&#x2F;x-tcl


tex
application&#x2F;x-tex


texi
application&#x2F;x-texinfo


texinfo
application&#x2F;x-texinfo


tgz
application&#x2F;x-compressed


tif
image&#x2F;tiff


tiff
image&#x2F;tiff


tr
application&#x2F;x-troff


trm
application&#x2F;x-msterminal


tsv
text&#x2F;tab-separated-values


txt
text&#x2F;plain


uls
text&#x2F;iuls


ustar
application&#x2F;x-ustar


vcf
text&#x2F;x-vcard


vrml
x-world&#x2F;x-vrml


wav
audio&#x2F;x-wav


wcm
application&#x2F;vnd.ms-works


wdb
application&#x2F;vnd.ms-works


wks
application&#x2F;vnd.ms-works


wmf
application&#x2F;x-msmetafile


wps
application&#x2F;vnd.ms-works


wri
application&#x2F;x-mswrite


wrl
x-world&#x2F;x-vrml


wrz
x-world&#x2F;x-vrml


xaf
x-world&#x2F;x-vrml


xbm
image&#x2F;x-xbitmap


xla
application&#x2F;vnd.ms-excel


xlc
application&#x2F;vnd.ms-excel


xlm
application&#x2F;vnd.ms-excel


xls
application&#x2F;vnd.ms-excel


xlt
application&#x2F;vnd.ms-excel


xlw
application&#x2F;vnd.ms-excel


xof
x-world&#x2F;x-vrml


xpm
image&#x2F;x-xpixmap


xwd
image&#x2F;x-xwindowdump


z
application&#x2F;x-compress


zip
application&#x2F;zip


]]></content>
      <categories>
        <category>MIME</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>MIME</tag>
      </tags>
  </entry>
  <entry>
    <title>WiFiDuck_修改成为连接到指定的WiFi</title>
    <url>/2024/03/29/WiFiDuck_%E4%BF%AE%E6%94%B9%E6%88%90%E4%B8%BA%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84WiFi/</url>
    <content><![CDATA[需求
原始项目为创建一个AP热点，需修改成连接现有WiFi的模式，然后其他设备访问这个设备的ip的形式使用。
由于esp8266的异步库不支持ipv6，因此需要通过nginx来对现有设备的进行代理，以实现在外部通过ipv6的形式进行访问

修改步骤修改网页文件并编译
注释掉原有的创建热点的代码：位于webserver.cpp中的 void begin()方法中

WiFi.softAP(settings::getSSID(), settings::getPassword(), settings::getChannelNum());
debugf(&quot;Started Access Point \&quot;%s\&quot;:\&quot;%s\&quot;\n&quot;, settings::getSSID(), settings::getPassword());
2. 在注释掉的位置新增连接到指定WiFi的代码：   - ```     WiFi.begin(&quot;SSID&quot;, &quot;PASSWORD&quot;);

- `SSID`需要修改成要连接的WiFi的名称
- `PASSWORD`需要修改成指定WiFi的密码




修改 script.js文件（需要去官方下载web源码）

注释掉其中的这个代码

ws = new WebSocket(&quot;ws://192.168.4.1/ws&quot;);
2. 新增如下代码   - ```     ws = new WebSocket(&quot;ws://IP+端口/ws&quot;);

- `IP+端口`的值为nginx服务器的地址，或者为设备本身的ip地址






使用 python webconverter.py命令将网页文件转换为所需的字节数组

将生成的字节数组替换到项目中对应位置，然后重新编译项目并上传


创建nginx配置块server &#123;        listen 9898;        location / &#123;            proxy_pass 设备实际ip+端口;            proxy_set_header Host $host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_set_header X-Forwarded-Proto $scheme;        &#125;                location /ws &#123;			# 开启 WebSocket 代理支持			proxy_set_header Upgrade $http_upgrade;			proxy_set_header Connection &quot;upgrade&quot;;			# 设置 WebSocket 代理目标			proxy_pass http://设备实际IP+端口/ws;			# 其他可能需要的代理设置			proxy_redirect off;			proxy_set_header Host $host;			proxy_set_header X-Real-IP $remote_addr;			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;						# 需要增加以下配置 不然websocker会短时间就断连			proxy_read_timeout 3600s;  # 增加读取超时时间			proxy_send_timeout 3600s;  # 增加发送超时时间			proxy_http_version 1.1;    # 必须使用HTTP/1.1或以上版本，以支持WebSocket			keepalive_timeout 3600s;  # 保持连接活跃超时时间，防止空闲连接被关闭		&#125;    &#125;

]]></content>
      <categories>
        <category>ESP8266</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>ESP8266</tag>
        <tag>WiFiDuck</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>Office操作指南</title>
    <url>/2024/04/22/Office%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[快捷操作f4：重做上一次的动作
截取指定的文本从绝对地址中截取文件名在Excel中，你可以使用函数MID和FIND来从绝对地址中截取文件名。假设你的绝对地址保存在单元格A1中，下面是截取文件名的公式：
复制代码=MID(A1, FIND(&quot;*&quot;, SUBSTITUTE(A1, &quot;\&quot;, &quot;*&quot;, LEN(A1)-LEN(SUBSTITUTE(A1, &quot;\&quot;, &quot;&quot;)))) + 1, LEN(A1) - FIND(&quot;*&quot;, SUBSTITUTE(A1, &quot;\&quot;, &quot;*&quot;, LEN(A1)-LEN(SUBSTITUTE(A1, &quot;\&quot;, &quot;&quot;)))))

通过上述公式，你就可以从绝对地址中提取文件名了。请确保在使用时将单元格引用替换为实际的绝对地址。
后续有多少数据，都显示标题（首行或首列）
打开你的Excel表格。
滚动到你想保持可视的第一行标题行的正下方。
点击菜单栏中的“视图”选项卡。
在“窗口”组中，点击“冻结窗格”按钮，然后选择“冻结首行”。

这样设置后，当你向下滚动查看数据时，第一行标题会始终停留在屏幕顶部。
另外，如果你希望在打印时每页都显示这些标题行，你需要进行以下操作：

转到“页面布局”标签页。
点击“页面设置”组中的“打印标题”按钮，这将打开“页面设置”对话框。
在“页面设置”对话框中，找到“工作表”选项卡。
在“顶端标题行”输入框旁的按钮上点击，然后在工作表中选择你想要作为顶端标题重复出现的那一行（通常是第一行）。
点击“确定”保存设置。

通过以上步骤，无论是编辑状态下滚动查看还是打印输出时，第一行标题都会保持可见。
限制某一列只能输入某几个值
选择你想要设置限制的列。如果你只想限制一列中的某些单元格，也可以直接选择这些单元格。
转到“数据”选项卡。
在“数据工具”组中，点击“数据验证”按钮（可能显示为“数据验证”或“数据有效性”取决于你的Excel版本）。
在弹出的“数据验证”对话框中，首先确保“设置”选项卡是激活状态。
在“允许”下拉列表中，选择“序列”。
在“来源”框中，输入你允许填写的值，各值之间用逗号隔开。例如，如果你希望该列只能输入“是”或“否”，则输入“是,否”（不带引号）。
如果需要，你可以在“输入信息”或“出错警告”标签页中设置提示信息，当用户尝试输入数据时，这些信息会显示为帮助或警告。比如，你可以在“输入信息”中写“请输入’是’或’否’”以指导用户正确输入。
点击“确定”完成设置。

现在，当你或他人尝试在该列输入除指定值之外的内容时，Excel会显示警告，并阻止输入，除非更改成允许的值之一。
限制某一列不允许重复在Excel中，要限制某一列输入的值不能重复，即实现唯一性验证，可以通过数据验证功能来完成。以下是具体的操作步骤：

选择你想要防止出现重复值的整列或特定单元格范围。

转到“数据”选项卡。

在“数据工具”组中，点击“数据验证”按钮（可能显示为“数据验证”或“数据有效性”取决于你的Excel版本）。

在弹出的“数据验证”对话框中，确保当前选中的是“设置”选项卡。

在“允许”下拉菜单中，选择“自定义”。

在“公式”框中，输入以下公式（假设你选择的是A列，要根据实际情况调整列字母）:
Code
1=COUNTIF($A:$A,A1)&lt;2

这个公式的意思是检查当前单元格（如A1）的值在整个A列中是否出现少于2次，也就是保证了唯一性。

点击“确定”应用设置。


完成上述设置后，如果有人尝试在该列输入一个已经存在的值，Excel会显示错误警告，阻止输入重复值。
请注意，这种设置是在数据输入时进行验证，对于已经存在于列中的重复值不会自动删除或标记。如果需要检查并处理已有的重复数据，你可能需要使用“条件格式”突出显示重复项，或者使用“数据”选项卡下的“删除重复项”功能来清理数据。
标记某一列中重复的数据在Excel中，若想将重复的单元格设置为特定的样式以便于识别，可以使用“条件格式”功能。以下是设置步骤：

选择范围：首先，选择你想要检查重复值并设置样式的单元格区域。如果你希望对整个列应用此格式，可以点击列标题（如A列就点击A），或者拖拽选择整个列。
应用条件格式：
转到“开始”选项卡，在“样式”组中点击“条件格式”按钮。
在下拉菜单中，选择“突出显示单元格规则”。
接着，从子菜单中选择“重复值”。


设置格式：
会出现一个对话框，询问你如何标记重复值。在这里，你可以选择预设的格式样式，比如浅红填充色深红色文本、绿色填充色等。
如果你不满意预设样式，可以点击“自定义格式…”按钮来自定义填充颜色、字体颜色、边框等。
选择好格式后，点击“确定”。



完成以上步骤后，Excel会自动将选定范围内所有重复的单元格按照你设定的格式进行高亮显示，便于你快速识别和处理这些重复数据。
假设每一行数据由第1列第二列联合起来做主键，请问如何在这个基础上保证数据不会重复？在Excel中，虽然没有直接建立联合主键的功能像数据库那样，但你可以通过数据验证的自定义公式来间接实现基于两列数据联合的唯一性检查。以下是一个示例步骤，假设你要确保A列和B列的组合值是唯一的：

选择范围：选择你想要应用数据验证的起始单元格，以及你想要这个规则应用到的所有相应单元格。例如，如果你想从第二行开始应用规则，可以选择A2:B最后一行。

应用数据验证：

转到“数据”选项卡，在“数据工具”组中点击“数据验证”按钮。
在弹出的“数据验证”对话框中，选择“设置”标签页。
在“允许”下拉菜单中选择“自定义”。


输入自定义公式：

在“公式”框中输入以下自定义公式（这里以A列和B列为例，根据你的实际列调整）:
Code
1=AND(COUNTIFS(A:A,A2,B:B,B2)=1,COUNTIFS(B:B,B2,A:A,A2)=1)

这个公式会检查当前行的A列和B列组合是否在A列和B列的其他任何地方出现过。



完成设置：

点击“确定”应用数据验证规则。



请注意，这个方法适用于手动数据输入时的即时验证。如果你的数据集很大或者经常需要批量导入数据，这种方法可能不够高效，因为Excel不会主动去检查整个数据集的唯一性，而是在用户尝试输入数据时才进行验证。对于这种情况，你可能需要先使用Excel的“删除重复项”功能检查并处理已有的重复数据，或者在数据输入前通过编程手段（如VBA宏）来实现更复杂的校验逻辑。
]]></content>
      <categories>
        <category>Office</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>Office</tag>
      </tags>
  </entry>
  <entry>
    <title>UnRaid使用指南</title>
    <url>/2024/10/04/UnRaid%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[设置中文
切换到 TOOLS 选项卡中，找到Language，点击进入后，输入如下URL： https://gitee.com/wsh-feiyu/language-templates/raw/master/limetech/lang-zh_CN.xml，然后点击INSTALL。


输入这个项目的汉化插件：https://github.com/seanzhang98/unraid_zh_CN_Beta
由于github访问困难，可以对这个文件做镜像，比如使用gitee：https://gitee.com/wsh-feiyu/language-templates/raw/master/limetech/lang-zh_CN.xml


点击完成INSTALL按钮之后，页面可能没有反应，可以按下F5刷新一下。当出现 简体中文后，语言包安装成功。



进入 SETTINGS设置页面，找到 Display Settings，点进去。



修改显示语言为 简体中文




然后下拉页面，点击APPLY更改，然后再次下拉点击完成按钮。



至此，中文设置完成。




安装应用商店配置网络代理（需要借助clash）
使用ssh或web界面的终端打开命令窗口

编辑/root/.wgetrc这个文件（这个文件可能不存在）

在其中写入如下代码：（建议使用ssh客户端进行）

use_proxy=yes
http_proxy=http://[你的clash设备IP]:[端口默认7890]
https_proxy=http://[你的clash设备IP]:[端口默认7890]
wait=10

如：

use_proxy=yes
http_proxy=http://192.168.172.216:7897
https_proxy=http://192.168.172.216:7897
wait=10
   2. &gt; 这段的含义就是，让unraid的wget走代理，因为下载安装是用的wget服务（根据我搜索了大量的文章，看了很多大佬的解决方法，最终确认，这个是管用的，我是6.11.5版本。**其他的修改profile的，直接在/usr/local/sbin/emhttp &amp;加proxy的，都不管用**）4. 编辑完保存，**不需要重启**，现在去APPS下点击install，已经可以安装市场了。5. 如果安装还是失败,测试指定的代理能否正常工作:   1. 先使用 `curl -x http://192.168.172.216:7897 www.google.com `测试代理是否正常`-x` 选项指定要使用的代理服务器，后面跟的是代理的URL（包括地址和端口）。例如，`-x http://192.168.172.216:7897` 表示通过指定的代理访问后面的URL。6. 此时,应用商店就能正常访问了.   1. ![image-20241004125236849](/Image/unraid使用指南.assets/image-20241004125236849.png)      ## 设置开机启动   因为unraid是从U盘启动的，重启后刚刚编辑的root/.wgetrc这个文件就没了，所以要编辑/boot/config/go这个文件，写入以下代码即可   ```text   echo &quot;use_proxy=yes&quot; &gt;&gt; /root/.wgetrc   echo &quot;http_proxy=http://[你的clash设备IP]:[端口默认7890]&quot; &gt;&gt; /root/.wgetrc   echo &quot;https_proxy=http://[你的clash设备IP]:[端口默认7890]&quot; &gt;&gt; /root/.wgetrc   echo &quot;wait=10&quot; &gt;&gt; /root/.wgetrc



这段的含义就是U盘引导开机的时候，在root里面写入一个.wgetrc的文件，就是把上面的代码开机的时候新建写入一遍。


Fatal error during checkPluginlnProgress SweetAlert:Unexpected 2nd argument (function (isConfirm) {if (isConfirm) {hidePluginPending(pluginURL);if($(“.selectedMenu”).data(“category”)&#x3D;&#x3D; “action centre”){var postFunction &#x3D;”actionCentre”} else {var postFunction&#x3D;”OpenSidebarAndRefreshDisplay”
port=7897tunnel=1proxy=http://192.168.172.216





主界面中硬盘顺序
似乎：

sda为U盘（系统）
sdb为距离开机按键最远的一块硬盘
sdc、sdd依次

能正确读取到硬盘SN码，换完硬盘需要手动保存硬盘序列号和盘位关系。
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>UnRaid</tag>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础教程</title>
    <url>/2024/02/29/Java%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[Java概述Java技术体系平台Java SE（Java Standard Edition）：标准版支持面向桌面级应用的Java平台，提供了完整的Java核心


Java EE（Java Enterprise Edition）：企业版为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet、Jsp等，主要针对于Web应用程序开发。版本以前称为J2EE


Java ME（Java Micro Edition）：小型版支持Java程序运行在移动终端(手机、PDA) 上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME


Java 重要特点
Java 语言是面向对象的(oop)。

Java 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证。

Java 语言是跨平台性的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]

Java 语言是解释型的[了解]
解释性语言：javascript,PHP, java 编译性语言: c &#x2F; c++
区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行, 编译性语言, 编译后的代码, 可以直接被机器执行。

Java内置了多线程的支持。

Java是动态的。基本组成单元是类，类是在运行的时候动态装载的，可以在环境中动态的维护程序和类库。（在面向对象时就区分了编译类型和运行类型）


Java的运行机制及运行过程JVM Java虚拟机 Java virtual machine
JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在 JDK 中。
对于不同的平台，有不同的虚拟机。
Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”。（即运行环境相等）

JDK Java开发工具包 Java Development KitJDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。


JRE Java运行环境 Java Runtime Environment包括 Java 虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序， 计算机中只需要安装 JRE 即可。


JDK、JRE 和 JVM 的包含关系
JDK &#x3D; JRE + 开发工具集（例如 Javac,java 编译工具等)
JRE &#x3D; JVM + Java SE 标准类库（java 核心类库）
如果只想运行开发好的 .class 文件 只需要 JRE

Java 开发注意事项和细节
Java源文件以.java为扩展名。源文件的基本组成部分是类(class) 。
Java应用程序的执行入口是main()方法。它有固定的书写格式:public static void main(String[] args) {..}
Java语言对大小写敏感。
Java方法由一条条语句构成，每个语句以”；“结束。
大括号都是成对出现的，缺一不可。 [习惯，先写{}再写代码]
一个源文件中最多只能有一个public类。 其它类的个数不限。
如果源文件包含一个public类，则文件名必须按该类名命名!
一个源文件中最多只能有一个public类。其它类的个数不限，也可以将main方法写在非public类中，然后指定运行非public类，这样入口方法就是非public的main方法

Java中常用的转义字符
\t ：一个制表位，实现对齐的功能
\n ：换行符
\\ ：一个\
\“ :一个”
\‘ ：一个’
\r :一个回车 （光标回到当前行的第一个字符）

Java注释（comment）Java 中的注释类型
单行注释 &#x2F;&#x2F;
多行注释 &#x2F;* *&#x2F;
文档注释 &#x2F;** *&#x2F;

使用细节
被注释的文字，不会被 JVM（java 虚拟机）解释执行
多行注释里面不允许有多行注释嵌

文档注释注释内容可以被JDK提供的工具Javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。一般写在类。


生成文档注释javadoc -d 文件名 -xx -yy zzz.java //文件名指存放的位置，xx、yy指参数，可以通过javadoc -help进行查看，

Java 代码规范
类、方法的注释，要以Javadoc的方式来写。
非Java Doc的注释，往往是给代码的维护者看的，着重告述读者为什么这样写，如何修改，注意什么问题等
使用tab操作， 实现缩进,默认整体向右边移动，时候用shift+ tab整体向左移
运算符和&#x3D;两边习惯性各加一个空格。比如:2 + 4 * 5 + 345 - 89
源文件使用utf-8编码
行宽度不要超过80字符
代码编写次行风格和行尾风格。

路径相对路径从当前目录开始定位，形成一个路径，含义是相对于现在这个目录，我指定的在哪里。在不同目录下该路径的含义不同。如：
..\abc2				//指向上一个文件夹中的abc2文件。	..表示返回上一级

绝对路径从根目录开始定位，只要是在这个计算机内就能保证路径指向的唯一性。如：
D;\hurr\test

Windows下简单的DOS命令
查看当前目录是有什么内容
dir D:\hurriedlu\test
切换到其他目录下
cd D:\Programs
切换到上一级目录 (使用相对路径)
cd ..
切换到根目录
cd \
查看指定的目录下所有的子级目录
tree
清屏
cls
退出 DOS
exit




Java中的变量同c、c++一样，每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间(字节)。


在Java中，整个数据类型可分为两大类：

基本数据类型和引用数据类型。
基本数据类型


数据类型
标识符
默认值
存储大小(字节)
数据范围



整型
byte
0
1
-128~127


整型
short
0
2
-32768~32767


整型
int
0
4
-2147483648~2147483647


整型
long
0L&#x2F;0l
8
-2^63~2^63-1


实型
float
0.0F&#x2F;0.0f
4
32位IEEEE 754单精度范围


实型
double
0.0&#x2F;0.0D&#x2F;0.0d
8
64位IEEEE 754双精度范围


逻辑
boolean
false
1bit
true或false


字符
char
空
2
Unicode的字符范围: ‘\u0000’ (即为0)到’\uffff’ (即为65,535)


同c、c++有些许不同，虽然要求任何变量在使用前必须初始化，但变量在定义的时候已经有初值了。（c中只有全局变量才有初值）
使用细节
Java中各整数类型都有固定的范围和字段长度，不受操作系统的影响，保证了可移植性。

整形变量默认为int型，声明long型需要在后面加上l或者L。

同c、c++有些许不同，虽然要求任何变量在使用前必须初始化，但变量在定义的时候已经有初值了。（c中只有全局变量才有初值）

注意数据范围，小心溢出。

对于浮点型而言，其中的数值不是准确的，存储的仅是近似值。因此，在比较浮点型数据中，一般的方法是将两个数相减，如果差值小于精度的要求，就认为是相等的。如下：
double num1 = 2.7;double num2 = 8.1/3;if(Math.abs(num1-num2)&lt;0.00001)    System.out.println(&quot;两个数相等&quot;);
字符常量是用单引号括起来的单个字符，因为使用的是Unicode编码，因此可以存储汉字，且占用空间是2个字节。

在Java中char是可以进行运算的，和c相同，当成一个整数。


类型转换自动类型转换Java在赋值和运算时，精度小的类型会自动转换为精度大的数据类型，这就是自动类型转换。


```**char -&gt; int -&gt; long -&gt; float -&gt; double**
**byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double**##### 自动类型转换中需要注意的细节1. 有多种类型的数据混合运算时，系统首先自动将所有数据转换成（精度）容量最大的那种数据类型，然后再进行计算。2. 当我们把精度(容量)大的数据类型赋值给精度(容量)小的数据类型时，就会报错，反之就会进行自动类型转换。3. (byte, short)和char之间不会相互自动转换。4. byte, short, char 他们三者可以计算，在计算时首先转换为int类型（自动）。5. boolean不参与转换。6. 自动提升原则：表达式结果的类型自动提升为操作数中最大的类型。#### 强制类型转换
自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符 ( )，但可能造成
**精度降低或溢出**，格外要注意。##### 强制类型转换细节1. 当需要对精度（容量）大的转换为小的的时候，就需要使用到强制转换。2. 强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级。   ```java   int x = (int)10 * 3.5 + 5 * 1.5;		//42.5   int y = (int)(10 * 3.5 + 5 * 1.5); 		//42

char类型可以保存int的常量值，但不能保存int的变量值，需要强转。（即以字符形式存储整型值）
char c1 = 100; //okint m = 100; //okchar c2 = m; //错误char c3 = (char)m; //okSystem.out.println(c3);//100对应的字符
byte和short，char类型在进行运算时，当做int类型处理。


引用类型每种编程语言都有自己操作内存中元素的方式，例如在 C 和 C++ 里是通过指针，而在 Java 中则是通过“引用”。


在 Java 中一切都被视为了对象，但是我们操作的标识符实际上是对象的一个引用（reference）。


通过将这个叫“引用”的标识符指向某个对象，之后便可以通过这个引用来实现操作对象了。


最常用的引用类型就是String，它可以很方便的存储字符串。


对于引用在后面面向对象的时候会详细的讲，这里只需要直到引用类型不能直接&#x3D;&#x3D;来判断值是否相同。
基本数据类型与String类型的转换基本数据类型转String基本类型+&quot;&quot;;	//基本类型加上一个空串就行

String转基本类型通过基本类型的包装类调用parseXX方法即可。
Integer.parseInt(&quot;123&quot;);Double.parseDouble(&quot;123.1&quot; );Float.parseFloat(&quot;123.45&quot;) ;Short.parseShort(&quot;12&quot; ); Long.parseLong(&quot;12345&quot; );Boolean.parseBoolean(&quot;true&quot;);Byte.parseByte(&quot;12&quot;);

注意事项
在将 String 类型转成基本数据类型时，比如我们可以把 “123” , 转成一 个整数，但是不能把 “hello”转换成整数。
对于格式不正确的转换，会直接抛出异常，程序停止。
不同于c，会从头开始转换，直到不能转换为止，如123abc可以转换成整数123，但这在Java中是不可以的。

Java中常用编码简介ASCII码最通用的单字节编码系统，等同于国际标准ISO/IEC 646 。


传统ASCII码规定了128个字符，只占用了一个字节中的后七位


扩展ASCII码扩展了128给，即一个字节八个位全都有使用。扩展ASCII码允许将每个字符的第8 位用于确定附加的128 个特殊符号字符、外来语字母和图形符号。


Unicode 编码
Unicode的好处: 每一个符号都给予一 个独一无二的编码，使用Unicode没有乱码的问题。
Unicode的缺点:一个英文字母和一个汉字都占用2个字节，这对于存储空间来说是浪费。
2的16次方是65536，所以最多编码是65536个字符。
Unicode码兼容ASCII码。编码0- 127的字符是与ASCII的编码一样，比如’a’ 在ASCII码是0x61，在Unicode码是0x0061,都对应97。

UTF-8编码
UTF-8是在互联网上使用最广的一种Unicode的实现方式(改进)。
UTF-8 是一种变长的编码方式。它可以使用1-6个字节表示一个符号， 根据不同的符号而变化字节长度。
使用大小可变的编码字母占1个字节，汉字占3个字节。

Java中的加号整个表达式从左往右进行运算，当运算符两边是数值时进行数值上的相加，当读到有非数值的时候，从此刻开始直到整个表达式结束，+号的作用变成了连接。如下：

System.out.println(100 + 98); //198System.out.println(&quot;100&quot; + 98)//10098System.out.println(100 + 3 + &quot;hello&quot;);//103helloSystem.out.println(&quot;hello&quot; + 100 +3); //hello1003
运算符与C++中的运算符类似，此处不再详细笔记。如有不同则会在后期添加

赋值运算符：&#x3D;
算数运算符：+ - * &#x2F; %
关系运算符：&gt; &lt; &gt;&#x3D; &lt;&#x3D; !&#x3D; &#x3D;&#x3D;
逻辑运算符（短路符，即一旦确定值后直接结束）： &amp;&amp; ||
（非短路，会全部运算完）&amp; | !

自增自减符：++ –
三元运算符： 条件表达式?表达式1：表达式2；
下标运算符：[]
类型转换：（）
其他运算符：new instanceof 位运算符 访问成员运算符

instanceof用于检查是否是类的对象。常用于后面的多态的向下转型。先判断这个对象引用的运行类型是否属于某个子类，是的话就可以进行向下转型。

标识符的命名标识符概念
Java 对各种变量、方法和类等命名时使用的字符序列称为标识符
凡是自己可以起名字的地方都叫标识符int num1 &#x3D; 90;

标识符的命名规则(必须遵守)与c++相同
由26个英文字母大小写，0-9，_或$组成。汉字也行，但不推荐。
数字不可以开头。
不可以使用关键字和保留字，但能包含关键字和保留字。
Java中严格区分大小写， 长度无限制。
标识符不能包含空格。

标识符命名规范
包名：多单词组成时所有字母都小写：aaa.bbb.ccc
类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰]
变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小驼峰， 简称 驼峰法]
常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ

后面我们学习到 类，包，接口，等时，我们的命名规范要这样遵守,更加详细的看文档。
Java中的位运算&amp;按位与：对应的两位全为1，结果为1

|按位或：对应位有1为1

^按位异或：对应位相异为一

~按位取反

&gt;&gt;算术右移 ：低位溢出，符号位不变，并用符号位补溢出的高位。

&lt;&lt;算术左移 ：符号位不变,低位补 0

&gt;&gt;&gt;逻辑右移：也叫无符号右移，运算规则是: 低位溢出，高位补 0

注意，没有逻辑左移！！！关键字关键字的定义和特点 (不用背) 定义：被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词） 特点：关键字中所有字母都为小写。
用于定义数据类型的关键字：
class
interface
enum
byte
short
int 
long
float
double
char
boolean
void

用于定义数据类型值的关键字
true
false
null

用于定义流程控制的关键字
if
else
switch
case
default
while
do
for
break
continue
return

用于定义访问权限修饰符的关键字
private
protected
public

定义类、函数、变量修饰符的关键字
abstract
final
static
synchronized

定义类与类之间关系的关键字
extends
implements

用于建立实例及引用实例、判断实例的关键字
new
this
super
instanceof

用于异常处理的关键字
try
catch
finally
throw
throws

用于包的关键字
package
import

其他修饰符关键字
native
strictfp
transient
volatile
assert

保留字现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留 字 byValue、cast、future、 generic、 inner、 operator、 outer、 rest、 var 、 goto 、const。

键盘输入语句
导入该类的所在包,  java.util.Scanner。
创建该类对象（声明变量）。
调用里面的功能。

常用的语句如下：
Scanner scanner = new Scanner(System.in);	//定义方法int num = scanner.nextInt();				//读取int类型double d = scanner.nextDouble();			//读取浮点型String s = scanner.next();					//读取字符串
数组、排序和查找数组的定义一维数组声明数组的元素类型 [] 数组名;数组的元素类型  数组名 [];
分配元素数组名 = new 数组元素的类型[个数];
同时进行声明和分配元素int num[] = new [10];//定义了一个int类型的一维数组，有10个元素，下标范围0-9
二维数组声明数组的元素类型 [][] 数组名;数组的元素类型 数组名[][];
分配元素数组名 = new 数组元素的类型[个数][个数];
同时进行声明和分配元素int num[][] = new [10][12];//定义了一个int类型的一维数组，有10个元素，下标范围0-9
数组的遍历一维数组不利用方法int num[] = new int[10];for (int i = 0; i &lt; num.length; i++) &#123;    System.out.println(num[i] + &#x27; &#x27;);&#125;
利用方法int num[] = new int[10];System.out.println(Arrays.toString(num));//利用数组类里面的toString方法，直接将整个数组转换成字符串的形式
二维数组不利用方法int arr[][] = new int[10][10];for (int i = 0; i &lt; arr.length; i++) &#123;    for (int j = 0; j &lt; arr[i].length; j++) &#123;        System.out.print(arr[i][j] + &quot; &quot;);    &#125;&#125;
利用方法int arr[][] = new int[10][10];for (int i = 0; i &lt; arr.length; i++) &#123;    System.out.println(Arrays.toString(arr[i]));&#125;
与c的不同之处
首先就是定义的方法不同。
其次就是，在二维数组中，在c里面可以以一维的方式进行访问（即第二行第一列等于第一行+1），但在java中不行。
java中的二维数组相当于：我定义了一个一维数组，里面存放了指向一个一维数组的地址。
因此，在Java中，二维数组可以不再是矩形的了，每一行的空间都可以单独的定义。比如这样：

int arr[][] = new int[10][];arr[2]=new int[112];arr[1]=new int[10];arr[2]=new int[13];

因为可以Java的特性，导致了数组的列数可能不统一，且每一行都能获取到当前行有多少列
有一点和C是一样的，就是数组一旦分配了就不能在更改长度，只能对该一维数组重新定义，然后把老的数组里面的值复制到新数组。
有一点和新版本的C是相似的，就是允许在运行的过程中分配空间，而不是在编译的时候就需要确定好。（c98以前的标准不允许）

程序控制结构在Java中，也分为三大流程控制：顺序控制 分支控制 循环控制。对应的语句和c也一样，此处不在进行笔记，不同的地方后期补足。
增强for循环语法for(暂存变量:数组名)&#123;    System.out.println(暂存变量);&#125;//需要注意暂存变量的类型需要与数组中元素的类型相同。在每次循环中会自动的将数组中的元素一次赋值给 
使用样例如下：
int nums[] = &#123;1,3,9&#125;;for(int i:nums)&#123;  System.out.print(i+&quot; &quot;);&#125;String s[] = &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;;for(String t:s)&#123;  System.out.print(t+&quot; &quot;);&#125;//运行结果：1 3 9 a b c 
面向对象：类与对象的关系
把需要的属性和方法抽象出来就形成了类，将类实例化后形成对象，形成对象后可以为其个性化。


类是抽象的，概念的，代表一类事物,比如人类,猫类.., 即它是数据类型。
对象是具体的，实际的，代表一个具体事物, 即 是实例
类是对象的模板，对象是类的一个个体，对应一个实

属性、成员变量（字段）基本介绍从概念或叫法上看： 成员变量 &#x3D; 属性 &#x3D; field(字段) （即 成员变量是用来表示属性的)。
属性是类的一个组成部分，可以是是基本数据类型,也可是引用类型(对象，数组)。
注意事项
属性的定义语法同变量
属性的定义类型可以为任意类型，包含基本类型或引用类型
属性如果不赋值，有默认值，规则和数组、变量一致。

对象创建对象
先声明再创建

1. Cat cat ; //声明对象 cat 2. cat = new Cat();

直接创建

Cat cat = new Cat();
访问对象的属性cat.name;	//对象名.属性名;
对象的细节类和对象的内存分配机制Java 内存的结构分析
栈： 一般存放基本数据类型(局部变量)。
堆： 存放对象(Cat cat , 数组等)。
方法区：常量池(常量，比如字符串)， 类加载信息

Java 创建对象流程的简单分析
先加载 Person 类信息(属性和方法信息, 只会加载一次。
在堆中分配空间（地址），进行默认初始化(看规则)
把地址赋给一个引用类型的变量，就指向对象
进行指定初始化， 比如 p.name &#x3D;”jack”

对象在内存中存在形式
程序运行时，会将整个类加载到”方法区“（只加载一次）。
当将类实例化成对象的时候，会按照方法区的类在堆中开辟一个空间，如果其中引用了字符串之类的，会将位于常量池的字符串的地址写入堆中对应的位置，如果是普通类型，会分配空间并使空间清零。
在栈中创建一个对象的引用变量，并将堆中的地址写入栈中。

成员方法基本介绍在某些情况下，我们要需要定义成员方法(简称方法)。比如人类:除了有一些属性外( 年龄，姓名..),我们人类还有一 些行为比如:可以说话、跑步..,通过学习，还可以做算术题。这时就要用成员方法才能完成。

方法，也称为函数。

方法的调用机制原理
当程序执行到方法的时候，就会开辟一个独立空间。
当方法执行完毕，或者执行到return语句时，就会返回到调用方法的地方继续执行（类似于中断）。
当整个main方法（栈）执行完毕，整个程序退出。


和C++一样，每个函数的空间独立，其中的局部变量的生存期和作用域都不会超出这个函数的空间

成员方法的意义
提高代码的复用性。
可以将实现的细节封装起来，然后供其他用户来调用

成员方法的定义：访问修饰符 返回数据类型 方法名（形参列表..） &#123;//方法体语句;return 返回值;&#125;

形参列表：表示成员方法输入 cal(int n) ， getSum(int num1, int num2)。
返回数据类型：表示成员方法输出, void 表示没有返回值。
方法主体：表示为了实现某一功能代码块。
return：返回一定的值，如在方法中计算得到的值，或者状态。该语句不是必须的 。

方法的细节
一个方法最多有一个返回值，如需返回多个可以借助数组或者类。
返回类型可以为任意类型，包含基本类型或引用类型(数组，对象)。
如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值; 而且要求返回值类型必须和 return 的 值类型一致或兼容。
如果方法是 void，则方法体中可以没有 return 语句，或者 只写 return ;
方法名遵循驼峰命名法，最好见名知义，表达出该功能的意思即可。
一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开，比如getSum(int n1,int n2)。
参数类型可以为任意类型，包含基本类型或引用类型，比如printArr(int[][] map[] [] )。
调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数! [getSum]
方法定义时的参数称为形式参数，简称形参;方法调用时的传入参数称为实际参数，简称实参，实参和形参的类型要一致或兼容、 个数、顺序必须致! 
方法体里面写完成功能的具体的语包，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法!即:方法不能嵌套定义。[演示]
传入方法的并不是原来的元素，而是其中的值。对于普通类型来说，因为传进去的是直接的值，相当于拷贝一份进去，因此不会影响到原来变量的地址；但对引用类型来说，传入的是一个地址，针对地址的修改会直接影响到原来的值。（好像与C++中有些不太一样，String是引用类型，但如果传到函数中并对其进行修改，回到main中再输出还是修改之前值）。
当方法是static的时候，表示这是一个静态的方法，可以不用实例化成对象，直接通过类名.方法名进行调用。具体细节后面说。

可变参数基本概念java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。 就可以通过可变参数实现。

简单的说就是当成一个不定长的数组，传入的一瞬间为这堆数开辟一个空间放进去，并把首地址传入。

基本语法访问修饰符 返回类型 方法名(数据类型... 形参名) &#123; &#125;public int fun(int ... nums)&#123;  int sum=0;  for(int i=0;i&lt;nums.length;i++)  &#123;    sum+=nums[i];  &#125;  return sum;&#125;
作用域基本使用面向对象中，变量作用域是非常重要的。


在java编程中，主要的变量就是属性(成员变量)和局部变量。
我们说的局部变量-般是指在成员方法中定义的变量。 [举例Cat类: cry]
java中作用域的分类全局变量:也就是属性，作用域为整个类体；局部变量:也就是除了属性之外的其他变量，作用域为定义它的代码块中!
全局变量(属性)可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值。

注意事项和细节
属性和局部变量可以重名，访问时遵循就近原则。
在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名。
属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而销毁。即在一次方法调用过程中。
作用域范围不同全局变量&#x2F;属性:可以被本类使用，或其他类使用(通过对象调用)局部变量:只能在本类中对应的方法中使用
修饰符不同全局变量&#x2F;属性可以加修饰符局部变量不可以加修饰符

构造方法&#x2F;构造器基本介绍构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。

特点：
方法名和类名相同。
没有返回值。
在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。

基本语法[修饰符] 方法名(形参列表)&#123; 方法体; &#125; 
具体说明
构造器的修饰符可以默认， 也可以是 public protected private
构造器没有返回值。
方法名 和类名字必须一样。
参数列表 和 成员方法一样的规则。
构造器的调用, 由系统完成。
一个类可以定义多个不同的构造器，即构造器重载
构造器是完成对象的初始化，并不是创建对象
在创建对象时,系统自动的调用该类的构造方法
如果程序员没有定义构造器，系统会自动给类生成一 个默认无参构造器(也叫默认构造器)，比如Dog (){}, 可以使用javap指令反编译查看到
一旦定义了自己的构造器,默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下,即: Dog( ){ }

this什么是thisjava虚拟机会给每个对象分配this，代表当前对象。

简单的说，this存储的当前对象的地址，哪个对象调用this，this就代表哪个对象

this 的注意事项和使用细节
this 关键字可以用来访问本类的属性、方法、构造器。
this 用于区分当前类的属性和局部变量。
访问成员方法的语法：this.方法名(参数列表); 。
访问构造器语法：this(参数列表); 注意只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一 条语句)。
this 不能在类定义的外部使用，只能在类定义的方法中使用。

包包的作用
区分相同名称的类
当类较多的时候，可以很好的管理类。
控制访问范围。

包的存在类似于电脑的文件夹，采用树状结构存放其中的文件。同一个包中的类不能重名，但不同包之间可以有重名的类。

基本语法声明存在位置package 包名；

package net.hurr.test;
包的引入import 包名；

improt 包名;
作用使用该包下面的类，可以使用通配符*。如导入Scanner类：

import java.util.Scanner;import java.util.*;
建议使用前者，用哪个导哪个。

部分IDE如Idea回自动导，不需手写。

访问修饰符(访问权限)


访问级别
访问控制修饰符
同类
同包
子类
不同包



公开
public
√
√
√
√


保护
protected
√
√
√
×


默认（不写）

√
√
×
×


私有
private
√
×
×
×



public：对外公开，均可访问
protested：对子类和同一个包中的其他类公开
默认：仅对同一个包中的类公开
private：只有本类成员可以访问，不对外公开。

面向对象三大特征：封装、继承、多态。将共有的属性抽象出来，封装成一个个小单元，如果需要的新的功能与之前的有些区别，可以通过继承的方式增加属于自己的功能。有些功能可能之前写过了，但不太符合需求，可以通过重写的方式更新对应方法，或者做出来的可能会有好几种的用途，根据用途不同可以重载一下。重载和重写就是多态的具体实现方式。

封装将抽象出来的数据（属性）和对数据的操作（方法）打包封装在一起，数据就会被保护在内部（私有化），想要使用只能通过对应的暴露在外面的方法进行操作，这样可以检查操作的合法性。

封装的好处
隐藏实现的细节。
可以对数据进行验证，保证安全合法

继承
继承很好的解决了代码复用的问题。类似于函数但比函数功能更加丰富。

对于两个相似的类，可以抽出其中共有的属性和方法，将其封装成父类，然后通过继承的方式继承父类即可，对于有差异的地方可以在继承后的子类中添加。
语法

class 子类名 extends 父类名&#123;&#125;
继承的好处
提高了代码的复用性
提高了代码的扩展性和维护性

继承的细节
子类继承了所有的属性和方法，非私有的属性可以在子类中直接访问，私有的属性和方法只能通过父类提供的公共方法来访问使用。
子类没有继承父类的构造器，所以必须调用父类的构造器，以完成父类的初始化。
创建子类对象时，不管使用了子类的哪个构造器，默认情况下都会去调用父类的无参构造器完成父类的初始化。如果父类没有预留无参构造器，则在子类中必须手动选择父类的有参构造器，否则编译器会报错。
如果需要指定调用父类的某个构造器，需要显示的调用一下：super(参数列表)
super()在使用的时候，必须放在构造器的第一行（super() 只能在构造器中使用）
super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器中。
java的所有类都是Object类的子类，Object是所有类的基类。
父类的构造器的调用不限于直接父类，可以一直往上追溯到Object类。
子类最多继承一个父类，因为Java是单继承的，因此不存在c++中的二义性的问题。如果一个类需要继承多个类，可以将这几个类串联在一起。
不能滥用继承，子类和父类之间必须满足 is – a的逻辑关系。

继承的本质当子类对象创建成功后，建立的查找关系。当创建了一个子类的时候，所有的属性（包括父类中的）全部都在对象内，但由于访问权限的不同不一定都可以访问。

查找属性和方法时，先从子类（最低级）开始寻找，一直找到最高类Object类。这其中如果有父类存在这个方法或者属性但权限是私有不允许访问的，则就不会继续向上查找，并报private的异常。

super
super代表父类的引用，用于访问父类的属性、方法、构造器。
super只能在类内使用，即只能在子类中通过super直接访问上一级中的属性。如果在main中将子类实例化后，不能在main中通过super访问父类。
要注意的是，super不能串联使用。他只能穿透一层。即有重名的属性的化，只能访问离自己最近的那个重名的。
super类似于一个指针（虽然java中没有指针的功能），存储了父类的地址。

基本语法
访问父类的属性（不能访问父类的private的属性）
  super.属性名;


访问父类的方法（同样不能访问private）
 super.方法名;


访问父类的构造器：只能在第一行
 super(参数列表);



super带来的便利
调用父类的构造器。
当子类与父类中的成员重名的时候，为了访问父类的成员，可以通过super访问。但仅限于访问被直接掩盖的。
super的访问不限于直接父类，如果爷爷类和本类中有共同的成员，也可以访问到爷爷类的成员。如果多个基类都有同名的成员，使用super访问遵循就近原则。（即只能穿透一层）

super和this的比较


区别点
this
super



访问属性、方法
优先在本类中进行查找，
越过本类，直接在父类中进行查找


调用构造器
调用本类的构造器，必须放在构造器的首行
调用父类的构造器，必须放在构造器的首行


特殊
表示当前对象
子类访问父类的对象


换句话数，this和super类似，一个存储了本类的地址，另一个存储了父类的地址。可以通过这个“地址”来控制访问
方法重写&#x2F;覆盖：简单的说，重写（覆盖）就是子类的一个方法，和父类的某个方法的名称、参数均一样，我们就说子类的这个方法覆盖了父类的方法。（类似于重载）

方法覆盖的注意事项和使用细节
子类的方法的形参列表、方法名，要和父类的对应的方法完全一致。
子类的方法的返回值需要和父类中被覆盖的方法保持一样，或者是父类返回类型的子类。如父类返回是Object，子类的返回类型是String，要保证子类的返回值可以向上转型为父类。
被覆盖的方法不能是private，否则只是在其子类中新定义了一个方法，并没有对其覆盖。
子类的方法不能缩小父类方法的访问权限，如父类是protected，子类可以是public、protected，但不能是private。

方法的重写和重载的对比


名称
发生范围
方法名
形参列表
返回类型
修饰符



重载  (overload)
本类
必须一样
类型，个数或者顺序至少有一个不同。
无要求
无要求


重写  (override)
父子类
必须一样
相同
子类重写的方法，返回类型和父类返回的类型一致，或者是其子类
子类方法不能缩小父类方法的访问范围。


多态基本介绍
方法或对象具有多种形态。
多态是面向对象的第三大特征。
多态是建立在封装和继承的基础上的。

多态的具体体现1.方法的多态

重写和重载。

2、 对象的多态

一个对象的编译类型和运行类型可以不一致。
编译类型在定义对象时，就已经确定了，不能更改。
运行类型是可以变化的（向上转型、向下转型）
编译类型看&#x3D;左边，运行类型看&#x3D;右边。

多态的注意事项
多态的前提：两个对象（类）存在继承关系。
多态的向上转型：

多态的向下转型本质将向上转型后的父类重新指回子类。

语法子类类型 引用名 = （子类类型）父类类型;
特点
只能强转父类的引用，不能强转父类的对象。即对象是子类的，但是被父类引用了。
要求父类的引用必须指向的是当前目标类型的对象。
向下转型后，可以调用子类类型中所有的成员。

属性没有重写之说需要注意，如果出现一个父类的引用指向了子类出现了向上转型的情况，当通过父类调用子类方法的时候，是可以正常调用的；但如果通过父类调用属性，则调用的会是父类自身的属性。如下代码可见：

简单的说就是，属性没有重写之说，属性的值看编译类型。

对于向上转型后的引用来说，只有方法是转型成功的，属性只能看引用的类。如果非要访问可以通过向下转型进行访问。

package net.hurr.test;public class Test &#123;    public static void main(String[] args) &#123;//属性没有重写之说！属性的值看编译类型        Base base = new Sub();//向上转型        System.out.println(base.count);// ？ 看编译类型 10        base.f();        Sub sub = new Sub();        System.out.println(sub.count);//? 20        sub.f();    &#125;&#125;class Base &#123; //父类    int count = 10;//属性    public void f()    &#123;        System.out.println(&quot;Base&quot;);    &#125;&#125;class Sub extends Base &#123;//子类    int count = 20;//属性    public void f()    &#123;        System.out.println(&quot;Sub&quot;);    &#125;&#125;
如果确实需要在向上转型的同时访问子类的属性，可以手动的向下转型一下，如下代码：
package net.hurr.test;public class Test &#123;    public static void main(String[] args) &#123;//属性没有重写之说！属性的值看编译类型        Base base = new Sub();//向上转型        System.out.println(base.count);// ？ 看编译类型 10        base.f();        Sub sub = new Sub();        System.out.println(sub.count);//? 20        sub.f();        System.out.println(&quot;=================================&quot;);        System.out.println(((Sub)base).count);// 20        System.out.println(sub.count);//? 20    &#125;&#125;class Base &#123; //父类    int count = 10;//属性    public void f()    &#123;        System.out.println(&quot;Base&quot;);    &#125;&#125;class Sub extends Base &#123;//子类    int count = 20;//属性    public void f()    &#123;        System.out.println(&quot;Sub&quot;);    &#125;&#125;
Java的动态绑定机制
当调用对象方法的时候，该方法会和该对象的内存地址&#x2F;运行类型绑定。
当调用对象属性的时候，没有动态绑定机制，哪里声明，就在那里使用。

多态的应用多态数组将数组的定义类型定义为父类，里面保存的实际元素类型为子类对象。（利用向上转型的规则）

多态参数在某个方法中，传入的参数可以是父类的形参，在方法中通过instanceof进行类型判断，如果属于类型A，就执行类型A对应的语句，否则就执行另一种预设的语句。

常用于面对不同身份进行不同的操作。不需要对方法进行重载就能完成。

Object类详解（equals方法）equals与&#x3D;&#x3D;的区别：&#x3D;&#x3D;：

&#x3D;&#x3D;既可以判断基本类型，也可以贩毒案引用类型。
如果判断的是基本类型，判断的是值是否相等。
如果判断的是引用类型如String，则判断是否是同一个对象。（引用类型的本质是指针，&#x3D;&#x3D;只能简单的判断两个值是否相等

equals：

equals是Object类中的方法，只能判断引用类型。
默认判断的是地址是否相同，但在子类中常常重写这个方法。如在String中就重写了，可以判断字符串的值是否相等。

面向对象 中级部分类变量和类方法类变量类变量介绍如果一个类创建的所有对象都需要一个变量（如进行计数），就可以将这个变量设置在类内，并设置成静态变量。

类变量也叫静态变量/静态属性，是该类的所有对象共享的变量,任何一个该类的对象去访问它时,取到的都是相同的值，同样任何一个该类的对象去修改它时修改的也是同一个变量。而且，在类没有实例化成对象的情况下，也可以使用

类变量的定义（基本语法）访问修饰符 static 数据类型 变量名;class A&#123;  public static int n = 10;//这个就是类变量，他的关键字是static。&#125;public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(A.n);//虽然没有实例化，但还是一样可以访问。并且在访问的一瞬间，就会完成类的加载（只会加载一次）    &#125;&#125;
类变量的访问类名.类变量名
类变量使用时的注意事项和细节
什么时候需要用类变量：当我们需要让某个类的所有对象都共享一个变量时， 就可以考虑使用类变量(静态变量):比如:定义学生类，统计所有学生共交多少钱。
类变量与实例变量(普通属性)区别：类变量是该类的所有对象共享的，而实例变量是每个对象独享的。
加上static称为类变量或静态变量，否则称为实例变量&#x2F;普通变量&#x2F;非静态变量 。
类变量可以通过类名.类变量名或者对象名.类变量名来访问，但java设计者推荐我们使用类名.类变量名方式访问。[前提是 满足访问修饰符的访问权限和范围]。
实例变量不能通过类名类变量名方式访问。
类变量是在类加载时就初始化了,也就是说，即使你没有创建对象，只要类加载了，就可以使用类变量了。（在使用的一瞬间就会加载）
类变量的生命周期是随类的加载开始，随着类消亡而销毁。

类变量的内存布局```*在JDK7以前，类变量存储在方法区；在JDK8以后，则就存储在了堆中*### 类方法#### 基本介绍
类方法也叫静态方法，具体细节和上方的类变量类似
#### 基本语法```java访问修饰符 static 数据返回类型 方法名()&#123;  //语句体&#125;class A&#123;  public static void f()&#123;//静态方法    System.out.println(&quot;类A中的静态方法f()已被调用&quot;);  &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;      A.f();//调用了    &#125;&#125;
类方法的经典使用场景当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法提高开发效率。

类方法使用注意事项和细节
类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区:
类方法中无this的参数普通方法中隐含着this的参数

类方法可以通过类名调用，也可以通过对象名调用。

普通方法和对象有关，需要通过对象名调用，比如对象名.方法名(参数)，不能通过类名调用。

类方法中不允许使用和对象有关的关键字，比如this和super。 普通方法(成员方法)可以。

类方法(静态方法)中只能访问静态变量或静态方法.

普通成员方法，既可以访问非静态成员，也可以访问静态成员。


小结:静态方法， 只能访问静态的成员,非静态的方法，可以访问静态成员和非静态成员(必须遵守访问权限)
main方法语法main方法的形式: public static void main(String[] args)&#123;&#125;


main方法时虚拟机调用
java虚拟机需要调用类的main() 方法，所以该方法的访问权限必须是public
java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static
该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数
java 执行的程序参数1参数2参数3 [举例说明:]

java 运行的类名 第一个参数 第二个参数 第三个参数 ...

对应到args数组中：第一个元素，第二个元素，第三个元素...

注意事项
在 main()方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性。
但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。比如：

package net.hurr.test;public class MAIN &#123;    //静态的变量/属性    private static String name = &quot;Hello&quot;;    //非静态的变量/属性    private int n1 = 10000;    //静态方法    public static void hi() &#123;        System.out.println(&quot;MAIN 的 hi 方法&quot;);    &#125;    //非静态方法    public void cry() &#123;        System.out.println(&quot;MAIN 的 cry 方法&quot;);    &#125;    public static void main(String[] args) &#123;//可以直接使用 name//1. 静态方法 main 可以访问本类的静态成员        System.out.println(&quot;name=&quot; + name);        hi();//2. 静态方法 main 不可以访问本类的非静态成员//System.out.println(&quot;n1=&quot; + n1);//错误//cry();//3. 静态方法 main 要访问本类的非静态成员，需要先创建对象 , 再调用即可        MAIN MAIN = new MAIN();        System.out.println(MAIN.n1);//ok        MAIN.cry();    &#125;&#125;/*运行结果：name=HelloMAIN 的 hi 方法10000MAIN 的 cry 方法*/
代码块基本介绍代码化块又称为初始化块属于类中的成员[即是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过&#123;&#125;包围起来。

但和方法不同，没有方法名，没有返回，没有叁数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。

基本语法[修饰符]&#123;  //语句组；&#125;[;]
注意事项
修饰符可选，且只能是static
代码块可分为两大类，一是加上修饰符的静态代码块，二是没加修饰符的普通代码块&#x2F;非静态代码块
逻辑语句可以为任何逻辑语句，包括但不限于输入、输出、方法调用、循环、判断等
结尾的分号可以缺省

代码块的作用、注意事项、细节
相当于另一种形式的构造器（对原有构造器的补充），可以进行初始化操作

使用的场景：如果多个构造器中都有重复的语句，就可以将这些重复的语句抽取到块中，提高代码的复用性。

static代码块也叫静态代码块，作用是对类进行初始化。它随着类的加载而执行，并且只会执行一次。如果是普通代码块，则在创建（实例化）出一个对象的时候，就执行一次。

类什么时候会被加载：

创建对象实例的时候（new）
创建子类对象实例时，父类也会被加载
使用类的静态成员时


普通的代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次。如果只是使用类的静态成员时，普通代码块并不会执行。

创建一个对象时，在一个类的调用顺序是：

调用静态代码块和静态属性初始化（注意，静态代码块和静态属性初始化调用的优先级相等，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）。
调用普通代码块和普通属性的初始化（注意普通代码块和普通属性初始化调用的优先级相等，如果有多个普通代码块和多个普通变量初始化，则按他们定义的顺序调用）。
最后调用构造方法。（构造方法的优先级最低）


构造器的最前面隐藏了super()和调用普通代码块的语句。（先super后普通）。

创建一个子类对象时（继承关系），他们的静态代码块、静态属性初始化、普通代码块、普通属性初始化、构造方法的调用顺序如下：

父类的静态代码块和静态属性（按定义的顺序执行）；

子类的静态代码块和静态属性（按定义的顺序执行）；

父类的普通代码块和普通属性初始化；

父类的构造方法；

子类的普通代码块和普通属性初始化；

子类的构造方法；

个人理解：
将子类实例化的过程：
首先调用了子类的构造方法，因为构造方法第一条语句是super，因此会去调用父类的构造方法，父类的构造方法里也有一个super，有去寻找直接父类的父类直到Object为止。到达Object后，运行Object的静态代码块（因为加载类了），然后加载下一级的静态代码，一直到被实例化的子类为止。将子类加载完后，然后依次将各个类都进行实例化，此时首先运行Object类的普通代码块和构造方法（因为创建对象了），然后按照普通代码块和属性、构造方法的顺序，直到子类完成。（算是递归的思想？好像不太对，因为调用的不是自身）





小结:

static代码块是类加载时执行，只会执行一次。（因为类只会执行一次）
普通代码块是在创建对象时调用的，创建一次，调用一次。（每个对象各调用一次）
类加载的3种情况， 需要记住。（上面第四条）

样例样例1：无继承，两次调用类的静态属性，再实例化对象public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;···············&quot;);        System.out.println(&quot;第一次调用静态属性&quot;);        System.out.println(A.n1);        System.out.println(&quot;···············&quot;);        System.out.println(&quot;第二次调用静态属性&quot;);        System.out.println(A.n1);        System.out.println(&quot;···············&quot;);        System.out.println(&quot;第一次实例化对象&quot;);        A a = new A();    &#125;&#125;class A&#123;    public static int n1 = 100;//静态属性    public int n2 = 200;//普通属性    &#123;        System.out.println(&quot;普通代码块被执行&quot;);//普通代码块    &#125;    static&#123;        System.out.println(&quot;静态代码块被执行&quot;);//静态代码块    &#125;&#125;

运行结果如下：
···············第一次调用静态属性静态代码块被执行100···············第二次调用静态属性100···············第一次实例化对象普通代码块被执行

样例2 有继承，连续调用两次子类的静态属性，调用一次继承得到的父类的属性，然后将子类实例化成对象public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;···············&quot;);        System.out.println(&quot;第一次调用子类的静态属性&quot;);        System.out.println(B.n3);        System.out.println(&quot;···············&quot;);        System.out.println(&quot;第二次调用子类静态属性&quot;);        System.out.println(B.n3);        System.out.println(&quot;···············&quot;);        System.out.println(&quot;第一次调用父类静态属性&quot;);        System.out.println(B.n1);        System.out.println(&quot;···············&quot;);        System.out.println(&quot;第一次实例化对象&quot;);        B b = new B();    &#125;&#125;class A&#123;    public A()&#123;        System.out.println(&quot;类A的构造方法被调用&quot;);    &#125;    public static int n1 = 100;//静态属性    public int n2 = 200;//普通属性    &#123;        System.out.println(&quot;类A:普通代码块被执行&quot;);//普通代码块    &#125;    static&#123;        System.out.println(&quot;类A:静态代码块被执行&quot;);//静态代码块    &#125;&#125;class B extends A&#123;    public static int n3 = 300;    &#123;        System.out.println(&quot;类B:普通代码块被执行&quot;);//普通代码块    &#125;    static&#123;        System.out.println(&quot;类B:静态代码块被执行&quot;);//静态代码块    &#125;    public B ()&#123;        System.out.println(&quot;类B的构造方法被调用&quot;);    &#125;&#125;

运行结果：
···············第一次调用子类的静态属性类A:静态代码块被执行类B:静态代码块被执行300···············第二次调用子类静态属性300···············第一次调用父类静态属性100···············第一次实例化对象类A:普通代码块被执行类A的构造方法被调用类B:普通代码块被执行类B的构造方法被调用

样例3 三次继承继承，直接对子类进行实例化操作package net.hurr.test;public class Test &#123;    public static void main(String[] args) &#123;        C c = new C();    &#125;&#125;class A&#123;    public A()&#123;        System.out.println(&quot;类A的构造方法被调用&quot;);    &#125;    public static int n1 = 100;//静态属性    public int n2 = 200;//普通属性    &#123;        System.out.println(&quot;类A:普通代码块被执行&quot;);//普通代码块    &#125;    static&#123;        System.out.println(&quot;类A:静态代码块被执行&quot;);//静态代码块    &#125;&#125;class B extends A&#123;    public static int n3 = 300;    &#123;        System.out.println(&quot;类B:普通代码块被执行&quot;);//普通代码块    &#125;    static&#123;        System.out.println(&quot;类B:静态代码块被执行&quot;);//静态代码块    &#125;    public B ()&#123;        System.out.println(&quot;类B的构造方法被调用&quot;);    &#125;&#125;class C extends B&#123;    public static int n4 = 400;    &#123;        System.out.println(&quot;类C:普通代码块被执行&quot;);//普通代码块    &#125;    static&#123;        System.out.println(&quot;类C:静态代码块被执行&quot;);//静态代码块    &#125;    public C ()&#123;        System.out.println(&quot;类C的构造方法被调用&quot;);    &#125;&#125;

运行结果：
类A:静态代码块被执行类B:静态代码块被执行类C:静态代码块被执行类A:普通代码块被执行类A的构造方法被调用类B:普通代码块被执行类B的构造方法被调用类C:普通代码块被执行类C的构造方法被调用

单例设计模式什么是设计模式
静态方法和属性的使用。
设计模式是在大量的事件中总结和理论化之后优选的代码结构、编程风格以及解决问题的思考方式。设计模式类似于数学的公式，免得我们自己再思考和摸索。

单例模式单例，就是指单个实例。所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对于某个类只能存在一个对象实例，并且该类只提供一个获取其对象实例的方法。

单例模式有两种实现方式，一是饿汉式，二是懒汉式。具体特点在后面。

大致的实现步骤如下：

        1. 构造器私有化，防止直接new。
        2. 在类的内部创建一个对象
        3. 向外暴露一个静态的方法，以获取其创建的对象

饿汉式package net.hurr.test;public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;获取类A的对象&quot;);        //A a = new A();//不再能通过new的方式进行新建        A a = A.getA();//只能通过暴露的接口获取到对象。在获取的一瞬间对象就会被创建出来。        System.out.println(a);        A b = A.getA();        System.out.println(a == b);//不管怎么获取，获取到的都是同一个对象。    &#125;&#125;class A &#123;    private String name;    private String ID;    private static A a = new A();//饿汉式的特点：直接创建对象，不管是否有需求。为了能在静态方法中返回，需要设置成静态    private A() &#123;//私有化构造函数防止被new，除此之外和普通的构造函数一样。        System.out.println(&quot;类A的构造器被调用&quot;);        name = &quot;nono&quot;;        ID = &quot;00001&quot;;    &#125;    public static A getA() &#123;        return a;    &#125;    @Override    public String toString() &#123;        return &quot;name:&quot; + name + &quot;  ID:&quot; + ID;    &#125;&#125;

运行结果：
获取类A的对象类A的构造器被调用name:nono  ID:00001true

懒汉式package net.hurr.test;public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;获取类A的对象&quot;);        //A a = new A();//不再能通过new的方式进行新建        A a = A.getInstanceA();//只能通过暴露的接口获取到对象。在获取的一瞬间对象才会被创建出来。        System.out.println(a);        A b = A.getInstanceA();        System.out.println(a == b);//同样，不管怎么获取，获取到的都是同一个对象。    &#125;&#125;class A &#123;    private String name;    private String ID;    private static A a;//懒汉式特点：类加载的时候不会自动创建对象，只有在调用的时候才会创建    private A() &#123;//构造函数仍然是私有化的，防止被new，除此之外和普通的构造函数一样。        System.out.println(&quot;类A的构造器被调用&quot;);        name = &quot;nono&quot;;        ID = &quot;00001&quot;;    &#125;    public static A getInstanceA() &#123;//只有调用这个方法的时候，对象才会被创建出来，节省空间，但有可能会造成线程异常。比如在多线程访问时，多个线程都进来了但对象还没创建好，这时就会造成重复创建的问题。只会保留最后一个创建的对象        if(a == null) &#123;//如果还没有创建对象，就创建            a = new A();        &#125;        return a;    &#125;    @Override    public String toString() &#123;        return &quot;name:&quot; + name + &quot;  ID:&quot; + ID;    &#125;&#125;

运行结果：
获取类A的对象类A的构造器被调用name:nono  ID:00001true

饿汉式和懒汉式的区别
二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建。
饿汉式不存在线程安全问题，懒汉式存在线程安全问题。
饿汉式存在浪费资源的可能。因为如果一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。
在我们javaSE标准类中，java.lang.Runtime就是经典的单例模式。

final关键字基本介绍final中文意思:最后的，最终的。

final可以修饰类、属性、方法和局部变量。

在某些情况下，可能有以下需求，就会使用到final：

    1. 当不希望类被继承时，可以用final修饰；
    2. 当不希望父类的某个方法被子类覆盖/重写(override)时，可以用final关键字修饰；
    3. 当不希望类的的某个属性的值被修改，可以用final修饰；
    4. 当不希望某个局部变量被修改，可以使用final修饰；


简单的说，只要经过final修饰，只要本质还是原来的，就不允许修改。

使用方法(样例)：样例1 要求某一个类不能被其他类继承//如果要求下面的类A不能被其他类所继承，可以在前面加上final修饰final class A&#123;    public int a = 100;&#125;/*//此时就会报错class B extends A&#123; &#125;*/
样例2 要求类中的某个方法不能被子类修改（重写&#x2F;覆盖）class A&#123;    public int a = 100;    //如果希望某个类中的某个方法不被改写或覆盖，同样也可以用final修饰一下    public final void fun()&#123;        System.out.println(&quot;这是类A独有的方法，不允许被重写&quot;);    &#125;   &#125;class B extends A&#123;    /*    此时如果想要重写父类中的被final修饰了的方法是不可以的    public final void fun()&#123;        System.out.println(&quot;对类A的方法进行重写&quot;);    &#125;*/&#125;
样例3 要求类中的某个属性不能被修改（即设置成常量）class A &#123;    //如果希望某个类中的某个属性不被改写或覆盖，同样也可以用final修饰一下    //被final修饰的属性必须赋初值。赋初值的地方可以有三种。一是在定义时如a1，二是利用构造方法，三是利用代码块。    //需要注意的是，初始化的地方只能在三个里面选一个。    public final int a1 = 100;    public final int a2;    public final int a3;    &#123;        a3 = 300;    &#125;    /*    public void fun()&#123;//如果试图修改这个属性，就会报错。        a=1;    &#125;*/    public A()&#123;        a2 = 200;    &#125;&#125;class B extends A &#123;    int a = 200;//但子类可以对这个继承下来的属性进行重写    /*    public void fun() &#123;//如果不重写就试图修改这个属性，就会报错。        super.a = 1;    &#125;*/&#125;
样例4  要求类中的某个属性不能被修改，且这个属性是静态的class A &#123;    static final public int n1 = 100;//可以直接赋初值    static final public int n2 ;    //static final public int n3 ;//但不可以在普通代码块或者构造方法中初始化。因为这个两个的根本是对象，而静态是属于类的。    static &#123;        n2 = 200;//也可以在静态代码块中赋初值    &#125;    /*    &#123;        n3 = 300;    &#125;      public A()&#123;        n3 = 300;    &#125;*/&#125;
final使用注意事项和细节
final修饰的属性又叫常量，一般用XX_XX_XX来命名；&#x2F;&#x2F;即全大写，类似于c中define的标准

**final修饰的属性在定义时必须赋初值，并且以后不能再修改，赋值可以在如下位置之一 [选择一个位置赋初值即可，只能选择一个] **;①定义时:如public final double TAX RATE&#x3D;0.08②在构造器中③在代码块中。

如果final修饰的属性是静态的，则初始化的位置只能是①定义时②在静态代码块不能在构造器中赋值。

final类不能继承，但是可以实例化对象。

如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。

一般来说，如果一个类已经是final类了，就没必要再将方法修饰成final方法。（修饰成final方法的目的在于防止子类的重写，但final类就已经不允许有子类，不可能会在子类中对方法进行重写）

final不能修饰构造方法（构造器）。（因为子类不会继承父类的构造器）

final和static往往都会搭配使用，效率更高，不会导致类加载。因为底层的编译器对此做了优化。
我们知道，在类加载的时候会同时加载静态代码块，可以利用静态代码块来检查类是否被加载了。
比如以下代码，会在调用类A的静态属性之前，先将类进行加载，因为在输出100之前，会先输出 类A被加载了 ;
public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(A.n1);    &#125;&#125;class A &#123;    public static int n1 = 100;    static &#123;        System.out.println(&quot;类A被加载了&quot;);    &#125;&#125;
如果改成下方的样子,在属性前面加上一个final，类A就就不会被加载，会直接输出100；
public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(A.n1);    &#125;&#125;class A &#123;    public final static int n1 = 100;    static &#123;//此时调用n1的值的时候，类就不会加载了。        System.out.println(&quot;类A被加载了&quot;);    &#125;&#125;
各种包装类如Integer,Double,Float,Boolean,String等都是final类。


抽象类当父类的某些方法需要声明但又不确定如何实现时，就可以将其声明为抽象方法，那么这个类就是抽象类。

当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰的类就是抽象类。

抽象类的介绍
用abstract关键字类修饰一个类时，这个类就叫做抽象类。一旦类是抽象类，那么这个类就不能实例化，因为对编译器来说这个类并没有完成全部的功能。
访问修饰符 abstract 类名&#123;&#125;
用abstract关键字来修饰一个方法时，这个方法就是抽象方法。需要注意的是，抽象方法只有声明，没有方法体。如果需要定义抽象方法，则该对象所处的类一定要是抽象类。
访问修饰符 abstract 类名&#123;  访问修饰符 abstract 返回类型 方法名(参数列表);&#125;
抽象类的价值更多作用时在于设计，是设计者设计好后，让子类继承并实现抽象类。

抽象类在框架和设计模式中使用的比较多。


抽象类的使用样例样例1 abstract类，但没有抽象方法public class Test &#123;    public static void main(String[] args) &#123;        //A a = new A();//虽然其中没有任何成员，但依然不能实例化成对象。报错信息：&#x27;A&#x27; 为 abstract；无法实例化。    &#125;&#125;abstract class A &#123;//如果仅是抽象类没有抽象方法，可以不需要继承实现&#125;
样例2 abstract方法public class Test &#123;    public static void main(String[] args) &#123;        //A a = new A();//抽象类不能实例化成对象报错信息：&#x27;A&#x27; 为 abstract；无法实例化。        B b = new B();        System.out.println(b.sum(1, 2, 3));    &#125;&#125;abstract class A &#123;    public abstract int sum(int... num);//如果类中含有抽象方法，则类必须也是抽象类（加上abstract修饰符）&#125;class B extends A &#123;    public int sum(int... num) &#123;//抽象类中必须要有一个子类实现父类的抽象方法，不然会报错。如果没有抽象方法，可以不用继承        int sum = 0;        for (int i = 0; i &lt; num.length; i++) &#123;            sum += num[i];        &#125;        return sum;    &#125;&#125;
抽象类使用的注意事项和细节
抽象类不能被实例化。
抽象类不一定包含抽象方法。
一旦类包含了abstract方法则这个类必须声明为abstract。
abstract只能修饰类和方法，不能修饰属性和其它的。
抽象类可以有任意成员[抽象类本质还是类] ,比如:非抽象方法、构造器、静态属性等等。
抽象方法不能有主体，即不能实现。
如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类。


抽象方法不能使用private、 final和static来修饰， 因为这些关键字都是和重写相违背的。

抽象类最佳实践-模板设计模式基本介绍抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。

模板设计模式能解决的问题
当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。
编写一个抽象父类， 父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，就是一种模板模式。

案例：求 求和 过程中的时间，可以是求1+2+n的值，也可以是求1x2xn的值package net.hurr.test;public class Test &#123;    public static void main(String[] args) &#123;        A a = new A();        a.fun(1000000000);        System.out.println(&quot;.................................&quot;);        B b = new B();        b.fun(1000000000);    &#125;&#125;abstract class Template &#123;    public void fun(long n) &#123;        long strat = System.currentTimeMillis();//获取现在的时间，（精确到毫秒）        job(n);//大体的公式放在这，具体的实现细节由子类完成        long end = System.currentTimeMillis();//获取现在的时间，（精确到毫秒）        System.out.println(&quot;消耗的时间为 &quot; + (end - strat));    &#125;    public abstract void job(long n);//中间需要进行一些运算，但目前还不知道运算的过程，所以设置成抽象类，由子类进行计算&#125;class A extends Template &#123;    public void job(long n) &#123;//子类完成具体的实现过程        long sum = 0;        for (long i = 1; i &lt;= n; i++) &#123;            sum += i;        &#125;    &#125;&#125;class B extends Template &#123;    public void job(long n) &#123;//而且可以个性化        long sum = 1;        for (long i = 1; i &lt;= n; i++) &#123;            sum *= i;        &#125;    &#125;&#125;

运行结果：
消耗的时间为 316……………………………消耗的时间为 719

接口基本介绍接口就是给出一些没有实现的方法,封装到一 起，到某个类要使用的时候，在根据具体情况把这些方法写出来。

语法//定义接口 访问修饰符 interface 接口名 &#123;   //接口内的方法，修饰符默认带有public 和 abstract （对于方法）。不可以是别的   void start();   void stop();&#125;//将接口应用到某个类某个类class 类名 implements 接口 [,接口2 ,接口3...]&#123;	自己属性:	自己方法;  //类似于继承了抽象类，必须实现接口中定义的所有方法&#125;//某个类通过接口调用其他的类class 类名 &#123;    public void work(UsbInterface usbInterface)&#123;//方法名正常，就是形参变成了定义的接口。编译器会自动调用类的对应实现的方法。如下方样例所示。类似于抽象类和向上转型的集合？系统会自动调用，不需要自己声明了        usbInterface.start();//        usbInterface.stop();    &#125;&#125;
样例1 接口入门package net.hurr.Interface_;public class Test &#123;    public static void main(String[] args) &#123;        Computer computer = new Computer();        Phone phone = new Phone();        Camera camera = new Camera();        computer.work(phone);        computer.work(camera);    &#125;&#125;interface UsbInterface &#123;//定义了一个接口，使用该接口的类必须实现其中定义的方法    void start();//默认自带了abstractb和public关键字，所以自己加不加都行。    void stop();&#125;class Phone implements UsbInterface &#123;//被接口规范了的类    @Override    public void start() &#123;//按照接口中定义的声明，实现具体的方法        System.out.println(&quot;手机开始工作&quot;);    &#125;    @Override    public void stop() &#123;        System.out.println(&quot;手机停止工作&quot;);    &#125;&#125;class Camera implements UsbInterface &#123;    @Override    public void start() &#123;        System.out.println(&quot;相机开始工作&quot;);    &#125;    @Override    public void stop() &#123;        System.out.println(&quot;相机停止工作&quot;);    &#125;&#125;class Computer &#123;    public void work(UsbInterface usbInterface) &#123;//调用被 UsbInterface 接口所规范的类        usbInterface.start();        usbInterface.stop();    &#125;&#125;

运行结果
手机开始工作手机停止工作相机开始工作相机停止工作

样例2 一个方法实现多个接口（被多个接口所约束）package net.hurr.Interface_;public class Test &#123;    public static void main(String[] args) &#123;        A a = new A();        InterfacrTest1 interfacrTest1 = new InterfacrTest1();//用于接口测试的类1        InterfacrTest2 interfacrTest2 = new InterfacrTest2();//用于接口测试的类2        interfacrTest1.work1(a);        System.out.println(&quot;...........&quot;);        interfacrTest2.work2(a);    &#125;&#125;interface MyInterface1 &#123;//定义了一个接口，使用该接口的类必须实现其中定义的方法    void fun();//默认自带了abstractb和public关键字，所以自己加不加都行。    void t();&#125;interface MyInterface2 &#123;    void fun();    void fun(String s);&#125;class A implements MyInterface1, MyInterface2 &#123;    public void fun() &#123;        System.out.println(&quot;重名的fun被执行&quot;);    &#125;    public void fun(String s) &#123;        System.out.println(&quot;参数名不同的fun被执行，内容是：&quot; + s);    &#125;    public void t()&#123;        System.out.println(&quot;未重名的t被执行&quot;);    &#125;&#125;class InterfacrTest1 &#123;    public void work1(MyInterface1 myInterface1) &#123;        myInterface1.fun();        myInterface1.t();    &#125;&#125;class InterfacrTest2 &#123;    public void work2(MyInterface2 myInterface2) &#123;        myInterface2.fun();        myInterface2.fun(&quot;参数不同的fun在测试&quot;);        //myInterface2.t();//虽然一个类能被多个接口所规范，但每个接口只能调用该接口自己声明的内容    &#125;&#125;

运行结果
重名的fun被执行未重名的t被执行………..重名的fun被执行参数名不同的fun被执行，内容是：参数不同的fun在测试

样例3 接口的继承package net.hurr.Interface_;public class Test &#123;    public static void main(String[] args) &#123;        A a = new A();        InterfacrTest1 interfacrTest1 = new InterfacrTest1();//用于接口测试的类1        InterfacrTest2 interfacrTest2 = new InterfacrTest2();//用于接口测试的类2        interfacrTest1.work1(a);        System.out.println(&quot;...................&quot;);        interfacrTest2.work2(a);    &#125;&#125;interface MyInterface1 &#123;//定义了一个接口，使用该接口的类必须实现其中定义的方法    void t();&#125;interface MyInterface2 extends MyInterface1&#123;    void fun();&#125;class A implements MyInterface2 &#123;    public void fun() &#123;        System.out.println(&quot;fun被执行&quot;);    &#125;    public void t()&#123;        System.out.println(&quot;t被执行&quot;);    &#125;&#125;class InterfacrTest1 &#123;    public void work1(MyInterface1 myInterface1) &#123;        //myInterface1.fun();//因为在接口1中，并没有这个方法        myInterface1.t();    &#125;&#125;class InterfacrTest2 &#123;    public void work2(MyInterface2 myInterface2) &#123;        myInterface2.fun();        myInterface2.t();//接口的子类一样可以调用父类的方法    &#125;&#125;

运行结果：
t被执行……………….fun被执行t被执行

样例4 带属性和方法体的接口package net.hurr.Interface_;public class Test &#123;    public static void main(String[] args) &#123;        A a = new A();        InterfaceTest interfaceTest = new InterfaceTest();//实例化用户测试的函数        System.out.println(&quot;通过接口调用的..............................&quot;);        interfaceTest.work1(a);        System.out.println(&quot;通过对象调用的..............................&quot;);        interfaceTest.work2(a);    &#125;&#125;interface MyInterface1 &#123;//定义了一个接口，使用该接口的类必须实现其中定义的方法    void t();    default void fun() &#123;//可以理解为switch里面的default？可以被重写，如果没被重写就实现这个方法        System.out.println(&quot;接口中可以带有语句&quot;);    &#125;    //也可以带有属性。属性好像自带了public static final关键字？    // 在idea中如果写上这个三个关键字会变成灰色，鼠标移上去会提示  修饰符 &#x27;final/static/public&#x27; 对于接口字段是冗余的    // 可以通过接口名直接调用,但不能修改    int n1 = 100;    //protected int n2 = 200;会报错 此处不允许使用修饰符 &#x27;protected&#x27;。&#125;class A implements MyInterface1&#123;    public void t()&#123;        System.out.println(&quot;接口中的t()的实现&quot;);    &#125;    public void test()&#123;//被接口规范的方法可以含有接口中没被声明的方法        System.out.println(MyInterface1.n1);        //MyInterface1.n1++;//不能修改，会提示  无法将值赋给 final 变量 &#x27;n1&#x27;    &#125;&#125;class InterfaceTest&#123;    void work1(MyInterface1 myInterface1)&#123;        myInterface1.t();//接口中声明的        myInterface1.fun();//接口中带有方法体的        //myInterface1.test();//接口中没有声明的类是不可以被接口调用的    &#125;    void work2(A a)&#123;        a.t();//接口中被声明的方法也可以通过对象名的方式进行调用        a.test();//单独的方法自然也是可以被调用的    &#125;&#125;

运行结果：
通过接口调用的…………………………接口中的t()的实现接口中可以带有语句通过对象调用的…………………………接口中的t()的实现100

package net.hurr.Interface_;public class Test &#123;    public static void main(String[] args) &#123;        Computer computer = new Computer();        Phone phone = new Phone();        Camera camera = new Camera();        A a = new A();        computer.work(phone);        computer.work(camera);              //new UsbInterface();//与抽象类类似，接口也不允许被实例化。&#x27;UsbInterface&#x27; 为 abstract；无法实例化        System.out.println(&quot;在main()中调用接口中的属性&quot; + UsbInterface.n);//通过接口名直接调用接口里面的属性        //UsbInterface.n = 200;接口里面的属性自带了static和final关键字        computer.test2(phone);        computer.test1(a);    &#125;&#125;interface UsbInterface &#123;//定义了一个接口，使用该接口的类必须实现其中定义的方法    void start();//默认自带了abstractb和public关键字，所以自己加不加都行。    void stop();    default void fun() &#123;//可以理解为switch里面的default？可以被重写，如果没被重写就实现这个方法        System.out.println(&quot;接口中带有语句&quot;);    &#125;    public int n = 100;//也可以带有属性。属性好像自带了static和final关键字？可以通过接口名直接调用&#125;interface T extends UsbInterface &#123;//同时接口好像还可以被继承？    void test();&#125;class Phone implements UsbInterface &#123;//被接口规范了的类    @Override    public void start() &#123;//按照接口中定义的声明，实现具体的方法        System.out.println(&quot;手机开始工作...&quot;);    &#125;    @Override    public void stop() &#123;        System.out.println(&quot;手机停止工作&quot;);    &#125;    @Override    public void fun() &#123;        System.out.println(&quot;Phone:接口中的类可以被重写&quot;);    &#125;&#125;class Camera implements UsbInterface &#123;    @Override    public void start() &#123;        System.out.println(&quot;相机开始工作&quot;);    &#125;    @Override    public void stop() &#123;        System.out.println(&quot;相机停止工作&quot;);    &#125;&#125;class Computer &#123;    public void work(UsbInterface usbInterface) &#123;        usbInterface.start();        usbInterface.stop();    &#125;    public void test1(T t) &#123;        t.test();    &#125;    /*    public void test2(T t) &#123;//同样也符合继承的规范：子类继承了所有的父类        t.fun();    &#125;*/    public void test2(UsbInterface usbInterface) &#123;//但运行被调用的类也必须得是由子类规范过的类，不兼容父类规范的类        usbInterface.fun();    &#125;&#125;class A implements T &#123;    @Override    public void start() &#123;    &#125;    @Override    public void stop() &#123;    &#125;    @Override    public void test() &#123;        System.out.println(&quot;类A:通过被继承的接口来规定一个类&quot;);    &#125;&#125;

运行结果：
手机开始工作…手机停止工作相机开始工作相机停止工作在main()中调用接口中的属性100Phone:重写接口中已有的类类A:通过被继承的接口来规定一个类

接口是更加抽象的抽象的类，抽象类里的方法可以有方法体，接口里的所有方法都没有方法体[jdk7.0] 。接口体现了程序设计的多态和高内聚低偶合的设计思想。

特别说明: Jdk8.0后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现。

与抽象类类似，接口也不允许被实例化。

注意事项和细节
接口不能被实例化。
接口中所有的方法都是 public 方法, 接口中抽象方法，可以不用 abstract 修饰。
一个普通类实现接口,就必须将该接口的所有方法都实现,可以使用 alt+enter 来解决。
抽象类去实现接口时，可以不实现接口的抽象方法。
一个类同时可以实现多个接口。
接口中的属性只能是final的，而且是public static final修饰符。比如:int a&#x3D;1;实际上是public static final int a&#x3D;1; (必须初始化)。
接口中属性的访问形式:接口名.属性名。
接口不能继承其它的类，但是可以继承多个别的接口。
接口的修饰符只能是public和默认，这点和类的修饰符是一样的。（默认的在接口中会被看作是public？）

接口与继承类的区别当子类继承了父类，就自动的拥有了父类的所有功能；如果子类需要扩展功能，可以通过 实现接口 的方式扩展。

可以把 实现接口 理解为对java单继承机制的一种补充。

继承的价值主要在于解决了代码的复用性和可维护性；		接口的价值注意在于设计，设计好各种规范（方法），让其他类去实现这些方法。

接口比继承更加灵活，继承满足是是某个（is a），而接口只需要满足像一个...(like a)的关系。

接口在一定的程度上实现了代码的解耦（接口规范性+动态绑定）

接口的多态性接口类型的变量 可以指向 实现了该接口的对象实例。（如在上方的样例1 中，类computer就可以接收实现了UsbInterface usbInterface接口的类，并通过该接口调用在接口中声明的所有方法与属性）。

利用接口的多态可以实现一个接口的数组。比如：

package net.hurr.Interface_;public class Test &#123;    public static void main(String[] args) &#123;        I[] i = new I[2];//定义了一个接口数组i        i[0] = new A();//数组的第一个位置指向了一个A类的对象        i[1] = new B();//数组的第一个位置指向了一个B类的对象        i[0].f();//并且可以通过接口调用在接口中声明了的方法或属性        //i[1].t();//但不能调用类中私有的属性        ((A)i[0]).t();//如果要调用类中私有的方法或属性，也可以使用向下转型的套路。不过需要多一重括号？    &#125;&#125;interface I &#123;    void f();&#125;class A implements I &#123;    public void f() &#123;    &#125;    public void t() &#123;    &#125;&#125;//定义了一个类A，并实现了接口I的方法class B implements I &#123;    public void f() &#123;    &#125;&#125;//定义了一个类B，并实现了接口I的方法
同时接口的多态还具有传递性，可以相互继承。如语法样例1中的接口的继承。

接口多态中的二义性因为一个类可以同时进行继承和实现接口的功能，因此就会出现“二义性”

interface I &#123;    int x = 1;//等价于public static final int x = 1;&#125;class T&#123;    int x = 2;//普通属性&#125;class A extends T implements I &#123;   void f()&#123;       //System.out.println(x);//此时就会报错，因为编译器不知道是要哪个里面的x。报错信息：对 &#x27;x&#x27; 的引用不明确，&#x27;T.x&#x27; 和 &#x27;I.x&#x27; 均匹配       System.out.println(I.x);//因为接口里面的属性是静态的，所以可以通过接口名.属性名进行访问       System.out.println(super.x);//或者使用super关键字指定访问父类的x   &#125;&#125;
内部类基本介绍一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class)，嵌套其他类的类称为外部类(outer class)。

内部类是我们类的第五大成员[属性、方法、构造器、代码块、内部类]，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。

类的组成：

class Outer &#123;//外部类    //属性    private int n1 = 100;    //方法    public void m1() &#123;        System.out.println(&quot;m1()&quot;);    &#125;    //构造器    public Outer(int n1) &#123;        this.n1 = n1;    &#125;    public Outer() &#123;    &#125;    //代码块    &#123;        System.out.println(&quot;代码块&quot;);    &#125;    //内部类    class Inner &#123;    &#125;&#125;
内部类的分类定义在外部类的局部位置上（比如方法内）：局部内部类（有类名）、
匿名内部类（无类名）；
定义在外部类的成员位置上：成员内部类（非static）、静态内部类（static）；

局部内部类局部内部类是定义在外部类的局部位置，比如方法中或块中，并且有类名。

演示代码package net.hurr.innerclass_;public class InnerClass01 &#123;    public static void main(String[] args) &#123;        Outer outer = new Outer(100);        outer.m1();    &#125;&#125;class Outer &#123;    //属性    private int n1 = 100;    private int n3 = 300;    private void m2()&#123;&#125;    //方法    public void m1() &#123;        //局部内部类是定义在外部类的局部位置， 比如方法中，并且有类名。        class Inter&#123;//局部内部类，本质还是一个类，里面也可以有五大类            private int n2 = 200;            private int n1 = 1;            public void f1()&#123;                System.out.println(&quot;Outer:n3 = &quot;+n3);//可以直接访问外部类的所有成员， 包含私有的。                m2();//同样也可以访问到外部的方法            &#125;            public void f2()&#123;                System.out.println(&quot;Inter:n1 = &quot;+n1);//当重名发生时，遵守就近原则。              //外部类.this的含义：因为外部类不一定是静态的，因此直接可能不能访问到，加上this表示找的时这个类的对象。                System.out.println(&quot;Inter:Outer:n1 = &quot;+Outer.this.n1);//如果需要访问外部类的成员,可以同外部类名.this.成员名 的方式进行访问            &#125;        &#125;        //public class InnerTest&#123;&#125;//作为方法的一个成员，是不可以有访问权限的管理。但可以用final进行只读保护，就像其他方法成员一样        class InnerTest extends Inter&#123;&#125;//内部类也是可以被继承的（如果能访问到）        Inter inter = new Inter();//在作用域内内部类也可以实例化成对象        System.out.println(&quot;Inter n2:&quot;+inter.n2);//并通过对象访问其中的属性        inter.f1();//内部类的方法也可以通过对象调用        inter.f2();    &#125;    //构造器    public Outer(int n1) &#123;        this.n1 = n1;    &#125;&#125;

运行结果：
Inter n2:200Outer:n3 &#x3D; 300Inter:n1 &#x3D; 1Inter:Outer:n1 &#x3D; 100

匿名内部类匿名内部类时定义在外部类的局部位置，比如方法中或代码块中，且没有类名.

匿名内部类的本质还是类，而且是一个内部的类，他没有名字（有名字但不是开发者命名，是由系统自动生成）

基本语法new 类或接口(参数列表)&#123;  类体;&#125;
基于接口的匿名类 演示需求：使用接口来定义一个类，并用这个类创建一个对象

传统的方法是将新建一个类，但由于只需要使用一次，后面不会再用到，因此可以使用匿名内部类来简化以下编写的流程。

比如这样：

I tiger = new I()&#123;            @Override            public void cry() &#123;                System.out.println(&quot;老虎在叫....&quot;);            &#125;        &#125;;
在上方的片段中，tiger的编译类型是I，运行类型是匿名类。匿名类的命名规范为外部类名$编号
这个匿名的内部类一旦实例化成tiger后，就会直接抛弃，而对象名tiger，可以在生存期内无限次被使用。
具体实现代码
package net.hurr.innerclass_;//匿名内部类的使用public class InnerClass01 &#123;    public static void main(String[] args) &#123;        Outer outer = new Outer();        outer.method();    &#125;&#125;class Outer&#123;    private int n1 = 100;    public void method()&#123;        //基于接口的匿名内部类        //使用接口I，并创建一个对象。传统方式：写一个类，实现该接口，并创建对象。但由于这个类只会使用一次，且一会不会再使用。可以使用内部类来简化。如下所示        //此时tiger的编译类型是I；运行类型是匿名的内部类。        /*        下方这个匿名内部类约等于以下语句            class XXXX implements I&#123;                public void cry() &#123;                    System.out.println(&quot;老虎在叫&quot;);                &#125;            &#125;            而其中的XXXX就是系统分配的一个类名。具体的名字是:外部类名$编号。比如这里就是Other$01.         */        I tiger = new I()&#123;            @Override            public void cry() &#123;                System.out.println(&quot;老虎在叫....&quot;);            &#125;        &#125;;        tiger.cry();//通过将匿名对象实例化后的变量访问其中的方法        System.out.println(&quot;tiger的类名为 &quot;+tiger.getClass());    &#125;&#125;interface I&#123;//接口    void cry();&#125;class A&#123;    public A() &#123;    &#125;    public void test()&#123;    &#125;&#125;
基于类的匿名类基本构成：class Outer &#123;    public void method() &#123;        A a = new A(&quot;jack&quot;) &#123;//这就完成了一个基于类的匿名内部类。括号内的值会传给父类A的构造函数.相当于继承了A这个类，但没有重写任何方法。          	//内部匿名类的语句组;        &#125;;    &#125;&#125;class A &#123;    public A(String s) &#123;        System.out.println(&quot;传入的值为：&quot; + s);    &#125;&#125;
匿名类中不允许存在构造函数（因为创建完就丢弃，没有构造的意义）
匿名内部类的调用方式：
对象名.内部类的参数；
也可以不创建对象名直接调用，比如：
new A(&quot;Tom&quot;) &#123;    public void test() &#123;      System.out.println(&quot;不创建对象名直接调用&quot;);    &#125;&#125;.test();//new出来直接调用class A &#123;    public A(String s) &#123;      System.out.println(&quot;传入的值为：&quot; + s);    &#125;&#125;

匿名内部类通常会当作实参直接传递。如：
public class InnerClass01 &#123;    public static void main(String[] args) &#123;        fun(new I()&#123;//直接把创造出来的基于接口的匿名内部类的对象作为实参传入到定义好的方法中            public void show()&#123;//在匿名类中完成接口所定义的功能                System.out.println(&quot;这是一幅名画&quot;);            &#125;        &#125;);               &#125;    public static void fun(I i)&#123;//定义一个方法，可以使用符合这个接口的对象        i.show();    &#125;&#125;interface I&#123;//定义一个接口    void show();&#125; 
更改为传统的写法如下（硬编码）：
public class InnerClass01 &#123;    public static void main(String[] args) &#123;        fun(new C());    &#125;    public static void fun(I i)&#123;//定义一个方法，可以使用符合这个接口的对象        i.show();    &#125;&#125;interface I&#123;//定义一个接口    void show();&#125;class C implements I&#123;    public void show()&#123;        System.out.println(&quot;这是一幅名画&quot;);    &#125;&#125;

两者在功能上一模一样，都是输出一句&quot;这是一幅名画&quot;，但在写法上，传统的方法需要先定义一个类，而这个类很有可能只会被使用一次之后就不会再被使用，占地方，而且看代码的时候比较啰嗦。

前者适合只用一次的场景，后者更适合需要复用的场景。

全部实验样例如下：
package net.hurr.innerclass_;//匿名内部类的使用public class InnerClass01 &#123;    public static void main(String[] args) &#123;        Outer outer = new Outer();        outer.method();        outer.fun();    &#125;&#125;class Outer &#123;    private int n1 = 100;    //基于类的匿名内部类    public void method() &#123;        //a的编译类型：A;a的运行类型：匿名        //相当于继承了A这个类，但没有重写任何方法。        A a = new A(&quot;jack&quot;) &#123;            @Override            public void test() &#123;                System.out.println(&quot;匿名内部类重写了test方法&quot;);            &#125;            public int n = 20;            public void fun1() &#123;                System.out.println(&quot;在匿名内部类中的n被打印：&quot; + n);            &#125;        &#125;;        a.test();//运行时会动态绑定，根据实际的对象调用对应的方法        System.out.println(a.n);//但属性同样不参与动态绑定，只能按照编译类型调用        a.fun1();//但参与动态绑定的内部类回去找自身的变量而非找编译类型变量        new A(&quot;Tom&quot;) &#123;            public void test() &#123;                System.out.println(&quot;不创建对象名直接调用&quot;);            &#125;        &#125;.test();    &#125;    //基于抽象类的匿名类    public void fun() &#123;        Anima anima = new Anima() &#123;            public void eat() &#123;                System.out.println(&quot;在基于抽象类的匿名内部类中的eat（）&quot;);                return;            &#125;        &#125;;        anima.eat();    &#125;&#125;class A &#123;    public A(String s) &#123;        System.out.println(&quot;传入的值为：&quot; + s);    &#125;    public void test() &#123;        System.out.println(&quot;类A中的test（）&quot;);    &#125;    public int n = 10;    public void fun1() &#123;        System.out.println(&quot;在普通外部类中的n被打印：&quot; + n);    &#125;&#125;abstract class Anima &#123;    abstract void eat();&#125;

内部类的细节
匿名内部类的语法比较奇特，请大家注意，因为匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征，对前面代码分析可以看出这个特点，因此可以调用匿名内部类方法。
可以直接访问外部类的所有成员， 包含私有的。(私有的访问权限在于类内，而内部类就在类中，因此可以方法私有)
不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final 修饰，因为局部变量也可以使用final。
作用域:仅仅在定义它的方法或代码块中。（类似于网络中的内部网络。内部网络可以访问外网的资源，但外网不能主动联系内网从的成员，因为找不到，除非借助端口转发？）
局部内部类 的成员访向 外部类 的成员：当作自己的成员一样直接访问。
外部类 访向 局部内部类的成员：需要实例化一个内部类的变量，通过对象的名字去找他。前提是能找到（在作用域范围内）
外部其他类 不能直接访问到 局部内部类(因为局部内部类地位是一个局部变量)
如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员) 去访问。



局部内部类定义在方法中&#x2F;代码块
作用域在方法体或者代码块中
本质仍然是一个类


外部类成员内部类语法class Outer &#123;    class Inter &#123;    		public void say() &#123;            System.out.println(&quot;内部类的一个方法&quot;);        &#125;    &#125;&#125;
细节讨论
成员内部类就是一个成员，因此它的作用域和外部类的其他成员一样，为整个类体。

定义在外部类的成员位置。不能有static修饰。

它可以直接访问外部类的所有成员（包括私有的）。但如果反过来外部类的成员（和内部类平级的）想要访问内部类内的数据，需要先创建对象。（或者加static，和普通类一样）

它也可以添加访问修饰符，因为他的地位就是一个成员。

成员内部类的方法不能加static修饰,除非这个内部类已经是static的了。或者java版本升级到16以上。

如果想在类A中访问外部类B中的内部类C，可以有一下三种方式。（ABC三者的关系：A、B平级，B、C内部外部）如下代码所示。或者在外部类B中创建对应的方法，通过方法调用内部类实例化后的对象。
//1、靠实例化后的对象来创建一个内部类的对象class A&#123;    B b = new B();    B.C c = b.new C();//相当于把new C()当作是b的一个成员    B b1 = new B();    B.C c2 = b1.new C();    public void fun()&#123;        System.out.println(&quot;c=&quot;+c.hashCode());        System.out.println(&quot;c2=&quot;+c2.hashCode());    &#125;&#125;class B &#123;    static private int n1 = 100;    static protected String name = &quot;张三&quot;;    class C &#123;        public void say() &#123;            System.out.println(&quot;位于内部类的say()被执行，外部类的成员 n1 = &quot; + n1 + &quot; name = &quot; + name);        &#125;    &#125;&#125;//2、在外部类中，编写一个方法，返回内部类的对象class B &#123;    static private int n1 = 100;    static protected String name = &quot;张三&quot;;    class C &#123;        public void say() &#123;            System.out.println(&quot;位于内部类的say()被执行，外部类的成员 n1 = &quot; + n1 + &quot; name = &quot; + name);        &#125;    &#125;    public C getInterC()&#123;//在外部类中实例化并返回，同样需要借助外部类的对象        return new C();    &#125;&#125;//3、或者用静态的方法：

package net.hurr.Interface_;public class Test &#123;    public static void main(String[] args) &#123;        Outer outer = new Outer();        Outer.inter01.say();    &#125;&#125;class Outer &#123;    static private int n1 = 100;    static protected String name = &quot;张三&quot;;    static class Inter01 &#123;        static public void say() &#123;//需要注意的是，此处的成员内部类的方法不能加static修饰,除非这个内部类已经是static的了。或者java版本升级到16以上            //内部类可以访问外部类中所有的成员，包括私有的。            System.out.println(&quot;位于内部类的say()被执行，外部类的成员 n1 = &quot; + n1 + &quot; name = &quot; + name);        &#125;    &#125;    //需要注意，内部类不能被外面的类（不是外部类）直接实例化，因为找不到这个类。    static Inter01 inter = new Inter01();    class Inter02 &#123;        public void t() &#123;            System.out.println(&quot;t()&quot;);        &#125;    &#125;      Inter02 inter02 = new Inter02();    public void t()&#123;//创建一个跳板，其他类可以通过这个方法访问到内部类的数据        inter02.t();    &#125;&#125;

如果外部类和内部类的成员重名时，会遵循就近原则，会访问到重名的内部类的成员。如果内部类想要访问重名了的外部类的成员，需要使用“外部类名.this.成员”的语法进行访问。

class A&#123;    private int n = 100;    class B&#123;        private int n = 200;        public void fun()&#123;            System.out.println(&quot;直接访问n会访问到内部类的n，会输出200.：&quot;+n);            System.out.println(&quot;如果需要访问外部类的n，需要特殊处理，比如这样就能访问到外部的值：&quot;+A.this.n);        &#125;    &#125;&#125;
静态内部类静态内部类是定义在外部类的成员位置，并有static修饰。

特点
可以直接访问外部类的所有静态成员，包括私有，但不能访问非静态的成员。
可以添加任意的修饰符，因为地位就是一个成员。
作用域：和成员一样，为整个类体。

package net.hurr.Interface_;public class Test &#123;    public static void main(String[] args) &#123;        A a = new A();        a.fun();    &#125;&#125;class A &#123;    private int n1 = 100;    private static int n2 = 200;    static class B &#123;//静态内部类有static修饰        private int n3 = 300;        public void say() &#123;            System.out.println(&quot;可以直接访问静态成员（类外）或者类内的所有成员 n2 = &quot; + n2 + &quot;  n3 = &quot; + n3);            //System.out.println(n1);//但不能访问类外的非静态成员        &#125;        public static void t()&#123;            System.out.println(&quot;外部类可以直接访问静态内部类中的静态成员而不需要实例化&quot;);        &#125;    &#125;    public void fun()&#123;        new B().say();//作用域在整个类中，因为可以在类外访问内部类的成员。        // 需要注意的是虽然是静态的内部类，但还需要实例化之后才能访问。因为里面的方法不是静态的，只有类是静态的        B.t();//可以直接访问内部类的静态成员    &#125;&#125;

静态内部类可以直接访问所有外部类的成员；但外部类想要访问内部类的成员则需要先实例化成对象。或者内部类的成员也是静态的。
外部其他类想要使用静态内部类的方式为：

public class Test &#123;   public static void main(String[] args) &#123;       //1、外部类名.       new A.B().fun();//对于静态内部类的非静态成员需要先实例化成对象       A.B.t();//如果成员也是静态的，就可以直接访问   &#125;&#125;class A &#123;   static class B &#123;       void fun()&#123;           System.out.println(&quot;在其他类中访问了静态内部类中的普通变量&quot;);       &#125;       public static void  t()&#123;           System.out.println(&quot;在其他类中访问了静态内部类中的静态变量&quot;);       &#125;   &#125;&#125;

同样如果外部类和静态内部类重名时，仍然遵守就近原则。如果想访问外部对象，可以使用 外部类名.成员 的方式进行访问。
package net.hurr.Interface_;public class Test &#123;    public static void main(String[] args) &#123;        A a = new A();        A.B b = new A.B();        b.t();    &#125;&#125;class A &#123;    private static int n = 100;    static class B &#123;        int n = 200;        public void t() &#123;            System.out.println(&quot;就近原则，访问到内部类的成员&quot; + n);            System.out.println(&quot;访问外部则需要类名.成员名&quot; + A.n);//需要注意的是，外部的成员需要是静态的。        &#125;    &#125;&#125;

小结内部类共有四种，局部内部类、匿名内部类、成员内部类、静态内部类。前两者是在成员内部，后两者的存在地位就是普通类的一个成员（本质）。（重点是匿名内部类）


枚举和注解自定义枚举实现方法
将构造器私有化，防止被直接的new；
去掉set相关的方法，防止属性被修改；
在类的内部直接创建固定的对象；
在第三步的语句前加入final防止被修改；

class Season &#123;    private String name;    private String desc;    private Season(String name, String desc) &#123;        this.name = name;        this.desc = desc;    &#125;    //3、在类的内部直接创建固定的对象    public static final Season SPRING = new Season(&quot;春天&quot;,&quot;温暖&quot;);    public static final Season SUMMER = new Season(&quot;夏天&quot;,&quot;炎热&quot;);    public static final Season AUTUMN = new Season(&quot;秋天&quot;,&quot;凉爽&quot;);    public static final Season WINTER = new Season(&quot;冬天&quot;,&quot;寒冷&quot;);&#125;
自定义枚举的注意事项
样式类似于单例模式中的饿汉式；
不需要提供set方法，因为对象值通常都是只读的；
对枚举的对象或属性一般都使用final+static共同修饰，实现优化；（在使用的时候不会加载类，java8+）
枚举对象根据需要，可以有多个属性；（如上方的样例）

小结
构造器私有化；
本类内部创建一组对象；
对外暴露对象（通过为对象添加 public final static 修饰符） ；
可以提供 get 方法，但是不要提供 set；

enum关键字的枚举实现方法：
使用关键字 enum 替代 class；
public static final Season SPRING &#x3D; new Season(“春天”, “温暖”) 直接使用SPRING(“春天”, “温暖”) ；（常量名(实参列表)）
如果有多个常量(对象)， 使用 ,号间隔即可；（可能编译器只认一条语句？）
如果使用 enum 来实现枚举，要求将定义常量对象，写在最前面（与this或super的地位相同）；
如果我们使用的是无参构造器，创建常量对象，则可以省略 ()；

package net.hurr.chapter.enum_;public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(Season.SPRING);        System.out.println(Season.SUMMER);        System.out.println(Season.AUTUMN);        System.out.println(Season.WINTER);        System.out.println(Season.OTHER);    &#125;&#125;enum Season &#123;    //不再定义对象，直接使用常量名（实参列表）的方式进行说明）    SPRING(&quot;春天&quot;,&quot;温暖&quot;),    SUMMER(&quot;夏天&quot;,&quot;炎热&quot;),    AUTUMN(&quot;秋天&quot;,&quot;凉爽&quot;),    WINTER(&quot;冬天&quot;,&quot;寒冷&quot;),    OTHER;//若使用无参构造器，则可以不用加括号。    private String name;    private String desc;    private Season(String name, String desc) &#123;        this.name = name;        this.desc = desc;    &#125;    Season() &#123;    &#125;    @Override    public String toString() &#123;        return &quot;Season&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +                &quot;, desc=&#x27;&quot; + desc + &#x27;\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;

运行结果：
Season{name&#x3D;’春天’, desc&#x3D;’温暖’}Season{name&#x3D;’夏天’, desc&#x3D;’炎热’}Season{name&#x3D;’秋天’, desc&#x3D;’凉爽’}Season{name&#x3D;’冬天’, desc&#x3D;’寒冷’}Season{name&#x3D;’null’, desc&#x3D;’null’}

enum枚举的注意事项
当使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类, 而且是一个 final 类；（具体见javap反编译出的内容）

反编译结果：
Compiled from “Test.java”final class net.hurr.chapter.enum_.Season extends java.lang.Enum&lt;net.hurr.chapter.enum_.Season&gt; {public static final net.hurr.chapter.enum_.Season SPRING;public static final net.hurr.chapter.enum_.Season SUMMER;public static final net.hurr.chapter.enum_.Season AUTUMN;public static final net.hurr.chapter.enum_.Season WINTER;public static final net.hurr.chapter.enum_.Season OTHER;public static net.hurr.chapter.enum_.Season[] values();public static net.hurr.chapter.enum_.Season valueOf(java.lang.String);public java.lang.String toString();static {};}
具体代码：
enum Season {SPRING(“春天”,”温暖”),SUMMER(“夏天”,”炎热”),AUTUMN(“秋天”,”凉爽”),WINTER(“冬天”,”寒冷”),OTHER;&#x2F;&#x2F;若使用无参构造器，则可以不用加括号。private String name;private String desc;
private Season(String name, String desc) {this.name &#x3D; name;this.desc &#x3D; desc;}Season() {}@Overridepublic String toString() {return “Season{“ +“name&#x3D;’” + name + ‘&#39;‘ +“, desc&#x3D;’” + desc + ‘&#39;‘ +‘}’;}}


传统的 public static final Season2 SPRING &#x3D; new Season2(“春天”, “温暖”); 简化成 SPRING(“春天”, “温暖”)；（调用了有参构造器，由实参判断）

如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略；

当有多个枚举对象时，使用逗号间隔，最后有一个分号结尾；

枚举对象必须放在枚举类的行首；

如果直接输出toString（没有重写的情况下会继承父类的），则会输出常量名。如：
public class Test &#123;    public static void main(String[] args) &#123;        Gender a = Gender.BOY;        Gender b = Gender.BOY;        Gender c = Gender.GIRL;        System.out.println(a + &quot;  &quot; + b + &quot;  &quot; + c);      	System.out.println(a == b);    &#125;&#125;enum Gender &#123;    BOY, GIRL;&#125;/*运行结果：BOY  BOY  GIRLtrue*/
枚举类型只要常量名相同就是同一个。见上方代码，不管BOY被分给了几次，他们都是同一个。具体原理看自定义的枚举的实现方法，在枚举类每个名字不同的常量只有一个实例，调用不过是将这个实例的地址传给不同的对象。



enum的常用方法使用enum关键字的时候，会隐式的继承Enum类，这样我们就可以使用 Enum 类相关的方法。





方法名
详细描述



valueOf
将给定的字符串转换成枚举类型（或者说返回与字符串相同的枚举类型）。如果枚举类内没有匹配的字符串，会抛异常。语法：Season autumn &#x3D; Season.valueOf(“AUTUMN”);


values
隐藏方法，在源码中无法查看。返回一个数组，数组的内容是当前枚举类中的所有常量。数组类型为对应的枚举类


toString
得到当前枚举常量的名称。你可以通过重写这个方法未使得到的结果更易读。


equals
在枚举类型中可以直接使用”&#x3D;&#x3D;“来比较两个枚举常量是否相等。Enum提供的这个equals0方法，也是直接使用”等于“实现的。


hashCode
Enum实现了hashCode()来和equals())保持一致。 它也是不可变的。


getDeclanngClass
得到枚举常量所属枚举类型的Class对象。可以用它来判断两个枚举常量是否属千同-一个枚举类型。


name
得到当前枚举常量的名称。toString如果没有重写则同样输出当前常量的名字。


ordinal
得到当前枚举常量的次序。（从0开始编号，编号的顺序为当前常量在枚举类中的位置）


compareTo
比较两个枚举常量的大小(按照声明的顺序排列，即通过ordinal得到的数) 。返回当前枚举类型减去传入的类型之间相差的个数。等于0时表示两个枚举类型相176                    56 80等。


clonee
枚举类型不能被Clone。为了防止子类实现克隆方法，Enum实现了一个仅抛出CloneNotSupprtedException异常的不变Clone()


enum的注意事项
使用enum关键字后，就不能再继承其他类了，因为enum会隐式的继承Enum类，而Java中只有单继承，不支持多继承。、

除了不能继承其他的类外，enum类也不能被其他类继承

enum实现的枚举类的本质仍然还是一个类，因此是可以实现接口的，可以被接口所规范。使用时可以通过枚举出的对象.方法名。如下：
package net.hurr.chapter.enum_;public class Test &#123;    public static void main(String[] args) &#123;        E.TEST.play();    &#125;&#125;enum E implements I &#123;    TEST;    public void play()&#123;        System.out.println(&quot;播放音乐&quot;);    &#125;&#125;interface I&#123;    void play();&#125;

注解（Annotation）注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。

在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置等。

基本介绍使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素。

三个基本的 Annotation
@Override: 限定某个方法，是重写父类方法, 该注解只能用于方法；
@Deprecated: 用于表示某个程序元素(类, 方法等)已过时；
@SuppressWarnings: 抑制编译器警告

基本的 Annotation 应用案例@Override 注解的案例class A&#123;    private String s = &quot;AAA&quot;;    @Override//放在方法前    public String toString() &#123;        return s;    &#125;&#125;
@Override  放在方法的上一行，表示下面的方法重写了父类的方法。如果不加照样是重写的，但加上的话编译器就会去检查该方法是否真的重写了父类的方法，如果重写了，则编译通过；如果没有重写，则会编译报错。

它的价值就在于语法校验。

在源码中为：

@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125;
上方代码中的@interface 就表明了这是一个注解类。（注意这不是接口！！！）

@Override的使用说明
@Override表示指定重写父类的方法(从编译层面验证)， 如果父类没有对应方法，则会报错
如果不写@Override注解，而父类仍有public void fly00，仍然构成重写；
@Override只能修饰方法，不能修饰其它类，包，属性等等；
查看@Override注解源码为@ Target(ElementType.METHOD)说明只能修饰方法；
@Target是修饰注解的注解，称为元注解， 记住这个概念；

@Deprecated 注解的案例用于表示某个程序的元素（比如类、方法）已经过时。

只要在类前面加上这个注解，编译器在自动联想搜索的时候，就不会优先选中这个。但这并不代表不能用，还是可以选中的，只是不在第一位了，或者说不推荐使用了。而且选中之后会在使用该类的地方加上删除线。

他可以修饰构造器、字段（属性）、局部变量、方法、包、参数、类型。

他的用处就是做一个过渡，在版本升级的时候提示某些正在使用的东西在后期是会被淘汰的。

源码：

@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;    String since() default &quot;&quot;;    boolean forRemoval() default false;&#125;
@SuppressWarnings 注解的案例
当我们不希望看到这些警告的时候，可以使用 SuppressWarnings 注解来抑制警告信息
在{“”} 中，可以写入你希望抑制(不显示)警告信息
作用的范围与放置的位置有关。他只会作用于下方第一个对象。

可以指定的警告类型有：





关键字
用途



all
抑制所有警告


boxing
抑制与封装&#x2F;拆装作业相关的警告


cast
抑制与强制转型作业相关的警告


dep-ann
抑制与淘汰注释相关的警告


deprecation
抑制与淘汰的相关警告


fallthrough
抑制与switch陈述式中遗漏break相关的警告


finally
抑制与未传回finally区块相关的警告


hiding
抑制与隐藏变数的区域变数相关的警告


incomplete-switch
抑制与switch陈述式(enum case)中遗漏项目相关的警告


javadoc
抑制与javadoc相关的警告


nls
抑制与非nls字串文字相关的警告


null
抑制与空值分析相关的警告


rawtypes
抑制与使用raw类型相关的警告


resource
抑制与使用Closeable类型的资源相关的警告


restriction
抑制与使用不建议或禁止参照相关的警告


serial
抑制与可序列化的类别遗漏serialVersionUID栏位相关的警告


static-access
抑制与静态存取不正确相关的警告


static-method
抑制与可能宣告为static的方法相关的警告


super
抑制与置换方法相关但不含super呼叫的警告


synthetic-access
抑制与内部类别的存取未最佳化相关的警告


sync-override
抑制因为置换同步方法而遗漏同步化的警告


unchecked
抑制与未检查的作业相关的警告


unqualified-field-access
抑制与栏位存取不合格相关的警告


unused
抑制与未用的程式码及停用的程式码相关的警告


用法：在想要使用的对象的上一行，写上：

@SuppressWarnings(&quot;关键字&quot;)
如：让编译器忽略下方的类中所有的因未被使用所造成的警告：
@SuppressWarnings(&quot;unused&quot;)class A&#123;    public int n1 = 10;    private int i;    public void hi()&#123;    &#125;&#125;
JDK的元注解简单的说就是修饰注解的注解。


元注解的种类


注解类型
用途



Retention
指定注解的作用范围，三种 SOURCE,CLASS,RUNTIM


Target
指定注解可以在哪些地方使用


Documented
指定该注解是否会在 javadoc中体现


Inherited
子类会继承父类的注解


Retention注解只能用于修饰一个 Annotation （注解）定义, 用于指定该 Annotation 可以保留多长时间（或者说保留范围）, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值:


RetentionPolicy.SOURCE: 编译器使用后，直接丢弃这种策略的注释。简单的说就是只在源码阶段是生效的，往后的.class文件不保留；
RetentionPolicy.CLASS: 编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 不会保留注解。 这是默认值。简单的说就是上一个的扩展版，将注解保留至class文件1中；
RetentionPolicy.RUNTIME:编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注解. 程序可以 通过反射获取该注解。这是所有注解中保留范围最长的，当程序在运行的时候，jvm虚拟机仍然会去读取该注解，并作出相应的处理。

例如下方的Deprecated注解的源码，就有这个注解的存在

@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;    String since() default &quot;&quot;;    boolean forRemoval() default false;&#125;
其中的Retention的值为RetentionPolicy.RUNTIME，因此在javac编译的时候，就会提示一下信息：

注: Test.java使用或覆盖了已过时的 API。注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。

Target注解用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素。

@Target也包含一个名为value的成员变量。

比如下方的一个SupperssWarnings注解的一个源码

@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123;    String[] value();&#125;
可以看到其中就有Target注解的存在，正因为他的存在，所以这个SupperssWarnings注解就可以用于修饰TYPE（类型）, FIELD（字段/属性）, METHOD（方法）, PARAMETER（参数）, CONSTRUCTOR（构造器）, LOCAL_VARIABLE, MODULE这些类型。

Documented注解用于指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档。

即在生成文档时，可以看到该注解。

例如如下的Deprecated注解的源码，就有这个注解的存在

@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;    String since() default &quot;&quot;;    boolean forRemoval() default false;&#125;
异常基本概念将程序执行中发生的不正常的情况称为异常。
根据异常的发生情况可以分成两大类：运行时异常和编译时异常。
运行异常是指在运行阶段会触发的异常，比如数组越界、空间不足等情况。运行时异常编译器检查不出来。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。
对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。
而
编译异常是必须要处理的，不然通过不了编译。比如打开文件但文件不存在等情况
执行过程中所发生的异常事件可分为两大类：ERROR（错误）和Exception。
ERROR： Java虚拟机无法解决的严重问题。如: JVM系统内部错误、资源耗尽等严重情况。比如: StackOverflowError[栈溢出]和OOM(out of memory)，Error 是严重错误，程序会崩溃。

Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等，Exception 分为两大类:运行时异常[程序运行时，发生的异常]和编译时异常[编程时，编译器检查出的异常]。

异常处理当异常发生时，对异常的处理方式。

try - catch - finally
将捕获到的异常自行处理。


throws
发生异常后不处理，直接抛出，谁调用谁接收。



try - catch异常处理Java提供try和catch块来处理异常。try块用于包含可能出错的代码。catch块用于处理try块中发生的异常。可以根据需要在程序中有多个try...catch块。


基本语法try&#123;  //可能会出异常的代码&#125;catch(异常)&#123;  //出异常后会执行的代码。  //catch块可以有多个，&#125;finally&#123;  //不管异常是否发生，此处的代码都会被执行。如关闭连接、释放资源等。此块可以缺省不写。&#125;
样例try &#123;            String str = &quot;aaa&quot;;            int n = Integer.parseInt(str);            System.out.println(n);        &#125;        catch (Exception e) &#123;            System.out.println(&quot;异常信息为：&quot; + e.getMessage());        &#125;        System.out.println(&quot;程序继续执行&quot;);

运行结果：
异常信息为：For input string: “aaa”程序继续执行

try - catch的细节
如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块；如果存在finally块，还会执行finally块中的语句。

如果异常没有发生，则顺序执行try的代码块，不会进入到catch。如果存在finally块，还会执行finally块中的语句。

如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)则使用finally {}。需要注意的是，一旦有这个finally，哪怕 try或catch里面有return，也不会退出，而是执行finally语句块。虽然return暂时不会执行，但return后面的语句照样会被执行。如：
static int fun()&#123;  int i = 0;  try &#123;    int n1=2,n2=0;    int res = n1/n2;//出现异常    return i;  &#125;  catch (Exception e) &#123;    return ++i;//注意，此处的++i执行了，但并没有返回，因为下面的finally有返回了。  &#125;  finally &#123;    return ++i;//执行了并且返回了。  &#125;&#125;public static void main(String[] args) &#123;  System.out.println(fun());&#125;/*执行结果：2*/
如果finally中没有return退出语句，则还是会回到catch中执行对应的return。如：
 static int fun()&#123;        int i = 1;        try &#123;            i++;            int n1=2,n2=0;            int res = n1/n2;//制造异常        &#125;        catch (Exception e) &#123;            ++i;            return i;//执行到此i会被暂时保存，直到执行完finally为止。如果finally中没有结束程序，再回头将保存的给返回回去。        &#125;        finally &#123;            i++;            System.out.println(&quot;i = &quot; + i);        &#125;        return 0;    &#125;    public static void main(String[] args) &#123;        System.out.println(fun());    &#125;//执行结果：//i = 4//3
可以有多个catch语句捕获不同的异常(进行不同的业务处理)，要求父类异常在后，子类异常在前，比如(Exception 在后，NullPointerException 在前）。如果发生异常，只会匹配一个catch。


如：

public class Test &#123;    public static void main(String[] args) &#123;        try &#123;            Person person = new Person();            person = null;//空指针异常，NullPointerException            System.out.println(person.getName());            int n1 = 10, n2 = 0;            int res = n1 / n2;//算数异常，        &#125;        catch (NullPointerException e) &#123;            System.out.println(&quot;空指针异常：&quot; + e);        &#125;        catch (ArithmeticException e) &#123;            System.out.println(&quot;算术异常：&quot; + e);        &#125;        catch (Exception e) &#123;            System.out.println(&quot;其他异常&quot; + e);        &#125;    &#125;&#125;class Person &#123;    private String name = &quot;Jack&quot;;    public String getName() &#123;        return name;    &#125;&#125;

可以省略catch，直接进行try-finally配合使用，这种用法相当于没有捕获异常，因此程序会直接崩掉&#x2F;退出。比如发生异常后不进行处理，只负责关闭一些连接然后崩溃。因为没有处理异常，所以会被默认的throws抛出，层层上抛，直到JJVM机，然后JVM将异常信息打出来，并结束程序。

案例：利用try - catch使的用户输入的必须是整数，不是就重输Scanner scanner = new Scanner(System.in);        int num;        while (true)&#123;            try &#123;                num = Integer.parseInt(scanner.next());//如果输入的字符串不是纯整数，就会抛异常；                break;//只要抛异常就不会执行退出            &#125;            catch (NumberFormatException e) &#123;                System.out.println(&quot;输入有误，请重新输入&quot;);//检测到异常后输出提示信息让用户重新输入。            &#125;        &#125;
throws基本介绍和使用细节
如果个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。

在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。

对于编译异常，程序中必须处理，比如 try - catch 或者throws。
public void f2() throws Exception &#123;//针对编译异常必须要有对应的异常处理才能通过。可以抛出对应的FileNotFoundException异常或者对应异常的父类异常Exception        FileInputStream fileInputStream = new FileInputStream(&quot;D://test.txt&quot;);//这里创建了一个文件流，但因为不存在文件所以会报异常（编译异常）    &#125;
对于运行异常，程序中如果没有处理，默认就是throws的方式处理。知道throws到JVM虚拟机为止。JVM处理异常的功能就是，将异常打印出来，并中断运行。

子类重写父类的方法时，所抛出的异常类型要么和父类抛出的异常一致， 要么为父类抛出的异常的类型的子类型。或者说子类不能扩大父类的异常范围，也不能和父类没有关系。如：
class A&#123;    public void f() throws ArithmeticException&#123;    &#125;&#125;class B extends A&#123;    @Override    public void f() throws ArithmeticException &#123;//只能是父类类A中原函数抛出异常的子类或者他自己，不能比父类大，如Exception    &#125;&#125;
在throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必throws。

如果一个方法调用了另一个存在编译异常且直接throws抛出的方法，则在调用该方法的时候必须明确的处理。
哪怕只是抛出但并没有真正的触发
public void f1()&#123;        f2();//哪怕只是抛出但并没有真正的触发也得处理    &#125;      public void f2() throws FileNotFoundException &#123;    &#125;
public void f1()&#123;        try &#123;            f2();//对于调用的方法如果存在编译异常，则必须对这个异常进行显示(明确)的处理，再次throws抛出或者try        &#125;        catch (FileNotFoundException e) &#123;            throw new RuntimeException(e);//也可以捕获了再抛出        &#125;    &#125;    public void f2() throws FileNotFoundException &#123;//此处不做处理 直接抛出        //创建一个编译异常        FileInputStream fileInputStream = new FileInputStream(&quot;D://test.txt&quot;);    &#125;
或者在方法内就try - catch处理掉，或者捕获后再抛出：
public void f()&#123;        f2();//可以不处理    &#125;    public void f1()&#123;        try &#123;            f2();//也可以处理        &#125;        catch (Exception e) &#123;            System.out.println(e);        &#125;    &#125;    public void f2() &#123;//此处不做处理 直接抛出        //创建一个编译异常        try &#123;            FileInputStream fileInputStream = new FileInputStream(&quot;D://test.txt&quot;);        &#125;        catch (FileNotFoundException e) &#123;            throw new RuntimeException(e);//如果这样抛，也可以调用者也可以不用处理。        &#125;    &#125;
对于运行异常调用者可以不进行处理。因为存在默认的处理机制
public void f()&#123;        f2();//可以不处理，因为有默认的处理机制    &#125;    public void f1()&#123;        try &#123;            f2();//也可以处理一下        &#125;        catch (ArithmeticException e) &#123;            System.out.println(e);        &#125;    &#125;    public void f2() throws ArithmeticException&#123;//此处不做处理 直接抛出        int res = 10/0;    &#125;

自定义异常当程序中出现了某些&quot;错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息。

自定义异常的步骤
定义类自定义异常类名(程序员自己写)继承Exception或RuntimeException；
如果继承Exception，属于编译异常；
如果继承RuntimeException，属于运行异常（一般来说，继承RuntimeException，因为可以使用默认的异常处理机制）；

样例：要求：当我们接收Person对象年龄时，要求范围在18 - 120之间，否则抛出一个自定义异常(要求继承RuntimeException)并给出提示信息public class Test &#123;    public static void main(String[] args) &#123;        int age1 = 16;        if (!(age1 &gt;= 18 &amp;&amp; age1 &lt;= 120)) &#123;//设定一个范围            throw new AgeException(&quot;年龄需要在18-120之间&quot;);//通过构造器设置异常的信息        &#125;        System.out.println(&quot;年龄范围正常&quot;);    &#125;&#125;class AgeException extends RuntimeException &#123;//自定义一个异常类，因为要求是运行时异常，所以继承RuntimeException    public AgeException(String message) &#123;//类的构造函数        super(message);    &#125;&#125;

运行结果：
Exception in thread “main” net.hurr.exception_.AgeException: 年龄需要在18-120之间at net.hurr.exception_.Test.main(Test.java:10)

throw和throws的区别


名字
意义
位置
后面跟的东西



throws
异常处理的一种方式
方法的声明处
异常类型


throw
手动生成异常的关键字
方法体中
异常对象


常用类包装类针对八种基本定义相应的引用类型——包装类。

有了类的特点，就可以调用类中的方法。





基本数据类型
包装类
父类



boolean
Boolean



char
Character



byte
Byte
Number


short
Short
Number


int
Integer
Number


long
Long
Number


float
Float
Number


double
Double
Number


包装类与基本数据类型的转换
jdk5前的手动装箱和拆箱方式，装箱:基本类型-&gt;包装类型，反之，就是拆箱


jdk5以后(含jdk5)的自动装箱和拆箱方式
自动装箱底层调用的是valueOf方法，比如Integer.valueOf()



装箱和拆箱的演示//int &lt;---&gt; Integer//手动装箱int n1 = 100;Integer integer = new Integer(n1);Integer integer1 = Integer.valueOf(n1);//或者这样//手动装箱int i = integer.intValue();//jdk5（包括5）以后的自动装箱拆箱int n2 = 200;Integer integer2 = n2;//底层依然是Integer.valueOf(),本质仍然是手动装箱int n3 = integer2;//同样，底层也还是手动拆箱的intValue()//同理，其他的数据类型也可以这么玩char c = &#x27;A&#x27;;Character C = c;double d = new Double(20.2);
包装类型与String类型的相互转换//包装类 -&gt; StringInteger n = 100;//方式1：相当于生成一个新的串赋值给s1，而i的值不会变String s1 = n+&quot;&quot;;//方式2：比较传统，几乎所有包装类都有这个方法String s2 = n.toString();      String s3 = new Character(&#x27;a&#x27;).toString();//方式3 相当于转换了两次，i变成了obj，obj再到stringString s4 = String.valueOf(n);//String -&gt; 包装类String str = &quot;12345&quot;;Integer i1 = Integer.parseInt(str);Double d = Double.parseDouble(str);Integer i2 = new Integer(str);//利用Integer的构造方法
需要注意的是，当包装类与基本类型相比较的时候，比较的是值而非类型或地址。如：
int n1 = 100;Integer n2 = new Integer(100);System.out.println(n1 == n2);
执行之后会显示true。但Sting没有基本类型，所以如果这么比较，会是false
String s1 = &quot;A&quot;;        String s2 = new String(&quot;A&quot;);        System.out.println(s1 == s2);
String介绍
String对象用于保存字符串，也就是一组字符序列。
字符串常量对象是用双引号括起的字符序列。例如: “你好”、 “12.97”、 “boy”等。
字符串的字符使用Unicode字符编码，一个字符(不区分字母还是汉字)占两个字节。
String类较常用构造器(其它看手册):

String s1 = new String();String s2 = new String(String original);String s3 = new String(char[] a);String s4 = new String(char[] a,int startIndex,int count)//从字符数组中初始化，从第几位开始，获取几个
创建 String对象的方式
方式一:直接赋值String s1 &#x3D; “hurriedlu”;
方式二:调用构造器String s2 &#x3D; new String(“hurriedlu”);

两种创建 String对象的区别方式一：先从常量池查看是否有对应字符串的数据空间，如果有，直接指向;如果没有则重新创建，然后指向。
s1最终指向的是常量池的空间地址。        方式二：先在堆中创建空间，里面维护了value属性，指向常量池的对应字符串的空间。如果常量池没有”hsp”,重新创建，如果有，直接通过value指向。 s2最终指向的是堆中的空间地址。
简单的说，方式一的直接赋值相当于直接指向对应的空间，方式二通过构造函数的方式赋值相当于先创建一个对象，再由对象指向对应的空间。

String的父类和接口接口：Serializable（实现了这个接口说明这个类可以串行化，以便在网络中传输），Comparable（实现了这个接口说明这个类可以相互比较），CharSequence。
String的特性
String是一个final类， 代表不可变的字符序列，也就是说不能被其他类所继承并改写。
字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的。
String的底层还是数组，在String类中维护了一个可变长度的finial类型的value数组，字符串就存储在这个数组中。value一旦指向了某块地址，就不能再指向其他的地址（空间）了。但这块地址的值还是可以随便修改的。

常见的误区public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;========================================&quot;);        System.out.println(&quot;1：&quot;);        //1、求输出结果        String s1 = &quot;abc&quot;;        String s2 = &quot;abc&quot;;        System.out.println(s1.equals(s2));//T，因为equals函数是值比较        System.out.println(s1 == s2);//T,因为指向的是同一个常量池中的地址。        System.out.println(&quot;========================================&quot;);        System.out.println(&quot;2：&quot;);        //2、求输出结果        String s3 = &quot;hurr&quot;;        String s4 = new String(&quot;hurr&quot;);        System.out.println(s3.equals(s4));//T,因为是值比较        System.out.println(s3 == s4);//F,s3是直接指向常量池中的字符串，s4是指向堆中的一个对象，所以地址不同        System.out.println(s3 == s4.intern());//T,因为intern方法是返回常量池的地址，而s3也是常量池中的一个地址        System.out.println(s4 == s3.intern());//F,因为intern方法是返回常量池的地址，而s4是堆中一个对象的地址        System.out.println(&quot;========================================&quot;);        //3、问：以下语句创建了几个对象？        String s5 = &quot;hello&quot;;        s5 = &quot;World&quot;;        //一共创建了两个对象。字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的。        //因此，原来的仍然会保留，只是又新建了一个World的字符串，然后将s5指向了这个字符串。        //4、问：以下语句创建了几个对象？        String s6 = &quot;Hello&quot; + &quot;World&quot;;        //注意，只创建了一个。因为编译器在底层有一个优化，避免了两个字符串没有使用却要占地方，因此等价于String s6 = &quot;HelloWorld&quot;;        //5、问：以下语句创建了几个对象？        String s7 = &quot;Hello&quot;;        String s8 = &quot;World&quot;;        String s9 = s7 + s8;        //一共创建了三个。具体流程如下：        //1. 首先新建一个s9的对象；2. 在常量池中创建一个Hello；3. 在第二步创建的常量后面追加World；4. 将s9中的value指针指向第二步创建的常量。        System.out.println(&quot;========================================&quot;);        System.out.println(&quot;6：&quot;);        //6、问：以下语句的输出情况        String s10 = &quot;Hello&quot;;        String s11 = &quot;World&quot;;        String s12 = (s7 + s8).intern();        String s13 = &quot;HelloWorld&quot;;        System.out.println(s12 == s13);//T        System.out.println(s12.equals(s13));//T    &#125;&#125;
String 常用的方法String类是保存字符串常量的。每次更新都需要重新开辟空间，效率较低，因此java设计者还提供了StringBuilder和StringBuffer来增强String的功能，并提高效率。





方法名
作用



equals
比较两个字符串（String对象）的值是否相等。s1.equal(s2);


equalsIgnoreCase
比较两个字符串是否相等（忽略大小写）。s1.equalsIgnoreCase(s2);


length
返回字符串的长度。s1.length();














intern()
如果常量池已经包含一个等于此String的对象，就返回池中的字符串；否则将此String添加到池中，并返回此String对象的引用简单的说就是，返回常量池对应的字符串的地址，相当于返回用方式1新建出来的String对象。


equals &#x2F;&#x2F;区分大小写，判断内容是否相等equalslgnoreCase &#x2F;&#x2F;忽略大小写的判断内容是否相等length &#x2F;获取字符的个数，宇符串的长度indexOf &#x2F;&#x2F;获取字符在字符串中第1次出现的索引,索引从开始，如果找不到，返回-1lastIndexOf &#x2F;&#x2F;获取字符在字符串中最后1次出现的索引,索引从开始，如找不到，返回-1substring &#x2F;&#x2F;截取指定范围的子串trim &#x2F;&#x2F;去前后空格charAt:获取某索引处的字符，注意不能使用Str[index]这种方式
toUpperCasetoLowerCaseconcatreplace替换字符串中的字符split分割字符串，对于某些分割字符，我们需要转义比如| l\等案例: String poem &#x3D; “锄禾日当午,汗滴禾下土，谁知盘中餐,粒粒皆辛苦”:和文件路径.compareTo &#x2F;&#x2F;比较两个字符串的大小toCharArray &#x2F;&#x2F;转换成字符数组format &#x2F;&#x2F;格式字符串，%s宇符串%c字符%d整型%.2f浮点型案例，将一个人的信息格式化输出
StringBuffer
java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删。
很多方法与String相同，但StringBuffer是可变长度的。
StringBuffer是一个容器。

StringBuffer的特性
StringBuffer 的直接父类 是 AbstractStringBuilder；
StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化；
在父类中 AbstractStringBuilder 有属性 char[] value,不是 final，因此该 value 数组存放在堆中而不是常量池；
StringBuffer 是一个 final 类，不能被继承 ；
因为 StringBuffer 字符内容是存在 char[] value, 所有的变化(增加&#x2F;删除) 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String

String 和 StringBuffer的区别
String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址， 效率较低&#x2F;&#x2F;private final char value[];
StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次更新地址（只有在空间不够的时候才会更新，即不支持动态调整空间），效率较高&#x2F;&#x2F;char[] value; &#x2F;这个放在堆.

StringBuffer的构造器StringBuffer()构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符。简单的说就是，创建一个大小为 16 的char[]，用于存放字符内容。
StringBuffer(CharSequence seq)public java.lang StringBuilder(CharSequence seq)构造-一个字符串缓冲区，它包含与指定的CharSequence相同的字符。
StringBuffer(int capacity) &#x2F;&#x2F;capacity [容量]构造一个不带字符，但具有指定初始容量的字符串缓冲区。即对char[]大小进行指定和第一个构造器类似，简单的说就是可以指定初始空间的大小。
StringBuffer(String str)构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容。简单的说就是用已有的str对象创建一个StringBuffer对象，其空间大小为str字符串的长度+16.需要注意的是，如果str是一个空串，则会抛出空指针异常。因为在源码中需要先计算。如下代码所示
String str = null;StringBuffer s = new StringBuffer(str);
会抛出空指针异常。（java.lang.NullPointerException）因为在底层会先获取str的长度，而空串是没有长度的。

需要注意的是，如果用于初始化的数组
String 和 StringBuffer相互转换String 转 StringBuffer简单的说就是利用上方第四个构造器，创建一个StringBuffer对象；

String str = &quot;hurriedlu&quot;;StringBuffer stringBuffer = new StringBuffer(str);//注意，返回的只是一个利用str的值创建StringBuffer的对象，对他本身没有影响。
同样也可以利用追加的方式

StringBuffer stringBuffer1 = new StringBuffer();stringBuffer1 = stringBuffer1. append(str);//将str的值追加到新创的append里面。
StringBuffer 转 String同样也可以利于构造器进行转换
StringBuffer stringBuffer = new StringBuffer(&quot;Hurriedlu&quot;);String s1 = new String(stringBuffer);
利用StringBuffer的toString方法：
StringBuffer stringBuffer3 = new StringBuffer(&quot;Hurriedlu&quot;);String str = stringBuffer3.toString();
StringBuffer的常用方法
追加（增）
StringBuffer s = new StringBuffer(&quot;hello&quot;);s.append(&#x27;,&#x27;);s.append(&quot;worle&quot;);s.append(&quot;!&quot;).append(100).append(true).append(10.5);//append可以连，且返回值都是StringBuffer的类型。System.out.println(s);//hello,worle!100true10.5/*需要注意的是，如果追加的字符串是空，是null，则将null转换成字符串的“null”追加到后面。*/
删
StringBuffer s = new StringBuffer(&quot;helloworld&quot;);s.delete(5,10);//删除字符串序列中大于等于start,小于end的字符，小于10的字符。（序号从0起，左闭右开，类似于c++里面的迭代器）System.out.println(s);//hello
（替换）改
StringBuffer s = new StringBuffer(&quot;hello123world&quot;);s.replace(5,8,&quot;,&quot;);//同上面的删除功能，左闭右开，从0起，将区间内的文字替换成第三个参数System.out.println(s);//hello,world
查
StringBuffer s = new StringBuffer(&quot;123123123&quot;);int index = s.indexOf(&quot;2&quot;);//返回第一次出现实参数据的位置，此处返回1.因为序列是从0起System.out.println(index);
插
StringBuffer s = new StringBuffer(&quot;Hello,!&quot;);s.insert(6,&quot;World&quot;);//从0起，在第6个的位置插入参数2的数据,原来在参数1及后面的位置的数据自动后移System.out.println(s);//Hello,World!
长度
StringBuffer s = new StringBuffer(&quot;Hello&quot;);int len = s.length();//返回字符串的长度System.out.println(len);//5

StringBuilderStringBuilder一个可变的字符序列。此类提供一个与StringBuffer兼容的APl,但不保证同步(换句话说就是StringBuilder不是线程安全的)。该类被设计用作StringBuffer的一个简易替换，
用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类！因为在大多数实现中，它比StringBuffer要快。        在StringBuilder上的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据。
StringBuilder 常用方法StringBuilder和StringBuffer均代表可变的字符序列，方法是一样的，所以使用和StringBuffer一样。

StringBuilder的特点
StringBuilder 继承 AbstractStringBuilder 类；
实现了 Serializable ,说明 StringBuilder 对象是可以串行化(可以串行话说明对象可以网络传输，也可以保存到文件)
StringBuilder 是 final 类, 不能被继承；
StringBuilder 对象字符序列仍然是存放在其父类 AbstractStringBuilder 的 char[] value，因此，字符序列是存放在堆中的；
StringBuilder 的方法没有做互斥的处理,即没有 synchronized 关键字,因此最好只在单线程的情况下使用。

String、StringBuffer 和 StringBuilder的比较
StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样；
String:不可变字符序列，效率低，但是复用率高（因为字符串只会出现一次，后续的都会指向常量池中这唯一的一个）；
StringBuffer:可变字符序列、效率较高(增删)、线程安全；
StringBuilder: 可变字符序列、效率最高、线程不安全；
String使用注意说明:string s&#x3D;”a”; &#x2F;&#x2F;创建了一个字符串S +&#x3D; “b”; &#x2F;&#x2F;实际上原来的”a”字符串对象已经丢弃了（但还存在），现在又产生了一个字符串s+”b” (也就是” ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。结论:如果我们对String做大量修改，不要使用String

String、StringBuffer 和 StringBuilder 的应用场景
如果字符串存在大量的修改操作，-般使用StringBuffer或StringBuilder
如果字符事存在大量的修改操作，并在单线程的情况，使用StringBuilder
如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer
如果我们字符串很少修改，被多个对象引用，使用String,比如配置信息等

Math类Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。
Math常用的方法（均为静态方法）abs  求绝对值int n1 = Math.abs(-2);double n2 = Math.abs(-9.8);System.out.println(&quot;n1 = &quot; + n1 + &quot;   n2 = &quot; + n2);//n1 = 2   n2 = 9.8
pow 求幂（返回值为double）double s = Math.pow(2,3);//8.0，2的3次方
ceil 向上取整（返回大于等于该参数的最小整数，返回值依然是double）double s = Math.ceil(2.8);//3.0
floor 向下取整（返回小于等于该参数的最小整数，返回值依然是double）double s = Math.floor(2.8);//2.0
round 四舍五入（返回值为long，约等于Math.floor(该参数+0.5)？）long s = Math.round(2.8);//3
sqrt 求算数平方根（要求参数为大于等于0的非负数）double sqrt = Math.sqrt(9);//3.0
random 求随机数（返回一个大于等于0并且小于1之间的一个小数）double rand = Math.random()
扩展：求一个给定的范围之间的随机数（大于等于a , 小于等于b）
int n = (int)(a + Math.random() * (b - a + 1));
max , min 返回最大值和最小值int maxx = Math.max(2,3);//3int minn = Math.max(2,3);//2
Arrays该类的主要作用就是用于管理和操作数组（如排序、搜索等）
Arrays的常用方法toString    以字符串形式返回数组中的元素int arr[] = &#123;1,3,7,5&#125;;System.out.println(Arrays.toString(arr));//[1, 3, 7, 5]
sort排序（同c++一样，默认从小到大，也支持自定义）int arr[] = &#123;1, 3, 7, 5, -1&#125;;Arrays.sort(arr);System.out.println(Arrays.toString(arr));//[-1, 1, 3, 5, 7]
支持的数组类型：int,long,short,char,byte,float,double等。
同时，在Java中也支持sort的排序规则自定义（利用实现了Comparable接口的一个匿名内部类，要求实现 compare方法）。（ sort(T[] a , Comparator &lt;? super T&gt; c ) ）
Integer arr[] = &#123;1, 3, 7, 5, -1&#125;;//注意这里一定要是Integer,不能是int数组Arrays.sort(arr,new Comparator()&#123;  public int compare(Object o1,Object o2)&#123;    Integer i1 = (Integer) o1;    Integer i2 = (Integer) o2;    return i2-i1;  &#125;&#125;);System.out.println(Arrays.toString(arr));//[7, 5, 3, 1, -1]
binarySearch    通过二分搜索法进行查找，要求必须排好序Integer arr[] = &#123;1, 3, 7, 5, -1&#125;;//注意这里一定要是Integer,不能是int数组Arrays.sort(arr);//因为查找是基于二分的，所以要求序列有序.[-1, 1, 3, 5, 7]int index;//index = Arrays.binarySearch(arr, 5);//3index = Arrays.binarySearch(arr, 0);//-2//这个方法的一个特点就是，如果找不到，就返回这个数应该在的位置，并置为负数。简单的说就是返回左右指针相等的那个值的负数
copyOf    数组元素复制Integer arr[] = &#123;1, 3, 7, 5, -1&#125;;//注意这里一定要是Integer,不能是int数组Integer num[] = Arrays.copyOf(arr,arr.length);//从arr数组复制，复制arr.length个元素System.out.println(arr == num);//F，这是两个除了值一样其余完全不相干的数组System.out.println(Arrays.equals(arr,num));//T
fill 数组元素填充Integer arr[] = &#123;1, 3, 7, 5, -1&#125;;//注意这里一定要是Integer,不能是int数组Arrays.fill(arr,0);//全部填充System.out.println(Arrays.toString(arr));//[0, 0, 0, 0, 0]Arrays.fill(arr,1,3,2);//将数组arr中从下标1（包含）到3（不包含）的元素的值填充为2.System.out.println(Arrays.toString(arr));//[0, 2, 2, 0, 0]
equals 比较两个数组元素的内容是否完全一 致int arr1[] = &#123;1,2,3&#125;;int arr2[] = &#123;1,2,3&#125;;System.out.println(Arrays.equals(arr1,arr2));//T//需要注意两个数组的类型必须一样，哪怕一个是int一个是Integer都不行
asList 将一组值，转换成list
asList 方法，会将数组中的数据转成一个 List 集合
返回的 asList 编译类型 List（是接口）
asList 运行类型 java.util.Arrays#ArrayList, 是 Arrays 类的一个静态内部类 private static class ArrayList extends AbstractList implements RandomAccess, java.io.Serializable

Arrays项目：将自定义类型用sort的形式进行排序package net.hurr.annotation_;import java.util.Arrays;import java.util.Comparator;public class Test &#123;    public static void main(String[] args) &#123;        Book books[] = new Book[4];        books[0] = new Book();        books[0].setName(&quot;红楼梦&quot;);        books[0].setPricr(100.0);        books[1] = new Book();        books[1].setName(&quot;知音漫客&quot;);        books[1].setPricr(90.0);        books[2] = new Book();        books[2].setName(&quot;青年文摘&quot;);        books[2].setPricr(5.0);        books[3] = new Book();        books[3].setName(&quot;Java 从入门到入土&quot;);        books[3].setPricr(900.0);        Arrays.sort(books, new Comparator&lt;Book&gt;() &#123;            @Override            public int compare(Book o1, Book o2) &#123;                if (o2.getPricr() &gt; o1.getPricr()) &#123;                    return 1;                &#125;                else if (o2.getPricr() == o1.getPricr()) &#123;                    return 0;                &#125;                else &#123;                    return -1;                &#125;            &#125;        &#125;);        System.out.println(Arrays.toString(books));    &#125;&#125;class Book &#123;    private String name;    private Double pricr;    public Book(String name, Double pricr) &#123;        this.name = name;        this.pricr = pricr;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Double getPricr() &#123;        return pricr;    &#125;    public void setPricr(Double pricr) &#123;        this.pricr = pricr;    &#125;    public Book() &#123;    &#125;    @Override    public String toString() &#123;        return &quot;Book&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +                &quot;, pricr=&quot; + pricr +                &#x27;&#125;&#x27;;    &#125;&#125;//[Book&#123;name=&#x27;Java 从入门到入土&#x27;, pricr=900.0&#125;, Book&#123;name=&#x27;红楼梦&#x27;, pricr=100.0&#125;, Book&#123;name=&#x27;知音漫客&#x27;, pricr=90.0&#125;, Book&#123;name=&#x27;青年文摘&#x27;, pricr=5.0&#125;]
SystemSystem常用的方法exit    退出当前程序System.exit(-1);//括号中的参数代表一个状态，一般来说都写0，代表正常退出。反映在“进程已结束,退出代码0”
arraycopy :复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成数组的复制。
该方法的五个参数如下所示
@param    src    the source array .     源数组的地址@param    srcPos    starting position in the source array .        从源数组的第几个位置开始拷贝@param    dest    the destination array。    目标数组的地址@param    destPos    starting position in the destination data.    拷贝到目标数组的哪个位置@param    Length     the number of array elements to be copied。    从源数组拷贝多少个元素到目标数组。不能超过源数组长度

int num[] = &#123;1, 2, 3&#125;;int arr[] = new int[5];System.arraycopy(num, 0, arr, 0, 3);System.out.println(Arrays.toString(arr));//[1, 2, 3, 0, 0]
currentTimeMillens    返回当前时间距离1970-1-1的毫秒数System.out.println(System.currentTimeMillis());
gc    运行垃圾回收机制System.gc();
BigInteger 和 BigDecimal 类应用场景:

如果一个数非常大，大到长整型都装不下的时候，就可以利用 BigInteger 或 BigDecimald进行处理存储
BigInteger适合保存比较大的整型
BigDecimal适合保存精度更高的浮点型(小数)
在对大数进行加减乘除的时候，需要使用其对应的的方法处理，不能直接相加。

BigInteger 和 BigDecimald的常用方法add    加BigInteger bigInteger1 = new BigInteger(&quot;12312312312312312312312123123123&quot;);BigInteger bigInteger2 = new BigInteger(&quot;12312312312312312312312123123123&quot;);System.out.println(bigInteger1);bigInteger1 = bigInteger1.add(bigInteger2);System.out.println(bigInteger1);/*1231231231231231231231212312312324624624624624624624624246246246*/
subtract    减BigInteger bigInteger1 = new BigInteger(&quot;24624624624624624624624246246246&quot;);BigInteger bigInteger2 = new BigInteger(&quot;12312312312312312312312123123123&quot;);System.out.println(bigInteger1);bigInteger1 = bigInteger1.subtract(bigInteger2);System.out.println(bigInteger1);/*2462462462462462462462424624624612312312312312312312312123123123*/
multiply    乘BigInteger bigInteger1 = new BigInteger(&quot;12312312312312312312312123123123&quot;);BigInteger bigInteger2 = new BigInteger(&quot;12312312312312312312312123123123&quot;);System.out.println(bigInteger1);bigInteger1 = bigInteger1.multiply(bigInteger2);System.out.println(bigInteger1);/*12312312312312312312312123123123151593034475917358800237024411796154713271830424740055417273129*/
divide    除BigInteger bigInteger1 = new BigInteger(&quot;151593034475917358800237024411796154713271830424740055417273129&quot;);BigInteger bigInteger2 = new BigInteger(&quot;12312312312312312312312123123123&quot;);System.out.println(bigInteger1);bigInteger1 = bigInteger1.divide(bigInteger2);System.out.println(bigInteger1);/*15159303447591735880023702441179615471327183042474005541727312912312312312312312312312123123123*/
日期类第一代日期类 Date (java.util.Date)精确到毫秒，代表特定的瞬间

Date d1 = new Date(); //获取当前系统时间，即从1970年1月1日到现在经过了多少毫秒System.out.println(&quot;当前日期=&quot; + d1);//默认输出的日期格式为英文状态的星期 月份 天 时间 年份。即Sat May 28 17:21:19 CST 2022Date d2 = new Date(9234567); //通过指定毫秒数得到时间System.out.println(&quot;d2=&quot; + d2); //显示通过毫秒数创建的日期
SimpleDateFormat 格式化和解析日期Date d1 = new Date(); //获取当前系统时间System.out.println(d1);//因为默认的格式不便于读写，可以通过SimpleDateForma类对Date对象进行格式化//创建一个SimpleDateFormat对象，可以指定相应的格式。如年月日时分秒星期。SimpleDateFormat SDF = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss E a&quot;);System.out.println(SDF.format(d1));//格式化后输出当前的日期，2022年05月28日 18:03:01 周六 下午//2022年05月28日 05:30:02 周六




字母
日期或时间元素
表示
示例



G
Era标志符
Text
AD


y
年
Year
1996；96（四位&#x2F;两位）


M
月
Month
July；Jul；07


w
一年中的第几周
Number
27


W
一个月中的第几周
Number
2


D
一年中的第几天
Number
189


d
一个月中的第几天
Number
10


F
一个月中的第几个星期
Number
2


E
星期几
Text
周六


a
am&#x2F;pm标记
Text
PM；下午


H
小时（0-23）
Number
0


k
小时（1-24）
Number
24


K
am&#x2F;pm中的小时（0-11）
Number
0


h
am&#x2F;pm中的小时（1-12）
Number
12


m
分钟
Number
30


s
秒
Number
55


S
毫秒
Number
998


z
时区
Genera1 time zone
Pacific Standard Time; PST; GMT-08:00


Z
时区
RFC 822 time zone
-0800


第二代日期类，主要就是Calendar类(日历)。Calendar类是一个抽象类，它为特定瞬间与组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。

Calendar的说明
Calendar 是一个抽象类， 并且构造器是 private，如果需要创建对象，需要通过 getInstance() 来获取实例；
Calendar c = Calendar.getInstance();
提供大量的方法和字段，如果需要获取某个字段，可以参照如下格式；
c.get(Calendar.字段名);
Calendar 没有提供对应的格式化的类，因此需要自己组合来输出（灵活）；
Calendar c = Calendar.getInstance();System.out.println(&quot;年：&quot;+c.get(Calendar.YEAR));System.out.println(&quot;月：&quot;+(c.get(Calendar.MONTH)+1));//因为月是从0开始编号的System.out.println(&quot;日：&quot;+c.get(Calendar.DAY_OF_MONTH));System.out.println(&quot;时：&quot;+c.get(Calendar.HOUR));System.out.println(&quot;分：&quot;+c.get(Calendar.MINUTE));System.out.println(&quot;秒：&quot;+c.get(Calendar.SECOND));/*年：2022月：5日：28时：7分：57秒：43*/
如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR &#x3D;&#x3D;改成&#x3D;&gt; Calendar.HOUR_OF_DAY


第三代日期类JDK 1.0中包含了一个java.util.Date类,但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar也存在问题是:


可变性:像日期和时间这样的类应该是不可变的。
偏移性: Date中的年份是从1900开始的， 而月份都从0开始。
格式化:格式化只对Date有用，Calendar则不行。
此外，它们也不是线程安全的;不能处理闰秒等(每隔2天，多出1s)。

因此，在JDK8引入了新的类：
LocalDate(日期&#x2F;年月日)、LocalTime(时间&#x2F;时分秒)、LocalDateTime(日期时间&#x2F;年月日时分秒)
LocalDate只包含日期，可以获取日期字段LocalTime只包含时间，可以获取时间字段LocalDateTime包含日期+时间，可以获取日期和时间字段
LocalDateTime的常用方法以及通过DateTimeFormatter格式化输出//1、使用now返回当前的日期时间，返回值是一个LocalDateTime的对象LocalDateTime ldt = LocalDateTime.now();//LocalDate和LocalTime也有now方法，可以分别获取当前的日期和时间System.out.println(ldt);//2022-05-28T20:11:25.378881600//2、单独提取现在的年月日时分秒System.out.println(&quot;年：&quot;+ldt.getYear());System.out.println(&quot;月：&quot;+ldt.getMonth());System.out.println(&quot;日：&quot;+ldt.getDayOfMonth());System.out.println(&quot;时：&quot;+ldt.getHour());System.out.println(&quot;分：&quot;+ldt.getMinute());System.out.println(&quot;秒：&quot;+ldt.getSecond());//3、格式化显示：依靠DateTimeFormatter。整个过程类似于SimpleDateFormat,但还有更多的功能。具体见手册中DateTimeFormatter部分DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);System.out.println(dtf.format(LocalDateTime.now()));
Instant 时间戳类似于Date，提供了一系列和Date类转换的方式：
获取当前的时间戳Instant now = Instant.now();//利用Instant类的now方法（静态）获取当前的时间戳System.out.println(now);//2022-05-28T12:32:09.611215Z
Instant 转 DateDate date = Date.from(instant);
Date 转 Instant:Instant instant = date.tolnstant();
案例演示:Instant now &#x3D; Instant. now0;System. out.println(now);Date date &#x3D; Date. from(now);Instant instant &#x3D; date.tolnstant();
常用的LocalDateTime方法plus  过多少
集合集合解决了数组的一些局限性，比如：

长度开始时必须指定，而且一旦指定，不能更改；
保存的必须为同类型的元素；
使用数组进行增加&#x2F;删除元素比较麻烦；

集合的特点
可以动态保存任意多个对象（不限类型），使用比较方便；
提供了一系列方便的操作对象的方法: add、remove. set. get（增删改查）等；
使用集合添加,删除新元素简洁明了；

集合的框架体系集合主要分为两组，根据实现的接口不同分别是单列集合和双列集合，他们分别存储了一个元素或一个具有两个元素的键值对。
其中的单列集合Collection接口继承了Iterator类


实现了Collection 接口（单列）的子类的特点
collection实现子类可以存放多个元素，每个元素可以是0bject；
有些Collection的实现类，可以存放重复的元素，有些不可以；
有些Collection的实现类，有些是有序的(List，即存入的顺序和读取的顺序一致),有些不是有序(Set，即存入顺序和读出的顺序并不相同)；
Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的；

Collection 接口的常用方法(以ArrayList进行演示)
创建集合
List list = new ArrayList();//创建一个ArrayList集合，用List接口进行接收，本段演示均基于这个集合
add:添加单个元素
list.add(&quot;Hello&quot;);//只要是基于Object的对象都可以放入，换句话说就是可以放入所有的对象list.add(10);//放入基本数据类型会自动装箱成为一个对应包装类的对象list.add(true);System.out.println(&quot;list = &quot; + list);//list = [Hello, 10, true]
remove:删除指定元素
String s = (String)list.remove(0);//可以删除指定第几个（从0起），如果使用索引删除则返回被删除的对象System.out.println(s);//Helloboolean b = list.remove(new Integer(10));//如果删除的是指定的对象的话，返回的就是是否删除成功System.out.println(b);//trueb = list.remove(new Integer(11));//删除一个不存在的对象System.out.println(b);//falseSystem.out.println(&quot;list = &quot; + list);//list = [true]
contains:查找元素是否存在
if (list.contains(true)) &#123;//查找list里面是否存在一个true的对象，返回值为布尔型    System.out.println(&quot;存在&quot;);&#125;else&#123;    System.out.println(&quot;不存在&quot;);&#125;if (list.contains(false)) &#123;//查找list里面是否存在一个true的对象，返回值为布尔型    System.out.println(&quot;存在&quot;);&#125;else&#123;    System.out.println(&quot;不存在&quot;);&#125;//执行结果：//存在//不存在
size:获取元素个数
System.out.println(list.size());//获取当前list的个数，并输出出来，结果是1
isEmpty:判断是否为空
System.out.println(&quot;list集合是空的吗 &quot; + list.isEmpty());//判断集合是否为空//list集合是空的吗 false
clear:清空
list.clear();//清空整个集合的元素System.out.println(&quot;list集合是空的吗 &quot; + list.isEmpty());//然后再判断一下集合是否为空//list集合是空的吗 true
addAll:添加多个元素
ArrayList arrayList = new ArrayList();//临时创建一个集合并存入一些元素arrayList.add(&quot;hello&quot;);arrayList.add(&quot;hurriedlu&quot;);arrayList.add(100);list.addAll(arrayList);//只要是实现了Collection接口的对象都可以被添加进来。System.out.println(&quot;list = &quot; + list);//list = [hello, hurriedlu, 100]
containsAll:查找(判断)多个元素是否都存在，只要有一个元素不存在就返回false
//判断arrayList中所有的元素是否都存在，这个arrayList可以是任何实现了Collection接口的对象。System.out.println(list.containsAll(arrayList));//truelist.remove(new Integer(100));//删除掉一个元素再判断System.out.println(list.containsAll(arrayList));//false
removeAll：删除多个元素。只要有一个被删掉就返回true
list.add(&quot;hurriedlu&quot;);//添加一个存在的list.add(&quot;hurr&quot;);//添加一个之前不存在的// 删除和arrayList有关的元素，并输出一下结果.System.out.println(list.removeAll(arrayList));//true//看一下剩余的对象System.out.println(&quot;list = &quot; + list);//list = [hurr]





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>基础教程</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Windwos环境下F键的功能介绍</title>
    <url>/2023/02/28/Windwos%E7%8E%AF%E5%A2%83%E4%B8%8BF%E9%94%AE%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[F键的功能
f1可以帮你在困境中寻找帮助
可以唤出帮助页


f2可以在你懒得动右手中指时助你快速重命名
windows中可以快速的进行重命名操作


f3可以在你懒得动右手食指时助你搜遍文件夹
windows中可以打开搜索框进行搜索


f4和alt放在一起可以让电脑自动做你要做的工作
这个组合键可以强制关闭选定的窗口&#x2F;程序


f5可以陪伴你度过无聊的等待时光
可以对当前的页面进行刷新


f6可以在你懒得翻历史记录时助你搜到爱看的
f7可以在浏览器中切换使用文本光标浏览网页
f8可以在电脑启动时进入启动高级菜单选项（看电脑）
f9可以在windows media player降低音量 excel里计算
f10＋shift&#x3D;鼠标右键
Windows中可以用这个快捷键实现当前选项&#x2F;界面的右键操作


f11可以让你看片看的更爽
浏览器中可以使用这个键进入全屏模式


f12可以进入开发者工具
浏览器中快速打开开发者工具。



]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下通过CURL实现自动签到功能</title>
    <url>/2024/01/31/linux%E4%B8%8B%E9%80%9A%E8%BF%87CURL%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[本说明可以实现通过访问某一个链接就能实现签到网站。

获取链接
在点击签到之前打开开发者工具
点击链接
找到签到的网络活动





右击这个链接活动 -&gt; 复制 -&gt; 以cURL(bash)的格式复制



将复制的内容替换到模板中 response=$(  )的括号中。
找出页面中只有访问成功后一定出现字符串，如用户名、关键字等，将这个的值替换模板中 SUCCESS_STRING=&quot;字符串&quot;  处的 字符串。注意，一定要确保设置的字符串是正确的，如果检测不到字符串，会在一定的时间后再次访问。
执行这个脚本，检查访问结果。

shell脚本模板
#!/bin/bash#URL=&quot;http://www.51hei.com/bbs/&quot;  # 替换为你要访问的网站URLSUCCESS_STRING=&quot;字符串&quot;   # 替换为你要检测的成功字符串，识别到此字符串视为访问成功while true; do    #将复制的签到链接放置到括号里面。    response=$(  )  # 发送 GET 请求并将响应存储在变量中    if [[ $response == *&quot;$SUCCESS_STRING&quot;* ]]; then        echo &quot;访问成功！&quot;        echo &quot;&quot;        echo &quot;页面内容：&quot;        echo &quot;$response&quot;        break  # 如果成功，退出循环    else        echo &quot;访问未完成，等待10-20分钟后重试...&quot;        sleep $(( (RANDOM % 11) + 10 ))m  # 随机等待10-20分钟    fidone

模板说明：

当执行这shell脚本的时候，会一定的方式（如curl）命令来访问指定的链接。
访问之后，检测返回的内容是否包含设定的关键字，如果检测到，则输出 访问成功！ ，并在输出执行结果后退出。
如果没有检测到指定的关键字，则输出 访问未完成，等待10-20分钟后重试... ，随机等待10-20分钟后（通过sleep $(( (RANDOM % 11) + 10 ))m实现），然后再次执行，知道检测到指定的关键字为止。

]]></content>
      <categories>
        <category>知识杂谈</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>Linux</tag>
        <tag>curl</tag>
        <tag>知识杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>windows环境下使用dhcpsrv实现dhcp服务器</title>
    <url>/2025/05/04/windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8dhcpsrv%E5%AE%9E%E7%8E%B0dhcp%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[起因是一个很奇葩的需求：乙方要远程升级仪器，用TeamViewer远程控制并ssh到仪器，但仪器内部IP地址没有写死，靠DHCP服务器获取。那么就要在PC建立DHCP服务器，用网线连接仪器，然后才能看到仪器分配的IP，从而进行连接。网上搜了一下dhcpsrv是一个很好的帮助建立DHCP服务的软件。官网：
http://www.dhcpserver.de/cms/

最新版本需要donate才能下载，下载以前的版本即可。首先右键“我的电脑”，选择“管理”，左边选择“服务”，查看DHCP Server并未运行。

运行dhcpwiz.exe，下一步。

选择你需要连接的以太网口，把其IP作为DHCP服务器的IP，下一步。

我们只是把PC当作DHCP服务器，并不要设置DNS，什么都不做，下一步。

选择可分配的IP池，为了更容易ping到仪器（一开始不知道分配的IP可查- -），我们选择在本机网段内只分配2个IP给仪器（101和102）。其它不需要设置，下一步。

打勾并把我们前面的配置写到ini

查看解压文件夹里面的dhcpsrv.ini，下一步。

这里打开和在系统服务里打开是一样的，主要是生成的ini文件很重要！我们直接点击“完成”。

在服务管理里面，右键启动DHCP服务。看到服务正在运行。

用网线插上仪器。查看dhcpsrv.ini，此时在最下方会多出几行表明IP分配成功，并会显示已分配的IP。如果这里不成功，请看最后！

wim+R+cmd打开终端，可以ping通仪器。

好了，到这里对方就可以远程访问仪器了~
遇到的问题：一开始在启动DHCP服务后，我们一直无法ping通仪器，最后发现要关闭主机上的防火墙


如果连接的也是windows电脑，对方的防火墙也要关闭！
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>Windows</tag>
        <tag>DHCP</tag>
      </tags>
  </entry>
  <entry>
    <title>二手硬盘选购找坡指南</title>
    <url>/2023/11/17/%E4%BA%8C%E6%89%8B%E7%A1%AC%E7%9B%98%E9%80%89%E8%B4%AD%E6%89%BE%E5%9D%A1%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[二手硬盘选购找坡指南
以迈拓为代表的ide并口硬盘

概述
这种硬盘属于很古老的产品了, 还健在的话，使用时间已经是几万小时了, 盘片也存在老化的风险, 并且IDE并口已经基本找不到了。




西数假黑盘：500G - 1T

原因

这类硬盘往往在闲鱼上标注“全新”、“库存全新”等, 但是这些所谓的“全新”, 基本上都是维修盘或清零的, 清零自不用说，通电几万小时的硬盘, 清零后当全新出售, 而维修盘，则是原本其他型号的硬盘, 经过维修之后，抹掉原来的信息, 篡改硬盘型号，贴上假标签, 由于修改非常彻底, 在硬盘软件中只硬盘型号是看不出马脚的, 切勿在闲鱼贪小便宜吃大亏。


概述

闲鱼上标注为”全新”、”库存全新”的硬盘往往是维修盘或清零处理过的。维修盘是其他型号的硬盘经过维修后，抹掉原来的信息，篡改型号贴上假标签。这些修改非常彻底，只有通过硬盘软件才能发现。购买这些硬盘可能会导致质量问题，请谨慎选择。


盘体照片

不存在统一的盘体，全部都有可能。







西数的神奇幸运发发发硬盘

原因
即808.8G容量的绿盘, 这个硬盘因为本身的缺陷, 不能做成1T容量的, 被西数的营销部门一通骚操作, 直接就割国人的韭菜了, 本身这个买的人也不多, 但是我要劝喜欢把888和发发发联系起来的朋友, 这个88是拜拜的意思，不要会错意。


概述
从1t盘阉割而来，屏蔽坏道和转速后降为808.8G（标准931G）。
质量本身就不行。


盘体照片





酷鱼09年固件门

原因
这是希捷2009年的大雷——固件门的受害者之一, 固件门包括的型号有, 酷鱼7200.11、酷鱼ES.2 SATA、SV35系列, 轻则硬盘卡顿坏道，重则直接死亡变砖, 这件事也让很多人对希捷这个品牌敬而远之, 但值得指出的是, 大家买东西应该要看具体型号而非只认品牌, 选择正确型号的盘，才是制胜之道。


概述
注意型号：酷鱼7200.11、酷鱼ES.2 SATA、SV35系列


盘体照片





希捷酷鱼ST1000DM010

原因
希捷为了省钱，采用磁头内停泊设计, 故障率偏高，并且同时阉割了RV（震动传感器）, 曾经出过无数经典型号的Barracuda酷鱼系列, 现在为了省钱，只剩一副空空的骨架了。


概述
磁头设计缺陷
采用了内停泊，还阉割了震动传感器。


盘体照片





希捷酷鱼DM001、DM008系列

原因
包括2T和3T的版本（包括ST2000DM001、ST3000DM001）, 这个版本的酷鱼问题在于磁头架材料有缺陷, 磁头会将盘片的涂层直接划伤, 如果不幸划伤了固件区，硬盘甚至会无法识别, 后面上的DM008是DM001的小改款, 但是治标不治本，依然会划伤盘片, 导致出现唱片一样的划痕, 并且这几块硬盘全部阉割了震动传感器, 从三个阉割到了一个。


概述
磁头架材料缺陷，会将涂层划伤
阉割了震动传感器


盘体照片






日立3T&#x2F;4T（日立的翻新盘，也是目前最流行的翻新盘）

原因
这个应该是目前3T和4T的假盘中最流行的了, 这些硬盘都由日立（Hitachi）, 或日立环球【昱科】（HGST）生产, 已停产很长时间，特点是宽额头，左下角有三个螺丝孔, 因极其容易被清零, 所以成为各类翻车视频的常客。这个家伙从自己山寨自己, 到山寨成自己老板公司WD家的紫盘, 再到山寨成对手家希捷的酷鹰, 不所不能无孔不入, 最简单的避坑方法就是你不要去买这个盘体下这两个容量的硬盘, 另外现在西数出售的HC310、HC320、HC330等硬盘, 是西数收购HGST后的产品, 盘体与上述类似，细节略有不同（比如左下角及标签）, 并非是翻新产品，可以放心购买。


概述
特别容易被清零，慎买这个盘体中3-4T的硬盘（不局限品牌，因为品牌可以作假）


盘体照片





西数的老企业级——RE和SE两个系列。

原因
这两款盘固件老, 很容易被维修和清零, 虽然是企业级硬盘，但是年久失修，很容易翻车, 因为这两款盘是黄黑或蓝黑标签, 贩子最喜欢的就是将这两款盘造假成黑盘出售, 这个盘体很好认，就是正面有一圈黑色的铝, 如果在闲鱼看到这个盘体的硬盘，请尽量避免购买。


概述
固件老, 很容易被维修和清零。
容易造假成黑盘出售


盘体照片





希捷的绿圈盘（返修盘）

原因
这个盘是希捷的返修盘, 俗称R盘，返修盘是指硬盘曾经损坏, 原厂通过返修，再次上市, 无论是官方返修还是奸商私修, 盘片和磁头都有不确定性，所以不再建议购买了。


概述
硬盘返修赌人品。


盘体照片





OS盘

原因
由于smart信息中型号显示为oos, 同时标签上没有希捷logo，只有“OS”字体, 所以才叫这个名字, 这种盘是通过返修之后，依然不达到出厂标准, 理应被回收处理的电子垃圾级产品, 不仅没有官方保修，质量上更是一落千丈, 这种os盘不被官方承认，暴毙的风险也很大, 一些商家将os盘贴上银河的标签虚假销售, 一定要坚决抵制。


概述
电子垃圾级别的质量。


盘体照片





西数的元素盘（Elements）(西数桌面移动硬盘)

原因
以西数的元素盘（Elements）为首的一系列3.5英寸桌面移动硬盘, 也包括Mybook系列等, 这种盘主要在海外亚马逊出售, 内部是西数的“OS级”硬盘, 是7200转的不合格企业级产品, 降速到5400转并屏蔽坏块得来的, 内部硬盘盒缺乏散热手段, 很容易导致硬盘温度过高, 并且由于保修限制, 目前在国内大概率是没办法得到厂家质保的,


概述
质量一般，没有质保


盘体照片






2.5寸
希捷几个2.5寸SMR硬盘系列
原因
型号分别是LM007、LM008、LM015、LM048, 这几个系列使用同一个7mm厚度的盘体, 该盘体最大的问题在于设计缺陷, 磁头很容易划伤盘片, 这种盘体的硬盘, 在希捷2t及以下移动硬盘或酷鱼系列被广泛使用。出于数据安全的考虑, 建议大家尽量避开这些型号。


概述
叠瓦盘
磁头容易划伤盘片


盘体照片





东芝MQ03系列 
原因
尽管它是难得的CMR硬盘, 但MQ03的为了开出更大容量, 加热器在温度低时启动（如25摄氏度以下）很容易受损, 具体表现为严重掉速和曲线失常, 这个系列常见于16-18年东芝移动硬盘, 型号例如MQ03UBB300, 十块盘中，可能有九块加热器都出现了或多或少的问题, 翻车率很高，尽量避免购买,


概述
故障率高，容易翻车


盘体照片





东芝MQ04系列
原因
这是MQ03的继任者, 很不幸，他是叠瓦盘（SMR）, 尽管这款型号的速度相比西数、希捷的同类产品有些许优势, 然而叠瓦的策略很糟糕, 很容易脏盘（即速度巨大波动且下降）甚至卡死。夸张一点说，东芝的叠瓦盘算是“集大成者”, 将西数和希捷的叠瓦缺点集合在了一起, 因为东芝近年以来的出货率远不如西数和希捷, 统计故障率的数据样本不够, 很多硬盘的稳定性仍是一个问号, 但必须要指出，近两年的P300，品控极差, 请勿购买，请勿购买，请勿购买！（重要的事情说三遍）。


概述
叠瓦盘
叠瓦策略容易脏盘卡死


盘体照片






简要的说，希捷酷鱼不要买；叠瓦不要买；东芝慎重考虑；号称全新的硬盘也不要买。除非你知道你在干什么。同条件下不要考虑希捷。
来源

https://www.bilibili.com/video/BV1TS4y1f7VN/

]]></content>
      <categories>
        <category>硬盘</category>
        <category>知识杂谈</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>知识杂谈</tag>
        <tag>硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 CloudFlare Worker 搭建 Docker 加速镜像</title>
    <url>/2024/06/23/%E4%BD%BF%E7%94%A8%20CloudFlare%20Worker%20%E6%90%AD%E5%BB%BA%20Docker%20%E5%8A%A0%E9%80%9F%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[所需资源
cloudflare账号
域名（自带的域名或被墙）

步骤
在面板左侧找到 Workers 和 Pages，然后点击右侧的 创建应用程序、创建 Worker，修改一个好记的名字，部署






接下来编辑代码，将 worker.js 的内容替换为下面内容：

Vxxxxxxxxxx132 1// import HTML from &#39;./docker.html&#39;;23const HTML = `4&lt;!DOCTYPE html&gt;5&lt;html&gt;6    &lt;head&gt;7        &lt;meta charset=&quot;utf-8&quot; /&gt;8        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;9        &lt;title&gt;Mirror Usage&lt;/title&gt;10        &lt;style&gt;11        html &#123;12        height: 100%;13        &#125;14        body &#123;15        font-family: &quot;Roboto&quot;, &quot;Helvetica&quot;, &quot;Arial&quot;, sans-serif;16        font-size: 16px;17        color: #333;18        margin: 0;19        padding: 0;20        height: 100%;21        display: flex;22        flex-direction: column;23        justify-content: space-between;2425        &#125;26        .container &#123;27            margin: 0 auto;28            max-width: 600px;29        &#125;3031        .header &#123;32            background-color: #438cf8;33            color: white;34            padding: 10px;35            display: flex;36            align-items: center;37        &#125;3839        h1 &#123;40            font-size: 24px;41            margin: 0;42            padding: 0;43        &#125;4445        .content &#123;46            padding: 32px;47        &#125;4849        .footer &#123;50            background-color: #f2f2f2;51            padding: 10px;52            text-align: center;53            font-size: 14px;54        &#125;55        &lt;/style&gt;56    &lt;/head&gt;57    &lt;body&gt;58        &lt;div class=&quot;header&quot;&gt;59        &lt;h1&gt;Mirror Usage&lt;/h1&gt;60        &lt;/div&gt;61        &lt;div class=&quot;container&quot;&gt;62        &lt;div class=&quot;content&quot;&gt;63            &lt;p&gt;镜像加速说明&lt;/p&gt;64            &lt;p&gt;65            为了加速镜像拉取,你可以使用以下命令设置registery mirror:66            &lt;/p&gt;67            &lt;pre&gt;68            sudo tee /etc/docker/daemon.json &amp;lt;&amp;lt;EOF69            &#123;70                &quot;registry-mirrors&quot;: [&quot;https://&#123;&#123;host&#125;&#125;&quot;]71            &#125;72            EOF73            &lt;/pre&gt;74            &lt;/br&gt;75            &lt;p&gt;76            为了避免 Worker 用量耗尽,你可以手动 pull 镜像然后 re-tag 之后 push 至本地镜像仓库:77            &lt;/p&gt;78            &lt;pre&gt;79            docker pull &#123;&#123;host&#125;&#125;/library/alpine:latest # 拉取 library 镜像80            docker pull &#123;&#123;host&#125;&#125;/coredns/coredns:latest # 拉取 library 镜像81            &lt;/pre&gt;82        &lt;/div&gt;83        &lt;/div&gt;84        &lt;div class=&quot;footer&quot;&gt;85        &lt;p&gt;Powered by Cloudflare Workers&lt;/p&gt;86        &lt;/div&gt;87    &lt;/body&gt;88&lt;/html&gt;89`;9091export default &#123;92    async fetch(request) &#123;93        const url = new URL(request.url);94        const path = url.pathname;95        const originalHost = request.headers.get(&quot;host&quot;);96        const registryHost = &quot;registry-1.docker.io&quot;;9798        if (path.startsWith(&quot;/v2/&quot;)) &#123;99        const headers = new Headers(request.headers);100        headers.set(&quot;host&quot;, registryHost);101102        const registryUrl = `https://$&#123;registryHost&#125;$&#123;path&#125;`;103        const registryRequest = new Request(registryUrl, &#123;104            method: request.method,105            headers: headers,106            body: request.body,107            // redirect: &quot;manual&quot;,108            redirect: &quot;follow&quot;,109        &#125;);110111        const registryResponse = await fetch(registryRequest);112113        console.log(registryResponse.status);114115        const responseHeaders = new Headers(registryResponse.headers);116        responseHeaders.set(&quot;access-control-allow-origin&quot;, originalHost);117        responseHeaders.set(&quot;access-control-allow-headers&quot;, &quot;Authorization&quot;);118        return new Response(registryResponse.body, &#123;119            status: registryResponse.status,120            statusText: registryResponse.statusText,121            headers: responseHeaders,122        &#125;);123        &#125; else &#123;124        return new Response(HTML.replace(/&#123;&#123;host&#125;&#125;/g, originalHost), &#123;125            status: 200,126            headers: &#123;127            &quot;content-type&quot;: &quot;text/html&quot;128            &#125;129        &#125;);130        &#125;131    &#125;132&#125;




接下来，点击右上角的 部署，稍等片刻

最后，返回面板，在 设置，触发器 处设置一个自己的域名，一切就大功告成了不建议使用自带的 workers.dev 的域名，被墙了V


]]></content>
      <categories>
        <category>CloudFlare</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>CloudFlare</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>域名解析的类型</title>
    <url>/2024/01/26/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[在DNS（域名系统）中，当你添加DNS记录时，“类型”字段是指你想要创建的具体类型的资源记录（RR, Resource Record）。每种类型的记录都有其特定的目的和格式：


A记录 (Address)：将一个完全合格的域名（FQDN）映射到一个IPv4地址。例如，将www.example.com指向192.0.2.1。

AAAA记录：类似于A记录，但用于映射域名到一个IPv6地址。

CAA记录 (Certificate Authority Authorization)： CAA记录允许域名所有者指定哪些证书颁发机构（CA）可以为其域名签发SSL&#x2F;TLS证书。这有助于防止未经授权的CA错误或恶意地为您的域名发放证书。

CERT记录： CERT记录用于存储X.509证书或者PKIX证书信息在DNS系统中。这种类型的记录较少使用，主要用于安全相关的应用，比如IPsec和TLS认证等。

CNAME记录 (Canonical Name)：别名记录，用于将一个域名指向另一个域名，实际解析会指向目标域名的A或AAAA记录。

DNSKEY记录： DNSKEY记录是DNSSEC（DNS Security Extensions）的一部分，它包含了公钥数据，用于对区域传输和查询响应进行签名验证，以确保DNS数据的完整性和来源的真实性。

DS记录 (Delegation Signer)： DS记录也是DNSSEC的一部分，它存在于父域中，引用子域的DNSKEY记录，并提供一个散列值来验证子域的DNSSEC签名链。

LOC (Location)： LOC记录 用于存储地理位置信息。它允许域名所有者将特定的地理坐标与一个域名关联起来。LOC记录包含了经纬度、海拔高度以及精度等信息，主要用于标识网络资源（如服务器或设备）在地球上的具体位置。这种类型的记录在一些特定的应用场景下有用，比如通过DNS查找设备的物理位置，但在日常网站访问和邮件服务等方面并不常见。LOC记录的内容遵循RFC1876的标准格式进行编码。

MX记录 (Mail Exchange)：指定处理该域电子邮件的邮件服务器及其优先级。例如，定义example.com的邮件服务器为mail.example.com。

NAPTR记录 (Naming Authority Pointer)： NAPTR记录用于支持更复杂的名称转换服务，常用于ENUM（电话号码映射到URI）和其他高级命名方案。

NS记录 (Name Server)：指定托管域名区域的DNS名称服务器。

PTR记录 (Pointer Record)： PTR记录主要应用于反向DNS解析，将IP地址转换回域名。通常在IPv4的IN-ADDR.ARPA域或IPv6的IP6.ARPA域内使用。

SMIMEA：SMIMEA是DNS记录类型的一种，全称为S&#x2F;MIME证书颁发者授权记录（S&#x2F;MIME Authority Resource Record）。这种记录类型是在RFC8398中定义的，用于支持S&#x2F;MIME（Secure&#x2F;Multipurpose Internet Mail Extensions）邮件加密和签名服务。
在电子邮件安全领域，S&#x2F;MIME是一种标准，用于加密、签名以及验证电子邮件的内容。SMIMEA记录允许域名所有者指定哪些证书颁发机构（CA）可以为其域内的电子邮件地址签发S&#x2F;MIME证书，类似于CAA记录对TLS&#x2F;SSL证书颁发机构的限制作用。
当邮件客户端或其他S&#x2F;MIME处理软件需要验证来自某个域名的S&#x2F;MIME证书时，它们可以通过查询该域名的SMIMEA记录来确定是否信任由特定CA颁发的证书。这有助于提高电子邮件通信的安全性并防止未经授权的CA为域名发放证书。

SRV记录 (Service Location Record)： SRV记录用来定义特定服务的位置（即哪个主机提供了该服务以及通过哪个端口），如XMPP聊天服务、SIP电话服务等。

SSHFP：SSHFP（Secure Shell Fingerprint）是DNS记录类型的一种，它在RFC 4255中被定义。SSHFP记录用于存储SSH主机密钥的指纹信息，从而允许客户端验证远程SSH服务器的身份。
当SSH客户端连接到一个SSH服务器时，通常会通过SSHFP记录来验证服务器提供的公钥指纹是否与域名关联的DNS SSHFP记录相匹配。这样可以防止中间人攻击，并确保客户端连接的是预期且合法的SSH服务器。
SSHFP记录包含三个字段：资源记录类型（固定为SSHFP）、算法类型和指纹类型以及指纹值。其中，算法类型和指纹类型分别表示生成公钥所使用的加密算法和散列函数，而指纹值则是该公钥经过指定散列函数计算后得到的唯一标识符。

SVCB：SVCB（Service Binding and Parameter Specification for DNS）是DNS记录类型的一种，它在RFC 8624中被定义。SVCB记录允许通过DNS提供服务相关的参数和协议绑定信息，以便客户端能够更高效、安全地连接到服务端点。
SVCB记录主要用于服务发现，它允许发布者指定服务使用的协议版本、端口号、ALPN标识符（Application-Layer Protocol Negotiation）和其他特定于服务的参数。例如，在HTTP&#x2F;3或QUIC协议场景下，SVCB记录可以指示一个域名支持这些新协议，并提供相应的服务端点地址和配置信息。
这种记录类型对于实现网络服务的快速切换和优化具有重要意义，特别是在互联网基础设施演进的过程中，有助于推动新的传输层协议和技术的部署和使用。

TLSA：TLSA (Transport Layer Security Authentication) 是DNS记录类型的一种，它在RFC 6698和RFC 7671中被定义。TLSA记录主要用于DNS-Based Authentication of Named Entities (DANE) 技术框架，以增强基于SSL&#x2F;TLS协议的网络服务的安全性。
TLSA记录允许域名所有者通过DNS发布其服务（如HTTPS、SMTP等）所使用的TLS&#x2F;SSL证书或公钥信息。当客户端连接到支持DANE验证的服务时，可以查询相应的TLSA记录来验证服务器提供的证书是否与DNS记录中的数据相匹配，从而减少对传统证书颁发机构（CA）的信任依赖，并防止中间人攻击。
一个典型的TLSA记录包含了以下四部分：

资源记录类型：固定为TLSA。
使用证书的位置：证书用途字段（Cert Usage），如端点身份验证（PKIX-TA）、信任锚证明（PKIX-EE）等。
匹配类型：指定如何从证书中提取要匹配的数据（完整证书、公共密钥、指纹等）。
匹配数据：证书的部分内容或指纹，用于与服务器提供的证书进行比对验证。


TXT记录：文本记录，通常用于存储可读的文本信息，也可以用于验证域名所有权（如DKIM、SPF、DMARC记录）或其他服务的验证过程。

URI：URI（Uniform Resource Identifier）统一资源标识符，并不是DNS记录类型，而是一种用于唯一标识互联网上资源的字符串格式标准。URI包括URL（Uniform Resource Locator）和URN（Uniform Resource Name）两种形式。
在DNS系统中，虽然没有直接称为“URI”的DNS记录类型，但通过结合其他DNS记录类型如CNAME或HTTPREDIRECT（某些DNS服务商提供的非标准扩展记录类型），可以间接实现将域名映射到特定URI的目的。
例如，当用户访问一个设置为CNAME或其他重定向类型的DNS记录指向的域名时，最终会被重定向到一个具体的URI地址。然而，在DNS层面上，它并不直接处理或存储URI信息，而是处理域名与IP地址或其他域名之间的映射关系。

SOA记录 (Start of Authority)： SOA记录标志着一个DNS区域的开始，包含了区域的基本管理信息，例如主名字服务器、电子邮件联系人、序列号、刷新时间等参数。

LOC记录 (Location Record)： LOC记录用于存储地理位置坐标信息，比如经纬度、海拔高度等，这样可以通过DNS查找设备或资源的实际位置。

SPF记录 (Sender Policy Framework)： SPF记录虽然现在推荐使用TXT记录进行配置，但本质上是用于指定发送邮件的合法IP地址范围，防止伪造邮件源地址。

HINFO记录 (Host Information): HINFO记录包含主机的CPU类型和操作系统信息，这个记录类型已不再广泛使用，因为它可能暴露了不必要的安全性信息。


]]></content>
      <categories>
        <category>知识杂谈</category>
        <category>域名</category>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>知识杂谈</tag>
        <tag>域名解析</tag>
      </tags>
  </entry>
  <entry>
    <title>对讲机的常用功能术语</title>
    <url>/2024/06/24/%E5%AF%B9%E8%AE%B2%E6%9C%BA%E7%9A%84%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[监听（MONITOR）为接受弱小信号而采用的一种收听方式。通过按专用键强制接通接收信号通道，操作者用耳朵辨别扬声器中的微弱声音，达到收听的目的。
监听键一般是听对方的信号不清楚或是有断续的时候，按住这个键接听，效果会好一点。一般会有2到3个按键。第一个为PTT发射键就不说了。在有两个按键情况下第二个按键一般为静噪键〔在接收信号不好的时候使用〕，在一些叫高档的机子中次键还可以支持编程功能。如，身份码发射，报警，1750中继触发等。如果为三个按键，第二个键就为功能键〔功能设置或者作为组合键使用〕或者可编程键〔同上〕，第三个按键就为静噪键了。
扫描（SCAN）为了听到所有信道的通话，而采用的一种收听方式。
通过按专用键，使接收电路按一定顺序逐个信道接收一段时间，以收听到信道中的信号。若每个信道接收时间为100ms，则每秒可扫描过十个信道，即扫描速度为10ch&#x2F;s 。
优先信道扫描功能(PriorityChannel Scan)在扫描过程中优先扫描所设定的优先信道。
删除&#x2F;添加扫描信道(Delete&#x2F;Add Scan Channel)将某一信道从扫描列表中删除或添加到扫描列表中。
声控（VOX）当该功能被激活后，不必按PTT键，可直接通过语音启动发射操作。
VOX，Voice operated exchange，直译成中文就是「声音触发转换」。一般使用对讲机，我们需要按下对讲机的通话键再进行通话。但如果开启了 VOX，不用按下通话键，只要对讲机的麦克风检测到说话声就会自动开启发射，实现「声控」通话。当麦克风听不到声音时则会关闭：VOX 最大的意义就在于，可以让你彻底的解放双手，轻松通话。
发射限时功能(TOT: TimeOut Timer)发射限时功能此功能是防止任何呼叫方占用信道时间过长，计时器限制对讲机每次的发射时间，限制用户超时发射。
该功能用于限制用户在一信道上超时间发射，同时也避免对讲机因长时间发射而造成损坏。
省电功能(BatterySave)对讲机除了具有操作简单、通话成本低、应用范围广等特点外，还具有省电功能，能够使设备的待机时间更长，对讲机都具有省电功能，当对讲设备在一定时间内没有发射接受和按键操作时，对讲机将自动采取一段时间关机，一段时间开机的方式工作，也就是省电模式，省电功能的开关机时间长度比大约为1：4，当收到信号或有按键操作时，便立即进入正常的工作状态
照明功能(Backlight)用于在夜间或昏暗的情况下操作，可看清楚LCD显示和按键。
复制功能(Cloning)该功能允许将一台对讲机中的数据复制到型号相同的其他对讲机中。
静噪级数(SquelchLevel)接收信号中噪声的强弱与信号的强弱呈对应关系，信号越强噪声越弱。把最大噪声和最小噪声之间分成若干档，每一档称为一级。分成的档数叫静噪级数。用户可根据实际情况进行选择。
载波话音、数字信号、信令等有用信号的载体，易于传输的高频电磁波。
2-TONE&#x2F;DTMF选呼功能利用2-TONE或DTMF信令选择呼叫相应的对讲机。
倒频功能(ReverseFrequency)即是将对讲机的发射频率和接收频率将互换，并且所设定的信令也进行互换。
在有中继的时候一方不使用中继或者是中继突然不工作时候，而是把中继的使用的两个收发频率倒过来使用的一种通连方式。倒频通连具有信号直接（没有通过中继）、不改变对方使用中继的方式，因此适合在对方不知不觉的情况下进行直接通连测试。
脱网功能(Talk Around)使用脱网功能时，对讲机的发射频率变得与接收频率相同；发射信令也转成与接收信令相同。
自动应答功能(Auto-Transpond)当对讲机收到一个正确编码呼叫时，向呼叫方发出一个信号以响应呼叫。
紧急报警(EmergencyAlarm)按下报警专用键，对讲机以最大声音发出报警声或发出预定报警码给其他的手持机或基台。
巡逻登记(PatrolRecord)巡逻人员到达巡逻点时，对讲机将收到巡逻登记器发出的查询信号，然后自动启动登记操作，把自身的身份码等信息发给巡逻登记器予以登记，表明某巡逻人员已到达该地。
锁键功能(Keylock)使用该功能可以防止键的误操作。对讲机键盘锁可以锁定和解锁，这个功能主要就是为了防止误触碰按键，把正在使用的方式给调乱了。对讲机的键盘锁按键一般是标记着#号的键，上面还会有一个小钥匙符号。
调制
用调制信号的某一种或某几种参数控制载波的参数的改变，按照控制参数的不同，调制又可分为调幅、调频和调相。
高低功率选择功能(High&#x2F;Lowpower)该功能可让用户根据实际情况选择高功率或低功率。
禁发功能(BusyChannel Lockout)当使用该功能时，用户禁止在繁忙信道上发射信号。
信道和信道间隔（Channel Spacing）信道指发射接收时占用的频率值。信道间隔（Channel Spacing）指对讲机设置的两个相邻信道的频率差。规定的信道间隔有25KHz(宽带)、20KHz、12.5KHz(窄带)等。
CTCSSCTCSS(Continuous Tone Controlled Squelch System) , 连续语音控制静噪系统，俗称亚音频，是一种将低于音频频率的频率（67Hz-250.3Hz）附加在音频信号中一起传输的技术。因其频率范围在标准音频以下，故称为亚音频。当对讲机对接收信号进行中频解调后，亚音频信号经过滤波、整形，输入到CPU中，与本机设定的CTCSS频率进行比较，从而决定是否开启静音。
CDCSSCDCSS(Continuous Digital Controlled Squelch System)，连续数字控制静噪系统，其作用与CTCSS相同，区别在于它是以数字编码方式来作为静音是否开启的条件。
DTMFDTMF（Dual Tone Multi Frequency），双音多频，由高频群和低频群组成，高低频群各包含4个频率。一个高频信号和一个低频信号叠加组成一个组合信号，代表一个数字。DTMF信令有16个编码。利用DTMF信令可选择呼叫相应的对讲机。
]]></content>
      <categories>
        <category>对讲机</category>
        <category>知识杂谈</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>知识杂谈</tag>
        <tag>对讲机</tag>
      </tags>
  </entry>
  <entry>
    <title>泉盛UVk5对讲机简易使用指南</title>
    <url>/2024/06/24/%E6%B3%89%E7%9B%9BUVk5%E5%AF%B9%E8%AE%B2%E6%9C%BA%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[简易使用说明一键对频功能在不借助写频软件的前提下，使用这个方法同步其他对讲机当前通道的频率。
操作步骤
设备开机。
按下 F 键、4键进入频率计模式。
发射机按动PTT键（发送键），此时UVK5会显示出发射机的频率和哑音频（CTC）。
此时，按MEMU键（M）可以进行保存操作。
当扫描完成后（屏幕第三栏显示扫描结束，同时能显示出频率和CTC参数的值），按下MEMU按键，此时UVK5会发出“存储信道”的声音，屏幕的第三栏会显示SAVE:信道号。通过按动⬆和⬇可以切换要保存到的信道。（信道号的表现形式为：CH-xxx，xxx表示具体的信道，例如5信道显示为：CH-005）
当选择完信道之后，再次按下MEMU按键，UVK5会提示是否进行保存（第三栏显示为SAVE?）。
如果需要保存，再次按下MEMU按键进行确认，此时UVK5会发出“确定”的声音。此时，系统就会将当前信道参数保存到对应的信道里面。
如果需要重新扫描，可以按下 *键，UVK5会重新对能接收到的频段进行扫描。



解锁特殊频段的发射功能说明解锁特殊频段的发射限制。
操作步骤
设备关机。
按下PTT键（发射键）和PTT键下方的按键（同时按下）的同时，设备开机。
开机后会自动进入设置菜单，此时会出现隐藏的设置选项。

]]></content>
      <categories>
        <category>对讲机</category>
        <category>使用说明</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>知识杂谈</tag>
        <tag>对讲机</tag>
      </tags>
  </entry>
  <entry>
    <title>消除B站广告屏蔽插件的提示信息</title>
    <url>/2024/03/12/%E6%B6%88%E9%99%A4B%E7%AB%99%E5%B9%BF%E5%91%8A%E5%B1%8F%E8%94%BD%E6%8F%92%E4%BB%B6%E7%9A%84%E6%8F%90%E7%A4%BA%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[由于chrome用了某些插件, 所以在访问b站的时候出现了如下某些提示：
检测到您的页面展示可能受到浏览器插件影响，建议您将当前页面加入插件白名单，以保障您的浏览体验～

解决办法：
其一：去掉广告屏蔽器
其二：干掉这个横幅

在广告屏蔽插件中新建一个规则，内容为：

www.bilibili.com##.adblock-tips 

]]></content>
      <categories>
        <category>广告屏蔽</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>广告屏蔽</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>玩客云部署java环境</title>
    <url>/2024/01/26/%E7%8E%A9%E5%AE%A2%E4%BA%91%E9%83%A8%E7%BD%B2java%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[jdk包
jdk-7u60-linux-arm-vfp-hflt.tar.gz
zulu8.74.0.17-ca-jdk8.0.392-linux_aarch32hf.tar.gz

部署
将软件包上传到服务器上，然后移动到指定的位置。

解压
# 假设您将JDK压缩包上传到了 /usr/local 并命名为 jdk-&lt;version&gt;-linux-x64.tar.gzcd /usr/localtar -zxvf jdk-&lt;version&gt;-linux-x64.tar.gz# 解压后可以重命名目录以便管理，例如：mv jdk-&lt;version&gt; java-oracle-jdk&lt;version&gt;

配置环境变量

配置全局变量

编辑/etc/profile文件


配置当前用户的个人变量

特定用户的 家目录的.bashrc 或 .bash_profile 文件


增加如下配置：
export JAVA_HOME=/usr/local/java-oracle-jdk&lt;version&gt; # 替换为实际路径，注意不要有尾斜杠export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar


验证安装和切换：

执行 java -version 和 javac -version 来检查Java环境是否已经成功安装了java环境。



]]></content>
      <categories>
        <category>玩客云</category>
        <category>Linux部署</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>玩客云</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法与数据结构</title>
    <url>/2024/02/28/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[基础算法排序快速排序思想：基于分治。
确定分界点。在数组中随便找一个值，以划分出左右两堆数；

常见方法

直接取左边界，即q[ l ]；（边界不能是i）
直接取中间值，即q[ ( l + r ) &#x2F; 2 ]；
直接取右边界，即q[ r ]；（边界不能是j）
也可以直接随机一个值



调整区间。使得第一步确定的分界点x左边的区间全部 ≤ x，右边区间全部 ≥ x；


方法1，思想简单但需要额外空间。比较暴力，需要两个额外空间，但时间复杂度还好，是线性的
需要两个额外的数组 a[ ] , b[ ]；
扫描整个数组q[ l ~ r ]，若 q[ i ] &lt;&#x3D; x ，则将q [ i ] 存入a [] 数组，否则存入b[ ]数组；
先将数组a[ ]中的所有数据存取q[ ]，然后将数组b[ ]中的所有数据存入q[ ]；
方法2，时间复杂度空间复杂度都很好
需要两个额外的数组指针，设这两个指针为 i ， j，并将指针 i 指向数组的最左边，指针 j 指向数组的最右边。
判断指针 i 是否大于 x ，如果不大于，指针后移，直到找到第一个大于 x 的地方；
同理判断指针 j 是否小于 x ，如果小于，指针前移，直到找到第一个小于 x 的地方；
交换指针 i 和 j 指向空间的数据；
重复2 - 4步，直到指针 i j 相遇为止



递归处理左右两端，使得左右区间全部有序


实现代码：对数组进行排序模板void qsort(int nums[], int l, int r) &#123;    if (l &gt;= r)        return;    int x = nums[(l + r) / 2];    int i = l - 1;    int j = r + 1;    while (i &lt; j) &#123;        do &#123;            i++;        &#125; while (nums[i] &lt; x);        do &#123;            j--;        &#125; while (nums[j] &gt; x);        if (i &lt; j)            swap(nums[i], nums[j]);    &#125;    qsort(nums, l, j);    qsort(nums, j + 1, r);&#125;

C&#x2F;C++：#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;int n, nums[N];/// &lt;summary&gt;/// 快速排序，范围要求是左开右闭/// &lt;/summary&gt;/// &lt;param name=&quot;nums&quot;&gt;要排序的数组&lt;/param&gt;/// &lt;param name=&quot;l&quot;&gt;左边界（开始迭代器）&lt;/param&gt;/// &lt;param name=&quot;r&quot;&gt;右边界（结束迭代器）&lt;/param&gt;void qsort(int nums[], int l, int r) &#123;    if (l &gt;= r)//如果当左右边界相等的时候，证明已经递归到当前区域只有一个元素，也就表示当前区域已经有序了，可以直接退出        return;    int x = nums[(l + r) / 2];//随便选一个数当作分界点    int i = l - 1;//生成本轮循环的左边界（要求各多算一个）    int j = r + 1;//生成本轮循环的右边界（要求各多算一个）    while (i &lt; j) &#123;//开始本轮循环 要求左右边界不能碰面        do &#123;//必须要do while,先++后判断            i++;        &#125; while (nums[i] &lt; x);        do &#123;//同理 先--后判断            j--;        &#125; while (nums[j] &gt; x);        if (i &lt; j)//可能会有越界的行为，因此在交换前需要先判断            swap(nums[i], nums[j]);    &#125;    qsort(nums, l, j);//递归循环左边界，分界点一定要是j而不能是i    qsort(nums, j + 1, r);//递归循环右边界&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 0; i &lt; n; i++) &#123;        scanf(&quot;%d&quot;, &amp;nums[i]);    &#125;    qsort(nums, 0, n - 1);    for (int i = 0; i &lt; n; i++) &#123;        printf(&quot;%d &quot;, nums[i]);    &#125;    return 0;&#125;

Javapackage sort;import java.util.ArrayList;import java.util.Arrays;import java.util.Scanner;public class Main &#123;    private static final int N = 100000;    public static int n;    public static int num[] = new int[N];    public static void qsort(int nums[],int l,int r)&#123;        if (l &gt;= r)//如果当左右边界相等的时候，证明已经递归到当前区域只有一个元素，也就表示当前区域已经有序了，可以直接退出            return;        int x = nums[(l + r) / 2];//随便选一个数当作分界点        int i = l - 1;//生成本轮循环的左边界（要求各多算一个）        int j = r + 1;//生成本轮循环的右边界（要求各多算一个）        while (i &lt; j) &#123;//开始本轮循环 要求左右边界不能碰面            do &#123;//必须要do while,先++后判断                i++;            &#125; while (nums[i] &lt; x);            do &#123;//同理 先--后判断                j--;            &#125; while (nums[j] &gt; x);            if (i &lt; j)//可能会有越界的行为，因此在交换前需要先判断            &#123;                int t = nums[i];                nums[i] = nums[j];                nums[j] = t;            &#125;        &#125;        qsort(nums, l, j);//递归循环左边界，分界点一定要是j而不能是i        qsort(nums, j + 1, r);//递归循环右边界    &#125;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        n = scanner.nextInt();        for (int i = 0;i &lt; n;i++)&#123;            num[i] = scanner.nextInt();        &#125;        qsort(num, 0, n - 1);        //System.out.println(Arrays.toString(num));        for (int i = 0;i &lt; n;i++)&#123;            System.out.print(num[i] + &quot; &quot;);        &#125;    &#125;&#125;

归并排序思想：依然是分治但具体实现的方式与快排不相同

确定in数。
递归排序左右两边
归并。把两个有序的数组合并成一个数组

实现代码：对数组进行排序模板void merge_sort(int q[], int l, int r)&#123;    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);    int k = 0, i = l, j = mid + 1;    while (i &lt;= mid &amp;&amp; j &lt;= r)        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];        else tmp[k ++ ] = q[j ++ ];    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];&#125;

C&#x2F;C++#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;int n, nums[N], tmp[N];//数据长度，数据，辅助数组/// &lt;summary&gt;/// 归并排序/// &lt;/summary&gt;/// &lt;param name=&quot;nums&quot;&gt;要排序的数组&lt;/param&gt;/// &lt;param name=&quot;l&quot;&gt;左边界&lt;/param&gt;/// &lt;param name=&quot;r&quot;&gt;右边界&lt;/param&gt;void mergeSort(int nums[], int l, int r) &#123;    if (l &gt;= r)//当当前区域只有一个甚至一个元素都没有的时候，这个区域就有序了，可以退出了        return;    int mid = l + r &gt;&gt; 1;//算出整个数据的中间位置    //开始递归排序左右两边          mergeSort(nums, l, mid);    mergeSort(nums, mid + 1, r);    //开始归并到辅助数组    int k = 0;//存储当前进度    int i = l, j = mid + 1;//两个区域的首地址    while (i &lt;= mid &amp;&amp; j &lt;= r) &#123;        if (nums[i] &lt; nums[j])            tmp[k++] = nums[i++];        else            tmp[k++] = nums[j++];    &#125;    //进行扫尾，将剩余元素全部直接接到辅助数组的末尾    while (i &lt;= mid)        tmp[k++] = nums[i++];    while (j &lt;= r)        tmp[k++] = nums[j++];    //将辅助数组中的数据复制到原始数组中    for (int i = l, j = 0; i &lt;= r; i++, j++) &#123;        nums[i] = tmp[j];    &#125;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 0; i &lt; n; i++) &#123;        scanf(&quot;%d&quot;, &amp;nums[i]);    &#125;    mergeSort(nums, 0, n - 1);    for (int i = 0; i &lt; n; i++) &#123;        printf(&quot;%d &quot;, nums[i]);    &#125;    return 0;&#125;

应用第K个数&#x2F;第K小的数（快排+二分）
第k个数给定一个长度为 n 的整数数列，以及一个整数 k，请用快速选择算法求出数列从小到大排序后的第 k 个数。
输入格式第一行包含两个整数 n 和 k。
第二行包含 n 个整数（所有整数均在 1∼10^9^ 范围内），表示整数数列。
输出格式输出一个整数，表示数列的第 k 小数。
数据范围1≤n≤1000001≤k≤n
输入样例：5 32 4 1 5 3

输出样例：3
思路
首先这个数是否存在比较好判断（如果k大于n，直接报错即可），并且此题目保证了k ≤ n
在快排的时候，每次快排完成都可以使key左边的都比key小，右边的都比key大。因此，key的位置x就是整个序列中第x小的数。
快排完事之后递归之前，计算一下key的位置，看是否大于de

实现代码#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, k, num[N];int findKth(int num[], int l, int r, int k)&#123;    //基础的快排部分    if (l &gt;= r)        return num[l];    int key = num[l + r &gt;&gt; 1];    int i = l - 1;    int j = r + 1;    while (i &lt; j)    &#123;        do i++; while (num[i] &lt; key);        do j--; while (num[j] &gt; key);        if (i &lt; j) swap(num[i], num[j]);    &#125;    //快排之后得出一个序列，key左边的都比key小，右边的都比key大。此时，key这个数的位置，就是key在序列中的位置    int lcnt = j - l + 1;//计算出key的位置。位置等于k的位置减去左边界    if (k &lt;= lcnt)//如果要找到数在key的位置的前面，或者就是key        return findKth(num, l, j, k);//递归查找左边界到key这段距离    else//否则答案的位置就在key的右侧（不包括key）。递归查找key下一个位置到右边界的区间        return findKth(num, j + 1, r, k - lcnt);//假设要查找第7小的数，已经找到第5小的了，只需要在第六小开始的位置找出第2小的就行&#125;int main()&#123;    scanf_s(&quot;%d%d&quot;, &amp;n, &amp;k);    for (int i = 0; i &lt; n; i++) scanf_s(&quot;%d&quot;, &amp;num[i]);    cout &lt;&lt; findKth(num, 0, n - 1, k) &lt;&lt; endl;    return 0;&#125;

小结
虽然快排和归并都是nlgn级别的复杂度，但这是在宏观上的量级，在使用的时候，一般来说快排比归并快了两到三倍。

二分整数二分思想：本质是找边界给定一个区间，在这个区间上定义了某种性质，使得这个性质在整个范围的右半边是满足的，在左半边是不满足的；（即利用这个性质可以将整个范围一分为二）


```![image-20220628124834662](./Image/Other/image-20220628124834662.png)查找边界1：1. 首先还是计算出mid的值，mid = (l+r) / 2;2. 检查获取到的mid的值 if ( check( mid )  ) 看是否成立   1. 若为true，则表示mid的位置可能是答案，因此范围缩小至 [ mid , r ]；因此更新方式为  l = mid ;   2. 若为false，则表示在答案在 l 到 mid - 1 （因为是整数二分，数是离散的）; 因此更新方式为 r = mid -1;查找边界2：1. 首先还是计算出mid的值，mid = (l+r) / 2;2. 检查获取到的mid的值 if ( check( mid )  ) 看是否成立   1. 若为true，则表示mid的位置可能是答案，因此范围缩小至 [ l , mid ]；因此更新方式为  r = mid ;   2. 若为false，则表示在答案在 [ mid+1 , r ]  ; 因此更新方式为 l = mid + 1;简单的说就是根据查找边界的不同，mid的更新是下取整还是上取整。#### 模板```c整数二分算法模板 —— 模板题 AcWing 789. 数的范围bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质//前边界// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch_1(int l, int r)&#123;    while (l &lt; r)    &#123;        int mid = l + r &gt;&gt; 1;        if (check(mid)) r = mid;    // check()判断mid是否满足性质        else l = mid + 1;    &#125;    return l;//如果保证必然有解，可以输出，否则需要判断一下当前的l的位置是否是要找的数&#125;//后边界// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：int bsearch_2(int l, int r)&#123;    while (l &lt; r)    &#123;        int mid = l + r + 1 &gt;&gt; 1;//对mid进行上取整        if (check(mid)) l = mid;        else r = mid - 1;    &#125;    return l;&#125;

模板的使用说明
如果说要查找的数是唯一的，或者随便一个等值的，则两个模板随便一个就行。
如果需要查找的数（或者相关的数据）是这些个等值的数列的第一个，则需要用第一个模板（mid下取整），反之需要用第二个模板。

例题
数的范围给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。
对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。
如果数组中不存在该元素，则返回 -1。
输入格式第一行包含整数 n 和 q，表示数组长度和询问个数。
第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。
接下来 q 行，每行包含一个整数 k，表示一个询问元素。
输出格式共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。
如果数组中不存在该元素，则返回 -1。
数据范围1≤n≤1000001≤q≤100001≤k≤10000
输入样例：6 31 2 2 3 3 4345

输出样例：3 45 5-1 -1
实现代码#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;//数据量int n, m, x, num[N];//升序排序序列的长度，询问次数，询问的元素的值，存储序列的数组/// &lt;summary&gt;/// 基于循环的二分查找，用于查找这个区间的左边界。/// &lt;/summary&gt;/// &lt;param name=&quot;l&quot;&gt;要查找的序列的起始位置&lt;/param&gt;/// &lt;param name=&quot;r&quot;&gt;要查找的序列的结束位置（长度）&lt;/param&gt;/// &lt;param name=&quot;x&quot;&gt;要查找的值&lt;/param&gt;/// &lt;returns&gt;查找到的下标&lt;/returns&gt;int find1(int l, int r, int x)&#123;    while (l &lt; r)//只要左边界与右边界不相等，就证明这个范围内的数不止一个，可以继续循环    &#123;        int mid = l + r &gt;&gt; 1;//计算mid，下取整        if (num[mid] &gt;= x)//如果mid的值大于等于查找的值，就证明答案可能在左边界到mid的位置            r = mid;//缩小右边界，因为mid的位置可能是答案，所以r = mid        else//如果不满足条件，就证明答案在mid的右边，并且mid的位置不会是答案            l = mid + 1;//因此缩小左边界，到全部都是可能是答案的新的左边界    &#125;    if (num[l] == x)//循环完事，检查一下找到的数据是否满足要求        return l;//满足，就输出要求的下标    else        return -1;//不满足，证明没有找到，直接输出-1.&#125;/// &lt;summary&gt;/// 基于递归的二分查找，用于查找这个区间的左边界/// &lt;param name=&quot;l&quot;&gt;要查找的序列的起始位置&lt;/param&gt;/// &lt;param name=&quot;r&quot;&gt;要查找的序列的结束位置（长度）&lt;/param&gt;/// &lt;param name=&quot;x&quot;&gt;要查找的值&lt;/param&gt;/// &lt;returns&gt;查找到的下标&lt;/returns&gt;int find3(int l, int r, int x)&#123;    if (l == r)        if (num[l] == x)            return l;        else            return -1;    int mid = l + r &gt;&gt; 1;    if (num[mid] &gt;= x)        find3(l, mid, x);    else        find3(mid + 1, r, x);&#125;/// &lt;summary&gt;/// 基于循环的二分查找，用于查找这个区间的右边界。/// &lt;/summary&gt;/// &lt;param name=&quot;l&quot;&gt;要查找的序列的起始位置&lt;/param&gt;/// &lt;param name=&quot;r&quot;&gt;要查找的序列的结束位置（长度）&lt;/param&gt;/// &lt;param name=&quot;x&quot;&gt;要查找的值&lt;/param&gt;/// &lt;returns&gt;查找到的下标&lt;/returns&gt;int find2(int l, int r, int x)&#123;    while (l &lt; r)    &#123;        int mid = l + r + 1 &gt;&gt; 1;//查找右边界的时候需要上取整        if (num[mid] &lt;= x)//查找右边界，如果说答案大于等于mid的位置，就收缩左边界到mid            l = mid;        else            r = mid - 1;//否则就证明答案在小于mid的位置，收缩右边界    &#125;    if (num[l] == x)        return l;    else        return -1;&#125;/// &lt;summary&gt;/// 基于循环的循环查找，用于查找这个区间的右边界。/// &lt;/summary&gt;/// &lt;param name=&quot;l&quot;&gt;要查找的序列的起始位置&lt;/param&gt;/// &lt;param name=&quot;r&quot;&gt;要查找的序列的结束位置（长度）&lt;/param&gt;/// &lt;param name=&quot;x&quot;&gt;要查找的值&lt;/param&gt;/// &lt;returns&gt;查找到的下标&lt;/returns&gt;int find4(int l, int r, int x)&#123;    if (l == r)        if (num[l] == x)            return l;        else            return -1;    int mid = l + r + 1 &gt;&gt; 1;    if (num[mid] &lt;= x)        find4(mid, r, x);    else        find4(l, mid - 1, x);&#125;int main()&#123;    scanf_s(&quot;%d%d&quot;, &amp;n, &amp;m);//获取序列的长度和询问的次数    for (int i = 0; i &lt; n; i++)//读入序列    &#123;        scanf_s(&quot;%d&quot;, &amp;num[i]);    &#125;    while (m--)//开始询问    &#123;        scanf_s(&quot;%d&quot;, &amp;x);//读入询问的数值        cout &lt;&lt; find3(0, n - 1, x) &lt;&lt; &quot; &quot; &lt;&lt; find4(0, n - 1, x) &lt;&lt; endl;//调用函数运算并直接输出    &#125;    return 0;&#125;

浮点二分同上面的整数二分类似，而且更加简单，因为不用考虑边界问题。如下例题：利用二分的方法求出一个数的三次方根。
为什么可行：

首先一个数的三次方根是必然存在的
其次三次方是具有单调性的（偶数次方也可以二分，二分的左边界是0）


数的三次方根给定一个浮点数 n，求它的三次方根。
输入格式共一行，包含一个浮点数 n。
输出格式共一行，包含一个浮点数，表示问题的解。
注意，结果保留 6 位小数。
数据范围−10000 ≤ n ≤ 10000
输入样例：1000.00

输出样例：10.000000
#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;double n;/// &lt;summary&gt;/// 利用二分查找找出一个数的三次方根/// &lt;/summary&gt;/// &lt;param name=&quot;n&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;double binarySearch(double n)&#123;    double l = -10000, r = 10000;//设置左右边界    while (fabs(l - r) &gt;= 0.0000001)//算出的精度要比要求的精度多至少1位，因为存在四舍五入。    &#123;        double mid = (l + r) / 2;//获取mid的值        if (mid * mid * mid &gt;= n)//判断计算出来的值是大了还是小了            r = mid;//如果大了，就证明答案在mid左边，收缩右边界        else            l = mid;//否则就在mid的右边，收缩左边界    &#125;    //因为浮点数不是精确的数，不存在绝对边界，因此不需要边界判断    return l;//因为必然有解，所以可以直接返回&#125;int main()&#123;    scanf(&quot;%lf&quot;, &amp;n);//读入    printf(&quot;%.6lf&quot;, binarySearch(n));//计算并输出    return 0;&#125;

用二分法求算数根的好处：
精度可以做到非常高，而用pow()函数进行求解的话最高精度只能做到小数点后六位。
效率高，二分的时间复杂度是logn

高精度大整数：一个长度在10^6^的数；
普通数：数值小于10^9^的一个数；
大整数的实现（存储）：把大整数的每一位都存入到数组中，利用数组进行逐位存储 。
整个大整数的运算是一种模拟的体现，通过模拟我们手动运算的方法实现的。
两个大整数相加具体实现思想：
将两个大数均以倒序的形式存储到数组中，以便实现运算过程的进位问题。如一个数是“123456789“，则在存储的时候，下标为0的位置存储的是”9“，下标为1的位置存储的是”8“，下标为8的位置存储的是”1“
设一个临时遍历 t，并置初值为0，用于存储每一位相加后的值。
从下标0到数组长度-1开始，逐位读取并相加两个数组的当前位置（如果有）
将两个数相加完成后的值模除10（对10取余）后存入到答案数组，然后t除以10去掉已经存入答案的值后，剩余的值进入下轮循环继续参与运算

实现代码模板
//高精度加法 —— 模板题 AcWing 791. 高精度加法// C = A + B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; add(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;    vector&lt;int&gt;C;    int t = 0;    for (int i = 0; i &lt; A.size() || i &lt; B.size(); i++) &#123;        if (i &lt; A.size()) t += A[i];        if (i &lt; B.size()) t += B[i];        C.push_back(t % 10);        t = t / 10;    &#125;    if (t != 0 )        C.push_back(t);    return C;&#125;

使用stl库#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; add(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;//之所以用引用是因为引用传入的是一个地址，如果不加引用符号则需要把A、B全部复制一遍    vector&lt;int&gt;C;    int t = 0;//进位辅助的临时变量，只需要在开始置0即可    for (int i = 0; i &lt; A.size() || i &lt; B.size(); i++) &#123;        if (i &lt; A.size()) t += A[i];//要是没超过A的位置，或者说是当运行和到这一位的时候，A数组中仍然有值，就加上A[i]；        if (i &lt; B.size()) t += B[i];//同理        C.push_back(t % 10);//将临时变量模除10后存入答案数组，因为是10进制运算所以这个地方要模除10        t = t / 10;//将存入的值删除后，剩余的值继续参与下轮循环    &#125;    if (t != 0 )//要是t不空 证明还有进位没有存入到答案数组        C.push_back(t);    return C;&#125;int main() &#123;    string a, b;//利用string实现大数的一个读入    vector&lt;int&gt;A, B;//之所以用vector容器，是因为vector有一个size属性比较方便，且没有位数的限制    cin &gt;&gt; a &gt;&gt; b;//读入a,b    //逆序存入    for (int i = a.size() - 1; i &gt;= 0; i--)        A.push_back(a[i] - &#x27;0&#x27;);//逆序存入到vector数组    for (int i = b.size() - 1; i &gt;= 0; i--)        B.push_back(b[i] - &#x27;0&#x27;);//逆序存入到vector数组    auto C = add(A, B);//c++11的新东西，auto。    for (int i = C.size() - 1; i &gt;= 0; i--)//因为是倒序存入，因此在读出的时候也需要倒序        printf(&quot;%d&quot;, C[i]);    return 0;&#125;

使用普通的char数组完成#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 1e6 + 10;char A[N], B[N], C[N];char * add(char A[], char B[],int lenA,int lenB) &#123;      int k = 0;    int t = 0;//辅助的临时变量，只需要在开始置0即可    //const int lenA = sizeof(A) / sizeof(char);//存储A数组的长度，后面用的时候可以不用在计算了。因为不涉及到修改，就设置成const属性   // const int lenB = sizeof(B) / sizeof(char);//同理    for (int i = 0; i &lt; lenA || i &lt; lenB; i++) &#123;        if (i &lt; lenA) t = t + A[i];//要是没超过A的位置，或者说是当运行和到这一位的时候，A数组中仍然有值，就加上A[i]。、        if (i &lt; lenB) t = t + B[i];//同理        C[i] = t % 10;        k++;        t = t / 10;//将存入的值删除后，剩余的值继续参与下轮循环    &#125;    if (t != 0)//要是t不空 证明还有进位没有存入到答案数组        C[k++] = t;//因为最多就有1位的进位    return C;&#125;int main() &#123;    string a, b;//利用string实现大数的一个读入    cin &gt;&gt; a &gt;&gt; b;//读入a,b    int k = 0;//倒序存储时记录长度的辅助变量    //逆序存入    for (int i = a.size() - 1; i &gt;= 0; i--)        A[k++] = a[i] - &#x27;0&#x27;;//之间将字符转成值存入，后续就可以不用再转换了    k = 0;//辅助变量置0以便下次使用    for (int i = b.size() - 1; i &gt;= 0; i--)        B[k++] = b[i] - &#x27;0&#x27;;    add(A, B,a.size(),b.size());//c++11的新东西，auto。    bool flag = false;//一个标志位，用于去除先导的0    for (int i = sizeof(C) / sizeof(char) - 1; i &gt;= 0; i--)//因为是倒序存入，因此在读出的时候也需要倒序    &#123;        if (flag || C[i] != 0) &#123;            printf(&quot;%d&quot;, C[i]);            flag = true;        &#125;    &#125;    return 0;&#125;

两个大整数相减具体实现思想
同大整数加法类似，都是逆序输入两个数；不同之处在于进行减法运算的时候最好进行一下判断，可以避免很大的麻烦。因为题目已经声明两个数都是正整数，因此不需要判断是否存在负数的情况。如果需要的话在输入输出阶段判断一下即可。因为任意的两个数相减都可以转换成两个数 绝对值的相加或相减；
如果大数A 小于 大数B 的话，A - B 可以转换成 （A - B) * -1;
在减法函数中，需要一个辅助标志位 t ，表示上一位数在运算过程中是否发生进位的行为，并且临时存储当前位的运算结果
将t进行修正后存入答案数组。修正方法：若 t &gt;&#x3D; 0，则直接存入，否则将t + 10 存入答案（因为是十进制）
判断t是否小于0（上一步只是相加但并未改变t） ，如果是，将 t 置 1 表示发生了进位，否则置0。
循环4，5步直到算出答案。此时答案可能存在前导0，因此需要删除。此时存在一个例外的情况就是，如果答案只有1位，哪怕这位是0也不能删除。因此条件为：如果答案位数大于1，且答案的最高位为0，就可以删除最高位。
倒序输出答案。根据第2步的判断，要不要在输出前加一个负号。

实现代码使用stl库#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;//C = A - Bvector&lt;int&gt; sub(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;//之所以用引用是因为引用传入的是一个地址，如果不加引用符号则需要把A、B全部复制一遍    vector&lt;int&gt;C;    int t = 0;//减法运算过程的借位标识符。有借位值为1，否则为0.    for (int i = 0; i &lt; A.size(); i++)//在进入这个函数的时候已经确保了A一定是大于等于B的，因此长度上以A为准即可    &#123;        t = A[i] - t;//获取被减数。如果有借位先将借位偿还        if (i &lt; B.size())//判断一下B是否有这一位，只有存在这一位的情况才需减去            t = t - B[i];//算出 被减数 减去 减数 后的值        /*if(t &gt;= 0)//如果够减,直接将答案存入        &#123;            C.push_back(t);            t = 0;        &#125;        else        &#123;            C.push_back(t+10);            t = 1;        &#125;        */        //判断是否需要进位的语句也可以写成如下样式        C.push_back((t + 10) % 10);        if (t &lt; 0)            t = 1;        else            t = 0;    &#125;    //减法运算后的结果可能存在前导0的情况，需要去除前导0    while (C.size() &gt; 1 &amp;&amp; C.back() == 0)//如果答案只有一位，哪怕这位是0也需要保留。如果位数大于1位，并且最高位为0，则最高位需要弹出    &#123;        C.pop_back();    &#125;    return C;&#125;//比较两个大整数的大小 ， 是否存在 A &gt;= Bbool cmp(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;    if (A.size() != B.size())//如果位数不同，可以根据位数进行判断        return A.size() &gt; B.size();    else//如果位数相同，则从最高位依次与下一位相比较        for (int i = A.size() - 1; i &gt;= 0; i--)//因为是逆序存储，因此判断的时候也需要逆序判断            if (A[i] != B[i])                return A[i] &gt; B[i];    //如果全部判断完都没有判断出大小，则证明两个数相等。    return true;&#125;int main() &#123;    //注意：题目声明了a b 两个数均为正整数，不存在负数的情况。如果没有声明，则需要在读入后进行一次判断，判断两个数的首位是否存在负号。如果存在则需要加一个标记。    //任意两个数相减都可以转换为两个数的绝对值相加或相减，因此如果存在负数只需要在输入输出的时候特判一下即可    string a, b;//利用string实现大数的一个读入    vector&lt;int&gt;A, B;//之所以用vector容器，是因为vector有一个size属性比较方便，且没有位数的限制    cin &gt;&gt; a &gt;&gt; b;//读入a,b    //逆序存入    for (int i = a.size() - 1; i &gt;= 0; i--)        A.push_back(a[i] - &#x27;0&#x27;);//逆序存入到vector数组    for (int i = b.size() - 1; i &gt;= 0; i--)        B.push_back(b[i] - &#x27;0&#x27;);//逆序存入到vector数组    //因为题目中有“计算结果可能为负数”，即表示，A可能小于B,因此需要判断一下    //3 - 5 可以转换为 (5 - 3) * -1 。    if (cmp(A, B))    &#123;        auto C = sub(A, B);//c++11的新东西，auto。        for (int i = C.size() - 1; i &gt;= 0; i--)//因为是倒序存入，因此在读出的时候也需要倒序            printf(&quot;%d&quot;, C[i]);    &#125;    else    &#123;        auto C = sub(B, A);        printf(&quot;-&quot;);//如果A小于B，则证明结果是负数，需要提前打出负号，并将运算改为B-A        for (int i = C.size() - 1; i &gt;= 0; i--)//因为是倒序存入，因此在读出的时候也需要倒序            printf(&quot;%d&quot;, C[i]);    &#125;    return 0;&#125;

一个大整数与一个普通整数相乘具体实现思想同大整数相加的原理类似，但实现想法相比实际笔算有些许的不同。设大数A有5位，依次是A[0]，A[1]，...，A[4]；小整数为b，答案C[0] = A[0] x b，C[1] = A[1] x b；因为是十进制的相乘，每一位数最大值是9，因此需要一个进位辅助 t ，将每一位中大于9的部分进行暂存，并在下一位运算的过程中继续参与运算，直到t空为止。



首先逆序读入；
特判一下b是否等于0，如果等于0则直接结束运算并输出一个0；
大整数的每一位依次乘上小整数，并将结果存入辅助进位的变量t，将t模除10后写入对应的答案位；
t除以10去除写入答案的值，然后继续第3步直到大整数A的每一位都运算完成；
继续将t写入答案，然后除以10，直到t &#x3D; 0为止；
逆序输出答案；

实现代码模板vector&lt;int&gt; mul(vector&lt;int&gt; A, int b) &#123;    vector&lt;int&gt; C;    int t = 0;//存储进位的辅助变量    //如果大数A没有循环完，则每次都将大数A与小数b进行相乘    //当大数循环完，但t中还有数没有写到答案中，则依然继续循环，但不再进行大数与小数的相乘    //当大数循环完，t也被清空了，就结束循环    //根据之前的程序设计，是否在此处进行前导零的删除    for (int i = 0; i &lt; A.size() || t != 0; i++) &#123;        if(i &lt; A.size())            t += A[i] * b;        C.push_back(t % 10);        t /= 10;    &#125;    	//如果没有进行特判，则在退出之前需要删除多余的前导0.（当其中小数是0时就会出现多余的前导0）	  return C;&#125;

使用stl库#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt; A, int b) &#123;    vector&lt;int&gt; C;    int t = 0;//存储进位的辅助变量    for (int i = 0; i &lt; A.size(); i++) &#123;        t += A[i] * b;        C.push_back(t % 10);        t /= 10;    &#125;    while (t) &#123;//把剩余进位继续写入        C.push_back(t % 10);        t /= 10;    &#125;    //注意 可能存在前导0的情况，需要处理掉,或者检测到b = 0 的时候，直接输出一个0.    return C;&#125;int main() &#123;    string a;    int b;    cin &gt;&gt; a &gt;&gt; b;    //这里做了下特判，因为出现多余的0的情况只在b是0的时候，当我们检测到其中一个除数是0的时候，可以直接输出0。    if (b == 0) &#123;        printf(&quot;0&quot;);        return 0;    &#125;    vector&lt;int&gt;A;    for (int i = a.size() - 1; i &gt;= 0; i--) &#123;//逆序读入        A.push_back(a[i] - &#x27;0&#x27;);    &#125;    vector&lt;int&gt; C = mul(A, b);    for (int i = C.size() - 1; i &gt;= 0; i--)//再次逆序输出        printf(&quot;%d&quot;, C[i]);    return 0;&#125;

一个大整数与一个普通整数相除具体实现思想除法比较特殊，是从最高位开始算的， 整个过程模拟笔算，



把前一位的余数*10+这一位的余数，然后除以除数，把能除的部分写入到商（答案）中，
接着把上一步得到的数模除一下除数，留下本次的余数，并参与到下次的运算。
运算结束可以根据需求反转一下
去除前导0，结束运算

实现代码模板//大数A，小数b，余数rvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r) &#123;    vector&lt;int&gt; C;//商    r = 0;//余数 引用传回      for(int i = A.size()-1; i &gt;= 0; i--)&#123;        r = r * 10 + A[i];        C.push_back(r / b);        r %= b;    &#125;       reverse(C.begin(),C.end());      //去除前导0    while(C.size()&gt;1 &amp;&amp; C.back() == 0)        C.pop_back();      return C;&#125;

使用stl库#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;//大数A，小数b，余数rvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r) &#123;    vector&lt;int&gt; C;//商    r = 0;//余数 引用传回      /*    除法比较特殊，是从最高位开始算的    整个过程模拟笔算    把前一位的余数*10+这一位的余数，然后除以除数，把能除的部分写入到商（答案）中    然后把上一步得到的数模除一下除数，留下本次的余数，并参与到下次的运算。    */    for(int i = A.size()-1; i &gt;= 0; i--)&#123;        r = r * 10 + A[i];        C.push_back(r / b);        r %= b;    &#125;        //因为除法相比于其他的运算是反过来的，是从最高位开始运算的，这里需要反转一下    //否则就是输出的时候反过来输出。但这带来了一个新的问题：先导0很难去除    //所以还是反转一下比较好，这样好去除先导0，并且输出可以不用另外更改    reverse(C.begin(),C.end());//        //去除前导0    while(C.size()&gt;1 &amp;&amp; C.back() == 0)        C.pop_back();      return C;&#125;int main() &#123;    string a;    int b;    cin &gt;&gt; a &gt;&gt; b;    vector&lt;int&gt;A;    for (int i = a.size() - 1; i &gt;= 0; i--) &#123;//逆序读入        A.push_back(a[i] - &#x27;0&#x27;);    &#125;      int r;    vector&lt;int&gt; C = div(A, b, r);    for (int i = C.size() - 1; i &gt;= 0; i--)//再次逆序输出        printf(&quot;%d&quot;, C[i]);    cout &lt;&lt; endl &lt;&lt; r &lt;&lt;endl;    return 0;&#125;

前缀和与差分前缀和（一维）简介有一个长度为n的数组a，为：a[1]，a[2]，a[3]，…，a[n]；
对应的前缀和数组为：s[1]，s[2]，…，s[n]；s[ i ] &#x3D; a[ 1 ] + a[ 2 ] + … + a[ i ]
作用快速的求出数组中一段数的和。


使用前缀和进行计算可以将时间复杂度由原来的 O( n ) 降低到 O( 1 )；


计算方法前缀和预处理s[ i ] = s[ i - 1 ] + a[ i ];


使用前缀和a[ l ] ~ a[ r ]的和 = S[r] - S[ l - 1 ]


时间复杂度前缀和数组在预处理阶段是 O(n)，在使用的时候是 O(1)
注意事项
在使用前缀和的时候，一般使得数组下标从1起，空出开头的一个，方便计算。

模板S[i] = a[1] + a[2] + ... a[i]a[l] + ... + a[r] = S[r] - S[l - 1]

例题：795.前缀和
输入一个长度为 n 的整数序列。
接下来再输入 m 个询问，每个询问输入一对 l,r。
对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。
输入格式第一行包含两个整数 n 和 m。
第二行包含 n 个整数，表示整数数列。
接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。
输出格式共 m 行，每行输出一个询问的结果。
数据范围1 ≤ l ≤ r ≤ n1 ≤ n,m ≤ 100000−1000 ≤ 数列中元素的值 ≤ 1000
输入样例：5 32 1 3 6 41 21 32 4

输出样例：3610
#include &lt;iostream&gt;using namespace std;const int N = 1e6+10;int n,m,l,r;int nums[N],s[N];//输入的数组，对应的前缀和数组int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i ++ )&#123;        scanf(&quot;%d&quot;, &amp;nums[i]);        s[i] = s[i - 1] + nums[i];//输入的同时对前缀和进行一个初始化    &#125;    while(m--)&#123;        scanf(&quot;%d%d&quot;, &amp;l, &amp;r);        printf(&quot;%d\n&quot;,s[r] - s[l - 1]);//利用前缀和公式直接求出指定区间的和,区间和的计算      &#125;      return 0;&#125;

前缀和（二维）用于快速的求出一个子矩阵内的和。
原理和一维的前缀和相同，这里不再赘述。
前缀和矩阵的预处理公式s[ i, j ] = s[ i - 1, j ] + s[ i , j - 1 ] - s[ i - 1 , j - 1 ] + a[ i , j ]


区间和的计算s[x2,y2]  - s[x2,y1-1] - s[x1-1,y2-1 ] + s[x1-1,y1-1]



模板S[i, j] = 第i行j列格子左上部分所有元素的和以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]

例题：796. 子矩阵的和
输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。
对于每个询问输出子矩阵中所有数的和。
输入格式第一行包含三个整数 n，m，q。
接下来 n 行，每行包含 m 个整数，表示整数矩阵。
接下来 q 行，每行包含四个整数 x1,y1,x2,y2，表示一组询问。
输出格式共 qq 行，每行输出一个询问的结果。
数据范围1 ≤ n, m ≤ 10001 ≤ q ≤ 2000001 ≤ x1 ≤ x2 ≤n1 ≤ y1 ≤ y2 ≤m−1000 ≤ 矩阵内元素的值 ≤ 1000
输入样例：3 4 31 7 2 43 6 2 82 1 2 31 1 2 22 1 3 41 3 3 4

输出样例：172721
#include &lt;iostream&gt;using namespace std;const int N = 1010;int nums[N][N], s[N][N];int n, m, q;int main()&#123;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q);    for (int i = 1; i &lt;= n; i++) &#123;        for (int j = 1; j &lt;= m; j++) &#123;            scanf(&quot;%d&quot;, &amp;nums[i][j]);            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + nums[i][j];        &#125;    &#125;    while (q--) &#123;        int x1, y1, x2, y2;        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;        cout &lt;&lt; s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1] &lt;&lt; endl;    &#125;    return 0;&#125;

差分（前缀和的逆运算）差分就是给你一个前缀和数组，让你根据数组还原出原来的数组
对于一维数据来说，就是设给定一个前缀和数组s[n]，然后假想一个数组b，使得s数组是b数组的前缀和，此时，b就成为s的差分，s是b的前缀和；
对于二维数据，也是类似的，给定一个原数组a[i,j]，构造一个b矩阵b[i,j]，使得a数组是b数组的前缀和。
对于差分算法来说，都可以不用考虑构造的问题，假定初始数组都是0即可，对于原有的数据视为插入即可。
差分的作用对于一维数据来说，给定一个数组，要求在数组中指定的区域（l，r）中每个数都加上一个指定的数c。如果次数较多，可以使用 差分 算法实现。差分算法的实现要求是首先用O(n)的时间构造出一个辅助数组（不是必须的），之后的所有操作就可以在O(1)内完成，最后在用O(n)的时间算出全部。


一维差分思路
假定原数组a[n]全部是0，此时辅助的差分数组b内也全部都是0。
将输入的数据视为插入。就是说，可以看作进行了n次的插入操作。如a[1]是2的话，可以看作进行了如下的操作：原数组的[1,1] + a[1] ； 原数组的[n,n] + a[n]。此时，就规避了构造的问题。
此时，就可以总结出一个规律：想对一个区间全部加上一个数，就可以进行b[l] + c ; b[r + 1] - c;实现。
按照1到3的思路来说，原数组a[i]就没有存在的需要，只需要一个差分数组b[i]即可。输入原数组的时候，可以视为进行了插入操作，即b[i] +&#x3D; c , b[i + 1] -&#x3D; c;在全部输入完成后，只需要对着辅助数组求一遍前缀和即可还原为原数组的数据。如b[i] +&#x3D; b[i-1]；

模板给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c

例题 ：797. 差分
输入一个长度为 n 的整数序列。
接下来输入 m 个操作，每个操作包含三个整数 l,r,c 表示将序列中 [l,r] 之间的每个数加上 c。
请你输出进行完所有操作后的序列。
输入格式第一行包含两个整数 n 和 m。
第二行包含 n 个整数，表示整数序列。
接下来 m 行，每行包含三个整数 l，r，c 表示一个操作。
输出格式共一行，包含 n 个整数，表示最终序列。
数据范围1 ≤ n,m ≤ 1000001 ≤ l ≤ r ≤ n−1000 ≤ c≤1000−1000 ≤ 整数序列中元素的值 ≤ 1000
输入样例：6 31 2 2 1 2 11 3 13 5 11 6 1

输出样例：3 4 5 3 4 2
#include &lt;iostream&gt;using namespace std;const int N = 1e6+10;int b[N];//差分数组int n,m;void insert(int l,int r,int c)&#123;    b[l] += c;    b[r+1] -= c;&#125;int main()&#123;    int c;      scanf(&quot;%d%d&quot;, &amp;n, &amp;m);      for (int i = 1; i &lt;= n; i ++ )&#123;        scanf(&quot;%d&quot;, &amp;c);        insert(i,i,c);//把原数组视为逐个插入    &#125;      //多轮插入    while (m -- )&#123;        int l,r;        scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c);//读入每轮的范围及数值        insert(l,r,c);//插入    &#125;      //整合并输出    for (int i = 1; i &lt;= n; i ++ )    &#123;        b[i] += b[i-1];        printf(&quot;%d &quot;,b[i]);    &#125;      return 0;&#125;

二维差分对于一维差分来说，是给一段距离加上一个值；


而对于二维差分来说，是给一个子矩阵加上一个值；


操作的时间复杂度来说，由原先的整个子矩阵变成了四个点，由O(n) 下降到 O(1)


思路
不考虑构造，假定初始a[i,j]都是0，同样b[i,j]也就都为0了。对于a[i，j]中原有的数据，依次遍历插入即可；
对于插入方法来说，
一维插入方法是：b[l] +&#x3D; c; b[r+1] -&#x3D; c;
二维的插入方法是：（设要插入的子矩阵的左上角坐标为：x1,y1，右下角的坐标为：x2,y2）
b[x1 , y1] +&#x3D; c; &#x2F;&#x2F;先将从子矩阵左上角到整个大矩阵的右下角所有的值都加上c
b[x2 + 1 , y1] -&#x3D; c;  &#x2F;&#x2F;然后将子矩阵左下角到整个大矩阵右下角所有的值减去c
b[x1 , y2 + 1] -&#x3D; c;  &#x2F;&#x2F;接着将子矩阵右上角到整个大矩阵右下角所有的值减去c
b[x2+1 , y2+1] +&#x3D; c;  &#x2F;&#x2F;因为第2、3步的操作导致了子矩阵右下角到整个大矩阵右下角所有的值减去两遍c，因此需要补回一个。




最后输出的时候求一下b数组的前缀和就可以了。

模板给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c位运算 —— 模板题 AcWing 801. 二进制中1的个数求n的第k位数字: n &gt;&gt; k &amp; 1返回n的最后一位1：lowbit(n) = n &amp; -n

例题
输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c 其中 (x1,y1)和 (x2,y2)表示一个子矩阵的左上角坐标和右下角坐标。
每个操作都要将选中的子矩阵中的每个元素的值加上 c。
请你将进行完所有操作后的矩阵输出。
输入格式第一行包含整数 n,m,q。
接下来 n 行，每行包含 m 个整数，表示整数矩阵。
接下来 q 行，每行包含 5 个整数 x1,y1,x2,y2,c 表示一个操作。
输出格式共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。
数据范围1 ≤ n,m ≤ 10001 ≤ q ≤ 1000001 ≤ x1 ≤ x2 ≤ n1 ≤ y1 ≤ y2 ≤ m−1000 ≤ c ≤ 1000−1000 ≤ 矩阵内元素的值 ≤ 1000
输入样例：3 4 31 2 2 13 2 2 11 1 1 11 1 2 2 11 3 2 3 23 1 3 4 1

输出样例：2 3 4 14 3 4 12 2 2 2

#include &lt;iostream&gt;using namespace std;const int N = 1010;int b[N][N];int n,m,q;//二维差分的核心void insert(int x1,int y1,int x2,int y2,int c)&#123; b[x1][y1] += c; b[x1][y2+1] -= c; b[x2+1][y1] -= c; b[x2+1][y2+1] += c;&#125;int main()&#123; int c,x1,x2,y1,y2; scanf(&quot;%d%d%d&quot;,&amp;n ,&amp;m ,&amp;q); //将原数组的数据视为插入，依次进行读取处理 for(int i = 1; i &lt;= n; i++)&#123;     for(int j = 1; j &lt;= m; j++)&#123;         scanf(&quot;%d&quot;,&amp;c);         insert(i,j,i,j,c);     &#125; &#125; //开始多轮修改 while(q--)&#123;     scanf(&quot;%d%d%d%d%d&quot;,&amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;c);     insert(x1,y1,x2,y2,c); &#125; //修改完成后，根据差分数组b进行一次前缀和的运算，并且输出出来 for(int i = 1; i &lt;= n; i++)&#123;     for(int j = 1; j&lt;= m; j++)&#123;         b[i][j] = b[i][j] + b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];         printf(&quot;%d &quot;, b[i][j]);//直接输出     &#125;     printf(&quot;\n&quot;); &#125; return 0;&#125;
双指针算法介绍简单的说双指针算法就是有两个指针来进行操作的算法。
两个指针可以指向不同的序列，可以指向相同序列中不同的位置 。
双指针算法的应用范围非常广，有时甚至都意识不到。比如常见的快排、归并排序都应用到了双指针的思想。
模板一般的写法就一种情况：
for(int i = 0, j = 0; i &lt; n; i++)&#123;  	while(j &lt; i &amp;&amp; check(i,j))    &#123;      	j++;    &#125;    	//每个题目的具体逻辑&#125;

简单的说 双指针算法的核心思想就是，将原始的双重循环O( n ^ n  )的算法，通过某种性质优化到一重循环O(n)
样例1：给定一个字符串 将其转换成一个个单词输出
给定一个字符串 将其转换成一个个单词输出。保证字符串首字符不是空格，且单词之间的分隔符是空格
如：abc def ghi
输出：
abc	def	ghi


#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; char str[1000]; gets(str); int n = strlen(str); //利用双指针算法算出当前单词的结束位置 for(int i = 0; str[i]; i++)&#123;     int j = i;     while(j &lt; n &amp;&amp; str[j] != &#x27; &#x27;)//只要j没到终点，且当前j是非空格（分界符）         j++;//直到j指向分界符     //往下就是这道题的具体逻辑     for(; i &lt; j; i++)&#123;         cout &lt;&lt; str[i];     &#125;     cout &lt;&lt; endl ; &#125; return 0; &#125;
样例2：799. 最长连续不重复子序列实现思路
有两个指针i，j，j 在前 i 在后。i每次后移增加新的数据
每次增加完，检查 j 到 i 之间有没有重复数据，如果有，则 j 指针后移（j指针只能后移，因为序列是有序的，不可能存在前一个区间内有重复数字，新加入一个数后区间内重复数字消失了，只有一种情况就是新增加的数导致了区间内有重复的数据），直到整个区间内没有重复数字位置。（具体操作见后面）
计算已有的记录和当前区间的长度，如果当前的更长就更新记录
检查方法：类似于哈希，哈希公式就是数值本身。即f( x ) &#x3D; x ;

具体题目及代码
给定一个长度为 nn 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。
输入格式第一行包含整数 n。
第二行包含 n 个整数（均在 0∼105 范围内），表示整数序列。
输出格式共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。
数据范围1 ≤ n ≤ 105
输入样例：51 2 2 3 5

输出样例：3

#include &lt;iostream&gt;using namespace std;const int N = 1e6+10;int a[N];//读入的数据int s[N];//当前i到j之间，每一个数出现的次数int n;int main()&#123; cin&gt;&gt;n; for (int i = 0; i &lt; n; i ++ )     scanf(&quot;%d&quot;, &amp;a[i]); int res;//答案，或者说是最长的记录 for(int i = 0, j = 0; i &lt; n; i++)&#123;     s[a[i]]++;//i指针后移后，将新的数对应的地方++，表示多了这一个数     //条件1：j&lt;=i可以不用写，因为当j &gt; i的时候，区间里就没有数了，此时一定满足没有重复数的要求。     //条件2：新加入的数是a[i]，因此判断当前是否有不止一个的数。     //如果i指针当前指向的数不止一个，即表明j到i之间的数存在重复，且重复的位置是新入的i指针指向的位置。（因为在上一次循环已经排除了重复，最坏的可能就是上一轮中 i 和 j 都指向他自己     //假定重复的值是j指向的位置，只需要将s中j指向的个数--，然后j指针后移，直到j到i的区间内不存在重复即可     while(j &lt;= i &amp;&amp; s[a[i]]&gt;1)     &#123;         s[a[j]] -- ;//         j ++ ;     &#125;     res = max(res,i - j + 1);//此时计算一下j到i之间有多少个数，并将这个数与已有的记录进行比较，如果大于就更新一下。 &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;
他人题解
AcWing 799. 最长连续不重复子序列-从暴力到双指针的详细过程    原题链接    简单作者：    bbk ,  2020-10-27 20:55:03 ,  所有人可见 ,  阅读 1836
给定一个长度为n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。输入格式:第一行包含整数n。第二行包含n个整数（均在0~100000范围内），表示整数序列。输出格式:共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。数据范围:1≤n≤1000001≤n≤100000输入样例:：
51 2 2 3 5
输出样例：
3
思路：暴力法：当然可以用暴力法：对每个 i 和 j 都遍历一遍，对每个 i 和 j 都check一下中间的数据是否满足给定的条件。这样的时间复杂度是O(n^2)；数据稍微大点就会超时。代码如下：
for (int i = 0; i &lt; n; i++)for (int j = 0; j &lt;= i; j++)  if (check(v1,j, i) == 0)//检查 i 和 j 之间是否有重复的数字      res = max(res, i - j + 1);//check函数int check(vector&lt;int&gt;&amp; v1, int l, int r)&#123;for (int i = l+1; i &lt;=r ; i++)  for (int j = l; j &lt; i; j++)      if (v1[i] == v1[j])          return 1;return 0;&#125;

双指针法一：仔细考虑暴力法就会发现，暴力法在解题时有很多地方是重复计算了 ( i 指针在 j 指针的后面，i是遍历的整个数组的，j 是遍历 0 到 i 的)：
比如 j &#x3D; 0，i &#x3D; 5，此时发现 i，j 是满足题解条件的；那么后面的 j &#x3D; 1到5，i &#x3D; 5 就不用计算了，肯定是满足条件的。
所以引出了双指针法：还是上面的例子，双指针法就是说，既然发现 j &#x3D; 0，i &#x3D; 5满足题解条件，那就不用计算 j &#x3D; 1到5，i &#x3D; 5了，直接计算 j &#x3D; 1，i &#x3D; 6，如果不满足条件，那就计算 j &#x3D; 2，i &#x3D; 6，然后接着计算。
这样就是 i 和 j 指针都是从前移到后，也就是计算2n次。时间复杂度是O(2n)。
核心代码如下：（但是还会超时）。
for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i++){while (j &lt;&#x3D; i){if (check(v1, j, i) &#x3D;&#x3D; 0){res &#x3D; max(res, i - j + 1);break;}elsej++;}}
&#x2F;&#x2F;找得到重复的数返回1int check(vector&amp; v1, int l, int r){for (int i &#x3D; l + 1; i &lt;&#x3D; r; i++)for (int j &#x3D; l; j &lt; i; j++){if (v1[i] &#x3D;&#x3D; v1[j])return 1;}return 0;}
双指针法二（最终版）：但是上面代码还是超时，为什么呢？因为check函数写的不好，循环太多，直接是暴力计算找重复数字的，显然不好。
所以引出一个新的check方法：对于寻找是否有重复数字，一般用hash，没人用暴力。所以用hash就可以计算。
但是这道题还有一种计算方法：
用一个辅助数组S保存原数组V1每个元素存在的次数，和hash类似。比如说 V1 &#x3D; {1,2, 2, 3, 5 }。那 S就是 {0,1,2,1,0,1 }。S[V1[i]]表示的是V1[i]的个数。此处我们用S数组只保存 j 和 i 指针之间的数的个数。
算法思路： 如果j &#x3D; 0，i &#x3D; 5，此时检查S数组元素都是 &lt;&#x3D;1的。那下一步的情况就是 i 。i之后将S数组更新，只需要检查S[v1[i]]元素是不是比1大即可，因为随着 i 的递增，S数组中变化的只有S[v1[i]]元素。如果检查S[v1[i]]元素发现该元素比 1 大。那说明 j 指针和 i 指针之间有某个元素出现了两次。所以 i 指针保持不动， j 指针往后移动( j 指针不可能往前移动的，上次j指针往后移动就是因为 j 和 i之间有重复元素，这一往前移动肯定有重复元素)。j 指针往后移动之前需要先更新S数组，即进行 S[v1[j]]– 操作。然后 j 指针再往后移动。移动之后只需要检查 i 指针对应的S[v1[i]]元素是否大于1即可。（因为 j 指针移动之后只有两种情况，1.重复元素刚好没了，则S[v1[i]]肯定&#x3D;&#x3D;1；2.重复元素还在，那S[v1[i]]&#x3D;&#x3D;2，需要 j 继续往后移动 )。等S[v1[i]]&#x3D;&#x3D;1 时，说明 j 和 i 之间已经没有重复元素了，可以更新res值，然后 i++。
核心代码：
for (int i = 0,j = 0; i &lt; n; i++)&#123;S[v1[i]]++;while ( S[v1[i]] &gt; 1) --S[v1[j++]];res = max(res, i - j + 1);&#125;

代码实现：
#include&lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define N  100010using namespace std;int main()&#123;int n;cin &gt;&gt; n;vector&lt;int&gt; v1(n,0);for (int i = 0; i &lt; n; i++)  cin &gt;&gt; v1[i];vector&lt;int&gt; S(N,0);int res = 0;for (int i = 0,j = 0; i &lt; n; i++)&#123;  S[v1[i]]++;  while ( S[v1[i]] &gt; 1) --S[v1[j++]];  res = max(res, i - j + 1);&#125;cout &lt;&lt; res;return 0;&#125;

作者：bbk链接：https://www.acwing.com/solution/content/23474/来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

样例3：800. 数组元素的目标和
给定两个升序排序的有序数组 AA 和 BB，以及一个目标值 xx。
数组下标从 00 开始。
请你求出满足 A[i]+B[j]&#x3D;xA[i]+B[j]&#x3D;x 的数对 (i,j)(i,j)。
数据保证有唯一解。
输入格式第一行包含三个整数 n,m,xn,m,x，分别表示 AA 的长度，BB 的长度以及目标值 xx。
第二行包含 nn 个整数，表示数组 AA。
第三行包含 mm 个整数，表示数组 BB。
输出格式共一行，包含两个整数 ii 和 jj。
数据范围数组长度不超过 105105。同一数组内元素各不相同。1≤数组元素≤1091≤数组元素≤109
输入样例：4 5 61 2 4 73 4 6 8 9

输出样例：1 1
实现思路首先，因为两个数组的解是唯一的，不存在多种配对的问题。

首先让i指针指向a数组开头（即a数组中最小的数）
然后让j指针指向b数组的结尾（即b数组中最大的数）
此时可以发现，i不动，j前移；i与j指针指向的数相加的结果必然是从大到小的。
因此，利用这个性质，使得j不停的前移，直到两个指针指向的数的和小于等于要求的值
此时，j停止移动，判断i与j指向的数是否相等，相等就输出，不等就进入下轮循环，i指针后移，j指针不动，直到匹配为止

代码#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, m, x;int a[N], b[N];int main()&#123;    //读入数据    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;x);    for (int i = 0; i &lt; n; i++)        scanf(&quot;%d&quot;, &amp;a[i]);    for (int i = 0; i &lt; m; i++)        scanf(&quot;%d&quot;, &amp;b[i]);    /*    *利用双指针开始配对    * 首先让i指针指向a数组开头（即a数组中最小的数）    * 然后让j指针指向b数组的结尾（即b数组中最大的数）    * 此时可以发现，i不动，j前移；i与j指针指向的数相加的结果必然是从大到小的。    * 因此，利用这个性质，使得j不停的前移，直到两个指针指向的数的和小于等于要求的值    * 此时，j停止移动，判断i与j指向的数是否相等，相等就输出，不等就进入下轮循环，i指针后移，j指针不动，直到匹配为止    */    for (int i = 0, j = m - 1; i &lt; n; i++) &#123;        while (j &gt;= 0 &amp;&amp; b[j] + a[i] &gt; x)            j--;        if (a[i] + sb[j] == x) &#123;            printf(&quot;%d %d\n&quot;, i, j);            break;        &#125;    &#125;    return 0;&#125;

样例4：2816. 判断子序列
给定一个长度为 n 的整数序列 a1,a2,…,an 以及一个长度为 m 的整数序列 b1,b2,…,bm。
请你判断 a 序列是否为 b 序列的子序列。
子序列指序列的一部分项按原有次序排列而得的序列，例如序列 {a1,a3,a5} 是序列 {a1,a2,a3,a4,a5} 的一个子序列。
输入格式第一行包含两个整数 n,m。
第二行包含 n 个整数，表示 a1,a2,…,an。
第三行包含 m 个整数，表示 b1,b2,…,bm。
输出格式如果 a 序列是 b 序列的子序列，输出一行 Yes。
否则，输出 No。
数据范围1≤n≤m≤10^5^−10^9^ ≤ ai , bi ≤ 10^9^
输入样例：3 51 3 51 2 3 4 5

输出样例：Yes
实现思路读入序列后，设两个指针分别指向两个序列的起始位置，若两指针指向的值相等，则两个序列的指针都后移一个；若不等，则子序列的不移动，长序列的继续后移，进行判断，直到两个序列中任意一个到达终点为止。此时判断子序列有没有走完，如果走完了说明就是子序列，否则就不是子序列。


实现代码#include &lt;iostream&gt;using namespace std;const int N = 1e5+10;int a[N],b[N];int n,m;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 0; i &lt; n; i ++ )        scanf(&quot;%d&quot;, &amp;a[i]);    for (int i = 0; i &lt; m; i ++ )        scanf(&quot;%d&quot;, &amp;b[i]);          int i = 0, j = 0;      while(i &lt; n  &amp;&amp; j &lt; m)&#123;//指针不能到头        if(a[i] == b[j])//如果匹配的话子序列的指针后移            i++;        j++;//不管是否匹配长序列都回后移，    &#125;//直到子序列到头达成匹配或者长序列到头匹配失败退出      if(i == n)//此时判断子序列的指针有没有到头，以判断是否是子序列        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;    else        cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;    return 0;&#125;

位运算lowbit( x )：返回x的最后一位1eg:
x = 1010B		lowbit( x ) = 10B;


x = 101000B	lowbit( x ) = 1000B;


实现方法x &amp; -x


int lowbit(int x)&#123;   return x &amp; -x; &#125;

实现原理数在c中是以补码的形式存在的，而负数的补码是正数取反+1。


设x的二进制数是：			1010 . . . 100 . . . 0
则x取反后的二进制是：	0101 . . . 011 . . . 1
取反后+1的结果等于：	  0101 . . . 100 . . . 0
因此，在c中将一个数取反+1后再和这个数相与的结果就是，0101 . . . 100 . . . 0 ，前面因为取反和原数不一样，因此在与的过程中全部变0，后面因为一样就全部保留了。
常用地方求一个数的二进制中1的个数(奇偶校验？)


例题：801. 二进制中1的个数
给定一个长度为 n 的数列，请你求出数列中每个数的二进制表示中 1 的个数。
输入格式第一行包含整数 n。
第二行包含 n 个整数，表示整个数列。
输出格式共一行，包含 n 个整数，其中的第 ii 个数表示数列中的第 i 个数的二进制表示中 1 的个数。
数据范围1 ≤ n ≤ 100000,0 ≤ 数列中元素的值 ≤ 10^9^
输入样例：51 2 3 4 5

输出样例：1 1 2 1 2

代码#include &lt;iostream&gt;using namespace std;int lowbit(int x)&#123;return x &amp; -x; &#125;int main()&#123; int n, x, res = 0; scanf(&quot;%d&quot;, &amp;n); while (n -- )&#123;     scanf(&quot;%d&quot;, &amp;x);     while(x)&#123;         x -= lowbit(x);//每次减去最后一个1         res++;//减一个计数器+1     &#125;     printf(&quot;%d &quot;,res);     res = 0; &#125; return 0;&#125;
离散化（特指整数的有序的离散化）暂时回避
区间合并
给定 n 个区间 [li,ri][li,ri]，要求合并所有有交集的区间。
注意如果在端点处相交，也算有交集。
输出合并完成后的区间个数。
例如：[1,3][1,3] 和 [2,6][2,6] 可以合并为一个区间 [1,6][1,6]。
输入格式第一行包含整数 n。
接下来 n 行，每行包含两个整数 l 和 r。
输出格式共一行，包含一个整数，表示合并区间完成后的区间个数。
数据范围1 ≤ n ≤ 100000−10^9^ ≤ li ≤ ri ≤ 10^9^
输入样例：51 22 45 67 87 9

输出样例：3
解题思路
我们知道区间的开头和结尾，可以开一个数组存下来
将所有区间进行排序，排序规则为左端点降序
依次检查每个区间的右端点，如果左端点超过已有记录，就证明是一个新的区间，res++;
如果右区间超过但左区间小于等于记录，就证明区间是连续的，刷新一下右端点即可
输出res

代码#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 100010;typedef pair&lt;int, int&gt; PII;int n, l, r;vector&lt;PII&gt; nums;//利用vector数组进行存储所有区间的左右端点，方便后续的排序//sort的仿函数可写可不写，因为默认就是根据pair的键值（第一个值，左端点）进行升序排序的bool MyCom(PII x, PII y) &#123;    if (x.first &lt; y.first)        return true;    else        return false;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 0; i &lt; n; i++) &#123;        scanf(&quot;%d%d&quot;, &amp;l, &amp;r);        nums.push_back(&#123; l,r &#125;);//依次读入区间    &#125;    //进行排序，要求左端点升序排序    //sort(nums.begin(),nums.end(),MyCom);    sort(nums.begin(), nums.end());    //给记录设置一个区间，要求这个区间比题目要求的所有的区间都要小    l = r = -1e9 - 10;    int res = 0;//区间个数，初始化成0    for (int i = 0; i &lt; n; i++) &#123;        //如果区间左端点大于已有区间的右端点，证明两个区间不连续，区间数++，刷新区间        if (r &lt; nums[i].first) &#123;            l = nums[i].first;            r = nums[i].second;            res++;        &#125;        //能到这里就证明，当前区间的左端点一定是小于等于记录的右端点，证明是连续的，只需要更新右端点即可        else if (r &lt; nums[i].second)        &#123;            r = nums[i].second;        &#125;    &#125;    cout &lt;&lt; res &lt;&lt; endl;//输出答案    return 0;&#125;

数据结构链表与邻接表：树与图的存储使用数组来模拟链表的存在，虽然会造成内存泄漏，但可以大幅提高速度。
因为c++中的new是非常耗时间的，因此在竞赛或者笔试的时候，不要使用传统的结构体链表。(一般的数据范围都在10^5以上，如果new的话必定会超时)
单链表例题
实现一个单链表，链表初始为空，支持三种操作：

向链表头插入一个数；
删除第 k 个插入的数后面的数；
在第 k 个插入的数后插入一个数。

现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。
注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。
输入格式第一行包含整数 M，表示操作次数。
接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：

H x，表示向链表头插入一个数 x。
D k，表示删除第 kk 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。
I k x，表示在第 kk 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。

输出格式共一行，将整个链表从头到尾输出。
数据范围1≤M≤100000所有操作保证合法。
输入样例：10H 9I 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6

输出样例：6 4 6 5
思路类似于传统的结构体链表，不过改成用数组来模拟（变成静态链表）
分别开辟一个数组e，存储每个节点的数据；ne，存储每个节点的加一个节点的地址。e与ne数组的联系在于下标，换句话说就是，e[i] 与 ne[i] 是一组的。以及变量head，存储头节点的位置；idx，存储使用了多少个节点（idx始终指向第一个未被使用的节点）
当程序运行的时候需要进行初始化，将head置为-1，idx置为0。
对于头节点的插入操作，只需要简单的：
void insert_head(int x)&#123;  	e[idx] = x;//将数据读入到节点		ne[idx] = head;//将下一个节点的指针置为头指针指向的位置		head = idx ++;//将头指针指向新插入的节点，并且数量++&#125;

对于指定位置的插入，也很简单，可以在O(1)的时间内完成
void insert(int k,int x)&#123;		e[idx] = x;//同样读入到节点		ne[idx] = ne[k];//将新节点的next指针指向第k个位置原本指向的位置		ne[k] = idx ++;//将第k个位置的指针指向新加入的节点，同时idx++便于下一步操作&#125;

对于删除来说，就不需要再考虑空间的事了，可以直接的进行p-&gt;next &#x3D; p-&gt;next-&gt;next的操作
void del(int k)&#123;		ne[k] = ne[ne[k]];&#125;

但需要注意的是，如果要删除的节点是头节点，则需要这么做
void del_head()&#123;		head = ne[head];&#125;

对于模拟链表的遍历，和传统链表也很相似：
void display()&#123;  	//i从头节点开始，直到遇到-1（head的初始化值）为止，i的下一位是ne[i]		for(int i = head; i != -1 ; i = ne[i])        printf(&quot;%d &quot;,e[i]);&#125;

实现代码需要注意的是，k需要-1.因为题是从1起，而数组是从0起
#include &lt;iostream&gt;using namespace std;const int N = 100010;//head 头节点的下标//e[i] 节点i的值//ne[i] 节点i的next指针是多少//idx  存储当前已经用了多少int head, e[N], ne[N], idx;//初始化void init()&#123;    head = -1;//-1表示空    idx = 0;&#125;//将x插入到头节点void add_to_head(int x)&#123;    //idx存储了最新的节点可用的下标是什么    e[idx] = x;//将x输入到e中新的节点    ne[idx] = head;//将新的节点的指针指向head；    head = idx;//将head的指针指向到新插入的头节点的位置    idx++;//将idx的值++，方便下次使用&#125;//将x插入到下标为k的节点的后面void add(int k,int x)&#123;    e[idx] = x;    ne[idx] = ne[k];    ne[k] = idx;    idx++;&#125;//将下标是k的点的后一个点删掉void remove(int k)&#123;    ne[k] = ne[ne[k]];&#125;int main()&#123;    int m;    scanf(&quot;%d&quot;, &amp;m);    init();    while(m--)&#123;        char op;        int k,x;        //scanf(&quot;%c&quot;,&amp;op);        cin&gt;&gt;op;        if(op == &#x27;H&#x27;)        &#123;            //scanf(&quot;%d&quot;,&amp;x);            cin&gt;&gt;x;            add_to_head(x);        &#125;        else if(op == &#x27;D&#x27;)        &#123;            //scanf(&quot;%d&quot;, &amp;k);            cin&gt;&gt;k;            if(k == 0)//特判一下删除头节点的情况                head = ne[head];            else                remove(k - 1);        &#125;        else        &#123;            //scanf(&quot;%d%d&quot;, &amp;k, &amp;x);            cin&gt;&gt;k&gt;&gt;x;            add(k - 1,x);        &#125;          &#125;    for(int i = head; i != -1 ; i = ne[i])        printf(&quot;%d &quot;,e[i]);      return 0;&#125;

双链表与单链表类似，只不过多了一个指针
例题
实现一个双链表，双链表初始为空，支持 55 种操作：

在最左侧插入一个数；
在最右侧插入一个数；
将第 k 个插入的数删除；
在第 k 个插入的数左侧插入一个数；
在第 k 个插入的数右侧插入一个数

现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。
注意:题目中第 k 个插入的数并不是指当前链表的第 kk 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。
输入格式第一行包含整数 M，表示操作次数。
接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：

L x，表示在链表的最左端插入数 x。
R x，表示在链表的最右端插入数 x。
D k，表示将第 k 个插入的数删除。
IL k x，表示在第 k 个插入的数左侧插入一个数。
IR k x，表示在第 k 个插入的数右侧插入一个数。

输出格式共一行，将整个链表从左到右输出。
数据范围1≤M≤100000所有操作保证合法。
输入样例：10R 7D 1L 3IL 2 10D 3IL 2 7L 8R 9IL 4 7IR 2 2

输出样例：8 7 7 3 2 9
思路和单链表类似，一个存储数据的数组e[N]，一个存储当前节点的左侧的数组l[N]，当前节点的右侧的数组r[N]，和下一个节点的地址idx。
首先对数组进行初始化：一共有两个节点，下标分别是0和1，链表的最右边节点的下标是1，即 r[0] = 1；然后将最左边的节点设为0，即l[1] = 0
对于插入到节点右侧的数据，可以进行如下操作：

将数据写入到新的节点


e[idx] &#x3D; x;


将新创建的节点入队
l[idx] &#x3D; k , r[idx] &#x3D; r[k];


然后使得前后节点接受新插入的节点
l[r[k]] &#x3D; idx  , r[k] &#x3D; idx;


最后，idx++，为下次插入做准备

对于插入到节点左侧的数据，可以视为对指定节点的前一个节点进行尾插操作，可以对上方教程进行复用

insert(l[k],x);

对于删除指定节点，可以直接修改前后指针即可。

&#x2F;&#x2F;第k个节点右边的左侧不再是k，而是k之前的节点
l[r[k]] = l[k];
- ```  //同理，第k个节点左边的右侧不再是k，而是k右边的节点。


r[l[k]] = r[k];
#### 实现代码```c/*注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。*/#include &lt;iostream&gt;using namespace std;const int N = 1e5+10;int e[N],l[N],r[N],idx;//初始化void init()&#123;    r[0] = 1;//链表的最右边是1    l[1] = 0;//最左边是0    idx = 2;//起始节点&#125;//在第k个节点的右边插入一个元素void insert(int k,int x)&#123;    //将数据写入新的节点    e[idx] = x;    //将新的节点连入链接    l[idx] = k;//新节点的左边是指定的位置    r[idx] = r[k];//新节点的右边是指定位置的右边    //将原链接指向新的节点    l[r[k]] = idx;//第k个节点后一个节点的左边变成新插入的节点    r[k] = idx;//第k个节点的右边变成新插入的节点    idx ++;&#125;//在第k个节点的左边插入一个节点void insert_front(int k,int x)&#123;    //第k个节点的左边，可以视作 l[k] ，因此可以写作：    insert(l[k],x);&#125;//删除第k个节点void remove(int k)&#123;    //第k个节点右边的左侧不再是k，而是k之前的节点    l[r[k]] = l[k];    //同理，第k个节点左边的右侧不再是k，而是k右边的节点。    r[l[k]] = r[k];&#125;int main()&#123;    init();      int m;    cin&gt;&gt;m;    string op;    int k,x;    while(m--)    &#123;        cin &gt;&gt; op;//读入每行的开头        //一次根据开头判断要干的事        if(op == &quot;L&quot;)//最左端插入，相当于在头节点的右侧插入        &#123;            cin &gt;&gt; x;            insert(0, x);        &#125;        else if(op == &quot;R&quot;)//最右端插入，相当于在尾节点的左侧插入        &#123;            cin &gt;&gt; x;            insert_front(1, x );        &#125;        else if(op == &quot;D&quot;)        &#123;            cin &gt;&gt; k;            remove(k + 1);        &#125;        else if(op == &quot;IL&quot;)        &#123;            cin &gt;&gt; k &gt;&gt; x;            insert_f(k + 1, x);        &#125;        else if(op == &quot;IR&quot;)        &#123;            cin &gt;&gt; k &gt;&gt; x;            insert(k + 1,x);        &#125;              &#125;    for(int i = r[0]; i != 1; i = r[i])        printf(&quot;%d &quot;,e[i]);      return 0;&#125;





栈与队列：单调队列、单调栈模拟栈例题
实现一个栈，栈初始为空，支持四种操作：

push x – 向栈顶插入一个数 x；
pop – 从栈顶弹出一个数；
empty – 判断栈是否为空；
query – 查询栈顶元素。

现在要对栈进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。
输入格式第一行包含整数 M，表示操作次数。
接下来 M 行，每行包含一个操作命令，操作命令为 push x，pop，empty，query 中的一种。
输出格式对于每个 empty 和 query 操作都要输出一个查询结果，每个结果占一行。
其中，empty 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示栈顶元素的值。
数据范围1≤M≤1000001≤x≤10^9^所有操作保证合法。
输入样例：10push 5querypush 6popquerypopemptypush 4queryempty

输出样例：55YES4NO
思路首先用数组模拟一个栈，对栈的所有操作都可以转换成如下的操作：

入栈：stk[++ tt] &#x3D; x;
出栈：tt –;
判断是否为空：if(tt &gt; 0) 不空 else 空
栈顶元素stk[tt]

其中：stk数组就是模拟栈的数组，tt为栈顶元素的指针
实现代码#include &lt;iostream&gt;using namespace std;const int N = 1e5+10;//模拟栈的数组，栈顶指针（栈顶下标）int stk[N], tt = 0;//入栈void push(int x)&#123;    stk[++ tt] = x;&#125;//出栈（弹出）int pop()&#123;    tt --;    return stk[tt];&#125;//判断栈是否为空，空为真bool empty()&#123;    if(tt &gt; 0)        return false;    else         return true;&#125;//查看栈顶元素int query()&#123;    return stk[tt];&#125;int main()&#123;    int m, x;    string op;    cin &gt;&gt; m;    while(m--)    &#123;        cin &gt;&gt; op;        if(op == &quot;push&quot;)        &#123;            cin &gt;&gt; x;            push(x);        &#125;        else if(op == &quot;pop&quot;)        &#123;            pop();        &#125;        else if(op == &quot;empty&quot;)        &#123;            if(empty())                cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;            else                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;        &#125;        else if(op == &quot;query&quot;)        &#123;            cout &lt;&lt; query() &lt;&lt;endl;        &#125;          &#125;      return 0;&#125;

模拟队列例题
实现一个队列，队列初始为空，支持四种操作：

push x – 向队尾插入一个数 x；
pop – 从队头弹出一个数；
empty – 判断队列是否为空；
query – 查询队头元素。

现在要对队列进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。
输入格式第一行包含整数 M，表示操作次数。
接下来 M 行，每行包含一个操作命令，操作命令为 push x，pop，empty，query 中的一种。
输出格式对于每个 empty 和 query 操作都要输出一个查询结果，每个结果占一行。
其中，empty 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示队头元素的值。
数据范围1≤M≤1000001≤x≤10^9^所有操作保证合法。
输入样例：10push 6emptyquerypopemptypush 3push 4popquerypush 6

输出样例：NO6YES4
思路和模拟栈类似，相比模拟栈多了一个队头指针，出队的时候用队头指针的后移实现；判断队空是由队头指针是否大于队尾指针实现。
实现代码#include &lt;iostream&gt;using namespace std;const int N = 1e5+10;//模拟队列的数组，队头，队尾int q[N], hh = 1, tt = 0;//需要注意的是，下标为0的地方是闲置不用的，模拟栈不需要考虑这点，但队列需要。//因此，队列在空的情况下队头指针是大于队尾指针的（）//入队void push(int x)&#123;    q[++ tt] = x;//先后移队尾指针，然后再将数据写入到队尾指针指向的位置&#125;//出队void pop()&#123;    hh ++;//队头指针后移&#125;//判断队列是否为空bool empty()&#123;    if(hh &gt; tt)//只要出现队头大于队尾的情况，就是空的。队头等于队尾的时候表示还有一个元素        return true;    else        return false;&#125;//查看队头元素int query()&#123;    return q[hh];&#125;int main()&#123;    int m, x;    string op;    cin &gt;&gt; m;    while(m --)    &#123;        cin &gt;&gt; op;        if(op == &quot;push&quot;)        &#123;            cin &gt;&gt; x;            push(x);        &#125;        else if(op == &quot;pop&quot;)        &#123;            pop();        &#125;        else if(op == &quot;empty&quot;)        &#123;            if(empty())                cout &lt;&lt; &quot;YES&quot; &lt;&lt;endl;            else                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;        &#125;        else if(op == &quot;query&quot;)        &#123;            cout &lt;&lt; query() &lt;&lt; endl;        &#125;          &#125;        return 0;&#125;

单调栈例题
给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。
输入格式第一行包含整数 N，表示数列长度。
第二行包含 N 个整数，表示整数数列。
输出格式共一行，包含N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。
数据范围1≤N≤10^5^1≤数列中元素≤10^9^
输入样例：53 4 2 7 5

输出样例：-1 3 -1 2 2
思路要求是左边第一个小的数（也可以是左&#x2F;右边 第一个 最大&#x2F;小的数），可以利用栈的特性实现。

判断当前栈是否为空，如果不为空判断栈顶元素是否比输入的数小（或者大），不满足就出栈，直到栈空。
再次判断栈是否为空，如果不是空的，那么栈顶元素就是需要的了。如果栈空了，就证明没匹配到，输出-1
不管上面如何，将输入的数入栈，供下个数使用。

实现代码#include &lt;iostream&gt;using namespace std;const int N = 1e5+10;int n, stk[N], tt;int main()&#123;    cin &gt;&gt; n;      for(int i = 0; i &lt; n; i++)    &#123;        int x;        cin &gt;&gt; x;        while(tt != 0 &amp;&amp; stk[tt] &gt;= x)//如果栈不为空，同时栈顶元素大于等于当前的元素，那么栈顶元素就不会用到了，可以出栈了            tt --;        if(tt != 0)//如果栈仍然不为空，那么当前的栈顶的元素就是需要的数，直接输出            cout &lt;&lt; stk[tt] &lt;&lt; &quot; &quot;;        else            cout &lt;&lt; -1 &lt;&lt; &quot; &quot;;                  stk[++ tt] = x;//把元素入栈    &#125;      return 0;&#125;

单调队列（滑动窗口）例题
给定一个大小为 n≤10^6^ 的数组。
有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。
你只能在窗口中看到 k 个数字。
每次滑动窗口向右移动一个位置。
以下是一个例子：
该数组为 [1 3 -1 -3 5 3 6 7]，kk 为 33。



窗口位置
最小值
最大值



[1 3 -1] -3 5 3 6 7
-1
3


1 [3 -1 -3] 5 3 6 7
-3
3


1 3 [-1 -3 5] 3 6 7
-3
5


1 3 -1 [-3 5 3] 6 7
-3
5


1 3 -1 -3 [5 3 6] 7
3
6


1 3 -1 -3 5 [3 6 7]
3
7


你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。
输入格式输入包含两行。
第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。
第二行有 n 个整数，代表数组的具体数值。
同行数据之间用空格隔开。
输出格式输出包含两个。
第一行输出，从左至右，每个位置滑动窗口中的最小值。
第二行输出，从左至右，每个位置滑动窗口中的最大值。
输入样例：8 31 3 -1 -3 5 3 6 7

输出样例：-1 -3 -3 -3 3 33 3 5 5 6 7
实现代码#include &lt;iostream&gt;using namespace std;const int N = 1e6+10;//原始数据，单调队列int a[N],q[N];int main()&#123;    int n, k;    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);      for(int i = 0; i &lt; n; i ++)        scanf(&quot;%d&quot;,&amp;a[i]);      int hh = 0, tt = -1;    for(int i = 0; i &lt; n; i++)    &#123;        //判断队头是否已经滑出窗口        //因为窗口只会后移一位，因此不需要循环        if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh])            hh ++;              while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i])            tt --;              q[++ tt] = i;              if(i &gt;= k - 1)            printf(&quot;%d &quot;, a[q[hh]]);              &#125;      puts(&quot;&quot;);        hh = 0, tt = -1;    for(int i = 0; i &lt; n; i++)    &#123;        //判断队头是否已经滑出窗口        //因为窗口只会后移一位，因此不需要循环        if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh])            hh ++;              while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i])            tt --;              q[++ tt] = i;              if(i &gt;= k - 1)            printf(&quot;%d &quot;, a[q[hh]]);              &#125;      puts(&quot;&quot;);        return 0;&#125;

他人题解1
解题思路（以最大值为例）：
由于我们需要求出的是滑动窗口的最大值。
如果当前的滑动窗口中有两个下标 i 和 j ，其中i在j的左侧（i&lt;j），并且i对应的元素不大于j对应的元素（nums[i]≤nums[j]），则：
当滑动窗口向右移动时，只要 i 还在窗口中，那么 j 一定也还在窗口中。这是由于 i 在 j 的左侧所保证的。
因此，由于 nums[j] 的存在，nums[i] 一定不会是滑动窗口中的最大值了，我们可以将nums[i]永久地移除。
因此我们可以使用一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组nums中对应的值是严格单调递减的。
当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。
为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果新元素大于等于队尾元素，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。
由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。
窗口向右移动的时候。因此我们还需要不断从队首弹出元素保证队列中的所有元素都是窗口中的，因此当队头元素在窗口的左边的时候，弹出队头。
#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;using namespace std;const int N = 1000010;int a[N];int main()&#123; int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; a[i];//读入数据 deque&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) &#123;     while(q.size() &amp;&amp; q.back() &gt; a[i]) //新进入窗口的值小于队尾元素，则队尾出队列         q.pop_back();     q.push_back(a[i]);//将新进入的元素入队     if(i - k &gt;= 1 &amp;&amp; q.front() == a[i - k])//若队头是否滑出了窗口，队头出队          q.pop_front();     if(i &gt;= k)//当窗口形成，输出队头对应的值         cout &lt;&lt; q.front() &lt;&lt;&quot; &quot;; &#125; q.clear(); cout &lt;&lt; endl; //最大值亦然 for(int i = 1; i &lt;= n; i++) &#123;     while(q.size() &amp;&amp; q.back() &lt; a[i]) q.pop_back();     q.push_back(a[i]);     if(i - k &gt;= 1 &amp;&amp; a[i - k] == q.front()) q.pop_front();      if(i &gt;= k) cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;; &#125;&#125;作者：Hasity链接：https://www.acwing.com/solution/content/97229/来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
他人题解2
思路：
最小值和最大值分开来做，两个for循环完全类似，都做以下四步：
解决队首已经出窗口的问题;解决队尾与当前元素a[i]不满足单调性的问题;将当前元素下标加入队尾;如果满足条件则输出结果;需要注意的细节：
上面四个步骤中一定要先3后4，因为有可能输出的正是新加入的那个元素;队列中存的是原数组的下标，取值时要再套一层，a[q[]];算最大值前注意将hh和tt重置;此题用cout会超时，只能用printf;hh从0开始，数组下标也要从0开始。
# include &lt;iostream&gt;using namespace std;const int N = 1000010;int a[N], q[N], hh, tt = -1;int main()&#123; int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; ++ i) &#123;     scanf(&quot;%d&quot;, &amp;a[i]);     if (i - k + 1 &gt; q[hh]) ++ hh;                  // 若队首出窗口，hh加1     while (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) -- tt;    // 若队尾不单调，tt减1     q[++ tt] = i;                                  // 下标加到队尾     if (i + 1 &gt;= k) printf(&quot;%d &quot;, a[q[hh]]);       // 输出结果 &#125; cout &lt;&lt; endl; hh = 0; tt = -1;                                   // 重置！ for (int i = 0; i &lt; n; ++ i) &#123;     if (i - k + 1 &gt; q[hh]) ++ hh;     while (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) -- tt;     q[++ tt] = i;     if (i + 1 &gt;= k) printf(&quot;%d &quot;, a[q[hh]]); &#125; return 0;&#125;
kmpTrie并查集堆Hash表[li,ri]:
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>算法</tag>
        <tag>基础算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>排序的总类 思想 效率</title>
    <url>/2022/09/08/%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%B1%BB_%E6%80%9D%E6%83%B3_%E6%95%88%E7%8E%87/</url>
    <content><![CDATA[准备随机数生成C++中没有自带的random函数，要实现随机数的生成就需要使用rand()和srand()。
不过，由于rand()的内部实现是用线性同余法做的，所以生成的并不是真正的随机数，而是在一定范围内可看为随机的伪随机数。
rand（）rand()会返回一随机数值, 范围在0至RAND_MAX 间。RAND_MAX定义在stdlib.h, 其值为2147483647。
参考代码#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;int main()&#123;    for (int i = 0; i &lt; 10; i++)    &#123;        cout &lt;&lt; rand()%100&lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;//在100中产生随机数， 但是因为没有随机种子所以，下一次运行也是这个数，因此就要引出srand



srand（）srand()可用来设置rand()产生随机数时的随机数种子。通过设置不同的种子，我们可以获取不同的随机数序列。
可以利用srand((int)(time(NULL))的方法，利用系统时钟，产生不同的随机数种子。不过要调用time()，需要加入头文件&lt; ctime &gt;。
参考代码#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;using namespace std;int main()&#123;    srand((int)time(0));  // 产生随机种子  把0换成NULL也行    for (int i = 0; i &lt; 10; i++)    &#123;        cout &lt;&lt; rand()%100&lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;



为了使用方便可以使用宏定义来替换rand函数（或者srand）
#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#define random(x) rand()%(x)using namespace std;int main()&#123;    srand((int)time(0));  // 产生随机种子  把0换成NULL也行    for (int i = 0; i &lt; 10; i++)    &#123;        cout &lt;&lt; random(100) &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;





其他的随机数的范围通式产生一定范围随机数的通用表示公式是：
要取得[0,n) 就是rand（）%n   表示 从0到n-1的数
要取得[a,b)的随机整数，使用(rand() % (b-a))+ a; 
要取得[a,b]的随机整数，使用(rand() % (b-a+1))+ a; 
要取得(a,b]的随机整数，使用(rand() % (b-a))+ a + 1; 
通用公式:a + rand() % n；其中的a是起始值，n是整数的范围。 
要取得a到b之间的随机整数，另一种表示：a + (int)b * rand() &#x2F; (RAND_MAX + 1)。 
要取得0～1之间的浮点数，可以使用rand() &#x2F; double(RAND_MAX)。
来源https://www.cnblogs.com/xiaokang01/p/9786751.html
显示计算机当前的时间冒泡排序思想
比较相邻元素，如果第一个比第二个大，就进行交换，使得最大的数（或者最小的数）在最后
继续第一步，总共需要进行 n - 1 次的循环，就可以实现排序完成

效率及特点
双重循环，因此时间复杂度是 n^2^
因为前后两个数是通过大于 或者 小于 的方法进行比较，因此排序具有稳定性。即如果两个数相等，排完序后两个数的前后关系不会改变。
可以进行优化，如果当前循环内没有进行交换，则认为数组已经是有序的了，可以停止排序直接退出。

实现代码/// &lt;summary&gt;/// 冒泡排序/// &lt;/summary&gt;/// &lt;param name=&quot;arr&quot;&gt;要排序的数组&lt;/param&gt;/// &lt;param name=&quot;len&quot;&gt;数组的长度&lt;/param&gt;void bubbleSort(int arr[], int len)&#123;        for (int i = 0; i &lt; len - 1; i++)    &#123;        for (int j = 0; j &lt; len - i - 1; j++)        &#123;            //如果当前元素比后一个元素的值大（或者小），就进行交换，循环一遍后使得最大的元素到达最后            if (arr[j] &gt; arr[j + 1])            &#123;                swap(arr[j], arr[j + 1]);            &#125;        &#125;    &#125;&#125;



优化后的版本
/// &lt;summary&gt;/// 优化过的冒泡排序/// &lt;/summary&gt;/// &lt;param name=&quot;arr&quot;&gt;数组名&lt;/param&gt;/// &lt;param name=&quot;len&quot;&gt;数组长度&lt;/param&gt;void bubbleSort_s(int arr[], int len)&#123;    bool flag ;    for (int i = 0; i &lt; len - 1; i++)    &#123;        flag = true;        for (int j = 0; j &lt; len - i - 1; j++)        &#123;            //如果当前元素比后一个元素的值大（或者小），就进行交换，循环一遍后使得最大的元素到达最后            if (arr[j] &gt; arr[j + 1])            &#123;                swap(arr[j], arr[j + 1]);                flag = false;//如果发生排序，则证明数列还不一定是有序的            &#125;        &#125;        if (flag == true)//如果这个循环中没有进行过交换，则认为数列已经有序，可以退出        &#123;            break;        &#125;    &#125;&#125;



选择排序思想
在当前数列中设第一位是最小值
将最小值的与当前数列的每一位元素进行比较，达到最小值是整个未排序的数列中最小的元素。
将最小值与数列的第一位进行交换，使得每次循环后，最小的在最前面。

效率和特点
和冒泡类似，都是双重循环，因此时间复杂度是n^2^。
不好继续优化，对于全是同一个数的数列来说不能像冒泡排序一样循环一遍后直接退出。
节省空间？因为对于结构体数组来说，每次判断只需要存储下标。
需要注意的是选择排序是不稳定的，可能出现两个相等的数前后的位置关系发生改变。

实现代码/// &lt;summary&gt;/// 选择排序/// &lt;/summary&gt;/// &lt;param name=&quot;arr&quot;&gt;要排序的数组名&lt;/param&gt;/// &lt;param name=&quot;len&quot;&gt;数组长度&lt;/param&gt;void selectSort(int arr[], int len)&#123;    int minn;//设定一个最小值    for (int i = 0; i &lt; len; i++)    &#123;        minn = i;// 设当前数列的第一个数是整个数列最小的数（或者最大的数）。只存储下标，方便交换        for (int j = i; j &lt; len; j++)        &#123;            if (arr[j] &lt; arr[minn])//如果当前的数比数列的第一个要小，则更新下标值.通过更改这个对比实现升序降序的选择。                minn = j;        &#125;        swap(arr[minn], arr[i]);//将当前数列的最小值与第一个互换，保证每次循环中最小的值在最前面    &#125;&#125;





插入排序思想
每次循环后使数组后移一位，然后将最小值或最大值插入到整个数列中第一个比他小的位置。

效率和特点
双重循环，n^2^
稳定。
最优情况：数列相等或者顺序符合要求，只会比较n - 1次
最坏情况：数列完全逆序，需要2(1 + 2 + .. + n-1)次的比较和移动(即 n^2^ - n)。

实现代码/// &lt;summary&gt;/// 插入排序/// &lt;/summary&gt;/// &lt;param name=&quot;arr&quot;&gt;数组名&lt;/param&gt;/// &lt;param name=&quot;len&quot;&gt;数组长度&lt;/param&gt;void insertSort(int arr[], int len)&#123;    int key;    for (int i = 1; i &lt; len; i++)    &#123;        key = arr[i];        int j = i - 1;        while ((j &gt;= 0) &amp;&amp; (key &lt; arr[j]))//只要j大于0并且关键字始终小于当前元素，就不停的后移        &#123;            arr[j + 1] = arr[j];//数组中的数 每次都后移一位            j--;        &#125;        arr[j + 1] = key;//把最小的值插入到前面    &#125;&#125;



快速排序思想
从数列中挑出一个元素，称为 “基准”（pivot）。可以是第一个元素，也可以是最后一个元素，或者中间的任意一个元素
重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

效率及特点
时间复杂度只有nlogn，因为是二叉树形式的递归

实现代码void quickSort(int arr[], int l, int r)&#123;    //如果左右边界相等了，就证明当前数列中只有一个元素，可以认为当前数列是有序的    if (l &gt;= r)        return;    int x = arr[l + r &gt;&gt; 1];//对数组取中间元素的值作为分界值    int i = l - 1;//生成本轮循环的左边界    int j = r + 1;//生成本轮循环的右边界    //使得分界值左边所有元素都小于分界值，右边所有元素都大于分界值。    while (i &lt; j)//开始本轮循环 要求左右边界不能碰面    &#123;        do &#123;            i++;        &#125; while (arr[i] &lt; x);//从头开始，寻找第一个值大于等于分界值的元素        do &#123;            j--;        &#125; while (arr[j] &gt; x);//从后往前，寻找第一个值小于等于分界值的元素        if (i &lt; j)//如果左指针比右指针小，就交换两个元素。可能会有越界的行为，因此在交换前需要先判断            swap(arr[i], arr[j]);    &#125;    //从分界点开始递归排序    quickSort(arr, l, j);    quickSort(arr, j + 1, r);&#125;









归并排序思想​		整个算法是基于基于分治的，先对要排序的数列求出中间值，然后以中间值为界限，将左右两边依次递归的进行排序，直到序列中只有一个元素为止。
​		在归并中，有两个指针分别指向左右两个序列的起始位置，依次判断当前指针指向的数的大小，并按要求将指定的数存入临时数组，此过程可以保证排序的稳定性。
​		当归并完成后，依次对两个数列进行“扫尾”的操作，将剩下的没有进行归并的数全部依次存入临时数组。
​		最后将临时数组返回或者复制到答案数组中。
效率及特点
虽然时间复杂度都是nlogn，但在对1e7的数量级的0-100的随机数进行排序的时候发现，归并排序只需要4秒钟，快排需要8秒。（排序数据相同，没修改过随机种子）。需要注意的是，用于归并的辅助数组一定要在归并函数外面定义，如果定义在内部会导致巨量的内存及时间的浪费（13秒，2G）
相比快排具有稳定性。
基于分治的思想

实现代码void mergeSort(int nums[], int l, int r)&#123;    //int* tmp = (int*)malloc((r - l) * sizeof(int));    if (l &gt;= r)        return;    int mid = l + r &gt;&gt; 1;    mergeSort(nums, l, mid);    mergeSort(nums, mid + 1, r);    int k = 0;    int i = l, j = mid + 1;    while (i &lt;= mid &amp;&amp; j &lt;= r)    &#123;        if (nums[i] &lt; nums[j])            tmp[k++] = nums[i++];        else            tmp[k++] = nums[j++];    &#125;    //进行扫尾操作    while (i &lt;= mid)        tmp[k++] = nums[i++];    while (j &lt;= r)        tmp[k++] = nums[j++];    for (int i = l, j = 0; i &lt;= r; i++, j++)    &#123;        nums[i] = tmp[j];    &#125;&#125;

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>联想ThinkCentreM710q恢复第2个M.2接口功能的方法</title>
    <url>/2024/06/14/%E8%81%94%E6%83%B3ThinkCentre%20M710q%E6%81%A2%E5%A4%8D%E7%AC%AC2%E4%B8%AAM.2%E6%8E%A5%E5%8F%A3%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[板子图片正面
背面
需改动的地方




主要的注意事项如下
焊接m2插槽时，最好一个引脚一个引脚的焊接，尽量不要拖焊。同时焊完注意测量是否存在短路问题。旁边的电容阻碍了焊接，先行移除




焊接完插槽后，用热风枪恢复电容（当然也可以用烙铁）。

经过以上处理，主板就可以恢复M.2功能了，注意：这个M.2只支持SATA模式。

另外，M710q除了可以恢复M.2以外，也可以恢复PCIE X8的功能，也就是说可以升级到M910q，我也成功改过一台并装上显卡使用中。问题是很复杂，需要补很多零件，20V转PCIE供电部分的所有零件也需要补齐，介于难度较大我就暂时不“害”大家了
]]></content>
      <categories>
        <category>搞事情</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>魔改</tag>
        <tag>捡垃圾</tag>
      </tags>
  </entry>
  <entry>
    <title>视频格式基础知识</title>
    <url>/2023/08/10/%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[视频格式的基础知识封装格式(MP4&#x2F;MKV…)  vs 媒体格式(H.264&#x2F;FLAC&#x2F;AAC…)概述​	MP4+MKV是下载的视频文件最常见的种类。这些文件其实类似一个包裹，它的后缀则是包裹的包装方式。
​	这些包裹里面，包含了视频（只有图像），音频（只有声音），字幕等。当播放器在播放的时候，首先对这个包裹进行拆包（专业术语叫做分离&#x2F;splitting）,把其中的视频、音频等拿出来，再进行播放。
​	既然它们只是一个包裹，就意味着这个后缀不能保证里面的东西是啥，也不能保证到底有多少东西。包裹里面的每一件物品，我们称之为轨道(track)，一般有这么些： 

视频(Video): 一般来说肯定都有，但是也有例外，比如mka格式的外挂音轨，其实就是没视频的mkv。注意我们说到视频的时候，是不包括声音的。

音频(Audio)：一般来说也肯定有，但是有些情况是静音的，就没必要带了。

章节(Chapter): 蓝光原盘中自带的分段信息。如果文件带上了，那么你可以在播放器中看到带章节的效果：

.potplayer右键画面，选项-播放-在进度条上显示书签&#x2F;章节标记

.mpc-hc 右键画面，选项-调节-在进度条显示章节标记



字幕(Subtitles)：有些时候文件自带字幕，并且字幕并非是直接整合于视频的硬字幕，那么就是一起被打包在封装容器中。

其他可能还有附件等，不一一列举。每个类型也不一定只有一条轨道，比如经常见到带多音轨的MKV。


​	每个轨道，都有自己的格式。比如大家常说的，视频是H.264，音频是AAC，这些就是每个轨道的格式。
​	视频的格式，常见的有H.264(可以细分为8bit&#x2F;10bit)，H.265(当前也有8bit&#x2F;10bit之分)，RealVideo(常见于早期rm&#x2F;rmvb)，VC-1(微软主导的，常见于wmv)。基本上，H.264=AVC=AVC1, H.265=HEVC。
​	音频的格式，常见的有 FLAC&#x2F;ALAC&#x2F;TrueHD&#x2F;DTS-HD MA这四种无损，和AAC&#x2F;MP3&#x2F;AC3&#x2F;DTS(Core)这四种有损。但请注意，如Flac格式的音频，只是支持无损，并不代表全部都是无损。比如将aac格式的音频转成flac，虽然格式变了，但其中的音频还是原来的有损。

这里插播一个小的知识点，有损压缩是不可逆的，当信息丢失后，除非有辅助手段，否则丢失的信息是找不回来的。马赛克就可以视为一种局部的手动丢失信息的措施，因此经过打码的图片or视频是无法还原的，但可以使用ai都手段，“脑补”出打码之前的原始形态。

MKV vs MP4的主要区别
MKV支持封装FLAC作为音频，MP4则不支持。但是MP4也可以封装无损音轨(比如说ALAC，虽然普遍认为ALAC的效率不如FLAC优秀)
MKV支持封装ASS&#x2F;SSA格式的字幕，MP4则不支持。一般字幕组制作的字幕是ASS格式，所以内封字幕多见于MKV格式
MP4作为工业标准，在视频编辑软件和播放设备上的兼容性一般好于MKV。这也是vcb-s那些为移动设备优化的视频基本上选择MP4封装的原因。

​	除此之外，这两个格式很大程度上可以互相代替。比如它们都支持封装AVC和HEVC，包括8bit&#x2F;10bit的精度。所以所谓的MP4画质不如MKV好，这种论断是非常无知的——它们完全可以封装一样的视频。
​	为什么会有这样的分歧，就是历史原因了。MKV是民间研发，为了代替古老的AVI，从而更好地支持H264，它开发和修改的灵活度使得它可以兼容flac&#x2F;ass这类非工业标准的格式；而MP4则是出生豪门，作为工业标准，替代更古老的MPG，作为新一代视频&#x2F;音频封装服务的。
视频的基础参数：分辨率，帧率和码率。​	视频是由连续的图像构成的。每一张图像，我们称为一帧(frame)。图像则是由像素(pixel)构成的。一张图像有多少像素，称为这个图像的分辨率。比如说1920×1080的图像，说明它是由横纵1920×1080个像素点构成。视频的分辨率就是每一帧图像的分辨率。 
​	一个视频，每一秒由多少图像构成，称为这个视频的帧率(frame-rate)。常见的帧率有24000&#x2F;1001&#x3D;23.976, 30000&#x2F;1001&#x3D;29.970, 60000&#x2F;1001&#x3D;59.940, 25.000, 50.000等等。这个数字是一秒钟内闪过的图像的数量。比如23.976，就是1001秒内，有24000张图像。视频的帧率是可以是恒定的(cfr, Const Frame-Rate)，也可以是变化的(vfr, Variable Frame-Rate) 
​	码率的定义是视频文件体积除以时间。单位一般是Kbps(Kbit&#x2F;s)或者Mbps(Mbit&#x2F;s)。注意1B(Byte)&#x3D;8b(bit)。所以一个24分钟，900MB的视频：

体积：900MB &#x3D; 900MByte &#x3D; 7200Mbit

时间：24min &#x3D; 1440s

码率：7200&#x2F;1440  &#x3D; 5000 Kbps &#x3D; 5Mbps


当视频文件的时间基本相同的时候（比如现在一集番大概是24分钟），码率和体积基本上是等价的，都是用来描述视频大小的参数。长度分辨率都相同的文件，体积不同，实际上就是码率不同。
码率也可以解读为单位时间内，用来记录视频的数据总量。码率越高的视频，意味着用来记录视频的数据量越多，潜在的解读就是视频可以拥有更好的质量。（注意，仅仅是潜在，后文我们会分析为什么高码率不一定等于高画质）
图像的表示方法：RGB模型 vs YUV模型光的三原色是红(Red)、绿(Green)、蓝(Blue)。现代的显示器技术就是通过组合不同强度的三原色，来达成几乎任何一种可见光的颜色。图像储存中，通过记录每个像素红绿蓝强度，来记录图像的方法，称为RGB模型 (RGB Model)
常见的图片格式中，PNG和BMP这两种就是基于RGB模型的。
比如说原图：


分别只显示R G B通道的强度，效果如下：








​	三个通道下，信息量和细节程度不一定是均匀分布的。比如说可以注意南小鸟脸上的红晕，在3个平面上的区分程度就不同——红色平面下几乎无从区分，造成区别的主要是绿色和蓝色的平面。外围白色的脸颊，三色都近乎饱和；但是红晕部分，只有红色饱和，绿色和蓝色不饱和。这是造成红色凸显的原因。 
​	除了RGB模型，还有一种广泛采用的模型，称为YUV模型，又被称为亮度-色度模型（Luma-Chroma）。它是通过数学转换，将RGB三个通道，转换为一个代表亮度的通道(Y,又称为Luma)，和两个代表色度的通道(UV，并成为Chroma)。
​	举个形象点的例子：一家养殖场饲养猪和牛，一种记数方式是：（猪的数量，牛的数量）
​	但是也可以这么记录：（总数量&#x3D;猪的数量+牛的数量，相差&#x3D;猪的数量-牛的数量）。两种方法之间有数学公式可以互转。
YUV模型干的是类似的事儿。通过对RGB数据的合理转换，得到另一种表示方式。YUV模型下，还有不同的实现方式。举个用的比较多的YCbCr模型：它把RGB转换成一个亮度(Y)，和 蓝色色度(Cb) 以及 红色色度(Cr)。转换背后复杂的公式大家不需要了解，只需要看看效果：
只有亮度通道：

只有蓝色色度：

只有红色色度：

在图像视频的加工与储存中，YUV格式一般更受欢迎，理由如下： 
1、人眼对亮度的敏感度远高于色度，因此人眼看到的有效信息主要来自于亮度。YUV模型可以将绝大多数的有效信息分配到Y通道。UV通道相对记录的信息少的多。相对于RGB模型较为平均的分配，YUV模型将多数有效信息集中在Y通道，不但减少了冗余信息量，还为压缩提供了便利
2、保持了对黑白显示设备的向下兼容
3、图像编辑中，调节亮度和颜色饱和度，在YUV模型下更方便。
几乎所有的视频格式，以及广泛使用的JPEG图像格式，都是基于YCbCr模型的。播放的时候，播放器需要将YCbCr的信息，通过计算，转换为RGB。这个步骤称为渲染（Rendering）
每个通道的记录，通常是用整数来表示。比如RGB24，就是RGB各8个bit，用0~255 (8bit的二进制数范围)来表示某个颜色的强弱。YUV模型也不例外，也是用整数来表示每个通道的高低。
色深色深(bit-depth)，就是我们通常说的8bit和10bit，是指每个通道的精度。8bit就是每个通道用一个8bit整数(0~255)代表，10bit就是用10bit整数(0~1023)来显示。16bit则是0~65535
(注意，上文的表述是不严谨的，视频在编码的时候，并非一定能用到0~255的所有范围，而是可能有所保留，只用到一部分，比如16~235。这我们就不详细展开了) 
你的显示器是8bit的，代表它能显示RGB每个通道0~255所有强度。但是视频的色深是YUV的色深，播放的时候，YUV需要通过计算转换到RGB。因此，10bit的高精度是间接的，它使得运算过程中精度增加，以让最后的颜色更细腻。 
如何理解8bit显示器，播放10bit是有必要的呢：

一个圆的半径是12.33m, 求它的面积，保留两位小数。

半径的精度给定两位小数，结果也要求两位小数，那么圆周率精度需要给多高呢？也只要两位小数么？取pi&#x3D;3.14, 面积算出来是477.37平方米取pi&#x3D;3.1416，面积算出来是477.61平方米取pi精度足够高，面积算出来是477.61平方米。所以取pi&#x3D;3.1416是足够的，但是3.14就不够了。


​	换言之，即便最终输出的精度要求较低，也不意味着参与运算的数字，以及运算过程，可以保持较低的精度。在最终输出是8bit RGB的前提下，10bit YUV比起8bit YUV依旧具有精度优势的原因就在这里。事实上，8bit YUV转换后，覆盖的精度大概相当于8bit RGB的26%，而10bit转换后的精度大约可以覆盖97%——你想让你家8bit显示器发挥97%的细腻度么？看10bit吧。
8bit精度不足，主要表现在亮度较低的区域，容易形成色带：

注意这图右边那一圈圈跟波浪一样的效果。这就是颜色精度不足的表现。
10bit的优势不只在于显示精度的提高，在提高视频压缩率，减少失真方面，相对8bit也有优势。这方面就不展开了。
色度半采样​	在YUV模型的应用中，Y和UV的重要性是不等同的。图像视频的实际储存和传输中，通常将Y以全分辨率记录，UV以减半甚至1&#x2F;4的分辨率记录。这个手段被称为色度半采样(Chroma Sub-Sampling)。色度半采样可以有效减少传输带宽，和加大UV平面的压缩率，但是不可避免的会损失UV平面的有效信息。 
​	我们平常的视频，最常见的是420采样。配合YUV格式，常常被写作yuv420。这种采样是Y保留全部，UV只以(1&#x2F;2) x (1&#x2F;2)的分辨率记录。比如说1920×1080的视频，其实只有亮度平面是1920×1080。两个色度平面都只有960×540的分辨率。
​	当然了，你也可以选择不做缩减。这种称为444采样，或者yuv444。YUV三个平面全是满分辨率。 
​	在做YUV-&gt;RGB的时候，首先需要将缩水的UV分辨率拉升到Y的分辨率（madVR中允许自定义算法，在Chroma Upscaling当中），然后再转换到RGB。做RGB-&gt;YUV的转换，也是先转换到444（YUV的分辨率相同），再将UV分辨率降低。 
​	一般能拿到的片源，包括所有蓝光原盘，都是420采样的。所以成品一般也保留420采样。所以yuv420就表示这个视频是420采样的yuv格式。
​	将420做成444格式，需要自己手动将UV分辨率拉升2×2倍。在今天madVR等渲染器可以很好地拉升UV平面的情况下，这种做法无异于毫无必要的拉升DVD做成伪高清。
​	当然了，有时候也需要在444&#x2F;RGB平面下做处理和修复，常见的比如视频本身RGB平面不重叠（比如摩卡少女樱），这种修复过程首先要将UV分辨率拉升，然后转RGB，做完修复再转回YUV。修复后的结果相当于全新构图，这种情况下保留444格式就是有理由，有必要的。 
​	H264格式编码444格式，需要High 4:4:4 Predictive Profile（简称Hi444pp）。所以看到Hi444pp&#x2F;yuv444 之类的标示，你就需要去找压制者的陈述，为什么他要做这么个拉升。如果找不到有效的理由，你应该默认作者是在瞎做。
空间上的低频与高频：平面，纹理和线条在视频处理中，空间(spatial)的概念指的是一帧图片以内（你可以认为就是一张图所呈现的二维空间&#x2F;平面）。跟时间(temporal)相对；时间的概念就强调帧与帧之间的变换。 
于是我们重新来看这张亮度的图：

亮度变化较快，变动幅度大的区域，我们称之为高频区域。否则，亮度变化缓慢且不明显的区域，我们称为低频区域。 

图中的蓝圈就是一块典型的低频区域，或者就叫做平面（平坦的部分）。亮度几乎没有变化
绿圈中，亮度呈现跳跃式的突变，这种高频区域我们称之为线条。
红圈中，亮度频繁变化，幅度有高有低，这种高频区域我们称为纹理。

有时候，线条和纹理（高频区域）统称为线条，平面（低频区域）又叫做非线条。 
​	这是亮度平面。色度平面，高频低频，线条等概念也同样适用，就是描述色度变化的快慢轻重。一般我们所谓的“细节”，就是指图像中的高频信息。
​	一般来说，一张图的高频信息越多，意味着这张图信息量越大，所需要记录的数据量就越多，编码所需要的运算量也越大。如果一个视频包含的空间性高频信息很多（通俗点说就是每一帧内细节很多），意味着这个视频的空间复杂度很高。
​	记录一张图片，编码器需要决定给怎样的部分多少码率。码率在一张图内不同部分的分配，叫做码率的空间分配。分配较好的时候，往往整幅图目视观感比较统一；分配不好常见的后果，就是线条纹理尚可，背景平面区域出现大量色带色块（码率被过分的分配给线条）；或者背景颜色过渡自然，纹理模糊，线条烂掉（码率被过分的分配给非线条）。
时间上的低频与高频：动态在视频处理中，时间(temporal)的概念强调帧与帧之间的变换。跟空间(spatial)相对。
​	动态的概念无需多解释；就是帧与帧之间图像变化的强弱，变化频率的高低。一段视频如果动态很高，变化剧烈，我们称为时间复杂度较高，时域上的高频信息多。否则如果视频本身舒缓多静态，我们称为时间复杂度低，时域上的低频信息多。 
​	一般来说，一段视频的时域高频信息多，动态的信息量就大，所需要记录的数据量就越多，编码所需要的运算量也越大。但是另一方面，人眼对高速变化的场景，敏感度不如静态的图片来的高（你没有时间去仔细观察细节），所以动态场景的优先度可以低于静态场景。如何权衡以上两点去分配码率，被称为码率的时间分配。分配较好的时候，看视频无论动态还是静态效果都较好；分配不好的时候往往是静态部分看着还行，动态部分糊烂掉；或者动态部分效果过分的好，浪费了大量码率，造成静态部分欠码，瑕疵明显。
​	很多人喜欢看静止的截图对比，来判断视频的画质。从观看的角度，这种做法其实并不完全科学——如果你觉得比较烂的一帧其实是取自高动态场景，那么这一帧稍微烂点无可厚非，反正观看的时候你注意不到，将码率省下来给静态部分会更好。
清晰度与画质简述我们经常讨论，一个视频清晰度如何，画质好不好。但是如何给这两个术语做定义呢？ 
​	经常看到的说法：“这个视频清晰度是1080p的”。其实看过上文你就应该知道，1080p只是视频的分辨率，它不能直接代表清晰度——比如说，我可以把一个480p的dvd视频拉升到1080p，那又怎样呢？它的清晰度难道就提高了么？ 
​	一个比较接近清晰度的概念，是上文所讲述的，空间高频信息量，就是一帧内的细节。一张图，一个视频的细节多，它的清晰度就高。分辨率决定了高频信息量的上限；就是它最清晰能到什么地步。1080p之所以比480p好，是因为它可以允许图像记录的高频信息多。这个说法看样子很靠谱，但是，有反例：

​	右图的高频信息远比左图多——它的线条很锐利，有大量致密的噪点（注意噪点完全符合高频信息的定义；它使得图像变化的非常快）
​	但是你真的觉得右图清晰度高么？
​	事实上，右图完全是通过左图加工而来。通过过度锐化+强噪点，人为的增加无效的高频信息。
​	所以清晰度的定义我更倾向于这样一个说法：图像或视频中，原生、有效的高频信息。原生，强调这种清晰度是非人工添加的；有效；强调细节本身有意义，而不是毫无意义的噪点特效。 
​	值得一提的是，人为增加的高频信息不见得完全没有帮助。有的时候适度锐化的确能够起到不错的目视效果：

​	这是一幅适度锐化后的效果。如果有人觉得右图更好，至少某些部分更好，相信我，你不是一个人。所以适度锐化依旧是视频和图像处理中，可以接受的一种主观调整的手段，一定的场合下，它确实有助于提高目视效果。 
​	以上是清晰度的概述。注意，清晰度只是空间方面（就是一帧以内）。如果再考虑到动态效果的优秀与否（视频是不是那种一动起来就糊成一团的，或者动起来感觉卡顿明显的，常见于早起RMVB），空间和时间上优秀的观看效果共同定义了画质。所以我们说madVR&#x2F;svp那些倍帧效果有助于提高画质，实际上它们增强了时间上的观看效果。 
​	好的画质，是制作者和观众共同追求的。怎么样的视频会有好的画质呢？是不是码率越高的视频画质越好呢？真不见得。视频的画质，是由以下几点共同决定的： 
1、源的画质。俗话说的好，上梁不正下梁歪。如果源的画质本身很差，那么再如何折腾都别指望画质好到哪去。所以压制者往往会选择更好的源进行压制——举个栗子，BDRip一般都比TVRip来的好，哪怕是720p。蓝光也分销售地区，一般日本销售的日版，画质上比美版、台版、港版啥的都来得好，所以同样是BDRip，选取更好的源，就能做到画质上优先一步。 
2、播放条件。观众是否用了足矣支持高画质播放的硬件和软件。这就是为啥我们在发布Rip的同时大力普及好的播放器；有时候一个好的播放器胜过多少在制作方面的精力投入。 
3、码率投入vs编码复杂度。视频的时间和空间复杂度，并称为编码复杂度。编码复杂度高的视频，往往细节多，动态高（比如《魔法少女小圆剧场版 叛逆的物语》），这样的视频天生需要较高的码率去维持一个优秀的观看效果。相反，有些视频编码复杂度低（比如《请问今天要来点兔子么》，动态少，线条细节柔和），这种视频就是比较节省码率的。 
4、码率分配的效率和合理度。同样多的码率，能起到怎样好的效果，被称为效率。比如H264就比之前的RealVideo效率高；10bit比8bit效率高；编码器先进，参数设置的比较合理，编码器各种高端参数全开（通常以编码时间作为代价），码率效率就高。合理度就是码率在时空分配方面合理与否，合理的分配，给观众的观看效果就比较统一协调。 码率分配的效率和合理度，是对制作者的要求，要求制作者对片源分析，参数设置有比较到位的理解。
码率分配和合理度做的好，就常常能做出低码率高画质的良心作品。 
这里再多提一句，至少在这个时间点，也就是此文发布的2014年年底，HEVC相对于AVC可以提高50%的效率，依旧是一个纸面上的理论值。实际操作中，因为HEVC编码器的成熟度远不及经过了十几年发展的AVC编码器，导致现在HEVC的潜力远没有能发挥出来，特别是高画质下甚至不如。
对于目前主流的，定位收藏画质的BDRip，同样码率下x265的画质相对于x264没有优势；所以在近期，大家不用优先的去下载HEVC版作为收藏目的，更不必迷信什么“码率降低一半”。再强调一次，这个时间点；如果一年后以上陈述被不断进步的HEVC编码器推翻，我毫不惊讶。 
5、编码前的预处理。预处理分三种：
①，客观修复。强调修复片源固有的瑕疵，比如锯齿，色带，晕轮等等。②，主观调整，强调将片源调整的更适合人眼观看，比如适度的锐化，调色（有时候你是可以通过科学方法判定片源的颜色有问题，然后针对的做修复的）。③，移除无效高频信息，比如降噪，避免码率浪费在无效的噪点上
​	预处理做的好，往往能达到画质上超越片源，或是在几乎不牺牲清晰度的前提下，节省码率开销。
​	但是预处理是一把双刃剑，优化的同时，可能引入副效果。降噪、抗锯齿、去晕轮等操作会不可避免的损失一些有效细节（或多或少，取决于制作者水准）；主观调整很可能会引入副效果（比如过度锐化会导致锯齿和晕轮），或是变成了作者的自我满足，形成对观众的欺骗。 
​	综上，一个优秀的画质，是由片源、制作者、观看者共同决定的；码率高低也只是部分因素，并非决定性的效果。
播放器背后的知识播放器的工作流程：分离，解码，渲染简单说就三个大步骤：分离、解码、渲染。
​	分离，指的是拿到媒体文件(MKV&#x2F;MP4&#x2F;MKA)等，先收集相关的文件（包括外挂音轨、字幕），然后将所有轨道拆开，拆分成单独的内容。视频流、音频流、字幕、章节信息，等等。负责执行分离的模块滤镜，叫做分离器(splitter&#x2F;demuxer)。
​	当同样类型的轨道不止一条的时候（比如多音轨），分离器还负责挑选其中的一条。通常同类型多轨道，会有一条轨道被设定为“默认轨”（比如多音轨MKV一般以主音轨为默认），你想选择副音轨，你就需要在分离器中手动切换。很多播放器会在自己的界面中提供音轨&#x2F;字幕切换的功能，其实也是间接利用分离器实现的。
​	分离器现在能用的基本上只有LAV&#x2F;ffmpeg了（这俩几乎可以算一家），以前还有个Haali，然而停止更新已久，不能适应HEVC时代了。
​	分离器一般不耗费运算性能。因为它只是简单地收集、拆分和选择。
​	解码，指的是将分离器丢来的各种原生压缩格式，比如H264&#x2F;H265的视频，FLAC&#x2F;AAC的音频，解码为非压缩的格式，比如视频是YUV&#x2F;RGB（相当于bmp），音频是PCM（相当于wav），然后丢给下游模块。负责解码的模块滤镜称为解码器(decoder)。常见的有LAV&#x2F;ffmpeg, ffdshow(同样停止更新了)……
​	当解码器能完全解码一个轨道中所有有效信息的时候，我们成为完全解码（现在绝大多数情况是如此），否则称为不完全解码。比如说，早期一些显卡的硬解，不能完全处理H264视频流的所有，解码出的画质有折扣；又或者DTS-HD MA解码器开源之前，基于ffmpeg&#x2F;lav等解码器只能解码出部分信息，导致音频是有损的。
​	解码出来的格式，都需要加上精度的度量。比如说10bit 视频完全解码后是YUV 10bit，8bit视频是YUV 8bit，16bit flac格式是PCM 16bit整数，aac是PCM 32bit浮点。麻烦在于，解码器下游的模块不见得能照单全收。比如说以前播放器就不支持10bit YUV丢给下游，解码器只好转为YUV 8bit（后来madVR之所以是一个极大的提升，就是因为madVR基本上全部通吃）。同理；很多声卡能支持24bit整数PCM已经是极限，所以32bit浮点的PCM需要转为24bit整数。
​	如果解码器可以将最原始的数据，或者更高精度（比如有时候为了方便，将10bit转为16bit）输出给下游，我们称为全精度输出；否则，解码器会试图降低精度输出，我们称为低精度输出。少数时候，我们会让解码器做一些转换（比如vcb-s新播放器教程中，让lav解码器做YUV-&gt;RGB的转换），我们称为转换输出。
​	解码器，特别是视频解码器，往往成为大量消耗运算资源的地方。这个问题在H264早期非常严重，那时候的主流CPU很难负担720p&#x2F;1080p的高清解码，能耗巨大，移动平台尤其如此。所以才催生了各种硬件加速和硬件解码，并逐渐成为一个规范标准。
​	渲染，指的是将解码后的数据，在pc硬件上（显示器、扬声器）进行播放。负责渲染的模块我们称之为渲染器(Render)，视频渲染器主流有EVR（Enhanced Video Render, 微软送的）以及madVR(madshi Video Render)。
​	音频渲染器一般都是系统自带的（同样是微软送的），也有可以自定义的。比如MPC播放器有MPC Audio Render，可以支持类似wasapi输出等其他功能。
​	因为显示器是RGB显示，而解码后的视频多为YUV格式，渲染器一般也需要负责将YUV转换为RGB，并保证输出的图像大小跟播放窗口吻合。
​	多数播放器自带的滤镜（mpc&#x2F;pot都有很多调色之类的功能），显卡的加成，以及SVP，都作用于解码器和渲染器中间。它们接过解码器解码的数据，对其进行处理，然后将处理后的数据送给渲染器。因为渲染器是需要借助显卡进行图形运算，YUV数据基本上需要先进入显存，所以显卡可以检测到丢来的YUV数据，对其进行“优化”。同样需要当心的是，这些滤镜和处理，往往入口精度低，处理精度也低。导致的后果就是解码器被迫低精度输出，给这些滤镜低精度处理，从而大幅降低视频精度，导致色带色块问题。
​	字幕的加载可能在渲染器前（将字幕信息整合进YUV&#x2F;RGB数据给渲染器），也可能在渲染器后（播放器来将字幕整合入生成完毕的RGB图像）。
多数解码包的配置界面，主要就是让你选择分离器、解码器和渲染器的：

如上图，上方就有让你选择视频渲染器，然后下方左右分别是针对不同文件格式的分离器，以及针对不同媒体格式的解码器。
硬解的定义与分类​	如上文所说，硬解是为了缓解高分辨率新编码面世初期，CPU不堪重负的解码压力，而诞生的技术。如果说软解的定义是：利用CPU通用运算能力，进行解码，那么硬解的定义可以这么说：不利用CPU通用运算能力，而是依赖其他集成电路，无论是否特制，来进行解码。
​	更古老的时候，有些显卡没办法进行完全解码，只是帮助计算部分解码过程中的运算，那么可以归为“硬件加速”。估计Intel下一代CPU“混合加速HEVC解码”也是一样的道理。
硬解现在比较常见的是以下种类：

DXVA(DirectX Video Acceleration)，比较古老的方案了。Windows XP以及之前系统上流行的。上古ffdshow的硬解就是利用DXVA。DXVA规范下容易出现不完全解码，导致画质降低。Vista以后，渐渐地被抛弃。
DXVA2，目前主流的硬解方式。主要由GPU来实现，但是并非利用GPU的流处理器，INA三家都是使用了单独附在GPU芯片上的一块专职电路来完成。GPU硬解能力往往不与显卡游戏性能相关，而与搭载的专职电路先进与否相关。典型的就是GT610，它是NVIDIA第一款能硬解4K视频的GPU，同时代其他GTX650&#x2F;GTX580什么面对4K视频只有傻眼的份儿，就因为它的GPU塞入的专职电路，是刚开发出最先进的一款（代号为VP5，其他同时代的都是VP4）。

使用DXVA解码，都需要先将视频数据（压缩的格式）传输到显存中，然后再让GPU进行解码。
DXVA2有两种实现方式：native和copy-back。区别是解码后的数据是否还要传回内存。
​	native选择不传，直接丢给同样依赖GPU工作的渲染器，数据从头到尾都在显存中。而copy-back选择传，数据会传回内存，一番处理后再传回显存，让渲染器工作。native的输出必须为YUV 8bit，而copy-back则可以为10bit。
​	之所以需要有copy-back这么个传来传去的过程，就是因为有些滤镜，比如SVP，比如LAV的转格式，必须依赖CPU+内存进行工作。不传回来没办法继续处理。copy-back保证了硬解的流程类似软解，可以不漏下任何后处理。而代价是传来传去必定降低性能，增加能耗。需要注意的是，即便用native，也可能导致解码后的数据被“优化”，因为有些处理，包括播放器、显卡驱动带的那些，是可以完全作用在GPU环境中的。
​	除了DXVA2，还有两种特殊的硬解：Intel Quick Sync, 和NVIDIA CUVID。如同名称所示，它们是Intel和NV的专属。
​	Intel Quick Sync是集成在CPU中的逻辑电路承担的。注意的是这玩意并非隶属于Intel的集显，而是CPU的直属。它直接读写内存，运行表现和软解非常类似。Intel Quick Sync堪称速度快，能耗低。
​	NVIDIA CUVID，是基于NV自己的接口，写的一个类似DXVA2(copy-back)的升级版。
硬解的模式可以在LAV Decoder的设置中选择：

红框的下拉框可选None(软解)，CUVID，QuickSync，DXVA2(native 和 copy back)。
每选择一个模式（除了None），蓝框会显示一个单词：

Active：当前正在使用这种模式解码
Available：应该可以使用这种模式
Not Available：不支持使用这种模式

绿框当中则是显示当前在使用哪个解码器。如果是软解，显示avcodec，否则显示类似dxva2cb, dxva2n等标示。
碰到没办法开启硬解，比如设备不能正常工作，或者碰到10bit AVC这种不支持的，那么自动转为软解。
YUV-&gt;RGB转换过程中的细节​	将解码器输出的YUV格式，转为RGB，并且缩放到播放窗口输出，是视频渲染器的职能。可以说，如果解码过程是完全解码，也不主动添加播放器调校和驱动增强，渲染的环节决定了最终成品的画质。造成画质区别的可以说就三点：缩放算法，运算精度，和抖动算法。任何试图优化渲染器效果的尝试，都应该从这三个方面着手。
缩放算法造成的区别，比较好理解。例如原图(150*150)：

用双线性算法（上，多数播放器默认算法）和nnedi3(下)放大到272 * 272像素：


不同算法造成的效果肉眼可见。注意上图中随处可见的锯齿，以及细线的模糊。
​	精度，是指运算的过程中，参与运算的数，有效位数的高低。在计算机中表现为使用怎样的格式来进行，8bit&#x2F;16bit&#x2F;32bit整数，16bit&#x2F;32bit浮点。精度不足的表现在上篇教程中已经有展示，不做赘述，然而还是提醒一句：千万不要以为显示器是8bit，就认为8bit 整数 的片源精度&#x2F;处理精度是足够的。
​	另外，RGB处理相对YUV处理，精度要求相对较低；或者说，RGB处理相比较，精度稍低带来的影响不明显。（不幸的是多数时候处理的数据都是YUV，然后根据水桶原理……）播放过程中，应该尽量减少RGB-YUV互转的次数，每一次转换都要做一次计算与取整，都会导致实际精度降低。
​	抖动算法(Dithering Algorithm)，通常出现在高精度转低精度中。在数字图像高转低处理中，全部四舍五入不见得是好习惯。抖动算法通过科学的添加噪点，来掩盖精度的不足。比如说原图（RGB24，即RGB 8bit）：

分别用四舍五入（上） 和 Floyd–Steinberg 抖动算法（下），将此图转为RGB16(RGB分别为5bit，6bit和5bit，早期windows桌面的“16色”，区别于RGB24的“真彩色”)


​	可以看出，使用抖动算法的图片较好的掩盖了精度不足引起的色带和偏色问题。在YUV 和 RGB的运算过程中，如果出现高精度转低精度，是否使用抖动，使用的抖动算法如何，也会决定输出效果。
现在，我们来模拟一下渲染器的工作流程，并用加粗标注出可能造成画质差别的地方：
1、渲染器从解码器那里获取YUV数据。注意拿到的数据可能是全精度，也可能是降精度，取决于渲染器接口类型；
2、播放器和显卡驱动可能会试图“优化”画面；
3、如果不是YUV444格式的，渲染器会先将UV平面放大到Y平面的大小。这个步骤称为Chroma upscaling；
4、将YUV444的数据，转为RGB。转换的过程势必需要浮点运算（YUV-&gt;RGB一些参与运算的常数是浮点数）；
5、播放器或者渲染器将RGB用特定的算法缩放到播放窗口大小。这个步骤称为Image Upscaling(图像放大)&#x2F;Downscaling(图像缩小)；
6、因为4的步骤中，必须以浮点数运算，而输出结果一定是RGB 8bit整数，因此输出之前必须有一个高转低的过程。
2~6每一步都涉及数字运算，因此有运算精度的区别。
问：什么样的渲染器，什么样的输出画面是标准的、完美的？答：没有。因为运算精度总可以无限的高，缩放算法也永远有提升的空间，所以视频播放不存在“标准、完美”一说；只有相比较而言的好与差，以及在人眼识别程度内的“接近完美”
问：有哪些渲染器能“接近完美”的处理以上所有情况？答：只有madVR。
问：Windows充话费送的那个EVR，默认情况下有啥不好？答：1、接口精度低，强迫YUV 8bit&#x2F;RGB 8bit的输入；2、缩放算法默认是平庸的双线性；3、运算精度较低，默认只有8bit整数和16bit浮点数；4、抖动算法有，较为单一和固定；5、如果输入的是YUV数据，EVR会任由播放器和驱动乱来。
问：我们能怎么拯救EVR？答：1、因为RGB对精度要求不敏感，而且输入RGB后，驱动和播放器基本没办法插手，所以设法永远输入RGB 8bit，不让YUV数据经过低精度处理；2、让LAV解码器来做YUV-&gt;RGB。LAV可以以32bit浮点的高精度、双立方的UV放大算法、随机抖动算法，较高质量的完成转换；3、图像缩放算法手动设置为更高级的双立方。
问：听上去不错，我们应该怎么操作？答：参见http://vcb-s.com/archives/4384或者http://vcb-s.com/archives/4407
所以，如果你使用的是madVR渲染器，你应该允许LAV输出它默认设置的那些格式，YUV&#x2F;RGB。LAV会以全精度输出YUV给madVR进行处理；如果你使用EVR渲染器，你应该永远只允许LAV输出RGB 8bit。
RGB 8bit 包括RGB24和RGB32。RGB32多一个透明层通道，看似带了个没用的东西，但是因为计算机更喜欢2的次方，所以部分运算下RGB32比RGB24快。在视频播放中，这两个格式几乎完全等同；互转也人畜无害（加一个空的透明度通道 vs 去掉透明度通道）。
之前基于EVR CP教程中，之所以pot推荐RGB24输出，而mpc推荐RGB32输出，是测试的结果。这样设置播放器不会再多一次转换（虽然就算转换了也没啥）。
硬解的优劣与选择​	绝大多数vcb-s的教程，都让大家不要开启硬解，就算开启，优先使用DXVA2(copy-back)，这里我们做一个详细的解释。
​	首先考虑一个问题：什么样的视频能被硬解？
​	8bit AVC可以被各种显卡硬解；然而8bit AVC格式的软解压力小的可怜，以vcb-s常发的24fps 1080p的视频算，现在CPU软解，占用率普遍不到5%。
​	10bit AVC没有能硬解的。（所以10bit版炮姐时代，试图硬解的洗洗睡吧。）软解，解码压力尚可，不是很可怕，24fps 1080p的视频，现在的cpu大约10%
​	8bit HEVC现在最新显卡普遍能硬解；然而因为8bit x265的缺陷（或者说8bit x264的优越性），我们发现这玩意表现多数还不及8bit AVC，所以vcb-s从来不用；相对而言，它的解码压力也不大，大致相当于10bit AVC。
​	10bit HEVC，目前只有NV的GTX950和GTX960支持硬解。它的软解压力算是比较大，现在主流的CPU占用在20%左右；对于上古CPU或者一些低端笔记本CPU，流畅解码会比较吃力，特别是60fps的特典。对于将来的4K 60fps，现在桌面4核心CPU基本上完全无力软解。
​	能硬解的视频必须是YUV420格式。
分析完毕了，你觉得自己需要硬解么？
如果你没有GTX960&#x2F;GTX950，你也基本碰不到1080p 60fps乃至4K的8bit HEVC，那么你只能去硬解8bit AVC，省那么5%不到的CPU占用率——真有这个必要么？软解吃力的硬解解不了，硬解解得了的软解解的飞起，那我们为什么要冒着各种潜在风险去开硬解呢？
好吧，就算你说我真有理由要开硬解：我有GTX960&#x2F;950，我的CPU真的太烂……我们来分析下不同情况下，硬解应该怎么开。硬解设置跟你使用的渲染器有关：
如果你使用madVR，通常是不建议你开硬解的。众所周知madVR会消耗大量显卡运算，因此没必要再去把大量数据塞进GPU和显存，跟madVR抢夺资源。让CPU分担解码，让GPU专心跑madVR，是比较推荐的做法；
如果你使用GTX960&#x2F;950硬解10bit HEVC，请务必设置为DXVA2(copy-back)，这是现在唯一可以开启10bit HEVC硬解的模式；(2020年更新：现在native&#x2F;D3D11也行了，那就选这俩加加速吧）
其他情况下，如果你真的非要开硬解搭配madVR，建议顺序（保证你硬件可用）： Intel QS, DXVA2(native), NV CUVID, DXVA2(copy-back)，其实用哪个都没有太多关系，主要的功耗消耗点在madVR。
如果你使用EVR CP（调节过缩放算法），希望追求较高质量的播放，你首先要排除的是DXVA2(Native)。因为这种模式下，LAV会直接输出YUV 8bit给显卡，哪怕强制规定了输出只能是RGB。用DXVA2(copy-back)是可以的；这种模式下，解码后的数据将回传给CPU，继续做高质量转RGB的后续操作。
一般情况下，建议顺序： Intel QS, NV CUVID, DXVA2(copy-back)
所以不难理解为什么之前教程我说了，要开硬解请用DXVA2(copy-back)。这种软解流程、硬解运算的泛用性模式，是最人畜无害的，哪怕这种模式折腾程度，导致在性能和功耗上大多是得不偿失。
追求最大性能的，特别是用来对付那些能够被硬解的高清病毒的，请使用EVR默认，搭配DXVA2(Native)播放。这样效率应该是最高的，各种专治8bit AVC 4K的高清病毒。只不过这种做法会损失画质，因此不建议日常使用。
图像格式的标识与查看方法在播放器中，不同格式、不同精度的图像，有着规范的定义和标号。这一点可以在LAV的设置界面很清楚的看到：

其中蓝色部分标示的这些是最常见到的，主要是YUV 420的不同精度，以及RGB格式（注意16bit RGB，即RGB48，在现有播放器体系下还没有实装，所以现在播放器中的RGB基本就是RGB 8bit）
使用DXVA2(Native)硬解的时候，输出是DXVA，也是YUV420 8bit。
RGB格式除了上文所说的RGB32和RGB24，播放器中还有XRGB和ARGB的标示，也都是一回事儿。
Potplayer中观察方法，可以用tab键显示：

potplayer会给出视频解码器（图中是LAV）
解码器输入的格式是HVC1(HEVC)，输出是RGB给渲染器。YUV-&gt;RGB的过程完全是LAV处理。
渲染器是EVR CP，渲染整个过程，格式都是RGB，没有转回YUV。需要注意的是你必须关闭pot自带的内置滤镜（按F5，进入”参数选项”设置。 2、点击“滤镜”，将右边的”内置图像处理滤镜设置”激活条件设置为：”不使用”），否则potplayer一定会自作主张转回YUV的。
缩放算法是Lanczos 3。(注意如果你播放画面跟视频画面相同，比如你在1080p的显示器上全屏播放，缩放算法会显示临近采样，这是正常的)
MPC-HC&#x2F;MPC-BE中，按Ctrl+J可以调出类似的信息：(再按1~2次取消)

红框中勾选的，Formats表示渲染过程中格式变化，从始至终都是RGB；
Video Size给出了原始尺寸和播放尺寸，以及使用的缩放算法(双立方 A&#x3D;-0.6)
Decoder则是解码器；输出是RGB。
通过这样的查看方法，你可以知道你的播放器工作流程，以及设置是否按照预期。
动漫画面区别于常规录制视频的特殊性​	一直以来都有这样的说法：“10bit, madVR这些东西都是那些压动漫的人弄出来的歪门邪道，我是看不出这些东西在电影上有个P用。”
​	其实吧，这还真不是这群人眼力不好或者装睡不醒。区别于录制视频，比如电影之类的，动漫、CG等有着自己的特殊性。总结起来就两点：1、噪点少，2、线条非常突兀。
​	视频拍摄，限制于器材水准，噪点是不可避免的，在后续制作等过程中也难以完全去除。而动漫天生可以0噪点，动漫中的噪点更多是数字图像处理中主动加上去的。噪点的一大作用就是极大地降低视频处理和压制，对于精度的需要。说的简单点：高噪点的视频不怕低精度，反之亦然。
怎么理解这个概念呢？我们借助一个简化的图片来演示。假设我们有一条平滑、高精度的曲线(这是y&#x3D;1&#x2F;x在[10,30]上的图)：

现在，我们把所有函数值，四舍五入到小数点后三位数：

降低精度的效果很明显，我们现在的图看上去跟楼梯一样，出现了明显的”断层”。表现在视频中，这种断层就是色带。同时值得注意的是，越是平坦、变化小的地方（就是之前科普中的”平面”），色带表现越严重。
现在，我们模仿给图像加噪点，来给这个函数加一个小幅度(约为1%)随机抖动：

然后我们也把它的精度限制为小数点后3位：

可见，这一次精度降低，图像似乎没有受到太多影响，精度降低造成的阶梯状效果也很不明显。表现在数字图像处理中，意味着噪点重的图片，在降低精度的时候收到的影响很小。
这就是为什么那些致力于改善精度的提升，对于电影等视频几乎没有用——播放过程的精度低怎么了；能有什么视觉影响？
类似的现象，噪点会使得人眼对图像锐利度等差异不敏感，或者说，缩放算法造成的区别，变得不太可见。以之前的图为例，假如为两幅图都加上强度相同的噪点：


区别已然几乎不可见。注意噪点是如何帮忙掩盖拉升过程中的锯齿等瑕疵，并加入虚假的高频信息，让图像看上去细节很丰富。这还是应用在线条&#x2F;平面非常分明的动漫；换作电影，这样的差异只会更不起眼。
小结一下，当有噪点存在的时候，主打高精度、优秀缩放算法的播放器，优势将不再明显。从另一个方面讲，面对较少噪点、较为突出线条的动漫，对播放器的精度和缩放算法提出的要求就很高。编码器也是一样的道理，动漫非常需要10bit x264&#x2F;x265这样原生高精度的编码器来提升画质。
因此，再面对本节开头的说法，不需要反驳，那是很自然的（摊手）。
问：既然加噪点可以有效避免精度降低，为什么在动漫压制中不用这个方法呢？
答：噪点作为一种高频信息，需要浪费成倍的码率。在今天10bit编码可以不增加（甚至减少）码率完美解决问题的前提下，我们为什么要用10年前的理解呢？
PS: 10年前只有8bit编码器的时候，主动加噪确实是很常见的防色带、去色带手段。在今天商业性蓝光编码器只有8bit精度的限制下，很多动漫蓝光后期也是通过加噪点解决的（Sony那高大上的“SBMV技术”的核心）。然而，蓝光可以不惜码率，Rip不行，除非你是Yousei。（所以Yousei的Devil-Jin至今用着这种手段）
播放器软件的现状与分析​	接上文分析。面对占绝对多数的电影观众，现有的播放器，pot&#x2F;mpc默认，已然足够好了。再好的设置能带来的观感提升几乎没有，还不如在什么一键增强，左眼效果，以及在线字幕、弹幕上下功夫。
​	面对多数动漫党，稍微修改一下基于EVR CP+LAV的播放设置，也能达到很满意的效果，很平衡的兼顾画质、性能与稳定性。所以如果你不求折腾（还把这么长的教程看到这里，真是辛苦你了），建议使用vcb-s最新写的两篇64bit播放器教程。
​	如果你真的欲求不满，那么你就可以试着接触madVR，SVP这些东西。但是有一点需要提醒的是：这些纯粹由fans开发的东西，甚至包括mpc&#x2F;pot这些软件，是高度不可靠的。哪怕所谓的“稳定版”，出bug的几率都很高。（更别提现在madVR一直都是“测试版”，版本号还在0.x）MadVR至今有个问题，就是它所在的目录路径不能有中文。这个问题存在几年了，作者压根不屑于，或者说，抽不出精力去修复它——你见过几个正儿八经的软件不支持安装目录有中文？！
​	更恐怖的是，高质量播放依赖的组件数量庞大，而彼此之间缺乏系统性的联系测试。开发者往往是各自测试各自的，没有组织、没有公司说作为一个整体来调试一套方案。当播放软件趋于复杂，组件数量增多，功能强化，出错的概率指数级上升。一个基于potplayer+madVR的播放方案，不考虑音频，涉及到以下可能出问题的地方：
​	potplayer本体,  LAV分离器，LAV视频解码器，madVR渲染器，操作系统，显卡和显卡驱动。
假设每一个组件出错的平均概率是3%，求问这一套方案正常运行不出错的概率是多少？1-0.97^6&#x3D;83%。
​	也就是说，平均5个人里面，就有一个人用这套方案出错。出错的理由往往很难查到，每个人都有每个人的原因。

（举个我自己的例子，虽然我写的教程基于mpc-hc，但我自己在用mpc-be。因为对于mpc-hc，我设置让EVR渲染器使用双立方缩放，mpc-hc始终都使用的是最朴素的双线性，导致缩放效果很差（对我来说）。各种途径查错无功而返，最终换mpc-be问题解决。）

所以以后请别问我为什么不写madVR+SVP+Reclock+XySubFilter这些高端货的教程，更别出了错问我错在哪里、怎么解决——臣妾做不到啊！
其他常见播放器配件简介除了madVR，其他播放器折腾一般还有这些配件：
​	SVP(Smooth Video Project)比较众所周知了，它是一个插值平滑软件。本身依赖avisynth开发，通过ffdshow&#x2F;ffdraw来加载，作用在解码器之后，渲染器之前。SVP只能支持YUV420 8bit输入输出。
​	SVP的性能消耗非常可观，特别是开启OpenCL之后，如果再开启madVR（接EVR CP容易导致精度问题，这时候可以手动在ffdshow&#x2F;ffdraw中加噪点来缓解），对显卡的性能和驱动稳定性都是考验。尽管如此，SVP的插值平滑带来的观看提升也是非常可观的，强烈建议madVR的倍帧满足不了、同时又有很强配置的观众们爬文安装。
​	XySubFilter，是目前最先进的字幕插件，对高级字幕特效的支持，渲染的质量，性能的优化，对高精度播放以及madVR的配合都做得很到位。如果你患有字幕强迫症末期，建议去折腾一下这个插件。
​	Reclock，一个致力于改善播放视频帧率不稳定的插件，不过多数人用它的目的可能还是为了它的wasapi输出。实际表现完全聊胜于无，特别是wasapi现在mpc自带的audio render就内置了，而且Reclock没有64bit版，因此不建议折腾。
播放器配置学习的建议​	对于想自学高级播放器设置的同学们，教程总是不缺的，网上一搜一大堆，各大论坛什么的置顶帖，万年冷冻库，等等。写的比vcb-s现有几篇教程更新、更详细、更高端的比比皆是，也都可以作为很不错的教程。然而我一直认为，这些教程只是授人以鲤，或者授人以鳊、鲢、鳙……，导致的结果就是来一只鲫，或者给你个渔网让你按照自己喜好捞一只，很多人一下子就傻眼了。
​	这也是我写这篇教程的初衷，讲述一下现在网上林林总总的教程，不会跟你说的很多细节与知识。有的人madVR设置玩出了花，结果不知道检查pot内置的ffmpeg解码器，会把YUV420 10bit 降低精度+瞎转换 为YUV422 8bit丢给madVR，然后又说自己看不出区别……这折腾的意义何在呢。
学习播放器配置，有这么几条原则，是我希望分享给大家的：
1、实事求是。不要盲目的去折腾，也不要为了心理安慰去折腾。一套更好的方案，只有你确实感觉到了提升，并且这个提升在你心理满意度上，足够抵消麻烦，才值得你去升级。比较的过程中，相信自己的眼睛，而不是相信别人的说教。比如说我真不推荐笔记本用户折腾任何顶级缩放算法——那么小个屏幕你能看出点啥？教程里说出花的放大算法跟你有几毛钱关系？
2、循序渐进。先把一套简单基础的方案弄好弄懂，再去学习和尝试更好的方法。对于新的插件，你要尝试测试它们在你机器上的表现；对于别人的设置，设法了解他这么推荐的原因，以及这个原因是否适用于你。最典型的，很多人用着madVR问我，你在新教程里教我们LAV只勾选RGB，我要改么？看了这篇教程你应该知道要不要改与背后的原因了吧。
3、量力而行。播放器越高级，组件越多，往往性能消耗越大，出错概率也越高，同时收益越少。学会放弃与妥协，毕竟，你看的是片子，不是播放器组件和参数。
动漫视频常见的瑕疵&#x2F;缺陷介绍前情提要​	这篇科普教程本身有两个目的，第一个作为给观众们的科普，讲述一下动漫处理中常见的画面问题，帮助大家理解每次vcb-s发布帖当中那些技术描述；第二个作为vcb-s内部处理教程的基础部分，帮助组内组外所有入门压制的新手们了解所面对的“敌人”。
​	需要注意的是，下文列举的大多数瑕疵，大多数情况下，是无法修复&#x2F;无法完全修复&#x2F;无法不具备破坏力部分修复的。多数瑕疵可修复的程度，取决于问题的轻重，rippers水准，以及牺牲的有效细节多寡……
​	阅读本教程前，强烈建议先理解 视频格式的基础知识 中的内容，并在大屏pc上观看（方便看图）
本文中，如果图像看不明显，建议点击单独打开，并缩放到1:1观看。放大版图片使用的是临近采样放大到2x倍，相当于一个像素放大到2×2倍大小，方便大家理解。
本教程中所有图例，除非有说明，否则均来自于动漫蓝光原盘截图。
色带(banding&#x2F;color banding)​	色带是出现频率最多的瑕疵，没有之一。色带产生的原因是精度不足。因为几乎100%的片源采用YUV 8bit编码，而这种编码是不足以达到可视范围精度的极限，所以编码本身的瓶颈，决定了从制作到放源，几乎一定会因为精度不足产生色带。

色带的表现大家应该看得多了，颜色在渐变区域表现为波浪状、环状的阶梯型。常见于暗场处。
去色带一般被叫做deband&#x2F;de-banding
锯齿(aliasing)锯齿是最典型、最常见的线条部分瑕疵，通常是因为制作分辨率较低，且不规范拉升到更高分辨率造成的：

锯齿的处理方式叫做抗锯齿(anti-aliasing, aa)
晕轮&#x2F;振铃(ringing&#x2F;haloing)严格来说这俩是不同的东西，但是表现非常相似，处理时候也通常不区分。它们也是较为典型的线条瑕疵，通常是因为制作分辨率较低，且不规范拉升到更高分辨率，且&#x2F;或 过度锐化造成的：

瑕疵表现为线条周围似乎裹着一层明亮的光晕，如果上图看不出，下图放大版，仔细看线条两侧：

ringing&#x2F;haloing通常和aliasing是伴生的，这在upscale片源中尤其常见。
播放器拉大、锐化等处理（包括madVR的功能），也很容易出现这两种瑕疵。
ringing&#x2F;haloing的处理方法叫做去晕轮(dering&#x2F;de-ringing,  dehalo&#x2F;de-haloing)
MacroBlock&#x2F;blocking(色块)色块一般是严重欠码，或者是视频损坏，导致的图像如网格状凸显，横平竖直:

更严重的大家自己去看各种在线视频就好。上图是LL的演唱会蓝光。
色块一般跟色带共生。解决方法称为去色块(deblock&#x2F;de-blocking)
拉丝&#x2F;横纹(combing)拉丝是指图像中相邻两行错位造成的视觉效果：

​	拉丝的产生，一般是原生隔行扫描(interlaced)的片源，没有经过任何处理（或者部分片段漏了处理），然后在逐行扫描(progressive)的设备上（比如pc显示器）播放的结果。
​	隔行扫描和逐行扫描啥意思啥区别大家不用细究，你只要知道，前者是老技术，后者是新技术，两者之间需要一定步骤做转换，不转换就可能出这种问题。
​	这玩意是你在任何小白向的压制论坛，见到最多的提问：为啥我压制出来的东西播放有横纹？
根据片源类型的不同，处理方式一般有以下几类：
反交错(de-interlacing)&#x2F;场匹配(field-matching)&#x2F;反交卷过带(ivtc)
缟缟(此名称有一定争议，但是vcb-s的发布页看到这个单词，你默认就是下图的效果)缟缟的效果兼具拉丝和锯齿的效果，有其特殊的线条特征：

缟缟的产生是隔行扫描的源，没有先转换为逐行扫描，而是在隔行状态下，用逐行扫描的算法放大的结果。
缟缟按照具体表现及程度有不同的处理方法，统称去缟缟。
鬼影（blending&#x2F;ghosting）排除掉视频本身采用的特效，这里鬼影指的是非正常的帧融合，造成的动态瑕疵（图片自制，其实寒蝉的BD挺适合拿来展示，但是当初我下好准备做BDRip，看了一眼就shift+delete了）：

blending一般是不规范的反交错&#x2F;交卷过带产生，且&#x2F;或者是滥用不可靠的时域处理造成的。
多数情况下无解（比如寒蝉那BDBOX）；少数有规律可循的，一定手段可以还原。一般称为de-blending&#x2F;ghost-removal
颜色越界（overflow&#x2F;underflow）数字图像处理中，数据如同道路上机动车的速度一样，在规章制度下有着严格的范围限定。而颜色溢出则是发生了数据在既定规范下上下溢出的问题。典型的如dal的OP：

黑咕隆咚的，看我变出点纹理细节来：

越界的调整一般需要对数字图像规范有着专业的了解，同时还得熟知中间的变换公式。记为fix overflow&#x2F;underflow
噪点；彩色噪点&#x2F;色度噪点（Noise&#x2F;Grain; chroma noise&#x2F;grain）噪点不多介绍了；这里单独贴一下Chroma平面的噪点，往往表现为噪点本身花花绿绿的：

如果你表示看不出啥，加一张去掉上图中色度噪点的：

一般来说手段就是降噪(de-noise&#x2F;de-grain)。
不讨论特效噪点，就普通数字噪点，降噪本身应该与否，这是被讨论烂的问题。这里简单说一下我个人的一些看法，注意这是很主观的，完全不是什么“普世价值”：
1、噪点的重要性低于有效细节，然而，噪点依旧是组成画面的重要部分，在片源噪点明显时候，定位于中&#x2F;高还原度的BDRip，噪点不应该被一刀切，导致源和成品画风突变；
2、噪点会消耗大量码率这是不争的事实；因此，越是本身细节丰富动态高的视频，且低码率压制，那么降噪的意义越大，因为可以把有限的码率省下来给真正需要的细节。
3、降噪会不可避免的损失有效细节，特别是暗场处，因此，降噪时候，保留有效细节的多寡，是衡量一个ripper降噪水准的重要指标；
4、降噪应该引入视觉的心理学优化，比如说Chroma noise对画风的影响基本是恼人的，应该尽可能去掉；亮处的噪点去掉了对画风影响教低，而暗处较高；降噪应该在人眼不注意的地方强力，在人眼容易注意的地方较轻，等等。
烂边&#x2F;蚊噪(DCT ringing&#x2F;DCT noise)突出一个烂字。是指画面欠码的时候，线条和平面都出现了很脏的观感，似乎线条被一圈絮絮叨叨的脏东西裹着，而平面有噪点的地方，噪点烂的很不规律，伴随着色块很难看：

这种瑕疵是因为现在的视频都是基于DCT(Discrete Cosine Transform，离散余弦变换)的编码。在编码码率严重不足的时候，将一些频率一刀切，就会造成这样的后果。越是早期的视频编码格式越常见。处理一般要求搭配deband&#x2F;deblock&#x2F;denoise进行综合性的处理。
色度色带(Chroma banding)色度色带，特别指色度平面的精度不足。专门把它拉出来说的原因是，随着SBMV技术普及，蓝光加噪带来的效果，就是亮度平面精度不足问题削弱，相比较而言，色度平面问题则凸显。色度色带在目视表现上，跟一般的色带略有区别（下图自制）：

通常来说，表面看不出画面有波浪状的断层，但是颜色过渡很不自然。只有单独拉出UV平面看才发现精度不足：

Chroma banding的处理一般随着正常deband的处理，无非是强化UV平面的力度。
色度锯齿(chroma aliasing)色度锯齿特指色度平面的锯齿，之所以单独说，是因为色度半采样的存在，导致色度平面经常需要被放大缩小（比如转为RGB处理，再转回去做视频），如果缩放不规范，就容易造成色度锯齿：

图放大到两倍：

chroma aliasing的处理方式一般是拆分UV平面的抗锯齿(chroma aa)
色度偏移（chroma shift）色度偏移，指的是色度平面相对亮度平面的错位，通常在极红&#x2F;蓝&#x2F;绿&#x2F;紫处（这四个地方分别是U&#x2F;V极大值或者极小值），线条多了一些重影（下图自制）：

上图是故意将UV左移两个像素。实际蓝光中鲜有这么大尺度的偏移，最多偏移一个像素，效果非常不明显；一般人很难观察到。
Chroma shift一般发生在数字图像处理中，不正确处理Chroma placement(Chroma相对Luma的位移)，造成的后果。修复手段通常叫做fix chroma shift。
色度溢出（chroma bleeding）色度溢出跟色度偏移很像，区别在于色度偏移是有方向的偏移，色度溢出是无方向的扩张（找不到更明显的图了；看不出来就算了吧）：

注意上图线条两侧，可以观察到颜色似乎跟周围饱和度不一致。这是轻度的溢出；失控的如下图（自制）：

整个图线条部分，颜色饱和度都不正常了。
修复手段叫做fix chroma bleeding
重复场（duplicate field）重复场表现为一张图，奇数行和偶数行相同。视觉效果如下（轻音少女横滨演唱会；部分动漫中也有，如K的剧场版）：

通常和锯齿难以区分；但是如果把奇数行和偶数行拆开各自组成一幅图，把图像一分为二，两份图是一样的。
解决方法就是丢掉奇数行或者偶数行，用剩下的缩放到原来高度。记为fix duplicate field。
revertible upscale（可还原拉升）指的是图像明显是放大而来，而放大的算法，可以被精确或者近似的判断出，然后设计逆向，把图像缩回去：

比如这图（局部），线条有大量锯齿，且出现ringing&#x2F;haloing，经验丰富的rippers大致可以判断图像是通过类似Bicubic(sharp&#x3D;-1.0)的算法拉升到1080p的。那么压制之前就可以根据拉升算法本身数学性质，逆向回720p再处理压制。这样的处理比一般性降低到720p来的科学。
一般你见到inverse-upscale&#x2F;de-bilinear&#x2F;de-bicubic之类的，就说明用了这样的手段。
Over Blurring(过度柔化)说简单点就是图像太模糊了。本身分辨率低，然后用柔和的算法给拉上来：

注意这种模糊是全局性的，不是个别镜头&#x2F;个别位置。一般来说图像还没有锯齿&#x2F;ringing之类的问题。
处理手段可以是inverse-upscale，拉回低分辨率，也可以采用主动性锐化(active sharpening)。注意这样的操作属于主观调整。锐化本身是很考验设计的，如何调整强度，设计自适应(adaptive)和保护手段(protective)，来保证不出现过度锐化的瑕疵（比如锯齿，haloing等），都是学问。
锐化一般分为四种：
补偿性锐化（contra-sharp），不属于主观调整，目的是补偿一些修复操作中，损失的细节和锐利度，补偿性锐化后的图像看起来不会比源锐利。补偿性锐化更多作为一些修复操作的保护手段，保护细节纹理不受太多损失。
可控性锐化（controlled sharp），属于主观调整，目的是补偿一些在非极高码率编码下，可能会损失的细节（我知道编码会损失细节，那么在编码之前，我先把容易损失的细节强化一点点，补偿编码的削减），以及在不破坏原盘画风的前提下，改善细节和纹理观感。往往看源和成品，第一眼看上去没啥区别，特别是线条部分；仔细看才发现，一些细微纹理，成品似乎比源还要清晰点。可控性锐化被中文区raw组不约而同地使用，强度不一。
主动性锐化（active sharp），属于主观调整，目的是让成品清晰度明显的高于源，同时几乎不引入过度锐化导致的瑕疵。主动性锐化会破坏原盘本身画风，以此换来主观观感的极大提升。典型的比如date a live第二季度，vcb-s和TUC的合作版BDRip。
过度锐化（over sharp），属于主观调整，相比主动性锐化，结果就是出现大量锯齿&#x2F;ringing等瑕疵。常见于韩国raw组。
这几种锐化我个人的态度：
1、补偿性锐化是画面修复手段，不是主观调整，没有什么争议。
2、过度锐化非常不可取，与其这样不如让观众自己在播放器里调整。
3、可控性锐化和主动性锐化，是锐化强度，从量变到质变（是否引起画风明显改变）的过程。因人而异，也很难说到底什么强度算可控，什么强度算主动。
4、实践证明，在中文区raw组和观众习惯的体积范围(~1GB&#x2F;集)，可控性锐化利大于弊。强度太低，往往编码造成的损失肉眼可见，画面相比片源明显模糊；强度过高则画风改变明显，让多数观众厌恶。所以各组一般都选择一个适中的强度，最大程度的平衡观众满意度，也让BDRip的细节保留和画面观感，能与2GB&#x2F;集的BDRip相媲美。这也是BDRip制作中的一种心理学优化。
晃动(Global Motion&#x2F;pan)通常是在老片翻新过程中，因为镜头&#x2F;胶带位置不固定，导致录制的视频，似乎镜头在不断晃动一样，哪怕是应该静止的场景，都有不规律的、小幅晃动
动态图就不找了。大家自己脑补自己拿着手机，边走边录像的效果。
解决方法一般记为depan。
彩虹（rainbow）Rainbow多出现在早期真人视频中。表现为亮度快速变化的地方，UV似乎像彩虹一般红蓝交织（网上找的图）：

看球拍部位。rainbow的产生是YUV数据作为电磁信号传输过程中，高频的Y信号，因为传输介质不理想，影响到了UV，而产生的后果。如果这时候进行进一步转录，就会把这个问题保留。
B站放的《亮剑》，也有这个问题：战士们背着枪在雪地里走，黑色的枪和白色的雪构成了高频的亮度变化，结果枪身周围出现了红蓝光晕。弹幕一些人吐槽说这枪怎么还带魔法效果……然而我早已看穿了一切┑(￣Д ￣)┍
修复手段一般称为de-rainbow
点状斑纹(dot-crawl):点装斑纹也是传输YUV中，不正确处理导致的问题（wiki上的图）：

Rainbow和Dot-Crawl在一些上古蓝光，甚至是上古TV源中还能发现它们的存在。高清数字时代之后，特别是动漫，几乎找不到了。
解决方法一般记为 Dot-Crawl removal
最后，用两对问答来结束本章科普：问：作为一名ripper，你都干过哪些本末倒置的事情？答：为了看高清高画质，学习视频修复。
问：作为一名收藏党，你都干过哪些本末倒置的事情？答：为了省硬盘，逛vcb-s.com。
WEBPWEBP 是一种衍生自 Google VP8 的图像格式，同时支持有损和无损编码。当使用有损模式，它在相同体积提供比 JPG 图像更好的质量；当使用无损模式，它提供比最佳压缩的 PNG 图像更小的体积。
你可以通过如下方式浏览 WEBP 图像：

如果你使用 Windows XP SP3 或更高版本的 Windows 系统，可以通过安装 Google 官方的小插件实现系统自带图片浏览器与略缩图的原生支持：百度网盘 备用链接 (请安装其中的 WebpCodecSetup.exe)
安装第三方图片浏览器，包括且不限于：
Xnview (Windows only)
Xnview MP (Win&#x2F;Linux&#x2F;Mac)
Honeyview (Windows only)
ACDSee (Windows only)


通过 Google Chrome 浏览器直接打开 WEBP 图像。

番剧相关什么是番剧？
“番剧“是一个外来语词汇，意思为日本连载动画电视剧，属于二次元用户常用语。通常日本每年有四季动画剧，集中在1月、4月、7月、10月的某一个月份播出。因而类似美剧，番剧也是以季为单位，通常每周播出一集，一季12~13集(季番)或23-25集(半年番)居多。
**来源：**番剧一词来源于日语的”番组”，可以算是外来语演变而成。”番组”可以理解为电视节目，在日语中”番组”可以指电视剧，也可以指综艺节目，新闻节目，当然也包括动画。中文里的”番剧”可以理解为是番组电视剧，简称”番剧”，广义上来讲，应该可以理解成电视连续剧，包括了真人和动画的电视连续剧。


番剧分类
**番组:**电视节目，动画片电视连续剧。

**新番:**意指新番剧，每个季度在播中，或者将要播出的番组，都被称为新番。通常，1月新番，4月新番，7月新番，10月新番，分别指在1月、4月、7月、10月开播的新番。

**半年番:**播出持续半年(24话左右)的作品。

**季番:**播出持续一季度(12话左右)的作品。

**里番:**在日本评级为面向较为成年观众的R18+作品，一般不在电视台或深夜档播出。

**表番:**与”里番”相对，指代在日本评级为面向一般年龄观众的作品，内容及题材一般较为纯洁、健康向上。一般治愈番、致郁番和催泪番也属于这一范畴。除此之外，表番一般也指代评价较高，拥有较高人气的作品。
所谓”表”和”里”番都是相对概念。一般，用于定义”表””里”的标准很大程度上取决于节目的人气，但并不绝对。

**泡面番:**一集时间很短的动画，通常在三分钟到六分钟左右不等，相当于泡一杯方便面的时间，等你把泡面泡好了， 动画也完了。

**番外、外番:**有别于主线连续剧的番外篇，有外传的意思，动画的OVA、OAD被归类到外番。

**追番:**在电视上首播一个番剧时，坚持看每一集的首播。

**补番:**看已经播出过的番剧。

**连番：**接连几次，连续多次看。



什么是OV、OVA、OAD等？
OVA（原创光盘动画，Original Video Animation简称），一般指通过DVD，蓝光光盘等以影碟发行的方式为主的剧集，也指一些相较原著篇幅较小且内容不一的动画剧集。

OAD全称Original Animation Disc或者Original Animation，DVD本质上与OVA（Original Video Anime）同义，在DVD等光碟储存媒体普及后的用语。一般在漫画中捆绑发售，媒介包括DVD及Blu-ray Disc。OAD的内容一般为原创，也有将TV版本再编辑后制作而成，看似和在大荧幕上映的剧场版动画一样，其实不一样。

OVD英文意思：光录像盘；视频光盘(Optical Video Disk)。OV、OVA、OAD总称。

OV非动画领域的光盘作品

TV版电视动画（Television animation）一般也叫动画剧，是指在电视频道上播映的动画作品。

剧场版是在影院公映的特摄与动漫作品，是日本特摄与动漫按传播方式分类的一种，在中国又被称为特摄与动画电影。通常片长为90分钟，制作成本一般高于OVA及TV动画。
不论在人物动作的流畅感，还是使用的分色数，甚至每秒的作画张数上，都比电视版动画和原创动画录影带有明显的提升。因此画面精度是三者（剧场版、TV版、OVA版）中最高的。

网络(WEB)版全称“Original Net Anime”，直译为“原创网络动画”又简称为ONA。指的是以通过互联网作为最初或主要发行渠道的动画作品。

PV英文名为Preview Video，即正式专辑或者影像发售之前，预先放松的预告。是MV(music video)在日专本的常见称呼属Promotion Video的略称。有时也被称为music clip或者video clip。其主要指流行音乐的乐曲发表的时候制作的，包含乐曲的影像作品。因为是以促销CD为目的，所以在日本一般被叫做プロモーション・ビデオ (promotion video) ，略称为promo 或者PV的情况也很多见。
「简单的说PV就是一种音乐发行时所制作的同步宣传影像，是一类多媒体作品，现多用于ACG领域。」目前Vocaloid音乐等网络音乐大多都是以PV的形式做专辑宣传。
它与其它音乐视频相比，PV作品使用素材多为原创，而其它视频创作素材使用广泛。一般原创或同人音乐社团包括作曲师、画师、歌姬&#x2F;基、后期制作人员（即pv师），其中还能细分为比如，编曲&amp;演奏&amp;美工等。一部好的PV作品需要长时间精心制作和社团成员共同协助完成；主要目的还是突显音乐气氛和促销CD宣传。

CM一是Commercial Message的缩写
英文解释：a commercially sponsored ad on radio or television 中文解释：商业广播广告，日本的广告领域力，CM被当做广告简称，在其国内广泛应用。
二是Comic Market的缩写
Comiket是日本最大的同人志展会，全称Comic Market（コミックマーケット），是由Comic Market准备会举办的日本以至全球最大型的同人志即卖会。

SP(スッペシャルSpecial的简写)在日本动画中一般正传出完之后因为市场反应很热烈会为了赚钱而推出特别篇，也就是SP，意思就是两个小时左右的特别篇。通常是90分钟到两个小时不等。SP一般只讲一个完整的故事，类似于电影，但是没有电影的手法复杂．日剧是同期拍摄的，边拍边播．每一季接档的空闲时间就播放SP。大多数SP是以前热播剧的一个番外篇，也有的只是独立的小故事，也有的是系列篇。

特典是日文：とくてん的汉字写法，意思是优惠。引申义是特别版，游戏追加的相关周边产品都能算特典，不过一般是指数码内容的例如游戏的图片，声音，视频，也可能追加一些新剧情。再补充一些：就是一些无字幕的OP，ED，TV放映前的CV。一般是OVA里全剧结束后特别附赠的东西，主要有访谈、卡拉OK、原画设定、特别版动画之类。

OP（オープニングテーマ&#x2F;ソング，Opening Theme&#x2F;Song，简称OP）片头曲是电视剧或电视动画剧初播放的乐曲、歌曲（但日本动画和电视剧常在前情提要前或在播放部分正片后）。片头曲动画一般带有职员的文字。片头曲是一部番给人的第一印象，好的片头曲歌词内容紧扣主题，与OP动画节奏吻合，相辅相成，这样的片头曲也会为动画本身带来人气。


sola OP视频截图

ED也被称为（Ending Theme或者Ending Song；日文：エンディングテーマ&#x2F;ソング），是影视业术语，泛指在影视作品（如电视剧，动画片等）正片之后播出的带有人声甚至无人声的歌曲，某些情况下同时也是该部作品的主题曲。片尾曲常被人认为是正片故事的延续，是其风格的彰显，它已经成为影视作品的一个不可或缺的元素。很多动画都会在第一话把OP作为片尾曲播放。

sola ED视频截图

NCOP（Non-Credit Opening，无制作人员字幕开头）发售BD等时则会去除。

sola NCOP视频截图

NCED（Non-Credit Ending，无制作人员字幕结尾）

sola NCED视频截图

IN 指视频里的插曲
OST（Original Sound Track，简称Soundtrack或Sound Track，缩写OST）原声带是将一部电影或一部电视剧的主题曲（或片头片尾曲）和主要的插曲或配乐录一起，制作成一张完整的唱片，然后由唱片公司制成Caart,Dnb,CD或DAT&#x2F;DCC发行。

CLANNAD Original Sound Track CD封面

扩展：Hi10p、BD、X264_flac等
Hi10p指的是H.264编码使用10位深的色彩讯息。Hi10P 和10bit 是意思一样的。而10bit又特指一种回视频编码技术，能够提答供非常高的视频画质，能够在色彩的渐进和变化方面表现出非凡的细腻度，但是能播放10bit的配置要求非常高。
Hi10P编码的优点：
1．低码率（Low Bit Rate）：和MPEG2和MPEG4 ASP等压缩技术相比，在同等图像质量下，采用H.264技术压缩后的数据量只有MPEG2的1&#x2F;8，MPEG4的1&#x2F;3。 
2．高质量的图像：H.264能提供连续、流畅的高质量图像（DVD质量）。
3．容错能力强：H.264提供了解决在不稳定网络环境下容易发生的丢包等错误的必要工具。 
4．网络适应性强：H.264提供了网络抽象层（Network Abstraction Layer），使得H.264的文件能容易地在不同网络上传输（例如互联网，CDMA，GPRS，WCDMA，CDMA2000等）。

BD是指蓝光（Blu－ray）或称蓝光盘（Blu－ray Disc，缩写为BD），目前为止，蓝光是最先进应用最广泛的大容量光碟格式，网上下载的标有BD或者Blu－ray的高清影片，是指直接通过蓝光片源录制的，画面品质比HD和WEB-DL要好。
BDRIP（Blu-ray Disc Rip）即蓝光影碟转录，就是从蓝光光盘上把视频内容重新编码形成的视频文件。画质可能比原盘差一点点。

X264_flac
x264&#x3D;压缩的视频编码方式。flac&#x3D;音频的重编码方式。
附加：FLAC AC3x2&#x3D;三条音频
 1、FLAC音频
 2、AC3音频
 3、AC3音频



扩展：.cue文件.tak文件.opus文件.ehviewer文件等
.cue文件

以CLANNAD Original Sound Track为例，用Notepad++打开其中的.cue文件

实质：纯文本文件
百科：CUE(cuesheet)是指光盘映像(镜像)辅助文件或称标记文件，按照文本文件格式编制。它在刻录光盘映像文件时，起很重要的作用。它可以指挥刻录软件刻什么格式，刻录那些内容，从哪里开始，到哪里结束，附加什么信息等等、等等。有了cue文件，既可以减少刻录的准备工作以提高刻录效率，又可以保证刻录的准确性。更详细一点的可以看这篇文章https://b23.tv/nRRMYZs

.tak文件


.tak文件及用VLC打开（专辑封面是用图片编辑软件加上去）

实质：无损音频文件（编码格式）
百科：TAK是一种无损音频压缩格式，全称是Tom’s Audio Kompressor，产于德国。类似于FLAC和APE，总体来说，压缩率类似APE而且解压缩速度类似FLAC，算是综合了两者的优点。但目前软件支持有限（有限？用VLC就可以打开）。

.opus文件


.opus文件及用MusicPlayer2打开

实质：有损声音编码音频文件（编码格式）
百科：Opus编码器 是一个有损声音编码的格式，由互联网工程任务组(IETF)近来开发Opus 格式是一个开放格式，使用上没有任何专利或限制。

.ehviewer文件


用Notepad++打开.ehviewer文件

实质：纯文本文件
百科：（自己找吧）



来源链接（感谢以下优秀文章或视频）什么是番剧？、番剧分类


https://baike.so.com/doc/23736557-24292454.html
连番一词：https://baike.baidu.com/item/%E7%95%AA%E5%89%A7/17528517


什么是OV、OVA、OAD等？


OVA：https://baike.baidu.com/item/ova/9989
OAD一词：https://zhidao.baidu.com/question/754018613605198244.html
OVD、OV和其它部分内容：BV177411m7ni
TV版、剧场版：https://zhidao.baidu.com/question/602632582.html
网络(WEB)版一词：https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%8A%A8%E7%94%BB/6542913
PV一词：https://zhidao.baidu.com/question/360234748.html
CM一词：https://zhidao.baidu.com/question/421364713.html
SP一词：https://baike.baidu.com/item/%E5%8A%A8%E6%BC%ABSP/15551866
特典一词：https://baike.baidu.com/item/%E7%89%B9%E5%85%B8
OP、ED、NCOP：https://zhidao.baidu.com/question/360353977151434812.html
NCED一词：https://zhidao.baidu.com/question/545257011.html
OP、ED、NCOP、NCED图片：BV1Gs411m7Dj
OST一词：https://baike.baidu.com/item/%E5%8E%9F%E5%A3%B0%E5%B8%A6/1120682


扩展：Hi10p、BD、X264_flac等


Hi10p一词：https://zhidao.baidu.com/question/2009347754951855908.html
BD一词：https://zhidao.baidu.com/question/212528826.html
BDRIP一词：https://baike.so.com/doc/5443852-5682205.html
X264_flac和附加：https://tieba.baidu.com/p/7124754437



扩展：.cue文件.tak文件.opus文件.ehviewer文件等

**.**cue文件一词：https://baike.so.com/doc/7161053-7385063.html
.tak文件一词：https://baike.so.com/doc/5504067-5739811.html
.opus文件一词：https://baike.so.com/doc/10912034-11438562.html
ehviewer：https://github.com/seven332/EhViewer/releases
MusicPlayer2：https://github.com/zhongyang219/MusicPlayer2/

（文中图片除已标出出处外，均是来源于网络收集或本地运行截图储存于本地硬盘）
（如有不完善的地方欢迎在评论区指出）
（最后编辑时间:2022.6.04晚上0时）
第一版：2021.2.26下午3时
第二版：2022.6.04晚上0时
https://vcb-s.com/archives/4738
]]></content>
      <categories>
        <category>知识杂谈</category>
        <category>格式</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>知识杂谈</tag>
        <tag>视频格式</tag>
      </tags>
  </entry>
  <entry>
    <title>第二代身份证号码的编码规则及校验</title>
    <url>/2023/06/25/%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E7%A0%81%E7%9A%84%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99%E5%8F%8A%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[身份证号码的编码规则及校验身份证号码的编码规则身份证号码共18位，由17位本体码和1位校验码组成。

前6位是地址码，表示登记户口时所在地的行政区划代码，依照《中华人民共和国行政区划代码》国家标准（GB&#x2F;T2260）的规定执行；
7到14位是出生年月日，采用YYYYMMDD格式；
15到17位是顺序码，表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编订的顺序号，顺序码的奇数分配给男性，偶数分配给女性，即第17位奇数表示男性，偶数表示女性；
第18位是校验码，采用ISO 7064:1983, MOD 11-2校验字符系统，计算规则下一章节说明。

一代身份证与二代身份证的区别在于：

一代身份证是15位，二代身份证是18位；
一代身份证出生年月日采用YYMMDD格式，二代身份证出生年月日采用YYYYMMDD格式；
一代身份证无校验码，二代身份证有校验码。

校验码计算规则身份证号码中各个位置上的号码字符值应满足下列公式的校验：$$\sum_{i&#x3D;1}^{18}(a\pmb{i} * W\pmb{i})\equiv(mod\ 11)$$

i表示号码字符从右至左包括校验码字符在内的位置序号；

ai 表示第i位置上的号码字符值， a1 是身份证号码第18位校验码；

Wi位置上的加权因子，加权因子计算公式：$$W\pmb{i}&#x3D;2^{i-1}(mod\ 11)$$


样例以370683198901117657这个身份证号为例，根据上述公式进行校验



i
18
17
16
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1



ai
3
7
0
6
8
3
1
9
8
9
0
1
1
1
7
6
5
7


Wi
7
9
10
5
8
4
2
1
6
3
7
9
10
5
8
4
2
1


ai*Wi
21
63
0
30
64
12
2
9
48
27
0
9
10
5
56
24
10
7


将每一位的ai*Wi相加，得到和为390，
将390模除11，得到余数5。根据下方对照表得到对应的数为7，与身份证最后一位相符，至此验证成功。



余数
0
1
2
3
4
5
6
7
8
9
10



对照值
1
0
X
9
8
7
6
5
4
3
2


实际应用在金融行业软件系统中，对于身份证号码的采集、校验用途甚广。

身份证号码前6位，可采集客户户籍所在地，只需将国家标准GB&#x2F;T 2260中定义的行政区划代码导入数据库，程序中进行映射即可；但需要注意的是，行政区划代码每隔几年会修订一次，从笔者手上的2007版来看，共经历了1982年、1984年、1986年、1988年、1991年、1995年、1999年、2002年、2007年九次修订，所以要预留更新机制；
身份证号码7到14位，可采集客户的出生日期、年龄、生日；
身份证号码17位，可采集客户的性别，奇数表示男性，偶数表示女性；
身份证号码的验证渠道，不管验证成功与否，往往都是收费的，比如银行渠道、公安部渠道，在发往这些渠道验证之前，先对其进行长度、正则表达式、校验码的验证，能够适当提高收费验证的成功率，节省成本支出；而且也可以提升用户体验，在用户输入错误时及时反馈而不必等待验证渠道结果的返回。

下面，就以实际代码为例，说明身份证号码校验的方法。首先，给出身份证号码的正则表达式：
/** * 18位二代身份证号码的正则表达式 */public static final String REGEX_ID_NO_18 = &quot;^&quot;        + &quot;\\d&#123;6&#125;&quot; // 6位地区码        + &quot;(18|19|([23]\\d))\\d&#123;2&#125;&quot; // 年YYYY        + &quot;((0[1-9])|(10|11|12))&quot; // 月MM        + &quot;(([0-2][1-9])|10|20|30|31)&quot; // 日DD        + &quot;\\d&#123;3&#125;&quot; // 3位顺序码        + &quot;[0-9Xx]&quot; // 校验码        + &quot;$&quot;;/** * 15位一代身份证号码的正则表达式 */public static final String REGEX_ID_NO_15 = &quot;^&quot;        + &quot;\\d&#123;6&#125;&quot; // 6位地区码        + &quot;\\d&#123;2&#125;&quot; // 年YYYY        + &quot;((0[1-9])|(10|11|12))&quot; // 月MM        + &quot;(([0-2][1-9])|10|20|30|31)&quot; // 日DD        + &quot;\\d&#123;3&#125;&quot;// 3位顺序码        + &quot;$&quot;;

校验身份证号码：
/** * 校验身份证号码 *  * &lt;p&gt; * 适用于18位的二代身份证号码 * &lt;/p&gt; *  * @param IDNo18 身份证号码 * @return true - 校验通过&lt;br&gt; *         false - 校验不通过 * @throws IllegalArgumentException  *             如果身份证号码为空或长度不为18位或不满足身份证号码组成规则 *             &lt;i&gt;6位地址码+ *             出生年月日YYYYMMDD+3位顺序码 *             +0~9或X(x)校验码&lt;/i&gt; */public static boolean checkIDNo(String IDNo18) &#123;    // 校验身份证号码的长度    if (!checkStrLength(IDNo18, 18)) &#123;        throw new IllegalArgumentException();    &#125;    // 匹配身份证号码的正则表达式    if (!regexMatch(IDNo18, REGEX_ID_NO_18)) &#123;        throw new IllegalArgumentException();    &#125;    // 校验身份证号码的验证码    return validateCheckNumber(IDNo18);&#125;/** * 校验字符串长度 *  * @param inputString 字符串 * @param len 预期长度 * @return true - 校验通过&lt;br&gt; *         false - 校验不通过 */private static boolean checkStrLength(String inputString, int len) &#123;    if (inputString == null || inputString.length() != len) &#123;        return false;    &#125;    return true;&#125;/** * 匹配正则表达式 *  * @param inputString 字符串 * @param regex 正则表达式 * @return true - 校验通过&lt;br&gt; *         false - 校验不通过 */private static boolean regexMatch(String inputString, String regex) &#123;    return inputString.matches(regex);&#125;/** * 校验码校验 * &lt;p&gt; * 适用于18位的二代身份证号码 * &lt;/p&gt; *  * @param IDNo18 身份证号码 * @return true - 校验通过&lt;br&gt; *         false - 校验不通过 */private static boolean validateCheckNumber(String IDNo18) &#123;    // 加权因子    int[] W = &#123; 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 &#125;;    char[] IDNoArray = IDNo18.toCharArray();    int sum = 0;    for (int i = 0; i &lt; W.length; i++) &#123;        sum += Integer.parseInt(String.valueOf(IDNoArray[i])) * W[i];    &#125;    // 校验位是X，则表示10    if (IDNoArray[17] == &#x27;X&#x27; || IDNoArray[17] == &#x27;x&#x27;) &#123;        sum += 10;    &#125; else &#123;        sum += Integer.parseInt(String.valueOf(IDNoArray[17]));    &#125;    // 如果除11模1，则校验通过    return sum % 11 == 1;&#125;

计算校验码
/** * 计算身份证号码的校验码 * &lt;p&gt; * 适用于18位的二代身份证号码，身份证号码由17位本体码和1位校验码组成 * &lt;/p&gt; *  * @param masterNumber 本体码 * @return 身份证号码 * @throws IllegalArgumentException  *             如果本体码为空或长度不为17位或不满足本体码组成规则 *             &lt;i&gt;6位地址码+ *             出生年月日YYYYMMDD+3位顺序码&lt;/i&gt; */public static String computeIDNoCheckNumber(String masterNumber) &#123;    // 校验本体码的长度    if (!checkStrLength(masterNumber, 17)) &#123;        throw new IllegalArgumentException();    &#125;    // 匹配本体码的正则表达式    if (!regexMatch(masterNumber, REGEX_MASTER_NUMBER)) &#123;        throw new IllegalArgumentException();    &#125;    // 计算校验码    String checkNumber = computeCheckNumber(masterNumber);    // 返回本体码+校验码=完整的身份证号码    return masterNumber + checkNumber;&#125;/** * 计算校验码 * &lt;p&gt; * 适用于18位的二代身份证号码 * &lt;/p&gt; *  * @param masterNumber 本体码 * @return 校验码 */private static String computeCheckNumber(String masterNumber) &#123;    // 加权因子    int[] W = &#123; 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 &#125;;    char[] masterNumberArray = masterNumber.toCharArray();    int sum = 0;    for (int i = 0; i &lt; W.length; i++) &#123;        sum += Integer.parseInt(String.valueOf(masterNumberArray[i])) * W[i];    &#125;    // 根据同余定理得到的校验码数组    String[] checkNumberArray = &#123; &quot;1&quot;, &quot;0&quot;, &quot;X&quot;, &quot;9&quot;, &quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;, &quot;4&quot;,            &quot;3&quot;, &quot;2&quot; &#125;;    // 得到校验码    String checkNumber = checkNumberArray[sum % 11];    // 返回校验码    return checkNumber;&#125;

虽然15位的一代身份证已经停用，但是难免有需要用到将15位的一代身份证升级为18位的二代身份证的情形，代码示例如下：
/** * 15位一代身份证号码升级18位二代身份证号码 * &lt;p&gt; * 为15位的一代身份证号码增加年份的前2位和最后1位校验码 * &lt;/p&gt; *  * @param IDNo15 15位的一代身份证号码 * @return 18位的二代身份证号码 */public static String updateIDNo15to18(String IDNo15) &#123;    // 校验身份证号码的长度    if (!checkStrLength(IDNo15, 15)) &#123;        throw new IllegalArgumentException();    &#125;    // 匹配身份证号码的正则表达式    if (!regexMatch(IDNo15, REGEX_ID_NO_15)) &#123;        throw new IllegalArgumentException();    &#125;    // 得到本体码，因一代身份证皆为19XX年生人，年份中增加19，组成4位    String masterNumber = IDNo15.substring(0, 6) + &quot;19&quot; + IDNo15.substring(6);    // 计算校验码    String checkNumber = computeCheckNumber(masterNumber);    // 返回本体码+校验码=完整的身份证号码    return masterNumber + checkNumber;&#125;







最后 来个合集
package com.godson.util;import java.math.BigInteger;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * ISO7064工具类 * &lt;p&gt; * 使用ISO7064规范中定义的校验字符系统进行字符串的校验以及生成校验字符 * &lt;/p&gt; *  */public class ISO7064Util &#123;    /**     * ISO7064规范中定义的校验字符系统     * &lt;p&gt;     * &lt;li&gt;ISO 7064, MOD 11-2使用 &#123;@link #ISO_7064_MOD_11_2&#125;表示     * &lt;/li&gt;     * &lt;li&gt;ISO 7064, MOD 37-2使用&#123;@link #ISO_7064_MOD_37_2&#125;表示&lt;/li&gt;     * &lt;li&gt;ISO 7064, MOD 97-10使用&#123;@link #ISO_7064_MOD_97_10&#125;     * 表示&lt;/li&gt;     * &lt;li&gt;     * ISO 7064, MOD 661-26使用 &#123;@link #ISO_7064_MOD_661_26&#125;表示     * &lt;/li&gt;     * &lt;li&gt;ISO 7064, MOD 1271-36使用     * &#123;@link #ISO_7064_MOD_1271_36&#125;表示&lt;/li&gt;     * &lt;li&gt;ISO 7064, MOD 11,10使用     * &#123;@link #ISO_7064_MOD_11_HYBRID_10&#125;表示&lt;/li&gt;     * &lt;li&gt;ISO 7064, MOD 27,26使用     * &#123;@link #ISO_7064_MOD_27_HYBRID_26&#125;表示&lt;/li&gt;     * &lt;li&gt;ISO 7064, MOD 37,36使用     * &#123;@link #ISO_7064_MOD_37_HYBRID_36&#125;表示&lt;/li&gt;     */    public enum Designation &#123;        /** ISO 7064, MOD 11-2 */        ISO_7064_MOD_11_2,        /** ISO 7064, MOD 37-2 */        ISO_7064_MOD_37_2,        /** ISO 7064, MOD 97-10 */        ISO_7064_MOD_97_10,        /** ISO 7064, MOD 661-26 */        ISO_7064_MOD_661_26,        /** ISO 7064, MOD 1271-36 */        ISO_7064_MOD_1271_36,        /** ISO 7064, MOD 11,10 */        ISO_7064_MOD_11_HYBRID_10,        /** ISO 7064, MOD 27,26 */        ISO_7064_MOD_27_HYBRID_26,        /** ISO 7064, MOD 37,36 */        ISO_7064_MOD_37_HYBRID_36    &#125;    /**     * 计算校验字符     *      * @param withoutCheckCharacterString 不含校验字符的字符串     * @param designation 校验字符系统     * @return 校验字符     * @throws IllegalArgumentException     *             如果字符串不匹配对应校验字符系统的正则表达式     */    public static String computeCheckCharacter(            String withoutCheckCharacterString, Designation designation) &#123;        // 检查字符串是否匹配对应校验字符系统的正则表达式        if (!RegexMatcher.withoutCheckCharacterStringIsMatch(                withoutCheckCharacterString, designation)) &#123;            throw new IllegalArgumentException();        &#125;        // 计算校验字符        return CheckCharacterComputor.compute(withoutCheckCharacterString,                designation);    &#125;    /**     * 校验字符串     *      * @param withCheckCharacterString 含校验字符的字符串     * @param designation 校验字符系统     * @return true - 校验通过&lt;br&gt;     *         false-校验不通过     * @throws IllegalArgumentException     *             如果字符串不匹配对应校验字符系统的正则表达式     */    public static boolean checkString(String withCheckCharacterString,            Designation designation) &#123;        // 检查字符串是否匹配对应校验字符系统的正则表达式        if (!RegexMatcher.withCheckCharacterStringIsMatch(                withCheckCharacterString, designation)) &#123;            throw new IllegalArgumentException();        &#125;        // 校验字符串        return CheckCharacterSystemValidator.validate(withCheckCharacterString,                designation);    &#125;    /**     * 正则表达式匹配器     * &lt;p&gt;     * 检查字符串是否匹配对应校验字符系统的正则表达式     * &lt;/p&gt;     * &lt;table border=&quot;1&quot;&gt;     * &lt;tr&gt;     * &lt;th&gt;系统名称&lt;/th&gt;     * &lt;th&gt;适用范围&lt;/th&gt;     * &lt;th&gt;校验码数目及类型&lt;/th&gt;     * &lt;/tr&gt;     * &lt;tr&gt;     * &lt;td&gt;ISO 7064, MOD 11-2&lt;/td&gt;     * &lt;td&gt;数字&lt;/td&gt;     * &lt;td&gt;1位数字或附加符X&lt;/td&gt;     * &lt;/tr&gt;     * &lt;tr&gt;     * &lt;td&gt;ISO 7064, MOD 37-2&lt;/td&gt;     * &lt;td&gt;字母数字&lt;/td&gt;     * &lt;td&gt;1位数字或字母或附加符*&lt;/td&gt;     * &lt;/tr&gt;     * &lt;tr&gt;     * &lt;td&gt;ISO 7064, MOD 97-10&lt;/td&gt;     * &lt;td&gt;数字&lt;/td&gt;     * &lt;td&gt;2位数字&lt;/td&gt;     * &lt;/tr&gt;     * &lt;tr&gt;     * &lt;td&gt;ISO 7064, MOD 661-26&lt;/td&gt;     * &lt;td&gt;字母&lt;/td&gt;     * &lt;td&gt;2位字母&lt;/td&gt;     * &lt;/tr&gt;     * &lt;tr&gt;     * &lt;td&gt;ISO 7064, MOD 1271-36&lt;/td&gt;     * &lt;td&gt;字母数字&lt;/td&gt;     * &lt;td&gt;2位数字或字母&lt;/td&gt;     * &lt;/tr&gt;     * &lt;tr&gt;     * &lt;td&gt;ISO 7064, MOD 11,10&lt;/td&gt;     * &lt;td&gt;数字&lt;/td&gt;     * &lt;td&gt;1位数字&lt;/td&gt;     * &lt;/tr&gt;     * &lt;tr&gt;     * &lt;td&gt;ISO 7064, MOD 27,26&lt;/td&gt;     * &lt;td&gt;字母&lt;/td&gt;     * &lt;td&gt;1位字母&lt;/td&gt;     * &lt;/tr&gt;     * &lt;tr&gt;     * &lt;td&gt;ISO 7064, MOD 37,36&lt;/td&gt;     * &lt;td&gt;字母数字&lt;/td&gt;     * &lt;td&gt;1位数字或字母&lt;/td&gt;     * &lt;/tr&gt;     * &lt;/table&gt;     */    private static class RegexMatcher &#123;        /**         * 检查不含校验字符的字符串是否匹配对应校验字符系统的正则表达式         *          * @param withoutCheckCharacterString 不含校验字符的字符串         * @param designation 校验字符系统         * @return true - 匹配&lt;br&gt;         *         false - 不匹配         */        static boolean withoutCheckCharacterStringIsMatch(                String withoutCheckCharacterString, Designation designation) &#123;            return regexMatch(withoutCheckCharacterString,                    REGEX_MAPPING_WITHOUT_CHECK_CHARACTER_STRING                            .get(designation));        &#125;        /**         * 检查有校验字符的字符串是否匹配对应校验字符系统的正则表达式         *          * @param withCheckCharacterString 含校验字符的字符串         * @param designation 校验字符系统         * @return true - 匹配&lt;br&gt;         *         false - 不匹配         */        static boolean withCheckCharacterStringIsMatch(                String withCheckCharacterString, Designation designation) &#123;            return regexMatch(withCheckCharacterString,                    REGEX_MAPPING_WITH_CHECK_CHARACTER_STRING.get(designation));        &#125;        /** 数字正则表达式 */        static final String REGEX_NUMBERIC_STRINGS = &quot;^[0-9]+$&quot;;        /** 含补充校验字符X的数字正则表达式 */        static final String REGEX_NUMBERIC_STRINGS_WITH_SUPPLEMENTARY_CHECK_CHARACTER = &quot;^[0-9]+[0-9X]$&quot;;        /** 字母正则表达式 */        static final String REGEX_ALPHABETIC_STRINGS = &quot;^[A-Z]+$&quot;;        /** 字母数字正则表达式 */        static final String REGEX_ALPHANUMBERIC_STRINGS = &quot;^[0-9A-Z]+$&quot;;        /** 含补充校验字符*的字母数字表达式 */        static final String REGEX_ALPHANUMBERIC_STRINGS_WITH_SUPPLEMENTARY_CHECK_CHARACTER = &quot;^[0-9A-Z]+[0-9A-Z*]$&quot;;        /** 校验字符系统对应的正则表达式（不含校验字符） */        @SuppressWarnings(&quot;serial&quot;)        static final Map&lt;Designation, String&gt; REGEX_MAPPING_WITHOUT_CHECK_CHARACTER_STRING = new HashMap&lt;Designation, String&gt;() &#123;            &#123;                put(Designation.ISO_7064_MOD_11_2, REGEX_NUMBERIC_STRINGS);                put(Designation.ISO_7064_MOD_37_2, REGEX_ALPHANUMBERIC_STRINGS);                put(Designation.ISO_7064_MOD_97_10, REGEX_NUMBERIC_STRINGS);                put(Designation.ISO_7064_MOD_661_26, REGEX_ALPHABETIC_STRINGS);                put(Designation.ISO_7064_MOD_1271_36,                        REGEX_ALPHANUMBERIC_STRINGS);                put(Designation.ISO_7064_MOD_11_HYBRID_10,                        REGEX_NUMBERIC_STRINGS);                put(Designation.ISO_7064_MOD_27_HYBRID_26,                        REGEX_ALPHABETIC_STRINGS);                put(Designation.ISO_7064_MOD_37_HYBRID_36,                        REGEX_ALPHANUMBERIC_STRINGS);            &#125;        &#125;;        /** 校验字符系统对应的正则表达式（含校验字符） */        @SuppressWarnings(&quot;serial&quot;)        static final Map&lt;Designation, String&gt; REGEX_MAPPING_WITH_CHECK_CHARACTER_STRING = new HashMap&lt;Designation, String&gt;() &#123;            &#123;                put(Designation.ISO_7064_MOD_11_2,                        REGEX_NUMBERIC_STRINGS_WITH_SUPPLEMENTARY_CHECK_CHARACTER);                put(Designation.ISO_7064_MOD_37_2,                        REGEX_ALPHANUMBERIC_STRINGS_WITH_SUPPLEMENTARY_CHECK_CHARACTER);                put(Designation.ISO_7064_MOD_97_10, REGEX_NUMBERIC_STRINGS);                put(Designation.ISO_7064_MOD_661_26, REGEX_ALPHABETIC_STRINGS);                put(Designation.ISO_7064_MOD_1271_36,                        REGEX_ALPHANUMBERIC_STRINGS);                put(Designation.ISO_7064_MOD_11_HYBRID_10,                        REGEX_NUMBERIC_STRINGS);                put(Designation.ISO_7064_MOD_27_HYBRID_26,                        REGEX_ALPHABETIC_STRINGS);                put(Designation.ISO_7064_MOD_37_HYBRID_36,                        REGEX_ALPHANUMBERIC_STRINGS);            &#125;        &#125;;        static boolean regexMatch(String inputString, String regex) &#123;            Pattern pattern = Pattern.compile(regex);            Matcher matcher = pattern.matcher(inputString);            return matcher.matches();        &#125;    &#125;    /** 适用于数字的校验字符系统的数值对应表 */    private static final String[] NUMBERIC_STRINGS = &#123; &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;,            &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;X&quot; &#125;;    /** 适用于字母的校验字符系统的数值对应表 */    private static final String[] ALPHABETIC_STRINGS = &#123; &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;,            &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;,            &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot; &#125;;    /** 适用于字母数字的校验字符系统的数值对应表 */    private static final String[] ALPHANUMBERIC_STRINGS = &#123; &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;,            &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;,            &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;,            &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;*&quot; &#125;;    /**     * 校验字符系统验证器     */    private static class CheckCharacterSystemValidator &#123;        static boolean validate(String inputString, Designation designation) &#123;            switch (designation) &#123;                case ISO_7064_MOD_11_2:                case ISO_7064_MOD_37_2:                case ISO_7064_MOD_97_10:                case ISO_7064_MOD_661_26:                case ISO_7064_MOD_1271_36:                    return validatePureSystem(inputString, designation);                case ISO_7064_MOD_11_HYBRID_10:                case ISO_7064_MOD_27_HYBRID_26:                case ISO_7064_MOD_37_HYBRID_36:                    return validateHybridSystem(inputString, designation);                default:                    return false;            &#125;        &#125;        /**         * 纯系统校验         */        static boolean validatePureSystem(String inputString,                Designation designation) &#123;            int M = 0; // 模数            int r = 0; // 基数            List&lt;String&gt; mapping = null;            switch (designation) &#123;                case ISO_7064_MOD_11_2:                    M = 11;                    r = 2;                    mapping = Arrays.asList(NUMBERIC_STRINGS);                    break;                case ISO_7064_MOD_37_2:                    M = 37;                    r = 2;                    mapping = Arrays.asList(ALPHANUMBERIC_STRINGS);                    break;                case ISO_7064_MOD_97_10:                    M = 97;                    r = 10;                    mapping = Arrays.asList(NUMBERIC_STRINGS);                    break;                case ISO_7064_MOD_661_26:                    M = 661;                    r = 26;                    mapping = Arrays.asList(ALPHABETIC_STRINGS);                    break;                case ISO_7064_MOD_1271_36:                    M = 1271;                    r = 36;                    mapping = Arrays.asList(ALPHANUMBERIC_STRINGS);                    break;                default:                    return false;            &#125;            char[] strArray = inputString.toCharArray();            int S = 0;            int n = strArray.length;            for (int i = 1; i &lt;= n; i++) &#123;                // 注意这里不要使用Math的pow方法                S += mapping.indexOf(String.valueOf(strArray[i - 1]))                        * BigInteger.valueOf(r).pow(n - i)                                .mod(BigInteger.valueOf(M)).intValue();            &#125;            return S % M == 1;        &#125;        /**         * 混合系统校验         */        static boolean validateHybridSystem(String inputString,                Designation designation) &#123;            int M = 0; // 模数1            List&lt;String&gt; mapping = null;            switch (designation) &#123;                case ISO_7064_MOD_11_HYBRID_10:                    M = 10;                    mapping = Arrays.asList(NUMBERIC_STRINGS);                    break;                case ISO_7064_MOD_27_HYBRID_26:                    M = 26;                    mapping = Arrays.asList(ALPHABETIC_STRINGS);                    break;                case ISO_7064_MOD_37_HYBRID_36:                    M = 36;                    mapping = Arrays.asList(ALPHANUMBERIC_STRINGS);                    break;                default:                    return false;            &#125;            int Mplus1 = M + 1; // 模数2            char[] strArray = inputString.toCharArray();            int S = M + mapping.indexOf(String.valueOf(strArray[0]));            int P = 0;            for (int i = 1; i &lt; strArray.length; i++) &#123;                P = ((S % M == 0 ? M : S % M) * 2) % Mplus1;                S = P + mapping.indexOf(String.valueOf(strArray[i]));            &#125;            return S % M == 1;        &#125;    &#125;    /**     * 校验字符生成器     */    private static class CheckCharacterComputor &#123;        static String compute(String inputString, Designation designation) &#123;            switch (designation) &#123;                case ISO_7064_MOD_11_2:                case ISO_7064_MOD_37_2:                    return polynomialMethod4PureSystemWith1CheckChar(                            inputString, designation);                case ISO_7064_MOD_97_10:                case ISO_7064_MOD_661_26:                case ISO_7064_MOD_1271_36:                    return polynomialMethod4PureSystemWith2CheckChar(                            inputString, designation);                case ISO_7064_MOD_11_HYBRID_10:                case ISO_7064_MOD_27_HYBRID_26:                case ISO_7064_MOD_37_HYBRID_36:                    return recursiveMethod4HybridSystemWith1CheckChar(                            inputString, designation);                default:                    return null;            &#125;        &#125;        /**         * 通过多项式法计算纯系统一位校验字符         */        static String polynomialMethod4PureSystemWith1CheckChar(String str,                Designation designation) &#123;            int M = 0; // 模数            int r = 0; // 基数            List&lt;String&gt; mapping = null;            switch (designation) &#123;                case ISO_7064_MOD_11_2:                    M = 11;                    r = 2;                    mapping = Arrays.asList(NUMBERIC_STRINGS);                    break;                case ISO_7064_MOD_37_2:                    M = 37;                    r = 2;                    mapping = Arrays.asList(ALPHANUMBERIC_STRINGS);                    break;                default:                    break;            &#125;            char[] strArray = str.toCharArray();            int S = 0;            int n = strArray.length + 1;            for (int i = n; i &gt;= 2; i--) &#123;                // 注意这里不要使用Math的pow方法                S += mapping.indexOf(String.valueOf(strArray[n - i]))                        * BigInteger.valueOf(r).pow(i - 1)                                .mod(BigInteger.valueOf(M)).intValue();            &#125;            return mapping.get((M + 1 - S % M) % M);        &#125;        /**         * 通过多项式法计算纯系统二位校验字符         */        static String polynomialMethod4PureSystemWith2CheckChar(String str,                Designation designation) &#123;            int M = 0; // 模数            int r = 0; // 基数            List&lt;String&gt; mapping = null;            switch (designation) &#123;                case ISO_7064_MOD_97_10:                    M = 97;                    r = 10;                    mapping = Arrays.asList(NUMBERIC_STRINGS);                    break;                case ISO_7064_MOD_661_26:                    M = 661;                    r = 26;                    mapping = Arrays.asList(ALPHABETIC_STRINGS);                    break;                case ISO_7064_MOD_1271_36:                    M = 1271;                    r = 36;                    mapping = Arrays.asList(ALPHANUMBERIC_STRINGS);                    break;                default:                    break;            &#125;            char[] strArray = str.toCharArray();            int S = 0;            int n = strArray.length + 2;            for (int i = n; i &gt;= 3; i--) &#123;                // 注意这里不要使用Math的pow方法                S += mapping.indexOf(String.valueOf(strArray[n - i]))                        * BigInteger.valueOf(r).pow(i - 1)                                .mod(BigInteger.valueOf(M)).intValue();            &#125;            return mapping.get(((M + 1 - S % M) % M) / r)                    + mapping.get(((M + 1 - S % M) % M) % r);        &#125;        /**         * 通过递归法法计算混合系统一位校验字符         */        static String recursiveMethod4HybridSystemWith1CheckChar(                String inputString, Designation designation) &#123;            int M = 0; // 模数1            List&lt;String&gt; mapping = null;            switch (designation) &#123;                case ISO_7064_MOD_11_HYBRID_10:                    M = 10;                    mapping = Arrays.asList(NUMBERIC_STRINGS);                    break;                case ISO_7064_MOD_27_HYBRID_26:                    M = 26;                    mapping = Arrays.asList(ALPHABETIC_STRINGS);                    break;                case ISO_7064_MOD_37_HYBRID_36:                    M = 36;                    mapping = Arrays.asList(ALPHANUMBERIC_STRINGS);                    break;                default:                    break;            &#125;            int Mplus1 = M + 1; // 模数2            char[] strArray = inputString.toCharArray();            int S = 0;            int P = M;            int n = strArray.length + 1;            for (int i = n; i &gt;= 2; i--) &#123;                S = P + mapping.indexOf(String.valueOf(strArray[n - i]));                P = ((S % M == 0 ? M : S % M) * 2) % Mplus1;            &#125;            return mapping.get((M + 1 - P % M) % M);        &#125;    &#125;&#125;





算法设想
由一个字母作为开头，用于区分物品大类别。该字母区分大小写，对于字母的转换公式为：
如果这个字母是大写的，则分别对应1、2、3、…、26；
如果这个字母是大写的，则分别对应27、28、29、…、52。


第二位是一个字母，与第一位一样，区分大小写，用于表明小类别。包括不限于：（具体对应规则待定）
单片机相关
芯片
贴片原件
电池
电路板


第三位到第五位为纯数字。从001起，截止999。
第六到第十位比较特殊：
对于收纳盒指示而言，这五位可以缺省。
对于物品来说，这五位不可缺省，范围是00001-99999。
对于第五位和第六位之间使用连字符-作为连接，但这一位只作为区分，不参与校验运算。


第六位&#x2F;第十一位为校验码，用于校验数据。

样例
对于外部收纳部分：AA001X
对于物品部分：AA001X-00001

校验方法与身份证校验类似，字母位要转换成对应的数字然后参与运算。
]]></content>
      <categories>
        <category>程序片段</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>编码规则</tag>
        <tag>程序片段</tag>
      </tags>
  </entry>
  <entry>
    <title>One-KVM Docker应用扩展</title>
    <url>/2024/01/14/%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E_One-KVM%20Docker%E5%BA%94%E7%94%A8%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[One-KVM Docker应用扩展总览：
安装OpenWRT（Docker版）
安装Casaos
安装Docker玩客云内部储存空间为8G，如果要使用Docker应用请注意储存空间使用情况。
本文所写Docker应用无需额外设置都可以与PiKVM共存，不必为此修改PiKVM配置文件。
#解决docker无法启动报错的问题，系统使用默认nftables代替了iptables，下面两行将iptables命令替换为原始版本的iptablessudo update-alternatives --set iptables /usr/sbin/iptables-legacysudo update-alternatives --set ip6tables /usr/sbin/ip6tables-legacy#安装Dockerapt install docker.io

安装docker-compose#!/bin/bash# 定义安装函数install_docker_compose() &#123;    # 获取系统类型和架构    OS_NAME=$(uname -s | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;)    OS_ARCH=$(uname -m)    # 特定架构的处理    if [ &quot;$OS_ARCH&quot; == &quot;x86_64&quot; ]; then        OS_ARCH=&quot;amd64&quot;    elif [ &quot;$OS_ARCH&quot; == &quot;armv7l&quot; ]; then        OS_ARCH=&quot;armv7&quot;    elif [ &quot;$OS_ARCH&quot; == &quot;aarch64&quot; ]; then        OS_ARCH=&quot;arm64&quot;    else        echo &quot;不支持的架构: $OS_ARCH&quot;        exit 1    fi    # 构建下载 URL    DOWNLOAD_URL=&quot;https://mirror.ghproxy.com/https://github.com/docker/compose/releases/download/$(curl -s https://api.github.com/repos/docker/compose/releases/latest | jq &#x27;.tag_name&#x27; | tr -d &#x27;&quot;&#x27;)/docker-compose-$&#123;OS_NAME&#125;-$&#123;OS_ARCH&#125;&quot;    # 下载并安装 Docker Compose    echo &quot;正在下载 Docker Compose...&quot;    sudo curl -L $&#123;DOWNLOAD_URL&#125; -o /usr/local/bin/docker-compose        # 添加执行权限    sudo chmod +x /usr/local/bin/docker-compose    # 测试安装    echo &quot;Docker Compose 安装完成。版本信息：&quot;    docker-compose version&#125;# 定义卸载函数uninstall_docker_compose() &#123;    # 卸载 Docker Compose    echo &quot;正在卸载 Docker Compose...&quot;    sudo rm -f /usr/local/bin/docker-compose    echo &quot;Docker Compose 已卸载。&quot;&#125;# 主逻辑case &quot;$1&quot; in    install)        install_docker_compose        ;;    uninstall)        uninstall_docker_compose        ;;    *)        echo &quot;使用方法: $0 &#123;install|uninstall&#125;&quot;        ;;esac

添加执行权限：chmod +x docker_compose_manager.sh
.&#x2F;docker_compose_manager.sh install
.&#x2F;docker_compose_manager.sh uninstall
玩客云安装OpenWRT（Docker版）系统环境：Armbian 22.11.0-trunk Jammy Linux onecloud 5.10.149-meson
Docker版本：Docker version 24.0.5, build 24.0.5-0ubuntu1~22.04.1
OpenWRT默认账号和密码：root&#x2F;root
效果演示![img](.&#x2F;Image&#x2F;One-KVM Docker应用扩展.assets&#x2F;1705214673188-6.png)
![img](.&#x2F;Image&#x2F;One-KVM Docker应用扩展.assets&#x2F;1705214673170-1.png)
安装命令#打开网卡混杂模式ip link set eth0 promisc on#subnet为玩客云所在网段，gateway为主路由地址docker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 -o parent=eth0 macnet#Docker换源nano /etc/docker/daemon.json&#123;&quot;registry-mirrors&quot;:[&quot;https://hub-mirror.c.163.com/&quot;,&quot;https://docker.mirrors.ustc.edu.cn/&quot;]&#125;#拉取OpenWRT的Docker镜像docker pull dreamwsbg/openwrt:9.0docker run -d --name=&quot;openwrt&quot; --restart unless-stopped --network macnet --privileged dreamwsbg/openwrt:9.0 /sbin/init#进入容器内部docker exec -it openwrt bash#修改添加OpenWRT网络设置（括号记得删掉）nano /etc/config/networkoption ipaddr &#x27;192.168.1.5&#x27; （oenpwrt地址）option gateway &#x27;192.168.1.1&#x27; (网关)option broadcast &#x27;192.168.1.255&#x27;option dns &#x27;192.168.1.1&#x27; (dns)#使网络修改生效 /etc/init.d/network restart 

![img](.&#x2F;Image&#x2F;One-KVM Docker应用扩展.assets&#x2F;1705214673170-2.png)
解决一些问题OpenWRT ttyd设置接口”未指定”即可使用网页终端
![img](.&#x2F;Image&#x2F;One-KVM Docker应用扩展.assets&#x2F;1705214673170-3.png)
安装Casaos效果演示![img](.&#x2F;Image&#x2F;One-KVM Docker应用扩展.assets&#x2F;1705214673171-4.png)
![img](.&#x2F;Image&#x2F;One-KVM Docker应用扩展.assets&#x2F;1705214673171-5.png)
安装命令CasaOS官网：CasaOS - A simple, easy-to-use, elegant open-source personal cloud system
建议先按照此文章开始部分提前安装好Docker，因为脚本自带的Docker安装程序没有修改iptables会导致Docker安装失败。
curl -fsSL https://get.casaos.io | sudo bash

参考资料【2023.10.13】玩客云docker下刷openwrt-迅雷玩客云、京东云等各种云设备-恩山无线论坛
玩客云刷Armbian，安装docker+CasaOS+OpenWrt
]]></content>
      <categories>
        <category>玩客云</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>玩客云</tag>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title>One-KVM FAQ和故障排除</title>
    <url>/2024/01/14/%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E_One-KVM%20FAQ%E5%92%8C%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/</url>
    <content><![CDATA[One-KVM FAQ和故障排除说明如果你遇到任何问题，你可以检查这个页面，它会列出常见的错误。如果这仍然没有帮助你，欢迎你提出问题或加入我们的交流群寻求进一步的帮助。
Github地址：https://github.com/mofeng-git/One-KVM （欢迎点个Star）
QQ交流群：569514148 （One-KVM交流群）
常见问题玩客云上的PiKVM支持哪些功能？不支持哪些功能？


功能
One-KVM
TinyPilot 社区版本
PiKVMv3版本



HTML5界面
简体中文
英文
英文


BIOS级访问
√
√
√


视频捕捉
√
√
√


音频捕捉
×
√
√


鼠键捕获
√
√
√


从剪贴板粘贴
√
√
√


OCR识别
√
×
√


基于密码的身份验证
√
需升级Pro
√


LAN唤醒
√
需升级Pro
√


从WebUI更新
×
√
×


VNC支持
√
×
√


挂载虚拟驱动器
√
需升级Pro
√


ATX开关机
√
×
√


WiFi
×
√
√


串行接口
×
×
√


视频流格式
MJPEG
MJPEG, H.264
MJPEG, H.264


视频分辨率
1920x1080
1920x1080
1920x1080


PiKVM官方的功能说明文档在哪？ 如果您需要对功能进行高级配置，非常建议查阅官方文档，官方项目文档的的FAQ和功能配置讲解非常详细，包含示例易于上手。官方文档（英文）：PiKVM Handbook。
能进去网页但网页黑屏如何解决？网页视频黑屏提示无No Singal，请检查采集卡硬件是否受支持、是否正确连接、是否松动；

网页端黑屏无任何画面或是彩色竖条，请检查是否有被控机HDMI信号输入；

进系统画面显示正常，BIOS界面黑屏或渲染异常，请在BIOS界面开启CMS兼容模式；

网页画面显示片刻黑屏，刷新网页重复此现象，请使用火狐浏览器或修改kvmd主配置文件使用yuyv格式。

如果以上情况都不符合请尝试重启玩客云自动复位。

为什么网页视频感觉非常卡顿？视频流输出配置中采用了yuyv格式。mjpeg格式可以实现1080p30帧或720p60帧，但占用带宽非常大（峰值50mbps左右），yuyv格式更加稳定但帧率较低（1080p5fps或720p10fps、峰值10mbps左右）。在浏览器中使用mjpeg视频流非常容易黑屏，仅火狐浏览器使用mjpeg格式的视频流不会出现黑屏现象。

**提示使用体验的方法**：使用mjpeg格式，选择火狐浏览器，使用720p60帧或1080p30帧，右上角sysytem调整至最大帧率。针对1080p屏幕1080p画质远控请全屏使用，720p请点击网页视频右上角的“•”自动缩放画面与原画面分辨率相同。演示图为3终端720p60fps演示效果：

![img](.&#x2F;Image&#x2F;One-KVM FAQ和故障排除.assets&#x2F;1705214473639-4.png)
如何在公网中访问局域网的One-KVM？如果您的路由器有公网IP地址，您可以直接使用端口映射转发443端口。在其他情况下，您可以使用内网穿透服务（如Tailscale），只需几个简单的命令即可在One-KVM上配置。

如何修改软件端口和账户密码？修改端口请编辑 /etc/kvmd/nginx/目录下的conf后缀文件将相关端口修改所需端口（443是网页运行的端口），然后运行systemctl restart kvmd kvmd-nginx 生效。

修改账号密码示例：

   #添加用户 请将silentwind替换为你的用户名kvmd-htpasswd set silentwind#输入密码#删除用户kvmd-htpasswd del admin#列出所有用户kvmd-htpasswd list#重启服务，使修改立刻生效systemctl restart kvmd kvmd-nginx

如何给One-KVM设置静态IP？使用终端图形化工具armbain-config。

示例：armbain-config  Network--&gt;IP--&gt;eth0--&gt;Static

![img](.&#x2F;Image&#x2F;One-KVM FAQ和故障排除.assets&#x2F;1705214473631-1.png)
我可以使用One-KVM进行游戏或是刷剧吗？不能，因HDMI-USB采集卡的视频帧率（最高1080p30fps）无法满足游戏要求，且没有音频。

One-KVM可以传输4K视频吗？对于USB采集设备将原视频画面采样到更小的分辨率以满足USB 2.0带宽限制，因此源可能是4k，但网友视频流不会。4K的实时视频无论如何都不适合通过网络。

光标&#x2F;视频延迟来自哪里？这是将图像传输到浏览器或VNC客户端的过程：采集设备-&gt;压缩-&gt;网络-&gt;解压-&gt;渲染，延迟大概100-200ms。

我可以在移动设备上使用One-KVM上吗？是的，但WEB界面可能无法正常操控，所以在移动设备上推荐使用VNC应用程序，请注意不要使用不兼容的RealVNC。

如何添加自己的SSL证书？如果您有证书（制作证书超出了PiKVM的范围-请参考OpenSSL留档或使用Let&#39;s Encrypt），请替换 /etc/kvmd/nginx/ssl中的密钥，必要时编辑 /etc/kvmd/nginx/ssl.conf并重新启动kvmd-nginx服务。

当我尝试访问 One-KVM 主页时，提示 500 错误?可能原因：错误的 YAML 语法或者硬件外设不满足。可执行systemctl status kvmd kvmd-otg或是kvmd --run查看详细报错信息。

如何为多个 One-KVM 使用不同的主机名？使用 SSH 会话或 Web 终端，如果您不是 root，请使用命切换为 root 再执行命名`hostnamectl set-hostname onecloud`，然后重新启动 pikvm服务。

![img](.&#x2F;Image&#x2F;One-KVM FAQ和故障排除.assets&#x2F;1705214473632-2.png)
为什么我的机器不能再通过按下重置键的方式刷机了？脚本通过覆盖分区的方式跳过了UBoot线刷检测，如需使用其他系统则需重新短接主板刷机或使用烧录好系统的U盘通过U盘启动。

网页视频窗口提示”Janus WebSocket“连接失败如何解决？此事件发生概率为2%，为偶发性事件，难以复现，无法解决，建议重装软件。
为什么网页视频会有无法消除的黑边且模糊无比？非硬件和软件原因，请检查你的被控机系统设置。
![img](.&#x2F;Image&#x2F;One-KVM FAQ和故障排除.assets&#x2F;1705214473632-3.jpeg)
]]></content>
      <categories>
        <category>玩客云</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>玩客云</tag>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title>One-KVM使用指南</title>
    <url>/2024/01/14/%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E_One-KVM%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[One-KVM使用指南介绍One-KVM是基于玩客云硬件和PiKVM软件的远控设备。通过移植PiKVM该软件至玩客云设备上，实现了极高的性价比，不到百元功能即可接近甚至超越部分昂贵的商业设备。
该设备在于帮助用户通过得到控制设备的HDMI 画面和鼠标键盘，去远程管理服务器、工作站或个人PC等。 和基于软件的远程管理方式不同，你无需在被控电脑安装任何软件，做到无侵入式控制。
当前您使用的PiKVM内部版本号为0.4，有中文界面，支持网页与VNC同时远控、BIOS级控制、USB键鼠模拟、远程挂载镜像（MSD）、网络远程唤醒（WOL）、网页终端，文本粘贴和中英文识别（OCR）等特性。



功能
One-KVM
TinyPilot 社区版本
PiKVMv3版本



HTML5界面
简体中文
英文
英文


BIOS级访问
√
√
√


视频捕捉
√
√
√


音频捕捉
×
√
√


鼠键捕获
√
√
√


从剪贴板粘贴
√
√
√


OCR识别
√
×
√


基于密码的身份验证
√
需升级Pro
√


LAN唤醒
√
需升级Pro
√


从WebUI更新
×
√
×


VNC支持
√
×
√


挂载虚拟驱动器
√
需升级Pro
√


ATX开关机
√
×
√


WiFi
×
√
√


串行接口
×
×
√


视频流格式
MJPEG
MJPEG, H.264
MJPEG, H.264


视频分辨率
1920x1080
1920x1080
1920x1080


开始使用将HDMI转USB采集卡插入玩客云主机网口旁USB口，HDMI视频线插入采集卡HDMI端，USB双公线插入玩客云主机HDMI口旁USB口，插入网线，接入电源。
被控机端，讲HDMI视频线和USB双公线接入对应接口即可。

提醒：玩客云USB设备插反会导致PiKVM所有远控功能无法使用。
帮助：部分低功耗设备在未接通电源时可能通过USB双公线从玩客云取电并启动至异常状态，再接通电源也无法启动。要解决此问题，您可以 剥开USB双公线剪断红色5V细电线。
玩客云主机前面板灯在系统极低负载时为红色，在系统启动和使用PiKVM时（有负载时）会不同颜色交替闪烁，这是正常的。
玩客云主机默认上网方式为DCHP，启动后在浏览器访问网络新增IP即可。由于软件自签SSL证书不被信任，请无视风险继续访问。




提示： 默认WEB和VNC账号密码都为admin且同步，root用户密码为1234，所有端口皆为服务默认端口。
帮助：排障指南　　
网页视频黑屏提示无No Singal，请检查硬件是否正确连接或松动；
网页端黑屏无任何画面或彩色竖条，请检查是否有被控机HDMI信号输入；
进系统画面显示正常，bios界面黑屏或渲染异常，请在BIOS界面开启CMS兼容模式；
画面显示片刻黑屏，刷新网页重复此现象，请使用火狐浏览器或修改kvmd主配置文件使用yuyv格式。
如果以上情况都不符合请尝试重启玩客云自动复位。
如果要使用ATX控制物理开关机功能请连接好开机线（目前成品深色引出线接9pin中的开机负极，浅色引出线接开机针脚正极，如黑白、褐红，橙黄对应负极和正极），延长线不分颜色直接使用。


其他文档目录（可在此查阅其他文档）：https://p1b237lu9xm.feishu.cn/drive/folder/IsOifWmMKlzYpRdWfcocI7jdnQA
Github地址：https://github.com/mofeng-git/One-KVM （欢迎点个Star）
QQ交流群：569514148 （One-KVM交流群）
]]></content>
      <categories>
        <category>玩客云</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>玩客云</tag>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title>One-KVM启用MSD、WOL功能</title>
    <url>/2024/01/14/%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E_One-KVM%E5%90%AF%E7%94%A8MSD%E3%80%81WOL%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[One-KVM启用MSD、WOL功能启用MSDMSD（Mass Storage Drive），即大容量储存设备，可以实现远程上传文件，挂载镜像等功能。
分区使用玩客云EMMC空间作者在安装篇的网盘的链接中提供了包含此软件的系统镜像，刷入U盘后将U盘插到玩客云网口旁的USB口插电启动，连接ssh（root&#x2F;1234）输入gparted即可启动磁盘分区软件。
如果没有打开软件界面请检查你的ssh终端是否支持X11转发功能。
在打开的Gparted界面右键 &#x2F;dev&#x2F;mmcblp1p2 选择 Resize&#x2F;Move 来调整分区，在Free space following框中输入新建分区的大小（可输入4096），再将分出来的空闲空间格式化为ext4格式，最后点击主界面选项卡下的绿底√应用应用刚才的选择即可。


应用补丁
#拔掉U盘重启进入EMMC系统添加分区nano /etc/fstab#在文件末尾添加如下挂载/dev/mmcblk1p3 /var/lib/kvmd/msd  ext4  nodev,nosuid,noexec,ro,errors=remount-ro,data=journal,X-kvmd.otgmsd-root=/var/lib/kvmd/msd,X-kvmd.otgmsd-user=kvmd  0 0#如果使用的0.3版本（非一键脚本安装），请执行命令应用补丁 cd ~/fruity-pikvm &amp;&amp; sudo ./msd-patch.shmount /dev/mmcblk1p3#开启MSD功能，到/etc/kvmd/override.yaml修改msd选项为otgnano /etc/kvmd/override.yamlsystemctl restart kvmd-otg kvmd

使用TF卡（SD卡）建议不要使用杂牌储存卡（部分杂牌储存卡反应为Windows正常、Linux能识别但无法访问和读写）。
#查看TF卡位置fdisk -l#将其格式化为ext4文件格式（将sdx替换为你的设备地址）mkfs.ext4 /dev/sdxnano /etc/fstab#在文件末尾添加如下挂载（将sdx替换为你的设备地址）/dev/sdx  /var/lib/kvmd/msd  ext4  nodev,nosuid,noexec,ro,errors=remount-ro,data=journal,X-kvmd.otgmsd-root=/var/lib/kvmd/msd,X-kvmd.otgmsd-user=kvmd  0 0#如果使用的0.3版本（非一键脚本安装），请执行命令应用补丁 cd ~/fruity-pikvm &amp;&amp; sudo ./msd-patch.sh#挂载分区（将sdx替换为你的设备地址），如失败报错请检查设备地址和挂载内容是否出错mount /dev/sdx#开启MSD功能，到/etc/kvmd/override.yaml修改msd选项为otgnano /etc/kvmd/override.yamlsystemctl restart kvmd-otg kvmd

启用WOLWOL（Wake On LAN），即网络唤醒，在被控机支持的情况下（部分机器可能默认关闭，开启教程可参考网络唤醒WOL（Wake On LAN） - 知乎 (zhihu.com)），可以通过网络唤醒设备开机，实现机器开停自由。更详细的介绍和配置可查阅官方教程。
首先在获取被控机网卡的MAC地址记录下来（格式为linux小写），然后编辑 &#x2F;etc&#x2F;kvmd&#x2F;override.yaml 添加如下内容，完成后重启服务 systemctl restart kvmd （请注意格式缩进，否则会导致服务启动失败）。
gpio:    drivers:        wol_server1:            type: wol            mac: 2c:56:dc:db:7c:1e    scheme:        wol_server1:            driver: wol_server1            pin: 0            mode: output            switch: false    view:        table:            - [&quot;#设备名称&quot;, &quot;wol_server1|网络唤醒&quot;]


]]></content>
      <categories>
        <category>玩客云</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>玩客云</tag>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title>项目思路_远程（WIFI）键盘</title>
    <url>/2023/12/11/%E9%A1%B9%E7%9B%AE%E6%80%9D%E8%B7%AF_%E8%BF%9C%E7%A8%8B%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[思想使用esp8266作为主控方案，将通过wifi + ipv6的形式实现远程输入。借助ch9328芯片，使其与主控通过ttl通信，并将串口传来的数据转换成usb键盘的键值传给计算机。
应用场景借助WIFI实现远程控制主机。
大致流程使用ddns的方式将获取到的ipv6地址绑定到域名，并监听指定的端口。当有其他应用访问这个端口的时候，解析访问的资源。访问格式如下： 域名:端口/访问方式（协议 明文，两个字母）/要传输的内容（base64编码）。
获取请求的地址：

String path = server.uri(); // 获取请求的路径
- 获取路径  - ```c++    String path = &quot;/jp/hello&quot;; // 假设这就是请求路径    int lastSlashIndex = path.lastIndexOf(&#x27;/&#x27;); //获取最后一个/的位置    int secondLastSlashIndex = path.lastIndexOf(&#x27;/&#x27;, lastSlashIndex - 1); // 获取倒数第二个/的位置    String secondLastSegment = path.substring(secondLastSlashIndex + 1, lastSlashIndex); // 从倒数第二个斜杠后一位开始，一直截取到最后一个斜杠，将截取出的信息写入到secondLastSegment字符串中    String lastSegment = path.substring(lastSlashIndex + 1);//截取最后一个斜杠到最后的位置，    Serial.println(secondLastSegment); // 输出 jp    Serial.println(lastSegment); // 输出 hello





当获取到协议和编码后，将编码进行解码，获取其中的数据，按照协议的内容进行处理功能点
当协议部分是jp的时候，内容中的部分可以直接输入到计算机
当协议部分是passwd的时候，内容部分经过aes解密后设置成下次解密时的密钥。相当于设置密码。
注意，设置密码时解密的密钥为一个特定的值（写死）
当执行设置密码后，将解密后的值写入到指定的文件中（覆盖）


每次运行的时候，都从指定位置读取密码文件.
若不存在，则使用默认的密码：123456
若存在，则使用文件中指定的密码。密码文件中的所有内容均为密码



功能的部分代码
base64解码

要解码一个经过Base64编码的字符串，你可以使用Base64库或者函数来完成。以下是一个示例代码，使用Arduino ESP8266的base64库来解码字符串：
#include &lt;Base64.h&gt;String encodedString = &quot;cnVub29iaQ==&quot;;String decodedString = base64::decode(encodedString);Serial.println(decodedString);

在上面的示例中，我们使用了ESP8266的Base64库来解码字符串。首先，我们将经过Base64编码的字符串赋值给encodedString。然后，使用base64::decode()函数对字符串进行解码，并将解码后的结果赋值给decodedString。最后，使用Serial.println()函数将解码后的字符串打印出来。
请确保在你的Arduino开发环境中正确安装了ESP8266的Base64库。



AES解密

如果解密内容和解密密码随时会变化，你可以将解密密码作为一个变量，以便在需要时进行修改。你可以 在代码中定义一个变量来存储解密密码，并在每次解密之前更新它。
以下是一个示例代码，演示如何使用变量来存储解密密码：
#include &lt;AESLib.h&gt;String encryptedString = &quot;U2FsdGVkX1+Td5IhADeOWSntJwhcWAwE/F35ZrmRCL0=&quot;;String decryptedString;AES aes;String decryptionKey = &quot;1234&quot;; // 解密密码，可以随时修改void setup() &#123;  Serial.begin(115200);  byte iv[] = &#123;0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F&#125;; // 初始化向量  byte key[decryptionKey.length() + 1]; // 创建解密密码字节数组  decryptionKey.getBytes(key, decryptionKey.length() + 1); // 将解密密码字符串转换为字节数组  aes.set_key(key, decryptionKey.length()); // 设置解密密码  aes.set_iv(iv, sizeof(iv)); // 设置初始化向量  decryptedString = aes.decrypt(encryptedString); // 解密字符串  Serial.println(decryptedString);&#125;void loop() &#123;  // 你的其他代码&#125;

在上面的示例中，我们定义了一个变量decryptionKey来存储解密密码。你可以随时修改这个变量的值，以改变解密密码。在setup()函数中，我们将解密密码转换为字节数组，并使用aes.set_key()函数将 其设置为解密密钥。
关于初始化向量（IV），它是在AES加密中用于增加加密强度的参数。IV是一个固定长度的字节数组，必须与加密时使用的IV相匹配。在解密过程中，使用相同的IV可以确保正确解密数据。在示例代码中，我们使 用了一个固定的IV，你可以根据需要进行更改。
请注意，示例代码只是一个参考，具体的实现可能会因为你使用的库或平台而有所不同。确保根据你的需 求和使用的AES库的要求进行相应的修改。




将结果发送到ch9328
参考wifi badusb中的keyboard.cpp：

以下是代码中的一些重要部分：

makeReport 函数：该函数用于创建键盘输入报告。它接受多个参数，包括修饰键和按键的值，并返回一个报告对象。

begin 函数：该函数用于初始化 ESP8266 的键盘控制。它设置了引脚模式、波特率等，并发送复位信号。

setLocale 函数：该函数用于设置键盘的区域设置。它接受一个 hid_locale_t 类型的指针作为参数，并将其赋值给 locale  变量。

send 函数：该函数用于发送键盘输入报告到串口。

pressKey 函数：该函数用于模拟按下一个按键。它接受按键的值和修饰键的值作为参数，并在先前的报告中找到一个空闲的位置来存储按键信息。

pressModifier 函数：该函数用于模拟按下修饰键。它接受修饰键的值作为参数，并在先前的报告中设置相应的修饰键位。

press 函数：该函数用于模拟按下一个字符。它接受一个字符指针作为参数，并根据当前的键盘区域设置转换字符为相应的键值和 修饰键，并调用 pressKey 函数发送按键信息。

write 函数：该函数用于模拟按下一个字符串。它接受一个字符串指针作为参数，并调用 press 函数模拟按下每个字符，并在最后释放按键。


这些函数和变量的组合可以用于控制 ESP8266 作为一个键盘设备，模拟按键操作。

bito&gt; 假设我要将字符a传输到计算机，这段代码应该怎么工作？
bito response&gt;根据您提供的代码，如果您想将字符 ‘a’ 传输到计算机，可以按照以下步骤进行操作：

调用 begin() 函数来初始化 ESP8266 的键盘控制。

调用 press() 函数，并将字符 ‘a’ 作为参数传入。该函数会根据当前的键盘区域设置将字符转换为相应的键值和修饰键，并模拟 按下该按键。

如果需要，可以调用其他按键函数，例如 pressModifier() 来模拟按下修饰键。

最后，调用 release() 函数来释放所有按键，确保没有按键被持续按下。


完整的示例代码如下：
#include &quot;keyboard.h&quot;void setup() &#123;  keyboard::begin();&#125;void loop() &#123;  // 模拟按下字符 &#x27;a&#x27;  keyboard::press(&#x27;a&#x27;);  // 模拟释放所有按键  keyboard::release();  // 延时一段时间，以便观察效果  delay(1000);&#125;

在上述示例中，setup() 函数会在程序开始时调用一次，用于初始化键盘控制。然后，loop() 函数会不断循环执行，每次循环都会 模拟按下字符 ‘a’ 并释放所有按键。之后会延时1秒，以便观察效果。

bito&gt; 假设我想传输 shift + ctrl + r到计算机，我应该如何调用？
bito response&gt;要模拟传输 Shift + Ctrl + R 到计算机，您可以按照以下步骤调用相关函数：
#include &quot;keyboard.h&quot;void setup() &#123;  keyboard::begin();&#125;void loop() &#123;  // 模拟按下 Shift、Ctrl 和 R 键  keyboard::pressModifier(KEY_LEFT_SHIFT);  keyboard::pressModifier(KEY_LEFT_CTRL);  keyboard::press(&#x27;r&#x27;);  // 模拟释放所有按键  keyboard::release();  // 延时一段时间，以便观察效果  delay(1000);&#125;

在上述示例中，setup() 函数用于初始化键盘控制，而 loop() 函数则用于循环执行按键操作。
首先，我们调用 pressModifier() 函数两次，分别传入 KEY_LEFT_SHIFT 和 KEY_LEFT_CTRL 作为参数，以模拟按下 Shift 和 Ctrl 键。
然后，我们调用 press() 函数，并传入字符 ‘r’ 作为参数，以模拟按下 R 键。
最后，我们调用 release() 函数来释放所有按键，确保没有按键被持续按下。
请注意，具体的修饰键值（如 KEY_LEFT_SHIFT 和 KEY_LEFT_CTRL）可能会根据您的键盘设置和操作系统有所不同。您可以根据需要进行调整。

bito&gt; 也就是说，如果我想按下ctrl、shift、alt、insert之类的功能键，我需要调用pressModifier()方法；如果我想按下英文字母、 空格、数字，我就调用press()方法；同时，在没有调用release()方法之前，每调用一次pressModifier()、press()方法，就相当与按下对应的键不松手，直到调用release()方法后，全部统一松手，对吗？
bito response&gt;是的，您的理解是正确的。

如果您想按下功能键（如Ctrl、Shift、Alt等），可以使用 pressModifier() 方法来模拟按下这些键。每次调用 pressModifier() 方法，都会将相应的修饰键添加到先前的报告中，表示按下该键。在调用 release() 方法之前，这些修饰键会一直保持按下状态。

如果您想按下英文字母、空格、数字等普通键，可以使用 press() 方法来模拟按下这些键。每次调用 press() 方法，都会将相应的键值添加到先前的报告中，表示按下该键。在调用 release() 方法之前，这些普通键会一直保持按下状态。


最后，当您调用 release() 方法时，所有之前按下的键（无论是修饰键还是普通键）都会被释放，相当于将所有键松开。
请注意，为了模拟按键操作的连续性，您可以在每次按下和释放之间添加适当的延时，以确保操作的顺序和持续时间符合预期。

bito&gt; 能不能告诉我，键盘上114个按键，我应该调用哪个按键才能实现分别按下？
bito response&gt;键盘上的114个按键可以使用不同的键值常量来表示。以下是一些常见的键值常量示例：

字母键：’a’, ‘b’, ‘c’, … ‘z’
数字键：’0’, ‘1’, ‘2’, … ‘9’
功能键：KEY_F1, KEY_F2, KEY_F3, … KEY_F12
修饰键：KEY_LEFT_CTRL, KEY_RIGHT_CTRL, KEY_LEFT_SHIFT, KEY_RIGHT_SHIFT, KEY_LEFT_ALT, KEY_RIGHT_ALT, KEY_LEFT_GUI, KEY_RIGHT_GUI
特殊键：KEY_ENTER, KEY_ESC, KEY_BACKSPACE, KEY_TAB, KEY_SPACE, KEY_INSERT, KEY_DELETE, KEY_HOME, KEY_END, KEY_PAGE_UP, KEY_PAGE_DOWN, KEY_ARROW_UP, KEY_ARROW_DOWN, KEY_ARROW_LEFT, KEY_ARROW_RIGHT

您可以根据需要调用相应的键值常量来模拟按下不同的按键。例如，要按下字母 ‘a’，您可以使用 keyboard::press(&#39;a&#39;)；要按下Shift键，您可以使用 keyboard::pressModifier(KEY_LEFT_SHIFT)。
请注意，具体的键值常量可能会根据您的键盘设置和操作系统有所不同。您可以参考键盘库的文档或查阅相关资料，以获取完整的键值常量列表，并根据您的需要进行调用。

bito&gt; 功能键、修饰键、特殊键需要通过pressModifier()实现按下，其余的通过press()按下，对吗？
bito response&gt;是的，您的理解是正确的。

功能键（如F1、F2等）、修饰键（如Ctrl、Shift、Alt等）和特殊键（如Enter、Esc、Backspace等）需要使用 pressModifier() 方法来模拟按下。

其他普通键（如字母键、数字键、符号键等）可以使用 press() 方法来模拟按下。


通过调用适当的函数，您可以按照需求模拟按下不同类型的键。请确保在按下和释放键之间适当地调用 release() 方法，以便在完成 按键操作后将键释放。
请注意，键盘库中的函数和键值常量可能会根据库的实现和键盘设置有所不同。建议查阅相关文档或参考库的示例代码以了解准确的函数和键值常量。

bito&gt; 也就是说，我通过write(“hello”, 5)的形式调用，相当于将hello分解成五个字母，然后逐个输入 到计算机是吗？
bito response&gt;是的，您的理解是正确的。通过调用 write(&quot;hello&quot;, 5) 方法，将字符串 “hello” 分解为五个字母， 并逐个输入到计算机中。
在 write(const char* str, size_t len) 方法中的循环中，每次迭代都会调用 write(&amp;str[i]) 方 法，其中 &amp;str[i] 表示字符串中的一个字母。这样，循环会逐个处理字符串中的每个字母，并将其模拟输入到计算机中。
因此，write(&quot;hello&quot;, 5) 的效果等同于逐个按下字符 ‘h’、’e’、’l’、’l’、’o’，即将字符串 “hello” 分解为五个字母，并逐个输入到计算机中。





9238接收到数据后，转换成usb键值传给主机。

]]></content>
      <categories>
        <category>项目思路</category>
        <category>ESP8266</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>protected</tag>
        <tag>ESP8266</tag>
        <tag>项目思路</tag>
        <tag>CH9328</tag>
      </tags>
  </entry>
  <entry>
    <title>One-KVM安装完整教程</title>
    <url>/2024/01/14/%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E_One-KVM%E5%AE%89%E8%A3%85%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[One-KVM安装完整教程
介绍One-KVM是基于玩客云硬件和PiKVM软件的远控设备。KVM over IP可以远程管理服务器或工作站，无论操作系统或是否安装了操作系统。 相较于购买向日葵控控（￥7？？）或树莓派开发板，50多的矿渣玩客云 + HDMI转USB采集卡的组合（不包含其他工具）运行PiKVM同样可以实现很好的效果。



功能
One-KVM
TinyPilot 社区版本
PiKVMv3版本



HTML5界面
简体中文
英文
英文


BIOS级访问
√
√
√


视频捕捉
√
√
√


音频捕捉
×
√
√


鼠键捕获
√
√
√


从剪贴板粘贴
√
√
√


OCR识别
√
×
√


基于密码的身份验证
√
需升级Pro
√


LAN唤醒
√
需升级Pro
√


从WebUI更新
×
√
×


VNC支持
√
×
√


挂载虚拟驱动器
√
需升级Pro
√


ATX开关机
√
×
√


WiFi
×
√
√


串行接口
×
×
√


视频流格式
MJPEG
MJPEG, H.264
MJPEG, H.264


视频分辨率
1920x1080
1920x1080
1920x1080


运行效果

开始安装准备工具必备硬件：玩客云（含电源和USB刷机线），HDMI转USB采集卡（推荐MS2109型号），网线和HDMI线
可选硬件：TF卡（扩展储存） TTL转USB适配器（调试工具）
镜像工具文件链接：https://pan.baidu.com/s/166-2Y8PBF4SbHXFkGmFJYg?pwd=o9aj



采集卡硬件兼容性列表







型号&#x2F;方案
USB接口
Linux支持
PiKVM支持
使用情况


MS2109
USB2.0
√
√
推荐


MS2130
USB3.0
√
√
配置过剩


MS2131
USB3.0
√
√
配置过剩


腾飞 TFDGK05
USB2.0
√
×
&#x2F;


迈拓矩阵 MT-UH02
USB2.0
×
×
&#x2F;


仓库介绍先简单介绍一下One-KVM项目，目前有三个仓库：
One-KVM：提供一键PiKVM安装脚本，目前只支持Armbian_22.11.0-trunk_Onecloud_jammy_legacy_5.10.149系统，后续会加入Build-Armbian分支基础镜像的完全支持；
One-KVM-docker：提供PiKVM docker镜像，目前只有pikvm-ch9329_amd64容器，后续会加入常见架构容器支持；
Build-Armbian：提供适用与PiKVM的基础系统镜像和One-KVM成品固件镜像，目前已经开始第一版镜像已完成，One-KVM_Armbian_20.12_Aml-s812_jammy_current_5.9.0-rc7_minimal_240110以开始内测，后续将完善细节。
对应的，PiKVM有三种安装方式：脚本安装，直刷One-KVM镜像，docker镜像部署。
方式一：脚本安装使用 https://github.com/hzyitc/armbian-onecloud/releases/download/ci-20221026-074131-UTC/Armbian_22.11.0-trunk_Onecloud_jammy_legacy_5.10.149.burn.img.xz 线刷镜像刷入玩客云EMMC，SSH登录配置好密码。
玩客云刷机教程请自行百度，这里不再赘述。
注意：作者只测试过此镜像可正常运行PiKVM，其他版本的镜像可能存在运行问题（不限于不包含UVC驱动，无所需Python版本，OTG拔插死机），不确定是否适用于此教程，如有问题请自行解决。
提示：Amlogic USB Burning Tool建议使用 v2.1.3及以下版本，不要使用高版本软件（下图是反面教材）。
刷机短接时不需要一直短接，在烧录软件识别到并加载到1%可以松手耐心等待刷机成功了。

进入Armbian系统处理好设置密码等基础操作后就可以使用使用一键安装脚本安装PiKVM了。
git clone https://github.com/mofeng-git/One-KVM.gitcd One-KVM  &amp;&amp; bash ./install.sh#对于国内网络环境，可以尝试以下命令wget https://mirror.ghproxy.com/https://github.com/mofeng-git/One-KVM/archive/refs/heads/main.zip -o One-KVM-main.zipunzip One-KVM-main.zipcd One-KVM-main  &amp;&amp; bash ./install.sh


方式二：直刷One-KVM镜像带burn后缀的为线刷镜像，可使用USB_Burning_Tool线刷至玩客云。不带burn后缀的为U盘&#x2F;SD卡启动镜像，直接写入U盘&#x2F;SD卡即可。镜像为开箱即用，刷好后启动设备就可以开始用One-KVM了。
方式三：docker镜像部署目前支持仅有pikvm-ch9329_amd64，后续将支持更多控制方式和处理器架构。使用示例：
docker run -itd -p443:443 -p80:80 --name pikvm-docker --device=/dev/ttyUSB0:/dev/kvmd-hid --device=/dev/video0:/dev/kvmd-video pikvm-ch9329:0.61

开始使用按图连接好设备（网口旁接USB采集卡，HDMI旁边的为OTG口接USB双公线，可以直接用刷机线），访问玩客云IP，默认账号密码 admin&#x2F;admin，即可开始使用！
至于如何MSD功能、VNC远控和ATX开关机控制请查看作者其他文章。

其他感谢名单：
H_xiaoming测试适配OTG正常可用镜像、*0蓝蓝0*提供开机卡线刷检测解决办法、fairybl关于MSD和线刷检测的其他解决方案、浩龙的电子嵌入式之路的充电，以及其他开源项目、各位大佬和网友的讨论交流。
更新日志：
当前One-KVM版本号：V0.5
Github地址：https://github.com/mofeng-git/One-KVM （欢迎点个Star）
V0.5：通过锁定CPU频率修复ustreamer mjpeg视频流异常的问题；屏蔽主程序找不到温度传感器的报错；优化中文翻译；优化安装流程
V0.4：实现了ATX开关机物理控制功能；初步建立了使用文档；优化了安装流程。
V0.3：制作了简体中文补丁；实现了MSD功能在EMMC和TF卡上的使用；实现了WOL和中文OCR功能；优化了安装流程。
V0.2：解决了OTG拔插死机问题；初步实现了MSD功能；解决了开机卡线刷检测；优化了安装流程。
V0.1：PiKVM在玩客云上初步运行。
参考项目

GitHub - pikvm&#x2F;pikvm: Open and inexpensive DIY IP-KVM based on Raspberry Pi
GitHub - hzyitc&#x2F;armbian-onecloud: Armbian for onecloud. 玩客云用armbian
GitHub - jacobbar&#x2F;fruity-pikvm: Install Pi-KVM on debian SBCs such as Orange Pi, Banana Pi, Mango Pi debian SBCs such as Orange Pi, Banana Pi, Mango Pi, etc (github.com)

]]></content>
      <categories>
        <category>玩客云</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>玩客云</tag>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title>One-KVM实现物理开关机控制功能</title>
    <url>/2024/01/14/%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E_One-KVM%E5%AE%9E%E7%8E%B0%E7%89%A9%E7%90%86%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8E%A7%E5%88%B6%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[One-KVM实现物理开关机控制功能介绍这个教程是比较粗糙的版本，在新旧版玩客云上测试通过，操作无差别，适合DIY玩家参考。通过使用玩客云红外接口预留的GPIO接口连接主板9PIN中的开机针脚实现物理控制开机、关机和强制关机的功能。
教程物理控制开关机只需要一个GPIO接口（两者都是3.3V），不能占用宝贵的WiFi模块引脚，led用处也不小，最后选择测试红外控制引脚（应该没人会同时使用PiKVM和红外遥控功能吧）。
硬件改动：
整个操作并不复杂，首先需要在玩客云主板的红外模块预留接口焊上两根引线（接在图中GPIO-420和GND位置），然后接驳开机线（GPIO接开机引脚正极，GND接开机引脚负极）。




软件改动对于One-KVM V0.4用户
一键脚本已经配置好了，硬件连接好之后即可使用此功能。
对于One-KVM V0.3用户
请下载https://github.com/mofeng-git/One-KVM patch目录下的short_press_gpio420和long_press_gpio420两个shell脚本文件，然后上传至玩客云&#x2F;usr&#x2F;bin目录下。
#给kvmd程序执行这两个脚本的权限echo kvmd ALL=\(ALL\) NOPASSWD: /usr/bin/long_press_gpio420,/usr/bin/short_press_gpio420 &gt;&gt;  /etc/sudoers

然后编辑 &#x2F;etc&#x2F;kvmd&#x2F;override.yaml 文件添加如下内容（注意缩进和格式，否则会报错）。
gpio:    drivers:        short_press:            type: cmd            cmd: [/usr/bin/sudo, short_press_gpio420]        long_press:            type: cmd            cmd: [/usr/bin/sudo, long_press_gpio420]    scheme:        short_button:            driver: short_press            pin: 0            mode: output            switch: false        long_button:            driver: long_press            pin: 0            mode: output            switch: false    view:        header:            title: ATX        table:                            - [&quot;#电源管理&quot;]            - []            - [&quot;#短按（开/关机）:&quot;, short_button|按下]            - [&quot;#长按（强制关机）:&quot;, long_button|按下]


#最后重启kvmd服务就可以看到修改生效了。systemctl restart kvmd 



提示：对于DIY玩家，您也可以使用尝试PiKVM自带的GPIO驱动方式进行控制（作者采用的调用bash脚本），作者使用的引脚对于系统位置是gpio-420，对于PiKVM位置是gpiochip1 pin7，PiKVM源代码默认为gpiochip0需要手动修改。

]]></content>
      <categories>
        <category>玩客云</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>玩客云</tag>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title>高可用高并发后端架构通用蓝图</title>
    <url>/2025/10/08/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E9%80%9A%E7%94%A8%E8%93%9D%E5%9B%BE/</url>
    <content><![CDATA[核心设计原则在深入细节之前，整个架构遵循以下几个核心原则：

无单点（No Single Point of Failure）: 系统中任何一个组件的故障都不会导致整个系统瘫痪。所有服务和数据存储都必须是集群化的或有冗余备份。
水平扩展（Horizontal Scaling &#x2F; Scale-Out）: 当负载增加时，可以通过简单地增加更多服务器节点来提升系统的处理能力，而不是升级单个服务器的硬件（垂直扩展）。
服务拆分与隔离（Decoupling &amp; Isolation）: 将庞大的单体应用拆分为更小、更专注的服务。服务之间的故障不会相互影响，可以独立部署和扩展。
异步化（Asynchronous Communication）: 对于非核心、耗时的操作，采用消息队列进行异步处理，可以削峰填谷，提高系统的响应速度和吞吐量。
数据分片与多副本（Sharding &amp; Replication）: 对海量数据进行分片存储以分散压力，同时为数据创建多个副本以保证高可用和容灾。


架构笔记：一次请求的旅程概览1. 客户端与网络接入层 (Client &amp; Edge)这是用户请求的起点，也是系统抵御外部风险和加速内容分发的第一道防线。

核心职责:
解析域名，将用户流量导向正确的入口。
缓存静态资源（图片、JS、CSS），减少对后端服务器的请求。
抵御网络攻击（如DDoS、SQL注入）。


高可用&#x2F;高并发策略:
DNS 负载均衡: 配置多个IP地址，DNS服务可以根据负载或地理位置返回一个最优的IP。
CDN (内容分发网络): 将静态资源分发到全球各地的边缘节点，用户就近访问，极大提升加载速度并分担源站压力。
WAF (Web应用防火墙): 在流量进入系统前进行过滤和清洗。


主流技术: Cloudflare, AWS CloudFront, Akamai, F5, 各大云厂商的DNS&#x2F;WAF服务。

2. 流量接入层 (Traffic Ingress)流量穿过边缘网络后，到达我们自己数据中心的入口。

核心职责:
作为所有内部服务的统一入口。
SSL&#x2F;TLS 卸载（解密HTTPS流量）。
将请求根据URL路径、域名等规则，均匀地转发到后端的API网关集群。


高可用&#x2F;高并发策略:
负载均衡器集群: 使用至少两台负载均衡器组成集群（例如，通过 Keepalived + VIP 实现主备切换），避免单点故障。
健康检查 (Health Checks): 负载均衡器会持续检查后端网关节点的健康状况，自动剔除故障节点，将流量转发到健康节点。
四层&#x2F;七层负载均衡: L4（TCP&#x2F;UDP）转发速度快，L7（HTTP）可以根据请求内容做更智能的路由。


主流技术: Nginx, HAProxy, F5 BIG-IP, 各大云厂商的负载均衡器（ALB&#x2F;NLB）。

3. API网关层 (API Gateway)网关是微服务架构的“门面”，处理所有服务的通用横切关注点。

核心职责:
路由: 将请求精确地路由到对应的后端业务服务。
认证与授权: 校验用户身份（Token&#x2F;JWT），确保用户有权限访问该API。
限流与熔断: 防止突发流量冲垮后端服务，当某个服务不可用时快速失败（熔断），避免雪崩效应。
日志、监控、协议转换等。


高可用&#x2F;高并发策略:
无状态与集群部署: 网关本身是无状态的，可以轻松地水平扩展多个节点。
服务发现: 网关从服务注册中心动态获取后端服务的地址列表，实现自动的服务上下线感知。
熔断降级: 集成Hystrix, Sentinel等库，实现对下游服务的保护。


主流技术: Kong, Spring Cloud Gateway, Zuul, Traefik。

4. 业务服务层 (Application Services)这是实现核心业务逻辑的地方。

核心职责: 处理具体的业务请求，如订单处理、用户管理、商品查询等。
高可用&#x2F;高并发策略:
微服务化: 将复杂的业务拆分成多个独立的服务，每个服务都可以独立部署、扩展和容错。
无状态服务: 将会话状态等信息存储在外部的缓存或数据库中，使得任何一个服务节点都可以处理任意用户的请求，为水平扩展奠定基础。
容器化与编排: 使用 Docker 将服务打包成镜像，通过 Kubernetes (K8s) 等平台进行自动化部署、扩缩容和故障自愈。


主流技术:
服务框架: Spring Boot (Java), Django&#x2F;Flask (Python), Express (Node.js), Go-kit&#x2F;Gin (Go)。
服务治理: Spring Cloud (Java), Istio (Service Mesh)。
容器编排: Kubernetes, Docker Swarm。



5. 数据与状态层 (Data &amp; State)这是系统的心脏，数据的可靠性和性能直接决定了整个系统的质量。

缓存集群 (Cache Cluster):
职责: 缓存热点数据，降低对数据库的访问压力，提升响应速度。
HA&#x2F;HC策略: 使用 Redis Sentinel&#x2F;Cluster 或 Memcached 集群。通过数据分片分散存储压力，通过主从复制&#x2F;多副本保证数据可用性。


消息队列集群 (Message Queue Cluster):
职责: 服务间解耦、异步处理、流量削峰。例如，用户下单后，将“生成订单”、“扣减库存”、“发送通知”等消息放入队列，由下游服务异步消费。
HA&#x2F;HC策略: 使用 Kafka, RabbitMQ, RocketMQ 等集群。Topic&#x2F;Queue可以有多个分区（Partition）以支持高并发读写，数据有多副本保证不丢失。


数据库集群 (Database Cluster):
职责: 持久化存储核心业务数据。
HA&#x2F;HC策略:
读写分离 (Read&#x2F;Write Splitting): 采用主从（Master-Slave）架构，主库负责写，多个从库负责读，分散读取压力。
分库分表 (Sharding): 当单表数据量过大时，将数据水平拆分到多个库或多个表中。
高可用切换: 使用MHA, Galera Cluster, 或云数据库的HA方案实现主库故障时自动切换。


主流技术: MySQL, PostgreSQL, TiDB (分布式数据库)。


对象存储&#x2F;搜索引擎:
职责: 对象存储 (S3, MinIO) 用于存储图片、视频等非结构化大文件。搜索引擎 (Elasticsearch, Solr) 提供复杂的全文检索功能。
HA&#x2F;HC策略: 这些系统天生就是分布式的，通过增加节点即可线性扩展，数据自动分片和复制。



6. 运维与可观测性 (Operations &amp; Observability)这是保证系统稳定运行的“眼睛”和“大脑”。

集中式日志系统 (Centralized Logging):
职责: 收集所有服务节点的日志，提供统一的查询和分析界面，便于快速定位问题。
技术栈: ELK (Elasticsearch, Logstash, Kibana) 或 EFK (Elasticsearch, Fluentd, Kibana)。


监控与告警系统 (Monitoring &amp; Alerting):
职责: 持续收集系统各项性能指标（CPU, 内存, QPS, 延迟等），通过仪表盘进行可视化展示，并在指标异常时自动告警。
技术栈: Prometheus + Grafana (事实标准), Zabbix。


分布式追踪系统 (Distributed Tracing &#x2F; APM):
职责: 跟踪一个请求在多个微服务之间的完整调用链，帮助分析性能瓶颈和排查分布式系统中的复杂问题。
技术栈: SkyWalking, Jaeger, Zipkin。



通过以上六层的协同工作，我们构建了一个具有弹性、容错和高性能的后端系统，能够从容应对高并发的挑战，并保证在部分组件失效时，核心服务依然可用。

第一章：客户端与网络接入层 (Client &amp; Network Access Layer)1.1 本章定位：系统的“护城河”与“先锋部队”这是整个系统架构的最外层，是用户请求到达我们应用的第一站。你可以把它想象成一座城堡的护城河与城墙。它的核心目标有两个：

加速 (Acceleration): 让合法的、常规的请求尽可能快地得到响应。
防御 (Defense): 将非法的、恶意的攻击流量阻挡在外，保护内部核心服务的安全和稳定。

在高并发场景下，如果这一层设计不当，海量请求和潜在攻击会瞬间冲垮后端的服务器，谈高可用就无从说起。因此，这一层是实现高可用、高并发的第一道防线。

1.2 核心组件详解A. DNS (Domain Name System) - 智能交通调度员
核心职责:将人类易于记忆的域名（如 www.example.com）解析成机器能够识别的IP地址（如 93.184.216.34）。这是互联网的“电话簿”。

如何实现高可用与高并发:

DNS 负载均衡 (DNS Load Balancing):
机制: 一个域名可以配置解析到多个不同的IP地址。当用户发起DNS查询时，DNS服务器会根据预设的策略（如轮询、加权轮询）返回其中一个IP。这样，来自不同用户的请求就会被自然地分发到不同的服务器入口，实现了最基础的负载均衡。
高可用价值: 如果其中一个IP地址对应的服务器集群发生故障，我们可以从DNS解析记录中移除该IP。用户的后续请求就会被解析到其他健康的IP上，实现了数据中心级别的故障转移。


智能DNS解析 (GeoDNS &#x2F; Latency-based Routing):
机制: 更高级的DNS服务（通常由专业DNS提供商或云厂商提供）可以判断DNS查询请求来自哪个地理位置或哪个运营商网络。然后，它会返回一个物理距离最近、访问延迟最低的服务器IP地址。
高并发价值: 将用户流量“就近”引入，极大地提升了访问速度和用户体验，同时也分散了不同区域的流量，避免单一入口的拥堵。




技术实现与选型:

基础：Bind9 (自建)
云服务商：AWS Route 53, Google Cloud DNS, 阿里云DNS
专业DNS服务商：Cloudflare DNS, DNSPod



B. CDN (Content Delivery Network) - 分布式前哨仓库
核心职责:缓存网站的静态资源（如图片、视频、JavaScript文件、CSS文件等），并将其分发到全球各地靠近用户的“边缘节点”（Edge Nodes &#x2F; PoPs）上。

如何实现高可用与高并发:

极大降低源站负载 (Offloading Traffic):
机制: 当用户第一次请求一个静态资源时，CDN边缘节点会从我们的源站服务器拉取该资源并缓存起来。后续所有对该资源的请求，都将直接由CDN边缘节点响应，不再需要访问我们的源站。
高并发价值: 网站流量中通常有70%-80%是静态资源。将这部分流量剥离出去，意味着我们的后端服务器只需要处理剩余20%-30%的动态API请求。这使得后端服务可以专注于核心业务逻辑，承载远超以往的并发量。


天然的分布式与高可用:
机制: CDN服务商在全球拥有成百上千的节点。这些节点本身就是高可用的。如果某个节点或区域出现故障，流量会自动被路由到其他健康的节点。
高可用价值: 它不仅缓存了内容，实际上也为我们的静态资源提供了一个极其强大的、分布式的冗余系统。即使我们的源站短暂宕机，只要CDN缓存未过期，用户依然可以访问网站的静态部分。


加速访问，提升用户体验:
机制: 用户总是从物理距离最近的CDN节点获取资源，减少了网络传输的延迟（RTT - Round-Trip Time）。
价值: 更快的加载速度意味着更低的用户流失率，这在高并发系统中至关重要。




技术实现与选型:

云服务商：AWS CloudFront, Google Cloud CDN, Azure CDN, 阿里云CDN, 腾讯云CDN
专业CDN服务商：Cloudflare, Akamai, Fastly



C. WAF (Web Application Firewall) - 智能安全卫士
核心职责:部署在Web服务器之前，对HTTP&#x2F;HTTPS请求进行检测和过滤，防御常见的Web应用攻击，如SQL注入、跨站脚本（XSS）、DDoS攻击等。

如何实现高可用:

保障服务的可用性 (Protecting Availability):
机制: WAF是保障可用性的关键组件。分布式拒绝服务（DDoS）攻击的目的就是通过海量的垃圾流量耗尽服务器的带宽、CPU或内存资源，导致正常用户无法访问。WAF能够识别并清洗这些恶意流量，只放行合法的请求。
高可用价值: 如果没有WAF，在高并发时期，一次小规模的DDoS攻击就可能导致整个系统瘫痪。WAF确保了后端服务的“存活权”。


防止数据泄露和篡改:
机制: 通过防御SQL注入等攻击，WAF防止了数据库被拖库或恶意修改，间接保护了系统的稳定和数据的完整性，这也是高可用的一个方面（系统能正确提供服务）。




技术实现与选型:

通常与CDN服务集成在一起，如Cloudflare的WAF功能。
云服务商：AWS WAF, 阿里云WAF等。
硬件&#x2F;软件：F5 BIG-IP ASM, ModSecurity (开源)。




1.3 本章总结在这一层，我们通过DNS的智能调度，将用户流量导向最合适的数据中心入口；通过CDN，将绝大部分静态资源请求“拦截”在全球各地的边缘节点，极大地减轻了后端压力；最后通过WAF，清洗掉恶意攻击流量。
架构图中的流程:
[ 用户 ] --- 1. DNS查询 ---&gt; [ DNS服务器 ]   |                                 | 2. 返回最优IP (CDN节点/WAF入口)   |                                 |   +----- 3. 发起HTTP/HTTPS请求 ---&gt; [ CDN / WAF 全球边缘节点 ]                                       |                                       | 4. a) 如果是静态资源 -&gt; 直接从CDN缓存返回                                       | b) 如果是动态API请求 -&gt; 清洗过滤后，转发到下一层...                                       |                                       V                                  (流量接入层)

当流量安全、稳定地穿过这第一道防线后，它将抵达我们数据中心的正式入口——流量接入层。我们将在下一章详细探讨。
第二章：流量接入层 (Traffic Ingress Layer)2.1 本章定位：系统的“总接待”与“安检口”如果说第一章是“城墙”和“护城河”，那么这一层就是城堡的唯一主城门和卫兵。所有外部请求，无论好坏，最终都会汇聚于此。它的核心职责是：

统一入口 (Unified Entry Point): 成为所有后端服务的唯一流量入口，避免将内部服务直接暴露在公网上，增强安全性。
分发与均衡 (Distribution &amp; Balancing): 将海量的并发请求，稳定、高效、均匀地分发给后端的多个处理单元（通常是API网关集群）。
协议处理 (Protocol Handling): 集中处理一些网络层面的通用任务，如HTTPS解密，让后端服务可以更专注于业务逻辑。

这一层是实现后端服务水平扩展和高可用的基础。如果这里的负载均衡器宕机，那么整个系统就与外界“失联”了。

2.2 核心组件详解A. 负载均衡器 (Load Balancer, LB)这是本层的核心组件，通常是一个集群而非单个设备。

核心职责:监听来自公网的特定端口（如80, 443），并将收到的请求根据预设的策略转发给后端服务器池（Server Pool）中的一个健康节点。

如何实现高可用与高并发:

高可用 - 消除单点故障 (HA Cluster):

机制: 负载均衡器本身绝不能是单点。在生产环境中，至少会部署两台负载均衡器，构成**主备（Active-Passive）或主主（Active-Active）**集群。
Keepalived + VIP (Virtual IP) 是一种常见的开源实现方案。集群共享一个虚拟的IP地址（VIP）。正常情况下，VIP由主（Master）节点持有，所有流量都经过它。Keepalived会通过VRRP协议在主备节点间发送心跳包。一旦主节点宕机，备（Backup）节点会立即检测到心跳丢失，并在几秒内接管VIP。对于客户端来说，它们访问的IP地址从未改变，故障切换是透明的。
高可用价值: 确保了流量入口的7x24小时可用。即使一台LB物理机宕机、重启或进行维护，服务也不会中断。


高并发 - 水平扩展后端 (Horizontal Scaling):

机制: 负载均衡器后面可以连接任意数量的后端服务器（比如API网关节点）。当并发量上升时，我们只需要向服务器池中添加新的节点，LB就会自动将流量分发给它们。
负载均衡算法 (Balancing Algorithms):
轮询 (Round Robin): 按顺序依次分发，简单公平。
加权轮询 (Weighted Round Robin): 按权重分配，适用于服务器性能不一的场景。
最少连接 (Least Connections): 将请求发给当前连接数最少的服务器，适合处理长连接。
IP哈希 (IP Hash): 根据客户端IP地址计算哈希值，确保来自同一客户端的请求总是发往同一台后端服务器。这对于需要维持会话状态（Session Stickiness）的场景很有用。


高并发价值: 负载均衡器是实现后端服务无缝水平扩展的关键。它将单个服务的处理能力从“一台服务器的上限”扩展到了“整个集群的综合处理能力”。


健康检查 (Health Checks):

机制: 负载均衡器会以固定的频率，主动向后端服务器池中的每个节点发送“探测”请求（比如一个HTTP GET请求或一个TCP连接请求）。
如果服务器返回了预期的健康状态码（如HTTP 200），则认为该节点健康。
如果服务器超时未响应或返回错误状态，LB会将其标记为“不健康”，并自动停止向该节点转发新的流量。当节点恢复后，健康检查通过，LB会再次将其加入到服务池中。
高可用价值: 这是实现自动故障转移 (Automatic Failover) 的核心机制。它能实时、自动地隔离故障节点，保证用户的请求总是被发送到能够正常处理的服务器上，极大提升了系统的健壮性。





B. SSL&#x2F;TLS 卸载 (SSL&#x2F;TLS Offloading)
核心职责:我们现在的Web服务普遍使用HTTPS来加密传输内容，保障数据安全。HTTPS的加解密过程（特别是握手阶段）会消耗大量的CPU资源。SSL卸载就是将这个加解密的工作集中在负载均衡器上完成。

如何实现高并发:

降低后端服务CPU消耗:
机制: 外部请求 (Client --HTTPS--&gt; LB) 到达LB后，LB负责解密，然后以普通的HTTP协议将请求转发给内部的后端服务器 (LB --HTTP--&gt; Backend Server)。返回的响应也是同理。
高并发价值: 这意味着后端的成百上千个业务服务节点不再需要各自消耗CPU资源去处理加解密。它们可以把宝贵的计算资源全部用于执行核心业务逻辑，从而提升整体的应用处理性能和吞吐量。


简化证书管理:
机制: 所有的SSL&#x2F;TLS证书只需要在负载均衡器这一层进行部署和更新，而不需要在每一个后端服务节点上都去管理证书。
价值: 简化了运维，降低了因证书过期或配置错误导致服务不可用的风险。




技术实现与选型:

软件负载均衡器: Nginx, HAProxy, LVS (Linux Virtual Server)
硬件负载均衡器: F5 BIG-IP, A10 Networks
云服务商: AWS (ALB&#x2F;NLB&#x2F;ELB), Google Cloud Load Balancing, 阿里云SLB




2.3 本章总结在流量接入层，我们通过一个高可用的负载均衡器集群，为整个后端系统提供了一个稳定、统一的入口。它利用健康检查机制实现了后端服务的自动故障转移，通过负载均衡算法将高并发流量均匀地分发出去，并通过SSL卸载为后端服务减负。
架构图中的流程:
            (从第一层: CDN/WAF)                    |                    V[ Internet ] --&gt; [ VIP: 123.45.67.89 ]                    |         +--------------------------+         |     高可用负载均衡器集群     |         |                          |         | [ LB 1 (Master) ] &lt;---&gt; [ LB 2 (Backup) ] -- 心跳检测 --         +--------------------------+                    |                    | 1. SSL/TLS 解密                    | 2. 根据负载均衡算法选择一个后端节点                    | 3. 健康检查，确保节点存活                    |                    V     (转发到下一层: API网关集群的某个节点)

现在，解密后的、干净的、被均匀分发的流量，即将进入微服务架构的“咽喉”——API网关层。我们将在下一章探讨它的作用。
第三章：API网关层 (API Gateway Layer)3.1 本章定位：微服务的“智能门面”与“中央管制塔”如果说流量接入层是城堡的“主城门”，那么API网关层就是城门后的中央广场和卫队长。所有进入城堡的请求都会在这里进行身份核查、登记，并被指引到正确的目的地（具体的业务服务）。它不是简单地转发流量，而是进行了大量的**应用层（L7）**处理。
核心职责：

统一门面 (Unified Facade): 为外部客户端（Web、App、第三方服务）提供一个单一、稳定、规范的API入口，隐藏内部微服务的复杂性和部署细节。
横切关注点处理 (Cross-Cutting Concerns): 集中处理所有或大部分微服务都需要的通用功能，如认证、授权、限流、日志记录等，避免在每个微服务中重复实现。
请求路由与编排 (Routing &amp; Orchestration): 精确地将请求路由到下游的某个或某些微服务，甚至可以将多个微服务的调用结果聚合成一个单一的响应。

这一层是保障微服务架构安全、稳定、可治理的核心。没有它，成百上千的微服务将如一盘散沙，难以管理和保护。

3.2 核心组件与策略详解A. 动态路由 (Dynamic Routing)
核心职责:根据请求的特征（如URL路径、HTTP方法、Header头等），将其转发到正确的后端微服务实例。例如，将 /users/... 的请求路由到用户服务，将 /orders/... 的请求路由到订单服务。

如何实现高可用:

服务发现 (Service Discovery):
机制: API网关本身并不知道后端服务的具体IP地址和端口。相反，它会与一个服务注册中心 (Service Registry) 集成（如 Nacos, Consul, Eureka）。
每个微服务实例在启动时，会主动向注册中心“报到”（注册），并定时发送心跳来表明自己还活着。
API网关会从注册中心订阅服务列表。当有新的服务实例上线或旧的实例下线（因宕机或主动关闭）时，注册中心会实时通知网关。
高可用价值: 这是实现动态、自动化的服务伸缩和故障转移的关键。当订单服务从3个实例扩容到5个时，网关能立刻感知到并开始向新实例转发流量。当某个实例因故障心跳停止时，网关也会立刻将其从路由列表中移除，避免将请求发往一个“死”的服务。整个过程无需人工干预。





B. 安全屏障 (Security Shield)
核心职责:作为所有内部服务的安全前哨，保护它们免受未授权的访问。

高可用策略:

认证 (Authentication):
机制: 集中处理用户身份验证。客户端的请求通常会携带一个身份凭证（如 JWT Token, API Key）。API网关负责校验这个凭证的合法性、有效性。只有通过验证的请求才会被放行到后端服务。
价值: 将认证逻辑从所有业务服务中剥离出来，简化了业务服务的开发。更重要的是，它确保了任何一个内部服务都不会被匿名或非法请求直接访问。


授权 (Authorization):
机制: 在认证通过后，网关还可以进一步检查该用户是否有权限执行当前的操作。例如，检查用户角色是否是“管理员”才能访问某个管理API。
价值: 实现了更细粒度的访问控制，进一步增强了系统的安全性。





C. 流量管制 (Traffic Control)
核心职责:保护后端服务免受突发流量或恶意攻击的冲击，防止系统因过载而崩溃（即“雪崩效应”）。

如何实现高可用与高并发:

限流 (Rate Limiting):
机制: 对特定的API、用户或IP地址设置请求速率上限（如每秒100次请求）。当请求速率超过阈值时，网关会直接拒绝多余的请求（通常返回 429 Too Many Requests 错误）。
高并发价值: 这是一种主动的自我保护机制。它可以防止某个用户或恶意脚本的滥用导致整个服务不可用，确保系统在极限负载下仍能为大部分用户提供有保障的服务。常用的算法有令牌桶、漏桶算法。


熔断 (Circuit Breaking):
机制: 网关会持续监控对下游某个微服务的调用情况（如错误率、响应延迟）。当发现该服务的错误率超过设定的阈值时（比如10秒内失败率达到50%），网关会“熔断”对此服务的调用。
在接下来的一个时间窗口内（如30秒），所有发往该服务的请求都会被网关立即失败 (Fail Fast)，直接返回一个错误，而不再真正去调用那个可能已经崩溃的服务。
时间窗口过后，熔断器会进入“半开”状态，尝试放行少量请求。如果这些请求成功，则关闭熔断器，恢复正常调用；如果依然失败，则继续保持熔断。
高可用价值:
防止雪崩效应: 避免了对一个已知故障服务的无效、重复调用，这些调用会消耗网关自身的线程和连接资源。
给下游服务恢复时间: 停止发送流量，让故障服务有机会重启或恢复。
快速失败: 让上游调用方能迅速得到失败响应，而不是长时间等待超时，提升了用户体验。




降级 (Degradation):
机制: 在系统负载过高或非核心服务出现问题时，为了保住核心功能，会有策略地关闭或简化一些次要功能。这种策略可以在网关层实现，例如，当检测到系统压力大时，网关可以返回一个静态的、默认的响应，而不是去调用后端的推荐服务。
高可用价值: 舍卒保车，确保在极端情况下，系统核心功能依然可用。






3.3 本章总结API网关是微服务架构的“守护神”。它通过与服务注册中心联动，实现了服务的动态路由和自动故障转移。通过集中的认证授权，构筑了坚实的安全防线。更重要的是，它利用限流、熔断、降级等“保险丝”机制，在面对高并发和下游故障时，能有效保护整个系统的稳定性，防止连锁反应导致的全面崩溃。
架构图中的流程:
          (从第二层: 负载均衡器)                  |                  V      +-----------------------+      +-----------------------+      |     API Gateway 1     |      |     API Gateway 2     | ...      +-----------------------+      +-----------------------+               |    ^                            ^               |    | 2. 订阅服务列表             |               |    +--------------------------+ |               |                               | |               v 1. 请求进入                    | V      +----------------------------------------+ |      | 3. 安全: 认证/授权                       | |      | 4. 流量控制: 限流/熔断                   | |      | 5. 根据请求路径，查找服务地址              | |      +----------------------------------------+ |               |                                 |               |         (服务注册中心)             |               v         Nacos/Consul            |+----------------------+                         || [用户服务实例列表]     | &lt;-------------------------+| [订单服务实例列表]     |+----------------------+               |               V   (转发到下一层: 具体的业务服务集群)

现在，经过层层校验和管制的请求，终于到达了真正处理业务逻辑的地方——业务服务层。我们将在下一章探讨如何设计这一层来实现高可用。
第四章：业务服务层 (Application Services Layer)4.1 本章定位：系统的“大脑”与“功能单元”这一层是整个架构的核心价值所在。无论是用户注册、商品浏览、下单支付，还是后台的数据分析，所有的业务功能都在这里实现。它不再是单一的庞然大物，而是一个由多个自治、专注、可独立部署的服务组成的集群。
核心设计目标：

高内聚，低耦合 (High Cohesion, Low Coupling): 每个服务只做一件事并把它做好。服务之间通过定义良好的API进行通信，互不了解对方的内部实现。
弹性与可扩展性 (Elasticity &amp; Scalability): 能够根据业务负载的变化，自动、快速地增加或减少服务实例的数量，以最高效的方式利用资源。
故障隔离 (Fault Isolation): 一个服务的故障不应该导致整个系统的瘫痪。故障的影响范围应被限制在服务内部或其直接调用方。

这一层的设计直接决定了系统能否在业务快速发展的同时，保持技术上的灵活性和稳定性。

4.2 核心组件与策略详解A. 微服务化 (Microservices)
核心职责:将一个庞大的单体应用（Monolith）按照业务边界（Domain Boundary）拆分成多个更小、更独立的服务。例如，一个电商系统可以拆分为：用户服务、商品服务、订单服务、支付服务、库存服务等。

如何实现高可用与高并发:

独立部署与扩展 (Independent Deployment &amp; Scaling):
机制: 每个微服务都可以独立地进行开发、测试、部署和升级。例如，在“双十一”大促期间，我们可以只针对“订单服务”和“商品服务”进行大规模扩容（比如扩容到100个实例），而“用户服务”（主要是登录，压力相对较小）可能只需要10个实例。
高并发价值: 实现了资源的精细化、按需分配。我们可以把计算资源集中在最需要的地方，从而以更低的成本支撑更高的并发量。而在单体应用中，我们只能对整个应用进行扩容，即使只有10%的代码是性能瓶颈，也必须为另外90%的非瓶颈代码付出同样的扩容成本。


故障隔离 (Fault Isolation):
机制: 如果“推荐服务”因为一个内存泄漏的BUG而频繁崩溃，它不会影响到核心的“订单服务”或“支付服务”的运行。最坏的情况只是用户暂时看不到商品推荐。
高可用价值: 这大大提高了整个系统的健壮性。故障的影响被“防火墙”隔离在了单个服务的边界内，避免了“一颗老鼠屎坏了一锅汤”的情况。


技术栈异构 (Technology Heterogeneity):
机制: 不同的服务可以根据其业务特点选择最适合的技术栈。例如，可以用Java&#x2F;Spring Boot来编写复杂的业务逻辑服务，用Python&#x2F;Django来做数据分析服务，用Go来写需要高性能网络I&#x2F;O的中间件服务。
价值: 允许团队使用最合适的工具解决问题，有助于提升开发效率和系统性能。





B. 无状态服务 (Stateless Service)
核心职责:这是实现无缝水平扩展的基石。无状态服务指的是，服务本身不存储任何与特定请求或会话相关的状态信息。对于任何一个请求，集群中的任意一个实例处理的结果都应该是一样的。

如何实现高可用与高并发:

机制: 那么状态信息（如用户的登录会话、购物车内容）存到哪里去呢？答案是：外部化存储。通常我们会把这些状态存放在一个共享的、高性能的外部系统中，如**分布式缓存（Redis）**或数据库。
高可用&#x2F;高并发价值:
任意扩展: 因为每个实例都不包含独一无二的数据，所以我们可以随时增加新的实例来分担流量，也可以随时下线任何一个实例而不用担心数据丢失。
请求自由路由: 负载均衡器可以把同一个用户的连续请求发送到不同的服务实例上，这极大简化了负载均衡策略。
快速故障恢复: 如果一个实例宕机，Kubernetes等编排工具可以立刻启动一个新实例来替代它。由于状态在外部，新实例可以立即投入工作，无缝衔接。





C. 容器化与编排 (Containerization &amp; Orchestration)
核心职责:提供一种标准化的、与环境无关的应用打包、分发和运行方式，并自动化地管理这些应用的生命周期。

如何实现高可用与高并发:

Docker - 标准化打包:
机制: Docker将应用及其所有依赖（库、配置文件等）打包成一个轻量、可移植的“容器”镜像。这个镜像可以在任何支持Docker的机器上以完全相同的方式运行，解决了“在我电脑上明明是好的”这一经典问题。
价值: 实现了环境一致性，极大地简化了部署流程，是实现快速、可靠的持续集成&#x2F;持续部署（CI&#x2F;CD）的基础。


Kubernetes (K8s) - 自动化编排:
机制: Kubernetes是一个容器编排平台，你可以把它看作是管理成千上万个容器的“操作系统”。我们只需要向K8s声明我们期望的状态（例如，“我需要我的订单服务运行10个副本”），K8s就会自动地完成剩下的一切。
高可用价值:
自愈 (Self-healing): K8s会持续监控所有容器的健康状况。如果一个容器崩溃了，K8s会自动在另一台健康的物理机上重新启动一个新的容器来替代它。
自动扩缩容 (Auto-scaling): 我们可以配置策略，让K8s根据CPU或内存的使用率，自动增加或减少服务的副本数量（即容器实例数）。当流量高峰来临时，系统自动扩容；当流量低谷时，自动缩容，节省成本。
滚动更新 (Rolling Update): 在发布新版本时，K8s可以逐个地替换旧的容器实例，而不是一次性全部停止。这保证了应用在更新过程中服务不中断。








4.3 本章总结业务服务层是高可用架构的“血肉”。通过微服务化，我们将系统拆分为灵活、自治的单元；通过无状态设计，我们为这些单元的自由伸缩奠定了基础；最终，通过Docker和Kubernetes，我们获得了强大的自动化运维能力，包括自愈、自动扩缩容和零停机发布。这三者结合，共同构建了一个既能应对高并发冲击，又能在故障面前快速恢复的弹性服务集群。
架构图中的流程:
            (从第三层: API网关)                    |                    V+-------------------------------------------------------------+|               Kubernetes Cluster (多台物理/虚拟机)             ||                                                             ||   +--------------+      +--------------+      +--------------+  ||   | 订单服务 Pod 1 |      | 订单服务 Pod 2 | ...  | 订单服务 Pod N |  |  &lt;- 自动扩缩容|   +--------------+      +--------------+      +--------------+  ||         ^                                                     ||         | Service A (e.g., Order Service)                     ||         |                                                     ||   +--------------+      +--------------+                      ||   | 用户服务 Pod 1 |      | 用户服务 Pod 2 | ...                  |  &lt;- 故障自愈|   +--------------+      +--------------+                      ||         ^                                                     ||         | Service B (e.g., User Service)                      ||         |                                                     ||   +-----+--------+                                            ||   |  ... 其他服务  |                                            ||   +--------------+                                            ||                                                             |+-------------------------------------------------------------+         |           |            |         |           |            | (读写数据/状态)         V           V            V      (下一层: 数据与状态层 - 缓存/消息队列/数据库)

业务逻辑处理完毕后，不可避免地需要与数据打交道。下一章，我们将深入探讨架构的“地基”——数据与状态层，看看如何让数据存储也实现高可用和高并发。
第五章：数据与状态层 (Data &amp; State Layer)5.1 本章定位：系统的“中央银行”与“记忆中心”这一层是所有业务数据的最终归宿和状态信息的管理者。它负责持久化存储（Durability）核心数据，并提供高性能的数据访问（Performance）。在分布式系统中，数据的**一致性（Consistency）和可用性（Availability）**是这一层永恒的主题。
核心设计挑战：

高可用性: 即使部分存储节点发生硬件故障、网络分区，数据也不能丢失，并且服务应尽可能保持可用。
高性能&#x2F;高并发: 必须能够支撑上层成千上万个服务实例同时进行的高并发读写请求。
可扩展性: 当数据量或访问量增长时，必须有能力平滑地扩展存储容量和吞吐能力。

这一层的设计往往是整个架构中最昂贵、最复杂的部分，但也是决定系统质量上限的关键。

5.2 核心组件与策略详解A. 缓存集群 (Cache Cluster) - 高速公路的“快车道”
核心职责:在内存中存储那些被频繁读取但不经常修改的数据（即“热点数据”），例如商品信息、用户配置、首页内容等。其目的是减少对后端慢速存储（如关系型数据库）的直接访问。

如何实现高可用与高并发:

读写分离与数据冗余 (Replication):
机制: 使用主从（Master-Slave）架构。写操作只在主节点进行，然后异步地复制到多个从节点。读操作可以由所有的从节点来分担。
高并发价值: 极大地提升了读性能，因为可以水平扩展多个从节点来应对海量的读取请求。
高可用价值: 当主节点宕机时，可以从从节点中选举一个新的主节点（例如通过 Redis Sentinel 机制），实现自动故障转移，保证写入服务在短时间内恢复。


数据分片 (Sharding):
机制: 当单个Redis实例的内存容量或QPS达到瓶颈时，需要将数据分散到多个实例中。Redis Cluster 方案通过哈希槽（hash slots）的方式，自动将不同的key-value映射到不同的物理节点上。客户端请求任何一个节点，如果数据不在该节点，它会被透明地重定向到正确的节点。
高并发&#x2F;高扩展性价值: 打破了单机内存和CPU的限制，使得缓存集群的容量和吞吐能力可以理论上无限地水平扩展。




缓存使用模式:

Cache-Aside (旁路缓存): 最常用的模式。读：先读缓存，没有则读数据库，然后写回缓存。写：先更新数据库，然后删除缓存。
Read-Through &#x2F; Write-Through: 缓存作为唯一的数据源对应用透明，由缓存服务自身负责与数据库的同步。


技术选型: Redis, Memcached


B. 消息队列集群 (Message Queue Cluster) - 系统的“减震器”与“耦合器”
核心职责:提供一个异步通信的中间层，主要用于服务解耦、流量削峰、异步处理。

如何实现高可用与高并发:

异步处理 (Asynchronous Processing):
机制: 对于一些非核心、耗时的操作，主流程不必等待其完成。例如，用户下单后，订单服务只需成功写入数据库并向MQ发送一条“订单创建成功”的消息，就可以立即向上游返回成功响应。至于后续的扣减库存、发送通知邮件&#x2F;短信、增加用户积分等操作，都由下游的订阅者服务异步地去消费这条消息来完成。
高并发价值: 极大地缩短了核心链路的响应时间，显著提升了用户体验和系统的吞吐量。


流量削峰 (Traffic Shaping &#x2F; Peak Shaving):
机制: 在秒杀、大促等场景下，瞬间的流量洪峰可能会冲垮数据库。MQ此时可以作为一个巨大的“蓄水池”。前端应用以其最大能力将请求写入MQ，而后端的消费者服务则以自己平稳的处理速率（如每秒1000个订单）从MQ中拉取并处理。
高并发价值: 它将瞬时的高峰流量“拉平”成一段时间内的平稳流量，保护了后端脆弱的存储系统，是应对流量脉冲的“核武器”。


高可用与数据持久化:
机制: 现代MQ（如 Kafka, RocketMQ）天生就是分布式集群。数据（消息）被写入到Topic的不同分区（Partition）中，每个分区都有多个副本（Replicas）分布在不同的物理机（Broker）上。
高可用价值: 即使某个Broker宕机，存储在其上的分区副本依然在其他Broker上可用，保证了消息不丢失和服务不中断。




技术选型: Kafka (高吞吐量，日志场景), RocketMQ (金融级可靠性), RabbitMQ (功能灵活，成熟稳定)


C. 数据库集群 (Database Cluster) - 数据的“金库”
核心职责:作为系统最核心、最权威的数据存储，保证数据的ACID特性（原子性、一致性、隔离性、持久性）。

如何实现高可用与高并发:

读写分离 (Read&#x2F;Write Splitting):
机制: 与缓存类似，采用主从复制架构。一个主库（Master）负责所有写操作（INSERT, UPDATE, DELETE），多个从库（Slaves）同步主库的数据，并对外提供读服务（SELECT）。应用层或数据库中间件会根据SQL语句的类型，将写请求路由到主库，读请求路由到从库。
高并发价值: 大部分应用的读写比远大于1（例如10:1）。通过水平扩展从库数量，可以线性提升系统的读性能。


分库分表 (Sharding):
机制: 当单一数据库或单一数据表的容量或写入并发量达到极限时，需要进行水平拆分。
分库: 将不同业务的数据存到不同的数据库中（如用户库、订单库）。
分表: 将一张大表（如订单表）按照某种规则（如用户ID哈希取模、按时间范围）水平拆分到多张物理表中。这些物理表可以分布在同一个数据库，也可以分布在不同的数据库中。


高并发&#x2F;高扩展性价值: 这是解决数据库写入瓶颈和存储容量瓶颈的终极方案。它将压力分散到多个物理节点上，实现了数据库的水平扩展。


高可用架构:
机制:
主从+自动切换: 使用MHA (Master High Availability) 或 Orchestrator 等工具监控主库状态，一旦主库宕机，能自动在几秒到几十秒内将一个从库提升为新主库，并让其他从库指向新主。
多主同步&#x2F;分布式数据库: 采用 Galera Cluster, Percona XtraDB Cluster (PXC) 等方案实现多节点同时可写，或者直接采用原生分布式数据库如 TiDB, CockroachDB。


高可用价值: 确保了数据库服务的连续性，将RTO（恢复时间目标）降到最低。




技术选型:

关系型: MySQL, PostgreSQL
数据库中间件: ShardingSphere, MyCAT
分布式数据库: TiDB, CockroachDB, Google Spanner
NoSQL: MongoDB, Cassandra (适用于特定场景)




5.3 本章总结数据与状态层是架构中最需要精雕细琢的部分。我们通过引入缓存集群作为高速挡箭牌，保护了数据库；通过消息队列实现了系统的削峰和解耦；并通过数据库的读写分离、分库分表和高可用架构，确保了核心数据存储的性能、可扩展性和永不宕机。这三者共同构成了坚实可靠的数据基座。
架构图中的交互:
     (从第四层: 业务服务层)             |             |  (高频读/状态存储)+------------+-------------+|                          |V                          V[ Cache Cluster ]         [ Message Queue Cluster ] &lt;--- (异步/削峰) --- [业务服务层](e.g., Redis)             (e.g., Kafka)  ^   |                      |   ^  |   | (低频读/核心写)      |   | (异步消费)  |   |                      V   |  |   +------&gt; [ DB Proxy / Middleware ] ----&gt; [ Database Cluster ]  |                 (e.g., ShardingSphere)       (e.g., MySQL主从/分片)  |                                                  ^  +--------------------------------------------------+                (缓存未命中时回源)

至此，一个完整的业务请求流程已经走完。但是，系统要能长期稳定运行，还需要一双“眼睛”来时刻监控它。下一章，我们将探讨最后的支撑体系——运维与可观测性。
第六章：运维与可观测性 (Operations &amp; Observability)6.1 本章定位：系统的“神经网络”与“健康监护中心”这一层不直接处理用户的业务请求，但它像一个无处不在的神经网络，渗透到架构的每一个角落。它的核心职责是**“让不可见变为可见”**，确保我们能够实时、清晰地了解系统内部正在发生的一切，并在问题发生时（甚至在发生前）提供足够的信息来进行预警、定位和解决。
可观测性的三大支柱：

日志 (Logging): 回答 “发生了什么？”。记录离散的、具体的事件。
指标 (Metrics): 回答 “情况怎么样？”。聚合的、可量化的数据，用于衡量系统健康状况和趋势。
追踪 (Tracing): 回答 “为什么会这样？”。记录单个请求在分布式系统中的完整调用链路，用于诊断性能瓶颈和错误根源。

这一层是提升团队运维效率、保障系统SLA（服务等级协议）、实现快速故障恢复的基石。

6.2 核心组件与策略详解A. 集中式日志系统 (Centralized Logging)
核心职责:在微服务架构中，日志散落在成百上千个服务实例的文件系统中，手动排查问题如同大海捞针。集中式日志系统的任务就是将所有这些分散的日志**收集（Collect）、聚合（Aggregate）、存储（Store）起来，并提供一个统一的搜索（Search）和分析（Analyze）**界面。

典型工作流 (ELK&#x2F;EFK Stack):

数据采集 (Shipper): 在每个业务服务器节点上部署一个轻量级的日志采集代理（Agent），如 Filebeat 或 Fluentd。这个代理负责监听本地的日志文件（如 app.log, nginx_access.log），并将新增的日志行实时发送出去。
数据处理与转发 (Processor): （可选但常用）采集到的原始日志通常是无格式的文本。它们会被发送到一个中间处理层，如 Logstash 或 Fluentd，在这里进行解析（Parsing）（如将一行文本解析成JSON结构，提取出时间、日志级别、请求ID等字段）、过滤（Filtering）和丰富（Enriching）（如根据IP地址添加地理位置信息）。
数据存储与索引 (Storage &amp; Indexing): 处理干净的、结构化的日志数据最终被发送到 Elasticsearch 集群中。Elasticsearch 会对这些数据进行索引，以提供毫秒级的全文搜索能力。
数据可视化与查询 (Visualization): 运维和开发人员通过 Kibana 的Web界面，可以像使用Google一样，方便地查询、筛选、聚合日志，并创建各种仪表盘来监控日志趋势（如错误日志数量的变化）。


高可用价值:

故障排查效率提升几个数量级: 当用户报告问题时，开发人员可以通过一个唯一的请求ID（Trace ID），在Kibana中一键搜出这个请求经过的所有服务的全部相关日志。
实时告警: 可以基于日志内容设置告警。例如，当某个服务的错误日志（ERROR level）在5分钟内超过100条时，自动通过钉钉、Slack或邮件通知相关人员。



B. 监控与告警系统 (Monitoring &amp; Alerting)
核心职责:持续地、周期性地采集系统的聚合指标（Metrics），并将其可视化，同时基于这些指标设置告警规则。

典型工作流 (Prometheus + Grafana Stack):

指标暴露 (Exposition): 应用程序（或通过中间件&#x2F;exporter）需要以一种标准格式（如Prometheus的文本格式）通过一个HTTP端点（如 /metrics）暴露出自身的内部状态指标。例如：当前活跃请求数、API平均响应时间、JVM内存使用率、数据库连接池状态等。
指标拉取 (Scraping): Prometheus Server 会定期（如每15秒）主动地从这些端点“拉取”指标数据，并将其存储在自己的时序数据库（TSDB）中。
查询与告警 (Querying &amp; Alerting): Prometheus 提供了强大的查询语言（PromQL），可以对收集到的指标进行复杂的查询和聚合。Alertmanager 组件则负责根据预设的告警规则（如“CPU使用率连续5分钟超过80%”）进行去重、分组，并将告警发送到指定的通知渠道。
可视化 (Visualization): Grafana 是一个开源的可视化平台，它可以连接到Prometheus作为数据源，通过配置丰富的图表、仪表盘，将枯燥的指标数据以直观、美观的方式展示出来。


高可用价值:

宏观健康度概览: 通过仪表盘，运维人员可以一目了然地看到整个集群的健康状况，快速发现异常波动。
趋势分析与容量规划: 长期存储的指标数据可以用于分析业务增长趋势，为未来的扩容提供数据支持。
主动发现问题: 告警系统能够在问题影响到最终用户之前，就通知相关人员介入处理，实现“预防胜于治疗”。



C. 分布式追踪系统 (Distributed Tracing &#x2F; APM)
核心职责:当一个请求跨越多个微服务时，追踪系统能够将这个请求在每个服务内部的耗时、调用关系串联起来，形成一个完整的**调用链（Trace）**视图。


典型工作流 (SkyWalking &#x2F; Jaeger):


数据埋点 (Instrumentation): 通过在应用程序中引入一个Agent或SDK（通常是无侵入的字节码增强技术），自动地在服务调用的入口和出口进行“埋点”。当一个请求进入服务A时，Agent会生成一个唯一的 Trace ID 和一个 Span ID。当服务A调用服务B时，它会通过HTTP Header或RPC元数据将Trace ID和父Span ID传递给服务B。
数据上报 (Reporting): 每个服务中的Agent会将各自的Span信息（包含服务名、接口名、开始&#x2F;结束时间、标签、日志等）异步地上报给追踪系统的收集器（Collector）。
数据处理与存储 (Processing &amp; Storage): 收集器接收到来自各个服务的Span数据，将属于同一个Trace ID的Span组合起来，构建出完整的调用链拓扑关系，并将其存储起来（通常使用Elasticsearch或Cassandra）。
数据展示 (UI): 追踪系统提供一个Web UI，开发人员可以根据Trace ID查询，或者根据服务、接口等维度查找慢请求或错误请求，并查看其详细的甘特图，清晰地看到每个环节的耗时。


高可用价值:

性能瓶颈定位: 当一个API响应缓慢时，通过调用链视图可以一目了然地看到是哪个下游服务的调用慢，还是哪个数据库查询慢，或是服务内部的某个方法耗时长。
分布式系统错误分析: 可以清晰地看到错误是在哪个服务节点上首次发生的，以及它是如何影响到上游服务的。
服务依赖关系可视化: 追踪系统可以根据收集到的数据，自动生成整个系统的服务依赖拓扑图，帮助理解复杂的系统结构。




6.3 本章总结运维与可观测性是保障高可用架构“名副其实”的最后一块拼图，也是最关键的一块。集中式日志提供了事后追溯的详细线索，监控告警提供了宏观实时的健康心跳，而分布式追踪则提供了深入微观世界的性能“手术刀”。这三者结合，为我们构建了一个强大的、立体化的“作战指挥室”，使得我们有能力驾驭复杂、庞大的分布式系统，确保其持续稳定、高效地运行。
至此，我们已经完整地走完了构建一个高可用、高并发后端架构的六个核心章节。从外到内，从请求的入口到数据的存储，再到全方位的监控，每一层都环环相扣，共同支撑起一个强大而有弹性的系统。
]]></content>
      <categories>
        <category>技术</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>protected</tag>
        <tag>杂谈</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>高通410随身wifi刷机教程</title>
    <url>/2023/06/18/%E9%AB%98%E9%80%9A410%E9%9A%8F%E8%BA%ABwifi%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[前言本教程适用于基于高通410的cpu随身wifi。
基本样式
如果需要刷openwrt和Debian，只有纸盒系和类纸盒的uz801、sp970，其它型号不能刷。（不确定 没尝试过）
常见问题简单说几个常见问题: 

SIM卡要插对；
天线别弄掉了（弄掉了再插回去）；
板子所处位置的信号不能太差，台式电脑建议用后面主板的USB口，有些电脑前置USB口容易供电不足；
很多软件问题可以重启或者更换电脑就能解决；
刷机前最好先备份；
拿到板子后插卡确认能否识别sim卡以及数据wifi功能是否正常，然后撬开外壳确定自己的板子是什么型号。

准备工作​	工具文件可能被系统报毒删除，所以以win10为例，建议新建一个随身WiFi文件夹，然后在Windows安全中心一病毒和威胁防护一病毒威胁防护设置一管理设置一排除项一添加排除项，把文件夹添加进去，然后把刷机文件下载到这里，就不会被系统删除了，其它杀毒软件也可以类似这样设置。
安装驱动需要提前安装高通的驱动：高通板子刷机需要安装9008驱动和adb驱动，打开并安装文件里的9008driver

把板子插上电脑，等待板子完全开机后，输入命令: adb devices
如果显示有设备连接就说明adb正常 (有些板子adb功能没有打开，可以在本版块搜索开启方法)（比如直接9008刷入其他刷完的包）
进入9008的方法需要9008刷机时再开启此端口。
adb命令进入adb reboot edl

通过按键进入按住板子的恢复键，插入电脑一两秒后听到叮咚一声再松手，在设备管理器里看到端口有9008就表示成功了。（不是所有按键都可以进入9008，进入不了参考下一条方法）
其他方法可以尝试短接usb数据针脚（d+ d-）插入电脑再松开。
成功进入后可以在端口中找到9008字样的设备。

备份这一步非常重要！不建议拿到板子后直接刷的rom包，应该先备份好当前的rom，之后再刷。只要硬件没坏都能救活。
如果自己的板子系统是阉割版的，比如没有热点和网络共享等，可以刷一下别的设备的system包，其它情况不太需要刷别的文件。
备份主要有三个过程：备份基带、Miko loader制作救砖包（全量备份）、
备份固件-miko安装Miko找到miko文件夹，双击miko安装，直接默认就行了，记住安装路径，安装完成后把文件夹内的loader复制到miko的安装目录，替换掉原来的loader.exe。接着创建loader的快捷方式到桌面。
loader备份让板子进入9008模式，打开loader，按照图片数字顺序一步步来。


点read；
点partition backup；
双击下面double click to open save folder；
选好救砖包生成的路径：点load partition structure；
点击全选按钮选中所有的分区；
点read full image就能制作刷机救砖包，大概5分钟以内。

保存好这个名为.bin的单文件，后期救砖需要它
刷机&#x2F;救砖方法图片也标注了顺序，分别点flash，emmc block0，flasher，double click….， flash!

备份固件-QPT用Qualcomm Premium Tool（QPT）备份全部分区文件。
激活QPT（只需要激活一次）打开它的文件夹，有个提示先注册的程序，注意要把电脑音量调低!。然后点开它后可能会提示安装一些东西，同意就行了，没有的话不用管，弹出窗口点击GenerateKey,生成的key放在你知道的文件夹内。

打开Qualcomm Premium Tool程序，左上菜单栏找到help-active,选择刚才生成的key就能激活这个软件了。

备份按照前面介绍的方法使板子进入9008模式，在Qualcomm Premium Tool按照图片数字一步一步进行。
注意，如果前面Miko备份完，记得拔掉棒子再次进入9008后再进行备份。


Qualcomm选项卡
partition子选项卡
scan单选按钮
Do job按钮
backup单选按钮
backup ALL复选框
Do job按钮

备份的文件保存好，后续可能有用
如果需要刷写某些分区，点击scan识别分区后，点write, 再选要刷如果需要刷写某些分区，点击扫描识别分区后，点写，再选要刷的分区，点Do job后选择分区文件，就能完成刷写该分区。的分区，点做好后选择分区文件，就能完成刷写该分区。
备份基带（需要进行root操作）前提
在设备管理器中的端口（COM和LPT）中可以看到9091或901D字样的设备



通用串行总线设备中看到ADB interface字样的设备（或者在最开头的几个选项卡中）




root备份qcn和root。需要先进行root,简单点的办法就是安装magisk,再刷一下修补过的boot文件就有root了。当然我更建议自己修补boot,不用等别人做好，出问题的概率也更小。
下面是如何自己动手获得root权限:

首先安装ardc,这是一个投屏软件，解决板子没有屏幕无法操作的问题，它的操作逻辑是鼠标左键为点击功能，右键为返回。

安装完ardc后先别打开，检查一下任务管理器中，有adb或者android debug bridge程序在后台的话记得停掉，再把板子插到电脑上正常启动，打开ardc等待画面变化，成功后会停在深蓝色界面，然后把鼠标箭头移到此界面，右键点击两下，如果没有出现桌面，需要安装一个第三方桌面启动器，把我提供的apk文件里的launcher从电脑直接托到ardc界面就会自动给板子安装。




等五秒后在主界面点一下鼠标右键，应该会出现选择主屏幕应用选择，点launcher和始终。




然后就能看到板子的系统界面了，接着安装es文件管理器和magisk,也是直接拖到ardc界面自动安装，装好后点开文件管理器，进入下载文件夹，把之前Qualcomm备份的boot文件直接托到这里，就会复制过来了(几秒钟，点下面的刷新就会显示出来) 





退出es,点开magisk,找到图片提示的位置




安装&gt;下一步&gt;选择并修补一个文件，选择刚才复制过来的boot,然后开始，等待它修补完成，退出并来到es文件管理器，进入下载，发现修补好的boot文件名太长了，长按后重命名为magiskboot.img。再点击ardc菜单最后一个&gt;&gt;;弹出的cmd这里(实际就是这个软件也集成了adb功能，这里直接使用它的)




输入命令: 
adb pull /sdcard/Download/magiskboot.img D:/xxx

这里D:&#x2F;xxx换成你自己的路径(斜杠朝左还是朝右都可以)，接着按回车就会把magiskboot.img导出到你的电脑上的指定位置。

再输入命令: 
adb reboot bootloader

板子会重启到fastboot模式，然后输入命令: 
fastboot flash boot 

后再按个空格键，接着把电脑上 上一步备份的boot文件magiskboot.img拖到这里，会自动生成文件路径名成文件路径名。




再按回车等待几秒完成后输入命令:
fastboot reboot

板子重启后打开magisk (可能得多等会)，看到下面四个图标，第二个就是超级用户，那么root就完成了。





备份
下面是备份qcn的工作，依然在ARDC的&gt;&gt;这里的cmd后输入命令: 
adb shell su

然后会显示shell申请权限，点永久就行了，接着在magisk的超级用户里看看shell授权成功与否。




关掉ardc，同时在任务管理器里如果发现adb还在后台也要关掉，然后打开星海svip这个软件 (免安装)，如果打开时提示缺少库文件，安装我提供的微软软件包，装好后最好重启一下电脑就能打开星海了，以后如果操作没问题，这个软件还是报错的就重启电脑选择高通，再点联机会出现设备信息，找到高通强开1（如果不行也可以试试强开2），点一键执行，在设备管理器上查看是否有端口901D（如果开启失败可以尝试手动开启，文件夹里有命令代码）





接着备份qcn，一键执行，选择qcn文件生成路径，正常情况就能备份qcn成功，如果不行就检查901d端口或者重启电脑，备份的qcn一般在500多k，远小于这个大小的应该是备份失败了，建议再来一次。





注意事项高通工具的备份和miko的备份的不同：

miko它是把所有的分区全部备份成一个单个的文件
高通的这个备份它是把每一个分区备份成单独的文件

两者两种方式备份出来的文件数量有区别，但本质上来说备份的是同一个东西。
高通的这个工具备份出来的这个分区文件是可以用其他工具来打开并且提取里面的内容的
而miko的呢不行。
同样的在还原的时候，因为刷完Debian以后所有的分区都会被改动掉，所以用高通的工具去还原会发现对应不上分区。所以得用miko的工具来还原。
刷机androidAndroid，一般情况刷回自己的包就用Miko loader这个软件，比较简单。刷单个分区，可以用Qualcomm工具，前面都已经介绍；
或者进fastboot模式，用命令刷分区，比如刷system分区，命令就是fastboot flash system 加上分区路径 (和前面刷boot一样，直接拖到这里，如果失败，把文件放到adb目录下，把分区路径换成分区文件名system.img也能刷，效果更好)
Debian刷机过程作者网址有介绍，001b 001c sp970 uz801作者给了boot和firmware文件用来替换。如果刷后不识别手机卡，可以这样试试看：	参考了酷友lkiuyu 的动态，刷回安卓，恢复出厂设置，再root后用星海擦写基带 (擦写基带在fastboot模式下)，接着写入自己的qcn (写入qcn也要开启901d端口)，才能装Debian，boot要替换成作者提供的001c的，别用自己的。firmware需要替换成自己备份的 (把Qualcomm工具备份的NON-HLS.bin用diskgenius的虚拟磁盘打开并提取出来，接着用winscp登录Debian后把它复制到&#x2F;home&#x2F;user下，再ssh登录Debian，sudo -i获得权限，再用命令cp -rf &#x2F;home&#x2F;user&#x2F;你提取的基带文件&#x2F;*&#x2F;usr&#x2F;lib&#x2F;firmware&#x2F;，完成替换，重启板子基带应该就能用了。
项目地址：
大致步骤如下：

重启到fastboot模式

//使用adb连接到设备
adb devices

//重启到fastboot
adb reboot fastboot
   - 重启完事后可以在设备管理器中ADB相关的设备里面有个`Fastboot interface`字样的设备。出现这个设备的时候就证明设备已经重启到fastboot模式下了。2. 解压Debian文件夹中的 `base-generic.zip` 文件，进入解压出来的文件夹中   - ![image-20230618215120258](./Image/随身WiFi刷机教程.assets/image-20230618215120258.png)3. 点击地址栏，删除其中的内容，然后输入 `cmd` 打开cmd4. 在cmd的命令提示符中输入`flash.bat`，然后回车执行。   - ![image-20230618215310151](./Image/随身WiFi刷机教程.assets/image-20230618215310151.png)5. 中途会提示按任意键继续，根据提示按下任意一个键进行下一步。中途可能会听到设备弹出后再插入的提示音。继续按空格即可。6. 回到上一级，解压 `debian.zip` 文件，并进入解压出来的文件夹中   - ![image-20230618215517226](./Image/随身WiFi刷机教程.assets/image-20230618215517226.png)7. 再次清空地址栏，输入cmd，打开cmd窗口。8. 继续flash.bat，回车运行。   - ![image-20230618215614847](./Image/随身WiFi刷机教程.assets/image-20230618215614847.png)9. 继续按照提示按下任意按键。这回可能就需要一段时间了，因为正在推送系统到设备。   ## OpenWrtOpenWrt刷机就简单多了，进入fastboot模式打开脚本自动刷原作者仍只提供了001b版本，其它型号直接在本版块搜索，有不少酷友编译。如果遇到问题可以到我另一个动态看看解决办法。最后说一下，Debian和openwrt都有adb功能，刷这些系统都可以进fastboot模式刷，不用回到安卓。# Linux相关## 刷完初次进入linux时的准备工作检查`网络适配器`中是否存在一个基于远程NDIS的Internet共享…如果不存在，且在`其他设备`中存在一个名叫 `RNDIS`的设备，则右键点击这个设备，选择`更新驱动程序`，选择`浏览我的电脑以查找驱动程序`，接着 `让我从计算机上的可用驱动程序列表中选取`，拉到最下面找到 `网络适配器`，在厂商一栏中找到 `MicroSoft`，右侧的型号栏目中选择 `基于远程NDIS的Internet共享设备`。## 基础的系统配置1. 登录系统：初始用户：`user`，初始密码`1`2. 连接WIFI   ```bash   sudo nmtui



会显示一个蓝色背景的界面，使用上下光标键移动，选择 Activate a connection（回车），选择要连接的WiFi，回车，输入wifi密码，回车。
连上以后wifi名的左侧会多一个*号，同时右侧会有一个 Deactivate断开的选项。
按tab键将光标移动到back，回车，选择 Quit回车，回到ssh界面。
使用 sudo ifconfig命令就能看到一个连上WiFi以后得到的ip地址。
接下来就能使用这个ip地址进行登录。此时棒子就可以不插在电脑上，插在任意一个具有供电能力的设备上都能连接上了。

配置root用户密码
sudo passwd root

接下来要输入设置的密码。注意输入密码的时候是不可见的。

切换到root用户
sudo su



允许root用户远程登录，重启服务或系统后生效
echo &quot;PermitRootLogin yes&quot; &gt;&gt; /etc/ssh/sshd_config



修复mobian源并安装基础软件（逐行复制并执行）
apt updateapt install curl -yecho &quot;deb http://repo.mobian-project.org/ bookworm main non-free&quot; &gt; /etc/apt/sources.list.d/mobian.listcurl -s https://repo.mobian.org/mobian.gpg &gt; /etc/apt/trusted.gpg.d/mobian.gpgapt updateapt install vim wget git cron dnsutils unzip lrzsz fdisk gdisk exfat-fuse exfat-utils -y

可能需要一段时间，耐心等待即可。

配置系统时间
dpkg-reconfigure tzdata

选6 亚洲
然后选70 上海（亚洲 上海），需要按回车显示下一页，直到70 shanghai的选项出现，才能输入70.

配置ll命令
echo &quot;alias ll=&#x27;ls $LS_OPTIONS -alh&#x27;&quot; &gt;&gt; ~/.bashrc



修改vi配置
echo -e &quot;if has(&#x27;mouse&#x27;)\nset mouse-=a\nendif&quot; &gt; .vimrc



修改usb为主动模式
vi /usr/sbin/mobian-usb-gadget

把下面这行添加到[ setup() { ]的下一行
echo host &gt; /sys/kernel/debug/usb/ci_hdrc.0/role
然后:wq保存退出
注意，此条命令一旦执行，棒子再插到电脑上就不会显示成设备了，而是作为一个独立的主机存在。

重启设备
reboot

挂载u盘、配置开启启动、安装软件由于后续所有操作都直接用root用户登陆后操作，删掉已经没用的自带用户user
userdel -r user



挂载u盘
创建用于挂载的目录
mkdir /udisk



插上U盘，查看是否已经识别到
fdisk -l

可以看到Disk开头的文本，默认是挂载在/dev/sda目录中。
也有可能是sdb，一定要区分好

清理磁盘分区并新建（如果是大于2T的移动硬盘，下一条命令中的fdisk换成gdisk）
fdisk /dev/sda

然后按下如下字母执行操作

d   #删除分区

可以多按几下，直到出现 No partition is defined yet提示没有任何分区为止。


n   #新建分区，一路回车

如果提示yes or no，输入y然后回车


w   #保存更改

如果提示yes or no，输入y然后回车




再用 fdisk -l命令查看，可以发现插入的存储设备挂载的目录可能发生了变化。记住这个目录，后面要用.
比如 &#x2F;dev&#x2F;sda1

格式化分区
ext4性能好安全性高但不兼容windows，exfat性能差安全性差但兼容windows
mkfs.ext4 /dev/sda1或mkfs.exfat /dev/sda1

二者选其一执行。推荐ext4格式。
注意，如果存储设备是金士顿的这类写入速度很慢的设备，则此过程可能会很久，甚至卡死。

挂载
#挂载mount /dev/sda1 /udisk#mount /dev/sdb1 /hdisk#授权chmod 777 /udisk

配置开机行为
创建启动脚本
touch /etc/rc.localecho &#x27;#!/bin/sh -e&#x27; &gt; /etc/rc.localecho &quot;exit 0&quot; &gt;&gt; /etc/rc.local



给权限
chmod +x /etc/rc.local



重载systemd配置管理器
systemctl daemon-reload



启动守护进程
systemctl start rc-local



修改启动脚本
vi /etc/rc.local

将下方代码块中的内容复制到vi编辑器中。注意复制之前需要删除原有的数据。注意#开头的中文注释需要删除掉，因为可能会乱码
#!/bin/sh -e#等待2秒等待设备彻底启动完成sleep 2#开机自动挂载硬盘，可以修改成fstab？mount /dev/sda1 /udisk &amp;#等待5秒等待挂载完毕sleep 3#如果不安装接下来的miniDLNA，则这部分的内容不需要复制#清空minidlna缓存minidlnad -R#等待3秒等待清空完成sleep 2#启动dlnasystemctl start minidlna &amp;#如果不安装接下来的aria2，则这部分的内容不需要复制#启动aria2aria2c -D --conf-path=/etc/aria2/aria2.conf &amp;#可以试图把ddns的脚本粘贴到这里面exit 0

安装软件samba共享
安装samba
apt install samba samba-common-bin -y



修改配置文件
vi /etc/samba/smb.conf

将下方代码块中的内容复制到配置文件中。进入vi编辑器后要删除掉所有原来的数据。
[global]   workgroup = WORKGROUP   log file = /var/log/samba/log.%m   max log size = 1000   panic action = /usr/share/samba/panic-action %d   passdb backend = tdbsam   obey pam restrictions = yes   unix password sync = yes   security = user   passwd program = /usr/bin/passwd %u   passwd chat = *Enter\snew\s*\spassword:* %n\n *Retype\snew\s*\spassword:* %n\n *password\supdated\ssuccessfully* .   pam password change = yes   map to guest = bad user   load printers = no[samba]   browseable = yes   valid users = root   #samba共享的目录   path = /udisk   writable = yes   public = no   guest ok = no



配置samba用户，输入密码
smbpasswd -a root



重启samba服务
samba restart

注意事项与说明
samba用于局域网间共享文件
samba虽然也有端口号，也有协议，但没办法映射外网，是没有办法跨网段的，只能在当前网段中使用。

aria2下载器
新建下载目录并给权限
#分配文件夹mkdir /udisk/download#授权chmod 777 /udisk/download



安装aria2
apt install aria2 -y



创建aria2配置目录
mkdir /etc/aria2



创建aria2会话文件
touch /etc/aria2/aria2.session



创建aria2配置文件
vi /etc/aria2/aria2.conf

将下方代码块中的内容复制到vi编辑器中。注意配置信息不可以是别的，或者需要再修改一下，否则可能无法下载
#下载地址dir=/udisk/downloaddisk-cache=32Mcontinue=truefile-allocation=nonemax-concurrent-downloads=5max-connection-per-server=5max-overall-download-limit=0max-download-limit=0max-overall-upload-limit=0max-upload-limit=0disable-ipv6=truemin-split-size=10Msplit=10input-file=/etc/aria2/aria2.sessionsave-session=/etc/aria2/aria2.sessionsave-session-interval=60enable-rpc=truerpc-allow-origin-all=truerpc-listen-all=truefollow-torrent=true#peer-id-prefix=-TR2770-user-agent=Transmission/2.77bt-seed-unverified=truebt-save-metadata=truebt-enable-lpd=truebt-max-open-files=100bt-max-peers=60bt-min-crypto-level=plainbt-require-crypto=truelisten-port=65298dht-listen-port=65298seed-ratio=1seed-time=120rpc-secret=test123bt-tracker=udp://tracker.opentrackr.org:1337/announce,udp://9.rarbg.com:2810/announce,udp://tracker.openbittorrent.com:6969/announce,http://tracker.openbittorrent.com:80/announce,https://opentracker.i2p.rocks:443/announce,udp://tracker.torrent.eu.org:451/announce,udp://open.stealth.si:80/announce,udp://exodus.desync.com:6969/announce,udp://tracker2.dler.org:80/announce,udp://tracker.tiny-vps.com:6969/announce,udp://tracker.moeking.me:6969/announce,udp://tracker.dler.org:6969/announce,udp://tracker.0x.tf:6969/announce,udp://open.demonii.com:1337/announce,udp://movies.zsw.ca:6969/announce,udp://fe.dealclub.de:6969/announce,udp://explodie.org:6969/announce,udp://chouchou.top:8080/announce,udp://bt2.archive.org:6969/announce,udp://bt.oiyo.tk:6969/announce

注意事项开机自启在之前已经配置过来，这里不需要再配置了。
#####手动启动aria2aria2c -D –conf-path&#x3D;&#x2F;etc&#x2F;aria2&#x2F;aria2.conf &amp;
通过aria2.net调用，或者自建aria2 webuihttp://aria2.net/
使用端口6800
lamp环境与filerun 网页云盘注意，此教程只适合arrch64架构的设备，而且部分已经过时，需要注意

安装需要的软件
apt install apache2 php mariadb-server php-mysql php-mbstring php-curl php-gd php-imagick ffmpeg -y



编辑虚拟站点配置
vim /etc/apache2/sites-enabled/000-default.conf

将下方代码块中的内容复制到配置文件中。进入vi编辑器后要删除掉所有原来的数据。
&lt;VirtualHost *:80&gt;        DocumentRoot /var/www/html        ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log        CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined&lt;/VirtualHost&gt;



修改数据库编码
vi /etc/mysql/mariadb.conf.d/50-server.cnf

在[mysqld]字段的添加或修改如下部分
init_connect=&#x27;SET collation_connection = utf8mb4_unicode_ci&#x27;init_connect=&#x27;SET NAMES utf8mb4&#x27;character-set-server=utf8mb4collation-server=utf8mb4_unicode_ciskip-character-set-client-handshake



vi /etc/mysql/mariadb.conf.d/50-client.cnf

在[client]字段的修改如下部分
default-character-set=utf8mb4



vi /etc/mysql/mariadb.conf.d/50-mysql-clients.cnf

在[mysql]字段下修改如下部分
default-character-set=utf8mb4



重启数据库并初始化
#重启数据库systemctl restart mariadb#设置开机自启systemctl enable mariadb#初始化mysql_secure_installation#会提示输入密码，当前没有密码，直接回车即可#问是否切换到的时候输入n表示不切换#询问是否修改密码还是n，不在这里修改#是否移除匿名用户，输入y。Remove anonymous#然后接下来的三个询问都输入y，直到退出

进入数据库	
mysql -uroot -p#由于没有密码直接回车就能进入USE mysql;#这里输入要设置的密码，替换到下方的test123ALTER USER root@localhost IDENTIFIED VIA mysql_native_password USING PASSWORD(&#x27;test123&#x27;);FLUSH PRIVILEGES;#查看配置有没有生效，不打也可以show variables like &quot;%character%&quot;;show variables like &quot;%collation%&quot;;EXIT;#重启数据库systemctl restart mariadb



配置filerun运行环境：
注意不要cd切目录，保持再root用户登录后的初始目录中。

用pscp传输【loader-wizard.php】，【ioncube_loader_lin_7.4.so】，【00-ioncube.ini】，【FileRun_20220519_PHP73-74.zip】
在putty的目录中输入cmd，调出cmd命令框，然后在其中输入下方的几个命令，将文件传输到棒子
pscp loader-wizard.php root@192.168.123.131:/root/pscp ioncube_loader_lin_7.4.so root@192.168.123.131:/root/pscp 00-ioncube.ini root@192.168.123.131:/root/pscp FileRun_20220519_PHP73-74.zip root@192.168.123.131:/root/

或者直接用其他方式将这些文件上传到棒子的/root目录下。

将三个文件放到对应的目录下
mv loader-wizard.php /var/www/html/loader-wizard.phpmv ioncube_loader_lin_7.4.so /usr/lib/php/20210902/ioncube_loader_lin_7.4.somv 00-ioncube.ini /etc/php/8.1/apache2/conf.d/00-ioncube.inisystemctl restart apache2



访问http:&#x2F;&#x2F;设备的IP&#x2F;loader-wizard.php。如果看到绿色的框内容为：
Loader InstalledThe ionCube Loader version 11.0.1 for PHP 7.4 is already installed and encoded files should run without problems.


如果是红色的框则证明之前的操作有问题
那么运行环境就配置好了

删掉无用的文件
rm -rf /var/www/html/*



部署filerun文件包
mkdir 11 &amp;&amp; mv FileRun* 11 &amp;&amp; unzip -d 11 11/FileRun* &amp;&amp; rm 11/FileRun* &amp;&amp; mv 11/* /var/www/html &amp;&amp; rm -rf ~/11mkdir /var/www/html/userfile



设置filerun时区
echo &#x27;&lt;?php date_default_timezone_set(&quot;Asia/Shanghai&quot;); ?&gt;&#x27; &gt; /var/www/html/customizables/config.php



给权限，设置自启
chmod -R 777 /var/www/html/chmod -R 777 /udisksystemctl enable apache2



访问http:&#x2F;&#x2F;你的IP&#x2F;，开始配置


配置Fire RUN
next下一步

再next。应该都是绿色的OK字样。

输入完对应信息，next。
然后就会给一个初始用户。

使用初始用户登录进去

进入之后点击左侧下面的Control panel。

修改密码

输入主目录

汉化

退出再登录，就能看到中文的选项了


此时汉化完成

其他配置



注意事项可以使用FRP或者端口映射的形式进行外网访问。
默认端口80，可以修改
miniDLNA
安装软件包
apt install minidlna -y



修改配置文件
echo &#x27;media_dir=/udisk&#x27; &gt; /etc/minidlna.confecho &#x27;port=8200&#x27; &gt;&gt; /etc/minidlna.confecho &#x27;friendly_name=WiFi-410&#x27; &gt;&gt; /etc/minidlna.conf echo &#x27;inotify=yes&#x27; &gt;&gt; /etc/minidlna.conf



禁用自启
systemctl disable minidlna

后期会在脚本中启动，防止磁盘挂载失败导致认不到视频文件

启动minidlna
systemctl start minidlna


如果dlna认不到新加入的视频，重启一下系统，拔掉棒子再插上就行了


移动硬盘优化防止移动硬盘休眠
crontab -e*&#x2F;3 * * * * echo “1” &gt; &#x2F;udisk&#x2F;download&#x2F;.no-hiberfil
救砖（刷回原始包）Miko
Debian项目WIKIhttps://www.kancloud.cn/handsomehacker/openstick/2636505
概述关于 OpenStick针对于msm8916芯片的4G网卡的逆向工程和Mainline Linux移植。旨在实现一个廉价的带4G功能的ARM64单板电脑（性能其实和树莓派zero2、树莓派3b差不多）。提供完全可用的Debian发行版镜像和刷机方法。另外还会提供emcp扩容等高级玩法。支持电路板丝印为UFI001B、UFI001C、SP970、UZ801开头的4G无线网卡。本项目仅用于学习交流之用，请勿用于商业用途，本刷机包完全免费开源，欢迎举报倒卖的行为。
本教程的所有内容仅供参考，本人及文章作者不对任何刷机和改造设备的行为负责。也没有任何义务处理砖机。
设备具体配置虽然都在网上能查到，但是放在这里还是方便一点。

msm8916 主控 Cortex-A53 * 4 on 0.9GHZ
512MB内存+4GB储存的拆机二手emcp
WCN3620 &amp; WCN3680b
pm8916 PMIC

各外设对应GPIO


型号
red led
green led
blue led
按键



ufi001b&#x2F;c
gpio22
gpio21
gpio20
gpio37


sp970
gpio9
gpio10
gpio28
gpio107


uz801
gpio7
gpio8
gpio6
gpio23


UFI-16-V3
gpio8
(pmic) gpio4
gpio32
gpio49



设备支持情况这意味着主线内核(5.15 和 5.10)的对于设备的驱动程度



功能
支持状况



arm64
支持


KVM 虚拟化
支持


PSCI
支持（v1.0）


自适应emcp空间
支持


WIFI (WCN3620)
支持


WIFI (WCN3680b)
支持


蓝牙
支持


4G 流量
支持


短信
支持


USB HOST
支持


USB DEVICE
支持


Venus 视频解码器
支持


Venus 视频编码器
不支持


GPS
未验证


通话
未验证



注 : SP970与UZ801由于sim切卡gpio尚不明确，暂不支持与modem有关的功能（modem固件是正确的，如果你的机器是硬改实现切卡的可能modem能使用，未测试）。
SP970 V3 机型可能与SP970 V10的wifi芯片不太一样，刷入可能会导致wifi不稳定等问题。
UZ801在安卓下切卡后可能再刷机能使用modem，具体原因未知。
不同批次的相同版型可能存在cpu后缀的差异，使用不了modem的朋友短期内的解决方案只有自行提取modem firmware，未来可以通过独立modem固件分区的方法来实现兼容不同后缀的soc(感谢酷安 @fanxueke)。
HandsomeMod与Debian固件中使用的modem firmware信息如下所示，缺失的机型会在短时间内补充。




板型
SOC后缀



UFI001B
0VV


UFI001C
0VV


UFIW001
0VV


投稿与奉献欢迎各位大佬将自己的玩法或建议以markdown格式发到邮箱**handsomeyingyan@gmail.com**,或者私信（酷安、CSDN @handsomehacker）我们会尽快校对和更新文档，让更多的人看到：p
奉献者感谢所有为项目发展而奉献的朋友，排名不分先后。

HandsomeHacker
fanxueke （酷安 @fanxueke ）
魂梦九霄 （酷安 @魂梦九霄 ）
l305197437 (酷安 @l305197437 )
lilyok123 (酷安 @lilyok123 )
Zy143L (酷安 @Zy143L)

项目相关链接维护项目不易，欢迎star与关注！！HandsomeHacker的CSDN博客OpenStick 项目主页(github)HandsomeMod 项目主页
赞助如果你觉得本项目对你有帮助，欢迎赞助，帮助我们的项目发展的更好！
开始折腾首先你需要在Openstick项目的release中得到最新的Debian或HandsomeMod(可能会鸽)刷机包。然后准备好fastboot与adb工具,windows版本会在release中提供，linux直接使用包管理器中提供的版本即可。
Linux 下的刷机
不同的Linux发行版可能存在差异，这里以2022年2月8日的ArchLinux为例。
如果你的设备之前刷过base.zip，则可以将设备置于fastboot模式后从第4步开始。
ufi001b&#x2F;c之外的版型请使用更为通用的base-generic.zip，然后使用本机型的boot.img替换debian.zip中的boot.img


解压base.zip压缩包。
将你的设备置于fastboot模式
执行其中的flash.sh
当完成后解压&lt;系统名称&gt;.zip压缩包。
执行其中的flash.sh
enjoy!

Windows 下的刷机
作者的windows环境变量里有adb和fastboot，可能需要根据实际情况对脚本进行适当调整。
如果你的设备之前刷过base.zip，则可以将设备置于fastboot模式后从第4步开始。
ufi001b&#x2F;c之外的版型请使用更为通用的base-generic.zip，然后使用本机型的boot.img替换debian.zip中的boot.img


解压base.zip压缩包。
将你的设备置于fastboot模式
执行其中的flash.bat
当完成后解压&lt;系统名称&gt;.zip压缩包。
执行其中的flash.bat
enjoy!

Windows 下的常见驱动问题
[注] 部分翻译自postmarketOS wiki - Windows FAQ

如果你的设备被识别为adb 设备如果在启动OpenStick后，只有adb可以连接而rndis在设备管理器中没有出现，则可以将这个设备的驱动更新为Composite USB Device 即可,(Windows 7 下为“Android Composite USB Device”)。
安装RNDIS驱动
Windows 10 下的驱动位置




Windows 7 下的驱动位置 （感谢酷安 @l305197437）





基础使用这里记录一些基础使用的教程，仅供参考
Debian基础使用基本信息
Debian 11 bulleye 稳定版
Linux Kernel 5.15 LTS
装了一些bookworm的包（modemman ager）和mobian的fork，暂时不知道会给后续更新带来什么影响。
开机默认启动rndis与adbd，可以通过adb与ssh连接（ip地址为192.168.68.1）
默认配置了modem连接，插卡即有网。
默认hostname为openstick
默认用户名 user 密码 1
内核支持挂无线网卡和uvc摄像头，docker与anbox。

连接到OpenStick支持使用任何支持openssh协议的工具以及adb来连接到OpenStick的shell。

在windows下很多带颜色的字符会在adb下显示不出来，建议使用ssh进行连接。
adb fork自安卓4.4 不支持adb install 等涉及安卓图形界面或软件管理的指令。

使用adb# 进入bash$ adb shell# 也可以通过reboot bootloader进入到fastboot模式$ adb reboot bootloader

使用ssh$ ssh user@192.168.68.1

开启wifi热点 (不依赖网桥的方法)
Debian 使用NetworkManager进行网络连接管理，这里使用nmtui进行设置。
该方法不能同时使用rndis与wifi热点，如需要同时使用可以参考rndis与wifi热点共存(debian)

sudo nmtui

之后的界面如下所示：
创建一个连接

创建wifi类型的连接
device输入wlan0，其他选项按照你的需求自行填写
设置ip地址,注意ip类型必须为shared，ip地址必须为192.168.68.1
输入以下指令激活这个连接，激活后usb rndis功能会失效。sudo nmcli con up test

要再次使用usb rndis，可以down掉这个连接sudo nmcli con down test

常见问题UFI001C&#x2F;SP970&#x2F;UZ801 刷入debian.zip后工作不正常debian.zip仅适用于ufi001b，若需要支持其他版型需要同时更新设备树与固件。在github的release中下载boot-&lt;机型&gt;.img与firmware-&lt;机型&gt;.zip两个文件后，解压firmware.zip后,插入OpenStick，在你的电脑上键入以下指令。（uz801仅需更新boot.img)

注：windows下的替换建议配合scp使用，windows下adb不支持通配符“ * ”

 # 假设cmd&amp;terminal的当前目录在firmware的解压文件夹下$ adb push ./* /lib/firmware$ adb reboot bootloader$ fastboot flash boot boot-&lt;机型&gt;.img$ fastboot reboot

初次开机执行apt时报错 E: Release file for http://mirrors.163.com/debian/dists/bullseye/InRelease is not valid yet (invalid for another 157d 16h 49min 2s). Updates for this repository will not be applied.E: Release file for http://security.debian.org/dists/bullseye-security/InRelease is not valid yet (invalid for another 209d 4h 12min 32s). Updates for this repository will not be applied.E: Release file for http://repo.mobian-project.org/dists/bullseye/InRelease is not valid yet (invalid for another 23d 19h 53min 31s). Updates for this repository will not be applied.

这是ntp服务没有及时同步时间所导致的，重启即可。
adb环境下用不了nmtui等带图形的应用例如执行nmtui时出现以下错误
root@openstick:/# nmtui     TERM environment variable needs set.

设置TERM环境变量即可
$ export TERM=linux

root用户使用ssh登录不了
感谢酷友@fanxueke的投稿。
不要尝试在你有内网穿透或是在公网有ip的设备上使用root登录，这将会造成很大的安全隐患。
root的默认密码与user一致（都是1），可以通过passwd root修改

安装nano编辑器（需插入SIM卡或连接wifi）sudo apt-get update``sudo apt-get install nano

编辑sshd_configsudo nano /etc/ssh/sshd_config

将34行#PermitRootLogin prohibit-password改为PermitRootLogin yes将58行#PasswordAuthentication yes的#去掉
重启OpenSticksudo reboot







rndis与wifi热点共存(debian)解决debian rndis与wifi热点共存的问题

感谢 lilyok123 (酷安 @lilyok123) 的投稿
原理：创建一个网桥，配置ip地址，并且将usb网卡与无线网卡设备加入到网桥中即可
注意事项：建议操作前将wifi连接到路由器上，操作时先将usb网络加入到网桥中，确保电脑能够正常 连接后，再将无线网卡加入到网桥中，万一操作失误还能从其它的网卡登录设备。否则估计得重新刷机了。

具体步骤第一步，输入命令nmtui，创建一个网桥

第二步,配置ip地址为192.168.68.1&#x2F;24（大佬默认是这个地址，如果更改网段需要修改dnsmsq.conf文件），配置名随意，设备名随意，这里都写br0

第三步，为网桥添加一个ETHERNET设备

第四步，ethernet设备需要填写为usb0（ifconfig命令看到的网卡名），配置名随意，这里起个名也是usb0

第五步，此时usb0的设备添加成功，保存退出

第六步，此时usb0配置文件如果没有生效，需要nmcli connection手动激活下，如无意外此时电脑能够正常访问随身wifi了。如果不成功通过另外的无线网卡登录看看配置是不是正确。

第七步，在第六步usb0的网桥确保正常后，可以为网桥添加无线网卡了，输入nmtui命令，选择刚刚的br0配置文件，选择edit编辑。

第八步，选择添加WLAN无线设备

第九步，配置热点的名称，密码等参数，配置文件随意，device需要添加ifconfig中的无线网卡名称。

第十步，保存配置，返回

最后一步，此时wlan0的配置文件没有生效，需要手动nncli connection切换下。

控制led行为OpenStick 存在三个led灯，默认blue表示wifi连接状态，red表示系统是否还处于正常运行状态。
可以通过 echo &lt;行为&gt; &gt; &#x2F;sys&#x2F;class&#x2F;led&#x2F;&lt;名字&gt;&#x2F;trigger 来修改led行为。可用的行为如下
root@openstick:/sys/class/leds/green:internet# cat trigger [none] usb-gadget usb-host rfkill-any rfkill-none kbd-scrolllock kbd-numlock kbd-capslock kbd-kanalock kbd-shiftlock kbd-altgrlock kbd-ctrllock kbd-altlock kbd-shiftllock kbd-shiftrlock kbd-ctrlllock kbd-ctrlrlock timer heartbeat cpu cpu0 cpu1 cpu2 cpu3 default-on panic mmc0 bluetooth-power hci0-power rfkill0 phy0rx phy0tx phy0assoc phy0radio rfkill1

例如把green led的行为定义为usb device模式的活动状态
root@openstick:/sys/class/leds/green:internet# echo usb-gadget &gt; trigger

写入该字符串后led行为立刻生效，重启失效
控制usb行为OpenStick 提供的所有系统都使用基于libusbgx的Gadget Controller (以下简称gc)来管理usb在device模式下的行为。
Debian默认通过&#x2F;usr&#x2F;sbin&#x2F;mobian-usb-network-config脚本启动rndis和adb两种usb复合设备，这也就意味着如果你的设备安装的是Debian，插入电脑默认会出现两个设备。
HandsomeMod 通过uci来调用gc，用户可以通过luci来控制gc。
在Debian中，rndis建立的usb0网络通过networkmanager进行管理，dnsmasq作为dhcp server分配ip地址。
你也可以通过以下指令（例子）来加入更多的功能（同时运行不同功能的种类是有限的，受限于硬件）。
注意：在windows下rndis必须为第一个加入gadget中的功能，且windows不支持动态更新gadget，只能在脚本中一次添加完所有的gadget。
以下指令需要root权限,重启后失效。
# 列出当前usb活动的devicegc -l# 加入一个串口设备# 有效的关键字为 serial ffs hid midi printer uvc mass rndis ecm acmgc -a serial# 删除指定串口设备 （X 为列表中的对应的config名称）gc -r serial.X# 清除所有的gadgetgc -c# 关闭gadgetgc -d# 开启gadgetgc -e

切换USB工作模式OpenStick没有usb-id脚，只能手动将usb切换为主模式来插入u盘等设备，你可以将以下语句加入 &#x2F;usr&#x2F;sbin&#x2F;mobian-usb-gadget setup()的最开头来实现开机切换，所有usb device功能将会失效。
echo host &gt; /sys/kernel/debug/usb/ci_hdrc.0/role

当然也可以通过把usb-typea头改为mircousb头，然后把vol up(fb)触点的gpio接到usb-id实现自动切换(需修改设备树)。
关于 Gadget ControllerGadget Controller 的开发时间有点短，可能不够成熟。。。欢迎star、提出issue和pull request来帮助我完善它~
lk bootloader基本使用这里只记录和平常的lk不大一样的地方
获取日志fastboot oem lk_logfastboot get_staged /dev/stdout

提取分区内容fastboot oem dump &lt;分区名&gt;fastboot get_staged &lt;文件名&gt;

进入edl模式fastboot oem reboot-edl



emali短信转发转载至酷安@魂梦九霄调用modemmanager的get-sms指令，可以将收到的短信转发到指定邮箱gitee源码
使用转发前请补全smtp.py开头的smtp信息python3 msg.py add 861234567890 text

添加发送到1234567890的内容为text的短信到暂存区
python3 msg.py send

将所有暂存区的短信发送
python3 msg.py clean

清除本地所有短信（暂存，已发送，接收）
python3 msg.py forward

将所有接收到的短信通过smtp邮件转发
高级玩法这里记录一些高级玩法，仅供参考。
emcp扩容这里只记录在linux下的扩容过程，windows应该类似，使用9008模式下的备份工具备份整个emcp上的内容即可（包含分区表）。高通的9008模式恢复时会将userdata分区自动扩充到所有可用的空间，所以理论上来说安卓系统也适合该方法备份（据部分用户反映安卓系统在扩容后的机器中无法使用）。

注意：方法仅供参考，不代表百分之百在你的环境中可用。

硬件按照原机搭配的emcp，可以确定emcp必须满足以下条件。

内置的内存必须是lpddr2 （不敢确定 我的机器大部分搭配的是lpddr2 msm8916支持lpddr3但可能需要不同的电压来驱动，即使电压一样也许需要使用不同的loader来初始化内存）
bga封装必须是bga162
符合规格的芯片会在焊接到位后上电进入9008(edl)模式，其他情况则会没有任何反应。

经过测试以下的芯片可以兼容UFI001B&#x2F;C机型

08emcp08-nl2cv100 (bga162 lpddr2 1g + 8g emmc)
kmk8x000vm-b412 (bga162 lpddr2 1g + 16g emmc)

软件推荐使用linux下的edl工具,安装之前默认你的环境中有python3及yay。
yay -S edl-git


不是Arch-based的发行版建议直接按照edl官方的方法安装。

之后长按机器上电，进入9008模式，输入以下指令备份emcp中的内容。
edl rl dumps --skip=userdata --genxml


如果长时间卡住，建议ctrl+c以后重试。
如果你的edl报例如no suitable loader found一类的错误，则可以尝试其他的loader初始化内存，edl提供了很多loader这里以红米2的loader为例(loader路径 不同的linux环境可能会有差异，仅供参考)。

$ edl rl dumps --skip=userdata --genxml  \--loader /usr/lib/python3.10/site-packages/edlclient-3.53-py3.10.egg/edlclient/../Loaders/xiaomi/007050e100000000_50838757eab7c632_fhprg_peek_wt88047.bin

换上新的emcp后，会出现9008设备，此时在备份文件夹里输入以下指令
$ edl qfil rawprogram0.xml patch0.xml


如果出错，同上，加入loader参数即可。

重启机器，灯光亮起即代表扩容成功。
$ edl reset

参考资料这里有些常见的emcp&amp;emmc型号，仅供参考(感谢 酷安@Zy143L 的整理)


编译内核（debian）这里介绍如何使用linux定制自己的内核，推荐的发行版是Ubuntu 20.04。
需要的软件包不同的发行版可能对软件包命名会有所不同，这里以Ubuntu 20.04的命名为例。

binfmt-support
qemu-user-static
gcc-10-aarch64-linux-gnu
kernel-package
fakeroot
simg2img
img2simg
mkbootimg
bison

生成内核debian软件包克隆linux内核,这里选择深度为1减少体积。
$ git clone https://github.com/OpenStick/linux --depth=1

开始编译
$ export CROSS_COMPILE=aarch64-linux-gnu-$ export ARCH=arm64$ make msm8916_defconfig$ make menuconfig$ make -j16

生成debian格式的软件包
$ fakeroot make-kpkg  --initrd --cross-compile aarch64-linux-gnu- --arch arm64  kernel_image kernel_headers

之后将生成的deb软件包(会在代码目录上层生成)，与arch/arm64/boot/Image.gz保留备用将rootfs.img转换成img格式并挂载
$ simg2img rootfs.img root.img$ sudo mount root.img /mnt

在chroot环境下，将前面生成的linux-image等deb安装包安装即可。注意要将安装完成后生成的boot/initrd.img取出备用（安装之前最好卸载原来的linux-image之类的软件包）。
$ sudo  mount --bind /proc /mnt/proc $ sudo  mount --bind /dev /mnt/dev$ sudo  mount --bind /dev/pts /mnt/dev/pts$ sudo  mount --bind /sys /mnt/sys$ sudo  chroot /mnt

安装完成后，解除所有挂载，将img再次转换为simg
$ img2simg root.img rootfs.img

生成boot.img取前面文件系统安装新内核后/boot/initrd.img**文件与内核编译阶段生成的Image.gz和arch/arm64/boot/dts/qcom/下对应设备的*.dtb备用将devicetree(dtb)附在Image.gz之后
cat Image.gz dtb &gt; kernel-dtb

生成boot.img
$ mkbootimg \             --base 0x80000000 \        --kernel_offset 0x00080000 \        --ramdisk_offset 0x02000000 \        --tags_offset 0x01e00000 \        --pagesize 2048 \        --second_offset 0x00f00000 \        --ramdisk initrd.img \        --cmdline &quot;earlycon root=PARTUUID=a7ab80e8-e9d1-e8cd-f157-93f69b1d141e console=ttyMSM0,115200 no_framebuffer=true rw&quot;\        --kernel kernel-dtb -o boot.img

之后将两个img文件分别刷入对应分区即可。
编译lk bootloader这里不再介绍lk2nd的编译，只介绍lk1st的编译方法。原理其实很简单，交叉编译后得到aboot之后使用dragonboard提供的密匙签名即可。

注意：不适用于开启secureboot的设备，如果你的设备不在支持列表之内，教程的有效性将得不到保证。
uz801和sp970由于某些原因在lk阶段点不亮led。
目前最为完美的机型是UFI001B&#x2F;C系列

克隆lk2nd项目
$  git clone https://github.com/OpenStick/lk2nd.git

进入lk2nd目录使用以下指令开始编译
make TOOLCHAIN_PREFIX=arm-none-eabi- lk1st-msm8916 -j8

之后会出现build-lk1st-msm8916目录，复制产物emmc_appsboot.mbn备用。
克隆签名工具qtestsign
$ git clone https://github.com/msm8916-mainline/qtestsign

将前面的emmc_appsboot.mbn放入qtestsign目录，之后输入以下指令。
$ ./qtestsign.py aboot emmc_appsboot.mbn

之后会生成emmc_appsboot-test-signed.mbn,刷入即可。
$ fastboot flash aboot emmc_appsboot-test-signed.mbn]]></content>
      <categories>
        <category>搞事情</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>刷机</tag>
        <tag>搞事情</tag>
        <tag>随身WiFi</tag>
      </tags>
  </entry>
  <entry>
    <title>C Sharp学习笔记/基础教程</title>
    <url>/2023/01/25/CSharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[C#简介CIL和JIT在编译使用.NET Framework或.NET Core库的代码时，不是立即创建专用于操作系统的本机代码，而是把代码编译为通用中间语言(Common Intermediate Language, CIL)代码,这些代码并非专门用于任何一种操作系统，也非专门用于C#。其他NET语言(如Visual Basic .NET或F#)也会在第一阶段编译为这种语言。开发C#应用程序时，这个编译步骤由Visual Studio完成。Microsoft Intermediate Language(MSIL)这一术语，它是CIL原来的名称，许多开发人员仍沿用这个术语。
要执行应用程序，必须完成更多工作，这是Just-In-Time（JIT）编译器的任务，它把CIL编译为专用于OS和目标机器架构的本机代码。这样OS才能执行应用程序。这里编译器的名称Just-In-Time反映了CIL代码仅在需要时才编译的事实。这种编译可以在应用程序的运行过程中动态发生，不过开发人员一般不需要关心这个过程。除非要编写性能十分关键的高级代码，否则知道这个编译过程会在后台自动进行，并不需要人工干预就可以了。过去，经常需要把代码编译为几个应用程序，每个应用程序都用于特定的操作系统和CPU架构。这通常是一种优化形式(例如，为了让代码在AMD芯片组上运行得更快)，但有时则是非常重要的(例如，使应用程序可以同时工作在Win9x和WinNT&#x2F;2000环境F)。现在就没必要了，因为JIT编译器使用CIL代码，而CIL代码是独立于计算机、操作系统和CPU的。目前有几种JIT编译器，每种编译器都用于不同的架构，CLR&#x2F;CoreCLR会使用合适的编译器创建所需的本机代码。
垃圾回收机制.NET垃圾回收会定期检查计算机的内存，从中删除不再需要的内容。执行垃圾回收的时间并不固定，可能一秒钟内会进行数千次的检查，也可能每几秒钟才检查- -次，不过一定会进行检查。这里要给程序员一些提示。因为是在不可预知的时间执行这项工作，所以在设计应用程序时，必须留意这一点。需要许多内存才能运行的代码应自行完成清理工作，而不是坐等垃圾回收，但这不像听起来那样难。
类和名称空间
类（class）构成程序主体

​    类 (class) 是最基础的 C# 类型。类是一个数据结构，将状态（字段）和操作（方法和其他函数成员）组合在一个单元中。类为动态创建的类实例 (instance) 提供了定义，实例也称为对象 (object)。类支持继承 (inheritance) 和多态性 (polymorphism)，这是派生类 (derived class) 可用来扩展和专用化基类 (base class) 的机制。
​    使用类声明可以创建新的类。类声明以一个声明头开始，其组成方式如下：先指定类的特性和修饰符，然后是类的名称，接着是基类（如有）以及该类实现的接口。声明头后面跟着类 { 和 } 之间的成员声明组成。


名称空间（namespace）以树型结构组织类和其他类型

命名空间将类用良好的结构组合在一起，有效的避免了重名类带来的冲突。



eg：
using System;namespace ConsoleApp1&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;Hello, World!&quot;);                    &#125;    &#125;&#125;

由于c#是完全面向对象的，因此入口点Main方法也需要在类内。
其中的Console这个类，是系统定义的，这个使用了这个类中的WriteLine的方法，用于将指定的字符串输出到控制台。
而编写的这个Program类，放在了ConsoleApp1这个命名空间中。
using System的作用就是，告诉编译器，如果我没有指定这个类的来源于哪个命名空间，就在引用的名称空间内部检索一边。
如果想要手动指定属于某个名称空间的类的话，可以这样：System.Console.WriteLine(“hello”);
类库的引用
类库引用是使用名称空间的物理基础

dll引用（黑盒引用）只能使用，但无法修改。同时增加了依赖关系，如果引用的dll有错误或者不存在，则程序可能无法使用。  
项目引用（白盒引用）类类（class）是现实世界事务的模型，将事务进行抽象后得到的结果，事务包括实体和逻辑等。
类与对象的关系对象也称为实例，是类实例化后得到的内存中的实体
实例化后的类就是对象，但不是所有的类都可以被实例化。
使用new操作符创建类的实例
类的三大成员属性（Property）存储数据，组合起来表示类或对象的当前状态
方法（Method）由函数进化而来，表示类或对象能够做什么
事件（Event）类或对象通知其他类或对象的机制，为c#特有
静态成员与实例成员
静态（static）成员在语义上表示他是“类的成员”
实例（非静态）成员在语义上表示他是“对象的成员”
绑定（binding）指的是编译器如何把一个成员与类或对象关联起来
.操作符：用于成员的访问，全称为成员访问操作符。

C#的基本元素
关键字（keyword）
操作符（operator）
标识符（identifier）
合法的标识符：用于给类、对象等命名
不能是关键字
可以由字母数字下划线组成，但不能以数字开头
如 果需要使用关键字作为标识符，需要在前面加上@（Unicode转义序列）
可以包含汉语，但不建议使用


大小写规范
大驼峰：命名空间、类型、接口、方法、属性、事件、非私有字段、枚举值
小驼峰：私有字段、参数、局部变量


命名规范
类、类的属性的名字是一个名词或者名词的复数形式‘
对类的方法命名的时候，需要是一个动词，或者动词短语




标点符号
不同于加减乘除，不用来表示运算思想
;     表示语句结束
{}  表示程序段
以及其他的一下




文本（值）
整数
int
long：结尾需要加L


实数
float：结尾需要加F
double


字符
char：单引号引起来的一个字符


字符串
string：双引号引起来的零个或多个字符串


布尔
bool：只能为true或false


空
null，如str &#x3D; null；




注释与空白
单行注释：//开头的一行
多行注释（块注释）：/*  */内的字符，不可以嵌套使用
空白：空格、换行、注释等。



除了注释与空白，其余的都是对编译器有意义的记号。也成为标记
类型、变量与方法的概述
类型（type），又称为数据类型（Data Type)

变量是存储数据的地方

变量需要先声明后使用
声明方法：
类型名 + 变量名




方法（旧称函数）是处理数据的逻辑，又称为算法

方法的声明
方法名需要是合法的标识符


方法的使用
类（对象）.方法名




程序 &#x3D; 变量 + 方法。


c#中的数据类型数据类型的概述什么是类型（Type）
是性质相同的值的集合
数据类型配备了一系列针对这种类型的值的操作
数据类型是数据在内存中存储时的“型号”

类型在C#中的作用一个C#类型中所包含的信息有：

存储此类型变量所需的空间大小
此类型的值可表示的最大、最小值范围
此类型所包含的成员（如方法、属性、事件等）
此类型有何基类派生而来
程序运行的时候，此类型的变量分配在内存的什么位置
c++没有内存回收机制，因此没有手动回收的话可能会造成内存泄漏；c#存在垃圾收集器的机制，当一个对象没有再被使用的时候，会自动进行回收，没有手动释放的一说。换句话说就是c#相对比较安全。
实例永远是分配在堆内


此类型允许的操作（运算）

C#语言的类型系统c#的五大数据类型
类（Classes）：如Windows，Form，Console，Srting
结构体（Structres）：如Int32，Int64，Single，Double
枚举（Enumerations）如HorizontalAlignment，Visibility
接口（Interfaces）
委托（Delegates）

c#的派生谱系
关键字解析：

第一组
object、string：真正的数据类型
class、interface、delegate：不是具体的数据类型，而是用这三个关键字定义自己的数据类型


第二组
bool、byte、…、ushort：都是值类型
struct、enum：定义自己的类型的关键字


第三组
true、false：布尔类型的值
void、null：表示“空”
var、dynamic：声明变量



其中蓝色的都是基本数据类型（或称为内建数据类型），没有其他类型可以来构成他们
变量、对象与内存变量概述
表面上看，变量的用途是存储数据
实际上，变量表示了存储位置，并且每一个变量都有一个类型，以决定什么样的值能够存入变量。变量名表示（对应着）变量的值在内存中的存储位置，变量类型表示从这个位置开始，往后多少个字节，用来保存这个变量的值。
变量一共有七种
静态变量（静态字段）
实例变量（成员变量，字段）
数组元素
值参数
引用参数（ref修饰）
输出形参（out修饰）
局部变量


狭义的变量是指局部变量，因为其他种类的变量都有自己的约定名称
局部变量就是方法体（函数体）内声明的变量


变量的声明
[有效的修饰符组合] 类型 变量名 [初始化器]
如：unsigned int a &#x3D; 10;


局部变量实在stack上分配内存的

using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Student student= new Student();            int[] array = new int[5];//数组        &#125;        &#125;           class Student    &#123;        public static int Amount;//静态成员变量        public int Age;        public int Name;//Age Name都是成员变量（字段）        public double Add(ref double a, double b)//a：引用参数变量；b:值参数变量        &#123;            return a + b;        &#125;    &#125;&#125;




值类型的变量（简单数据类型）值类型没有实例，所谓的“实例”与变量名合二为一。



类型
描述
范围
默认值



bool
布尔值
True 或 False
False


byte
8 位无符号整数
0 到 255
0


char
16 位 Unicode 字符
U +0000 到 U +ffff
‘\0’


decimal
128 位精确的十进制值，28-29 有效位数，也属于浮点数，只是底数是10.
(-7.9 x 10^28^ 到 7.9 x 10^28^) &#x2F; 100 到 28
0.0M


double
64 位双精度浮点型，常规的浮点数，底数是2
(+&#x2F;-)5.0 x 10^-324^ 到 (+&#x2F;-)1.7 x 10^308^
0.0D


float
32 位单精度浮点型
-3.4 x 10^38^ 到 + 3.4 x 10^38^
0.0F


int
32 位有符号整数类型
-2,147,483,648 到 2,147,483,647
0


long
64 位有符号整数类型
-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807
0L


sbyte
8 位有符号整数类型
-128 到 127
0


short
16 位有符号整数类型
-32,768 到 32,767
0


uint
32 位无符号整数类型
0 到 4,294,967,295
0


ulong
64 位无符号整数类型
0 到 18,446,744,073,709,551,615
0


ushort
16 位无符号整数类型
0 到 65,535
0


引用类型（Reference types）的变量与实例​	引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。换句话说，它们指的是一个内存位置。使用多个变量时，引用类型可以指向一个内存位置。如果内存位置的数据是由一个变量改变的，其他变量会自动反映这种值的变化。内置的 引用类型有：object、dynamic 和 string。
​	引用类型变量与实例的关系：引用类型变量里存储的数据是对象的内存地址。
​	也就是说，在创建引用类型的变量的时候，会在内存中开辟一段4个字节的内存空间，并全部置0，当这个变量指向一个实例的时候，会在堆内开辟空间，将这个空间的首地址存储到这个变量里面来。
变量的作用域
成员变量：在类中定义的变量，在整个类中都有效，类中定义的方法都可以使用该变量。成员变量又可以分为实例成员变量和静态成员变量。

静态成员变量：使用static修饰的成员变量，static用于把属性和方法绑定到类本身，而不是使用类创建的对象。使用静态成员变量时直接使用类名称进行调用，无论用户使用该类创建了多少个对象，静态成员变量始终只有一个，始终绑定到类本身，每个创建的对象中并不存在该静态成员变量。
实例成员变量：实例成员变量是绑定使用类创建的对象上的，要想使用实例成员变量，必须先使用类创建一个对象。使用实例成员变量时是使用对象名进行调用，使用同一类创建的多个对象中各自有自己的实例成员变量，互相隔离，互不干扰。


局部变量：在方法体中定义的变量，其使用范围只局限在定义它的方法之中或者方法之中的循环体之内，作用域不超过一个大括号

全局变量：在类中定义的变量用static修饰的变量为全局变量，在整个namespace中的所有类中都可以使用


需要注意的是：定义变量时不能在同一作用域内定义相同名称的变量
装箱和拆箱​	对象（Object）类型 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换.
​	当一个值类型转换为对象类型时，则被称为 装箱；另一方面，当一个对象类型转换为值类型时，则被称为 拆箱。
​	装箱：当obj类型的变量要引用的值不是堆上的实例，而是栈上的一个值类型的时候，会先在堆上找一块可以存储下的空间，然后将值类型的值copy到堆上开辟的空间，最后将obj变量指向新开辟的空间上。
​	拆箱：一个值类型的变量想要拿到obj在堆上面存储的值。将堆上的值按照要求复制到变量内。注意，编译器并不检测箱子内的数据的类型，比如将short类型装箱，然后以char形式拆箱，编译器不会报错，但运行的时候会出现System.InvalidCastException:“指定的转换无效。”的异常。
还有就是，装箱和拆箱会损失系统性能。
int x = 100;object obj;//需要注意，object类型是引用类型obj = x;//装箱int y = (int)obj;//拆箱Console.WriteLine(y);



扩展任意类型类型到Object都是装箱，从Object到原有类型都是拆箱。
虽然会损失系统性能，但对于多态来说是非常常用的。
发生装箱和拆箱的前提是两种类型之间存在了继承关系。如果没有继承关系，比如string和int，则相互转换属于类型转换而非装箱拆箱。
复杂数据类型除了这些简单的变量类型外，C#还提供了3个较复杂(但非常有用)的变量:枚举、结构和数组。
枚举（Enum）
枚举类型 是由基础整型数值类型的一组命名常量定义的值类型。枚举类型是使用 enum 关键字声明的。
C# 枚举是值类型。换句话说，枚举包含自己的值，且不能继承或传递继承。
不是仅声明一个给定类型的变量，而是声明和描述一个用户定义的类型，再声明这个新类型的变量。
**枚举的基本类型可以是byte,sbyte,short,ushort,int,uint,long,ulong。默认情况下为int。**不可以为浮点数或string，甚至是class。
可以在声明的时候使用其他类型来节省空间。

声明 enum 变量声明枚举的一般语法：
enum &lt;enum_name&gt;&#123;     enumeration list &#125;;

其中，

enum_name 指定枚举的类型名称。
enumeration list 是一个用逗号分隔的标识符列表。

枚举列表中的每个符号代表一个整数值，一个比它前面的符号大的整数值。默认情况下，第一个枚举符号的值是 0。
例如：
enum Days &#123; Sun, Mon, tue, Wed, thu, Fri, Sat &#125;;



​	默认情况下，枚举成员的关联常数值为类型 int；它们从零开始，并按定义文本顺序递增 1。 可以显式指定任何其他整数数值类型作为枚举类型的基础类型。 还可以显式指定关联的常数值，如下面的示例所示：
enum ErrorCode : ushort&#123;    None = 0,    Unknown = 1,    ConnectionLost = 100,    OutlierReading = 200,    NotFound = 404,    BadGateway = 502&#125;



样例下面的实例演示了枚举变量的用法：
using System;public class EnumTest&#123;    enum Day &#123; Sun, Mon, Tue, Wed, Thu, Fri, Sat &#125;;    static void Main()    &#123;        int x = (int)Day.Sun;        int y = (int)Day.Fri;        Console.WriteLine(&quot;Sun = &#123;0&#125;&quot;, x);        Console.WriteLine(&quot;Fri = &#123;0&#125;&quot;, y);    &#125;&#125;

当上面的代码被编译和执行时，它会产生下列结果：
Sun = 0Fri = 5

​	
注意事项
不能在枚举类型的定义内定义方法。 若要向枚举类型添加功能，请创建扩展方法。
枚举类型 E 的默认值是由表达式 (E)0 生成的值，即使零没有相应的枚举成员也是如此。
可以使用枚举类型，通过一组互斥值或选项组合来表示选项。 若要表示选项组合，请将枚举类型定义为位标志。

作为位标志的枚举类型​	如果希望枚举类型表示选项组合，请为这些选项定义枚举成员，以便单个选项成为位字段。 也就是说，这些枚举成员的关联值应该是 2 的幂。 然后，可以使用按位逻辑运算符|或 &amp; 分别合并选项或交叉组合选项。 若要指示枚举类型声明位字段，请对其应用 Flags 属性。 如下面的示例所示，还可以在枚举类型的定义中包含一些典型组合。
using System;using System.Windows.Diagnostics;using System.Windows.Forms;namespace ConsoleApp&#123;    public enum Days    &#123;        None = 0b_0000_0000,  // 0        Monday = 0b_0000_0001,  // 1        Tuesday = 0b_0000_0010,  // 2        Wednesday = 0b_0000_0100,  // 4        Thursday = 0b_0000_1000,  // 8        Friday = 0b_0001_0000,  // 16        Saturday = 0b_0010_0000,  // 32        Sunday = 0b_0100_0000,  // 64        Weekend = Saturday | Sunday    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Days meetingDays = Days.Monday | Days.Wednesday | Days.Friday; // 0001 0101 -&gt; 21            Console.WriteLine(meetingDays);            // Output:            // Monday, Wednesday, Friday            //实际输出：21            Days workingFromHomeDays = Days.Thursday | Days.Friday;            Console.WriteLine($&quot;Join a meeting by phone on &#123;meetingDays &amp; workingFromHomeDays&#125;&quot;);            // Output:            // Join a meeting by phone on Friday            bool isMeetingOnTuesday = (meetingDays &amp; Days.Tuesday) == Days.Tuesday;            Console.WriteLine($&quot;Is there a meeting on Tuesday: &#123;isMeetingOnTuesday&#125;&quot;);            // Output:            // Is there a meeting on Tuesday: False            var a = (Days)37;            Console.WriteLine(a);            // Output:            // Monday, Wednesday, Saturday            //实际输出：37            Console.ReadKey();        &#125;    &#125;&#125;

System.Enum 类型和枚举约束​	System.Enum 类型是所有枚举类型的抽象基类。 它提供多种方法来获取有关枚举类型及其值的信息。 有关更多信息和示例，请参阅 System.Enum API 参考页。
​	可在基类约束中使用 System.Enum（称为枚举约束），以指定类型参数为枚举类型。 所有枚举类型也都满足 struct 约束，此约束用于指定类型参数为不可为 null 的值类型。
转换对于任何枚举类型，枚举类型与其基础整型类型之间存在显式转换。 如果将枚举值转换为其基础类型，则结果为枚举成员的关联整数值。
如果基础整数类型转换到的枚举类型时，整数的值 不在 目标枚举类型的范围中（如下方样例中的，Season枚举内的值是0，1，2，3，但我将4转换为这个枚举类型），也不会报错，但对应的这个枚举的值就是目标转换的4（不是整型了，而是Season类型的枚举4，可以看到输出var的类型名是ConsoleApp.Season）。但如果进一步的查询4是否在Season枚举中，查询的结果是false。
public enum Season&#123;    Spring,    Summer,    Autumn,    Winter&#125;public class EnumConversionExample&#123;    public static void Main()    &#123;      	Season a = Season.Autumn;        Console.WriteLine($&quot;Integral value of &#123;a&#125; is &#123;(int)a&#125;&quot;);          // output: Integral value of Autumn is 2        var b = (Season)1;        Console.WriteLine(b);  // output: Summer        Console.WriteLine(b.GetType());     //output: ConsoleApp.Season        var c = (Season)4;        Console.WriteLine(c);  // output: 4        Console.WriteLine(c.GetType());  //output: ConsoleApp.Season                Console.WriteLine(Enum.IsDefined(typeof(Season),4));//false    &#125;&#125;





使用 Enum.IsDefined 方法来确定枚举类型是否包含具有特定关联值的枚举成员。
对于任何枚举类型，都存在分别与 System.Enum 类型的装箱和取消装箱相互转换。
string类型转换为枚举值需要借助Enum.Parse()方法。
基本语法如下：
(目标枚举类型)Enum.Parse(typeof(目标枚举类型),&quot;要转换的string字符串&quot;);

样例using System;using System.Windows.Diagnostics;using System.Windows.Forms;namespace ConsoleApp&#123;    public enum Error : short    &#123;        NOT_FOUND = 404,        BAD_GATEWAY = 502    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Error err = Error.NOT_FOUND;            err = (Error)Enum.Parse(typeof(Error), &quot;502&quot;);//将字符类型的502转换成对应的整型值为502的枚举类型。                        Console.WriteLine(err);//输出：BAD_GATEWAY            Console.ReadKey();        &#125;    &#125;&#125;







结构体（Struct）在 C# 中，结构体是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。struct 关键字用于创建结构体。
结构体是用来代表一个记录。假设您想跟踪图书馆中书的动态。yy您可能想跟踪每本书的以下属性：

Title

Author

Subject

Book ID


定义结构体struct 语句为程序定义了一个带有多个成员的新的数据类型。
例如，可以按照如下的方式声明 Book 结构：
struct Books&#123;   public string title;   public string author;   public string subject;   public int book_id;&#125;;  

下面的程序演示了结构的用法：
using System;using System.Text;struct Books&#123;    public string title;    public string author;    public string subject;    public int book_id;&#125;;public class testStructure&#123;    public static void Main(string[] args)    &#123;        Books Book1;        /* 声明 Book1，类型为 Books */        Books Book2;        /* 声明 Book2，类型为 Books */        /* book 1 详述 */        Book1.title = &quot;C Programming&quot;;        Book1.author = &quot;Nuha Ali&quot;;        Book1.subject = &quot;C Programming Tutorial&quot;;        Book1.book_id = 6495407;        /* book 2 详述 */        Book2.title = &quot;Telecom Billing&quot;;        Book2.author = &quot;Zara Ali&quot;;        Book2.subject = &quot;Telecom Billing Tutorial&quot;;        Book2.book_id = 6495700;        /* 打印 Book1 信息 */        Console.WriteLine(&quot;Book 1 title : &#123;0&#125;&quot;, Book1.title);        Console.WriteLine(&quot;Book 1 author : &#123;0&#125;&quot;, Book1.author);        Console.WriteLine(&quot;Book 1 subject : &#123;0&#125;&quot;, Book1.subject);        Console.WriteLine(&quot;Book 1 book_id :&#123;0&#125;&quot;, Book1.book_id);        /* 打印 Book2 信息 */        Console.WriteLine(&quot;Book 2 title : &#123;0&#125;&quot;, Book2.title);        Console.WriteLine(&quot;Book 2 author : &#123;0&#125;&quot;, Book2.author);        Console.WriteLine(&quot;Book 2 subject : &#123;0&#125;&quot;, Book2.subject);        Console.WriteLine(&quot;Book 2 book_id : &#123;0&#125;&quot;, Book2.book_id);        Console.ReadKey();    &#125;&#125;



当上面的代码被编译和执行时，它会产生下列结果：
Book 1 title : C ProgrammingBook 1 author : Nuha AliBook 1 subject : C Programming TutorialBook 1 book_id : 6495407Book 2 title : Telecom BillingBook 2 author : Zara AliBook 2 subject : Telecom Billing TutorialBook 2 book_id : 6495700

C# 结构的特点在 C# 中的结构与传统的 C 或 C++ 中的结构不同。C# 中的结构有以下特点：

结构可带有方法、字段、索引、属性、运算符方法和事件。

结构可定义构造函数，但不能定义析构函数。但是，不能为结构定义无参构造函数。无参构造函数(默认)是自动定义的，且不能被改变。

与类不同，结构不能继承其他的结构或类。

结构不能作为其他结构或类的基础结构。

结构可实现一个或多个接口。

结构成员不能指定为 abstract、virtual 或 protected。

当您使用 New 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。

如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。


类与结构的区别类和结构有以下几个基本的不同点：

类是引用类型，结构是值类型。

结构不支持继承。

结构不能声明默认的构造函数。

针对上述讨论，让我们重写前面的实例：


样例using System;using System.Text;struct Books&#123;    private string title;    private string author;    private string subject;    private int book_id;    public void setValues(string t, string a, string s, int id)    &#123;        title = t;        author = a;        subject = s;        book_id = id;    &#125;    public void display()    &#123;        Console.WriteLine(&quot;Title : &#123;0&#125;&quot;, title);        Console.WriteLine(&quot;Author : &#123;0&#125;&quot;, author);        Console.WriteLine(&quot;Subject : &#123;0&#125;&quot;, subject);        Console.WriteLine(&quot;Book_id :&#123;0&#125;&quot;, book_id);    &#125;&#125;;public class testStructure&#123;    public static void Main(string[] args)    &#123;        Books Book1 = new Books(); /* 声明 Book1，类型为 Books */        Books Book2 = new Books(); /* 声明 Book2，类型为 Books */        /* book 1 详述 */        Book1.setValues(&quot;C Programming&quot;,        &quot;Nuha Ali&quot;, &quot;C Programming Tutorial&quot;, 6495407);        /* book 2 详述 */        Book2.setValues(&quot;Telecom Billing&quot;,        &quot;Zara Ali&quot;, &quot;Telecom Billing Tutorial&quot;, 6495700);        /* 打印 Book1 信息 */        Book1.display();        /* 打印 Book2 信息 */        Book2.display();        Console.ReadKey();    &#125;&#125;



当上面的代码被编译和执行时，它会产生下列结果：
Title : C ProgrammingAuthor : Nuha AliSubject : C Programming TutorialBook_id : 6495407Title : Telecom BillingAuthor : Zara AliSubject : Telecom Billing TutorialBook_id : 6495700







C# 数组（Array）数组是一个存储相同类型元素的固定大小的顺序集合。数组是用来存储数据的集合，通常认为数组是一个同一类型变量的集合。
声明数组变量并不是声明 number0、number1、…、number99 一个个单独的变量，而是声明一个就像 numbers 这样的变量，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来表示一个个单独的变量。数组中某个指定的元素是通过索引来访问的。
所有的数组都是由连续的内存位置组成的。最低的地址对应第一个元素，最高的地址对应最后一个元素。
数组最大的一个局限性就是长度不可变。可以使用集合进行优化。 
声明数组在 C# 中声明一个数组，可以使用下面的语法：
datatype[] arrayName;

其中，

datatype 用于指定被存储在数组中的元素的类型。
[ ]指定数组的秩（维度）。秩指定数组的大小。
arrayName 指定数组的名称。

例如：
double[] balance;



声明多维数组和一维的声明类似，但与c&#x2F;c++有一定的差异。
double[,] d = new double[3,4];//二维数组的声明int[,,] ints = new int[3, 4, 5];//三维数组



初始化数组声明一个数组不会在内存中初始化数组。当初始化数组变量时，可以赋值给数组。
数组是一个引用类型，所以需要使用 new 关键字来创建数组的实例。
例如：
double[] balance = new double[10];

赋值给数组可以通过使用索引号赋值给一个单独的数组元素，比如：
double[] balance = new double[10];balance[0] = 4500.0;

可以在声明数组的同时给数组赋值，比如：
double[] balance = &#123; 2340.0, 4523.69, 3421.0&#125;;

也可以创建并初始化一个数组，比如：
int [] marks = new int[5]  &#123; 99,  98, 92, 97, 95&#125;;

在上述情况下，你也可以省略数组的大小，比如：
int [] marks = new int[]  &#123; 99,  98, 92, 97, 95&#125;;

也可以赋值一个数组变量到另一个目标数组变量中。在这种情况下，目标和源会指向相同的内存位置：
int [] marks = new int[]  &#123; 99,  98, 92, 97, 95&#125;;int[] score = marks;

当创建一个数组时，C# 编译器会根据数组类型隐式初始化每个数组元素为一个默认值。例如，int 数组的所有元素都会被初始化为 0。
访问数组元素元素是通过带索引的数组名称来访问的。这是通过把元素的索引放置在数组名称后的方括号中来实现的。例如：
double salary &#x3D; balance[9];下面是一个实例，使用上面提到的三个概念，即声明、赋值、访问数组：
实例using System;namespace ArrayApplication&#123;   class MyArray   &#123;      static void Main(string[] args)      &#123;         int []  n = new int[10]; /* n 是一个带有 10 个整数的数组 */         int i,j;         /* 初始化数组 n 中的元素 */                 for ( i = 0; i &lt; 10; i++ )         &#123;            n[ i ] = i + 100;         &#125;         /* 输出每个数组元素的值 */         for (j = 0; j &lt; 10; j++ )         &#123;            Console.WriteLine(&quot;Element[&#123;0&#125;] = &#123;1&#125;&quot;, j, n[j]);         &#125;         Console.ReadKey();      &#125;   &#125;&#125;

当上面的代码被编译和执行时，它会产生下列结果：
Element[0] = 100Element[1] = 101Element[2] = 102Element[3] = 103Element[4] = 104Element[5] = 105Element[6] = 106Element[7] = 107Element[8] = 108Element[9] = 109



实例2using System;using System.Windows.Diagnostics;using System.Windows.Forms;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            double[,] d = new double[3,4];//二维数组的声明            int[,,] ints = new int[3, 4, 5];//三维数组            for(int i = 0;i &lt; 3; i++)            &#123;                for(int j = 0; j &lt; 4; j++)                &#123;                    for(int k = 0; k &lt; 5; k++)                    &#123;                        ints[i,j,k] = i;                     &#125;                    d[i,j] = j;                &#125;            &#125;            foreach(double x in d)            &#123;                Console.WriteLine(x);                         &#125;            foreach(int x in ints)            &#123;                Console.WriteLine(x);            &#125;            Console.ReadKey();        &#125;    &#125;&#125;



使用 foreach 循环在前面的实例中，我们使用一个 for 循环来访问每个数组元素。也可以使用一个 foreach 语句来遍历数组。
实例1 一维数组的使用using System;namespace ArrayApplication&#123;   class MyArray   &#123;      static void Main(string[] args)      &#123;         int []  n = new int[10]; /* n 是一个带有 10 个整数的数组 */         /* 初始化数组 n 中的元素 */                 for ( int i = 0; i &lt; 10; i++ )         &#123;            n[i] = i + 100;         &#125;         /* 输出每个数组元素的值 */         foreach (int j in n )         &#123;            int i = j-100;            Console.WriteLine(&quot;Element[&#123;0&#125;] = &#123;1&#125;&quot;, i, j);         &#125;         Console.ReadKey();      &#125;   &#125;&#125;

当上面的代码被编译和执行时，它会产生下列结果：
Element[0] = 100Element[1] = 101Element[2] = 102Element[3] = 103Element[4] = 104Element[5] = 105Element[6] = 106Element[7] = 107Element[8] = 108Element[9] = 109



数组的数组（锯齿数组）普通的数组称为矩形数组，因为每一行的元素个数都相等。
如果需要每行的元素个数不同，可以使用锯齿数组（jagged array)
using System;using System.Windows.Diagnostics;using System.Windows.Forms;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            int[][] jaggedIntArray;            //jaggedIntArray= new int[3][4];//不能像普通数组一样声明。就算可以，也没有意义。因为这样就像普通数组一样了。            //jaggedIntArray = &#123; &#123;1, 2, 3 &#125;, &#123; 4, 5&#125;, &#123; 6, 7, 8, 9&#125; &#125;;//也不可以这样            //可用的两种方法：            jaggedIntArray = new int[2][];//先声明第一层            jaggedIntArray[0] = new int[3];//再声明第二层的第一个            jaggedIntArray[1] = new int[5];//再声明第二层第二个            //第二种方法            jaggedIntArray = new int[2][]            &#123;                new int[]&#123;0, 1, 2, 3&#125;,                new int[]&#123;4, 5&#125;            &#125;;            //遍历的时候，也不能简单的使用foreach了，需要根据层数嵌套            //foreach(int i in jaggedIntArray)            //&#123;            //    Console.WriteLine(i);//因为i的类型是int[]            //&#125;            foreach (int[] it in jaggedIntArray)            &#123;                foreach(int i in it)                &#123;                    Console.Write($&quot;&#123; i&#125; &quot;);                &#125;                Console.WriteLine();            &#125;            Console.ReadKey();        &#125;    &#125;&#125;





锯齿数组的注意事项
声明和遍历方法均与普通的数组有一定的区别，需要注意。
有点类似于c++中的数组指针？外一层的类型是内一层的数组指针，每一个指针单独malloc大小存储数据。

C#	 数组细节


概念
描述



多维数组
C# 支持多维数组。多维数组最简单的形式是二维数组。


交错数组
C# 支持交错数组，即数组的数组。


传递数组给函数
您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。


参数数组
这通常用于传递未知数量的参数给函数。


Array 类
在 System 命名空间中定义，是所有数组的基类，并提供了各种用于数组的属性和方法。


数组的数据类型
数组元素的类型后面加上[]。如：System.Int32[]


常量比如 const int N = 1e5+10;
​	常量是固定值，程序执行期间不会改变。常量可以是任何基本数据类型，比如整数常量、浮点常量、字符常量或者字符串常量，还有枚举常量。
​	常量可以被当作常规的变量，只是它们的值在定义后不能被修改。
​	常量隶属于类型，因此没有实例常量一说。对于“实例常量”只能使用只读实例字段（属性）实现。
​	只读实例字段仍然是一个变量，访问变量需要访问这个这个变量所在的地址，访问变量的效率不如访问常量。
​	成员常量，是类的常量，如Math.PI, int.MaxValue等
​	局部常量，是在方法体内的常量，如
namespace ConsoleApp&#123;    internal class Program    &#123;              static void Main(string[] args)        &#123;            const int x = 100;                      Console.ReadLine();        &#125;    &#125;&#125;



整数常量​	整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，没有前缀则表示十进制。
​	整数常量也可以有后缀，可以是 U 和 L 的组合，其中，U 和 L 分别表示 unsigned 和 long。后缀可以是大写或者小写，多个后缀以任意顺序进行组合。
这里有一些整数常量的实例：
212         /* 合法 */215u        /* 合法 */0xFeeL      /* 合法 */078         /* 非法：8 不是一个八进制数字 */032UU       /* 非法：不能重复后缀 */

​	以下是各种类型的整数常量的实例：
85         /* 十进制 */0213       /* 八进制 */0x4b       /* 十六进制 */30         /* int */30u        /* 无符号 int */30l        /* long */30ul       /* 无符号 long */

浮点常量​	一个浮点常量是由整数部分、小数点、小数部分和指数部分组成。可以使用小数形式或者指数形式来表示浮点常量。
​	这里有一些浮点常量的实例：
3.14159       /* 合法 */314159E-5L    /* 合法 */510E          /* 非法：不完全指数 */210f          /* 非法：没有小数或指数 */.e55          /* 非法：缺少整数或小数 */

使用浮点形式表示时，必须包含小数点、指数或同时包含两者。使用指数形式表示时，必须包含整数部分、小数部分或同时包含两者。有符号的指数是用 e 或 E 表示的。
字符常量和转义字符字符常量是括在单引号里，例如，’x’，且可存储在一个简单的字符类型变量中。一个字符常量可以是一个普通字符（例如 ‘x’）、一个转义序列（例如 ‘\t’）或者一个通用字符（例如 ‘\u02C0’）。
在 C# 中有一些特定的字符，当它们的前面带有反斜杠时有特殊的意义，可用于表示换行符（\n）或制表符 tab（\t）。在这里，列出一些转义序列码：



转义序列
含义



\\
\ 字符


\‘
‘ 字符


\“
“ 字符


?
? 字符


\a
警告（产生蜂鸣）


\b
退格键（Backspace）


\f
换页符（Form feed）


\n
换行符（Newline）


\r
回车


\t
水平制表符 tab


\v
垂直制表符 tab


\ooo
一到三位的八进制数


\xhh . . .
一个或多个数字的十六进制数


以下是一些转义序列字符的实例：
namespace EscapeChar&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;Hello\tWorld\n\n&quot;);            Console.ReadLine();        &#125;    &#125;&#125;

当上面的代码被编译和执行时，它会产生下列结果：
Hello   World

字符串常量字符串常量是括在双引号 &quot;&quot;里，或者是括在 @&quot;&quot; 里。字符串常量包含的字符与字符常量相似，可以是：普通字符、转义序列和通用字符
使用字符串常量时，可以把一个很长的行拆成多个行，可以使用空格分隔各个部分。
这里是一些字符串常量的实例。下面所列的各种形式表示相同的字符串。
string a = &quot;hello, world&quot;;                  // hello, worldstring b = @&quot;hello, world&quot;;               // hello, worldstring c = &quot;hello \t world&quot;;               // hello     worldstring d = @&quot;hello \t world&quot;;               // hello \t worldstring e = &quot;Joe said \&quot;Hello\&quot; to me&quot;;      // Joe said &quot;Hello&quot; to mestring f = @&quot;Joe said &quot;&quot;Hello&quot;&quot; to me&quot;;   // Joe said &quot;Hello&quot; to mestring g = &quot;\\\\server\\share\\file.txt&quot;;   // \\server\share\file.txtstring h = @&quot;\\server\share\file.txt&quot;;      // \\server\share\file.txtstring i = &quot;one\r\ntwo\r\nthree&quot;;string j = @&quot;onetwothree&quot;;



定义常量常量是使用 const 关键字来定义的 。定义一个常量的语法如下：
const &lt;data_type&gt; &lt;constant_name&gt; = value;

下面的代码演示了如何在程序中定义和使用常量：
实例using System;public class ConstTest&#123;  class SampleClass  &#123;    public int x;    public int y;    public const int c1 = 5;    public const int c2 = c1 + 5;    public SampleClass(int p1, int p2)    &#123;      x = p1;      y = p2;    &#125;  &#125;  static void Main()  &#123;    SampleClass mC = new SampleClass(11, 22);    Console.WriteLine(&quot;x = &#123;0&#125;, y = &#123;1&#125;&quot;, mC.x, mC.y);    Console.WriteLine(&quot;c1 = &#123;0&#125;, c2 = &#123;1&#125;&quot;,             SampleClass.c1, SampleClass.c2);  &#125;&#125;

当上面的代码被编译和执行时，它会产生下列结果：
x = 11, y = 22c1 = 5, c2 = 10













字符串（String）类型与处理​	字符串（String）类型 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串（String）类型的值可以通过两种形式进行分配：双引号和 @双引号
例如：
String str = &quot;hurriedlu&quot;;

一个 @引号字符串：
@&quot;hurriedlu&quot;;

C# string 字符串的前面可以加 @（称作”逐字字符串”）将转义字符（\）当作普通字符对待，比如：
string str = @&quot;C:\Windows&quot;;

等价于：
string str = &quot;C:\\Windows&quot;;

@ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。
string str = @&quot;&lt;script type=&quot;&quot;text/javascript&quot;&quot;&gt;    &lt;!--    --&gt;&lt;/script&gt;&quot;;

用户自定义引用类型有：class、interface 或 delegate。我们将在以后的章节中讨论这些类型。
字符串的处理
string类型的遍历可以视为char变量的只读数组。

例如：char c &#x3D; str[0];


如果需要将string转换成一个可写的char数组，可以使用如下代码:

string str = &quot;hurriedlu&quot;;
char[] myChars = str.ToCharArray();
- 也可以使用foreach遍历字符串  - ```c#    string str = &quot;hurriedlu&quot;;    foreach(char c in str)    &#123;    	Console.Write($&quot;&#123;c&#125; &quot;);//输出：h u r r i e d l u    &#125;




与普通数组一样，可以使用.Length获取数组长度。如：

string str = &quot;hurriedlu&quot;;
Console.WriteLine(str.Length);//输出：9
- 将字符串转换成全大写或全小写  - ```c#    string str = &quot;hUrrIEdlu&quot;;    Console.WriteLine(str);//原样输出    Console.WriteLine(str.ToLower());//转换成全小写后输出    Console.WriteLine(str.ToUpper());//转换成全大写后输出    //输出：hUrrIEdlu    //      hurriedlu    //      HURRIEDLU


注意，这个方法不会改变原有的值，而是创建一个新的值，新的值是全大&#x2F;小写的，并把这个值通过返回值的形式输出出去。



去除多余的前后空格（也可以删除指定的字符）。使用Trim删除指定字符的时候，会遍历整个string遍历，遇到符合的字母就会删除，遇到不符合的就停止删除操作

string str = &quot;  hu  rr          &quot;;
Console.WriteLine(str.Trim());//去除多余的前后空格，输出“hu  rr”
- ```c#  char[] trimChars = new char[] &#123; &#x27; &#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;u&#x27; &#125;;  string str = &quot;  hu  rriedlu          &quot;;  str = str.Trim(trimChars);//从头或者尾扫描，如果字符是数组trimChars的值就删掉，直到非trimChars数组的值停下，不再删除 直接返回剩余的字符串  Console.WriteLine(str);//删除指定的元素，这里指定了空格、h和i，输出“rriedl”  Console.WriteLine(str.Length);//输出6

- 可以看到在这个样例中，开头和结尾处的指定元素已经被删除了，但在中间的i并没有被删除。因为只要遇到非trimChars数组的值就停下，然后直接返回剩余的值。




在字符串的指定位置添加空格，常用于对齐字符串（数字）。

string str1 = &quot;hurr&quot;;
string str2 = &quot;hurriedlu&quot;;
//9表示字符串将变成9长度，在新增加的位置上补‘0’.
str1 = str1.PadLeft(9, &#39;0&#39;);//可以自定义补充元素，如果不指定就默认是空格。
Console.WriteLine(str1);
Console.WriteLine(str2);
//输出：
// 00000hurr
// hurriedlu
    ## 动态（Dynamic）类型​	可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。### 声明动态类型的语法：```c#dynamic &lt;variable_name&gt; = value;





例如：
dynamic d = 20;

动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。
隐式变量​	可声明局部变量而无需提供显式类型。 var 关键字指示编译器通过初始化语句右侧的表达式推断变量的类型。 推断类型可以是内置类型、匿名类型、用户定义类型或 .NET 类库中定义的类型。 有关如何使用 var 初始化数组的详细信息，请参阅隐式类型化数组。
以下示例演示使用 var 声明局部变量的各种方式：
// i is compiled as an intvar i = 5;// s is compiled as a stringvar s = &quot;Hello&quot;;// a is compiled as int[]var a = new[] &#123; 0, 1, 2 &#125;;// expr is compiled as IEnumerable&lt;Customer&gt;// or perhaps IQueryable&lt;Customer&gt;var expr =    from c in customers    where c.City == &quot;London&quot;    select c;// anon is compiled as an anonymous typevar anon = new &#123; Name = &quot;Terry&quot;, Age = 34 &#125;;// list is compiled as List&lt;int&gt;var list = new List&lt;int&gt;();



重要的是了解 var 关键字并不意味着“变体”，并且并不指示变量是松散类型或是后期绑定。 它只表示由编译器确定并分配最适合的类型。
在以下上下文中，可使用 var 关键字：

在局部变量（在方法范围内声明的变量）上，如前面的示例所示。

在 for 初始化语句中。
for (var x = 1; x &lt; 10; x++)

在 foreach 初始化语句中。
foreach (var item in list) &#123;...&#125;

在 using 域间中。
using (var file = new StreamReader(&quot;C:\\myfile.txt&quot;)) &#123;...&#125;

有关详细信息，请参阅如何在查询表达式中使用隐式类型化局部变量和数组。
var 和匿名类型在许多情况下，使用 var 是可选的，只是一种语法便利。 但是，在使用匿名类型初始化变量时，如果需要在以后访问对象的属性，则必须将变量声明为 var。 这是 LINQ 查询表达式中的常见方案。 有关详细信息，请参阅匿名类型。
从源代码角度来看，匿名类型没有名称。 因此，如果使用 var 初始化了查询变量，则访问返回对象序列中的属性的唯一方法是在 foreach 语句中将 var 用作迭代变量的类型。
class ImplicitlyTypedLocals2&#123;    static void Main()    &#123;        string[] words = &#123; &quot;aPPLE&quot;, &quot;BlUeBeRrY&quot;, &quot;cHeRry&quot; &#125;;        // If a query produces a sequence of anonymous types,        // then use var in the foreach statement to access the properties.        var upperLowerWords =             from w in words             select new &#123; Upper = w.ToUpper(), Lower = w.ToLower() &#125;;        // Execute the query        foreach (var ul in upperLowerWords)        &#123;            Console.WriteLine(&quot;Uppercase: &#123;0&#125;, Lowercase: &#123;1&#125;&quot;, ul.Upper, ul.Lower);        &#125;    &#125;&#125;/* Outputs:    Uppercase: APPLE, Lowercase: apple    Uppercase: BLUEBERRY, Lowercase: blueberry    Uppercase: CHERRY, Lowercase: cherry */



备注以下限制适用于隐式类型化变量声明：

仅当局部变量在相同语句中进行声明和初始化时，才能使用 var；变量不能初始化为 null，也不能初始化为方法组或匿名函数。
var 不能在类范围内对字段使用。
使用 var 声明的变量不能在初始化表达式中使用。 换句话说，此表达式是合法的：int i = (i = 20);，但是此表达式会生成编译时错误：var i = (i = 20);
不能在相同语句中初始化多个隐式类型化变量。
如果一种名为 var 的类型处于范围内，则 var 关键字会解析为该类型名称，不会被视为隐式类型化局部变量声明的一部分。

带 var 关键字的隐式类型只能应用于本地方法范围内的变量。 隐式类型不可用于类字段，因为 C# 编译器在处理代码时会遇到逻辑悖论：编译器需要知道字段的类型，但它在分析赋值表达式前无法确定类型，而表达式在不知道类型的情况下无法进行计算。 考虑下列代码：
private var bookTitles;

bookTitles 是类型为 var 的类字段。 由于该字段没有要计算的表达式，编译器无法推断出 bookTitles 应该是哪种类型。 此外，向该字段添加表达式（就像对本地变量执行的操作一样）也是不够的：
private var bookTitles = new List&lt;string&gt;();

当编译器在代码编译期间遇到字段时，它会在处理与其关联的任何表达式之前记录每个字段的类型。 编译器在尝试分析 bookTitles 时遇到相同的悖论：它需要知道字段的类型，但编译器通常会通过分析表达式来确定 var 的类型，这在事先不知道类型的情况下无法实现。
你可能会发现，对于在其中难以确定查询变量的确切构造类型的查询表达式，var 也可能会十分有用。 这可能会针对分组和排序操作发生。
当变量的特定类型在键盘上键入时很繁琐、或是显而易见、或是不会提高代码的可读性时，var 关键字也可能非常有用。 var 采用此方法提供帮助的一个示例是针对嵌套泛型类型（如用于分组操作的类型）。 在下面的查询中，查询变量的类型是 IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt;。 只要你和必须维护你的代码的其他人了解这一点，使用隐式类型化实现便利性和简便性时便不会出现问题。
// Same as previous example except we use the entire last name as a key.// Query variable is an IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt;var studentQuery3 =    from student in students    group student by student.Last;

使用 var 有助于简化代码，但是它的使用应该限制在需要使用它的情况下，或在它可使代码更易于读取的情况下。 有关何时正确使用 var 的详细信息，请参阅 C# 编码指南一文中的隐式类型本地变量节。
C# 类型转换隐式转换和显示转换类型转换从根本上说是类型铸造，或者说是把数据从一种类型转换为另一种类型。在 C# 中，类型铸造有两种形式：

隐式类型转换 - 这些转换是 C# 默认的以安全方式进行的转换, 不会导致数据丢失。例如，从小的整数类型转换为大的整数类型，从派生类转换为基类。

当试图用一个引用变量去访问它引用的实例的成员时，只能访问到这个变量所具有的成员。当用基类变量指向一个派生类的实例时，变量只能调用基类的成员（即使出现了重载，也会使用基类的而非派生类）。


显式类型转换 - 显式类型转换，即强制类型转换。显式转换需要强制转换运算符，而且强制转换会造成数据丢失。


下面的实例显示了一个显式的类型转换：
namespace TypeConversionApplication&#123;  class ExplicitConversion  &#123;    static void Main(string[] args)    &#123;      double d = 5673.74;      int i;      // 强制转换 double 为 int      i = (int)d;      Console.WriteLine(i);      Console.ReadKey();          &#125;  &#125;&#125;

当上面的代码被编译和执行时，它会产生下列结果：
5673



注意事项
如果彼此之间没有什么关系的类型不能进行强制转换。如string到int。

如果发生溢出，可以使用checked对可能溢出的代码进行修饰（或 包括），这样如果发生溢出就会抛出异常。详见c#基本语句中的checked/unchecked语句


Convert转换C# 提供了Convert类，其中内置了下列的一些类型转换方法：



序号
方法 &amp; 描述



1
ToBoolean 如果可能的话，把类型转换为布尔型。


2
ToByte 把类型转换为字节类型。


3
ToChar 如果可能的话，把类型转换为单个 Unicode 字符类型。


4
ToDateTime 把类型（整数或字符串类型）转换为 日期-时间 结构。


5
ToDecimal 把浮点型或整数类型转换为十进制类型。


6
ToDouble 把类型转换为双精度浮点型。


7
ToInt16 把类型转换为 16 位整数类型。


8
ToInt32 把类型转换为 32 位整数类型。


9
ToInt64 把类型转换为 64 位整数类型。


10
ToSbyte 把类型转换为有符号字节类型。


11
ToSingle 把类型转换为小浮点数类型。


12
ToString 把类型转换为字符串类型。


13
ToType 把类型转换为指定类型。


14
ToUInt16 把类型转换为 16 位无符号整数类型。


15
ToUInt32 把类型转换为 32 位无符号整数类型。


16
ToUInt64 把类型转换为 64 位无符号整数类型。


下面的实例把不同值的类型转换为字符串类型：
namespace TypeConversionApplication&#123;  class StringConversion  &#123;    static void Main(string[] args)    &#123;      int i = 75;      float f = 53.005f;      double d = 2345.7652;      bool b = true;      Console.WriteLine(i.ToString());      Console.WriteLine(f.ToString());      Console.WriteLine(d.ToString());      Console.WriteLine(b.ToString());      Console.ReadKey();     &#125;  &#125;&#125;

当上面的代码被编译和执行时，它会产生下列结果：
7553.0052345.7652True

注意事项
使用Convert类进行数值转换的时候，是比较安全的，转换的时候会自动检测精度是否会受损或者字符串是否是一个正确的数值，如果发生溢出或不是正确的字符串，会抛出异常。
数值的有效表达方式：
首先是一个可选符号(加号或减号)，然后是0位或多位数字，一个可选的句点后跟一位或多位数字，接着是一个可选的e或E，后跟一个可选符号和一位或多位数字，除了还可能有空格(在这个序列之前或之后)，不能有其他字符。利用这些可选的额外数据，可将- 1.2451e -24这样复杂的字符串识别为数值。


总是要进行溢出检查，checked 和unchecked关键字以及项目属性设置不起作用。

Parse转换用于string类型转其他类型，实际上是一种对字符串的解析。
需要注意的是，Parse只对格式正确的字符串进行解析，对于格式不正确的字符串会抛出System.FormatException:“输入字符串的格式不正确。”异常。
string str1 = &quot;123.456&quot;;string str2 = &quot;123.123.234&quot;;//格式错误double d1 = double.Parse(str1);//double d2 = double.Parse(str2); //会抛出错误

升级版的TryParse尝试转换，转换成功通过参数带回。返回值是一个布尔类型的变量。
string str1 = &quot;123.456&quot;;string str2 = &quot;123.123.234&quot;;//格式错误double d1;double d2;if(double.TryParse(str1,out d1))	Console.WriteLine(&quot;转换成功&quot;);    else	Console.WriteLine(&quot;转换失败&quot;);if (double.TryParse(str2, out d2))	Console.WriteLine(&quot;转换成功&quot;);else	Console.WriteLine(&quot;转换失败&quot;);



自定义类型转换基础知识​		类型转换有2种：隐式转换和显式转换。但是，不管是隐式转换，还是显式转换，都是生成了一个新对象返回的。改变新对象的属性，不会影响老对象！(dynamic对象除外，详情搜索dynamic动态类型。)
自定义隐式&#x2F;显式转换的方法需要用到几个关键字：implicit(隐式转换)、explicit(显式转换)、operator(操作符)。更多的注意点见下：

方法必须是static
使用implicit或explicit
搭配operator(此也是c#关键字，可在类别或结构宣告内多载内建运算子或提供使用者定义的转换)
返回值为要转换为的目标类型，但不要在方法上声明，方法名为目标类型。注意：返回值不一定是本类类型。本类型和其他类型之间可以互相转换，只要定义转换方法就行。
参数为原始类型，方法名为目标类型
类A到类B的类型转换定义不能在类C中进行（即2个类的转换不能在第3个类中定义），否则会报错：用户定义的转换必须是转换成封闭类型，或者从封闭类型转换。具体查看后面的用户定义的转换必须是转换成封闭类型，或者从封闭类型转换
不能被virtual&#x2F;override修饰（不能“覆盖”运算符，因为它们是静态的。）Overriding implicit operators in C#

对于自定义类型而言，可以手动的自定义类型转换。
样例1using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            A a = new A();            B b = (B)a;//自定义类型转换            Console.ReadLine();        &#125;        &#125;    class A    &#123;        public int n;        public static explicit operator B(A a)//自定义转换规则，显示类型转换，如果需要隐式转换，则将explicit换成implicit即可。        &#123;            B b = new B();//创建一个目标对象            b.n = a.n;//将自己的值按照一定的规则传给b对象            return b;//转换完成后返回目标对象        &#125;    &#125;    class B    &#123;        public int n;    &#125;&#125;



样例2//================定义类型和方法================class Robot&#123;    public int Id &#123; get; set; &#125;    public string Name &#123; get; set; &#125;    public Robot(int id, string name)    &#123;        Id = id;        Name = name;    &#125;    #region 其他类型-&gt;本类    //隐式转换    public static implicit operator Robot(string name)    &#123;        return new Robot(101, name);    &#125;    //显式转换    public static explicit operator Robot(int id)    &#123;        return new Robot(id, &quot;miku&quot;);    &#125;    #endregion    #region 本类-&gt;其他类型    //隐式转换    public static implicit operator string(Robot robot)    &#123;        return robot.Name;    &#125;    //显式转换    public static explicit operator int(Robot robot)    &#123;        return robot.Id;    &#125;    #endregion&#125;//================测试代码================#region 其他类型-&gt;本类string gumiStr = &quot;gumi&quot;;Robot gumi001 = gumiStr; //隐式转换Console.WriteLine(&quot;隐式转换：gumi001 : &#123;0&#125;&quot;, JsonConvert.SerializeObject(gumi001));int lukaId = 1004;Robot luka001 = (Robot)lukaId; //显式转换Console.WriteLine(&quot;显式转换：luka001 : &#123;0&#125;&quot;, JsonConvert.SerializeObject(luka001));#endregion#region 其他类型-&gt;本类Robot miku001 = new Robot(1001, &quot;miku10001&quot;);//隐式转换string mikuName = miku001;//显式转换int mikuId = (int)miku001;Console.WriteLine(&quot;隐式转换：miku001 Name: &#123;0&#125;&quot;, mikuName);Console.WriteLine(&quot;显式转换：miku001 Id: &#123;0&#125;&quot;, mikuId);#endregion

输出结果如下：
隐式转换：gumi001 : &#123;&quot;Id&quot;:101,&quot;Name&quot;:&quot;gumi&quot;&#125;显式转换：luka001 : &#123;&quot;Id&quot;:1004,&quot;Name&quot;:&quot;miku&quot;&#125;隐式转换：miku001 Name: miku10001显式转换：miku001 Id: 1001





实际应用问题
[1,[[2,2],[2,2],[2,2],[2,2]]]

这样一个字符串，如何可以反序列化成一个对象？（如何定义这个类？）
using System;using System.Linq;using System.Collections.Generic;using Newtonsoft.Json;using Newtonsoft.Json.Linq;                    public class Program&#123;    public static void Main()    &#123;        var json = &quot;[1,[[2,2],[2,2],[2,2],[2,2]]]&quot;;        var root = JsonConvert.DeserializeObject&lt;Root&gt;(json);        foreach(var ele in root)        &#123;            if(ele.SingleValue.HasValue)            &#123;//有值，原始数据为 1                Console.WriteLine(ele.SingleValue.Value);            &#125;else            &#123;//原始数据为 二维数组                Console.WriteLine(string.Join(&quot; &quot;,ele.Select(x=&gt;string.Join(&quot;,&quot;,x))));            &#125;        &#125;        Console.WriteLine(JsonConvert.SerializeObject(root));    &#125;&#125;class Root : List&lt;Element&gt; &#123; &#125;[JsonConverter(typeof(CConverter))]class Element : List&lt;List&lt;long&gt;&gt;&#123;    //该属性，存放 1 。后续可以通过判断该属性是否有值来得知原始数据的情况    public long? SingleValue &#123; get; set; &#125;    //遇到 1 ，隐式转换为 该类型，其中 1 被存放到SingleValue属性    public static implicit operator Element(long d)    &#123;        return new Element &#123; SingleValue = d &#125;;    &#125;&#125;public class CConverter : JsonConverter&#123;    public override bool CanConvert(Type objectType)    &#123;        return (objectType == typeof(Element));    &#125;    public override bool CanRead  &#123; get &#123; return false; &#125; &#125;    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)    &#123;        throw new NotImplementedException();    &#125;    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)    &#123;        var ele = value as Element;        var token = ele.SingleValue.HasValue ? JToken.FromObject(ele.SingleValue.Value) : JToken.FromObject(ele.ToList());        token.WriteTo(writer);    &#125;    public override bool CanWrite &#123; get &#123; return true; &#125; &#125;&#125;

来源：https://cloud.tencent.com/developer/article/1986028#:~:text=C%23%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%201%20%E6%96%B9%E6%B3%95%E5%BF%85%E9%A0%88%E6%98%AFstatic%202%20%E4%BD%BF%E7%94%A8%20implicit%20%E6%88%96%20explicit,%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%BF%85%E9%A1%BB%E6%98%AF%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%81%E9%97%AD%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%88%96%E8%80%85%E4%BB%8E%E5%B0%81%E9%97%AD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%207%20%E4%B8%8D%E8%83%BD%E8%A2%AB%20virtual%20%2F%20override%20%E4%BF%AE%E9%A5%B0%EF%BC%88%E4%B8%8D%E8%83%BD%E2%80%9C%E8%A6%86%E7%9B%96%E2%80%9D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%83%E4%BB%AC%E6%98%AF%E9%9D%99%E6%80%81%E7%9A%84%E3%80%82%20
C# 中的 Lvalues 和 RvaluesC# 中的两种表达式：（变量和常量？）

lvalue：lvalue 表达式可以出现在赋值语句的左边或右边。
rvalue：rvalue 表达式可以出现在赋值语句的右边，不能出现在赋值语句的左边。

变量是 lvalue 的，所以可以出现在赋值语句的左边。数值是 rvalue 的，因此不能被赋值，不能出现在赋值语句的左边。下面是一个有效的语句：
int g = 20;

下面是一个无效的语句，会产生编译时错误：
10 = 20;











C# 运算符


类别
运算符



基本
x.y f(x) a[x] x++ x– new typeof default checked unchecked delegate sizeof -&gt;


一元
+ - ! ~ ++ – (T)x await &amp;x *x


乘法
* &#x2F; %


加减
+ -


移位
&lt;&lt; &gt;&gt;


关系
&lt; &gt; &lt;&#x3D; &gt;&#x3D;


类型检测
is as


相等
&#x3D;&#x3D; !&#x3D;


逻辑与
&amp;


逻辑异或
^


逻辑或
|


条件与
&amp;&amp;


条件或
||


null 合并
??


条件
?:


赋值和lambda表达式
&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; +&#x3D; -&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D; &#x3D;&gt;



运算符也称为操作符
运算符的本质是函数的“简记法”
运算符不能脱离与它关联的数据类型

运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。分类如下：

算术运算符
关系运算符
逻辑运算符
位运算符
赋值运算符
其他运算

算术运算符C# 支持的所有算术运算符。假设变量 A 的值为 10，变量 B 的值为 20，则：



运算符
描述
实例



+
把两个操作数相加
A + B 将得到 30


-
从第一个操作数中减去第二个操作数
A - B 将得到 -10


*
把两个操作数相乘
A * B 将得到 200


&#x2F;
分子除以分母
B &#x2F; A 将得到 2


%
取模运算符，整除后的余数
B % A 将得到 0


++
自增运算符，整数值增加 1
A++ 将得到 11


–
自减运算符，整数值减少 1
A– 将得到 9


乘法运算符对于 x * y 形式的运算，应用二元运算符重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。
下面列出了预定义的乘法运算符。这些运算符均计算 x 和 y 的乘积。
·    整数乘法：
int operator *(int x, int y);uint operator *(uint x, uint y);long operator *(long x, long y);ulong operator *(ulong x, ulong y);
在 checked 上下文中，如果积超出结果类型的范围，则引发 System.OverflowException。在 unchecked 上下文中，不报告溢出并且结果类型范围外的任何有效高序位都被放弃。
·    浮点乘法：
float operator *(float x, float y);double operator *(double x, double y);
根据 IEEE 754 算术运算法则计算乘积。下表列出了非零有限值、零、无穷大和 NaN 的所有可能组合的结果。在该表中，x 和 y 是正有限值，z 是 x * y 的结果。如果结果对目标类型而言太大，则 z 为无穷大。如果结果对目标类型而言太小，则 z 为零。




+y
–y
+0
–0
+∞
–∞
NaN



+x
+z
–z
+0
–0
+∞
–∞
NaN


–x
–z
+z
–0
+0
–∞
+∞
NaN


+0
+0
–0
+0
–0
NaN
NaN
NaN


–0
–0
+0
–0
+0
NaN
NaN
NaN


+∞
+∞
–∞
NaN
NaN
+∞
–∞
NaN


–∞
–∞
+∞
NaN
NaN
–∞
+∞
NaN


NaN
NaN
NaN
NaN
NaN
NaN
NaN
NaN


·    小数乘法：
decimal operator *(decimal x, decimal y);
如果结果值太大，不能用 decimal 格式表示，则将引发 System.OverflowException。如果结果值太小，无法用 decimal 格式表示，则结果为零。在进行任何舍入之前，结果的小数位数是两个操作数的小数位数的和。
小数乘法等效于使用 System.Decimal 类型的乘法运算符。
除法运算符对于 x &#x2F; y 形式的运算，应用二元运算符重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。
下面列出了预定义的除法运算符。这些运算符均计算 x 和 y 的商。
·    整数除法：
int operator &#x2F;(int x, int y);uint operator &#x2F;(uint x, uint y);long operator &#x2F;(long x, long y);ulong operator &#x2F;(ulong x, ulong y);
如果右操作数的值为零，则引发 System.DivideByZeroException 导常。
除法将结果舍入到零。因此，结果的绝对值是小于或等于两个操作数的商的绝对值的最大可能整数。当两个操作数符号相同时，结果为零或正；当两个操作数符号相反时，结果为零或负。
如果左操作数为最小可表示 int 或 long 值，右操作数为 –1，则发生溢出。在 checked 上下文中，这会导致引发 System.ArithmeticException（或其子类）。在 unchecked 上下文中，它由实现定义为或者引发 System.ArithmeticException（或其子类），或者不以左操作数的结果值报告溢出。
·    浮点除法：
float operator &#x2F;(float x, float y);double operator &#x2F;(double x, double y);
根据 IEEE 754 算法法则计算商。下表列出了非零有限值、零、无穷大和 NaN 的所有可能组合的结果。在该表中，x 和 y 是正有限值，z 是 x &#x2F; y 的结果。如果结果对目标类型而言太大，则 z 为无穷大。如果结果对目标类型而言太小，则 z 为零。




+y
–y
+0
–0
+∞
–∞
NaN



+x
+z
–z
+∞
–∞
+0
–0
NaN


–x
–z
+z
–∞
+∞
–0
+0
NaN


+0
+0
–0
NaN
NaN
+0
–0
NaN


–0
–0
+0
NaN
NaN
–0
+0
NaN


+∞
+∞
–∞
+∞
–∞
NaN
NaN
NaN


–∞
–∞
+∞
–∞
+∞
NaN
NaN
NaN


NaN
NaN
NaN
NaN
NaN
NaN
NaN
NaN


·    小数除法：
decimal operator &#x2F;(decimal x, decimal y);
如果右操作数的值为零，则引发 System.DivideByZeroException 导常。如果结果值太大，不能用 decimal 格式表示，则将引发 System.OverflowException。如果结果值太小，无法用 decimal 格式表示，则结果为零。结果的小数位数是最小的小数位数，它保留等于最接近真实算术结果的可表示小数值的结果。
小数除法等效于使用 System.Decimal 类型的除法运算符。
余数运算符对于 x % y 形式的运算，应用二元运算符重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。
下面列出了预定义的余数运算符。这些运算符均计算 x 除以 y 的余数。
·    整数余数：
int operator %(int x, int y);uint operator %(uint x, uint y);long operator %(long x, long y);ulong operator %(ulong x, ulong y);
x % y 的结果是由 x – (x &#x2F; y) * y 生成的值。如果 y 为零，则将引发 System.DivideByZeroException。
如果左侧的操作数是最小的 int 或 long 值，且右侧的操作数是 -1，则将引发 System.OverflowException。只要 x % y 不引发异常，x &#x2F; y 也不会引发异常。
·    浮点余数：
float operator %(float x, float y);double operator %(double x, double y);
下表列出了非零有限值、零、无穷大和 NaN 的所有可能组合的结果。在该表中，x 和 y 是有限的正值。z 是 x % y 的结果，按照 x – n * y 进行计算，其中 n 是小于或等于 x &#x2F; y 的最大可能整数。这种计算余数的方法类似于用于整数操作数的方法，但不同于 IEEE 754 定义（在此定义中，n 是最接近 x &#x2F; y 的整数）。




+y
–y
+0
–0
+∞
–∞
NaN



+x
+z
+z
NaN
NaN
x
x
NaN


–x
–z
–z
NaN
NaN
–x
–x
NaN


+0
+0
+0
NaN
NaN
+0
+0
NaN


–0
–0
–0
NaN
NaN
–0
–0
NaN


+∞
NaN
NaN
NaN
NaN
NaN
NaN
NaN


–∞
NaN
NaN
NaN
NaN
NaN
NaN
NaN


NaN
NaN
NaN
NaN
NaN
NaN
NaN
NaN


·    小数余数：
decimal operator %(decimal x, decimal y);
如果右操作数的值为零，则引发 System.DivideByZeroException 导常。在进行任何舍入之前，结果的小数位数是两个操作数中较大的小数位数，而且结果的符号与 x 的相同（如果非零）。
小数余数等效于使用 System.Decimal 类型的余数运算符。
加法运算符对于 x + y 形式的运算，应用二元运算符重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。
下面列出了预定义的加法运算符。对于数值和枚举类型，预定义的加法运算符计算两个操作数的和。当一个或两个操作数为 string 类型时，预定义的加法运算符把两个操作数的字符串表示形式串联起来。
·    整数加法：
int operator +(int x, int y);uint operator +(uint x, uint y);long operator +(long x, long y);ulong operator +(ulong x, ulong y);
在 checked 上下文中，如果和超出结果类型的范围，则引发 System.OverflowException。在 unchecked 上下文中，不报告溢出并且结果类型范围外的任何有效高序位都被放弃。
·    浮点加法：
float operator +(float x, float y);double operator +(double x, double y);
根据 IEEE 754 算术运算法则计算和。下表列出了非零有限值、零、无穷大和 NaN 的所有可能组合的结果。在该表中，x 和 y 是非零有限值，z 是 x + y 的结果。如果 x 和 y 的绝对值相同但符号相反，则 zz 为正零。如果 x + y 太大，不能用目标类型表示，则 z 是与 x + y 具有相同符号的无穷大。




y
+0
–0
+∞
–∞
NaN



x
z
x
x
+∞
–∞
NaN


+0
y
+0
+0
+∞
–∞
NaN


–0
y
+0
–0
+∞
–∞
NaN


+∞
+∞
+∞
+∞
+∞
NaN
NaN


–∞
–∞
–∞
–∞
NaN
–∞
NaN


NaN
NaN
NaN
NaN
NaN
NaN
NaN


·    小数加法：
decimal operator +(decimal x, decimal y);
如果结果值太大，不能用 decimal 格式表示，则将引发 System.OverflowException。在进行任何舍入之前，结果的小数位数是两个操作数中较大的小数位数。
小数加法等效于使用 System.Decimal 类型的加法运算符。
·    枚举加法。每个枚举类型都隐式提供下列预定义运算符，其中 E 为枚举类型，U 为 E 的基础类型：
E operator +(E x, U y);E operator +(U x, E y);
在运行时，这些运算符完全按 (E)((U)x + (U)y) 计算。
·    字符串串联：
string operator +(string x, string y);string operator +(string x, object y);string operator +(object x, string y);
这些二元 + 运算符的重载执行字符串串连。在字符串串联运算中，如果它的一个操作数为 null，则用空字符串来替换此操作数。否则，任何非字符串参数都通过调用从 object 类型继承的虚 ToString 方法，转换为它的字符串表示形式。如果 ToString 返回 null，则将替换成空字符串。
using System;
class Test{static void Main() {string s &#x3D; null;Console.WriteLine(“s &#x3D; &gt;” + s + “&lt;”);   &#x2F;&#x2F; displays s &#x3D; &gt;&lt;int i &#x3D; 1;Console.WriteLine(“i &#x3D; “ + i);      &#x2F;&#x2F; displays i &#x3D; 1float f &#x3D; 1.2300E+15F;Console.WriteLine(“f &#x3D; “ + f);      &#x2F;&#x2F; displays f &#x3D; 1.23E+15decimal d &#x3D; 2.900m;Console.WriteLine(“d &#x3D; “ + d);      &#x2F;&#x2F; displays d &#x3D; 2.900}}
字符串串联运算符的结果是一个字符串，由左操作数的字符后接右操作数的字符组成。字符串串联运算符从不返回 null 值。如果没有足够的内存可用于分配得到的字符串，则可能引发 System.OutOfMemoryException。
·    委托组合。每个委托类型都隐式提供以下预定义运算符，其中 D 是委托类型：
D operator +(D x, D y);
当两个操作数均为某个委托类型 D 时，二元 + 运算符执行委托组合。（如果操作数具有不同的委托类型，则发生绑定时错误。）如果第一个操作数为 null，则运算结果为第二个操作数的值（即使此操作数也为 null）。否则，如果第二个操作数为 null，则运算结果为第一个操作数的值。否则，运算结果是一个新委托实例，该实例在被调用时调用第一个操作数，然后调用第二个操作数。有关委托组合的示例，请参见第 ‎7.8.5 节和第 ‎15.4 节。由于 System.Delegate 不是委托类型，因此不为它定义 operator +。
减法运算符对于 x – y 形式的运算，应用二元运算符重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。
下面列出了预定义的减法运算符。这些运算符均从 x 中减去 y。
·    整数减法：
int operator –(int x, int y);uint operator –(uint x, uint y);long operator –(long x, long y);ulong operator –(ulong x, ulong y);
在 checked 上下文中，如果差超出结果类型的范围，则引发 System.OverflowException。在 unchecked 上下文中，不报告溢出并且结果类型范围外的任何有效高序位都被放弃。
·    浮点减法：
float operator –(float x, float y);double operator –(double x, double y);
根据 IEEE 754 算术运算法则计算差。下表列出了非零有限值、零、无穷大和 NaN 的所有可能组合的结果。在该表中，x 和 y 是非零有限值，z 是 x – y 的结果。如果 x 和 y 相等，则 z 为正零。如果 x – y 太大，不能用目标类型表示，则 z 是与 x – y 具有相同符号的无穷大。




y
+0
–0
+∞
–∞
NaN



x
z
x
x
–∞
+∞
NaN


+0
–y
+0
+0
–∞
+∞
NaN


–0
–y
–0
+0
–∞
+∞
NaN


+∞
+∞
+∞
+∞
NaN
+∞
NaN


–∞
–∞
–∞
–∞
–∞
NaN
NaN


NaN
NaN
NaN
NaN
NaN
NaN
NaN


·    小数减法：
decimal operator –(decimal x, decimal y);
如果结果值太大，不能用 decimal 格式表示，则将引发 System.OverflowException。在进行任何舍入之前，结果的小数位数是两个操作数中较大的小数位数。
小数减法等效于使用 System.Decimal 类型的减法运算符。
·    枚举减法。每个枚举类型都隐式提供下列预定义运算符，其中 E 为枚举类型，U 为 E 的基础类型：
U operator –(E x, E y);
此运算符严格按 (U)((U)x – (U)y) 计算。换言之，运算符计算 x 和 y 的序数值之间的差，结果类型是枚举的基础类型。
E operator –(E x, U y);
此运算符严格按 (E)((U)x – y) 计算。换言之，该运算符从枚举的基础类型中减去一个值，得到枚举的值。
·    委托移除。每个委托类型都隐式提供以下预定义运算符，其中 D 是委托类型：
D operator –(D x, D y);
当两个操作数均为某个委托类型 D 时，二元 – 运算符执行委托移除。如果操作数具有不同的委托类型，则发生绑定时错误。如果第一个操作数为 null，则运算结果为 null。否则，如果第二个操作数为 null，则运算结果为第一个操作数的值。否则，两个操作数都表示包含一项或多项的调用列表（第 ‎15.1 节），并且只要第二个操作数列表是第一个操作数列表的适当的邻接子列表，那么结果就是从第一个操作数的调用列表中移除了第二个操作数的调用列表所含各项后的一个新调用列表。     （为确定子列表是否相等，用委托相等运算符（第 ‎7.10.8 节）比较相对应的项。）否则，结果为左操作数的值。在此过程中两个操作数的列表均未被更改。如果第二个操作数的列表与第一个操作数的列表中的多个邻接项子列表相匹配，则移除最右边的那个匹配邻接项的子列表。如果移除导致空列表，则结果为 null。例如：
delegate void D(int x);class C&#123; public static void M1(int i) &#123; /* … */ &#125; public static void M2(int i) &#123; /* … */ &#125;&#125;class Test&#123; static void Main() &#123;     D cd1 = new D(C.M1);     D cd2 = new D(C.M2);     D cd3 = cd1 + cd2 + cd2 + cd1; // M1 + M2 + M2 + M1     cd3 -= cd1;              // =&gt; M1 + M2 + M2     cd3 = cd1 + cd2 + cd2 + cd1;    // M1 + M2 + M2 + M1     cd3 -= cd1 + cd2;         // =&gt; M2 + M1     cd3 = cd1 + cd2 + cd2 + cd1;    // M1 + M2 + M2 + M1     cd3 -= cd2 + cd2;         // =&gt; M1 + M1     cd3 = cd1 + cd2 + cd2 + cd1;    // M1 + M2 + M2 + M1     cd3 -= cd2 + cd1;         // =&gt; M1 + M2     cd3 = cd1 + cd2 + cd2 + cd1;    // M1 + M2 + M2 + M1     cd3 -= cd1 + cd1;         // =&gt; M1 + M2 + M2 + M1 &#125;&#125;















关系和类型测试运算符&#x3D;&#x3D;、!&#x3D;、&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;、is 和 as 运算符称为关系和类型测试运算符。

relational-expression:
shift-expression
relational-expression  &lt;  shift-expression
relational-expression  &gt;  shift-expression
relational-expression  &lt;&#x3D;  shift-expression
relational-expression  &gt;&#x3D;  shift-expression
relational-expression  is  type
relational-expression  as  type


equality-expression:
relational-expression
equality-expression  &#x3D;&#x3D;  relational-expression
equality-expression  !&#x3D;  relational-expression



is 和 as 运算符分别在第 ‎7.10.10 节和第 ‎7.10.11 节中说明。
&#x3D;&#x3D;、!&#x3D;、&lt;、&gt;、&lt;&#x3D; 和 &gt;&#x3D; 运算符为比较运算符 (comparison operator)。
如果比较运算符的某个操作数为编译时类型 dynamic，则表达式是动态绑定的（第 ‎7.2.2 节）。在此情况下，表达式的编译时类型为 dynamic，并且会在运行时使用具有编译时类型 dynamic 的操作数的运行时类型进行下面所述的决策。
对于 x op y 形式（其中 op 为比较运算符）的运算，应用重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。
预定义的比较运算符详见下面各节的介绍。所有预定义的比较运算符都返回 bool 类型的结果，详见下表。



运算
结果



x &#x3D;&#x3D; y
如果 x 等于  y，则为  true，否则为 false


x !&#x3D; y
如果 x 不等于  y，则为  true，否则为 false


x &lt;  y
如果 x 小于  y，则为  true，否则为 false


x &gt;  y
如果 x 大于  y，则为  true，否则为 false


x &lt;&#x3D;  y
如果 x 小于或等于 y，则为  true，否则为 false


x &gt;&#x3D;  y
如果 x 大于或等于 y，则为  true，否则为 false


x is y
如果x的类型与y的类型一致，则为true，否则为false


比较运算符整数比较运算符预定义的整数比较运算符为：
bool operator &#x3D;&#x3D;(int x, int y); bool operator &#x3D;&#x3D;(uint x, uint y); bool operator &#x3D;&#x3D;(long x, long y); bool operator &#x3D;&#x3D;(ulong x, ulong y);
bool operator !&#x3D;(int x, int y); bool operator !&#x3D;(uint x, uint y); bool operator !&#x3D;(long x, long y); bool operator !&#x3D;(ulong x, ulong y);
bool operator &lt;(int x, int y); bool operator &lt;(uint x, uint y); bool operator &lt;(long x, long y); bool operator &lt;(ulong x, ulong y);
bool operator &gt;(int x, int y); bool operator &gt;(uint x, uint y); bool operator &gt;(long x, long y); bool operator &gt;(ulong x, ulong y);
bool operator &lt;&#x3D;(int x, int y); bool operator &lt;&#x3D;(uint x, uint y); bool operator &lt;&#x3D;(long x, long y); bool operator &lt;&#x3D;(ulong x, ulong y);
bool operator &gt;&#x3D;(int x, int y); bool operator &gt;&#x3D;(uint x, uint y); bool operator &gt;&#x3D;(long x, long y); bool operator &gt;&#x3D;(ulong x, ulong y);
这些运算符都比较两个整数操作数的数值并返回一个 bool 值，该值指示特定的关系是 true 还是 false。
浮点比较运算符预定义的浮点比较运算符为：
bool operator &#x3D;&#x3D;(float x, float y); bool operator &#x3D;&#x3D;(double x, double y);
bool operator !&#x3D;(float x, float y); bool operator !&#x3D;(double x, double y);
bool operator &lt;(float x, float y); bool operator &lt;(double x, double y);
bool operator &gt;(float x, float y); bool operator &gt;(double x, double y);
bool operator &lt;&#x3D;(float x, float y); bool operator &lt;&#x3D;(double x, double y);
bool operator &gt;&#x3D;(float x, float y); bool operator &gt;&#x3D;(double x, double y);
这些运算符根据 IEEE 754 标准法则比较操作数：
·    如果两个操作数中的任何一个为 NaNN，则对于除 !&#x3D;（对于此运算符，结果为 true）外的所有运算符，结果均为 false。对于任何两个操作数，x !&#x3D; y 始终生成与 !(x &#x3D;&#x3D; y) 相同的结果。然而，当一个操作数或两个操作数为 NaN 时，&lt;、&gt;、&lt;&#x3D; 和 &gt;&#x3D; 运算符不产生与其对应的反向运算符的逻辑否定相同的结果。例如，如果 x 和 y 中的任何一个为 NaN，则 x &lt; y 为 false，而 !(x &gt;&#x3D; y) 为 true。
·    当两个操作数都不为 NaN 时，这些运算符就按下列顺序来比较两个浮点操作数的值
–∞ &lt; –max &lt; … &lt; –min &lt; –0.0 &#x3D;&#x3D; +0.0 &lt; +min &lt; … &lt; +max &lt; +∞
这里的 min 和 max 是可以用给定浮点格式表示的最小和最大正有限值。这样排序的显著特点是：
o  负零和正零被视为相等。
o  负无穷大被视为小于所有其他值，但等于其他负无穷大。
o  正无穷大被视为大于所有其他值，但等于其他正无穷大。
小数比较运算符预定义的小数比较运算符为：
bool operator &#x3D;&#x3D;(decimal x, decimal y);
bool operator !&#x3D;(decimal x, decimal y);
bool operator &lt;(decimal x, decimal y);
bool operator &gt;(decimal x, decimal y);
bool operator &lt;&#x3D;(decimal x, decimal y);
bool operator &gt;&#x3D;(decimal x, decimal y);
这些运算符都比较两个 decimal 操作数的数值并返回一个 bool 值，该值指示特定的关系是 true 还是 false。各小数比较等效于使用 System.Decimal 类型的相应关系运算符或相等运算符。
布尔相等运算符预定义的布尔相等运算符为：
bool operator &#x3D;&#x3D;(bool x, bool y);
bool operator !&#x3D;(bool x, bool y);
如果 x 和 y 都为 true，或者如果 x 和 y 都为 false，则 &#x3D;&#x3D; 的结果为 true。否则，结果为 false。
如果 x 和 y 都为 true，或者如果 x 和 y 都为 false，则 !&#x3D; 的结果为 false。否则，结果为 true。当操作数为 bool 类型时，!&#x3D; 运算符产生与 ^ 运算符相同的结果。
枚举比较运算符每种枚举类型都隐式提供下列预定义的比较运算符：
bool operator &#x3D;&#x3D;(E x, E y);
bool operator !&#x3D;(E x, E y);
bool operator &lt;(E x, E y);
bool operator &gt;(E x, E y);
bool operator &lt;&#x3D;(E x, E y);
bool operator &gt;&#x3D;(E x, E y);
x op y（其中 x 和 y 是具有基础类型 U 的枚举类型 E 的表达式，op 是一个比较运算符）的计算结果与 (E)((U)x) op ((U)y) 的计算结果完全相同。换言之，枚举类型比较运算符只比较两个操作数的基础整数值。
引用类型相等运算符预定义的引用类型相等运算符为：
bool operator &#x3D;&#x3D;(object x, object y);
bool operator !&#x3D;(object x, object y);
这些运算符返回两个引用是相等还是不相等的比较结果。
由于预定义的引用类型相等运算符接受 object 类型的操作数，因此它们适用于所有那些没有为自己声明适用的 operator &#x3D;&#x3D; 和 operator !&#x3D; 成员的类型。相反，任何适用的用户定义的相等运算符都有效地隐藏上述预定义的引用类型相等运算符。
预定义的引用类型相等运算符要求满足以下条件之一：
·    两个操作数均为已知的 reference-type 类型的值或文本 null。此外，存在从其中一个操作数的类型到另一个操作数的类型的显式引用转换（第 ‎6.2.4 节）。
·    一个操作数是类型为 T 的值，其中 T 为 type-parameter，另一个操作数为文本 null。此外，T 不具有值类型约束。
除非满足以下这些条件之一，否则将发生绑定时错误。这些规则中值得注意的含义是：
·    使用预定义的引用类型相等运算符比较两个在绑定时已能确定是不相同的引用时，会导致绑定时错误。例如，如果操作数的绑定时类型是两种类类型 A 和 B，并且如果 A 和 B 都不是从对方派生的，则两个操作数不可能引用同一对象。因此，此运算被认为是绑定时错误。
·    预定义的引用类型相等运算符不允许比较值类型操作数。因此，除非结构类型声明自己的相等运算符，否则不可能比较该结构类型的值。
·    预定义的引用类型相等运算符从不会导致对它们的操作数执行装箱操作。执行此类装箱操作毫无意义，这是因为对新分配的已装箱实例的引用必将不同于所有其他引用。
·    如果将类型参数类型 T 的操作数与 null进行比较，并且 T 的运行时类型为值类型，则比较结果为 false。
下面的示例检查未受约束的类型形参类型的实参是否为 null。
虽然 T 可能表示值类型，但是 x &#x3D;&#x3D; null 构造是允许的，当 T 为值类型时，结果只是被定义为 false。
对于 x &#x3D;&#x3D; y 或 x !&#x3D; y 形式的运算，如果存在任何适用的 operator &#x3D;&#x3D; 或 operator !&#x3D;，则运算符重载决策（第 ‎7.3.4 节）规则将选择该运算符而不是上述的预定义的引用类型相等运算符。不过，始终可以通过将一个或两个操作数显式强制转换为 object 类型来选择预定义的引用类型相等运算符。下面的示例
using System;class Test&#123;    static void Main()    &#123;        string s = &quot;Test&quot;;        string t = string.Copy(s);        Console.WriteLine(s == t);        Console.WriteLine((object)s == t);        Console.WriteLine(s == (object)t);        Console.WriteLine((object)s == (object)t);    &#125;&#125;

产生输出
True False False False
变量 s 和 t 引用两个包含相同字符的不同 string 实例。第一个比较输出 True，原因是当两个操作数都为 string 类型时选择了预定义的字符串相等运算符（第 ‎7.10.7 节）。其余的比较全都输出 False，这是因为是在一个或两个操作数为 object 类型时选定预定义的引用类型相等运算符。
注意，以上技术对值类型没有意义。下面的示例
class Test&#123;    static void Main()    &#123;        int i = 123;        int j = 123;        System.Console.WriteLine((object)i == (object)j);    &#125;&#125;

输出 False，这是因为强制转换创建对已装箱 int 值的两个单独实例的引用。
字符串相等运算符预定义的字符串相等运算符为：
bool operator &#x3D;&#x3D;(string x, string y);
bool operator !&#x3D;(string x, string y);
当下列条件中有一个为真时，两个 string 值被视为相等：
·    两个值都为 null。
·    两个值都是对字符串实例的非空引用，这两个字符串不仅具有相同的长度，而且在每个字符位置上的字符亦都彼此相同。
字符串相等运算符比较的是字符串值而不是对字符串的引用。当两个单独的字符串实例包含完全相同的字符序列时，字符串的值相等，但引用不相同。正如第 ‎7.10.6 节中所描述的那样，引用类型相等运算符可用于比较字符串引用而不是字符串值。
委托相等运算符每个委托类型都隐式地提供下列预定义的比较运算符：
bool operator &#x3D;&#x3D;(System.Delegate x, System.Delegate y);
bool operator !&#x3D;(System.Delegate x, System.Delegate y);
两个委托实例按下面这样被视为相等：
·    如果两个委托实例中有一个为 null，则当且仅当它们都为 null 时相等。
·    具有不同运行时类型的委托永远不相等。
·    如果两个委托实例都具有调用列表（第 ‎15.1) 节），则当且仅当它们的调用列表长度相同，并且一个实例的调用列表中的每项依次等于（如下面的定义）另一个的调用列表中的相应项时，这两个委托实例相等。
以下规则控制调用列表项的相等性：
·    如果两个调用列表项都引用同一静态方法，则这两项相等。
·    如果两个调用列表项都引用同一个目标对象（引用相等运算符定义的目标对象）上的同一个非静态方法，则这两个调用列表项相等。
·    允许（但不要求）具有相同被捕获外层变量实例集（可能为空集）且语义上相同的  anonymous-function-expression 计算生成的调用列表项相等。
相等运算符和 null&#x3D;&#x3D; 和 !&#x3D; 运算符允许一个操作数是可为 null 的类型的值，另一个是 null 文本，即使运算中不存在预定义或用户定义的运算符（未提升或提升形式）。
对于下面某个形式的操作
x &#x3D;&#x3D; null  null &#x3D;&#x3D; x  x !&#x3D; null  null !&#x3D; x
其中 x 是可为 null 的类型的表达式，如果运算符重载决策（第 7.2.4 节）未能找到适用的运算符，则改为从 x 的 HasValue 属性计算结果。具体而言，前两种形式将转换为 !x.HasValue，后两种形式将转换为 x.HasValue。
is 运算符is 运算符用于动态检查对象的运行时类型是否与给定类型兼容。E is T 运算（其中 E 为表达式，T 为类型）的结果是布尔值，表示 E 的类型是否可通过引用转换、装箱转换或取消装箱转换而成功转换为类型 T。使用类型实参替换了所有类型形参后，按如下方式计算该运算：

如果 E 是匿名函数，将发生编译时错误

如果 E 是方法组或 null 文本，或者如果 E 的类型是引用类型或可为 null 的类型并且 E 的值为 null，则结果为 false。

否则，根据下列规则让 D 表示 E 的动态类型：

如果 E 的类型为引用类型，则 D 为 E 引用的实例的运行时类型。

如果 E 的类型为可以为 null 的类型，则 D 为该可以为 null 的类型的基础类型。

如果 E 的类型为不可以为 null 值的类型，则 D 为 E 的类型。

该操作的结果取决于 D 和 T，具体如下：

如果 T 为引用类型，那么，在以下情况下结果为 true：D 和 T 为相同类型，或者 D 为引用类型并且存在从 D 到 T 的隐式引用转换，或者 D 为值类型并且存在从 D 到 T 的装箱转换。

如果 T 为可以为 null 的类型，那么，当 D 为 T 的基础类型时结果为 true。

如果 T 为不可以为 null 值的类型，那么，如果 D 和 T 为相同类型，则结果为 true。

否则，结果为 false。




请注意，用户定义的转换不在 is 运算符考虑之列。
as 运算符as 运算符用于将一个值显式转换为一个给定的引用类型或可为 null 的类型。与强制转换表达式不同，as 运算符从不引发异常。它采用的是：如果指定的转换不可能实施，则运算结果为 null。
在 E as T 形式的操作中，E 必须为表达式，T 必须为引用类型、已知为引用类型的类型参数或可以为 null 的类型。此外，下列条件中必须至少有一条成立，否则会发生编译时错误：
·    存在从 E 到 T 的以下类型转换：标识（第 6.1.1 节）、隐式可以为 null（第 ‎6.1.4 节）、隐式引用（第 ‎6.1.6 节）、装箱（第 ‎6.1.7 节）、显式可以为 null（第 ‎6.2.3 节）、显式引用（第 ‎6.2.4 节）或取消装箱（第 ‎6.2.5 节）转换。
·    E 或 T 的类型为开放类型。
·    E 为 null 文本。
如果 E 的编译时类型不是 dynamic，则运算 E as T 将生成与下面的计算相同的结果
E is T ? (T)(E) : (T)null
不同的只是：实际执行中 E 只计算一次。编译器应该优化 E as T 以最多执行一次动态类型检查，而不是上面的扩展隐含的两次动态类型检查。
如果 E 的编译时类型为 dynamic，则与强制转换运算符不同，as 运算符不是动态绑定的（第 ‎7.2.2 节）。因此这种情况下的扩展为：
E is T ? (T)(object)(E) : (T)null
请注意，不能使用 as 运算符执行某些转换（如用户定义的转换），应改为使用强制转换表达式来执行这些转换。
在下面的示例中
using System;class X&#123;    public string F(object o)    &#123;        return o as string;   // OK, string is a reference type    &#125;    public T G&lt;T&gt;(object o) where T : Attribute    &#123;        return o as T;       // Ok, T has a class constraint    &#125;    public U H&lt;U&gt;(object o)    &#123;        return o as U;       // Error, U is unconstrained     &#125;&#125;

G 的类型参数 T 已知为引用类型，原因是它有类约束。但 H 的类型参数 U 不是；因此，不允许在 H 中使用 as 运算符。
逻辑运算符下表显示了 C# 支持的所有逻辑运算符。假设变量 A 为布尔值 true，变量 B 为布尔值 false，则：



运算符
描述
实例



&amp;&amp;
称为逻辑与运算符。如果两个操作数都非零，则条件为真。
(A &amp;&amp; B) 为假。


||
称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。
(A || B) 为真。


!
称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。
!(A &amp;&amp; B) 为真。



1.1 条件逻辑运算符&amp;&amp; 和 || 运算符称为条件逻辑运算符。也称为“短路”逻辑运算符。
conditional-and-expression:inclusive-or-expressionconditional-and-expression  &amp;&amp;  inclusive-or-expression
conditional-or-expression:conditional-and-expressionconditional-or-expression  ||  conditional-and-expression
&amp;&amp; 和 || 运算符是 &amp; 和 | 运算符的条件版本：
·    x &amp;&amp; y 运算对应于 x &amp; y 运算，但仅当 x 不为 false 时才计算 y。
·    x || y 运算对应于 x | y 运算，但仅当 x 不为 true 时才计算 y。
如果条件逻辑运算符的某个操作数具有编译时类型 dynamic，则表达式是动态绑定的（第 ‎7.2.2 节）。在此情况下，表达式的编译时类型为 dynamic，并且会在运行时使用具有编译时类型 dynamic 的操作数的运行时类型进行下面所述的决策。
x &amp;&amp; y 或 x || y 形式的运算通过应用重载决策（第 ‎7.3.4 节）来处理，就好比运算的书写形式为 x &amp; y 或 x | y。然后，
·    如果重载决策未能找到单个最佳运算符，或者重载决策选择一个预定义的整数逻辑运算符，则发生绑定时错误。
·    否则，如果选定的运算符是一个预定义的布尔逻辑运算符（第 ‎7.11.3 节）或可以为 null 的布尔逻辑运算符（第 ‎7.11.4 节），则运算按第 ‎7.12.1 节中所描述的那样进行处理。
·    否则，选定的运算符为用户定义的运算符，且运算按第 ‎7.12.2 节中所描述的那样进行处理。
不可能直接重载条件逻辑运算符。不过，由于条件逻辑运算符按通常的逻辑运算符计算，因此通常的逻辑运算符的重载，在某些限制条件下，也被视为条件逻辑运算符的重载。第 ‎7.12.2 节对此有进一步描述。
1.1.1 布尔条件逻辑运算符当 &amp;&amp; 或 || 的操作数为 bool 类型时，或者当操作数的类型本身未定义适用的 operator &amp; 或 operator |，但确实定义了到 bool 的隐式转换时，运算按下面这样处理：
·    运算 x &amp;&amp; y 的求值过程相当于 x ? y : false。换言之，首先计算 x 并将其转换为 bool 类型。如果 x 为 true，则计算 y 并将其转换为 bool 类型，并且这成为运算结果。否则，运算结果为 false。
·    运算 x || y 的求值过程相当于 x ? true : y。换言之，首先计算 x 并将其转换为 bool 类型。然后，如果 x 为 true，则运算结果为 true。否则，计算 y 并将其转换为 bool 类型，并且这作为运算结果。
1.1.2 用户定义的条件逻辑运算符当 &amp;&amp; 或 || 的操作数所属的类型声明了适用的用户定义的 operator &amp; 或 operator | 时，下列两个条件必须都为真（其中 T 是声明的选定运算符的类型）：
·    选定运算符的返回类型和每个参数的类型都必须为 T。换言之，该运算符必须计算类型为 T 的两个操作数的逻辑 AND 或逻辑 OR，且必须返回类型为 T 的结果。
·    T 必须包含 operator true 和 operator false 的声明。
如果这两个要求中有一个未满足，则发生绑定时错误。如果这两个要求都满足，则通过将用户定义的 operator true 或 operator false 与选定的用户定义的运算符组合在一起来计算 &amp;&amp; 运算或 || 运算：
·    x &amp;&amp; y 运算按 T.false(x) ? x : T.&amp;(x, y) 进行计算，其中 T.false(x) 是 T 中声明的 operator false 的调用，T.&amp;(x, y) 是选定 operator &amp; 的调用。换言之，首先计算 x，然后对结果调用 operator false 以确定 x 是否肯定为 false。如果 x 肯定为假，则运算结果为先前为 x 计算的值。否则将计算 y，并对先前为 x 计算的值和为 y 计算的值调用选定的 operator &amp; 以产生运算结果。
·    x || y 运算按 T.true(x) ? x : T.|(x, y) 进行计算，其中 T.true(x) 是 T 中声明的 operator true 的调用，T.|(x, y) 是选定 operator | 的调用。换言之，首先计算 x，然后对结果调用 operator true 以确定 x 是否肯定为 true。然后，如果 x 肯定为真，则运算结果为先前为 x 计算的值。否则将计算 y，并对先前为 x 计算的值和为 y 计算的值调用选定的 operator | 以产生运算结果。
在这两个运算中，x 给定的表达式只计算一次，y 给定的表达式要么不计算，要么只计算一次。
有关实现了 operator true 和 operator false 的类型的示例，请参见第 ‎11.4.2 节。

位运算符位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：



p
q
p &amp; q
p | q
p ^ q



0
0
0
0
0


0
1
0
1
1


1
1
1
1
0


1
0
0
1
1


假设如果 A &#x3D; 60，且 B &#x3D; 13，现在以二进制格式表示，它们如下所示：
A &#x3D; 0011 1100
B &#x3D; 0000 1101
-—————-
A&amp;B &#x3D; 0000 1100
A|B &#x3D; 0011 1101
A^B &#x3D; 0011 0001
~A &#x3D; 1100 0011
下表列出了 C# 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：



运算符
描述
实 例



&amp;
如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。
(A &amp; B) 将得到 12，即为 0000 1100


|
如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。
(A | B) 将得到 61，即为 0011 1101


^
如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。
(A ^ B) 将得到 49，即为 0011 0001


~
按位取反运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0，包括符号位。
(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。


&lt;&lt;
二进制左移运算符。左操作数的值向左移动右操作数指定的位数。
A &lt;&lt; 2 将得到 240，即为 1111 0000


&gt;&gt;
二进制右移运算符。左操作数的值向右移动右操作数指定的位数。
A &gt;&gt; 2 将得到 15，即为 0000 1111


左移不管是正数还是负数，补的数都是0；
右移：如果正在操作的数是证书的话，最高位补入0；如果是负数则补入1

1.1 逻辑运算符&amp;、^ 和 | 运算符称为逻辑运算符。
and-expression:equality-expressionand-expression  &amp;  equality-expression
exclusive-or-expression:and-expressionexclusive-or-expression  ^  and-expression
inclusive-or-expression:exclusive-or-expressioninclusive-or-expression  |  exclusive-or-expression
如果逻辑运算符的某个操作数具有编译时类型 dynamic，则表达式是动态绑定的（第 ‎7.2.2 节）。在此情况下，表达式的编译时类型为 dynamic，并且会在运行时使用具有编译时类型 dynamic 的操作数的运行时类型进行下面所述的决策。
对于 x op y 形式的运算（其中 op 为一个逻辑运算符），应用重载决策（第 ‎7.3.4 节）以选择一个特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。
下列章节介绍了预定义的逻辑运算符。
1.1.1 整数逻辑运算符预定义的整数逻辑运算符为：
int operator &amp;(int x, int y);uint operator &amp;(uint x, uint y);long operator &amp;(long x, long y);ulong operator &amp;(ulong x, ulong y);
int operator |(int x, int y);uint operator |(uint x, uint y);long operator |(long x, long y);ulong operator |(ulong x, ulong y);
int operator ^(int x, int y);uint operator ^(uint x, uint y);long operator ^(long x, long y);ulong operator ^(ulong x, ulong y);
&amp; 运算符计算两个操作数的按位逻辑 AND，| 运算符计算两个操作数的按位逻辑 OR，而 ^ 运算符计算两个操作数的按位逻辑 XOR。这些运算不可能产生溢出。
1.1.2 枚举逻辑运算符每个枚举类型 E 都隐式地提供下列预定义的逻辑运算符：
E operator &amp;(E x, E y);E operator |(E x, E y);E operator ^(E x, E y);
x op y（其中 x 和 y 是具有基础类型 U 的枚举类型 E 的表达式，op 是一个逻辑运算符）的计算结果与 (E)((U)x op (U)y) 的计算结果完全相同。换言之，枚举类型逻辑运算符直接对两个操作数的基础类型执行逻辑运算。
1.1.3 布尔逻辑运算符预定义的布尔逻辑运算符为：
bool operator &amp;(bool x, bool y);
bool operator |(bool x, bool y);
bool operator ^(bool x, bool y);
如果 x 和 y 均为 true，则 x &amp; y 的结果为 true。否则，结果为 false。
如果 x 或 y 为 true，则 x | y 的结果为 true。否则，结果为 false。
如果 x 为 true 且 y 为 false，或者 x 为 false 且 y 为 true，则 x ^ y 的结果为 true。否则，结果为 false。当操作数为 bool 类型时，^ 运算符计算结果与 !&#x3D; 运算符相同。
1.1.4 可以为 null 的布尔逻辑运算符可以为 null 的布尔类型 bool? 可表示三个值 true、false 和 null，并且在概念上类似于 SQL 中的布尔表达式的三值类型。为了确保针对 bool? 操作数的 &amp; 和 | 运算符产生的结果与 SQL 的三值逻辑一致，提供了下列预定义运算符：
bool? operator &amp;(bool? x, bool? y);
bool? operator |(bool? x, bool? y);
下表列出了这些运算符对 true、false 和 null 值的所有组合所产生的结果。



x
y
x &amp; y
x | y



true
true
true
true


true
false
false
true


true
null
null
true


false
true
false
true


false
false
false
false


false
null
false
null


null
true
null
true


null
false
false
null


null
null
null
null


1.2 移位运算符&lt;&lt; 和 &gt;&gt; 运算符用于执行移位运算。
shift-expression:additive-expressionshift-expression  &lt;&lt;  additive-expressionshift-expression  right-shift  additive-expression
如果 shift-expression 的某个操作数具有编译时类型 dynamic，则表达式是动态绑定的（第 ‎7.2.2 节）。在此情况下，表达式的编译时类型为 dynamic，并且会在运行时使用具有编译时类型 dynamic 的操作数的运行时类型进行下面所述的决策。
对于 x &lt;&lt; count 或 x &gt;&gt; count 形式的运算，应用二元运算符重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。
当声明重载移位运算符时，第一个操作数的类型必须总是包含运算符声明的类或结构，并且第二个操作数的类型必须总是 int。
下面列出了预定义的移位运算符。
·    左移位：
int operator &lt;&lt;(int x, int count);uint operator &lt;&lt;(uint x, int count);long operator &lt;&lt;(long x, int count);ulong operator &lt;&lt;(ulong x, int count);
&lt;&lt; 运算符将 x 向左位移若干个位，具体计算方法如下所述。
放弃 x 中经移位后会超出结果类型范围的那些高序位，将其余的位向左位移，将空出来的低序位均设置为零。
·    右移位：
int operator &gt;&gt;(int x, int count);uint operator &gt;&gt;(uint x, int count);long operator &gt;&gt;(long x, int count);ulong operator &gt;&gt;(ulong x, int count);
&gt;&gt; 运算符将 x 向右位移若干个位，具体计算方法如下所述。
当 x 为 int 或 long 类型时，放弃 x 的低序位，将剩余的位向右位移，如果 x 非负，则将高序空位位置设置为零，如果 x 为负，则将其设置为 1。
当 x 为 uint 或 ulong 类型时，放弃 x 的低序位，将剩余的位向右位移，并将高序空位位置设置为零。
对于预定义运算符，位移的位数按下面这样计算：
·    当 x 的类型为 int 或 uint 时，位移计数由 count 的低序的 5 位给出。换言之，位移计数由 count &amp; 0x1F 计算出。
·    当 x 的类型为 long 或 ulong 时，位移计数由 count 的低序的 6 位给出。换言之，位移计数由 count &amp; 0x3F 计算出。
如果计算位移计数的结果为零，则移位运算符只返回 x 的值。
移位运算从不会导致溢出，并且在 checked 和 unchecked 上下文中产生的结果相同。
当 &gt;&gt; 运算符的左操作数为有符号的整型时，该运算符执行算术右移位，在此过程中，操作数的最有效位（符号位）的值扩展到高序空位位置。当 &gt;&gt; 运算符的左操作数为无符号的整型时，该运算符执行逻辑右移位，在此过程中，高序空位位置总是设置为零。若要执行与由操作数类型确定的不同的移位运算，可以使用显式强制转换。例如，如果 x 是 int 类型的变量，则 unchecked((int)((uint)x &gt;&gt; y)) 运算执行 x 的逻辑右移位。

赋值运算符下表列出了 C# 支持的赋值运算符：



运算符
描述
实例



&#x3D;
简单的赋值运算符，把右边操作数的值赋给左边操作数
C &#x3D; A + B 将把 A + B 的值赋给 C


+&#x3D;
加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数
C +&#x3D; A 相当于 C &#x3D; C + A


-&#x3D;
减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数
C -&#x3D; A 相当于 C &#x3D; C - A


*&#x3D;
乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数
C *&#x3D; A 相当于 C &#x3D; C * A


&#x2F;&#x3D;
除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数
C &#x2F;&#x3D; A 相当于 C &#x3D; C &#x2F; A


%&#x3D;
求模且赋值运算符，求两个操作数的模赋值给左边操作数
C %&#x3D; A 相当于 C &#x3D; C % A


&lt;&lt;&#x3D;
左移且赋值运算符
C &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2


&gt;&gt;&#x3D;
右移且赋值运算符
C &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2


&amp;&#x3D;
按位与且赋值运算符
C &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2


^&#x3D;
按位异或且赋值运算符
C ^&#x3D; 2 等同于 C &#x3D; C ^ 2


|&#x3D;
按位或且赋值运算符
C |&#x3D; 2 等同于 C &#x3D; C | 2



1.1 赋值运算符赋值运算符为变量、属性、事件或索引器元素赋新值。
assignment:unary-expression  assignment-operator  expression
assignment-operator:+&#x3D;-&#x3D;
*&#x3D;&#x2F;&#x3D;%&#x3D;&amp;&#x3D;|&#x3D;^&#x3D;&lt;&lt;&#x3D;right-shift-assignment
赋值的左操作数必须是属于变量、属性访问、索引器访问或事件访问类别的表达式。
&#x3D; 运算符称为简单赋值运算符。它将右操作数的值赋予左操作数给定的变量、属性或索引器元素。简单赋值运算符的左操作数一般不可以是一个事件访问（第 ‎10.8.1 节中描述的例外）。简单赋值运算符的介绍详见第 ‎7.17.1 节。
除 &#x3D; 运算符以外的赋值运算符称为复合赋值运算符 (compound assignment operator)。这些运算符对两个操作数执行指示的运算，然后将结果值赋予左操作数指定的变量、属性或索引器元素。复合赋值运算符的介绍详见第 ‎7.17.2 节。
以事件访问表达式作为左操作数的 +&#x3D; 和 -&#x3D; 运算符称为事件赋值运算符。当左操作数是事件访问时，其他赋值运算符都是无效的。事件赋值运算符的介绍详见第 ‎7.17.3 节。
赋值运算符为向右关联，即此类运算从右到左分组。例如，a &#x3D; b &#x3D; c 形式的表达式可以按 a &#x3D; (b &#x3D; c) 进行计算。
1.1.1 简单赋值&#x3D; 运算符称为简单赋值运算符。
如果简单赋值的左操作数为 E.P 或 E[Ei] 形式，其中 E 具有编译时类型 dynamic，则赋值是动态绑定的（第 ‎7.2.2 节）。在此情况下，赋值表达式的编译时类型为 dynamic，并且会在运行时基于 E 的运行时类型进行下面所述的决策。
在简单赋值中，右操作数必须为可以隐式转换为左操作数所属类型的表达式。运算将右操作数的值赋予左操作数指定的变量、属性或索引器元素。
简单赋值表达式的结果是赋予左操作数的值。结果的类型与左操作数相同，且始终为值类别。
如果左操作数为属性或索引器访问，则该属性或索引器必须具有 set 访问器。如果不是这样，则发生绑定时错误。
x &#x3D; y 形式的简单赋值的运行时处理包括以下步骤：

如果 x 属于变量：
计算 x 以产生变量。
计算 y，必要时还需通过隐式转换（第 ‎6.1 节）将其转换为 x 的类型。
如果 x给定的变量是 reference-type 的数组元素，则执行运行时检查以确保为 y 计算的值与以 x 为其元素的那个数组实例兼容。如果 y 为 null，或存在从 y 引用的实例的实际类型到包含 x 的数组实例的实际元素类型的隐式引用转换（第 ‎6.1.6 节），则检查成功。否则，将引发 System.ArrayTypeMismatchException。
y 的计算和转换后所产生的值存储在 x 的计算所确定的位置中。


如果 x 属于属性或索引器访问：
计算与 x 关联的实例表达式（如果 x 不是 static）和参数列表（如果 x 是索引器访问），结果用于后面的对和 set 访问器调用。
计算 y，必要时还需通过隐式转换（第 ‎6.1 节）将其转换为 x 的类型。
使用针对 y 计算的值作为 value 参数调用 x 的 set 访问器。



如果存在从 B 到 A 的隐式引用转换，则数组协变规则（第 ‎12.5 节）允许数组类型 A[] 的值是对数组类型 B[] 的实例的引用。由于这些规则，对 reference-type 的数组元素的赋值需要运行时检查以确保所赋的值与数组实例兼容。在下面的示例中
using System.Collections;string[] sa = new string[10];object[] oa = sa;oa[0] = null;        // Okoa[1] = &quot;Hello&quot;;       // Okoa[2] = new ArrayList(); // ArrayTypeMismatchException

最后的赋值将导致引发 System.ArrayTypeMismatchException，这是因为 ArrayList 的实例不能存储在 string[] 的元素中。
当 struct-type 中声明的属性或索引器是赋值的目标时，与属性或索引器访问关联的实例表达式必须为变量类别。如果该实例表达式归类为值类别，则发生绑定时错误。由于第 ‎7.6.4 节中所说明的原因，同样的规则也适用于字段。
给定下列声明：
struct Point&#123;    int x, y;    public Point(int x, int y)    &#123;        this.x = x;        this.y = y;    &#125;    public int X    &#123;        get &#123; return x; &#125;        set &#123; x = value; &#125;    &#125;    public int Y    &#123;        get &#123; return y; &#125;        set &#123; y = value; &#125;    &#125;&#125;struct Rectangle&#123;    Point a, b;    public Rectangle(Point a, Point b)    &#123;        this.a = a;        this.b = b;    &#125;    public Point A    &#123;        get &#123; return a; &#125;        set &#123; a = value; &#125;    &#125;    public Point B    &#123;        get &#123; return b; &#125;        set &#123; b = value; &#125;    &#125;&#125;

在下面的示例中
using System.Windows.Shapes;Point p = new Point();p.X = 100;p.Y = 100;Rectangle r = new Rectangle();r.A = new Point(10, 10);r.B = p;

由于 p 和 r 为变量，因此允许对 p.X、p.Y、r.A 和 r.B 进行赋值。但是，在以下示例中
Rectangle r = new Rectangle(); r.A.X = 10; r.A.Y = 10; r.B.X = 100; r.B.Y = 100;

由于 r.A 和 r.B 不是变量，因此赋值全部无效。
1.1.2 复合赋值如果复合赋值的左操作数为 E.P 或 E[Ei] 形式，其中 E 具有编译时类型 dynamic，则赋值为动态绑定的（第 ‎7.2.2 节）。在此情况下，赋值表达式的编译时类型为 dynamic，并且会在运行时基于 E 的运行时类型进行下面所述的决策。
x op&#x3D; y 形式的运算是这样来处理的：应用重载决策（第 ‎7.3.4 节），就好比运算的书写形式为 x op y。然后，
·    如果选定的运算符的返回类型可“隐式”转换为 xx 的类型，则运算按 x &#x3D; x op y 计算，但 x 只计算一次。
·    否则，如果选定运算符是预定义的运算符，选定运算符的返回类型可“显式”转换为 x 的类型，并且 y 可“隐式”转换为 x 的类型或者该运算符是移位运算符，则运算按 x &#x3D; (T)(x op y) 计算（其中 T 是 x 的类型），但 x 只计算一次。
·    否则，复合赋值无效，且发生绑定时错误。
术语“只计算一次”表示：在 x op y 的计算中，x 的任何要素表达式的计算结果都临时保存起来，然后在执行对 x 的赋值时重用这些结果。例如，在计算赋值 A()[B()] +&#x3D; C() 时（其中 A 为返回 int[] 的方法，B 和 C 为返回 int 的方法），按 A、B、C 的顺序只调用这些方法一次。
当复合赋值的左操作数为属性访问或索引器访问时，属性或索引器必须同时具有 get 访问器和 set 访问器。如果不是这样，则发生绑定时错误。
上面的第二条规则允许在某些上下文中将 x op&#x3D; y 按 x &#x3D; (T)(x op y) 计算。按此规则，当左操作数为 sbyte、byte、short、ushort 或 char 类型时，预定义的运算符可用作复合运算符。甚至当两个参数都为这些类型之一时，预定义的运算符也产生 intint类型的结果，详见第 ‎7.3.6.2 节中的介绍。因此，不进行强制转换，就不可能把结果赋值给左操作数。
此规则对预定义运算符的直观效果只是：如果同时允许 x op y 和 x &#x3D; y，则允许 x op&#x3D; y。在下面的示例中
byte b = 0;char ch = &#x27;\0&#x27;;int i = 0;b += 1;      // Okb += 1000;    // Error, b = 1000 not permittedb += i;      // Error, b = i not permittedb += (byte)i;   // Okch += 1;       // Error, ch = 1 not permittedch += (char)1;  // Ok

每个错误的直观理由是对应的简单赋值也发生错误。
这还意味着复合赋值运算支持提升运算。在下面的示例中
int? i = 0; i += 1;      // Ok

使用了提升运算符 +(int?,int?)。
1.1.3 事件赋值如果 +&#x3D; 或 -&#x3D; 运算符的左操作数属于事件访问类别，则表达式按下面这样计算：
·    计算事件访问的实例表达式（如果有）。
·    计算 +&#x3D; 或 -&#x3D; 运算符的右操作数，如果需要，通过隐式转换（第 ‎6.1 节）转换为左操作数的类型。
·    调用该事件的事件访问器，所需的参数列表由右操作数（经过计算和必要的转换后）组成。如果运算符为 +&#x3D;，则调用 add 访问器；如果运算符为 -&#x3D;，则调用 remove 访问器。
事件赋值表达式不产生值。因此，事件赋值表达式只在 statement-expression（第 ‎8.6 节）的上下文中是有效的。

其他运算符下表列出了 C# 支持的其他一些重要的运算符，包括 sizeof、typeof 和 ? :。



运算符
描述
实例



sizeof()
返回数据类型的大小。默认情况下只能获取基本数据类型在内存中占据的字节数（除了string object）。如果需要获取自定义结构体实例的大小，需要放在不安全的上下文中。
sizeof(int)，将返回 4.


typeof()
返回 class 的类型。
typeof(StreamReader);


&amp;
返回变量的地址。
&a; 将得到变量的实际地址。


*
变量的指针。
*a; 将指向一个变量。


? :
条件表达式
如果条件为真 ? 则为 X : 否则为 Y


new
在内存中创建指定类型的实例，并调用实例构造器。在类中要慎用new，一旦在某个类中调用的new，当前编写的类型就和创建实例的这个类型构成了紧密的耦合。一旦创建实例的类有问题，那么当前类也会出问题。
new Form();


checked
检查指定的运算是否产生溢出。如果产生抛出异常(OverflowException )
uint i &#x3D; unit.MaxValue; uint j &#x3D; checked(i + 1); 或者checked{}(检查语句块)


delegate
声明匿名方法。一般并不作为操作符，而是声明委托数据类型。



~
求反操作符。对一个数在二进制层面按位取反



空合并运算符​	?? 运算符称为空合并运算符。
​	a ?? b 形式的空合并表达式要求 a 为可以为 null 的类型或引用类型。
​	如果 a 为非 null，则 a ?? b 的结果为 a；否则，结果为 b。仅当 a 为 null 时，该操作才计算 b。
​	空合并运算符为右结合运算符，表示操作从右向左进行组合。例如，a ?? b ?? c 形式的表达式可以按 a ?? (b ?? c) 进行计算。概括地说，E1 ?? E2 ?? … ?? EN 形式的表达式返回第一个非 null 的操作数，如果所有操作数都为 null，则返回 null。
表达式 a ?? b 的类型取决于对操作数可用的隐式转换。按照优先顺序，a ?? b 的类型为 A0、A 或 B，其中 A 是 a 的类型（如果 a 有类型），B 是 b 的类型（如果 b 有类型），A0 是 A 的基础类型（如果 A 是可以为 null 的类型）或 A（如果该项不是可以为 null 的类型）。具体而言，a ?? b 的处理过程如下：
·    如果 A 存在并且不是可以为 null 的类型或引用类型，将发生编译时错误。
·    如果 b 是动态表达式，则结果类型为 dynamic。在运行时，首先计算 a。如果 a 不为 null，则 aa 转换为动态类型，这成为结果。否则，计算 b，这成为结果。
·    否则，如果 A 存在并且是可以为 null 的类型，并且存在从 b 到 A0 的隐式转换，则结果类型为 A0。在运行时，首先计算 a。如果 a 不为 null，则 a 解包为类型 A0，这即是结果。否则，计算 b 并转换为类型 A0，这即是结果。
·    否则，如果 A 存在并且存在从 b 到 A 的隐式转换，则结果类型为 A。在运行时，首先计算 a。如果 a 不为 null，则 a 即是结果。否则，计算 b 并转换为类型 A，这即是结果。
·    否则，如果 b 的类型为 B，并且存在从 a 到 B 的隐式转换，则结果类型为 B。在运行时，首先计算 a。如果 a 不为 null，则 a 解包为类型 A0（如果 A 存在并且可以为 null）并转换为类型 B，并且这成为结果。否则，计算 b 并且 b 作为结果。
·    否则，a 和 b 不兼容，并发生编译时错误。
可以使用以下代码来检查一个可空类型变量是否为null，并在它为null时返回一个默认值：
int? x = null;int y = x ?? -1;



?. 空条件运算符在C#中，?.运算符被称为空条件运算符。它用于执行成员或元素访问操作，仅当操作数不为null时才执行。如果操作数为null，则表达式的结果为null。
例如，您可以使用以下代码来检查一个对象是否为null，并在它不为null时访问其成员：
string s = null;int? length = s?.Length;

在上面的示例中，由于s的值为null，因此length的值将被设置为null。
下面是一个使用?.运算符的示例：
public class Person&#123;    public string Name &#123; get; set; &#125;&#125;Person person = null;string name = person?.Name;

在上面的示例中，我们定义了一个名为Person的类，它具有一个名为Name的属性。然后，我们创建了一个名为person的变量，它的值为null。接下来，我们使用?.运算符来访问person对象的Name属性。由于person的值为null，因此name变量的值将被设置为null。
如果我们将person变量的值更改为非null值，则可以正常访问其成员：
Person person = new Person &#123; Name = &quot;John&quot; &#125;;string name = person?.Name; // name will be &quot;John&quot;

在上面的示例中，由于person的值不为null，因此我们可以正常访问其成员，并且name变量的值将被设置为”John”。
用途有助于避免繁杂的空值检查带来的代码歧义。如果想得到给定客户的订单数，就需要在设置计数值之前检查空值:
int count = 0;if (customer.orders != null)&#123;	count = customer. orders.Count() ;&#125;

如果只编写了这段代码，但客户没有订单(即为null),就会抛出System.ArgumentNullException:
int count = customer .orders. Count() ;

使用?.运算符，会把int? count设置为null，而不会抛出一一个异常。
int? count = customer . orders? .Count() ;

结合上一节讨论的空合并操作符??与空条件运算符?.可以在结果是null时设置一个默认值。
int? count = customer.orders?.Count() ?? 0;

触发事件空条件运算符的另一个用途是触发事件。触发事件的最常见方法是使用如下代码模式:
var onChanged = OnChanged;if (onChanged != null)&#123;	onChanged(this, args) ;&#125;

这种模式不是线程安全的，因为有人会在null检查已经完成后，退订最后一个事件处理程序。此时会抛出异常，程序崩溃。使用空条件运算符可以避免这种情形:
OnChanged?.Invoke(this, args) ;

注意如果使用运算符重载方法(例如&#x3D;&#x3D;)，但没有检查null, 就会抛出System.NullReferenceException.
C# 中的运算符优先级运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。
例如 x &#x3D; 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。
下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。



类别
运算符
结合性



后缀
() [] -&gt; . ++ - -
从左到右


一元
+ - ! ~ ++ - - (type)* &amp; sizeof
从右到左


乘除
* &#x2F; %
从左到右


加减
+ -
从左到右


移位
&lt;&lt; &gt;&gt;
从左到右


关系
&lt; &lt;&#x3D; &gt; &gt;&#x3D;
从左到右


相等
&#x3D;&#x3D; !&#x3D;
从左到右


位与 AND
&amp;
从左到右


位异或 XOR
^
从左到右


位或 OR
|
从左到右


逻辑与 AND
&amp;&amp;
从左到右


逻辑或 OR
||
从左到右


条件
?:
从右到左


赋值
&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;&gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;
从右到左


逗号
,
从左到右


c#表达式
表达式（Expressions）是任何语言的基础组件之一（其二分别是命令和声明），而且是最重要的。
表达式是一种语法实体，用于表达一定的算法意图。
在C#中，表达式是由一个或多个操作数和零个或多个操作符组成的序列。表达式求值后，得到的结果为single value, object, method, or namespace.


expression 为 non-assignment-expression 或 assignment。
expression:non-assignment-expressionassignment
non-assignment-expression:conditional-expressionlambda-expressionquery-expression
表示为 非赋值表达式或 分配表达式：非赋值表达式分配非赋值表达式：条件表达式lambda表达式查询表达式

c#元组（Tuple）​	元组功能在 C# 7.0 及更高版本中可用，它提供了简洁的语法，用于将多个数据元素分组成一个轻型数据结构。 
​	元组是一种 有序的，有限不可变的，支持混杂类型的固定个数的 一种数据结构。混杂指的是 Tuple 中的若干元素类型，即可以是同类型，也可以是不同类型。如一个元组中可以有int、string等不同类型的数据
​	常用于方法数据的传入和传出
使用元组的场景
如果你的方法需要返回多个值 或者 方法需要传递多个值。

如果你不想为某些功能专门去定义一个类。

如果你有若干个混杂元素，并且想提供对其简单的访问方式。


用法和匿名类类似，但是，方法的返回值不能指定为匿名类型。
元组的缺陷
Tuple 是引用类型不是值类型，意味着它会在 托管堆 上进行内存分配，如果 Tuple 过大并且没有很好的释放，对程序也是一个不小的性能挑战。

声明和使用样例using System;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            //如果定义的时候不声明字段名，则使用的时候只能使用默认的 Item + 数字编号（从1起）            (double , int)numbers1 = (0.98, 2);            Console.WriteLine($&quot;numbers1元组中第一个值为：&#123;numbers1.Item1&#125;\t第二个值为：&#123;numbers1.Item2&#125;\t\t元组的类型为：&#123;numbers1.GetType()&#125;&quot;);            //如果在定义的时候声明了字段名，则使用的时候可以用字段名进行访问。此时，默认的Item名无法使用。            (int num1, double num2) numbers2 = (0, 0.02);            Console.WriteLine($&quot;numbers2元组中第一个值为：&#123;numbers2.num1&#125;\t第二个值为：&#123;numbers2.num2&#125;\t元组的类型为：&#123;numbers2.GetType()&#125;&quot;);            numbers2 = MySwap(numbers1);//将number1的元组转换成num2的元组的形式            Console.WriteLine($&quot;numbers2元组中第一个值为：&#123;numbers2.num1&#125;\t第二个值为：&#123;numbers2.num2&#125;\t元组的类型为：&#123;numbers2.GetType()&#125;&quot;);            //并不可以使用foreach遍历。            //foreach(var x in numbers2)            //&#123;            //    Console.WriteLine(x);            //&#125;            Console.ReadKey();        &#125;        //一个样例方法，演示使用元组进行数据的传入和传出。        static (int, double)MySwap((double, int) x)        &#123;            (int, double) t;            t.Item1 = x.Item2;            t.Item2 = x.Item1;            return t;        &#125;    &#125;&#125;



使用元组时的注意事项​	元组功能需要 System.ValueTuple 类型和相关的泛型类型（例如 System.ValueTuple&lt;T1,T2&gt;），这些类型在 .NET Core 和 .NET Framework 4.7 及更高版本中可用。 若要在面向 .NET Framework 4.6.2 或更早版本的项目中使用元组，请将 NuGet 包 System.ValueTuple 添加到项目。
C#的基本语句
语句是命令式编程语言（高级语言）中最小的独立元素。用于表达将要执行的动作。
语句对应着一组指令。
简单地说就是，陈述算法思想，控制逻辑走向，完成有意义的动作。
在c#中，语句一定是出现在方法体内。

c#的语句种类
声明语句
用于声明变量、常量等


表达式语句
嵌入式语句
块语句（简称“块”）
选择语句（判断、分支）
迭代语句（循环）
跳转语句
try…catch…finally语句
using语句
yield语句
checked&#x2F;unchecked语句
lock语句（用于多线程）
标签语句 labeled-statement（比较少见）
空语句

声明语句声明一个或多个局部变量。
局部变量声明：

局部变量类型 局部变量声明器


局部变量类型：

具体类型

var类型



局部变量声明器：

一个局部变量声明器

一组局部变量声明器 , 一个局部变量声明器



一个局部变量声明符：

标识符

标识符 &#x3D; 局部变量初始化器



局部变量初始化器：

表达式（值）

数组初始化器





local-variable-declaration 声明一个或多个局部变量。
local-variable-declaration:local-variable-type  local-variable-declarators
local-variable-type:typevar
local-variable-declarators:local-variable-declaratorlocal-variable-declarators  ,  local-variable-declarator
local-variable-declarator:identifieridentifier  &#x3D;  local-variable-initializer
local-variable-initializer:expressionarray-initializer

样例int x;//指定类型声明，但没有初始化x = 0;//赋值var y = 100;//未指定类型的声明，靠编译器自动推断。一旦推断完成，就不可更改int z = 200;//与第一个样例不相等。这种是声明变量的时候追加了初始化器int[] arr = &#123;x, y, z&#125;;//数组初始化器初始化数组









声明局部常量
声明局部变量的前面加上const关键字。
常量在声明的时候必须跟上初始化器，设定初始值。
常量一旦定义不可修改。


local-constant-declaration 用于声明一个或多个局部常量。
local-constant-declaration:const  type  constant-declarators
constant-declarators:constant-declaratorconstant-declarators  ,  constant-declarator
constant-declarator:identifier  &#x3D;  constant-expression
local-constant-declaration 的 type 指定由该声明引入的常量的类型。此类型后接一个 constant-declarator 列表，其中每一项都引入一个新常量。cconstant-declarator 包含一个命名常量的 identifier，后接一个“&#x3D;”标记，然后是一个对该常量赋值的 constant-expression（第 ‎7.19 节）。
局部常量声明的 type 和 constant-expression 必须遵循与常量成员声明（第 ‎10.4 节）一样的规则。
可以在表达式中通过 simple-name（第 ‎7.6.2 节）来获取局部常量的值。
局部常量的范围是在其中声明了该常量的块。在局部常量的 constant-declarator 之前的文本位置中引用该局部常量是错误的。在局部常量的范围内声明其他具有相同名称的局部变量或常量是编译时错误。
声明多个常量的局部常量声明等效于多个同一类型的单个常量的声明。

样例const double PI = 3.1415926;







表达式语句
简单的说就是可以形成表达式的语句。用于计算所给定的表达式。由此表达式计算出来的是（如果有）将被丢弃。
不是所有的表达式都允许被作为语句。


expression-statement:statement-expression  ;
statement-expression:invocation-expressionobject-creation-expressionassignmentpost-increment-expressionpost-decrement-expressionpre-increment-expressionpre-decrement-expressionawait-expression

表达式语句：
语句表达式；


语句表达式：
调用表达式
对象创建表达式
赋值
后增量表达式
减量后表达式
前增量表达式
减量前表达式
等待表达式




样例//Console.WriteLine //成员访问，一旦添加括号即表示调用Console.WriteLine(&quot;hello world&quot;);//方法调用表达式Form form= new Form();//对象创建表达式x = 100;//赋值x++;//自增，只关心结果，不关心返回值（返回值为自增前的x）x--;++x;--x;//x + y;//不允许，因为无意义



块
用于在只允许使用单个语句的上下文中编写多条语句。
块 由一个扩在大括号内的可选的语句序列组成。如果没有语句序列，则称块是空的。
所有语句都可以写在块内。
块语句一定被大括号包裹，但被大括号包裹的语句不一定是块语句。（块语句是语句，因此一定出现在方法体内。）
编译器将整个块视为一个完整的语句，不需要额外的分号。
一般与判断、循环连用。
块语句外声明的变量在块内也可以用，但在块内声明的在块外就无法使用。详见变量的生存期和作用域。

选择语句​	判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。
​	基本语法与c相同



语句
描述



if 语句
一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。


if…else
一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。


嵌套 if 语句
您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。


switch 语句
一个 switch 语句允许测试一个变量等于多个值时的情况。需要注意switch的表达式类型必须是整形数、布尔类型、char、string或枚举类型。不允许是浮点类型，因为浮点不精确不可比较。


嵌套 switch 语句
您可以在一个 switch 语句内使用另一个 switch 语句。


Switch语句C#与C++是有区别的。在C++中，可以在运行完一个case语句后，运行另一个case语句。即case后面的语句块中缺省break语句，一个case语句执行了两个以上的语句块。
在C#中，执行完每个部分的代码后，还需要有另一个语句break。在执行完一个case块后，再执行第二个case语句是非法的。
在C#代码中,还有其他方法可以防止程序流程从一个case语句转到下一个case语句。可以使用returm语句，中断当前函数的运行，而不是仅中断switch结构的执行(详见第6章)。也可以使用goto语句(如前所述)，
case语句实际上是在C#代码中定义的标签。
一个case语句处理完毕后，不能自由进入下一个case 语句，但这条规则有一个例外。如果把多个case语句放在一起(堆叠它们)， 其后加一个代码块，实际上是一次检查多个条件。如果满足这些条件中的任何一个，就会执行代码，例如:
switch (&lt;testVar&gt;) &#123;    case &lt;compari sonVa11&gt;:	case &lt;comparisonva12&gt; :		&lt;当&lt;testVar&gt;=&lt;comparisonva11&gt;或&lt;testVar&gt;=&lt;comparisonva12&gt;时要执行的代码 &gt;	break;&#125;

注意，这些条件也适用于default语句。default 语句不一定要放在比较操作列表的最后，还可以把它和case语句放在一起。用break或returm添加一个断点， 可确保在任何情况下，该结构都有一条有效的执行路径。
? : 运算符 **条件运算符 ? :**可以用来替代 if…else 语句。它的一般形式如下：
Exp1 ? Exp2 : Exp3;

其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。
? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。
循环循环语句允许我们多次执行一个语句或语句组。
基础循环C# 提供了以下几种循环类型。
基本语法与c++相同。此处不再赘述。



循环类型
描述



while 循环
当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。


for&#x2F;foreach 循环
多次执行一个语句序列，简化管理循环变量的代码。


do…while 循环
除了它是在循环主体结尾测试条件外，其他与 while 语句类似。


嵌套循环
您可以在 while、for 或 do..while 循环内使用一个或多个循环。


foreach循环使用foreach可以迭代数组或者一个集合对象。
foreach循环用于列举出集合中所有的元素，foreach语句中的表达式由关键字in隔开的两个项组成。in右边的项是集合名，in左边的项是变量名，用来存放该集合中的每个元素。
该循环的运行过程如下：每一次循环时，从集合中取出一个新的元素值。放到只读变量中去，如果括号中的整个表达式返回值为true，foreach块中的语句就能够执行。一旦集合中的元素都已经被访问到，整个表达式的值为false，控制流程就转入到foreach块后面 的执行语句。
foreach语句经常与数组一起使用，下面实例将通过foreach语句读取数组的值并进行显示。
只要这个类实现了IEnumerable这个接口的类，就可以被foreach遍历。比如数组、泛型list
循环的本意是调用类的迭代器。如：
int[] arr = new int[] &#123; 1, 2, 3,4 &#125;;System.Collections.IEnumerator enumerator = arr.GetEnumerator();//获取arr的迭代器while(enumerator.MoveNext())&#123;	Console.WriteLine(enumerator.Current); //输出&#125;





基本语法foreach（type objName in collection/Array）

注： objName的数据类型type必须与collection&#x2F;Array对象的类型相同或比它大。

type
迭代变量的数据类型


objName
迭代变量


collection&#x2F;Array
需要循环的集合



如：
int[,,] a = new int[2, 2, 2] &#123; &#123;&#123; 1, 2 &#125;, &#123; 3,4&#125;&#125;,&#123;&#123; 5, 6 &#125;, &#123; 7,8&#125;&#125; &#125;;//定义一个2行2列2纵深的3维数组aforeach(int i in a)&#123;    Console .WriteLine (i);&#125;



以下实例有三个部分：

通过 foreach 循环输出整型数组中的元素。
通过 for 循环输出整型数组中的元素。
foreach 循环设置数组元素的计算器。

实例class ForEachTest&#123;  static void Main(string[] args)  &#123;    int[] fibarray = new int[] &#123; 0, 1, 1, 2, 3, 5, 8, 13 &#125;;    foreach (int element in fibarray)    &#123;      System.Console.WriteLine(element);    &#125;    System.Console.WriteLine();    // 类似 foreach 循环    for (int i = 0; i &lt; fibarray.Length; i++)    &#123;      System.Console.WriteLine(fibarray[i]);    &#125;    System.Console.WriteLine();    // 设置集合中元素的计算器*    int count = 0;    foreach (int element in fibarray)    &#123;      count += 1;      System.Console.WriteLine(&quot;Element #&#123;0&#125;: &#123;1&#125;&quot;, count, element);    &#125;    System.Console.WriteLine(&quot;Number of elements in the array: &#123;0&#125;&quot;, count);  &#125;&#125;

输出结果为：
011235813011235813Element #1: 0Element #2: 1Element #3: 1Element #4: 2Element #5: 3Element #6: 5Element #7: 8Element #8: 13Number of elements in the array: 8



实例2通过遍历多维数组来比较for和foreach
int[,,] a = new int[2, 2, 2] &#123; &#123;&#123; 1, 2 &#125;, &#123; 3,4&#125;&#125;,&#123;&#123; 5, 6 &#125;, &#123; 7,8&#125;&#125; &#125;;// 定义一个2行2列2纵深的3维数组afor (int i = 0; i &lt; a.GetLength (0) ;i++ )  //用Array.GetLength(n)得到数组[0,1,,,n]上的维数的元素数，0代表行，1列，n代表此数组是n+1维&#123;  for (int j = 0; j &lt; a.GetLength(1); j++)  &#123;    for (int z = 0; z &lt; a.GetLength(2);z++ )//2代表得到纵深上的元素数，如果数组有n维就得写n个for循环    &#123;      Console.WriteLine(a[i,j,z]);    &#125;  &#125;&#125;



int[,,] a = new int[2, 2, 2] &#123; &#123;&#123; 1, 2 &#125;, &#123; 3,4&#125;&#125;,&#123;&#123; 5, 6 &#125;, &#123; 7,8&#125;&#125; &#125;;//定义一个2行2列2纵深的3维数组aforeach(int i in a)&#123;  Console .WriteLine (i);&#125;

两段程序的功能一样。
注意事项
foreach是只读的
foreach会迭代每个元素，依次把每个元素放在声明的变量中。如果在循环中试图给声明的变量赋一个值，编译器会报错。


foreach是相对安全的，不存在访问非法元素的危险。
当循环次数特别大的时候，foreach的效率是远高于for的。（至少一个数量级）

循环控制语句循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。
C# 提供了下列的控制语句。点击链接查看每个语句的细节。



控制语句
描述



break 语句
终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。


continue 语句
引起循环跳过主体的剩余部分，立即重新开始测试条件。


try语句(异常处理)
​	try 语句提供一种机制，用于捕捉在块的执行期间发生的各种异常。此外，try 语句还能让您指定一个代码块，并保证当控制离开 try 语句时，总是先执行该代码。
不管是否发生异常，finally子句都会执行。
可以有多个catch子句，但只能执行其中的一个。
有三种可能的 try 语句形式：
一个 try 块后接一个或多个 catch 块。
一个 try 块后接一个 finally 块。
一个 try 块后接一个或多个 catch 块，后面再跟一个 finally 块。


C# 异常处理时建立在四个关键词之上的：try、catch、finally 和 throw。
try：一个 try 块标识了一个将被激活的特定的异常的代码块。后跟一个或多个 catch 块。
catch：程序通过异常处理程序捕获异常。catch 关键字表示异常的捕获。可以不写异常类型，表示捕捉所有异常。
finally：finally 块用于执行给定的语句，不管异常是否被抛出都会执行。例如，如果您打开一个文件，不管是否出现异常文件都要被关闭。
throw：当问题出现时，程序抛出一个异常。使用 throw 关键字来完成。



基本语法try&#123;   // 可能引起异常的语句&#125;catch( ExceptionName e1 )&#123;   // 错误处理代码&#125;catch( ExceptionName e2 )&#123;   // 错误处理代码&#125;catch( ExceptionName eN )&#123;    throw eN;//不处理，直接再次抛出&#125;finally&#123;   // 要执行的语句&#125;



样例C# 以 try 和 catch 块的形式提供了一种结构化的异常处理方案。使用这些块，把核心程序语句与错误处理语句分离开。
这些错误处理块是使用 try、catch 和 finally 关键字实现的。下面是一个当除以零时抛出异常的实例：
using System;namespace ErrorHandlingApplication&#123;    class DivNumbers    &#123;        int result;        DivNumbers()        &#123;            result = 0;        &#125;        public void division(int num1, int num2)        &#123;            try            &#123;                result = num1 / num2;            &#125;            catch (DivideByZeroException e)            &#123;                Console.WriteLine(&quot;Exception caught: &#123;0&#125;&quot;, e);            &#125;            finally            &#123;                Console.WriteLine(&quot;Result: &#123;0&#125;&quot;, result);            &#125;        &#125;        static void Main(string[] args)        &#123;            DivNumbers d = new DivNumbers();            d.division(25, 0);            Console.ReadKey();        &#125;    &#125;&#125;

当上面的代码被编译和执行时，它会产生下列结果：
Exception caught: System.DivideByZeroException: Attempted to divide by zero. at ...Result: 0

样例2捕捉全部异常
int a = 0;int b = 10;int c;try&#123;	c = b / a;&#125;catch &#123;	Console.WriteLine(&quot;发生错误&quot;);&#125;



异常处理的详细说明详见c#异常处理部分

try-statement:try  block  catch-clausestry  block  finally-clausetry  block  catch-clauses  finally-clause
catch-clauses:specific-catch-clauses  general-catch-clauseoptspecific-catch-clausesopt  general-catch-clause
specific-catch-clauses:specific-catch-clausespecific-catch-clauses  specific-catch-clause
specific-catch-clause:catch  (  class-type  identifieropt  )  block
general-catch-clause:catch  block
finally-clause:finally  block

try语句：
try-block catch子句
try-block finally子句
try-block catch子句 finally子句


catch子句：
通用捕获异常
特定捕获异常


特定捕获异常：
特定捕获异常
特定捕获条款
特定捕获条款：
catch（类类型 标识符opt）块


一般捕获子句：
catch子句


finally-clause:
finally子句




标签语句简单的说就是，在一个语句前面加上标签。
标签遵循标识符的规范。
类似于声明变量，只是不用加数据类型。
hurr://标签    &#123;   	 	Console.WriteLine(&quot;hurriedlu&quot;);    &#125;goto hurr;//跳转到指定的标签处







checked&#x2F;unchecked语句checked 和 unchecked 语句指定整型类型算术运算和转换的溢出检查上下文。 当发生整数算术溢出时，溢出检查上下文将定义发生的情况。 在已检查的上下文中，引发 System.OverflowException；如果在常数表达式中发生溢出，则会发生编译时错误。 在未检查的上下文中，会通过丢弃任何不适应目标类型的高序位来将操作结果截断。 例如，在加法示例中，它将从最大值包装到最小值。 以下示例显示了 checked 和 unchecked 上下文中的相同操作：
try&#123;    checked    &#123;        int x = Int32.MaxValue;        int y = x + 1;//发生溢出    &#125;&#125;catch(OverflowException e)&#123;    Console.WriteLine(&quot;捕获到溢出异常&quot;);&#125;













C#的类和成员更深入的了解一些细节。’

类是一种数据结构，它可以包含数据成员（常量和字段）、函数成员（方法、属性、事件、索引器、运算符、实例构造函数、静态构造函数和析构函数）以及嵌套类型。类类型支持继承，继承是一种机制，它使派生类可以对基类进行扩展和专用化。 —— 《C# 语言规范》
当你定义一个类时，你定义了一个数据类型的蓝图。这实际上并没有定义任何的数据，但它定义了类的名称意味着什么，也就是说，类的对象由什么组成及在这个对象上可执行什么操作。对象是类的实例。构成类的方法和变量称为类的成员。

类类的定义类的定义是以关键字 class 开始，后跟类的名称。类的主体，包含在一对花括号内。下面是类定义的一般形式：
&lt;access specifier&gt; class  class_name &#123;    // member variables    &lt;access specifier&gt; &lt;data type&gt; variable1;    &lt;access specifier&gt; &lt;data type&gt; variable2;    ...    &lt;access specifier&gt; &lt;data type&gt; variableN;    // member methods    &lt;access specifier&gt; &lt;return type&gt; method1(parameter_list)    &#123;        // method body    &#125;    &lt;access specifier&gt; &lt;return type&gt; method2(parameter_list)    &#123;        // method body    &#125;    ...    &lt;access specifier&gt; &lt;return type&gt; methodN(parameter_list)    &#123;        // method body    &#125;&#125;


访问标识符 &#x2F;&lt;access specifier&gt; 指定了对类及其成员的访问规则。如果没有指定，则使用默认的访问标识符。类的默认访问标识符是 internal，成员的默认访问标识符是 private。
数据类型  指定了变量的类型，返回类型  指定了返回的方法返回的数据类型。
如果要访问类的成员，你要使用点（.）运算符。
点运算符链接了对象的名称和成员的名称。
如果

注意事项
所有类都直接或间接的继承自object（System.Object）
类只能继承一个父类，但能继承（完成）多个接口.
关于继承的更多事宜，在面向对象编程单元中的继承子目录中有更详细的说明。



System.Object​	所有类都继承于System.Object,所以这些类都可以访问该类中受保护的成员和公共成员。因为所有类都继承于System.Object，所以这些类都可以访问该类中受保护的成员和公共成员.



方法
返回类型
是否是虚拟
是否是静态
说明



Object()
N&#x2F;A
否
否
System.Object类型的构造函数,由派生类型的构造函数自动调用


~Object()
N&#x2F;A
否
否
System.Object类型的析构函数，由派生类型的析构函数自动调用，不能手动调用


Equals(object)
bool
是
否
把调用该方法的对象与另一个对象相比，如果它们相等，就返回true。默认的实现代码会查看其对象参数是否引用了同一个对象(因为对象是引用类型)。如果想以不同方式来比较对象，则可以重写该方法，例如，比较两个对象的状态


Equals(object, object)
bool
否
是
这个方法比较传送给它的两个对象，看看它们是否相等。检查时使用了Equalsl(object)方法。 注意，如果两个对象都是空引用，这个方法就返回true


ReferenceEquals(object,object)
bool
否
是
这个方法比较传送给它的两个对象，看看它们是不是同一个实例的引用


ToString()
string
是
否
返回一个对应于对象实例的字符串。默认情况下，这是一个类类型的限定名称，但可以重写它，给类类型提供合适的实现代码


MemberwiseClone()
object
否
否
通过创建一个新对象实例并复制成员，以复制该对象。成员复制不会得到这些成员的新实例。新对象的任何引用类型成员都将引用与源类相同的对象，这个方法是受保护的，所以只能在类或派生的类中使用


GetType()
System.Type
否
否
以System.Type对象的形式返回对象的类型


GetHashCode()
int
是
否
在需要此参数的地方，用作对象的散列函数，它返回一个以压缩形式标识对象状态的值


成员


成员
说明



常量
与类关联的常量值


字段
类的变量


方法
类可执行的计算和操作


属性
与读写类的命名属性相关联的操作


索引器
与以数组方式索引类的实例相关联的操作


事件
可由类生成的通知


运算符
类所支持的转换和表达式运算符


构造函数
初始化类的实例或类本身所需要的操作


析构函数
在永久丢弃类的实例之前执行的操作


类型
类所声明的嵌套类型


对于一个类或对象来说，最重要的三类成员就是属性（白色小扳手）、事件（黄色小闪电）和方法（紫色小方块）。
属性：这个对象或类当前处于什么状态
方法：当前这个类或方法能做什么
事件：能在什么情况下通知谁
存储数据、做事情、通知别人
静态成员和实例成员​	属性、方法和字段等成员是对象实例所特有的，此外，还有静态成员,例如静态方法、静态属性或静态字段。静态成员可以在类的实例之间共享，所以可将它们看成类的全局对象。静态属性和静态字段可以访问独立于任何对象实例的数据，静态方法可以执行与对象类型相关但与对象实例无关的命令。在使用静态成员时，甚至不需要实例化对象。
​	例如，Console.WriteLine()和Convert.ToString()方法就是静态的，根本不需要实例化Console或Convert类(如果试着进行这样的实例化，操作会失败,因为这些类的构造函数不是可公共可访问的，如前所述)。
​	许多情况下，静态属性和静态方法有很好的效果。例如，可以使用静态属性跟踪给类创建了多少个实例。在UML语法中，类的静态成员带有下画线。
静态类​	如果希望类只包含静态成员，且不能用于实例化对象(如Console)。一种简单的方法是使用静态类，而不是把类的构造函数设置为私有。静态类只能包含静态成员，不能包含实例构造函数，因为按照定义，它根本不能被实例化。但静态类可以有一个静态构造函数，如上一节所述。
对象对象是实例化的类。
对象的生存周期每一个对象都有一个明确的生命周期，除了”正在使用”的正常状态外，还有两个重要的阶段：

构造阶段
第一次实例化一个对象时，需要初始化该对象。这个初始化过程称为构造阶段，由构造函数完成。


析构阶段
在删除一个对象时，常常需要执行一些清理操作，如释放内存，这由析构函数完成。



构造函数对象的初始化过程是自动完成的，所有类定义都最少包含一个构造函数。
在C#中，使用new关键字来调用构造函数。
析构函数​	.NET Framework使用析构函数来清理对象。一般情况下，不需要提供析构函数的代码，而由默认的析构函数自动执行操作。但是，如果在删除对象实例前需要完成一些重要操作，就应提供具体的析构函数。
​	例如，如果变量超出了作用域,代码就不能访问它，但该变量仍存在于计算机内存的某个地方。只有在.NET运行程序执行其垃圾回收，进行清理时，该实例才被彻底删除。
字段什么是字段
字段（field）是一种表示与对象或类型（类与结构体）关联的变量
方法体中的局部变量是在方法运行的时候为方法暂时存储数据的，而字段是为一个对象或类型存储数据


字段是类型的成员，旧称”成员变量”
与对象关联的字段亦称”实例字段“
与类型关联的字段称为“静态字段“，由static修饰。
静态字段为类所有，类不需要实例化即可使用。
需要注意的是，类一旦实例化成对象后便无法调用静态字段


对于实例字段，其初始化的时机是在实例创建的时候。
对于静态字段，是在运行环境加载这个数据类型的时候。

字段的声明
尽管字段声明带有分号,但它不是语句
字段的名字一定是名词
当声明字段的时候，一定要写在类体内，如果写到方法体中，就是局部变量了。
如果不手动指定字段的初始值，编译器会自动指定一个对应类型的默认初始值。
也可以在构造函数中声明初始值



基本语法[特性] [访问修饰符（可多个）] 数据类型 变量声明器;

样例public int Amount = 0;

访问修饰符
new

public

protected

private

static

readonly

修饰的字段将变成只读字段


volatile


只读字段又分为实例只读字段和静态只读字段
修饰符为readonly
对于只读字段，只能在初始化的时候进行赋值（构造器属于初始化），一旦初始化完成不可再修改。类似于常量？
对于实例只读字段，常用于学生的编号等不可修改的场景；
属性什么是属性​	属性（Property） 是类（class）、结构（structure）和接口（interface）的命名（named）成员。类或结构中的成员变量或方法称为 域（Field）。属性（Property）是域（Field）的扩展，且可使用相同的语法来访问。它们使用 访问器（accessors） 让私有域的值可被读写或操作。
​	属性（Property）不会确定存储位置。相反，它们具有可读写或计算它们值的 访问器（accessors）。
​	属性( property)是一种用于访问对象或类型的特征的成员，特征反映了状态
​	属性是字段的自然扩展

从命名上看. field更偏向于实例对象在内存中的布局，property更偏向于反映现实世界对象的特征
对外:暴露数据，数据可以是存储在字段里的，也可以是动态计算出来的
对内:保护字段不被非法值“污染”

​	属性由Get&#x2F;Set方法对进化而来。(在Java、C++ 中，经常在类中使用Set和Get方法来设置和获取值，防止这个关键字段被污染)
​	例如，有一个名为 Student 的类，带有 age、name 和 code 的私有域。我们不能在类的范围以外直接访问这些域，但是我们可以拥有访问这些私有域的属性。
访问器（Accessors）属性（Property）的访问器（accessor）包含有助于获取（读取或计算）或设置（写入）属性的可执行语句。
访问器（accessor）声明可包含一个 get 访问器、一个 set 访问器，或者同时包含二者。例如：
public string Code&#123;   get   &#123;      return code;   &#125;   set   &#123;      code = value;//访问器中只提供value，表示要写入的值   &#125;&#125;

在属性中，value是访问器中的一个上下文关键字（例如this，在vs中用蓝色进行标识），在访问器这个特定的代码中，指代了传入的值。
属性的声明完整声明后台（back）成员变量与访问器
正常的声明变量，然后在后面加一个大括号（访问器），在括号里面有set和get两部分。
也可以分开写（propfull）
private int myVar;public int MyProperty&#123;	get &#123; return myVar; &#125;	set &#123; myVar = value; &#125;&#125;





简略声明 （自动属性）只有访问器
class Student&#123;	public int MyProperty &#123; get; set; &#125;&#125;

public int Age&#123;	get	&#123;		//相关语句	&#125;	set	&#123;		//相关语句	&#125;&#125;

注意：如果没有给get、set提供实现代码，这些块的实现代码（和底层的字段）都由编译器提供。
使用自动属性时，只能通过
样例using System;namespace runoob&#123;    class Student    &#123;        private string code = &quot;N.A&quot;;        private string name = &quot;not known&quot;;        private int age = 0;        // 声明类型为 string 的 Code 属性        public string Code        &#123;            get            &#123;                return code;            &#125;            set            &#123;                code = value;            &#125;        &#125;        // 声明类型为 string 的 Name 属性        public string Name        &#123;            get            &#123;                return name;            &#125;            set            &#123;                name = value;            &#125;        &#125;        // 声明类型为 int 的 Age 属性        public int Age        &#123;            get            &#123;                return age;            &#125;            set//可以在里面写上相关的语句。value是访问器提供的一个变量，表示传入的值            &#123;                if (value &gt;= 0 &amp;&amp; value &lt;= 120)                &#123;                    age = value;                &#125;                else                &#123;                    throw new Exception(&quot;Age value has error&quot;);                &#125;            &#125;        &#125;        public override string ToString()        &#123;            return &quot;Code = &quot; + Code + &quot;, Name = &quot; + Name + &quot;, Age = &quot; + Age;        &#125;    &#125;    class ExampleDemo    &#123;        public static void Main()        &#123;            // 创建一个新的 Student 对象            Student s = new Student();            // 设置 student 的 code、name 和 age            s.Code = &quot;001&quot;;            s.Name = &quot;Zara&quot;;            s.Age = 9;//在使用的时候不必使用get、set，直接赋值即可。            Console.WriteLine(&quot;Student Info: &#123;0&#125;&quot;, s);            // 增加年龄            s.Age += 1;            Console.WriteLine(&quot;Student Info: &#123;0&#125;&quot;, s);            Student t = new Student();            t.Age = 120;            t.Age++;//只要属性发生变化，就自动调用set方法，以检查值是否合法，一旦不合法，就报错            Console.ReadKey();        &#125;    &#125;&#125;





字段封装成属性选中字段后，ctrl r + ctrl e;

限制属性的读写只读属性在访问器中删除set部分，即完成了属性的只读
样例using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            //Test.Age = 0;//在只读状态下无法写入            Console.WriteLine(Test.Age);//但可以正常读                        Console.ReadLine();        &#125;        &#125;    class Test    &#123;        static private int age = 10;        static public int Age        &#123;            get &#123; return age = 10; &#125;        &#125;    &#125;&#125;



类外只读类内读写对于的set和get方法设置成private即可。
样例using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Test t = new Test();            t.Tools(100);//类外不能直接写            Console.WriteLine(t.Age);//类外可读                        Console.ReadLine();        &#125;        &#125;    class Test    &#123;        private int age = 10;        public int Age        &#123;            get &#123; return age; &#125;            private set &#123; age = value; &#125;        &#125;        public void Tools(int a)        &#123;            Age = a;//类内可写        &#125;    &#125;&#125;



对于这种类内读写的属性对类外来说并不是只读属性，只是set从外界不能直接访问到
动态计算值的属性这个属性本身并没有封装一个字段，当从外界访问的时候，值是实时计算出来的。
被动计算当调用的时候才会被计算。
如果访问的比较频繁，会比较浪费性能（每次访问都要计算）
using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Test t = new Test();            t.Age = 20;            Console.WriteLine(t.Checked);//输出Checked的值            Console.ReadLine();        &#125;        &#125;    class Test    &#123;        private int age = 10;        public int Age        &#123;            get &#123; return age; &#125;            set &#123; age = value; &#125;        &#125;        /*         动态计算值的属性。Checked这个属性，并没有封装一个字段，当从外界访问的时候，值是实时计算出来的。         */        public bool Checked        &#123;            get//获取值，必须确保一定有返回值            &#123;                if(this.age &gt;= 18)//计算，当 当前对象的age值大于等于18                    return true;//得到计算结果 true                else                    return false;//否则得到计算结果false            &#125;        &#125;    &#125;&#125;



主动计算每次修改都会计算
如果经常被设定但不经常check，还是被动计算比较好。
using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Test t = new Test();            t.Age = 20;            Console.WriteLine(t.Check);//输出Checked的值            Console.ReadLine();        &#125;    &#125;    class Test    &#123;        private int age = 10;        public int Age        &#123;            get &#123; return age; &#125;            set            &#123;                 age = value;                //在值发生变化的时候，同时自动计算check的值                this.CalculateCheck();            &#125;        &#125;        //主动的计算        //创建一个计算属性        private bool check;        public bool Check        &#123;            get &#123; return check; &#125;            set &#123; check = value; &#125;//据说是只读的属性，但注释掉这行后无法执行？        &#125;        private void CalculateCheck()   //计算属性        &#123;            if (this.age &gt;= 18)//计算，当 当前对象的age值大于等于18                this.Check = true;            else                this.Check = false;        &#125;    &#125;&#125;



注意实例属性和静态属性●属性的名字一 定是名词只读属性一只有getter没 有setter尽管语法上正确，几乎没有人使用”只写属性”，因为属性的主要目的是通过向外暴露数据而表示对象&#x2F;类型的状态
属性与字段的关系
一般情况下，它们都用于表示实体(对象或类型)的状态
属性大多数情况下是字段的包装器( wrapper )
建议:永远使用属性(而不是字段)来暴露数据，即字段永远都是private或protected的

方法方法的由来
方法（method）的前身是c&#x2F;c++语言的函数（function）
方法是面向对象范畴的概念，在非面向对象语言中仍称为函数


永远都是类（或结构体）的成员
c#中方法不可独立于类（或结构体）之外
只有作为类（结构体）的成员的时候才称为方法


方法是类（结构体）最基本的成员之一
类基本成员只有两个，字段和方法



方法的定义与调用方法的声明和定义是放在一起的，没有头文件的概念
方法、属性的访问修饰符详见c#封装的部分。
方法声明详细语法&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)&#123;   Method Body&#125;


Access Specifier：访问修饰符，这个决定了变量或方法对于另一个类的可见性。（详见后面的c#封装）
new
public
protected
internal
private
static（静态）
virtual
sealed
override
abstract
extern
async


Return type：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 void。
Method name：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。并且需要时一个动词或动词短语，并满足大驼峰的规则
Parameter list：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。
Method body：方法主体，包含了完成任务所需的指令集。

方法的调用方法名(对应参数)；
方法的返回值通过函数进行数据交换的最简单方式是利用返回值。
当函数返回一个值的时候，需要如下修改函数：

在函数声明中指定返回值类型，但不使用void关键字。
使用return关键字结束函数的执行把返回值传给主调函数

需要注意的是，返回值的类型必须是声明时的返回值类型，或者可以隐式的转换成该类型。如声明返回int，实际可以返回short。
return不一定在最后一行，一旦执行到return语句，方法将直接退出，不再执行return后面的语句（如果有）
方法的参数传值参数（值参数）
声明时不带修饰符的形参是值形参。

本质是作用域在当前方法的一个局部变量。其初始值是调用它的时候赋值在当前方法

它的初始值是在调用这个方法的时候赋值给它的实参的值。换句话说就是传进来的实参的一个副本。即堆值参数的操作永远不会影响原来变量的值。

当形参是值形参时，方法调用中的对应实参必须是表达式，并且它的类型可以隐式转换为形参的类型。

允许方法将新值赋给值参数。这样的赋值只影响由该值形参表示的局部存储位置，而不会影响在方法调用时由调用方给出的实参。

当传入的参数不是值类型的参数，而是引用类型的参数，则传入的是指向引用类型的对象。此时，方法内部和外部的两个变量指向的都是同一个对象。

如果如果给传入的变量创建一个新的对象，在方法内使用的是新创建的对象，在方法外还是原来的那个对象。如：

using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Policy;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using ShowInfos;
namespace ConsoleApp
{
    internal class Program
    {
        static void Main(string[] args)
        {
            A a = new A();
            a.Name= &quot;A&quot;;//创建一个对象，这个对象中的Name属性的值是A
            T(a);//把创建的引用类型的变量作为值传入到T方法中
            Console.WriteLine(a.Name);//T方法结束后再次输出a的Name属性，结果还是A
            Console.ReadLine();
        }
        static void T(A a)
        {
            Console.WriteLine(a.Name);//输出A
            a = new A();
            a.Name= &quot;B&quot;;
            Console.WriteLine(a.Name);//输出B
        }
    }

    class A//将被引用的对象
    {
        private string name;

        public string Name
        {
            get { return name; }
            set { name = value; }
        }
    }

}
  - 还可以更直接一点，输出hashcode检查一下是否是同一个对象使用值参数的时候，必须做到参数匹配。#### 引用参数​	使用引用参数时，必须在方法的申明和调用中都使用关键字`ref`修饰符。​	**实参必须是变量**，在用作**实参前必须被赋值**。如果是引用类型的变量，可以赋值为一个引用或者null值。​	引用参数不会像值参数那样创建副本，而是直接指向传进来的参数所指向的地址。就像c++的`&amp;`修饰符一样，可以使用引用的方式带回所需的数据。##### 样例​	下面的代码阐明了引用参数的声明和调用的语法：```c#void MyMethod(ref int val)  //方法声明包含ref修饰符&#123;    //your code&#125;





int y = 1;		   //必须先赋值MyMethod(ref y);   //方法调用MyMethod(ref 3+5);  //错误,形参必须是变量

​	如果传入的是引用类型的变量，则在方法内重新指向新的对象后，在方法外一样会指向新的对象。如：
using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;              static void Main(string[] args)        &#123;            A a = new A();            a.Name = &quot;A&quot;;            T(ref a);//引用参数要求调用的时候也明确声明是引用            Console.WriteLine(a.Name);//还是输出B，最早创建的Name = “A&quot;            Console.ReadLine();        &#125;        static void T(ref A a)        &#123;            Console.WriteLine(a.Name);//输出A            a = new A();            a.Name= &quot;B&quot;;            Console.WriteLine(a.Name);//输出B        &#125;    &#125;    class A//被引用的对象    &#123;        private string name;        public string Name        &#123;            get &#123; return name; &#125;            set &#123; name = value; &#125;        &#125;    &#125;&#125;





输出参数​	在声明的时候使用out关键字进行声明的参数
​	正常来说方法的返回值只能有一个，如果需要返回多个参数可以借助输出参数
​	输出参数和引用参数类似，都不会创建新的存储位置。引用参数在传入的时候必须有一个明确的值，而输出参数不需要，原有的值会被丢弃。
​	在方法返回前，必须对传进来的输出参数名确赋值，否则编译器会报错。
​	不能借助输出参数传入数据。因为在方法体中，如果未对输出参数进行赋值，则无法使用。一旦赋值先前带有的值则会被丢弃
样例1using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;              static void Main(string[] args)        &#123;            A a = new A();            a.Name= &quot;A&quot;;            A b;//不需要赋值            T(out a, out b);//也需要在调用的时候声明出来            Console.WriteLine(b.Name);//还是输出B            Console.ReadLine();        &#125;        static void T(out A a, out A b)        &#123;            //Console.WriteLine(a.Name);//编译器报错：使用了未赋值的out参数&quot;a&quot;；            //a = new A();            a = null;            b = new A();            b.Name= &quot;B&quot;;            Console.WriteLine(b.Name);//输出B        &#125;    &#125;    class A//被引用的对象    &#123;        private string name;        public string Name        &#123;            get &#123; return name; &#125;            set &#123; name = value; &#125;        &#125;    &#125;&#125;

样例2 TryParse转换using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            string s;            s = &quot;123.45.6&quot;;            double d = -1;            if (double.TryParse(s, out d))//尝试的转换，如果转换成功，则返回true，否则为false。同时转换完成的值以输出参数的形式带出，转换失败带出对应参数的默认值                Console.WriteLine(&quot;转换成功&quot;);            else                Console.WriteLine(&quot;转换失败&quot;);            Console.WriteLine(&quot;转换完成的值是：&#123;0&#125;&quot;, d);            Console.ReadLine();        &#125;    &#125;&#125;





数组参数(形参数组,params)​	有时，当声明一个方法时，不能确定要传递给函数作为参数的参数数目。C# 参数数组解决了这个问题，参数数组通常用于传递未知数量的参数给函数。
​	在使用数组作为形参时，C# 提供了 params 关键字，使调用数组为形参的方法时，既可以传递数组实参，也可以传递一组数组元素。params 的使用格式为：
public 返回类型 方法名称( params 类型名称[] 数组名称 )

需要注意，在使用params进行修饰的时候，只能存在一个被修饰的形参，且这个形参位于最后（因为无法分辨那些是属于这个参数）。
样例在不使用形参数组作为形参的时候，写法是这样的，需要先创建一个数组，然后传入数组：
using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            int[] arr = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;;            Console.WriteLine(&quot;ans is &#123;0&#125;&quot;, CalculateSum(arr));            Console.ReadLine();        &#125;        static int CalculateSum(int[] arr)        &#123;            int sum = 0;            foreach(var item in arr)            &#123;                sum += item;            &#125;            return sum;        &#125;    &#125;&#125;

而使用形参数组之后，就不需要先新建一个数组，而是直接把数通过形参全部传入，且不需要指定传入的数的个数
using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            int ans = CalculateSum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);//可以直接传入数个参数而不声明参数个数            Console.WriteLine(&quot;ans is &#123;0&#125;&quot;, ans);            Console.ReadLine();        &#125;        static int CalculateSum(params int[] arr)        &#123;            int sum = 0;            foreach(var item in arr)            &#123;                sum += item;            &#125;            return sum;        &#125;    &#125;&#125;







具名参数：参数的位置不再受约束严格来说不是具名参数不是某个参数的种类，而是参数的使用方法
正常情况下，实参顺序要和形参顺序相等，这种调用就是不具名调用。如：
using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            PrintInfo(&quot;张三&quot;, 0);            Console.ReadLine();        &#125;        static void PrintInfo(string name, int age)        &#123;            Console.WriteLine(&quot;&#123;0&#125; &#123;1&#125;&quot;, name, age);        &#125;    &#125;&#125;





使用具名调用后：
using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            PrintInfo(name: &quot;张三&quot;, age: 0);//具名调用                                            Console.ReadLine();        &#125;        static void PrintInfo(string name, int age)        &#123;            Console.WriteLine(&quot;&#123;0&#125; &#123;1&#125;&quot;, name, age);        &#125;    &#125;&#125;





优点
提高代码的可读性
参数的位置不受参数列表的约束

可选参数当在调用一个方法的时候，这个参数可写可不写。因为在声明参数的时候这个参数带有默认值。
对于带有默认值的参数，如果在调用参数的时候不写这个参数，则这个参数获得声明时的值。
不建议用可选参数。
using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            PrintInfo(name: &quot;李四&quot;, age: 20);//可以正常调用            PrintInfo();//当参数缺省时，使用默认值输出            Console.ReadLine();        &#125;        static void PrintInfo(string name = &quot;张三&quot;, int age = -1)        &#123;            Console.WriteLine(&quot;&#123;0&#125; &#123;1&#125;&quot;, name, age);        &#125;    &#125;&#125;



元组参数使用样例//一个样例方法，演示使用元组进行数据的传入和传出。static (int, double)MySwap((double, int) x)&#123;    (int, double) t;    t.Item1 = x.Item2;    t.Item2 = x.Item1;    return t;&#125;

具体见c#元组部分
扩展方法（this参数）方法必须是公有的、静态的，即被public static所修饰。
必须是形参列表中的第一个，由this修饰
必须由一个静态类（类名一般为 数据类型+Extension ，如DoubleExtension）来统一收纳。（必须放在一个静态类中）
当无法对一个类型的源码进行修改的时候，可以使用扩展方法对这种数据类型进行追加方法。
具体步骤
创建一个静态类，类名为要扩展的数据类型的名字 + Extension。（不强制要求，但是是规范）
在这个静态类中创建一个静态的公共的方法，声明方法与常规方法相同，除了形参列表外。
形参列表的规则：
有且最少有一个形参，并且第一个形参需要在前面加上this修饰符。形参的数据类型就是要扩展的数据类型，形参名随便，稍后要用。
this修饰符只允许存在一个，并且修饰的形参必须是第一个形参。
后面可以有多个参数。


方法体中是这个扩展方法的实现过程，实现完后可以没有返回。

样例给string类型的变量增加一个ShowInfo的方法，以实现将string字符串输出到控制台。
using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            string s = &quot;hurr&quot;;            s.ShowInfo();            Console.ReadKey();        &#125;    &#125;    static class StringExtension    &#123;        public static void ShowInfo(this string str)        &#123;            Console.WriteLine(str);        &#125;    &#125;    static class DoubleExtension    &#123;        public static double Round(this double input, int digits)        &#123;            double result = Math.Round(input, digits);            return result;        &#125;    &#125;&#125;



各种参数的使用场景
传值参数：参数的默认传递方式
输出参数：用于除返回值外还需要返回输出的场景
引用参数：用于需要修改实际参数值的场景
数组参数：用于简化方法的调用
具名参数：提高可读性
可选参数：使参数拥有默认值
扩展方法（this参数）：为目标数据类型“追加”方法

方法的重载（Overload）定义
当为一个类创建方法的时候，方法名可以一样，但方法的签名不能一样。
方法签名（method signature）由方法的名字、类型形参的个数和它每一个形参（按从左到右的顺序）的类型和种类（值、引用或输出）组成。方法的签名不包含返回类型
重载决策（调用哪一个重载）：用于在给定了参数列表和一组候选函数成员的情况下，选择一个最佳函数成员来实施调用。

简单地说就是，当多个方法的方法名相同，但所需的形参列表不同(类型或种类)的时候，就构成了方法的重载。注意方法的返回值是无所谓的
方法的调用与栈的关系方法调用时栈内存的分析
stack frame的分析：一个方法在被调用的时候在栈内存中的布局。

栈内存在内存中由高字节位向低字节位分配，分配到最低后就溢出了。 

在当前方法中调用另一个方法，当前方法称为主调者，被调用的方法称为被调者。

static void Main(string[] args)
{
    Student student= new Student(10,&quot;张三&quot;);
    student.ShowInfo();//Main：主调者 caller ；ShowInfo：被调者 callee
    Console.ReadLine();
}
- 传入的参数（变量）也需要压入栈中，并且在C#中，传入的变量归主调者管。入栈的时候，值是传入的参数，但类型是被调者形参决定的。如果主调者调用的方法的形参列表是double，但调用传入的时候是int类型的100，则在栈中，会分配一片double的空间，将int的100自动的进行隐式类型转换成double，然后存入。- 到被调者执行的时候，只需要再往栈中压入内部的局部变量即可（传进来的参数不用管，那个由主调者压）。- 除此之外，还需要压入主调者指针等其他参数- 返回值一般存储在cpu的寄存器中（前提是能存储下）### 静态方法#### 修饰符被static修饰。#### 特点1. 静态方法属于类所有，类实例化前即可使用（不需要实例化就可以方法）。2. 静态方法只能访问类中的静态成员，而非静态方法可以访问类中的任何成员。3. 静态方法在使用上不需要实例化类，而非静态方法需要实例化后才能调用。4. 静态方法不能直接使用非静态成员，因为非静态成员与实例相关，通过对象点取间接使用。5. 静态方法中不能用this（与实例相关）。6. 静态方法的生命周期很长，一旦被创建，直到程序结束位置。   - 静态变量不管是在全局还是局部声明的static变量都存放于程序的全局变量区域。   - 静态变量的作用域是变量的可见代码域（块作用域，函数作用域，类作用域，程序全局作用域）。#### 注意事项- 静态方法可以使用类名也可以使用对象来调用，而非静态方法只能使用对象来调用[1](https://bing.com/search?q=使用静态方法的注意事项有哪些).- 静态方法可以直接访问静态的成员，但是不能直接访问非静态的成员[1](https://bing.com/search?q=使用静态方法的注意事项有哪些).- 静态方法不能出现this或者super关键字，因为静态方法可以直接使用类名进行访问，而this关键字代表的是调用方法的对象，此时就会产生冲突。- 静态方法不宜过多。可能会占用过多的内存。## 索引器?### 什么是索引器**索引器（Indexer）** 允许一个对象可以像数组一样使用下标的方式来访问。当为类定义一个索引器时，该类的行为就会像一个 **虚拟数组（virtual array）** 一样，可以使用数组访问运算符 **[ ]** 来访问该类的的成员。### 语法```c#element-type this[int index]&#123;   // get 访问器   get   &#123;      // 返回 index 指定的值   &#125;   // set 访问器   set   &#123;      // 设置 index 指定的值   &#125;&#125;





索引器（Indexer）的用途​	索引器的行为的声明在某种程度上类似于属性（property）。就像属性（property），可使用 get 和 set 访问器来定义索引器。但是，属性返回或设置一个特定的数据成员，而索引器返回或设置对象实例的一个特定值。换句话说，它把实例数据分为更小的部分，并索引每个部分，获取或设置每个部分。
​	定义一个属性（property）包括提供属性名称。索引器定义的时候不带有名称，但带有 this 关键字，它指向对象实例。下面的实例演示了这个概念：
using System;namespace IndexerApplication&#123;   class IndexedNames   &#123;      private string[] namelist = new string[size];      static public int size = 10;      public IndexedNames()      &#123;         for (int i = 0; i &lt; size; i++)         namelist[i] = &quot;N. A.&quot;;      &#125;      public string this[int index]      &#123;         get         &#123;            string tmp;            if( index &gt;= 0 &amp;&amp; index &lt;= size-1 )            &#123;               tmp = namelist[index];            &#125;            else            &#123;               tmp = &quot;&quot;;            &#125;            return ( tmp );         &#125;         set         &#123;            if( index &gt;= 0 &amp;&amp; index &lt;= size-1 )            &#123;               namelist[index] = value;            &#125;         &#125;      &#125;      static void Main(string[] args)      &#123;         IndexedNames names = new IndexedNames();         names[0] = &quot;Zara&quot;;         names[1] = &quot;Riz&quot;;         names[2] = &quot;Nuha&quot;;         names[3] = &quot;Asif&quot;;         names[4] = &quot;Davinder&quot;;         names[5] = &quot;Sunil&quot;;         names[6] = &quot;Rubic&quot;;         for ( int i = 0; i &lt; IndexedNames.size; i++ )         &#123;            Console.WriteLine(names[i]);         &#125;         Console.ReadKey();      &#125;   &#125;&#125;

当上面的代码被编译和执行时，它会产生下列结果：
ZaraRizNuhaAsifDavinderSunilRubicN. A.N. A.N. A.





样例using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;              static void Main(string[] args)        &#123;            Student student = new Student();            student[0] = &quot;张三&quot;;            student[1] = &quot;李四&quot;;            student[2] = &quot;王五&quot;;            for(int i = 0; i &lt; Student.size; i++)             &#123;                Console.WriteLine(student[i]);            &#125;                        Console.ReadLine();        &#125;    &#125;    class Student    &#123;        static public int size = 10;        private string[] nameList = new string[size];//创建一个string list        public Student()//无参构造器，默认全部构造成“空”        &#123;            for(int i = 0; i &lt; size; i++)            &#123;                nameList[i] = &quot;NA&quot;;            &#125;        &#125;        //索引器        public string this[int index]        &#123;            get//读取            &#123;                string tmp;//一个临时变量                if (index &gt;= 0 &amp;&amp; index &lt; nameList.Length)//如果索引值在合法范围内                &#123;                    tmp = nameList[index];//获取值                &#125;                else                &#123;                    tmp = &quot;&quot;;//不在就返回空串                &#125;                return tmp;//返回获取到的值            &#125;            set//写入            &#123;                if(index &gt;=0 &amp;&amp; index &lt; size - 1) //如果没有超过规定的大小                &#123;                    nameList[index] = value;//就读入                &#125;            &#125;        &#125;    &#125;&#125;




索引器可以使用任何有效的访问修饰符（public、protected internal、protected、internal、private、private protected）。它们可能是密封、虚拟或者抽象的。与属性一样，可以在索引器中为get和set访问器指定不同的访问修饰符。还可以指定只读索引器（忽略set访问器）或只写索引器（忽略get访问器）。
属性的各种用法同样适用于索引器（唯一例外的是“自动实现属性”，编译器无法始终为索引器生成正确的存储）。
创建索引器的必备要素：

必须先创建索引器所需要的容器（可以理解为数据的存放）；
创建索引器需要使用this关键字；
索引器中必须包含get和set访问器，在C# 7.0后可以使用表达式（&#x3D;&gt;）主体进行简化；
在使用表达式主体成员进行索引时，必须额外的提供容器的修改接口（因为表达式主体不包括set访问器）。

索引器相当于一个方法，支持多个或多种类型的参数，与方法不同的是，索引器没有独立的名称，只能通过返回值的不同和参数的不同来区分不同的签名（从而实现重载），其返回值不能为void。索引器除了可以传入参数外，其返回值不能为void。索引器除了可以传入参数外，还可以对其进行赋值。
创建索引器时，其返回值为value关键字所使用的类型，定义了返回值类型的同时，也定义了其可接受的值类型。
总之，我对索引器的理解就是：是一个可以进行读写操作的自定义类中数据集合的接口。通过该接口，简化或丰富了该自定义类中数据集合的操作方式。
例如，在如下示例中，此索引器使用List作为容器，使用int类型的index进行索引，返回值为Measurements对象。

https://zhuanlan.zhihu.com/p/488448024
构造器对于类而言，可分为静态构造器和实例构造器两种。
构造器（特殊的方法）
构造器(constructor)（构造函数）是类的成员之一
狭义的构造器是指“实例构造器”（instance constructor）
一般来说构造器都是public的
当声明了一个类之后，但又没有写构造器，编译器就会为它准备一个默认的构造器。一旦写了构造器，编译器将不会添加默认构造器。
构造器没有返回值类型。
构造器的名称必须和类名称相同。
构造器可以被重载。
当调用子类构造器时 会自动调用父类的构造器。

构造器的声明访问修饰符 类名(参数列表) [: base(传递给父类构造器的实参)]&#123;	//执行语句&#125;

样例class A&#123;    public int a &#123; get; set; &#125;    public A(int a)    &#123;        this.a = a;    &#125;&#125;class B : A&#123;    public int b &#123; get; set; &#125;    public B(int a, int b) : base(a)//当调用子类的构造函数时，会自动调用父类的构造函数。如果父类不存在无参构造函数，则需要使用base关键字向父类的构造函数传递值。    &#123;        this.b = b;    &#125;&#125;









静态构造器​	在使用类中的静态成员的时候，需要预先初始化这些成员。
​	静态构造函数用于初始化任何静态数据，或执行仅需执行一次的特定操作。 将在创建第一个实例或引用任何静态成员之前自动调用静态构造函数。
​	他的语法规则和普通的构造器类似，要求都是方法名与类型相同，且都不可以有返回值；不同的是静态构造器的修饰符不再是public，而是static。
​	一个类只能有一个静态构造器，该构造器不能有访问修饰符，也不能带有任何参数。静态构造器不能直接调用，只能在下述情况下执行：

创建包含静态构造函数的类实例时
访问包含静态构造函数的类的静态成员时

​	首先先调用静态构造器，之后再实例化或访问静态成员。
​	可以说，只要类存在静态构造器，只要这个类被调用过，就会且只会调用一次静态构造器。
​	
样例using System;using System.Diagnostics;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;正在执行Main方法&quot;);            A.num = 10;//当访问包含静态构造函数的类的静态成员时，运行环境会将这个类加载到内存中，同时会触发这个类的静态构造器。            B b1 = new B();//创建包含静态构造函数的类实例时，也会在调用实例构造器的同时调用静态构造器。            B b2 = new B();//静态构造器只会执行一次，再次创建实例的时候，只会再次调用实例构造器，而不会调用静态构造器。            Console.ReadKey();        &#125;     &#125;        static class A    &#123;        public static int num;        static A()//静态构造器，只在运行环境加载这个类的时候调用，且只调用一次。        &#123;            Console.WriteLine(&quot;A的静态构造器已执行。&quot;);        &#125;    &#125;     class B    &#123;        static B()//静态构造器，只在运行环境加载这个类的时候调用，且只调用一次。        &#123;            Console.WriteLine(&quot;B的静态构造器已执行。&quot;);        &#125;        public B()        &#123;            Console.WriteLine(&quot;B的实例构造器已执行。&quot;);        &#125;        public int id        &#123;            get; set;        &#125;    &#125;&#125;





析构器析构方法（析构器）是在垃圾回收、释放资源时使用的。

不能在结构中定义析构函数。只能对类使用析构函数。
析构函数不能重载，一个类只能有一个析构函数。
析构函数无法继承，他的子类将拥有除父类的析构函数外的所有元素（先执行子类的构造函数，再执行父类的构造函数。如果需要手动调用父类的构造函数，可以用base关键字）。
无法调用析构函数。它们是被自动调用的。
析构函数既没有修饰符，也没有参数。

基本语法~方法名()&#123;    语句块；&#125;

无法控制何时调用析构函数，因为这是由垃圾回收器决定的。垃圾回收器检查是否存在应用程序不再使用的对象。如果垃圾回收器认为某个对象符合析构，则调用析构函数（如果有）并回收用来存储此对象的内存。程序退出时也会调用析构函数。
可以通过调用 Collect 强制进行垃圾回收，但大多数情况下应避免这样做，因为这样会导致性能问题。有关更多信息，请参见强制垃圾回收。
接口​	接口定义了所有类继承接口时应遵循的语法合同。接口定义了语法合同 “是什么” 部分，派生类定义了语法合同 “怎么做” 部分。
​	接口定义了属性、方法和事件，这些都是接口的成员。接口只包含了成员的声明。成员的定义是派生类的责任。接口提供了派生类应遵循的标准结构。
​	接口使得实现接口的类或结构在形式上保持一致。
​	抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。
​	接口本身并不实现任何功能，它只是和声明实现该接口的对象订立一个必须实现哪些行为的契约。
​	抽象类不能直接实例化，但允许派生出具体的，具有实际功能的类。
​	可以使用virtual或abstract来实现接口成员，但不能使用static或const。
定义接口: MyInterface.cs接口使用 interface 关键字声明，它与类的声明类似。接口声明默认是 public 的。下面是一个接口声明的实例：
interface IMyInterface&#123;    void MethodToImplement();&#125;

以上代码定义了接口 IMyInterface。通常接口命令以 I 字母开头，这个接口只有一个方法 MethodToImplement()，没有参数和返回值，当然我们可以按照需求设置参数和返回值。
值得注意的是，该方法并没有具体的实现。
接下来我们来实现以上接口：InterfaceImplementer.cs
样例using System;interface IMyInterface&#123;        // 接口成员    void MethodToImplement();&#125;class InterfaceImplementer : IMyInterface&#123;    static void Main()    &#123;        InterfaceImplementer iImp = new InterfaceImplementer();        iImp.MethodToImplement();    &#125;    public void MethodToImplement()    &#123;        Console.WriteLine(&quot;MethodToImplement() called.&quot;);    &#125;&#125;

InterfaceImplementer 类实现了 IMyInterface 接口，接口的实现与类的继承语法格式类似：
class InterfaceImplementer : IMyInterface

​	继承接口后，我们需要实现接口的方法 MethodToImplement() , 方法名必须与接口定义的方法名一致。
接口继承: InterfaceInheritance.cs以下实例定义了两个接口 IMyInterface 和 IParentInterface。
如果一个接口继承其他接口，那么实现类或结构就需要实现所有接口的成员。
以下实例 IMyInterface 继承了 IParentInterface 接口，因此接口实现类必须实现 MethodToImplement() 和 ParentInterfaceMethod() 方法：
样例using System;interface IParentInterface&#123;    void ParentInterfaceMethod();&#125;interface IMyInterface : IParentInterface&#123;    void MethodToImplement();&#125;class InterfaceImplementer : IMyInterface&#123;    static void Main()    &#123;        InterfaceImplementer iImp = new InterfaceImplementer();        iImp.MethodToImplement();        iImp.ParentInterfaceMethod();    &#125;    public void MethodToImplement()    &#123;        Console.WriteLine(&quot;MethodToImplement() called.&quot;);    &#125;        public void ParentInterfaceMethod()    &#123;        Console.WriteLine(&quot;ParentInterfaceMethod() called.&quot;);    &#125;&#125;

实例输出结果为：
MethodToImplement() called.ParentInterfaceMethod() called.









嵌套类嵌套类顾名思义就是类或者结构中定义的类
class Container&#123;    class Nested    &#123;        Nested() &#123; &#125;    &#125;&#125;


嵌套类的默认访问权限是private ，可以指定为public，protected，private，internal，protected internal。
嵌套类型可以访问外部类（包裹嵌套类的类），如果要访问外部类型，要把外部类通过构造函数传进一个实例
嵌套类中只能访问外部类中的静态成员，不能直接访问外部类的非静态成员。

namespace ConsoleApplication11Anonymous&#123;    class Class1    &#123;        private int x;        protected string str;        static int y;        public class Nested        &#123;            int xx;            string ss;            void print()            &#123;                //int y = x;  //error,不能访问外部的非静态成员                int z = y;    //OK ,可以访问外部的静态成员            &#125;            public Nested(Class1 A)            &#123;                xx = A.x;   //通过外部类的实例来访问外部类私有成员                ss = A.str; //通过外部类的实例来访问外部类保护成员            &#125;        &#125;    &#125;     class Program    &#123;        static void Main(string[] args)        &#123;            Class1 X = new Class1();            Class1.Nested CN = new Class1.Nested( X );             &#125;      &#125;&#125;



根据C#作用域的规则，外部类只能通过内部类的实例来访问内部类的public成员，不能访问protected，private。
class Class2    &#123;        private int x;        static private int y;         public void func()        &#123;            //x = xx;   //当前上下文中不存在名称“xx”            //x = zz;   //当前上下文中不存在名称“zz”            //x = aa;   //当前上下文中不存在名称“aa”            x = Nested.aa;            Console.WriteLine(x);        &#125;         public void funcs()        &#123;            //这个只能访问Nested类的public成员            Nested XX = new Nested();            x = XX.zz;            Console.WriteLine(x);            //x = XX.aa;//访问静态成员只能通过类名而不是实例            x = Nested.aa;            Console.WriteLine(x);        &#125;         private class Nested        &#123;            private int xx;            protected int yy;            public int zz;            public static int aa;                    &#125;&#125;



C# 访问级别​	封装 被定义为”把一个或多个项目封闭在一个物理的或者逻辑的包中”。在面向对象程序设计方法论中，封装是为了防止对实现细节的访问。
​	抽象和封装是面向对象程序设计的相关特性。抽象允许相关信息可视化，封装则使开发者实现所需级别的抽象。
​	C# 封装根据具体的需要，设置使用者的访问权限，并通过 访问修饰符 来实现。
同一修饰符在一个类的声明中多次出现是编译时错误
在C#中，不同的类型和成员有不同的默认访问级别，如下：

类型（类、结构、枚举、委托等）在命名空间中声明时，默认访问级别是内部的（internal），这意味着它们只能在同一个程序集中访问；在其他类型中嵌套时，默认访问级别是私有的，这意味着它们只能在包含它们的类型中访问。
类型成员（字段、属性、方法、事件等）默认访问级别是私有的，这意味着它们只能在类内部访问。
接口成员默认访问级别是公共的，这意味着它们必须在实现接口的类或结构中公开。

不好意思深夜打扰老师了，刚刚遇到一个小问题，关于c# 中的gethashcode方法，new bing回答我的时候说到了“GetHashCode()方法返回的值不能用来判断对象是否相等，也不能用来存储或比较数据”，我有点没看懂这个意思，gethashcode方法是不能可靠的辨别对象是否是同一个吗？
一个 访问修饰符 定义了一个类成员的范围和可见性。C# 支持的访问修饰符如下所示：

public：所有对象都可以访问；
private：对象本身在对象内部可以访问；
protected：只有该类对象及其子类对象可以访问
internal：同一个程序集的对象可以访问；
protected internal：访问限于当前程序集或派生自包含类的类型。
sealed：用于修饰类。一旦类被这个关键字所修饰，就不允许再被继承。

Public 访问修饰符Public 访问修饰符允许一个类将其成员变量和成员函数暴露给其他的函数和对象。任何公有成员可以被外部的类访问。
下面的实例说明了这点：
using System;namespace RectangleApplication&#123;  class Rectangle  &#123;    *//成员变量*    public double length;    public double width;    public double GetArea()    &#123;      return length * width;    &#125;    public void Display()    &#123;      Console.WriteLine(&quot;长度： &#123;0&#125;&quot;, length);      Console.WriteLine(&quot;宽度： &#123;0&#125;&quot;, width);      Console.WriteLine(&quot;面积： &#123;0&#125;&quot;, GetArea());    &#125;  &#125;*// Rectangle 结束*  class ExecuteRectangle  &#123;    static void Main(string[] args)    &#123;      Rectangle r = new Rectangle();      r.length = 4.5;      r.width = 3.5;      r.Display();      Console.ReadLine();    &#125;  &#125;&#125;

当上面的代码被编译和执行时，它会产生下列结果：
长度： 4.5宽度： 3.5面积： 15.75

在上面的实例中，成员变量 length 和 width 被声明为 public，所以它们可以被函数 Main() 使用 Rectangle 类的实例 r 访问。
成员函数 Display() 和 GetArea() 可以直接访问这些变量。
成员函数 Display() 也被声明为 public，所以它也能被 Main() 使用 Rectangle 类的实例 r 访问。
Private 访问修饰符Private 访问修饰符允许一个类将其成员变量和成员函数对其他的函数和对象进行隐藏。只有同一个类中的函数可以访问它的私有成员。即使是类的实例也不能访问它的私有成员。
下面的实例说明了这点：
using System;namespace RectangleApplication&#123;  class Rectangle  &#123;    *//成员变量*    private double length;    private double width;    public void Acceptdetails()    &#123;      Console.WriteLine(&quot;请输入长度：&quot;);      length = Convert.ToDouble(Console.ReadLine());      Console.WriteLine(&quot;请输入宽度：&quot;);      width = Convert.ToDouble(Console.ReadLine());    &#125;    public double GetArea()    &#123;      return length * width;    &#125;    public void Display()    &#123;      Console.WriteLine(&quot;长度： &#123;0&#125;&quot;, length);      Console.WriteLine(&quot;宽度： &#123;0&#125;&quot;, width);      Console.WriteLine(&quot;面积： &#123;0&#125;&quot;, GetArea());    &#125;  &#125;*//end class Rectangle*     class ExecuteRectangle  &#123;    static void Main(string[] args)    &#123;      Rectangle r = new Rectangle();      r.Acceptdetails();      r.Display();      Console.ReadLine();    &#125;  &#125;&#125;

当上面的代码被编译和执行时，它会产生下列结果：
请输入长度：4.4请输入宽度：3.3长度： 4.4宽度： 3.3面积： 14.52

在上面的实例中，成员变量 length 和 width 被声明为 private，所以它们不能被函数 Main() 访问。
成员函数 AcceptDetails() 和 Display() 可以访问这些变量。
由于成员函数 AcceptDetails() 和 Display() 被声明为 public，所以它们可以被 Main() 使用 Rectangle 类的实例 r 访问。
Protected 访问修饰符Protected 访问修饰符允许子类访问它的基类的成员变量和成员函数。这样有助于实现继承。我们将在继承的章节详细讨论这个。更详细地讨论这个。
Internal 访问修饰符Internal 访问说明符允许一个类将其成员变量和成员函数暴露给当前程序中的其他函数和对象。换句话说，带有 internal 访问修饰符的任何成员可以被定义在该成员所定义的应用程序内的任何类或方法访问。
如果一个类前面没有添加任何修饰符，则相当于添加了Internal修饰符。
但，如果声明了internal，则在同一个项目中可以访问，在其他项目中无法访问。
简单的说就是阻止跨项目的访问。
样例：环境说明：一个ConsoleApp项目下的Program文件，其中的命名空间时ConsoleApp，并且在ConsoleApp项目中的引用里添加了MyLib的引用
一个MyLib类库下的Calculator文件，其中的命名空间为MyNamespace。
一个MyLib类库下的test文件，其中的命名空间为MyNamespace2。
Program文件：using System;using System.Windows.Forms;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            //MyLib.MyNamespace.ADD Add = new MyLib.MyNamespace.ADD();//编译器报错： 错误 CS0122	“ADD”不可访问，因为它具有一定的保护级别             MyLib.MyNamespace.SUB Sub = new MyLib.MyNamespace.SUB();//public修饰的则可以正常的访问            Console.ReadKey();        &#125;    &#125;&#125;

Calculator文件using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace MyLib.MyNamespace&#123;    internal class ADD    &#123;        public double Add(double x, double y)        &#123;            return x + y;        &#125;    &#125;    public class SUB    &#123;        public double Sub(double x, double y)        &#123;            return x - y;        &#125;    &#125;    public class test    &#123;        ADD Add = new ADD();//在同一个命名空间中可以访问    &#125;&#125;

test文件using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace MyLib.MyNamespace2&#123;    internal class test    &#123;        MyNamespace.ADD Add = new MyNamespace.ADD();//同一项目下跨命名空间也是可以访问的    &#125;&#125;


Protected Internal 访问修饰符Protected Internal 访问修饰符允许在本类,派生类或者包含该类的程序集中访问。这也被用于实现继承。
面向对象编程（OOP）继承继承是OOP的最重要的特征之一，任何类都可以从另一个类继承。
​	继承的本质是派生类在基类已有的成员的基础上，对基类进行的横向的和纵向的扩展。

派生类基于已有的成员
当继承发生时，子类继承了父类所有的成员（除了构造函数和析构函数）


在派生和继承的过程中，进行的是扩展
类的成员只能是越来越多，不可能减少。即不可以删除任何已有的成员。
一个类成员一旦被引入到继承链中，就会一直向下传递。
不要贸然引入新的类成员，不然可能造成对继承链的污染
部分动态语言可以做到移除成员变量，如python、js


横向指的是添加类成员，纵向指的是重写类成员


​	在UML中，公共成员用+表示，其他成员用一(私有成员)、#(受 保护的成员)和斜体(虚拟成员)表示。
​	虚拟成员不能是私有成员，因为这样会自相矛盾一不能既要求派生类重写成员，又不让派生类访问该成员。
​	C#提供了第三种可访问性: protected, 只有派生类才能访问protected成员。对于外部代码来说，这个可访问性与私有成员一样:外部代码不能访问private成员和protected成员。详细说明见上方类与成员中

继承的特性
当子类的构造器被调用的时候，会自动调用父类的构造器。先调用父类，再调用子类。当结束时，会按照与构造器调用顺序相反的顺序调用析构器。

using System;
using System.Windows.Forms;

namespace ConsoleApp
{
    internal class Program
    {
        static void Main(string[] args)
        {
            A a = new A();
            B b = new B();
            //输出结果：
            //A的构造器被调用了
            //A的构造器被调用了
            //B的构造器被调用了
            //B的析构器被调用了
            //A的析构器被调用了
            //A的析构器被调用了
            //请按任意键继续. . .

            Console.ReadKey();
        }
    }
    class A
    {
        public A()
        {
            Console.WriteLine(&quot;A的构造器被调用了&quot;);
        }
        ~A()
        {
            Console.WriteLine(&quot;A的析构器被调用了&quot;);
        }
    }
    class B : A
    {
        public B()
        {
            Console.WriteLine(&quot;B的构造器被调用了&quot;);
        }
        ~B()
        {
            Console.WriteLine(&quot;B的析构器被调用了&quot;);
        }
    }

}
    - 一个类可以被多个类继承，但一个类只能继承一个类，整个关系呈现一个 `树状` 的形态- 子类 is a 父类。一个子类的实例同时也是父类的一个实例。子类是属于父类的，在子类实例化的对象可以被父变量所指向，但父变量只能调用一些父类中拥有的成员。  - ```c#    using System;    using System.Windows.Forms;        namespace ConsoleApp    &#123;        internal class Program        &#123;            static void Main(string[] args)            &#123;                A a = new A();                B b = new B();                A c = new B();                a.showinfo();//输出A                b.showinfo();//B                c.showinfo();//A                 Console.WriteLine(a is B);//false，证明父类不属于子类                Console.WriteLine(b is A);//true，证明子类属于父类                Console.ReadKey();            &#125;        &#125;            class A        &#123;            public void showinfo()            &#123;                Console.WriteLine(&quot;A&quot;);            &#125;        &#125;        class B : A        &#123;            public void showinfo()            &#123;                Console.WriteLine(&quot;B&quot;);            &#125;        &#125;        &#125;




在子类中可以使用base关键字访问父类的元素，但只能向上访问一层。

using System;
using System.Windows.Forms;

namespace ConsoleApp
{
    internal class Program
    {
        static void Main(string[] args)
        {
            A a = new A();
            B b = new B();
            a.ShowInfo();//A
            b.ShowInfo();//B
            b.ShoeInfoFa();//A

            Console.ReadKey();
        }
    }

    class S
    {
        public string str { get; set; }
    }

    class A : S
    {
        public string str { get; set; }
        public A()
        {
            str = &quot;A&quot;;
        }
        public void ShowInfo()
        {
            Console.WriteLine(str);
        }
    }
    class B : A
    {
        public string str { get; set; }
        public B()
        {
            str = &quot;B&quot;;
        }
        public void ShowInfo()
        {
            Console.WriteLine(str);
        }
        public void ShoeInfoFa()
        {
            Console.WriteLine(base.str);
            //base.base.str = &quot;A&quot;;  //是不被允许的
        }
    }

}
- 子类的访问权限不能超越父类的访问权限。如父类的一个字段是保护的，可以将这个字段在子类中设置成私有、保护  ，但不能设置成public或internal。  ## 多态性多态是同一个行为具有多个不同表现形式或形态的能力。**多态性**意味着有多重形式。在面向对象编程范式中，多态性往往表现为&quot;一个接口，多个功能&quot;。多态性可以是静态的或动态的。在**静态多态性**中，函数的响应是在编译时发生的。在**动态多态性**中，函数的响应是在运行时发生的。在 C# 中，每个类型都是多态的，因为包括用户定义类型在内的所有类型都继承自 Object。多态就是同一个接口，使用不同的实例而执行不同操作。多态的概念：让一个对象能够表现出多种状态。### 静态多态性在编译时，函数和对象的连接机制被称为早期绑定，也被称为静态绑定。C# 提供了两种技术来实现静态多态性。分别为：- 函数重载  - 具体见C#的类与成员中的方法部分 其中介绍了方法的重载- 运算符重载#### 运算符重载##### 概述可以重定义或重载 C# 中内置的运算符。因此，程序员也可以使用用户自定义类型的运算符。重载运算符是具有特殊名称的函数，是通过关键字 **operator** 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。注意，只能重载现有的C#运算符，不能创建新的运算符。​	运算符重载其实就是函数重载。首先通过指定的运算表达式调用对应的运算符函数，然后再将运算对象转化为运算符函数的实参，接着根据实参的类型来确定需要调用的函数的重载，这个过程是由编译器完成。##### 可重载和不可重载运算符| 运算符                                | 描述                                               || :------------------------------------ | :------------------------------------------------- || +, -, !, ~, ++, --                    | 这些      一元运算符只有一个操作数，且可以被重载。 || +, -, *, /, %                         | 这些二元运算符带有两个操作数，且可以被重载。       || ==, !=, &lt;, &gt;, &lt;=, &gt;=                  | 这些比较运算符可以被重载。                         || &amp;&amp;, \|\|                              | 这些条件逻辑运算符不能被直接重载。                 || +=, -=, *=, /=, %=                    | 这些赋值运算符不能被重载。                         || =, ., ?:, -&gt;, new, is, sizeof, typeof | 这些运算符不能被重载。                             |##### 自定义类型转换###### 自定义隐式类型转换​	implicit 关键字用于声明隐式的用户定义类型转换运算符。​	如果可以确保转换过程不会造成数据丢失，则可使用该关键字在用户定义类型和其他类型之间进行隐式转换。隐式转换可以通过消除不必要的类型转换来提高源代码的可读性。 但是，因为隐式转换不需要程序员将一种类型显式强制转换为另一种类型，所以使用隐式转换时必须格外小心，以免出现意外结果。```c#using System;namespace ConsoleApp&#123;     class Program    &#123;        static void Main(string[] args)        &#123;            Person p = new(&quot;张三&quot;);            string str1 = p;            Console.WriteLine(str1);//输出张三            Console.ReadKey();        &#125;    &#125;    //Person类中此时只有一个属性Name，可以无损的转换成为string，因此可以使用自定义隐式类型转换进行转换    class Person    &#123;        public string Name &#123; get; set; &#125;//姓名        public Person(string name)        &#123;            Name = name;        &#125;        public static implicit operator string(Person p)        &#123;            return p.Name;        &#125;    &#125;&#125;





自定义显示类型转换当类型转换时会（可能）发生数据丢失，此时需要定义显式类型转换而不是隐式转换
定义语法与隐式类似，只是关键字由implicit换成了explicit
using System;namespace ConsoleApp&#123;     class Program    &#123;        static void Main(string[] args)        &#123;            Person p = new(&quot;张三&quot;);            string str1 = (string)p;            int id = (int)p;            Console.WriteLine(str1);//输出张三            Console.WriteLine(id);            Console.ReadKey();        &#125;    &#125;    // Person类中此时有两个属性：Name、Id    // 不可以无损的转换到int或string，因此需要显式类型转换    class Person    &#123;        static int id;        public string Name &#123; get; set; &#125;//姓名        public int uid &#123; get; private set; &#125;//序列号        public Person(string name)        &#123;            id++;            Name = name;            uid = id;        &#125;        public static explicit operator string(Person p)        &#123;            return p.Name;        &#125;        public static explicit operator int(Person p)        &#123;            return p.uid;        &#125;    &#125;&#125;



反向隐式类型转换整个过程也可以反过来，用一个string类型的变量隐式的转换成Person类型的对象。
using System;namespace ConsoleApp&#123;     class Program    &#123;        static void Main(string[] args)        &#123;            string str = &quot;张三&quot;;            Person p = str;            Console.WriteLine(p.uid);            Console.WriteLine(p.Name);            Console.ReadKey();        &#125;    &#125;    // 自定义的反向隐式类型转换    class Person    &#123;        static int id;        public string Name &#123; get; set; &#125;//姓名        public int uid &#123; get; private set; &#125;//序列号        public Person(string name)        &#123;            id++;            Name = name;            uid = id;        &#125;        public static implicit operator Person(string name)        &#123;            return new Person(name);        &#125;    &#125;&#125;

反向显式类型转换既然可以反向隐式类型转换，那么就可以反向的显式类型转换。
using System;namespace ConsoleApp&#123;     class Program    &#123;        static void Main(string[] args)        &#123;            string str = &quot;张三&quot;;            Person p = (Person)str;            Console.WriteLine(p.uid);            Console.WriteLine(p.Name);            Console.ReadKey();        &#125;    &#125;    // 自定义的反向隐式类型转换    class Person    &#123;        static int id;        public string Name &#123; get; set; &#125;//姓名        public int uid &#123; get; private set; &#125;//序列号        public Person(string name)        &#123;            id++;            Name = name;            uid = id;        &#125;        public static explicit operator Person(string name)        &#123;            return new Person(name);        &#125;    &#125;&#125;





自定义类型转换的注意事项
一般情况下，隐式转换运算符应当从不引发异常并且从不丢失信息，以便可以在程序员不知晓的情况下安全使用它们。 如果转换运算符不能满足那些条件，则应将其标记为 explicit（显示类型转换）。
如果定义了隐式类型转换，则使用显式类型转换的语法也可以通过编译。

声明operator 关键字用于在类或结构声明中声明运算符。运算符声明可以采用下列四种形式之一：

public static result-type operator unary-operator ( op-type operand )
public static result-type operator binary-operator ( op-type operand, op-type2 operand2 )
public static implicit operator conv-type-out ( conv-type-in operand )
public static explicit operator conv-type-out ( conv-type-in operand )

 参数说明：
　　result-type：运算符的结果类型。　　unary-operator：下列运算符之一：+ - ! ~ ++ — true false　　op-type：第一个（或唯一一个）参数的类型。　　operand：第一个（或唯一一个）参数的名称。　　binary-operator：其中一个：+ - * &#x2F; % &amp; | ^ &lt;&lt; &gt;&gt; &#x3D;&#x3D; !&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D;　　op-type2：第二个参数的类型。　　operand2：第二个参数的名称。　　conv-type-out：类型转换运算符的目标类型。　　conv-type-in：类型转换运算符的输入类型。
注意

运算符重载的声明方式：operator 关键字告诉编译器，它实际上是一个运算符重载，后面是相关运算符的符号。
运算符只能采用值参数，不能采用ref或out参数。可参考注意事项一实例。
前两种形式声明了用户定义的重载内置运算符的运算符。op-type 和 op-type2 中至少有一个必须是封闭类型（即运算符所属的类型，或理解为自定义的类型）。例如，这将防止重定义整数加法运算符。可参考注意事项二实例。
后两种形式声明了转换运算符。conv-type-in 和 conv-type-out 中正好有一个必须是封闭类型（即转换运算符只能从它的封闭类型转换为其他某个类型，或从其他某个类型转换为它的封闭类型）。
对于二元运算符，第一个参数是放在运算符左边的值，一般命名为lhs；第二个参数是放在运算符右边的值，一般命名为rhs。
C#要求所有的运算符重载都声明为public和static，必须是类的静态方法，这表示它们与它们的类或结构相关联，而不是与实例相关联。

样例using System;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Number n = new(-1);            Console.WriteLine(n);// -1            Number n2 = + n;//            Console.WriteLine(n2);// 1            n = -n2;            Console.WriteLine(n);// -1            n++;            Console.WriteLine(n);//0            Console.ReadKey();        &#125;    &#125;    // 自定义的反向隐式类型转换    class Number    &#123;        public int Value &#123; get; set; &#125;        public Number(int value)        &#123;            Value = value;        &#125;        public static implicit operator string(Number n)        &#123;            return n.Value.ToString();        &#125;        //重载-符号 使得值强制取反        public static Number operator -(Number n)        &#123;            n.Value = n.Value * -1;            return n;        &#125;        //重载-符号 使得值强制为正数        public static Number operator +(Number n)        &#123;            if(n.Value &lt; 0)            &#123;                positive(n);            &#125;            return n;        &#125;         // 重载++        public static Number operator ++ (Number n)        &#123;            n.Value++;            return n;        &#125;        //辅助函数        private static Number positive(Number n)        &#123;            n.Value = n.Value * -1;            return n;        &#125;    &#125;&#125;




动态多态性C# 允许使用关键字 abstract 创建抽象类，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。抽象类包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。
请注意，下面是有关抽象类的一些规则：

您不能创建一个抽象类的实例。
您不能在一个抽象类外部声明一个抽象方法。
通过在类定义前面放置关键字 sealed，可以将类声明为密封类。当一个类被声明为 sealed 时，它不能被继承。抽象类不能被声明为 sealed。

抽象类​	抽象类指的是函数成员没有被完全实现的类。（有至少一个函数成员没被实现）
​	反过来，如果一个类的成员全部都实现了，就是具体类。
​	在抽象类中，没被实现的成员一定要用abstract关键字修饰，而且这个成员不能是private类型。因为私有类型不允许被重写，因此将无法将抽象类转变为具体类。
​	换句话说，一旦一个成员被abstract修饰，就就不能实现。
​	同时，抽象类也必须要用abstract进行修饰。
​	抽象类不允许被实例化，只能被继承或声明变量引用一个子类实例。
​	当抽象类作为变量引用子类实例时，通过抽象类调用的是子类的方法而不是父类的方法。
​	当子类实现父类的抽象方法时，子类成员需要加上override关键字
​	抽象方法在某些语言中也被称为纯虚方法。
​	当一个类没有任何实现的方法，全是抽象成员，在Java、C#中本质上就已经是接口了
样例using System;using System.Windows.Forms;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            //A a = new A();//一旦一个类是抽象类了，则这个类就不能实例化成对象            A c = new C();//但可以作为变量接收子类的实例.	当抽象类作为变量引用子类实例时，通过抽象类调用的是子类的方法而不是父类的方法。            B b = new B();            c.ShowClassName();   //this is C            b.ShowClassName();   //this is B            c.Show();            //A 的 show被执行//不影响父类中已有的类            Console.ReadKey();        &#125;    &#125;    abstract class A//同时类名也需要加上abstract关键字    &#123;        abstract public void ShowClassName();//当一个类需要多次被子类修改，且在父类中没有实现的必要，就可以使用抽象。关键字abstract        public void Show()        &#123;            Console.WriteLine(&quot;A 的 show被执行&quot;);        &#125;    &#125;    class B : A    &#123;        public override void ShowClassName()//当子类实现父类的抽象方法时，子类成员需要加上`override`关键字。        &#123;            Console.WriteLine(&quot;this is B&quot;);        &#125;        public void Show()        &#123;            Console.WriteLine(&quot;B 的 show被执行&quot;);        &#125;    &#125;    class C : A    &#123;        public override void ShowClassName()        &#123;            Console.WriteLine(&quot;this is C&quot;);        &#125;        public void Show()        &#123;            Console.WriteLine(&quot;C 的 show被执行&quot;);        &#125;    &#125;&#125;



接口
一个纯抽象类的本质就是接口。接口是由抽象类进化而来。

进化过程：

接口中的抽象方法不需要abstract修饰
抽象类中的方法不允许是private，但接口中的抽象方法必须是public（不允许有修饰符，强制public）
注意：接口的默认访问修饰符是internal，接口的成员才是public！！！！！




接口的产生：自底向上（重构），自顶向下（设计）

自顶向下一般适用于非常了解技术、业务逻辑的人。

自底向下一般在重构代码的时候使用。



与抽象类一样 也不允许实例化，但一样允许作为接口接收子类的实例。当通过接口调用子类的成员时，会调用最先实现这个成员的类所在的数据  

定义与抽象类类似，类的关键字由abstract关键字替换为interface。

接口要求内部所有成员的访问权限均是public。

声明接口类时默认就是public
里面的成员也不需要额外的声明，只需要返回值、方法名、参数列表这些基本元素即可。


当一个类没有实现接口的所有方法时，此时这个类就转换为了抽象类，要遵循抽象类的约束。类前面加上abstract

接口的命名：不成文的约定：以i开头，加上一个名词。

接口即契约：甲方“我不会多要”；乙方“我不会少给”。

乙方不会少给：硬性规定，即一个类只要实现了接口，就必需实现接口里面的所有方法，一旦未全部实现，类就还只是个抽象类，就不能实例化
甲方不会多要：软性规定，是个设计问题


接口还保证调用者去调用这些功能的时候都是实现好的，只需要关注功能，不需要关注功能是谁提供的。

在代码中 只要有可以替换的地方，就一定会有接口的存在。

接口就是为了解耦而生。

松耦合它最大的好处就是可以让这个功能的提供方变得可替换，从而降低紧耦合的时候功能的提供方不能被替换所带来的这个高风险和高成本

使用接口替换调实例变量时，只能调用接口内约定的方法。


接口隔离：显式接口实现使用接口替换调实例变量时，只能调用接口内约定的方法。
using System;using System.Collections;using System.Runtime.Remoting.Messaging;using System.Windows.Controls;using System.Windows.Forms;using System.Xml.Linq;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            IA a = new A();            IB b = new A();            a.A();//由于接口是显式实现，因此只能调用接口中约定的方法            //a.B();            b.B();//b也一样            Console.ReadKey();        &#125;    &#125;    interface IA    &#123;        void A();    &#125;    interface IB    &#123;        void B();    &#125;    class A : IA, IB    &#123;        void IA.A()//接口的显式实现        &#123;            Console.WriteLine(&quot;A方法&quot;);        &#125;        void IB.B()        &#123;            Console.WriteLine(&quot;B方法&quot;);        &#125;    &#125;    //一个接口，    public interface ICustomer    &#123;        void SomeMethod();    &#125;    //隐式实现接口,代码大致如下    public class Customer1 : ICustomer    &#123;        public void SomeMethod()        &#123;            throw new NotImplementedException();        &#125;    &#125;    //显式实现接口，代码大致如下    public class Customer2 : ICustomer    &#123;        void ICustomer.SomeMethod()//        &#123;            throw new NotImplementedException();        &#125;    &#125;&#125;



样例using System;using System.Windows.Forms;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            A a = new C();            a.ShowClassName();           //this is B    //当通过接口调用子类的成员时，会调用最先实现这个成员的类所在的数据            a.test();                    //C test                   Console.ReadKey();        &#125;    &#125;    interface A//声明接口只需要interface 接口名  即可。    &#123;        void ShowClassName();//内部的成员只需要返回值 方法名 参数列表，不需要其他的声明标识符        void test();            &#125;    abstract class B : A//当一个类没有实现接口的所有方法时，此时这个类就转换为了抽象类，要遵循抽象类的约束。类前面加上abstract    &#123;        public void ShowClassName()//当实现接口的时候，没必要加上override，直接按照正常的格式书写方法即可。        &#123;                                                                                  Console.WriteLine(&quot;this is B&quot;);        &#125;       abstract public void test();//同时作为抽象方法抛给别的类    &#125;    class C : B    &#123;        public void ShowClassName()//当实现接口的时候，没必要加上override，直接按照正常的格式书写方法即可。        &#123;            Console.WriteLine(&quot;this is B&quot;);        &#125;        public override void test()//实现的时候也需要按照抽象类的约束 加上override。        &#123;            Console.WriteLine(&quot;C test&quot;);        &#125;    &#125;&#125;



样例：实现对数组的求平均和求和。using System;using System.Collections;using System.Windows.Controls;using System.Windows.Forms;using System.Xml.Linq;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            //要求：对下面两个序列求平均和求和。            int[] arr1 = &#123; 1, 2, 3, 4, 5 &#125;;            ArrayList arr2 = new ArrayList &#123; 1, 2, 3, 4, 5 &#125;;            Console.WriteLine($&quot;OldTools arr1 和：&#123;OldTools.Sum(arr1)&#125;\t平均：&#123;OldTools.Avg(arr1)&#125;&quot;);            Console.WriteLine($&quot;OldTools arr2 和：&#123;OldTools.Sum(arr2)&#125;\t平均：&#123;OldTools.Avg(arr2)&#125;&quot;);            Console.WriteLine($&quot;NewTools arr1 和：&#123;NewTools.Sum(arr1)&#125;\t平均：&#123;NewTools.Avg(arr1)&#125;&quot;);            Console.WriteLine($&quot;NewTools arr2 和：&#123;NewTools.Sum(arr2)&#125;\t平均：&#123;NewTools.Avg(arr2)&#125;&quot;);            Console.ReadKey();        &#125;    &#125;    //传统的方法：    static class OldTools    &#123;        //求和        static public int Sum(int[] arr )        &#123;            int sum = 0;            foreach(var item in arr)            &#123;                sum += item;            &#125;            return sum;        &#125;        //求平均        static public double Avg(int[] arr)        &#123;            int sum = 0;            double count = 0;            foreach(var item in arr)            &#123;                sum += item;                count++;            &#125;            return sum / count;        &#125;        //求和        static public int Sum(ArrayList arr)        &#123;            int sum = 0;            foreach (var item in arr)            &#123;                sum += (int)item;            &#125;            return sum;        &#125;        //求平均        static public double Avg(ArrayList arr)        &#123;            int sum = 0;            double count = 0;            foreach (var item in arr)            &#123;                sum += (int)item;                count++;            &#125;            return sum / count;        &#125;    &#125;    static class NewTools    &#123;        //可以发现，主体部分都是foreach，foreach的本质是迭代，也就是实现了IEnumerable接口的类型都可以被迭代。        //因此 可以做一下修改，使用接口来接受子类的实例，可以大幅的降低代码重复        //求和        static public int Sum(IEnumerable arr)        &#123;            int sum = 0;            foreach (var item in arr)            &#123;                sum += (int)item;            &#125;            return sum;        &#125;        //求平均        static public double Avg(IEnumerable arr)        &#123;            int sum = 0;            double count = 0;            foreach (var item in arr)            &#123;                sum += (int)item;                count++;            &#125;            return sum / count;        &#125;    &#125;&#125;

样例：解决紧耦合:引入接口using System;using System.Collections;using System.Runtime.Remoting.Messaging;using System.Windows.Controls;using System.Windows.Forms;using System.Xml.Linq;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            NokiaPhone phone1 = new NokiaPhone();             PhoneUser user = new PhoneUser(phone1);//给用户一个诺基亚的手机            user.UserPhone();//用户使用手机            Console.WriteLine(&quot;\n\n用户更换手机了\n\n&quot;);            EricssonPhone phone2 = new EricssonPhone();            user.phone = phone2;            user.UserPhone();            Console.ReadKey();        &#125;    &#125;    //用户    class PhoneUser    &#123;        public IPhone phone &#123; set; get; &#125;//不再具体是某一款具体类型        public PhoneUser(IPhone phone)        &#123;            this.phone = phone;        &#125;        public void UserPhone()        &#123;            phone.Dail();            phone.Send();            phone.Receive();            phone.Pickup();        &#125;    &#125;    interface IPhone    &#123;        void Dail();//拨号        void Pickup();//接电话        void Send();//发短信        void Receive();//收短信    &#125;    class NokiaPhone : IPhone    &#123;        public void Dail()        &#123;            Console.WriteLine(&quot;使用诺基亚打电话&quot;);        &#125;        public void Pickup()        &#123;            Console.WriteLine(&quot;使用诺基亚接电话&quot;);        &#125;        public void Receive()        &#123;            Console.WriteLine(&quot;使用诺基亚发短息&quot;);        &#125;        public void Send()        &#123;            Console.WriteLine(&quot;使用诺基亚收短信&quot;);        &#125;    &#125;    class EricssonPhone : IPhone     &#123;        public void Dail()        &#123;            Console.WriteLine(&quot;使用爱立信打电话&quot;);        &#125;        public void Pickup()        &#123;            Console.WriteLine(&quot;使用爱立信接电话&quot;);        &#125;        public void Receive()        &#123;            Console.WriteLine(&quot;使用爱立信发短息&quot;);        &#125;        public void Send()        &#123;            Console.WriteLine(&quot;使用爱立信收短信&quot;);        &#125;    &#125;&#125;





接口和抽象类的概述
接口和抽象类都是软件工程的产物

具体类 -&gt; 抽象类 -&gt; 接口：越来越抽象，内部实现的东西越来越少

对于方法成员，方法体就是它的实现
对于数据成员，字段就是实现


抽象类是未完全实现逻辑的类(可以有字段和public成员，它们代表了“具体逻辑”)

接口是完全未实现。


抽象类为复用而生:专门作为基类来使用，也具有解耦功龍

封装确定的，开放不确定的，推迟到合适的子类中去实现。

就是开闭原则


接口是完全未实现逻辑的“类”(“纯虚类”:只有函数成员:成员全部public)

接口为解耦而生:“高内聚，低耦合”，方便单元测试

接口是一个“协约”，早已为工业生产所熟知(有分工必有协作，有协作必有协约)

它们都不能实例化。只能用来声明变量、引用具体类(concrete class)的实例

因为有完成的成员


依赖越直接 耦合就越紧。

需要注意：当使用接口接口实现两个类的解耦合的时候，实际上是把紧耦合的关系转嫁给了接口也就是说，当类实现一个接口的时候，类与接口之间的关系也是“紧耦合”的。


依赖反转（倒置）单元测试：依赖反转（依赖倒置）在开发中的直接应用和直接受益者。
自顶向下 逐步求精。

可以看到，图片中右侧有效的改善了依赖。
所谓的依赖倒置，就是由原本的司机直接指向类，变成类指向一个接口，然后再用另一个类去调用这个接口的方法（IVehicle）。
再次进化：

DriverBase派生出了两个子类：Driver、AiDriver。当需要这两个类调用Car、Truck类的时候，只需要通过IVehicle字段调用自己的run方法即可。
这样以来，Driver可以驱动Car和Truck，AiDriver也可以驱动这两个类。
单元测试（使用依赖倒置）（需完善）对DeskFan进行测试，如果直接修改Power电压 可能会造成其他使用这个Power的类损毁（出bug）。
using System;using System.Collections;using System.Runtime.Remoting.Messaging;using System.Windows.Controls;using System.Windows.Forms;using System.Xml.Linq;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            DeskFan fan = new DeskFan(new PowerSupply());//创建一个电扇，并给电扇配一个电源            Console.WriteLine(fan.Work()); //输出风扇的工作状态            Console.ReadKey();        &#125;    &#125;    class PowerSupply    &#123;        public int GetPower()//想要测试的话 只能修改程序里面的值。当程序创建完成后 不可以轻易修改。        &#123;            return 100;//标准电源 输出100        &#125;    &#125;    class DeskFan    &#123;        private PowerSupply powerSupply;        public DeskFan(PowerSupply powerSupply)        &#123;            this.powerSupply = powerSupply;        &#125;        public string Work()        &#123;            int power = powerSupply.GetPower();            if(power &lt;= 0)            &#123;                return &quot;不工作&quot;;            &#125;            else if(power &lt; 100)             &#123;                return &quot;Slow&quot;;            &#125;            else if(power &lt; 200)            &#123;                return &quot;Fast&quot;;            &#125;            else            &#123;                return &quot;电压过高&quot;;            &#125;        &#125;    &#125;&#125;

进行自底向上的解耦重构并进行单元测试。
一般测试的时候，新建一个测试项目而不是在原先的项目上测试。






显示类型实现
反射反射并不是C#的功能，而是.Net框架的功能。换句话说就是，只要有.Net框架的地方，都可以实现反射。
反射：以不变应万变
依赖注入虚方法对于用父类对象调用子类方法的时候，会从父类开始，向子类搜索第一个能被调用的方法。如果从父类到最终子类的途中存在已经实现了的方法，就直接调用这个方法。如果强制调用子类方法，则需要手动将父类转换成对应子类后调用。
using System;using System.Collections;using System.ComponentModel;using System.IO;using System.Text;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            A a = new C();            a.Say();        &#125;    &#125;    abstract class A    &#123;        public abstract void Say();    &#125;    class B : A    &#123;        public override void Say()        &#123;            Console.WriteLine(&quot;B&quot;);        &#125;    &#125;    class C : B    &#123;        public void Say()        &#123;            Console.WriteLine(&quot;C&quot;);        &#125;    &#125;&#125;



c#设计原则
单一职责原则（Single Responsibility Principle）；
开闭原则（Open Closed Principle）；
里氏替换原则（Liskov Substitution Principle）；
迪米特法则（Law of Demeter），又叫“最少知道法则”；
接口隔离原则（Interface Segregation Principle）；
依赖倒置原则（Dependence Inversion Principle）。

6 个原则结合使用的好处：建立稳定、灵活、健壮的设计。
单一职责原则单一职责原则的定义是：应该有且仅有一个原因引起类的变更。
举个例子。
我们以打电话为例，电话通话的时候有 4 个过程发生：拨号、通话、回应、挂机。那我们写一个接口，类图如下：

interface IPhone&#123;    //接电话    void dial(string phoneNumber);    //通话    void chat(object o);    //挂电话    void hangup();&#125;

​	IPhone这个接口包含了两个职责：协议管理和数据传送。dial 和 hangup 这两个方法实现的是协议管理，分别负责拨号接通和挂机，chat 方法实现的是数据传送。不管是协议接通的变化还是输出传送的变化，都会引起这个接口的变化。所以，IPhone这个接口并不符合单一职责原则。若要让IPhone满足单一职责原则，我们就要对其进行拆分，拆分后的类图如下：

​	这样设计就完美了，一个类实现了两个接口，把两个职责融合在一个类中。你会觉得这个Phone有两个原因引起变化了啊，是的，但是别忘了我们是面向接口编程，我们对外公布的是接口而不是实现类。
​	另外，单一职责原则不仅适用于接口和类，也适用于方法。一个方法尽可能只做一件事，比如一个修改用户密码的方法，不要把这个方法放到“修改用户信息”方法中。
单一职责的好处
类的复杂性降低，实现什么职责都有清晰明确的定义；
可读性高，复杂性降低，可读性自然就提高了；
可维护性提高，可读性提高了，那自然更容易维护了；
变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。

里氏替换原则​	在面向对象的语言中，继承是必不可少的、非常优秀的语言机制，它有如下优点：

代码共享，减少创建类的工作量，每个子类都拥有父类的属性和方法；
提高代码的重用性；
子类可以形似父类，但又异于父类；
提高代码的可扩展性；
提高产品或项目的开放性。

有优点就必然存在缺点：

继承是侵入性的。只要继承，就必须拥有父类的属性和方法。
降低代码的灵活性。子类会多一些父类的约束。
增强了耦合性。当父类的常量、变量、方法被修改时，需要考虑子类的修改。

​	为了让“利”的因素发挥最大的作用，同时减少“弊”带来的麻烦，引入了里氏替换原则（LSP）。
历史替换原则最正宗的定义是：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代替o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。
通俗点讲，就是只要父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常。
里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义。

子类必须完全实现父类的方法。

我们在做系统设计的时候，经常会定义一个接口或抽象类，然后编码实现，调用类则直接传入接口或抽象类，其实这里就已经使用了里氏替换原则。我们以打CS举例，来描述一下里面用到的枪。类图如下：



枪的主要职责是射击，如何射击在各个具体的子类中实现，在士兵类Soldier中定义了一个方法 killEnemy，使用枪来kill敌人，具体用什么枪，调用的时候才知道。

**注意：**在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。

实现代码：

using System;
using System.Windows.Forms;

namespace ConsoleApp
{
    //internal class Program
    //{
    //    static void Main(string[] args)
    //    {
    //        A a = new C();
    //        a.ShowClassName();           //this is B    //当通过接口调用子类的成员时，会调用最先实现这个成员的类所在的数据
    //        a.test();                    //C test       


    //        Console.ReadKey();
    //    }
    //}

    //枪的抽象类
    public abstract class AbstractGun
    {
        //射击方法
        public abstract void shoot();
    }

    //手枪、步枪、机枪的实现代码
    //手枪：
    public class HandGun : AbstractGun
    {
        //射击方法
        public override void shoot()
        {
            Console.WriteLine(&quot;手枪射击了&quot;);
        }
    }
    //步枪
    public class Rifle : AbstractGun
    {
        public override void shoot()
        {
            Console.WriteLine(&quot;步枪射击了&quot;);
        }
    }
    //机枪
    public class MachineGun : AbstractGun
    {
        public override void shoot()
        {
            Console.WriteLine(&quot;机枪射击了&quot;);
        }
    }


    //士兵的源码
    public class Soldier
    {
        private AbstractGun gun;

        public Soldier(AbstractGun gun)
        {
            this.gun = gun;
        }

        //士兵开始射击
        public void killEnemy()
        {
            Console.WriteLine(&quot;士兵开始杀戮&quot;);
            this.gun.shoot();//开枪
        }
    }



    //客户端源码
    public class Client
    {
        public static void Main(string[] args)
        {
            //创建一个士兵的对象，并给他一把手枪
            Soldier soldier1 =  new Soldier(new HandGun());
            
            //士兵射击
            soldier1.killEnemy();

            //再次创建一个士兵，这次给他一把机枪
            Soldier soldier2 = new Soldier(new MachineGun());
            soldier2.killEnemy();//士兵2也射击

            //执行结果
            //士兵开始杀戮
            //手枪射击了
            //士兵开始杀戮
            //机枪射击了

            //可以看到，里氏替换原则的特性：父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常。

            Console.ReadKey();
        }
    }
}
2. 孩子类可以有自己的个性。   1. 孩子类当然可以有自己的属性和方法了，也正因如此，在子类出现的地方，父类未必就可以代替。   2. 还是以上面的关于枪支的例子为例，步枪有 AK47、SKS狙击步枪等型号，把这两个型号的枪引入后的Rifle的子类图如下：   3. ![image-20230307081242661](./Image/C#学习笔记_基础教程.assets/image-20230307081242661.png)   4. SKS狙击步枪可以配一个8倍镜进行远程瞄准，相对于父类步枪，这就是SKS的个性。源码如下：   5. ```c#      using System;      using System.Windows.Forms;            namespace ConsoleApp      &#123;          //internal class Program          //&#123;          //    static void Main(string[] args)          //    &#123;          //        A a = new C();          //        a.ShowClassName();           //this is B    //当通过接口调用子类的成员时，会调用最先实现这个成员的类所在的数据          //        a.test();                    //C test                             //        Console.ReadKey();          //    &#125;          //&#125;                //枪的抽象类          public abstract class AbstractGun          &#123;              //射击方法              public abstract void shoot();          &#125;                //手枪、步枪、机枪的实现代码          //手枪：          public class HandGun : AbstractGun          &#123;              //射击方法              public override void shoot()              &#123;                  Console.WriteLine(&quot;手枪射击了&quot;);              &#125;          &#125;          //步枪          public class Rifle : AbstractGun          &#123;              public override void shoot()              &#123;                  Console.WriteLine(&quot;步枪射击了&quot;);              &#125;          &#125;          //机枪          public class MachineGun : AbstractGun          &#123;              public override void shoot()              &#123;                  Console.WriteLine(&quot;机枪射击了&quot;);              &#125;          &#125;                      //士兵的源码          public class Soldier          &#123;              private AbstractGun gun;                    public Soldier(AbstractGun gun)              &#123;                  this.gun = gun;              &#125;                    //士兵开始射击              public void killEnemy()              &#123;                  Console.WriteLine(&quot;士兵开始杀戮&quot;);                  this.gun.shoot();//开枪              &#125;          &#125;                            //客户端源码          public class Client          &#123;              public static void Main(string[] args)              &#123;                  //创建一个狙击手的对象，并给他一把狙击枪                  Spinner spinner = new Spinner();                  spinner.setSks(new SKS());                  spinner.killEnemy();                  //输出结果                  //使用8倍镜进行瞄准                  //SKS射击                        Console.ReadKey();              &#125;          &#125;                //sks          public class SKS : Rifle          &#123;              //配一个8倍镜              public void zoomOut()              &#123;                  Console.WriteLine(&quot;使用8倍镜进行瞄准&quot;);              &#125;              public void shoot()              &#123;                  Console.WriteLine(&quot;SKS射击&quot;);              &#125;          &#125;                //狙击手          public class Spinner          &#123;              private SKS sks;                            public void setSks(SKS sks)              &#123;                  this.sks = sks;              &#125;                    public void killEnemy()              &#123;                  //先瞄准后开枪                  sks.zoomOut();                  sks.shoot();              &#125;          &#125;            &#125;






覆盖或实现父类的方法时，输入参数可以被放大。

即方法的重载


覆盖或实现父类的方法时，输出结果可以被缩小。

父类的一个方法的返回值是类型T，子类的相同方法（重载或重写）的返回值为类型S，那么里氏替换原则就要求S必须小于等于T。为什么呢？因为重写父类方法，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这时重写父类方法的要求。



依赖倒置原则
模块间的依赖通过抽象发生，实现类之间不直接发生依赖关系，其依赖关系是通过接口或抽象类产生的；
接口或抽象类不依赖于实现类；
实现类依赖接口或抽象类。

说白了，就是“面向接口编程”。
依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。
以汽车和司机举例，画出类图：

//奔驰车public class Benz&#123;    public void run()    &#123;        Console.WriteLine(&quot;奔驰车开始运行&quot;);    &#125;&#125;//司机public class Driver&#123;    public void driver(Benz benz)    &#123;        benz.run();    &#125;&#125;//客户端public class Client&#123;    public static void main(string[] args)    &#123;        Driver driver = new Driver();        driver.driver(new Benz());    &#125;&#125;

​	由于司机现在只有开奔驰的方法，所以他是开不了宝马的。一个拿有C驾照的司机能开奔驰，不能开宝马？太不合理了。所以，这就暴露出上面的设计问题了。我们对上面的功能重新设计，首先新建两个接口。
//汽车接口ICar：    interface ICar    &#123;        void run();    &#125;    //司机接口IDriver：    interface IDriver    &#123;        void driver(ICar car);    &#125;    //IDriver中，通过传入ICar接口实现了抽象之间的依赖关系。    //汽车实现类：奔驰和宝马。    public class Benz : ICar    &#123;        public void run()        &#123;            Console.WriteLine(&quot;奔驰车开始运行&quot;);        &#125;    &#125;    public class BWM : ICar    &#123;        public void run()        &#123;            Console.WriteLine(&quot;宝马车开始运行&quot;);        &#125;    &#125;    //创建司机实现类：    public class Driver : IDriver    &#123;        void IDriver.driver(ICar car)        &#123;            car.run();//开车        &#125;    &#125;    //客户端    public class Client    &#123;        public static void Main(string[] args)        &#123;            IDriver driver = new Driver();            ICar car = new Benz();            driver.driver(car);//司机开奔驰            car = new BWM();            driver.driver(car);//司机开宝马            //如果还有别的车，直接new别的车就行            //Client属于高层业务逻辑，它对低层模块的依赖都建立在抽象上，driver的表面类型是IDriver，benz的表面类型是ICar。        &#125;    &#125;

依赖倒置原则的使用建议：
每个类尽量都有接口或抽象类，或者接口和抽象类两者都具备。
变量的表面类型尽量是接口或抽象类。
任何类都不应该从具体类派生。
尽量不要重写基类的方法。如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要重写。
结合里氏替换原则使用。

接口隔离原则接口隔离原则的定义
Clients should not be forced to depend upon interfaces that they don’t use.客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。


The dependency of one class to another one should depend on the smallest possible interface.类间的依赖关系应建立在最小的接口上。

也就是说: 接口尽量细化，接口中的方法尽量少。
接口隔离原则和单一职责原则从功能上来看，接口隔离原则和单一职责原则都是为了提高类的内聚, 降低类之间的耦合, 体现了封装的思想。但二者还是有区别的。
（1）从原则约束来看: 接口隔离原则更关注的是接口依赖程度的隔离；而单一职责原则更加注重的是接口职责的划分。
（2）从接口的细化程度来看: 单一职责原则对接口的划分更加精细，而接口隔离原则注重的是相同功能的接口的隔离。接口隔离里面的最小接口有时可以是多个单一职责的公共接口。
（3）单一职责原则更加偏向对业务的约束: 接口隔离原则更加偏向设计架构的约束。这个应该好理解，职责是根据业务功能来划分的，所以单一原则更加偏向业务；而接口隔离更多是为了“高内聚”，偏向架构的设计。
​	接口隔离原则就是客户端不应该依赖它不需要的接口，或者说类间的依赖关系应该建立在最小的接口上。
​	以搜索美女为例，设计了如下的类图：

//美女及其实现类：interface IPettyGirl&#123;    //高颜值    void goodLooking();    //好身材    void niceBody();    //有气质    void greatTemperament();&#125;public class PettyGril : IPettyGirl&#123;    private string name;    public PettyGril(string name)    &#123;        this.name = name;    &#125;    //高颜值    void IPettyGirl.goodLooking()    &#123;        Console.WriteLine($&quot;&#123;this.name&#125; 颜值很高 &quot;);    &#125;    //好身材    void IPettyGirl.niceBody()    &#123;        Console.WriteLine($&quot;&#123;this.name&#125; 身材很好&quot;);    &#125;    //有气质    void IPettyGirl.greatTemperament()    &#123;        Console.WriteLine($&quot;&#123;this.name&#125; 气质出众&quot;);    &#125;&#125;//搜索程序及其子类源代码如下：abstract class AbstractSearcher&#123;    protected IPettyGirl gril;    public AbstractSearcher(IPettyGirl gril)    &#123;        this.gril = gril;    &#125;    //输出美女信息    public abstract void show();&#125; class Searcher : AbstractSearcher&#123;    public Searcher(IPettyGirl girl):base(girl)//调用父类的构造函数    &#123;            &#125;    public override void show()//实现抽象方法    &#123;        Console.WriteLine(&quot;美女信息如下：&quot;);        base.gril.goodLooking();        base.gril.niceBody();        base.gril.greatTemperament();    &#125;&#125;//场景调用类public class Client&#123;    public static void Main(string[] args)    &#123;        IPettyGirl aa = new PettyGril(&quot;aa&quot;);        AbstractSearcher searcher = new Searcher(aa);        searcher.show();    &#125;&#125;/*输出： * 美女信息如下：    aa 颜值很高    aa 身材很好    aa 气质出众  */

IPettyGirl接口是否做到了最优化？并没有。
每个人的审美观不一样，张三认为颜值高就是美女，即使身材和气质一般；李四认为身材好就行，不在乎颜值和气质；而王五则认为颜值和身材都是外在，只要有气质，那就是美女。这时，IPettyGirl接口就满足不了了，因为IPettyGirl的要求是颜值、身材、气质兼具才是美女。所以为了满足各种人的口味，我们需要重新设计接口的结构。把IPettyGirl拆分为3个接口，分别表示颜值高、身材好、气质佳。修改后的类图如下：

c#异常处理非中断（正常）模式下的调试
输出调试信息
Debug.WriteLine()
Trace.WriteLine()

这两个命令用法几乎相同，区别在于：第一个命令仅在调试模式下运行，而第二个命令还可用于发布程序。实际上Debug.Write甚至不能编译到可发布的程序中，在发布版本中，该命令会消失，可以减小文件体积。
这两个方法都包含在System.Diangnostics名称空间中。using static只能用于静态类，比如System.Console，因此该指令不能用在- Debug.WriteLine()、Trace.WriteLine()函数中。
​	异常是在程序执行期间出现的问题。C# 中的异常是对程序运行时出现的特殊情况的一种响应，比如尝试除以零。
​	异常提供了一种把程序控制权从某个部分转移到另一个部分的方式。C# 异常处理时建立在四个关键词之上的：try、catch、finally 和 throw。

try：一个 try 块标识了一个将被激活的特定的异常的代码块。后跟一个或多个 catch 块。
catch：程序通过异常处理程序捕获异常。catch 关键字表示异常的捕获。
finally：finally 块用于执行给定的语句，不管异常是否被抛出都会执行。例如，如果您打开一个文件，不管是否出现异常文件都要被关闭。
throw：当问题出现时，程序抛出一个异常。使用 throw 关键字来完成。

基本语法详见 C#基本语句 - try语句。
C# 中的异常类C# 异常是使用类来表示的。C# 中的异常类主要是直接或间接地派生于 System.Exception 类。System.ApplicationException 和 System.SystemException 类是派生于 System.Exception 类的异常类。
System.ApplicationException 类支持由应用程序生成的异常。所以程序员定义的异常都应派生自该类。
System.SystemException 类是所有预定义的系统异常的基类。
下表列出了一些派生自 System.SystemException 类的预定义的异常类：



异常类
描述



System.IO.IOException
处理 I&#x2F;O 错误。


System.IndexOutOfRangeException
处理当方法指向超出范围的数组索引时生成的错误。


System.ArrayTypeMismatchException
处理当数组类型不匹配时生成的错误。


System.NullReferenceException
处理当依从一个空对象时生成的错误。


System.DivideByZeroException
处理当除以零时生成的错误。


System.InvalidCastException
处理在类型转换期间生成的错误。


System.OutOfMemoryException
处理空闲内存不足生成的错误。


System.StackOverflowException
处理栈溢出生成的错误。


异常处理​	C# 以 try 和 catch 块的形式提供了一种结构化的异常处理方案。使用这些块，把核心程序语句与错误处理语句分离开。
​	这些错误处理块是使用 try、catch 和 finally 关键字实现的。下面是一个当除以零时抛出异常的实例：
实例using System;namespace ErrorHandlingApplication&#123;    class DivNumbers    &#123;        int result;        DivNumbers()        &#123;            result = 0;        &#125;        public void division(int num1, int num2)        &#123;            try            &#123;                result = num1 / num2;            &#125;            catch (DivideByZeroException e)            &#123;                Console.WriteLine(&quot;Exception caught: &#123;0&#125;&quot;, e);            &#125;            finally            &#123;                Console.WriteLine(&quot;Result: &#123;0&#125;&quot;, result);            &#125;    &#125;    static void Main(string[] args)    &#123;        DivNumbers d = new DivNumbers();        d.division(25, 0);        Console.ReadKey();    &#125;&#125;&#125;

当上面的代码被编译和执行时，它会产生下列结果：
Exception caught: System.DivideByZeroException: Attempted to divide by zero. at ...Result: 0

创建用户自定义异常您也可以定义自己的异常。用户自定义的异常类是派生自 ApplicationException 类。下面的实例演示了这点：
实例using System;namespace UserDefinedException&#123;   class TestTemperature   &#123;      static void Main(string[] args)      &#123;         Temperature temp = new Temperature();         try         &#123;            temp.showTemp();         &#125;         catch(TempIsZeroException e)         &#123;            Console.WriteLine(&quot;TempIsZeroException: &#123;0&#125;&quot;, e.Message);         &#125;         Console.ReadKey();      &#125;   &#125;&#125;public class TempIsZeroException: ApplicationException&#123;   public TempIsZeroException(string message): base(message)   &#123;   &#125;&#125;public class Temperature&#123;   int temperature = 0;   public void showTemp()   &#123;      if(temperature == 0)      &#123;         throw (new TempIsZeroException(&quot;Zero Temperature found&quot;));      &#125;      else      &#123;         Console.WriteLine(&quot;Temperature: &#123;0&#125;&quot;, temperature);      &#125;   &#125;&#125;

当上面的代码被编译和执行时，它会产生下列结果：
TempIsZeroException: Zero Temperature found

抛出对象如果异常是直接或间接派生自 System.Exception 类，您可以抛出一个对象。您可以在 catch 块中使用 throw 语句来抛出当前的对象，如下所示：
catch(Exception e)&#123;   ...   throw e&#125;



c#泛型​	泛型是一种在.NET中引入类型参数的概念，它使得设计类和方法可以推迟一个或多个类型的指定，直到客户端代码声明并实例化类或方法。例如，通过使用泛型类型参数T，您可以编写一个单一的类，其他客户端代码可以使用它而不会产生运行时转换或装箱操作的成本或风险。
​	泛型类和方法结合了可重用性、类型安全性和效率，而它们的非泛型对应物则不能做到这一点。泛型最常用于集合和操作它们的方法。System.Collections.Generic命名空间包含了几个基于泛型的集合类。
​	也可以创建自定义的泛型类型和方法，以提供您自己的类型安全和高效的通用解决方案和设计模式。
使用泛型可空类型值类型区别于引用类型的一个特点是值类型必须包含一个值。
使用可空泛型System.Nullable&lt;T&gt;类提供了使值类型为空的一种方式。
基本语法System.Nullable&lt;类型名&gt; 变量名; // 创建指定类型的可空类型类型名? 变量名;// 两个语句功能相等



使用可空类型时的注意事项
可以使用只读属性Nullable&lt;T&gt;.HasValue和Nullable&lt;T&gt;.Value来检查和获取可空值类型变量的值。
Nullable.HasValue指示可为空值类型的实例是否具有其基础类型的值。
如果HasValue为true，则Nullable.Value获取基础类型的值。如果HasValue为false，则Value属性将抛出InvalidOperationException。


在使用泛型约束时，需要注意多个泛型约束不能以OR方式（更不严格）组合，只能以AND方式（更严格）组合。这意味着一个方法不能同时处理两种情况。泛型约束也不能用于为方法创建唯一签名，因此您需要使用两个单独的方法名称。

例如：
using System;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            // 声明一个变量 nullableInt ，它除了拥有int变量的所有值外，还可以拥有null值。            System.Nullable&lt;int&gt; nullableInt;            nullableInt = null;            if(nullableInt == null)            &#123;                Console.WriteLine(&quot;nullableInt 的值是 null&quot;);            &#125;            // Console.WriteLine(nullableInt.GetType().FullName); // 注意 在值为null的时候，获取不到类型；当值为数值时，类型为int32.            // 同理 也可以存在可空类型的其他值类型 如bool：            // 注意，可空类型的语法可以进行缩写：bool? nullableBool等价于Nullable&lt;bool&gt; nullableBool            bool? nullableBool = null;            if(nullableBool == true)            &#123;                Console.WriteLine(&quot;nullableBool的值是true&quot;);            &#125;            else if(nullableBool == false)            &#123;                Console.WriteLine(&quot;nullableBool的值为false&quot;);            &#125;            else if (nullableBool == null)            &#123;                Console.WriteLine(&quot;nullableBool的值为null&quot;);            &#125;            // 可空类型还有一个属性：HasValue，可以使用这个属性类查看可空类型的变量是否有值            // 如果HasValue值为true，则说明存在非null值，否则值为null。            // 注意 这并不适用于引用类型，即便引用类型也存在一个HasValue的属性。因为引用变量的值为null则表示不存在对象，所有不能通过对象来访问这个属性，不然就会抛出空引用的错误            Console.WriteLine(nullableInt.HasValue);// false            nullableInt = 1;            Console.WriteLine(nullableInt.HasValue);// true            Console.WriteLine(nullableInt.Value);// 1        &#125;    &#125;&#125;



从可空值类型到基础类型的转换如果要将可空值类型的值分配给不可空值类型变量，您可能需要指定要分配的值来代替null. 使用null 合并运算符??来执行此操作（也可以使用Nullable.GetValueOrDefault(T)方法来达到相同目的）：
int? a = 28;int b = a ?? -1;Console.WriteLine($&quot;b is &#123;b&#125;&quot;);  // output: b is 28int? c = null;int d = c ?? -1;Console.WriteLine($&quot;d is &#123;d&#125;&quot;);  // output: d is -1

也可以使用强制类型转换将可空类型强转成普通类型
int a = (int)nullableInt;



?? 空合并运算符在C#中，??运算符被称为空合并运算符。它会返回其左操作数的值（如果不为null）。否则，它会计算右操作数并返回其结果。如果左操作数的值不为null，则??运算符不会计算其右操作数1。
例如，您可以使用以下代码来检查一个可空类型变量是否为null，并在它为null时返回一个默认值：
int? x = null;int y = x ?? -1;

在上面的示例中，由于x的值为null，因此y的值将被设置为-1。
更多信息，详见c#运算符。
可空类型与运算符对于简单类型，可以直接使用原有的运算符。
如果一个或两个操作数是null，则产生null；否则，运算符使用其操作数中包含的值来计算结果。例如：
int? a = 10;int? b = null;int? c = 10;a++;        // a is 11a = a * c;  // a is 110a = a + b;  // a is null



对于比较运算符 &lt;, &gt;, &lt;=, 和&gt;=，如果一个或两个操作数是null，则结果是false；否则，比较操作数包含的值。不要假设因为特定比较（例如&lt;=）返回false，所以相反的比较 ( &gt;) 返回true。下面的例子表明 10 是

既不大于也不等于null
不少于null

int? a = 10;Console.WriteLine($&quot;&#123;a&#125; &gt;= null is &#123;a &gt;= null&#125;&quot;);Console.WriteLine($&quot;&#123;a&#125; &lt; null is &#123;a &lt; null&#125;&quot;);Console.WriteLine($&quot;&#123;a&#125; == null is &#123;a == null&#125;&quot;);// Output:// 10 &gt;= null is False// 10 &lt; null is False// 10 == null is Falseint? b = null;int? c = null;Console.WriteLine($&quot;null &gt;= null is &#123;b &gt;= c&#125;&quot;);Console.WriteLine($&quot;null == null is &#123;b == c&#125;&quot;);// Output:// null &gt;= null is False// null == null is True



注意对于bool?类型，预定义的&amp;和|运算符不遵循本节中描述的规则：运算符评估的结果可以是非空的，即使其中一个操作数是null。有关详细信息，请参阅布尔逻辑运算符一文的可空布尔逻辑运算符部分。
可空类型的装箱和拆箱可空值类型的实例按如下方式T?装箱：
如果HasValue返回false，则生成空引用。如果HasValue返回true，则基础值类型的相应值被装箱，而不是Nullable&lt;T&gt;T的实例。可以将值类型的装箱值取消装箱T为相应的可为空值类型T?，如以下示例所示：
int a = 41;object aBoxed = a;int? aNullable = (int?)aBoxed;Console.WriteLine($&quot;Value of aNullable: &#123;aNullable&#125;&quot;);object aNullableBoxed = aNullable;if (aNullableBoxed is int valueOfA)&#123;    Console.WriteLine($&quot;aNullableBoxed is boxed int: &#123;valueOfA&#125;&quot;);&#125;// Output:// Value of aNullable: 41// aNullableBoxed is boxed int: 41





List&lt;T&gt;List&lt;T&gt;是C#中的一个泛型集合类型，它表示一组强类型对象，可以通过索引访问。它提供了用于创建对象列表、向列表中添加项以及查找、排序和更新列表项的方法1。
List&lt;T&gt;是ArrayList的泛型版本，属于System.Collections.Generic命名空间。与ArrayList不同，List&lt;T&gt;可以包含指定类型的元素，并且由于它是泛型的，因此在编译时进行类型检查，不会执行装箱和拆箱操作。
下面是一个简单的示例，演示如何创建一个List&lt;T&gt;并向其中添加元素：
List&lt;int&gt; numbers = new List&lt;int&gt;();numbers.Add(1);numbers.Add(2);numbers.Add(3);

在上面的示例中，我们创建了一个名为numbers的List&lt;int&gt;，并使用Add方法向其中添加了三个元素。
对泛型列表进行排序和搜索要对List&lt;T&gt;排序，可以在要排序的类型上提供IComparable&lt;T&gt;接口，或者提供IComparer&lt;T&gt;接口。另外，还可以提供泛型委托，作为排序方法。从了解代码工作原理的角度看，这非常有趣，因为实现上述接口并不比实现其非泛型版本更麻烦。
一般情况下，给列表排序需要有一个方法来比较两个T类型的对象。要在列表中搜索，只需要一个方法来检查T类型的对象，看它是否满足某个条件。定义这样的方法很简单，这里给出两个可以使用的泛型委托类型:

Comparison&lt;T&gt;: 这个委托类型用于排序方法，其返回类型和参数如下:

int method(T objectA, T objectB)
- Predicate\&lt;T&gt;: 这个委托类型用于搜索方法，其返回类型和参数如下:  - ```c#    bool method (T targetobject)





可以定义任意多个这样的方法，使用它们实现List&lt;T&gt;的搜索和排序方法。
定义泛型类型定义泛型类泛型类封装不特定于特定数据类型的操作。 泛型类最常见用法是用于链接列表、哈希表、堆栈、队列和树等集合。 无论存储数据的类型如何，添加项和从集合删除项等操作的执行方式基本相同。
对于大多数需要集合类的方案，推荐做法是使用 .NET 类库中提供的集合类。 有关使用这些类的详细信息，请参阅 .NET 中的泛型集合。
通常，创建泛型类是从现有具体类开始，然后每次逐个将类型更改为类型参数，直到泛化和可用性达到最佳平衡。 创建自己的泛型类时，需要考虑以下重要注意事项：
定义方法要创建泛型类，需要在类名后面添加尖括号&lt;&gt;，并在其中指定一个或多个类型参数。类型参数可以在类的定义中用作占位符，表示未知的类型。当客户端代码声明并实例化类时，它将指定类型参数的具体类型。
下面是一个简单的示例，演示如何创建一个泛型类：
public class MyGenericClass&lt;T&gt;&#123;    private T value;    public MyGenericClass(T value)    &#123;        this.value = value;    &#125;    public T GetValue()    &#123;        return value;    &#125;&#125;

在上面的示例中，我们定义了一个名为MyGenericClass&lt;T&gt;的泛型类。该类具有一个名为value的私有字段，其类型为T。我们还定义了一个构造函数和一个名为GetValue的方法，它们都使用了类型参数T。
要使用这个泛型类，您需要在声明并实例化它时指定类型参数的具体类型。例如，您可以使用以下代码创建一个MyGenericClass&lt;int&gt;的实例：
MyGenericClass&lt;int&gt; myInt = new MyGenericClass&lt;int&gt;(10);int value = myInt.GetValue(); // value will be 10

在上面的示例中，我们创建了一个名为myInt的MyGenericClass&lt;int&gt;实例，并使用构造函数将其初始化为10。然后，我们调用了GetValue方法来获取存储在该实例中的值。
其中 上面提到的T可以是任意标识符。但一般只使用T
也可以在定义泛型类时指定多个类型参数。只需在类名后面的尖括号&lt;&gt;中用逗号分隔多个类型参数即可。
下面是一个简单的示例，演示如何创建一个带有两个类型参数的泛型类：
public class MyGenericClass&lt;T1, T2&gt;&#123;    private T1 value1;    private T2 value2;    public MyGenericClass(T1 value1, T2 value2)    &#123;        this.value1 = value1;        this.value2 = value2;    &#125;    public T1 GetValue1()    &#123;        return value1;    &#125;    public T2 GetValue2()    &#123;        return value2;    &#125;&#125;

在上面的示例中，我们定义了一个名为MyGenericClass&lt;T1, T2&gt;的泛型类。该类具有两个私有字段，分别为value1和value2，它们的类型分别为T1和T2。我们还定义了一个构造函数和两个方法，它们都使用了类型参数T1和T2。
要使用这个泛型类，您需要在声明并实例化它时指定类型参数的具体类型。例如，您可以使用以下代码创建一个MyGenericClass&lt;int, string&gt;的实例：
MyGenericClass&lt;int, string&gt; myPair = new MyGenericClass&lt;int, string&gt;(10, &quot;hello&quot;);int value1 = myPair.GetValue1(); // value1 will be 10string value2 = myPair.GetValue2(); // value2 will be &quot;hello&quot;

在上面的示例中，我们创建了一个名为myPair的MyGenericClass&lt;int, string&gt;实例，并使用构造函数将其初始化为(10, &quot;hello&quot;)。然后，我们调用了GetValue1和GetValue2方法来获取存储在该实例中的值。
default关键字在泛型类或方法中，可以使用default关键字来获取类型参数的默认值。default(T)表达式将返回类型T的默认值。对于引用类型，它将返回null；对于值类型，它将返回该类型的默认值（例如，对于int类型，它将返回0）。
下面是一个简单的示例，演示如何在泛型类中使用default关键字：
public class MyGenericClass&lt;T&gt;&#123;    private T value;    public MyGenericClass()    &#123;        value = default(T);    &#125;    public T GetValue()    &#123;        return value;    &#125;&#125;

在上面的示例中，我们定义了一个名为MyGenericClass&lt;T&gt;的泛型类。该类具有一个名为value的私有字段，其类型为T。我们还定义了一个构造函数，在其中使用了default(T)表达式来初始化value字段。
要使用这个泛型类，您需要在声明并实例化它时指定类型参数的具体类型。例如，您可以使用以下代码创建一个MyGenericClass&lt;int&gt;的实例：
MyGenericClass&lt;int&gt; myInt = new MyGenericClass&lt;int&gt;();int value = myInt.GetValue(); // value will be 0

在上面的示例中，我们创建了一个名为myInt的MyGenericClass&lt;int&gt;实例，并使用构造函数将其初始化。由于我们在构造函数中使用了default(T)表达式来初始化value字段，因此该字段的值将被设置为0。
where泛型约束泛型定义中的 where 子句指定对用作泛型类型、方法、委托或本地函数中类型参数的参数类型的约束。 约束可指定接口、基类或要求泛型类型为引用、值或非托管类型。 约束声明类型参数必须具有的功能，并且约束必须位于任何声明的基类或实现的接口之后。
作用泛型约束用于限制可替换类型参数的类型。当我们创建一个新的泛型类型实例时，我们可以使用约束来限制可替换类型参数的类型。如果客户端代码使用不满足约束的类型，编译器会发出错误。约束通过使用 where 上下文关键字指定1。
例如，你可以声明一个泛型类 AGenericClass ，以使类型参数 T 实现 IComparable&lt;T&gt; 接口：
public class AGenericClass&lt;T&gt; where T : IComparable&lt;T&gt;&#123;&#125;

这样，你就可以在泛型类中使用 Employee.Name 属性。 约束指定所有类型为 T 的项都保证是 Employee 对象或从 Employee 继承的对象。 可以对同一类型参数应用多个约束，约束本身也可以是泛型类型1。
泛型约束有多种类型，它们可以帮助你限制可替换类型参数的类型。下面是一些常见的泛型约束类型：

where T : struct：类型参数必须是非空值类型。所有值类型都具有可访问的无参数构造函数，因此 struct 约束意味着 new() 约束，不能与 new() 约束结合使用。您不能将 struct 约束与 unmanaged 约束结合使用1。
where T : class：类型参数必须是引用类型。此约束也适用于任何类、接口、委托或数组类型。在可为空上下文中，T 必须是非空引用类型1。
where T : class?：类型参数必须是引用类型，可以为空或非空。此约束也适用于任何类、接口、委托或数组类型1。
where T : notnull：类型参数必须是非空类型。参数可以是非空引用类型或非空值类型1。
where T : new()：类型参数必须具有公共无参数构造函数。与其他约束一起使用时，new() 约束必须最后指定。new() 约束不能与 struct 和 unmanaged 约束结合使用1。
where T : &lt;base class name&gt;：类型参数必须是指定基类或从指定基类派生。在可为空上下文中，T 必须是从指定基类派生的非空引用类型1。

这些约束可以帮助你更好地控制泛型类的行为，并确保客户端代码使用正确的类型来实例化泛型类。
泛型方法协变 逆变
泛型缓存
c#委托什么是委托C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针，是函数指针的升级版，可以按照某些约束指向某个方法，使得对方法的间接调用。
委托（Delegate） 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。
委托（Delegate）特别用于实现事件和回调方法。所有的委托都派生自 System.Delegate 类。
从数据结构来讲，委托是和类一样是一种用户自定义类型；从设计模式来讲，委托（类）提供了方法（对象）的抽象。
为什么要使用委托c#的内置泛型委托Action委托​	Action&lt;T&gt;是.NET Framework内置的泛型委托，可以使用Action&lt;T&gt;委托以参数形式传递方法，而不用显示声明自定义的委托。封装的方法必须与此委托定义的方法签名相对应。也就是说，封装的方法必须具有一个通过值传递给它的参数，并且不能有返回值。
​	Action其实就是没有返回值的delegate。
Action委托定义using System.Runtime.CompilerServices;namespace System&#123;    //    // 摘要:    //     封装一个方法，该方法不具有参数且不返回值。    [TypeForwardedFrom(&quot;System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089&quot;)]    public delegate void Action();&#125;


Action委托至少0个参数，至多16个参数，无返回值。
Action 表示无参，无返回值的委托。
Action&lt;int,string&gt; 表示有传入参数int,string无返回值的委托。
Action&lt;int,string,bool&gt; 表示有传入参数int,string,bool无返回值的委托。
Action&lt;int,int,int,int&gt; 表示有传入4个int型参数，无返回值的委托。

样例using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            //等待被委托的对象            Calculator calculator = new Calculator();            //Action委托的定义            Action action = new Action(calculator.Report);//使用action委托指向了新创建的方法                        //以下三条语句的功能相同，都是调用calculator的Report            calculator.Report();//直接调用目标发放            action.Invoke();//使用委托的Invoke方法进行间接调用            action();//简便写法，模仿了函数指针            Console.ReadKey();        &#125;    &#125;    class Calculator    &#123;        public void Report()        &#123;            Console.WriteLine(&quot;I have 3 methods&quot;);        &#125;        public int Add(int a, int b)        &#123;            int res = a + b;            return res;        &#125;        public int Sub(int a, int b)        &#123;            int res = a - b;            return res;        &#125;    &#125;&#125;





Func委托Func委托代表有返回类型的委托。
Func委托定义using System.Runtime.CompilerServices;namespace System&#123;    //    // 摘要:    //     封装一个方法，该方法具有两个参数，并返回由 TResult 参数指定的类型的值。    //    // 参数:    //   arg1:    //     此委托封装的方法的第一个参数。    //    //   arg2:    //     此委托封装的方法的第二个参数。    //    // 类型参数:    //   T1:    //     此委托封装的方法的第一个参数的类型。    //    //   T2:    //     此委托封装的方法的第二个参数的类型。    //    //   TResult:    //     此委托封装的方法的返回值类型。    //    // 返回结果:    //     此委托封装的方法的返回值。    [TypeForwardedFrom(&quot;System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089&quot;)]    public delegate TResult Func&lt;in T1, in T2, out TResult&gt;(T1 arg1, T2 arg2);&#125;





Func至少0个输入参数，至多16个输入参数，根据返回值泛型返回。必须有返回值，不可void。
Func&lt;int&gt; 表示没有输入参参，返回值为int类型的委托。
Func&lt;object,string,int&gt; 表示传入参数为object, string ，返回值为int类型的委托。
Func&lt;object,string,int&gt; 表示传入参数为object, string， 返回值为int类型的委托。
Func&lt;T1,T2,,T3,int&gt; 表示传入参数为T1,T2,,T3(泛型)，返回值为int类型的委托。
样例using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            //等待被委托的对象            Calculator calculator = new Calculator();                        //Func委托：分别指向了calculator的两个方法            Func&lt;int, int, int&gt; func1 = new Func&lt;int, int, int&gt;(calculator.Add);            Func&lt;int, int, int&gt; func2 = new Func&lt;int, int, int&gt;(calculator.Sub);            //Func&lt;void&gt; func3 = new Func&lt;void&gt;(calculator.Report);报错，不允许没有返回值            int x = 100;            int y = 200;            int z;            z = func1.Invoke(x, y);//可以用Invoke调用            Console.WriteLine(z);            //z = func2.Invoke(x, y);            z = func2(x, y);//也可以模仿函数指针的形式调用            Console.WriteLine(z);            Console.ReadKey();        &#125;    &#125;    class Calculator    &#123;        public void Report()        &#123;            Console.WriteLine(&quot;I have 3 methods&quot;);        &#125;        public int Add(int a, int b)        &#123;            int res = a + b;            return res;        &#125;        public int Sub(int a, int b)        &#123;            int res = a - b;            return res;        &#125;    &#125;&#125;



自定义委托委托是一种类（class），类是数据类型，所以委托也是一种数据类型。委托也可以创建实例、声明对象
与类一样，委托类型必须在被使用之前进行声明。
他的声明方式与一般的类不同。
需要注意声明委托的地方：委托是一个类，是在命名空间下面的一个类，与其他类同级。
类是可以被嵌套的，因此委托也可以，所以，委托是可以被声明在一个类中，运行可能也不会报错，但此时的委托已经不是一个独立的类了，而是外层类的一个嵌套类
委托所封装的方法必须“类型兼容”，即声明委托的时候，所使用的目标方法的返回值类型、目标方法的参数列表类型，必须与目标方法保持一致。     声明的是什么类型，创建对象时指向的也得是什么类型。
常用于将一个方法赋值给一个自定义的委托类型。前提是方法和委托的签名一样（即参数和返回值相同）
声明新参列表只需要保证类型数量一致即可，形参名是否相等无所谓。
注意委托是一个类，直属于命名空间，与其他类平级。
delegate 目标方法的返回值 委托名（目标方法的形参列表）

样例1public delegate double Calc(double x, double y);//自定义委托的声明







初始化使用new运算符new运算符的操作数的组成如下：

委托类型名
一组圆括号，其中包含作为调用列表中的第一个成员的方法的名字。方法可以是实例方法或静态方法。

如：
Calc calc1 = new Calc(calculator.Add);Calc calc2 = new Calc(calculator.Sub);



使用快捷语法快键语法，它仅由方法说明符构成。之所以能这样，是因为在方法名称和其相应的委托类型之间有隐式转换。
如：
Calc calc3 = calculator.Mul;Calc calc4 = calculator.Div;



赋值委托 由于委托是引用类型，我们可以通过给它赋值来改变包含在委托变量中的方法地址引用。旧的引用会被垃圾回收器回收。
Calc calc1 = new Calc(calculator.Add);calc1 = new Calc(calculator.Sub);



组合委托也称为委托的多播（Multicasting of a Delegate）
委托可以使用额外的运算符来组合。这个运算最终会创建一个新的委托，其调用列表是两个操作数的委托调用列表的副本的连接。
委托是恒定的，操作数委托创建后不会被改变。委托组合拷贝的是操作数的副本。
可以使用+&#x3D;运算符，为委托新增方法。
同样可以使用-&#x3D;运算符，为委托移除方法。
具体的应用场景？
using System;delegate int NumberChanger(int n);namespace DelegateAppl&#123;   class TestDelegate   &#123;      static int num = 10;      public static int AddNum(int p)      &#123;         num += p;         return num;      &#125;      public static int MultNum(int q)      &#123;         num *= q;         return num;      &#125;      public static int getNum()      &#123;         return num;      &#125;      static void Main(string[] args)      &#123;         // 创建委托实例         NumberChanger nc;         NumberChanger nc1 = new NumberChanger(AddNum);         NumberChanger nc2 = new NumberChanger(MultNum);         nc = nc1;         nc += nc2;         // 调用多播         nc(5);         Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum());         Console.ReadKey();      &#125;   &#125;&#125;

当上面的代码被编译和执行时，它会产生下列结果：
Value of Num: 75



委托调用委托调用跟方法调用类似。委托调用后，调用列表的每个方法将会被执行。
在调用委托前，应判断委托是否为空。调用空委托会抛出异常。
if(calc1 != null)&#123;    c = calc1.Invoke(a, b);    Console.WriteLine(c);&#125;



匿名方法匿名方法是在初始化委托时内联声明的方法。
基本结构：deleage( 参数 ) &#123; 语句块 &#125;

例如：
delegate int MyDel (int x); //定义一个委托 MyDel del = delegate( int x)&#123; return x; &#125;;

从上面我们可以看到，匿名方法是不会显示声明返回值的。
泛型委托我们每次要使用一个委托时，都需要先声明这个委托类，规定参数和返回值类型，然后才能实例化、调用。为了简化这个过程， .NET 框架为我们封装了三个泛型委托类，因此大部分情况下我们不必再声明委托，可以拿来直接实例化使用，方便了我们的日常写代码。这三种泛型委托包括：Func委托、Action委托和Predicate委托。
自定义泛型委托声明public delegate int DelCompareT&lt;T&gt;(T t1,T t2);

应用public static T GetMaxT&lt;T&gt;(T[] nums, DelCompareT&lt;T&gt; del)&#123;    T maxx = nums[0];    for(int i = 0; i &lt; nums.Length; i++)    &#123;        if(del(maxx, nums[i]) &lt; 0)        &#123;            maxx = nums[i];        &#125;    &#125;    return maxx;&#125;



委托的一般使用常用于把委托当作方法的参数传到方法里面去。
一个具有委托类型参数的方法，在方法体内使用传进来的委托间接的调用委托封装的那个方法，这样就形成了一种动态调用方法的结构。
像这种把委托当作参数传进方法的用法，具体可分为两种：模板方法、回调（callback）方法
模板方法​	所谓模板方法，就是将传进来的委托参数，借用指定的外部方法来产生结果。
​	相当于在写的方法中有一个“填空题”，中间空缺的位置就用传进来的委托参数填补，也就是通过传进来的委托参数简介的调用指定的外部方法。这个方法一般是具有返回值的，当拿到返回值后，再继续执行后面的逻辑。
​	写了一个方法，这个方法是一个模板，这个模板里有一处是不确定的，区域部分是确定好的，这个不确定的部分，就是靠传进来的委托类型的参数所包含的方法来填补
样例没有直接使用MakePizza，而是通过委托间接的调用
using System;using System.Windows.Diagnostics;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            ProductFactory productFactory = new ProductFactory();//生产工厂的实例            WrapFactory wrapFactory = new WrapFactory();//包装工厂的实例            //开始使用模板方法            //准备委托类型的变量，当作参数传入模板方法            Func&lt;Product&gt; func1 = new Func&lt;Product&gt;(productFactory.MakePizza);//生产披萨的委托             Func&lt;Product&gt; func2 = new Func&lt;Product&gt;(productFactory.MakeToyCar);//生产玩具车            //调用模板方法            Box box1 = wrapFactory.WrapPorduct(func1);            Box box2 = wrapFactory.WrapPorduct(func2);            Console.WriteLine(box1.Product.Name);            Console.WriteLine(box2.Product.Name);            Console.ReadKey();        &#125;    &#125;    //产品    class Product    &#123;        public string Name &#123; get; set; &#125;    &#125;    //包装产品的箱子    class Box    &#123;        public Product Product &#123; get; set; &#125;    &#125;    //将产品包上箱子交给客户    class WrapFactory    &#123;        //模板方法，大部分逻辑都已经被固定了，最大限度的实现了代码的重用        //准备一个箱子        //获取产品        //将产品装入box        //将打包好的box送回        //回调方法：使用Func委托，返回值是Product        public Box WrapPorduct(Func&lt;Product&gt; getProduct)        &#123;            Box box = new Box();            //间接调用 生产工厂的生产方法 拿到一个product的对象            //可以动态的选择调用方法            Product product = getProduct();            box.Product = product;            return box;        &#125;    &#125;    //生产工厂    class ProductFactory    &#123;        //生产披萨        public Product MakePizza()        &#123;            Product product = new Product();            product.Name = &quot;Pizza&quot;;            return product;        &#125;        //生存玩具车        public Product MakeToyCar()        &#123;            Product product = new Product();            product.Name = &quot;ToyCar&quot;;            return product;        &#125;    &#125;&#125;



回调方法回调：callback
回调方法是是通过委托类型的参数传进主调方法的被调用方法，主调方法可以根据自己的逻辑决定是否调用这个方法。换句话说就是，某个方法可以调用它，也可以不调用它，而且可以动态地选择后续调用的方法。
在以回调方法的形式来使用委托的时候，要做的是把委托类型的参数传进主调方法里面去，被传进主调方法里面的委托类型的参数，它内部会封装一个被回调的方法，也就是常说的回调方法。主调函数会根据自己的逻辑决定是否调用这个回调方法。
就像一个流水线一样，主调方法会在主要逻辑执行完毕后，决定是否调用这个回调方法
回调方法一般都位于主调方法的末尾，一般用于执行后续的工作，一般是没有返回值的。																																																																																																																
样例using System;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Calculator calculator = new Calculator();            //委托的声明以及初始化实例            Calc calc1 = new Calc(calculator.Add);            Calc calc2 = new Calc(calculator.Sub);            //快键语法，它仅由方法说明符构成。            //之所以能这样，是因为在方法名称和其相应的委托类型之间有隐式转换。            Calc calc3 = calculator.Mul;            Calc calc4 = calculator.Div;            double a = 100;            double b = 200;            double c = 0;            //间接调用4个委托，也可以不用Invoke关键字，直接（）调用            c = calc1.Invoke(a, b);            Console.WriteLine(c);            c = calc2.Invoke(a, b);            Console.WriteLine(c);            c = calc3.Invoke(a, b);                            Console.WriteLine(c);            c = calc4.Invoke(a, b);            Console.WriteLine(c);            Console.ReadKey();        &#125;    &#125;    public delegate double Calc(double x, double y);//自定义委托的声明，只需要保证类型一致即可，形参名是否相等无所谓    class Calculator    &#123;        public double Add(double x, double y)        &#123;            return x + y;        &#125;        public double Sub(double x, double y)        &#123;            return x - y;        &#125;        public double Mul(double x, double y)        &#123;            return x * y;        &#125;        public double Div(double x, double y)        &#123;            return x / y;        &#125;    &#125;&#125;



样例2：借助委托，使用一个方法调用不同的方法。using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 委托&#123;    //声明一个委托，指向一个函数    //委托所指向的函数必须和委托具有相同的签名（即参数和返回值）    public delegate void DelSayHi(string name);    internal class Program    &#123;        static void Main(string[] args)        &#123;            //DelSayHi del = SayHiChinese;//不再创建一个对象，而是直接给一个方法            //del(&quot;张三&quot;);            Test(&quot;张三&quot;, SayHiChinese);            Test(&quot;张三&quot;, SayHiEnglish);            Console.ReadLine();        &#125;                public static void Test(string name, DelSayHi del)        &#123;            del(name);        &#125;        public static void SayHiChinese(String name)        &#123;            Console.WriteLine(&quot;你好，&quot; + name);        &#125;        public static void SayHiEnglish(String name)        &#123;            Console.WriteLine(&quot;hi，&quot; + name);        &#125;    &#125;&#125;





样例3：借助委托，利用一个方法实现将string数组中每个元素变成全大写或全小写，然后再加上双引号using System;using System.Collections.Generic;using System.Linq;using System.Security.AccessControl;using System.Text;using System.Threading.Tasks;namespace 委托&#123;    //声明一个委托    delegate void DelStr(string[] str);    internal class Program    &#123;        static void Main(string[] args)        &#123;            string[] str = &#123; &quot;Hello&quot;, &quot;Any&quot;, &quot;Hurr&quot; &#125;;            //Test(str, ProStrToUpper);//转大写            //Test(str, ProStrToLower);//转小写            Test(str, ProStrSYH);//加双引号            foreach(var s in str)            &#123;                Console.WriteLine(s);            &#125;            Console.ReadLine();        &#125;        public static void Test(string[] str, DelStr del)        &#123;            del(str);        &#125;        public static void ProStrToUpper(string[] str)        &#123;            for(int i = 0; i &lt; str.Length; i++)            &#123;                str[i] = str[i].ToUpper();            &#125;        &#125;        public static void ProStrToLower(string[] str)        &#123;            for(int i = 0; i &lt; str.Length; i ++)            &#123;                str[i] = str[i].ToLower();            &#125;        &#125;        public static void ProStrSYH(string[] str)        &#123;            for(int i = 0; i &lt; str.Length; i++)            &#123;                str[i] = &quot;\&quot;&quot; + str[i] + &quot;\&quot;&quot;;            &#125;        &#125;    &#125;&#125;





样例4：借助委托，利用一个方法实现将string数组中每个元素变成全大写或全小写，然后再加上双引号。using System;using System.Collections.Generic;using System.Linq;using System.Security.AccessControl;using System.Text;using System.Threading.Tasks;namespace 委托&#123;    //声明一个委托    delegate void DelStr(string[] str);    public delegate string DelProStr(string str);    internal class Program    &#123;        static void Main(string[] args)        &#123;            string[] str = &#123; &quot;Hello&quot;, &quot;Any&quot;, &quot;Hurr&quot; &#125;;            //ProStr(str, ProStrToUpper);            //ProStr(str, ProStrToLower);            ProStr(str, ProStrSYH);            foreach(var s in str)            &#123;                Console.WriteLine(s);            &#125;            Console.ReadLine();        &#125;        public static void ProStr(string[] name, DelProStr del )        &#123;            for(int i = 0; i &lt; name.Length; i++)            &#123;                name[i] = del(name[i]);            &#125;        &#125;        public static string ProStrToUpper(string str)        &#123;            return str.ToUpper();        &#125;        public static string ProStrToLower(string str)        &#123;            return str.ToLower();        &#125;        public static string ProStrSYH(string str)        &#123;            return &quot;\&quot;&quot; + str + &quot;\&quot;&quot;;                    &#125;    &#125;&#125;

在上一个样例的基础上，修改成使用匿名方法的委托。using System;using System.Collections.Generic;using System.Linq;using System.Security.AccessControl;using System.Text;using System.Threading.Tasks;namespace 委托&#123;    //声明一个委托    delegate void DelStr(string[] str);    public delegate string DelProStr(string str);    internal class Program    &#123;        static void Main(string[] args)        &#123;            string[] str = &#123; &quot;Hello&quot;, &quot;Any&quot;, &quot;Hurr&quot; &#125;;            //ProStr(str, delegate (string s)            //&#123;            //    return s.ToUpper();            //&#125;);            //ProStr(str, delegate (string s)            //&#123;            //    return s.ToLower();            //&#125;);            ProStr(str, delegate (string s)            &#123;                return &quot;\&quot;&quot; + s + &quot;\&quot;&quot;;            &#125;);            foreach (var s in str)            &#123;                Console.WriteLine(s);            &#125;            Console.ReadLine();        &#125;        public static void ProStr(string[] name, DelProStr del)        &#123;            for (int i = 0; i &lt; name.Length; i++)            &#123;                name[i] = del(name[i]);            &#125;        &#125;    &#125;&#125;



泛型委托的应用：求任意数组的最大值using System;using System.Collections.Generic;using System.Globalization;using System.Linq;using System.Text;using System.Threading.Tasks;namespace 泛型委托&#123;    public delegate int DelCompare(object x, object y);    //声明一个泛型委托    public delegate int DelCompareT&lt;T&gt;(T t1,T t2);    internal class Program    &#123;        static void Main(string[] args)        &#123;            //object[] o = &#123; 1, 5, 3, 9 &#125;;            //object[] o2 = &#123; &quot;hurr&quot;, &quot;Any&quot;, &quot;Jam&quot; &#125;;            //object result = GetMax(o, CompareInt);            //result = GetMax(o2, CompareString);            //Console.WriteLine(result);            int[] nums = &#123; 1, 2, 3, 4, 5 &#125;;            var Result = GetMaxT&lt;int&gt;(nums, CompareIntNew);            Console.WriteLine(Result);            Console.ReadLine();        &#125;        public static int GetMaxNum(int[] num)        &#123;            int maxx = num[0];            for(int i = 0; i &lt; num.Length; i++)            &#123;                if(maxx &lt; num[i])                    maxx = num[i];            &#125;            return maxx;        &#125;        public static string GetMaxName(string[] names)        &#123;            string maxx = names[0];            for(int i = 0; i &lt; names.Length;i++)            &#123;                if(maxx.Length &lt; names[i].Length)                    maxx = names[i];            &#125;            return maxx;        &#125;        //传参的时候可以传一个委托，用于执行比较方法        public static object GetMax(object[] nums, DelCompare del)        &#123;            object maxx = nums[0];            for (int i = 0; i &lt; nums.Length; i++)            &#123;                //要传一个委托的比较方法                if ( del(maxx, nums[i]) &lt; 0)                    maxx = nums[i];            &#125;            return maxx;        &#125;        //泛型委托的应用        public static T GetMaxT&lt;T&gt;(T[] nums, DelCompareT&lt;T&gt; del)        &#123;            T maxx = nums[0];            for(int i = 0; i &lt; nums.Length; i++)            &#123;                if(del(maxx, nums[i]) &lt; 0)                &#123;                    maxx = nums[i];                &#125;            &#125;            return maxx;        &#125;        //比较方法        public static int CompareInt(object x, object y)        &#123;            int a = (int)x;            int b = (int)y;            return a - b;        &#125;        public static int CompareIntNew(int x, int y)        &#123;            return x - y;        &#125;        public static int CompareString(object x, object y)        &#123;            string s1 = (string)x;            string s2 = (string)y;            return s1.Length - s2.Length;        &#125;        public static int CompareStringNew(String x, string y)        &#123;            return x.Length - y.Length;        &#125;    &#125;&#125;





使用委托的时机​	委托和接口都允许类设计器分离类型声明和实现。 任何类或结构都能继承和实现给定的接口。 可以为任何类上的方法创建委托，前提是该方法符合委托的方法签名。 接口引用或委托可由不了解实现该接口或委托方法的类的对象使用。 既然存在这些相似性，那么类设计器何时应使用委托，何时又该使用接口呢？
在以下情况下，请使用委托：

当使用事件设计模式时。
当封装静态方法可取时。
当调用方不需要访问实现该方法的对象中的其他属性、方法或接口时。
需要方便的组合。
当类可能需要该方法的多个实现时。

在以下情况下，请使用接口：

当存在一组可能被调用的相关方法时。
当类只需要方法的单个实现时。
当使用接口的类想要将该接口强制转换为其他接口或类类型时。
当正在实现的方法链接到类的类型或标识时：例如比较方法。

IComparable 或泛型版本 IComparable 就是一个使用单一方法接口而不使用委托的很好的示例。 IComparable 声明 CompareTo 方法，该方法返回一个整数，指定相同类型的两个对象之间的小于、等于或大于关系。 IComparable 可用作排序算法的基础。 虽然将委托比较方法用作排序算法的基础是有效的，但是并不理想。 因为进行比较的能力属于类，而比较算法不会在运行时改变，所以单一方法接口是理想的。
来源：https://learn.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/ms173173(v=vs.100)
Lambda表达式纵然匿名方法使用很方便，可惜她很快就成了过气网红，没能领多长时间的风骚。如今已经很少见到了，因为delegate关键字限制了她用途的扩展。自从C# 3.0开始，她就被Lambda表达式取代，而且Lambda表达式用起来更简单。Lambda表达式本质上是改进的匿名方法。
表达式Lambda当匿名函数只有一行代码时，可采用这种形式。例如：
MyCalculator myCal = (num1, num2) =&gt;  num1 + num2;int num = myCal(1, 2);// 3

其中=&gt;符号代表Lambda表达式，它的左侧是参数，右侧是要返回或执行的语句。参数要放在圆括号中，若只有一个参数，为了方便起见可省略圆括号。有多个参数或者没有参数时，不可省略圆括号。相比匿名函数，在表达式Lambda中，方法体的花括号{}和return关键字被省略掉了。
语句Lambda当匿名函数有多行代码时，只能采用语句Lambda。
MyCalculator myCal = (int num1, int num2)=&gt;&#123;    Console.WriteLine(System.Reflection.MethodBase.GetCurrentMethod().Name);    return num1 + num2;&#125;;int num = myCal(1, 2);// 3

语句Lambda不可以省略{}和return语句。
Lambda的主要用处实际中用到Lambda表达式的地方大都是委托，例如linq的对集合类的扩展查询方法；很多架构的搭建需要调用自定义方法，也离不开委托；事件机制是基于委托的；等等。
Lambda样例using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Lambda表达式&#123;    internal class Program    &#123;        public delegate void DelOne();//没有参数，没有返回值的委托        public delegate void DelTwo(string str);//有参数，但没有返回值的委托        public delegate string DelThree(string str);//有参数，也有返回值的委托        static void Main(string[] args)        &#123;            //使用lambda表达式创建三个对应的委托            DelOne d1 = () =&gt; &#123; Console.WriteLine(&quot;这是一个没有参数 没有返回值的Lambda表达式&quot;); &#125;;            DelTwo d2 = (string name) =&gt; &#123; Console.WriteLine(&quot;这是一个有参数但没有返回值的Lambda表达式，值为：&quot; + name); &#125;;            DelThree d3 = (string name) =&gt; &#123; Console.WriteLine(&quot;这是一个具有参数和返回值委托&quot;); return &quot;hello,&quot; + name; &#125;;            //调用三个委托            d1();            d2(&quot;hurr&quot;);            Console.WriteLine(d3(&quot;hurr&quot;));            Console.ReadKey();        &#125;    &#125;&#125;

样例2：移除指定集合的元素List&lt;int&gt; list = new List&lt;int&gt;() &#123;1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;;list.RemoveAll(n =&gt; n &gt; 4);//使用lambda表达式来确定删除的范围。范围是大于4的元素foreach (int i in list)&#123;    Console.WriteLine(i);&#125;





C# 事件（Event）事件的概述​	事件（Event） 基本上说是一个用户操作，如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件。例如，中断。
事件可以感知发生了什么事情，
事件 使 对象或类具备了通知能力的成员。
​	事件本身不会主动通知别的对象或类，事件的拥有者在完成某个逻辑的之后，明确的告诉事件成员通知其他人的时候，才会进行通知。即事件不会主动发声，当被拥有者的某些内部逻辑触发后，才能够发声。
事件的功能 &#x3D; 通知 + 可选的事件参数（详细信息）
事件的使用时机：
​	用于对象或类之间的动作协调与信息传递（消息推送）
​	C# 中使用事件机制实现线程间的通信。
事件模型（发生-相应模型）事件的组成部分
事件的拥有者（event source， 对象）
事件成员（event，成员）
事件的响应者（event subscriber，对象）
事件处理器（event handler， 成员）
本质是一个回调方法


事件订阅
把事件处理器和事件关联在一起，本质上是一种以委托类型为基础的“约定”



发布器（publisher）(事件的拥有者) 
​	发布器是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器（publisher）类的对象调用这个事件，并通知其他的对象。
订阅器（事件的响应者）
​	订阅器（subscriber） 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器（subscriber）类中的方法（事件处理程序）。
注意事项
事件处理器是方法成员
挂接事件处理器的时候，可以使用委托实例，也可以直接使用方法名（语法糖）
事件处理器对事件的订阅不是随意的，匹配与否由声明事件时所使用的委托类型来检测。
用于订阅这个事件的事件处理器必须和事件遵循同一个约定，这个约定既约束了事件能够把什么样的消息发送给事件处理器，也约束了事件的处理器能够处理什么样的消息。
如果事件是使用某个约定定义的，而且事件处理器也遵循同样的约定，那就可以说事件处理器与事件是匹配的，就可以拿这个事件处理器去订阅这个事件。
如果提供的事件处理器与想订阅的事件没有遵循同一个约定，那么此时就可以说这个事件处理器与事件是不匹配的。此时编译器就会报错。
这个约定，就是所说的委托。


事件可以同步调用也可以异步调用。

发生-响应的五个动作：
我有一个事件

有人关心我这个事件（订阅）

我的事件发生了

关心事件的人依次被通知到

被通知到的人根据拿到事件信息（数据、参数、通知）对事件进行响应（处理时间）


注意：以下几个术语表示的是同一个对象：

事件的订阅者

事件消息的接收者
事件的处理者
事件的响应者
被事件所通知的对象


事件参数

事件信息
事件消息
事件数据



样例闹钟响了我起床了：

闹钟：事件
响了：事件发生了
我：我被通知到了
起床：我根据通知到的信息（闹钟响了）做出响应（起床）
隐藏关系：订阅
我订阅了这个闹钟，我才会被这个闹钟通知，就像我的闹钟不会通知别人起床一样，如果我没有订阅别人的闹钟，那么别人的闹钟响了我也不会去响应，



事件的应用场景
常用于开发客户端程序
如桌面、手机等开发的客户端，这些程序常是用户通过事件来“驱动”



事件的注意事项
对于事件的机制各种语言的实现方法不尽相同
Java中没有事件这个成员，也没有委托。Java使用接口实现相应功能
MVC、MVP、MVVM等模式是事件模式的高级用法。
事件模式本身也是一种设计模式


经常使用已有的事件，自己声明事件的情况较少
自己声明的场景：自定义控件



事件的应用样例1
创建一个事件拥有者Timer
创建两个事件响应者A和B
分别在响应者内部设置事件处理器
名字自定义，不限于Action


分别订阅时间拥有着的拥有的Elapsed事件
订阅只能+&#x3D; 或 -&#x3D;


开启事件
Elapsed对应的开启方法为start



using System;using System.Timers;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Timer timer = new Timer();//事件的拥有者            //事件的图标是一个黄色的小闪电，此处用Elapsed演示：度过一段时间后就会触发。(小扳手是属性，小方块是方法)            timer.Interval = 1000;//时间间隔1000ms，事件拥有者 拥有的 事件            A a = new A();//事件响应者            //创建事件，并订阅事件，+=左边是事件，右边是事件响应者的事件处理器            //事件订阅操作符： +=。只能是+= 或 -=，不能分开写            timer.Elapsed += a.Action;            timer.Start();//开启事件            B b = new B();//再次创建一个事件的响应者            timer.Elapsed += b.Action;//并订阅时间拥有着timer的Elapsed事件。            Console.ReadKey();        &#125;     &#125;    //事件的响应者    class A    &#123;        //自动生成的事件处理器（vs的修补功能）        internal void Action(object sender, ElapsedEventArgs e)        &#123;            //throw new NotImplementedException();            Console.WriteLine(&quot;+1s&quot;);        &#125;    &#125;    class B    &#123;        internal void Action(object sender, ElapsedEventArgs e)        &#123;            Console.WriteLine(&quot;Ohhhhh!&quot;);        &#125;    &#125;&#125;





样例2 事件的拥有者和事件的响应者是完全不同的两个对象VC、MVB设计模式的雏形。

using System;using System.Windows.Forms;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            Form form = new Form();//事件的拥有者            Controller controller = new Controller(form);//事件的响应者            form.ShowDialog();            Console.ReadKey();        &#125;     &#125;    class Controller    &#123;        private Form form;        public Controller(Form form)        &#123;            if(form == null)                 throw new ArgumentNullException(&quot;form is null&quot;);            else            &#123;                this.form = form;                this.form.Click += this.FormClicked;//事件 及 事件订阅            &#125;        &#125;        //vs自动生成的事件处理器        private void FormClicked(object sender, EventArgs e)        &#123;            //throw new NotImplementedException();            this.form.Text = DateTime.Now.ToString();//当点击窗口时，让窗口的标题栏显示当前时间        &#125;    &#125;&#125;



样例3事件的拥有者和事件的响应者是同一个对象。即一个对象用自己的方法去订阅处理自己的事件。

using System;using System.Windows.Forms;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            MyForm myForm = new MyForm();//事件的拥有者和响应者            myForm.Click += myForm.FormClicked;//事件订阅            myForm.ShowDialog();                       Console.ReadKey();        &#125;        private static void MyForm_Click(object sender, EventArgs e)        &#123;            throw new NotImplementedException();        &#125;    &#125;    class MyForm : Form    &#123;        //事件处理器        internal void FormClicked(object sender, EventArgs e)        &#123;            this.Text = DateTime.Now.ToString();        &#125;    &#125;&#125;



样例4 事件的拥有者是事件响应者的一个字段成员，事件响应者用自己的方法订阅着自己字段成员的某个事件
using System;using System.Windows.Forms;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            MyForm myForm = new MyForm();//事件响应者            myForm.ShowDialog();                        Console.ReadKey();        &#125;    &#125;    class MyForm : Form    &#123;                private TextBox textBox;        private Button button;//事件的拥有者        public MyForm()        &#123;            this.textBox = new TextBox();            this.button = new Button();            //使添加的按钮和文本框显示出来            this.Controls.Add(textBox);            this.Controls.Add(button);            this.button.Click += this.ButtonClicked;//事件 事件订阅            //美化            this.button.Text = &quot;Say Hello&quot;;            this.button.Top = 100;//按键的上边缘距离绘制窗口的顶端的距离        &#125;        //事件处理器        private void ButtonClicked(object sender, EventArgs e)        &#123;            this.textBox.Text = &quot;Hello World&quot;;        &#125;    &#125;&#125;









声明事件（Event）事件是基于委托的：
​	第一层：事件需要委托类型来做一个约束。约束既规定事件能发送什么样的消息给响应者，也规定事件响应者能收到什么样的事件消息。这就决定了事件响应者的事件处理器，必须能够和这个约束匹配上，才能够订阅这个事件。
​	第二层意思：当事件响应者向事件拥有者提供了能够匹配这个事件的事件处理器之后，需要把事件处理器保存或者记录下来。能够记录或者说引用方法的任务，只有委托类型的实例能够做到。
简而言之，只有委托能把五要素连起来
委托是事件的底层基础，事件是委托的上层建筑。
声明一个委托类型和声明一个委托类型的字段，都可以简化为声明一个委托。
如果形参含有ref out方法参数就用不了func和action委托
完整声明简略声明在类的内部声明事件，首先必须声明该事件的委托类型。例如：
public delegate void BoilerLogHandler(string status);

然后，声明事件本身，使用 event 关键字：
// 基于上面的委托定义事件public event BoilerLogHandler BoilerEventLog;

上面的代码定义了一个名为 BoilerLogHandler 的委托和一个名为 BoilerEventLog 的事件，该事件在生成的时候会调用委托。
样例样例1using System;namespace SimpleEvent&#123;  using System;  /***********发布器类***********/  public class EventTest  &#123;    private int value;    public delegate void NumManipulationHandler();    public event NumManipulationHandler ChangeNum;    protected virtual void OnNumChanged()    &#123;      if ( ChangeNum != null )      &#123;        ChangeNum(); /* 事件被触发 */      &#125;else &#123;        Console.WriteLine( &quot;event not fire&quot; );        Console.ReadKey(); /* 回车继续 */      &#125;    &#125;    public EventTest()    &#123;      int n = 5;      SetValue( n );    &#125;    public void SetValue( int n )    &#123;      if ( value != n )      &#123;        value = n;        OnNumChanged();      &#125;    &#125;  &#125;  /***********订阅器类***********/  public class subscribEvent  &#123;    public void printf()    &#123;      Console.WriteLine( &quot;event fire&quot; );      Console.ReadKey(); /* 回车继续 */    &#125;  &#125;  /***********触发***********/  public class MainClass  &#123;    public static void Main()    &#123;      EventTest e = new EventTest(); /* 实例化对象,第一次没有触发事件 */      subscribEvent v = new subscribEvent(); /* 实例化对象 */      e.ChangeNum += new EventTest.NumManipulationHandler( v.printf ); /* 注册 */      e.SetValue( 7 );      e.SetValue( 11 );    &#125;  &#125;&#125;

当上面的代码被编译和执行时，它会产生下列结果：
event not fireevent fireevent fire



实例 2本实例提供一个简单的用于热水锅炉系统故障排除的应用程序。当维修工程师检查锅炉时，锅炉的温度和压力会随着维修工程师的备注自动记录到日志文件中。
using System;using System.IO;namespace BoilerEventAppl&#123;   // boiler 类   class Boiler   &#123;      private int temp;      private int pressure;      public Boiler(int t, int p)      &#123;         temp = t;         pressure = p;      &#125;      public int getTemp()      &#123;         return temp;      &#125;      public int getPressure()      &#123;         return pressure;      &#125;   &#125;   // 事件发布器   class DelegateBoilerEvent   &#123;      public delegate void BoilerLogHandler(string status);      // 基于上面的委托定义事件      public event BoilerLogHandler BoilerEventLog;          public void LogProcess()      &#123;         string remarks = &quot;O. K&quot;;         Boiler b = new Boiler(100, 12);         int t = b.getTemp();         int p = b.getPressure();         if(t &gt; 150 || t &lt; 80 || p &lt; 12 || p &gt; 15)         &#123;            remarks = &quot;Need Maintenance&quot;;         &#125;         OnBoilerEventLog(&quot;Logging Info:\n&quot;);         OnBoilerEventLog(&quot;Temparature &quot; + t + &quot;\nPressure: &quot; + p);         OnBoilerEventLog(&quot;\nMessage: &quot; + remarks);      &#125;          protected void OnBoilerEventLog(string message)      &#123;         if (BoilerEventLog != null)         &#123;            BoilerEventLog(message);         &#125;      &#125;   &#125;   // 该类保留写入日志文件的条款   class BoilerInfoLogger   &#123;      FileStream fs;      StreamWriter sw;      public BoilerInfoLogger(string filename)      &#123;         fs = new FileStream(filename, FileMode.Append, FileAccess.Write);         sw = new StreamWriter(fs);      &#125;      public void Logger(string info)      &#123;         sw.WriteLine(info);      &#125;      public void Close()      &#123;         sw.Close();         fs.Close();      &#125;   &#125;   // 事件订阅器   public class RecordBoilerInfo   &#123;      static void Logger(string info)      &#123;         Console.WriteLine(info);      &#125;//end of Logger      static void Main(string[] args)      &#123;         BoilerInfoLogger filelog = new BoilerInfoLogger(&quot;e:\\boiler.txt&quot;);         DelegateBoilerEvent boilerEvent = new DelegateBoilerEvent();         boilerEvent.BoilerEventLog += new         DelegateBoilerEvent.BoilerLogHandler(Logger);         boilerEvent.BoilerEventLog += new         DelegateBoilerEvent.BoilerLogHandler(filelog.Logger);         boilerEvent.LogProcess();         Console.ReadLine();         filelog.Close();      &#125;//end of main   &#125;//end of RecordBoilerInfo&#125;

当上面的代码被编译和执行时，它会产生下列结果：
Logging info:Temperature 100Pressure 12Message: O. K





集合、比较和转换概述
集合:可以使用集合来维护对象组。与前面章节使用的数组不同，集合可以包含更高级的功能，例如，控制对它们包含的对象的访问、搜索和排序等。本章将介绍如何使用和创建集合类，学习充分利用它们的一些强大技术。
比较:在处理对象时，常要比较它们。这对于集合尤其重要，因为这是排序的实现方式。本章将介绍如何以各种方式比较对象(包括运算符重载)，如何使用IComparable和IComparer接口对集合进行排序。
转换:前面的章节介绍了如何把对象从一*种类型转换为另- 种类型。 本章讨论如何定制类型转换，以满足自己的需要。

集合大多数集合都在System.Collections，System.Collections.Generic两个命名空间。其中System.Collections.Generic专门用于泛型集合。
针对特定类型的集合类型位于System.Collections.Specialized;命名空间；
线程安全的集合类位于System.Collections.Concurrent;命名空间。
System.Collections名称空间中的以下几个接口提供了基本的集合功能:

IEnumerable：可以迭代集合中的项。
ICollection： 继承于IEnumerable。 可以获取集合中项的个数,并能把项复制到一个简单的数组类型中。
IList：继承于lEnumerable 和ICollection。 提供了集合的项列表，允许访问这些项，并提供其他- -些
与项列表相关的基本功能。
IDictionary：继 承于lEnumerable 和ICollection。 类似于IList,但提供了可通过键值(而不是索引)访问
的项列表。

System.Array类实现了IList、ICollection 和lEnumerable,但不支持IList的- -些更高级功能，它表示大小固定的项列表。
集合概述集合（Collection）类是专门用于数据存储和检索的类。这些类提供了对栈（stack）、队列（queue）、列表（list）和哈希表（hash table）的支持。大多数集合类实现了相同的接口。
集合（Collection）类服务于不同的目的，如为元素动态分配内存，基于索引访问列表项等等。这些类创建 Object 类的对象的集合。在 C# 中，Object 类是所有数据类型的基类。
集合和列表实现的接口


接口
说明



lEoumerable&lt;T&gt;
如果将foreach语句用于集合，就需要IEoumerable接口。这个接口定义了方法GetEoumerator0,它返回一个实现了IEnumerator接口的枚举


ICollection&lt;T&gt;
ICollection&lt;T&gt;接口由泛型集合类实现。使用这个接口可以获得集合中的元素个数(Count属性),把集合复制到数组中(CopyTo0方法),还可以从集合中添加和删除元素(Add0, Remove),Clear()


IList&lt;T&gt;
IList接口用于可通过位置访问其中的元素列表，这个接口定义了-个索引器，可以在集合的指定位置插入或删除某些项(nsert0和RemoveAt0方法)lList接口派生自LCollction接口


ISet&lt;T&gt;
ISet接口是.NET 4中新增的。实现这个接口的集允许合并不同的集，获得两个集的交集，检查两个集是否重叠。ISet接口派生自lCollection接口


IDictionary&lt;TKey,TValue&gt;
IDictionary&lt;TKey,TValue&gt;接口由包含键和值的泛型集合类实现。使用这个接口可以访问所有的键和值，使用键类型的索引器可以访问某些项，还可以添加或删除某些项


ILookup&lt;TKey,Tvalue&gt;
lLookup&lt;TKey,Tvalue&gt;接口类似于Dictionary&lt;IKey,TValue &gt;接口,实现该接口的集合有键和值，且可以通过一个键包含多个值


IComparer &lt;T&gt;
接口IComparer 由比较器实现，通过Compare()方法给集合中的元素排序


IEqualityComparer&lt;T&gt;
接口IEqualityComparer由一个比较器实现，该比较器可用于字典中的键。使用这个接口,可以对对象进行相等性比较。在.NET4中，这个接口也由数组和元组实现


IProducerConsumerCollection&lt;I&gt;
IProducerConsumerCollection接口是.NET4中新增的，它支持新的线程安全的集合类


各种集合类和它们的用法


类
描述和用法



动态数组（ArrayList）
它代表了可被单独索引的对象的有序集合。它基本上可以替代一个数组。但是，与数组不同的是，您可以使用索引在指定的位置添加和移除项目，动态数组会自动重新调整它的大小。它也允许在列表中进行动态内存分配、增加、搜索、排序各项。


哈希表（Hashtable）
它使用键来访问集合中的元素。当您使用键访问元素时，则使用哈希表，而且您可以识别一个有用的键值。哈希表中的每一项都有一个键&#x2F;值对。键用于访问集合中的项目。


排序列表（SortedList）
它可以使用键和索引来访问列表中的项。排序列表是数组和哈希表的组合。它包含一个可使用键或索引访问各项的列表。如果您使用索引访问各项，则它是一个动态数组（ArrayList），如果您使用键访问各项，则它是一个哈希表（Hashtable）。集合中的各项总是按键值排序。


堆栈（Stack）
它代表了一个后进先出的对象集合。当您需要对各项进行后进先出的访问时，则使用堆栈。当您在列表中添加一项，称为推入元素，当您从列表中移除一项时，称为弹出元素。


队列（Queue）
它代表了一个先进先出的对象集合。当您需要对各项进行先进先出的访问时，则使用队列。当您在列表中添加一项，称为入队，当您从列表中移除一项时，称为出队。


点阵列（BitArray）
它代表了一个使用值 1 和 0 来表示的二进制数组。当您需要存储位，但是事先不知道位数时，则使用点阵列。您可以使用整型索引从点阵列集合中访问各项，索引从零开始。


使用简单集合本部分中的示例使用泛型 List 类，通过此类可使用对象的强类型列表。
以下示例创建字符串列表，并通过使用 foreach 语句循环访问字符串。
// Create a list of strings.var salmons = new List&lt;string&gt;();salmons.Add(&quot;chinook&quot;);salmons.Add(&quot;coho&quot;);salmons.Add(&quot;pink&quot;);salmons.Add(&quot;sockeye&quot;);// Iterate through the list.foreach (var salmon in salmons)&#123;    Console.Write(salmon + &quot; &quot;);&#125;// Output: chinook coho pink sockeye

如果集合中的内容是事先已知的，则可以使用集合初始值设定项来初始化集合。 
以下示例与上一示例相同，除了有一个集合初始值设定项用于将元素添加到集合
// Create a list of strings by using a// collection initializer.var salmons = new List&lt;string&gt; &#123; &quot;chinook&quot;, &quot;coho&quot;, &quot;pink&quot;, &quot;sockeye&quot; &#125;;// Iterate through the list.foreach (var salmon in salmons)&#123;    Console.Write(salmon + &quot; &quot;);&#125;// Output: chinook coho pink sockeye

可以使用 for 语句，而不是 foreach 语句来循环访问集合。 通过按索引位置访问集合元素实现此目的。 元素的索引开始于 0，结束于元素计数减 1。
以下示例通过使用 for 而不是 foreach 循环访问集合中的元素。
// Create a list of strings by using a// collection initializer.var salmons = new List&lt;string&gt; &#123; &quot;chinook&quot;, &quot;coho&quot;, &quot;pink&quot;, &quot;sockeye&quot; &#125;;for (var index = 0; index &lt; salmons.Count; index++)&#123;    Console.Write(salmons[index] + &quot; &quot;);&#125;// Output: chinook coho pink sockeye

以下示例通过指定要删除的对象，从集合中删除一个元素。
// Create a list of strings by using a// collection initializer.var salmons = new List&lt;string&gt; &#123; &quot;chinook&quot;, &quot;coho&quot;, &quot;pink&quot;, &quot;sockeye&quot; &#125;;// Remove an element from the list by specifying// the object.salmons.Remove(&quot;coho&quot;);// Iterate through the list.foreach (var salmon in salmons)&#123;    Console.Write(salmon + &quot; &quot;);&#125;// Output: chinook pink sockeye

以下示例从一个泛型列表中删除元素。 使用以降序进行循环访问的 for 语句，而非 foreach 语句。 这是因为 RemoveAt 方法将导致已移除的元素后的元素的索引值减小。
var numbers = new List&lt;int&gt; &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;;// Remove odd numbers.for (var index = numbers.Count - 1; index &gt;= 0; index--)&#123;    if (numbers[index] % 2 == 1)    &#123;        // Remove the element by specifying        // the zero-based index in the list.        numbers.RemoveAt(index);    &#125;&#125;// 遍历列表// 一个lambda表达式被放置在ForEach方法中// of the List(T) object.numbers.ForEach(    number =&gt; Console.Write(number + &quot; &quot;));// Output: 0 2 4 6 8

对于 List 中的元素类型，还可以定义自己的类。 在下面的示例中，由 List 使用的 Galaxy 类在代码中定义。
private static void IterateThroughList()&#123;    var theGalaxies = new List&lt;Galaxy&gt;        &#123;            new Galaxy() &#123; Name=&quot;Tadpole&quot;, MegaLightYears=400&#125;,            new Galaxy() &#123; Name=&quot;Pinwheel&quot;, MegaLightYears=25&#125;,            new Galaxy() &#123; Name=&quot;Milky Way&quot;, MegaLightYears=0&#125;,            new Galaxy() &#123; Name=&quot;Andromeda&quot;, MegaLightYears=3&#125;        &#125;;    foreach (Galaxy theGalaxy in theGalaxies)    &#123;        Console.WriteLine(theGalaxy.Name + &quot;  &quot; + theGalaxy.MegaLightYears);    &#125;    // Output:    //  Tadpole  400    //  Pinwheel  25    //  Milky Way  0    //  Andromeda  3&#125;public class Galaxy&#123;    public string Name &#123; get; set; &#125;    public int MegaLightYears &#123; get; set; &#125;&#125;

















集合的类型许多通用集合由 .NET 提供。 每种类型的集合用于特定的用途。
本部分介绍了一些通用集合类：

System.Collections.Generic 类
System.Collections.Concurrent 类
System.Collections 类

System.Collections.Generic 类可以使用 System.Collections.Generic 命名空间中的某个类来创建泛型集合。 当集合中的所有项都具有相同的数据类型时，泛型集合会非常有用。 泛型集合通过仅允许添加所需的数据类型，强制实施强类型化。
下表列出了 System.Collections.Generic 命名空间中的一些常用类：



类
说明



Dictionary
表示基于键进行组织的键&#x2F;值对的集合。


List
表示可按索引访问的对象的列表。 提供用于对列表进行搜索、排序和修改的方法。


Queue
表示对象的先进先出 (FIFO) 集合。


SortedList
表示基于相关的 IComparer 实现按键进行排序的键&#x2F;值对的集合。


Stack
表示对象的后进先出 (LIFO) 集合。


有关其他信息，请参阅常用集合类型、选择集合类和 。
System.Collections.Concurrent 类在 .NET Framework 4 以及更新的版本中，System.Collections.Concurrent 命名空间中的集合可提供高效的线程安全操作，以便从多个线程访问集合项。
只要多个线程同时访问集合，就应使用 System.Collections.Concurrent 命名空间中的类，而不是 System.Collections.Generic 和 System.Collections 命名空间中的相应类型。 有关详细信息，请参阅线程安全集合和 。
包含在 System.Collections.Concurrent 命名空间中的一些类为 BlockingCollection、ConcurrentDictionary、ConcurrentQueue 和 ConcurrentStack。
System.Collections 类System.Collections 命名空间中的类不会将元素作为特别类型化的对象存储，而是作为 Object 类型的对象存储。
只要可能，则应使用 System.Collections.Generic 命名空间或 System.Collections.Concurrent 命名空间中的泛型集合，而不是 System.Collections 命名空间中的旧类型。
下表列出了 System.Collections 命名空间中的一些常用类：



类
描述



ArrayList
表示对象的数组，这些对象的大小会根据需要动态增加。


Hashtable
表示根据键的哈希代码进行组织的键&#x2F;值对的集合。


Queue
表示对象的先进先出 (FIFO) 集合。


Stack
表示对象的后进先出 (LIFO) 集合。


System.Collections.Specialized 命名空间提供专门类型化以及强类型化的集合类，例如只包含字符串的集合以及链接列表和混合字典。
ArrayList​	在C#中，ArrayList是一个非泛型的对象集合，其大小会动态增加。它与数组相同，除了它的大小会动态增加。当不知道数据的类型和大小时，可以使用ArrayList添加未知数据。
​	创建ArrayList时，需要引入包含ArrayList类的命名空间System.Collections。可以使用new关键字创建ArrayList对象。例如：使用ArrayList arlist &#x3D; new ArrayList();
​	ArrayList可以包含多个null和重复值。
​	Insert 和 InsertRange的区别：（也适用于Add的两个方法）

Insert只能插入一个元素，InsertRange可以插入一堆元素
如果使用Insert插入一个数组如arrayList.Insert(0, new int[]{0, 0, 0});，则表示将数组作为一个整体插入。如执行上面的语句，则表示插入一个int[]类型的元素
如果使用InsertRange插入一个数组，如arrayList.InsertRange(1, new int[] { -1, -1, -1 });,则表示将数组中的元素逐个添加到集合中。相当于执行了3次插入，每次插入“-1”。

​	访问ArrayList时，可以使用索引器，与数组相同。索引从零开始，并且每个后续元素都会增加一。当需要访问其中的数据时，需要显式转换为适当的类型，或使用var变量。
​	迭代ArrayList时，可以使用foreach和for循环。ArrayList的Count属性返回ArrayList中元素的总数。
​	相对于数组，ArrayList的优点在于它是一个动态的、可调整大小的对象集合。它的大小可以根据需要动态增加或减少。这意味着不需要预先指定ArrayList的大小，而可以根据需要添加或删除元素。此外，ArrayList可以存储不同类型的数据，而数组只能存储特定类型的数据。
​	然而，由于ArrayList不是强类型的，因此每次插入或检索都需要进行类型转换。此外，当ArrayList达到其容量时，它会动态扩展其内部数组的大小，这会带来一些性能损失。
using System;using System.Collections;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            // 创建了一个集合对象            ArrayList arrayList = new ArrayList();            // 根据里氏转换原则，如果一个地方需要父类，可以使用一个子类代替。            // 因为ArrayList里面存放的元素是Object类型的，而所有元素都是继承于Object，因此可以存放任何的元素到ArrayList。            // 属于拆箱和装箱。            arrayList.Add(1);// 存放一个int            arrayList.Add(&quot;Hello World!&quot;);// 存放一个string            arrayList.Add(1);//可以存放重复值            arrayList.Add(null);//null也可以放进去。            arrayList.Add(new Person());//自定义类型也可以。            arrayList.Add(new int[] &#123; 1, 2, 3 &#125;);//甚至数组也可以。            // 删除集合中的元素            arrayList.Remove(1);//通过元素删除 删除第一次出现的这个元素。            arrayList.RemoveAt(2);// 通过下标进行删除（从0起）。            arrayList.RemoveRange(0, 1); // 删除指定范围的元素。            // 在指定的位置插入一个元素。            arrayList.Insert(0, new int[]&#123;0, 0, 0&#125;);//在指定的位置插入一个元素            arrayList.InsertRange(1, new int[] &#123; -1, -1, -1 &#125;);// 在指定的集合插入一个元素            // Insert 和 InsertRange的区别：（也适用于Add的两个方法）            // 前者只会插入一个元素（如果插入数组，则将整个数组视为一个整体插入）            // 后者只能插入一个集合或数组，并将数组中的元素依次插入                        arrayList.Add(&quot;over&quot;);            // 可以通过count属性来获取ArrayList的长度。            // 可以使用foreach实现此功能。            for (int i = 0; i &lt; arrayList.Count; i++)            &#123;                var item = arrayList[i];//调用的时候需要显示的转换成为目标类型。                if (item is Person)                &#123;                    ((Person)item).Say();//如果当前类型可以显示转换为Person类，则调用其中的Say方法。                &#125;                else if (item is int[])//如果当前元素是数组，则遍历数组                &#123;                    foreach (var x in (int[])item)                    &#123;                        Console.Write(x + &quot; &quot;);                    &#125;                    Console.WriteLine();                &#125;                else                &#123;                    Console.WriteLine(item); //如果是简单类型，自动调用了ToString方法                &#125;            &#125;        &#125;    &#125;    class Person    &#123;        public void Say()        &#123;            Console.WriteLine(&quot;this is Person&quot;);        &#125;    &#125;&#125;



ArrayList分配空间的方式ArrayList类使用内部的T []数组来实现。如果使用List&lt;T&gt; (int)构造函数进行初始化，它将分配指定大小的数组。如果使用默认构造函数，它将使用默认容量4，但在这种情况下，数组只会在第一次添加时分配。每次向列表中添加元素时，它首先检查容量是否已达到（即现有计数是否等于容量）。如果是，则创建一个新的大小为前一个数组两倍的新数组，将所有现有元素复制到其中，然后继续写入新元素。这将一直持续下去，直到达到您引用的硬限制（Int32.MaxValue）。
​	也就是说 初始插入数据的时候分配4个空间，以后的每次超限都会将空间扩大一倍。
using System;using System.Collections;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            // 创建了一个集合对象            ArrayList arrayList = new ArrayList();            /*             * count:表示这个集合中实际包含的元素的个数。             * capcity：表示这个集合中可以包含的元素的个数。             */            // 当其中没有元素的时候，实际包含的和可包含的都是0.            Console.WriteLine(&quot;未添加数据时&quot;);            Console.WriteLine(&quot;arrayList.Count:&quot; + arrayList.Count);            Console.WriteLine(&quot;arrayList.Capacity:&quot; + arrayList.Capacity);            arrayList.Add(1);            //添加了一个数据之后，实际包含的个数变成了1，可包含的个数变成了4            Console.WriteLine(&quot;只添加一个数据时&quot;);            Console.WriteLine(&quot;arrayList.Count:&quot; + arrayList.Count);            Console.WriteLine(&quot;arrayList.Capacity:&quot; + arrayList.Capacity);            arrayList.Add(1); arrayList.Add(1); arrayList.Add(1);            //添加了4个数据之后，实际包含的个数变成了4，可包含的个数变成了4            Console.WriteLine(&quot;添加了4个数据时&quot;);            Console.WriteLine(&quot;arrayList.Count:&quot; + arrayList.Count);            Console.WriteLine(&quot;arrayList.Capacity:&quot; + arrayList.Capacity);            arrayList.Add(1);            //再次添加了一个数据之后，实际包含的个数变成了5，可包含的个数变成了8            Console.WriteLine(&quot;添加了5个数据时&quot;);            Console.WriteLine(&quot;arrayList.Count:&quot; + arrayList.Count);            Console.WriteLine(&quot;arrayList.Capacity:&quot; + arrayList.Capacity);            // 再次实验 使得其中的数量再次超界            arrayList.Add(1); arrayList.Add(1); arrayList.Add(1); arrayList.Add(1);            // 可以看到 可包含的个数达到16个了。            Console.WriteLine(&quot;添加了9个数据时&quot;);            Console.WriteLine(&quot;arrayList.Count:&quot; + arrayList.Count);            Console.WriteLine(&quot;arrayList.Capacity:&quot; + arrayList.Capacity);            // 也就是说 初始插入数据的时候分配4个空间，以后的每次超限都会将空间扩大一倍        &#125;    &#125;&#125;





键&#x2F;值对集合（Hashtable）根据键去找值。键和值一一对应。
using System;using System.Collections;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            // 声明一个键值对            Hashtable ht = new Hashtable();            // 添加元素            ht.Add(1, &quot;张三&quot;);// 前者是键，后者是值。            ht.Add(2, &quot;李四&quot;);            ht.Add(3, &quot;王五&quot;);            ht.Add(false, &quot;错误&quot;);//任何类型均可作为键或值，因为所需的参数是Object类型。            //ht.Add(3, &quot;王六&quot;);// 当发生值重复的时候，会抛出异常System.ArgumentException:“Item has already been added. Key in dictionary: &#x27;3&#x27;  Key being added: &#x27;3&#x27;”            ht[4] = &quot;王六&quot;;// 也可以使用这种方式来添加数据            ht[4] = &quot;王七&quot;;// 此时可以避免因键重复而导致的异常。                                    // 访问元素            // 在键值对集合中，是通过键去找值的。            // 因此，在键值对集合中，键必须是唯一的，而值可以重复。            //Console.WriteLine(ht[false]); //根据键 false 去寻找对应的值，然后输出值。 可以看到 这里输出了“错误”            // 因此，在键值对集合中，不能用for循环来遍历。只能用forweach遍历。具体方法如下：            // 需要注意的是，如果使用foreach进行遍历，其顺序是与添加顺序相逆的。            foreach (var item in ht.Keys)            &#123;                Console.WriteLine(ht[item]);            &#125;            //或者直接遍历值。            foreach (var item in ht.Values)            &#123;                Console.WriteLine(item);            &#125;            Console.WriteLine(); Console.WriteLine();            Console.WriteLine(&quot;常用方法演示&quot;);            // hashtable常用的一些方法：            // 插入数据前判断一下要插入的“键”是否是已存在的            if (!ht.ContainsKey(&quot;abc&quot;))// 如果键值对集合中不存在键为abc的对，            &#123;                ht.Add(&quot;abc&quot;, &quot;cba&quot;);// 则添加abc -&gt; cba的键值对            &#125;            //删除键值对中的指定元素            ht.Remove(4);            foreach (var item in ht.Values)            &#123;                Console.WriteLine(item);            &#125;            // 清空键值对集合            ht.Clear();                        Console.WriteLine(); Console.WriteLine();            Console.WriteLine(&quot;注意事项部分：&quot;);            //注意事项            Console.WriteLine(ht.ContainsKey(0));//查看一下是否存在键为0的键值对            Console.WriteLine(ht[0]);//在不存在的前提下方法一下这个键值对            Console.WriteLine(ht.ContainsKey(0));//此时可以发现。如果不存在，则访问后还不存在。            ht[0] = 1;            Console.WriteLine(ht.ContainsKey(0));//除非手动插入            Console.WriteLine(); Console.WriteLine();        &#125;    &#125;&#125;





Dictionary：字典键值对Dictionary是一个通用集合，通常用于存储键&#x2F;值对。
它的工作方式与非通用的哈希表非常相似。Dictionary的优点是它是一种通用类型。Dictionary定义在System.Collections.Generic命名空间下。
Dictionary&lt;TKey, TValue&gt;存储键值对，实现了IDictionary&lt;TKey, TValue&gt;接口。键必须是唯一的且不能为空。值可以为空或重复。可以通过传递关联键来访问值，例如myDictionary [key] 。
using System;using System.Collections;using System.IO;using System.Text;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            //创建一个字典键值对集合            //与hashtable不同，键和值的类型在定义的时候就已经被定义了。            Dictionary&lt;int, string&gt; dic = new Dictionary&lt;int, string&gt;();                        //添加数据            //键只能是int，值只能是string            //同样键不可以重复            dic.Add(1, &quot;张三&quot;);            dic.Add(2, &quot;李四&quot;);            dic[3] = &quot;王五&quot;;            //遍历            //可以以键值对的形式进行遍历            foreach(KeyValuePair&lt;int, string&gt; kvp in dic)            &#123;                Console.WriteLine($&quot;key:&#123;kvp.Key&#125;\tvalue:&#123;kvp.Value&#125;&quot;);            &#125;        &#125;    &#125;&#125;

















List 泛型集合对集合中的类型已经有了比较确切的定义（和数组一样）。
具体操作和普通的ArrayList类型。
特殊的地方就是可以与数组相互转换。能转成什么类型的数组取决于是什么类型的集合。
使用 LINQ 访问集合可以使用 LINQ（语言集成查询）来访问集合。 LINQ 查询提供筛选、排序和分组功能。 有关详细信息，请参阅 C# 中的 LINQ 入门。
以下示例运行一个对泛型 List 的 LINQ 查询。 LINQ 查询返回一个包含结果的不同集合。
private static void ShowLINQ()&#123;    List&lt;Element&gt; elements = BuildList();    // LINQ Query.    var subset = from theElement in elements                 where theElement.AtomicNumber &lt; 22                 orderby theElement.Name                 select theElement;    foreach (Element theElement in subset)    &#123;        Console.WriteLine(theElement.Name + &quot; &quot; + theElement.AtomicNumber);    &#125;    // Output:    //  Calcium 20    //  Potassium 19    //  Scandium 21&#125;private static List&lt;Element&gt; BuildList()&#123;    return new List&lt;Element&gt;    &#123;        &#123; new Element() &#123; Symbol=&quot;K&quot;, Name=&quot;Potassium&quot;, AtomicNumber=19&#125;&#125;,        &#123; new Element() &#123; Symbol=&quot;Ca&quot;, Name=&quot;Calcium&quot;, AtomicNumber=20&#125;&#125;,        &#123; new Element() &#123; Symbol=&quot;Sc&quot;, Name=&quot;Scandium&quot;, AtomicNumber=21&#125;&#125;,        &#123; new Element() &#123; Symbol=&quot;Ti&quot;, Name=&quot;Titanium&quot;, AtomicNumber=22&#125;&#125;    &#125;;&#125;public class Element&#123;    public string Symbol &#123; get; set; &#125;    public string Name &#123; get; set; &#125;    public int AtomicNumber &#123; get; set; &#125;&#125;





对集合排序以下示例阐释了对集合排序的过程。 该示例对 List 中存储的 Car 类的实例进行排序。 Car 类实现 IComparable 接口，此操作需要实现 CompareTo 方法。
每次对 CompareTo 方法的调用均会执行用于排序的单一比较。 CompareTo 方法中用户编写的代码针对当前对象与另一个对象的每个比较返回一个值。 如果当前对象小于另一个对象，则返回的值小于零；如果当前对象大于另一个对象，则返回的值大于零；如果当前对象等于另一个对象，则返回的值等于零。 这使你可以在代码中定义大于、小于和等于条件。
在 ListCars 方法中，cars.Sort() 语句对列表进行排序。 对 List 的 Sort 方法的此调用将导致为 List 中的 Car 对象自动调用 CompareTo 方法。
using System;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            ListCars();            Console.ReadKey();        &#125;        private static void ListCars()        &#123;            var cars = new List&lt;Car&gt;            &#123;                &#123; new Car() &#123; Name = &quot;car1&quot;, Color = &quot;blue&quot;, Speed = 20&#125;&#125;,                &#123; new Car() &#123; Name = &quot;car2&quot;, Color = &quot;red&quot;, Speed = 50&#125;&#125;,                &#123; new Car() &#123; Name = &quot;car3&quot;, Color = &quot;green&quot;, Speed = 10&#125;&#125;,                &#123; new Car() &#123; Name = &quot;car4&quot;, Color = &quot;blue&quot;, Speed = 50&#125;&#125;,                &#123; new Car() &#123; Name = &quot;car5&quot;, Color = &quot;blue&quot;, Speed = 30&#125;&#125;,                &#123; new Car() &#123; Name = &quot;car6&quot;, Color = &quot;red&quot;, Speed = 60&#125;&#125;,                &#123; new Car() &#123; Name = &quot;car7&quot;, Color = &quot;green&quot;, Speed = 50&#125;&#125;            &#125;;            // 按颜色字母顺序排序，然后按速度降序排序。            cars.Sort();            // View all of the cars.            foreach (Car thisCar in cars)            &#123;                Console.Write(thisCar.Color.PadRight(5) + &quot; &quot;);                Console.Write(thisCar.Speed.ToString() + &quot; &quot;);                Console.Write(thisCar.Name);                Console.WriteLine();            &#125;            // Output:            //  blue  50 car4            //  blue  30 car5            //  blue  20 car1            //  green 50 car7            //  green 10 car3            //  red   60 car6            //  red   50 car2        &#125;    &#125;    public class Car : IComparable&lt;Car&gt;    &#123;        public string Name &#123; get; set; &#125;        public int Speed &#123; get; set; &#125;        public string Color &#123; get; set; &#125;        /// &lt;summary&gt;        /// 摘要：        /// 将当前实例与同一类型的另一个对象进行比较，并返回一个整数，        /// 该整数指示当前实例在排序顺序中是在其他对象之前、之后还是出现在相同的位置。        /// &lt;/summary&gt;        /// &lt;param name=&quot;other&quot;&gt;要与此实例进行比较的对象。&lt;/param&gt;        /// &lt;returns&gt;        ///         /// 一个值，表示被比较对象的相对顺序。返回值具有以下含义：        ///  价值–意义        ///  小于零–此实例在排序顺序上位于其他实例之前。        ///  零–此实例与其他实例在排序顺序中出现在相同的位置。        ///  大于零–此实例在排序顺序上跟在其他实例之后。        ///         /// &lt;/returns&gt;        public int CompareTo(Car other)        &#123;            // 对该方法的调用将进行一次用于排序的比较。            // 确定被比较对象的相对顺序。            // 按颜色字母顺序排序，然后按速度降序排序。            // 比较颜色。            int compare;            compare = String.Compare(this.Color, other.Color, true);            // 如果颜色相同，请比较速度。            if (compare == 0)            &#123;                compare = this.Speed.CompareTo(other.Speed);                // 使用降序表示速度。                compare = -compare;            &#125;            return compare;        &#125;    &#125;&#125;

定义自定义集合可以通过实现 IEnumerable&lt;T&gt; 或 IEnumerable 接口来定义集合。
尽管可以定义自定义集合，但通常最好使用包含在 .NET 中的集合，这在本文前面的集合类型中进行了介绍。
以下示例定义一个名为 AllColors 的自定义集合类。 此类实现 IEnumerable 接口，此操作需要实现 GetEnumerator 方法。
GetEnumerator 方法返回 ColorEnumerator 类的一个实例。 ColorEnumerator 实现 IEnumerator 接口，此操作需要实现 Current 属性、MoveNext 方法以及 Reset 方法。
private static void ListColors()&#123;    var colors = new AllColors();    foreach (Color theColor in colors)    &#123;        Console.Write(theColor.Name + &quot; &quot;);    &#125;    Console.WriteLine();    // Output: red blue green&#125;// Collection class.public class AllColors : System.Collections.IEnumerable&#123;    Color[] _colors =    &#123;        new Color() &#123; Name = &quot;red&quot; &#125;,        new Color() &#123; Name = &quot;blue&quot; &#125;,        new Color() &#123; Name = &quot;green&quot; &#125;    &#125;;    public System.Collections.IEnumerator GetEnumerator()    &#123;        return new ColorEnumerator(_colors);        // Instead of creating a custom enumerator, you could        // use the GetEnumerator of the array.        //return _colors.GetEnumerator();    &#125;    // Custom enumerator.    private class ColorEnumerator : System.Collections.IEnumerator    &#123;        private Color[] _colors;        private int _position = -1;        public ColorEnumerator(Color[] colors)        &#123;            _colors = colors;        &#125;        object System.Collections.IEnumerator.Current        &#123;            get            &#123;                return _colors[_position];            &#125;        &#125;        bool System.Collections.IEnumerator.MoveNext()        &#123;            _position++;            return (_position &lt; _colors.Length);        &#125;        void System.Collections.IEnumerator.Reset()        &#123;            _position = -1;        &#125;    &#125;&#125;// Element class.public class Color&#123;    public string Name &#123; get; set; &#125;&#125;





迭代器迭代器用于对集合执行自定义迭代。 迭代器可以是一种方法，或是一个 get 访问器。 迭代器使用 yield return 语句返回集合的每一个元素，每次返回一个元素。
通过使用 foreach 语句调用迭代器。 foreach 循环的每次迭代都会调用迭代器。 迭代器中到达 yield return 语句时，会返回一个表达式，并保留当前在代码中的位置。 下次调用迭代器时，将从该位置重新开始执行。
有关详细信息，请参阅迭代器 (C#)。
下面的示例使用迭代器方法。 迭代器方法具有位于 for 循环中的 yield return 语句。 在 ListEvenNumbers 方法中，foreach 语句体的每次迭代都会创建对迭代器方法的调用，并将继续到下一个 yield return 语句。
private static void ListEvenNumbers()&#123;    foreach (int number in EvenSequence(5, 18))    &#123;        Console.Write(number.ToString() + &quot; &quot;);    &#125;    Console.WriteLine();    // Output: 6 8 10 12 14 16 18&#125;private static IEnumerable&lt;int&gt; EvenSequence(    int firstNumber, int lastNumber)&#123;    // Yield even numbers in the range.    for (var number = firstNumber; number &lt;= lastNumber; number++)    &#123;        if (number % 2 == 0)        &#123;            yield return number;        &#125;    &#125;&#125;



比较对象间的比较可以分为两大类，分别是类型比较、引用比较、值比较、深度比较、大小比较等

类型比较，即比较两个对象的类型是否是同一个
引用比较，即比较两个对象的引用是否相同，可以使用Object.ReferenceEquals方法或者&#x3D;&#x3D;操作符（对于引用类型）。
值比较，即比较两个对象的值是否相等，可以使用Object.Equals方法或者重载的&#x3D;&#x3D;操作符（对于值类型或者自定义类型）。
深度比较，即比较两个引用类型对象中包含的所有属性或字段是否相等，可以使用一些第三方库，如Objects Comparer或者自己实现一个递归的比较方法。
大小比较，即比较两个对象的大小顺序，可以使用IComparable接口或者IComparer&lt;T&gt;接口。

注意：类型比较和引用比较不是指的同一个。类型比较是指比较两个对象的类型是否相同，可以使用GetType方法或者is操作符。引用比较是指比较两个对象的引用是否相同，可以使用Object.ReferenceEquals方法或者==操作符（对于引用类型）。
类型比较在比较对象时，常需要了解它们的类型，才能确定是否可以进行值的比较。常用的方法有：GetType()和is 运算符。它可以提供可读性较高的代码，还可以检查基类。在is运算符之前，需要了解处理值类型(与引用类型相反)时后台的一些常见操作:封箱(boxing)和拆箱(unboxing)。
is运算符基本语法&lt;operand&gt; is &lt;type&gt;这个表达式的结果如下:

如果&lt;type&gt;是一个类类型， 而&lt;operand&gt;也是该类型，或者它继承了该类型，或者它可以封箱到该类型中，则结果为true。
如果&lt;type&gt;是 一个接口类型，而&lt;operand&gt; 也是该类型，或者它是实现该接口的类型，则结果为tnue.
如果&lt;type&gt;是一个值类型， 而&lt;operand&gt;也是该类型， 或者它可以拆箱到该类型中，则结果为true。

样例is运算符是一种用来判断对象是否是某种类型，或者是否可以转换为某种类型的运算符。如果是，这个运算符就返回true，否则返回false12。例如：
double x = 100;Console.WriteLine(x is double); // 输出：TrueConsole.WriteLine(x is int); // 输出：False

is运算符还可以用来匹配表达式与模式，如常量模式，关系模式，属性模式等3。例如：
static bool IsFirstFridayOfOctober(DateTime date) =&gt; date is &#123; Month: 10, Day: &lt;=7, DayOfWeek: DayOfWeek.Friday &#125;;

static bool IsFirstFridayOfOctober(DateTime date)&#123;    return date.Month == 10 &amp;&amp; date.Day &lt;= 7 &amp;&amp; date.DayOfWeek == DayOfWeek.Friday;&#125;

在这个例子中，is运算符将date与一个属性模式匹配，判断它是否是10月的第一个星期五。
引用比较引用比较是一种用来判断两个对象是否指向同一个内存地址的比较方式。在c#中，可以使用Object.ReferenceEquals静态方法或者&#x3D;&#x3D;运算符（对于引用类型）来进行引用比较。例如：
string s1 = &quot;hello&quot;;string s2 = &quot;hello&quot;;string s3 = new string(&quot;hello&quot;.ToCharArray());Console.WriteLine(Object.ReferenceEquals(s1, s2)); // 输出：TrueConsole.WriteLine(Object.ReferenceEquals(s1, s3)); // 输出：FalseConsole.WriteLine(s1 == s2); // 输出：TrueConsole.WriteLine(s1 == s3); // 输出：True

在这个例子中，s1和s2都是指向字符串常量池中的同一个字符串对象，所以引用比较返回true。而s3是通过构造函数创建的一个新的字符串对象，所以引用比较返回false。注意，&#x3D;&#x3D;运算符对于字符串类型是进行内容比较的，所以s1和s3的内容比较返回true。
值比较值比较是一种用来判断两个对象的内容是否相等的比较方式。在c#中，可以使用Object.Equals静态方法或者&#x3D;&#x3D;运算符（对于值类型）来进行值比较。例如：
int x = 10;int y = 10;Console.WriteLine(Object.Equals(x, y)); // 输出：TrueConsole.WriteLine(x == y); // 输出：True

在这个例子中，x和y都是值类型，所以它们的值比较返回true。注意，&#x3D;&#x3D;运算符对于值类型是进行值比较的，而对于引用类型是进行引用比较的。
IComparable和IComparer接口IComparable和IComparer接日是.NETFramework中比较对象的标准方式。这两个接口之间的区别如下:

IComparable 在要比较的对象的类中实现，可以比较该对象和另一个对象。
IComparer 在一个单独的类中实现，可以比较任意两个对象

​	IComparable提供了一个方法CompareTo() , 这个方法接受一个对象。 例如，在实现该方法时，使其可以接受一个Peson对象，以便确定这个人比当前的人更年老还是更年轻。实际上，这个方法返回一个int, 所以也可以确定第二个人与当前的人的年龄差:
if(person1.CompareTo(person2) == 0)&#123;	Console.WriteLine(&quot;SameAge&quot;);&#125;else if(person1.CompareTo(person2) &gt; 0)&#123;	Console.WriteLine(&quot;person1 is older&quot;);&#125;else&#123;	Console.WriteLine(&quot;person1 is Younger&quot;);&#125;



IComparer也提供-一个方法Compare()。 这个方法接受两个对象，返回一个整型结果，这与Compare To()相同。对于支持IComparer的对象，可使用下面的代码:
if (personComparer.Compare(personl, person2) == 0)&#123;	WriteLine (&quot;Same age&quot;) ;&#125;else if (personComparer.Compare(person1, person2) &gt; 0)&#123;	Console.WriteLine(&quot;person1 is older&quot;);&#125;else&#123;	Console.WriteLine(&quot;person1 is Younger&quot;);&#125;



值比较的方法
使用String.Compare()方法，它接受两个字符串作为参数，并返回一个整数值，表示两个字符串的比较结果。如果两个字符串相等，返回0；如果第一个字符串小于第二个字符串，返回负数；如果第一个字符串大于第二个字符串，返回正数。
使用CompareTo()方法，它是一个实例方法，用于比较当前对象和另一个对象的值。它也返回一个整数值，表示两个对象的比较结果。如果两个对象相等，返回0；如果当前对象小于另一个对象，返回负数；如果当前对象大于另一个对象，返回正数。
使用&#x3D;&#x3D;和!&#x3D;运算符，它们用于比较两个值是否相等或不相等。它们返回一个布尔值，表示两个值的比较结果。如果两个值相等，返回true；如果两个值不相等，返回false。

对自定义类实现sort排序在c#中实现对自定义类的sort排序的方法有以下几种：

让自定义类实现IComparable接口，并定义CompareTo方法，用于比较当前对象和另一个对象。然后使用List&lt;T&gt;.Sort()方法对列表进行排序，它会使用默认的比较器。
定义一个实现IComparer接口的类，并定义Compare方法，用于比较两个对象。然后使用List&lt;T&gt;.Sort(IComparer&lt;T&gt;)方法对列表进行排序，它会使用指定的比较器。
使用LINQ的orderby子句对列表进行排序，它会返回一个排序后的序列。可以指定排序的属性和顺序。

样例假设有一个自定义类Student，有两个属性Name和Score，表示学生的姓名和成绩。

使用IComparable接口的示例代码：

using System;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            List&lt;StudentA&gt; studentsA = new List&lt;StudentA&gt;()// 创建要比较的序列            &#123;                new StudentA(&quot;张三&quot;, 20),                new StudentA(&quot;李四&quot;, 21),                new StudentA(&quot;王五&quot;, -10)            &#125;;            studentsA.Sort();//直接调用            foreach(var t in studentsA)            &#123;                Console.WriteLine($&quot;name : &#123;t.Name&#125;   age : &#123;t.Age&#125;&quot;);            &#125;            Console.ReadKey();        &#125;    &#125;    /// &lt;summary&gt;    /// 样例1 在自定义的类内定义比较方法    /// 使用Icomparable实现类内自带比较方法    /// &lt;/summary&gt;    class StudentA : IComparable&lt;StudentA&gt;    &#123;        public string Name &#123; get; set; &#125;        public int Age &#123; get; set; &#125;        public int CompareTo(StudentA other)//加上一个?表示这个参数是一个可空类型，可以接受null作为值。这样可以增加方法的灵活性，可以处理null的情况。例如，如果other是null，那么可以返回1，表示当前对象大于null。        &#123;            return other.Age - this.Age;//调整这个实现正序、逆序的排序        &#125;        public StudentA(string name, int age)        &#123;            Name = name;            Age = age;        &#125;    &#125;&#125;


使用IComparer接口的示例代码：

using System;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            List&lt;StudentB&gt; studentsB = new List&lt;StudentB&gt;()// 创建要比较的序列            &#123;                new StudentB(&quot;张三&quot;, 20),                new StudentB(&quot;李四&quot;, 21),                new StudentB(&quot;王五&quot;, -10)            &#125;;            // 实例化比较对象            MyComparer myComparer = new MyComparer();            //使用Sort进行排序            studentsB.Sort(myComparer);            foreach (var t in studentsB)            &#123;                Console.WriteLine($&quot;name : &#123;t.Name&#125;   age : &#123;t.Age&#125;&quot;);            &#125;            Console.ReadKey();        &#125;    &#125;    /// &lt;summary&gt;    /// 样例2 使用第三方比较类实现    /// &lt;/summary&gt;    class StudentB    &#123;        public string Name &#123; get; set; &#125;        public int Age &#123; get; set; &#125;        public StudentB(string name, int age)        &#123;            Name = name;            Age = age;        &#125;    &#125;	// yo    class MyComparer : IComparer&lt;StudentB&gt;    &#123;        public int Compare(StudentB x, StudentB y)        &#123;            return x.Age - y.Age;//调整这个实现正序、逆序的排序        &#125;    &#125;    &#125;


使用LINQ的orderby子句的示例代码：

//定义Student类class Student&#123;    public string Name &#123; get; set; &#125;    public int Score &#123; get; set; &#125;&#125;//创建一个Student列表List&lt;Student&gt; students = new List&lt;Student&gt;()&#123;    new Student() &#123; Name = &quot;Alice&quot;, Score = 90 &#125;,    new Student() &#123; Name = &quot;Bob&quot;, Score = 80 &#125;,    new Student() &#123; Name = &quot;Charlie&quot;, Score = 85 &#125;,    new Student() &#123; Name = &quot;David&quot;, Score = 95 &#125;&#125;;//使用LINQ的orderby子句对列表进行排序，按照成绩升序，姓名降序var sortedStudents = from student in students orderby student.Score, student.Name descending select student;//打印排序后的序列foreach (var student in sortedStudents)&#123;    Console.WriteLine($&quot;&#123;student.Name&#125;: &#123;student.Score&#125;&quot;);&#125;





文件文件编码
文本文件有不同的存储方式，将字符串以什么形式保存为二进制，这个就是编码。常见的编码有UTF-8、ASCII、Unicode、gbk等。
如果出现乱码一般都是编码的问题，文本文件相关的函数一般都具有一个Encoding类型的参数。
取得编码的方式：Encoding.Defaule，Encoding.UTF8、Encoding.GetEncoding(“GBK”)
常用静态方法
void AppendAllText(string path, string contents);
将文本contents附加到文件path中


bool Exists(string path)
判断文件path是否存在


string[ ReadAllL ines(string path)读取文本文件到字符串数组中
string ReadAIIText(string path)读取文本文件到字符串中void WriteAllText(string path, string contents)将文本contents保存到文件path中，会覆盖旧内容。WriteAllL ines(string path,string[ contents);将字符串数组逐行保存到文件path中，会覆盖旧内容。



输入输出的类Path类Path 类是 C# 中的一个静态类，它属于 System.IO 命名空间和 System.Runtime.dll 程序集。这个类用于对包含文件路径或目录路径信息的字符串实例执行操作。路径是一个字符串，它提供了文件或目录的位置，它可以是绝对位置或相对位置。这些操作以跨平台的方式执行。
例如，可以使用 Path 类的一些方法来检查文件路径是否有扩展名（HasExtension），检查文件路径是否为根路径（IsPathRooted），获取临时文件的完整路径（GetFullPath），获取临时文件的位置（GetTempPath）以及获取可用于使用的临时文件名（GetTempFileName）。
此外，还可以使用 Combine 方法将多个路径组合在一起。
using System;using System.Collections;using System.IO;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            string str = @&quot;D:\Documents\hurriedlu\资源\hurr.wav&quot;;// @的意思是忽略后续字符串中的转义字符，当作普通字符进行处理            // 获取路径中的文件名：            // 传统做法：            int index = str.LastIndexOf(&quot;\\&quot;);//找到最后一个斜杠的位置            string name = str.Substring(index + 1);// 从最后一个斜杠的下一个位置开始截取，截取剩下全部的字符            Console.WriteLine(name);            // 使用Path类实现            //获取文件的名字。            Console.WriteLine(Path.GetFileName(str));//hurr.wav            //只获取文件名而不获取扩展名。            Console.WriteLine(Path.GetFileNameWithoutExtension(str));//hurr            //只获取扩展名(包括点)。            Console.WriteLine(Path.GetExtension(str));//.wav            //获取文件所在的文件夹的地址(文件夹的绝对地址)            Console.WriteLine(Path.GetDirectoryName(str));//D:\Documents\hurriedlu\资源            //组合路径            //注意，如果组合时当前分块没有扩展名，则会自动添加/。例如：将文件名和扩展名组合在一起：hurr\.wav            Console.WriteLine(Path.Combine(Path.GetFileNameWithoutExtension(str), Path.GetExtension(str)));            //组合可以不止两个，但依然存在上面的问题 例如：D:\Documents\hurriedlu\资源\hurr\.wav            Console.WriteLine(Path.Combine(Path.GetDirectoryName(str), Path.GetFileNameWithoutExtension(str), Path.GetExtension(str)));            //组合文件夹和文件名            Console.WriteLine(Path.Combine(Path.GetDirectoryName(str), Path.GetFileName(str)));            //获取完整的路径（绝对地址）。            Console.WriteLine(Path.GetFullPath(str));            //检查提供的路径是否含有扩展名（返回类型bool）            Console.WriteLine(Path.HasExtension(str));            //检查是否是根路径            Console.WriteLine(Path.IsPathRooted(str));            //获取临时文件位置            string temp = Path.GetTempPath();            Console.WriteLine(temp);            //创建临时文件            temp = Path.GetTempFileName();            Console.WriteLine(temp);            /*             * GetTempFileName 方法用于在磁盘上创建一个唯一命名的零字节临时文件，并返回该文件的完整路径。             * 该临时文件将在用户的临时文件夹内创建，该路径是由 GetTempPath 方法返回的路径。             * 需要注意的是，如果在不删除先前的临时文件的情况下使用此方法创建超过 65535 个文件，             * GetTempFileName 方法将引发 IOException。             * 如果没有可用的唯一临时文件名，GetTempFileName 方法也会引发 IOException。             * 要解决此错误，请删除所有不需要的临时文件。            */        &#125;    &#125;&#125;

File类File 类是 C# 中的一个静态类，它属于 System.IO 命名空间和 System.Runtime.dll 程序集。这个类提供了用于创建、复制、删除、移动和打开单个文件的静态方法，并帮助创建 FileStream 对象。
可以使用 File 类执行诸如复制、移动、重命名、创建、打开、删除和追加到单个文件的典型操作。还可以使用 File 类获取和设置与文件创建、访问和写入相关的文件属性或 DateTime 信息。
例如，可以使用 Exists 方法检查文件是否存在，使用 Copy 方法复制文件，使用 Create 方法创建或覆盖文件，使用 Delete 方法删除文件，使用 ReadAllText 方法读取文件内容，使用 WriteAllText 方法创建新文件并将内容写入其中（如果文件已存在，则将其覆盖）。
常用方法判断文件是否存在：Existsif (File.Exists(@&quot;D:\tmp\tmp.txt&quot;))&#123;    Console.WriteLine(&quot;已存在&quot;);&#125;else&#123;    Console.WriteLine(&quot;不存在&quot;);&#125;



创建文件：CreateFile.Create(@&quot;D:\tmp\tmp.txt&quot;);

​	使用File创建一个文件。注意，只能创建文件，而不能创建目录。如果目录不存在，则会抛出异常。​	当使用File创建文件的时候，如果重复执行（已存在要创建的文件），则会对要创建的文件进行修改，而不是删除再创建。
剪切（移动）一个文件：MoveFile.Move(@&quot;D:\tmp\tmp1.txt&quot;, @&quot;D:\tmp\1\tmp.txt&quot;);

同时在移动的过程中允许对移动的文件进行重命名操作。
复制一个文件：CopyFile.Copy(@&quot;D:\tmp\tmp.txt&quot;, @&quot;D:\tmp\tmp1.txt&quot;);

如果目标文件（tmp1）已存在，则会抛出异常
删除一个文件：DeleteFile.Delete(@&quot;D:\tmp\tmp.txt&quot;);

注意，使用File删除文件的时候，是直接删除一个文件，而非移动到回收站
using System;using System.Collections;using System.IO;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            //使用File创建一个文件。注意，只能创建文件，而不能创建目录。如果目录不存在，则会抛出异常。            //当使用File创建文件的时候，如果重复执行（已存在要创建的文件），则会对要创建的文件进行修改，而不是删除再创建。            //File.Create(@&quot;D:\tmp\tmp.txt&quot;);            // 删除一个指定的文件            // 直接删除一个文件，不经过回收站            //File.Delete(@&quot;D:\tmp\tmp.txt&quot;);            //复制一个文件            //如果目标文件（tmp1）已存在，则会抛出异常            //File.Copy(@&quot;D:\tmp\tmp.txt&quot;, @&quot;D:\tmp\tmp1.txt&quot;);            // 移动一个文件            // 同时在移动的过程中允许对移动的文件进行重命名操作。            //File.Move(@&quot;D:\tmp\tmp1.txt&quot;, @&quot;D:\tmp\1\tmp.txt&quot;);            // 判断文件是否存在            //if (File.Exists(@&quot;D:\tmp\tmp.txt&quot;))            //&#123;            //    Console.WriteLine(&quot;已存在&quot;);            //&#125;            //else            //&#123;            //    Console.WriteLine(&quot;不存在&quot;);            //&#125;        &#125;    &#125;&#125;





使用File读写数据一般来说，只是用File操作小文件。
对于ReadAllBytes来说可以读取非文本文件，但对于其他方法来说，只能读取文本文件。
using System;using System.Collections;using System.IO;using System.Text;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            //逐行读取文本，并将每一行的文本信息转换成一个string对象存入string数组中            // 参数二可以缺省，如果缺省则使用默认的编码格式进行解码。也可以指定解码方式            string[] str = File.ReadAllLines(@&quot;D:\tmp\tmp.txt&quot;,Encoding.UTF8);            foreach (string item in str)            &#123;                Console.WriteLine(item);            &#125;            //直接读取所有的文本，存入一个string类型的变量中后返回            //同上方的逐行读取一样，也可以指定解码编码            //会将所有的字符（包括回车）存入string字符串中返回。            string s = File.ReadAllText(@&quot;D:\tmp\tmp.txt&quot;, Encoding.UTF8);            Console.WriteLine(s);            //以字节的形式去读取一个文件，将每个字节的二进制编码直接汇集成数组返回。            //输出的时候需要将字节数组转换为字符串            byte[] buffer = File.ReadAllBytes(@&quot;D:\tmp\tmp.txt&quot;);            string strbuf = Encoding.UTF8.GetString(buffer);            strbuf = Encoding.GetEncoding(&quot;UTF-8&quot;).GetString(buffer);//也可以这么写。但需要注意，如果编码输入错误，会直接抛异常！！！            Console.WriteLine(strbuf);        &#125;    &#125;&#125;

使用File写数据注意，使用file写数据会使得原先的所有文本信息丢失。
使用方法和读数据类似
using System;using System.Collections;using System.IO;using System.Text;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            //使用WriteAllBytes逐字节写入到指定文件中            //注意！！！会从文件头开始写，导致先前的所有文本都丢失            //string str = &quot;张三李四王五&quot;;            //byte[] buffer = Encoding.UTF8.GetBytes(str);//将字符串变成字节数组            //File.WriteAllBytes(@&quot;D:\tmp\tmp.txt&quot;, buffer);//将转换完成的字节数组写入到指定的文件中            //以行的形式写入到指定的文本文件中            //也是从文件头开始写            //File.WriteAllLines(@&quot;D:\tmp\tmp.txt&quot;, new string[] &#123;&quot;tmp&quot;, &quot;test&quot;&#125;);            //以字符串的形式写入到指定的文本文件中去            //依然复写            //File.WriteAllText(@&quot;D:\tmp\tmp.txt&quot;, &quot;副本&quot;);        &#125;    &#125;&#125;

使用file追加数据using System;using System.Collections;using System.IO;using System.Text;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            //向指定的文本文件追加n行文本            //从源文件末尾开始追加，保留原有文本            //File.AppendAllLines(@&quot;D:\tmp\tmp.txt&quot;, new string[] &#123; &quot;hurr&quot;, &quot;visual&quot; &#125;);            //向指定的文本文件追加指定字符串            //保留原有文本，支持转义字符            //File.AppendAllText(@&quot;D:\tmp\tmp.txt&quot;, &quot;\n测试&quot;);        &#125;    &#125;&#125;

注意，追加数据的话，只能追加文本文件，File并没有能追加二进制数据的能力。
注意事项使用File只适合读取小文件，对于大文件不适用。因为File的读写是一次性完成的，容易爆内存
FileInfo类可以看作非静态的File类。
FileInfo 类是 C# 中的一个类，它属于 System.IO 命名空间和 System.Runtime.dll 程序集。这个类提供了用于创建、复制、删除、移动和打开文件的属性和实例方法，并帮助创建 FileStream 对象。
FileInfo 类提供了许多用于操作文件的实例方法。与静态 File 类不同，FileInfo 类允许您在同一文件上执行多个操作，而不需要每次都进行安全检查。
下面是一些常用的 FileInfo 类方法（与File类似）：

AppendText：创建一个 StreamWriter，它将文本追加到由此 FileInfo 实例表示的文件中。
CopyTo：将现有文件复制到新文件，不允许覆盖现有文件。
Create：创建文件。
CreateText：创建一个 StreamWriter，它写入新文本文件。
Decrypt：解密由当前帐户使用 Encrypt 方法加密的文件。
Delete：删除指定的文件。
Encrypt：加密文件，以便只有加密该文件的帐户才能解密它。
GetAccessControl：获取封装指定文件的访问控制列表 (ACL) 条目的 FileSecurity 对象。
MoveTo：将指定的文件移动到新位置，提供指定新文件名的选项。
Open：以指定的 FileMode 打开文件。
OpenRead：创建一个只读 FileStream。
OpenText：创建一个使用 UTF8 编码从现有文本文件读取的 StreamReader。
OpenWrite：创建一个只写 FileStream。
Replace：使用当前 FileInfo 对象描述的文件替换指定文件的内容，删除原始文件，并创建被替换文件的备份。

FileInfo的专用属性：
Director
检索一个DirectorInfo对象，表示包括当前文件的目录。这个属性是只读的。


DirectorName
返回文件目录的路径，这个属性也是只读的。


IsReadOnly
文件只读的快捷方式，也可以通过Attributes来访问这个属性。


Length
获取文件的大小（以字节为单位），返回long值，这个属性是只读的。



Directory类Directory 类是 C# 中的一个静态类，它属于 System.IO 命名空间和 System.Runtime.dll 程序集。这个类提供了用于创建、复制、移动和删除目录和子目录的静态方法。
可以使用 Directory 类执行诸如复制、移动、重命名、创建和删除目录的典型操作。要创建目录，可以使用 CreateDirectory 方法。要删除目录，可以使用 Delete 方法。要获取或设置应用程序的当前目录，可以使用 GetCurrentDirectory 或 SetCurrentDirectory 方法。使用 Exists 方法检查目录是否存在，使用 CreateDirectory 方法创建目录，使用 Move 方法移动目录，使用 GetDirectories 方法获取目录中的所有子目录。
Directory 类提供了许多用于操作目录和子目录的静态方法。下面是一些常用的 Directory 类方法：

CreateDirectory：创建目录。
Delete：删除目录。
使用这个方法的时候，需要注意catch一下。当要删除的目录为非空目录时，需要指定第二个参数为true。
并且默认只删除最后的以后的一个文件夹


Exists：检查目录是否存在。
GetDirectories：返回指定目录中的所有子目录的string对象数组。
GetFiles：返回指定目录中的所有文件名称的string对象数组。
GetFileSystemEntries：返回指定目录中的所有文件和子目录的string数组
Move：移动目录。
EnumerateDirectories：枚举目录中的所有子目录。
EnumerateFiles：枚举目录中的所有文件。
EnumerateFileSystemEntries：枚举目录中的所有文件和子目录。

注意：Enum和Get的功能类似，只是返回类型由string数组变成IEnumerable&lt;string&gt;的集合。
当存在大量文件和目录的时候，EnumerateXXX方法要好于Get XXX方法。
其余不常用的方法

GetCreationTime：获取目录的创建时间。
GetCreationTimeUtc：获取目录的 UTC 创建时间。
GetCurrentDirectory：获取应用程序的当前工作目录。
GetDirectories：获取目录中的所有子目录。
GetDirectoryRoot：获取指定路径的根目录信息。
GetLastAccessTime：获取目录上次访问时间。
GetLastAccessTimeUtc：获取目录上次 UTC 访问时间。
GetLastWriteTime：获取目录上次写入时间。
GetLastWriteTimeUtc：获取目录上次 UTC 写入时间。
GetLogicalDrives：检索计算机上逻辑驱动器名称的字符串数组。
SetCreationTime：设置目录的创建时间。
SetCreationTimeUtc：设置目录的 UTC 创建时间。
SetCurrentDirectory：设置应用程序的当前工作目录。
SetLastAccessTime：设置目录上次访问时间。
SetLastAccessTimeUtc：设置目录上次 UTC 访问时间。
SetLastWriteTime：设置目录上次写入时间。
SetLastWriteTimeUtc：设置目录上次 UTC 写入时间。

DirectorInfo类DirectoryInfo类的作用类似于FileInfo类。它是一个实例化的对象，表示计算机上的单一目录。与FileInfo类一样，在Directory和DirectoryInfo之间存在许多类似的方法调用。选择使用File 或FileInfo方法的规则也适用于DirectoryInfo方法: 

如果执行单一调用，就使用静态Directory类。
如果执行一系列调用，则使用实例化的DirectoryInfo对象。

DirectoryInfo类的大多数属性继承自FileSystemInfo， 与FileInfo 类一样， 但这些属性作用于目录上，而不是文件上。还有两个DirectoryInfo专用属性。

Parent
检索一个DirectorInfo对象，表示包含当前目录的目录。这个属性是只读的。


Root
检索一个DirectorInfo对象，表示包含当前目录的根目录，例如C:\。这个属性是只读的。



文件流FileStreamFileStream是C#中用于读写文件的类，它属于System.IO命名空间。要使用FileStream操作文件，您需要创建一个FileStream类的对象。这个对象有四个参数：文件名、FileMode、FileAccess和FileShare。它为文件操作提供了一个流，可以执行同步和异步的读写操作。
当您创建一个FileStream类的对象时，需要提供四个参数：文件名、FileMode、FileAccess和FileShare。

文件名（FileName）：指定要打开或创建的文件的名称。
FileMode：指定操作文件时所使用的模式。它是一个枚举类型，包括以下几种值：Append（在文件末尾追加内容）、Create（创建新文件，如果文件已存在则覆盖）、CreateNew（创建新文件，如果文件已存在则引发异常）、Open（打开现有文件）、OpenOrCreate（打开现有文件，如果文件不存在则创建新文件）和Truncate（打开现有文件并截断为零字节）。
FileAccess：指定对文件的访问权限。它是一个枚举类型，包括以下几种值：Read（读取权限）、ReadWrite（读写权限）和Write（写入权限）。
FileShare：指定文件的共享级别。它是一个枚举类型，包括以下几种值：None（拒绝共享）、Read（允许随后打开该文件进行读取）、ReadWrite（允许随后打开该文件进行读取或写入）、Write（允许随后打开该文件进行写入）和Delete（允许随后删除该文件）。

using框架将创建文件流对象的过程写在using框架中，会自动挡释放占用的资源

创建流的过程写在小括号中
创建、写入的过程写在大括号中

using ()&#123;&#125;



使用FileStream读取文件样例1using System;using System.Collections;using System.IO;using System.Text;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            // 使用文件流打开一个文件            // 常用的一个重载是第一个参数是路径，第二个参数是打开方式            // 其中第二个参数是一个枚举类型的参数。可以选择打开、创建、追加等方式打开文件            // 这里选的枚举值是打开或创建。对于单独打开来说，如果文件不存在就会跑异常，对于打开或创建来说，如果不存在就创建一个，然后再打开            // 第三个参数的意思是对文件进行什么操作。是读、写还是又读又写            FileStream fsReader = new FileStream(@&quot;D:\tmp\tmp.txt&quot;, FileMode.OpenOrCreate, FileAccess.Read);            //创建一个5兆的buffer            byte[] buffer = new byte[1024 * 1024 * 5];            //读取数据，一次只读5兆的数据            //参数依次为：读取到哪个数组、从哪个地方开始读、读多少数据            //能少则少，降低内存压力            //返回值是实际读到的字节数            int len = fsReader.Read(buffer, 0, buffer.Length);                        // 将读到的字节按照指定的编码格式解码成字符串            //最好限制一下解码长度。可能版本更新了修复了？？            string str = Encoding.UTF8.GetString(buffer, 0, len);            Console.WriteLine(str);            Console.WriteLine($&quot;读到了&#123;len &#125;个字节&quot;);                        //使用完毕后一定要关闭流            //文件流是少数的几个垃圾回收机制gc回收不了的东西            fsReader.Close();//关闭流            fsReader.Dispose();//释放资源        &#125;    &#125;&#125;



样例2 使用using框架改造样例1using System;using System.Collections;using System.IO;using System.Text;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            byte[] buffer = new byte[1024 * 1024 * 5];            int len;            using (FileStream fsReader = new FileStream(@&quot;D:\tmp\tmp.txt&quot;, FileMode.OpenOrCreate, FileAccess.Read))            &#123;                                len = fsReader.Read(buffer, 0, buffer.Length);            &#125;            string str = Encoding.UTF8.GetString(buffer, 0, len);            Console.WriteLine(str);        &#125;    &#125;&#125;





使用FileStream写入文件using System;using System.Collections;using System.ComponentModel;using System.IO;using System.Text;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            //5KB的buffer            byte[] buffer = new byte[1024 * 1024 * 5];            for(int i = 0; i &lt; buffer.Length;i++)            &#123;                buffer[i] = (byte)((i % 26) + &#x27;a&#x27;);            &#125;            /*             * 对于文件流的写入，只要每次流不断，文件指针就不会断。             * 比如下方的例子中的Write方法，第二个值的意思是相对文件指针的位置，             * 虽然循环了十次，但写入的起始位置第一次是0，第二次就是50兆+1的位置，             * 依次类推。             * 虽然wirte的第2、3个参数是int，但不代表不能写入超过int大小的字节数             *              * 对于覆盖：             * 不想file的全部覆盖，filestream的覆盖是只覆盖有的字符。             * 比如文件原先是已经存在了的，文件中存在100字节的内容             * 现在往里面写50个字节，则只有前50个字节会被覆盖，后50个字节原来是什么还是什么             */            using (FileStream fsWrite = new FileStream(@&quot;D:\tmp\tmp_using_test.txt&quot;, FileMode.OpenOrCreate, FileAccess.Write))            &#123;                for (int i = 0; i &lt; 100; i ++)                &#123;                    fsWrite.Write(buffer, 0, buffer.Length);                &#125;            &#125;        &#125;    &#125;&#125;



StreamReader、StreamWriter常用于操作字符。
using框架同样适用于这两个。
样例1：使用StreamReader逐行读取文本文件，并将结果在控制台显示出来。using System;using System.Collections;using System.ComponentModel;using System.IO;using System.Text;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            using (StreamReader sr = new StreamReader(@&quot;D:\tmp\tmp.txt&quot;))            &#123;                // 只要文件流没到结束                while(!sr.EndOfStream)                &#123;                    //输出读到的行                    Console.WriteLine(sr.ReadLine());                &#125;            &#125;        &#125;    &#125;&#125;



样例2：使用StreamWriter向文本文件写入数据using System;using System.Collections;using System.ComponentModel;using System.IO;using System.Text;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            //对于要写入的文件来说，如果文件不存在会自动创建            using (StreamWriter sw = new StreamWriter(@&quot;D:\tmp\tmp_StreamWrite_test.txt&quot;))            &#123;                //和file一样，全部覆盖                //第二个参数可以缺省，缺省则表示使用ANSI编码（当前地区的默认编码）写入                sw.Write(&quot;StreamWrite测试&quot;, Encoding.UTF8);            &#125;            //如果需要追加，则需要在创建流的时候使用第二个参数            using (StreamWriter sw = new StreamWriter(@&quot;D:\tmp\tmp_StreamWrite_test.txt&quot;, true))            &#123;                sw.Write(&quot;\n追加测试&quot;, Encoding.UTF8);            &#125;        &#125;    &#125;&#125;



Directory用于操作文件夹和目录。
可以创建、复制、移动和删除目录和子目录。
Directory类是静态类，直接调用即可。
using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ConsoleApp4&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            //在指定目录下创建一个文件夹            //可以依次创建直到指定的目录都可以被访问到            //如果指定的目录不存在则不进行操作            //Directory.CreateDirectory(@&quot;D:\tmp\tmp\CreateTheDirectory&quot;);            // 删除指定的文件夹：            // 只能删除空的文件夹。如果文件夹非空，则抛异常            // 只会删除指定的文件夹，对于指定文件夹之前的路径不会进行删除            //Directory.Delete(@&quot;D:\tmp\tmp\CreateTheDirectory&quot;);            // 如果要删除目标文件夹不是空的，里面含义子目录或者文件，可以使用第二个参数            // 将第二个参数的值设置成true后表示全部删除            //Directory.Delete(@&quot;D:\tmp\tmp\CreateTheDirectory&quot;,true);            //移动指定的文件夹            // 如果指定的文件夹不存在，则抛出异常            // 在移动的时候可以对文件夹进行重命名            // 如果文件夹中存在子文件夹或文件，则照样移动            //Directory.Move(@&quot;D:\tmp\tmp1&quot;, @&quot;D:\tmp\tmp\tmpTest&quot;);            // 获取指定文件夹下的所有文件名            // 对所有的文件汇集到string数组中，但不汇集子目录下的文件            //string[] FileName = Directory.GetFiles(@&quot;D:\tmp\&quot;);            //foreach (string str in FileName)            //&#123;            //    Console.WriteLine(str);            //&#125;            // 可以筛选只要符合要求的文件。比如只要MP3文件            // 使用第二个参数可以进行搜索匹配，支持通配符            //FileName = Directory.GetFiles(@&quot;D:\tmp\&quot;, &quot;*.mp3&quot;);            //foreach (string str in FileName)            //&#123;            //    Console.WriteLine(str);            //&#125;            // 获取指定目录下所有文件夹的路径            // 如果指定的文件夹不存在，则抛异常            //string[] DirectoryName = Directory.GetDirectories(@&quot;D:\tmp1\&quot;);            //foreach(string dir in DirectoryName)            //&#123;            //    Console.WriteLine(dir);            //&#125;            //判断指定的路径是否存在            Console.WriteLine(Directory.Exists(@&quot;D:\tmp\&quot;));        &#125;    &#125;&#125;















































多线程进程和线程基础知识进程可以将计算机中每一个运行的程序视为一个进程。而一个进程又是由多个线程组成的。
进程指一个应用程序所运行的操作系统单元，它是操作系统环境中的基本成分、是系统进行资源分配的基本单位。
进程是执行程序的实例。当运行一个应用程序后，就生成了一个进程，这个进程拥有自己的独立内存空间。每一个进程对应一个活动的程序，当进程激活时，操作系统就将系统的资源包括内存、I&#x2F;O和CPU等分配给它，使它执行。

进程在运行时创建的资源随着进程的终止而死亡。
进程间获得专用数据或内存的唯一途径就是通过协议来共享内存块，这是一种协作策略。
一个进程可以创建多个线程及子进程（启动外部程序）。
一个进程内部的线程可以共享该进程所分配的资源。

由于进程之间的切换非常消耗资源和时间，为了提高操作系统的并发性，提高CPU的利用率，在进程下面又加入了线程的概念。线程的创建与撤销、线程之间的切换所占用的资源比进程少很多。
线程在.Net环境下，是不允许跨线程访问的。
进程可以分为若干个独立执行流（路径），这些执行流被称为线程。
线程是指进程内的一个执行单元，也是进程内的可调度实体。线程是进程的一个实体，是CPU调度和分配时间的基本单位。
线程基本不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），但是它可与同一进程的其它线程共享进程所拥有的全部资源。所以线程间共享内存空间很容易做到，多线程协作也很容易和便捷。
一个线程可以创建和撤销另一个线程，同一个进程中的多个线程间可以并发执行。
线程提供了多任务处理的能力。
线程和进程的区别
地址空间：

进程拥有自己独立的内存地址空间；

线程共享进程的地址空间；

换句话说就是进程间彼此是完全隔绝的，同一进程的所有线程共享(堆heap)内存；




资源拥有：

进程是资源分配和拥有的单位
同一进程内的线程共享进程的资源；


系统粒度：

进程是分配资源的基本单位
线程则是系统（处理器）调度的基本单位；


执行过程：

每个独立的进程都有一个程序运行的入口、顺序执行序列和程序的出口；
线程不能独立执行，必须依存于进程中；


系统开销：
创建或撤销进程时，系统都要为之分配或回收资源（如内存空间、IO设备）进程间的切换也要消耗远大于线程切换的开销。


二者均可并发执行。
一个程序至少有一个进程，一个进程至少有一个线程（主线程）。主线程以函数地址的形式，如Main或WinMain函数，提供程序的启动点，当主线程终止时，进程也随之终止。一个进程中的所有线程都在该进程的虚拟地址空间中，使用该进程的全局变量和系统资源。
并发&#x2F;并行在单CPU系统中，系统调度在某一刻只能让一个线程运行，虽然这种调度机制有多种形式（时分&#x2F;频分），但无论如何，要通过不断切换需要运行的线程，这种运行模式称为并发（Concurrent）。
而在多CPU系统中，可以让两个以上的线程同时运行，这种运行模式称为并行（Parallel）。
同步&#x2F;异步操作同步与异步的定义同步和异步关注的是消息通信机制 (synchronous communication&#x2F; asynchronous communication)

同步，就是调用某个东西，调用方得等待这个调用返回结果才能继续往后执行。（类似于函数调用？直到执行完成后才能进行下一步操作）
异步，和同步相反 调用方不会立即得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状态来通知调用者，或者通过回掉函数来处理这个调用。

所有的程序最终都会由计算机硬件来执行，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。这些无须消耗CPU时间的I&#x2F;O操作是异步操作的硬件基础。硬盘、光驱、网卡、声卡、显卡都具有DMA功能。
DMA（DirectMemory Access）是直接内存访问的意思，它是不经过CPU而直接进行内存数据存储的数据交换模式。
I&#x2F;O操作包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.Net Remoting等跨进程的调用。
异步操作可达到避免调用线程堵塞的目的，从而提高软件的可响应性。
同步与异步的对比线程不是一个计算机的硬件功能，而是操作系统提供的一种逻辑功能，线程本质上是进程中一段并发运行的代码，所以线程需要操作系统投入CPU资源来运行和调度。
异步模式无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必共享变量，减少了死锁的可能。
不过，编写异步操作的复杂程度比较高，程序主要使用回调方式进行处理，与人的思维方式有出入，而且难以调试。
计算密集型工作使用多线程（如图形处理、算法）；IO密集型工作使用异步机制。
任务管理器映射名称列：	进程并不拥有独立于其所属实例的映射名称；

如果运行5个Notepad拷贝，你会看到5个称为Notepad.exe的进程；

它们是根据进程ID进行区分的，该进程ID是由系统维护，并可以循环使用。
CPU列：它是进程中线程所占用的CPU时间百分比
每个任务管理器中的进程，其实内部都包含若干个线程，每个时间点都是某个程序进程中的某个线程在运行。
线程是如何工作的线程被一个线程协调程序管理着——一个CLR委托给操作系统的函数。线程协调程序确保将所有活动的线程被分配适当的执行时间；并且那些等待或阻止的线程——比如说在排它锁中、或在用户输入——都是不消耗CPU时间的。
在单核处理器的电脑中，线程协调程序完成一个时间片之后迅速地在活动的线程之间进行切换执行。这就导致“波涛汹涌”的行为，例如在第一个例子，每次重复的X 或 Y 块相当于分给线程的时间片。在Windows XP中时间片通常在10毫秒内选择要比CPU开销在处理线程切换的时候的消耗大的多。(即通常在几微秒区间)
在多核的电脑中，多线程被实现成混合时间片和真实的并发——不同的线程在不同的CPU上运行。但这仍然会出现一些时间切片,因为操作系统的服务线程、以及一些其他的应用程序都会争夺对CPU的使用权。
线程由于外部因素（比如时间片）被中断被称为被抢占，在大多数情况下,一个线程在被抢占的那一刻就失去了对它的控制权。
线程安全当使用线程（Thread）时，必须注意同步处理的问题
理论上每个Thread都是独立运行的个体，由CLR来主导排程，视Thread的优先权的设置，每个Thread会分到特定的运行时间，当某个Thread的运行时间用完时，CLR就会强制将运行权由该Thread取回，转交给下个Thread
这也就意味着Thread本身无法得知自己何时会丧失运行权，所以会发生所谓的race condition（竞速状态）。
当两个线程争夺一个锁的时候（在这个例子里是locker），一个线程等待，或者说被阻止到那个锁变的可用。在这种情况下，就确保了在同一时刻只有一个线程能进入临界区，所以”Done”只被打印了1次。代码以如此方式在不确定的多线程环境中被叫做线程安全。
临时暂停，或阻止是多线程的协同工作，同步活动的本质特征。等待一个排它锁被释放是一个线程被阻止的原因，另一个原因是线程想要暂停或Sleep一段时间：
Thread.Sleep (TimeSpan.FromSeconds (30)); &#x2F;&#x2F; 阻止30秒
一个线程也可以使用它的Join方法来等待另一个线程结束：
Threadt &#x3D; new Thread(Go); &#x2F;&#x2F; 假设Go是某个静态方法
t.Start();
t.Join(); &#x2F;&#x2F; 等待（阻止）直到线程t结束
使用多线程的情况分析2.1 为什么要使用多线程
并发需要在C&#x2F;S或B&#x2F;S模式下的服务端需要处理来自不同终端的并发请求，使用单线程是不可思议的。
提高应用程序的响应速度当一个耗时的操作进行时，当前程序都会等待这个操作结束此时程序不会响应键盘、鼠标、菜单等操作，程序处于假死状态；使用多线程可将耗时长的操作（Time Consuming）置于一个新的线程，此时程序仍能响应用户的其它操作
提高CPU利用率在多CPU体系中，操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。
改善程序结构一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分这样的程序会利于理解和修改。
花销小、切换快线程间的切换时间很小，可以忽略不计
方便的通信机制线程间共享内存，互相间交换数据很简单。

多线程的意义在于一个应用程序中，有多个执行部分可以同时执行：一个线程可以在后台读取数据，而另一个线程可以在前台展现已读取的数据。
C#支持通过多线程并行地执行代码，一个线程有它独立的执行路径，能够与其它的线程同时地运行。一个C#程序开始于一个单线程，这个单线程是被CLR和操作系统（也称为“主线程”）自动创建的，并具有多线程创建额外的线程。
何时使用多线程多线程程序一般被用来在后台执行耗时的任务：主线程保持运行，而工作线程执行后台工作。

对于Windows Forms程序来说，如果主线程执行了一个冗长的操作，键盘和鼠标的操作会变的迟钝，程序也会失去响应，进入假死的状态，可能导致用户强制结束程序进程而出现错误。有鉴于此，应该在主线程运行一个耗时任务时另外添加一个工作线程，同时在主线程上有一个友好的提示“处理中…”，允许继续接收事件（比如响应鼠标、键盘操作）。同时程序还应该实现“取消”功能，允许取消&#x2F;结束当前工作线程。BackgroundWorker类就提供这一功能。
在没有用户界面的程序里，比如说WindowsService中使用多线程特别的有意义。当一个任务有潜在的耗时（在等待被请求方的响应——比如应用服务器，数据库服务器），用工作线程完成任务意味着主线程可以在发送请求后立即做其它的事情。
另一个多线程的用途是在需要完成一个复杂的计算工作时,它会在多核的电脑上运行得更快，如果工作量被多个线程分开的话（C#中可使用Environment.ProcessorCount属性来侦测处理芯片的数量）。

远程服务器，或WebServices或ASP.NET程序将别无选择，必须使用多线程；
一个单线程的ASP.NET Web Service是不可想象的；
幸运的是，应用服务器中多线程是相当普遍的；
唯一值得关心的是提供适当锁机制的静态变量问题。
何时不用多线程多线程也同样会带来缺点，最大的问题是它使程序变的过于复杂。拥有多线程本身并不复杂，复杂是的线程的交互作用。无论交互是否是有意的，都会带来较长的开发周期，以及带来间歇性和非重复性的Bugs。因此，要么多线程的交互设计简单一些，要么就根本不使用多线程，除非你有强烈的重写和调试欲望。
当用户频繁地分配和切换线程时，多线程会带来增加资源和CPU的开销。在某些情况下，太多的I&#x2F;O操作是非常棘手的，当只有一个或两个工作线程要比有众多的线程在相同时间执行任务快的多。
C#中的线程程序域在.Net中Process由AppDomain对象所取代。
虽然AppDomain在CLR中被视为Process的替代品，但实际上AppDomain跟Process是属于主从关系的，AppDomain被放置在一个Process中，每个Process可以拥有多个AppDomain，每个AppDomain又可拥有多个Thread对象。
Process、AppDomain、Thread的关系如下图所示：

AppDomain定义了一些事件供程序员使用。



事件
说明



AssemblyLoad
触发于AppDomain载入一个Assembly时


DomainUnLoad
触发于AppDomain卸载时，也就是Unload函数被调用或是该AppDomain被消灭前


ProcessExit
当默认的AppDomain被卸载时触发，多半是应用程序退出时


各AppDomain间互不影响。
C#中实现线程的方法一个C#程序成为多线程可以通过2种方式来实现：

明确地创建和运行多线程
使用.NET Framework中封装了多线程的类比如:
BackgroundWorker类
线程池
Threading Timer



Thread类概述
使用Thread类通过ThreadStart（无参数）或ParameterizedThreadStart（一个输入参数）类型的委托创建一个Thread对象，开启一个新线程，执行该委托传递的任务，此时线程尚未处于运行状态。
调用Start()函数启动线程，当前线程继续执行。
调用Join()函数可以阻塞当前线程，直到调用Join()的线程终止。
调用Abort()方法，如需中止线程，在调用该方法的线程上抛出ThreadAbortException异常，以结束该线程
可以通过Thread.ResetAbort()方法阻止线程的中止。

属性表


属性
说明



Name
属性，获取或设置线程的名称


Priority
属性，获取或设置线程的优先级


ThreadState
属性，获取线程当前的状态


IsAlive
属性，获取当前线程是否处于启动状态


IsBackground
属性，获取或设置值，表示该线程是否为后台线程


CurrentThread
属性，获取当前正在运行的线程


方法表


方法
说明



Start()
方法，启动线程


Sleep(int millisecondsTimout)
方法，将当前线程暂停指定的毫秒数


Suspend()
方法，挂起当前线程（已经被弃用）


Join()
方法，阻塞调用线程，直到某个线程终止为止


Interrupt()
方法，中断当前线程


Resume()
方法，继续已经挂起的线程（已经被弃用）


Abort()
方法，终止线程（已经被弃用）


开启线程首先用new申请Thread对象，然后对象调用Start()方法启用线程。
class Program&#123;    static void DownLoad()    &#123;        Console.WriteLine(&quot;DownLoad Begin &quot; + Thread.CurrentThread.ManagedThreadId);        Thread.Sleep(1000);        Console.WriteLine(&quot;DownLoad End&quot;);    &#125;    static void Main(string[] args)    &#123;        //创建Thread对象        Thread thread = new Thread(DownLoad);        //启动线程        thread.Start();        Console.WriteLine(&quot;Main&quot;);        Console.ReadKey();    &#125;&#125;


Thread.CurrentThread.ManagedThreadId获取当前线程的ID，便于管理。

用Lambda表达式代替函数调用，也能达到相同的效果
class Program&#123;    static void Main(string[] args)    &#123;        Thread thread = new Thread(() =&gt;        &#123;            Console.WriteLine(&quot;DownLoad Begin &quot; + Thread.CurrentThread.ManagedThreadId);            Thread.Sleep(1000);            Console.WriteLine(&quot;DownLoad End&quot;);        &#125;);        thread.Start();        Console.WriteLine(&quot;Main&quot;);        Console.ReadKey();    &#125;&#125;

传递参数有两种为线程传递参数的方法：

Start()函数传参法
对象成员方法传参法
匿名方法传参法

Start()函数传参为某方法创建新线程后，在使用Start()方法启动线程时传递该方法需要的参数。
class Program&#123;    static void DownLoad(object name)    &#123;        Console.WriteLine(&quot;DownLoad Begin &quot; + name);        Thread.Sleep(1000);        Console.WriteLine(&quot;DownLoad End&quot;);    &#125;    static void Main(string[] args)    &#123;        //创建Thread对象        Thread thread = new Thread(DownLoad);        //启动线程        thread.Start(&quot;April&quot;);        Console.WriteLine(&quot;Main&quot;);        Console.ReadKey();    &#125;&#125;

对象传递初始化一个对象，然后用对象的方法初始化Thread，这样该线程就可以使用这个对象的所有成员。
class Program&#123;    public class Download    &#123;        private int Id;        private string Name;        public Download(int id, string name)        &#123;            Id = id;            Name = name;        &#125;        public void DownloadFile()        &#123;            Console.WriteLine(&quot;DownLoad Begin &quot; + &quot;ID: &quot; + Id + &quot; Name: &quot; + Name);            Thread.Sleep(1000);            Console.WriteLine(&quot;DownLoad End&quot;);                      &#125;    &#125;    static void Main(string[] args)    &#123;        Download download = new Download(1, &quot;人民日报&quot;);        Thread thread = new Thread(download.DownloadFile);        thread.Start();        Console.WriteLine(&quot;Main&quot;);        Console.ReadKey();    &#125;&#125;

匿名方法需要接收多个参数的解决方案是使用一个匿名方法调用，方法如下
class Program&#123;    static void Main()    &#123;        Thread t = new Thread(delegate() &#123; WriteText(&quot;Hello&quot;); &#125;);        t.Start();    &#125;    static void WriteText(string text)    &#123;         Console.WriteLine(text);     &#125;&#125;

它的优点是目标方法（这里是WriteText），可以接收任意数量的参数，并且没有装箱操作。
不过这需要将一个外部变量放入到匿名方法中，如下示例：
class Program&#123;    static void Main()    &#123;        string text = &quot;Before&quot;;        Thread t = new Thread(delegate () &#123; WriteText(text); &#125;);        text = &quot;After&quot;;        t.Start();    &#125;    static void WriteText(string text)     &#123;         Console.WriteLine(text);     &#125;&#125;

需要注意的是:当外部变量的值被修改，匿名方法可能进行无意的互动，导致一些古怪的现象。一旦线程开始运行，外部变量最好被处理成只读的。除非有人愿意使用适当的锁。
线程命名线程可以通过它的Name属性进行命名，这非常有利于调试：
可以用Console.WriteLine打印出线程的名字
Microsoft Visual Studio可以将线程的名字显示在调试工具栏的位置上。
线程的名字可以在被任何时间设置，但只能设置一次，重命名会引发异常。
程序的主线程也可以被命名，下面例子里主线程通过CurrentThread命名：
class ThreadNaming&#123;    static void Main()    &#123;        Thread.CurrentThread.Name = &quot;main&quot;;        Thread worker = new Thread(Go);        worker.Name = &quot;worker&quot;;        worker.Start();        Go();    &#125;    static void Go()    &#123;        Console.WriteLine(&quot;Hello from &quot; + Thread.CurrentThread.Name);    &#125;&#125;

输出
Hellofrom main
Hellofrom worker
前台线程和后台线程
前台线程(用户界面线程)只要存在有一个前台线程在运行，应用程序就在运行通常用来处理用户的输入并响应各种事件和消息
后台线程(工作线程)应用程序关闭时，如果后台线程没有执行完，会被强制性的关闭用来执行程序的后台处理任务，比如计算、调度、对串口的读写操作等

例如：
class Program&#123;    static void DownLoad()    &#123;        Console.WriteLine(&quot;DownLoad Begin &quot; + Thread.CurrentThread.ManagedThreadId);        Thread.Sleep(1000);        Console.WriteLine(&quot;DownLoad End&quot;);    &#125;    static void Main(string[] args)    &#123;        //创建Thread对象        Thread thread = new Thread(DownLoad);        //设为后台线程        thread.IsBackground = true;        //启动线程        thread.Start();        Console.WriteLine(&quot;Main&quot;);    &#125;&#125;

在上例中，thread被设置为后台线程。Main执行完后，没有前台线程了，应用程序就结束，虽然后台线程thread此时尚未执行完，也被终止。

改变线程从前台到后台不会以任何方式改变它在CPU协调程序中的优先级和状态。

拥有一个后台工作线程是有益的，最直接的理由是当提到结束程序它总是可能有最后的发言权。
交织以不会消亡的前台线程，保证程序的正常退出。
抛弃一个前台工作线程是尤为险恶的，尤其对Windows Forms程序，因为程序直到主线程结束时才退出（至少对用户来说），但是它的进程仍然运行着。
在Windows任务管理器它将从应用程序栏消失不见，但却可以在进程栏找到它。
除非用户找到并结束它，它将继续消耗资源，并可能阻止一个新的实例的运行从开始或影响它的特性。
对于程序失败退出的普遍原因就是存在“被忘记”的前台线程。



线程类型
动作
结束
后续处理



前台线程
主程序关闭
否
显示关闭线程&#x2F;杀掉当前进程


后台线程
主程序关闭
是
无


注意事项
Thread类创建的线程默认为前台线程，可以通过IsBackground属性设置其为前台或后台线程。

用Thread类创建的线程是前台线程，线程池中的线程总是后台线程


可以通过Priority属性设置线程的优先级。

线程内部可以通过try catch捕获该异常，在catch模块中进行一些必要的处理如释放持有的锁和文件资源等

慎重使用Abort()方法如果在当前线程中抛出该异常，其结果是可预测的但是对于其他线程，它会中断任何正在执行的代码，有可能中断静态对象的生成，造成不可预测的结果。


线程池概述ThreadPool类维护一个线程的列表，提供给用户以执行不同的小任务，减少频繁创建线程的开销。
该线程池可用于执行任务、发送工作项、处理异步 I&#x2F;O、代表其他线程等待以及处理计时器。
线程池其实就是一个存放线程对象的“池子(pool)”，他提供了一些基本方法，如：设置pool中最小&#x2F;最大线程数量、把要执行的方法排入队列等等。ThreadPool是一个静态类，因此可以直接使用，不用创建对象。
线程池的优点每新建一个线程都需要占用内存空间和其他资源而新建了那么多线程，有很多在休眠，或者在等待资源释放；又有许多线程只是周期性的做一些小工作，如刷新数据等等，太浪费了，划不来。实际编程中大量线程突发，然后在短时间内结束的情况很少见。
于是，就提出了线程池的概念。
线程池中的线程执行完指定的方法后并不会自动消除，而是以挂起状态返回线程池，如果应用程序再次向线程池发出请求，那么处以挂起状态的线程就会被激活并执行任务，而不会创建新线程，这就节约了很多开销。
只有当线程数达到最大线程数量，系统才会自动销毁线程。
因此，使用线程池可以避免大量的创建和销毁的开支，具有更好的性能和稳定性，其次，开发人员把线程交给系统管理，可以集中精力处理其他任务。
线程池的使用
设置线程池最大最小：ThreadPool.SetMaxThreads (int workerThreads,int completionPortThreads)
设置可以同时处于活动状态的线程池的请求数目。所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。还可以设置最小线程数。
将任务添加进线程池:ThreadPool.QueueUserWorkItem(new WaitCallback(方法名));或ThreadPool.QueueUserWorkItem(new WaitCallback(方法名), 参数);



但是线程池的使用也有一些限制：

线程池中的线程均为后台线程，并且不能修改为前台线程
不能给入池的线程设置优先级或名称
对于COM对象，入池的所有线程都是多线程单元（MTA）线程，许多COM对象都需要单线程单元（STA） 线程
入池的线程只适合时间较短的任务，如果线程需要长时间运行，应使用Thread类创建线程或使用Task的LongRunning选项
.Net下线程池最小默认允许4个工作线程，最大允许2048个工作线程。并发线程启动后，瞬间会启动4个线程。而剩下的会依据环境每0.5秒或者1秒启动一个。如果同时运行的线程达到Max工作线程，那么剩下的就会挂起直到线程池中的线程有空闲得了，才会去执行。

Parallel类概述Parallel和Task类都位于System.Threading.Task命名空间中，是对Thread和ThreadPool类更高级的抽象。
Parrallel类有For()、ForEach()、Invoke()三个方法

Invoke()实现任务并行性允许同时调用不同的方法，
Parallel.For()和 Parallel.ForEach()实现数据并行性在每次迭代中调用相同的代码

常用方法Parallel.For()Parallel.For()方法类似于 C#的 for循环语旬,也是多次执行一个任务。使用Parallel.For()方法,可以并行运行迭代。
迭代的顺序没有定义，不能保证。
在For()方法中：

前两个参数定义了循环的开头和结束。示例从0迭代到 9。
第 3个参数是一个Action委托是要并行运行迭代的方法
整数参数是循环的迭代次数,该参数被传递给Action委托引用的方法。
Parallel.For()方法的返回类型是ParalleLoopResult结构,它提供了循环是否结束的信息。

案例如下：
public static void Main()&#123;    ParallelLoopResult result = Parallel.For(0, 10, i =&gt;    &#123;        Console.WriteLine        (&quot;i:&#123;0&#125;, thread id: &#123;1&#125;&quot;, i, Thread.CurrentThread.ManagedThreadId);        Thread.Sleep(10);    &#125;);    Console.WriteLine(&quot;Is completed: &#123;0&#125;&quot;, result.IsCompleted);    //i: 0, thread id: 9    //i: 2, thread id: 10    //i: 1, thread id: 9    //i: 3, thread id: 10    //i: 4, thread id: 9    //i: 6, thread id: 11    //i: 7, thread id: 10    //i: 5, thread id: 9    //i: 8, thread id: 12    //i: 9, thread id: 11    //Is completed: True    Console.ReadKey();&#125;

同For()循环类似，Parallel.For()方法也可以中断循环的执行。
Parallel.For()方法的一个重载版本接受第3个Action&lt;int, ParallelLoopState&gt;类型的参数。使用这些参数定义一个方法,就可以调用ParalleLoopState的Break()或Stop()方法,以影响循环的结果。

注意,迭代的顺序没有定义

案例如下：
public static void Main()&#123;    ParallelLoopResult result = Parallel.For(0, 100, (i, state) =&gt;    &#123;        Console.WriteLine(&quot;i:&#123;0&#125;, thread id: &#123;1&#125;&quot;, i, Thread.CurrentThread.ManagedThreadId);        if (i &gt; 10)            state.Break();        Thread.Sleep(10);    &#125;);    Console.WriteLine(&quot;Is completed: &#123;0&#125;&quot;, result.IsCompleted);    Console.WriteLine(&quot;Lowest break iteration: &#123;0&#125;&quot;, result.LowestBreakIteration);    //i: 0, thread id: 10    //i: 25, thread id: 6    //i: 1, thread id: 10    //i: 2, thread id: 10    //i: 3, thread id: 10    //i: 4, thread id: 10    //i: 5, thread id: 10    //i: 6, thread id: 10    //i: 7, thread id: 10    //i: 8, thread id: 10    //i: 9, thread id: 10    //i: 10, thread id: 10    //i: 11, thread id: 10    //Is completed: False    //Lowest break iteration: 11    Console.ReadKey();&#125;

Parallel.For &lt; TLocal &gt;Parallel.For()方法可能使用几个线程来执行循环 。
如果需要对每个线程进行初始化,就可以使用Parallel.For方法。除了from和to对应的值之外,For()方法的泛型版本还接受3个委托参数:

第一个参数的类型是Func&lt; TLocal &gt;因为这里的例子对于TLocal使用字符串,所以该方法需要定义为Func&lt; string &gt;,即返回string的方法。这个方法仅对于用于执行迭代的每个线程调用一次
第二个委托参数为循环体定义了委托在示例中,该参数的类型是Func&lt;int, ParallelLoopState, string, string&gt;。其中第一个参数是循环迭代,第二个参数 ParallelLoopstate允许停止循环,如前所述 。循环体方法通过第3个参数接收从init方法返回的值,循环体方法还需要返回一个值,其类型是用泛型for参数定义的。
For()方法的最后一个参数指定一个委托Action&lt; TLocal &gt;;在该示例中,接收一个字符串。这个方法仅对于每个线程调用一次,这是一个线程退出方法。

案例如下：
static void Main()&#123;    Parallel.For&lt;string&gt;(0, 20, () =&gt;    &#123;        Console.WriteLine(&quot;init thread &#123;0&#125;,\t task &#123;1&#125;&quot;, Thread.CurrentThread.ManagedThreadId, Task.CurrentId);        return string.Format(&quot;t&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);    &#125;,    (i, pls, str) =&gt;    &#123;        Console.WriteLine(&quot;body i &#123;0&#125; \t str &#123;1&#125; \t thread &#123;2&#125; \t task &#123;3&#125;&quot;, i, str, Thread.CurrentThread.ManagedThreadId, Task.CurrentId);        Thread.Sleep(10);        return string.Format(&quot;i \t&#123;0&#125;&quot;, i);    &#125;,    (str) =&gt;    &#123;        Console.WriteLine(&quot;finally\t &#123;0&#125;&quot;, str);    &#125;);    Console.ReadKey();&#125;

Parallel.For 方法 (Int32, Int32, Func, Func&lt;Int32, ParallelLoopState, TLocal, TLocal&gt;, Action)
参数表：



参数名
数据类型
作用




TLoca
线程本地数据的类型


fromInclusive
System.Int32
开始索引（含）


toExclusive
System.Int32
结束索引（不含）


localInit
System.Func
用于返回每个任务的本地数据的初始状态的函数委托


body
System.Func&lt;Int32, ParallelLoopState, TLocal, TLocal&gt;
将为每个迭代调用一次的委托


localFinally
System.Action
用于对每个任务的本地状态执行一个最终操作的委托


返回值
System.Threading.Tasks.ParallelLoopResult



在迭代范围 (fromInclusive，toExclusive) ，为每个值调用一次body 委托。为它提供以下参数：

迭代次数 (Int32)
可用来提前退出循环的ParallelLoopState实例
可以在同一线程上执行的迭代之间共享的某些本地状态。

对于参与循环执行的每个任务调用 localInit 委托一次，并返回每个任务的初始本地状态。这些初始状态传递给第一个在该任务上 调用的 body。然后，每个后续正文调用返回可能修改过的状态值，传递到下一个正文调用。最后，每个任务上的最后正文调用返回传递给 localFinally 委托的状态值。每个任务调用 localFinally 委托一次，以对每个任务的本地状态执行最终操作。此委托可以被多个任务同步调用；因此您必须同步对任何共享变量的访问。
Parallel.For方法比在它执行生存期的线程可能使用更多任务，作为现有的任务完成并被新任务替换。这使基础 TaskScheduler 对象有机会添加、更改或移除服务循环的线程。
如果 fromInclusive 大于或等于 toExclusive，则该方法立即返回，而无需执行任何迭代。
Parallel.ForEach()Parallel.ForEach()方法遍历实现了IEnumerable的集合,其方式类似于foreach语句,但以异步方式遍历。这里也没有确定遍历顺序。
static void Main()&#123;    string[] data = &#123; &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;, &quot;ten&quot;, &quot;eleven&quot;, &quot;twelve&quot; &#125;;    ParallelLoopResult result = Parallel.ForEach&lt;string&gt;(data, (s) =&gt;    &#123;        Console.WriteLine(s);    &#125;);    Console.ReadKey();&#125;

中断循环如果需要中断循环,就可以使用ForEach()方法的重载版本和ParallelLoopState参数。其方式与前面的For()方法相同。ForEach()方法的一个重载版本也可以用于访问索引器,从而获得迭代次数如下所示:　
static void Main()&#123;    string[] data = &#123; &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;, &quot;ten&quot;, &quot;eleven&quot;, &quot;twelve&quot; &#125;;    ParallelLoopResult result = Parallel.ForEach&lt;string&gt;(data, (s, pls, l) =&gt;    &#123;        Console.WriteLine(&quot;&#123;0&#125;\t&#123;1&#125;&quot;, s, l);        if (l &gt; 10)        &#123;            pls.Break();        &#125;    &#125;);    Console.WriteLine(&quot;Lowest break iteration: &#123;0&#125;&quot;, result.LowestBreakIteration);    Console.ReadKey();&#125;

4.2.4 Parallel.Invoke()如果多个任务应并行运行,就可以使用Parallel.Invoke()方法。Parallel.Invoke()方法允许传递一个Action委托数组,在其中可以指定应运行的方法。示例代码传递了要并行调用的Foo()和Bar()方法:
static void Main(string[] args)&#123;    Parallel.Invoke(Foo, Bar);    Console.ReadKey();&#125;static void Foo()&#123;    Console.WriteLine(&quot;Foo&quot;);&#125;static void Bar()&#123;    Console.WriteLine(&quot;Bar&quot;);&#125;

如需同时执行多个不同的任务，可以使用Parallel.Invoke()方法，它允许传递一个Action委托数组。
public static void Main()&#123;    Parallel.Invoke(Func1, Func2, Func3);    Console.ReadKey();&#125;

Task类概述相比于Thread类，Task类为控制线程提供了更大的灵活性。

Task类可以获取线程的返回值
可以定义连续的任务：在一个任务结束结束后开启下一个任务
可以在层次结构中安排任务，在父任务中可以创建子任务这样就创建了一种依赖关系，如果父任务被取消，子任务也随之取消


注意：Task类默认使用线程池中的线程，如果该任务需长期运行，应使用TaskCreationOptions.LongRunning属性告诉任务管理器创建一个新的线程，而不是使用线程池中的线程。

任务Task和线程Thread的区别：
任务是架构在线程之上的也就是说任务最终还是要抛给线程去执行。
任务跟线程不是一对一的关系比如开10个任务并不是说会开10个线程，这一点任务有点类似线程池，但是任务相比线程池有很小的开销和精确的控制。
Task和Thread一样，位于System.Threading命名空间下!

Task的生存周期与状态


状态
说明



Created
表示默认初始化任务，但是“工厂创建的”实例直接跳过。


WaitingToRun
这种状态表示等待任务调度器分配线程给任务执行。


RanToCompletion
任务执行完毕。


static void Main()&#123;    //查看Task中的状态    var task1 = new Task(() =&gt;    &#123;        Console.WriteLine(&quot;Begin&quot;);        System.Threading.Thread.Sleep(2000);        Console.WriteLine(&quot;Finish&quot;);    &#125;);    Console.WriteLine(&quot;Before start:&quot; + task1.Status);    task1.Start();    Console.WriteLine(&quot;After start:&quot; + task1.Status);    task1.Wait();    Console.WriteLine(&quot;After Finish:&quot; + task1.Status);    /*     * Before start:Created     * After start:WaitingToRun     * Begin     * Finish     * After Finish:RanToCompletion     */&#125;

Task的使用方法启动任务以下程序演示了几种通过Task类启动任务的方式：

实例化后手动start()
var task1 = new Task(() =&gt;&#123;    //TODO you code&#125;);task1.Start();

使用Task工厂对象创建新任务并执行
TaskFactory tf = new TaskFactory();Task t1 = tf.StartNew(TaskMethod.DoTask, &quot;using a task factory&quot;);

工厂创建，直接执行
Task t2 = Task.Factory.StartNew(TaskMethod.DoTask, &quot;factory via a task&quot;);

案例如下：
public class ThreadExample&#123;    public static void Main()    &#123;        TaskFactory tf = new TaskFactory();        Task t1 = tf.StartNew(TaskMethod.DoTask, &quot;using a task factory&quot;);        Task t2 = Task.Factory.StartNew(TaskMethod.DoTask, &quot;factory via a task&quot;);        Task t3 = new Task(TaskMethod.DoTask, &quot;using a task constructor and start&quot;);        t3.Start();        //需要.NetFramework 4.5以上        var t4 = Task.Run(() =&gt; TaskMethod.DoTask(&quot;using Run method&quot;));        Console.ReadKey();    &#125;    class TaskMethod    &#123;        static object taskLock = new object();        public static void DoTask(object msg)        &#123;            lock (taskLock)            &#123;                Console.WriteLine(msg);                Console.WriteLine(&quot;Task id:&#123;0&#125;, Thread id :&#123;1&#125;&quot;,                               Task.CurrentId == null ? &quot;no task&quot; : Task.CurrentId.ToString(),                               Thread.CurrentThread.ManagedThreadId);            &#125;        &#125;    &#125;&#125;

任务控制Task.Wait()就是等待任务执行（task1）完成，task1的状态变为Completed。
Task.WaitAll()等待所有的任务都执行完成：例如：
Task.WaitAll(task,task2,task3...N)Console.WriteLine(&quot;All task finished!&quot;);

即当task,task2,task3…N全部任务都执行完成之后才会往下执行代码（打印出：“All task finished!”）
Task.WaitAny()同Task.WaitAll，等待任何一个任务完成就继续向下执行，将上面的代码WaitAll替换为WaitAny
Task.WaitAny(task,task2,task3...N)Console.WriteLine(&quot;Any task finished!&quot;);

即当task,task2,task3…N任意一个任务都执行完成之后就会往下执行代码（打印出：” Any task finished!”）
Task.ContinueWith()在第一个Task完成后自动启动下一个Task，实现Task的延续，编写如下代码：
public static void Main()&#123;    TaskFactory tf = new TaskFactory();    Task t1 = tf.StartNew(()=&gt;    &#123;        Console.WriteLine(&quot;Current Task id = &#123;0&#125;&quot;, Task.CurrentId);        Console.WriteLine(&quot;执行任务1\r\n&quot;);        Thread.Sleep(10);    &#125;);    Task t2 = t1.ContinueWith((t) =&gt;    &#123;        Console.WriteLine(&quot;Last Task id = &#123;0&#125;&quot;, t.Id);        Console.WriteLine(&quot;Current Task id = &#123;0&#125;&quot;, Task.CurrentId);        Console.WriteLine(&quot;执行任务2\r\n&quot;);        Thread.Sleep(10);    &#125;);    Task t3 = t2.ContinueWith(delegate(Task t)     &#123;        Console.WriteLine(&quot;Last Task id = &#123;0&#125;&quot;, t.Id);        Console.WriteLine(&quot;Current Task id = &#123;0&#125;&quot;, Task.CurrentId);        Console.WriteLine(&quot;执行任务3\r\n&quot;);    &#125;, TaskContinuationOptions.OnlyOnRanToCompletion);    Console.ReadKey(); &#125;    //执行结果    //    //Current Task id = 1    //执行任务1    //Last Task id = 1    //Current Task id = 2    //执行任务2    //Last Task id = 2    //Current Task id = 3    //执行任务3

从执行结果可以看出，任务1，2，3被顺序执行，同时通过 TaskContinuationOptions 还可以指定何种情况下继续执行该任务，常用的值包括OnlyOnFaulted, OnlyOnCanceled, NotOnFaulted, NotOnCanceled等。如将上例中的OnlyOnRanToCompletion改为OnlyOnFaulted，任务2结束之后，任务3将不被执行。
对于ContinueWith()的使用，MSDN演示了更加优雅的“流式”调用方法：
private void Button1_Click(object sender, EventArgs e)  &#123;     var backgroundScheduler = TaskScheduler.Default;     var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();     Task.Factory.StartNew(delegate &#123; DoBackgroundComputation(); &#125;,                           backgroundScheduler).     ContinueWith(delegate &#123; UpdateUI(); &#125;, uiScheduler).                  ContinueWith(delegate &#123; DoAnotherBackgroundComputation(); &#125;,                               backgroundScheduler).                  ContinueWith(delegate &#123; UpdateUIAgain(); &#125;, uiScheduler);  &#125;

RunSynchronously()用于实现同步调用，直接在当前线程上调用该任务。
public static void Main()&#123;    TaskMethod.DoTask(&quot;Just Main thread&quot;);    Task t1 = new Task(TaskMethod.DoTask, &quot;using Run Sync&quot;);    t1.RunSynchronously();    //输出结果    //Just Main thread    //Task id: no task, Thread id: 9    //    //using Run Sync    //Task id:1, Thread id :9&#125;

任务取消当我们启动了一个task,出现异常或者用户点击取消等等，我们可以取消这个任务。
我们通过cancellation的tokens来取消一个Task。在很多Task的Body里面包含循环，我们可以在轮询的时候判断IsCancellationRequested属性是否为True如果是True的话就return或者抛出异常，抛出异常后面再说，因为还没有说异常处理的东西。
下面在代码中看下如何实现任务的取消，代码如下：
public static void Main()        &#123;            var tokenSource = new CancellationTokenSource();            var token = tokenSource.Token;            var task = Task.Factory.StartNew(() =&gt;            &#123;                for (var i = 0; i &lt; 1000; i++)                &#123;                    System.Threading.Thread.Sleep(1000);                    if (token.IsCancellationRequested)                    &#123;                        Console.WriteLine(&quot;Abort mission success!&quot;);                        return;                    &#125;                &#125;            &#125;, token);            token.Register(() =&gt;            &#123;                Console.WriteLine(&quot;Canceled&quot;);            &#125;);            Console.WriteLine(&quot;Press enter to cancel task...&quot;);            Console.ReadKey();            tokenSource.Cancel();            Console.ReadKey();        &#125;

这里开启了一个Task,并给token注册了一个方法，输出一条信息，然后执行ReadKey开始等待用户输入，用户点击回车后，执行tokenSource.Cancel方法，取消任务。

注意：因为任务通常运行以异步方式在线程池线程上，创建并启动任务的线程将继续执行，一旦该任务已实例化。在某些情况下，当调用线程的主应用程序线程，该应用程序可能会终止之前任何任务实际开始执行。其他情况下，应用程序的逻辑可能需要调用线程继续执行，仅当一个或多个任务执行完毕。您可以同步调用线程的执行，以及异步任务它启动通过调用 Wait 方法来等待要完成的一个或多个任务。若要等待完成一项任务，可以调用其 Task.Wait 方法。调用 Wait 方法将一直阻塞调用线程直到单一类实例都已完成执行。

接收任务的返回值对于任务有返回值的情况，可使用Task泛型类，TResult定义了返回值的类型，以下代码演示了调用返回int值的任务的方法。
public static void Main()&#123;    var t5 = new Task&lt;int&gt;(TaskWithResult, Tuple.Create&lt;int, int&gt;(1, 2));    t5.Start();    t5.Wait();    Console.WriteLine(&quot;adder results: &#123;0&#125;&quot;, t5.Result);    Console.ReadKey(); &#125;public static int TaskWithResult(object o)&#123;    Tuple&lt;int, int&gt; adder = (Tuple&lt;int, int&gt;)o;    return adder.Item1 + adder.Item2;&#125;Copy

任务的层次结构如果在一个Task内部创建了另一个任务，这两者间就存在父&#x2F;子的层次结构，当父任务被取消时，子任务也会被取消。
如果不希望使用该层次结构，可在创建子任务时选择TaskCreationOptions.DetachedFromParent。
BackgroundWorker控件概述C#提供了BackgroundWorker控件帮助用户更简单、安全地实现多线程运算。
该控件提供了DoWork, ProgressChanged 和 RunWorkerCompleted事件为DoWork添加事件处理函数，再调用RunWorkerAsync()方法，即可创建一个新的线程执行DoWork任务
ProgressChanged和RunWorkerCompleted事件均在UI线程中执行，添加相应的处理函数，即可完成任务线程与UI线程间的交互，可用于显示任务的执行状态（完成百分比）、执行结果等。
同时，该控件还提供了CancleAsync()方法，以中断线程的执行需注意的是，调用该方法后，只是将控件的CancellationPending属性置True，用户需在程序执行过程中查询该属性以判定是否应中断线程。
具体用法可参考MSDN：BackgroundWorker用法范例可以看的出来，BackgroundWorker组件提供了一种执行异步操作（后台线程）的同时，并且还能妥妥的显示操作进度的解决方案。
属性表WorkerReportsProgressbool类型，指示BackgroundWorker是否可以报告进度更新。

True时，可以成功调用ReportProgress方法
否则将引发InvalidOperationException异常

用法：
private BackgroundWorker bgWorker = new BackgroundWorker();bgWorker.WorkerReportsProgress = true;

WorkerSupportsCancellationbool类型，指示BackgroundWorker是否支持异步取消操作

True时，将可以成功调用CancelAsync方法

否则将引发InvalidOperationException异用法：
bgWorker.WorkerSupportsCancellation = true;

CancellationPendingbool类型，指示应用程序是否已请求取消后台操作。此属性通常放在用户执行的异步操作内部，用来判断用户是否取消执行异步操作。当执行BackgroundWorker.CancelAsync()方法时，该属性值将变为True。用法：
//在DoWork中键入如下代码  for (int i = 0; i &lt;= 100; i++)  &#123;      if (bgWorker.CancellationPending)      &#123;          e.Cancel = true;          return;      &#125;      else      &#123;          bgWorker.ReportProgress(i,&quot;Working&quot;);          System.Threading.Thread.Sleep(10);      &#125;  &#125;   

IsBusybool类型，指示BackgroundWorker是否正在执行一个异步操作。此属性通常放在BackgroundWorker.RunWorkerAsync()方法之前，避免多次调用RunWorkerAsync()方法引发异常。当执行BackgroundWorker.RunWorkerAsync()方法是，该属性值将变为True。
//防止重复执行异步操作引发错误 if (bgWorker.IsBusy)     return; bgWorker.RunWorkerAsync();

方法表RunWorkerAsync()开始执行一个后台操作。
调用该方法后，将触发BackgroundWorker.DoWork事件，并以异步的方式执行DoWork事件中的代码。该方法还有一个带参数的重载方法：RunWorkerAsync(Object)。该方法允许传递一个Object类型的参数到后台操作中，并且可以通过DoWork事件的DoWorkEventArgs.Argument属性将该参数提取出来。

注：当BackgroundWorker的IsBusy属性为True时，调用该方法将引发InvalidOperationException异常。

//在启动异步操作的地方键入代码bgWorker.RunWorkerAsync(&quot;hello&quot;);

ReportProgress(Int percentProgress)报告操作进度。
调用该方法后，将触发BackgroundWorker. ProgressChanged事件。另外，该方法包含了一个int类型的参数percentProgress，用来表示当前异步操作所执行的进度百分比。
该方法还有一个重载方法：ReportProgress(Int percentProgress, Object userState)。允许传递一个Object类型的状态对象到 ProgressChanged事件中并且可以通过ProgressChanged事件的ProgressChangedEventArgs.UserState属性取得参数值。

注：调用该方法之前需确保WorkerReportsProgress属性值为True，否则将引发InvalidOperationException异常。

用法：
for (int i = 0; i &lt;= 100; i++)&#123;    //向ProgressChanged报告进度    bgWorker.ReportProgress(i,&quot;Working&quot;);    System.Threading.Thread.Sleep(10);&#125;

CancelAsync()请求取消当前正在执行的异步操作。
调用该方法将使BackgroundWorker.CancellationPending属性设置为True。但需要注意的是，并非每次调用CancelAsync()都能确保异步操作，CancelAsync()通常不适用于取消一个紧密执行的操作，更适用于在循环体中执行。用法：
//在需要执行取消操作的地方键入以下代码bgWorker.CancelAsync();

事件表DoWork用于承载异步操作。当调用BackgroundWorker.RunWorkerAsync()时触发。
需要注意的是：由于DoWork事件内部的代码运行在非UI线程之上，所以在DoWork事件内部应避免于用户界面交互，而于用户界面交互的操作应放置在ProgressChanged和RunWorkerCompleted事件中。
ProgressChanged当调用BackgroundWorker.ReportProgress(int percentProgress)方式时触发该事件。该事件的ProgressChangedEventArgs.ProgressPercentage属性可以接收来自ReportProgress方法传递的percentProgress参数值,ProgressChangedEventArgs.UserState属性可以接收来自ReportProgress方法传递的userState参数。
RunWorkerCompleted异步操作完成或取消时执行的操作，当调用DoWork事件执行完成时触发。
该事件的RunWorkerCompletedEventArgs参数包含三个常用的属性Error,Cancelled,Result。其中，Error表示在执行异步操作期间发生的错误；Cancelled用于判断用户是否取消了异步操作；Result属性接收来自DoWork事件的DoWorkEventArgs参数的Result属性值，可用于传递异步操作的执行结果。
案例using System;using System.ComponentModel;using System.Threading;using System.Windows.Forms; namespace bcworker&#123;    public partial class Form1 : Form    &#123;        //后台工作        private BackgroundWorker bw = new BackgroundWorker();         public Form1()        &#123;            InitializeComponent();            //后台工作初始化            bw.WorkerReportsProgress = true;//报告进度            bw.WorkerSupportsCancellation = true;//支持取消            bw.DoWork += new DoWorkEventHandler(bgWorker_DoWork);//开始工作            bw.ProgressChanged += new ProgressChangedEventHandler(bgWorker_ProgessChanged);//进度改变事件            bw.RunWorkerCompleted += new RunWorkerCompletedEventHandler(bgWorker_WorkerCompleted);//进度完成事件        &#125;         private void btnStart_Click(object sender, EventArgs e)        &#123;            //后台工作运行中，避免重入            if (bw.IsBusy) return;            bw.RunWorkerAsync(&quot;参数&quot;);//触发DoWork事件并异步执行，IsBusy置为True        &#125;        //后台工作将异步执行        public void bgWorker_DoWork(object sender, DoWorkEventArgs e)        &#123;            //(string)e.Argument == &quot;参数&quot;;            for (int i = 0; i &lt;= 100; i++)            &#123;                 if (bw.CancellationPending)                &#123;//用户取消了工作                    e.Cancel = true;                    return;                &#125;                else                &#123;                    bw.ReportProgress(i, &quot;Working&quot;);//报告进度，触发ProgressChanged事件                    Thread.Sleep(10);//模拟工作                &#125;            &#125;        &#125;        //进度改变事件        public void bgWorker_ProgessChanged(object sender, ProgressChangedEventArgs e)        &#123;            //(string)e.UserState==&quot;Working&quot;            progressBar1.Value = e.ProgressPercentage;//取得进度更新控件，不用Invoke了        &#125;        //后台工作执行完毕,IsBusy置为False        public void bgWorker_WorkerCompleted(object sender, RunWorkerCompletedEventArgs e)        &#123;            //e.Error == null 是否发生错误            //e.Cancelled 完成是由于取消还是正常完成        &#125;         private void btnCancel_Click(object sender, EventArgs e)        &#123;            if (bw.IsBusy) bw.CancelAsync();//设置CancellationPending属性为True        &#125;     &#125;&#125;



调用系统对话框注意，需要在winform应用程序下实现。
如需在控制台中使用，注意引入System.Windows.Forms命名空间（需要先引入对应的dll），而且还存在某些问题
打开文件对话框public void OpenFileDialogFunction()&#123;    /*实例化出打开文件对话框的对象*/    OpenFileDialog ofd = new OpenFileDialog();    /*设置对话框的参数*/    //设置对话框的标题    ofd.Title = &quot;对话框的标题&quot;;    //设置对话框是否可以多选文件。允许多选为true，否则为false    ofd.Multiselect = true;    //设置对话框的初始目录    //默认是在当前用户的文档文件夹下？    ofd.InitialDirectory = @&quot;D:\files&quot;;    //设置允许打开文件的类型    //竖线分隔，前面是提示信息，后面是筛选的文件格式。支持多个，可以一对一，也可以一对多。    //对于一对多（多个文件格式）,每个筛选条件后面都需要加上分号表示结束。    ofd.Filter = &quot;文本文件|*.txt; | 可执行文件|*.exe;*.apk; | 压缩文件|*.zip;*.rar;*.7z; | 所有文件|*.*;&quot;;    /*显示对话框*/    ofd.ShowDialog();    /*获取选中文件的路径*/    //对于允许多选的打开文件类型，可以通过FileNames获取。    //如果允许了多选文件，并且运行的时候确实多选了文件，使用FileName属性获取也不会报错    //只是只会获取到多选中第一个文件的路径    string[] fileName = ofd.FileNames;    /*将获取到的信息展示出来*/    lblInfo.Text = &quot;&quot;;    foreach(string file in ofd.FileNames)    &#123;        lblInfo.Text += file;        lblInfo.Text += &quot;\n&quot;;    &#125;&#125;



保存文件对话框public void SaveFileDialogFunction()&#123;    //实例化出一个保存对话框的对象    SaveFileDialog sfd = new SaveFileDialog();    /*设置对话框的属性*/    //设置对话框的标题    sfd.Title = &quot;保存对话框的标题&quot;;    //设置保存对话框的默认路径    sfd.InitialDirectory = @&quot;D:\files&quot;;    //设置保存的格式    sfd.Filter = &quot;文本文件|*.txt; | 所有文件|*.*&quot;;    //对于保存对话框来说，不存在多选的选项    /*展示对话框*/    sfd.ShowDialog();    /*获取用户要保存的路径*/    //因为不允许多选，因此这里只有这一个属性    string path = sfd.FileName;    lblInfo.Text = path;&#125;

Socket套接字Socket作为进程通信机制，通常也被称为套接字。用于描述IP地址和端口号，是一个通信链的句柄。
建立连接的时候，服务器应该有一个用于监听的Socket，用于监听应用程序是否有人连接。这个有用于监听的Socket就相当于电话的接线员，一旦检测到有连接，就创建一个负责跟客户端连接的Socket。此时，服务器端Socket的数量为2（至少两个），其中一个只负责监听，另外一个只负责通信；而客户端，从始至终都只有1个Socket。
需要注意，一个Socket一次只能连接一台主机，且Socket被关闭后无法再次被使用。
每个Socket对象只能一台主机连接，如果需要连接多台主机，必须创建多个Socket对象。
Socket的通信过程服务器端
申请一个Socket
绑定到一个IP地址和端口号上
开启侦听，等待连接

客户端
申请一个Socket
连接服务器（需要指明ip地址和端口号）

过程服务器接到连接请求后，产生一个新的Socket（端口号需要大于1024）与客户端建立连接并进行通信，原监听Socket继续监听。

Socket的构造函数连接通过构造函数
GDI+​	GDI+ (Graphics Device Interface)是一种绘图装置接口，可应用程序和绘图硬件分隔，让我们能够编写与装置无关的应用程序。它可以让我们不需注意特定显示装置的详细数据，便可在屏幕或打印机显示信息。我们可以呼叫GDI+类别所提供的方法，然后这些方法会适当地呼叫特定的装置驱动程序，而完成绘图。而且与.NET进行了更好的融合。
后端using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace GDITest&#123;    public partial class Form1 : Form    &#123;        public Form1()        &#123;            InitializeComponent();        &#125;        /*        * 在Windows中，当窗口移动、最小化、还原或遮盖时，窗口的内容会被清除。        * 为了保持窗口内容的一致性，需要在窗口的Paint事件中重新绘制窗口内容。        * 这就是为什么需要重新绘制的原因。        *         * 只要在事件中添加了对应的方法后，只要对应的图形出显示屏        * 系统就会自动调用这个事件。重新绘制（只要出一点就调用）        */        /// &lt;summary&gt;        /// 使用GDI绘制一条直线        /// &lt;/summary&gt;        void GDITest1()        &#123;            //使用GDI绘制的时候，需要准备一根笔、颜色、两个点、绘制直线的对象            //创建GDI对象            //Graphics g = new Graphics(); 不能直接创建            Graphics g = this.CreateGraphics();//只能通过this创建对象            //创建画笔对象            Pen pen = new Pen(Brushes.Blue);            //创建两个点，用于确定绘制范围            Point p1 = new Point(30, 50);            Point p2 = new Point(250, 250);            //开始绘制            g.DrawLine(pen, p1, p2);        &#125;        /// &lt;summary&gt;        /// 使用GDI绘制一个矩形        /// &lt;/summary&gt;        void GDITest2()        &#123;            //获得GDI对象            Graphics g = this.CreateGraphics();            //实例化画笔            Pen pen = new Pen(Brushes.Blue);            //设置绘制的大小            Size size = new System.Drawing.Size(80, 80);            //设置要绘制的矩形尺寸，从窗口左上角开始的50，50点开始，生成一个80x80像素的矩形            Rectangle r1 = new Rectangle(new Point(50, 50), size);            //使用画笔绘制出指定的矩形            g.DrawRectangle(pen, r1);        &#125;        /// &lt;summary&gt;        /// 绘制一个扇形        /// &lt;/summary&gt;        void GDITest3()        &#123;            Graphics g = this.CreateGraphics();            //从文本框中拿到所需要的信息            if (txt1.Text == &quot;&quot; || txt2.Text == &quot;&quot; || txt3.Text == &quot;&quot; || txt4.Text == &quot;&quot; || txt5.Text == &quot;&quot; || txt6.Text == &quot;&quot;)            &#123;                MessageBox.Show(&quot;请在个文本框中分别输入信息以生成扇形&quot;);                return;            &#125;            int x = int.Parse(txt1.Text);            int y = int.Parse(txt2.Text);            int L = int.Parse(txt3.Text);            int W = int.Parse(txt4.Text);            float f1 = float.Parse(txt5.Text);            float f2 = float.Parse(txt6.Text);                        //生成一个画笔和对应的颜色            Pen pen = new Pen(Color.Blue);            //生成一个矩形            Size size = new System.Drawing.Size(L, W);//设置一下初始位置            Rectangle r1 = new Rectangle(new Point(x, y), size);//借助位置生成一个矩形                        //需要四个参数，分别是画笔、矩形和两个角度。            //两个角度分别是：从x轴到扇形的第一条边沿顺时针方向度量的角（以度为单位）            //和： 从上一个参数开始到扇形的第二条边沿顺时针方向度量的角（以度为单位）            g.DrawPie(pen, r1, f1, f2);        &#125;        /// &lt;summary&gt;        /// 使用GDI绘制一个文本        /// &lt;/summary&gt;        void GDITest4()        &#123;            int x = int.Parse(txt1.Text);            int y = int.Parse (txt2.Text);            //获取GDI对象            Graphics g =this.CreateGraphics();            //所需参数：            //要显示的文本信息            //字体信息            //颜色            //显示位置            g.DrawString(txtInfo.Text, new Font(&quot;微软雅黑&quot;, 20, FontStyle.Bold), Brushes.Black, new Point(x, y));        &#125;        /// &lt;summary&gt;        /// 绘制一个验证码        /// &lt;/summary&gt;        void GDITest5()        &#123;            //生成随机数            Random random = new Random();            string str = null;            for(int i = 0; i &lt; 5; i++)            &#123;                int rNum = random.Next(0, 10);                str += rNum.ToString();            &#125;            //生成位图            //因为Bitmap继承于Image，而Image是抽象类不可以被实例化，因此只能用Bitmap替代Image传入GDI            Bitmap bmp = new Bitmap(100, 20);            //创建GDI对象            Graphics g = Graphics.FromImage(bmp);            //设置一些随机化的值            //生成的字体从这些集合中选            string[] fonts = &#123; &quot;微软雅黑&quot;, &quot;宋体&quot;, &quot;隶书&quot;, &quot;黑体&quot;, &quot;仿宋&quot; &#125;;            //文字的颜色在这个集合中随机选            Color[] colors = &#123; Color.Yellow, Color.Blue, Color.Red, Color.Black, Color.Green &#125;;            //将产生的随机数绘制到位图中            for(int i = 0; i &lt; 5; i++)            &#123;                Point point = new Point(i * 15 + 2, 0);                g.DrawString(str[i].ToString(), new Font(fonts[random.Next(0,5)], 15, FontStyle.Bold), new SolidBrush(colors[random.Next(0,5)]), point);            &#125;            //增加干扰线            for(int i = 0;i &lt; 15; i++)            &#123;                //随机生成点作为绘制坐标。                //要求起始点的横坐标在0到图片的宽度之间，纵坐标在0到图片的高度之间随机选择                Point p1 = new Point(random.Next(0, bmp.Width), random.Next(0, bmp.Height));                Point p2 = new Point(random.Next(0, bmp.Width), random.Next(0, bmp.Height));                g.DrawLine(new Pen(Brushes.Green), p1, p2);            &#125;            //增加像素颗粒            for(int i = 0; i &lt; 100; i++)            &#123;                bmp.SetPixel(random.Next(0, bmp.Width), random.Next(0, bmp.Height), Color.Black);            &#125;            //将图片镶嵌到PictureBox中            pictureBox1.Image = bmp;        &#125;        private void btn1_Click(object sender, EventArgs e)        &#123;            GDITest1();        &#125;        //在窗口改变的时候重新绘制指定的GDI        private void Form1_Paint(object sender, PaintEventArgs e)        &#123;            //GDITest1();        &#125;        private void button2_Click(object sender, EventArgs e)        &#123;            GDITest2();        &#125;        private void btn3_Click(object sender, EventArgs e)        &#123;            GDITest3();        &#125;        private void Form1_Load(object sender, EventArgs e)        &#123;        &#125;        private void btn4_Click(object sender, EventArgs e)        &#123;            GDITest4();        &#125;        private void btn5_Click(object sender, EventArgs e)        &#123;            GDITest5();        &#125;    &#125;&#125;





序列化关于二进制序列化需要注意的事项:
要序列化的类型必须标记为: [Serializable]
该类型的父类也必须标记为: [Serializable]
该类型中的所有成员的类型也必须标记为: [Seralizable]
序列化只会对类中的字段序列化。(只能序列化一些状态信息)
需要头文件：System.Runtime.Serialization.Formatters.Binary

using System;using System.Runtime.Serialization.Formatters.Binary;namespace ConsoleApp&#123;    class Program    &#123;        /*         * 序列化步骤：         * 首先将要序列化的对象的类标记为可以被序列化的         * 然后产生一个文件流用于写入被序列化的对象（可缺省？）         * 接着创建一个BinaryFormatter的对象用于对目标类进行序列化         * 最后调用这个对象的Serialize方法将目标对象进行序列化，并保存到对应的位置         */        static void Main(string[] args)         &#123;            //创建Person对象            Person p = new Person();            p.Name = &quot;张三&quot;;            p.Age = 30;            p.Gender = &#x27;男&#x27;;            using (FileStream fsWrite = new FileStream(@&quot;D:\tmp\tmp.txt&quot;, FileMode.OpenOrCreate, FileAccess.Write))            &#123;                //创建用于序列化的对象                BinaryFormatter bf = new BinaryFormatter();                //开始序列化                bf.Serialize(fsWrite, p);            &#125;            Console.WriteLine(&quot;序列化完成&quot;);                      //开始反序列化            //将保存到文件的对象的字段信息还原成一个对象            using(FileStream fsRead = new FileStream(@&quot;D:\tmp\tmp.txt&quot;, FileMode.Open, FileAccess.Read))            &#123;                //创建用于反序列化的对象                BinaryFormatter bf = new BinaryFormatter();                //反序列化对象                //返回的是一个object类型的对象                object o =  bf.Deserialize(fsRead);                //经is判断可以得出o是Person的对象                Console.WriteLine(o is Person);                //拆箱成为原始类型的对象                Person pt = (Person)o;                //输出反序列化后的一些信息                Console.WriteLine(pt.Name);                Console.WriteLine(pt.Age);                Console.WriteLine(pt.Gender);                            &#125;        &#125;    &#125;    //将类标记为可以被序列化的    [Serializable]    public class Person    &#123;        public string Name &#123; get; set; &#125;        public int Age &#123; get; set; &#125;        public char Gender &#123; get; set; &#125;    &#125;&#125;



c#复制c#中复制可分为深复制、浅复制两种。
首先要明确拷贝产生的结果都是reference type（引用类型）的，本质上还是指向一个对象（毕竟primitive type（简单类型）不需要）
所以深拷贝和浅拷贝的区别，就是拷贝这个reference指向的对象是不是之前的。
浅复制对于值类型来说，C#中的浅复制指的是创建一个新对象，并将当前对象的值类型字段复制到新对象中。
对于数据是引用类型时，只复制引用，而不复制引用的对象本身。因此，原始对象和副本对象指向同一个对象。浅复制可以使用Object.MemberwiseClone方法来实现，也可以使用其他方式。与深复制相比，浅复制更快，但也更容易出现数据不一致或内存泄漏的问题。
使用浅复制的场景
当我们想要创建一个新对象，但不想完全复制原始对象的所有数据时，例如，当原始对象包含大量的引用类型字段时，深复制会消耗更多的内存和时间。
当我们想要保持原始对象和副本对象之间的一些联系时，例如，当原始对象和副本对象共享一些引用类型字段时，我们可以通过修改其中一个来影响另一个。
当我们不需要担心数据不一致或内存泄漏的问题时，例如，当原始对象和副本对象的生命周期相同或相近时，或者当我们可以正确地管理引用类型字段的释放时。

样例假设有一个类Person，它有两个字段：name和address。name是一个字符串，是值类型；address是一个类Address，是引用类型。
下面是Person类的定义：
class Person&#123;    public string name;    public Address address;    public Person(string name, Address address)    &#123;        this.name = name;        this.address = address;    &#125;    public Person ShallowCopy()    &#123;        return (Person)this.MemberwiseClone();//MemberwiseClone()功能见后续解释    &#125;&#125;

下面是Address类的定义：
class Address&#123;    public string city;    public string street;    public Address(string city, string street)    &#123;        this.city = city;        this.street = street;    &#125;&#125;

现在我们创建一个Person对象p1，并用ShallowCopy方法创建一个浅复制对象p2：
Person p1 = new Person(&quot;Alice&quot;, new Address(&quot;Beijing&quot;, &quot;Xidan&quot;));Person p2 = p1.ShallowCopy();

这时，p1和p2都有相同的name和address字段的值，但是它们指向不同的对象。如果我们修改p1的name字段，那么p2的name字段不会受到影响，因为它们是值类型：
p1.name = &quot;Bob&quot;;Console.WriteLine(p1.name); // BobConsole.WriteLine(p2.name); // Alice

但是如果我们修改p1的address字段，那么p2的address字段也会受到影响，因为它们是引用类型，并且指向同一个Address对象：
p1.address.city = &quot;Shanghai&quot;;Console.WriteLine(p1.address.city); // ShanghaiConsole.WriteLine(p2.address.city); // Shanghai

样例中部分方法的解释MemberwiseClone()MemberwiseClone();是一个Object类的方法，它可以创建一个新对象，其字段是对原始对象字段的逐位复制。如果字段是值类型的，那么新对象和原始对象的字段值相同；如果字段是引用类型的，那么新对象和原始对象的字段指向同一个引用对象。因此，MemberwiseClone();方法可以实现浅复制。要使用这个方法，我们需要在自定义类中定义一个ShallowCopy()方法，并在其中调用MemberwiseClone();方法，然后返回新对象。
浅复制与赋值的区别浅复制和赋值的区别是，浅复制会创建一个新对象，并将原始对象的值类型字段复制到新对象中，而赋值只是将原始对象的引用赋给一个变量，不会创建新对象。例如，如果我们用赋值代替浅复制：
Person p1 = new Person(&quot;Alice&quot;, new Address(&quot;Beijing&quot;, &quot;Xidan&quot;));Person p2 = p1;

这时，p1和p2都指向同一个Person对象，如果我们修改p1或p2的任何字段，都会影响另一个变量：
p1.name = &quot;Bob&quot;;Console.WriteLine(p1.name); // BobConsole.WriteLine(p2.name); // Bobp2.address.city = &quot;Shanghai&quot;;Console.WriteLine(p1.address.city); // ShanghaiConsole.WriteLine(p2.address.city); // Shanghai





深复制为什么要用到深拷贝呢？比如我们建了某个类Person，并且实例化出一个对象，然后，突然需要把这个对象复制一遍，并且复制出来的对象要跟之前的一模一样，如果两个变量直接赋值，如： A a = new A(); A b = a; 得到的还是同一个对象，并没有复制真正的内容。这时候如果需要复制真正内容的话，就需要用到深拷贝的方式了。
几种常见的深拷贝方式利用反射实现public static T DeepCopyByReflection&lt;T&gt;(T obj)&#123;　　if (obj is string || obj.GetType().IsValueType)　　return obj;　　object retval = Activator.CreateInstance(obj.GetType());　　FieldInfo[] fields = obj.GetType().GetFields(BindingFlags.Public|BindingFlags.NonPublic|BindingFlags.Static|BindingFlags.Instance);　　foreach(var field in fields)　　&#123;　　　　try　　　　&#123;　　　　　　field.SetValue(retval, DeepCopyByReflection(field.GetValue(obj)));　　　　&#125;　　　　catch &#123; &#125;　　&#125;　　return (T)retval;&#125;

利用二进制序列化和反序列化public static T DeepCopyByBinary&lt;T&gt;(T obj)&#123;　　object retval;　　using (MemoryStream ms = new MemoryStream())　　&#123;　　　　BinaryFormatter bf = new BinaryFormatter();　　　　bf.Serialize(ms, obj);　　　　ms.Seek(0, SeekOrigin.Begin);　　　　retval = bf.Deserialize(ms);　　　　ms.Close();　　&#125;　　return (T)retval;&#125;

注意，使用二进制序列化和反序列化时，在需要序列化的类上要加上[Serializable]
[Serializable]public class Person&#123;　　public string Name &#123; get; set; &#125;&#125;

利用xml序列化和反序列化public static T DeepCopyByXml&lt;T&gt;(T obj)&#123;　　object retval;　　using (MemoryStream ms = new MemoryStream())　　&#123;　　　　XmlSerializer xml=new XmlSerializer(typeof(T));　　　　xml.Serialize(ms, obj);　　　　ms.Seek(0, SeekOrigin.Begin);　　　　retval = xml.Deserialize(ms);　　　　ms.Close();　　&#125;　　return (T)retval;&#125;





c#中复制可分为深复制、浅复制两种。
首先要明确拷贝产生的结果都是reference type（引用类型）的，本质上还是指向一个对象（毕竟primitive type（简单类型）不需要）
所以深拷贝和浅拷贝的区别，就是拷贝这个reference指向的对象是不是之前的。
有以下两种方式，更推荐第一种：
泛型+反射/* 利用反射实现深拷贝*/public static object DeepCopy(object _object)&#123;    Type T = _object.GetType();    object o = Activator.CreateInstance(T);    PropertyInfo[] PI = T.GetProperties();    for (int i = 0; i &lt; PI.Length; i++)    &#123;        PropertyInfo P = PI[i];        P.SetValue(o, P.GetValue(_object));    &#125;    return o;&#125;


反射是.NET中的重要机制,通过反射,可以在运行时获得程序或程序集中每一个类型(包括类、结构、委托、接口和枚举等)的成员和成员的信息。有了反射,即可对每一个类型了如指掌。另外我还可以直接创建对象,即使这个对象的类型在编译时还不知道。可以实现从对象的外部来了解对象(或程序集)内部结构的功能,哪怕你不知道这个对象(或程序集)是个什么东西,另外.NET中的反射还可以运态创建出对象并执行它其中的方法。为什么要用反射呢? 举个最简单的例子,当你在VS的设计器里拖入一个控件后,设计器会通过反射获取这个控件的属性,并提供给你进行设置，设计器在做的时候,根本不可能预知将来有什么控件会被你拖入进去，所以要用反射。

这样的好处在于，它消除了模块之间的耦合，便于动态接口调用，在一些灵活的系统里面比较常用。
反射和泛型来实现深拷贝怎么做
首先我们应该获取传入参数的那个对象的类型，也就是反射的GetType()
接下来Activator.CreateInstance(T); 用类型创建新拷贝的对象
PropertyInfo[] PI &#x3D; T.GetProperties(); 这里使用PropertyInfo了解属性的名称、数据类型、声明类型、反射类型和只读或可写状态等,获取或设置属性值。
接下来用Property的SetValue和GetValue来给新对象属性逐个赋值
大功告成，返回新对象就行

所以思路很清晰，调用的时候 Test b &#x3D; (Test)DeepCopy(a); 泛型把object转回来就行
总的来说我觉得这是一种比较简单直接也好理解的方法
二进制流的方式（序列化）/// 深拷贝 【不建议使用二进制流方法，此方法即使在类前面加了可序列化标志，调用该方法时也会报未序列化错误】，推荐使用反射方式public object DeepCopy()&#123;    using (MemoryStream stream = new MemoryStream())    &#123;        BinaryFormatter bFormatter = new BinaryFormatter();        bFormatter.Serialize(stream, this);        stream.Seek(0, SeekOrigin.Begin);        return (InvoiceDetailResponse)bFormatter.Deserialize(stream);    &#125;&#125;













return原则尽早return在进入方法的时候先判断是否满足条件，如果不满足直接return；而不是判断条件是否满足而执行指定的代码。
必须保证一定可以return单例模式只能创建一个对象

将构造函数私有化
对外提供一个静态方法，返回一个对象
创建一个单例
返回单例

演示环境：WinForm
Form1代码：using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace 单例模式&#123;    public partial class Form1 : Form    &#123;        public Form1()        &#123;            InitializeComponent();        &#125;        private void Form1_Load(object sender, EventArgs e)        &#123;        &#125;        private void button1_Click(object sender, EventArgs e)        &#123;                        Form2 frm2 = Form2.GetSingle();            frm2.ShowDialog();        &#125;    &#125;&#125;

Form2代码using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace 单例模式&#123;    public partial class Form2 : Form    &#123;        //全局唯一的单例        public static Form2 FrmSingle = null;        //首先私有化构造函数        private Form2()        &#123;            InitializeComponent();        &#125;        private void Form2_Load(object sender, EventArgs e)        &#123;        &#125;        /// &lt;summary&gt;        /// 提供一个静态方法，返回一个对象        /// &lt;/summary&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public static Form2 GetSingle()        &#123;            //只有这个对象没被实例化的时候才会被创建对象            if(FrmSingle == null)            &#123;                FrmSingle = new Form2();            &#125;            //如果已经存在了一个对象，则直接返回这个对象            return FrmSingle;        &#125;    &#125;&#125;



XML 可扩展的标记语言用于存储数据，并且严格区分大小写。
xml中所有能看到的都是元素
其中一对一对的标签都是节点。
节点包含元素，但元素不都是节点。
对于xml文档来说，有且只能有一个根节点。
通过代码创建xml文档
引用命名空间
创建xml文档对象
创建根节点
创建子节点
为子节点再创建子节点
将子节点添加到父节点
保存xml对象。

using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Xml;namespace XML&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            //2. 创建xml对象            XmlDocument doc = new XmlDocument();            //3. 创建第一行描述信息，并添加到doc文档中            //第一个参数是xml的版本号，第二个是编码方式            //返回的是一个类型为XmlDeclaration的xml节点信息            XmlDeclaration dec =  doc.CreateXmlDeclaration(&quot;1.0&quot;, &quot;utf-8&quot;, null);            //4. 将节点加入到xml文档中            doc.AppendChild(dec); //追加节点            //创建根节点            XmlElement books = doc.CreateElement(&quot;Books&quot;);            //将根节点添加到文档中            doc.AppendChild(books);            //5. 给根节点Books创建子节点            XmlElement book1 = doc.CreateElement(&quot;Boook&quot;);            //将创建出来的子节点添加到根节点中            books.AppendChild(book1);            //6. 给Book1添加子节点            XmlElement name1 = doc.CreateElement (&quot;Name&quot;);            XmlElement price1 = doc.CreateElement(&quot;Price&quot;);            XmlElement des1 = doc.CreateElement(&quot;Des&quot;);            //给这个子节点添加文本            name1.InnerText = &quot;西游记&quot;;            price1.InnerText = &quot;10&quot;;            des1.InnerText = &quot;向西的游记&quot;;            //将子节点添加到Book1中            book1.AppendChild(name1);            book1.AppendChild (price1);            book1.AppendChild (des1);            //将xml进行保存            doc.Save(@&quot;D:\tmp\test.xml&quot;);        &#125;    &#125;&#125;





创建带属性的XML文档static void Main(string[] args)&#123;    //创建xml对象    XmlDocument doc = new XmlDocument();    //创建版本声明    XmlDeclaration dec = doc.CreateXmlDeclaration(&quot;1.1&quot;, &quot;utf-8&quot;, null);    //将版本声明添加到xml对象中    doc.AppendChild(dec);    //创建根节点    XmlElement order = doc.CreateElement(&quot;Order&quot;);    doc.AppendChild(order);    //创建子节点，并将子节点添加到根节点    XmlElement customerName = doc.CreateElement(&quot;CustomerName&quot;);    customerName.InnerText = &quot;张三&quot;;    order.AppendChild(customerName);    XmlElement customerNumber = doc.CreateElement(&quot;CustomerNumber&quot;);    customerNumber.InnerText = &quot;10001&quot;;    order.AppendChild(customerNumber);    //创建带属性的子节点    XmlElement items = doc.CreateElement(&quot;items&quot;);    order.AppendChild(items);    XmlElement orderItem1 = doc.CreateElement(&quot;OrderItem&quot;);    //给节点添加属性    orderItem1.SetAttribute(&quot;Name&quot;, &quot;码表&quot;);    orderItem1.SetAttribute(&quot;Count&quot;, &quot;10&quot;);    //将这个子节点添加到Item    items.AppendChild(orderItem1);    //添加更多带属性的子节点    XmlElement orderItem2 = doc.CreateElement(&quot;OrderItem&quot;);    orderItem2.SetAttribute(&quot;Name&quot;, &quot;ESP8266&quot;);    orderItem2.SetAttribute(&quot;Count&quot;, &quot;10&quot;);    items.AppendChild(orderItem2);    XmlElement orderItem3 = doc.CreateElement(&quot;OrderItem&quot;);    orderItem3.SetAttribute(&quot;Name&quot;, &quot;ESP8266&quot;);    orderItem3.SetAttribute(&quot;Count&quot;, &quot;10&quot;);    items.AppendChild(orderItem3);    XmlElement orderItem4 = doc.CreateElement(&quot;OrderItem&quot;);    orderItem4.SetAttribute(&quot;Name&quot;, &quot;ESP32&quot;);    orderItem4.SetAttribute(&quot;Count&quot;, &quot;10&quot;);    items.AppendChild(orderItem4);    doc.Save(@&quot;D:\tmp\Order.xml&quot;);&#125;



向XML文档中追加内容大致流程

实例化XML对象
创建根节点XmlElement，但不给对象
通过File的Exists判断文件是否存在
如果存在则加载到根节点
如果不存在则创建根节点并添加版本信息
生成要追加的子节点
将子节点保存到根节点中
保存Xml对象

static void Main(string[] args)&#123;    //追加XML文档    //只要对XML操作，就需要创建XML对象。    XmlDocument doc = new XmlDocument();    //声明一个根节点，但不给对象    XmlElement books = null;    //如果XML文件存在，只需要拿到根节点    //如果文件不存在，则需要创建XML文档    if (File.Exists(@&quot;D:\tmp\test.xml&quot;))    &#123;        //文件存在， 拿到根节点        //先加载        doc.Load(@&quot;D:\tmp\test.xml&quot;);        //后获取        books = doc.DocumentElement;    &#125;    else    &#123;        //不存在，就先创建在添加        XmlDeclaration dec = doc.CreateXmlDeclaration(&quot;1.0&quot;, &quot;utf-8&quot;, null);        doc.AppendChild(dec);//将说明添加进去        //创建根节点        books = doc.CreateElement(&quot;Books&quot;);        doc.AppendChild(books);    &#125;    //拿到根节点后，就可以往里面添加数据了。    //给根节点Books创建子节点    XmlElement book1 = doc.CreateElement(&quot;Boook&quot;);    //将创建出来的子节点添加到根节点中    books.AppendChild(book1);    //给Book1添加子节点    XmlElement name1 = doc.CreateElement(&quot;Name&quot;);    XmlElement price1 = doc.CreateElement(&quot;Price&quot;);    XmlElement des1 = doc.CreateElement(&quot;Des&quot;);    //给这个子节点添加文本    name1.InnerText = &quot;C#开发&quot;;    price1.InnerText = &quot;110&quot;;    des1.InnerText = &quot;csharp&quot;;    //将子节点添加到Book1中    book1.AppendChild(name1);    book1.AppendChild(price1);    book1.AppendChild(des1);    //将xml进行保存    doc.Save(@&quot;D:\tmp\test.xml&quot;);&#125;



读取Xml文档static void Main(string[] args)&#123;    //实例化xml对象    XmlDocument doc = new XmlDocument();    //加载要读取的文件    doc.Load(@&quot;D:\tmp\test.xml&quot;);    //获取根节点    XmlElement books = doc.DocumentElement;    //根据父节点获取子节点。返回的是子节点的集合    XmlNodeList xnl = books.ChildNodes;    foreach (XmlNode xn in xnl)    &#123;        Console.WriteLine(xn.InnerText);//遍历集合中每个子节点的值    &#125;&#125;



读取带有属性的Xml文档static void Main(string[] args)&#123;    //创建xml对象    XmlDocument doc = new XmlDocument();    //加载文档    doc.Load(@&quot;D:\tmp\Order.xml&quot;);        //查找指定的路径下的节点，返回的是一个节点的集合    XmlNodeList xnl = doc.SelectNodes(&quot;/Order/items/OrderItem&quot;);	//遍历这个集合，并输出其中的值    foreach (XmlNode xn in xnl)    &#123;        Console.WriteLine(xn.Attributes[&quot;Name&quot;].Value);        Console.WriteLine(xn.Attributes[&quot;Count&quot;].Value);    &#125;    Console.ReadKey();&#125;





删除节点static void Main(string[] args)&#123;    //创建xml对象并加载文档    XmlDocument doc = new XmlDocument();    doc.Load(@&quot;D:\tmp\Order.xml&quot;);    //查找到指定的节点    XmlNode xn = doc.SelectSingleNode(&quot;/Order/items&quot;);    //删除指定节点下的所有子节点    xn.RemoveAll();    doc.Save(@&quot;D:\tmp\Order2.xml&quot;);    Console.ReadKey();&#125;









注意事项
当需要往节点中添加标签的时候，需要使用InnerXml属性添加。
当要添加文本的时候，需要使用InnerText添加。
区别：InnerText添加的时候会对一些特殊字符进行转义。

对象的生存周期每一个对象都有一个明确的生命周期，除了”正在使用”的正常状态外，还有两个重要的阶段：

构造阶段
第一次实例化一个对象时，需要初始化该对象。这个初始化过程称为构造阶段，由构造函数完成。


析构阶段
在删除一个对象时，常常需要执行一些清理操作，如释放内存，这由析构函数完成。



构造函数对象的初始化过程是自动完成的，所有类定义都最少包含一个构造函数。
在C#中，使用new关键字来调用构造函数。
析构函数​	.NET Framework使用析构函数来清理对象。一般情况下，不需要提供析构函数的代码，而由默认的析构函数自动执行操作。但是，如果在删除对象实例前需要完成一些重要操作，就应提供具体的析构函数。
​	例如，如果变量超出了作用域,代码就不能访问它，但该变量仍存在于计算机内存的某个地方。只有在.NET运行程序执行其垃圾回收，进行清理时，该实例才被彻底删除。
C# 编码约定编码约定可实现以下目的：

它们为代码创建一致的外观，以确保读取器专注于内容而非布局。
它们使得读取器可以通过基于之前的经验进行的假设更快地理解代码。
它们便于复制、更改和维护代码。
它们展示 C# 最佳做法。

Microsoft 根据本文中的准则来开发样本和文档。 根据 .NET 运行时 C# 编码样式指南采用它们。 可使用它们，或者按照你的需求采用它们。 主要目标是在项目、团队、组织或公司源代码中实现一致性和可读性。
简要Pascal （大驼峰）命名方式命名空间、类、接口、抽象类、结构体、枚举类、方法名、以及类中的属性，须要使用 Pascal 命名规范；名称中每一个单词的首字母都要大写；
Camel （小驼峰）命名方式方法参数、局部变量、以及私有的成员变量，须要使用 Camel 命名规范；名称中第一个单词是小写的，从第二个单词起，后面每一个单词的首字母都要大写；
命名约定编写 C# 代码时需要考虑几个命名约定。
在下面的示例中，在使用 protected 和 protected internal 元素时，还需遵守与标记了 public 的元素相关的任何指南 - 所有这些元素都旨在对外部调用方可见。
帕斯卡拼写法(大驼峰)命名 class、record 或 struct 时，使用 pascal 大小写（“PascalCasing”）。
public class DataService&#123;&#125;

public record PhysicalAddress(    string Street,    string City,    string StateOrProvince,    string ZipCode);

public struct ValueCoordinate&#123;&#125;

命名 interface 时，使用 pascal 大小写并在名称前面加上前缀 I。 这可以清楚地向使用者表明这是 interface。
public interface IWorkerQueue&#123;&#125;

命名类型的 public 成员（例如字段、属性、事件、方法和本地函数）时，请使用 pascal 大小写。
public class ExampleEvents&#123;    // A public field, these should be used sparingly    public bool IsValid;    // An init-only property    public IWorkerQueue WorkerQueue &#123; get; init; &#125;    // An event    public event Action EventProcessing;    // Method    public void StartEventProcessing()    &#123;        // Local function        static int CountQueueItems() =&gt; WorkerQueue.Count;        // ...    &#125;&#125;

编写位置记录时，对参数使用 pascal 大小写，因为它们是记录的公共属性。
public record PhysicalAddress(    string Street,    string City,    string StateOrProvince,    string ZipCode);

有关位置记录的详细信息，请参阅属性定义的位置语法。
驼峰式大小写（小驼峰）命名 private 或 internal 字段时，使用驼峰式大小写（“camelCasing”），并且它们以 _ 作为前缀。
public class DataService&#123;    private IWorkerQueue _workerQueue;&#125;

在支持语句完成的 IDE 中编辑遵循这些命名约定的 C# 代码时，键入 _ 将显示所有对象范围的成员。
使用为 private 或 internal 的static 字段时 请使用 s_ 前缀，对于线程静态，请使用 t_。
public class DataService&#123;    private static IWorkerQueue s_workerQueue;    [ThreadStatic]    private static TimeSpan t_timeSpan;&#125;

编写方法参数时，请使用驼峰式大小写。
public T SomeMethod&lt;T&gt;(int someNumber, bool isValid)&#123;&#125;

有关 C# 命名约定的详细信息，请参阅 C# 编码样式。
其他命名约定
在不包括 using 指令的示例中，使用命名空间限定。 如果你知道命名空间默认导入项目中，则不必完全限定来自该命名空间的名称。 如果对于单行来说过长，则可以在点 (.) 后中断限定名称，如下面的示例所示。
var currentPerformanceCounterCategory = new System.Diagnostics.    PerformanceCounterCategory();

你不必更改使用 Visual Studio 设计器工具创建的对象的名称以使它们适合其他准则。


布局约定好的布局利用格式设置来强调代码的结构并使代码更便于阅读。 Microsoft 示例和样本符合以下约定：

使用默认的代码编辑器设置（智能缩进、4 字符缩进、制表符保存为空格）。 有关详细信息，请参阅选项、文本编辑器、C#、格式设置。

每行只写一条语句。

每行只写一个声明。

如果连续行未自动缩进，请将它们缩进一个制表符位（四个空格）。

在方法定义与属性定义之间添加至少一个空白行。

使用括号突出表达式中的子句，如下面的代码所示。
if ((val1 &gt; val2) &amp;&amp; (val1 &gt; val3))&#123;    // Take appropriate action.&#125;

将 using 指令放在命名空间声明之外当 using 指令位于命名空间声明之外时，该导入的命名空间是其完全限定的名称。 这样就比较清楚了。 如果 using 指令位于命名空间内部，它可以是相对于该命名空间的，也可以是完全限定的名称。 这容易说不清楚。
using Azure;namespace CoolStuff.AwesomeFeature&#123;    public class Awesome    &#123;        public void Stuff()        &#123;            WaitUntil wait = WaitUntil.Completed;            …        &#125;    &#125;&#125;

假设存在对 WaitUntil 类的引用（直接或间接）。
现在，让我们稍作改动：
namespace CoolStuff.AwesomeFeature&#123;    using Azure;        public class Awesome    &#123;        public void Stuff()        &#123;            WaitUntil wait = WaitUntil.Completed;            …        &#125;    &#125;&#125;

今天的编译成功了。 明天的也没问题。 但在下周的某个时候，此（保持不变）代码故障，并出现两个错误：
控制台复制
- error CS0246: The type or namespace name &#x27;WaitUntil&#x27; could not be found (are you missing a using directive or an assembly reference?)- error CS0103: The name &#x27;WaitUntil&#x27; does not exist in the current context

其中一个依赖项已在命名空间中引入了此类，然后以 .Azure 结尾：
namespace CoolStuff.Azure&#123;    public class SecretsManagement    &#123;        public string FetchFromKeyVault(string vaultId, string secretId) &#123; return null; &#125;    &#125;&#125;

放置在命名空间中的 using 指令与上下文相关，使名称解析复杂化。 在此示例中，它是它找到的第一个命名空间。

CoolStuff.AwesomeFeature.Azure
CoolStuff.Azure
Azure

添加匹配 CoolStuff.Azure 或 CoolStuff.AwesomeFeature.Azure 的新命名空间将在全局 Azure 命名空间前匹配。 可以通过向 using 声明添加 global:: 修饰符来解决此问题。 但是，改为将 using 声明放在命名空间之外更容易。
namespace CoolStuff.AwesomeFeature&#123;    using global::Azure;        public class Awesome    &#123;        public void Stuff()        &#123;            WaitUntil wait = WaitUntil.Completed;            …        &#125;    &#125;&#125;



注释约定
将注释放在单独的行上，而非代码行的末尾。

以大写字母开始注释文本。

以句点结束注释文本。

在注释分隔符 (&#x2F;&#x2F;) 与注释文本之间插入一个空格，如下面的示例所示。
// The following declaration creates a query. It does not run// the query.

请勿在注释周围创建格式化的星号块。

请确保所有公共成员都有必要的 XML 注释，从而提供有关其行为的适当说明。


语言准则以下各节介绍 C# 遵循以准备代码示例和样本的做法。
字符串数据类型
使用字符串内插来连接短字符串，如下面的代码所示。
string displayName = $&quot;&#123;nameList[n].LastName&#125;, &#123;nameList[n].FirstName&#125;&quot;;

若要在循环中追加字符串，尤其是在使用大量文本时，请使用 StringBuilder 对象。
var phrase = &quot;lalalalalalalalalalalalalalalalalalalalalalalalalalalalalala&quot;;var manyPhrases = new StringBuilder();for (var i = 0; i &lt; 10000; i++)&#123;    manyPhrases.Append(phrase);&#125;//Console.WriteLine(&quot;tra&quot; + manyPhrases);

隐式类型本地变量
当变量类型明显来自赋值的右侧时，或者当精度类型不重要时，请对本地变量进行隐式类型化。
var var1 = &quot;This is clearly a string.&quot;;var var2 = 27;

当类型并非明显来自赋值的右侧时，请勿使用 var。 请勿假设类型明显来自方法名称。 如果变量类型为 new 运算符或显式强制转换，则将其视为明显来自方法名称。
int var3 = Convert.ToInt32(Console.ReadLine()); int var4 = ExampleClass.ResultSoFar();

请勿依靠变量名称来指定变量的类型。 它可能不正确。 在以下示例中，变量名称 inputInt 会产生误导性。 它是字符串。
var inputInt = Console.ReadLine();Console.WriteLine(inputInt);

避免使用 var 来代替 dynamic。 如果想要进行运行时类型推理，请使用 dynamic。 有关详细信息，请参阅使用类型 dynamic（C# 编程指南）。

使用隐式类型化来确定 for 循环中循环变量的类型。
下面的示例在 for 语句中使用隐式类型化。
var phrase = &quot;lalalalalalalalalalalalalalalalalalalalalalalalalalalalalala&quot;;var manyPhrases = new StringBuilder();for (var i = 0; i &lt; 10000; i++)&#123;    manyPhrases.Append(phrase);&#125;//Console.WriteLine(&quot;tra&quot; + manyPhrases);

不要使用隐式类型化来确定 foreach 循环中循环变量的类型。 在大多数情况下，集合中的元素类型并不明显。 不应仅依靠集合的名称来推断其元素的类型。
下面的示例在 foreach 语句中使用显式类型化。
foreach (char ch in laugh)&#123;    if (ch == &#x27;h&#x27;)        Console.Write(&quot;H&quot;);    else        Console.Write(ch);&#125;Console.WriteLine();

 备注
注意不要意外更改可迭代集合的元素类型。 例如，在 foreach 语句中从 System.Linq.IQueryable 切换到 System.Collections.IEnumerable 很容易，这会更改查询的执行。


无符号数据类型通常，使用 int 而非无符号类型。 int 的使用在整个 C# 中都很常见，并且当你使用 int 时，更易于与其他库交互。
数组当在声明行上初始化数组时，请使用简洁的语法。 在以下示例中，请注意不能使用 var 替代 string[]。
string[] vowels1 = &#123; &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; &#125;;

如果使用显式实例化，则可以使用 var。
var vowels2 = new string[] &#123; &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; &#125;;

委托使用 Func&lt;&gt; 和 Action&lt;&gt;，而不是定义委托类型。 在类中，定义委托方法。
public static Action&lt;string&gt; ActionExample1 = x =&gt; Console.WriteLine($&quot;x is: &#123;x&#125;&quot;);public static Action&lt;string, string&gt; ActionExample2 = (x, y) =&gt;     Console.WriteLine($&quot;x is: &#123;x&#125;, y is &#123;y&#125;&quot;);public static Func&lt;string, int&gt; FuncExample1 = x =&gt; Convert.ToInt32(x);public static Func&lt;int, int, int&gt; FuncExample2 = (x, y) =&gt; x + y;

使用 Func&lt;&gt; 或 Action&lt;&gt; 委托定义的签名来调用方法。
ActionExample1(&quot;string for x&quot;);ActionExample2(&quot;string for x&quot;, &quot;string for y&quot;);Console.WriteLine($&quot;The value is &#123;FuncExample1(&quot;1&quot;)&#125;&quot;);Console.WriteLine($&quot;The sum is &#123;FuncExample2(1, 2)&#125;&quot;);

如果创建委托类型的实例，请使用简洁的语法。 在类中，定义委托类型和具有匹配签名的方法。
public delegate void Del(string message);public static void DelMethod(string str)&#123;    Console.WriteLine(&quot;DelMethod argument: &#123;0&#125;&quot;, str);&#125;

创建委托类型的实例，然后调用该实例。 以下声明显示了紧缩的语法。
Del exampleDel2 = DelMethod;exampleDel2(&quot;Hey&quot;);

以下声明使用了完整的语法。
Del exampleDel1 = new Del(DelMethod);exampleDel1(&quot;Hey&quot;);



try-catch 和 using 语句正在异常处理中
对大多数异常处理使用 try-catch 语句。
static string GetValueFromArray(string[] array, int index)&#123;    try    &#123;        return array[index];    &#125;    catch (System.IndexOutOfRangeException ex)    &#123;        Console.WriteLine(&quot;Index is out of range: &#123;0&#125;&quot;, index);        throw;    &#125;&#125;

通过使用 C# using 语句简化你的代码。 如果具有 try-finally 语句（该语句中 finally 块的唯一代码是对 Dispose 方法的调用），请使用 using 语句代替。
在以下示例中，try-finally 语句仅在 finally 块中调用 Dispose。
Font font1 = new Font(&quot;Arial&quot;, 10.0f);try&#123;    byte charset = font1.GdiCharSet;&#125;finally&#123;    if (font1 != null)    &#123;        ((IDisposable)font1).Dispose();    &#125;&#125;

可以使用 using 语句执行相同的操作。
using (Font font2 = new Font(&quot;Arial&quot;, 10.0f))&#123;    byte charset2 = font2.GdiCharSet;&#125;

使用不需要大括号的新 using 语法：
using Font font3 = new Font(&quot;Arial&quot;, 10.0f);byte charset3 = font3.GdiCharSet;

&amp;&amp; 和 || 运算符若要通过跳过不必要的比较来避免异常并提高性能，请在执行比较时使用 &amp;&amp;（而不是 &amp;）和 ||（而不是 |），如下面的示例所示。
Console.Write(&quot;Enter a dividend: &quot;);int dividend = Convert.ToInt32(Console.ReadLine());Console.Write(&quot;Enter a divisor: &quot;);int divisor = Convert.ToInt32(Console.ReadLine());if ((divisor != 0) &amp;&amp; (dividend / divisor &gt; 0))&#123;    Console.WriteLine(&quot;Quotient: &#123;0&#125;&quot;, dividend / divisor);&#125;else&#123;    Console.WriteLine(&quot;Attempted division by 0 ends up here.&quot;);&#125;

如果除数为 0，则 if 语句中的第二个子句将导致运行时错误。 但是，当第一个表达式为 false 时，&amp;&amp; 运算符将发生短路。 也就是说，它并不评估第二个表达式。 如果 divisor 为 0，则 &amp; 运算符将同时计算这两个表达式，这会导致运行时错误。
new 运算符
使用对象实例化的简洁形式之一，如以下声明中所示。 第二个示例显示了从 C# 9 开始可用的语法。
var instance1 = new ExampleClass();

ExampleClass instance2 = new();

前面的声明等效于下面的声明。
ExampleClass instance2 = new ExampleClass();

使用对象初始值设定项简化对象创建，如以下示例中所示。
var instance3 = new ExampleClass &#123; Name = &quot;Desktop&quot;, ID = 37414,    Location = &quot;Redmond&quot;, Age = 2.3 &#125;;

下面的示例设置了与前面的示例相同的属性，但未使用初始值设定项。
var instance4 = new ExampleClass();instance4.Name = &quot;Desktop&quot;;instance4.ID = 37414;instance4.Location = &quot;Redmond&quot;;instance4.Age = 2.3;

事件处理如果你正在定义一个稍后不需要删除的事件处理程序，请使用 lambda 表达式。
public Form2()&#123;    this.Click += (s, e) =&gt;        &#123;            MessageBox.Show(                ((MouseEventArgs)e).Location.ToString());        &#125;;&#125;

Lambda 表达式缩短了以下传统定义。
public Form1()&#123;    this.Click += new EventHandler(Form1_Click);&#125;void Form1_Click(object? sender, EventArgs e)&#123;    MessageBox.Show(((MouseEventArgs)e).Location.ToString());&#125;



静态成员使用类名调用 static 成员：ClassName.StaticMember。 这种做法通过明确静态访问使代码更易于阅读。 请勿使用派生类的名称来限定基类中定义的静态成员。 编译该代码时，代码可读性具有误导性，如果向派生类添加具有相同名称的静态成员，代码可能会被破坏。
LINQ 查询
对查询变量使用有意义的名称。 下面的示例为位于西雅图的客户使用 seattleCustomers。
var seattleCustomers = from customer in customers                       where customer.City == &quot;Seattle&quot;                       select customer.Name;

使用别名确保匿名类型的属性名称都使用 Pascal 大小写格式正确大写。
var localDistributors =    from customer in customers    join distributor in distributors on customer.City equals distributor.City    select new &#123; Customer = customer, Distributor = distributor &#125;;

如果结果中的属性名称模棱两可，请对属性重命名。 例如，如果你的查询返回客户名称和分销商 ID，而不是在结果中将它们保留为 Name 和 ID，请对它们进行重命名以明确 Name 是客户的名称，ID 是分销商的 ID。
var localDistributors2 =    from customer in customers    join distributor in distributors on customer.City equals distributor.City    select new &#123; CustomerName = customer.Name, DistributorID = distributor.ID &#125;;

在查询变量和范围变量的声明中使用隐式类型化。
var seattleCustomers = from customer in customers                       where customer.City == &quot;Seattle&quot;                       select customer.Name;

对齐 from 子句下的查询子句，如上面的示例所示。

在其他查询子句前面使用 where 子句，确保后面的查询子句作用于经过缩减和筛选的一组数据。
var seattleCustomers2 = from customer in customers                        where customer.City == &quot;Seattle&quot;                        orderby customer.Name                        select customer;

使用多行 from 子句代替 join 子句来访问内部集合。 例如，Student 对象的集合可能包含测验分数的集合。 当执行以下查询时，它返回高于 90 的分数，并返回得到该分数的学生的姓氏。
var scoreQuery = from student in students                 from score in student.Scores!                 where score &gt; 90                 select new &#123; Last = student.LastName, score &#125;;

安全性请遵循安全编码准则中的准则。
请参阅
.NET 运行时编码准则
Visual Basic 编码约定
安全编码准则

附录XXX.ToString 格式化数值结果表


格式说明符
说明
示例
输出



C
货币
15.ToString(“C”)
￥15.00




15.ToString(“C1”)
￥15.0




15.ToString(“C3”)
￥15.000


D
十进制数
15.ToString(“D1”)
15




15.ToString(“D2”)
15




15.ToString(“D5”)
00015


E
科学型
15.ToString(“E”)
1.500000E+001




1500.ToString(“E”)
1.500000E+003




0.15.ToString(“E”)
1.500000E-001




0.0015.ToString(“E”)
1.500000E-003




0.0015.ToString(“E0”)
2E-003




0.0015.ToString(“E1”)
1.5E-003




0.0015.ToString(“E2”)
1.50E-003


F
固定点
15.ToString(“F1”)
15.0




15.ToString(“F2”)
15.00


G
常规
2.5.ToString(“G”)
2.5


N
数字
1500000.ToString(“N”)
1,500,000.00




1500000.ToString(“N0”)
1,500,000




1500000.ToString(“N1”)
1,500,000.0


X
十六进制
15.ToString(“X”)
F




15.ToString(“X3”)
00F


String.Format 格式化数值结果表


字符
说明
示例
输出



C
货币
string.Format(“{0:C3}”, 2)
＄2.000


D
十进制
string.Format(“{0:D3}”, 2)
002


E
科学计数法
1.20E+001
1.20E+001


G
常规
string.Format(“{0:G}”, 2)
2


N
用分号隔开的数字
string.Format(“{0:N}”, 250000)
250,000.00


X
十六进制
string.Format(“{0:X000}”, 12)
C


0
零占位符
string.Format(“{0:000.000}”, 12.3)
012.300


#
数字占位符
String.Format(“{0:#}”, 12.3)
12




String.Format(“{0:##}”, 12.3)
12




String.Format(“{0:###}”, 12.3)
12




String.Format(“{0:###.#}”, 12.3)
12.3


String.Format 自定义模式输出
“0”描述：占位符，如果可能，填充位

String.Format(&quot;&#123;0:000000&#125;&quot;, 1234);  // 结果：001234


“#”描述：占位符，如果可能，填充位

String.Format(&quot;&#123;0:######&#125;&quot;, 1234);  // 结果：1234String.Format(&quot;&#123;0:#0####&#125;&quot;, 1234);  // 结果：01234String.Format(&quot;&#123;0:0#0####&#125;&quot;, 1234);  // 结果：0001234


“.”描述：小数点

String.Format(&quot;&#123;0:000.000&#125;&quot;, 1234);  // 结果：1234.000String.Format(&quot;&#123;0:000.000&#125;&quot;, 4321.12543);  // 结果：4321.125


“,”描述：数字分组，也用于增倍器

String.Format(&quot;&#123;0:0,0&#125;&quot;, 1234567);  // 结果：1,234,567


“%”描述：格式为百分数

String.Format(&quot;&#123;0:0%&#125;&quot;, 1234);  // 结果：123400%String.Format(&quot;&#123;0:#%&#125;&quot;, 1234.125);  // 结果：123413%String.Format(&quot;&#123;0:0.00%&#125;&quot;, 1234);  // 结果： 123400.00%String.Format(&quot;&#123;0:#.00%&#125;&quot;, 1234.125);  // 结果：123412.50%


“abc”描述：显示单引号内的文本

String.Format(&quot;&#123;0:&#x27;文本&#x27;0&#125;&quot;, 1234);  // 结果：文本1234


“”描述：用于转移符

String.Format(&quot;\&quot;abc!\&quot;&quot;);  // 结果：abc!


c”@”描述：后跟要打印字符串c

String.Format(@&quot;&quot;abc!&quot;&quot;);  // 结果：abc! 



c#的一些小样例读取键盘输入的值到变量System 命名空间中的 Console 类提供了一个函数 ReadLine()，用于接收来自用户的输入，并把它存储到一个变量中。
例如：
int num;num = Convert.ToInt32(Console.ReadLine());

函数 Convert.ToInt32() 把用户输入的数据转换为 int 数据类型，因为 Console.ReadLine() 只接受字符串格式的数据。
c#指针c#是可以用指针的，但不推荐。如果必须要使用，则需要在这段程序的前面加上修饰符unsafe，表示在书写不安全的代码。
同时可能还需要在visual studio的项目-项目属性-生成（build）勾选上允许不安全代码。
这样：
public class Test    &#123;        public unsafe void Fun()        &#123;            int a = 10;            int* p = &amp;a;            Console.WriteLine(*p);        &#125;    &#125;

或这样：把涉及到指针的代码放到一个代码块内，然后声明这个代码块是不安全的
public  void Fun()        &#123;            int a = 10;            unsafe            &#123;                int* p = &amp;a;                Console.WriteLine(*p);            &#125;                                &#125;





强制分配数组在栈空间中public class Test&#123;    public  void Fun()    &#123;        int[] a = new int[10];//正常的创建一个数组        unsafe        &#123;            int* b = stackalloc int[10];//强制的在栈上创建一个数组        &#125;    &#125;&#125;





常量和只读字段的区别
常量隶属于类,而不是对象,即没有”实例常量”
“实例常量”的角色由只读实例字段担当

常见的应用场景
为了提高程序可读性和执行效率 &#x3D;&#x3D;&gt; 常量
为了防止对象的值被改变 &#x3D;&#x3D;&gt; 只读字段
向外暴露不允许修改的数据 &#x3D;&#x3D;&gt; 只读属性(静态或非静态), 功能与常量有一些重叠
当希望成为常量的值其类型不能被常量声明接收时(类&#x2F;自定义结构体) &#x3D;&#x3D;&gt; 静态只读字段 (这句话太绕了)

namespace ConsoleApp1&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(Web.WebsiteURL);            Web web = new Web();            Console.WriteLine(web.version);        &#125;    &#125;    class Web    &#123;    	// 常量        public const string WebsiteURL = &quot;http://www.baidu.com&quot;;        // 只读字段        public readonly string version = &quot;1.0.0&quot;;    &#125;&#125;







各种“只读”的应用场景为了提高程序的可读性和执行效率——常量
为了放置对象的值被修改——只读字段
向外暴露不允许修改的数据——只读属性
当希望成为常量的值其类型不能被常量声明接受时（类&#x2F;自定义结构）——静态只读字段（常量只能是基本数据类型）
值类型和值参数的区别值参数是一个变量，他有值类型和引用类型两种。
值类型在作为参数传递进方法的时候是复制传入
判断两个对象是否是同一个因为在c#中，所有的类都继承于Object，而object具有一个方法，就是GetHashCode。
GetHashCode获取到的值类似于对象的指纹，每一个对象都具有不同的hash
GetHashCode获取到的值是一个32位有符号整型。（有疑问，为什么是32位？是因为编译出来的是32位的应用吗）
string s = &quot;hurr&quot;;Console.WriteLine(s.GetHashCode());//获取并输出s字符串的hash





TryParse类型转换using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            string s;            s = &quot;123.45.6&quot;;            double d = -1;            if (double.TryParse(s, out d))//尝试的转换，如果转换成功，则返回true，否则为false。同时转换完成的值以输出参数的形式带出                Console.WriteLine(&quot;转换成功&quot;);            else                Console.WriteLine(&quot;转换失败&quot;);            Console.WriteLine(&quot;转换完成的值是：&#123;0&#125;&quot;, d);            Console.ReadLine();        &#125;    &#125;&#125;





使用Split方法使得string字符串进行按指定符号分割。using System;using System.Collections.Generic;using System.Linq;using System.Security.Policy;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using ShowInfos;namespace ConsoleApp&#123;    internal class Program    &#123;        static void Main(string[] args)        &#123;            string str = &quot;tim,hurrr;amy.Lisa&quot;;//一个字符串，里面存在多个符号            string[] res = str.Split(&#x27;,&#x27;, &#x27;;&#x27;, &#x27;.&#x27;);//用string类自带的Split方法，指出其中的符号，并存到一个string数组中返回            foreach(var item in res)//遍历分割完的字符串            &#123;                Console.WriteLine(item);            &#125;            Console.ReadLine();        &#125;            &#125;&#125;





string的花样玩法：深入理解C# 中 “$” 符号的作用以及用法前言：$是c# 6.0 的语言特性，功能类似string.format()，更方便的地方在于不要像format一样使用索引，可以直接使用变量、表达式或者方法的执行。
C#中$的作用谈及这个$，其实它是C#6.0语法中模板字符串的一种写法，什么是模版字符串？还记得你们用过的格式化字符串吗？string.Format() 这个方法，是最常用的方法之一。
那$又是什么呢？它是为了替代string.format()的，原先赋值需要占位符和变量，当需要拼接多个变量会造成语句过长等不易理解问题。
$是为了替代string.format()，可以把字符串中的C#变量{}包含起来达到识别C#变量的目的$&quot;{id}&quot;；也支持表达式，使用$&quot;{(你的表达式)}&quot;；或者方法的执行，使用$&quot;{(方法)}&quot;。
C#中$的用法C# 中$符号的作用是C#6.0中新出现的一个特性，也即是字符串的拼接优化。
语法格式$&quot;string &#123;参数&#125;&quot;

解释：以$符号开头开始字符串，其中以{}来进行传参，可以多个参数累加。
例如:
var results = $&quot;Hello &#123;Name&#125;&quot;;



$的示例var str = string.Format(&quot;我的名字叫&#123;1&#125;，我今年&#123;1&#125;岁。&quot;, &quot;张三&quot;, 23);Console.WriteLine(str);

这是我们使用string.format()的写法，下来我们使用$改写一下。
var str = $&quot;我的名字叫&#123;&quot;张三&quot;&#125;，我今年&#123;23&#125;岁。&quot;;Console.WriteLine(str);12

通过上面这个案例，我们发现，现在使用$代码简洁，可读性强。
可能有些朋友觉得效果不太明显，那么请看下面这个案例：
var name = &quot;张三&quot;;var age = 23;var sex = &quot;男&quot;;var message = string.Format(&quot;我叫&#123;0&#125;,我的年龄为&#123;1&#125;,我的性别是&#123;2&#125;&quot;, name, age, sex);var show = $&quot;我叫&#123;name&#125;,我的年龄为&#123;age&#125;,我的性别是&#123;sex&#125;&quot;;Console.WriteLine(message);Console.WriteLine(show);1234567

如果还感受不到，那么请你试想一下：如果我们要操作的数据很多，假设它是一个多条的SQL语句，那么在长篇字符串中定位索引，那是不是很累啊！纵使你写对了索引（没写对还得一个个检查、修改），好不容易完工了。但下一个需求让你加两个参数，你的索引位置又得变，还得在万码丛中查找你原来索引在哪里的，是不是很恶心？
哈哈，不用沮丧，此时C#6.0模版字符串就可以闪亮登场啦！
怎么用？总结一下，就是在字符串的双引号前面加一个 $ 符号，在需要使用变量的地方用{变量}就可以了。这个在我们上面的案例中，也有体现。
关于$的补充知识正如我们上面所说，{变量}表示在字符串中输出变量的值，当然{}中间也可以是一个表达式或者方法的执行。
$&quot;我的姓名是&#123;GetName()&#125;&quot;;$&quot;name的类型是&#123;name.GetType()&#125;&quot;;12

如上，这样就很方便，帅气了！那么变量和索引可以混用吗？当然也是可以的，如下：
var name = &quot;张三&quot;;var age = 23;var sex = &quot;男&quot;;var show = string.Format($&quot;我是&#123;name&#125;，今年&#123;age&#125;，家住在&#123;&#123;0&#125;&#125;&quot;, sex); Console.WriteLine(show);12345



要注意的是需要用两次大括号 {{}} 将索引包含起来，也就是这样的形式，&quot;({*2)索引(}*2)&quot;。因为一次是输出表达式，两次就转义成普通的占位符了，这点一定要注意！

查询枚举类型是否包含具有特定关联值的枚举成员使用Enum.IsDefined 方法
如：
using System;using System.Windows.Diagnostics;using System.Windows.Forms;namespace ConsoleApp&#123;    public enum Season    &#123;        Spring,        Summer,        Autumn,        Winter    &#125;    internal class Program    &#123;        static void Main(string[] args)        &#123;            var c = (Season)4;            Console.WriteLine(c);  // output: 4            Console.WriteLine(c.GetType());//output：ConsoleApp.Season            Console.WriteLine(Enum.IsDefined(typeof(Season),4));//false            Console.ReadKey();        &#125;    &#125;&#125;





添加引用依赖：类库
纠错：
​	如果是别人编写的dll，不是微软自带的，需要在最下方的浏览中添加进来。而不是在程序集中添加。
MD5转换using System;using System.Collections;using System.ComponentModel;using System.IO;using System.Security.Cryptography;using System.Text;namespace ConsoleApp&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(GetMD5(&quot;123&quot;));        &#125;        public static string GetMD5(string str)        &#123;            //将目标字符串转换成字节            byte[] buffer = Encoding.UTF8.GetBytes(str);            // 创建MD5对象            MD5 md5 = MD5.Create();            byte[] MD5Buffer =  md5.ComputeHash(buffer);            string strmd5 = &quot;&quot;;            //将加密完成的字节数组转换成字符串            for(int i = 0; i &lt; MD5Buffer.Length; i++)            &#123;                strmd5 += MD5Buffer[i].ToString(&quot;x&quot;);//注意需要转换成16进制。默认是10进制            &#125;            return strmd5;        &#125;    &#125;&#125;





对于使用.Net FrameWork的控制台应用程序，调用From窗体。
引入依赖
右击引用，选择添加引用
找到System.Windwos.Forms，选择确认加入引用
使用using语句引用导入的forms。如果这一步报错，则表示上一步的引入没引成功。


实例化Form对象，然后ShowDialog显示出来。

存在的问题string的比较，能否直接用==。
输入一个string的字符串，假设输入的值与待比较的值相等，==是否可以进行比较。
string str;str = Console.ReadLine();//假设输入hurrif(str.ToLower() == &quot;hurr&quot;)//true or false？

在c#中string也是引用类型，因此str是一个4字节的变量，而输入的文本存储在堆中，==运算符是否可以比较存储的值而不是变量的值。
属性与类的关系
完整声明中的private部分，是否可以是为一个动态计算值的属性？
c#索引器
一个类只能有一个list？
是否需要单独拎出一个类作为属性类来实现？是否增加了耦合？就像在当前类中new另外一个类
委托中组合委托（组播）的用途？引用场景？
委托的用途：常见的使用场景？
自定义委托相比Action或Func有什么特点？或者是有什么不可替代性？
枚举中：作为位标志的枚举类型的部分
c#的锯齿数组与c++中的数组指针的区别
c#中是否存在着：不使用Main方法作为入口点。如像在c++中的 static int s = execute();这样的语句，在main前面，初始化静态变量的时候调用第三方函数，使得第三方函数的运行在main前。
方法参数中的引用参数，ref修饰符在public的位置时，表示的是什么意思？（p86）
ref在参数前面，表示的是指定的参数是引用参数，在声明和调用的时候要在参数前面加上ref修饰符；
如果这样，ref此时表示什么意思？
static ref int ReturnByRef()&#123;    int[] arr = &#123; 2 &#125;;    return ref arr[0];&#125;







接口
当一个类实现了多个接口的时候，是不是必须显式实现接口？
c#中的GetHashCode
在C#中，GetHashCode()方法是用来返回一个对象的哈希码，也就是一个整数值，用于表示对象的内容或状态1。GetHashCode()方法可以返回负值，因为它没有限制哈希码的范围2。GetHashCode()方法只要求相等的对象返回相同的哈希码，但不要求不相等的对象返回不同的哈希码13。因此，GetHashCode()方法返回的值不能用来判断对象是否相等，也不能用来存储或比较数据23。GetHashCode()方法只能用来优化一些数据结构或算法，例如哈希表或字典1。
gethashcode是否能可靠的判断两个对象是否相等？
如何判断两个对象是否相等。
在C#中，判断两个对象是否相等有多种方法，取决于你想要比较的是对象的引用还是值。1
如果你想要比较两个对象的引用，也就是说，它们是否指向同一个内存地址，你可以使用Object.ReferenceEquals方法或者==运算符（如果该类型重载了该运算符）。2
如果你想要比较两个对象的值，也就是说，它们是否具有相同的属性和字段，你可以使用Object.Equals方法或者IEquatable接口（如果该类型实现了该接口）。2
另外，你也可以使用反射来遍历两个对象的所有属性，并返回它们之间的差异。34
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>基础教程</tag>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP8266开发参考资料</title>
    <url>/2023/06/07/ESP8266%E5%BC%80%E5%8F%91%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99_%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[开发参考资料ESP8266-Arduino库 总览
网络功能物联网相关的ESP8266库。这些库主要用于控制ESP8266连接WiFi网络、设置工作模式以及利用通用的互联网协议（TCP&#x2F;IP协议族）实现ESP8266物联网应用。
工作模式ESP8266共有三种工作模式，分别是无线接入点模式（AP）、无线终端模式（Wireless Station）以及混合模式（以上两种模式的混合）。这一部分的库主要用于控制ESP8266的工作模式。

ESP8266WiFiAP库 – ESP8266 WiFi接入点工作模式应用库
ESP8266WiFiSTA库– ESP8266 WiFi终端工作模式应用库

联网
ESP8266WiFiGeneric库 – ESP8266基本功能库
ESP8266WiFiMulti库 – ESP8266记录多个WiFi网络信息并自动连接信号最强的WiFi网络
ESP8266WiFiScan库 – ESP8266扫描WiFi网络信号库

物联网通讯TCP协议
WiFiClient库 – TCP客户端库
WiFiServer库 – TCP服务器库

HTTP协议
ESP8266HTTPClient库 – HTTP客户端库
ESP8266WebServer库 – HTTP服务器库

HTTPS协议
WiFiClientSecure库 – HTTPS客户端库
WiFiServerSecure库 – HTTPS服务器库

UDP协议
WiFiUDP库 – UDP通讯库

DNS协议
DNSServer库 – DNS服务器应用库

其它部分由于本部分库相对应用较少，因此仅对它们进行简单介绍，而不像以上库内容具有较为详细介绍内容。

ESP8266mDNS库
ESP8266LLMNR库
Ethernet库
ESP8266NetBIOS库
ESP8266SSDP库

ESP8266库网络功能其它部分各库简介由于本部分库中的内容较少被用户所使用。因此我们仅对这部分内容进行简单介绍。
— ESP8266mDNS库通过本库，我们可以利用mDNS协议(multicast DNS协议)为ESP8266建立域名访问功能。也就是说，我们在通过WiFi访问ESP8266时，无需使用ESP8266的IP地址，而可以为ESP8266分配域名并实现访问。就像我们在访问某一个网址服务器一样。但由于安卓系统不支持mDNS协议，因此使用本库时要慎重。
— ESP8266LLMNR库通过本库，我们可以利用LLMNR协议(Link-Local Multicast Name Resolution协议)为ESP8266建立域名访问功能。也就是说，我们在通过WiFi访问ESP8266时，无需使用ESP8266的IP地址，而可以为ESP8266分配域名并实现访问。就像我们在访问某一个网址服务器一样。但由于Linux和苹果电脑mac系统不支持LLMNR协议，因此使用本库时要慎重。
— Ethernet库本库用于ESP8266的以太网通讯。该库是由Arduino的Ethernet库修改而来，以使ESP8266模块具备以太网通讯功能。
— ESP8266NetBIOS库本库用于ESP8266的NetBIOS应用。NetBIOS是Network Basic Input&#x2F;Output System的缩写，其中文名称是网上基本输入输出系统。NetBIOS可用于局域网设备间传输数据信息。如需了解更多关于NetBIOS的基本介绍，可前往百度百科的NETBIOS介绍页面。
— ESP8266SSDP库本库用于ESP8266的SSDP应用。SSDP是Simple Service Discovery Protocol的缩写，其中文名称是简单服务发现协议。SSDP协议提供了在网络里面发现设备的机制。控制点（也就是接受服务的客户端）可以通过使用SSDP协议，根据自己的需要查询网络里面提供服务的设备。设备（也就是提供服务的服务器端）也可以通过使用SSDP协议，向网络里的控制点宣告它的存在。
非网络功能时控部分
TICKER库 – 控制ESP8266定时执行任务。通过Ticker库，我们可以实现ESP8266的多任务处理功能。

哈希部分
HASH库 – 哈希算法库

数据储存部分
EEPROM库 – EEPROM数据储存库
SPIFFS库 – 闪存文件系统控制库
LittleFS库 – 闪存文件系统控制库
SD库 – SD文件储存库
ESP8266SdFat库 – Fat文件储存库

通讯部分SPI
SPI库 – SPI通讯库
SPISlave库 – SPI通讯库

I2C
Wire库 – I2C通讯库

串行通讯
SoftwareSerial库 – 软件串口库

电机控制部分
Servo库 – 舵机控制库

显示屏控制部分
TFT_Touch_Shield_V2库 – TFT触摸屏控制库

其它部分
GDBStub库 – GDB调试支持


OTA功能所谓OTA即Over The Air的英文缩写。该词对ESP8266来说指通过WiFi来向ESP8266上传控制程序或向ESP8266的闪存写入信息。如需了解以下各库的基本介绍，请点击此处。

ArduinoOTA库 – 使用Arduino IDE通过WiFi为开发板上传控制程序
ESP8266HTTPUpdateServer库 – 使用WiFi通过HTTP协议为ESP8266上传程序或闪存文件（有服务器功能）
ESP8266httpUpdate库 – 使用WiFi通过HTTP协议为ESP8266上传程序或闪存文件
ArduinoAVRISP库 – 通过WiFi为与ESP8266相连的Arduino控制器上传程序

ESP8266WiFiAP库ESP8266可以建立WiFi网络供其它设备连接。当ESP8266以此模式运行时，我们可以使用手机搜索ESP8266所建立的WiFi网络并进行连接。

当ESP8266以上图所示的模式进行工作时，我们称ESP8266的工作模式是“接入点模式(AP模式)”。
ESP8266模块的工作模式一共有三种。分别是：1，接入点模式（AP）2，无线终端模式（Wireless Station）3，混合模式。
ESP8266WiFiAP库用于ESP8266的接入点工作模式启动和设置。以下为ESP8266WiFiAP库的整体结构图。在此图下方有ESP8266WiFiAP库的函数目录。您可以通过点击目录项目打开各个函数的说明页面。

管理类型softAP说明softAP函数可用于启动校验式wifi网络或开放式wifi网络。校验式网络就是需要我们输入密码的网络，开放网络也就是不需要密码，只需要知道网络的名字就可以链接的无密码网络。
语法WiFi.softAP()WiFi.softAP(ssid, passphrase, channel, ssid_hidden, max_connection)
参数
ssid: char型，WiFi网络名称

passphrase: int型，WiFi密码(对于WPA2加密类型最少8个字符，对于开放网络设置为NULL)
channel: int型，wifi信道。可选通道有1-13，不设置的情况下默认是1。
hidden: bool型，控制 WiFI是否隐藏的标志变量。设置为0不隐藏，设置为1隐藏。


passphrase: int型，WiFi密码(对于WPA2加密类型最少8个字符，对于开放网络设置为NULL)
channel: int型，wifi信道。可选通道有1-13，不设置的情况下默认是1。
hidden: bool型，控制 WiFI是否隐藏的标志变量。设置为0不隐藏，设置为1隐藏。

max_connection: int型，最大的允许连接的无线终端数量。可选数值范围是1 – 4(ESP8266模块最多允许同时连接的无线终端设备数量是4个）。


示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将以下示例程序上传给ESP8266开发板后，ESP8266将会建立一个隐藏的WiFi网络。网络名称(SSID)为”TaichiMaker_WIFI”,网络密码为”12345678″ 。这些信息都是通过以下程序中的WiFi.softAP(AP_ssid, password,3,1);实现的。当然您也可以自行修改网络名称(SSID)和网络密码。
值得注意的是，WiFi.softAP(AP_ssid, password,3,1)语句中的3意味着ESP8266所建立的WiFi网络使用信道3。最后一个参数1意味着此WiFi网络是隐藏网络。
/****************************************************程序名称/Program name     : softAP()程序目的/Purpose          : 此程序使用ESP8266WiFiAP库来演示softAP()函数的用法softAP()函数会开启一个校验式wifi。我们可以在代码中设置WiFi网络名称、WiFi密码、最大允许连接设备数量、信号通道编号、是否广播WiFi名称。-----------------------------------------------------****************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下接入点名字#define password  &quot;12345678&quot;         //这里改成你的设备当前环境下接入点密码void setup() &#123;  // 启动串口通讯  Serial.begin(9600);   Serial.println();  //配置接入点信息  WiFi.mode(WIFI_AP);  //启动接入点模式，并设置账号和密码  Serial.print(&quot;设置接入点中 ... &quot;);  //启动校验式网络（需要输入账号密码的网络）,通道为3，wifi隐藏，最大连接数=4  WiFi.softAP(AP_ssid, password,3,1);  Serial.println(&quot;&quot;);              // 通过串口监视器输出信息  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;接入点名字:&quot;);      Serial.println(AP_ssid);         // 告知用户建立的接入点WiFi名  Serial.print(&quot;接入点密码:&quot;);          Serial.println(password);        // 告知用户建立的接入点WiFi密码&#125;void loop() &#123;&#125;

softAPConfig说明softAPConfig函数可用于配置ESP8266开发板所建立的接入点网络信息，如开发板IP地址，网关，子网掩码。
假如您对IP地址、网关、以及子网掩码的概念不甚清楚，可通过以下百度百科内容来对它们进行初步了解。
百度百科-IP地址介绍页面百度百科-网关介绍页面百度百科-子网掩码介绍页面
语法WiFi.softAPConfig() WiFi.softAPConfig (local_ip, gateway, subnet)
参数
local_ip： 接入点的ip地址。(IPAddress型)
gateway： 网关IP地址。 (IPAddress型)
subnet： 子网掩码。(IPAddress型）

返回值返回设置结果。设置成功返回true，否则返回false。数据类型为bool型。
示例程序在以下示例程序中，我们使用了以下语句建立了三个IPAddress类型的变量。
IPAddress local_IP(192,168,4,22);//手动设置的开启的网络的ip地址 
IPAddress gateway(192,168,4,9); //手动设置的网关IP地址
IPAddress subnet(255,255,255,0); //手动设置的子网掩码
接下来我们使用以下语句，利用以上变量对ESP8266所建立的WiFi网络进行设置。
WiFi.softAPConfig(local_IP, gateway, subnet);
注意：在不同的网络环境中，子网掩码，网关IP等信息各不相同，所以您在使用本示例程序时要根据您网络环境的网关IP、设备IP、子网掩码进行相应设置。请不要照搬示例程序中的IP地址，否则例程可能会无法正常运行。
/***************************************************程序名称/Program name     : softAPConfig()演示程序目的/Purpose          : 此程序使用ESP8266WiFiAP库来演示softAPConfig()函数可用于配置网络信息.在wifi初始化时可配置接入点IP地址，网关IP地址，子网掩码和默认的IP地址.****************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下接入点名字#define password  &quot;12345678&quot;          //这里改成你的设备当前环境下接入点密码 IPAddress local_IP(192,168,4,22);//手动设置的开启的网络的ip地址IPAddress gateway(192,168,4,9);  //手动设置的网关IP地址IPAddress subnet(255,255,255,0); //手动设置的子网掩码 bool flag; void setup() &#123;  // 启动串口通讯  Serial.begin(9600);   Serial.println();    //设置为接入点模式  WiFi.mode(WIFI_AP);    //配置接入点的IP，网关IP，子网掩码  WiFi.softAPConfig(local_IP, gateway, subnet);    //启动AP，并设置账号和密码  Serial.printf(&quot;设置接入点中 ... &quot;);    //启动校验式网络（需要输入账号密码的网络）,通道为3，wifi隐藏，最大连接数=4  WiFi.softAP(AP_ssid, password,3,1);    //监控状态变量result   flag = WiFi.softAP(AP_ssid, password);   if(flag)&#123;   Serial.println(&quot;&quot;);              // 通过串口监视器输出信息  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;接入点名字:&quot;);      Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名  Serial.print(&quot;接入点密码:&quot;);          Serial.println(password);        // 告知用户建立的接入点WiFi密码     Serial.println(&quot;网络IP&quot;);  Serial.println(&quot;local_IP&quot;);     //打印ip地址  Serial.println(&quot;网关IP&quot;);  Serial.println(gateway);        //打印网关IP  Serial.println(&quot;子网掩码：&quot;);  Serial.println(subnet);         //打印子网掩码  &#125;else&#123;    //若没有开启成功    Serial.println(&quot;开启失败&quot;);  &#125;    Serial.println(&quot;初始化结束&quot;);&#125; void loop() &#123;&#125;



softAPDisconnect说明softAPdisconnect函数可用于关闭ESP8266开发板的接入点模式，即关闭ESP8266所建立的WiFi网络。
语法
WiFi.softAPdisconnect()
WiFi.softAPdisconnect(val)

参数参数val类型为bool。如果将该参数设置为true，设备将直接关闭接入点模式。
在不输入参数的情况下调用该函数，设备会将当前配置的网络名和密码设置为空值。
返回值返回设置是否成功的结果。设置成功返回true。数据类型为bool型。
示例程序/***************************************************  程序名称/Program name     : softAPdisconnect()函数演示  程序目的/Purpose          :   此程序使用ESP8266WiFiAP库来演示softAPdisconnect()可用，可关闭AP模式***************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下接入点名字#define password  &quot;12345678&quot;         //这里改成你的设备当前环境下接入点密码 bool flag;bool wifioff = true;      // 接入点模式设置变量 void setup() &#123;  // 启动串口通讯  Serial.begin(9600);  Serial.println();    //设置为接入点模式  WiFi.mode(WIFI_AP);    //启动AP，并设置账号和密码  Serial.printf(&quot;设置接入点中 ... &quot;);    //启动校验式网络（需要输入账号密码的网络）,通道为3，wifi隐藏，最大连接数=4  WiFi.softAP(AP_ssid, password, 3, 1);    //监控状态变量result  flag = WiFi.softAP(AP_ssid, password);    if (flag) &#123;    Serial.println(&quot;&quot;);              // 通过串口监视器输出信息    Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式    Serial.println(WiFi.getMode());    Serial.print(&quot;接入点名字:&quot;);    Serial.println(AP_ssid);         // 告知用户建立的接入点WiFi名    Serial.print(&quot;接入点密码:&quot;);    Serial.println(password);        // 告知用户建立的接入点WiFi密码    Serial.println(&quot;接入点模式成功开启&quot;);    Serial.println(&quot;15秒后关闭接入点&quot;);    delay(5000);    delay(5000);    delay(5000); //延时15s检查接入点开启效果    Serial.println(&quot;即将关闭接入点&quot;);    delay(1000);    WiFi.softAPdisconnect(wifioff);//关闭接入点    Serial.println(&quot;接入点已经关闭&quot;);  &#125; else &#123;    //若没有开启成功    Serial.println(&quot;开启失败&quot;);  &#125;    Serial.println(&quot;初始化结束&quot;);&#125; void loop() &#123;&#125;



信息类型softAPIP说明ESP8266开发板建立WiFi接入点后， 我们可以使用本函数获取ESP8266开发板的IP地址。
语法wiFiAP.softAPIP()
Serial.println(wiFiAP.softAPIP());
参数无
返回值此函数的返回值是ESP8266开发板的IP地址。（类型：IPAddress）
示例程序当您将以下示例程序上传给ESP8266开发板后，ESP8266将会建立一个隐藏的WiFi网络。网络名称(SSID)为”TaichiMaker_WIFI”,网络密码为”12345678″ 。在开发板成功建立WiFi网络后，您也可以通过串口监视器看到ESP8266开发板的IP地址。该信息是由以下程序中的WiFi.softAPIP()所获取的。
/**********************************************************************程序名称/Program name     : softAPIP获取接入点的IP地址程序目的/Purpose          : 演示softAPIP()函数的用法，获取接入点的ip地址***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下接入点名字#define password  &quot;12345678&quot;         //这里改成你的设备当前环境下接入点密码 bool flag;     void setup() &#123;  // 启动串口通讯  Serial.begin(9600);  Serial.println();    //设置为接入点模式  WiFi.mode(WIFI_AP);    //启动AP，并设置账号和密码  Serial.printf(&quot;设置接入点中 ... &quot;);    //启动校验式网络（需要输入账号密码的网络）,通道为3，wifi隐藏，最大连接数=4  WiFi.softAP(AP_ssid, password, 3, 1);    //监控状态变量result  flag = WiFi.softAP(AP_ssid, password);  if (flag) &#123;    Serial.println(&quot;&quot;);              // 通过串口监视器输出信息    Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式    Serial.println(WiFi.getMode());        Serial.print(&quot;接入点名字:&quot;);    Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名        Serial.print(&quot;接入点密码:&quot;);    Serial.println(password);        // 告知用户建立的接入点WiFi密码    Serial.print(&quot;接入点模式成功开启&quot;);     Serial.print(&quot;当前接入点的IP地址为： &quot;);    Serial.println(WiFi.softAPIP());     //串口打印当前AP点的IP地址  &#125; else &#123;    //若没有开启成功    Serial.println(&quot;开启失败&quot;);  &#125;    Serial.println(&quot;初始化结束&quot;);&#125; void loop() &#123;&#125;



softAPmacAddress说明ESP8266开发板建立WiFi接入点后， 我们可以使用本函数获取ESP8266开发板的mac地址。
语法WiFi.softAPmacAddress()WiFi.softAPmacAddress(macAddr)
参数 &#x2F; 返回值a.如以下语句所示，如果不输入参数，函数的返回值为ESP8266开发板的mac地址（String类型）。
Serial.printf(&quot;MAC地址为 %s\n&quot;, WiFi.softAPmacAddress().c_str());

b.如果输入参数macAddr。那么ESP8266开发板的mac地址将会存储在macAddr中。macAddr必须是一个uint8_t类型的数组，且该数组含有6个元素。如下简例所示：
uint8_t macAddr[6];WiFi.softAPmacAddress(macAddr);Serial.printf(&quot;MAC地址为  %02x:%02x:%02x:%02x:%02x:%02x\n&quot;, macAddr[0], macAddr[1], macAddr[2], macAddr[3], macAddr[4], macAddr[5]);





示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将以下示例程序上传给ESP8266开发板后，ESP8266将会建立一个WiFi网络。网络名称(SSID)为”TaichiMaker_WIFI”,网络密码为”12345678″ 。在开发板成功建立WiFi网络后，您将通过串口监视器看到ESP8266模块的mac地址。在以下示例程序中，我们使用了两种macAddress函数调用方式来获取设备的IP地址。第一种是有参数的第二种是无参数的。这两种方式所获得的mac地址格式不同。有参数调用时，mac地址保存在数组macAddr中。无参数调用时，mac地址将以字符串形式返回。
/**********************************************************************程序名称/Program name     : softAPIP获取接入点MAC地址程序目的/Purpose          : 演示softAPIP()函数的用法，获取接入点的MAC地址***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下接入点名字#define password  &quot;12345678&quot;         //这里改成你的设备当前环境下接入点密码bool flag;uint8_t macAddr[6]; // 存储设备mac地址的数组void setup() &#123;  // 启动串口通讯  Serial.begin(9600);  Serial.println();    //设置为接入点模式  WiFi.mode(WIFI_AP);    //启动AP，并设置账号和密码  Serial.printf(&quot;设置接入点中 ... &quot;);    //启动校验式网络（需要输入账号密码的网络）  WiFi.softAP(AP_ssid, password);    //监控状态变量result  flag = WiFi.softAP(AP_ssid, password);    if (flag) &#123;    Serial.println(&quot;&quot;);              // 通过串口监视器输出信息    Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式    Serial.println(WiFi.getMode());    Serial.print(&quot;接入点名字:&quot;);    Serial.println(AP_ssid);         // 告知用户建立的接入点WiFi名    Serial.print(&quot;接入点密码:&quot;);    Serial.println(password);        // 告知用户建立的接入点WiFi密码    Serial.println(&quot;接入点模式成功开启&quot;);    //不输入参数获取MAC地址    Serial.printf(&quot;MAC地址为 %s\n&quot;, WiFi.softAPmacAddress().c_str());    //输入参数获取MAC地址    WiFi.softAPmacAddress(macAddr);                                      Serial.printf(&quot;MAC地址为  %02x:%02x:%02x:%02x:%02x:%02x\n&quot;, macAddr[0], macAddr[1], macAddr[2], macAddr[3], macAddr[4], macAddr[5]);  &#125; else &#123;    //若没有开启成功    Serial.println(&quot;开启失败&quot;);  &#125;  Serial.println(&quot;初始化结束&quot;);&#125;void loop() &#123;&#125;



softAPSSID说明ESP8266开发板建立WiFi接入点后， 我们可以使用本函数获取WiFi名称。
语法WiFi.softAPSSID()
参数无
返回值返回接入点WiFi名称，数据类型为字符串型。
示例程序当您将以下示例程序上传给ESP8266开发板后，ESP8266将会建立一个WiFi网络。网络名称(SSID)为”TaichiMaker_WIFI”,网络密码为”12345678″ 。在开发板成功建立WiFi网络后，您也可以通过串口监视器看到ESP8266建立的WiFi名称。该信息是由以下程序中的WiFi.softAPSSID()所获取的。
/**********************************************************************程序名称/Program name     : softAPSSID获取接入点SSID程序目的/Purpose          : 演示softAPSSID()函数的用法，获取接入点的wifi名称-----------------------------------------------------------------------***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下接入点名字#define password  &quot;12345678&quot;          //这里改成你的设备当前环境下接入点密码 bool flag;  void setup() &#123;  // 启动串口通讯  Serial.begin(9600);  Serial.println();    //设置为接入点模式  WiFi.mode(WIFI_AP);   //启动AP，并设置账号和密码  Serial.printf(&quot;设置接入点中 ... &quot;);    //启动校验式网络（需要输入账号密码的网络）  WiFi.softAP(AP_ssid, password);    //监控状态变量result  flag = WiFi.softAP(AP_ssid, password);    if (flag) &#123;    Serial.println(&quot;&quot;);              // 通过串口监视器输出信息    Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式    Serial.println(WiFi.getMode());        Serial.print(&quot;接入点名字:&quot;);    Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名        Serial.print(&quot;接入点密码:&quot;);    Serial.println(password);        // 告知用户建立的接入点WiFi密码        Serial.print(&quot;接入点模式成功开启&quot;);     Serial.print(&quot;softAPSSID()获取接入点SSID为：&quot;);    Serial.println(WiFi.softAPSSID()); //输出接入点的wifi名称  &#125; else &#123;    //若没有开启成功    Serial.println(&quot;开启失败&quot;);  &#125;  Serial.println(&quot;初始化结束&quot;);&#125; void loop() &#123;&#125;







softAPPSK说明ESP8266开发板建立WiFi接入点后， 我们可以使用本函数获取WiFi密码。
语法wiFi.softAPPSK()
参数无
返回值返回接入点WiFi密码，数据类型为字符串型
示例程序当您将以下示例程序上传给ESP8266开发板后，ESP8266将会建立一个WiFi网络。网络名称(SSID)为”TaichiMaker_WIFI”,网络密码为”12345678″ 。在开发板成功建立WiFi网络后，您也可以通过串口监视器看到ESP8266建立的WiFi名称。该信息是由以下程序中的WiFi.softAPPSK()所获取的。
/**********************************************************************程序名称/Program name     : softAPPSK获取AP的psk程序目的/Purpose          : 演示softAPSSID()函数的用法，获取接入点密码***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下接入点名字#define password  &quot;12345678&quot;          //这里改成你的设备当前环境下接入点密码 bool flag;  void setup() &#123;  // 启动串口通讯  Serial.begin(9600);  Serial.println();    //设置为接入点模式  WiFi.mode(WIFI_AP);   //启动AP，并设置账号和密码  Serial.printf(&quot;设置接入点中 ... &quot;);    //启动校验式网络（需要输入账号密码的网络）  WiFi.softAP(AP_ssid, password);    //监控状态变量result  flag = WiFi.softAP(AP_ssid, password);    if (flag) &#123;    Serial.println(&quot;&quot;);              // 通过串口监视器输出信息    Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式    Serial.println(WiFi.getMode());        Serial.print(&quot;接入点名字:&quot;);    Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名        Serial.print(&quot;接入点密码:&quot;);    Serial.println(password);        // 告知用户建立的接入点WiFi密码        Serial.print(&quot;接入点模式成功开启&quot;);     Serial.print(&quot;softAPPSK()获取接入点密码为：&quot;);    Serial.println(WiFi.softAPPSK()); //输出接入点密码  &#125; else &#123;    //若没有开启成功    Serial.println(&quot;开启失败&quot;);  &#125;  Serial.println(&quot;初始化结束&quot;);&#125; void loop() &#123;&#125;





softAPGetStationNum说明softAPgetStationNum函数可用于获取通过WiFi连接到ESP8266开发板接入点的无线终端数量。
语法wiFi.softAPgetStationNum()
参数无
返回值连接到ESP8266开发板接入点的无线终端数量，数据类型为int型。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将以下示例程序上传给ESP8266开发板后，ESP8266将会建立一个WiFi网络。网络名称(SSID)为”TaichiMaker_WIFI”,网络密码为”12345678″ 。在开发板成功建立WiFi网络后，您也可以通过串口监视器看到连接到该WiFi网络的终端数量。该信息是由以下程序中的WiFi.softAPgetStationNum()所获取的。
/**********************************************************************程序名称/Program name     : 获取连接到接入点的无线终端数量程序目的/Purpose          : 演示softAPSSID()函数的用法，获取连接到接入点的无线终端数量***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下接入点名字#define password  &quot;12345678&quot;          //这里改成你的设备当前环境下接入点密码 bool flag;void setup() &#123;  // 启动串口通讯  Serial.begin(9600);  Serial.println();  //设置为接入点模式  WiFi.mode(WIFI_AP);    //启动AP，并设置账号和密码  Serial.printf(&quot;设置接入点中 ... &quot;);    //启动校验式网络（需要输入账号密码的网络）  WiFi.softAP(AP_ssid, password);    //监控状态变量result  flag = WiFi.softAP(AP_ssid, password);  if (flag) &#123;    Serial.println(&quot;&quot;);              // 通过串口监视器输出信息    Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式    Serial.println(WiFi.getMode());        Serial.print(&quot;接入点名字:&quot;);    Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名        Serial.print(&quot;接入点密码:&quot;);      Serial.println(password);        // 告知用户建立的接入点WiFi密码    Serial.print(&quot;接入点模式成功开启&quot;);  &#125; else &#123;    //若没有开启成功    Serial.println(&quot;开启失败&quot;);  &#125;  Serial.println(&quot;初始化结束&quot;);&#125; void loop() &#123;  //打印出当前连接到此接入点上的无线终端数目  Serial.printf(&quot;连接此接入点上的无线终端数目 = %d\n&quot;, WiFi.softAPgetStationNum());  delay(1000);&#125;



ESP8266WiFiSTA库ESP8266WiFiSTA库用于ESP8266开发板的无线终端模式（Wireless Station）控制。
ESP8266模块的工作模式一共有三种。分别是：1，接入点端模式（AP）2，无线终端模式（Wireless Station）3，混合模式。
在无线终端模式下，ESP8266开发板可通过WiFi连接无线路由器。这与用您的手机通过WiFi连接无线路由器的模式相同。

以下为ESP8266WiFiSTA库的整体结构图。在此图下方有ESP8266WiFiSTA库的函数目录。

管理类型begin – 连接WiFi说明此函数用于启动ESP8266开发板的无线终端工作模式。
在无线终端工作模式下，ESP8266可以通过局域网或者互联网收取物联网信息或者向其它物联网设备发送控制信号。
注：如果ESP8266模块之前被设置为接入点模式(AP)，我们在直接切换为无线终端模式的时候，使用ESP8266WiFiSTA库 – begin函数有可能会切换为接入点+无线终端混合的模式，而不能成功切换为我们想要的无线终端模式。如果调用后不清楚当前的模式状况，或者网络出现异常，我们最好检测一下ESP8266模块当前处于什么模式。(具体请参阅ESP8266WiFiGeneric库中的mode函数)
语法WiFi.begin()a. 在不使用任何参数的情况下调用此函数，ESP8266模块将启用无线终端模式，并根据以前保存在闪存中的wifi配置连接到最近一次使用的接入点。
WiFi.begin(ssid, password, channel, bssid, connect)b.我们也可以再调用begin函数的时候，为函数提供参数。这些参数的具体功能请见下面的“参数”部分介绍。
参数
ssid – 要连接的wifi接入点的名字，最多可以包含32个字符。(类型：char*)
password – 要连接的 wifi接入点密码，长度至少应为8个字符且不超过64个字符。(类型：char*)
channel – 要连接的wifi接入点信道。(类型：int32_t)
bssid – 要连接的wifi接入点的mac地址。(类型：const uint8_t*)
connect – 连接状态参数。如果connect参数为true，ESP8266开发板会使用闪存中储存的信息尝试连接WiFi。如果connect参数为false，ESP8266开发板不会尝试连接WiFi，而只会将WiFi连接信息保存在闪存中。(类型：bool)

返回值返回值数据类型为布尔型。如果ESP8266开发板成功启动无线终端模式，则返回true，否则返回false。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的工作模式，即无线终端模式。
/**********************************************************************  程序名称/Program name     : WiFi.begin()演示  程序目的/Purpose          :   此程序使用ESP8266WiFiSTA库来演示建立连接，ESP8266模块切换工作模式为无线终端模式。***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxxx&quot;         //这里改成你的设备当前环境下要连接的接入点密码 int i = 0;    //用来判定连接是否超时的累加量 void setup() &#123;  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600  Serial.println(&quot;开始连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;    Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户建立的接入点WiFi密码  Serial.print(&quot;无线终端模式成功开启，网络连接成功&quot;);  Serial.println(&quot;初始化完成&quot;);&#125; void loop() &#123;&#125;





config – 配置网络（如,IP地址，网关IP等）说明config函数可以用来设置ESP8266模块在无线终端模式下的IP配置，并将站接口的IP地址设置为用户定义的值。
语法wiFi.config()wiFi.config(local_ip, gateway, subnet, dns1, dns2)
用法简例
IPAddress staticIP(192,168,1,22);//ESP8266的IP地址IPAddress gateway(192,168,1,9); //网关IP地址IPAddress subnet(255,255,255,0);//子网掩码WiFi.config(staticIP, gateway, subnet);//进行设置



参数
local_ip: 配置ESP8266的固定IP地址。(IPAdress型)
gateway: 网关IP地址。(IPAdress型)
subnet: 子网掩码。(IPAddress型)
dns1，dns2: 这两个参数是可选参数。它们可定义域名服务器（DNS）的ip地址，这些域名服务器会关联一个域名目录，并将它们翻译成ip地址 (IPAddress型)

返回值返回值会返回调用函数后是否有设置成功的结果。如果设置成功则返回true。数据类型为布尔型。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的网络配置信息。
以下程序中，我们首先使用了以下语句建立用于配置ESP8266模块的IP地址信息。
IPAddress staticIP(192, 168, 1, 22);IPAddress gateway(192, 168, 1, 9);IPAddress subnet(255, 255, 255, 0);

接下来，我们使用以下语句对开发板进行网络配置。
WiFi.config(staticIP, gateway, subnet)

在使用以下示例程序时请注意：

设置了静态IP地址的无线终端在连接WiFi时速度会更快。下面附带的例子用了500ms左右就可以连接上。原因是跳过了获得动态IP配置这一步。在设置固定IP时，要注意不要出现设置的ESP8266开发板IP地址与其它网络设备的IP发生冲突。

由于不同路由所提供的WiFi网络配置是不同的,使用本例程时请根据网络环境设置自己的网关IP、设备IP和子网掩码，否则可能会造成例程无法正常运行


/**********************************************************************  程序名称/Program name     : WiFi.config()演示  程序目的/Purpose          :   此程序使用ESP8266WiFiSTA库来演示建立连接，ESP8266模块设置无线终端模式下的IP配置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxx&quot;          //这里改成你的设备当前环境下要连接的接入点密码 int i = 0;//用来判定连接是否超时的累加量IPAddress staticIP(192, 168, 1, 22);//请按照自己的网络环境设置这三个参数IPAddress gateway(192, 168, 1, 9);IPAddress subnet(255, 255, 255, 0); void setup(void)&#123;  Serial.begin(9600); // 启动串口通讯，波特率设置为9600  Serial.printf(&quot;正在配置网络&quot;);    //无线终端模式下配置IP，并将接口的IP配置设置为用户定义的值  //如果不设置 则表示使用DHCP下发的信息  WiFi.config(staticIP, gateway, subnet);  Serial.println(&quot;开始连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;    Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户连接到的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户连接到的接入点WiFi密码  Serial.print(&quot;无线终端模式成功开启&quot;);  Serial.print(&quot;当前无线终端静态IP地址： &quot;);// 告知用户当前无线终端的IP地址(也就是我们设置的地址)  Serial.println(WiFi.localIP());  Serial.print(&quot;当前无线终端网关的IP地址： &quot;);// 告知用户当前无线终端网关的IP地址  Serial.println(WiFi.gatewayIP());  Serial.print(&quot;当前无线终端： &quot;);// 告知用户当前无线终端的子网掩码地址  Serial.println(WiFi.subnetMask());  Serial.println(&quot;初始化完成&quot;);&#125; void loop() &#123;&#125;



reconnect – 重新连接WiFi说明调用reconnect函数可以让ESP8266模块断开再重新连接WiFi。
语法wifi.reconnect()注意：1.如果ESP8266模块没有接入任何WiFi或者不处于无线终端模式，则函数将返回false，且不执行任何操作2.如果函数返回true，则表示ESP8266已成功开始执行重新连接WiFi这一操作。但这里的返回值true并不代表ESP已经成功连接到了WiFi。
参数无
返回值数据类型为布尔型。返回false，则说明ESP8266不处于无线终端模式，或者说在此之前没有连结果任何接入点。返回true，说明已经成功重新启动WiFi连接。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，设备会保持连接状态等待10秒钟，然后设备将会使用以下程序中的WiFi.reconnect();语句来实现网络重新连接这一操作。
/**********************************************************************  程序名称/Program name     : WiFi.reconnect()演示  程序目的/Purpose          :  此程序使用ESP8266WiFiSTA库来演示reconnect()重新连接网络***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxxx&quot;         //这里改成你的设备当前环境下要连接的接入点密码 int i = 0;//用来判定连接是否超时的累加量 void setup(void)&#123;  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600  Serial.begin(9600);  Serial.println(&quot;开始连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;  Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户连接到的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户连接到的接入点WiFi密码  Serial.println(&quot;无线终端模式成功开启，网络连接成功&quot;);  delay(1000);  Serial.println(&quot;10秒后断开重连&quot;);  delay(5000);  delay(5000);  Serial.println(&quot;即将重新连接&quot;);  delay(1000);    Serial.println(&quot;开始重新连接&quot;);  WiFi.reconnect();//重新连接    i = 0;//重新赋值i以便再次计数  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是重新连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;    Serial.println(&quot;重新连接成功！&quot;);&#125; void loop() &#123;&#125;





disconnect – 断开WiFi连接说明disconnect函数将当前配置给ESP8266模块的SSID和密码设置为空值，使ESP8266与断开WiFi连接。
语法wiFi.disconnect()
wiFi.disconnect(wifioff)
如果参数wifioff设置为false或者不填参数，SSID和密码将会被设置为空值，同时这一操作还会使ESP8266模块与接入点断开连接。需要注意的是，用这种方法仅仅会断开WiFi连接，ESP8266模块仍然会处于无线终端模式。
WiFi.disconnect();//断开连接，但仍然处于无线终端模式，只是清除了SSID和密码
当我们设置入参wifioff 为true，那么这样的操作会直接关闭无线终端模式。
bool wifioff = true//设置关闭变量WiFi.disconnect(wifioff);//断开连接





参数wifioff (可选参数)：此参数为bool型。设置为true，那么就会关闭无线终端模式。设置为false，则SSID和密码将会被设置为空值，同时还会使ESP8266模块与接入点断开连接。
返回值返回是否成功设置。成功设置则返回true，否则返回false。返回值数据类型为布尔型。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，设备会保持连接状态等待10秒钟，然后设备将会使用以下程序中的 WiFi.disconnect(wifioff) 语句来实现断开网络这一操作。
/**********************************************************************  程序名称/Program name     : WiFi.disconnect(wifioff)演示  程序目的/Purpose          :  此程序使用ESP8266WiFiSTA库来演示建立连接，ESP8266模块关闭无线终端模式***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxxx&quot;         //这里改成你的设备当前环境下要连接的接入点密码 int i = 0;//用来判定连接是否超时的累加量 bool wifioff = true;//演示关闭连接所需的参数 void setup(void)&#123;  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600  Serial.println(&quot;开始连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;  Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户连接到的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户连接到的接入点WiFi密码  Serial.print(&quot;无线终端模式成功开启，网络连接成功&quot;);    Serial.println(&quot;10秒后断开连接&quot;);  delay(5000);  delay(5000);    Serial.println(&quot;即将断开连接&quot;);  delay(500);  WiFi.disconnect(wifioff);//断开连接    if (WiFi.status() != WL_CONNECTED) &#123;    Serial.println(&quot;无线终端和接入点的连接已中断&quot;);  &#125;  else  &#123;    Serial.println(&quot;未能成功断开连接！&quot;);  &#125;&#125; void loop() &#123;&#125;



setAutoConnect – 设置是否自动连接WiFi说明setAutoConnect函数可以激活ESP8266模块的自动连接模式。模式激活后，ESP8266模块会在通电后自动连接到最近连接过的WiFi接入点。
另外，我们也可以使用getAutoConnect函数来获取ESP8266开发板是否激活自动连接模式。
语法wiFi.setAutoConnect()
wiFi.setAutoConnect(autoConnect)
简例：
bool autoConnect = ture;...WiFi.setAutoConnect(autoConnect); //启用自动连接模式



参数autoConnect是一个可选的参数。如果设置为false，则将禁用自动连接功能。如果省略或设置为true，则将启用自动连接模式。（参数类型：布尔型）
返回值返回值的状态可以表明是否设置成功。设置自动连接成功则返回true，否则返回false。数据类型为布尔型。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，设备会保持连接状态等待10秒钟，然后设备将会使用以下程序中的 WiFi.setAutoConnect(autoConnect) 语句来实激活自动连接模式。
/**********************************************************************  程序名称/Program name     : WiFi.setAutoConnect()演示  程序目的/Purpose          :  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下设置上电后自动连接***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxxx&quot;         //这里改成你的设备当前环境下要连接的接入点密码 bool autoConnect = true; int i = 0;//用来判定连接是否超时的累加量 void setup(void)&#123;  // 启动串口通讯，波特率设置为9600  Serial.begin(9600);  Serial.printf(&quot;正在配置网络&quot;);    //设置自动连接  WiFi.setAutoConnect(autoConnect);//启用自动连接。  Serial.println(&quot;已设置自动连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  Serial.println(&quot;开始连接&quot;);  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;  Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.println(&quot;&quot;);              // 通过串口监视器输出信息  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户连接到的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户连接到的接入点WiFi密码  Serial.println(&quot;无线终端模式成功开启，网络连接成功&quot;);&#125; void loop()&#123;&#125;



setAutoReconnect – 设置是否自动重新连接WiFi说明setAutoReconnect函数可以用来设置是否要自动重新连接到最近连接过的接入点。设置后，一旦ESP8266模块出现断开网络连接的状况，ESP8266模块会反复尝试自动重连。
语法wiFi.setAutoReconnect()
wiFi.setAutoReconnect(autoReconnect)
参数输入参数只要一个autoReconnect，如果参数autoReconnect设置为true，则模块将尝试重新建立与无线终端的丢失连接。如果设置为false则模块将保持断开连接状态。（参数类型：bool）
返回值返回值会返回设置是否成功。如果设置成功则返回true，数据类型为布尔型。
注意：断开网络连接后再调用该函数进行设置是无效的，一定要在断开连接之前就设置好，最好就放在网络初始化的时候进行设置。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，设备会保持连接状态等待10秒钟，然后设备将会使用以下程序中的WiFi.setAutoReconnect(autoReconnect); 语句来设置ESP8266模块为自动重新连接网络模式。你可以在模块连接网络成功后，重启WiFi接入点，这时候您将会看到ESP8266模块在WiFi接入点重启后，重新尝试连接该WiFi接入点。
/**********************************************************************  程序名称/Program name     : WiFi.setAutoReConnect()演示  程序目的/Purpose          :  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下设置自动重新连接***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxxx&quot;         //这里改成你的设备当前环境下要连接的接入点密码 bool autoReconnect = true; int i = 0;//用来判定连接是否超时的累加量 void setup(void)&#123;  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600  Serial.printf(&quot;正在配置网络&quot;);    //设置自动连接  WiFi.setAutoReconnect(autoReconnect);//设置断开连接后重连  Serial.println(&quot;已设置自动重新连接&quot;);  Serial.println(&quot;开始连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;  Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户连接到的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户连接到的接入点WiFi密码  Serial.print(&quot;无线终端模式成功开启，网络连接成功&quot;);  Serial.println(&quot;此时可关闭接入点使网络连接断开，接入点再次打开后ESP8266模块可自动重连&quot;);&#125; void loop() &#123;  if(WiFi.status() == WL_CONNECTED)  &#123;    Serial.println(&quot;网络连接正常&quot;);  &#125;  else  &#123;    Serial.println(&quot;网络连接断开，模块已设置自动重连，正在等待连接&quot;);  &#125;  delay(1000);&#125;







waitForConnectResult – 等待WiFi连接说明waitForConnectResult用于在无线终端模式或无线终端+接入点混合模式下的ESP8266模块检测当前连接状态。
语法wiFi.waitForConnectResult()
wiFi.waitForConnectResult(timeoutLength)
简例：
unsigned long timeoutLength = 5000;//设置5000毫秒后无响应就视为网络连接超时...WiFi.waitForConnectResult(timeoutLength);		

参数ESP8266在尝试连接WiFi时，我们可以通过timeoutLength（毫秒）来设置等待连接的时间。如果ESP8266在timeoutLength设置的时间内仍未成功连接WiFi，则本函数会返回“超时错误”错误码：-1。
关于ESP8266的错误码详情见下面的返回值部分（参数数据类型：unsigned long型）
返回值返回值类型为uint8_t。以下是返回值数值以及对应的信息：

255： WL_NO_SHIELD – 返回值为255说明无扩展板。8266本来带有网络功能，不需要额外的扩展板（sheld），因此一般不会出现这个报错
0：​ WL_IDLE_STATUS – 返回值为0说明正在尝试连接
1​： WL_NO_SSID_AVAIL – 返回值为1说明没有找到设定的SSID的网络
2​： WL_SCAN_COMPLETED – 返回值为2说明网络扫描完毕
3：​ WL_CONNECTED – 返回值为3说明连接成功成功
4： WL_CONNECT_FAILED – 返回值为4说明连接失败
5： WL_CONNECTION_LOST – 返回值为5说明连接丢失
6： WL_DISCONNECTED – 返回值为6说明未连接
-1： WiFi连接超时

示例程序/**********************************************************************  程序名称/Program name     : WiFi.waitForConnectResult()演示  日期/Date（YYYYMMDD）     : 20200405  此程序使用ESP8266WiFiSTA库来演示在Station模式下返回当前网络连接状态。本实例仅展示成功连接状况的返回值***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxxx&quot;         //这里改成你的设备当前环境下要连接的接入点密码 int i = 0;//用来判定连接是否超时的累加量 void setup(void)&#123;  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600  Serial.println(&quot;开始连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;  Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户连接到的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户连接到的接入点WiFi密码  Serial.print(&quot;无线终端模式成功开启，网络连接成功&quot;);&#125; void loop() &#123;  //设置5000毫秒后无响应就视为网络连接超时    unsigned long timeoutLength = 5000;     //打印当前网络连接状态码  Serial.println(WiFi.waitForConnectResult(timeoutLength));    delay(1000);&#125;



信息类型status – 获取WiFi连接状态说明status函数可以在无线终端模式下，获取当前的ESP8266模块网络连接状态。
语法wifi.status()
简例：
Serial.printf(&quot;当前连接状态: &quot;);Serial.printf(WiFi.status());//打印当前连接状态



参数无
返回值返回值类型为uint8_t。以下是返回值数值以及对应的信息：

255： WL_NO_SHIELD – 返回值为255说明无扩展板。8266本来带有网络功能，不需要额外的扩展板（sheld），因此一般不会出现这个报错
0：​ WL_IDLE_STATUS – 返回值为0说明正在尝试连接
1​： WL_NO_SSID_AVAIL – 返回值为1说明没有找到设定的SSID的网络
2​： WL_SCAN_COMPLETED – 返回值为2说明网络扫描完毕
3：​ WL_CONNECTED – 返回值为3说明连接成功成功
4： WL_CONNECT_FAILED – 返回值为4说明连接失败
5： WL_CONNECTION_LOST – 返回值为5说明连接丢失
6： WL_DISCONNECTED – 返回值为6说明未连接

示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块的联网状态代码。在以下示例程序中，我们使用了WiFi.status()语句来获取联网状态。
/**********************************************************************  项目名称/Project          : 零基础入门学用物联网  程序名称/Program name     : WiFi.status()演示  团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)  作者/Author              : 小黑  日期/Date（YYYYMMDD）     : 20200405  此程序使用ESP8266WiFiSTA库来演示在无线终端模式获取当前的网络连接状态  -----------------------------------------------------------------------  本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。  该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：  http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxxx&quot;         //这里改成你的设备当前环境下要连接的接入点密码 int i = 0;//用来判定连接是否超时的累加量 void setup(void)&#123;  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600  Serial.println(&quot;开始连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;  Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户建立的接入点WiFi密码  Serial.print(&quot;无线终端模式成功开启，网络连接成功&quot;);  Serial.print(&quot;此时关闭接入点，可以看到连接状态报告函数 WiFi.status()返回值变化&quot;);&#125; void loop() &#123;  Serial.printf(&quot;\n当前连接状态: %d\n&quot;, WiFi.status());  delay(1000);&#125;



SSID – 获取SSID说明利用SSID函数可以获取当前ESP8266模块所连接的网络SSID。
语法wifi.SSID()
简例：
Serial.printf(&quot;SSID:&quot;);Serial.printf(WiFi.SSID()); //打印出当前8266模块所连接的网络的SSID



参数无
返回值返回SSID，数据类型为string型。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块所连接WiFi的SSID。
/**********************************************************************  程序名称/Program name     : WiFi.SSID()演示  程序目的/Purpose          :  此程序使用ESP8266WiFiSTA库来演示在无线终端模式获取当前网络的SSID***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxxx&quot;         //这里改成你的设备当前环境下要连接的接入点密码 int i = 0;//用来判定连接是否超时的累加量 void setup(void)&#123;  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600  Serial.println(&quot;开始连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;  Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户建立的接入点WiFi密码  Serial.print(&quot;无线终端模式成功开启，网络连接成功&quot;);   Serial.printf(&quot;SSID: %s\n&quot;, WiFi.SSID().c_str());//打印出当前8266模块所连接的网络的SSID.此处用.c_str()来确保打印正常&#125;void loop() &#123;  delay(1000);&#125;



psk – 获取psk说明无线终端模式下，调用psk()函数就可以获取ESP8266模块连接到当前网络的密码。
语法wifi.psk()
参数无
返回值返回当前连接的接入点的密码，数据类型为 string型
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块所连接WiFi的网络密码。
/**********************************************************************  程序名称/Program name     : WiFi.psk();演示 程序目的/Purpose          :  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下打印当前接入点密码***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxxxxxx&quot; //这里改成你的设备当前环境下要连接的接入点密码 int i = 0;//用来判定连接是否超时的累加量 void setup(void)&#123;  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600  Serial.println(&quot;开始连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;  Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户建立的接入点WiFi密码  Serial.print(&quot;无线终端模式成功开启，网络连接成功&quot;);   Serial.printf(&quot;psk: %s\n&quot;, WiFi.psk().c_str());//打印出当前8266模块所连接网络的psk.此处用.c_str()来确保打印正常&#125;void loop() &#123;&#125;



BSSIDstr – 获取WiFi接入点的mac地址说明当ESP8266开发板处于无线终端模式下，BSSIDstr函数可用于获取wif接入点设备的MAC地址。
语法wifi.BSSIDstr()

参数无
返回值wif接入点设备的MAC地址，返回值数据类型为string。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块所连接WiFi的接入点设备mac地址。
/**********************************************************************  程序名称/Program name     : WiFi.BSSID();  程序目的/Purpose          :  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下打印当前wifi网络macaddress***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxxx&quot;         //这里改成你的设备当前环境下要连接的接入点密码 int i = 0;//用来判定连接是否超时的累加量 void setup(void)&#123;  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600  Serial.println(&quot;开始连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;  Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户建立的接入点WiFi密码  Serial.print(&quot;无线终端模式成功开启，网络连接成功&quot;);    Serial.printf(&quot;BSSID为: &quot;);  Serial.printf(WiFi.BSSIDstr().c_str());//获取wifi接入点的MAC地址，并打印出来&#125; void loop() &#123;&#125;



localIP – 获取IP地址说明localIP函数可在无线终端模式下获取当前SEP8266模块的IP地址。
语法wifi.localIP()

参数无
返回值返回值为当前无线终端分配的IP地址，数据类型为IPAdress型。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块的IP地址。在以下示例程序中，我们使用了WiFi.localIP()语句来获取IP地址。
/**********************************************************************  程序名称/Program name     : WiFi.localIP();演示  程序目的/Purpose          :  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下打印当前无线终端IP地址***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxxx&quot;         //这里改成你的设备当前环境下要连接的接入点密码 int i = 0;//用来判定连接是否超时的累加量 void setup(void)&#123;  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600  Serial.println(&quot;开始连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;  Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户建立的接入点WiFi密码  Serial.print(&quot;无线终端模式成功开启，网络连接成功&quot;);    if (WiFi.status() == WL_CONNECTED)  &#123;    Serial.print(&quot;无线终端IP地址为: &quot;);    Serial.println(WiFi.localIP());  &#125;&#125; void loop() &#123;&#125;



subnetMask – 获取子网掩码说明利用SSID函数可以获取当前ESP8266模块所连接网络的子网掩码。
语法wifi.subnetMask()

简例：
Serial.print(&quot;子网掩码: &quot;);Serial.println(WiFi.subnetMask());//直接打因为字符串获取子网掩码



参数无
返回值返回值为ESP8266设备的子网掩码，数据类型为IPAdress。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块的子网掩码。在以下示例程序中，我们使用了WiFi.subnetMask()语句来获取该信息。
/**********************************************************************  程序名称/Program name     : WiFi.subnetMask()演示  程序目的/Purpose          :  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下打印子网掩码的IP地址***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxxx&quot;         //这里改成你的设备当前环境下要连接的接入点密码 int i = 0;//用来判定连接是否超时的累加量 void setup(void)&#123;  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600  Serial.println(&quot;开始连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;  Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户建立的接入点WiFi密码  Serial.print(&quot;无线终端模式成功开启，网络连接成功&quot;);    Serial.print(&quot;子网掩码: &quot;);  Serial.println(WiFi.subnetMask());//直接打因为字符串获取子网掩码&#125;void loop() &#123;&#125;





gatewayIP – 获取网关地址说明利用gatewayIP函数可以获取当前ESP8266模块所连接网络的网关IP。
语法wifi.gatewayIP()
简例：
Serial.printf(&quot;网关地址: &quot;);Serial.printf(WiFi.gatewayIP());//把网关地址打印为字符串



参数无
返回值返回值直接返回网关IP，数据类型为IPAdress型。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块的联网状态代码。在以下示例程序中，我们使用了WiFi.gatewayIP()语句来获取网关IP。
/**********************************************************************  程序名称/Program name     : WiFi.gatewayIP();演示  程序目的/Purpose          :  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下获取网关IP地址***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxx&quot;          //这里改成你的设备当前环境下要连接的接入点密码 int i = 0;//用来判定连接是否超时的累加量 void setup(void)&#123;  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600  Serial.println(&quot;开始连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;  Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户建立的接入点WiFi密码  Serial.print(&quot;无线终端模式成功开启，网络连接成功&quot;);    Serial.printf(&quot;网关地址: %s\n&quot;, WiFi.gatewayIP().toString().c_str());//打印网关地址。此处使用.toString()和.c_str()确保能够正常打印&#125; void loop() &#123;&#125;



dnsIP – 获取DNS地址说明利用dnsIP函数可以获取当前ESP8266模块的dns IP地址。
语法WiFi.dnsIP()
WiFi.dnsIP(dns_no)
简例：
Serial.print(&quot;DNS #1IP为: &quot;);//打印出获取的DNS地址Serial.print(WiFi.dnsIP());Serial.print(&quot; &quot;);Serial.print(&quot;DNS #2 IP为: &quot;);Serial.print(WiFi.dnsIP(1));



参数参数dns_no为可选参数。通过输入参数dns_no，我们可以指定所需的域名服务器的IP。此参数允许的值是0或1。如果未提供任何参数或参数为0，函数会返回DNS＃1的IP。如果参数为1，则返回DNS#2的IP。参数数据类型uint8_t型。
返回值DNS服务的IP地址，返回DNS＃1或DNS＃2的IP，数据类型为IPAdress。
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块的DNS IP地址。
/**********************************************************************  程序名称/Program name     : WiFi.dnsIP();演示  程序目的/Purpose          :  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下获取dns地址***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxxx&quot;          //这里改成你的设备当前环境下要连接的接入点密码 int i = 0;//用来判定连接是否超时的累加量 void setup(void)&#123;  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600  Serial.println(&quot;开始连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;  Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户建立的接入点WiFi密码  Serial.print(&quot;无线终端模式成功开启，网络连接成功&quot;);    //打印出当前网络下的DNSIP  Serial.print(&quot;DNS #1IP为: &quot;);  Serial.print(WiFi.dnsIP());  Serial.print(&quot; &quot;);  Serial.print(&quot;DNS #2 IP为: &quot;);  Serial.print(WiFi.dnsIP(1));&#125; void loop() &#123;&#125;



macAddress – 获取mac地址说明利用gatewayIP函数可以获取ESP8266模块的mac地址
语法WiFi.macAddress(macAddr)
WiFi.macAddress()
简例：
a. 如果输入参数macAddr，那么ESP8266开发板的mac地址将会存储在macAddr中。macAddr必须是一个uint8_t类型的数组，这个数组含有6个元素。
if (WiFi.status() == WL_CONNECTED)&#123;  uint8_t macAddr[6];  WiFi.macAddress(macAddr);  Serial.printf(&quot;用转存到数组的方式获取MAC地址: %02x:%02x:%02x:%02x:%02x:%02x\n&quot;, macAddr[0], macAddr[1], macAddr[2], macAddr[3], macAddr[4], macAddr[5]);  //MAC地址会储存在这个数组里面&#125;

b.如下示例所示，直接调用WiFi.macAddress()不输入参数，ESP8266的mac地址将以字符串类型返回。
if (WiFi.status() == WL_CONNECTED)&#123;  Serial.printf(&quot;字符串获取MAC地址: %s\n&quot;, WiFi.macAddress().c_str()); //不输入参数直接调用可以直接打印出字符串&#125;



参数macAddr：此参数为可选参数。该参数为uint8_t类型的数组，这个数组含有6个元素。ESP8266的mac地址将会储存在这个数组中。
返回值若输入参数则会返回储存了MAC地址的数组（uint8_t型）。若没有输入参数则会返回MAC地址字符串（string型）
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块的mac地址。在以下示例程序中，我们使用了两种macAddress函数调用方式来获取设备的IP地址。第一种是有参数的第二种是无参数的。这两种方式所获得的mac地址格式不同。有参数调用时，mac地址保存在数组macAddr中。无参数调用时，mac地址将以字符串形式返回。
/**********************************************************************  程序名称/Program name     : WiFi.macAddress()演示  程序目的/Purpose          :  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下打印当前无线终端MAC地址***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#define AP_ssid   &quot;TaichiMaker&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxxxxxx&quot; //这里改成你的设备当前环境下要连接的接入点密码int i = 0;//用来判定连接是否超时的累加量void setup(void)&#123;  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600  Serial.println(&quot;开始连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;  Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户建立的接入点WiFi密码  Serial.print(&quot;无线终端模式成功开启，网络连接成功&quot;);    if (WiFi.status() == WL_CONNECTED)  &#123;    uint8_t macAddr[6]; // 建立保存mac地址的数组。用于以下语句    WiFi.macAddress(macAddr);       Serial.printf(&quot;通过转存数组获取MAC地址: %02x:%02x:%02x:%02x:%02x:%02x\n&quot;, macAddr[0], macAddr[1], macAddr[2], macAddr[3], macAddr[4], macAddr[5]);     // 无参数调用macAddress时，ESP8266的mac地址将以字符串形式返回    Serial.printf(&quot;字符串获取MAC地址: %s\n&quot;, WiFi.macAddress().c_str());  &#125;&#125; void loop() &#123;&#125;



hostname – 获取&#x2F;设置主机名说明利用hostname函数可以获取WiFi路由器分配给ESP8266模块的主机名，同时也可以输入参数手动给ESP8266模块设置hostname（主机名）。
语法WiFi.hostname()WiFi.hostname(hostname)
简例：
Serial.printf(&quot;当前的hostname: %s\n&quot;, WiFi.hostname().c_str());//读取当前的hostname并输出Serial.printf(&quot;即将修改hostname为Station_Taichi&quot;);WiFi.hostname(&quot;Station_Taichi&quot;);//设置新的hostnameSerial.printf(&quot;当前hostname: %s\n&quot;, WiFi.hostname().c_str());

参数hostname，数据类型可为String型。我们手动设置的主机名的最大长度为32个字符。可以使用大写字母（A-Z），小写字母（a-z），数字（0-9），符号（.）和符号（-）。大小写字母之间没有区别，不允许将空格或者空格字符作为hostname。这里只列举了一部分规则，详细说明请参阅此链接：https://github.com/esp8266/Arduino/blob/master/libraries/ESP8266WiFi/src/ESP8266WiFiSTA.cpp。一旦hostname超过32个字符的限制, 则无法完成主机名设置。
返回值输入参数的情况下，如果设置新的hostname成功，会返回true。如果超过了32个字符的限制，或者设置失败，则函数将返回false而不会分配新的主机名。返回值数据类型为布尔型。
没有输入参数的情况下，会返回当前的hostname，数据类型为string型。
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块的主机名称。我们是通过以下示例程序中的WiFi.hostname()来获取该主机名的。在程序的后续部分中，我们使用了WiFi.hostname(“Station_Taichi”)来将ESP8266模块的主机名改为Station_Taichi。
/**********************************************************************  程序名称/Program name     : WiFi.hostname();演示  程序目的/Purpose          :  此程序使用ESP8266WiFiSTA库来演示在无线终端模式下获取hostname并修改***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxxx&quot;         //这里改成你的设备当前环境下要连接的接入点密码 int i = 0;//用来判定连接是否超时的累加量 void setup(void)&#123;  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600  Serial.println(&quot;开始连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;  Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户建立的接入点WiFi密码  Serial.print(&quot;无线终端模式成功开启，网络连接成功&quot;);  delay(1000);  Serial.printf(&quot;当前的hostname: %s\n&quot;, WiFi.hostname().c_str());//读取当前的hostname并输出  Serial.printf(&quot;即将修改hostname为Station_Taichi&quot;);  delay(1000);  WiFi.hostname(&quot;Station_Taichi&quot;);//设置新的hostname  Serial.printf(&quot;当前hostname: %s\n&quot;, WiFi.hostname().c_str());&#125; void loop() &#123;  delay(1000);&#125;



isConnected – 获取WiFi连接状态说明利用isConnected函数可以获取当前ESP8266模块是否成功连接WiFi。
语法WiFi.isConnected()
参数无
返回值返回值返回是否连接上接入点。若连接上则返回true，没有连接上返回false。数据类型为布尔型。
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将通过串口监视器看到ESP8266模块已经成功连接到WiFi。在以下程序中 ，我们是通过调用WiFi.isConnected()来获取当前ESP8266开发板的联网状态的。
/**********************************************************************  程序名称/Program name     : WiFi.isConnected();演示  程序目的/Purpose          :  此程序使用ESP8266WiFiSTA库来演示在Station模式下判断当前是否连接上接入点***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxx&quot;          //这里改成你的设备当前环境下要连接的接入点密码int i = 0;//用来判定连接是否超时的累加量void setup(void)&#123;  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600  Serial.println(&quot; &quot;);  Serial.println(&quot;判断是否连接上接入点&quot;);  if (WiFi.isConnected() == true) &#123;    Serial.println(&quot;已连接上接入点&quot;);  &#125;  else&#123;    Serial.println(&quot;未连接上接入点&quot;);  &#125;    Serial.println(&quot;开始连接&quot;);  //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;    Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);         // 告知用户建立的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户建立的接入点WiFi密码  Serial.print(&quot;无线终端模式成功开启，网络连接成功&quot;);&#125;void loop() &#123;  if (WiFi.isConnected() == true) &#123;    Serial.println(&quot;已连接上接入点&quot;);  &#125;  else    Serial.println(&quot;未连接上接入点&quot;);  delay(1000);&#125;



getAutoConnect – 获取自动连接WiFi设置说明利用getAutoConnect函数可以获取当前ESP8266模块是否设置为自动连接上次使用的WiFi接入点。我们可以通过setAutoConnect函数来将ESP8266模块设置为自动连接WiFi。
语法WiFi.getAutoConnect()

参数无
返回值如果ESP8266模块配置为在开机时自动连接到上次使用的WiFi接入点，它将返回true。如果禁用了自动连接功能，则会返回false。数据类型为布尔型。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************  程序名称/Program name     : WiFi.getAutoConnect();演示  程序目的/Purpose          :   此程序使用ESP8266WiFiSTA库来演示在无线终端模式下判断当前是否有自动连接***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxx&quot;          //这里改成你的设备当前环境下要连接的接入点密码 int i = 0;//用来判定连接是否超时的累加量 bool autoConnect = true;//设置自动连接所需变量 void setup(void)&#123;  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600  Serial.println(&quot;开始连接&quot;);  Serial.println(&quot;检查自动连接设置状态&quot;);    if (WiFi.getAutoConnect() == true) &#123;    Serial.println(&quot;已设置自连接&quot;);  &#125;  else    Serial.println(&quot;未设置连接&quot;);    WiFi.setAutoConnect(autoConnect);//启用自动连接模式  delay(500);//启用自动连接后再检查一次，确定设置变化    Serial.println(&quot;再次检查自动连接设置状态&quot;);  if (WiFi.getAutoConnect() == true) &#123;    Serial.println(&quot;已设置自连接&quot;);  &#125;  else    Serial.println(&quot;未设置连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;  Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户建立的接入点WiFi密码  Serial.print(&quot;无线终端模式成功开启，网络连接成功&quot;);&#125; void loop() &#123;&#125;





RSSI – 获取WiFi信号强度说明获取当前ESP8266模块连接到接入点的WiFi信号强度,单位为dBm。
语法WiFi.RSSI()
参数无
返回值返回代表ESP8266模块连接的接入点信号强度。返回值数据类型为int32_t，通过串口输出时需要注意这一点。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************  程序名称/Program name     : WiFi.RSSI();演示  程序目的/Purpose          :   此程序使用ESP8266WiFiSTA库来演示在无线终端模式下打印当前wifi信号强度***********************************************************************/#include &lt;ESP8266WiFi.h&gt; #define AP_ssid   &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下要连接的接入点名字#define password  &quot;xxxxxxx&quot;          //这里改成你的设备当前环境下要连接的接入点密码 int i = 0;//用来判定连接是否超时的累加量 void setup(void)&#123;  Serial.begin(9600);  // 启动串口通讯，波特率设置为9600  Serial.println(&quot;开始连接&quot;);    //调用 WiFi.begin()函数，开始连接接入点  WiFi.begin(AP_ssid, password);  Serial.print(&quot;正在连接到&quot;);  Serial.print(AP_ssid);    //这里的循环用来判断是否连接成功的。连接过程中每隔500毫秒会检查一次是否连接成功，，并打一个点表示正在连接中  //连接成功后会给出提示，但是若60秒后还是没有连接上，则会提示超时  while (WiFi.status() != WL_CONNECTED) &#123;    i++;    delay(500);    Serial.print(&quot;.&quot;);    if (i &gt; 120) &#123; //60秒后如果还是连接不上，就判定为连接超时      Serial.print(&quot;连接超时！请检查网络环境&quot;);      break;    &#125;  &#125;  Serial.println(&quot;网络连接成功&quot;);    //这一部分用来输出连接网络的基本信息  Serial.println(&quot;500&quot;);              // 延时500毫秒  Serial.print(&quot;当前工作模式:&quot;);     // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;连接到的接入点名字:&quot;);  Serial.println(AP_ssid);            // 告知用户建立的接入点WiFi名  Serial.print(&quot;连接到的接入点密码:&quot;);  Serial.println(password);        // 告知用户建立的接入点WiFi密码  Serial.print(&quot;无线终端模式成功开启，网络连接成功&quot;);&#125; void loop() &#123;  Serial.printf(&quot;RSSI: %d dBm\n&quot;, WiFi.RSSI());  delay(1000);&#125;









ESP8266 – ESP8266WiFiGeneric库ESP8266WiFiGeneric库主要包含ESP8266的通用功能，如工作模式设置、WiFi时间类型设置等。
以下为ESP8266WiFiGeneric库的整体结构图。在此图下方是库函数目录。
WiFi事件类型接入点模式事件类型onSoftAPModeStationConnected – 有无线终端连接到接入点说明ESP8266在接入点模式下有无线终端连接到ESP8266所建立的WiFi网络时，ESP8266会自动调用事件处理回调函数。该事件处理回调函数由onSoftAPModeStationConnected的参数所定义。
语法WiFi.onSoftAPModeStationConnected(onStationConnected);

参数onStationConnected：回调函数名称
返回值WiFiEventHandler对象
示例代码关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
onSoftAPModeStationConnected函数使用时有两个重点步骤:

通过语句WiFiEventHandler stationConnectedHandler;建立WiFiEventHandler 实例对象，对象名称为stationConnectedHandler。

通过语句stationConnectedHandler = WiFi.onSoftAPModeStationConnected(onStationConnected);对回调函数进行相应的设置。此处onSoftAPModeStationConnected函数的参数“onStationConnected”就是设置了回调函数的名称。


/**********************************************************************程序名称/Program name     : ESP8266WiFiGeneric_AP_1程序目的/Purpose          : 用于演示ESP8266WiFiGeneric库中onSoftAPModeStationConnected函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; #define ssid   &quot;TaichiMaker_WIFI&quot;  // 这里定义将要建立的WiFi名称。此处以&quot;TaichiMaker_WIFI&quot;为示例                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中#define password  &quot;12345678&quot;        // 这里定义将要建立的WiFi密码。此处以12345678为示例                                    // 您可以将自己想要使用的WiFi密码放入引号内                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息 WiFiEventHandler stationConnectedHandler;  //实例化WIFI事件对象 void setup() &#123;   Serial.begin(115200);         //打开串口  WiFi.softAP(ssid, password);  // 此语句是重点。WiFi.softAP用于启动NodeMCU的AP接入点模式。                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。                                // 这两个参数具体内容在setup函数之前的位置进行定义。    Serial.println(&quot;&quot;);   Serial.print(&quot;Access Point: &quot;);    // 通过串口监视器输出信息  Serial.println(ssid);              // 告知用户NodeMCU所建立的WiFi名  Serial.print(&quot;Password: &quot;);          Serial.println(password);          // 告知用户NodeMCU所建立的WiFi密码  Serial.print(&quot;IP address: &quot;);      // 以及NodeMCU的IP地址  Serial.println(WiFi.softAPIP());   // 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址   // onSoftAPModeStationConnected函数的参数onStationConnected为事件处理回调函数。  // 也就是说，每当有新的无线终端连接到ESP8266设备建立的WiFi后，设备都会自动调用onStationConnected函数  stationConnectedHandler = WiFi.onSoftAPModeStationConnected(onStationConnected); &#125; void loop()&#123;&#125; void onStationConnected(const WiFiEventSoftAPModeStationConnected&amp; evt) &#123;//接入点模式下有无线终端设备连接进来时的回调函数  Serial.print(&quot;无线终端设备的mac地址: &quot;);  Serial.println(macToString(evt.mac));//调用macToString函数将mac转换成字符串  Serial.print(&quot;无线终端设备的序号: &quot;);  Serial.println(evt.aid);  &#125; String macToString(const unsigned char* mac) &#123;  //字符串转换函数  char buf[20];  snprintf(buf, sizeof(buf), &quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;,mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);  return String(buf);&#125;



onSoftAPModeStationDisconnected – 有无线终端断开与接入点的连接说明设备在接入点模式下有无线终端从设备所建立的WiFi网络断开时，设备会自动调用事件处理回调函数。该事件处理回调函数由onSoftAPModeStationDisconnected的参数所定义。
语法WiFi.onSoftAPModeStationDisconnected(onStationDisconnected)

参数onStationDisconnected：回调函数
返回值WiFiEventHandler对象
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
onSoftAPModeStationDisconnected函数使用时有两个重点步骤:

通过语句WiFiEventHandler stationDisconnectedHandler;建立WiFiEventHandler 实例对象，对象名称为stationDisconnectedHandler。
通过语句stationDisconnectedHandler = WiFi.onSoftAPModeStationDisconnected(onStationDisconnected);对回调函数进行相应的设置。此处onSoftAPModeStationDisconnected函数的参数“onStationDisconnected”就是设置了回调函数的名称。

/**********************************************************************程序名称/Program name     : ESP8266WiFiGeneric_AP_2程序目的/Purpose          : 用于演示ESP8266WiFiGeneric库中onSoftAPModeStationDisconnected函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; #define ssid   &quot;TaichiMaker_WIFI&quot;   // 这里定义将要建立的WiFi名称。此处以&quot;TaichiMaker_WIFI&quot;为示例                                    // 您可以将自己想要建立的WiFi名称填写入此处的双引号中#define password  &quot;12345678&quot;        // 这里定义将要建立的WiFi密码。此处以12345678为示例                                    // 您可以将自己想要使用的WiFi密码放入引号内                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息 WiFiEventHandler stationDisconnectedHandler;  //实例化WIFI事件对象 void setup() &#123;   Serial.begin(115200);  WiFi.softAP(ssid, password);  // 此语句是重点。WiFi.softAP用于启动NodeMCU的AP接入点模式。                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。                                // 这两个参数具体内容在setup函数之前的位置进行定义。    Serial.println(&quot;&quot;);   Serial.print(&quot;Access Point: &quot;);    // 通过串口监视器输出信息  Serial.println(ssid);              // 告知用户NodeMCU所建立的WiFi名  Serial.print(&quot;Password: &quot;);          Serial.println(password);          // 告知用户NodeMCU所建立的WiFi密码  Serial.print(&quot;IP address: &quot;);      // 以及NodeMCU的IP地址  Serial.println(WiFi.softAPIP());   // 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址   // onSoftAPModeStationDisconnected函数的参数onStationDisconnected为事件处理回调函数。  // 也就是说，每当有无线终端从ESP8266设备建立的WiFi连接断开后，设备都会自动调用onStationDisconnected函数  stationDisconnectedHandler = WiFi.onSoftAPModeStationDisconnected(onStationDisconnected);&#125; void loop()&#123;&#125; void onStationDisconnected(const WiFiEventSoftAPModeStationDisconnected&amp; evt) &#123;  //接入点模式下有无线终端设备断开连接时的回调函数  Serial.print(&quot;断开连接的无线终端是: &quot;);  Serial.println(macToString(evt.mac));//调用macToString函数将mac转换成字符串&#125; String macToString(const unsigned char* mac) &#123;//字符串转换函数  char buf[20];  snprintf(buf, sizeof(buf), &quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;,mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);  return String(buf);&#125;



onSoftAPModeProbeRequestReceived – 接入点模式下收到探针请求说明设备在接入点模式下收到无线终端的探针请求时，设备会自动调用事件处理回调函数。该事件处理回调函数由onSoftAPModeProbeRequestReceived 的参数所定义。
语法WiFi.onSoftAPModeProbeRequestReceived(onProbeRequestReceived)

参数onProbeRequestReceived：回调函数
返回值WiFiEventHandler对象
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
onSoftAPModeProbeRequestReceived函数使用时有两个重点步骤:

通过语句WiFiEventHandler probeRequestReceivedHandler建立WiFiEventHandler 实例对象，对象名称为probeRequestReceivedHandler。

通过语句probeRequestReceivedHandler = WiFi.onSoftAPModeProbeRequestReceived(onProbeRequestReceived);对回调函数进行相应的设置。此处onSoftAPModeProbeRequestReceived函数的参数“onProbeRequestReceived”就是设置了回调函数的名称。


/**********************************************************************程序名称/Program name     : ESP8266WiFiGeneric_AP_3程序目的/Purpose          : 用于演示ESP8266WiFiGeneric库中onSoftAPModeProbeRequestReceived 函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; #define ssid   &quot;TaichiMaker_WIFI&quot;  // 这里定义将要建立的WiFi名称。此处以&quot;TaichiMaker_WIFI&quot;为示例                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中#define password  &quot;12345678&quot;        // 这里定义将要建立的WiFi密码。此处以12345678为示例                                    // 您可以将自己想要使用的WiFi密码放入引号内                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息 WiFiEventHandler probeRequestReceivedHandler;//实例化WIFI事件对象 void onProbeRequestReceived(const WiFiEventSoftAPModeProbeRequestReceived&amp; evt)&#123;//设备在接入点模式下收到无线终端的探针请求时的回调函数  Serial.print(&quot;请求终端的mac地址: &quot;);  Serial.print(macToString(evt.mac));//调用macToString函数将mac转换成字符串  Serial.print(&quot;     请求终端的信号强度: &quot;);  Serial.println(evt.rssi);//调用macToString函数将mac转换成字符串&#125; void setup() &#123;  Serial.begin(115200);  WiFi.softAP(ssid, password);  // 此语句是重点。WiFi.softAP用于启动NodeMCU的AP接入点模式。                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。                                // 这两个参数具体内容在setup函数之前的位置进行定义。    Serial.println(&quot;&quot;);   Serial.print(&quot;Access Point: &quot;);    // 通过串口监视器输出信息  Serial.println(ssid);              // 告知用户NodeMCU所建立的WiFi名  Serial.print(&quot;Password: &quot;);          Serial.println(password);          // 告知用户NodeMCU所建立的WiFi密码  Serial.print(&quot;IP address: &quot;);      // 以及NodeMCU的IP地址  Serial.println(WiFi.softAPIP());   // 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址   // onSoftAPModeProbeRequestReceived函数的参数onProbeRequestReceived为事件处理回调函数。  // 也就是说，每当设备在接入点模式下收到无线终端的探针请求时，设备都会自动调用onStationConnected函数  probeRequestReceivedHandler = WiFi.onSoftAPModeProbeRequestReceived(onProbeRequestReceived);&#125; void loop() &#123;&#125;    String macToString(const unsigned char* mac) &#123;//字符串转换函数  char buf[20];  snprintf(buf, sizeof(buf), &quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;,mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);  return String(buf);&#125;



无线终端模式事件类型onStationModeConnected – 无线终端模式连上WiFi说明无线终端模式下连接上WIFI时，设备会自动调用事件处理回调函数。该事件处理回调函数由onStationModeConnected的参数所定义。
语法WiFi.onStationModeConnected(ConnectedHandler)

参数ConnectedHandler：回调函数
返回值WiFiEventHandler对象
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
通过以下程序，当设备连接到WiFi网络后，将会通过串口监视器输出信息告知用户无线终端设备已经成功连接到网络。即ConnectedHandler函数所实现的程序内容。
onStationModeConnected函数使用时有两个重点步骤:

通过语句WiFiEventHandler STAConnected;建立WiFiEventHandler 实例对象，对象名称为STAConnected。

通过语句STAConnected = WiFi.onStationModeConnected(ConnectedHandler);对回调函数进行相应的设置。此处onStationModeConnected函数的参数“ConnectedHandler”就是设置了回调函数的名称。


/**********************************************************************程序名称/Program name     : ESP8266WiFiGeneric_STA_1程序目的/Purpose          : 用于演示ESP8266WiFiGeneric库中onStationModeConnected函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; #define ssid   &quot;TaichiMaker_WIFI&quot;  // 这里定义将要连接的WiFi名称。此处以&quot;TaichiMaker_WIFI&quot;为示例                                   // 您可以将自己想要连接的WiFi名称填写入此处的双引号中#define password  &quot;12345678&quot;        // 这里定义将要连接的WiFi密码。此处以12345678为示例                                    // 您可以将自己想要使用的WiFi密码放入引号内                                    // 如果连接的WiFi不要密码，则在双引号内不要填入任何信息 WiFiEventHandler STAConnected;      //实例化WIFI事件对象 void setup()&#123;  Serial.begin(115200);    //打开串口      // onStationModeConnected函数的参数ConnectedHandler为事件处理回调函数。  // 也就是说，当无线终端连接到WiFi后，设备都会自动调用ConnectedHandler函数  STAConnected = WiFi.onStationModeConnected(ConnectedHandler);     WiFi.begin(ssid, password);   // 此语句是重点。WiFi.begin用于启动NodeMCU的无线终端模式。                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。                                // 这两个参数具体内容在setup函数之前的位置进行定义。   Serial.println(&quot;&quot;);              // 通过串口监视器输出信息  Serial.print(&quot;Access Point:&quot;);      Serial.println(ssid);            // 告知用户连接的WiFi名  Serial.print(&quot;Password:&quot;);          Serial.println(password);        // 告知用户连接的WiFi密码&#125; void loop()&#123;&#125; void ConnectedHandler(const WiFiEventStationModeConnected &amp;event)//无线终端模式下连接上WIFI时的回调函数&#123;  Serial.println(&quot;无线终端连接到网络&quot;);&#125;





onStationModeDisconnected – 无线终端模式断开WiFi说明无线终端模式下连接上的WIFI断开时，设备会自动调用事件处理回调函数。该事件处理回调函数由onStationModeDisconnected的参数所定义。
语法WiFi.onStationModeDisconnected(DisconnectedHandler)

参数DisconnectedHandler：回调函数
返回值WiFiEventHandler对象
示例程序通过本程序，当设备与WiFi网络断开连接后，将会通过串口监视器输出信息，告知用户无线终端设备已经断开到网络连接。即DisconnectedHandler函数所实现的程序内容。
onStationModeDisconnected函数使用时有两个重点步骤:

通过语句WiFiEventHandler STADisconnected;建立WiFiEventHandler 实例对象，对象名称为STADisconnected。

通过语句STADisconnected = WiFi.onStationModeDisconnected(DisconnectedHandler);对回调函数进行相应的设置。此处onStationModeDisconnected函数的参数“DisconnectedHandler”就是设置了回调函数的名称。


/**********************************************************************程序名称/Program name     : ESP8266WiFiGeneric_STA_2程序目的/Purpose          : 用于演示ESP8266WiFiGeneric库中onStationModeDisconnected函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; #define ssid   &quot;TaichiMaker_WIFI&quot;  // 这里定义将要连接的WiFi名称。此处以&quot;TaichiMaker_WIFI&quot;为示例                                   // 您可以将自己想要连接的WiFi名称填写入此处的双引号中#define password  &quot;12345678&quot;        // 这里定义将要连接的WiFi密码。此处以12345678为示例                                    // 您可以将自己想要使用的WiFi密码放入引号内                                    // 如果连接的WiFi不要密码，则在双引号内不要填入任何信息 WiFiEventHandler STADisconnected;  //实例化WIFI事件对象 void setup()&#123;  Serial.begin(115200);//打开串口      // onStationModeDisconnected函数的参数DisconnectedHandler为事件处理回调函数。  // 也就是说，当无线终端从连接到的WiFi断开后，设备都会自动调用DisconnectedHandler函数  STADisconnected = WiFi.onStationModeDisconnected(DisconnectedHandler);     WiFi.begin(ssid, password);   // 此语句是重点。WiFi.begin用于启动NodeMCU的无线终端模式。                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。                                // 这两个参数具体内容在setup函数之前的位置进行定义。      Serial.println(&quot;&quot;);              // 通过串口监视器输出信息  Serial.print(&quot;Access Point:&quot;);      Serial.println(ssid);            // 告知用户连接的WiFi名  Serial.print(&quot;Password:&quot;);          Serial.println(password);        // 告知用户连接的WiFi密码&#125; void loop()&#123;  delay(5000); //等待5秒  WiFi.disconnect(); //断开当前网络连接，以触发onStationModeDisconnected事件&#125; void DisconnectedHandler(const WiFiEventStationModeDisconnected &amp;event)//无线终端从连接到的WiFi断开后，设备都会自动调用&#123;  Serial.println(&quot;无线终端从网络断开&quot;);&#125;



onStationModeAuthModeChanged – 无线终端模式下校验模式改变说明无线终端模式下连接上WIFI并且校验模式改变时，设备会自动调用事件处理回调函数。该事件处理回调函数由onStationModeAuthModeChanged的参数所定义。
语法WiFi.onStationModeAuthModeChanged(ChangedHandler)

参数ChangedHandler：回调函数
返回值WiFiEventHandler对象
onStationModeGotIP – 无线终端模式下获取到IP地址说明无线终端模式下连接上WIFI并且获得IP地址后，设备会自动调用事件处理回调函数。该事件处理回调函数由onStationModeGotIP的参数所定义。
语法WiFi.onStationModeGotIP(GotIPHandler)

参数GotIPHandler：回调函数
返回值WiFiEventHandler对象
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
通过本程序，当设备连接到WiFi并且获取到IP地址后，将会通过串口监视器输出设备的IP地址信息。串口输出设备IP地址信息是通过GotIPHandler函数所实现的。
onStationModeGotIP函数使用时有两个重点步骤:

通过语句WiFiEventHandler STAGotIP;建立WiFiEventHandler 实例对象，对象名称为STAGotIP。

通过语句STAGotIP = WiFi.onStationModeGotIP(GotIPHandler);对回调函数进行相应的设置。此处onStationModeGotIP函数的参数“GotIPHandler”就是设置了回调函数的名称。


/**********************************************************************程序名称/Program name     : ESP8266WiFiGeneric_STA_4程序目的/Purpose          : 用于演示ESP8266WiFiGeneric库中onStationModeGotIP函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; #define ssid   &quot;TaichiMaker_WIFI&quot;  // 这里定义将要连接的WiFi名称。此处以&quot;TaichiMaker_WIFI&quot;为示例                                   // 您可以将自己想要连接的WiFi名称填写入此处的双引号中#define password  &quot;12345678&quot;        // 这里定义将要连接的WiFi密码。此处以12345678为示例                                    // 您可以将自己想要使用的WiFi密码放入引号内                                    // 如果连接的WiFi不要密码，则在双引号内不要填入任何信息 WiFiEventHandler STAGotIP;   //实例化WIFI事件对象 void setup()&#123;  Serial.begin(115200);   //打开串口      // onStationModeGotIP函数的参数GotIPHandler为事件处理回调函数。  // 也就是说，当无线终端连接到WiFi后，设备都会自动调用GotIPHandler函数  STAGotIP = WiFi.onStationModeGotIP(GotIPHandler);   WiFi.begin(ssid, password);   // 此语句是重点。WiFi.begin用于启动NodeMCU的无线终端模式。                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。                                // 这两个参数具体内容在setup函数之前的位置进行定义。      Serial.println(&quot;&quot;);              // 通过串口监视器输出信息  Serial.print(&quot;Access Point:&quot;);      Serial.println(ssid);            // 告知用户连接的WiFi名  Serial.print(&quot;Password:&quot;);          Serial.println(password);        // 告知用户连接的WiFi密码&#125; void loop()&#123;&#125; void GotIPHandler(const WiFiEventStationModeGotIP &amp;event)//当无线终端连接到WiFi后，设备都会自动调用&#123;  Serial.println(&quot;模块获得IP：&quot;);  Serial.print(WiFi.localIP());//输出NodeMCU的IP地址。这一功能是通过调用                               //WiFi.localIP()函数来实现的。该函数的返回值即NodeMCU的IP地址。&#125;



onStationModeDHCPTimeout – 无线终端模式下动态分配IP超时说明无线终端模式下连接上WIFI并且DHCP分配IP超时时，设备会自动调用事件处理回调函数。该事件处理回调函数由onStationModeDHCPTimeout的参数所定义。
语法WiFi.onStationModeDHCPTimeout(DHCPTimeout)

参数DHCPTimeout：回调函数
返回值无
设置类型persistent – 是否保存WiFi连接信息在闪存中说明此函数用于控制是否将WiFi配置信息保存到开发板的闪存中。默认情况下为true，也就是将WiFi配置信息保存到开发板的闪存中。当我们使用这个函数并设置参数为false时，开发板将不会把WiFi配置写入开发板的闪存中。
语法WiFi.persistent(val)

参数val：此参数值为true时，WiFi配置信息将保存到开发板的闪存中。参数值为false时，不WiFi配置信息不保存到开发板的闪存中。此参数类型为bool型。
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiGeneric_demo_1程序目的/Purpose          : 用于演示ESP8266WiFiGeneric库中persistent函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; #define ssid   &quot;TaichiMaker_WIFI&quot;  // 这里定义将要建立的WiFi名称。此处以&quot;TaichiMaker_WIFI&quot;为示例                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中#define password  &quot;12345678&quot;        // 这里定义将要建立的WiFi密码。此处以12345678为示例                                    // 您可以将自己想要使用的WiFi密码放入引号内                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息 void setup() &#123;   Serial.begin(115200);      WiFi.persistent(false);       // 不保存wifi配置到开发板闪存中    WiFi.begin(ssid, password);   // WiFi.begin用于启动NodeMCU的无线终端模式。                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。                                // 这两个参数具体内容在setup函数之前的位置进行定义。   Serial.println(&quot;&quot;);              // 通过串口监视器输出信息  Serial.print(&quot;Current Mode:&quot;);   // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;Access Point:&quot;);      Serial.println(ssid);            // 告知用户连接的WiFi名  Serial.print(&quot;Password:&quot;);          Serial.println(password);        // 告知用户连接的WiFi密码&#125; void loop()&#123;&#125;





mode – 设置WiFi工作模式说明此函数用于设置ESP8266开发板设备的WiFi网络工作模式。ESP8266开发板一共有三种工作模式。分别是：接入点模式（AP）、无线终端模式（Station）以及混合模式。
语法WiFi.mode(val);
参数
val：此参数允许使用以下值。

WIFI_OFF，（关闭WiFi）
WIFI_STA，（无线终端模式）
WIFI_AP, （接入点模式）
WIFI_AP_STA，（接入点-无线终端双模式）

举例来说，如果我们使用WiFi.mode(WIFI_STA)，则意味着我们让ESP8266以无线终端模式进行工作。
返回值此函数的返回值为布尔型。当ESP8266成功设置为指定模式后，将会返回true，否则返回false。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。我们使用了WiFi.mode(WIFI_STA);将ESP8266设置为无线终端模式。
/**********************************************************************程序名称/Program name     : ESP8266WiFiGeneric_demo_2程序目的/Purpose          : 用于演示ESP8266WiFiGeneric库中mode函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; #define ssid   &quot;TaichiMaker_WIFI&quot;  // 这里定义将要建立的WiFi名称。此处以&quot;TaichiMaker_WIFI&quot;为示例                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中#define password  &quot;12345678&quot;        // 这里定义将要建立的WiFi密码。此处以12345678为示例                                    // 您可以将自己想要使用的WiFi密码放入引号内                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息 void setup() &#123;   Serial.begin(115200);         //打开串口    WiFi.mode(WIFI_STA);          //设置设备的工作模式为无线终端模式      WiFi.begin(ssid, password);   // 此语句是重点。WiFi.begin用于启动NodeMCU的无线终端模式。                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。                                // 这两个参数具体内容在setup函数之前的位置进行定义。      while (WiFi.status() != WL_CONNECTED) &#123;//等待WiFi连接    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.print(&quot;当前模式为： &quot;);     // 通过串口监视器输出信息  Serial.println(WiFi.getMode());  // 告知用户设备当前工作模式   delay(5000);//延时便于查看效果  WiFi.mode(WIFI_OFF);             //设置设备的工作模式为关闭模式  Serial.print(&quot;当前模式为： &quot;);         Serial.println(WiFi.getMode());  // 告知用户设备当前工作模式&#125; void loop()&#123;&#125;



enableSTA – 设置为终端模式说明本函数用于设置ESP8266开发板的工作模式为无线终端模式。ESP8266开发板一共有三种工作模式。分别是：接入点模式（AP）、无线终端模式（Station）以及混合模式。
语法WiFi.enableSTA(val);
参数val：此参数用于控制ESP8266开发板启动或停止无线终端模式。参数值为true时，ESP8266开发板启动无线终端模式。参数值为false时，ESP8266开发板停止无线终端模式。此参数类型为bool型。
返回值返回值类型为布尔型。设备成功启动无线终端模式，返回值为true。否则返回值为false。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiGeneric_demo_4程序目的/Purpose          : 用于演示ESP8266WiFiGeneric库中enableSTA函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; #define ssid   &quot;TaichiMaker_WIFI&quot;  // 这里定义将要建立的WiFi名称。此处以&quot;TaichiMaker_WIFI&quot;为示例                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中#define password  &quot;12345678&quot;        // 这里定义将要建立的WiFi密码。此处以12345678为示例                                    // 您可以将自己想要使用的WiFi密码放入引号内                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息 void setup() &#123;   Serial.begin(115200);          //打开串口    WiFi.enableSTA(true);          //设置设备的工作模式为无线终端模式。    WiFi.begin(ssid, password);   // 此语句是重点。WiFi.begin用于启动NodeMCU的无线终端模式。                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。                                // 这两个参数具体内容在setup函数之前的位置进行定义。   Serial.println(&quot;&quot;);              // 通过串口监视器输出信息  Serial.print(&quot;Current Mode:&quot;);   // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;Access Point:&quot;);      Serial.println(ssid);            // 告知用户连接的WiFi名  Serial.print(&quot;Password:&quot;);          Serial.println(password);        // 告知用户连接的WiFi密码&#125; void loop()&#123;&#125;



enableAP – 设置为接入点模式说明本函数用于设置ESP8266开发板的工作模式为WiFi接入点模式。ESP8266开发板一共有三种工作模式。分别是：WiFi接入点模式（AP）、无线终端模式（Station）以及混合模式。
语法WiFi.enableAP(val)

参数val：此参数用于控制ESP8266开发板启动或停止无线接入点模式。参数值为true时，ESP8266开发板启动无线接入点模式。参数值为false时，ESP8266开发板停止无线接入点模式。此参数类型为bool型。
返回值返回值类型为布尔型。设备成功启动无线接入点模式，返回值为true。否则返回值为false。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiGeneric_demo_5程序目的/Purpose          : 用于演示ESP8266WiFiGeneric库中enableAP函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; #define ssid   &quot;TaichiMaker_WIFI&quot;  // 这里定义将要建立的WiFi名称。此处以&quot;TaichiMaker_WIFI&quot;为示例                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中#define password  &quot;12345678&quot;        // 这里定义将要建立的WiFi密码。此处以12345678为示例                                    // 您可以将自己想要使用的WiFi密码放入引号内                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息 void setup() &#123;   Serial.begin(115200);          //打开串口      WiFi.enableAP(true);           // 设置设备的工作模式为接入点模式。       WiFi.softAP(ssid, password);   // WiFi.softAP用于启动NodeMCU的AP模式。                                 // 括号中有两个参数，ssid是WiFi名。password是WiFi密码                                 // 这两个参数具体内容在setup函数之前的位置进行定义。    Serial.println(&quot;&quot;);              // 通过串口监视器输出信息  Serial.print(&quot;Current Mode:&quot;);   // 告知用户设备当前工作模式  Serial.println(WiFi.getMode());  Serial.print(&quot;Access Point:&quot;);      Serial.println(ssid);            // 告知用户建立的WiFi名  Serial.print(&quot;Password:&quot;);          Serial.println(password);        // 告知用户建立的WiFi密码&#125; void loop()&#123;&#125;



setSleepMode – 设置为休眠模式说明设置ESP8266的睡眠模式,从而使ESP8266降低功耗,达到节能的目的。以下是ESP8266的三种睡眠模式介绍：
WIFI_NONE_SLEEP– 此模式将打开ESP8266所有的功能并将长期处于此状态, 缺点也是不言而喻的增大功耗;– 但是对于ESP8266初学者,这里还是建议使用此模式进行调试和开发,因为在不进行产品开发的前提下,使用此模式不会给您带来丢包和重连等问题;
WIFI_MODEM_SLEEP– 这是ESP8266的默认睡眠方式,但此模式仅在无线终端模式下正常运行,而且只有当您连接到WiFi的时候才生效;– 当您设置了WIFI_MODEM_SLEEP模式并且成功连接WiFi之后,它会在ESP8266与路由器传递消息的间隔内关闭WIFI连接电路来达到节能的目的。ESP8266可以在下一次通讯到来之前自动唤醒WIFI电路来确保其工作;– 如果您使用干电池或者是您的设备不能持久供电的情况下,可以考虑采用此模式
WIFI_LIGHT_SLEEP– 此模式在WIFI_MODEM_SLEEP基础上还会暂停ESP8266的CPU、系统时钟等，从而达到比前者更加节能的目的。
语法WiFi.setSleepMode(type, listenInterval)``WiFi.setSleepMode(type)

参数type： 此参数用于设置睡眠模式。ESP8266开发板一共有以下几种睡眠模式。WIFI_NONE_SLEEP （非睡眠模式）WIFI_LIGHT_SLEEP （轻度睡眠）WIFI_MODEM_SLEEP （深度睡眠）
listenInterval：睡眠间隔时间, 单位毫秒。（参数类型： int）
返回值返回值类型为布尔型。设备成功进入指定睡眠模式，返回值为true。否则返回值为false。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会定时向www.example.com网站发送HTTP请求，并且将该网站服务器的响应信息显示在串口监视器中。
请留意在以下示例程序中，我们使用了WiFi.setSleepMode(WIFI_LIGHT_SLEEP); 对ESP8266的睡眠模式进行了设置。
/**********************************************************************程序名称/Program name     : setSleepMode程序目的/Purpose          : 此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求，并且将网站服务器响应的信息输出在屏幕中。程序中使用了setSleepMode函数来演示如何使用该函数将ESP8266设置为低功耗工作状态。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WiFiMulti.h&gt; ESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象 const char* host = &quot;www.example.com&quot;; // 网络服务器地址const int httpPort = 80;              // http端口80 // WiFi连接信息const char*  WiFi_SSID = &quot;TaichiMaker&quot;;const char*  WiFi_Password = &quot;12345678&quot;; void setup()&#123;  Serial.begin(9600);            Serial.println(&quot;&quot;);   // 设置睡眠模式（可选参数：WIFI_NONE_SLEEP、WIFI_LIGHT_SLEEP、WIFI_MODEM_SLEEP ）  WiFi.setSleepMode(WIFI_LIGHT_SLEEP);        wifiMulti.addAP(WiFi_SSID, WiFi_Password);   Serial.println(&quot;Connecting ...&quot;);    // 尝试进行wifi连接。  int i = 0;    while (wifiMulti.run() != WL_CONNECTED) &#123;     delay(1000);    Serial.print(i++); Serial.print(&#x27; &#x27;);  &#125;    // WiFi连接成功后将通过串口监视器输出连接成功信息   Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(WiFi.SSID());              // WiFi名称  Serial.print(&quot;IP address:\t&quot;);  Serial.println(WiFi.localIP());           // IP&#125; void loop()&#123;  // 发送HTTP请求  httpRequest();        delay(10000);&#125; // 向服务器发送HTTP请求void httpRequest()&#123;  // 建立WiFi客户端对象，对象名称client  WiFiClient client;       // 建立字符串，用于HTTP请求  String httpRequest =  String(&quot;GET /&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;    // 通过串口输出连接服务器名称以便查阅连接服务器的网址                        Serial.print(&quot;Connecting to &quot;);   Serial.print(host);    // 连接网络服务器，以下段落中的示例程序为本程序重点1  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/  if (client.connect(host, httpPort))&#123;     Serial.println(&quot; Success!&quot;);        // 连接成功后串口输出“Success”信息        client.print(httpRequest);          // 向服务器发送合同谈判请求    Serial.println(&quot;Sending request: &quot;);// 通过串口输出HTTP请求信息内容以便查阅    Serial.println(httpRequest);             // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/    Serial.println(&quot;Web Server Response:&quot;);            while (client.connected() || client.available())&#123;       if (client.available())&#123;        String line = client.readStringUntil(&#x27;\n&#x27;);        Serial.println(line);      &#125;    &#125;        client.stop();                      // 断开与服务器的连接    Serial.print(&quot;Disconnected from &quot;); // 并且通过串口输出断开连接信息    Serial.print(host);      &#125; else&#123;    // 如果连接不成功则通过串口输出“连接失败”信息    Serial.println(&quot; connection failed!&quot;);    client.stop();  &#125;  &#125;



信息类型getMode – 获取WiFi工作模式说明获取ESP8266开发板的工作模式。
ESP8266开发板一共有三种工作模式。分别是：接入点模式（AP）、无线终端模式（Station）以及混合模式。
如需了解更多有关ESP8266开发板的工作模式详细内容，请参考本站的ESP8266-物联网开发基础视频教程。其中“NodeMCU开发板的接入点模式”部分有更多关于接入点模式的讲解。
语法WiFi.getMode()

参数无
返回值以下是此函数的返回值以及对应的工作模式说明：0：WiFi关闭模式1：无线终端模式2：接入点模式3：接入点-无线终端混合模式
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分，该语句通过WiFi.getMode()获取ESP8266开发板的工作模式并且通过串口监视器输出。
/**********************************************************************程序名称/Program name     : ESP8266WiFiGeneric_demo_3程序目的/Purpose          : 用于演示ESP8266WiFiGeneric库中getMode函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; #define ssid   &quot;TaichiMaker_WIFI&quot;  // 这里定义将要建立的WiFi名称。此处以&quot;TaichiMaker_WIFI&quot;为示例                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中#define password  &quot;12345678&quot;        // 这里定义将要建立的WiFi密码。此处以12345678为示例                                    // 您可以将自己想要使用的WiFi密码放入引号内                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息 void setup() &#123;   Serial.begin(115200);         //打开串口    WiFi.mode(WIFI_STA);          //设置设备的工作模式为无线终端模式      WiFi.begin(ssid, password);   // 此语句是重点。WiFi.begin用于启动NodeMCU的无线终端模式。                                // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。                                // 这两个参数具体内容在setup函数之前的位置进行定义。      while (WiFi.status() != WL_CONNECTED) &#123;//等待WiFi连接    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.print(&quot;当前模式为： &quot;);     // 通过串口监视器输出信息  Serial.println(WiFi.getMode());  // 告知用户设备当前工作模式   delay(5000);//延时便于查看效果  WiFi.mode(WIFI_OFF);             //设置设备的工作模式为关闭模式  Serial.print(&quot;当前模式为： &quot;);         Serial.println(WiFi.getMode());  // 告知用户设备当前工作模式&#125; void loop()&#123;&#125;



ESP8266WiFiMulti库当我们需要使用ESP8266开发板存储多个WiFi网络连接信息时，可以使用ESP8266WiFiMulti库来实现。
以下为ESP8266WiFiMulti库的整体结构图。

设置类型addAp – 添加 WiFi连接信息说明当我们需要使用ESP8266开发板存储多个WiFi网络连接信息时，可以使用addAp来添加多个联网信息。ESP8266开发板在使用run函数尝试联网时，会检查当前WiFi网络环境中有无addAp函数所添加的网络信息。如果找到一个或多个已经添加的网络，则自动连接信号最强的WiFi网络。
语法wiFiMulti.addAP(ssid, password)
参数
ssid：需要添加的WiFi网络名称
password：需要添加的WiFi网络密码

返回值无
示例程序为模块添加WiFi信息，只要可以连接的wifi出现在环境中，搜索addAP函数所存储的WiFi。将会连接信号最强的那一个WiFi信号。
/**********************************************************************程序名称/Program name     : ESP8266WiFiMulti_demo_1程序目的/Purpose          : 用于演示ESP8266WiFiMulti库中addAP函数***********************************************************************/ #include &quot;ESP8266WiFiMulti.h&quot; ESP8266WiFiMulti WiFiMulti;//实例化ESP8266WiFiMulti对象 void setup() &#123;  Serial.begin(115200);  delay(100);   //通过addAp函数存储  WiFi名称       WiFi密码  WiFiMulti.addAP(&quot;taichi-maker&quot;, &quot;12345678&quot;);    WiFiMulti.addAP(&quot;taichi-maker2&quot;, &quot;87654321&quot;);   WiFiMulti.addAP(&quot;taichi-maker3&quot;, &quot;13572468&quot;);   // 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。  // 这3个WiFi网络名称分别是taichi-maker, taichi-maker2, taichi-maker3。  // 这3个网络的密码分别是123456789，87654321，13572468。  // 此处WiFi信息只是示例，请在使用时将需要连接的WiFi信息填入相应位置。  // 另外这里只存储了3个WiFi信息，您可以存储更多的WiFi信息在此处。      while(WiFiMulti.run() != WL_CONNECTED) &#123;    Serial.print(&quot;.&quot;);    delay(500);  &#125;   // 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前  // 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU  // 将会连接信号最强的那一个WiFi信号。  // 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是  // 此处while循环判断是否跳出循环的条件。   Serial.println(&#x27;\n&#x27;);                     // WiFi连接成功后  Serial.print(&quot;Connected to &quot;);            // NodeMCU将通过串口监视器输出。  Serial.println(WiFi.SSID());              // 连接的WiFI名称  Serial.print(&quot;IP address:\t&quot;);            // 以及  Serial.println(WiFi.localIP());           // NodeMCU的IP地址&#125; void loop() &#123;&#125;



run – 连接WiFi说明当我们使用addAP函数为ESP8266开发板存储多个WiFi网络连接信息以后，可以使用run函数尝试联网。在联网过程中，ESP8266开发板会检查当前WiFi网络环境中有无addAp函数所添加的网络信息。如果找到一个或多个已经添加的网络，则自动连接信号最强的WiFi网络。
语法wiFiMulti.run()
参数无
返回值返回值为整数型,以下是返回值说明。

0 : WL_IDLE_STATUS – 当WiFi正在状态之间切换时
1 : WL_NO_SSID_AVAIL – 无法访问配置的SSID
3 : WL_CONNECTED – 成功建立连接
4 : WL_CONNECT_FAILED – 密码不正确
6 : WL_DISCONNECTED – 模块未配置为无线终端模式

示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiMulti_demo_2程序目的/Purpose          : 用于演示ESP8266WiFiMulti库中run函数***********************************************************************/#include &quot;ESP8266WiFiMulti.h&quot; ESP8266WiFiMulti WiFiMulti;//实例化ESP8266WiFiMulti对象 void setup() &#123;  Serial.begin(115200);  delay(100);   //通过addAp函数存储  WiFi名称       WiFi密码  WiFiMulti.addAP(&quot;taichi-maker&quot;, &quot;12345678&quot;);    WiFiMulti.addAP(&quot;taichi-maker2&quot;, &quot;87654321&quot;);   WiFiMulti.addAP(&quot;taichi-maker3&quot;, &quot;13572468&quot;);   // 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。  // 这3个WiFi网络名称分别是taichi-maker, taichi-maker2, taichi-maker3。  // 这3个网络的密码分别是123456789，87654321，13572468。  // 此处WiFi信息只是示例，请在使用时将需要连接的WiFi信息填入相应位置。  // 另外这里只存储了3个WiFi信息，您可以存储更多的WiFi信息在此处。   Serial.println();  Serial.print(&quot;Wait for WiFi... &quot;);   // 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前  // 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU  // 将会连接信号最强的那一个WiFi信号。  // 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是  // 此处while循环判断是否跳出循环的条件。  while(WiFiMulti.run() != WL_CONNECTED) &#123;    Serial.print(&quot;.&quot;);    delay(500);  &#125;   Serial.println(&#x27;\n&#x27;);                     // WiFi连接成功后  Serial.print(&quot;Connected to &quot;);            // NodeMCU将通过串口监视器输出。  Serial.println(WiFi.SSID());              // 连接的WiFI名称  Serial.print(&quot;IP address:\t&quot;);            // 以及  Serial.println(WiFi.localIP());           // NodeMCU的IP地址&#125; void loop() &#123;&#125;





cleanAPlist – 清除WiFi连接信息说明此函数可以删除ESP8266开发板WiFi连接列表中的WiFi连接信息。
语法WiFiMulti.cleanAPlist()

参数无
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiMulti_demo_3程序目的/Purpose          : 用于演示ESP8266WiFiMulti库中cleanAPlist函数***********************************************************************/#include &quot;ESP8266WiFiMulti.h&quot; ESP8266WiFiMulti WiFiMulti;//实例化ESP8266WiFiMulti对象 void setup() &#123;  Serial.begin(115200);  delay(100);   //通过addAp函数存储  WiFi名称       WiFi密码  WiFiMulti.addAP(&quot;taichi-maker&quot;, &quot;12345678&quot;);    WiFiMulti.addAP(&quot;taichi-maker2&quot;, &quot;87654321&quot;);   WiFiMulti.addAP(&quot;taichi-maker3&quot;, &quot;13572468&quot;);   // 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。  // 这3个WiFi网络名称分别是taichi-maker, taichi-maker2, taichi-maker3。  // 这3个网络的密码分别是123456789，87654321，13572468。  // 此处WiFi信息只是示例，请在使用时将需要连接的WiFi信息填入相应位置。  // 另外这里只存储了3个WiFi信息，您可以存储更多的WiFi信息在此处。      WiFiMulti.cleanAPlist();  Serial.println(&quot;AP列表已删除&quot;);    //查看该接入点是否在接入点列表中  if(WiFiMulti.existsAP(&quot;taichi-maker&quot;, &quot;12345678&quot;))&#123;    Serial.println(&quot;taichi-maker在列表中&quot;);  &#125;else&#123;Serial.println(&quot;taichi-maker不在列表中&quot;);&#125;    if(WiFiMulti.existsAP(&quot;taichi-maker&quot;, &quot;12345678&quot;))&#123;    Serial.println(&quot;taichi-maker2在列表中&quot;);  &#125;else&#123;Serial.println(&quot;taichi-maker2不在列表中&quot;);&#125;    if(WiFiMulti.existsAP(&quot;taichi-maker&quot;, &quot;12345678&quot;))&#123;    Serial.println(&quot;taichi-maker3在列表中&quot;);  &#125;else&#123;Serial.println(&quot;taichi-maker3不在列表中&quot;);&#125;&#125; void loop() &#123;&#125;

相关内容– addAp – 添加 WiFi连接信息– run – 连接WiFi
信息类型existsAP – 检查WiFi连接信息内容说明此函数用于确认某一个接入点信息是否已经通过addAP函数添加到ESP8266开发板的联网信息列表中了。
语法wiFiMulti.existsAP(ssid, password)
参数
ssid：需要确认的WiFi网络名称
password：需要确认的WiFi网络密码

返回值返回值类型为布尔型。如果某一个接入点信息已经通过addAP函数添加到ESP8266开发板的联网信息列表中了，则返回值为true，否则返回值为false。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiMulti_demo_1程序目的/Purpose          : 用于演示ESP8266WiFiMulti库中existsAP函数***********************************************************************/ #include &quot;ESP8266WiFiMulti.h&quot;ESP8266WiFiMulti WiFiMulti; void setup() &#123;  Serial.begin(115200);  delay(100);  Serial.println(&quot; &quot;);   //通过addAp函数存储  WiFi名称       WiFi密码  WiFiMulti.addAP(&quot;taichi-maker&quot;, &quot;12345678&quot;);    WiFiMulti.addAP(&quot;taichi-maker2&quot;, &quot;87654321&quot;);   WiFiMulti.addAP(&quot;taichi-maker3&quot;, &quot;13572468&quot;);  Serial.println(&quot;AP列表添加完毕&quot;);  // 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。  // 这3个WiFi网络名称分别是taichi-maker, taichi-maker2, taichi-maker3。  // 这3个网络的密码分别是123456789，87654321，13572468。  // 此处WiFi信息只是示例，请在使用时将需要连接的WiFi信息填入相应位置。  // 另外这里只存储了3个WiFi信息，您可以存储更多的WiFi信息在此处。      // 确认接入点列表中有无&quot;taichi-maker&quot;  if(WiFiMulti.existsAP(&quot;taichi-maker&quot;, &quot;12345678&quot;))&#123;      Serial.println(&quot;taichi-maker在列表中&quot;);  &#125;else&#123;Serial.println(&quot;taichi-maker不在列表中&quot;);&#125;    // 确认接入点列表中有无&quot;测试WiFi&quot;  if(WiFiMulti.existsAP(&quot;测试WiFi&quot;, &quot;12345678&quot;))&#123;      Serial.println(&quot;测试WiFi 在列表中&quot;);  &#125;else&#123;Serial.println(&quot;测试WiFi 不在列表中&quot;);&#125;&#125; void loop() &#123;&#125;

相关内容– addAp – 添加 WiFi连接信息– run – 连接WiFi– cleanAPlist – 清除WiFi连接信息
ESP8266 – ESP8266WiFiScan库ESP8266WiFiScan库用于ESP8266开发板扫描WiFi网络以及分析扫描到的WiFi网络信息。
以下为ESP8266WiFiScan库的整体结构图。

设置类型scanNetworks – 同步扫描WiFi网络说明该函数可以扫描到ESP8266开发板所在环境中的可用WIFI网络，并且将WiFi网络信息保存到内存中。通过调用SSID、RSSI等函数，我们还可以得到这些扫描到的WIFI的更多信息。
此函数在扫描WiFi网络时采用同步扫描模式。与其相对应的还有scanNetworksAsync异步扫描WiFi。
所谓同步扫描就是每一次调用本函数时，ESP8266开发板会一次性得到完整的WiFi列表，并且将WiFi列表保存在内存中。
语法WiFi.scanNetworks()

参数无
返回值返回值为扫描到可用的网络数量，数据类型为int8_t型。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiScan_demo_1程序目的/Purpose          : 用于演示ESP8266WiFiScan库中scanNetworks函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; void setup() &#123;  Serial.begin(115200);  //设置串口波特率，以便打印信息  delay(1000);           //延时  WiFi.mode(WIFI_STA);   //设置为无线终端模式  WiFi.disconnect();     //断开，不连接到任何一个接入点  delay(100);  Serial.println(&quot;STA建立完成&quot;);&#125; void loop() &#123;  Serial.println(&quot;同步扫描开始&quot;);  int n = WiFi.scanNetworks();    //开始同步扫描，将返回值  Serial.println(&quot;同步扫描结束&quot;);   //存放在变量n中  if (n == 0)&#123;    Serial.println(&quot;找不到网络&quot;);  &#125;else&#123;    Serial.println(&quot;发现网络&quot;);    for (int i = 0; i &lt; n; ++i)&#123;  //开始逐个打印扫描到的      Serial.print(i + 1);        //接入点信息      Serial.print(&quot;: &quot;);      //打印wifi账号      Serial.print(WiFi.SSID(i));      //打印该接入点信道      Serial.print(String(&quot;,   WIFI信道:&quot;)+WiFi.channel(i));      Serial.print(&quot;,   是否隐藏：&quot;);      //打印该接入点是否隐藏      Serial.print(WiFi.isHidden(i)?&quot;隐藏&quot;:&quot;显示&quot;);      Serial.print(&quot;,   信号强度：&quot;);      //打印wifi信号强度      Serial.print(WiFi.RSSI(i));      Serial.print(&quot;dBm&quot;);      Serial.print(&quot;,   是否加密：&quot;);      //打印wifi加密方式      Serial.println((WiFi.encryptionType(i) == ENC_TYPE_NONE)?&quot;开放&quot;:&quot;加密&quot;);      delay(10);    &#125;  &#125;  Serial.println(&quot;&quot;);  delay(5000);// 延时5s之后再次扫描&#125;



相关内容– scanDelete– scanNetworksAsync
scanNetworksAsync – 异步扫描WiFi网络说明该函数可以扫描到ESP8266开发板所在环境中的可用WIFI网络，并且将WiFi网络信息保存到内存中。通过调用SSID、RSSI等函数，我们还可以得到这些扫描到的WIFI信息。
此函数在扫描WiFi网络时采用异步扫描模式。与其相对应的还有scanNetworks同步扫描WiFi。
所谓异步扫描是与同步扫描相对应的。在异步扫描模式下，ESP8266开发板每一次扫描到一个WiFi网络，即将该网络信息保存到开发板内存中。
调用本函数时，需要提供一个回调函数作为参数。当所有WiFi网络都扫描完成以后，ESP8266开发板将会调用此回调函数。另外，在调用回调函数时，ESP8266开发板所扫描到的WiFi网络数量还会作为参数传递给该回调函数。
语法wifi.scanNetworksAsync(onComplete)wifi.scanNetworksAsync(scanResult, showHidden)

参数onComplete：WiFi扫描结束后的回调函数（WiFi扫描 结束后将会调用此回调函数）
showHidden：此参数用于控制扫描过程中是否扫描隐藏WiFi网络。设置为true时，ESP8266开发板会扫描隐藏WiFi。默认为false。（参数类型：bool）
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiScan_demo_3程序目的/Purpose          : 用于演示ESP8266WiFiScan库中scanNetworksAsync 函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; void setup() &#123;  Serial.begin(115200);  //设置串口波特率，以便打印信息  delay(1000);           //延时1s  WiFi.mode(WIFI_STA);   //设置为无线终端模式  WiFi.disconnect();     //断开，不连接到任何一个接入点  delay(100);  Serial.println(&quot;STA建立完成&quot;);  Serial.println(&quot;异步扫描开始 ... &quot;);  WiFi.scanNetworksAsync(onComplete);&#125; void loop() &#123;&#125; //回调函数void onComplete(int n)&#123;  Serial.printf(&quot;扫描完成，共发现%d个网络\n&quot;, n);  for (int i = 0; i &lt; n; i++)  &#123;    Serial.print(i + 1);        //接入点信息    Serial.print(&quot;: &quot;);    //打印wifi账号    Serial.print(WiFi.SSID(i));    //打印该接入点信道    Serial.print(String(&quot;,   WIFI信道:&quot;)+WiFi.channel(i));    Serial.print(&quot;,   是否隐藏：&quot;);    //打印该接入点是否隐藏    Serial.print(WiFi.isHidden(i)?&quot;隐藏&quot;:&quot;显示&quot;);    Serial.print(&quot;,   信号强度：&quot;);    //打印wifi信号强度    Serial.print(WiFi.RSSI(i));    Serial.print(&quot;dBm&quot;);    Serial.print(&quot;,   是否加密：&quot;);    //打印wifi加密方式    Serial.println((WiFi.encryptionType(i) == ENC_TYPE_NONE)?&quot;开放&quot;:&quot;加密&quot;);  &#125;&#125;

相关内容– scanDelete– scanNetworks
scanDelete – 删除扫描结果说明此函数将清除掉ESP8266开发板通过扫描后储存在内存中的WiFi扫描结果。
语法wiFi.scanDelete()
参数无
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiScan_demo_4程序目的/Purpose          : 用于演示ESP8266WiFiScan库中scanDelete函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; long lastScanMillis; void setup() &#123;  Serial.begin(115200);  //设置串口波特率，以便打印信息  delay(5000);           //延时5s  WiFi.mode(WIFI_STA);   //设置为无线终端模式  WiFi.disconnect();     //断开，不连接到任何一个接入点  delay(100);  Serial.println(&quot;STA建立完成&quot;);&#125; void loop() &#123;  long currentMillis = millis();//调用millis函数，获取当前时钟  if (currentMillis - lastScanMillis &gt; 5000)&#123;//5s扫描一次    WiFi.scanNetworks(true);//开始异步扫描    Serial.println(&quot;异步扫描开始 ... &quot;);    lastScanMillis = currentMillis;//保存当前时钟，进入下一次扫描  &#125;   //检查异步扫描的结果，将返回值存放在变量n中  int n = WiFi.scanComplete();  if(n &gt;= 0)&#123;    Serial.printf(&quot;发现%d个网络\n&quot;, n);    for (int i = 0; i &lt; n; i++)&#123;      Serial.print(i + 1);        //接入点信息      Serial.print(&quot;: &quot;);      //打印wifi账号      Serial.println(WiFi.SSID(i));    &#125;    Serial.println(&quot;&quot;);    WiFi.scanDelete();//删除内存中保存结果  &#125;&#125;



信息类型getNetworkInfo – 获取扫描到的WiFi网络信息(网络名称，信号强度等）说明当ESP8266开发板使用scanNetworks或者scanNetworksAsync对所处环境的WiFi网络进行扫描后，ESP8266开发板会将扫描到的网络信息保存在内存中。
通过此函数，我们可以获取扫描到的WiFi的网络名称、加密类型、信号强度、MAC地址、网络信道、网络是否隐藏等信息。
注：如需单独获取以上列出的WiFi信息中的某一项，可参考ESP8266WiFiScan库中信息类型的其它函数内容。
语法wiFi.getNetworkInfo(i, ssid, encryptionType, RSSI, BSSID, channel, isHidden)

参数getNetworkInfo函数会将WiFi网络信息存入参数中。这些参数的具体功能如下。

i：扫描到的接入点网络列表的序号（uint8_t型）
ssid：扫描到的接入点网络的网络名称（String型）
encryptionType：扫描到的接入点网络的加密类型（uint8_t型）
RSSI：扫描到的接入点网络的网络信号强度（int32_t型）
BSSID：扫描到的接入点网络的MAC地址(大小为6个元素的uint8数组指针)
channel：扫描到的接入点网络的网络通道(int32_t型)
isHidden：扫描到的接入点网络是否是隐藏网络(bool型)

返回值如果成功获取WiFi信息，则返回true，否则返回false。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiScan_demo_5程序目的/Purpose          : 用于演示ESP8266WiFiScan库中encryptionType函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; void setup() &#123;  Serial.begin(115200);  //设置串口波特率，以便打印信息  delay(5000);           //延时5s  WiFi.mode(WIFI_STA);   //设置为无线终端模式  WiFi.disconnect();     //断开，不连接到任何一个接入点  delay(100);  Serial.println(&quot;STA建立完成&quot;);&#125; void loop() &#123;  Serial.println(&quot;同步扫描开始&quot;);  int n = WiFi.scanNetworks();    //开始同步扫描，将返回值  Serial.println(&quot;同步扫描结束&quot;);   //存放在变量n中  if (n == 0)&#123;    Serial.println(&quot;找不到网络&quot;);  &#125;else&#123;    Serial.println(&quot;发现网络&quot;);        // 建立一系列变量，用于存储网络信息    String ssid;            // 网络名称    uint8_t encryptionType; // 网络加密类型    int32_t RSSI;           // 网络信号强度    uint8_t* BSSID;         // 网络接入点设备mac地址    int32_t channel;        // 网络信道    bool isHidden;          // 网络是否隐藏    for (int i = 0; i &lt; n; i++) //逐个打印扫描到的接入点信息    &#123;       //获取扫描到的接入点网络信息(网络名称，信号强度等）       WiFi.getNetworkInfo(i, ssid, encryptionType, RSSI, BSSID, channel, isHidden);       //打印扫描到的接入点网络信息(网络名称，信号强度等）       Serial.printf(&quot;%d: %s, Ch:%d, (%ddBm) %s %s\n&quot;, i + 1, ssid.c_str(), channel, RSSI, encryptionType == ENC_TYPE_NONE ? &quot;开放&quot; : &quot;加密&quot;, isHidden ? &quot;隐藏&quot; : &quot;显示&quot;);    &#125;        Serial.println(&quot;&quot;);    delay(5000);// 延时5s之后再次扫描  &#125;&#125;

相关内容– SSID – 获取扫描到的WiFi网络名称– RSSI – 获取扫描到的WiFi网络信号强度– encryptionType – 获取扫描到的WiFi网络加密类型– BSSID &#x2F; BSSIDstr – 获取扫描到的WiFi网络mac地址– channel – 获取扫描到的WiFi网络信道号– isHidden – 检查扫描到的WiFi网络是否是隐藏网络– scanComplete – 获取异步扫描结果或状态
SSID – 获取扫描到的WiFi网络名称说明当ESP8266开发板使用scanNetworks或者scanNetworksAsync对所处环境的WiFi网络进行扫描后，ESP8266开发板会将扫描到的网络信息保存在内存中。
通过此函数，我们可以获取扫描到的WiFi网络信息中的网络名称(SSID)信息。
语法wiFi.SSID(val)
参数val：扫描到的WiFi网络信息序号（类型：uint8_t ）
返回值扫描到的WiFi网络信息中的网络名称(SSID)信息(类型：String)
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiScan_demo_1程序目的/Purpose          : 用于演示ESP8266WiFiScan库中SSID函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; void setup() &#123;  Serial.begin(115200);  //设置串口波特率，以便打印信息  delay(1000);           //延时1s  WiFi.mode(WIFI_STA);   //设置为无线终端模式  WiFi.disconnect();     //断开，不连接到任何一个接入点  delay(100);  Serial.println(&quot;STA建立完成&quot;);&#125; void loop() &#123;  Serial.println(&quot;同步扫描开始&quot;);  int n = WiFi.scanNetworks();    //开始同步扫描，将返回值  Serial.println(&quot;同步扫描结束&quot;);   //存放在变量n中  if (n == 0)&#123;    Serial.println(&quot;找不到网络&quot;);  &#125;else&#123;    Serial.println(&quot;发现网络&quot;);    for (int i = 0; i &lt; n; ++i)&#123;  //开始逐个打印扫描到的      Serial.print(i + 1);        //接入点信息      Serial.print(&quot;: &quot;);      //打印wifi账号      Serial.println(WiFi.SSID(i));      delay(10);    &#125;  &#125;  Serial.println(&quot;&quot;);  delay(5000);// 延时5s之后再次扫描&#125;



RSSI – 获取扫描到的WiFi网络信号强度说明当ESP8266开发板使用scanNetworks或者scanNetworksAsync对所处环境的WiFi网络进行扫描后，ESP8266开发板会将扫描到的网络信息保存在内存中。
通过此函数，我们可以获取扫描到的WiFi网络信息中的网络信号强度。
语法wiFi.RSSI(val)
参数val：扫描到的WiFi网络信息序号（类型：uint8_t）
返回值扫描到的WiFi网络信息中的网络信号长度(类型：int32_t)
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiScan_demo_2程序目的/Purpose          : 用于演示ESP8266WiFiScan库中RSSI函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; void setup() &#123;  Serial.begin(115200);  //设置串口波特率，以便打印信息  delay(1000);           //延时1s  WiFi.mode(WIFI_STA);   //设置为无线终端模式  WiFi.disconnect();     //断开，不连接到任何一个接入点  delay(100);  Serial.println(&quot;STA建立完成&quot;);&#125; void loop() &#123;  Serial.println(&quot;同步扫描开始&quot;);  int n = WiFi.scanNetworks();    //开始同步扫描，将返回值  Serial.println(&quot;同步扫描结束&quot;);   //存放在变量n中  if (n == 0)&#123;    Serial.println(&quot;找不到网络&quot;);  &#125;else&#123;    Serial.println(&quot;发现网络&quot;);    for (int i = 0; i &lt; n; ++i)&#123;  //开始逐个打印扫描到的      Serial.print(i + 1);        //接入点信息      Serial.print(&quot;: &quot;);      //打印wifi账号      Serial.print(WiFi.SSID(i));      Serial.print(&quot;,   信号强度：&quot;);      //打印wifi信号强度      Serial.print(WiFi.RSSI(i));      Serial.println(&quot;dBm&quot;);      delay(10);    &#125;  &#125;  Serial.println(&quot;&quot;);  delay(5000);// 延时5s之后再次扫描&#125;

相关内容– getNetworkInfo – 获取扫描到的WiFi网络信息(网络名称，信号强度等）– SSID – 获取扫描到的WiFi网络名称– encryptionType – 获取扫描到的WiFi网络加密类型– BSSID &#x2F; BSSIDstr – 获取扫描到的WiFi网络mac地址– channel – 获取扫描到的WiFi网络信道号– isHidden – 检查扫描到的WiFi网络是否是隐藏网络– scanComplete – 获取异步扫描结果或状态
encryptionType – 获取扫描到的WiFi网络加密类型说明当ESP8266开发板使用scanNetworks或者scanNetworksAsync对所处环境的WiFi网络进行扫描后，ESP8266开发板会将扫描到的网络信息保存在内存中。
通过此函数，我们可以获取扫描到的WiFi网络信息中的网络加密类型。
语法wiFi.encryptionType(val)

参数val：扫描到的WiFi网络信息序号（类型：uint8_t）
返回值返回值类型为uint8_t，以下是返回值数值以及相应的说明信息。
5：ENC_TYPE_WEP-WEP加密类型
2：ENC_TYPE_TKIP-WPA&#x2F;PSK加密类型
4：ENC_TYPE_CCMP-WPA 2&#x2F;PSK加密类型
7：ENC_TYPE_NONE-开放网络
8：ENC_TYPE_AUTO-WPA&#x2F;WPA 2&#x2F;PSK加密类型
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiScan_demo_3程序目的/Purpose          : 用于演示ESP8266WiFiScan库中encryptionType函数***********************************************************************/#include &lt;ESP8266WiFi.h&gt; void setup() &#123;  Serial.begin(115200);  //设置串口波特率，以便打印信息  delay(1000);           //延时1s  WiFi.mode(WIFI_STA);   //设置为无线终端模式  WiFi.disconnect();     //断开，不连接到任何一个接入点  delay(100);  Serial.println(&quot;STA建立完成&quot;);&#125; void loop() &#123;  Serial.println(&quot;同步扫描开始&quot;);  int n = WiFi.scanNetworks();    //开始同步扫描，将返回值  Serial.println(&quot;同步扫描结束&quot;);   //存放在变量n中  if (n == 0)&#123;    Serial.println(&quot;找不到网络&quot;);  &#125;else&#123;    Serial.println(&quot;发现网络&quot;);    for (int i = 0; i &lt; n; ++i)&#123;  //开始逐个打印扫描到的      Serial.print(i + 1);        //接入点信息      Serial.print(&quot;: &quot;);      //打印wifi账号      Serial.print(WiFi.SSID(i));      Serial.print(&quot;,   是否加密：&quot;);      //打印wifi加密方式      Serial.println((WiFi.encryptionType(i) == ENC_TYPE_NONE)?&quot;开放&quot;:&quot;加密&quot;);      delay(10);    &#125;  &#125;  Serial.println(&quot;&quot;);  delay(5000);// 延时5s之后再次扫描&#125;

相关内容– getNetworkInfo – 获取扫描到的WiFi网络信息(网络名称，信号强度等）– SSID – 获取扫描到的WiFi网络名称– RSSI – 获取扫描到的WiFi网络信号强度– BSSID &#x2F; BSSIDstr – 获取扫描到的WiFi网络mac地址– channel – 获取扫描到的WiFi网络信道号– isHidden – 检查扫描到的WiFi网络是否是隐藏网络– scanComplete – 获取异步扫描结果或状态
BSSID &#x2F; BSSIDstr – 获取扫描到的WiFi网络mac地址说明当ESP8266开发板使用scanNetworks或者scanNetworksAsync对所处环境的WiFi网络进行扫描后，ESP8266开发板会将扫描到的网络信息保存在内存中。
通过BSSID函数和BSSIDstr函数，我们可以获取扫描到的WiFi网络接入点设备的mac地址。虽然这两个函数功能相同，但是它们的返回值类型是不同的。
BSSIDstr函数以字符串形式将WiFi接入点设备mac地址返回。
BSSID函数的返回值是存储WiFi接入点设备mac地址信息的内存位置，即一个大小为6个元素的uint8数组指针。
语法WiFi.BSSID(val)WiFi.BSSIDstr(val)
参数val：扫描到的WiFi网络信息序号（类型：uint8_t ）
返回值BSSIDstr函数以字符串形式将WiFi接入点设备mac地址返回。
BSSID函数的返回值是存储WiFi接入点设备mac地址信息的内存位置，即一个大小为6个元素的uint8数组指针。
示例程序BSSID函数示例
/**********************************************************************程序名称/Program name     : ESP8266WiFiScan_demo_4程序目的/Purpose          : 用于演示ESP8266WiFiScan库中BSSID函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; void setup() &#123;  Serial.begin(115200);  //设置串口波特率，以便打印信息  delay(5000);           //延时5s  WiFi.mode(WIFI_STA);   //设置为无线终端模式  WiFi.disconnect();     //断开，不连接到任何一个接入点  delay(100);  Serial.println(&quot;STA建立完成&quot;);&#125; void loop() &#123;  Serial.println(&quot;同步扫描开始&quot;);  int n = WiFi.scanNetworks();    //开始同步扫描，将返回值  Serial.println(&quot;同步扫描结束&quot;);   //存放在变量n中  if (n == 0)&#123;    Serial.println(&quot;找不到网络&quot;);  &#125;else&#123;    Serial.println(&quot;发现网络&quot;);    for (int i = 0; i &lt; n; ++i)&#123;  //开始逐个打印扫描到的      Serial.print(i + 1);        //接入点信息      Serial.print(&quot;: &quot;);      //打印wifi账号      Serial.print(WiFi.SSID(i));      Serial.print(&quot;,   mac地址：&quot;);      Serial.printf(&quot;%p&quot;,WiFi.BSSID(i));//BSSID返回网络的MAC地址。      Serial.println(&quot;&quot;);    &#125;  &#125;  Serial.println(&quot;&quot;);  delay(5000);//延时5s之后再次扫描&#125;



BSSIDstr
/**********************************************************************程序名称/Program name     : ESP8266WiFiScan_demo_4程序目的/Purpose          : 用于演示ESP8266WiFiScan库中BSSIDstr函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; void setup() &#123;  Serial.begin(115200);  //设置串口波特率，以便打印信息  delay(5000);           //延时5s  WiFi.mode(WIFI_STA);   //设置为无线终端模式  WiFi.disconnect();     //断开，不连接到任何一个接入点  delay(100);  Serial.println(&quot;STA建立完成&quot;);&#125; void loop() &#123;  Serial.println(&quot;同步扫描开始&quot;);  int n = WiFi.scanNetworks();    //开始同步扫描，将返回值  Serial.println(&quot;同步扫描结束&quot;);   //存放在变量n中  if (n == 0)&#123;    Serial.println(&quot;找不到网络&quot;);  &#125;else&#123;    Serial.println(&quot;发现网络&quot;);    for (int i = 0; i &lt; n; ++i)&#123;  //开始逐个打印扫描到的      Serial.print(i + 1);        //接入点信息      Serial.print(&quot;: &quot;);      //打印wifi账号      Serial.print(WiFi.SSID(i));      Serial.print(&quot;,   mac为：&quot;);      Serial.println(WiFi.BSSIDstr(i));//BSSIDstr返回网络的MAC地址的字符串。    &#125;  &#125;  Serial.println(&quot;&quot;);  delay(5000);//延时5s之后再次扫描&#125;



相关内容– getNetworkInfo – 获取扫描到的WiFi网络信息(网络名称，信号强度等）– SSID – 获取扫描到的WiFi网络名称– RSSI – 获取扫描到的WiFi网络信号强度– encryptionType – 获取扫描到的WiFi网络加密类型– channel – 获取扫描到的WiFi网络信道号– isHidden – 检查扫描到的WiFi网络是否是隐藏网络– scanComplete – 获取异步扫描结果或状态
channel – 获取扫描到的WiFi网络信道号说明当ESP8266开发板使用scanNetworks或者scanNetworksAsync对所处环境的WiFi网络进行扫描后，ESP8266开发板会将扫描到的网络信息保存在内存中。
通过此函数，我们可以获取扫描到的WiFi网络信息中的WiFi网络信道号。
语法wiFi.channel(val)
参数val：扫描到的WiFi网络信息序号（类型：uint8_t ）
返回值扫描到的WiFi网络信息中的网络信道号(类型：uint8_t)
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiScan_demo_3程序目的/Purpose          : 用于演示ESP8266WiFiScan库中encryptionType函数***********************************************************************/#include &lt;ESP8266WiFi.h&gt; void setup() &#123;  Serial.begin(115200);  //设置串口波特率，以便打印信息  delay(5000);           //延时5s  WiFi.mode(WIFI_STA);   //设置为无线终端模式  WiFi.disconnect();     //断开，不连接到任何一个接入点  delay(100);  Serial.println(&quot;STA建立完成&quot;);&#125; void loop() &#123;  Serial.println(&quot;同步扫描开始&quot;);  int n = WiFi.scanNetworks();    //开始同步扫描，将返回值  Serial.println(&quot;同步扫描结束&quot;);   //存放在变量n中  if (n == 0)&#123;    Serial.println(&quot;找不到网络&quot;);  &#125;else&#123;    Serial.println(&quot;发现网络&quot;);    for (int i = 0; i &lt; n; ++i)&#123;  //开始逐个打印扫描到的      Serial.print(i + 1);        //接入点信息      Serial.print(&quot;: &quot;);      //打印wifi账号      Serial.print(WiFi.SSID(i));      Serial.print(String(&quot;,   WIFI信道:&quot;)+WiFi.channel(i));    &#125;  &#125;  Serial.println(&quot;&quot;);  delay(5000);// 延时5s之后再次扫描&#125;



相关内容– getNetworkInfo – 获取扫描到的WiFi网络信息(网络名称，信号强度等）– SSID – 获取扫描到的WiFi网络名称– RSSI – 获取扫描到的WiFi网络信号强度– encryptionType – 获取扫描到的WiFi网络加密类型– BSSID &#x2F; BSSIDstr – 获取扫描到的WiFi网络mac地址– isHidden – 检查扫描到的WiFi网络是否是隐藏网络– scanComplete – 获取异步扫描结果或状态
isHidden – 检查扫描到的WiFi网络是否是隐藏网络说明当ESP8266开发板使用scanNetworks或者scanNetworksAsync对所处环境的WiFi网络进行扫描后，ESP8266开发板会将扫描到的网络信息保存在内存中。
通过此函数，我们可以获取WiFi网络是否是隐藏WiFi这一状态信息。
语法wiFi.isHidden(val)

参数val：扫描到的WiFi网络信息序号（类型：uint8_t ）
返回值扫描到的WiFi网络是否为隐藏的这一状态信息(类型：bool)
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiScan_demo_7程序目的/Purpose          : 用于演示ESP8266WiFiScan库中isHidden函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; void setup() &#123;  Serial.begin(115200);  //设置串口波特率，以便打印信息  delay(5000);           //延时5s  WiFi.mode(WIFI_STA);   //设置为无线终端模式  WiFi.disconnect();     //断开，不连接到任何一个接入点  delay(100);  Serial.println(&quot;STA建立完成&quot;);&#125; void loop() &#123;  Serial.println(&quot;同步扫描开始&quot;);  int n = WiFi.scanNetworks();    //开始同步扫描，将返回值  Serial.println(&quot;同步扫描结束&quot;);   //存放在变量n中  if (n == 0)&#123;    Serial.println(&quot;找不到网络&quot;);  &#125;else&#123;    Serial.println(&quot;发现网络&quot;);    for (int i = 0; i &lt; n; ++i)&#123;  //开始逐个打印扫描到的      Serial.print(i + 1);        //接入点信息      Serial.print(&quot;: &quot;);      //打印wifi账号      Serial.print(WiFi.SSID(i));      Serial.print(&quot;,   是否隐藏：&quot;);      Serial.println(WiFi.isHidden(i)?&quot;隐藏&quot;:&quot;显示&quot;);      delay(10);    &#125;  &#125;  Serial.println(&quot;&quot;);  delay(5000);// 延时5s之后再次扫描&#125;



scanComplete – 获取异步扫描结果或状态说明此函数用于获取扫描中扫描到的WiFi网络数量。
注：如需了解更多异步扫描信息，请参考scanNetworksAsync函数
语法wiFi.scanComplete()

参数无
返回值扫描到的网络数量（int8_t类型）
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiScan_demo_8程序目的/Purpose          : 用于演示ESP8266WiFiScan库中scanComplete函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt; long lastScanMillis; void setup() &#123;  Serial.begin(115200);  //设置串口波特率，以便打印信息  delay(5000);           //延时5s  WiFi.mode(WIFI_STA);   //设置为无线终端模式  WiFi.disconnect();     //断开，不连接到任何一个接入点  delay(100);  Serial.println(&quot;STA建立完成&quot;);&#125; void loop() &#123;  long currentMillis = millis();//调用millis函数，获取当前时钟  if (currentMillis - lastScanMillis &gt; 5000)&#123;//5s扫描一次    WiFi.scanNetworks(true);//开始异步扫描    Serial.println(&quot;异步扫描开始 ... &quot;);    lastScanMillis = currentMillis;//保存当前时钟，进入下一次扫描  &#125;   //检查异步扫描的结果，将返回值存放在变量n中  int n = WiFi.scanComplete();  if(n &gt;= 0)&#123;    Serial.printf(&quot;发现%d个网络\n&quot;, n);    for (int i = 0; i &lt; n; i++)&#123;      Serial.print(i + 1);      Serial.print(&quot;: &quot;);      //打印wifi账号      Serial.println(WiFi.SSID(i));    &#125;    Serial.println(&quot;&quot;);    WiFi.scanDelete();//打印完一次扫描结果之后，删除内存保存结果  &#125;&#125;











ESP8266 – WiFiClient库WiFiClient库用于ESP8266的TCP协议物联网通讯。通过WiFiClient库，可以使用ESP8266利用互联网或局域网向网络服务器发送请求，从而获取网络信息，实现物联网应用。
ESP8266库中还有一个专门用于HTTP通讯的ESP8266HTTPClient库 。HTTP协议是建立在TCP协议基础之上的，我们也可以使用ESP8266HTTPClient库来通过HTTP协议向网络服务器发送请求。WiFiClient库与ESP8266HTTPClient库 在功能上形成了互补。
以下为WiFiClient库的整体结构图。在此图下方有WiFiClient库的函数目录。

请留意，WiFiServer对象在处理或发送网络数据时，可以通过调用Stream类中的函数来实现。因此在以下结构图中的“发送数据类型”以及“响应信息操作类型”中有“Stream类”作为这种类型函数的一部分。
连接服务器类型设置类型connect – 连接服务器说明connect函数用于ESP8266开发板通过TCP协议连接网络服务器。
语法client.connect(ip, port);

参数
ip:所要连接的服务器地址。注：在定义参数ip的时候可使用String、const char。如下所示：const char * ip = &quot;47.92.129.18&quot;;String ip = &quot;www.ranye-iot.com&quot;;
port:所要连接的服务器端口号,允许使用int类型。

返回值连接失败返回0，连接成功返回1。返回值数据类型是bool型。
示例代码关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266随即会尝试连接www.example.com网站服务器。以下程序使用了client.connect(host, port)来实现这一操作。如果服务器连接成功，则client.connect(host, port)语句将会返回true。
/**********************************************************************程序名称/Program name     : TCP_Client_connect程序目的/Purpose          : 用于演示WiFiClient库中connect函数***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WiFiMulti.h&gt; ESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象 const char* host = &quot;www.example.com&quot;; // 网络服务器地址const int httpPort = 80;              // http端口80 // WiFi连接信息const char*  WiFi_SSID = &quot;TaichiMaker&quot;;const char*  WiFi_Password = &quot;12345678&quot;; void setup()&#123;  Serial.begin(9600);            WiFi.mode(WIFI_STA);    // 设置ESP8266为无线终端模式    wifiMulti.addAP(WiFi_SSID, WiFi_Password);   Serial.println(&quot;Connecting ...&quot;);    // 尝试进行wifi连接。  int i = 0;    while (wifiMulti.run() != WL_CONNECTED) &#123;     delay(1000);    Serial.print(i++); Serial.print(&#x27; &#x27;);  &#125;    // WiFi连接成功后将通过串口监视器输出连接成功信息   Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(WiFi.SSID());              // WiFi名称  Serial.print(&quot;IP address:\t&quot;);  Serial.println(WiFi.localIP());           // IP&#125; void loop()&#123;  // 发送HTTP请求  httpRequest();        delay(10000);&#125; // 向服务器发送HTTP请求void httpRequest()&#123;  // 建立WiFi客户端对象，对象名称client  WiFiClient client;       // 建立字符串，用于HTTP请求  String httpRequest =  String(&quot;GET /&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;    // 通过串口输出连接服务器名称以便查阅连接服务器的网址                        Serial.print(&quot;Connecting to &quot;);   Serial.print(host);    // 连接网络服务器，以下段落中的示例程序为本程序重点1  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/  if (client.connect(host, httpPort))&#123;     Serial.println(&quot; Success!&quot;);        // 连接成功后串口输出“Success”信息        client.print(httpRequest);          // 向服务器发送合同谈判请求    Serial.println(&quot;Sending request: &quot;);// 通过串口输出HTTP请求信息内容以便查阅    Serial.println(httpRequest);             // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/    Serial.println(&quot;Web Server Response:&quot;);            while (client.connected() || client.available())&#123;       if (client.available())&#123;        String line = client.readStringUntil(&#x27;\n&#x27;);        Serial.println(line);      &#125;    &#125;        client.stop();                      // 断开与服务器的连接    Serial.print(&quot;Disconnected from &quot;); // 并且通过串口输出断开连接信息    Serial.print(host);      &#125; else&#123;    // 如果连接不成功则通过串口输出“连接失败”信息    Serial.println(&quot; connection failed!&quot;);    client.stop();  &#125;  &#125;



stop – 停止客户端说明stop函数用于停止ESP8266连接TCP服务器。
语法client.stop()

参数无
示例代码关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266随即会尝试连接www.example.com网站服务器。如果服务器连接成功，
/**********************************************************************项目名称/Project          : 零基础入门学用物联网程序名称/Program name     : TCP_Client_stop团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)作者/Author              : Dapenson日期/Date（YYYYMMDD）     : 20200317程序目的/Purpose          : 用于演示WiFiClient库中connect函数-----------------------------------------------------------------------修订历史/Revision History  日期/Date    作者/Author      参考号/Ref    修订说明/Revision Description20200410      CYNO朔           001        将服务器响应信息输出过程使用stream类函数实现-----------------------------------------------------------------------本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WiFiMulti.h&gt; ESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象 const char* host = &quot;www.example.com&quot;; // 网络服务器地址const int httpPort = 80;              // http端口80 // WiFi连接信息const char*  WiFi_SSID = &quot;TaichiMaker&quot;;const char*  WiFi_Password = &quot;12345678&quot;; void setup()&#123;  Serial.begin(9600);            WiFi.mode(WIFI_STA);    // 设置ESP8266为无线终端模式    wifiMulti.addAP(WiFi_SSID, WiFi_Password);   Serial.println(&quot;Connecting ...&quot;);    // 尝试进行wifi连接。  int i = 0;    while (wifiMulti.run() != WL_CONNECTED) &#123;     delay(1000);    Serial.print(i++); Serial.print(&#x27; &#x27;);  &#125;    // WiFi连接成功后将通过串口监视器输出连接成功信息   Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(WiFi.SSID());              // WiFi名称  Serial.print(&quot;IP address:\t&quot;);  Serial.println(WiFi.localIP());           // IP&#125; void loop()&#123;  // 发送HTTP请求  httpRequest();        delay(10000);&#125; // 向服务器发送HTTP请求void httpRequest()&#123;  // 建立WiFi客户端对象，对象名称client  WiFiClient client;       // 建立字符串，用于HTTP请求  String httpRequest =  String(&quot;GET /&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;    // 通过串口输出连接服务器名称以便查阅连接服务器的网址                        Serial.print(&quot;Connecting to &quot;);   Serial.print(host);    // 连接网络服务器，以下段落中的示例程序为本程序重点1  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/  if (client.connect(host, httpPort))&#123;     Serial.println(&quot; Success!&quot;);        // 连接成功后串口输出“Success”信息        client.print(httpRequest);          // 向服务器发送合同谈判请求    Serial.println(&quot;Sending request: &quot;);// 通过串口输出HTTP请求信息内容以便查阅    Serial.println(httpRequest);             // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/    Serial.println(&quot;Web Server Response:&quot;);            while (client.connected() || client.available())&#123;       if (client.available())&#123;        String line = client.readStringUntil(&#x27;\n&#x27;);        Serial.println(line);      &#125;    &#125;        client.stop();                      // 断开与服务器的连接    Serial.print(&quot;Disconnected from &quot;); // 并且通过串口输出断开连接信息    Serial.print(host);      &#125; else&#123;    // 如果连接不成功则通过串口输出“连接失败”信息    Serial.println(&quot; connection failed!&quot;);    client.stop();  &#125;  &#125;

相关内容— connect – 连接服务器— connected – 检查是否成功连接服务器
setNoDelay- 停止小包合并发送说明setNoDelay()用于与TCP服务器通讯时 ，是否禁用 Nagle 算法。Nagle 算法的目的是通过合并一些小的发送消息，然后一次性发送所有的消息来减少通过网络发送的小数据包的tcp&#x2F;ip流量。
语法client.setNoDelay(true);
语法数据类型：bool
server.setNoDelay(true);//true 表示禁用 Nagle 算法，合并一些小的消息server.setNoDelay(false);//false 表示启用 Nagle 算法，消息直接发送



信息类型connected – 检查是否成功连接服务器说明connected 函数用于检查设备是否成功连接服务器。
语法client.connected();
返回值0:连接失败返回01:连接成功返回1返回值数据类型：bool
示例代码关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : TCP_Client_connected程序目的/Purpose          : 用于演示WiFiClient库中connect函数***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WiFiMulti.h&gt; ESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象 const char* host = &quot;www.example.com&quot;; // 网络服务器地址const int httpPort = 80;              // http端口80 // WiFi连接信息const char*  WiFi_SSID = &quot;taichimaker&quot;;const char*  WiFi_Password = &quot;12345678&quot;; void setup()&#123;  Serial.begin(9600);            WiFi.mode(WIFI_STA);    // 设置ESP8266为无线终端模式    wifiMulti.addAP(WiFi_SSID, WiFi_Password);   Serial.println(&quot;Connecting ...&quot;);    // 尝试进行wifi连接。  int i = 0;    while (wifiMulti.run() != WL_CONNECTED) &#123;     delay(1000);    Serial.print(i++); Serial.print(&#x27; &#x27;);  &#125;    // WiFi连接成功后将通过串口监视器输出连接成功信息   Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(WiFi.SSID());              // WiFi名称  Serial.print(&quot;IP address:\t&quot;);  Serial.println(WiFi.localIP());           // IP&#125; void loop()&#123;  // 发送HTTP请求  httpRequest();        delay(10000);&#125; // 向服务器发送HTTP请求void httpRequest()&#123;  // 建立WiFi客户端对象，对象名称client  WiFiClient client;       // 建立字符串，用于HTTP请求  String httpRequest =  String(&quot;GET /&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;    // 通过串口输出连接服务器名称以便查阅连接服务器的网址                        Serial.print(&quot;Connecting to &quot;);   Serial.print(host);    // 连接网络服务器，以下段落中的示例程序为本程序重点1  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/  if (client.connect(host, httpPort))&#123;     Serial.println(&quot; Success!&quot;);        // 连接成功后串口输出“Success”信息        client.print(httpRequest);          // 向服务器发送合同谈判请求    Serial.println(&quot;Sending request: &quot;);// 通过串口输出HTTP请求信息内容以便查阅    Serial.println(httpRequest);             // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/    Serial.println(&quot;Web Server Response:&quot;);            while (client.connected() || client.available())&#123;       if (client.available())&#123;        String line = client.readStringUntil(&#x27;\n&#x27;);        Serial.println(line);      &#125;    &#125;        client.stop();                      // 断开与服务器的连接    Serial.print(&quot;Disconnected from &quot;); // 并且通过串口输出断开连接信息    Serial.print(host);      &#125; else&#123;    // 如果连接不成功则通过串口输出“连接失败”信息    Serial.println(&quot; connection failed!&quot;);    client.stop();  &#125;  &#125;



相关内容— connect – 连接服务器— stop – 停止客户端
status – 获取客户端运行状态说明status函数用于获取设备与服务器的连接状态。
语法client.status();

返回值
CLOSED &#x3D; 0
LISTEN &#x3D; 1
SYN_SENT &#x3D; 2
SYN_RCVD &#x3D; 3
ESTABLISHED &#x3D; 4
FIN_WAIT_1 &#x3D; 5
FIN_WAIT_2 &#x3D; 6
CLOSE_WAIT &#x3D; 7
CLOSING &#x3D; 8
LAST_ACK &#x3D; 9
TIME_WAIT &#x3D; 10

示例代码关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************项目名称/Project          : 零基础入门学用物联网程序名称/Program name     : TCP_Client_status团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)作者/Author              : Dapenson日期/Date（YYYYMMDD）     : 20200317程序目的/Purpose          : 用于演示WiFiClient库中connect函数-----------------------------------------------------------------------修订历史/Revision History  日期/Date    作者/Author      参考号/Ref    修订说明/Revision Description20200410      CYNO朔           001        将服务器响应信息输出过程使用stream类函数实现-----------------------------------------------------------------------本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WiFiMulti.h&gt; ESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象 const char* host = &quot;www.example.com&quot;; // 网络服务器地址const int httpPort = 80;              // http端口80 // WiFi连接信息const char*  WiFi_SSID = &quot;taichimaker&quot;;const char*  WiFi_Password = &quot;12345678&quot;; void setup()&#123;  Serial.begin(9600);            WiFi.mode(WIFI_STA);    // 设置ESP8266为无线终端模式    wifiMulti.addAP(WiFi_SSID, WiFi_Password);   Serial.println(&quot;Connecting ...&quot;);    // 尝试进行wifi连接。  int i = 0;    while (wifiMulti.run() != WL_CONNECTED) &#123;     delay(1000);    Serial.print(i++); Serial.print(&#x27; &#x27;);  &#125;    // WiFi连接成功后将通过串口监视器输出连接成功信息   Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(WiFi.SSID());              // WiFi名称  Serial.print(&quot;IP address:\t&quot;);  Serial.println(WiFi.localIP());           // IP&#125; void loop()&#123;  // 发送HTTP请求  httpRequest();        delay(10000);&#125; // 向服务器发送HTTP请求void httpRequest()&#123;  // 建立WiFi客户端对象，对象名称client  WiFiClient client;       // 建立字符串，用于HTTP请求  String httpRequest =  String(&quot;GET /&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;    // 通过串口输出连接服务器名称以便查阅连接服务器的网址                        Serial.print(&quot;Connecting to &quot;);   Serial.print(host);    // 连接网络服务器，以下段落中的示例程序为本程序重点1  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/  if (client.connect(host, httpPort))&#123;     Serial.println(&quot; Success!&quot;);        // 连接成功后串口输出“Success”信息        client.print(httpRequest);          // 向服务器发送合同谈判请求    Serial.println(&quot;Sending request: &quot;);// 通过串口输出HTTP请求信息内容以便查阅    Serial.println(httpRequest);             // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/    Serial.println(&quot;Web Server Response:&quot;);            while (client.connected() || client.available())&#123;       if (client.available())&#123;        String line = client.readStringUntil(&#x27;\n&#x27;);        Serial.println(line);      &#125;    &#125;        Serial.print(&quot;Current Client Status: &quot;);    Serial.println(client.status());            client.stop();                      // 断开与服务器的连接    Serial.print(&quot;Disconnected from &quot;); // 并且通过串口输出断开连接信息    Serial.print(host);        Serial.println(&quot;&quot;);     Serial.print(&quot;Current Client Status: &quot;);    Serial.println(client.status());      &#125; else&#123;    // 如果连接不成功则通过串口输出“连接失败”信息    Serial.println(&quot; connection failed!&quot;);    client.stop();  &#125;  &#125;

相关内容— connected – 检查是否成功连接服务器— connect – 连接服务器
发送数据类型print – 发送信息（Stream类）说明print函数用于发送数据到已连接的服务器。print函数与println函数功能十分相似。他们二者的区别是，println函数会在发送的数据结尾增加一个换行符（’\n’），而print函数则不会。
请留意，WiFiClient库对象在处理或发送网络数据时，可以通过调用Stream类中的函数来实现。本函数即是Stream类中的一员。
语法client.print(val);

参数val:所要发送的数据，可以是字符串、字符或者数值。
返回值无
示例代码关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : TCP_Client_print程序目的/Purpose          : 此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求。在发送HTTP请求时使用了print函数，从而演示该函数的使用方法。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WiFiMulti.h&gt; ESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象 const char* host = &quot;www.example.com&quot;; // 网络服务器地址const int httpPort = 80;              // http端口80 // WiFi连接信息const char*  WiFi_SSID = &quot;TaichiMaker&quot;;const char*  WiFi_Password = &quot;12345678&quot;; void setup()&#123;  Serial.begin(9600);            Serial.println(&quot;&quot;);    wifiMulti.addAP(WiFi_SSID, WiFi_Password);   Serial.println(&quot;Connecting ...&quot;);    // 尝试进行wifi连接。  int i = 0;    while (wifiMulti.run() != WL_CONNECTED) &#123;     delay(1000);    Serial.print(i++); Serial.print(&#x27; &#x27;);  &#125;    // WiFi连接成功后将通过串口监视器输出连接成功信息   Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(WiFi.SSID());              // WiFi名称  Serial.print(&quot;IP address:\t&quot;);  Serial.println(WiFi.localIP());           // IP&#125; void loop()&#123;  // 发送HTTP请求  httpRequest();        delay(10000);&#125; // 向服务器发送HTTP请求void httpRequest()&#123;  // 建立WiFi客户端对象，对象名称client  WiFiClient client;       // 建立字符串，用于HTTP请求  String httpRequest =  String(&quot;GET /&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;    // 通过串口输出连接服务器名称以便查阅连接服务器的网址                        Serial.print(&quot;Connecting to &quot;);   Serial.print(host);    // 连接网络服务器，以下段落中的示例程序为本程序重点1  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/  if (client.connect(host, httpPort))&#123;     Serial.println(&quot; Success!&quot;);        // 连接成功后串口输出“Success”信息        client.print(httpRequest);          // 向服务器发送合同请求    Serial.println(&quot;Sending request: &quot;);// 通过串口输出HTTP请求信息内容以便查阅    Serial.println(httpRequest);             // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/    Serial.println(&quot;Web Server Response:&quot;);            while (client.connected() || client.available())&#123;       if (client.available())&#123;        String line = client.readStringUntil(&#x27;\n&#x27;);        Serial.println(line);      &#125;    &#125;        client.stop();                      // 断开与服务器的连接    Serial.print(&quot;Disconnected from &quot;); // 并且通过串口输出断开连接信息    Serial.print(host);      &#125; else&#123;    // 如果连接不成功则通过串口输出“连接失败”信息    Serial.println(&quot; connection failed!&quot;);    client.stop();  &#125;  &#125;



相关内容— println – 发送信息（Stream类）— write – 发送信息（Stream类）— Stream类
println – 发送信息（Stream类）说明println函数用于发送数据到已连接的服务器。println函数与print函数功能十分相似。他们二者的区别是，println函数会在发送的数据结尾增加一个换行符（’\n’），而print函数则不会。
请留意，WiFiClient对象在处理或发送网络数据时，可以通过调用Stream类中的函数来实现。本函数即是Stream类中的一员。
语法client.println(val);

参数val:所要发送的数据，可以是字符串、字符或者数值。
返回值无
示例代码关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************项目名称/Project          : 零基础入门学用物联网程序名称/Program name     : TCP_Client_print团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)作者/Author              : Dapenson日期/Date（YYYYMMDD）     : 20200317程序目的/Purpose          : 此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求。在发送HTTP请求时使用了println函数，从而演示该函数的使用方法。-----------------------------------------------------------------------修订历史/Revision History  日期/Date    作者/Author      参考号/Ref    修订说明/Revision Description20200410      CYNO朔           001        将服务器响应信息输出过程使用stream类函数实现-----------------------------------------------------------------------本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WiFiMulti.h&gt; ESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象 const char* host = &quot;www.example.com&quot;; // 网络服务器地址const int httpPort = 80;              // http端口80 // WiFi连接信息const char*  WiFi_SSID = &quot;taichimaker&quot;;const char*  WiFi_Password = &quot;12345678&quot;; void setup()&#123;  Serial.begin(9600);            Serial.println(&quot;&quot;);    wifiMulti.addAP(WiFi_SSID, WiFi_Password);   Serial.println(&quot;Connecting ...&quot;);    // 尝试进行wifi连接。  int i = 0;    while (wifiMulti.run() != WL_CONNECTED) &#123;     delay(1000);    Serial.print(i++); Serial.print(&#x27; &#x27;);  &#125;    // WiFi连接成功后将通过串口监视器输出连接成功信息   Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(WiFi.SSID());              // WiFi名称  Serial.print(&quot;IP address:\t&quot;);  Serial.println(WiFi.localIP());           // IP&#125; void loop()&#123;  // 发送HTTP请求  httpRequest();        delay(10000);&#125; // 向服务器发送HTTP请求void httpRequest()&#123;  // 建立WiFi客户端对象，对象名称client  WiFiClient client;       // 建立字符串，用于HTTP请求  String httpRequest =  String(&quot;GET /&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;    // 通过串口输出连接服务器名称以便查阅连接服务器的网址                        Serial.print(&quot;Connecting to &quot;);   Serial.print(host);    // 连接网络服务器，以下段落中的示例程序为本程序重点1  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/  if (client.connect(host, httpPort))&#123;     Serial.println(&quot; Success!&quot;);        // 连接成功后串口输出“Success”信息        client.print(httpRequest);          // 向服务器发送合同请求    Serial.println(&quot;Sending request: &quot;);// 通过串口输出HTTP请求信息内容以便查阅    Serial.println(httpRequest);             // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/    Serial.println(&quot;Web Server Response:&quot;);            while (client.connected() || client.available())&#123;       if (client.available())&#123;        String line = client.readStringUntil(&#x27;\n&#x27;);        Serial.println(line);      &#125;    &#125;        client.stop();                      // 断开与服务器的连接    Serial.print(&quot;Disconnected from &quot;); // 并且通过串口输出断开连接信息    Serial.print(host);      &#125; else&#123;    // 如果连接不成功则通过串口输出“连接失败”信息    Serial.println(&quot; connection failed!&quot;);    client.stop();  &#125;  &#125;



相关内容— print – 发送信息（Stream类）— write – 发送信息（Stream类）— Stream类
write – 发送信息（Stream类）说明write函数可用于发送数据到已连接的服务器。你可以发送单个字节的信息也可以发送多字节的信息。
语法WiFiClient.write(val);WiFiClient.write(str)WiFiClient.write(buf, len)
参数
val: 要发送的单字符数据
str: 要发送的多字符数据
buf: 要发送的多字符数组
len: buf的字节长度

返回值写入发送缓存的字节数
相关内容— print – 发送信息（Stream类）— println – 发送信息（Stream类）— Stream类
响应信息操作类型readString – 读取数据并保存为字符串 （Stream类）说明本函数可用于从ESP8266接收到数据中读取数据信息。读取到的信息将以字符串格式返回。
请留意，WiFiClient对象在处理或发送网络数据时，可以通过调用Stream类中的函数来实现。本函数即是Stream类中的一员。
语法client.readString()

参数无
返回值接收到的数据，类型为字符串。
示例程序此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求，并且将网站服务器响应的信息通过readString函数获取并保存。
关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : 3_5_1_http_request_basic程序目的/Purpose          : 此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求，并且将网站服务器响应的信息通过readString函数获取并保存。***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WiFiMulti.h&gt; ESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象 const char* host = &quot;www.example.com&quot;; // 网络服务器地址const int httpPort = 80;              // http端口80 void setup()&#123;  Serial.begin(9600);            Serial.println(&quot;&quot;);      wifiMulti.addAP(&quot;ssid_from_AP_1&quot;, &quot;your_password_for_AP_1&quot;); // 将需要连接的一系列WiFi ID和密码输入这里  wifiMulti.addAP(&quot;ssid_from_AP_2&quot;, &quot;your_password_for_AP_2&quot;); // ESP8266-NodeMCU再启动后会扫描当前网络  wifiMulti.addAP(&quot;ssid_from_AP_3&quot;, &quot;your_password_for_AP_3&quot;); // 环境查找是否有这里列出的WiFi ID。如果有  Serial.println(&quot;Connecting ...&quot;);    // 尝试进行wifi连接。  int i = 0;    while (wifiMulti.run() != WL_CONNECTED) &#123;     delay(1000);    Serial.print(i++); Serial.print(&#x27; &#x27;);  &#125;    // WiFi连接成功后将通过串口监视器输出连接成功信息   Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(WiFi.SSID());              // WiFi名称  Serial.print(&quot;IP address:\t&quot;);  Serial.println(WiFi.localIP());           // IP&#125; void loop()&#123;  // 发送HTTP请求  httpRequest();        delay(30000);&#125; // 向服务器发送HTTP请求void httpRequest()&#123;  // 建立WiFi客户端对象，对象名称client  WiFiClient client;       // 建立字符串，用于HTTP请求  String httpRequest =  String(&quot;GET /&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;    // 通过串口输出连接服务器名称以便查阅连接服务器的网址                        Serial.print(&quot;Connecting to &quot;);   Serial.print(host);    // 连接网络服务器，以下段落中的示例程序为本程序重点1  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/  if (client.connect(host, httpPort))&#123;     Serial.println(&quot; Success!&quot;);        // 连接成功后串口输出“Success”信息        client.print(httpRequest);          // 向服务器发送合同谈判请求    Serial.println(&quot;Sending request: &quot;);// 通过串口输出HTTP请求信息内容以便查阅    Serial.println(httpRequest);             // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/    Serial.println(&quot;Web Server Response:&quot;);            while (client.connected() || client.available())&#123;       if (client.available())&#123;        String line = client.readString();        Serial.println(line);      &#125;    &#125;        client.stop();                      // 断开与服务器的连接    Serial.print(&quot;Disconnected from &quot;); // 并且通过串口输出断开连接信息    Serial.print(host);      &#125; else&#123;    // 如果连接不成功则通过串口输出“连接失败”信息    Serial.println(&quot; connection failed!&quot;);    client.stop();  &#125;  &#125;

相关内容— readString – 读取数据并保存为字符串 （Stream类）— readStringUntil – 读取数据直到指定字符并保存为字符串 （Stream类）— find – 在数据中寻找信息（Stream类）— parseInt – 解析数据中的整数（Stream类）
readStringUntil – 读取数据直到指定字符并保存为字符串 （Stream类）说明readStringUntil函数可用于从设备接收到的数据中读取信息。读取到的数据信息将以字符串形式返回。该函数在满足以下任一条件后都会停止函数执行并返回。
– 读取到指定终止字符– 达到设定时间（可使用setTimeout来设置）
当函数读取到终止字符后，会立即停止函数执行。此时函数所返回的字符串为”终止字符”前的所有字符信息。
请留意，WiFiClient对象在处理或发送网络数据时，可以通过调用Stream类中的函数来实现。本函数即是Stream类中的一员。
语法client.readStringUntil(terminator)

参数terminator: 终止字符。用于设置终止函数执行的字符信息。设备在读取数据时一旦读取到此终止字符，将会结束函数执行。允许使用char类型。
返回值接收到的数据，类型为字符串。
示例程序此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求，并且将网站服务器响应的信息通过readStringUntil函数获取并且输出在屏幕中。
关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : 3_5_1_http_request_basic程序目的/Purpose          : 此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求，并且将网站服务器响应的信息通过readStringUntil函数获取并且输出在屏幕中。***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WiFiMulti.h&gt; ESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象 const char* host = &quot;www.example.com&quot;; // 网络服务器地址const int httpPort = 80;              // http端口80 void setup()&#123;  Serial.begin(9600);            Serial.println(&quot;&quot;);      wifiMulti.addAP(&quot;ssid_from_AP_1&quot;, &quot;your_password_for_AP_1&quot;); // 将需要连接的一系列WiFi ID和密码输入这里  wifiMulti.addAP(&quot;ssid_from_AP_2&quot;, &quot;your_password_for_AP_2&quot;); // ESP8266-NodeMCU再启动后会扫描当前网络  wifiMulti.addAP(&quot;ssid_from_AP_3&quot;, &quot;your_password_for_AP_3&quot;); // 环境查找是否有这里列出的WiFi ID。如果有  Serial.println(&quot;Connecting ...&quot;);    // 尝试进行wifi连接。  int i = 0;    while (wifiMulti.run() != WL_CONNECTED) &#123;     delay(1000);    Serial.print(i++); Serial.print(&#x27; &#x27;);  &#125;    // WiFi连接成功后将通过串口监视器输出连接成功信息   Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(WiFi.SSID());              // WiFi名称  Serial.print(&quot;IP address:\t&quot;);  Serial.println(WiFi.localIP());           // IP&#125; void loop()&#123;  // 发送HTTP请求  httpRequest();        delay(30000);&#125; // 向服务器发送HTTP请求void httpRequest()&#123;  // 建立WiFi客户端对象，对象名称client  WiFiClient client;       // 建立字符串，用于HTTP请求  String httpRequest =  String(&quot;GET /&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;    // 通过串口输出连接服务器名称以便查阅连接服务器的网址                        Serial.print(&quot;Connecting to &quot;);   Serial.print(host);    // 连接网络服务器，以下段落中的示例程序为本程序重点1  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/  if (client.connect(host, httpPort))&#123;     Serial.println(&quot; Success!&quot;);        // 连接成功后串口输出“Success”信息        client.print(httpRequest);          // 向服务器发送合同谈判请求    Serial.println(&quot;Sending request: &quot;);// 通过串口输出HTTP请求信息内容以便查阅    Serial.println(httpRequest);             // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/    Serial.println(&quot;Web Server Response:&quot;);            while (client.connected() || client.available())&#123;       if (client.available())&#123;        String line = client.readStringUntil(&#x27;\n&#x27;);        Serial.println(line);      &#125;    &#125;        client.stop();                      // 断开与服务器的连接    Serial.print(&quot;Disconnected from &quot;); // 并且通过串口输出断开连接信息    Serial.print(host);      &#125; else&#123;    // 如果连接不成功则通过串口输出“连接失败”信息    Serial.println(&quot; connection failed!&quot;);    client.stop();  &#125;  &#125;



相关内容— readString – 读取数据并保存为字符串 （Stream类）— find – 在数据中寻找信息（Stream类）— parseInt – 解析数据中的整数（Stream类）
find – 在数据中寻找信息（Stream类）说明find函数可用于从设备接收到的数据中寻找指定字符串信息。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。
请留意，WiFiClient对象在处理或发送网络数据时，可以通过调用Stream类中的函数来实现。本函数即是Stream类中的一员。
语法client.find(target)

参数target: 被查找字符串。允许使用String或char类型。
返回值返回值类型为bool。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。
示例程序此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求，并且使用find函数在网站服务器响应的信息中寻找“Date”字符串。如果找到“Date”字符串，则通过串口监视器告知用户开发板已经找到了“Date”字符串。
关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************项目名称/Project          : 零基础入门学用物联网程序名称/Program name     : wifiClient_find团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)作者/Author              : CYNO朔日期/Date（YYYYMMDD）     : 20200210程序目的/Purpose          : 此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求，并且使用find函数在网站服务器响应的信息中寻找“Date”字符串。如果找到“Date”字符串，则通过串口监视器告知用户开发板已经找到了“Date”字符串。-----------------------------------------------------------------------本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WiFiMulti.h&gt; ESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象 const char* host = &quot;www.example.com&quot;; // 网络服务器地址const int httpPort = 80;              // http端口80 void setup()&#123;  Serial.begin(9600);            Serial.println(&quot;&quot;);      wifiMulti.addAP(&quot;ssid_from_AP_1&quot;, &quot;your_password_for_AP_1&quot;); // 将需要连接的一系列WiFi ID和密码输入这里  wifiMulti.addAP(&quot;ssid_from_AP_2&quot;, &quot;your_password_for_AP_2&quot;); // ESP8266-NodeMCU再启动后会扫描当前网络  wifiMulti.addAP(&quot;ssid_from_AP_3&quot;, &quot;your_password_for_AP_3&quot;); // 环境查找是否有这里列出的WiFi ID。如果有  Serial.println(&quot;Connecting ...&quot;);    // 尝试进行wifi连接。  int i = 0;    while (wifiMulti.run() != WL_CONNECTED) &#123;     delay(1000);    Serial.print(i++); Serial.print(&#x27; &#x27;);  &#125;    // WiFi连接成功后将通过串口监视器输出连接成功信息   Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(WiFi.SSID());              // WiFi名称  Serial.print(&quot;IP address:\t&quot;);  Serial.println(WiFi.localIP());           // IP&#125; void loop()&#123;  // 发送HTTP请求  httpRequest();        delay(30000);&#125; // 向服务器发送HTTP请求void httpRequest()&#123;  // 建立WiFi客户端对象，对象名称client  WiFiClient client;       // 建立字符串，用于HTTP请求  String httpRequest =  String(&quot;GET /&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;    // 通过串口输出连接服务器名称以便查阅连接服务器的网址                        Serial.print(&quot;Connecting to &quot;);   Serial.print(host);    // 连接网络服务器，以下段落中的示例程序为本程序重点1  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/  if (client.connect(host, httpPort))&#123;     Serial.println(&quot; Success!&quot;);        // 连接成功后串口输出“Success”信息        client.print(httpRequest);          // 向服务器发送合同谈判请求    Serial.println(&quot;Sending request: &quot;);// 通过串口输出HTTP请求信息内容以便查阅    Serial.println(httpRequest);             // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/    Serial.println(&quot;Web Server Response:&quot;);            while (client.connected() || client.available())&#123;       if (client.available())&#123;        if (client.find(&quot;Date&quot;))&#123;          Serial.println(&quot;Found Date Info in Server Response.&quot;);        &#125;      &#125;    &#125;        client.stop();                      // 断开与服务器的连接    Serial.print(&quot;Disconnected from &quot;); // 并且通过串口输出断开连接信息    Serial.print(host);      &#125; else&#123;    // 如果连接不成功则通过串口输出“连接失败”信息    Serial.println(&quot; connection failed!&quot;);    client.stop();  &#125;  &#125;



相关内容— readString – 读取数据并保存为字符串 （Stream类）— readStringUntil – 读取数据直到指定字符并保存为字符串 （Stream类）— parseInt – 解析数据中的整数（Stream类）— Stream类
parseInt – 解析数据中的整数（Stream类）说明parseInt函数可用于从设备接收到的数据中寻找整数数值。
请留意，WiFiClient对象在处理或发送网络数据时，可以通过调用Stream类中的函数来实现。本函数即是Stream类中的一员。
语法client.parseInt()
参数无
返回值在输入信息中找到的整数数值。类型：long
示例程序此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求，并且使用find函数在网站服务器响应的信息中寻找“Date”字符串。如果找到“Date”字符串，则进一步使用parseInt函数来寻找“Date”字符串后面的第一个数字。由于标准服务器相应信息中“Date”字符串后面的第一个数字信息即是当前服务器的日期信息中的”日”数值。因parseInt函数寻找到的数字即是服务器的日期信息中的”日”数值。
关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : WiFiClient_parseInt程序目的/Purpose          : 此程序用于演示如何使用esp8266作为互联网客户端向www.example.com网站服务器发送http请求，并且使用find函数在网站服务器响应的信息中寻找“Date”字符串。如果找到“Date”字符串，则进一步使用parseInt函数来寻找“Date”字符串后面的第一个数字。由于标准服务器相应信息中“Date”字符串后面的第一个数字信息即是当前服务器的日期信息中的&quot;日&quot;数值。因此parseInt函数寻找到的数字即是服务器的日期信息中的&quot;日&quot;数值。***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WiFiMulti.h&gt; ESP8266WiFiMulti wifiMulti;           // 建立ESP8266WiFiMulti对象 const char* host = &quot;www.example.com&quot;; // 网络服务器地址const int httpPort = 80;              // http端口80 void setup()&#123;  Serial.begin(9600);            Serial.println(&quot;&quot;);      wifiMulti.addAP(&quot;ssid_from_AP_1&quot;, &quot;your_password_for_AP_1&quot;); // 将需要连接的一系列WiFi ID和密码输入这里  wifiMulti.addAP(&quot;ssid_from_AP_2&quot;, &quot;your_password_for_AP_2&quot;); // ESP8266-NodeMCU再启动后会扫描当前网络  wifiMulti.addAP(&quot;ssid_from_AP_3&quot;, &quot;your_password_for_AP_3&quot;); // 环境查找是否有这里列出的WiFi ID。如果有  Serial.println(&quot;Connecting ...&quot;);    // 尝试进行wifi连接。  int i = 0;    while (wifiMulti.run() != WL_CONNECTED) &#123;     delay(1000);    Serial.print(i++); Serial.print(&#x27; &#x27;);  &#125;    // WiFi连接成功后将通过串口监视器输出连接成功信息   Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(WiFi.SSID());              // WiFi名称  Serial.print(&quot;IP address:\t&quot;);  Serial.println(WiFi.localIP());           // IP&#125; void loop()&#123;  // 发送HTTP请求  httpRequest();        delay(30000);&#125; // 向服务器发送HTTP请求void httpRequest()&#123;  // 建立WiFi客户端对象，对象名称client  WiFiClient client;       // 建立字符串，用于HTTP请求  String httpRequest =  String(&quot;GET /&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;    // 通过串口输出连接服务器名称以便查阅连接服务器的网址                        Serial.print(&quot;Connecting to &quot;);   Serial.print(host);    // 连接网络服务器，以下段落中的示例程序为本程序重点1  // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：  // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/  if (client.connect(host, httpPort))&#123;     Serial.println(&quot; Success!&quot;);        // 连接成功后串口输出“Success”信息        client.print(httpRequest);          // 向服务器发送合同谈判请求    Serial.println(&quot;Sending request: &quot;);// 通过串口输出HTTP请求信息内容以便查阅    Serial.println(httpRequest);             // 通过串口输出网络服务器响应信息， 以下段落中的示例程序为本程序重点2    // 请参考太极创客网站中关于本程序的讲解页面获取详细说明信息。网址：    // http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/    Serial.println(&quot;Web Server Response:&quot;);            while (client.connected() || client.available())&#123;       if (client.available())&#123;        if (client.find(&quot;Date&quot;))&#123;          Serial.println(&quot;Found Date Info in Server Response.&quot;);          int day = client.parseInt();                 Serial.print(&quot;day = &quot;);Serial.println(day);        &#125;      &#125;    &#125;        client.stop();                      // 断开与服务器的连接    Serial.print(&quot;Disconnected from &quot;); // 并且通过串口输出断开连接信息    Serial.print(host);      &#125; else&#123;    // 如果连接不成功则通过串口输出“连接失败”信息    Serial.println(&quot; connection failed!&quot;);    client.stop();  &#125;  &#125;



相关内容— readString – 读取数据并保存为字符串 （Stream类）— readStringUntil – 读取数据直到指定字符并保存为字符串 （Stream类）— find – 在数据中寻找信息（Stream类）— Stream类
备注:以上带有（Stream类）标注的函数说明该函数是Stream类函数。Stream类说明当我们使用ESP8266开发板或者Arduino开发板来开发项目时，可以使用基于Stream类的库来处理Stream数据。以下列表中的库都是基于Stream类所建立的。



库
类



Serial
Serial


SoftwareSerial
SoftwareSerial


Ehternet
EthernetClient


ESP8266FS
File


SD
File


Wire
Wire


GSM
GSMClient


WifiClient
WiFiClient


WiFiServer
WiFiServer


WiFiUDP
WiFiUDP


WiFiClientSecure
WiFiClientSecure


函数available说明available() 函数可用于检查设备是否接收到数据。该函数将会返回等待读取的数据字节数。
available()函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。
语法stream.available()注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：Serial.available()wifiClient.available()
参数无
返回值等待读取的数据字节数。返回值数据类型：int
示例程序/**********************************************************************程序名称/Program name     : stream_readString程序目的/Purpose          : Stream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。然而当我们使用基于Stream类的库时，都会调用Stream中的内容。 以下Arduino库及相应库中的类都是基于Stream类所实现的。 库          类Core        SerialWifi        WiFiClientEhternet    EthernetClientESP8266FS   FileSD          FileWire        WireGSM         GSMClientSoftwareSerial  SoftwareSerial 此程序使用Serial库来演示Stream类中的available()以及readString()函数的使用方法。available() 函数可用于检查设备是否接收到数据。该函数将会返回等待读取的数据字节数。readString() 函数将读取stream中的字符并存储到字符中。***********************************************************************/ void setup() &#123;  // 启动串口通讯  Serial.begin(9600);   Serial.println();&#125; void loop() &#123;    if (Serial.available())&#123;                      // 当串口接收到信息后    Serial.println(&quot;Serial Data Available...&quot;); // 通过串口监视器通知用户        String serialData = Serial.readString();    // 将接收到的信息使用readString()存储于serialData变量    Serial.print(&quot;Received Serial Data: &quot;);     // 然后通过串口监视器输出serialData变量内容    Serial.println(serialData);                 // 以便查看serialData变量的信息  &#125;&#125;



read说明read() 函数可用于从设备接收到数据中读取一个字节的数据。
本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。
语法stream.read()注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：Serial.read()wifiClient.read()
参数无
返回值设备没有接收到数据时，返回值为-1设备接收到数据时，返回值为接收到的数据流中的1个字符。
示例程序/**********************************************************************程序名称/Program name     : stream_read程序目的/Purpose          : Stream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。然而当我们使用基于Stream类的库时，都会调用Stream中的内容。 以下Arduino库及相应库中的类都是基于Stream类所实现的。 库          类Core        SerialWifi        WiFiClientEhternet    EthernetClientESP8266FS   FileSD          FileWire        WireGSM         GSMClientSoftwareSerial  SoftwareSerial 此程序使用Serial对象来演示Stream类中的read()read() 函数可用于从设备接收到数据中读取一个字节的数据。***********************************************************************/ void setup() &#123;  // 启动串口通讯  Serial.begin(9600);   Serial.println();&#125; void loop() &#123;  while (Serial.available())&#123;           // 当串口接收到信息后     char serialData = Serial.read();    // 将接收到的信息使用read读取    Serial.println((char)serialData);   // 然后通过串口监视器输出read函数读取的信息  &#125;&#125;



readBytes说明readBytes函数可用于从设备接收的数据中读取信息。读取到的数据信息将存放在缓存变量中。该函数在读取到指定字节数的信息或者达到设定时间后都会停止函数执行并返回。该设定时间可使用setTimeout来设置。
本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。
语法stream.readBytes(buffer, length)注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：Serial.readBytes(buffer, length)wifiClient.readBytes(buffer, length)
参数buffer: 缓存变量&#x2F;数组。用于存储读取到的信息。允许使用char或者byte类型的变量或数组。length: 读取字节数量。readBytes函数在读取到length所指定的字节数量后就会停止运行。允许使用int类型。
返回值buffer(缓存变量)中存储的字节数。数据类型：size_t
示例程序/**********************************************************************程序名称/Program name     : stream_readBytes程序目的/Purpose          : Stream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。然而当我们使用基于Stream类的库时，都会调用Stream中的内容。 以下Arduino库及相应库中的类都是基于Stream类所实现的。 库          类Core        SerialWifi        WiFiClientEhternet    EthernetClientESP8266FS   FileSD          FileWire        WireGSM         GSMClientSoftwareSerial  SoftwareSerial 此程序使用Serial对象来演示Stream类中的readByte()函数使用方法readByte()函数在读取到指定字节数的信息或者达到设定时间后都会停止执行。***********************************************************************/const int bufferLength = 10;    // 定义缓存大小为10个字节char serialBuffer[bufferLength];// 建立字符数组用于缓存 void setup() &#123;  // 启动串口通讯  Serial.begin(9600);   Serial.println();&#125; void loop() &#123;    if (Serial.available())&#123;             			// 当串口接收到信息后      Serial.println(&quot;Received Serial Data:&quot;);      Serial.readBytes(serialBuffer, bufferLength);// 将接收到的信息使用readBytes读取    for(int i=0; i&lt;bufferLength; i++)&#123;  		// 然后通过串口监视器输出readBytes      Serial.print(serialBuffer[i]);      		// 函数所读取的信息    &#125;    Serial.println(&quot;&quot;);      Serial.println(&quot;Finished Printing Recevied Data.&quot;);        &#125;&#125;



readBytesUntil说明readBytesUntil() 函数可用于从设备接收到数据中读取信息。读取到的数据信息将存放在缓存变量中。该函数在满足以下任一条件后都会停止函数执行并且返回。
– 读取到指定终止字符– 读取到指定字节数的信息– 达到设定时间（可使用setTimeout来设置）
当函数读取到终止字符后，会立即停止函数执行。此时buffer（缓存变量&#x2F;数组）中所存储的信息为设备读取到终止字符前的字符内容。
本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。
语法stream.readBytesUntil(character, buffer, length)注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：Serial.readBytesUntil(character, buffer, length)wifiClient.readBytesUntil(character, buffer, length)
参数
character: 终止字符。用于设置终止函数执行的字符信息。设备在读取数据时一旦读取到此终止字符，将会结束函数执行。允许使用char类型。
buffer: 缓存变量&#x2F;数组。用于存储读取到的信息。允许使用char或者byte类型的变量或数组。
length: 读取字节数量。readBytes函数在读取到length所指定的字节数量后就会停止运行。允许使用int类型。&#96;

返回值buffer(缓存变量)中存储的字节数。数据类型：size_t
示例程序/**********************************************************************程序名称/Program name     : stream_readBytesUntil程序目的/Purpose          : Stream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。然而当我们使用基于Stream类的库时，都会调用Stream中的内容。 以下Arduino库及相应库中的类都是基于Stream类所实现的。 库          类Core        SerialWifi        WiFiClientEhternet    EthernetClientESP8266FS   FileSD          FileWire        WireGSM         GSMClientSoftwareSerial  SoftwareSerial 此程序使用Serial对象来演示Stream类中的readByteUntil()函数使用方法。***********************************************************************/char terminateChar =  &#x27;T&#x27;;      // 建立终止字符const int bufferLength = 10;    // 定义缓存大小为10个字节char serialBuffer[bufferLength];// 建立字符数组用于缓存   void setup() &#123;  // 启动串口通讯  Serial.begin(9600);   Serial.println();&#125; void loop() &#123;  if (Serial.available())&#123;             // 当串口接收到信息后      Serial.readBytesUntil(terminateChar, serialBuffer, bufferLength);// 将接收到的信息使用read读取     for(int i=0; i&lt;bufferLength; i++)&#123;  // 然后通过串口监视器输出readBytesUntil      Serial.print(serialBuffer[i]);    // 函数所读取的信息    &#125;        Serial.println(&quot;&quot;);        &#125; &#125;



readString说明readString() 函数可用于从设备接收到数据中读取数据信息。读取到的信息将以字符串格式返回。
本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。
语法stream.readString()注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：Serial.readString()wifiClient.readString()
参数无
返回值接收到的数据，类型为字符串。
示例程序/**********************************************************************程序名称/Program name     : stream_readString程序目的/Purpose          : Stream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。然而当我们使用基于Stream类的库时，都会调用Stream中的内容。 以下Arduino库及相应库中的类都是基于Stream类所实现的。 库          类Core        SerialWifi        WiFiClientEhternet    EthernetClientESP8266FS   FileSD          FileWire        WireGSM         GSMClientSoftwareSerial  SoftwareSerial 此程序使用Serial库来演示Stream类中的available()以及readString()函数的使用方法。available() 函数将会返回开发板所接收到的stream中等待读取的字节数。readString() 函数将读取stream中的字符并存储到字符中。***********************************************************************/ void setup() &#123;  // 启动串口通讯  Serial.begin(9600);   Serial.println();&#125; void loop() &#123;    if (Serial.available())&#123;                      // 当串口接收到信息后    Serial.println(&quot;Serial Data Available...&quot;); // 通过串口监视器通知用户        String serialData = Serial.readString();    // 将接收到的信息使用readString()存储于serialData变量    Serial.print(&quot;Received Serial Data: &quot;);     // 然后通过串口监视器输出serialData变量内容    Serial.println(serialData);                 // 以便查看serialData变量的信息  &#125;&#125;

相关内容– available– readStringUntil
readStringUntil说明readStringUntil函数可用于从设备接收到的数据中读取信息。读取到的数据信息将以字符串形式返回。该函数在满足以下任一条件后都会停止函数执行并返回。
– 读取到指定终止字符– 达到设定时间（可使用setTimeout来设置）
当函数读取到终止字符后，会立即停止函数执行。此时函数所返回的字符串为”终止字符”前的所有字符信息。
本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。
语法Stream.readStringUntil(terminator)注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：Serial.readStringUntil(terminator)wifiClient.readStringUntil(terminator)
参数terminator: 终止字符。用于设置终止函数执行的字符信息。设备在读取数据时一旦读取到此终止字符，将会结束函数执行。允许使用char类型。
返回值接收到的数据，类型为字符串
示例程序/**********************************************************************程序名称/Program name     : stream_readStringUntil程序目的/Purpose          : 此程序使用Serial来演示Stream类中的readString()函数的使用方法。readStringUntil() 函数可用于从设备接收到数据中读取信息。读取到的数据信息将以字符串形式返回中。 Stream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。然而当我们使用基于Stream类的库时，都会调用Stream中的内容。 以下Arduino库及相应库中的类都是基于Stream类所实现的。 库          类Core        SerialWifi        WiFiClientEhternet    EthernetClientESP8266FS   FileSD          FileWire        WireGSM         GSMClientSoftwareSerial  SoftwareSerial***********************************************************************/char terminatorChar = &#x27;T&#x27;;    // 定义终止字符为‘T’ void setup() &#123;  // 启动串口通讯  Serial.begin(9600);   Serial.println();&#125; void loop() &#123;    if (Serial.available())&#123;                      // 当串口接收到信息后    Serial.println(&quot;Serial Data Available...&quot;); // 通过串口监视器通知用户        String serialData = Serial.readStringUntil(terminatorChar);    // 将接收到的信息使用readString()存储于serialData变量    Serial.print(&quot;Received Serial Data: &quot;);     // 然后通过串口监视器输出serialData变量内容    Serial.println(serialData);                 // 以便查看serialData变量的信息  &#125;&#125;



find说明find函数可用于从设备接收到的数据中寻找指定字符串信息。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。
本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。
语法Stream.find(target)注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：Serial.find(target)wifiClient.find(target)
参数target: 被查找字符串。允许使用String或char类型。
返回值返回值类型为bool。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。
示例程序/**********************************************************************程序名称/Program name     : find程序目的/Purpose          : 此程序使用Serial来演示Stream类中的find函数使用方法。find函数可用于从设备接收到数据中寻找指定信息。当该函数找到了指定信息后将会立即结束函数执行并且返回“真”。否则该函数将会返回“假”。 Stream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。然而当我们使用基于Stream类的库时，都会调用Stream中的内容。 以下Arduino库及相应库中的类都是基于Stream类所实现的。 库          类Core        SerialWifi        WiFiClientEhternet    EthernetClientESP8266FS   FileSD          FileWire        WireGSM         GSMClientSoftwareSerial  SoftwareSerial***********************************************************************/ void setup() &#123;  // 启动串口通讯  Serial.begin(9600);   Serial.println();&#125; void loop() &#123;   if (Serial.available())&#123;                      // 当串口接收到信息后    Serial.println(&quot;Serial Data Available...&quot;); // 通过串口监视器通知                                                // 用户系统开始查找指定信息    Serial.print(&quot;system is trying to find &quot;); Serial.println(&quot;^_^&quot;);      // 执行查找并通过串口监视器输出查找结果    if(Serial.find(&quot;^_^&quot;)) &#123;      Serial.print(&quot;Great! System found &quot;); Serial.println(&quot;^_^&quot;);     &#125; else &#123;      Serial.print(&quot;Sorry System can&#x27;t find &quot;); Serial.println(&quot;^_^&quot;);     &#125;      Serial.println(&quot;&quot;);  &#125;&#125;

相关内容– available– findUntil
findUntil说明findUntil函数可用于从设备接收到的数据中寻找指定字符串信息。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。该函数在满足以下任一条件后都会停止函数执行
– 读取到指定终止字符串– 找到了指定字符串信息– 达到设定时间（可使用setTimeout来设置）
本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。
语法Stream.findUntil(target, terminator)注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：Serial.findUntil(target, terminator)wifiClient.findUntil(target, terminator)
参数target: 被查找字符串。允许使用String或char类型。
terminator: 终止字符串。用于设置终止函数执行的字符串信息。设备在读取数据时一旦读取到此终止字符串，将会结束函数执行并返回。
返回值返回值类型为bool。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。
示例程序/**********************************************************************程序名称/Program name     : findUntil程序目的/Purpose          : 此程序使用Serial来演示Stream类中的findUntil函数使用方法。findUntil函数可用于从设备接收到数据中寻找指定字符串信息。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。 Stream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。然而当我们使用基于Stream类的库时，都会调用Stream中的内容。 以下Arduino库及相应库中的类都是基于Stream类所实现的。 库          类Core        SerialWifi        WiFiClientEhternet    EthernetClientESP8266FS   FileSD          FileWire        WireGSM         GSMClientSoftwareSerial  SoftwareSerial***********************************************************************/void setup() &#123;  // 启动串口通讯  Serial.begin(9600);   Serial.println();&#125; void loop() &#123;   if (Serial.available())&#123;                      // 当串口接收到信息后    Serial.println(&quot;Serial Data Available...&quot;); // 通过串口监视器通知                                                // 用户系统开始查找指定信息    Serial.print(&quot;system is trying to find &quot;); Serial.println(&quot;^_^&quot;);      // 执行查找并通过串口监视器输出查找结果    if(Serial.findUntil(&quot;^_^&quot;, &quot;STOP&quot;)) &#123;      Serial.print(&quot;Great! System found &quot;); Serial.println(&quot;^_^&quot;);     &#125; else &#123;      Serial.print(&quot;Sorry System can&#x27;t find &quot;); Serial.println(&quot;^_^&quot;);     &#125;      Serial.println(&quot;&quot;);  &#125;&#125;

相关内容– available– find
peek说明peek函数可用于从设备接收到的数据中读取一个字节的数据。但是与read函数不同的是，使用peek函数读取数据后，被读取的数据不会从数据流中消除。这就导致每一次调用peek函数，只能读取数据流中的第一个字符。然而每一次调用read函数读取数据时，被读取的数据都会从数据流中删除。
本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。
语法stream.peek()注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：Serial.peek()wifiClient.peek()
参数target: 被查找字符串。允许使用String或char类型。
terminator: 终止字符串。用于设置终止函数执行的字符串信息。设备在读取数据时一旦读取到此终止字符串，将会结束函数执行并返回。
返回值设备没有接收到数据时，返回值为-1
设备接收到数据时，返回值为接收到的数据流中的第1个字符。
示例程序/**********************************************************************程序名称/Program name     : stream_peek程序目的/Purpose          : 此程序使用Serial来演示Stream类中的peek()。 Stream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。然而当我们使用基于Stream类的库时，都会调用Stream中的内容。 以下Arduino库及相应库中的类都是基于Stream类所实现的。 库          类Core        SerialWifi        WiFiClientEhternet    EthernetClientESP8266FS   FileSD          FileWire        WireGSM         GSMClientSoftwareSerial  SoftwareSerial***********************************************************************/ void setup() &#123;  // 启动串口通讯  Serial.begin(9600);   Serial.println();&#125; void loop() &#123;    while (Serial.available())&#123;             // 当串口接收到信息后        char serialData = Serial.peek();      // 将接收到的信息使用peek读取    Serial.println((char)serialData);     // 然后通过串口监视器输出peek函数所读取的信息  &#125;&#125;



flush说明flush函数可让开发板在所有待发数据发送完毕前，保持等待状态。
请注意：很多人误认为flush函数具有清除开发板接收缓存区的功能。事实上此函数是没有此功能的。如需了解如何清除开发板接收缓存区内信息的方法，请点击这里进入相应说明页面。
本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。
为了更好的理解flush函数的作用，我们在这里用Serial.flush()作为示例讲解。
当我们通过Serial.print或Serial.println来发送数据时，被发送的字符数据将会存储于开发板的“发送缓存”中。这么做的原因是开发板串行通讯速率不是很高，如果发送数据较多，发送时间会比较长。
在没有使用flush函数的情况下，开发板不会等待所有“发送缓存”中数据都发送完毕再执行后续的程序内容。也就是说，开发板是在后台发送缓存中的数据。程序运行不受影响。
相反的，在使用了flush函数的情况下，开发板是会等待所有“发送缓存”中数据都发送完毕以后，再执行后续的程序内容。
语法stream.flush()注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：Serial.flush()wifiClient.flush()
参数无
返回值无
示例程序为了演示flush函数工作效果，一共为您准备了两个示例程序。这两个程序一个使用了flush函数另外一个没有使用flush函数。
通过这两个示例程序的运行结果比较，您可以看到flush函数的工作效果。
示例1：没有使用flush函数的情况下，通过串口监视器显示开发板输出一大串字符的运行效果。
/**********************************************************************程序名称/Program name     : stream_With_flush程序目的/Purpose          : 此程序使用Serial来演示Stream类中的flush函数。flush函数可让开发板在所有发送数据全部发送完毕之前，保持等待状态。 为了演示flush函数工作效果，一共为您准备了两个示例程序。这两个程序一个使用了flush函数另外一个没有使用flush函数。 通过这两个示例程序的运行结果比较，您可以看到flush函数的工作效果。 此程序为没有使用flush函数的情况下，通过串口监视器显示开发板在输出一大串字符的运行效果。***********************************************************************/ void setup() &#123;  Serial.begin(9600);   // 记录输出串口信息前的millis时间  unsigned long millisNoFlushStart = millis();    // 通过串口输出信息  Serial.println(F(&quot;abcdefghijklmnopqrstuvwxyz&quot;));    // 记录输出串口信息后的millis时间  unsigned long millisNoFlushStop = millis();   // 通过串口监视器输出没有使用flush函数情况下，输出信息前后的时间差。  Serial.print(F(&quot;NO flush: &quot;));  Serial.print( millisNoFlushStop - millisNoFlushStart);  Serial.println(F(&quot; milliseconds.&quot;));&#125;void loop() &#123;&#125; /*Stream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。然而当我们使用基于Stream类的库时，都会调用Stream中的内容。 以下Arduino库及相应库中的类都是基于Stream类所实现的。 库          类Core        SerialWifi        WiFiClientEhternet    EthernetClientESP8266FS   FileSD          FileWire        WireGSM         GSMClientSoftwareSerial  SoftwareSerial-----------------------------------------------------------------------*/



parseInt说明parseInt函数可用于从设备接收到的数据中寻找整数数值。
本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。
语法stream.parseInt()注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：Serial.parseInt()wifiClient.parseInt()
参数无
返回值在输入信息中找到的整数数值。类型：long
示例程序/**********************************************************************程序名称/Program name     : stream_parseInt程序目的/Purpose          : 此程序使用Serial来演示Stream类中的parseInt。parseInt函数可用于从设备接收到的数据中寻找整数数值。 Stream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。然而当我们使用基于Stream类的库时，都会调用Stream中的内容。 以下Arduino库及相应库中的类都是基于Stream类所实现的。 库          类Core        SerialWifi        WiFiClientEhternet    EthernetClientESP8266FS   FileSD          FileWire        WireGSM         GSMClientSoftwareSerial  SoftwareSerial***********************************************************************/ void setup() &#123;    // 启动串口通讯  Serial.begin(9600);   Serial.println();  &#125; void loop() &#123;    if (Serial.available())&#123;              // 当串口接收到信息后       int serialData = Serial.parseInt(); // 使用parseInt查找接收到的信息中的整数    Serial.print(&quot;serialData = &quot;);      // 然后通过串口监视器输出找到的数值    Serial.println(serialData);  &#125;  &#125;

相关内容– available– parseFloat
parseFloat说明parseFloat函数可用于从设备接收到的数据中寻找浮点数值。
本函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。
语法stream.parseFloat()注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：Serial.parseFloat()wifiClient.parseFloat()
参数无
返回值在输入信息中找到浮点数值。类型：float
示例程序/**********************************************************************程序名称/Program name     : stream_parseFloat程序目的/Purpose          : 此程序使用Serial来演示Stream类中的parseFloat。parseFloat函数可用于从设备接收到的数据中寻找整数数值。 Stream类用于处理字符数据流或二进制数据流。Stream类是不能被直接调用的。然而当我们使用基于Stream类的库时，都会调用Stream中的内容。 以下Arduino库及相应库中的类都是基于Stream类所实现的。 库          类Core        SerialWifi        WiFiClientEhternet    EthernetClientESP8266FS   FileSD          FileWire        WireGSM         GSMClientSoftwareSerial  SoftwareSerial***********************************************************************/ void setup() &#123;    // 启动串口通讯  Serial.begin(9600);   Serial.println();  &#125; void loop() &#123;    if (Serial.available())&#123;              // 当串口接收到信息后       float serialData = Serial.parseFloat(); // 使用parseFloat查找接收到的信息中的整数    Serial.print(&quot;serialData = &quot;);      // 然后通过串口监视器输出找到的数值    Serial.println(serialData);  &#125;  &#125;

相关内容– available– parseInt
setTimeout说明setTimeout函数用于设置设备等待数据流的最大时间间隔。
当设备在接收数据时，是以字符作为单位来逐个字符执行接收任务。由于设备无法预判即将接收到的信息包含有多少字符，因此设备会设置一个等待时间。默认情况下，该等待时间是1000毫秒。
举例来说，假设我们要向设备发送一个字符串“ok”。那么设备在接收到第一个字符“o”以后，他会等待第二个字符的到达。假如在1000毫秒内，设备接收到第二个字符“k”，那么设备会重置等待时间，也就是再等待1000毫秒，看一看字符“k”后面还有没有字符到达。我们知道我们发给设备的字符串只有两个字符，后面没有更多字符了。但是设备并不知道这一情况。因此设备在接收到“k”以后，会等待1000毫秒。直到1000毫秒等待时间结束都没有再次接到字符。这时，设备才会很肯定地结束这一次接收工作。这里这个等待的1000毫秒时间就是通过setTimeout函数来设置的。
setTimeout函数属于Stream类。该函数可被Stream类的子类所使用，如（Serial, WiFiClient, File 等）。
语法stream.setTimeout(time)注：此处stream为概念对象名称。在实际使用过程中，需要根据实际使用的stream子类对象名称进行替换。如：Serial.setTimeout(time)wifiClient.setTimeout(time)
参数time: 设置最大等待时间。单位：毫秒。允许类型：long
返回值无
示例程序/**********************************************************************程序名称/Program name     : stream_setTimeout程序目的/Purpose          : 此程序使用Serial来演示Stream类中的setTimeout。setTimeout函数用于设置设备等待数据流的最大时间间隔。默认情况下，该等待时间是1000毫秒。 ***********************************************************************/ void setup() &#123;  Serial.begin(9600);  Serial.setTimeout(5000);&#125; void loop() &#123;  if (Serial.available()) &#123;				    String s = Serial.readString();    Serial.println(s);  &#125;&#125;

相关内容– available
清除接收缓存说明此页面用于演示如何清除开发板的接收缓存。
制作此说明页面是由于很多人误认为stream类中的flush函数具有清除缓存的功能。事实上此函数是没有清除缓存功能的。
为了便于理解，我们在这里用Serial作为示例，演示如何清除串口接收缓存中的信息。
示例程序/**********************************************************************程序名称/Program name     : stream_clear_buffer团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)作者/Author              : CYNO朔日期/Date（YYYYMMDD）     : 20200318程序目的/Purpose          :  -----------------------------------------------------------------------本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/***********************************************************************/void setup() &#123;  Serial.begin(9600);&#125; void loop() &#123;  // 以下while循环语句将会清除接收缓存内容。  // 具体工作原理是这样的。每当有数据输入接收缓存后，  // 我们可以使用Serial.read()来读取接收缓存中的内容。  // 这时，如果我们对Serial.read()函数的返回值不加以任何利用  // 那么读取到的数据，也就是Serial.read()函数的返回值将会在  // 下一次执行Serial.read时所抛弃。利用while循环语句，我们可以  // 保证在接收缓存中有数据的时候，反复将串口接收缓存中的信息读取并抛弃。  // 从而达到清除接收缓存的目的。  while(Serial.available())&#123;    Serial.println(&quot;Clearing Serial Incoming Buffer.&quot;);    Serial.read();  &#125;    // 当接收缓存为空时，Serial.read返回值为“-1”  // 通过以下语句我们将看到无论我们是否通过串口监视器  // 输入信息，开发板的串口监视器会一直输出:  // &quot;Incoming Buffer is Clear.&quot;  // 这是因为接收缓存中的信息被以上while语句中的内容给清除掉了。  if (Serial.read() == -1)&#123;    Serial.println(&quot;Incoming Buffer is Clear.&quot;);  &#125;&#125;











ESP8266 – WiFiServer库WiFiServer库用于ESP8266的TCP协议物联网通讯。TCP协议又称传输控制协议是Transmission Control Protocol的简称。如需了解更多有关TCP协议介绍，请点击这里查看TCP协议的百度百科介绍页。
通过WiFiServer库，我们可以使用ESP8266开发板建立网络服务器,从而允许其它网络设备以及物联网设备通过TCP协议访问并实现物联网信息交流。
ESP8266库中还有一个专门用于HTTP通讯的ESP8266WebServer库 。
由于HTTP协议是建立在TCP协议基础之上的，我们也可以使用ESP8266WebServer库来实现HTTP通讯。在这一点上，WiFiServer库与ESP8266WebServer库 在功能上形成了互补。
请留意，WiFiServer对象在处理或发送网络数据时，可以通过调用Stream类中的函数来实现。因此在以下结构图中的“响应信息操作类型”中有“Stream类”作为这种类型函数的一部分。
以下为WiFiServer库的整体结构图。

服务器设置类型WiFiServer – 建立新的WiFiServer对象说明此函数用于建立新的WiFiServer对象，以便利用此对象来控制ESP8266建立的物联网服务器。
语法WiFiServer server(port)

参数– port: 此参数用于设置服务端口号。(类型:int)
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址。此时，ESP8266已经成功建立了网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。
假设您的ESP8266开发板IP地址是192.168.0.110。那么接下来您可以通过浏览器输入该IP地址。
当您在浏览器地址栏中输入Ip后并按下回车，这时您将看到浏览器中显示上图所示的网页页面。该页面即是通过ESP8266所建立的。在以下的示例程序中，我们使用了语句WiFiServer server(80);来建立了WiFiServer对象以便后续程序中对服务器进行相应的控制。
/**********************************************************************程序名称/Program name     : WIFIServer_demo_1程序目的/Purpose          : 此示例程序演示了如何使用WiFiServer库建立网络服务器。通过以下网址可以设置板载LED灯的状态http://server_ip/gpio/0将设置 LED_BUILTIN 引脚设置为低电平，http://server_ip/gpio/1将设置 LED_BUILTIN 引脚设置为高电平以上网址链接中的server_ip指的是ESP8266模块的IP地址。***********************************************************************/#include &lt;ESP8266WiFi.h&gt; //此处设置您的wifi接入信息#ifndef STASSID#define STASSID &quot;Taichi-Maker&quot;#define STAPSK  &quot;12345678&quot;#endif const char* ssid = STASSID;const char* password = STAPSK; //创建TCP server对象,并将端口指定为80WiFiServer server(80); void setup() &#123;  //打开串口  Serial.begin(115200);   //初始化板载LED  pinMode(LED_BUILTIN, OUTPUT);  digitalWrite(LED_BUILTIN, 0);   //连接WiFi  Serial.println();  Serial.println();  Serial.print(F(&quot;Connecting to &quot;));  Serial.println(ssid);   WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);   while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(F(&quot;.&quot;));  &#125;  Serial.println();  Serial.println(F(&quot;WiFi connected&quot;));   //启动TCP server服务器  server.begin();  Serial.println(F(&quot;Server started&quot;));   //打印IP地址  Serial.println(WiFi.localIP());&#125; void loop() &#123;  //检查客户端是否已连接  WiFiClient client = server.available();  if (!client) &#123;    return;  &#125;  Serial.println(F(&quot;new client&quot;));   client.setTimeout(5000); //默认为 1000   //读取客户端发起的TCP请求  String req = client.readStringUntil(&#x27;\r&#x27;);  Serial.println(F(&quot;request: &quot;));  Serial.println(req);   //解析请求里是否含有以下指定内容  int val;  //检查发起的请求内容是否包含&quot;/gpio/0&quot;  if (req.indexOf(F(&quot;/gpio/0&quot;)) != -1) &#123;    val = 0;     //检查发起的请求内容是否包含&quot;/gpio/1&quot;  &#125; else if (req.indexOf(F(&quot;/gpio/1&quot;)) != -1) &#123;    val = 1;  &#125; else &#123;    Serial.println(F(&quot;invalid request&quot;));    val = digitalRead(LED_BUILTIN);  &#125;   //根据要求设置板载LED状态  digitalWrite(LED_BUILTIN, val);   //读取剩余的内容,用于清除缓存  while (client.available()) &#123;    client.read();  &#125;   //将响应体发送到客户端 注:若要使用中文则必须在其中添加&lt;meta charset=\&quot;utf-8\&quot;&gt;声明编码  client.print(F(&quot;HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n&lt;!DOCTYPE HTML&gt;\r\n&lt;html&gt;\r\n&lt;meta charset=\&quot;utf-8\&quot;&gt;NodeMCU板载LED灯的状态 : &quot;));  client.print((val) ? F(&quot;关&quot;) : F(&quot;开&quot;));  client.print(F(&quot;&lt;br&gt;&lt;br&gt; &lt;a href=&#x27;http://&quot;));  client.print(WiFi.localIP());  client.print(F(&quot;/gpio/1&#x27;&gt;  点击关灯  &lt;/a&gt; , 或  &lt;a href=&#x27;http://&quot;));  client.print(WiFi.localIP());  client.print(F(&quot;/gpio/0&#x27;&gt;  点击开灯  &lt;/a&gt; &lt;/html&gt;&quot;));   //通过浏览器点击按钮之后,TCP连接将会被重置,并且浏览器会发起新的TCP请求到我们的8266服务器,从而去控制LED灯  Serial.println(F(&quot;Disconnecting from client&quot;));&#125;





相关内容— begin – 服务器启动— stop – 停止服务器— close – 停止服务器
begin – 服务器启动说明本函数用于启动ESP8266开发板所建立的物联网网络服务器。
语法server.begin()

参数无
返回值无
示例程序/**********************************************************************程序名称/Program name     : WIFIServer_demo_1程序目的/Purpose          : 此示例程序演示了如何使用WiFiServer库建立网络服务器。通过以下网址可以设置板载LED灯的状态http://server_ip/gpio/0将设置 LED_BUILTIN 引脚设置为低电平，http://server_ip/gpio/1将设置 LED_BUILTIN 引脚设置为高电平以上网址链接中的server_ip指的是ESP8266模块的IP地址。***********************************************************************/#include &lt;ESP8266WiFi.h&gt; //此处设置您的wifi接入信息#ifndef STASSID#define STASSID &quot;Taichi-Maker&quot;#define STAPSK  &quot;12345678&quot;#endif const char* ssid = STASSID;const char* password = STAPSK; //创建TCP server对象,并将端口指定为80WiFiServer server(80); void setup() &#123;  //打开串口  Serial.begin(115200);   //初始化板载LED  pinMode(LED_BUILTIN, OUTPUT);  digitalWrite(LED_BUILTIN, 0);   //连接WiFi  Serial.println();  Serial.println();  Serial.print(F(&quot;Connecting to &quot;));  Serial.println(ssid);   WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);   while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(F(&quot;.&quot;));  &#125;  Serial.println();  Serial.println(F(&quot;WiFi connected&quot;));   //启动TCP server服务器  server.begin();  Serial.println(F(&quot;Server started&quot;));   //打印IP地址  Serial.println(WiFi.localIP());&#125; void loop() &#123;  //检查客户端是否已连接  WiFiClient client = server.available();  if (!client) &#123;    return;  &#125;  Serial.println(F(&quot;new client&quot;));   client.setTimeout(5000); //默认为 1000   //读取客户端发起的TCP请求  String req = client.readStringUntil(&#x27;\r&#x27;);  Serial.println(F(&quot;request: &quot;));  Serial.println(req);   //解析请求里是否含有以下指定内容  int val;  //检查发起的请求内容是否包含&quot;/gpio/0&quot;  if (req.indexOf(F(&quot;/gpio/0&quot;)) != -1) &#123;    val = 0;     //检查发起的请求内容是否包含&quot;/gpio/1&quot;  &#125; else if (req.indexOf(F(&quot;/gpio/1&quot;)) != -1) &#123;    val = 1;  &#125; else &#123;    Serial.println(F(&quot;invalid request&quot;));    val = digitalRead(LED_BUILTIN);  &#125;   //根据要求设置板载LED状态  digitalWrite(LED_BUILTIN, val);   //读取剩余的内容,用于清除缓存  while (client.available()) &#123;    client.read();  &#125;   //将响应体发送到客户端 注:若要使用中文则必须在其中添加&lt;meta charset=\&quot;utf-8\&quot;&gt;声明编码  client.print(F(&quot;HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n&lt;!DOCTYPE HTML&gt;\r\n&lt;html&gt;\r\n&lt;meta charset=\&quot;utf-8\&quot;&gt;NodeMCU板载LED灯的状态 : &quot;));  client.print((val) ? F(&quot;关&quot;) : F(&quot;开&quot;));  client.print(F(&quot;&lt;br&gt;&lt;br&gt; &lt;a href=&#x27;http://&quot;));  client.print(WiFi.localIP());  client.print(F(&quot;/gpio/1&#x27;&gt;  点击关灯  &lt;/a&gt; , 或  &lt;a href=&#x27;http://&quot;));  client.print(WiFi.localIP());  client.print(F(&quot;/gpio/0&#x27;&gt;  点击开灯  &lt;/a&gt; &lt;/html&gt;&quot;));   //通过浏览器点击按钮之后,TCP连接将会被重置,并且浏览器会发起新的TCP请求到我们的8266服务器,从而去控制LED灯  Serial.println(F(&quot;Disconnecting from client&quot;));&#125;









setNoDelay – 停止小包合并发送说明此函数用于设置ESP8266服务器是否使用Nagle算法来将发送的信息先拆分成小包再发送。
使用Nagle算法来拆包发送的优点是可以将较大的数据信息拆分，从而让信息传输的网络利用率更加优化。但缺点是比起不拆包发送的模式来说，拆包发送的速度要慢一些。
语法server.setNoDelay(val)

参数val: 此参数类型为bool。以下是参数功能说明。

– true: 不使用Nagle算法来将发送的信息先拆分成小包再发送。
– false: 使用Nagle算法来将发送的信息先拆分成小包再发送。

返回值无
示例程序在以下的示例程序中，我们使用了语句server.setNoDelay(true);将发送的信息先拆分成小包再发送。
/**********************************************************************  程序名称/Program name     : WIFIServer_demo_2  程序目的/Purpose          :  此示例程序演示了如何使用WiFiServer库建立网络服务器。  通过以下网址可以设置板载LED灯的状态  http://server_ip/gpio/0将设置 LED_BUILTIN 引脚设置为低电平，  http://server_ip/gpio/1将设置 LED_BUILTIN 引脚设置为高电平  以上网址链接中的server_ip指的是ESP8266模块的IP地址。***********************************************************************/#include &lt;ESP8266WiFi.h&gt; //此处设置您的wifi接入信息#ifndef STASSID#define STASSID &quot;z&quot;#define STAPSK  &quot;18xxxxxx52&quot;#endif const char* ssid = STASSID;const char* password = STAPSK; //创建TCP server对象,并将端口指定为80WiFiServer server(80); void setup() &#123;  //打开串口  Serial.begin(115200);   //初始化板载LED  pinMode(LED_BUILTIN, OUTPUT);  digitalWrite(LED_BUILTIN, 0);   //连接WiFi  Serial.println();  Serial.println();  Serial.print(F(&quot;Connecting to &quot;));  Serial.println(ssid);   WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);   while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(F(&quot;.&quot;));  &#125;  Serial.println();  Serial.println(F(&quot;WiFi connected&quot;));   //启动TCP server服务器  server.begin();  Serial.println(F(&quot;Server started&quot;));   //停止小包合并发送  server.setNoDelay(true);    //打印TCP server状态码  Serial.print(F(&quot;server.status :&quot;));  Serial.println(server.status());    //打印IP地址  Serial.println(WiFi.localIP());&#125; void loop() &#123;  //检查客户端是否已连接  WiFiClient client = server.available();  if (!client) &#123;    return;  &#125;  Serial.println(F(&quot;new client&quot;));   client.setTimeout(5000); //默认为 1000   //打印TCP server状态码  Serial.print(F(&quot;server.status :&quot;));  Serial.println(server.status());    //读取客户端发起的TCP请求  String req = client.readStringUntil(&#x27;\r&#x27;);  Serial.println(F(&quot;request: &quot;));  Serial.println(req);   //解析请求里是否含有以下指定内容  int val;  //检查发起的请求内容是否包含&quot;/gpio/0&quot;  if (req.indexOf(F(&quot;/gpio/0&quot;)) != -1) &#123;    val = 0;     //检查发起的请求内容是否包含&quot;/gpio/1&quot;  &#125; else if (req.indexOf(F(&quot;/gpio/1&quot;)) != -1) &#123;    val = 1;  &#125; else &#123;    Serial.println(F(&quot;invalid request&quot;));    val = digitalRead(LED_BUILTIN);  &#125;   //根据要求设置板载LED状态  digitalWrite(LED_BUILTIN, val);   //读取剩余的内容,用于清除缓存  while (client.available()) &#123;    client.read();  &#125;   //将响应体发送到客户端 注:若要使用中文则必须在其中添加&lt;meta charset=\&quot;utf-8\&quot;&gt;声明编码  client.print(F(&quot;HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n&lt;!DOCTYPE HTML&gt;\r\n&lt;html&gt;\r\n&lt;meta charset=\&quot;utf-8\&quot;&gt;NodeMCU板载LED灯的状态 : &quot;));  client.print((val) ? F(&quot;关&quot;) : F(&quot;开&quot;));  client.print(F(&quot;&lt;br&gt;&lt;br&gt; &lt;a href=&#x27;http://&quot;));  client.print(WiFi.localIP());  client.print(F(&quot;/gpio/1&#x27;&gt;  点击关灯  &lt;/a&gt; , 或  &lt;a href=&#x27;http://&quot;));  client.print(WiFi.localIP());  client.print(F(&quot;/gpio/0&#x27;&gt;  点击开灯  &lt;/a&gt; &lt;/html&gt;&quot;));   //通过浏览器点击按钮之后,TCP连接将会被重置,并且浏览器会发起新的TCP请求到我们的8266服务器,从而去控制LED灯  Serial.println(F(&quot;Disconnecting from client&quot;)); &#125;







stop – 停止服务器说明本函数用于停止ESP8266开发板所建立的网络服务器。
注: stop函数和close函数功能相同。
语法server.stop()

参数无
返回值无
示例程序/**********************************************************************程序名称/Program name     : WIFIServer_demo_3_stop程序目的/Purpose          : 此示例程序演示了如何使用WiFiServer库建立网络服务器。服务器将根据浏览器请求设置板载LED灯的状态;http://server_ip/gpio/0将设置 LED_BUILTIN 拉低，http://server_ip/gpio/1将设置 LED_BUILTIN 拉高以上网址链接中的server_ip是ESP8266模块的IP地址，连接WiFi成功后将自动将ip打印在串口;在浏览器点击“关闭LED”3次之后关闭tcp server服务器。我们是通过以下程序中的server.stop()实现这一功能的。***********************************************************************/#include &lt;ESP8266WiFi.h&gt; //设置您的wifi接入信息#ifndef STASSID#define STASSID &quot;taichimaker&quot;#define STAPSK  &quot;12345678&quot;#endif const char* ssid = STASSID;const char* password = STAPSK; //创建TCP server对象,并将端口指定为80WiFiServer server(80); int server_stop_switch = 0 ; void setup() &#123;  //打开串口  Serial.begin(115200);   //初始化板载LED  pinMode(LED_BUILTIN, OUTPUT);  digitalWrite(LED_BUILTIN, 0);   //连接WiFi  Serial.println();  Serial.println();  Serial.print(F(&quot;Connecting to &quot;));  Serial.println(ssid);   WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);   while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(F(&quot;.&quot;));  &#125;  Serial.println();  Serial.println(F(&quot;WiFi connected&quot;));   //启动TCP server服务器  server.begin();  Serial.println(F(&quot;Server started&quot;));   //打印IP地址  Serial.println(WiFi.localIP());&#125; void loop() &#123;  //检查客户端是否已连接  WiFiClient client = server.available();  if (!client) &#123;    return;  &#125;  Serial.println(F(&quot;new client&quot;));   client.setTimeout(5000); //默认为 1000   //读取客户端发起的TCP请求  String req = client.readStringUntil(&#x27;\r&#x27;);  Serial.println(F(&quot;request: &quot;));  Serial.println(req);   int val;    //通过浏览器请求控制LED  if (req.indexOf(F(&quot;/gpio/0&quot;)) != -1) &#123;    val = 0;  &#125; else if (req.indexOf(F(&quot;/gpio/1&quot;)) != -1) &#123;    val = 1;    server_stop_switch++;  &#125; else &#123;    Serial.println(F(&quot;invalid request&quot;));    val = digitalRead(LED_BUILTIN);  &#125;   //根据要求设置板载LED状态  digitalWrite(LED_BUILTIN, val);   //读取剩余的内容,用于清除缓存  while (client.available()) &#123;    client.read();  &#125;   //将响应体发送到客户端 注:若要使用中文则必须在其中添加&lt;meta charset=\&quot;utf-8\&quot;&gt;声明编码  client.print(F(&quot;HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n&lt;!DOCTYPE HTML&gt;\r\n&lt;html&gt;\r\n&lt;meta charset=\&quot;utf-8\&quot;&gt;NodeMCU板载LED灯的状态 : &quot;));  client.print((val) ? F(&quot;关&quot;) : F(&quot;开&quot;));  client.print(F(&quot;&lt;br&gt;&lt;br&gt; &lt;a href=&#x27;http://&quot;));  client.print(WiFi.localIP());  client.print(F(&quot;/gpio/1&#x27;&gt;  点击关灯（关灯3次后将会关闭服务器）&lt;/a&gt; , 或  &lt;a href=&#x27;http://&quot;));  client.print(WiFi.localIP());  client.print(F(&quot;/gpio/0&#x27;&gt;  点击开灯 &lt;/a&gt; &lt;/html&gt;&quot;));   //通过浏览器点击按钮之后,TCP连接将会被重置,并且浏览器会发起新的TCP请求到我们的8266服务器,从而去控制LED灯  Serial.println(F(&quot;Disconnecting from client&quot;));   //  如果 server_stop_switch &gt;= 3 时则关闭TCP server  if (server_stop_switch &gt;= 3) &#123;    Serial.println(F(&quot;TCP server turn off &quot;));    server.stop();  &#125;&#125;



close – 停止服务器说明本函数用于停止ESP8266开发板所建立的网络服务器。
注: close函数和stop函数功能相同。
语法server.close()
参数无
返回值无
示例程序/**********************************************************************程序名称/Program name     : WIFIServer_demo_3_close程序目的/Purpose          : 此示例程序演示了如何使用WiFiServer库建立网络服务器。服务器将根据浏览器请求设置板载LED灯的状态;http://server_ip/gpio/0将设置 LED_BUILTIN 拉低，http://server_ip/gpio/1将设置 LED_BUILTIN 拉高以上网址链接中的server_ip是ESP8266模块的IP地址，连接WiFi成功后将自动将ip打印在串口;在浏览器点击“关闭LED”3次之后关闭tcp server服务器。我们是通过以下程序中的server.close()实现这一功能的。***********************************************************************/#include &lt;ESP8266WiFi.h&gt; //设置您的wifi接入信息#ifndef STASSID#define STASSID &quot;taichimaker&quot;#define STAPSK  &quot;12345678&quot;#endif const char* ssid = STASSID;const char* password = STAPSK; //创建TCP server对象,并将端口指定为80WiFiServer server(80); int server_stop_switch = 0 ; void setup() &#123;  //打开串口  Serial.begin(115200);   //初始化板载LED  pinMode(LED_BUILTIN, OUTPUT);  digitalWrite(LED_BUILTIN, 0);   //连接WiFi  Serial.println();  Serial.println();  Serial.print(F(&quot;Connecting to &quot;));  Serial.println(ssid);   WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);   while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(F(&quot;.&quot;));  &#125;  Serial.println();  Serial.println(F(&quot;WiFi connected&quot;));   //启动TCP server服务器  server.begin();  Serial.println(F(&quot;Server started&quot;));   //打印IP地址  Serial.println(WiFi.localIP());&#125; void loop() &#123;  //检查客户端是否已连接  WiFiClient client = server.available();  if (!client) &#123;    return;  &#125;  Serial.println(F(&quot;new client&quot;));   client.setTimeout(5000); //默认为 1000   //读取客户端发起的TCP请求  String req = client.readStringUntil(&#x27;\r&#x27;);  Serial.println(F(&quot;request: &quot;));  Serial.println(req);   int val;    //通过浏览器请求控制LED  if (req.indexOf(F(&quot;/gpio/0&quot;)) != -1) &#123;    val = 0;  &#125; else if (req.indexOf(F(&quot;/gpio/1&quot;)) != -1) &#123;    val = 1;    server_stop_switch++;  &#125; else &#123;    Serial.println(F(&quot;invalid request&quot;));    val = digitalRead(LED_BUILTIN);  &#125;   //根据要求设置板载LED状态  digitalWrite(LED_BUILTIN, val);   //读取剩余的内容,用于清除缓存  while (client.available()) &#123;    client.read();  &#125;   //将响应体发送到客户端 注:若要使用中文则必须在其中添加&lt;meta charset=\&quot;utf-8\&quot;&gt;声明编码  client.print(F(&quot;HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n&lt;!DOCTYPE HTML&gt;\r\n&lt;html&gt;\r\n&lt;meta charset=\&quot;utf-8\&quot;&gt;NodeMCU板载LED灯的状态 : &quot;));  client.print((val) ? F(&quot;关&quot;) : F(&quot;开&quot;));  client.print(F(&quot;&lt;br&gt;&lt;br&gt; &lt;a href=&#x27;http://&quot;));  client.print(WiFi.localIP());  client.print(F(&quot;/gpio/1&#x27;&gt;  点击关灯（关灯3次后将会关闭服务器）&lt;/a&gt; , 或  &lt;a href=&#x27;http://&quot;));  client.print(WiFi.localIP());  client.print(F(&quot;/gpio/0&#x27;&gt;  点击开灯 &lt;/a&gt; &lt;/html&gt;&quot;));   //通过浏览器点击按钮之后,TCP连接将会被重置,并且浏览器会发起新的TCP请求到我们的8266服务器,从而去控制LED灯  Serial.println(F(&quot;Disconnecting from client&quot;));   //  如果 server_stop_switch &gt;= 3 时则关闭TCP server  if (server_stop_switch &gt;= 3) &#123;    Serial.println(F(&quot;TCP server turn off &quot;));    server.close();  &#125;&#125;









服务器信息类型status – 获取服务器运行状态说明此函数用于获取ESP8266服务器的工作状态。工作状态信息将以”状态值”形式返回。
如需了解具体状态信息内容，请参考本页面的返回值部分。
语法server.status()

参数无
返回值服务器状态值(类型：uint8_t)。以下是状态值所对应的数值说明。

CLOSED &#x3D; 0 （关闭连接）
LISTEN &#x3D; 1 （监听）
SYN_SENT &#x3D; 2
SYN_RCVD &#x3D; 3
ESTABLISHED &#x3D; 4 （建立连接）
FIN_WAIT_1 &#x3D; 5
FIN_WAIT_2 &#x3D; 6
CLOSE_WAIT &#x3D; 7 （关闭连接等待）
CLOSING &#x3D; 8 （关闭连接中）
LAST_ACK &#x3D; 9
TIME_WAIT &#x3D; 10

示例程序/**********************************************************************  程序名称/Program name     : WIFIServer_demo_4  程序目的/Purpose          :  此示例程序演示了如何使用WiFiServer库建立网络服务器。通过以下网址可以设置板载LED灯的状态  http://server_ip/gpio/0将设置 LED_BUILTIN 引脚设置为低电平，  http://server_ip/gpio/1将设置 LED_BUILTIN 引脚设置为高电平  以上网址链接中的server_ip指的是ESP8266模块的IP地址。  在程序运行中同时会将ESP8266的状态码通过串口监视器显示。我们使用了server.status来获取这一信息。***********************************************************************/#include &lt;ESP8266WiFi.h&gt; //此处设置您的wifi接入信息#ifndef STASSID#define STASSID &quot;taichimaker&quot;#define STAPSK  &quot;12345678&quot;#endif const char* ssid = STASSID;const char* password = STAPSK; //创建TCP server对象,并将端口指定为80WiFiServer server(80); void setup() &#123;  //打开串口  Serial.begin(115200);   //初始化板载LED  pinMode(LED_BUILTIN, OUTPUT);  digitalWrite(LED_BUILTIN, 0);   //连接WiFi  Serial.println();  Serial.println();  Serial.print(F(&quot;Connecting to &quot;));  Serial.println(ssid);   WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);   while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(F(&quot;.&quot;));  &#125;  Serial.println();  Serial.println(F(&quot;WiFi connected&quot;));   //启动TCP server服务器  server.begin();  Serial.println(F(&quot;Server started&quot;));   //打印TCP server状态码  Serial.print(F(&quot;server.status :&quot;));  Serial.println(server.status());   //打印IP地址  Serial.println(WiFi.localIP());&#125; void loop() &#123;  //检查客户端是否已连接  WiFiClient client = server.available();  if (!client) &#123;    return;  &#125;  Serial.println(F(&quot;new client&quot;));   client.setTimeout(5000); //默认为 1000   //打印TCP server状态码  Serial.print(F(&quot;server.status :&quot;));  Serial.println(server.status());   //读取客户端发起的TCP请求  String req = client.readStringUntil(&#x27;\r&#x27;);  Serial.println(F(&quot;request: &quot;));  Serial.println(req);   //解析请求里是否含有以下指定内容  int val;  //检查发起的请求内容是否包含&quot;/gpio/0&quot;  if (req.indexOf(F(&quot;/gpio/0&quot;)) != -1) &#123;    val = 0;     //检查发起的请求内容是否包含&quot;/gpio/1&quot;  &#125; else if (req.indexOf(F(&quot;/gpio/1&quot;)) != -1) &#123;    val = 1;  &#125; else &#123;    Serial.println(F(&quot;invalid request&quot;));    val = digitalRead(LED_BUILTIN);  &#125;   //根据要求设置板载LED状态  digitalWrite(LED_BUILTIN, val);   //读取剩余的内容,用于清除缓存  while (client.available()) &#123;    client.read();  &#125;   //将响应体发送到客户端 注:若要使用中文则必须在其中添加&lt;meta charset=\&quot;utf-8\&quot;&gt;声明编码  client.print(F(&quot;HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n&lt;!DOCTYPE HTML&gt;\r\n&lt;html&gt;\r\n&lt;meta charset=\&quot;utf-8\&quot;&gt;NodeMCU板载LED灯的状态 : &quot;));  client.print((val) ? F(&quot;关&quot;) : F(&quot;开&quot;));  client.print(F(&quot;&lt;br&gt;&lt;br&gt; &lt;a href=&#x27;http://&quot;));  client.print(WiFi.localIP());  client.print(F(&quot;/gpio/1&#x27;&gt;  点击关灯  &lt;/a&gt; , 或  &lt;a href=&#x27;http://&quot;));  client.print(WiFi.localIP());  client.print(F(&quot;/gpio/0&#x27;&gt;  点击开灯  &lt;/a&gt; &lt;/html&gt;&quot;));   //通过浏览器点击按钮之后,TCP连接将会被重置,并且浏览器会发起新的TCP请求到我们的8266服务器,从而去控制LED灯  Serial.println(F(&quot;Disconnecting from client&quot;));&#125;



hasClient – 判断是否有客户端访问说明本函数用于检查是否有客户端访问ESP8266开发板所建立的网络服务器。
语法server.hasClient()
参数无
返回值返回值类型为bool。当检查到有客户端访问ESP8266开发板所建立的网络服务器，则返回true，否则返回false。
示例程序/**********************************************************************  程序名称/Program name     : WIFIServer_demo_5  程序目的/Purpose          :  此示例程序演示了如何使用WiFiServer库建立网络服务器。通过以下网址可以设置板载LED灯的状态  http://server_ip/gpio/0将设置 LED_BUILTIN 引脚设置为低电平，  http://server_ip/gpio/1将设置 LED_BUILTIN 引脚设置为高电平  以上网址链接中的server_ip指的是ESP8266模块的IP地址。  本程序使用了server.hasClient函数来判断是否有客户端与服务器产生连接。***********************************************************************/#include &lt;ESP8266WiFi.h&gt; //此处设置您的wifi接入信息#ifndef STASSID#define STASSID &quot;taichimaker&quot;#define STAPSK  &quot;12345678&quot;#endif const char* ssid = STASSID;const char* password = STAPSK; //创建TCP server对象,并将端口指定为80WiFiServer server(80); void setup() &#123;  //打开串口  Serial.begin(115200);   //初始化板载LED  pinMode(LED_BUILTIN, OUTPUT);  digitalWrite(LED_BUILTIN, 0);   //连接WiFi  Serial.println();  Serial.println();  Serial.print(F(&quot;Connecting to &quot;));  Serial.println(ssid);   WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);   while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(F(&quot;.&quot;));  &#125;  Serial.println();  Serial.println(F(&quot;WiFi connected&quot;));   //启动TCP server服务器  server.begin();  Serial.println(F(&quot;Server started&quot;));   //停止小包合并发送,停止之后,消息会直接发送,不会延时  server.setNoDelay(true);   //打印TCP server状态码  Serial.print(F(&quot;server.status :&quot;));  Serial.println(server.status());    //打印IP地址  Serial.println(WiFi.localIP());&#125; void loop() &#123;  //使用server.hasClient()来确保有效的TCP连接  if (server.hasClient()) &#123;    //检查客户端是否已连接    WiFiClient client = server.available();    if (!client) &#123;      return;    &#125;    Serial.println(F(&quot;new client&quot;));     client.setTimeout(5000); //默认为 1000     //打印TCP server状态码    Serial.print(F(&quot;server.status :&quot;));    Serial.println(server.status());      //读取客户端发起的TCP请求    String req = client.readStringUntil(&#x27;\r&#x27;);    Serial.println(F(&quot;request: &quot;));    Serial.println(req);     //解析请求里是否含有以下指定内容    int val;    //检查发起的请求内容是否包含&quot;/gpio/0&quot;    if (req.indexOf(F(&quot;/gpio/0&quot;)) != -1) &#123;      val = 0;       //检查发起的请求内容是否包含&quot;/gpio/1&quot;    &#125; else if (req.indexOf(F(&quot;/gpio/1&quot;)) != -1) &#123;      val = 1;    &#125; else &#123;      Serial.println(F(&quot;invalid request&quot;));      val = digitalRead(LED_BUILTIN);    &#125;     //根据要求设置板载LED状态    digitalWrite(LED_BUILTIN, val);     //读取剩余的内容,用于清除缓存    while (client.available()) &#123;      client.read();    &#125;     //将响应体发送到客户端 注:若要使用中文则必须在其中添加&lt;meta charset=\&quot;utf-8\&quot;&gt;声明编码    client.print(F(&quot;HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n&lt;!DOCTYPE HTML&gt;\r\n&lt;html&gt;\r\n&lt;meta charset=\&quot;utf-8\&quot;&gt;NodeMCU板载LED灯的状态 : &quot;));    client.print((val) ? F(&quot;关&quot;) : F(&quot;开&quot;));    client.print(F(&quot;&lt;br&gt;&lt;br&gt; &lt;a href=&#x27;http://&quot;));    client.print(WiFi.localIP());    client.print(F(&quot;/gpio/1&#x27;&gt;  点击关灯  &lt;/a&gt; , 或  &lt;a href=&#x27;http://&quot;));    client.print(WiFi.localIP());    client.print(F(&quot;/gpio/0&#x27;&gt;  点击开灯  &lt;/a&gt; &lt;/html&gt;&quot;));     //通过浏览器点击按钮之后,TCP连接将会被重置,并且浏览器会发起新的TCP请求到我们的8266服务器,从而去控制LED灯    Serial.println(F(&quot;Disconnecting from client&quot;));  &#125;&#125;





ESP8266 – ESP8266HTTPClient库ESP8266HTTPClient库用于HTTP协议通讯。通过ESP8266HTTPClient库，我们可以使用ESP8266利用互联网或局域网向网络服务器发送HTTP请求，并且分析网络服务器返回的HTTP响应信息，从而实现物联网应用。
ESP8266库中还有一个专门用于TCP通讯的WiFiClient库。由于HTTP协议是建立在TCP协议基础之上的，我们也可以使用WiFiClient库来实现HTTP通讯。在这一点上，ESP8266HTTPClient库与WiFiClient库在功能上形成了互补。
以下为ESP8266HTTPClient库的整体结构图。

请求类型请求信息类型begin – 设置请求URL说明物联网应用中，我们经常使用ESP8266通过HTTP协议向网络服务器发送HTTP请求。本函数用于设置ESP8266发送HTTP请求的目标URL。
语法httpClient.begin(url)httpClient.begin(url, port)
参数url: HTTP请求网址port: HTTP请求的网络服务器端口 (此参数为可选参数，默认为端口80)
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求并通过串口监视器将网站服务器响应信息通过串口监视器显示出来。
/**********************************************************************  程序名称/Program name     : HTTPClient_begin  程序目的/Purpose          :  此程序用于演示如何使用ESP8266来向www.example.com网站服务器发送HTTP请求并通过串口  监视器将网站服务器响应信息通过串口监视器显示出来。***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt; // 测试HTTP请求用的URL#define URL &quot;http://www.example.com&quot; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichimaker&quot;;const char* password = &quot;12345678&quot;; void setup() &#123;  //初始化串口设置  Serial.begin(9600);   //设置ESP8266工作模式为无线终端模式  WiFi.mode(WIFI_STA);   //开始连接wifi  WiFi.begin(ssid, password);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(1000);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;WiFi Connected!&quot;);&#125; void loop() &#123;  // 如果ESP8266连接WiFi则发送HTTP请求  if ((WiFi.status() == WL_CONNECTED)) &#123;    esp8266Http();  &#125;    delay(5000);   // 短暂等待&#125; // 发送HTTP请求并且将服务器响应通过串口输出void esp8266Http()&#123;   //创建 HTTPClient 对象  HTTPClient httpClient;   //配置请求地址。此处也可以不使用端口号和PATH而单纯的  httpClient.begin(URL);   Serial.print(&quot;URL: &quot;); Serial.println(URL);   //启动连接并发送HTTP请求  int httpCode = httpClient.GET();  Serial.print(&quot;Send GET request to URL: &quot;);  Serial.println(URL);    //如果服务器响应OK则从服务器获取响应体信息并通过串口输出  //如果服务器不响应OK则将服务器响应状态码通过串口输出  if (httpCode == HTTP_CODE_OK) &#123;    String responsePayload = httpClient.getString();    Serial.println(&quot;Server Response Payload: &quot;);    Serial.println(responsePayload);  &#125; else &#123;    Serial.println(&quot;Server Respose Code：&quot;);    Serial.println(httpCode);  &#125;   //关闭ESP8266与服务器连接  httpClient.end();&#125;

相关内容— GET— end – 结束请求
setReuse – 设置请求头中的keep-alive说明此函数用于设置ESP8266开发板在通过HTTP发送请求时，请求头中的keep-alive是否为”true”。
HTTP keep-alive 也称为 HTTP 长连接。它通过重用一个 TCP 连接来发送&#x2F;接收多个 HTTP请求，来减少创建&#x2F;关闭多个 TCP 连接的开销。
如果设置 keep-alive为true，则服务端在返回 response 后不关闭 TCP 连接；同样的，在接收完响应报文后，客户端也不关闭连接，发送下一个 HTTP 请求时会重用该连接。
语法httpClient.setReuse（true）httpClient.setReuse（false）
参数返回值类型为布尔型。返回值的简要说明如下：true: 启用请求头中的keep-alivefalse: 禁用请求头中的keep-alive
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
您将以下示例程序的WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求并通过串口监视器将网站服务器响应信息通过串口监视器显示出来。
以下是本程序控制下，ESP8266发送的HTTP请求信息：
/**********************************************************************  程序名称/Program name     : HTTPClient_setReuse  程序目的/Purpose          :  此程序用于演示如何使用ESP8266来向www.example.com网站服务器发送HTTP请求并通过串口  监视器将网站服务器响应信息通过串口监视器显示出来。  程序使用了setReuse函数来设置请求头中的keep-alive。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt; // 测试HTTP请求用的URL#define URL &quot;http://www.example.com&quot; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichimaker&quot;;const char* password = &quot;12345678&quot;; void setup() &#123;  //初始化串口设置  Serial.begin(9600);   //设置ESP8266工作模式为无线终端模式  WiFi.mode(WIFI_STA);   //开始连接wifi  WiFi.begin(ssid, password);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(1000);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.println(&quot;WiFi Connected!&quot;);&#125; void loop() &#123;  // 如果ESP8266连接WiFi则发送HTTP请求  if ((WiFi.status() == WL_CONNECTED)) &#123;    esp8266Http();  &#125;    delay(5000);   // 短暂等待&#125; // 发送HTTP请求并且将服务器响应通过串口输出void esp8266Http()&#123;   //创建 HTTPClient 对象  HTTPClient httpClient;   //配置请求地址。此处也可以不使用端口号和PATH而单纯的  httpClient.begin(URL);   Serial.print(&quot;URL: &quot;); Serial.println(URL);   //设置请求头中的keep-alive  httpClient.setReuse(true);   //启动连接并发送HTTP请求  int httpCode = httpClient.GET();  Serial.print(&quot;Send GET request to URL: &quot;);  Serial.println(URL);    //如果服务器响应OK则从服务器获取响应体信息并通过串口输出  //如果服务器不响应OK则将服务器响应状态码通过串口输出  if (httpCode == HTTP_CODE_OK) &#123;    String responsePayload = httpClient.getString();    Serial.println(&quot;Server Response Payload: &quot;);    Serial.println(responsePayload);  &#125; else &#123;    Serial.println(&quot;Server Respose Code：&quot;);    Serial.println(httpCode);  &#125;   //关闭ESP8266与服务器连接  httpClient.end();&#125;

相关内容— begin – 设置请求URL— setUserAgent – 设置请求头中的User-Agent— setAuthorization – 设置请求头中的Authorization— addHeader – 请求头中添加自定义信息— useHTTP10 – 设置http协议版本
setUserAgent – 设置请求头中的User-Agent说明ESP8266开发板在通过HTTP发送请求时，我们可以使用此函数设置请求头的User-Agent内容。
User Agent请求头的作用是让服务器能够识别客户端使用的操作系统及版本、客户端设备的CPU类型、浏览器名称和版本、浏览器所用的语言、浏览器所用的插件等。换句话说,就是告诉服务端现在是什么设备在访问服务器。
语法httpClient.setUserAgent（device_info）

参数– device_info : 用户自定义的客户端标识– 参数类型: 字符串 或 const char *
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
您将以下示例程序的WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求并通过串口监视器将网站服务器响应信息通过串口监视器显示出来。
以下是本程序控制下，ESP8266发送的HTTP请求信息：
GET / HTTP/1.1Host: 192.168.0.110User-Agent: ESP8266Connection: keep-aliveAccept-Encoding: identity;q=1,chunked;q=0.1,*;q=0Content-Length: 0

其中User-Agent: ESP8266部分即是通过以下程序中的httpClient.setUserAgent(&quot;ESP8266&quot;);来实现的。
/**********************************************************************  程序名称/Program name     : HTTPClient_setReuse  程序目的/Purpose          :  此程序用于演示如何使用ESP8266来向www.example.com网站服务器发送HTTP请求并通过串口  监视器将网站服务器响应信息通过串口监视器显示出来。  程序使用了setUserAgent函数来设置请求头中的客户端信息。***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt; // 测试HTTP请求用的URL#define URL &quot;http://www.example.com&quot; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichimaker&quot;;const char* password = &quot;12345678&quot;; void setup() &#123;  //初始化串口设置  Serial.begin(9600);   //设置ESP8266工作模式为无线终端模式  WiFi.mode(WIFI_STA);   //开始连接wifi  WiFi.begin(ssid, password);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(1000);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.println(&quot;WiFi Connected!&quot;);&#125; void loop() &#123;  // 如果ESP8266连接WiFi则发送HTTP请求  if ((WiFi.status() == WL_CONNECTED)) &#123;    esp8266Http();  &#125;    delay(5000);   // 短暂等待&#125; // 发送HTTP请求并且将服务器响应通过串口输出void esp8266Http()&#123;   //创建 HTTPClient 对象  HTTPClient httpClient;   //配置请求地址。此处也可以不使用端口号和PATH而单纯的  httpClient.begin(URL);   Serial.print(&quot;URL: &quot;); Serial.println(URL);   //设置请求头中的User-Agent  httpClient.setUserAgent(&quot;ESP8266&quot;);   //启动连接并发送HTTP请求  int httpCode = httpClient.GET();  Serial.print(&quot;Send GET request to URL: &quot;);  Serial.println(URL);    //如果服务器响应OK则从服务器获取响应体信息并通过串口输出  //如果服务器不响应OK则将服务器响应状态码通过串口输出  if (httpCode == HTTP_CODE_OK) &#123;    String responsePayload = httpClient.getString();    Serial.println(&quot;Server Response Payload: &quot;);    Serial.println(responsePayload);  &#125; else &#123;    Serial.println(&quot;Server Respose Code：&quot;);    Serial.println(httpCode);  &#125;   //关闭ESP8266与服务器连接  httpClient.end();&#125;

相关内容— begin – 设置请求URL— setReuse – 设置请求头中的keep-alive— setAuthorization – 设置请求头中的Authorization— addHeader – 请求头中添加自定义信息— useHTTP10 – 设置http协议版本
setAuthorization – 设置请求头中的Authorization说明此函数用于设置ESP8266开发板在通过HTTP发送请求时，设置请求头中的Authorization部分。
语法httpClient.setAuthorization(user,password)

参数user: 设备进行访问的用户名请求头信息
password: 设备进行访问的密码请求头信息
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
您将以下示例程序的WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求并通过串口监视器将网站服务器响应信息通过串口监视器显示出来。
以下是本程序控制下，ESP8266发送的HTTP请求信息：
GET / HTTP/1.1Host: www.example.comUser-Agent: ESP8266HTTPClientConnection: keep-aliveAccept-Encoding: identity;q=1,chunked;q=0.1,*;q=0Authorization: Basic VGFpY2hpTWFrZXI6MTIzNDU2Nzg=Content-Length: 0

其中Authorization: Basic VGFpY2hpTWFrZXI6MTIzNDU2Nzg=部分即是通过以下程序中的httpClient.setUserAgent(“TaichiMaker”, &quot;12345678&quot;);来实现的。(www.example.com网站不需要认证即可访问，此示例程序仅仅是为了演示如何使用setUserAgent。)
/**********************************************************************  程序名称/Program name     : HTTPClient_setReuse  程序目的/Purpose          :  此程序用于演示如何使用ESP8266来向www.example.com网站服务器发送HTTP请求并通过串口  监视器将网站服务器响应信息通过串口监视器显示出来。  程序使用了setUserAgent函数来将ESP8266发送的HTTP请求头中Authorization部分  的user信息设置为&quot;TaichiMaker&quot;，password部分设置为&quot;12345678&quot;。***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt; // 测试HTTP请求用的URL#define URL &quot;http://www.example.com&quot; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichimaker&quot;;const char* password = &quot;12345678&quot;; void setup() &#123;  //初始化串口设置  Serial.begin(9600);   //设置ESP8266工作模式为无线终端模式  WiFi.mode(WIFI_STA);   //开始连接wifi  WiFi.begin(ssid, password);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(1000);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.println(&quot;WiFi Connected!&quot;);&#125; void loop() &#123;  // 如果ESP8266连接WiFi则发送HTTP请求  if ((WiFi.status() == WL_CONNECTED)) &#123;    esp8266Http();  &#125;    delay(5000);   // 短暂等待&#125; // 发送HTTP请求并且将服务器响应通过串口输出void esp8266Http()&#123;   //创建 HTTPClient 对象  HTTPClient httpClient;   //配置请求地址。此处也可以不使用端口号和PATH而单纯的  httpClient.begin(URL);   Serial.print(&quot;URL: &quot;); Serial.println(URL);   //设置请求头中的Authorization信息  httpClient.setAuthorization(&quot;TaichiMaker&quot;, &quot;12345678&quot;);   //启动连接并发送HTTP请求  int httpCode = httpClient.GET();  Serial.print(&quot;Send GET request to URL: &quot;);  Serial.println(URL);    //如果服务器响应OK则从服务器获取响应体信息并通过串口输出  //如果服务器不响应OK则将服务器响应状态码通过串口输出  if (httpCode == HTTP_CODE_OK) &#123;    String responsePayload = httpClient.getString();    Serial.println(&quot;Server Response Payload: &quot;);    Serial.println(responsePayload);  &#125; else &#123;    Serial.println(&quot;Server Respose Code：&quot;);    Serial.println(httpCode);  &#125;   //关闭ESP8266与服务器连接  httpClient.end();&#125;

相关内容— begin – 设置请求URL— setReuse – 设置请求头中的keep-alive— setUserAgent – 设置请求头中的User-Agent— addHeader – 请求头中添加自定义信息— useHTTP10 – 设置http协议版本
addHeader – 请求头中添加自定义信息说明使用此函数，我们可以ESP8266开发板发起HTTP请求的时候,添加自定义的请求头信息。
语法http.addHeader(name,value)

参数name: 自定义请求头名称 (类型：String 或 const char *)value: 自定义请求头参数值 (类型：String 或 const char *)
注：自定义请求头不能使用Connection、User-Agent、Host、Authorization等标准请求头名称。
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
您将以下示例程序的WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求并通过串口监视器将网站服务器响应信息通过串口监视器显示出来。
以下是本程序控制下，ESP8266发送的HTTP请求信息：
GET / HTTP/1.1Host: www.example.comUser-Agent: ESP8266HTTPClientConnection: keep-aliveAccept-Encoding: identity;q=1,chunked;q=0.1,*;q=0Device: ESP8266Content-Length: 0

其中Device: ESP8266部分即是通过以下程序中的httpClient.addHeader(&quot;Device&quot;, &quot;ESP8266&quot;);来实现的。
/**********************************************************************  程序名称/Program name     : HTTPClient_addHeader  程序目的/Purpose          :  此程序用于演示如何使用ESP8266来向www.example.com网站服务器发送HTTP请求并通过串口  监视器将网站服务器响应信息通过串口监视器显示出来。  程序使用了addHeader函数来将ESP8266发送的HTTP请求头中假如自定义信息***********************************************************************/ #include #include  // 测试HTTP请求用的URL#define URL &quot;http://www.example.com&quot; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichimaker&quot;;const char* password = &quot;12345678&quot;; void setup() &#123;  //初始化串口设置  Serial.begin(9600);   //设置ESP8266工作模式为无线终端模式  WiFi.mode(WIFI_STA);   //开始连接wifi  WiFi.begin(ssid, password);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(1000);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.println(&quot;WiFi Connected!&quot;);&#125; void loop() &#123;  // 如果ESP8266连接WiFi则发送HTTP请求  if ((WiFi.status() == WL_CONNECTED)) &#123;    esp8266Http();  &#125;    delay(5000);   // 短暂等待&#125; // 发送HTTP请求并且将服务器响应通过串口输出void esp8266Http()&#123;   //创建 HTTPClient 对象  HTTPClient httpClient;   //配置请求地址。此处也可以不使用端口号和PATH而单纯的  httpClient.begin(URL);   Serial.print(&quot;URL: &quot;); Serial.println(URL);   //设置请求头中自定义信息  httpClient.addHeader(&quot;Device&quot;, &quot;ESP8266&quot;);   //启动连接并发送HTTP请求  int httpCode = httpClient.GET();  Serial.print(&quot;Send GET request to URL: &quot;);  Serial.println(URL);    //如果服务器响应OK则从服务器获取响应体信息并通过串口输出  //如果服务器不响应OK则将服务器响应状态码通过串口输出  if (httpCode == HTTP_CODE_OK) &#123;    String responsePayload = httpClient.getString();    Serial.println(&quot;Server Response Payload: &quot;);    Serial.println(responsePayload);  &#125; else &#123;    Serial.println(&quot;Server Respose Code：&quot;);    Serial.println(httpCode);  &#125;   //关闭ESP8266与服务器连接  httpClient.end();&#125;

相关内容— begin – 设置请求URL— setReuse – 设置请求头中的keep-alive— setUserAgent – 设置请求头中的User-Agent— setAuthorization – 设置请求头中的Authorization— useHTTP10 – 设置http协议版本
useHTTP10 – 设置http协议版本说明此函数用于设置ESP8266开发板在通过HTTP发送请求时使用的HTTP协议版本。
语法http.useHTTP10(val)
参数val: 控制HTTTP版本。默认情况下，设备时使用HTTTP 1.1 版本。当此参数为true时，则使用HTTTP 1.0版本。false时，使用HTTTP 1.1版本。（参数类型：bool）
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
您将以下示例程序的WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求并通过串口监视器将网站服务器响应信息通过串口监视器显示出来。
以下是本程序控制下，ESP8266发送的HTTP请求信息：
GET / HTTP/1.0Host: www.example.comUser-Agent: ESP8266HTTPClientConnection: closeContent-Length: 0

其中GET / HTTP/1.0部分即是通过以下程序中的httpClient.useHTTP10(true);来实现的。
/**********************************************************************  程序名称/Program name     : HTTPClient_http10  程序目的/Purpose          :  此程序用于演示如何使用ESP8266来向www.example.com网站服务器发送HTTP请求并通过串口  监视器将网站服务器响应信息通过串口监视器显示出来。  程序使用了useHTTP10函数来将ESP8266发送的HTTP请求版本设置为1.0版本***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt; // 测试HTTP请求用的URL#define URL &quot;http://www.example.com&quot; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichimaker&quot;;const char* password = &quot;12345678&quot;; void setup() &#123;  //初始化串口设置  Serial.begin(9600);   //设置ESP8266工作模式为无线终端模式  WiFi.mode(WIFI_STA);   //开始连接wifi  WiFi.begin(ssid, password);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(1000);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.println(&quot;WiFi Connected!&quot;);&#125; void loop() &#123;  // 如果ESP8266连接WiFi则发送HTTP请求  if ((WiFi.status() == WL_CONNECTED)) &#123;    esp8266Http();  &#125;    delay(5000);   // 短暂等待&#125; // 发送HTTP请求并且将服务器响应通过串口输出void esp8266Http()&#123;   //创建 HTTPClient 对象  HTTPClient httpClient;   //配置请求地址。此处也可以不使用端口号和PATH而单纯的  httpClient.begin(URL);   Serial.print(&quot;URL: &quot;); Serial.println(URL);   //使用http1.0  httpClient.useHTTP10(true);   //启动连接并发送HTTP请求  int httpCode = httpClient.GET();  Serial.print(&quot;Send GET request to URL: &quot;);  Serial.println(URL);    //如果服务器响应OK则从服务器获取响应体信息并通过串口输出  //如果服务器不响应OK则将服务器响应状态码通过串口输出  if (httpCode == HTTP_CODE_OK) &#123;    String responsePayload = httpClient.getString();    Serial.println(&quot;Server Response Payload: &quot;);    Serial.println(responsePayload);  &#125; else &#123;    Serial.println(&quot;Server Respose Code：&quot;);    Serial.println(httpCode);  &#125;   //关闭ESP8266与服务器连接  httpClient.end();&#125;



请求方法类型GET说明此函数用于ESP8266使用HTTP协议通过网络向服务器发送GET请求。
客户端与服务器通讯时最常被用到的方法是：GET 和 POST。– GET – 从指定的资源请求数据。– POST – 向指定的资源提交要被处理的数据
语法http.GET()

参数无
返回值服务器状态码（返回值类型：int类型）
以下是常见的HTTP状态码（以下括号中内容为ESP8266HTTPClient库声明定义的HTTP状态码替代文字，具体内容可参考ESP8266库ESP8266HTTPClient.h文件中相应内容）：– 200: 请求成功 （HTTP_CODE_OK）– 301: 资源（网页等）被永久转移到其它URL (HTTP_CODE_MOVED_PERMANENTLY)– 404: 请求的资源（网页等）不存在(HTTP_CODE_NOT_FOUND)– 500: 内部服务器错误(HTTP_CODE_INTERNAL_SERVER_ERROR)
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
您将以下示例程序的WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求并通过串口监视器将网站服务器响应信息通过串口监视器显示出来。
以下是本程序控制下，ESP8266发送的HTTP请求信息：
ArduinoGET / HTTP/1.1Host: www.example.comUser-Agent: ESP8266HTTPClientConnection: keep-aliveAccept-Encoding: identity;q=1,chunked;q=0.1,*;q=0Content-Length: 0

其中HTTP请求方法GET即是通过以下程序中的httpClient.GET();来实现的。
/**********************************************************************  程序名称/Program name     : HTTPClient_begin  程序目的/Purpose          :  此程序用于演示如何使用ESP8266来向www.example.com网站服务器发送GET请求并通过串口  监视器将网站服务器响应信息通过串口监视器显示出来。***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt; // 测试HTTP请求用的URL#define URL &quot;http://www.example.com&quot; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichimaker&quot;;const char* password = &quot;12345678&quot;; void setup() &#123;  //初始化串口设置  Serial.begin(9600);   //设置ESP8266工作模式为无线终端模式  WiFi.mode(WIFI_STA);   //开始连接wifi  WiFi.begin(ssid, password);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(1000);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;WiFi Connected!&quot;);&#125; void loop() &#123;  // 如果ESP8266连接WiFi则发送HTTP请求  if ((WiFi.status() == WL_CONNECTED)) &#123;    esp8266Http();  &#125;    delay(5000);   // 短暂等待&#125; // 发送HTTP请求并且将服务器响应通过串口输出void esp8266Http()&#123;   //创建 HTTPClient 对象  HTTPClient httpClient;   //配置请求地址。此处也可以不使用端口号和PATH而单纯的  httpClient.begin(URL);   Serial.print(&quot;URL: &quot;); Serial.println(URL);   //启动连接并发送HTTP请求  int httpCode = httpClient.GET();  Serial.print(&quot;Send GET request to URL: &quot;);  Serial.println(URL);    //如果服务器响应OK则从服务器获取响应体信息并通过串口输出  //如果服务器不响应OK则将服务器响应状态码通过串口输出  if (httpCode == HTTP_CODE_OK) &#123;    String responsePayload = httpClient.getString();    Serial.println(&quot;Server Response Payload: &quot;);    Serial.println(responsePayload);  &#125; else &#123;    Serial.println(&quot;Server Respose Code：&quot;);    Serial.println(httpCode);  &#125;   //关闭ESP8266与服务器连接  httpClient.end();&#125;

相关内容— POST
POST说明此函数用于ESP8266备使用HTTP协议通过网络向服务器发送POST请求。
客户端与服务器通讯时最常被用到的方法是：GET 和 POST。– GET – 从指定的资源请求数据。– POST – 向指定的资源提交要被处理的数据
语法http.POST(payload)
http.POST(payload, size)
参数payload: 通过POST请求所发送的数据信息（该信息置于请求体中被发送）。该参数可使用字符串类型。size: 通过POST请求所发送的数据字节数(此参数为可选参数，类型：size_t )。
返回值服务器响应状态码（类型：int）
以下是常见的HTTP状态码（以下括号中内容为ESP8266HTTPClient库声明定义的HTTP状态码替代文字，具体内容可参考ESP8266库ESP8266HTTPClient.h文件中相应内容）：

– 200: 请求成功 （HTTP_CODE_OK）
– 301: 资源（网页等）被永久转移到其它URL (HTTP_CODE_MOVED_PERMANENTLY)
– 404: 请求的资源（网页等）不存在(HTTP_CODE_NOT_FOUND)
– 500: 内部服务器错误(HTTP_CODE_INTERNAL_SERVER_ERROR)

示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
您将以下示例程序的WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向http://quan.suning.com/getSysTime.do发送HTTP请求并通过串口监视器将响应信息通过串口监视器显示出来。
以下是本程序控制下，ESP8266发送的HTTP请求信息：
POST /getSysTime.do HTTP/1.1Host: quan.suning.comUser-Agent: ESP8266HTTPClientConnection: keep-aliveAccept-Encoding: identity;q=1,chunked;q=0.1,*;q=0Content-Length: 9 date_test

其中HTTP请求方法POST即是通过以下程序中的http.POST(&quot;date_test&quot;)语句来实现的。另外我们可以看到在以上的请求信息中，请求体部分包含有date_test。该信息即是通过http.POST(&quot;date_test&quot;)语句的参数实现的。
/**********************************************************************  项目名称/Project          : 零基础入门学用物联网  程序名称/Program name     : HTTPClient_demo_POST  团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)  作者/Author              : Dapenson  日期/Date（YYYYMMDD）     : 20200325  程序目的/Purpose          :  以苏宁易购的获取时间的公共api为例子,发起HTTP请求,并将获取到的数据信息打印到串口监视器中  具体HTTP请求可参考自定义函数http_POST()内容  -----------------------------------------------------------------------  本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。  该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：  http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt; //以苏宁易购api为例子获取时间数据#define SERVER_IP &quot;http://quan.suning.com/getSysTime.do&quot;  //设置你的wifi接入信息#ifndef STASSID#define STASSID &quot;taichimaker&quot;#define STAPSK  &quot;12345678&quot;#endif void setup() &#123;   //初始化串口设置  Serial.begin(115200);  Serial.println();   //开始连接wifi  WiFi.begin(STASSID, STAPSK);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected! IP address: &quot;);  Serial.println(WiFi.localIP()); &#125; void loop() &#123;  if ((WiFi.status() == WL_CONNECTED)) &#123;    http_post();  &#125;  delay(10000);&#125; void http_post() &#123;   //创建 WiFiClient 实例化对象  WiFiClient client;   //创建http对象  HTTPClient http;   //配置请求地址  http.begin(client, SERVER_IP); //HTTP请求  Serial.print(&quot;[HTTP] begin...\n&quot;);   //启动连接并发送HTTP报头和报文  int httpCode = http.POST(&quot; &quot;);  Serial.print(&quot;[HTTP] POST...\n&quot;);   //连接失败时 httpCode时为负  if (httpCode &gt; 0) &#123;     //将服务器响应头打印到串口    Serial.printf(&quot;[HTTP] POST... code: %d\n&quot;, httpCode);     //将从服务器获取的数据打印到串口    if (httpCode == HTTP_CODE_OK) &#123;      const String&amp; payload = http.getString();      Serial.println(&quot;received payload:\n&lt;&lt;&quot;);      Serial.println(payload);      Serial.println(&quot;&gt;&gt;&quot;);    &#125;  &#125; else &#123;    Serial.printf(&quot;[HTTP] POST... failed, error: %s\n&quot;, http.errorToString(httpCode).c_str());  &#125;  //关闭http连接  http.end();&#125;

相关内容— GET
PUT说明此函数用于ESP8266使用HTTP协议通过网络向服务器发送PUT请求。
语法http.PUT(payload)http.PUT(payload, size)
参数payload:通过PUT请求所发送的数据信息（该信息置于请求体中被发送）。该参数可使用字符串类型。size: 通过PUT请求所发送的数据字节数(此参数为可选参数，类型：size_t )。
返回值服务器状态码
以下是常见的HTTP状态码（以下括号中内容为ESP8266HTTPClient库声明定义的HTTP状态码替代文字，具体内容可参考ESP8266库ESP8266HTTPClient.h文件中相应内容）：

– 200: 请求成功 （HTTP_CODE_OK）
– 301: 资源（网页等）被永久转移到其它URL (HTTP_CODE_MOVED_PERMANENTLY)
– 404: 请求的资源（网页等）不存在(HTTP_CODE_NOT_FOUND)
– 500: 内部服务器错误(HTTP_CODE_INTERNAL_SERVER_ERROR)

相关内容— GET— POST
PATCH说明此函数用于ESP8266使用HTTP协议通过网络向服务器发送PATCH请求。
语法http.PATCH(payload)http.PATCH(payload, size)
参数payload:通过PATCH请求所发送的数据信息（该信息置于请求体中被发送）。该参数可使用字符串类型。size: 通过PATCH请求所发送的数据字节数(此参数为可选参数，类型：size_t )。
返回值服务器响应状态码
以下是常见的HTTP状态码（以下括号中内容为ESP8266HTTPClient库声明定义的HTTP状态码替代文字，具体内容可参考ESP8266库ESP8266HTTPClient.h文件中相应内容）：

– 200: 请求成功 （HTTP_CODE_OK）
– 301: 资源（网页等）被永久转移到其它URL (HTTP_CODE_MOVED_PERMANENTLY)
– 404: 请求的资源（网页等）不存在(HTTP_CODE_NOT_FOUND)
– 500: 内部服务器错误(HTTP_CODE_INTERNAL_SERVER_ERROR)

发送请求类型sendRequest – 发送请求说明此函数用于ESP8266使用HTTP协议通过网络向服务器发送请求。本函数可以自定义请求方法类型，如 GET、POST等。
语法sendRequest(type, payload)sendRequest(type, payload, size)sendRequest(type, stream, size)
参数
type: 发送请求的类型,可以是”GET”、”POST”等。参数类型: const char *

payload: 请求所发送的数据信息（该信息置于请求体中被发送）。该参数可使用字符串类型。（使用GET作为请求方法时，此参数可以省略）。

size: 请求所发送的数据字节数(此参数为可选参数，类型：size_t )。

stream: 数据流对象


返回值服务器状态码
以下是常见的HTTP状态码：

– 200 – 请求成功
– 301 – 资源（网页等）被永久转移到其它URL
– 404 – 请求的资源（网页等）不存在
– 500 – 内部服务器错误

示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
您将以下示例程序的WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向http://quan.suning.com/getSysTime.do发送HTTP请求并通过串口监视器将响应信息通过串口监视器显示出来。
以下是本程序控制下，ESP8266发送的HTTP请求信息：
POST /getSysTime.do HTTP/1.1Host: quan.suning.comUser-Agent: ESP8266HTTPClientConnection: keep-aliveAccept-Encoding: identity;q=1,chunked;q=0.1,*;q=0Content-Length: 9date_test

其中HTTP请求方法POST即是通过以下程序中的http.sendRequest(&quot;POST&quot;, &quot;date_test&quot;)语句来实现的。该语句的第一个参数设置了HTTP请求方法为POST。另外我们可以看到在以上的请求信息中，请求体部分包含有date_test。该信息即是通过http.sendRequest(&quot;POST&quot;, &quot;date_test&quot;)语句的第二个参数实现的。
/**********************************************************************  程序名称/Program name     : HTTPClient_sendRequest  程序目的/Purpose          :  以苏宁易购的获取时间的公共api为例子,发起HTTP请求,并将获取到的数据信息打印到串口监视器中  具体HTTP请求可参考自定义函数http_POST内容***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt; //以苏宁易购api为例子获取时间数据//#define URL &quot;http://quan.suning.com/getSysTime.do&quot;#define URL &quot;http://192.168.0.110&quot; //设置你的wifi接入信息#ifndef STASSID#define STASSID &quot;taichimaker&quot;#define STAPSK  &quot;12345678&quot;#endif void setup() &#123;   //初始化串口设置  Serial.begin(115200);  Serial.println();   //开始连接wifi  WiFi.begin(STASSID, STAPSK);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected! IP address: &quot;);  Serial.println(WiFi.localIP());&#125; void loop() &#123;  if ((WiFi.status() == WL_CONNECTED)) &#123;    http_post();  &#125;  delay(10000);&#125; void http_post() &#123;   //创建http对象  HTTPClient http;   //配置请求地址  http.begin(URL); //HTTP请求  Serial.print(&quot;[HTTP] begin...\n&quot;);   //启动连接并发送HTTP请求。请求方法：POST。请求体信息：date_test  int httpCode = http.sendRequest(&quot;POST&quot;, &quot;date_test&quot;);  Serial.print(&quot;[HTTP] POST...\n&quot;);   //连接失败时 httpCode时为负  if (httpCode &gt; 0) &#123;     //将服务器响应头打印到串口    Serial.printf(&quot;[HTTP] POST... code: %d\n&quot;, httpCode);     //将从服务器获取的数据打印到串口    if (httpCode == HTTP_CODE_OK) &#123;      const String&amp; payload = http.getString();      Serial.println(&quot;received payload:\n&lt;&lt;&quot;);      Serial.println(payload);      Serial.println(&quot;&gt;&gt;&quot;);    &#125;  &#125; else &#123;    Serial.printf(&quot;[HTTP] POST... failed, error: %s\n&quot;, http.errorToString(httpCode).c_str());  &#125;  //关闭http连接  http.end();&#125;



相关内容— GET— POST
end – 结束请求说明当ESP8266发送HTTP请求结束后，我们应该调用此函数来清除ESP8266的接收缓存以便设备再次接收服务器发来的响应信息。
语法http.end()
参数无
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************  程序名称/Program name     : HTTPClient_end  程序目的/Purpose          :  此程序用于演示如何使用ESP8266来向www.example.com网站服务器发送HTTP请求并通过串口  监视器将网站服务器响应信息通过串口监视器显示出来。***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt; // 测试HTTP请求用的URL#define URL &quot;http://www.example.com&quot; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichimaker&quot;;const char* password = &quot;12345678&quot;; void setup() &#123;  //初始化串口设置  Serial.begin(9600);   //设置ESP8266工作模式为无线终端模式  WiFi.mode(WIFI_STA);   //开始连接wifi  WiFi.begin(ssid, password);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(1000);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;WiFi Connected!&quot;);&#125; void loop() &#123;  // 如果ESP8266连接WiFi则发送HTTP请求  if ((WiFi.status() == WL_CONNECTED)) &#123;    esp8266Http();  &#125;    delay(5000);   // 短暂等待&#125; // 发送HTTP请求并且将服务器响应通过串口输出void esp8266Http()&#123;   //创建 HTTPClient 对象  HTTPClient httpClient;   //配置请求地址。此处也可以不使用端口号和PATH而单纯的  httpClient.begin(URL);   Serial.print(&quot;URL: &quot;); Serial.println(URL);   //启动连接并发送HTTP请求  int httpCode = httpClient.GET();  Serial.print(&quot;Send GET request to URL: &quot;);  Serial.println(URL);    //如果服务器响应OK则从服务器获取响应体信息并通过串口输出  //如果服务器不响应OK则将服务器响应状态码通过串口输出  if (httpCode == HTTP_CODE_OK) &#123;    String responsePayload = httpClient.getString();    Serial.println(&quot;Server Response Payload: &quot;);    Serial.println(responsePayload);  &#125; else &#123;    Serial.println(&quot;Server Respose Code：&quot;);    Serial.println(httpCode);  &#125;   //关闭ESP8266与服务器连接  httpClient.end();&#125;



响应类型响应头类型collectHeaders – 设置收集响应头内容说明在我们使用ESP8266HTTPClient库中的header、headers 、headerName 、hasHeader 函数来处理网站服务器响应头以前，需要首先调用本函数来设置ESP8266具体收集哪些响应头信息。
语法httpClient.collectHeaders(headerKeys, headerKeysCount)

参数– headerKeys: 响应头名数组。此数组中的元素即是需要ESP8266处理或收集的响应头信息。下面我们看一个headerKeys数组的例子：const char *headerKeys[] = {&quot;Content-Length&quot;, &quot;Date&quot;};此数组共有两个元素，分别是”Content-Length”和”Date”。只有如此建立了数组后，接下来的程序里我们才可以使用其它ESP8266HTTPClient库函数来处理这两个响应头的信息内容。可以把这个数组看作是对ESP8266的提醒，即告诉ESP8266在后续的程序中，我们将要对数组中所包含的响应头信息进行处理。（具体操作方法，请见本函数的示例程序部分。）
– headerKeysCount: 需要获取&#x2F;处理的响应头个数（可选参数，类型：size_t）
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求，并且将服务器响应头中的”Content-Length”和”Date”信息通过串口监视器输出。（如下图所示）

我们通过以下示例程序的const char *headerKeys[] = {&quot;Content-Length&quot;, &quot;Date&quot;};语句建立了headerKeys数组。该数组将被用于接下来程序中的httpClient.collectHeaders(headerKeys, 2);语句。以上操作的目的是为了告知ESP8266我们即将对服务器响应头中的”Content-Length”, “Date”信息进行处理。
在后续的程序中，我们使用了一系列串口输出语句将服务器响应头中的”Content-Length”, “Date”信息通过串口监视器显示，也就是您所看到的上图内容。
值得注意的是，在上图中红色标注的Connection响应头信息是空的。造成这个结果的原因是我们在建立headerKeys数组时，没有在该数组中加入Connection这一元素。那么ESP8266在后续的程序中自然就无法输出Connection信息了。
/**********************************************************************  程序名称/Program name     : HTTPClient_collectHeaders  程序目的/Purpose          :  此程序用于演示如何使用collectHeaders函数处理www.example.com网站服务器返回的响应信息。***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt; // 测试HTTP请求用的URL#define URL &quot;http://www.example.com&quot; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichimaker&quot;;const char* password = &quot;12345678&quot;; //需要收集的响应头的信息const char *headerKeys[] = &#123;&quot;Content-Length&quot;, &quot;Date&quot;&#125;; void setup() &#123;  //初始化串口设置  Serial.begin(9600);   //设置ESP8266工作模式为无线终端模式  WiFi.mode(WIFI_STA);   //开始连接wifi  WiFi.begin(ssid, password);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(1000);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;WiFi Connected!&quot;);&#125; void loop() &#123;  // 如果ESP8266连接WiFi则发送HTTP请求  if ((WiFi.status() == WL_CONNECTED)) &#123;    esp8266Http();  &#125;    delay(5000);   // 短暂等待&#125; // 发送HTTP请求并且将服务器响应通过串口输出void esp8266Http()&#123;   //创建 HTTPClient 对象  HTTPClient httpClient;   //配置请求地址。此处也可以不使用端口号和PATH而单纯的  httpClient.begin(URL);   Serial.print(&quot;URL: &quot;); Serial.println(URL);   //通过headerKeys数组设置即将处理的服务器响应头内容  httpClient.collectHeaders(headerKeys, 2);   //启动连接并发送HTTP请求  int httpCode = httpClient.GET();  Serial.print(&quot;Send GET request to URL: &quot;);  Serial.println(URL);    //如果服务器响应OK则从服务器获取响应体信息并通过串口输出  //如果服务器不响应OK则将服务器响应状态码通过串口输出  if (httpCode == HTTP_CODE_OK) &#123;      Serial.println(&quot;==========================&quot;);      Serial.println(&quot;Collected Server Headers: &quot;);            Serial.print(&quot;Content-Length = &quot;);       Serial.println(httpClient.header(&quot;Content-Length&quot;));           Serial.print(&quot;Date = &quot;);       Serial.println(httpClient.header(&quot;Date&quot;));            Serial.print(&quot;Connection = &quot;);       Serial.println(httpClient.header(&quot;Connection&quot;));      Serial.println(&quot;==========================&quot;);  &#125; else &#123;    Serial.println(&quot;Server Respose Code：&quot;);    Serial.println(httpCode);  &#125;   //关闭ESP8266与服务器连接  httpClient.end();&#125;

以上程序利用collectHeaders函数获取服务器响应头信息，并通过串口监视器将获取到的响应头信息输出，以便我们查阅程序运行结果。
在以上程序中有2条语句很重要。

const char *headerKeys[] = {&quot;Content-Length&quot;, &quot;Date&quot;};这条语句建立了用于存储响应头信息的数组。

httpClient.collectHeaders(headerKeys, 2);这条语句用于设置响应头收集。


相关内容— header – 获取指定响应头参数值— headers – 获取响应头数量— headerName – 获取指定的响应头名— hasHeader – 确认是否存在指定响应头
header – 获取指定响应头参数值说明通过此函数，ESP8266可以获取服务器响应头的参数值。
注：在使用此函数前，必须使用collectHeaders函数来设置响应头处理内容。
语法httpClient.header(name)httpClient.header(index)
参数name: 响应头中指定项的参数名(参数类型: const char*)index: 响应头中指定项的序号(参数类型: size_t)
返回值响应头中指定项的参数值 (返回值类型:String)
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求，并且将服务器响应头中的”Content-Length”和”Date”信息通过串口监视器输出。（如下图所示）
 
我们通过以下示例程序的const char *headerKeys[] = {&quot;Content-Length&quot;, &quot;Date&quot;};语句建立了headerKeys数组。该数组将被用于接下来程序中的httpClient.collectHeaders(headerKeys, 2);语句。以上操作的目的是为了告知ESP8266我们即将对服务器响应头中的”Content-Length”, “Date”信息进行处理。
在后续的程序中，我们使用了一系列header函数来获取指定响应头的数值。并且将这些数值通过串口监视器显示，也就是您所看到的上图内容。
值得注意的是，在上图中红色标注的Connection响应头信息是空的。造成这个结果的原因是我们在建立headerKeys数组时，没有在该数组中加入Connection这一元素。那么ESP8266在后续的程序中自然就无法输出Connection信息了。
/**********************************************************************  程序名称/Program name     : HTTPClient_header  程序目的/Purpose          :  此程序用于演示如何使用header函数处理www.example.com网站服务器返回的响应信息。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt; // 测试HTTP请求用的URL#define URL &quot;http://www.example.com&quot; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichimaker&quot;;const char* password = &quot;12345678&quot;; //需要收集的响应头的信息const char *headerKeys[] = &#123;&quot;Content-Length&quot;, &quot;Date&quot;&#125;; void setup() &#123;  //初始化串口设置  Serial.begin(9600);   //设置ESP8266工作模式为无线终端模式  WiFi.mode(WIFI_STA);   //开始连接wifi  WiFi.begin(ssid, password);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(1000);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;WiFi Connected!&quot;);&#125; void loop() &#123;  // 如果ESP8266连接WiFi则发送HTTP请求  if ((WiFi.status() == WL_CONNECTED)) &#123;    esp8266Http();  &#125;    delay(5000);   // 短暂等待&#125; // 发送HTTP请求并且将服务器响应通过串口输出void esp8266Http()&#123;   //创建 HTTPClient 对象  HTTPClient httpClient;   //配置请求地址。此处也可以不使用端口号和PATH而单纯的  httpClient.begin(URL);   Serial.print(&quot;URL: &quot;); Serial.println(URL);   //通过headerKeys数组设置即将处理的服务器响应头内容  httpClient.collectHeaders(headerKeys, 2);   //启动连接并发送HTTP请求  int httpCode = httpClient.GET();  Serial.print(&quot;Send GET request to URL: &quot;);  Serial.println(URL);    //如果服务器响应OK则从服务器获取响应体信息并通过串口输出  //如果服务器不响应OK则将服务器响应状态码通过串口输出  if (httpCode == HTTP_CODE_OK) &#123;      Serial.println(&quot;==========================&quot;);      Serial.println(&quot;Collected Server Headers: &quot;);            Serial.print(&quot;Content-Length = &quot;);       Serial.println(httpClient.header(&quot;Content-Length&quot;));           Serial.print(&quot;Date = &quot;);       Serial.println(httpClient.header(&quot;Date&quot;));            Serial.print(&quot;Connection = &quot;);       Serial.println(httpClient.header(&quot;Connection&quot;));      Serial.println(&quot;==========================&quot;);  &#125; else &#123;    Serial.println(&quot;Server Respose Code：&quot;);    Serial.println(httpCode);  &#125;   //关闭ESP8266与服务器连接  httpClient.end();&#125;

相关内容— collectHeaders – 设置收集响应头内容— header – 获取指定响应头参数值— headers – 获取响应头数量— headerName – 获取指定的响应头名— hasHeader – 确认是否存在指定响应头
headers – 获取响应头数量说明当ESP8266开发板通过HTTP协议向服务器发送请求后，服务器将会向ESP8266开发板发送HTTP响应信息。这个响应信息的响应头部分是多个键值对组成的。此函数用于ESP8266获取响应头中键值对的数量。
注：在使用此函数前，必须使用collectHeaders函数来设置响应头处理内容。另外此函数所获取的服务器响应头数量并不是服务器****的实际响应头数量，而是collectHeaders函数中设置的“headerKeysCount”参数数值。
语法httpClient.headers()

参数无
返回值获取的响应头数量（参数类型： int）
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求，并且将ESP8266获取的服务器响应头中数量通过串口监视器显示出来。
/**********************************************************************  程序名称/Program name     : HTTPClient_headers  程序目的/Purpose          :  此程序用于演示如何使用headers函数获取www.example.com网站服务器返回的响应头数量。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt; // 测试HTTP请求用的URL#define URL &quot;http://www.example.com&quot; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichimaker&quot;;const char* password = &quot;12345678&quot;; //需要收集的响应头的信息const char *headerKeys[] = &#123;&quot;Content-Length&quot;, &quot;Date&quot;&#125;; void setup() &#123;  //初始化串口设置  Serial.begin(9600);   //设置ESP8266工作模式为无线终端模式  WiFi.mode(WIFI_STA);   //开始连接wifi  WiFi.begin(ssid, password);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(1000);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;WiFi Connected!&quot;);&#125; void loop() &#123;  // 如果ESP8266连接WiFi则发送HTTP请求  if ((WiFi.status() == WL_CONNECTED)) &#123;    esp8266Http();  &#125;    delay(5000);   // 短暂等待&#125; // 发送HTTP请求并且将服务器响应通过串口输出void esp8266Http()&#123;   //创建 HTTPClient 对象  HTTPClient httpClient;   //配置请求地址。此处也可以不使用端口号和PATH而单纯的  httpClient.begin(URL);   Serial.print(&quot;URL: &quot;); Serial.println(URL);   //通过headerKeys数组设置即将处理的服务器响应头内容  httpClient.collectHeaders(headerKeys, 3);   //启动连接并发送HTTP请求  int httpCode = httpClient.GET();  Serial.print(&quot;Send GET request to URL: &quot;);  Serial.println(URL);    //如果服务器响应OK则从服务器获取响应体信息并通过串口输出  //如果服务器不响应OK则将服务器响应状态码通过串口输出  if (httpCode == HTTP_CODE_OK) &#123;       int headerQuantity = httpClient.headers();      Serial.println(&quot;==========================&quot;);      Serial.print(&quot;Server Header Quantity: &quot;);            Serial.println(headerQuantity);      Serial.println(&quot;==========================&quot;);  &#125; else &#123;    Serial.println(&quot;Server Respose Code：&quot;);    Serial.println(httpCode);  &#125;   //关闭ESP8266与服务器连接  httpClient.end();&#125;

相关内容— collectHeaders – 设置收集响应头内容— header – 获取指定响应头参数值— headerName – 获取指定的响应头名— hasHeader – 确认是否存在指定响应头
headerName – 获取指定的响应头名说明当ESP8266开发板通过HTTP协议向服务器发送请求后，服务器将会向ESP8266开发板发送HTTP响应信息。这个响应信息的响应头部分是多个键值对组成的。此函数用于获取响应头中指定序号的键名。
注:要使用此函数必须在发起请求之前使用collectHeaders函数来设置收集响应头内容。
语法httpClient.headerName(index)

参数index: 要获取的响应头键名序号(类型：size_t)例：如需获取响应头中首个键的键名，可使用以下语句。http.headerName(0)
返回值要获取的响应头键名（类型：字符串）
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
您将WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求，并且将ESP8266获取的服务器响应中的第一个响应头名称通过串口监视器显示出来。我们是通过以下示例程序中的语句`httpClient.headerName(0);`来获取该信息的。
/**********************************************************************  程序名称/Program name     : HTTPClient_headerName  程序目的/Purpose          :  此程序用于演示如何使用headers函数获取www.example.com网站服务器返回的响应头数量。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt; // 测试HTTP请求用的URL#define URL &quot;http://www.example.com&quot; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichimaker&quot;;const char* password = &quot;12345678&quot;; //需要收集的响应头的信息const char *headerKeys[] = &#123;&quot;Content-Length&quot;, &quot;Date&quot;&#125;; void setup() &#123;  //初始化串口设置  Serial.begin(9600);   //设置ESP8266工作模式为无线终端模式  WiFi.mode(WIFI_STA);   //开始连接wifi  WiFi.begin(ssid, password);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(1000);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;WiFi Connected!&quot;);&#125; void loop() &#123;  // 如果ESP8266连接WiFi则发送HTTP请求  if ((WiFi.status() == WL_CONNECTED)) &#123;    esp8266Http();  &#125;    delay(5000);   // 短暂等待&#125; // 发送HTTP请求并且将服务器响应通过串口输出void esp8266Http()&#123;   //创建 HTTPClient 对象  HTTPClient httpClient;   //配置请求地址。此处也可以不使用端口号和PATH而单纯的  httpClient.begin(URL);   Serial.print(&quot;URL: &quot;); Serial.println(URL);   //通过headerKeys数组设置即将处理的服务器响应头内容  httpClient.collectHeaders(headerKeys, 2);   //启动连接并发送HTTP请求  int httpCode = httpClient.GET();  Serial.print(&quot;Send GET request to URL: &quot;);  Serial.println(URL);    //如果服务器响应OK则从服务器获取响应体信息并通过串口输出  //如果服务器不响应OK则将服务器响应状态码通过串口输出  if (httpCode == HTTP_CODE_OK) &#123;      String headerKey = httpClient.headerName(0);      Serial.println(&quot;==========================&quot;);      Serial.print(&quot;Server Header1 Name: &quot;);            Serial.println(headerKey);      Serial.println(&quot;==========================&quot;);  &#125; else &#123;    Serial.println(&quot;Server Respose Code：&quot;);    Serial.println(httpCode);  &#125;   //关闭ESP8266与服务器连接  httpClient.end();&#125;

相关内容— collectHeaders – 设置收集响应头内容— header – 获取指定响应头参数值— headers – 获取响应头数量— hasHeader – 确认是否存在指定响应头
hasHeader – 确认是否存在指定响应头说明此函数用于确认服务器HTTP响应头中是否含有指定响应头信息。
注:要使用此函数必须在发起请求之前使用collectHeaders函数来设置收集响应头内容。
语法httpClient.hasHeader(name)

参数name: 需要确认的响应头键名（类型：const char* ）
返回值返回值类型为bool。如果存在需要确认的响应头键名则返回true，否则返回false。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
您将WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求，并且通过串口监视器输出服务器响应头中包含有”Date”信息。我们是通过以下示例程序中的语句`httpClient.hasHeader(&quot;Date&quot;)`来获取该信息的。
/**********************************************************************  程序名称/Program name     : HTTPClient_hasHeader  程序目的/Purpose          :  此程序用于演示如何使用headers函数获取www.example.com网站服务器返回的响应头数量。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt; // 测试HTTP请求用的URL#define URL &quot;http://www.example.com&quot; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichimaker&quot;;const char* password = &quot;12345678&quot;; //需要收集的响应头的信息const char *headerKeys[] = &#123;&quot;Content-Length&quot;, &quot;Date&quot;&#125;; void setup() &#123;  //初始化串口设置  Serial.begin(9600);   //设置ESP8266工作模式为无线终端模式  WiFi.mode(WIFI_STA);   //开始连接wifi  WiFi.begin(ssid, password);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(1000);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;WiFi Connected!&quot;);&#125; void loop() &#123;  // 如果ESP8266连接WiFi则发送HTTP请求  if ((WiFi.status() == WL_CONNECTED)) &#123;    esp8266Http();  &#125;    delay(5000);   // 短暂等待&#125; // 发送HTTP请求并且将服务器响应通过串口输出void esp8266Http()&#123;   //创建 HTTPClient 对象  HTTPClient httpClient;   //配置请求地址。此处也可以不使用端口号和PATH而单纯的  httpClient.begin(URL);   Serial.print(&quot;URL: &quot;); Serial.println(URL);   //通过headerKeys数组设置即将处理的服务器响应头内容  httpClient.collectHeaders(headerKeys, 2);   //启动连接并发送HTTP请求  int httpCode = httpClient.GET();  Serial.print(&quot;Send GET request to URL: &quot;);  Serial.println(URL);    //如果服务器响应OK则从服务器获取响应体信息并通过串口输出  //如果服务器不响应OK则将服务器响应状态码通过串口输出  if (httpCode == HTTP_CODE_OK) &#123;      if(httpClient.hasHeader(&quot;Date&quot;))&#123;        Serial.println(&quot;==========================&quot;);        Serial.println(&quot;Server Response has Date Header&quot;);              Serial.println(&quot;==========================&quot;);      &#125;  &#125; else &#123;    Serial.println(&quot;Server Respose Code：&quot;);    Serial.println(httpCode);  &#125;   //关闭ESP8266与服务器连接  httpClient.end();&#125;

相关内容— collectHeaders – 设置收集响应头内容— header – 获取指定响应头参数值— headers – 获取响应头数量— headerName – 获取指定的响应头名
响应体类型getString – 获取响应体数据并且以字符串形式返回说明此函数可用于获取服务器响应中的响应体信息。响应体信息将以字符串的形式进行返回。
语法http.getString()
参数无
返回值服务器HTTP响应中的响应体数据。(返回值类型:String)
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求并通过串口监视器将网站服务器响应体信息通过串口监视器显示出来。我们是通过以下示例程序中的`httpClient.getString()`来获取该信息的。
/**********************************************************************  程序名称/Program name     : HTTPClient_demo_getString  程序目的/Purpose          :  此程序用于演示如何使用getString来获取www.example.com网站服务器返回的响应信息。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt; // 测试HTTP请求用的URL#define URL &quot;http://www.example.com&quot; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichimaker&quot;;const char* password = &quot;12345678&quot;; void setup() &#123;  //初始化串口设置  Serial.begin(9600);   //设置ESP8266工作模式为无线终端模式  WiFi.mode(WIFI_STA);   //开始连接wifi  WiFi.begin(ssid, password);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(1000);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;WiFi Connected!&quot;);&#125; void loop() &#123;  // 如果ESP8266连接WiFi则发送HTTP请求  if ((WiFi.status() == WL_CONNECTED)) &#123;    esp8266Http();  &#125;    delay(5000);   // 短暂等待&#125; // 发送HTTP请求并且将服务器响应通过串口输出void esp8266Http()&#123;   //创建 HTTPClient 对象  HTTPClient httpClient;   //配置请求地址。此处也可以不使用端口号和PATH而单纯的  httpClient.begin(URL);   Serial.print(&quot;URL: &quot;); Serial.println(URL);   //启动连接并发送HTTP请求  int httpCode = httpClient.GET();  Serial.print(&quot;Send GET request to URL: &quot;);  Serial.println(URL);    //如果服务器响应OK则从服务器获取响应体信息并通过串口输出  //如果服务器不响应OK则将服务器响应状态码通过串口输出  if (httpCode == HTTP_CODE_OK) &#123;    String responsePayload = httpClient.getString();    Serial.println(&quot;Server Response Payload: &quot;);    Serial.println(responsePayload);  &#125; else &#123;    Serial.println(&quot;Server Respose Code：&quot;);    Serial.println(httpCode);  &#125;   //关闭ESP8266与服务器连接  httpClient.end();&#125;

相关内容— getStream – 获取响应体数据并且以Stream形式返回— writeToStream – 获取响应体数据并且写入其它Stream对象— getSize – 获取响应体数据字节数— errorToString – 获取错误代码并且以字符串形式返回
getStream – 获取响应体数据并且以Stream形式返回说明此函数可用于获取服务器响应中的响应体信息。响应体信息将以WiFiClient对象返回。
我们可以使用WiFiClient库（ TCP客户端库）建立WiFiClient对象，继而使用该对象对本函数所返回的响应体信息进行分析处理。由于WiFiClient对象可以调用Stream类提里面的诸多功能强大的函数，如 parseInt 、 find 、 readStringUntil，使用本函数可以为分析服务器响应信息提供很多便利。
为了更好的了解本函数的用法，建议您首先了解WiFiClient库（ TCP客户端库）以及是该库中Stream类函数的具体使用方法。
语法httpClient.getStream()

参数无
返回值以Stream形式返回响应体数据。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求并通过串口监视器将网站服务器响应体信息通过串口监视器显示出来。
在以下示例程序中，首先我们通过语句WiFiClient wifiClient;来创建 WiFiClient 对象。该对象用于处理getStream函数所获取的服务器响应体。
接下来在84-87行程序中，我们利用WiFiClient 对象调用available和readStringUntil这两个Stream类函数，从而将服务器响应体信息先赋值给字符串，再通过监视器显示出来。
/**********************************************************************  程序名称/Program name     : HTTPClient_getStream  程序目的/Purpose          :  此程序用于演示如何使用getStream来处理www.example.com网站服务器返回的响应信息。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt; // 测试HTTP请求用的URL#define URL &quot;http://www.example.com&quot; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichimaker&quot;;const char* password = &quot;12345678&quot;; void setup() &#123;  //初始化串口设置  Serial.begin(9600);   //设置ESP8266工作模式为无线终端模式  WiFi.mode(WIFI_STA);   //开始连接wifi  WiFi.begin(ssid, password);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(1000);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;WiFi Connected!&quot;);&#125; void loop() &#123;  // 如果ESP8266连接WiFi则发送HTTP请求  if ((WiFi.status() == WL_CONNECTED)) &#123;    esp8266Http();  &#125;    delay(5000);   // 短暂等待&#125; // 发送HTTP请求并且将服务器响应通过串口输出void esp8266Http()&#123;  //创建 WiFiClient 对象。该对象用于处理getStream函数所获取的服务器响应体  WiFiClient wifiClient;     //创建 HTTPClient 对象  HTTPClient httpClient;   //配置请求地址。此处也可以不使用端口号和PATH而单纯的  httpClient.begin(URL);   Serial.print(&quot;URL: &quot;); Serial.println(URL);   //启动连接并发送HTTP请求  int httpCode = httpClient.GET();  Serial.print(&quot;Send GET request to URL: &quot;);  Serial.println(URL);    //如果服务器响应OK则从服务器获取响应体信息并通过串口输出  //如果服务器不响应OK则将服务器响应状态码通过串口输出  if (httpCode == HTTP_CODE_OK) &#123;        // 获取服务器响应体Stream并传递给wifiClient    wifiClient = httpClient.getStream();        Serial.println(&quot;Server Response: &quot;);    // 以下部分使用了Stream类中的available函数以及readStringUntil函数    // 对服务器响应体信息进行分析处理。并且通过串口监视器将服务器响应体信息    // 输出到串口监视器中。    while (wifiClient.available())&#123;      String resonseBodyLine = wifiClient.readStringUntil(&#x27;\n&#x27;);      Serial.println(resonseBodyLine);    &#125;  &#125; else &#123;    Serial.println(&quot;Server Respose Code：&quot;);    Serial.println(httpCode);  &#125;   //关闭ESP8266与服务器连接  httpClient.end();&#125;

相关内容— getString – 获取响应体数据并且以字符串形式返回— writeToStream – 获取响应体数据并且写入其它Stream对象— getSize – 获取响应体数据字节数— errorToString – 获取错误代码并且以字符串形式返回
writeToStream – 获取响应体数据并且写入其它Stream对象说明此函数用于将获取到的响应数据写入Stream数据流。
语法httpClient.writeToStream(stream)

参数stream: stream类型指针
返回值返回值类型为int。如果返回值大于零，则返回值数值是写入对象的数据大小（单位：字节）。如果返回值小于零，说明函数执行出错。以下是错误代码说明：

-1： HTTPC_ERROR_CONNECTION_REFUSED
-2： HTTPC_ERROR_SEND_HEADER_FAILED
-3： HTTPC_ERROR_SEND_PAYLOAD_FAILED
-4： HTTPC_ERROR_NOT_CONNECTED
-5： HTTPC_ERROR_CONNECTION_LOST
-6： HTTPC_ERROR_NO_STREAM
-7： HTTPC_ERROR_NO_HTTP_SERVER
-8： HTTPC_ERROR_TOO_LESS_RAM
-9： HTTPC_ERROR_ENCODING
-10： HTTPC_ERROR_STREAM_WRITE
-11： HTTPC_ERROR_READ_TIMEOUT

getSize – 获取响应体数据字节数说明此函数可用于获取服务器响应中的响应体大小（单位：字节）。
语法httpClient.getSize()

参数无
返回值返回值类型为int。服务器响应中的响应体大小（单位：字节）
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，ESP8266将会向www.example.com网站服务器发送HTTP请求，并且将ESP8266获取的服务器响应头大小通过串口监视器显示出来。我们使用了`httpClient.getSize()`来获取该信息。
/**********************************************************************  程序名称/Program name     : HTTPClient_getSize  程序目的/Purpose          :  此程序用于演示如何使用getSize函数来获取www.example.com网站服务器返回的响应信息大小。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt; // 测试HTTP请求用的URL#define URL &quot;http://www.example.com&quot; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichimaker&quot;;const char* password = &quot;12345678&quot;; void setup() &#123;  //初始化串口设置  Serial.begin(9600);   //设置ESP8266工作模式为无线终端模式  WiFi.mode(WIFI_STA);   //开始连接wifi  WiFi.begin(ssid, password);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(1000);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;WiFi Connected!&quot;);&#125; void loop() &#123;  // 如果ESP8266连接WiFi则发送HTTP请求  if ((WiFi.status() == WL_CONNECTED)) &#123;    esp8266Http();  &#125;    delay(5000);   // 短暂等待&#125; // 发送HTTP请求并且将服务器响应通过串口输出void esp8266Http()&#123;   //创建 HTTPClient 对象  HTTPClient httpClient;   //配置请求地址。此处也可以不使用端口号和PATH而单纯的  httpClient.begin(URL);   Serial.print(&quot;URL: &quot;); Serial.println(URL);   //启动连接并发送HTTP请求  int httpCode = httpClient.GET();  Serial.print(&quot;Send GET request to URL: &quot;);  Serial.println(URL);    //如果服务器响应OK则从服务器获取响应体信息并通过串口输出  //如果服务器不响应OK则将服务器响应状态码通过串口输出  if (httpCode == HTTP_CODE_OK) &#123;        Serial.print(&quot;Response Body Size: &quot;);    Serial.print(httpClient.getSize());    Serial.println(&quot; Bytes&quot;);   &#125; else &#123;    Serial.println(&quot;Server Respose Code：&quot;);    Serial.println(httpCode);  &#125;   //关闭ESP8266与服务器连接  httpClient.end();&#125;

相关内容— getString – 获取响应体数据并且以字符串形式返回— getStream – 获取响应体数据并且以Stream形式返回— writeToStream – 获取响应体数据并且写入其它Stream对象— errorToString – 获取错误代码并且以字符串形式返回
errorToString – 获取错误代码并且以字符串形式返回说明此函数可用于将ESP8266的HTTP请求失败代码转换为字符串描述。
语法httpClient.errorToString(httpCode)

参数httpCode:服务器错误代码。注意，此错误代码非HTTP响应状态码，而是ESP8266库自定义的一系列错误代码。以下是错误代码数值以及该数值所对应的错误信息。

-1： HTTPC_ERROR_CONNECTION_REFUSED
-2： HTTPC_ERROR_SEND_HEADER_FAILED
-3： HTTPC_ERROR_SEND_PAYLOAD_FAILED
-4： HTTPC_ERROR_NOT_CONNECTED
-5： HTTPC_ERROR_CONNECTION_LOST
-6： HTTPC_ERROR_NO_STREAM
-7： HTTPC_ERROR_NO_HTTP_SERVER
-8： HTTPC_ERROR_TOO_LESS_RAM
-9： HTTPC_ERROR_ENCODING
-10： HTTPC_ERROR_STREAM_WRITE
-11： HTTPC_ERROR_READ_TIMEOUT

返回值服务器响应错误说明（类型：String）
示例程序/**********************************************************************  程序名称/Program name     : HTTPClient_errorToString  程序目的/Purpose          :  此程序用于演示如何使用errorToString函数来获取网站服务器请求错误代码。***********************************************************************/#include &lt;ESP8266HTTPClient.h&gt; void setup() &#123;  Serial.begin(9600);    //创建 HTTPClient 对象  HTTPClient httpClient;   for (int i = -11; i &lt; 0; i++)&#123;    Serial.print(&quot;Response errorToString &quot;);    Serial.print(i);Serial.print(&quot; - &quot;);    Serial.println(httpClient.errorToString(i));    &#125;&#125; void loop() &#123;&#125;

相关内容— getString – 获取响应体数据并且以字符串形式返回— getStream – 获取响应体数据并且以Stream形式返回— writeToStream – 获取响应体数据并且写入其它Stream对象— getSize – 获取响应体数据字节数— errorToString – 获取错误代码并且以字符串形式返回
ESP8266 – ESP8266WebServer库ESP8266WebServer库用于HTTP协议通讯。通过ESP8266WebServer库，我们可以使用ESP8266开发板建立网络服务器,从而允许其它网络设备以及物联网设备通过HTTP协议访问并实现物联网信息交流。
ESP8266库中还有一个专门用于TCP通讯的WiFiServer库 。
由于HTTP协议是建立在TCP协议基础之上的，我们也可以使用WiFiServer库来实现HTTP通讯。在这一点上，WiFiServer库与ESP8266WebServer库 在功能上形成了互补。
以下为ESP8266WebServer库的整体结构图。在此图下方有ESP8266WebServer库的函数目录。您可以通过点击目录项目打开各个函数的说明页面。

服务器运行管理分类ESP8266WebServer – 建立新的ESP8266WebServer对象说明此函数用于建立新的ESP8266WebServer对象，以便我们在程序中利用此对象来实现物联网网络服务器。
语法ESP8266WebServer server(port)

参数– port: 此参数用于设置服务端口号。如不提供此参数，则默认为80端口。(类型:int)
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
在以下示例程序中，我们通过ESP8266WebServer语句建立了ESP8266WebServer对象，对象名称是server，端口号是server(80)中的数字80。接下来我们就可以通过对象server来实现对ESP8266开发板的物联网服务器的控制。
当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址。此时，ESP8266已经成功建立了网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。
/**********************************************************************  程序名称/Program name     : WebServer_demo_server  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置您的WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; ESP8266WebServer server(80); //自定义主页访问处理函数void homepage() &#123;  server.send(200, &quot;text/plain&quot;, &quot;test homepage !&quot;);  Serial.println(&quot;用户访问了主页&quot;);&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.on(&quot;/&quot;, homepage);  server.begin();  Serial.println(&quot;HTTP server started&quot;);&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();  &#125;





begin – 服务器启动说明本函数用于启动ESP8266开发板所建立的网络服务器。
语法server.begin()

参数无
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
在以下示例程序中，我们通过ESP8266WebServer语句建立了ESP8266WebServer对象，对象名称是server，端口号是server(80)中的数字80。接下来我们就可以通过对象server来实现对ESP8266开发板的物联网服务器的控制。
当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址。此时，ESP8266已经成功建立了网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。
当您在浏览器地址栏中输入IP后并按下回车，这时您将看到浏览器中显示上图所示的网页页面。该页面即是通过ESP8266所建立的。在以下示例程序中，我们使用了server.begin();来启动ESP8266服务器工作。
/**********************************************************************  程序名称/Program name     : WebServer_demo_server  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置您的WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; ESP8266WebServer server(80); //自定义主页访问处理函数void homepage() &#123;  server.send(200, &quot;text/plain&quot;, &quot;test homepage !&quot;);  Serial.println(&quot;用户访问了主页&quot;);&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.on(&quot;/&quot;, homepage);  server.begin();  Serial.println(&quot;HTTP server started&quot;);&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125;





stop – 停止服务器说明本函数用于停止ESP8266开发板所建立的网络服务器。
注: stop函数和close函数功能相同。
语法server.stop()

参数无
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址。此时，ESP8266已经成功建立了网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。
当您在浏览器地址栏中输入IP后并按下回车，这时您将看到浏览器中显示上图所示的网页页面。该页面即是通过ESP8266所建立的。当您刷新此页面三次后，ESP8266开发板将会执行server.stop()语句，随即停止物联网服务器功能。
/**********************************************************************  程序名称/Program name     : WebServer_demo_stop  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问  且访问homepage三次之后关停服务器***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; ESP8266WebServer server(80); //设置访问次数变量int repeat = 0; void homepage() &#123;  server.send(200, &quot;text/plain&quot;, &quot;test homepage&quot;);  Serial.println(&quot;用户访问了主页&quot;);   //达到访问次数限制之后停止服务器运行  if (++repeat == 3) &#123;    Serial.println(&quot;服务器停止运行);    server.stop();  &#125;&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.on(&quot;/&quot;, homepage);  server.begin()  Serial.println(&quot;HTTP server started&quot;);&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125;





close – 停止服务器说明本函数用于停止ESP8266开发板所建立的网络服务器。
注: close函数和stop函数功能相同。
语法server.close()
参数无
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址。此时，ESP8266已经成功建立了网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。
当您在浏览器地址栏中输入IP后并按下回车，这时您将看到浏览器中显示上图所示的网页页面。该页面即是通过ESP8266所建立的。当您刷新此页面三次后，ESP8266开发板将会执行server.close()语句，随即停止物联网服务器功能。
/**********************************************************************  程序名称/Program name     : WebServer_demo_close  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问  且访问homepage三次之后关停服务器***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; ESP8266WebServer server(80); //设置访问次数变量int repeat = 0; void homepage() &#123;  server.send(200, &quot;text/plain&quot;, &quot;test homepage&quot;);  Serial.println(&quot;用户访问了主页&quot;);   //达到访问次数限制之后停止服务器运行  if (++repeat == 3) &#123;    Serial.println(&quot;服务器停止运行);    server.close();  &#125;&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.on(&quot;/&quot;, homepage);  server.begin();  Serial.println(&quot;HTTP server started&quot;);&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125;





处理客户端HTTP请求分类客户端请求处理配置分类on – 可找到资源处理配置说明当ESP8266开发板建立网络服务器以后，每当有客户端向服务器发送HTTP请求时，我们可以利用on函数来设置HTTP请求回调函数。
通过HTTP请求回调函数，我们可以让ESP8266服务器生成响应信息并发送给HTTP请求客户端。
语法server.on(uri, uri_handler);server.on(uri, method, uri_handler);
参数– uri: HTTP请求客户端所请求的uri（参数类型:const String*）
– uri_handler: HTTP请求回调函数（参数类型:THandlerFunction）
– method: 此参数用于设置向客户端发送响应信息时所使用的HTTP方法。以下为可供选择的响应方法关键字。

HTTP_ANY
HTTP_GET
HTTP_POST
HTTP_PUT
HTTP_PATCH
HTTP_DELETE
HTTP_OPTIONS

返回值无
示例程序如需进一步了解本示例程序的详细使用方法，特别是on函数的功能，请参考《零基础入门学用物联网》免费视频教程中“ESP8266-NodeMCU网络服务器”部分内容。
当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址。此时，ESP8266已经成功建立了网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。
当您在浏览器地址栏中输入IP后并按下回车，这时您将看到浏览器中显示上图所示的网页页面。该页面即是通过ESP8266所建立的。
在以下示例程序中，我们使用了server.on(“&#x2F;”, homepage);语句来设置浏览器访问网站首页时的回调函数“homepage”。
/**********************************************************************  程序名称/Program name     : WebServer_demo_on  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问***********************************************************************/  #include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置您的WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; ESP8266WebServer server(80); void homepage() &#123;  server.send(200, &quot;text/plain&quot;, &quot;test homepage !&quot;);  Serial.println(&quot;用户访问了主页&quot;);&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.on(&quot;/&quot;, homepage);  server.begin();  Serial.println(&quot;HTTP server started&quot;);&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125;

相关内容– onNotFound – 未找到资源处理配置– onFileUpload – 文件上传处理配置– addHandler – 设置请求响应回调
onNotFound – 未找到资源处理配置说明当ESP8266开发板建立网络服务器以后，每当有客户端向服务器发送HTTP请求时，我们可以利用onNotFound函数来设置HTTP请求无效地址的回调函数。
通过无效地址回调函数，我们可以让ESP8266服务器生成响应信息并在客户端请求无效地址时，将404页面信息发送给客户端。
语法server.onNotFound(function)

参数function – 处理无效地址请求的回调函数(类型: THandlerFunction)
返回值无
示例程序当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址。此时，ESP8266已经成功建立了网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。
当您在浏览器地址栏中输入IP后并按下回车，这时您将看到浏览器中显示上图所示的网页页面。该页面即是通过ESP8266所建立的。
在以下示例程序中，我们使用了server.onNotFound(handleNotFound);语句来设置浏览器访问无效地址的回调函数“handleNotFound”。
/**********************************************************************  程序名称/Program name     : WebServer_demo_onNotFound  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问  当访问地址为主页之外的路劲时返回404页面***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置您的WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; ESP8266WebServer server(80); //设置主页void homepage() &#123;  server.send(200, &quot;text/plain&quot;, &quot;test homepage !&quot;);  Serial.println(&quot;用户访问了主页&quot;);&#125; // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound() &#123;                                       // 当浏览器请求的网络资源无法在服务器找到时，  server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);   // NodeMCU将调用此函数。&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.on(&quot;/&quot;, homepage);  server.onNotFound(handleNotFound);  server.begin();  Serial.println(&quot;HTTP server started&quot;);&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125;

相关内容– on – 可找到资源处理配置– onFileUpload – 文件上传处理配置– addHandler – 设置请求响应回调
onFileUpload – 文件上传处理配置说明当ESP8266建立的网络服务器收到了客户端的文件上传请求时，我们可以利用此函数来配置处理文件上传请求的回调函数。
语法server.onFileUpload(function)

参数function
– 处理文件上传请求的回调函数(类型: THandlerFunction)
返回值无
相关内容– on – 可找到资源处理配置– onNotFound – 未找到资源处理配置– onFileUpload – 文件上传处理配置– addHandler – 设置请求响应回调
addHandler – 设置请求响应回调说明该函数可自定义请求处理。
语法server.addHandler(requestHandler)

参数requestHandler: RequestHandler对象
返回值无
处理客户端请求分类handleClient – 处理客户端请求说明此函数主要作用是检查有没有客户端设备通过网络向ESP8266网络服务器发送请求。每一次handleClient&#96;函数被调用时，ESP8266网络服务器都会检查一下是否有客户端发送HTTP请求。因此建议将该函数放在loop函数中，从而确保它能经常被调用。
假如loop函数里有类似delay一类的函数延迟程序运行，那么就一定要注意了。如果handleClient函数长时间得不到调用，ESP8266网络服务器会因为无法经常检查HTTP客户端请求而导致服务器响应变慢，严重的情况下，会导致服务器工作不稳定。
语法server.handleClient()

参数无
返回值无
示例程序当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址。此时，ESP8266已经成功建立了网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。
当您在浏览器地址栏中输入IP后并按下回车，这时您将看到浏览器中显示上图所示的网页页面。该页面即是通过ESP8266所建立的。以下示例程序中，我们使用了esp8266_server.handleClient(); 语句来让ESP8266检查浏览器的请求。
/**********************************************************************程序名称/Program name     : 3_2_1_First_Web_Server程序目的/Purpose          : 使用NodeMCU建立基本服务器。用户可通过浏览器使用8266的IP地址                           访问8266所建立的基本网页（Hello from ESP8266）***********************************************************************/#include &lt;ESP8266WiFi.h&gt;        // 本程序使用 ESP8266WiFi库#include &lt;ESP8266WiFiMulti.h&gt;   //  ESP8266WiFiMulti库#include &lt;ESP8266WebServer.h&gt;   //  ESP8266WebServer库 ESP8266WiFiMulti wifiMulti;     // 建立ESP8266WiFiMulti对象,对象名称是&#x27;wifiMulti&#x27; ESP8266WebServer esp8266_server(80);// 建立ESP8266WebServer对象，对象名称为esp8266_server                                    // 括号中的数字是网路服务器响应http请求的端口号                                    // 网络服务器标准http端口号为80，因此这里使用80为端口号 void setup(void)&#123;  Serial.begin(9600);          // 启动串口通讯   //通过addAp函数存储  WiFi名称       WiFi密码  wifiMulti.addAP(&quot;taichi-maker&quot;, &quot;12345678&quot;);  // 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。  wifiMulti.addAP(&quot;taichi-maker2&quot;, &quot;87654321&quot;); // 这3个WiFi网络名称分别是taichi-maker, taichi-maker2, taichi-maker3。  wifiMulti.addAP(&quot;taichi-maker3&quot;, &quot;13572468&quot;); // 这3个网络的密码分别是123456789，87654321，13572468。                                                // 此处WiFi信息只是示例，请在使用时将需要连接的WiFi信息填入相应位置。                                                // 另外这里只存储了3个WiFi信息，您可以存储更多的WiFi信息在此处。   int i = 0;                                   while (wifiMulti.run() != WL_CONNECTED) &#123;  // 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前    delay(1000);                             // 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU    Serial.print(i++); Serial.print(&#x27; &#x27;);    // 将会连接信号最强的那一个WiFi信号。  &#125;                                          // 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是                                             // 此处while循环判断是否跳出循环的条件。   // WiFi连接成功后将通过串口监视器输出连接成功信息   Serial.println(&#x27;\n&#x27;);                     // WiFi连接成功后  Serial.print(&quot;Connected to &quot;);            // NodeMCU将通过串口监视器输出。  Serial.println(WiFi.SSID());              // 连接的WiFI名称  Serial.print(&quot;IP address:\t&quot;);            // 以及  Serial.println(WiFi.localIP());           // NodeMCU的IP地址  //--------&quot;启动网络服务功能&quot;程序部分开始-------- //  此部分为程序为本示例程序重点1  esp8266_server.begin();                   //  详细讲解请参见太极创客网站《零基础入门学用物联网》  esp8266_server.on(&quot;/&quot;, handleRoot);       //  第3章-第2节 ESP8266-NodeMCU网络服务器-1  esp8266_server.onNotFound(handleNotFound);        //--------&quot;启动网络服务功能&quot;程序部分结束--------  Serial.println(&quot;HTTP esp8266_server started&quot;);//  告知用户ESP8266网络服务功能已经启动&#125; /* 以下函数语句为本示例程序重点3详细讲解请参见太极创客网站《零基础入门学用物联网》第3章-第2节 3_2_1_First_Web_Server 的说明讲解*/  void loop(void)&#123;  esp8266_server.handleClient();     // 处理http服务器访问&#125; /* 以下两个函数为本示例程序重点2详细讲解请参见太极创客网站《零基础入门学用物联网》第3章-第2节 3_2_1_First_Web_Server 的说明讲解*/                                                                            void handleRoot() &#123;   //处理网站根目录“/”的访问请求   esp8266_server.send(200, &quot;text/plain&quot;, &quot;Hello from ESP8266&quot;);   // NodeMCU将调用此函数。&#125; // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound()&#123;                                        // 当浏览器请求的网络资源无法在服务器找到时，  esp8266_server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);   // NodeMCU将调用此函数。&#125;

相关内容– on – 可找到资源处理配置– onNotFound – 未找到资源处理配置– onFileUpload – 文件上传处理配置– addHandler – 设置请求响应回调
获取客户端请求信息分类获取客户端请求行信息分类
uri – 获取请求路径说明使用该函数可获取客户端发送的HTTP请求行中的请求资源路径信息。
语法server.uri()

参数无
返回值客户端请求行中的请求资源路径信息。（类型：字符串）
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。
浏览器请求发送之后，您就可以通过ESP8266开发板串口监视器看到浏览器发送的GET请求路径。我们在以下示例程序中使用了Serial.println(server.uri());语句来实现通过串口监视器输出浏览器请求资源路径。
/**********************************************************************  程序名称/Program name     : WebServer_demo_uri  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; ESP8266WebServer server(80); //设置访问次数变量int repeat = 0; // 设置主页请求处理函数void homepage() &#123;  server.send(200, &quot;text/plain&quot;, &quot;test homepage&quot;);  Serial.println(&quot;用户访问了主页&quot;);  Serial.println(server.uri());  //达到访问次数限制之后停止服务器运行  if (++repeat == 50) &#123;    Serial.println(&quot;Done&quot;);    server.stop();  &#125;&#125;  // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound() &#123;                                       // 当浏览器请求的网络资源无法在服务器找到时，  server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);           // NodeMCU将调用此函数。  Serial.print(&quot;当前请求路径 :&quot;);   Serial.print(WiFi.localIP());   Serial.println(server.uri());  //串口输出当前客户端的请求路径    Serial.print(&quot;当前请求方法 :&quot;);   Serial.println(server.method());  //串口输出当前客户端的请求方法&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.begin();  server.on(&quot;/&quot;, homepage);  server.onNotFound(handleNotFound);  Serial.println(&quot;HTTP server started&quot;);&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125;

相关内容– uri – 获取请求路径– method – 获取请求方法
method – 获取请求方法说明此函数用于获取客户端的HTTP请求方法。
语法server.method()

参数无
返回值HTTP请求方法代表值。（类型: HTTPMethod）
以下为各请求方法及其所对应的代表值。

HTTP_ANY   1
HTTP_GET   1
HTTP_POST   3
HTTP_PUT   4
HTTP_PATCH   5
HTTP_DELETE   6
HTTP_OPTIONS   7

示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。
浏览器请求发送之后，您就可以通过ESP8266开发板串口监视器看到浏览器发送的GET请求方法。
/**********************************************************************  项目名称/Project          : 零基础入门学用物联网  程序名称/Program name     : WebServer_demo_uri  团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)  作者/Author              : Dapenson  日期/Date（YYYYMMDD）     : 20200320  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问  -----------------------------------------------------------------------  本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。  该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：  http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; ESP8266WebServer server(80); //设置访问次数变量int repeat = 0; // 设置主页请求处理函数void homepage() &#123;  server.send(200, &quot;text/plain&quot;, &quot;test homepage&quot;);  Serial.println(&quot;用户访问了主页&quot;);  Serial.println(server.method());  //串口输出当前客户端的请求方法  //达到访问次数限制之后停止服务器运行  if (++repeat == 50) &#123;    Serial.println(&quot;Done&quot;);    server.stop();  &#125;&#125; // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound() &#123;                                       // 当浏览器请求的网络资源无法在服务器找到时，  server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);           // NodeMCU将调用此函数。    Serial.print(&quot;当前请求路径 :&quot;);   Serial.print(WiFi.localIP());   Serial.println(server.uri());  //串口输出当前客户端的请求路径    Serial.print(&quot;当前请求方法 :&quot;);   Serial.println(server.method());  //串口输出当前客户端的请求方法&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.begin();  server.on(&quot;/&quot;, homepage);  server.onNotFound(handleNotFound);  Serial.println(&quot;HTTP server started&quot;);&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125;

相关内容– uri – 获取请求路径
获取客户端请求头信息分类
collectHeaders – 设置需要收集哪些请求头信息说明使用ESP8266开发板实现的物联网服务器可以收集客户端发送的请求头信息。我们知道，HTTP客户端发送的请求信息中通常是包含多个HTTP请求头信息的。利用collectHeaders函数，我们可以设置需要获取的HTTP请求头信息，以便我们在后面的程序中加以处理使用。
请注意：在我们使用ESP8266WebServer库中的headers、header 、headerName、hasHeader 函数来获取浏览器请求头以前，需要首先调用本函数来设置ESP8266具体收集哪些请求头信息。
语法server.collectHeaders(headerKeys, headerKeysCount)

参数– headerKeys: 请求头名数组。此数组中的元素即是需要ESP8266处理或收集的请求头信息。下面我们看一个headerKeys数组的例子：const char *headerKeys[] &#x3D; {“Content-Length”, “Date”};此数组共有两个元素，分别是”Content-Length”和”Date”。只有如此建立了数组后，接下来的程序里我们才可以使用其它ESP8266WebServer库函数来处理这两个请求头的信息内容。可以把这个数组看作是对ESP8266的提醒，即告诉ESP8266在后续的程序中，我们将要对数组中所包含的请求头信息进行处理。（具体操作方法，请见本函数的示例程序部分。）
– headerKeysCount: 需要获取&#x2F;处理的请求头个数（可选参数，类型：size_t）
返回值无
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。
浏览器请求发送之后，您就可以通过ESP8266开发板串口监视器看到浏览器发送的请求头信息中的connection以及HOST信息。（如下图所示）

/**********************************************************************  程序名称/Program name     : WebServer_demo_collectHeaders  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问  访问主页将从串口反馈请求头的信息,具体内容请参考自定义函数 echo_headers()  注:本示例程序为获取客户端请求头信息分类函数中功能较全的版本***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; //创建 ESP8266WebServer 对象ESP8266WebServer server(80); //设置访问次数变量int repeat = 0;//设置需要收集的请求头信息const char *headerKeys[] = &#123;&quot;Content-Length&quot;, &quot;Content-Type&quot;, &quot;Connection&quot;, &quot;Date&quot;&#125;; // 设置主页请求处理函数void homepage() &#123;  server.send(200, &quot;text/plain&quot;, &quot;test homepage&quot;);  Serial.println(&quot;用户访问了主页&quot;);  echo_headers();  //达到访问次数限制之后停止服务器运行  if (++repeat == 50) &#123;    Serial.println(&quot;Done&quot;);    server.stop();  &#125;&#125;  // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound() &#123;                                       // 当浏览器请求的网络资源无法在服务器找到时，  server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);           // NodeMCU将调用此函数。  echo_headers();&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.begin();  server.on(&quot;/&quot;, homepage);  server.onNotFound(handleNotFound);  Serial.println(&quot;HTTP server started&quot;);  server.collectHeaders(headerKeys, sizeof(headerKeys) / sizeof(headerKeys[0])); &#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125; void echo_headers() &#123;   if (server.hasHeader(&quot;Connection&quot;)) &#123;//判断该请求头是否存在    //使用示例,打印当前收集的请求头的数量    Serial.print(&quot;当前请求所收集的请求头数量:&quot;); Serial.println(server.headers());     //打印当前请求中所收集的请求头指定项的值    Serial.print(&quot;当前请求所收集的请求头Connection:&quot;); Serial.println(server.header(&quot;Connection&quot;));     //打印当前请求中所收集的Host    Serial.print(&quot;当前请求所收集的请求头Host :&quot;); Serial.println(server.hostHeader());    //分隔空行    Serial.println(&quot;\r\n&quot;);  &#125;&#125;

相关内容– headers – 获得请求头数量– header – 获得指定请求头所对应的数值– headerName – 获取指定请求头的名称– hasHeader – 确定是否包含指定请求头
headers – 获得请求头数量说明使用本函数，我们可以获取客户端向ESP8266物联网服务器发送的请求头数量
请注意，使用此函数前必须先使用collectHeaders函数来设置具体收集的请求头内容。
语法server.headers()

参数无
返回值获取的响应头的数量 （返回值类型:int）
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。
浏览器请求发送之后，您就可以通过串口监视器看到开发板的开发板收集的请求头数量。下图是程序运行结果。

/**********************************************************************  程序名称/Program name     : WebServer_demo_headers  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问  访问主页将从串口反馈请求头的信息,具体内容请参考自定义函数 echo_headers()***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; //创建 ESP8266WebServer 对象ESP8266WebServer server(80); //设置访问次数变量int repeat = 0;//设置需要收集的请求头信息const char *headerKeys[] = &#123;&quot;Connection&quot;&#125;; // 设置主页请求处理函数void homepage() &#123;  server.send(200, &quot;text/plain&quot;, &quot;test homepage&quot;);  Serial.println(&quot;用户访问了主页&quot;);  echo_headers();&#125; // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound() &#123;                                       // 当浏览器请求的网络资源无法在服务器找到时，  server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);           // NodeMCU将调用此函数。  echo_headers();&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.begin();  server.on(&quot;/&quot;, homepage);  server.onNotFound(handleNotFound);  Serial.println(&quot;HTTP server started&quot;);  server.collectHeaders(headerKeys, sizeof(headerKeys) / sizeof(headerKeys[0]));&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125; void echo_headers() &#123;    //使用示例,打印当前收集的请求头的数量    Serial.print(&quot;当前请求所收集的请求头数量:&quot;); Serial.println(server.headers());&#125;

相关内容– collectHeaders – 设置需要收集哪些请求头信息– header – 获得指定请求头所对应的数值– headerName – 获取指定请求头的名称– hasHeader – 确定是否包含指定请求头
header – 获得指定请求头所对应的数值说明使用本函数，我们可以获取客户端向ESP8266物联网服务器发送的请求头参数值。
请注意，使用此函数前必须先使用collectHeaders函数来设置具体收集的请求头内容。
语法server.header(name)server.header(index)
参数– name: 响应头名称(参数类型: String )– index: 响应头序号(参数类型: int)
返回值返回请求头中指定项的值。(类型: String )
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。
浏览器请求发送之后，您就可以通过串口监视器看到浏览器发送的“connection”请求头信息。
具体实现这一功能是通过以下程序中高亮语句server.header(&quot;Connection&quot;)实现的。该语句中header函数的参数”Connection”即是设置开发板要获取的是客户端请求头信息中的”Connection”参数值。

/**********************************************************************=  程序名称/Program name     : WebServer_demo_header  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问  访问主页将从串口反馈请求头的信息,具体内容请参考自定义函数 echo_headers()***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; //创建 ESP8266WebServer 对象ESP8266WebServer server(80); //设置需要收集的请求头信息const char *headerKeys[] = &#123;&quot;Content-Length&quot;, &quot;Content-Type&quot;, &quot;Connection&quot;, &quot;Date&quot;&#125;; // 设置主页请求处理函数void homepage() &#123;  server.send(200, &quot;text/plain&quot;, &quot;test homepage&quot;);  Serial.println(&quot;用户访问了主页&quot;);  echo_headers();&#125; // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound() &#123;                                       // 当浏览器请求的网络资源无法在服务器找到时，  server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);           // NodeMCU将调用此函数。  echo_headers();&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.begin();  server.on(&quot;/&quot;, homepage);  server.onNotFound(handleNotFound);  Serial.println(&quot;HTTP server started&quot;);  server.collectHeaders(headerKeys, sizeof(headerKeys) / sizeof(headerKeys[0])); &#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125; void echo_headers() &#123;  //打印当前请求中所收集的请求头的值信息,请求头名称+请求头值  Serial.print(&quot;Header \&quot;Connection\&quot;: &quot;); Serial.println(server.header(&quot;Connection&quot;));&#125;

相关内容– collectHeaders – 设置需要收集哪些请求头信息– headers – 获得请求头数量– headerName – 获取指定请求头的名称– hasHeader – 确定是否包含指定请求头
headerName – 获取指定请求头的名称说明使用本函数，我们可以获取客户端向ESP8266物联网服务器发送的请求头的名称。
请注意，使用此函数前必须先使用collectHeaders函数来设置具体收集的请求头内容。
语法server.headerName(index)

参数index: 请求头序号。（类型: int）
返回值指定请求头名称（类型: String）
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。
浏览器请求发送之后，您就可以通过串口监视器看到浏览器发送的请求头名称以及该请求头对应的数值。
以下程序使用了server.headerName(1)获取序号为1的请求头名称，也就是”Connection”。下图是程序运行的结果。

/**********************************************************************  程序名称/Program name     : WebServer_demo_headerName  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问  访问主页将从串口反馈请求头的信息,具体内容请参考自定义函数 echo_headers()***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; //创建 ESP8266WebServer 对象ESP8266WebServer server(80); //设置需要收集的请求头信息const char *headerKeys[] = &#123;&quot;Connection&quot;&#125;; // 设置主页请求处理函数void homepage() &#123;  server.send(200, &quot;text/plain&quot;, &quot;test homepage&quot;);  Serial.println(&quot;用户访问了主页&quot;);  echo_headers();&#125;  // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound() &#123;                                       // 当浏览器请求的网络资源无法在服务器找到时，  server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);           // NodeMCU将调用此函数。  echo_headers();&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.begin();  server.on(&quot;/&quot;, homepage);  server.onNotFound(handleNotFound);  Serial.println(&quot;HTTP server started&quot;);  server.collectHeaders(headerKeys, sizeof(headerKeys) / sizeof(headerKeys[0])); &#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125; void echo_headers() &#123;  //打印当前请求中所收集的请求头的值信息,请求头名称+请求头值  Serial.print(server.headerName(1));   Serial.print(&quot; = &quot;);   Serial.println(server.header(1));&#125;

相关内容– collectHeaders – 设置需要收集哪些请求头信息– headers – 获得请求头数量– header – 获得指定请求头所对应的数值– hasHeader – 确定是否包含指定请求头
hasHeader – 确定是否包含指定请求头说明使用本函数，我们可以获取客户端向ESP8266物联网服务器发送的请求头中有无用户指定的请求头信息。
请注意，使用此函数前必须先使用collectHeaders函数来设置具体收集的请求头内容。
语法server.hasHeader(name)

参数name需要确认客户端请求中是否存在的请求头信息名。(参数类型:String)
返回值检查请求头中是否存在指定请求头信息。如果存在则返回真,否则返回假。返回值类型: bool
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。
浏览器请求发送之后，您就可以通过串口监视器看到浏览器发送的请求头中是否存在“Connection”信息。
以下示例程序使用了server.hasHeader(“Connection”)来判断浏览器发送的请求头中是否存在“Connection”信息。以下是该程序运行的结果演示。

/**********************************************************************  程序名称/Program name     : WebServer_demo_hasHeader  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问  并从串口反馈请求头的信息,具体内容请参考自定义函数 echo_headers()***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; //创建 ESP8266WebServer 实例化对象ESP8266WebServer server(80); //设置需要收集的请求头信息const char *headerKeys[] = &#123; &quot;Connection&quot;&#125;; // 设置主页请求处理函数void homepage() &#123;  server.send(200, &quot;text/plain&quot;, &quot;test homepage&quot;);  Serial.println(&quot;用户访问了主页&quot;);  echo_headers();&#125;  // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound() &#123;                                       // 当浏览器请求的网络资源无法在服务器找到时，  server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);           // NodeMCU将调用此函数。  echo_headers();&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.begin();  server.on(&quot;/&quot;, homepage);  server.onNotFound(handleNotFound);  Serial.println(&quot;HTTP server started&quot;);  server.collectHeaders(headerKeys, sizeof(headerKeys) / sizeof(headerKeys[0])); &#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125; void echo_headers() &#123;   //判断该请求头是否存在Connection信息  if (server.hasHeader(&quot;Connection&quot;)) &#123;    Serial.println(&quot;请求信息包含Connection&quot;);   &#125; else &#123;    Serial.println(&quot;请求信息不包含Connection&quot;);   &#125; &#125;

相关内容– collectHeaders – 设置需要收集哪些请求头信息– headers – 获得请求头数量– header – 获得指定请求头所对应的数值– headerName – 获取指定请求头的名称
authenticate – 请求认证校验说明我们在使用ESP8266开发板实现物联网服务器时，可以通过本函数建立加密网页。也就是说，用户必须正确输入访问用户名和密码方可访问物联网服务器所建立的页面内容。
请注意，与此函数配套使用的是requestAuthentication函数。requestAuthentication函数用于向客户端发送认证请求，而authenticate函数用于设置与校验客户端请求信息中的用户名和密码。
语法authenticate(username, password)

参数username：客户端访问物联网服务器加密页面时的认证用户名（参数类型:const char*）
password：客户端访问物联网服务器加密页面时的认证密码（参数类型:const char*）
返回值
如果用户密码输入正确则返回真,输入错误则返回假。
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。
接下来浏览器将会弹出对话框，要求用户输入用户名:TaichiMaker和密码:123456。如下图所示。

只有当用户正确输入了用户名和密码信息以后，方可打开ESP8266开发板建立的网站页面。（如下图所示）

以下示例程序中的高亮语句server.authenticate(&quot;TaichiMaker&quot;, &quot;123456&quot;)设置了服务器的访问用户名和密码信息。
/**********************************************************************  程序名称/Program name     : WebServer_demo_authenticate  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问  在登录主页时使用认证方式登录,并从串口反馈请求头的信息***********************************************************************/  #include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;XXXXXXXX&quot;; ESP8266WebServer server(80); //设置需要收集的请求头信息const char *headerKeys[] = &#123;&quot;Content-Length&quot;, &quot;Content-Type&quot;, &quot;Connection&quot;, &quot;Date&quot;&#125;; // 设置主页请求处理函数void homepage() &#123;   //校验用户登录账号和密码,(使用Basic方式),若输入错误则继续返回认证界面  if (!server.authenticate(&quot;TaichiMaker&quot;, &quot;123456&quot;)) return server.requestAuthentication();   server.send(200, &quot;text/plain&quot;, &quot;test homepage&quot;);  Serial.println(&quot;用户访问了主页&quot;);  echo_headers();&#125;  // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound() &#123;                                       // 当浏览器请求的网络资源无法在服务器找到时，  server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);           // NodeMCU将调用此函数。  echo_headers();&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.begin();  //设置主页处理函数  server.on(&quot;/&quot;, homepage);  //设置404页面  server.onNotFound(handleNotFound);  //串口输出服务器准备完成信息  Serial.println(&quot;HTTP server started&quot;);  //设置需要收集的请求头信息  server.collectHeaders(headerKeys, sizeof(headerKeys) / sizeof(headerKeys[0]));&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125; void echo_headers() &#123;   if (server.hasHeader(&quot;Connection&quot;)) &#123;//判断该请求头是否存在     //打印当前请求中所收集的请求头指定项的值    Serial.print(&quot;当前请求所收集的请求头Connection:&quot;); Serial.println(server.header(&quot;Connection&quot;));     //打印当前请求中所收集的Host    Serial.print(&quot;当前请求所收集的请求头Host :&quot;); Serial.println(server.hostHeader());    //分隔空行    Serial.println(&quot;\r\n&quot;);  &#125;&#125;



相关内容– requestAuthentication
获取客户端请求参数信息分类
args – 请求包含的参数数量说明使用本函数，我们可以获取客户端向ESP8266物联网服务器发送的请求体中的参数数量。
语法server.args()

参数无
返回值返回获取的请求体中所包含的参数数量（返回值类型:int）
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
假设您的开发板IP地址为192.168.0.106，那么接下来您可以通过浏览器输入以下地址信息。
http://192.168.0.106/?a=1&amp;b=2
我们可以看到，以上信息中有两个参数，那么接下来您就可以通过串口监视器查看开发板所接收到的参数数量。如下图所示。

在以下的示例程序中，我们通过使用server.args()来获取客户端请求信息中的参数数量。
/**********************************************************************  项目名称/Project          : 零基础入门学用物联网  程序名称/Program name     : WebServer_demo_args  团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)  作者/Author              : Dapenson  日期/Date（YYYYMMDD）     : 20200320  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问  并在请求成功后返回请求体的参数数量,具体请参考自定义函数 echo_args()中的内容  -----------------------------------------------------------------------  本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。  该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：  http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;XXXXXXXX&quot;; //创建ESP8266WebServer对象ESP8266WebServer server(80); void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.begin();  //设置主页处理函数  server.on(&quot;/&quot;, homepage);  //设置404页面  server.onNotFound(handleNotFound);  //串口输出服务器准备完成信息  Serial.println(&quot;HTTP server started&quot;);&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125; //自定义返回请求体信息void echo_args() &#123;  Serial.print(&quot;当前请求中请求体数量:&quot;); Serial.println(server.args());&#125; // 设置主页请求处理函数void homepage() &#123;  server.send(200, &quot;text/plain&quot;, &quot;test homepage&quot;);  Serial.println(&quot;用户访问了主页&quot;);  echo_args();&#125; // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound() &#123;                                       // 当浏览器请求的网络资源无法在服务器找到时，  server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);           // NodeMCU将调用此函数。  echo_args();&#125;

相关内容– arg – 请求中指定参数的数值– argName – 请求中参数名– hasArg – 判断请求中是否包含某个参数名
arg – 请求中指定参数的数值说明使用本函数，我们可以获取客户端向ESP8266物联网服务器发送的指定参数的数值。
语法server.arg(Name)server.arg(index)
参数– Name请求体中的参数名（参数类型: String）
– index请求体中的参数序列号（参数类型: int）
返回值指定参数的数值（类型：String）
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
假设您的开发板IP地址为192.168.0.106，那么接下来您可以通过浏览器输入以下地址信息。
http://192.168.0.106/?a=1&amp;b=2&amp;c=3
我们可以看到，以上信息中有三个参数，这些参数中，a的数值为1，序列号为2的参数数值为3（序列号0的参数为a, 序列号1的参数为b…）。
在以下示例程序中，我们使用server.arg(&quot;a&quot;)来获取参数a的数值。使用server.arg(2)来获取序列号为2的参数数值。以下是串口监视器显示的以上语句所获取的参数数值。 

/**********************************************************************  程序名称/Program name     : WebServer_demo_arg  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问  并在请求成功后返回请求体的指定请求项的值,具体请参考自定义函数 echo_args()中的内容***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; //创建ESP8266WebServer对象ESP8266WebServer server(80); void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.begin();  //设置主页处理函数  server.on(&quot;/&quot;, homepage);  //设置404页面  server.onNotFound(handleNotFound);  //串口输出服务器准备完成信息  Serial.println(&quot;HTTP server started&quot;);&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125; //自定义返回请求体信息void echo_args() &#123;  Serial.print(&quot;请求体参数a的值:&quot;); Serial.println(server.arg(&quot;a&quot;));  Serial.print(&quot;请求体第2个参数的值:&quot;); Serial.println(server.arg(2));&#125; // 设置主页请求处理函数void homepage() &#123;  server.send(200, &quot;text/plain&quot;, &quot;test homepage&quot;);  Serial.println(&quot;用户访问了主页&quot;);  echo_args();&#125; // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound() &#123;                                       // 当浏览器请求的网络资源无法在服务器找到时，  server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);           // NodeMCU将调用此函数。  echo_args();&#125;

相关内容– args – 请求包含的参数数量– argName – 请求中参数名– hasArg – 判断请求中是否包含某个参数名
argName – 请求中参数名说明使用本函数，我们可以获取客户端向ESP8266物联网服务器发送的指定参数名称。
语法server.argName(index)

参数– index请求体中的参数序列号（参数类型: int）
返回值请求信息中指定参数的名称 (返回值类型: String)
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
假设您的开发板IP地址为192.168.0.106，那么接下来您可以通过浏览器输入以下地址信息。
http://192.168.0.106/?a=1&amp;b=2&amp;c=3
在以下示例程序中，我们使用了server.argName(2)来获取序列号为2的参数名称，也就是c（序列号0的参数为a, 序列号1的参数为b…）。以下是串口监视器显示的以上语句所获取的参数名称。

/**********************************************************************  程序名称/Program name     : WebServer_demo_argName  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问  并在请求成功后返回请求体的指定项名称,具体请参考自定义函数 echo_args()中的内容***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;12345678&quot;; //创建ESP8266WebServer对象ESP8266WebServer server(80); void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.begin();  //设置主页处理函数  server.on(&quot;/&quot;, homepage);  //设置404页面  server.onNotFound(handleNotFound);  //串口输出服务器准备完成信息  Serial.println(&quot;HTTP server started&quot;);&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125; //自定义返回请求体信息void echo_args() &#123;  Serial.print(&quot;当前请求中请求体2的名称:&quot;);  Serial.println(server.argName(2));&#125; // 设置主页请求处理函数void homepage() &#123;  server.send(200, &quot;text/plain&quot;, &quot;test homepage&quot;);  Serial.println(&quot;用户访问了主页&quot;);  echo_args();&#125; // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound() &#123;                                       // 当浏览器请求的网络资源无法在服务器找到时，  server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);           // NodeMCU将调用此函数。  echo_args();&#125;

相关内容– args – 请求包含的参数数量– arg – 请求中指定参数的数值– hasArg – 判断请求中是否包含某个参数名
hasArg – 判断请求中是否包含某个参数名说明使用本函数，我们可以获取客户端向ESP8266物联网服务器发送的请求信息中有无指定的参数。
语法server.hasArg(name)
参数– Name需要确认的请求体中的参数名（参数类型: String）
返回值返回是否存在指定参数（类型bool）
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
假设您的开发板IP地址为192.168.0.106，那么接下来您可以通过浏览器输入以下地址信息。
http://192.168.0.106/?token=abc
在以下示例程序中，我们使用了server.hasArg(&quot;token&quot;)来判断请求信息中是否有名称为”token”的参数。如果有此参数，则通过串口监视器输出参数数值。如下图示：

/**********************************************************************  程序名称/Program name     : WebServer_demo_hasArg  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问  在请求成功后判断是否存在该请求体指定项并返回请求体的指定请求项的值  具体请参考自定义函数 echo_args()中的内容***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;12345678&quot;; //创建ESP8266WebServer对象ESP8266WebServer server(80); void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.begin();  //设置主页处理函数  server.on(&quot;/&quot;, homepage);  //设置404页面  server.onNotFound(handleNotFound);  //串口输出服务器准备完成信息  Serial.println(&quot;HTTP server started&quot;);&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125; //自定义返回请求体信息void echo_args() &#123;  if (server.hasArg(&quot;token&quot;)) &#123;    Serial.print(&quot;请求中token参数的值:&quot;);     Serial.println(server.arg(&quot;token&quot;));  &#125;  else &#123;    Serial.println(&quot;当前请求中无法找到指定请求体内容&quot;);  &#125;&#125; // 设置主页请求处理函数void homepage() &#123;  server.send(200, &quot;text/plain&quot;, &quot;test homepage&quot;);  Serial.println(&quot;用户访问了主页&quot;);  echo_args();&#125; // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound() &#123;                                       // 当浏览器请求的网络资源无法在服务器找到时，  server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);           // NodeMCU将调用此函数。  echo_args();&#125;

相关内容– args – 请求包含的参数数量– arg – 请求中指定参数的数值– argName – 请求中参数名
响应客户端请求分类send – 发送响应信息说明在ESP8266开发板所建立的物联网服务器在运行过程中，如果有客户端向ESP8266服务器发送HTTP请求，ESP8266服务器可使用本函数向客户端发送响应信息。
语法send(responseCode, contentType, responseContent)

参数– responseCode: 响应状态码（类型：int）– contentType: 响应内容类型，本参数为可选参数，如不使用本参数则默认为空NULL（可使用字符串类型）– responseContent: 响应内容，本参数为可选参数，如不使用本参数则默认为空字符串（可使用字符串类型）
返回值无
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。
浏览器请求发送之后，您将会再浏览器中看到ESP8266物联网服务器发送的网页信息。也就是以下示例程序中server.send(200, &quot;text/plain&quot;, &quot;test homepage !&quot;)语句所实现的内容。
/**********************************************************************  程序名称/Program name     : WebServer_demo_send  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置您的WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;XXXXXXXX&quot;; ESP8266WebServer server(80); //自定义主页访问处理函数void homepage() &#123;  server.send(200, &quot;text/plain&quot;, &quot;test homepage !&quot;);  Serial.println(&quot;用户访问了主页&quot;);&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.on(&quot;/&quot;, homepage);  server.begin();  Serial.println(&quot;HTTP server started&quot;);&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125;

相关内容– sendHeader – 发送响应头– sendContent – 发送响应体– sendContent_P – 发送响应信息– setContentLength – 设置响应体长度
sendHeader – 发送响应头说明在ESP8266开发板所建立的物联网服务器在运行过程中，如果有客户端向ESP8266服务器发送HTTP请求，ESP8266服务器将会对客户端发送响应信息。本函数可用于向响应头信息中添加自定义键值对。
语法sendHeader(headerName, headerValue, first)

参数– headerName自定义的响应头信息的名称，可使用字符串类型。
– headerValue自定义的响应头值，可使用字符串类型。
– first设置该响应头是否需要放在第一行，不填则默认为false。（参数类型: bool）
返回值无
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
为了演示本实例程序的运行结果，我在这里使用基于Chrome内核的Microsoft Edge浏览器来进行示例程序操作演示。
如下图所示，首先请打开Microsoft Edge浏览器。并根据下图中的红色箭头知识一步步打开浏览器的“开发者工具”（Developer Tools）。该工具也可以使用快捷键”Ctrl+Shift+i”打开。

假设您的ESP8266开发板IP地址为192.168.0.106，那么请将ESP8266的IP地址输入浏览器地址栏中。
输入IP地址后，接下来请按下回车。如下图中箭头所示，请再点击“开发者工具”中的Network选项卡, 然后点击ESP8266的IP地址即可在右侧的响应信息中看到键值对”device: ESP8266″(下图星标所示)。此信息正是通过以下示例程序中的语句server.sendHeader(&quot;device&quot;, &quot;ESP-8266&quot;)实现的。

这一实验说明ESP8266建立的物联网服务器向浏览器客户端发送的响应头中带有“device:ESP8266”信息。
/**********************************************************************  程序名称/Program name     : WebServer_demo_sendHeader  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问  自定义响应体信息并在客户端访问时返回***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; //创建 ESP8266WebServer 实例对象ESP8266WebServer server(80); // 设置主页请求处理函数void homepage() &#123;  Serial.println(&quot;用户访问了主页&quot;);    //设置自定义响应头内容  server.sendHeader(&quot;device&quot;, &quot;ESP-8266&quot;);    //发送响应信息  server.send(200, &quot;text/plain&quot;, &quot;test homepage&quot;);&#125; // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound() &#123;                                       // 当浏览器请求的网络资源无法在服务器找到时，  server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);           // NodeMCU将调用此函数。&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.begin();  //设置主页处理函数  server.on(&quot;/&quot;, homepage);  //设置404页面  server.onNotFound(handleNotFound);  //串口输出服务器准备完成信息  Serial.println(&quot;HTTP server started&quot;);&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125;

相关内容– send – 发送响应信息– sendHeader – 发送响应头– sendContent_P – 发送响应信息– setContentLength – 设置响应体长度
sendContent – 发送响应体信息说明在ESP8266开发板所建立的物联网服务器在运行过程中，如果有客户端向ESP8266服务器发送HTTP请求，ESP8266服务器将会对客户端发送响应信息。本函数可用于向ESP8266服务器响应体中添加自定义信息。
请留意：可以实现此功能的函数共有三个。一个是sendContent，一个是sendContent_P，还有一个是streamFile。这三个函数虽然功能相同，但是他们所发送的信息存储位置有很大区别。
sendContent: sendContent函数所发送的信息通常是程序中的一个字符串。该函数的优点是直接调用程序内字符串，这个操作比起两外两种方法来说更加简单直接。但是其缺点是，由于存储发送信息的字符串是在程序中的，这会占用开发板的动态内存空间。因此，使用sendContent函数时，发送信息的大小受到了限制。
sendContent_P：当我们使用sendContent_P时，发送的响应信息必须存储在程序存储空间。这一特点大大优化了程序内存占用。因此sendContent_P对于我们在发送较大的响应信息时非常有帮助。但是sendContent_P的信息仍是写在程序中，如果发送的信息需要分为多个文件存储，使用sendContent_P函数是无法胜任的。
streamFile：使用streamFile函数来发送响应信息是最推荐的操作方法。因为streamFile利用了ESP8266开发板的闪存文件系统来存储发送的信息内容。可以说streamFile函数既可以节省程序内存空间，又允许我们将需要发送的信息分为多个文件进行保存。但是使用streamFile时需要我们使用Arduino IDE的闪存文件上传工具预先将文件上传到闪存中。这一操作可能有些朋友不甚了解。不过您可以通过《零基础入门学用物联网》免费视频教程中的“闪存文件系统”部分，了解具体操作方法。
语法sendContent(content)

参数content – 响应体信息，可使用字符串格式。
返回值无
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
为了演示本实例程序的运行结果，我在这里使用基于Chrome内核的Microsoft Edge浏览器来进行示例程序操作演示。
如下图所示，首先请打开Microsoft Edge浏览器。并根据下图中的红色箭头指示一步步打开浏览器的“开发者工具”（Developer Tools）。该工具也可以使用快捷键”Ctrl+Shift+i”打开。

假设您的ESP8266开发板IP地址为192.168.0.106，那么请将ESP8266的IP地址输入浏览器地址栏中。
输入IP地址后，接下来请按下回车。如下图中箭头所示，请点击“开发者工具”中的Network选项卡, 然后点击ESP8266的IP地址，再点击Response选项卡，即可在右侧的响应体信息中看到“sendContent_test_OK”(下图星标所示)。此信息正是通过以下示例程序中的语句server.sendContent(&quot;sendContent_test_OK&quot;)实现的。

/**********************************************************************  程序名称/Program name     : WebServer_demo_sendContent  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问  自定义响应体信息并在客户端访问时返回,使用浏览器访问主页即可查看响应体内容***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; //创建 ESP8266WebServer 实例对象ESP8266WebServer server(80); // 设置主页请求处理函数void homepage() &#123;  Serial.println(&quot;用户访问了主页&quot;);    //设置响应体内容以及响应体长度  server.sendContent(&quot;sendContent_test_OK&quot;);&#125; // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound() &#123;                                       // 当浏览器请求的网络资源无法在服务器找到时，  server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);           // NodeMCU将调用此函数。&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.begin();  //设置主页处理函数  server.on(&quot;/&quot;, homepage);  //设置404页面  server.onNotFound(handleNotFound);  //串口输出服务器准备完成信息  Serial.println(&quot;HTTP server started&quot;);&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125;

相关内容– send – 发送响应信息– sendHeader – 发送响应头– sendContent_P – 发送响应信息– setContentLength – 设置响应体长度– streamFile – 发送响应体信息
sendContent_P – 发送响应体信息说明在ESP8266开发板所建立的物联网服务器在运行过程中，如果有客户端向ESP8266服务器发送HTTP请求，ESP8266服务器将会对客户端发送响应信息。本函数可用于向服务器响应体中添加自定义信息。
请留意：可以实现此功能的函数共有三个。一个是sendContent，一个是sendContent_P，还有一个是streamFile。这三个函数虽然功能相同，但是他们所发送的信息存储位置有很大区别。
sendContent: sendContent函数所发送的信息通常是程序中的一个字符串。该函数的优点是直接调用程序内字符串，这个操作比起两外两种方法来说更加简单直接。但是其缺点是，由于存储发送信息的字符串是在程序中的，这会占用开发板的动态内存空间。因此，使用sendContent函数时，发送信息的大小受到了限制。
sendContent_P：当我们使用sendContent_P时，发送的响应信息必须存储在程序存储空间。这一特点大大优化了程序内存占用。因此sendContent_P对于我们在发送较大的响应信息时非常有帮助。但是sendContent_P的信息仍是写在程序中，如果发送的信息需要分为多个文件存储，使用sendContent_P函数是无法胜任的。
streamFile：使用streamFile函数来发送响应信息是最推荐的操作方法。因为streamFile利用了ESP8266开发板的闪存文件系统来存储发送的信息内容。可以说streamFile函数既可以节省程序内存空间，又允许我们将需要发送的信息分为多个文件进行保存。但是使用streamFile时需要我们使用Arduino IDE的闪存文件上传工具预先将文件上传到闪存中。
语法sendContent_P(responseContent)

参数responseContent: 响应体信息，该信息必须存储在程序存储空间的字符数组。
返回值无
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
假设您的开发板IP地址为192.168.0.106，那么接下来您可以通过浏览器输入以下地址信息。
http://192.168.0.106/
如下图示，接下来您将看到浏览器中显示出一行文字信息。这行信息正是通过以下示例程序中的server.sendContent_P(reponseContent)实现的。其中reponseContent参数信息是通过以下语句建立的。我们可以看到，该语句中的数组是保存在ESP8266开发板的程序存储空间中的。
const char reponseContent[] PROGMEM = &quot;HELLO FROM ESP8266&quot;;


/**********************************************************************  程序名称/Program name     : WebServer_demo_sendContent  程序目的/Purpose          :  此程序用于演示如何使用ESP8266开发板所建立的物联网服务器向客户端响应  储存在程序存储空间中的字符数组信息。使用程序存储空间保存信息可大大节省  程序内存占用。   具体操作如下：  1. 储存在程序存储空间中的字符数组信息  2. 使用sendContent_P函数将数组信息作为响应返回给客户端。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; //创建 ESP8266WebServer 实例对象ESP8266WebServer server(80); // 建立保存在程序存储空间中的字符串const char reponseContent[] PROGMEM = &quot;HELLO FROM ESP8266&quot;; // 设置主页请求处理函数void homepage() &#123;  Serial.println(&quot;用户访问了主页&quot;);    //设置响应体内容  server.sendContent_P(reponseContent);&#125; // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound() &#123;                                       // 当浏览器请求的网络资源无法在服务器找到时，  server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);           // NodeMCU将调用此函数。&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.begin();  //设置主页处理函数  server.on(&quot;/&quot;, homepage);  //设置404页面  server.onNotFound(handleNotFound);  //串口输出服务器准备完成信息  Serial.println(&quot;HTTP server started&quot;);&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125;

相关内容– send – 发送响应信息– sendHeader – 发送响应头– sendContent – 发送响应体– setContentLength – 设置响应体长度– streamFile – 发送响应体信息
streamFile – 发送响应体信息说明在ESP8266开发板所建立的物联网服务器在运行过程中，如果有客户端向服务器发送HTTP请求，服务器将会对客户端发送响应信息。本函数可用于向服务器响应体中添加自定义信息。
请留意：可以实现此功能的函数共有三个。一个是sendContent，一个是sendContent_P，还有一个是streamFile。这三个函数虽然功能相同，但是他们所发送的信息存储位置有很大区别。
sendContent: sendContent函数所发送的信息通常是程序中的一个字符串。该函数的优点是直接调用程序内字符串，这个操作比起两外两种方法来说更加简单直接。但是其缺点是，由于存储发送信息的字符串是在程序中的，这会占用开发板的动态内存空间。因此，使用sendContent函数时，发送信息的大小受到了限制。
sendContent_P：当我们使用sendContent_P时，发送的响应信息必须存储在程序存储空间。这一特点大大优化了程序内存占用。因此sendContent_P对于我们在发送较大的响应信息时非常有帮助。但是sendContent_P的信息仍是写在程序中，如果发送的信息需要分为多个文件存储，使用sendContent_P函数是无法胜任的。
streamFile：使用streamFile函数来发送响应信息是最推荐的操作方法。因为streamFile利用了ESP8266开发板的闪存文件系统来存储发送的信息内容。可以说streamFile函数既可以节省程序内存空间，又允许我们将需要发送的信息分为多个文件进行保存。但是使用streamFile时需要我们使用Arduino IDE的闪存文件上传工具预先将文件上传到闪存中。
语法streamFile(file, contentType)
参数file – 存储有响应信息的闪存文件对象contentType（可选参数） – 响应信息系类型 （const String&amp; ）
语法发送的文件大小，类型：size_t
示例程序首先请将以下下载链接中的网页文件上传到ESP8266的闪存文件系统中。
接下来请将示例程序中的WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
假设您的开发板IP地址为192.168.0.106，那么接下来您可以通过浏览器输入以下地址信息。
http://192.168.0.106/
接下来您将在浏览器中看到以下页面。此页面内容正是ESP8266开发板通过streamFile函数将闪存中的文件内容发送给浏览器的。
/**********************************************************************程序名称/Program name     : 3_4_1_SPIFFS_File_server程序目的/Purpose          : 当用户访问NodeMCU地址时，NodeMCU将会检查访问地址是否指向SPIFFS系统中的文件，并且将该文件显示于用户的浏览器中。如果访问地址所指向的文件无法在SPIFFS中找到，NodeMCU将会向用户发送404信息。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WiFiMulti.h&gt;#include &lt;ESP8266WebServer.h&gt;#include &lt;FS.h&gt;  ESP8266WiFiMulti wifiMulti;     // 建立ESP8266WiFiMulti对象ESP8266WebServer esp8266_server(80);    // 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）void setup() &#123;  Serial.begin(9600);          // 启动串口通讯  Serial.println(&quot;&quot;);    wifiMulti.addAP(&quot;ssid_from_AP_1&quot;, &quot;your_password_for_AP_1&quot;); // 将需要连接的一系列WiFi ID和密码输入这里  wifiMulti.addAP(&quot;ssid_from_AP_2&quot;, &quot;your_password_for_AP_2&quot;); // ESP8266-NodeMCU再启动后会扫描当前网络  wifiMulti.addAP(&quot;ssid_from_AP_3&quot;, &quot;your_password_for_AP_3&quot;); // 环境查找是否有这里列出的WiFi ID。如果有  Serial.println(&quot;Connecting ...&quot;);                            // 则尝试使用此处存储的密码进行连接。    int i = 0;    while (wifiMulti.run() != WL_CONNECTED) &#123; // 尝试进行wifi连接。    delay(1000);    Serial.print(i++); Serial.print(&#x27; &#x27;);  &#125;    // WiFi连接成功后将通过串口监视器输出连接成功信息   Serial.println(&#x27;\n&#x27;);  Serial.print(&quot;Connected to &quot;);  Serial.println(WiFi.SSID());              // 通过串口监视器输出连接的WiFi名称  Serial.print(&quot;IP address:\t&quot;);  Serial.println(WiFi.localIP());           // 通过串口监视器输出ESP8266-NodeMCU的IP  if(SPIFFS.begin())&#123;                       // 启动闪存文件系统    Serial.println(&quot;SPIFFS Started.&quot;);  &#125; else &#123;    Serial.println(&quot;SPIFFS Failed to Start.&quot;);  &#125;    esp8266_server.onNotFound(handleUserRequet);      // 告知系统如何处理用户请求  esp8266_server.begin();                           // 启动网站服务  Serial.println(&quot;HTTP server started&quot;);&#125;void loop(void) &#123;  esp8266_server.handleClient();                    // 处理用户请求&#125;// 处理用户浏览器的HTTP访问void handleUserRequet() &#123;                // 获取用户请求网址信息  String webAddress = esp8266_server.uri();    // 通过handleFileRead函数处处理用户访问  bool fileReadOK = handleFileRead(webAddress);  // 如果在SPIFFS无法找到用户访问的资源，则回复404 (Not Found)  if (!fileReadOK)&#123;                                                     esp8266_server.send(404, &quot;text/plain&quot;, &quot;404 Not Found&quot;);   &#125;&#125;bool handleFileRead(String path) &#123;            //处理浏览器HTTP访问  if (path.endsWith(&quot;/&quot;)) &#123;                   // 如果访问地址以&quot;/&quot;为结尾    path = &quot;/index.html&quot;;                     // 则将访问地址修改为/index.html便于SPIFFS访问  &#125;     String contentType = getContentType(path);  // 获取文件类型    if (SPIFFS.exists(path)) &#123;                     // 如果访问的文件可以在SPIFFS中找到    File file = SPIFFS.open(path, &quot;r&quot;);          // 则尝试打开该文件    esp8266_server.streamFile(file, contentType);// 并且将该文件返回给浏览器    file.close();                                // 并且关闭文件    return true;                                 // 返回true  &#125;  return false;                                  // 如果文件未找到，则返回false&#125;// 获取文件类型String getContentType(String filename)&#123;  if(filename.endsWith(&quot;.htm&quot;)) return &quot;text/html&quot;;  else if(filename.endsWith(&quot;.html&quot;)) return &quot;text/html&quot;;  else if(filename.endsWith(&quot;.css&quot;)) return &quot;text/css&quot;;  else if(filename.endsWith(&quot;.js&quot;)) return &quot;application/javascript&quot;;  else if(filename.endsWith(&quot;.png&quot;)) return &quot;image/png&quot;;  else if(filename.endsWith(&quot;.gif&quot;)) return &quot;image/gif&quot;;  else if(filename.endsWith(&quot;.jpg&quot;)) return &quot;image/jpeg&quot;;  else if(filename.endsWith(&quot;.ico&quot;)) return &quot;image/x-icon&quot;;  else if(filename.endsWith(&quot;.xml&quot;)) return &quot;text/xml&quot;;  else if(filename.endsWith(&quot;.pdf&quot;)) return &quot;application/x-pdf&quot;;  else if(filename.endsWith(&quot;.zip&quot;)) return &quot;application/x-zip&quot;;  else if(filename.endsWith(&quot;.gz&quot;)) return &quot;application/x-gzip&quot;;  return &quot;text/plain&quot;;&#125;

ESP8266 – ESP8266WebServer库 – streamFile – 太极创客 (taichi-maker.com)
setContentLength – 设置响应体长度说明在ESP8266开发板所建立的物联网服务器在运行过程中，如果有客户端向ESP8266服务器发送HTTP请求，ESP8266服务器将会对客户端发送响应信息。本函数可用于设置响应信息中的响应体长度。
假如我们在开发时不确定响应体信息长度，则可以如下所示对setContentLength使用CONTENT_LENGTH_UNKNOWN关键词作为参数来调用。
server.setContentLength(CONTENT_LENGTH_UNKNOWN)

语法setContentLength(contentLength)

参数contentLength响应体的长度(参数类型 : const size_t）
返回值无
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
假设您的ESP8266开发板IP地址为192.168.0.106，那么请将ESP8266的IP地址输入浏览器地址栏中。接下来您将看到浏览器将会显示ESP8266开发板返回的响应体信息。同时，以下程序中使用了server.setContentLength(CONTENT_LENGTH_UNKNOWN)来演示setContentLength的使用方法。
/**********************************************************************  程序名称/Program name     : WebServer_demo_sendHeader  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问  自定义响应体信息并在客户端访问时返回***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; //创建 ESP8266WebServer 实例对象ESP8266WebServer server(80); // 设置主页请求处理函数void homepage() &#123;  Serial.println(&quot;用户访问了主页&quot;);  server.sendContent(&quot;sendContent_test_OK&quot;);  server.setContentLength(CONTENT_LENGTH_UNKNOWN);&#125; // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound() &#123;                                       // 当浏览器请求的网络资源无法在服务器找到时，  server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);           // NodeMCU将调用此函数。&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.begin();  //设置主页处理函数  server.on(&quot;/&quot;, homepage);  //设置404页面  server.onNotFound(handleNotFound);  //串口输出服务器准备完成信息  Serial.println(&quot;HTTP server started&quot;);&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125;

相关内容– send – 发送响应信息– sendHeader – 发送响应头– sendContent – 发送响应体– sendContent_P – 发送响应信息
upload – 处理文件上传语法此函数用于ESP8266开发板所建立的物联网服务器处理客户端的文件上传请求。
参数server.upload()

返回值无
示例程序/**********************************************************************程序名称/Program name     : 3_4_8_SPIFFS_File_Upload_Server程序目的/Purpose          : 建立网络服务器，允许用户通过网页将文件上传到SPIFFS***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WiFiMulti.h&gt;#include &lt;ESP8266WebServer.h&gt;#include &lt;FS.h&gt;   ESP8266WiFiMulti wifiMulti;     // 建立ESP8266WiFiMulti对象,对象名称是 &#x27;wifiMulti&#x27; ESP8266WebServer esp8266_server(80);    // 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）       File fsUploadFile;              // 建立文件对象用于闪存文件上传 void setup() &#123;  Serial.begin(9600);          Serial.println(&quot;&quot;);   wifiMulti.addAP(&quot;ssid_from_AP_1&quot;, &quot;your_password_for_AP_1&quot;); // 将需要连接的一系列WiFi ID和密码输入这里  wifiMulti.addAP(&quot;ssid_from_AP_2&quot;, &quot;your_password_for_AP_2&quot;); // ESP8266-NodeMCU再启动后会扫描当前网络  wifiMulti.addAP(&quot;ssid_from_AP_3&quot;, &quot;your_password_for_AP_3&quot;); // 环境查找是否有这里列出的WiFi ID。如果有  Serial.println(&quot;Connecting ...&quot;);                            // 则尝试使用此处存储的密码进行连接。   int i = 0;    while (wifiMulti.run() != WL_CONNECTED) &#123; // 尝试进行wifi连接。    delay(1000);    Serial.print(i++); Serial.print(&#x27;.&#x27;);  &#125;    // WiFi连接成功后将通过串口监视器输出连接成功信息   Serial.println(&#x27;\n&#x27;);  Serial.print(&quot;Connected to &quot;);  Serial.println(WiFi.SSID());              // 通过串口监视器输出连接的WiFi名称  Serial.print(&quot;IP address:\t&quot;);  Serial.println(WiFi.localIP());           // 通过串口监视器输出ESP8266-NodeMCU的IP            if(SPIFFS.begin())&#123;                       // 启动闪存文件系统    Serial.println(&quot;SPIFFS Started.&quot;);  &#125; else &#123;    Serial.println(&quot;SPIFFS Failed to Start.&quot;);  &#125;    esp8266_server.on(&quot;/upload.html&quot;,   // 如果客户端通过upload页面                    HTTP_POST,        // 向服务器发送文件(请求方法POST)                    respondOK,        // 则回复状态码 200 给客户端                    handleFileUpload);// 并且运行处理文件上传函数   esp8266_server.onNotFound(handleUserRequest);   esp8266_server.begin();                           // 启动网站服务  Serial.println(&quot;HTTP server started&quot;);&#125; void loop() &#123;  esp8266_server.handleClient();&#125; // 处理上传文件函数void handleFileUpload()&#123;      HTTPUpload&amp; upload = esp8266_server.upload();    if(upload.status == UPLOAD_FILE_START)&#123;                     // 如果上传状态为UPLOAD_FILE_START        String filename = upload.filename;                        // 建立字符串变量用于存放上传文件名    if(!filename.startsWith(&quot;/&quot;)) filename = &quot;/&quot; + filename;  // 为上传文件名前加上&quot;/&quot;    Serial.println(&quot;File Name: &quot; + filename);                 // 通过串口监视器输出上传文件的名称     fsUploadFile = SPIFFS.open(filename, &quot;w&quot;);            // 在SPIFFS中建立文件用于写入用户上传的文件数据      &#125; else if(upload.status == UPLOAD_FILE_WRITE)&#123;          // 如果上传状态为UPLOAD_FILE_WRITE              if(fsUploadFile)      fsUploadFile.write(upload.buf, upload.currentSize); // 向SPIFFS文件写入浏览器发来的文件数据        &#125; else if(upload.status == UPLOAD_FILE_END)&#123;            // 如果上传状态为UPLOAD_FILE_END     if(fsUploadFile) &#123;                                    // 如果文件成功建立      fsUploadFile.close();                               // 将文件关闭      Serial.println(&quot; Size: &quot;+ upload.totalSize);        // 通过串口监视器输出文件大小      esp8266_server.sendHeader(&quot;Location&quot;,&quot;/success.html&quot;);  // 将浏览器跳转到/success.html（成功上传页面）      esp8266_server.send(303);                               // 发送相应代码303（重定向到新页面）     &#125; else &#123;                                              // 如果文件未能成功建立      Serial.println(&quot;File upload failed&quot;);               // 通过串口监视器输出报错信息      esp8266_server.send(500, &quot;text/plain&quot;, &quot;500: couldn&#x27;t create file&quot;); // 向浏览器发送相应代码500（服务器错误）    &#125;      &#125;&#125; //回复状态码 200 给客户端void respondOK()&#123;  esp8266_server.send(200);&#125; // 处理用户浏览器的HTTP访问void handleUserRequest()&#123;                                // 获取用户请求网址信息  String webAddress = esp8266_server.uri();    // 通过handleFileRead函数处处理用户访问  bool fileReadOK = handleFileRead(webAddress);   // 如果在SPIFFS无法找到用户访问的资源，则回复404 (Not Found)  if (!fileReadOK)&#123;                                                     esp8266_server.send(404, &quot;text/plain&quot;, &quot;404 Not Found&quot;);   &#125;&#125; bool handleFileRead(String path) &#123;            //处理浏览器HTTP访问   if (path.endsWith(&quot;/&quot;)) &#123;                   // 如果访问地址以&quot;/&quot;为结尾    path = &quot;/index.html&quot;;                     // 则将访问地址修改为/index.html便于SPIFFS访问  &#125;     String contentType = getContentType(path);  // 获取文件类型    if (SPIFFS.exists(path)) &#123;                     // 如果访问的文件可以在SPIFFS中找到    File file = SPIFFS.open(path, &quot;r&quot;);          // 则尝试打开该文件    esp8266_server.streamFile(file, contentType);// 并且将该文件返回给浏览器    file.close();                                // 并且关闭文件    return true;                                 // 返回true  &#125;  return false;                                  // 如果文件未找到，则返回false&#125; // 获取文件类型String getContentType(String filename)&#123;  if(filename.endsWith(&quot;.htm&quot;)) return &quot;text/html&quot;;  else if(filename.endsWith(&quot;.html&quot;)) return &quot;text/html&quot;;  else if(filename.endsWith(&quot;.css&quot;)) return &quot;text/css&quot;;  else if(filename.endsWith(&quot;.js&quot;)) return &quot;application/javascript&quot;;  else if(filename.endsWith(&quot;.png&quot;)) return &quot;image/png&quot;;  else if(filename.endsWith(&quot;.gif&quot;)) return &quot;image/gif&quot;;  else if(filename.endsWith(&quot;.jpg&quot;)) return &quot;image/jpeg&quot;;  else if(filename.endsWith(&quot;.ico&quot;)) return &quot;image/x-icon&quot;;  else if(filename.endsWith(&quot;.xml&quot;)) return &quot;text/xml&quot;;  else if(filename.endsWith(&quot;.pdf&quot;)) return &quot;application/x-pdf&quot;;  else if(filename.endsWith(&quot;.zip&quot;)) return &quot;application/x-zip&quot;;  else if(filename.endsWith(&quot;.gz&quot;)) return &quot;application/x-gzip&quot;;  return &quot;text/plain&quot;;&#125;



requestAuthentication – 请求客户端认证语法在ESP8266开发板所建立的物联网服务器在运行过程中，如果有客户端向服务器发送HTTP请求，服务器可使用本函数向客户端发送认证请求,从而建立需要用户名和密码认证的加密网页服务器。只有当客户端请求信息中包含正确的认证请求方可访问网页信息。
请注意，与此函数配套使用的是authenticate函数。authenticate用于设置与校验客户端请求信息中的用户名和密码。而requestAuthentication用于向客户端发送认证请求。
语法server.requestAuthentication(mode, realm, authFailMsg)``server.requestAuthentication()

参数mode (可选参数)– HTTP验证方式– 可选关键词：BASIC_AUTH、 DIGEST_AUTH（不填则默认为BASIC_AUTH）
realm (可选参数)– 认证范围– 参数类型: const char* (不填则默认为空NULL)
authFailMsg (可选参数)– 认证失败提示消息– 参数类型: const String– 不填则默认为空字符串 String(“”)
返回值无
示例程序当您将WiFi连接信息修改后并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP。
接下来您可以通过浏览器地址栏输入ESP8266开发板的IP地址并键入回车（即向ESP8266开发板所建立的物联网服务器发送一个GET请求）。
接下来浏览器将会弹出对话框，要求用户输入用户名:TaichiMaker和密码:123456。如下图所示。

只有当用户正确输入了用户名和密码信息以后，方可打开ESP8266开发板建立的网站页面。（如下图所示）

以下示例程序中的高亮语句server.requestAuthentication()要求客户端发送打开网页的用户名和密码。
/**********************************************************************  程序名称/Program name     : WebServer_demo_requestAuthentication  程序目的/Purpose          :  使用8266作为WebServer,并用浏览器打开设备IP+80端口进行访问  在登录主页时使用认证方式登录,登录账户密码分别为(TaichiMaker/123456)***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266WebServer.h&gt; //设置WiFi接入信息const char* ssid = &quot;TaichiMaker&quot;;const char* password = &quot;xxxxxxxx&quot;; ESP8266WebServer server(80); //设置需要收集的请求头信息const char *headerKeys[] = &#123;&quot;Content-Length&quot;, &quot;Content-Type&quot;, &quot;Connection&quot;, &quot;Date&quot;&#125;; // 设置主页请求处理函数void homepage() &#123;   //校验用户登录账号和密码,(默认使用Basic方式),若输入错误则继续返回认证界面  if (!server.authenticate(&quot;TaichiMaker&quot;, &quot;123456&quot;))   return server.requestAuthentication();   server.send(200, &quot;text/plain&quot;, &quot;test homepage&quot;);  Serial.println(&quot;用户访问了主页&quot;);&#125; // 设置处理404情况的函数&#x27;handleNotFound&#x27;void handleNotFound() &#123;                                       // 当浏览器请求的网络资源无法在服务器找到时，  server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);           // NodeMCU将调用此函数。&#125; void setup(void) &#123;  //初始化串口  Serial.begin(115200);  Serial.println(&quot;&quot;);   //初始化网络  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   //初始化WebServer  server.begin();  //设置主页处理函数  server.on(&quot;/&quot;, homepage);  //设置404页面  server.onNotFound(handleNotFound);  //串口输出服务器准备完成信息  Serial.println(&quot;HTTP server started&quot;);&#125; void loop(void) &#123;  //监听客户请求并处理  server.handleClient();&#125;

相关内容– authenticate– on– onNotFound
ESP8266 – WiFiClientSecure库WiFiClientSecure库用于HTTPS协议通讯。通过WiFiClientSecure库，我们可以使用ESP8266利用HTTPS协议向网络服务器发送请求，并且分析网络服务器返回的响应信息，从而实现更加安全的物联网应用。
HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的互联网协议。HTTPS协议在HTTP的基础上通过SSL或TLS来实现传输加密和身份认证，从而保证了传输过程的安全性。假如您需要进一步了解HTTPS协议的介绍关内容，请参考百度百科HTTPS协议页面。
当然，如果您的物联网应用对安全性能并没有很高的要求，那么您也可以使用ESP8266HTTPClient库通过HTTP协议来实现ESP8266物联网应用。
以下为WiFiClientSecure库的整体结构图。

ESP8266-HTTPS开发实用知识查看网站证书指纹在我们用HTTPS协议开发物联网项目时，有时需要获取网站服务器的证书指纹信息。我们可以用电脑中的浏览器来获取该信息。
为了演示本操作，我在这里使用基于Chrome内核的Microsoft Edge浏览器来进行演示如何获取www.howsmyssl.com网站服务器的证书指纹。
首先请在服务器地址栏中输入以下网址：
https://www.howsmyssl.com/
当浏览器成功打开以上网址的网页后，请如下图所示点击地址栏前面的“小锁”标志。然后在弹出的菜单中点击“证书”（如下图2号红色方框所标识的信息）。

如下图所示，请在弹出的“证书”窗口中，点击“证书路径”标签(如下图中数字1所标识)，然后用鼠标选中”www.howsmyssl.com”（如下图中数字1所标识）。

如下图所示，请在弹出的“证书”窗口中，点击“详细信息”，然后在窗口信息中找到“指纹”项目。当您用鼠标点击该项目后，即可在窗口下方看到一排英文字符（如下图红色标识）。这串红色标识的字符即是网站的证书指纹信息。

注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此您所看到的指纹信息可能与以上图片中显示的信息不同。同时，如果您将指纹信息写入程序中，要留意及时更新该信息。否则当网站更新指纹信息后，您的程序将无法用于通过HTTPS协议访问网站信息。
查看网站证书和公钥在我们用HTTPS协议开发物联网项目时，有时需要获取网站服务器的证书和公钥。我们可以用电脑中的浏览器来获取该信息。
为了演示本操作，我在这里使用基于Chrome内核的Microsoft Edge浏览器来进行演示如何获取必应网站(www.bing.com)服务器的证书和公钥。
首先请在服务器地址栏中输入以下网址：
https://www.bing.com
当浏览器成功打开以上网址的网页后，请如下图所示点击地址栏前面的“小锁”标志。然后在弹出的菜单中点击“证书”（如下图红色箭头所标识的信息）。

如下图所示，请在弹出的“证书”窗口中，点击下图数字1所示的“证书路径”，然后用鼠标选中下图数字2所示的“www.bing.com”。

如下图所示，接下来请点击下图数字1所示的“详细信息”标签。此时窗口中显示的都是上一步选中的“www.bing.com”网站服务器证书的详细信息。然后您 就可以点击下图中数字2所示的“复制到文件”按钮。

如下图所示，在弹出的“证书导出向导”中点击 “下一步”按钮。

如下图所示，接下来您可以根据自己的需要选择证书格式。请选择Base64编码X.509(.CER)选项，然后点击下一步。

如下图所示，在接下来的步骤里，点击浏览按钮，选择保存证书文件的路径。

如下图所示，我们完成了网站服务器证书的导出工作。如果您需要从该证书中提取公钥信息，那么请继续看后续的讲解。

在接下来的操作中，我们将需要使用OpenSSL工具。如果您使用的是Windows电脑，那么需要使用以下链接将OpenSSL工具下载并安装到电脑中。如果您的电脑中已经安装好git这类集成了OpenSSL的软件，那么您可以不必下载以下工具。简言之，无论您使用什么软件和方法，只要您可以在电脑中使用OpenSSL就可了。
Win64 OpenSSL v1.1.1g Light (蓝奏云下载，适用64位Windows)
Win32 OpenSSL v1.1.1g Light (蓝奏云下载，适用64位Windows)
Shining Light Productions网站下载
接下来请启动OpenSSL工具，并进入刚刚下载的证书存放路径，然后输入以下指令，即可从下载的证书中提取公钥信息。
openssl x509 -pubkey -noout -in bing.cer

注意，以上指令中的“bing.cer”为下载的证书名称，务必确保这一部分内容是准确的。另外在输入以上指令时务必确保您当前的操作路径是证书存放路径。
如下图所示，公钥信息将会显示在屏幕中供您复制粘贴到程序中使用。

查看网站根证书在我们用HTTPS协议开发物联网项目时，有时需要获取根证书。我们可以用电脑中的浏览器来获取该信息。
为了演示本操作，我在这里使用基于Chrome内核的Microsoft Edge浏览器来进行演示如何获取www.howsmyssl.com网站服务器的证书指纹。

请在服务器地址栏中输入以下网址：

https://www.howsmyssl.com/
当浏览器成功打开以上网址的网页后，请如下图所示点击地址栏前面的“小锁”标志。然后在弹出的菜单中点击“证书”（如下图2号红色方框所标识的信息）。


如下图所示，请在弹出的“证书”窗口中，点击下图数字1所示的“证书路径”，然后用鼠标选中下图数字2所示的“DST Root CA X3”证书。



接下来请点击下图数字1所示的“详细信息”标签。此时窗口中显示的都是上一步选中的“DST Root CA X3”证书的详细信息。然后您 就可以点击下图中数字2所示的“复制到文件”按钮。



在弹出的“证书导出向导”中点击 “下一步”按钮。



接下来您可以根据自己的需要选择证书格式。

假如您需要将本证书应用于本站的ESP8266物联网开发资料页中的示例程序，那么请选择Base64编码X.509(.CER)选项，然后点击下一步。


在接下来的步骤里，点击浏览按钮，选择保存证书文件的路径。



点击完成按钮，证书将会到出到您电脑中指定路径。



请使用Notepade++一类的文本编辑软件打开刚刚导出的证书文件，您就会得到网站证书的详细内容。



连接认证类型连接类型WiFiClientSecure – 建立WiFiClientSecure对象说明通过WiFiClientSecure语句，我们可以建立WiFiClientSecure对象从而实现ESP8266的HTTPS协议物联网通讯。
语法WiFiClientSecure httpsClient注：请参考本页的示例程序部分获取更多应用说明信息。此函数在示例程序中被高亮标记以便您查阅。
参数无
返回值无
示例程序示例1：ESP8266实现HTTPS通讯（指纹认证）
以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。本程序使用了指纹认证方式。比起本页的“示例2：ESP8266实现HTTPS通讯（证书认证）”，示例1所采用的指纹认证不如证书认证安全性高。
请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。

注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。如需了解如何执行这一操作，请参考“查看网站证书指纹”。
/**********************************************************************程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的WiFiClientSecure语句来建立WiFiClientSecure对象。该对象用于控制ESP8266的HTTPS协议通讯。 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。 本程序使用了指纹认证方式。该方式没有证书认证方式安全。 注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。如需了解如何执行这一操作，请参考“获取网站证书指纹”***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt; #include &lt;ESP8266WebServer.h&gt; //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;www.howsmyssl.com&quot;;  //HTTPS端口443const int httpsPort = 443;   //注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹//并复制粘贴到此处。如需了解如何执行这一操作，请参考太极创客网站中//“获取网站证书指纹”页面(网址见下)://http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/http-client-secure/certificate-fingerprint/const char fingerprint[] PROGMEM = &quot;c7c1f454fb33ef22191163c50c12dc7d4842694a&quot;; void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    // 实现HTTPS通讯  httpsCom();&#125; void loop()&#123;&#125; void httpsCom()&#123;  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象   Serial.println(host);   Serial.printf(&quot;Using fingerprint &#x27;%s&#x27;\n&quot;, fingerprint);  httpsClient.setFingerprint(fingerprint);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器  // 告知用户当前ESP8266已经成功接收服务器响应头信息。  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   // 通过串口监视器输出服务器响应体信息（服务器报文）  Serial.println(&quot;==========&quot;);  Serial.println(&quot;server response payload:&quot;);   String line;  while(httpsClient.available())&#123;            line = httpsClient.readStringUntil(&#x27;\n&#x27;);  //Read Line by Line    Serial.println(line); //Print response  &#125;  Serial.println(&quot;==========&quot;);    //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125;



示例2：ESP8266实现HTTPS通讯（证书认证）
本实例所实现的功能与示例1相同。唯一区别是本示例中在ESP8266与服务器的HTTPS通信中，使用证书认证而不是指纹认证。使用本示例中的证书认证可以提高HTTPS通讯安全性。
如需了解本示例程序的操作方法和运行结果，请参考示例1中的相应内容。
注意：出于安全原因，CA会定期更新根证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。如需了解如何执行这一操作，“查看网站根证书”。
/**********************************************************************程序名称/Program name     : WiFiClientSecure_2程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的WiFiClientSecure语句来建立WiFiClientSecure对象。该对象用于控制ESP8266的HTTPS协议通讯。 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。 本程序使用了证书认证方式。该方式比指纹认证方式要更安全。 注意：出于安全原因，CA会定期更新证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。如需了解如何执行这一操作，请参考“获取网站根证书”***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt; #include &lt;ESP8266WebServer.h&gt; //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;www.howsmyssl.com&quot;;  //HTTPS端口443const int httpsPort = 443;   void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    httpsCom(); // 实现https通讯&#125; void loop() &#123;&#125; // 实现https通讯void httpsCom()&#123;//注意：出于安全原因，CA会定期更新证书信息。因此本程序//中的证书可能已经过期。请使用浏览器获取最新的证书//并复制粘贴到此处。如需了解如何执行这一操作，请参考“获取网站证书”  static const char digicert[] PROGMEM = R&quot;EOF( // 证书信息-----BEGIN CERTIFICATE-----MIIDSjCCAjKgAwIBAgIQRK+wgNajJ7qJMDmGLvhAazANBgkqhkiG9w0BAQUFADA/MSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMTDkRTVCBSb290IENBIFgzMB4XDTAwMDkzMDIxMTIxOVoXDTIxMDkzMDE0MDExNVowPzEkMCIGA1UEChMbRGlnaXRhbCBTaWduYXR1cmUgVHJ1c3QgQ28uMRcwFQYDVQQDEw5EU1QgUm9vdCBDQSBYMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAN+v6ZdQCINXtMxiZfaQguzH0yxrMMpb7NnDfcdAwRgUi+DoM3ZJKuM/IUmTrE4Orz5Iy2Xu/NMhD2XSKtkyj4zl93ewEnu1lcCJo6m67XMuegwGMoOifooUMM0RoOEqOLl5CjH9UL2AZd+3UWODyOKIYepLYYHsUmu5ouJLGiifSKOeDNoJjj4XLh7dIN9bxiqKqy69cK3FCxolkHRyxXtqqzTWMIn/5WgTe1QLyNau7Fqckh49ZLOMxt+/yUFw7BZy1SbsOFU5Q9D8/RhcQPGX69Wam40dutolucbY38EVAjqr2m7xPi71XAicPNaDaeQQmxkqtilX4+U9m5/wAl0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFMSnsaR7LHH62+FLkHX/xBVghYkQMA0GCSqGSIb3DQEBBQUAA4IBAQCjGiybFwBcqR7uKGY3Or+Dxz9LwwmglSBd49lZRNI+DT69ikugdB/OEIKcdBodfpga3csTS7MgROSR6cz8faXbauX+5v3gTt23ADq1cEmv8uXrAvHRAosZy5Q6XkjEGB5YGV8eAlrwDPGxrancWYaLbumR9YbK+rlmM6pZW87ipxZzR8srzJmwN0jP41ZL9c8PDHIyh8bwRLtTcm1D9SZImlJnt1ir/md2cXjbDaJWFBM5JDGFoqgCWjBH4d1QB7wCCZAA62RjYJsWvIjJEubSfZGL+T0yjWW06XyxV3bqxbYoOb8VZRzI9neWagqNdwvYkQsEjgfbKbYK7p2CNTUQ-----END CERTIFICATE-----)EOF&quot;;    WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象  BearSSL::X509List cert(digicert);    // 设置时间  setClock();    Serial.println(&quot;Using certificate&quot;);  httpsClient.setTrustAnchors(&amp;cert);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器  // 告知用户当前ESP8266已经成功接收服务器响应头信息。  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   // 通过串口监视器输出服务器响应体信息（服务器报文）  Serial.println(&quot;==========&quot;);  Serial.println(&quot;server response payload:&quot;);   String line;  while(httpsClient.available())&#123;            line = httpsClient.readStringUntil(&#x27;\n&#x27;);  //Read Line by Line    Serial.println(line); //Print response  &#125;  Serial.println(&quot;==========&quot;);    //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125; // 获取网络时间，该时间信息用于证书认证void setClock() &#123;  configTime(3 * 3600, 0, &quot;ntp.ntsc.ac.cn&quot;,&quot;pool.ntp.org&quot;, &quot;time.nist.gov&quot;);    // bool configTime(int timezone, int daylightOffset, char *server1, char *server2, char *server3, bool enable);  Serial.print(&quot;Waiting for NTP time sync: &quot;);  time_t now = time(nullptr);  while (now &lt; 8 * 3600 * 2) &#123;    delay(500);    Serial.print(&quot;.&quot;);    now = time(nullptr);  &#125;  Serial.println(&quot;&quot;);  struct tm timeinfo;  gmtime_r(&amp;now, &amp;timeinfo);  Serial.print(&quot;Current time: &quot;);  Serial.print(asctime(&amp;timeinfo));&#125;



connect – 连接服务器说明connect函数用于ESP8266开发板通过HTTPS协议连接网络服务器。
语法httpsClient.connect(ip, port)httpsClient.connect(host, port)注：请参考本页的示例程序部分获取更多应用说明信息。此函数在示例程序中被高亮标记以便您查阅。
参数ip: 所要连接的服务器的IP地址。类型:IPAddress。host：所要连接的服务器域名,可使用字符串类型。port:所要连接的服务器端口号,允许使用int类型。
返回值连接失败返回0，连接成功返回1。返回值数据类型是bool型。
示例程序示例1：ESP8266实现HTTPS通讯（指纹认证）
以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。本程序使用了指纹认证方式。比起本页的“示例2：ESP8266实现HTTPS通讯（证书认证）”，示例1所采用的指纹认证不如证书认证安全性高。
请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。

此程序使用了语句**httpsClient.connect(host, httpsPort)**实现ESP8266与服务器连接。具体操作方法，请见以下示例程序的高亮部分。
注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。
/**********************************************************************程序名称/Program name     : connect_1程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的connect函数来控制ESP8266通过HTTPS协议连接服务器。 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。 本程序使用了指纹认证方式。该方式没有证书认证方式安全。 注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt;   //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;www.howsmyssl.com&quot;;  //HTTPS端口443const int httpsPort = 443;   //注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹const char fingerprint[] PROGMEM = &quot;c7c1f454fb33ef22191163c50c12dc7d4842694a&quot;; void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    // 实现HTTPS通讯  httpsCom();&#125; void loop()&#123;&#125; void httpsCom()&#123;  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象   Serial.println(host);   Serial.printf(&quot;Using fingerprint &#x27;%s&#x27;\n&quot;, fingerprint);  httpsClient.setFingerprint(fingerprint);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器  // 告知用户当前ESP8266已经成功接收服务器响应头信息。  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   // 通过串口监视器输出服务器响应体信息（服务器报文）  Serial.println(&quot;==========&quot;);  Serial.println(&quot;server response payload:&quot;);   String line;  while(httpsClient.available())&#123;            line = httpsClient.readStringUntil(&#x27;\n&#x27;);  //Read Line by Line    Serial.println(line); //Print response  &#125;  Serial.println(&quot;==========&quot;);    //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125;



示例2：ESP8266实现HTTPS通讯（证书认证）
本实例所实现的功能与示例1相同。唯一区别是本示例中在ESP8266与服务器的HTTPS通信中，使用证书认证而不是指纹认证。使用本示例中的证书认证可以提高HTTPS通讯安全性。
如需了解本示例程序的操作方法和运行结果，请参考示例1中的相应内容。
注意：出于安全原因，CA会定期更新根证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。
/**********************************************************************程序名称/Program name     : connect_2程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的connect函数来控制ESP8266通过HTTPS协议连接服务器。 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。 本程序使用了证书认证方式。该方式比指纹认证方式要更安全。 注意：出于安全原因，CA会定期更新证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt;   //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;www.howsmyssl.com&quot;;  //HTTPS端口443const int httpsPort = 443;   void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    httpsCom(); // 实现https通讯&#125; void loop() &#123;&#125; // 实现https通讯void httpsCom()&#123;//注意：出于安全原因，CA会定期更新证书信息。因此本程序//中的证书可能已经过期。请使用浏览器获取最新的证书//http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/http-client-secure/certificate/  static const char digicert[] PROGMEM = R&quot;EOF( // 证书信息-----BEGIN CERTIFICATE-----MIIDSjCCAjKgAwIBAgIQRK+wgNajJ7qJMDmGLvhAazANBgkqhkiG9w0BAQUFADA/MSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMTDkRTVCBSb290IENBIFgzMB4XDTAwMDkzMDIxMTIxOVoXDTIxMDkzMDE0MDExNVowPzEkMCIGA1UEChMbRGlnaXRhbCBTaWduYXR1cmUgVHJ1c3QgQ28uMRcwFQYDVQQDEw5EU1QgUm9vdCBDQSBYMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAN+v6ZdQCINXtMxiZfaQguzH0yxrMMpb7NnDfcdAwRgUi+DoM3ZJKuM/IUmTrE4Orz5Iy2Xu/NMhD2XSKtkyj4zl93ewEnu1lcCJo6m67XMuegwGMoOifooUMM0RoOEqOLl5CjH9UL2AZd+3UWODyOKIYepLYYHsUmu5ouJLGiifSKOeDNoJjj4XLh7dIN9bxiqKqy69cK3FCxolkHRyxXtqqzTWMIn/5WgTe1QLyNau7Fqckh49ZLOMxt+/yUFw7BZy1SbsOFU5Q9D8/RhcQPGX69Wam40dutolucbY38EVAjqr2m7xPi71XAicPNaDaeQQmxkqtilX4+U9m5/wAl0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFMSnsaR7LHH62+FLkHX/xBVghYkQMA0GCSqGSIb3DQEBBQUAA4IBAQCjGiybFwBcqR7uKGY3Or+Dxz9LwwmglSBd49lZRNI+DT69ikugdB/OEIKcdBodfpga3csTS7MgROSR6cz8faXbauX+5v3gTt23ADq1cEmv8uXrAvHRAosZy5Q6XkjEGB5YGV8eAlrwDPGxrancWYaLbumR9YbK+rlmM6pZW87ipxZzR8srzJmwN0jP41ZL9c8PDHIyh8bwRLtTcm1D9SZImlJnt1ir/md2cXjbDaJWFBM5JDGFoqgCWjBH4d1QB7wCCZAA62RjYJsWvIjJEubSfZGL+T0yjWW06XyxV3bqxbYoOb8VZRzI9neWagqNdwvYkQsEjgfbKbYK7p2CNTUQ-----END CERTIFICATE-----)EOF&quot;;    WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象  BearSSL::X509List cert(digicert);    // 设置时间  setClock();    Serial.println(&quot;Using certificate&quot;);  httpsClient.setTrustAnchors(&amp;cert);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器  // 告知用户当前ESP8266已经成功接收服务器响应头信息。  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   // 通过串口监视器输出服务器响应体信息（服务器报文）  Serial.println(&quot;==========&quot;);  Serial.println(&quot;server response payload:&quot;);   String line;  while(httpsClient.available())&#123;            line = httpsClient.readStringUntil(&#x27;\n&#x27;);  //Read Line by Line    Serial.println(line); //Print response  &#125;  Serial.println(&quot;==========&quot;);    //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125; // 获取网络时间，该时间信息用于证书认证void setClock() &#123;  configTime(3 * 3600, 0, &quot;ntp.ntsc.ac.cn&quot;,&quot;pool.ntp.org&quot;, &quot;time.nist.gov&quot;);    // bool configTime(int timezone, int daylightOffset, char *server1, char *server2, char *server3, bool enable);  Serial.print(&quot;Waiting for NTP time sync: &quot;);  time_t now = time(nullptr);  while (now &lt; 8 * 3600 * 2) &#123;    delay(500);    Serial.print(&quot;.&quot;);    now = time(nullptr);  &#125;  Serial.println(&quot;&quot;);  struct tm timeinfo;  gmtime_r(&amp;now, &amp;timeinfo);  Serial.print(&quot;Current time: &quot;);  Serial.print(asctime(&amp;timeinfo));&#125;



stop – 停止客户端说明stop函数用于停止ESP8266连接TCP服务器。
语法httpsClient.stop()注：请参考本页的示例程序部分获取更多应用说明信息。此函数在示例程序中被高亮标记以便您查阅。
参数无
返回值无
示例程序示例1：ESP8266实现HTTPS通讯（指纹认证）
以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。本程序使用了指纹认证方式。比起本页的“示例2：ESP8266实现HTTPS通讯（证书认证）”，示例1所采用的指纹认证不如证书认证安全性高。
请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。

此程序使用了语句**httpsClient.stop()**实现ESP8266断开服务器连接。具体操作方法，请见以下示例程序的高亮部分。
注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。
/**********************************************************************项目名称/Project          : 零基础入门学用物联网程序名称/Program name     : ESP8266-WiFiClientSecure-Stop_1团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)作者/Author              : CYNO朔日期/Date（YYYYMMDD）     : 20200418程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的stop函数来控制ESP8266断开与服务器的连接。 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。 本程序使用了指纹认证方式。该方式没有证书认证方式安全。 注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。如需了解如何执行这一操作，请参考太极创客网站中“获取网站证书指纹”页面(网址见下):http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/http-client-secure/certificate-fingerprint/-----------------------------------------------------------------------本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt; #include &lt;ESP8266WebServer.h&gt; //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;www.howsmyssl.com&quot;;  //HTTPS端口443const int httpsPort = 443;   //注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹//并复制粘贴到此处。如需了解如何执行这一操作，请参考太极创客网站中//“获取网站证书指纹”页面(网址见下)://http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/http-client-secure/certificate-fingerprint/const char fingerprint[] PROGMEM = &quot;c7c1f454fb33ef22191163c50c12dc7d4842694a&quot;; void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    // 实现HTTPS通讯  httpsCom();&#125; void loop()&#123;&#125; void httpsCom()&#123;  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象   Serial.println(host);   Serial.printf(&quot;Using fingerprint &#x27;%s&#x27;\n&quot;, fingerprint);  httpsClient.setFingerprint(fingerprint);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器  // 告知用户当前ESP8266已经成功接收服务器响应头信息。  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   // 通过串口监视器输出服务器响应体信息（服务器报文）  Serial.println(&quot;==========&quot;);  Serial.println(&quot;server response payload:&quot;);   String line;  while(httpsClient.available())&#123;            line = httpsClient.readStringUntil(&#x27;\n&#x27;);  //Read Line by Line    Serial.println(line); //Print response  &#125;  Serial.println(&quot;==========&quot;);    //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125;





认证类型setFingerprint – 设置校验指纹说明在使用ESP8266实现HTTPS协议物联网通讯时，我们可以使用服务器证书指纹进行服务器身份认证。setFingerprint函数即是用于设置服务器证书指纹信息以便ESP8266在与服务器进行HTTPS协议物联网通讯时，进行服务器身份认证的。请注意，目前该函数仅支持SHA-1证书指纹。
语法https.setFingerprint(fingerprint)
参数fingerprint: 服务器证书指纹。可以使用const char*类型或者20个uint8_t元素的数组。
返回值成功设置指纹则返回true。否则返回false。
示例程序以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。
请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。

此程序使用了语句 httpsClient.setFingerprint(fingerprint)来设置服务器证书指纹。具体操作方法，请见以下示例程序的高亮部分。
注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。
/**********************************************************************程序名称/Program name     : ESP8266-WiFiClientSecure-setFingerPrint程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的setFingerPrint函数来控制ESP8266验证服务器身份。 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。 本程序使用了指纹认证方式。该方式没有证书认证方式安全。 注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt; #include &lt;ESP8266WebServer.h&gt; //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;www.howsmyssl.com&quot;;  //HTTPS端口443const int httpsPort = 443;   //注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹//并复制粘贴到此处。//以下两行语句为两种不同方法建立fingerprint。他们的作用是相同的。//const char fingerprint[] PROGMEM = &quot;c7c1f454fb33ef22191163c50c12dc7d4842694a&quot;;const char *fingerprint = &quot;c7c1f454fb33ef22191163c50c12dc7d4842694a&quot;; void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    // 实现HTTPS通讯  httpsCom();&#125; void loop()&#123;&#125; void httpsCom()&#123;  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象   Serial.println(host);   Serial.printf(&quot;Using fingerprint &#x27;%s&#x27;\n&quot;, fingerprint);  httpsClient.setFingerprint(fingerprint);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器  // 告知用户当前ESP8266已经成功接收服务器响应头信息。  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   // 通过串口监视器输出服务器响应体信息（服务器报文）  Serial.println(&quot;==========&quot;);  Serial.println(&quot;server response payload:&quot;);   String line;  while(httpsClient.available())&#123;            line = httpsClient.readStringUntil(&#x27;\n&#x27;);  //Read Line by Line    Serial.println(line); //Print response  &#125;  Serial.println(&quot;==========&quot;);    //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125;







setTrustAnchors – 设置信任锚说明在使用ESP8266实现HTTPS协议物联网通讯时，我们可以使用服务器根证书进行服务器身份认证。setTrustAnchors函数用于安装服务器根证书，以便ESP8266进行服务器身份认证。（根证书是CA认证中心给自己颁发的证书,是信任链的起始点。安装根证书意味着对这个证书信任。出于通讯安全考虑，请尽量安装使用知名权CA认证中心颁发的证书。）
请注意：

目前该函数仅支持Base64编码X.509证书。
使用本函数前需要先建立X509List对象。并且将该对象作为setTrustAnchors的参数。如需了解具体操作方法，请见本函数页面的示例程序部分。

语法httpsClient.setTrustAnchors(cert)
参数cert: X.509证书对象（类型：X509List* ）
返回值无
示例程序以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。
请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。

在以下程序中，我们首先使用语句**X509List cert(digicert);建立X509List对象。该对象将会作为参数应用于语句httpsClient.setTrustAnchors(&amp;cert);**来实现证书安装。具体操作方法，请见以下示例程序中的高亮部分。
注意：出于安全原因，CA会定期更新根证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。
/**********************************************************************程序名称/Program name     : ESP8266-WiFiClientSecure-setTrustAnchors程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的stop函数来控制ESP8266断开与服务器的连接。 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。 本程序使用了证书认证方式。该方式比指纹认证方式要更安全。 注意：出于安全原因，CA会定期更新证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt; #include &lt;ESP8266WebServer.h&gt; //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;www.howsmyssl.com&quot;;  //HTTPS端口443const int httpsPort = 443;   void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    httpsCom(); // 实现https通讯&#125; void loop() &#123;&#125; // 实现https通讯void httpsCom()&#123;//注意：出于安全原因，CA会定期更新证书信息。因此本程序//中的证书可能已经过期。请使用浏览器获取最新的证书//并复制粘贴到此处。如需了解如何执行这一操作，请参考太极创客网站中//“获取网站证书”页面(网址见下)://http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/http-client-secure/certificate/  static const char digicert[] PROGMEM = R&quot;EOF( // 证书信息-----BEGIN CERTIFICATE-----MIIDSjCCAjKgAwIBAgIQRK+wgNajJ7qJMDmGLvhAazANBgkqhkiG9w0BAQUFADA/MSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMTDkRTVCBSb290IENBIFgzMB4XDTAwMDkzMDIxMTIxOVoXDTIxMDkzMDE0MDExNVowPzEkMCIGA1UEChMbRGlnaXRhbCBTaWduYXR1cmUgVHJ1c3QgQ28uMRcwFQYDVQQDEw5EU1QgUm9vdCBDQSBYMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAN+v6ZdQCINXtMxiZfaQguzH0yxrMMpb7NnDfcdAwRgUi+DoM3ZJKuM/IUmTrE4Orz5Iy2Xu/NMhD2XSKtkyj4zl93ewEnu1lcCJo6m67XMuegwGMoOifooUMM0RoOEqOLl5CjH9UL2AZd+3UWODyOKIYepLYYHsUmu5ouJLGiifSKOeDNoJjj4XLh7dIN9bxiqKqy69cK3FCxolkHRyxXtqqzTWMIn/5WgTe1QLyNau7Fqckh49ZLOMxt+/yUFw7BZy1SbsOFU5Q9D8/RhcQPGX69Wam40dutolucbY38EVAjqr2m7xPi71XAicPNaDaeQQmxkqtilX4+U9m5/wAl0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFMSnsaR7LHH62+FLkHX/xBVghYkQMA0GCSqGSIb3DQEBBQUAA4IBAQCjGiybFwBcqR7uKGY3Or+Dxz9LwwmglSBd49lZRNI+DT69ikugdB/OEIKcdBodfpga3csTS7MgROSR6cz8faXbauX+5v3gTt23ADq1cEmv8uXrAvHRAosZy5Q6XkjEGB5YGV8eAlrwDPGxrancWYaLbumR9YbK+rlmM6pZW87ipxZzR8srzJmwN0jP41ZL9c8PDHIyh8bwRLtTcm1D9SZImlJnt1ir/md2cXjbDaJWFBM5JDGFoqgCWjBH4d1QB7wCCZAA62RjYJsWvIjJEubSfZGL+T0yjWW06XyxV3bqxbYoOb8VZRzI9neWagqNdwvYkQsEjgfbKbYK7p2CNTUQ-----END CERTIFICATE-----)EOF&quot;;    WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象  X509List cert(digicert);    // 设置时间  setClock();    Serial.println(&quot;Using certificate&quot;);  httpsClient.setTrustAnchors(&amp;cert);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器  // 告知用户当前ESP8266已经成功接收服务器响应头信息。  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   // 通过串口监视器输出服务器响应体信息（服务器报文）  Serial.println(&quot;==========&quot;);  Serial.println(&quot;server response payload:&quot;);   String line;  while(httpsClient.available())&#123;            line = httpsClient.readStringUntil(&#x27;\n&#x27;);  //Read Line by Line    Serial.println(line); //Print response  &#125;  Serial.println(&quot;==========&quot;);    //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125; // 获取网络时间，该时间信息用于证书认证void setClock() &#123;  configTime(3 * 3600, 0, &quot;ntp.ntsc.ac.cn&quot;,&quot;pool.ntp.org&quot;, &quot;time.nist.gov&quot;);    // bool configTime(int timezone, int daylightOffset, char *server1, char *server2, char *server3, bool enable);  Serial.print(&quot;Waiting for NTP time sync: &quot;);  time_t now = time(nullptr);  while (now &lt; 8 * 3600 * 2) &#123;    delay(500);    Serial.print(&quot;.&quot;);    now = time(nullptr);  &#125;  Serial.println(&quot;&quot;);  struct tm timeinfo;  gmtime_r(&amp;now, &amp;timeinfo);  Serial.print(&quot;Current time: &quot;);  Serial.print(asctime(&amp;timeinfo));&#125;





setX509Time – 设置时间以认证x.509数字证书说明setX509Time函数可用于设置ESP8266对服务器证书进行认证时，所使用的时间信息。
语法httpsClient.setX509Time(timeInfo)
参数timeInfo: 设置服务器证书认证所使用的时间信息（类型: time_t）
返回值无
示例程序以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。
请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。

在以下程序中，我们首先使用语句**time_t timeSet &#x3D; 1587218446;建立time_t变量。该变量用于存储时间信息。接下来我们使用httpsClient.setX509Time(timeSet)**对认证服务器证书所用的时间进行设置。具体操作方法，请见以下示例程序中的高亮部分。
注意：出于安全原因，CA会定期更新根证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。
/**********************************************************************程序名称/Program name     : ESP8266-WiFiClientSecure-setX509Time程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的setX509Time函数来设置服务器证书认证使用的时间。以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。 本程序使用了证书认证方式。该方式比指纹认证方式要更安全。 注意：出于安全原因，网站服务器会定期更新证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的服务器证书并复制粘贴到程序中相应位置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt; #include &lt;ESP8266WebServer.h&gt; //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;www.howsmyssl.com&quot;;  //HTTPS端口443const int httpsPort = 443;   //建立WiFiClientSecure对象WiFiClientSecure httpsClient;    void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    httpsCom(); // 实现https通讯&#125; void loop() &#123;&#125; // 实现https通讯void httpsCom()&#123;//注意：出于安全原因，网站服务器会定期更新证书信息。因此本程序//中的证书可能已经过期。请使用浏览器获取最新的服务器证书//并复制粘贴到此处。  static const char digicert[] PROGMEM = R&quot;EOF( // 证书信息-----BEGIN CERTIFICATE-----MIIDSjCCAjKgAwIBAgIQRK+wgNajJ7qJMDmGLvhAazANBgkqhkiG9w0BAQUFADA/MSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMTDkRTVCBSb290IENBIFgzMB4XDTAwMDkzMDIxMTIxOVoXDTIxMDkzMDE0MDExNVowPzEkMCIGA1UEChMbRGlnaXRhbCBTaWduYXR1cmUgVHJ1c3QgQ28uMRcwFQYDVQQDEw5EU1QgUm9vdCBDQSBYMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAN+v6ZdQCINXtMxiZfaQguzH0yxrMMpb7NnDfcdAwRgUi+DoM3ZJKuM/IUmTrE4Orz5Iy2Xu/NMhD2XSKtkyj4zl93ewEnu1lcCJo6m67XMuegwGMoOifooUMM0RoOEqOLl5CjH9UL2AZd+3UWODyOKIYepLYYHsUmu5ouJLGiifSKOeDNoJjj4XLh7dIN9bxiqKqy69cK3FCxolkHRyxXtqqzTWMIn/5WgTe1QLyNau7Fqckh49ZLOMxt+/yUFw7BZy1SbsOFU5Q9D8/RhcQPGX69Wam40dutolucbY38EVAjqr2m7xPi71XAicPNaDaeQQmxkqtilX4+U9m5/wAl0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFMSnsaR7LHH62+FLkHX/xBVghYkQMA0GCSqGSIb3DQEBBQUAA4IBAQCjGiybFwBcqR7uKGY3Or+Dxz9LwwmglSBd49lZRNI+DT69ikugdB/OEIKcdBodfpga3csTS7MgROSR6cz8faXbauX+5v3gTt23ADq1cEmv8uXrAvHRAosZy5Q6XkjEGB5YGV8eAlrwDPGxrancWYaLbumR9YbK+rlmM6pZW87ipxZzR8srzJmwN0jP41ZL9c8PDHIyh8bwRLtTcm1D9SZImlJnt1ir/md2cXjbDaJWFBM5JDGFoqgCWjBH4d1QB7wCCZAA62RjYJsWvIjJEubSfZGL+T0yjWW06XyxV3bqxbYoOb8VZRzI9neWagqNdwvYkQsEjgfbKbYK7p2CNTUQ-----END CERTIFICATE-----)EOF&quot;;    X509List cert(digicert);    // 设置时间  setClock();    Serial.println(&quot;Using certificate&quot;);  httpsClient.setTrustAnchors(&amp;cert);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器  // 告知用户当前ESP8266已经成功接收服务器响应头信息。  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   // 通过串口监视器输出服务器响应体信息（服务器报文）  Serial.println(&quot;==========&quot;);  Serial.println(&quot;server response payload:&quot;);   String line;  while(httpsClient.available())&#123;            line = httpsClient.readStringUntil(&#x27;\n&#x27;);  //Read Line by Line    Serial.println(line); //Print response  &#125;  Serial.println(&quot;==========&quot;);    //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125; // 设置时间信息用于证书认证void setClock() &#123;  // 建立time_t变量用于存储时间信息  time_t timeSet = 1587218446;   // 对认证证书所用的时间进行设置  httpsClient.setX509Time(timeSet);    // 通过串口监视器输出设置的时间信息以便我们查看  struct tm timeinfo;  gmtime_r(&amp;timeSet, &amp;timeinfo);  Serial.print(&quot;timeSet: &quot;);  Serial.print(asctime(&amp;timeinfo));&#125;



setInsecure – 设置不进行身份校验说明使用setInsecure将会让ESP8266不进行服务器身份认证，而直接与服务器进行通讯。注意：此方法跳过了HTTPS协议中的安全加密措施，因此仅可用于测试使用，而不适合传输需要保密的信息。
语法httpsClient.setInsecure()
参数无
返回值无
示例程序请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯。
由于在以下示例程序中使用了httpsClient.setInsecure()，ESP8266将不会进行任何服务器身份认证而直接与服务器进行通讯，所以此方法不适合传输需要保密的信息。
/**********************************************************************程序名称/Program name     : WiFiClientSecure_setInsecure程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的setInsecure来控制ESP8266的HTTPS协议通讯。使用setInsecure将会让ESP8266不进行服务器身份认证，而直接与服务器进行通讯，这种方法非常不安全。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt; #include &lt;ESP8266WebServer.h&gt; //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;www.howsmyssl.com&quot;;  //HTTPS端口443const int httpsPort = 443;   void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    // 实现HTTPS通讯  httpsCom();&#125; void loop()&#123;&#125; void httpsCom()&#123;  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象   Serial.println(host);   Serial.println(&quot;Using Insecure&quot;);  httpsClient.setInsecure();  delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;ESP8266 Connected to Server. Now Disconect...&quot;);  &#125;    //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125;







allowSelfSignedCerts – 允许自签名证书说明使用allowSelfSignedCerts将会允许ESP8266对使用自签名证书的服务器进行身份认证。
服务器证书需要由权威证书颁发机构签名方可信赖。自签名证书不具安全效力，仅可用于测试使用。
语法httpsClient.allowSelfSignedCerts()
参数无
返回值无
示例程序请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接WiFi并通过HTTPS协议与badssl.com网站服务器进行通讯。
由于在以下示例程序中使用了httpsClient.allowSelfSignedCerts()，ESP8266对使用自签名证书的服务器进行身份认证，服务器证书需要由权威证书颁发机构签名方可信赖。自签名证书不具安全效力，仅可用于测试使用。所以此方法不适合传输需要保密的信息。
/**********************************************************************程序名称/Program name     : WiFiClientSecure_allowSelfSignedCerts程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的allowSelfSignedCerts来控制ESP8266的HTTPS协议通讯。使用allowSelfSignedCerts将会让ESP8266允许使用自签名证书进行服务器认证。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt; const char *ssid = &quot;taichimaker&quot;;const char *pass = &quot;12345678&quot;; // 连接服务器void fetchURL(BearSSL::WiFiClientSecure *client, const char *host, const uint16_t port, const char *path) &#123;  if (!path) &#123;    path = &quot;/&quot;;  &#125;   Serial.printf(&quot;Trying: %s:443...&quot;, host);  client-&gt;connect(host, port);  if (!client-&gt;connected()) &#123;    Serial.printf(&quot;*** Can&#x27;t connect. ***\n-------\n&quot;);    return;  &#125;  Serial.printf(&quot;Connected!\n-------\n&quot;);    // 向服务器发送请求  client-&gt;write(&quot;GET &quot;);  client-&gt;write(path);  client-&gt;write(&quot; HTTP/1.0\r\nHost: &quot;);  client-&gt;write(host);  client-&gt;write(&quot;\r\nUser-Agent: ESP8266\r\n&quot;);  client-&gt;write(&quot;\r\n&quot;);  uint32_t to = millis() + 5000;  if (client-&gt;connected()) &#123;    do &#123;      char tmp[32];      memset(tmp, 0, 32);      int rlen = client-&gt;read((uint8_t*)tmp, sizeof(tmp) - 1);      yield();      if (rlen &lt; 0) &#123;        break;      &#125;      // 输出服务器响应状态信息      char *nl = strchr(tmp, &#x27;\r&#x27;);      if (nl) &#123;        *nl = 0;        Serial.print(tmp);        break;      &#125;      Serial.print(tmp);    &#125; while (millis() &lt; to);  &#125;  client-&gt;stop();&#125; // 通过允许自签名证书方式连接网站服务器void fetchSelfSigned() &#123;  BearSSL::WiFiClientSecure client;    // 现尝试不开启自签名认证连接服务器（服务器会拒绝连接）  Serial.printf(&quot;First, try and connect to a badssl.com self-signed website (will fail):\n&quot;);    //设置允许自签名证书  fetchURL(&amp;client, &quot;self-signed.badssl.com&quot;, 443, &quot;/&quot;);    // 开启自签名认证连接服务器（可正常连接服务器）  Serial.printf(&quot;Now we&#x27;ll enable self-signed certs (will pass)\n&quot;);  client.allowSelfSignedCerts();  fetchURL(&amp;client, &quot;self-signed.badssl.com&quot;, 443, &quot;/&quot;);&#125; void setup() &#123;  Serial.begin(9600);  Serial.println();   // 连接WiFi  Serial.print(&quot;Connecting to &quot;);  Serial.println(ssid);  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, pass);   while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);   Serial.println(&quot;WiFi connected&quot;);  Serial.println(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());   fetchSelfSigned(); &#125; void loop() &#123;&#125;







setKnownKey – 设置服务器公钥说明在使用ESP8266实现HTTPS协议物联网通讯时，我们可以使用服务器公钥进行服务器身份认证。setKnownKey函数用于安装服务器公钥，以便ESP8266进行服务器身份认证。（公钥是服务器认证的关键。请确保服务器公钥正确，否则您的物联网通讯可能受到安全威胁。）
如需获取网站服务器公钥，可以先使用浏览器将服务器证书下载（注意这里下载的是服务器证书而不是根证书）。
请注意：在使用本函数前需要先建立PublicKey对象。并且将该对象作为setKnownKey的参数。如需了解具体操作方法，请见本函数页面的示例程序部分。
语法httpsClient.setKnownKey(key);
参数key: 公钥信息（类型：PublicKey*）
返回值无
示例程序以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应状态码以及响应头信息显示于串口监视器中。
请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与必应网站服务器进行通讯。服务器响应状态码以及响应头信息显示于串口监视器中以便我们查阅。程序运行结果如下图所示。

通过以上截屏，我们可以看到服务器响应状态码为200 OK。这一信息说明必应网站服务器已经成功地与ESP8266取得连接，另外服务器也已经成功的收到了ESP8266通过HTTPS协议发送的请求信息。
在以下示例程序中，我们使用了语句PublicKey key(pubkey)建立了公钥对象，并且将该对象作为参数应用在 httpsClient.setKnownKey(&amp;key)语句中。具体操作方法请见以下示例程序中高亮语句部分。
注：此程序中的公钥是服务器公钥，而不是CA公钥。如需获取该服务器公钥，可以先使用浏览器将服务器证书下载。假设此处下载的服务器证书名称为“bing.cer”，接下来可以使用OpenSSL工具软件通过以下指令从服务器证书中提取服务器公钥:openssl x509 -pubkey -noout -in bing.cer。
/**********************************************************************程序名称/Program name     : ESP8266-WiFiClientSecure-setKnownKey_bing程序目的/Purpose          : 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。本程序使用了setKnownKey来利用服务器公钥实现服务器身份认证方式。注：此程序中的公钥是服务器公钥，而不是CA公钥。如需获取该公钥，可以先使用浏览器将服务器证书下载（假设此处下载的服务器证书名称为www-bing-com.pem）。然后使用openssl通过以下指令从服务器证书中提取服务器公钥:openssl x509 -pubkey -noout -in www-bing-com.pem 注意：出于安全原因，网站服务器会定期更新公钥信息。因此本程序中的公钥可能已经过期。请使用以上方法获取最新的服务器公钥并复制粘贴到程序中相应位置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt; #include &lt;ESP8266WebServer.h&gt; //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;cn.bing.com&quot;;  //HTTPS端口443const int httpsPort = 443;   void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    httpsCom(); // 实现https通讯&#125; void loop() &#123;&#125; // 实现https通讯void httpsCom()&#123;  // 使用openssl获取网站服务器公钥（具体方法详见程序头部说明信息）// 并将其复制粘贴到以下数组中。static const char pubkey[] PROGMEM = R&quot;KEY(-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4SJT29Ij+8UZlEnCuN0COwov5b3zLploURQB3Bc4yAx7O+LKtAfs3vB1uT0ei1kXv3d8keXQvO4ELNKlxorc7D/b1iXKcCldu97ZZ1ohH4GcebbzQhXRzqqGKBy92vM3nfyZBkxHl7pBhF9E3gYAo3FU4+akcSYY5VsbNwHAf6uH+L4t0BvNE20lNlDtJZL4b37O9wtY6ou2bKYmv2LDKnEOl/gDwGfuILio0K+at9rc49hRrSTumZmbjVfVsG99vPdVIcGdw9j6yHJwjZSENfxWoeopu1XOu6jtsf/vq+4Duz7UfG8ghZxbjVFUMYUiJApI+hbz8XGHn6JNMCdFUQIDAQAB-----END PUBLIC KEY-----)KEY&quot;;   WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象  PublicKey key(pubkey);          Serial.println(&quot;Using public key&quot;);  httpsClient.setKnownKey(&amp;key);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。通过串口监视器输出服务器状态码和响应头信息  // 从而确定ESP8266已经成功连接服务器  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    Serial.println(line);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   Serial.println(&quot;Now disconect from the server...&quot;);      //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125;







setCiphers – 设置加密方式(自定义)说明setCiphers可用来设置ESP8266的HTTPS通讯加密方式。与使用setTrustAnchors函数来对服务器根证书认证比较，setCiphers安全性能要更低。但是此使用setCiphers可以降低ESP8266的运算工作。因此ESP8266的能耗也会相应降低。如果您的项目使用电池为ESP8266供电且需要降低ESP8266能耗，可以考虑采用此方法实现ESP8266的HTTPS通讯。如需了解更多加密方式，请参考ESP8266库源文件中WiFiClientSecureBearSSL.cpp中相关信息。
语法httpsClient.setCiphers(cipherList)
参数cipherList: 加密方式
返回值成功设置加密方式，则返回true。否则返回false。返回值为布尔型。
示例程序以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应状态码以及响应头信息显示于串口监视器中。
请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与必应网站服务器进行通讯。服务器响应状态码以及响应头信息显示于串口监视器中以便我们查阅。
在以下示例程序中，我们在使用setCiphers前需要首先使用httpsClient.setInsecure()来设置ESP8266。接下来使用 httpsClient.setCiphers(myCustomList)来设置具体加密方式。具体操作方法，请见以下程序中高亮语句部分。
/**********************************************************************程序名称/Program name     : ESP8266-WiFiClientSecure-setCiphers程序目的/Purpose          : 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。本程序使用了setCiphers来设置通讯加密方式。此方法与使用服务器根证书认证方法比较，安全性能要更低。但是此方法可以降低ESP8266的运算工作。因此ESP8266的能耗也会相应降低。如果您的项目使用电池为ESP8266供电，且需要降低ESP8266能耗，可以考虑采用此方法实现ESP8266的HTTPS通讯。如需了解更多加密方式，请参考ESP8266库源文件中WiFiClientSecureBearSSL.cpp中相关信息。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt; #include &lt;ESP8266WebServer.h&gt; //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;cn.bing.com&quot;;  //HTTPS端口443const int httpsPort = 443;   void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    httpsCom(); // 实现https通讯&#125; void loop() &#123;&#125; // 实现https通讯void httpsCom()&#123;   WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象     // 设置时间  setClock();    Serial.println(&quot;set ciphers...&quot;);  // 添加加密方式（如需了解更多加密方式，请参考ESP8266库源文件中WiFiClientSecureBearSSL.cpp中相关信息）  std::vector&lt;uint16_t&gt; myCustomList = &#123; BR_TLS_RSA_WITH_AES_256_CBC_SHA256, BR_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, BR_TLS_RSA_WITH_3DES_EDE_CBC_SHA &#125;;    // 使用setCiphers前需要首先使用setInsecure来设置ESP8266  httpsClient.setInsecure();   // 接下来使用setCiphers来设置具体加密方式  httpsClient.setCiphers(myCustomList);    httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。通过串口监视器输出服务器状态码和响应头信息  // 从而确定ESP8266已经成功连接服务器  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    Serial.println(line);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   Serial.println(&quot;Now disconect from the server...&quot;);      //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125; // 获取网络时间，该时间信息用于证书认证void setClock() &#123;  configTime(3 * 3600, 0, &quot;ntp.ntsc.ac.cn&quot;,&quot;pool.ntp.org&quot;, &quot;time.nist.gov&quot;);    // bool configTime(int timezone, int daylightOffset, char *server1, char *server2, char *server3, bool enable);  Serial.print(&quot;Waiting for NTP time sync: &quot;);  time_t now = time(nullptr);  while (now &lt; 8 * 3600 * 2) &#123;    delay(500);    Serial.print(&quot;.&quot;);    now = time(nullptr);  &#125;  Serial.println(&quot;&quot;);  struct tm timeinfo;  gmtime_r(&amp;now, &amp;timeinfo);  Serial.print(&quot;Current time: &quot;);  Serial.print(asctime(&amp;timeinfo));&#125;





setCiphersLessSecure– 设置加密方式(低级别)说明setCiphersLessSecure可用来设置ESP8266的HTTPS通讯加密方式。与使用setTrustAnchors函数来对服务器根证书认证比较，setCiphersLessSecure安全性能要更低。但是使用setCiphersLessSecure可以降低ESP8266的运算工作。因此ESP8266的能耗也会相应降低。如果您的项目使用电池为ESP8266供电且需要降低ESP8266能耗，可以考虑采用此方法实现ESP8266的HTTPS通讯。
语法
httpsClient.setCiphersLessSecure()
参数无
返回值成功设置加密方式，则返回true。否则返回false。返回值为布尔型。
示例程序以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应状态码以及响应头信息显示于串口监视器中。
请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与必应网站服务器进行通讯。服务器响应状态码以及响应头信息显示于串口监视器中以便我们查阅。
在以下示例程序中，我们在使用setCiphersLessSecure前需要首先使用httpsClient.setInsecure()来设置ESP8266。接下来使用 httpsClient.setCiphersLessSecure()来设置具体加密方式。具体操作方法，请见以下程序中高亮语句部分。
/**********************************************************************程序名称/Program name     : ESP8266-WiFiClientSecure-setCiphersLessSecure程序目的/Purpose          : 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。本程序使用了setCiphersLessSecure来设置通讯加密方式。此方法与使用服务器根证书认证方法比较，安全性能要更低。但是此方法可以降低ESP8266的运算工作。因此ESP8266的能耗也会相应降低。如果您的项目使用电池为ESP8266供电，且需要降低ESP8266能耗，可以考虑采用此方法实现ESP8266的HTTPS通讯。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt; #include &lt;ESP8266WebServer.h&gt; //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;cn.bing.com&quot;;  //HTTPS端口443const int httpsPort = 443;   void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    httpsCom(); // 实现https通讯&#125; void loop() &#123;&#125; // 实现https通讯void httpsCom()&#123;   WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象     // 设置时间  setClock();    Serial.println(&quot;set less secure ciphers ...&quot;);   // 使用setCiphersLessSecure前需要首先使用setInsecure来设置ESP8266  httpsClient.setInsecure();   // 接下来使用setCiphersLessSecure来设置具体加密方式  httpsClient.setCiphersLessSecure();    httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。通过串口监视器输出服务器状态码和响应头信息  // 从而确定ESP8266已经成功连接服务器  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    Serial.println(line);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   Serial.println(&quot;Now disconect from the server...&quot;);      //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125; // 获取网络时间，该时间信息用于证书认证void setClock() &#123;  configTime(3 * 3600, 0, &quot;ntp.ntsc.ac.cn&quot;,&quot;pool.ntp.org&quot;, &quot;time.nist.gov&quot;);    // bool configTime(int timezone, int daylightOffset, char *server1, char *server2, char *server3, bool enable);  Serial.print(&quot;Waiting for NTP time sync: &quot;);  time_t now = time(nullptr);  while (now &lt; 8 * 3600 * 2) &#123;    delay(500);    Serial.print(&quot;.&quot;);    now = time(nullptr);  &#125;  Serial.println(&quot;&quot;);  struct tm timeinfo;  gmtime_r(&amp;now, &amp;timeinfo);  Serial.print(&quot;Current time: &quot;);  Serial.print(asctime(&amp;timeinfo));&#125;







setClientRSACert – 设置客户端RSA证书说明setClientRSACert函数可以用来设置客户端私钥以及客户端证书。
注意：使用ESP8266通过HTTPS协议获取网站信息时，网站服务器无需ESP8266提供证书信息即可实现通信。但是在一些MQTT协议物联网应用中，服务器会需要ESP8266提供客户端证书以验证身份。
语法httpsClient.setClientRSACert(clientCert, clientPrivateKey)
参数clientCert：客户端证书clientPrivateKey：客户端私钥
返回值无
示例程序以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应状态码以及响应头信息显示于串口监视器中。
请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与必应网站服务器进行通讯。服务器响应状态码以及响应头信息显示于串口监视器中以便我们查阅。
在以下示例程序中，我们在使用setClientRSACert前需要首先使用X509List clientCert(digicert)来设置ESP8266的客户端证书。接下来使用 PrivateKey clientPrivateKey(key)来设置客户端私钥。具体操作方法，请见以下程序中高亮语句部分。
/**********************************************************************程序名称/Program name     : ESP8266-WiFiClientSecure-setClientRSACert程序目的/Purpose          : 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。程序使用WiFiClientSecure库中的setClientRSACert函数来设置客户端私钥以及客户端证书。 对于使用HTTPS协议访问网站信息，网站服务器无需客户端提供证书信息。此程序仅仅是为了向您演示如何来为ESP8266设置客户端私钥以及客户端证书。 注意：此程序使用网站服务器证书指纹作为服务器身份认证。出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt; #include &lt;ESP8266WebServer.h&gt; //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;cn.bing.com&quot;;  //HTTPS端口443const int httpsPort = 443;   //注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹//并复制粘贴到此处。//以下两行语句为两种不同类型的fingerprint建立。//const char fingerprint[] PROGMEM = &quot;62914576dc0afac83c4804bcc2c1b700a61139fe&quot;;const char *fingerprint = &quot;62914576dc0afac83c4804bcc2c1b700a61139fe&quot;; void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    // 实现HTTPS通讯  httpsCom();&#125; void loop()&#123;&#125; void httpsCom()&#123;  // 客户端证书信息  static const char digicert[] PROGMEM = R&quot;EOF( -----BEGIN CERTIFICATE-----MIIDiDCCAnACAQEwDQYJKoZIhvcNAQELBQAwgYkxCzAJBgNVBAYTAkNOMRAwDgYDVQQIDAdCZWlqaW5nMRAwDgYDVQQHDAdCZWlqaW5nMRUwEwYDVQQKDAxUYWljaGktTWFrZXIxDDAKBgNVBAsMA0lPVDENMAsGA1UEAwwEQ1lOTzEiMCAGCSqGSIb3DQEJARYTdGFpY2hpbWFrZXJAMTYzLmNvbTAeFw0yMDA0MTkwNzU4NDlaFw0yMzAxMTMwNzU4NDlaMIGJMQswCQYDVQQGEwJDTjEQMA4GA1UECAwHQmVpamluZzEQMA4GA1UEBwwHQmVpamluZzEVMBMGA1UECgwMVGFpY2hpLU1ha2VyMQwwCgYDVQQLDANJT1QxDTALBgNVBAMMBENZTk8xIjAgBgkqhkiG9w0BCQEWE3RhaWNoaW1ha2VyQDE2My5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDC+x7sS+0izluDQ6XJmLv9Kxh9MYG9zRrgigsTQwyv085hDyDGxaKG58ZVZfa7X+srSQ5IssaKoJqK91qTau28rcYQihBFYkGngJc1gFOyMJujFU0VDPxmSuSBUWCPcXbGg0Z4sy/z1vt2pe19AuqyKVJCDHMCRkMeX/nWbYWHqJTPoAnOZ1CW91urCc2Kf1/eq6L5aFsgjbuuY1193KP7VdumeHhbsSr6JrDwW/URtun3UjB/LjdbjHoq5bMuY94vgCGO0ykSds25jkz5rz+32obSNAreNcR9Mz9IPX6mYEP1Yj6Fv7V6zoJYNxyNiO5UYRxC5w0g9ihhaqmQVLofAgMBAAEwDQYJKoZIhvcNAQELBQADggEBAGqOfdH56LZt7WO18ymgcMRZZakH629BYu/fsX+t/mgdQ7coPQneGfHD7y2PDB76nIp+wqjlI0mAoVaGmCRny5wWOKpZbbvW6Kwn42dVab3M+zerM4ExzP3jeG76tsHbXZSHz1fUxASNONjcNjyh/s0HZcQwTgnGkFhpmMKXDkE4kU5T4itxn5j1mkVZjYOwL3d+IS8o3vmzgLCvwa4/BSK70xF3idoY6tl9bdkzU8nH4HKU8q5vjr3dh2HqWg6H7wOLx840BipKnvj4kago6AJILQ5vgo3D93eEiK3NRq/jNXJET+7/NC8xPNeKtraxlYc1o+lbQl/AqsJTBojWifs=-----END CERTIFICATE-----)EOF&quot;;   // 客户端私钥信息  static const char key[] PROGMEM = R&quot;KEY(-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4SJT29Ij+8UZlEnCuN0COwov5b3zLploURQB3Bc4yAx7O+LKtAfs3vB1uT0ei1kXv3d8keXQvO4ELNKlxorc7D/b1iXKcCldu97ZZ1ohH4GcebbzQhXRzqqGKBy92vM3nfyZBkxHl7pBhF9E3gYAo3FU4+akcSYY5VsbNwHAf6uH+L4t0BvNE20lNlDtJZL4b37O9wtY6ou2bKYmv2LDKnEOl/gDwGfuILio0K+at9rc49hRrSTumZmbjVfVsG99vPdVIcGdw9j6yHJwjZSENfxWoeopu1XOu6jtsf/vq+4Duz7UfG8ghZxbjVFUMYUiJApI+hbz8XGHn6JNMCdFUQIDAQAB-----END PUBLIC KEY-----)KEY&quot;;    WiFiClientSecure httpsClient;     //建立WiFiClientSecure对象  X509List clientCert(digicert);    //建立X509List对象用于处理客户端证书  PrivateKey clientPrivateKey(key); //建立PrivateKey对象用于处理客户端私钥   // 设置客户端私钥以及客户端证书  httpsClient.setClientRSACert(&amp;clientCert, &amp;clientPrivateKey);    Serial.println(host);    Serial.printf(&quot;Using fingerprint &#x27;%s&#x27;\n&quot;, fingerprint);  httpsClient.setFingerprint(fingerprint);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);    Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。通过串口监视器输出服务器状态码和响应头信息  // 从而确定ESP8266已经成功连接服务器  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    Serial.println(line);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   Serial.println(&quot;Now disconect from the server...&quot;);     //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125;







setSession – 会话控制说明ESP8266通过HTTPS协议实现物联网通讯时，我们可以使用setSession函数将会话保存在设备内存中以便在有需要的时候恢复会话。
语法httpsClient.setSession(session)
参数Session对象
返回值无
示例程序以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。
请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与必应网站服务器进行通讯。服务器响应状态码以及响应头信息显示于串口监视器中以便我们查阅。
注意：出于安全原因，CA会定期更新根证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。
/**********************************************************************程序名称/Program name     : ESP8266-WiFiClientSecure-setSessions程序目的/Purpose          : 本程序改编自ESP8266库中BearSSL_Sessions示例程序。以下是原示例程序注释信息Example of using SSL sessions to speed up SSL connection initiation September 2018 by Earle F. Philhower, IIIReleased to the public domain 本程序将使用setSessions函数将HTTPS对话保存在ESP8266的内存中，以便恢复使用。 ***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;time.h&gt; const char *ssid = &quot;taichimaker&quot;;const char *pass = &quot;12345678&quot;; const char *   host = &quot;cn.bing.com&quot;;const uint16_t port = 443;const char *   path = &quot;/&quot;; void setup() &#123;  Serial.begin(9600);  Serial.println();  Serial.println();   Serial.printf(&quot;Connecting to %s\n&quot;, ssid);  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, pass);   while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;\nConnected&quot;);  Serial.println(&quot;IP Address: &quot;);  Serial.println(WiFi.localIP());   // 设置时间  configTime(3 * 3600, 0, &quot;ntp.ntsc.ac.cn&quot;,&quot;pool.ntp.org&quot;, &quot;time.nist.gov&quot;);   Serial.print(&quot;Waiting for NTP time sync: &quot;);  time_t now = time(nullptr);  while (now &lt; 8 * 3600 * 2) &#123;    delay(500);    Serial.print(&quot;.&quot;);    now = time(nullptr);  &#125;  Serial.println(&quot;&quot;);  struct tm timeinfo;  gmtime_r(&amp;now, &amp;timeinfo);  Serial.print(&quot;Current time: &quot;);  Serial.print(asctime(&amp;timeinfo));&#125; // 连接网站服务器，通过串口监视器输出服务器响应状态码void fetchURL(BearSSL::WiFiClientSecure *client, const char *host, const uint16_t port, const char *path) &#123;  if (!path) &#123;    path = &quot;/&quot;;  &#125;   Serial.printf(&quot;Trying: %s:443...&quot;, host);  client-&gt;connect(host, port);  if (!client-&gt;connected()) &#123;    Serial.printf(&quot;*** Can&#x27;t connect. ***\n-------\n&quot;);    return;  &#125;  Serial.printf(&quot;Connected!\n-------\n&quot;);  client-&gt;write(&quot;GET &quot;);  client-&gt;write(path);  client-&gt;write(&quot; HTTP/1.0\r\nHost: &quot;);  client-&gt;write(host);  client-&gt;write(&quot;\r\nUser-Agent: ESP8266\r\n&quot;);  client-&gt;write(&quot;\r\n&quot;);  uint32_t to = millis() + 5000;  if (client-&gt;connected()) &#123;    do &#123;      char tmp[32];      memset(tmp, 0, 32);      int rlen = client-&gt;read((uint8_t*)tmp, sizeof(tmp) - 1);      yield();      if (rlen &lt; 0) &#123;        break;      &#125;            char *nl = strchr(tmp, &#x27;\r&#x27;);      if (nl) &#123;        *nl = 0;        Serial.print(tmp);        break;      &#125;      Serial.print(tmp);    &#125; while (millis() &lt; to);  &#125;  client-&gt;stop();  Serial.printf(&quot;\n-------\n\n&quot;);&#125;  void loop() &#123;  static const char digicert[] PROGMEM = R&quot;EOF(-----BEGIN CERTIFICATE-----MIIDdzCCAl+gAwIBAgIEAgAAuTANBgkqhkiG9w0BAQUFADBaMQswCQYDVQQGEwJJRTESMBAGA1UEChMJQmFsdGltb3JlMRMwEQYDVQQLEwpDeWJlclRydXN0MSIwIAYDVQQDExlCYWx0aW1vcmUgQ3liZXJUcnVzdCBSb290MB4XDTAwMDUxMjE4NDYwMFoXDTI1MDUxMjIzNTkwMFowWjELMAkGA1UEBhMCSUUxEjAQBgNVBAoTCUJhbHRpbW9yZTETMBEGA1UECxMKQ3liZXJUcnVzdDEiMCAGA1UEAxMZQmFsdGltb3JlIEN5YmVyVHJ1c3QgUm9vdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKMEuyKrmD1X6CZymrV51Cni4eiVgLGw41uOKymaZN+hXe2wCQVt2yguzmKiYv60iNoS6zjrIZ3AQSsBUnuId9Mcj8e6uYi1agnnc+gRQKfRzMpijS3ljwumUNKoUMMo6vWrJYeKmpYcqWe4PwzV9/lSEy/CG9VwcPCPwBLKBsua4dnKM3p31vjsufFoREJIE9LAwqSuXmD+tqYF/LTdB1kC1FkYmGP1pWPgkAx9XbIGevOF6uvUA65ehD5f/xXtabz5OTZydc93Uk3zyZAsuT3lySNTPx8kmCFcB5kpvcY67Oduhjprl3RjM71oGDHweI12v/yejl0qhqdNkNwnGjkCAwEAAaNFMEMwHQYDVR0OBBYEFOWdWTCCR1jMrPoIVDaGezq1BE3wMBIGA1UdEwEB/wQIMAYBAf8CAQMwDgYDVR0PAQH/BAQDAgEGMA0GCSqGSIb3DQEBBQUAA4IBAQCFDF2O5G9RaEIFoN27TyclhAO992T9Ldcw46QQF+vaKSm2eT929hkTI7gQCvlYpNRhcL0EYWoSihfVCr3FvDB81ukMJY2GQE/szKN+OMY3EU/t3WgxjkzSswF07r51XgdIGn9w/xZchMB5hbgF/X++ZRGjD8ACtPhSNzkE1akxehi/oCr0Epn3o0WC4zxe9Z2etciefC7IpJ5OCBRLbf1wbWsaY71k5h+3zvDyny67G7fyUIhzksLi4xaNmjICq44Y3ekQEe5+NauQrz4wlHrQMz2nZQ/1/I6eYs9HRCwBXbsdtTLSR9I4LtD+gdwyah617jzV/OeBHRnDJELqYzmp-----END CERTIFICATE-----)EOF&quot;;  uint32_t start, finish;  BearSSL::WiFiClientSecure client;  BearSSL::X509List cert(digicert);   Serial.printf(&quot;Connecting without sessions...&quot;);  start = millis();  client.setTrustAnchors(&amp;cert);  fetchURL(&amp;client, host, port, path);  finish = millis();  Serial.printf(&quot;Total time: %dms\n&quot;, finish - start);    BearSSL::Session session;  client.setSession(&amp;session);  Serial.printf(&quot;Connecting with an unitialized session...&quot;);  start = millis();  client.setTrustAnchors(&amp;cert);  fetchURL(&amp;client, host, port, path);  finish = millis();  Serial.printf(&quot;Total time: %dms\n&quot;, finish - start);   Serial.printf(&quot;Connecting with the just initialized session...&quot;);  start = millis();  client.setTrustAnchors(&amp;cert);  fetchURL(&amp;client, host, port, path);  finish = millis();  Serial.printf(&quot;Total time: %dms\n&quot;, finish - start);   Serial.printf(&quot;Connecting again with the initialized session...&quot;);  start = millis();  client.setTrustAnchors(&amp;cert);  fetchURL(&amp;client, host, port, path);  finish = millis();  Serial.printf(&quot;Total time: %dms\n&quot;, finish - start);   delay(10000);&#125;









setBufferSizes – 设置缓存大小说明setBufferSizes用于设置ESP8266在进行HTTPS协议的物联网通讯时，接收和发送缓存大小。
语法httpsClient.setBufferSizes(recv, xmit);
参数recv：接收缓存大小，该数值大小必须介于512和16384之间（单位字节，类型：int）xmit：发送缓存大小，该数值大小必须介于512和16384之间（单位字节，类型：int）
返回值无
示例程序成功设置加密方式，则返回true。否则返回false。返回值为布尔型。
示例程序以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应状态码以及响应头信息显示于串口监视器中。
请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与必应网站服务器进行通讯。服务器响应状态码以及响应头信息显示于串口监视器中以便我们查阅。
在以下示例程序中，我们在使用setBufferSizes来设置接收和发送缓存大小。具体操作方法，请见以下程序中高亮语句部分。
/**********************************************************************程序名称/Program name     : ESP8266-WiFiClientSecure-setBufferSizes程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的stop函数来控制ESP8266断开与服务器的连接。 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。程序使用了setBufferSizes函数来设置ESP8266的收发信息缓存大小。 注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt; #include &lt;ESP8266WebServer.h&gt; //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;cn.bing.com&quot;;  //HTTPS端口443const int httpsPort = 443;   //注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹//并复制粘贴到此处。//以下两行语句为两种不同类型的fingerprint建立。//const char fingerprint[] PROGMEM = &quot;62914576dc0afac83c4804bcc2c1b700a61139fe&quot;;const char *fingerprint = &quot;62914576dc0afac83c4804bcc2c1b700a61139fe&quot;; void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    // 实现HTTPS通讯  httpsCom();&#125; void loop()&#123;&#125; void httpsCom()&#123;  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象    Serial.println(host);  httpsClient.setBufferSizes(16000, 512);     Serial.printf(&quot;Using fingerprint &#x27;%s&#x27;\n&quot;, fingerprint);  httpsClient.setFingerprint(fingerprint);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);    Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。通过串口监视器输出服务器状态码和响应头信息  // 从而确定ESP8266已经成功连接服务器  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    Serial.println(line);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   Serial.println(&quot;Now disconect from the server...&quot;);     //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125;







setCertStore – 设置证书储存说明setCertStore函数用于为ESP8266设置CertStore（证书集）。
如果您知道ESP8266要连接哪些服务器，那么您就不需要CertStore。但是，如果您不知道ESP8266将要连接并验证哪些服务器身份， CertStore可以让您从几十个甚至上百个存储在SPIFFS或SD中的证书里选择证书从而进行服务器身份验证。这一过程很像是浏览器在验证网站服务器身份时所使用的方法。
语法httpsClient.setCertStore(certStore)
参数certStore：证书集对象
返回值无
示例程序以下示例程序
在运行程序之前，请先下载certs-from-mozilla.py。然后使用certs-from-mozilla.py下载证书集，接下来请将生成的.AR文件上传到SPIFFS或SD。
/**********************************************************************程序名称/Program name     : ESP8266-WiFiClientSecure-setCertStore程序目的/Purpose          : 本程序是ESP8266库中的BearSSL_CertStore示例程序。仅对程序注释信息做了翻译。以下是原程序头注释翻译。 如果您知道ESP8266要连接哪些服务器，那么您就不需要CertStore。但是，如果您不知道ESP8266将要连接并验证哪些服务器身份， CertStore可以让您从几十个甚至上百个存储在SPIFFS或SD中的证书里选择证书从而进行服务器身份验证。这一过程很像是浏览器在验证网站服务器身份时所使用的方法。 在运行程序之前，必须使用certs-from-mozilla.py下载证书集然后将生成的.AR文件上传到SPIFFS或SD。您不需要生成“ .IDX”文件，它是CertStore对象生成时自动生成并且由ESP8266创建并写入SD或SPIFFS。certs-from-mozilla.py可通过以下链接下载：http://www.taichi-maker.com/wp-content/uploads/2020/04/certs-from-mozilla.zip certs-from-mozilla.py可以从互联网获取Mozilla.org的证书集。但是请不要以此为认可或要求：用户（您）可以自行决定将要用作信任基础的证书。2018年3月 作者：Earle F. Philhower, IIIReleased to the public domain***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;CertStoreBearSSL.h&gt;#include &lt;time.h&gt;#include &lt;FS.h&gt; #ifndef STASSID#define STASSID &quot;your-ssid&quot;#define STAPSK  &quot;your-password&quot;#endif const char *ssid = STASSID;const char *pass = STAPSK; // 建立CertStore对象。BearSSL::CertStore certStore; // 通过互联网获取时间信息，该信息用于x.509证书验证void setClock() &#123;  configTime(3 * 3600, 0, &quot;pool.ntp.org&quot;, &quot;time.nist.gov&quot;);   Serial.print(&quot;Waiting for NTP time sync: &quot;);  time_t now = time(nullptr);  while (now &lt; 8 * 3600 * 2) &#123;    delay(500);    Serial.print(&quot;.&quot;);    now = time(nullptr);  &#125;  Serial.println(&quot;&quot;);  struct tm timeinfo;  gmtime_r(&amp;now, &amp;timeinfo);  Serial.print(&quot;Current time: &quot;);  Serial.print(asctime(&amp;timeinfo));&#125; // 连接服务器void fetchURL(BearSSL::WiFiClientSecure *client, const char *host, const uint16_t port, const char *path) &#123;  if (!path) &#123;    path = &quot;/&quot;;  &#125;   Serial.printf(&quot;Trying: %s:443...&quot;, host);  client-&gt;connect(host, port);  if (!client-&gt;connected()) &#123;    Serial.printf(&quot;*** Can&#x27;t connect. ***\n-------\n&quot;);    return;  &#125;  Serial.printf(&quot;Connected!\n-------\n&quot;);  client-&gt;write(&quot;GET &quot;);  client-&gt;write(path);  client-&gt;write(&quot; HTTP/1.0\r\nHost: &quot;);  client-&gt;write(host);  client-&gt;write(&quot;\r\nUser-Agent: ESP8266\r\n&quot;);  client-&gt;write(&quot;\r\n&quot;);  uint32_t to = millis() + 5000;  if (client-&gt;connected()) &#123;    do &#123;      char tmp[32];      memset(tmp, 0, 32);      int rlen = client-&gt;read((uint8_t*)tmp, sizeof(tmp) - 1);      yield();      if (rlen &lt; 0) &#123;        break;      &#125;      // 仅仅输出服务器响应状态码信息      char *nl = strchr(tmp, &#x27;\r&#x27;);      if (nl) &#123;        *nl = 0;        Serial.print(tmp);        break;      &#125;      Serial.print(tmp);    &#125; while (millis() &lt; to);  &#125;  client-&gt;stop();  Serial.printf(&quot;\n-------\n&quot;);&#125; void setup() &#123;  Serial.begin(115200);  Serial.println();  Serial.println();   SPIFFS.begin();  // 如果使用 SD 卡或者LittleFS库, 请使用::begin    // 连接WiFi  Serial.print(&quot;Connecting to &quot;);  Serial.println(ssid);  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, pass);   while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);   Serial.println(&quot;WiFi connected&quot;);  Serial.println(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());   setClock(); // X.509 认证用对时   int numCerts = certStore.initCertStore(SPIFFS, PSTR(&quot;/certs.idx&quot;), PSTR(&quot;/certs.ar&quot;));  Serial.printf(&quot;Number of CA certs read: %d\n&quot;, numCerts);  if (numCerts == 0) &#123;    Serial.printf(&quot;No certs found. Did you run certs-from-mozilla.py and upload the SPIFFS directory before running?\n&quot;);    return; // Can&#x27;t connect to anything w/o certs!  &#125;   BearSSL::WiFiClientSecure *bear = new BearSSL::WiFiClientSecure();  // 应用证书集（cert store）  bear-&gt;setCertStore(&amp;certStore);  Serial.printf(&quot;Attempting to fetch https://www.github.com/...\n&quot;);  fetchURL(bear, &quot;www.github.com&quot;, 443, &quot;/&quot;);  delete bear;&#125; void loop() &#123;  Serial.printf(&quot;\nPlease enter a website address (www.blah.com) to connect to: &quot;);  String site;  do &#123;    site = Serial.readString();  &#125; while (site == &quot;&quot;);  // Strip newline if present  site.replace(String(&quot;\r&quot;), emptyString);  site.replace(String(&quot;\n&quot;), emptyString);  Serial.printf(&quot;https://%s/\n&quot;, site.c_str());   BearSSL::WiFiClientSecure *bear = new BearSSL::WiFiClientSecure();  // Integrate the cert store with this connection  bear-&gt;setCertStore(&amp;certStore);  fetchURL(bear, site.c_str(), 443, &quot;/&quot;);  delete bear;&#125;







状态信息类型connected – 检查是否成功连接服务器说明connected函数可以用来检查ESP8266在使用HTTPS协议通讯时，ESP8266与服务器连接的状态。
语法httpsClient.connected()
参数无
返回值ESP8266与服务器连接则返回true，否则返回false。
示例程序请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。

此程序使用了语句 httpsClient.connected()检查当前ESP8266是否与服务器连接。具体操作方法，请见以下示例程序的高亮部分。
注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。
/**********************************************************************程序名称/Program name     : ESP8266-WiFiClientSecure-connected程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的connected函数来检查ESP8266是否与服务器连接。 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。 注意：本程序使用了指纹认证方式。出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt; #include &lt;ESP8266WebServer.h&gt; //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;www.howsmyssl.com&quot;;  //HTTPS端口443const int httpsPort = 443;   //注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹//并复制粘贴到此处。//以下两行语句为两种不同类型的fingerprint建立。//const char fingerprint[] PROGMEM = &quot;c7c1f454fb33ef22191163c50c12dc7d4842694a&quot;;const char *fingerprint = &quot;c7c1f454fb33ef22191163c50c12dc7d4842694a&quot;; void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    // 实现HTTPS通讯  httpsCom();&#125; void loop()&#123;&#125; void httpsCom()&#123;  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象   Serial.println(host);   Serial.printf(&quot;Using fingerprint &#x27;%s&#x27;\n&quot;, fingerprint);  httpsClient.setFingerprint(fingerprint);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器  // 告知用户当前ESP8266已经成功接收服务器响应头信息。  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   // 通过串口监视器输出服务器响应体信息（服务器报文）  Serial.println(&quot;==========&quot;);  Serial.println(&quot;server response payload:&quot;);   String line;  while(httpsClient.available())&#123;            line = httpsClient.readStringUntil(&#x27;\n&#x27;);  //Read Line by Line    Serial.println(line); //Print response  &#125;  Serial.println(&quot;==========&quot;);    //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125;



getLastSSLError – 获取SSL错误信息说明ESP8266通过HTTPS协议进行物联网通讯时，我们可以使用getLastSSLError获取通讯报错信息。这些报错信息将以错误代码的形式通过getLastSSLError返回。
如需了解报错代码的详细说明，您可以参考以下两个文件中相应部分。
bearssl_ssl.hbearssl_x509.h
语法httpsClient.getLastSSLError()
参数无
返回值错误代码值，（类型： int）
示例程序请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议尝试与必应网站服务器进行通讯。由于我们故意将服务器认证的指纹信息改为错误的，连接将会失败，同时程序中使用了httpsClient.getLastSSLError()来获取连接失败的报错信息。具体操作方法，请见以下 示例程序中的高亮代码部分。
如需了解报错代码的详细说明，您可以参考以下两个文件中相应部分。
bearssl_ssl.hbearssl_x509.h
/**********************************************************************程序名称/Program name     : ESP8266-WiFiClientSecure-getLastSSLError程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的getLastSSLError函数来获取连接出错信息。程序中故意将服务器指纹改为错误的。这么做是为了让getLastSSLError返回出错数据信息。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt; #include &lt;ESP8266WebServer.h&gt; //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;cn.bing.com&quot;;  //HTTPS端口443const int httpsPort = 443;   //注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹//并复制粘贴到此处。 //const char *fingerprint = &quot;62914576dc0afac83c4804bcc2c1b700a61139fe&quot;; // 正确指纹const char *fingerprint = &quot;62914576dc0afac83c4804bcc2c1b700a69fe123&quot;;// 错误指纹 void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    // 实现HTTPS通讯  httpsCom();&#125; void loop()&#123;&#125; void httpsCom()&#123;  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象    Serial.println(host);     Serial.printf(&quot;Using fingerprint &#x27;%s&#x27;\n&quot;, fingerprint);  httpsClient.setFingerprint(fingerprint);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;           Serial.print(&quot;httpsClient.getLastSSLError() = &quot;);      Serial.println(httpsClient.getLastSSLError());            delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;    Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);    Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。通过串口监视器输出服务器状态码和响应头信息  // 从而确定ESP8266已经成功连接服务器  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    //Serial.println(line);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;    Serial.println(&quot;Now disconect from the server...&quot;);     //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125;





发送数据类型print – 发送信息（Stream类）说明print函数用于发送数据到已连接的服务器。print函数与println函数功能十分相似。他们二者的区别是，println函数会在发送的数据结尾增加一个换行符（’\n’），而print函数则不会。
请留意，WiFiClientSecure库对象在处理或发送网络数据时，可以通过调用Stream类中的函数来实现。本函数即是Stream类中的一员。
语法httpsClient.print(val);

参数val:所要发送的数据，可以是字符串、字符或者数值。
返回值无
示例程序示例1：ESP8266实现HTTPS通讯（指纹认证）以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。本程序使用了指纹认证方式。比起本页的“示例2：ESP8266实现HTTPS通讯（证书认证）”，示例1所采用的指纹认证不如证书认证安全性高。
请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。

在以下示例程序中，我们使用httpsClient.print(request)通过ESP8266向网站服务器发送请求。具体操作方法，请见以下示例程序的高亮部分。
注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。
/**********************************************************************程序名称/Program name     : WiFiClientSecurre_print_1程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的print函数来控制ESP8266通过HTTPS协议向接服务器发送请求。 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。 本程序使用了指纹认证方式。该方式没有证书认证方式安全。 注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt;   //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;www.howsmyssl.com&quot;;  //HTTPS端口443const int httpsPort = 443;   //注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹//并复制粘贴到此处。const char fingerprint[] PROGMEM = &quot;c7c1f454fb33ef22191163c50c12dc7d4842694a&quot;; void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    // 实现HTTPS通讯  httpsCom();&#125; void loop()&#123;&#125; void httpsCom()&#123;  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象   Serial.println(host);   Serial.printf(&quot;Using fingerprint &#x27;%s&#x27;\n&quot;, fingerprint);  httpsClient.setFingerprint(fingerprint);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器  // 告知用户当前ESP8266已经成功接收服务器响应头信息。  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   // 通过串口监视器输出服务器响应体信息（服务器报文）  Serial.println(&quot;==========&quot;);  Serial.println(&quot;server response payload:&quot;);   String line;  while(httpsClient.available())&#123;            line = httpsClient.readStringUntil(&#x27;\n&#x27;);  //Read Line by Line    Serial.println(line); //Print response  &#125;  Serial.println(&quot;==========&quot;);    //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125;



示例2：ESP8266实现HTTPS通讯（证书认证）本示例所实现的功能与示例1相同。唯一区别是本示例在ESP8266与服务器的HTTPS通信中，使用证书认证而不是指纹认证。使用本示例中的证书认证可以提高HTTPS通讯安全性。
如需了解本示例程序的操作方法和运行结果，请参考示例1中的相应内容。
注意：出于安全原因，CA会定期更新根证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。
/**********************************************************************程序名称/Program name     : WiFiClientSecurre_print_2程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的print函数来控制ESP8266通过HTTPS协议向接服务器发送请求。 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。 本程序使用了证书认证方式。该方式比指纹认证方式要更安全。 注意：出于安全原因，网站服务器会定期更新证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的服务器证书并复制粘贴到程序中相应位置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt;   //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;www.howsmyssl.com&quot;;  //HTTPS端口443const int httpsPort = 443;   void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    httpsCom(); // 实现https通讯&#125; void loop() &#123;&#125; // 实现https通讯void httpsCom()&#123;//注意：出于安全原因，网站服务器会定期更新证书信息。因此本程序//中的证书可能已经过期。请使用浏览器获取最新的服务器证书//并复制粘贴到此处。如需了解如何执行这一操作，请参考太极创客网站中//“获取网站证书”页面(网址见下)://http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/http-client-secure/certificate/  static const char digicert[] PROGMEM = R&quot;EOF( // 证书信息-----BEGIN CERTIFICATE-----MIIDSjCCAjKgAwIBAgIQRK+wgNajJ7qJMDmGLvhAazANBgkqhkiG9w0BAQUFADA/MSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMTDkRTVCBSb290IENBIFgzMB4XDTAwMDkzMDIxMTIxOVoXDTIxMDkzMDE0MDExNVowPzEkMCIGA1UEChMbRGlnaXRhbCBTaWduYXR1cmUgVHJ1c3QgQ28uMRcwFQYDVQQDEw5EU1QgUm9vdCBDQSBYMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAN+v6ZdQCINXtMxiZfaQguzH0yxrMMpb7NnDfcdAwRgUi+DoM3ZJKuM/IUmTrE4Orz5Iy2Xu/NMhD2XSKtkyj4zl93ewEnu1lcCJo6m67XMuegwGMoOifooUMM0RoOEqOLl5CjH9UL2AZd+3UWODyOKIYepLYYHsUmu5ouJLGiifSKOeDNoJjj4XLh7dIN9bxiqKqy69cK3FCxolkHRyxXtqqzTWMIn/5WgTe1QLyNau7Fqckh49ZLOMxt+/yUFw7BZy1SbsOFU5Q9D8/RhcQPGX69Wam40dutolucbY38EVAjqr2m7xPi71XAicPNaDaeQQmxkqtilX4+U9m5/wAl0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFMSnsaR7LHH62+FLkHX/xBVghYkQMA0GCSqGSIb3DQEBBQUAA4IBAQCjGiybFwBcqR7uKGY3Or+Dxz9LwwmglSBd49lZRNI+DT69ikugdB/OEIKcdBodfpga3csTS7MgROSR6cz8faXbauX+5v3gTt23ADq1cEmv8uXrAvHRAosZy5Q6XkjEGB5YGV8eAlrwDPGxrancWYaLbumR9YbK+rlmM6pZW87ipxZzR8srzJmwN0jP41ZL9c8PDHIyh8bwRLtTcm1D9SZImlJnt1ir/md2cXjbDaJWFBM5JDGFoqgCWjBH4d1QB7wCCZAA62RjYJsWvIjJEubSfZGL+T0yjWW06XyxV3bqxbYoOb8VZRzI9neWagqNdwvYkQsEjgfbKbYK7p2CNTUQ-----END CERTIFICATE-----)EOF&quot;;    WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象  BearSSL::X509List cert(digicert);    // 设置时间  setClock();    Serial.println(&quot;Using certificate&quot;);  httpsClient.setTrustAnchors(&amp;cert);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器  // 告知用户当前ESP8266已经成功接收服务器响应头信息。  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   // 通过串口监视器输出服务器响应体信息（服务器报文）  Serial.println(&quot;==========&quot;);  Serial.println(&quot;server response payload:&quot;);   String line;  while(httpsClient.available())&#123;            line = httpsClient.readStringUntil(&#x27;\n&#x27;);  //Read Line by Line    Serial.println(line); //Print response  &#125;  Serial.println(&quot;==========&quot;);    //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125; // 获取网络时间，该时间信息用于证书认证void setClock() &#123;  configTime(3 * 3600, 0, &quot;ntp.ntsc.ac.cn&quot;,&quot;pool.ntp.org&quot;, &quot;time.nist.gov&quot;);    // bool configTime(int timezone, int daylightOffset, char *server1, char *server2, char *server3, bool enable);  Serial.print(&quot;Waiting for NTP time sync: &quot;);  time_t now = time(nullptr);  while (now &lt; 8 * 3600 * 2) &#123;    delay(500);    Serial.print(&quot;.&quot;);    now = time(nullptr);  &#125;  Serial.println(&quot;&quot;);  struct tm timeinfo;  gmtime_r(&amp;now, &amp;timeinfo);  Serial.print(&quot;Current time: &quot;);  Serial.print(asctime(&amp;timeinfo));&#125;





println – 发送信息（Stream类）说明println函数用于发送数据到已连接的服务器。println函数与print函数功能十分相似。他们二者的区别是，println函数会在发送的数据结尾增加一个换行符（’\n’），而print函数则不会。
请留意，WiFiClient对象在处理或发送网络数据时，可以通过调用Stream类中的函数来实现。本函数即是Stream类中的一员。
语法httpsClient.println(val);

参数val:所要发送的数据，可以是字符串、字符或者数值。
返回值无
示例程序示例1：ESP8266实现HTTPS通讯（指纹认证）以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。本程序使用了指纹认证方式。比起本页的“示例2：ESP8266实现HTTPS通讯（证书认证）”，示例1所采用的指纹认证不如证书认证安全性高。
请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。

在以下示例程序中，我们使用httpsClient.println(request)通过ESP8266向网站服务器发送请求。具体操作方法，请见以下示例程序的高亮部分。
注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。
/**********************************************************************程序名称/Program name     : WiFiClientSecurre_println_1程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的println函数来控制ESP8266通过HTTPS协议向接服务器发送请求。 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。 本程序使用了指纹认证方式。该方式没有证书认证方式安全。 注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt;   //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;www.howsmyssl.com&quot;;  //HTTPS端口443const int httpsPort = 443;   //注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹//并复制粘贴到此处。const char fingerprint[] PROGMEM = &quot;c7c1f454fb33ef22191163c50c12dc7d4842694a&quot;; void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    // 实现HTTPS通讯  httpsCom();&#125; void loop()&#123;&#125; void httpsCom()&#123;  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象   Serial.println(host);   Serial.printf(&quot;Using fingerprint &#x27;%s&#x27;\n&quot;, fingerprint);  httpsClient.setFingerprint(fingerprint);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.println(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器  // 告知用户当前ESP8266已经成功接收服务器响应头信息。  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   // 通过串口监视器输出服务器响应体信息（服务器报文）  Serial.println(&quot;==========&quot;);  Serial.println(&quot;server response payload:&quot;);   String line;  while(httpsClient.available())&#123;            line = httpsClient.readStringUntil(&#x27;\n&#x27;);  //Read Line by Line    Serial.println(line); //Print response  &#125;  Serial.println(&quot;==========&quot;);    //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125;



write – 发送信息（Stream类）说明write函数可用于发送数据到已连接的服务器。你可以发送单个字节的信息也可以发送多字节的信息。
语法httpsClient.write(val);``httpsClient.write(str)``httpsClient.write(buf, len)

参数val: 要发送的单字符数据str: 要发送的多字符数据buf: 要发送的多字符数组len: buf的字节长度
返回值写入发送缓存的字节数
响应信息类型readString – 读取数据并保存为字符串（Stream类）说明本函数可用于从ESP8266接收到数据中读取数据信息。读取到的信息将以字符串格式返回。
请留意，WiFiClientSecure对象在处理或发送网络数据时，可以通过调用Stream类中的函数来实现。本函数即是Stream类中的一员。
语法httpsClient.readString()

参数无
返回值接收到的数据，类型为字符串。
示例程序示例1：ESP8266实现HTTPS通讯（指纹认证）以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。本程序使用了指纹认证方式。比起本页的“示例2：ESP8266实现HTTPS通讯（证书认证）”，示例1所采用的指纹认证不如证书认证安全性高。
请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。

在以下示例程序中，我们使用httpsClient.readString()从ESP8266接收到数据中读取数据信息。读取到的信息将以字符串格式返回。具体操作方法，请见以下示例程序中的高亮语句部分。
注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。
/**********************************************************************程序名称/Program name     : WiFiClientSecurre_readString_1程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的readString函数来从ESP8266接收到数据中读取数据信息。读取到的信息将以字符串格式返回。 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。 本程序使用了指纹认证方式。该方式没有证书认证方式安全。 注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt;   //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;www.howsmyssl.com&quot;;  //HTTPS端口443const int httpsPort = 443;   //注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹//并复制粘贴到此处。const char fingerprint[] PROGMEM = &quot;c7c1f454fb33ef22191163c50c12dc7d4842694a&quot;; void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    // 实现HTTPS通讯  httpsCom();&#125; void loop()&#123;&#125; void httpsCom()&#123;  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象   Serial.println(host);   Serial.printf(&quot;Using fingerprint &#x27;%s&#x27;\n&quot;, fingerprint);  httpsClient.setFingerprint(fingerprint);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.println(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器  // 告知用户当前ESP8266已经成功接收服务器响应头信息。  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   // 通过串口监视器输出服务器响应体信息（服务器报文）  Serial.println(&quot;==========&quot;);  Serial.println(&quot;server response payload:&quot;);   String line;  while(httpsClient.available())&#123;            line = httpsClient.readString();     Serial.println(line);   &#125;  Serial.println(&quot;==========&quot;);    //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125;

示例2：ESP8266实现HTTPS通讯（证书认证）本示例所实现的功能与示例1相同。唯一区别是本示例在ESP8266与服务器的HTTPS通信中，使用证书认证而不是指纹认证。使用本示例中的证书认证可以提高HTTPS通讯安全性。
如需了解本示例程序的操作方法和运行结果，请参考示例1中的相应内容。
注意：出于安全原因，CA会定期更新根证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。
/**********************************************************************程序名称/Program name     : WiFiClientSecurre_readString_2程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的readString函数来从ESP8266接收到数据中读取数据信息。读取到的信息将以字符串格式返回。 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。 本程序使用了证书认证方式。该方式比指纹认证方式要更安全。 注意：出于安全原因，网站服务器会定期更新证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的服务器证书并复制粘贴到程序中相应位置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt;   //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;www.howsmyssl.com&quot;;  //HTTPS端口443const int httpsPort = 443;   void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    httpsCom(); // 实现https通讯&#125; void loop() &#123;&#125; // 实现https通讯void httpsCom()&#123;//注意：出于安全原因，网站服务器会定期更新证书信息。因此本程序//中的证书可能已经过期。请使用浏览器获取最新的服务器证书//并复制粘贴到此处。如需了解如何执行这一操作，请参考太极创客网站中//“获取网站证书”页面(网址见下)://http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/http-client-secure/certificate/  static const char digicert[] PROGMEM = R&quot;EOF( // 证书信息-----BEGIN CERTIFICATE-----MIIDSjCCAjKgAwIBAgIQRK+wgNajJ7qJMDmGLvhAazANBgkqhkiG9w0BAQUFADA/MSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMTDkRTVCBSb290IENBIFgzMB4XDTAwMDkzMDIxMTIxOVoXDTIxMDkzMDE0MDExNVowPzEkMCIGA1UEChMbRGlnaXRhbCBTaWduYXR1cmUgVHJ1c3QgQ28uMRcwFQYDVQQDEw5EU1QgUm9vdCBDQSBYMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAN+v6ZdQCINXtMxiZfaQguzH0yxrMMpb7NnDfcdAwRgUi+DoM3ZJKuM/IUmTrE4Orz5Iy2Xu/NMhD2XSKtkyj4zl93ewEnu1lcCJo6m67XMuegwGMoOifooUMM0RoOEqOLl5CjH9UL2AZd+3UWODyOKIYepLYYHsUmu5ouJLGiifSKOeDNoJjj4XLh7dIN9bxiqKqy69cK3FCxolkHRyxXtqqzTWMIn/5WgTe1QLyNau7Fqckh49ZLOMxt+/yUFw7BZy1SbsOFU5Q9D8/RhcQPGX69Wam40dutolucbY38EVAjqr2m7xPi71XAicPNaDaeQQmxkqtilX4+U9m5/wAl0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFMSnsaR7LHH62+FLkHX/xBVghYkQMA0GCSqGSIb3DQEBBQUAA4IBAQCjGiybFwBcqR7uKGY3Or+Dxz9LwwmglSBd49lZRNI+DT69ikugdB/OEIKcdBodfpga3csTS7MgROSR6cz8faXbauX+5v3gTt23ADq1cEmv8uXrAvHRAosZy5Q6XkjEGB5YGV8eAlrwDPGxrancWYaLbumR9YbK+rlmM6pZW87ipxZzR8srzJmwN0jP41ZL9c8PDHIyh8bwRLtTcm1D9SZImlJnt1ir/md2cXjbDaJWFBM5JDGFoqgCWjBH4d1QB7wCCZAA62RjYJsWvIjJEubSfZGL+T0yjWW06XyxV3bqxbYoOb8VZRzI9neWagqNdwvYkQsEjgfbKbYK7p2CNTUQ-----END CERTIFICATE-----)EOF&quot;;    WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象  BearSSL::X509List cert(digicert);    // 设置时间  setClock();    Serial.println(&quot;Using certificate&quot;);  httpsClient.setTrustAnchors(&amp;cert);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.println(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器  // 告知用户当前ESP8266已经成功接收服务器响应头信息。  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   // 通过串口监视器输出服务器响应体信息（服务器报文）  Serial.println(&quot;==========&quot;);  Serial.println(&quot;server response payload:&quot;);   String line;  while(httpsClient.available())&#123;            line = httpsClient.readString();  //Read Line by Line    Serial.println(line); //Print response  &#125;  Serial.println(&quot;==========&quot;);    //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125; // 获取网络时间，该时间信息用于证书认证void setClock() &#123;  configTime(3 * 3600, 0, &quot;ntp.ntsc.ac.cn&quot;,&quot;pool.ntp.org&quot;, &quot;time.nist.gov&quot;);    // bool configTime(int timezone, int daylightOffset, char *server1, char *server2, char *server3, bool enable);  Serial.print(&quot;Waiting for NTP time sync: &quot;);  time_t now = time(nullptr);  while (now &lt; 8 * 3600 * 2) &#123;    delay(500);    Serial.print(&quot;.&quot;);    now = time(nullptr);  &#125;  Serial.println(&quot;&quot;);  struct tm timeinfo;  gmtime_r(&amp;now, &amp;timeinfo);  Serial.print(&quot;Current time: &quot;);  Serial.print(asctime(&amp;timeinfo));&#125;





readStringUntil – 读取数据直到指定字符并保存为字符串（Stream类）说明readStringUntil函数可用于从设备接收到的数据中读取信息。读取到的数据信息将以字符串形式返回。该函数在满足以下任一条件后都会停止函数执行并返回。
– 读取到指定终止字符– 达到设定时间（可使用setTimeout来设置）
当函数读取到终止字符后，会立即停止函数执行。此时函数所返回的字符串为”终止字符”前的所有字符信息。
请留意，WiFiClientSecure对象在处理或发送网络数据时，可以通过调用Stream类中的函数来实现。本函数即是Stream类中的一员。
语法httpsClient.readStringUntil(terminator)

参数terminator: 终止字符。用于设置终止函数执行的字符信息。设备在读取数据时一旦读取到此终止字符，将会结束函数执行。允许使用char类型。
返回值接收到的数据，类型为字符串。
示例程序示例1：ESP8266实现HTTPS通讯（指纹认证）以下程序将实现ESP8266建立与网站的HTTPS通讯，并且将网站服务器响应信息显示于串口监视器中。本程序使用了指纹认证方式。比起本页的“示例2：ESP8266实现HTTPS通讯（证书认证）”，示例1所采用的指纹认证不如证书认证安全性高。
请将以下示例程序中的Wifi联网信息进行调整并将程序上传给ESP8266。程序上传完毕后，ESP8266将会自动连接 WiFi并通过HTTPS协议与www.howsmyssl.com网站服务器进行通讯（该网站专门用于HTTPS通讯测试）。服务器响应信息将会通过串口监视器显示以便我们查阅。程序运行结果如下图所示。

在以下示例程序中，我们使用httpsClient.readStringUntil()从ESP8266接收到数据中读取数据信息。读取到的信息将以字符串格式返回。具体操作方法，请见以下示例程序中的高亮语句部分。
注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。
/**********************************************************************程序名称/Program name     : WiFiClientSecurre_readStringUntil_1程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的readStringUntil函数来从ESP8266接收到数据中读取数据信息。读取到的信息将以字符串格式返回。 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。 本程序使用了指纹认证方式。该方式没有证书认证方式安全。 注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt;   //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;www.howsmyssl.com&quot;;  //HTTPS端口443const int httpsPort = 443;   //注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹//并复制粘贴到此处。const char fingerprint[] PROGMEM = &quot;c7c1f454fb33ef22191163c50c12dc7d4842694a&quot;; void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    // 实现HTTPS通讯  httpsCom();&#125; void loop()&#123;&#125; void httpsCom()&#123;  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象   Serial.println(host);   Serial.printf(&quot;Using fingerprint &#x27;%s&#x27;\n&quot;, fingerprint);  httpsClient.setFingerprint(fingerprint);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.println(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器  // 告知用户当前ESP8266已经成功接收服务器响应头信息。  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   // 通过串口监视器输出服务器响应体信息（服务器报文）  Serial.println(&quot;==========&quot;);  Serial.println(&quot;server response payload:&quot;);   String line;  while(httpsClient.available())&#123;            line = httpsClient.readString();     Serial.println(line);   &#125;  Serial.println(&quot;==========&quot;);    //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125;



示例2：ESP8266实现HTTPS通讯（证书认证）本示例所实现的功能与示例1相同。唯一区别是本示例在ESP8266与服务器的HTTPS通信中，使用证书认证而不是指纹认证。使用本示例中的证书认证可以提高HTTPS通讯安全性。
如需了解本示例程序的操作方法和运行结果，请参考示例1中的相应内容。
注意：出于安全原因，CA会定期更新根证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的网站根证书并复制粘贴到程序中相应位置。
/**********************************************************************程序名称/Program name     : WiFiClientSecurre_readStringUntil_2程序目的/Purpose          : 此程序用于演示如何使用WiFiClientSecure库中的readStringUntil函数来从ESP8266接收到数据中读取数据信息。读取到的信息将以字符串格式返回。 以下程序将实现ESP8266开发板建立与网站的HTTPS通讯,并且将网站服务器响应信息显示于串口监视器中。 本程序使用了证书认证方式。该方式比指纹认证方式要更安全。 注意：出于安全原因，网站服务器会定期更新证书信息。因此本程序中的证书可能已经过期。请使用浏览器获取最新的服务器证书并复制粘贴到程序中相应位置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt;   //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;www.howsmyssl.com&quot;;  //HTTPS端口443const int httpsPort = 443;   void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    httpsCom(); // 实现https通讯&#125; void loop() &#123;&#125; // 实现https通讯void httpsCom()&#123;//注意：出于安全原因，网站服务器会定期更新证书信息。因此本程序//中的证书可能已经过期。请使用浏览器获取最新的服务器证书//并复制粘贴到此处。  static const char digicert[] PROGMEM = R&quot;EOF( // 证书信息-----BEGIN CERTIFICATE-----MIIDSjCCAjKgAwIBAgIQRK+wgNajJ7qJMDmGLvhAazANBgkqhkiG9w0BAQUFADA/MSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMTDkRTVCBSb290IENBIFgzMB4XDTAwMDkzMDIxMTIxOVoXDTIxMDkzMDE0MDExNVowPzEkMCIGA1UEChMbRGlnaXRhbCBTaWduYXR1cmUgVHJ1c3QgQ28uMRcwFQYDVQQDEw5EU1QgUm9vdCBDQSBYMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAN+v6ZdQCINXtMxiZfaQguzH0yxrMMpb7NnDfcdAwRgUi+DoM3ZJKuM/IUmTrE4Orz5Iy2Xu/NMhD2XSKtkyj4zl93ewEnu1lcCJo6m67XMuegwGMoOifooUMM0RoOEqOLl5CjH9UL2AZd+3UWODyOKIYepLYYHsUmu5ouJLGiifSKOeDNoJjj4XLh7dIN9bxiqKqy69cK3FCxolkHRyxXtqqzTWMIn/5WgTe1QLyNau7Fqckh49ZLOMxt+/yUFw7BZy1SbsOFU5Q9D8/RhcQPGX69Wam40dutolucbY38EVAjqr2m7xPi71XAicPNaDaeQQmxkqtilX4+U9m5/wAl0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFMSnsaR7LHH62+FLkHX/xBVghYkQMA0GCSqGSIb3DQEBBQUAA4IBAQCjGiybFwBcqR7uKGY3Or+Dxz9LwwmglSBd49lZRNI+DT69ikugdB/OEIKcdBodfpga3csTS7MgROSR6cz8faXbauX+5v3gTt23ADq1cEmv8uXrAvHRAosZy5Q6XkjEGB5YGV8eAlrwDPGxrancWYaLbumR9YbK+rlmM6pZW87ipxZzR8srzJmwN0jP41ZL9c8PDHIyh8bwRLtTcm1D9SZImlJnt1ir/md2cXjbDaJWFBM5JDGFoqgCWjBH4d1QB7wCCZAA62RjYJsWvIjJEubSfZGL+T0yjWW06XyxV3bqxbYoOb8VZRzI9neWagqNdwvYkQsEjgfbKbYK7p2CNTUQ-----END CERTIFICATE-----)EOF&quot;;    WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象  BearSSL::X509List cert(digicert);    // 设置时间  setClock();    Serial.println(&quot;Using certificate&quot;);  httpsClient.setTrustAnchors(&amp;cert);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.println(request);   Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。一旦查到响应头结束字符，则通过串口监视器  // 告知用户当前ESP8266已经成功接收服务器响应头信息。  while (httpsClient.connected()) &#123;    String line = httpsClient.readStringUntil(&#x27;\n&#x27;);    if (line == &quot;\r&quot;) &#123;      Serial.println(&quot;headers received&quot;);      break;    &#125;  &#125;   // 通过串口监视器输出服务器响应体信息（服务器报文）  Serial.println(&quot;==========&quot;);  Serial.println(&quot;server response payload:&quot;);   String line;  while(httpsClient.available())&#123;            line = httpsClient.readString();  //Read Line by Line    Serial.println(line); //Print response  &#125;  Serial.println(&quot;==========&quot;);    //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125; // 获取网络时间，该时间信息用于证书认证void setClock() &#123;  configTime(3 * 3600, 0, &quot;ntp.ntsc.ac.cn&quot;,&quot;pool.ntp.org&quot;, &quot;time.nist.gov&quot;);    // bool configTime(int timezone, int daylightOffset, char *server1, char *server2, char *server3, bool enable);  Serial.print(&quot;Waiting for NTP time sync: &quot;);  time_t now = time(nullptr);  while (now &lt; 8 * 3600 * 2) &#123;    delay(500);    Serial.print(&quot;.&quot;);    now = time(nullptr);  &#125;  Serial.println(&quot;&quot;);  struct tm timeinfo;  gmtime_r(&amp;now, &amp;timeinfo);  Serial.print(&quot;Current time: &quot;);  Serial.print(asctime(&amp;timeinfo));&#125;







find – 在数据中寻找信息（Stream类）说明find函数可用于从设备接收到的数据中寻找指定字符串信息。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。
请留意，WiFiClientSecure对象在处理或发送网络数据时，可以通过调用Stream类中的函数来实现。本函数即是Stream类中的一员。
语法httpsClient.find(target)

参数target: 被查找字符串。允许使用String或char类型。
返回值返回值类型为bool。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。
示例程序此程序用于演示如何使用esp8266作为互联网客户端向网站服务器发送https请求，并且使用find函数在网站服务器响应的信息中寻找“Date”字符串。如果找到“Date”字符串，则通过串口监视器告知用户开发板已经找到了“Date”字符串。
关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。
/**********************************************************************程序名称/Program name     : ESP8266-WiFiClientSecure-find程序目的/Purpose          : 此程序用于演示如何使用esp8266作为互联网客户端向网站服务器发送https请求，并且使用find函数在网站服务器响应的信息中寻找“Date”字符串。如果找到“Date”字符串，则通过串口监视器告知用户开发板已经找到了“Date”字符串。 注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt; #include &lt;ESP8266WebServer.h&gt; //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;cn.bing.com&quot;;  //HTTPS端口443const int httpsPort = 443;   //注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹//并复制粘贴到此处。//以下两行语句为两种不同类型的fingerprint建立。//const char fingerprint[] PROGMEM = &quot;62914576dc0afac83c4804bcc2c1b700a61139fe&quot;;const char *fingerprint = &quot;62914576dc0afac83c4804bcc2c1b700a61139fe&quot;; void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    // 实现HTTPS通讯  httpsCom();&#125; void loop()&#123;&#125; void httpsCom()&#123;  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象    Serial.println(host);  httpsClient.setBufferSizes(16000, 512);     Serial.printf(&quot;Using fingerprint &#x27;%s&#x27;\n&quot;, fingerprint);  httpsClient.setFingerprint(fingerprint);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);    Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。通过串口监视器输出服务器状态码和响应头信息  // 从而确定ESP8266已经成功连接服务器  while (httpsClient.connected()) &#123;    if (httpsClient.available())&#123;      if (httpsClient.find(&quot;Date&quot;))&#123;        Serial.println(&quot;Found Date Info in Server Response.&quot;);        break;      &#125;    &#125;  &#125;   Serial.println(&quot;Now disconect from the server...&quot;);     //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125;



parseInt – 解析数据中的整数（Stream类）说明parseInt函数可用于从设备接收到的数据中寻找整数数值。
请留意，WiFiClientSecure对象在处理或发送网络数据时，可以通过调用Stream类中的函数来实现。本函数即是Stream类中的一员。
语法httpsClient.parseInt()
参数无
返回值在输入信息中找到的整数数值。类型：long
示例程序此程序用于演示如何使用esp8266作为互联网客户端向网站服务器发送https请求，并且使用find函数在网站服务器响应的信息中寻找“Date”字符串。如果找到“Date”字符串，则进一步使用parseInt函数来寻找“Date”字符串后面的第一个数字。由于标准服务器相应信息中“Date”字符串后面的第一个数字信息即是当前服务器的日期信息中的”日”数值。因parseInt函数寻找到的数字即是服务器的日期信息中的”日”数值。
关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266-WiFiClientSecure-parseInt程序目的/Purpose          : 此程序用于演示如何使用esp8266作为互联网客户端向网站服务器发送https请求，并且使用find函数在网站服务器响应的信息中寻找“Date”字符串。如果找到“Date”字符串，则进一步使用parseInt函数来寻找“Date”字符串后面的第一个数字。由于标准服务器相应信息中“Date”字符串后面的第一个数字信息即是当前服务器的日期信息中的&quot;日&quot;数值。因此parseInt函数寻找到的数字即是服务器的日期信息中的&quot;日&quot;数值。 注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹并复制粘贴到程序中相应位置。***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiClientSecure.h&gt; #include &lt;ESP8266WebServer.h&gt; //WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;taichimaker&quot;   //WiFi名称 #define password &quot;12345678&quot;  //WiFi密码 //测试HTTPS通讯的网站const char *host = &quot;cn.bing.com&quot;;  //HTTPS端口443const int httpsPort = 443;   //注意：出于安全原因，网站服务器会定期更新证书指纹信息。因此本程序//中的证书指纹可能已经过期。请使用浏览器获取最新的服务器证书指纹//并复制粘贴到此处。//以下两行语句为两种不同类型的fingerprint建立。//const char fingerprint[] PROGMEM = &quot;62914576dc0afac83c4804bcc2c1b700a61139fe&quot;;const char *fingerprint = &quot;62914576dc0afac83c4804bcc2c1b700a61139fe&quot;; void setup() &#123;  Serial.begin(9600);  WiFi.mode(WIFI_STA);        //设置ESP8266为无线终端工作模式    WiFi.begin(ssid, password); //连接WiFi  Serial.println(&quot;&quot;);   Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;);    // 等待连接  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;   //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。  Serial.println(&quot;&quot;);  Serial.print(&quot;Connected to &quot;);  Serial.println(ssid);  Serial.print(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());    // 实现HTTPS通讯  httpsCom();&#125; void loop()&#123;&#125; void httpsCom()&#123;  WiFiClientSecure httpsClient;    //建立WiFiClientSecure对象    Serial.println(host);  httpsClient.setBufferSizes(16000, 512);     Serial.printf(&quot;Using fingerprint &#x27;%s&#x27;\n&quot;, fingerprint);  httpsClient.setFingerprint(fingerprint);  httpsClient.setTimeout(15000);    delay(1000);    Serial.println(&quot;HTTPS Connecting&quot;);Serial.println(&quot;&quot;);  int r=0;  // 尝试连接服务器并等待  while((!httpsClient.connect(host, httpsPort)) &amp;&amp; (r &lt; 30))&#123;      delay(100);      Serial.print(&quot;.&quot;);      r++;  &#125;  // 连接超时后输出&quot;连接失败&quot;信息并返回  if(r==30) &#123;     Serial.println(&quot;Connection failed&quot;);    return;  &#125; else &#123; // 连接成功则输出“连接成功”信息    Serial.println(&quot;Connected...&quot;);  &#125;   Serial.print(&quot;requesting: &quot;);  Serial.println(host);    // 建立HTTPS请求信息字符串  String request =  String(&quot;GET /a/check&quot;) + &quot; HTTP/1.1\r\n&quot; +                        &quot;Host: &quot; + host + &quot;\r\n&quot; +                        &quot;Connection: close\r\n&quot; +                        &quot;\r\n&quot;;  // 向服务器发送请求                     httpsClient.print(request);    Serial.println(&quot;request sent&quot;);   // 检查服务器响应信息。通过串口监视器输出服务器状态码和响应头信息  // 从而确定ESP8266已经成功连接服务器  while (httpsClient.connected()) &#123;    if (httpsClient.available())&#123;      if (httpsClient.find(&quot;Date&quot;))&#123;        Serial.println(&quot;Found Date Info in Server Response.&quot;);        int day = httpsClient.parseInt();               Serial.print(&quot;day = &quot;);Serial.println(day);                break;      &#125;    &#125;  &#125;   Serial.println(&quot;Now disconect from the server...&quot;);     //操作结束，断开服务器连接   httpsClient.stop();  Serial.println(&quot;closing connection&quot;);  &#125;





备注:以上带有Stream标注的函数说明该函数是Stream类函数。
ESP8266 – WiFiServerSecure库WiFiServerSecure库用于ESP8266的HTTPS协议物联网通讯。HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的互联网协议。HTTPS协议在HTTP的基础上通过SSL或TLS来实现传输加密和身份认证，从而保证了传输过程的安全性。假如您需要进一步了解HTTPS协议的介绍关内容，请参考百度百科HTTPS协议页面。
通过WiFiServerSecure库，我们可以使用ESP8266开发板建立网络服务器,从而允许其它网络设备以及物联网设备通过HTTPS协议访问并实现物联网信息交流。
WiFiServerSecure – 建立WiFiServerSecure 对象说明通过WiFiServerSecure语句，我们可以建立WiFiServerSecure对象从而使用ESP8266建立支持HTTPS协议的物联网服务器。
语法WiFiServerSecure server(port)
参数– port: 此参数用于设置服务端口号。(类型:uint16_t)
返回值无
示例程序为了演示本实例程序的运行结果，我在这里使用基于Chrome内核的Microsoft Edge浏览器来进行示例程序操作演示。
请务必注意：本示例程序所使用的证书和密钥只能用于测试使用。您在自己搭建ESP8266物联网项目时，需要自行建立 证书密钥而不要使用本示例中的证书和密钥。
当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址。此时，ESP8266已经成功建立了支持HTTPS协议的网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。
当您如上图所示输入完IP地址后，接下来 请按下回车键。您将在浏览器中看到如下警告信息 。这很正常，因为ESP8266的服务器证书不是CA颁布的证书，所以浏览器会警告我们，它无法确定ESP8266服务器的身份信息。请忽略这一警告信息，并按照下图所示，点击按钮。

接下来您将看到如下图所示的信息。该信息正是详细说明为何无法验证ESP8266服务器身份的原因。我们需要继续忽略 这一警告信息，并按照下图所示，点击链接。

如下图所示，您将看到浏览器中出现了“Hello from ESP8266”信息。这一信息是由ESP8266服务器发来的。说明我们的ESP8266服务器已经可以通过HTTPS协议进行数据通讯了。

关于如何使用WiFiServerSecure来建立对象这一操作，请见以下程序中的高亮语句部分。
/**********************************************************************程序名称/Program name     : WiFiServerSecure程序目的/Purpose          : 此程序用于演示如何使用建立WiFiServerSecure对象从而使用ESP8266建立支持HTTPS协议的物联网服务器。 本示例程序借鉴ESP8266库中BearSSL_Server示例程序，该程序作者Earle F. Philhower, III 关于本程序的具体使用方法，请参考以下链接：http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/web-server-secure/wifiserversecure/***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;time.h&gt; // WiFi连接信息const char *ssid = &quot;taichimaker&quot;;// WiFi名称const char *pass = &quot;12345678&quot;;   // WiFi密码 // 建立WiFiServerSecure对象WiFiServerSecure server(443); // 建立服务器响应信息static const char *HTTP_RES =        &quot;HTTP/1.0 200 OK\r\n&quot;        &quot;Connection: close\r\n&quot;        &quot;Content-Length: 62\r\n&quot;        &quot;Content-Type: text/html; charset=iso-8859-1\r\n&quot;        &quot;\r\n&quot;        &quot;&lt;html&gt;\r\n&quot;        &quot;&lt;body&gt;\r\n&quot;        &quot;&lt;p&gt;Hello from ESP8266!&lt;/p&gt;\r\n&quot;        &quot;&lt;/body&gt;\r\n&quot;        &quot;&lt;/html&gt;\r\n&quot;; //服务器私钥const char server_private_key[] PROGMEM = R&quot;EOF(-----BEGIN PRIVATE KEY-----MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQDhDf/pokuS+FQOMPxiDTPMDZEFQjFoy/uCwiN4MebPg+IcXMVx2o6MSn8x9ofAatwAOq/dYoExhev1HN2C3O4ZjjFACsryL6hYXaKG+qHiNEfvHgPTw0olWsDm9N01CcQs7lJqW2wmM5JMxXP8ZU0rcUU70qWCUUTR+rN8WE4QHTd7BjP6OTvqjN7Al4ibg8//7owXlSECnM1BSKIZQZ6g0QcWLf+rSn6hRrbHPGIkp5RZTIGZ7k9zgUfHQezKKYtRZXRtUhB5JW78ZyGYaphaek5WlkgakL2pbM/Q/DgKew/2k0najKUjmkz+gxtof4vlmZAojSaN2647labAbuydAgMBAAECggEAYHi806zDUpvqhC7RcUKRio3iNWvbfD28cZ/AzpwtgZTaDyhhZt22L0Mb5RH1vTDRX7PIgVDhapYqwGaAOcF0uzWtvPMjbc+qDT8OFWhIjou0rjaik1rqZLrTZ+1dCYhHNK9wWrEX2gRPWWNmxbGy88VZVTyFwCgQJSafW9UKmXLu4KUTILHcyGsEfVBxth8Vr9uWuNWa6nRW/tb/3uNwRn1ATKV6h+HFgBHxgfkSN11GwZfdSRzuov7Y09qGbIHZmeoBYG8iNJ/A4qOhaMJis1Qmt6mjpBzUJRxGriZIHh2EznoM85Uejc8cqSnWH8mA8PPT4xDwCbv2ueT9bT5HYQKBgQD25qFyjx+Bbzsbok2alF7wQiN5WbzA5zdCusecTO+Fi2HkrKODFSQdaCHxl/kFKcy7NxYZjeIcNZzf6vnCB2Hyrm3B/eeCJ+WoTm/ajfS6dxgt2aO48An+wFAyb7qGdBBrPr+hvn3RG5hbupEMbGJnBhRfpcq0+9+JcqMfcAUkuQKBgQDpWUMtfuukR+hwkHhbs68FyXbGxnHMGYthsLRWmbmK6OVmSKWDU5kRPlMckztqUReJdE+x6fbvBDbW/cIi83mQa0+7KTxLajojzoCV6CKZz4dATURlisTtfqVCjQP/wHJ4y6E270Ar80CM/0AT8gw+HrWGLeCa+MQNL0Qg/u5dBQKBgDAsUaXbfQcxH7RFl6SofFmeXfOIacatll+jt9ysOjOxPVlzwbeKwXAnaDAOOd0jCbohhmNYBp0AbOpXm4GbFSZXmDy4gJoplKqhGzvmZLCZGhOgGky0MQ8OkNc2a4teS/HQ3Wz+kOfi3XhQT4q//vcg/Yqn+4QSfMwBnQg+QBKpAoGAdUchljoV4Ikrb3eMpjoWmwf4JEsUYonsHXscB/JW6FPJB7E3TluzsJDsYI427GY5OCI286otK0+o6EC9U6eez1C/z8cXwKdw9RISWkVDLp640T6EQ6yM8PgXwuzwt5dXcRKWwe9ZBz3IkZSv9dZPBOGWRgvEuN6SWjYJPbQixKkCgYA+plfKhE+f+ofA7wWkmfo31cyJmyBCL9ROwfzRlo1ftttYy1XHOLxpe2ts+hh+pqrftGdura1X0TuY6v7d1mk1snuyj7+E37PjIewk4nr45PU4OWwqW2Pqx4BZAYosU+ki1z12rh3ofZhudBH6B5nNTPhoHwGbAajgSzHYYG8koQ==-----END PRIVATE KEY-----)EOF&quot;; // 服务器证书const char server_cert[] PROGMEM = R&quot;EOF(-----BEGIN CERTIFICATE-----MIIEQzCCAyugAwIBAgIUCUSExaDX4tk9VoMXia7kABA2pewwDQYJKoZIhvcNAQELBQAwgbAxCzAJBgNVBAYTAkNOMRAwDgYDVQQIDAdCZWlqaW5nMRAwDgYDVQQHDAdCZWlqaW5nMRUwEwYDVQQKDAxUYWljaGktTWFrZXIxDDAKBgNVBAsMA0lPVDEQMA4GA1UEAwwHRVNQODI2NjFGMEQGCSqGSIb3DQEJARY3dGFpY2hpYW1rZXJAG1tEG1tEG1tEGxtbQxsbW0MbW0MbW0MbdGFpY2hpbWFrZXJAMTYzLmNvbTAeFw0yMDA0MjAxMDQ3MjNaFw0zMTA3MDgxMDQ3MjNaMIGwMQswCQYDVQQGEwJDTjEQMA4GA1UECAwHQmVpamluZzEQMA4GA1UEBwwHQmVpamluZzEVMBMGA1UECgwMVGFpY2hpLU1ha2VyMQwwCgYDVQQLDANJT1QxEDAOBgNVBAMMB0VTUDgyNjYxRjBEBgkqhkiG9w0BCQEWN3RhaWNoaWFta2VyQBtbRBtbRBtbRBsbW0MbG1tDG1tDG1tDG3RhaWNoaW1ha2VyQDE2My5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDhDf/pokuS+FQOMPxiDTPMDZEFQjFoy/uCwiN4MebPg+IcXMVx2o6MSn8x9ofAatwAOq/dYoExhev1HN2C3O4ZjjFACsryL6hYXaKG+qHiNEfvHgPTw0olWsDm9N01CcQs7lJqW2wmM5JMxXP8ZU0rcUU70qWCUUTR+rN8WE4QHTd7BjP6OTvqjN7Al4ibg8//7owXlSECnM1BSKIZQZ6g0QcWLf+rSn6hRrbHPGIkp5RZTIGZ7k9zgUfHQezKKYtRZXRtUhB5JW78ZyGYaphaek5WlkgakL2pbM/Q/DgKew/2k0najKUjmkz+gxtof4vlmZAojSaN2647labAbuydAgMBAAGjUzBRMB0GA1UdDgQWBBTttMAlJ46XNA1ydxe5J0bVfWA3ujAfBgNVHSMEGDAWgBTttMAlJ46XNA1ydxe5J0bVfWA3ujAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQCSQH9T7rWS11DHLvPXuwRx2F675y5bNZ7L4q0akgdQwH3T4RNRS0yQbcNPqOsiEwypsV45kEjzniBqNcHcfxld1Ik1zcv9wvvKZE9HfrZbaVRzIR7GPmIzjhdepBK8gPvQoqIHVLM6WTY5/2voGOUPB7NLjDtvVpFNGG3KpNjC6msfywWTCAAB3oNSHeQsy01DD6FSQHGjBZZiXo7P7MOFz/D5+z61OBy0UiCGi08UjVAodMTfTHNxGZW9D2yLzuKLfewbtcbeje2MACiXLDuIS+ed8YgXn7UH2SNfx1DhsSGueWgEMISsqJUMgU02IrTu3VViSE7eXoRQkLEdeiGI-----END CERTIFICATE-----)EOF&quot;; void setup() &#123;  Serial.begin(9600);  Serial.println();   // 连接 WiFi  Serial.print(&quot;Connecting to &quot;);  Serial.println(ssid);  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, pass);   while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);   Serial.println(&quot;WiFi connected&quot;);  Serial.println(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());   // 建立X509List对象用于处理及储存服务器证书  X509List *serverCertList = new BearSSL::X509List(server_cert);    // 建立PrivateKey对象用于处理及储存服务器私钥  PrivateKey *serverPrivKey = new BearSSL::PrivateKey(server_private_key);   // 设置服务器证书和服务器私钥  server.setRSACert(serverCertList, serverPrivKey);   // 启动服务器  server.begin();&#125; void loop() &#123;  static int cnt;  BearSSL::WiFiClientSecure incoming = server.available();  if (!incoming) &#123;    return;  &#125;  Serial.printf(&quot;Incoming connection...%d\n&quot;,cnt++);    // 等待客户端发送请求  uint32_t timeout=millis() + 1000;  int lcwn = 0;  for (;;) &#123;    unsigned char x=0;    if ((millis() &gt; timeout) || (incoming.available() &amp;&amp; incoming.read(&amp;x, 1) &lt; 0)) &#123;      incoming.stop();      Serial.printf(&quot;Connection error, closed\n&quot;);      return;    &#125; else if (!x) &#123;      yield();      continue;    &#125; else if (x == 0x0D) &#123;      continue;    &#125; else if (x == 0x0A) &#123;      if (lcwn) &#123;        break;      &#125;      lcwn = 1;    &#125; else      lcwn = 0;  &#125;  // 发送响应信息  incoming.write((uint8_t*)HTTP_RES, strlen(HTTP_RES));  incoming.flush();  incoming.stop();  Serial.printf(&quot;Connection closed.\n&quot;);&#125;





setRSACert – 设置RSA证书说明通过WiFiServerSecure语句，我们可以建立WiFiServerSecure对象从而使用ESP8266建立支持HTTPS协议的物联网服务器。
语法server.setRSACert(cert, privateKey)
参数– cert: 服务器证书– privateKey:服务器私钥
返回值无
示例程序为了演示本实例程序的运行结果，我在这里使用基于Chrome内核的Microsoft Edge浏览器来进行示例程序操作演示。
请务必注意：本示例程序所使用的证书和密钥只能用于测试使用。您在自己搭建ESP8266物联网项目时，需要自行建立 证书密钥而不要使用本示例中的证书和密钥。
当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址。此时，ESP8266已经成功建立了支持HTTPS协议的网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。
假设您的ESP8266开发板IP地址是192.168.0.111。那么接下来您可以通过浏览器输入https://192.168.0.111。
注意一定要在ESP8266的IP地址前面加上“https&#x2F;&#x2F;”。这一操作将会让浏览器通过https协议访问ESP8266所建立的服务器。如果不输入这一信息，浏览器默认会使用http协议而不是https协议。也就达不到我们想要实现的效果。（如下图所示）

当您如上图所示输入完IP地址后，接下来 请按下回车键。您将在浏览器中看到如下警告信息 。这很正常，因为ESP8266的服务器证书不是CA颁布的证书，所以浏览器会警告我们，它无法确定ESP8266服务器的身份信息。请忽略这一警告信息，并按照下图所示，点击按钮。

接下来您将看到如下图所示的信息。该信息正是详细说明为何无法验证ESP8266服务器身份的原因。我们需要继续忽略 这一警告信息，并按照下图所示，点击链接。

如下图所示，您将看到浏览器中出现了“Hello from ESP8266”信息。这一信息是由ESP8266服务器发来的。说明我们的ESP8266服务器已经可以通过HTTPS协议进行数据通讯了。

以下示例程序中我们首先使用语句 X509List *serverCertList = new BearSSL::X509List(server_cert);建立X509List对象用于处理及储存服务器证书。接下来我们使用了语句PrivateKey *serverPrivKey = new BearSSL::PrivateKey(server_private_key);建立PrivateKey对象用于处理及储存服务器私钥。最后我们使用语句server.setRSACert(serverCertList, serverPrivKey);设置服务器证书和服务器私钥。具体使用方法，请见以下程序的高亮部分。
/**********************************************************************程序名称/Program name     : WiFiServerSecure_setRSACert程序目的/Purpose          : 此程序用于演示如何使用使用WiFiServerSecure库的setRSACert来为服务器设置证书和私钥。 本示例程序借鉴ESP8266库中BearSSL_Server示例程序，该程序作者Earle F. Philhower, III***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;time.h&gt; // WiFi连接信息const char *ssid = &quot;taichimaker&quot;;// WiFi名称const char *pass = &quot;12345678&quot;;   // WiFi密码 // 建立WiFiServerSecure对象WiFiServerSecure server(443); // 建立服务器响应信息static const char *HTTP_RES =        &quot;HTTP/1.0 200 OK\r\n&quot;        &quot;Connection: close\r\n&quot;        &quot;Content-Length: 62\r\n&quot;        &quot;Content-Type: text/html; charset=iso-8859-1\r\n&quot;        &quot;\r\n&quot;        &quot;&lt;html&gt;\r\n&quot;        &quot;&lt;body&gt;\r\n&quot;        &quot;&lt;p&gt;Hello from ESP8266!&lt;/p&gt;\r\n&quot;        &quot;&lt;/body&gt;\r\n&quot;        &quot;&lt;/html&gt;\r\n&quot;; //服务器私钥const char server_private_key[] PROGMEM = R&quot;EOF(-----BEGIN PRIVATE KEY-----MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQDhDf/pokuS+FQOMPxiDTPMDZEFQjFoy/uCwiN4MebPg+IcXMVx2o6MSn8x9ofAatwAOq/dYoExhev1HN2C3O4ZjjFACsryL6hYXaKG+qHiNEfvHgPTw0olWsDm9N01CcQs7lJqW2wmM5JMxXP8ZU0rcUU70qWCUUTR+rN8WE4QHTd7BjP6OTvqjN7Al4ibg8//7owXlSECnM1BSKIZQZ6g0QcWLf+rSn6hRrbHPGIkp5RZTIGZ7k9zgUfHQezKKYtRZXRtUhB5JW78ZyGYaphaek5WlkgakL2pbM/Q/DgKew/2k0najKUjmkz+gxtof4vlmZAojSaN2647labAbuydAgMBAAECggEAYHi806zDUpvqhC7RcUKRio3iNWvbfD28cZ/AzpwtgZTaDyhhZt22L0Mb5RH1vTDRX7PIgVDhapYqwGaAOcF0uzWtvPMjbc+qDT8OFWhIjou0rjaik1rqZLrTZ+1dCYhHNK9wWrEX2gRPWWNmxbGy88VZVTyFwCgQJSafW9UKmXLu4KUTILHcyGsEfVBxth8Vr9uWuNWa6nRW/tb/3uNwRn1ATKV6h+HFgBHxgfkSN11GwZfdSRzuov7Y09qGbIHZmeoBYG8iNJ/A4qOhaMJis1Qmt6mjpBzUJRxGriZIHh2EznoM85Uejc8cqSnWH8mA8PPT4xDwCbv2ueT9bT5HYQKBgQD25qFyjx+Bbzsbok2alF7wQiN5WbzA5zdCusecTO+Fi2HkrKODFSQdaCHxl/kFKcy7NxYZjeIcNZzf6vnCB2Hyrm3B/eeCJ+WoTm/ajfS6dxgt2aO48An+wFAyb7qGdBBrPr+hvn3RG5hbupEMbGJnBhRfpcq0+9+JcqMfcAUkuQKBgQDpWUMtfuukR+hwkHhbs68FyXbGxnHMGYthsLRWmbmK6OVmSKWDU5kRPlMckztqUReJdE+x6fbvBDbW/cIi83mQa0+7KTxLajojzoCV6CKZz4dATURlisTtfqVCjQP/wHJ4y6E270Ar80CM/0AT8gw+HrWGLeCa+MQNL0Qg/u5dBQKBgDAsUaXbfQcxH7RFl6SofFmeXfOIacatll+jt9ysOjOxPVlzwbeKwXAnaDAOOd0jCbohhmNYBp0AbOpXm4GbFSZXmDy4gJoplKqhGzvmZLCZGhOgGky0MQ8OkNc2a4teS/HQ3Wz+kOfi3XhQT4q//vcg/Yqn+4QSfMwBnQg+QBKpAoGAdUchljoV4Ikrb3eMpjoWmwf4JEsUYonsHXscB/JW6FPJB7E3TluzsJDsYI427GY5OCI286otK0+o6EC9U6eez1C/z8cXwKdw9RISWkVDLp640T6EQ6yM8PgXwuzwt5dXcRKWwe9ZBz3IkZSv9dZPBOGWRgvEuN6SWjYJPbQixKkCgYA+plfKhE+f+ofA7wWkmfo31cyJmyBCL9ROwfzRlo1ftttYy1XHOLxpe2ts+hh+pqrftGdura1X0TuY6v7d1mk1snuyj7+E37PjIewk4nr45PU4OWwqW2Pqx4BZAYosU+ki1z12rh3ofZhudBH6B5nNTPhoHwGbAajgSzHYYG8koQ==-----END PRIVATE KEY-----)EOF&quot;; // 服务器证书const char server_cert[] PROGMEM = R&quot;EOF(-----BEGIN CERTIFICATE-----MIIEQzCCAyugAwIBAgIUCUSExaDX4tk9VoMXia7kABA2pewwDQYJKoZIhvcNAQELBQAwgbAxCzAJBgNVBAYTAkNOMRAwDgYDVQQIDAdCZWlqaW5nMRAwDgYDVQQHDAdCZWlqaW5nMRUwEwYDVQQKDAxUYWljaGktTWFrZXIxDDAKBgNVBAsMA0lPVDEQMA4GA1UEAwwHRVNQODI2NjFGMEQGCSqGSIb3DQEJARY3dGFpY2hpYW1rZXJAG1tEG1tEG1tEGxtbQxsbW0MbW0MbW0MbdGFpY2hpbWFrZXJAMTYzLmNvbTAeFw0yMDA0MjAxMDQ3MjNaFw0zMTA3MDgxMDQ3MjNaMIGwMQswCQYDVQQGEwJDTjEQMA4GA1UECAwHQmVpamluZzEQMA4GA1UEBwwHQmVpamluZzEVMBMGA1UECgwMVGFpY2hpLU1ha2VyMQwwCgYDVQQLDANJT1QxEDAOBgNVBAMMB0VTUDgyNjYxRjBEBgkqhkiG9w0BCQEWN3RhaWNoaWFta2VyQBtbRBtbRBtbRBsbW0MbG1tDG1tDG1tDG3RhaWNoaW1ha2VyQDE2My5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDhDf/pokuS+FQOMPxiDTPMDZEFQjFoy/uCwiN4MebPg+IcXMVx2o6MSn8x9ofAatwAOq/dYoExhev1HN2C3O4ZjjFACsryL6hYXaKG+qHiNEfvHgPTw0olWsDm9N01CcQs7lJqW2wmM5JMxXP8ZU0rcUU70qWCUUTR+rN8WE4QHTd7BjP6OTvqjN7Al4ibg8//7owXlSECnM1BSKIZQZ6g0QcWLf+rSn6hRrbHPGIkp5RZTIGZ7k9zgUfHQezKKYtRZXRtUhB5JW78ZyGYaphaek5WlkgakL2pbM/Q/DgKew/2k0najKUjmkz+gxtof4vlmZAojSaN2647labAbuydAgMBAAGjUzBRMB0GA1UdDgQWBBTttMAlJ46XNA1ydxe5J0bVfWA3ujAfBgNVHSMEGDAWgBTttMAlJ46XNA1ydxe5J0bVfWA3ujAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQCSQH9T7rWS11DHLvPXuwRx2F675y5bNZ7L4q0akgdQwH3T4RNRS0yQbcNPqOsiEwypsV45kEjzniBqNcHcfxld1Ik1zcv9wvvKZE9HfrZbaVRzIR7GPmIzjhdepBK8gPvQoqIHVLM6WTY5/2voGOUPB7NLjDtvVpFNGG3KpNjC6msfywWTCAAB3oNSHeQsy01DD6FSQHGjBZZiXo7P7MOFz/D5+z61OBy0UiCGi08UjVAodMTfTHNxGZW9D2yLzuKLfewbtcbeje2MACiXLDuIS+ed8YgXn7UH2SNfx1DhsSGueWgEMISsqJUMgU02IrTu3VViSE7eXoRQkLEdeiGI-----END CERTIFICATE-----)EOF&quot;; void setup() &#123;  Serial.begin(9600);  Serial.println();   // 连接 WiFi  Serial.print(&quot;Connecting to &quot;);  Serial.println(ssid);  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, pass);   while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);   Serial.println(&quot;WiFi connected&quot;);  Serial.println(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());   // 建立X509List对象用于处理及储存服务器证书  X509List *serverCertList = new BearSSL::X509List(server_cert);    // 建立PrivateKey对象用于处理及储存服务器私钥  PrivateKey *serverPrivKey = new BearSSL::PrivateKey(server_private_key);   // 设置服务器证书和服务器私钥  server.setRSACert(serverCertList, serverPrivKey);   // 启动服务器  server.begin();&#125; void loop() &#123;  static int cnt;  BearSSL::WiFiClientSecure incoming = server.available();  if (!incoming) &#123;    return;  &#125;  Serial.printf(&quot;Incoming connection...%d\n&quot;,cnt++);    // 等待客户端发送请求  uint32_t timeout=millis() + 1000;  int lcwn = 0;  for (;;) &#123;    unsigned char x=0;    if ((millis() &gt; timeout) || (incoming.available() &amp;&amp; incoming.read(&amp;x, 1) &lt; 0)) &#123;      incoming.stop();      Serial.printf(&quot;Connection error, closed\n&quot;);      return;    &#125; else if (!x) &#123;      yield();      continue;    &#125; else if (x == 0x0D) &#123;      continue;    &#125; else if (x == 0x0A) &#123;      if (lcwn) &#123;        break;      &#125;      lcwn = 1;    &#125; else      lcwn = 0;  &#125;  // 发送响应信息  incoming.write((uint8_t*)HTTP_RES, strlen(HTTP_RES));  incoming.flush();  incoming.stop();  Serial.printf(&quot;Connection closed.\n&quot;);&#125;









setClientTrustAnchor – 设置信任锚说明ESP8266建立的HTTPS服务器可以要求客户端提供证书以验证客户端身份。如果客户端无法提供证明身份的证书信息，ESP8266服务器会拒绝客户端访问。我们可以使用WiFiServerSecure库的setClientTrustAnchor函数来实现这一操作。
语法server.setClientTrustAnchor(cert)
参数– cert: CA证书
返回值无
示例程序请务必注意：本示例程序所使用的证书和密钥只能用于测试使用。您在自己搭建ESP8266物联网项目时，需要自行建立 证书密钥而不要使用本示例中的证书和密钥。
测试使用本示例程序需要使用wget指令。建议您在测试本示例程序以前先准备好一台Linux系统电脑。
接下来请点击以下链接，将用于客户端身份认证的证书和密钥文件下载并解压缩到您的Linux电脑中。
client_files
当您将以下示例程序中的WiFi连接信息修改并且将本示例程序上传ESP8266开发板后，开发板随即会自动连接WiFi。WiFi连接成功后，您将可以从串口监视器获取当前ESP8266开发板的IP地址。此时，ESP8266已经成功建立了支持HTTPS协议的网络服务器。您可以通过ESP8266的IP地址来访问该网络服务器。
假设您的ESP8266开发板IP地址是192.168.0.111。接下来请使用Linux电脑的终端应用输入以下指令：
wget –no-check-certificate –certificate&#x3D;client1_cer.pem –private-key&#x3D;client1_key.pem https://192.168.0.111
以上指令中client1_cer.pem和client1_key.pem 分别是您刚下载的客户端证书文件以及客户端私钥文件。这两个文件分别是客户端证书以及客户端私钥。他们的作用是为ESP8266服务器提供身份验证。
以下截屏是该指令的运行结果。我们可以看到，客户端成功的使用了下载的证书文件和私钥文件实现了与ESP8266服务器的网络通讯。

另外，我们从串口监视器可以看到，ESP8266服务器成功的响应了客户端请求。

以下示例程序中我们首先使用语句 BearSSL::X509List *serverTrustedCert &#x3D; new BearSSL::X509List(ca_cert);建立X509List对象用于处理及储存受信CA证书。接下来我们使用了语句server.setClientTrustAnchor(serverTrustedCert);设置受信CA证书以验证客户端身份。
/*  程序名称/Program name     : WiFiServerSecure_setClientTrustAnchor  程序目的/Purpose          :   本示例程序借鉴ESP8266库中BearSSL_ServerClientCert示例程序，该程序作者Earle F. Philhower, III。   ESP8266 建立的HTTPS服务器可以要求客户端提供证书以验证客户端身份。如果客户端无法提供CA签署的证书或者无法  提供自签名证书，ESP8266服务器会拒绝客户端访问。此示例程序即是演示如何使用WiFiServerSecure库的  setClientTrustAnchor函数来实现这一操作。    如需了解如何使用本示例程序，请参考以下网址：  http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-c-plus-plus-reference/web-server-secure/setclienttrustanchor/*/#include &lt;ESP8266WiFi.h&gt;#include &lt;time.h&gt; // WiFi连接信息const char *ssid = &quot;taichimaker&quot;;// WiFi名称const char *pass = &quot;12345678&quot;;   // WiFi密码 // 建立WiFiServerSecure对象BearSSL::WiFiServerSecure server(443); // 建立服务器响应信息static const char *HTTP_RES =        &quot;HTTP/1.0 200 OK\r\n&quot;        &quot;Connection: close\r\n&quot;        &quot;Content-Length: 59\r\n&quot;        &quot;Content-Type: text/html; charset=iso-8859-1\r\n&quot;        &quot;\r\n&quot;        &quot;&lt;html&gt;\r\n&quot;        &quot;&lt;body&gt;\r\n&quot;        &quot;&lt;p&gt;Hello my friend!&lt;/p&gt;\r\n&quot;        &quot;&lt;/body&gt;\r\n&quot;        &quot;&lt;/html&gt;\r\n&quot;; // 受信任的CA证书const char ca_cert[] PROGMEM = R&quot;EOF(-----BEGIN CERTIFICATE-----MIIC1TCCAb2gAwIBAgIJAMPt1Ms37+hLMA0GCSqGSIb3DQEBCwUAMCExCzAJBgNVBAYTAlVTMRIwEAYDVQQDDAkxMjcuMC4wLjMwHhcNMTgwMzE0MDQyMTU0WhcNMjkwNTMxMDQyMTU0WjAhMQswCQYDVQQGEwJVUzESMBAGA1UEAwwJMTI3LjAuMC4zMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxsa4qU/tlzN4YTcnn/I/ffsijOPc8QRcwClKzasIZNFEye4uThl+LGZWFIFb8X8Dc+xmmBaWlPJbqtphgFKStparDdduHSW1ud6Y1FVKxljo3UwCMrYm76Q/jNzXJvGs6Z1MDNsVZzGJaoqit2H2Hkvky+7kk3YbEDlcyVsLOw0zCKL4cd2DSNDyhIZxWo2a8Qn5IdjWAYtsTnW6MvLk/ya4abNeRfSZwi+r37rqi9CIs++NpL5ynqkKKEMrbeLactWgHbWrZeaMyLpuUEL2GF+wMRaAwaj7ERwT5gFJRqYwj6bbfIdx5PC7h7ucbyp272MbrDa6WNBCMwQO222t4wIDAQABoxAwDjAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQCmXfrC42nWIpL3JDkB8YlB2QUvD9JdMp98xxo33+xE69Gov0e6984F1Gluao0p6sS7KF+q3YLS4hjnzuGzF9GJMimIB7NMQ20yXKfKpmKJ7YugMaKTDWDhHn5679mKVbLSQxHCUMEetEnMT93/UaDbWBjV6zu876q5vjPMYgDHODqO295ySaA71UkijaCn6UwKUT49286TV9ZtzgabNGHXfklHgUPWoShyze+G3g29I1BR0qABoJI63zaNu8ua42v5g1RldxsWX8yKI14mFOGxuvcygG8L2xxysW7Zq+9g+O7gW0Pm6RDYnUQmIwY83h1KFCtYCJdS2PgozwkkUNyP-----END CERTIFICATE-----)EOF&quot;; // 服务器私钥const char server_private_key[] PROGMEM = R&quot;EOF(-----BEGIN RSA PRIVATE KEY-----MIIEowIBAAKCAQEAsRNVTvqP++YUh8NrbXwE83xVsDqcB3F76xcXNKFDERfVd2P/LvyDovCcoQtT0UCRgPcxRp894EuPH/Ru6Z2Lu85sV//i7ce27tc2WRFSfuhlRxHPLJWHxTl1CEfXp/owkECQ4MB3pw6Ekc16iTEPiezTG+T+mQ/BkiIwcIK6CMlpR9DIeYUTqv0f9NrUfAjdBrqlEO2gpgFvLFrkDEU2ntAIc4aPOP7yDOym/xzfy6TiG8Wo7nlh6M97xTZGfbEPCH9rZDjo5istym1HzF5P+COq+OTSPscjFGXoi978o6hZwa7izxorg4h5a5lGnshRu2Gl+Ybfa14OwnIrv/yCswIDAQABAoIBAHxwgbsHCriTcEoYYx6F0VTrQ6ydA5mXfuYvS/eIfIE+pp1IgMScYEXZobjrJPQg1CA1l0NyFSHS97oVJPy34sMQxcLx6KABgeVHCMJ/EeJtnv7a3SUP0GIhhsVS95Lsl8RIG4hWub+EzFVKeZqAB9N9wr4Pp3wZPodbz37B38rb1QPyMFmQOLlHjKTOmoxsXhL2ot+R3+aLYSuroPO1kQo7/d0UAZoy8h9OQN4a2EXvawh4O2EvFGbc5X/yXwAdEQ4NPp9VZhkNIRkV+XZ3FcIqEVOploKtRF/tVBTz3g61/lFz21L9PMmV5y8tvSafr2SpJugGVmp2rrVQVNyGlIECgYEA10JSI5gmeCU3zK6kvOfBp54hY/5dDrSUpjKkMxpmm7WZQ6Il/k7AhMcLeMzHiriT7WhRIXF8AOr2MoEkHkH3DhVNN4ccieVZx2SE5P5mVkItZGLrrpfUdysR/ARAI1HYegGUiKacZtf9SrRavU0m7fOVOiYwbFRhjyX+MyuteYkCgYEA0pbz4ZosetScP68uZx1sGlTfkcqLl7i15DHk3gnj6jKlfhvC2MjeLMhNDtKeUAuY7rLQguZ0CCghWAv0Glh5eYdfIiPhgqFfX4P5F3Om4zQHVPYj8xHfHG4ZP7dKQTndrO1QfLdGDTQLVXabAUSp2YGrijC8J9idSW1pYClvF1sCgYEAjkDn41nzYkbGP1/SwnwuAEWCL4Czoro32jVxScxSrugt5wJLNWp508VukWBTJhugtq3Pn9hNaJXeKbYqVkylpgrxwpZph7+nuxt0r5hnrO2C7eppcjIoWLB/7BorAKxf8REGReBFT7nBTBMwPBW2el4U6h6+tXh2GJG1Eb/1nnECgYAydVb0THOx7rWNkNUGggc/++why61M6kYy6j2Tcj05BW+f2tkCBoctpcTI83BZb53yO8g4RS2yMqNirGKN2XspwmTqEjzbhv0KLt4FX4GyWOoU0nFksXiLIFpOaQWSwWG7KJWrfGJ9kWXR0Xxsfl5QLoDCuNCsn3t4d43TK7phlwKBgHDzF+50+/Wez3YHCy2a/HgSbHCpLQjkknvgwkOh1z7YitYBUm72HP8ZGe6b4wEfNuBdlZll/y9BQQOZJLFvJTE5t51X9klrkGrOb+Ftwr7eI/H5xgcadI52tPYglR5fjuRF/wnt3oX9JlQ2RtSbs+3naXH8JoherHaqNn8UpH0t-----END RSA PRIVATE KEY-----)EOF&quot;; // 服务器证书const char server_cert[] PROGMEM = R&quot;EOF(-----BEGIN CERTIFICATE-----MIIDTzCCAjcCCQDPXvMRYOpeuDANBgkqhkiG9w0BAQsFADCBpjESMBAGA1UEAwwJMTI3LjAuMC4xMQswCQYDVQQGEwJVUzElMCMGA1UECgwcTXkgT3duIENlcnRpZmljYXRlIEF1dGhvcml0eTEUMBIGA1UECAwLQXJkdWlub0xhbmQxFTATBgNVBAcMDEFyZHVpbm9WaWxsZTEVMBMGA1UECgwMRVNQODI2NlVzZXJzMRgwFgYDVQQLDA9FU1A4MjY2LUFyZHVpbm8wHhcNMTgwMzE0MDQwMDAwWhcNMjkwMjI0MDQwMDAwWjAsMRYwFAYDVQQKDA1NeSBTZXJ2ZXIgT3JnMRIwEAYDVQQDDAkxMjcuMC4wLjMwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCxE1VO+o/75hSHw2ttfATzfFWwOpwHcXvrFxc0oUMRF9V3Y/8u/IOi8JyhC1PRQJGA9zFGnz3gS48f9G7pnYu7zmxX/+Ltx7bu1zZZEVJ+6GVHEc8slYfFOXUIR9en+jCQQJDgwHenDoSRzXqJMQ+J7NMb5P6ZD8GSIjBwgroIyWlH0Mh5hROq/R/02tR8CN0GuqUQ7aCmAW8sWuQMRTae0Ahzho84/vIM7Kb/HN/LpOIbxajueWHoz3vFNkZ9sQ8If2tkOOjmKy3KbUfMXk/4I6r45NI+xyMUZeiL3vyjqFnBruLPGiuDiHlrmUaeyFG7YaX5ht9rXg7Cciu//IKzAgMBAAEwDQYJKoZIhvcNAQELBQADggEBAEnG+FNyNCOkBvzHiUpHHpScxZqM2f+XDcewJgeSL6HkYEDIZZDNnd5gduSvkHpdJtWgsvJ7dJZL40w7Ba5sxpZHPIgKJGl9hzMkG+aAz5GMkjys9h2xpQZx9KL3q7G6A+C0bll7ODZlwBtY07CFMykT4Mp2oMRrQKRucMSVAB1mKujLAnMRKJ3NM89RQJH4GYiRps9y/HvM5lh7EIK/J0/nEZeJxY5hJngskPKboPPdmkR97kaQnll4KNsC3owVlHVU2fMftgYkgQLzyeWgzcNa39AF3B6JlcOzNyQYseoK24dHmt6tWmn/sbxX7Aa6TL/4mVlFoOgcaTJyVaY/BrY=-----END CERTIFICATE-----)EOF&quot;; // 获取网络时间，该时间信息用于证书认证void setClock()&#123;  configTime(8 * 3600, 0, &quot;ntp.ntsc.ac.cn&quot;,&quot;pool.ntp.org&quot;, &quot;time.nist.gov&quot;);   Serial.print(&quot;Waiting for NTP time sync: &quot;);  time_t now = time(nullptr);  while (now &lt; 8 * 3600 * 2) &#123;    delay(500);    Serial.print(&quot;.&quot;);    now = time(nullptr);  &#125;  Serial.println(&quot;&quot;);  struct tm timeinfo;  gmtime_r(&amp;now, &amp;timeinfo);  Serial.print(&quot;Current time: &quot;);  Serial.print(asctime(&amp;timeinfo));&#125; void setup() &#123;  Serial.begin(9600);  Serial.println();  Serial.println();   // 连接 WiFi  Serial.print(&quot;Connecting to &quot;);  Serial.println(ssid);  WiFi.mode(WIFI_STA);  WiFi.begin(ssid, pass);   while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);   Serial.println(&quot;WiFi connected&quot;);  Serial.println(&quot;IP address: &quot;);  Serial.println(WiFi.localIP());   setClock(); // 获取网络时间，该时间信息用于证书认证  // 建立X509List对象用于处理及储存服务器证书  BearSSL::X509List *serverCertList = new BearSSL::X509List(server_cert);   // 建立PrivateKey对象用于处理及储存服务器私钥    BearSSL::PrivateKey *serverPrivKey = new BearSSL::PrivateKey(server_private_key);   // 设置服务器证书和服务器私钥    server.setRSACert(serverCertList, serverPrivKey);   // 建立X509List对象用于处理及储存受信CA证书  BearSSL::X509List *serverTrustedCert = new BearSSL::X509List(ca_cert);   // 设置受信CA证书以验证客户端身份  server.setClientTrustAnchor(serverTrustedCert);   // 启动服务器  server.begin();&#125; void loop() &#123;  BearSSL::WiFiClientSecure incoming = server.available();  if (!incoming) &#123;    return;  &#125;  Serial.println(&quot;Incoming connection...\n&quot;);    // 等待客户端发送请求  uint32_t timeout=millis() + 1000;  int lcwn = 0;  for (;;) &#123;    unsigned char x=0;    if ((millis() &gt; timeout) || (incoming.available() &amp;&amp; incoming.read(&amp;x, 1) &lt; 0)) &#123;      incoming.stop();      Serial.printf(&quot;Connection error, closed\n&quot;);      return;    &#125; else if (!x) &#123;      yield();      continue;    &#125; else if (x == 0x0D) &#123;      continue;    &#125; else if (x == 0x0A) &#123;      if (lcwn) &#123;        break;      &#125;      lcwn = 1;    &#125; else      lcwn = 0;  &#125;  // 发送响应信息    incoming.write((uint8_t*)HTTP_RES, strlen(HTTP_RES));  incoming.flush();  incoming.stop();  Serial.printf(&quot;Connection closed.\n&quot;);&#125;



ESP8266 – WiFiUDP库UDP协议是User Datagram Protocol的简称，中文名是用户数据协议。UDP协议是一种无连接的传输层协议。
WiFiUDP库用于ESP8266开发板的物联网通讯控制以及UDP协议数据包处理。以下为WiFiUDP库的整体结构图。在此图下方有WiFiUDP库的函数目录。您可以通过点击目录项目打开各个函数的说明页面。
请留意，WiFiUDP对象在处理或发送UDP数据时，可以通过调用Stream类中的函数来实现。因此在以下结构图中的“接收&#x2F;处理UDP数据类型”以及“发送UDP数据类型”中有“Stream类”作为这两种类型函数的一部分。
为了方便您更好的了解ESP8266的WiFiUdp库以及本站资料中WiFiUdp库函数的示例程序操作方法，我们制作了一个较为详细的图文教程。该图文教程说明了如何利用TCP_UDP测试工具软件来测试ESP8266开发板的UDP协议通讯功能。

UDP服务控制类型begin – 启动UDP服务说明此函数用于初始化WiFiUDP库和网络设置。执行此函数后，ESP8266将开始监听指定端口以提供UDP协议物联网通讯服务。
语法wiFiUDP.begin(port)

参数port：为提供UDP物联网服务而监听的端口号（类型：uint16_t）
返回值返回值数据类型为uint8_t 型。以下是返回数值说明：1：ESP8266开发板启动UDP服务成功
0：ESP8266开发板启动UDP服务失败
示例程序以下示例程序演示如何使用ESP8266监听指定端口以提供UDP协议物联网通讯服务。关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiUdp_1程序目的/Purpose          : 用于演示ESP8266WiFiUdp库中begin函数。***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiUdp.h&gt; #define ssid      &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下WIFI名字#define password  &quot;12345678&quot;         //这里改成你的设备当前环境下WIFI密码 WiFiUDP Udp;                         //实例化WiFiUDP对象unsigned int localUdpPort = 1234;    //自定义本地监听端口 void setup()&#123;  Serial.begin(115200); //打开串口  Serial.println();   Serial.printf(&quot;正在连接 %s &quot;, ssid);  WiFi.begin(ssid, password);//连接到wifi  while (WiFi.status() != WL_CONNECTED)//等待连接  &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;连接成功&quot;);  delay(2000);      if(Udp.begin(localUdpPort))&#123;  //启动Udp监听服务    Serial.println(&quot;监听成功&quot;);    //打印本地的ip地址，在UDP工具中会使用到    //WiFi.localIP().toString().c_str()用于将获取的数据转化为字符串    Serial.printf(&quot;现在收听IP：%s, UDP端口：%d\n&quot;, WiFi.localIP().toString().c_str(), localUdpPort);  &#125;&#125; void loop()&#123;&#125;

为了方便您更好的了解ESP8266的WiFiUdp库以及本站资料中WiFiUdp库函数的示例程序操作方法，我们制作了一个较为详细的图文教程。该图文教程说明了如何利用TCP_UDP测试工具软件来测试ESP8266开发板的UDP协议通讯功能。
相关内容– stop – 停止UDP服务
stop – 停止UDP服务说明当我们使用WiFiUdp库的begin函数启动ESP8266的UDP物联网通讯服务以后，我们可以使用stop函数来停止该服务。
语法wiFiUDP.stop()
参数无
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiUdp_2程序目的/Purpose          : 用于演示ESP8266WiFiUdp库中stop函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiUdp.h&gt; #define ssid      &quot;TaichiMaker_WIFI&quot; // 这里改成你的设备当前环境下WIFI名字#define password  &quot;12345678&quot;         // 这里改成你的设备当前环境下WIFI密码 WiFiUDP Udp;                         // 实例化WiFiUDP对象unsigned int localUdpPort = 1234;    // 自定义本地监听端口 void setup()&#123;  Serial.begin(115200);//打开串口  Serial.println();   Serial.printf(&quot;正在连接 %s &quot;, ssid);  WiFi.begin(ssid, password);//连接到wifi  while (WiFi.status() != WL_CONNECTED)//等待连接  &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;连接成功&quot;);  delay(2000);   if(Udp.begin(localUdpPort))&#123; //启动Udp监听服务    Serial.println(&quot;监听成功&quot;);    //打印本地的ip地址，在UDP工具中会使用到    //WiFi.localIP().toString().c_str()用于将获取的数据转化为字符串    Serial.printf(&quot;现在收听IP：%s, UDP端口：%d\n&quot;, WiFi.localIP().toString().c_str(), localUdpPort);  &#125;else&#123;    Serial.println(&quot;监听失败&quot;);  &#125;  delay(3000);  Udp.stop();//关闭udp监听  Serial.println(&quot;停止监听&quot;);&#125; void loop()&#123;&#125;



接收&#x2F;处理UDP数据类型parsePacket – 解析数据说明本函数用于检查是否有UDP数据包传入ESP8266开发板。同时，如果我们需要使用stream类中的函数(如read、readString、parseInt、find等)来处理UDP数据包的话，那么我们需要先使用parsePacket，然后才能使用stream类中的函数对传入ESP8266开发板的UDP数据包进行处理。
语法wiFiUDP.parsePacket()

参数无
返回值返回值数据类型为整数型，以下是函数返回值含义说明：n：数据包的大小（以字节为单位）0：没有可用的数据包
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiUdp_6程序目的/Purpose          : 用于演示ESP8266WiFiUdp库中parsePacket函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiUdp.h&gt; #define ssid      &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下WIFI名字#define password  &quot;12345678&quot;          //这里改成你的设备当前环境下WIFI密码 WiFiUDP Udp;//实例化WiFiUDP对象unsigned int localUdpPort = 1234;  // 自定义本地监听端口unsigned int remoteUdpPort = 4321;  // 自定义远程监听端口char incomingPacket[255];  // 保存Udp工具发过来的消息char  replyPacket[] = &quot;Hi, this is esp8266\n&quot;;  //发送的消息,仅支持英文 void setup()&#123;  Serial.begin(115200);//打开串口  Serial.println();   Serial.printf(&quot;正在连接 %s &quot;, ssid);  WiFi.begin(ssid, password);//连接到wifi  while (WiFi.status() != WL_CONNECTED)//等待连接  &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;连接成功&quot;);   if(Udp.begin(localUdpPort))&#123;//启动Udp监听服务    Serial.println(&quot;监听成功&quot;);    //打印本地的ip地址，在UDP工具中会使用到    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串        Serial.printf(&quot;现在收听IP：%s, UDP端口：%d\n&quot;, WiFi.localIP().toString().c_str(), localUdpPort);  &#125;else&#123;    Serial.println(&quot;监听失败&quot;);  &#125;&#125; void loop()&#123;  //解析Udp数据包  int packetSize = Udp.parsePacket();//获得解析包  if (packetSize)//解析包不为空  &#123;    //收到Udp数据包    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串    Serial.printf(&quot;收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\n&quot;, Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);          // 读取Udp数据包并存放在incomingPacket    int len = Udp.read(incomingPacket, 255);//返回数据包字节数    if (len &gt; 0)    &#123;       incomingPacket[len] = 0;//清空缓存    &#125;    //向串口打印信息    Serial.printf(&quot;UDP数据包内容为: %s\n&quot;, incomingPacket);     //向udp工具发送消息    Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口    Udp.write(replyPacket);//把数据写入发送缓冲区    Udp.endPacket();//发送数据  &#125;&#125;

以下是该程序的运行结果。

相关内容– available(Stream类) – 检查是否有数据被接收– read(Stream类) – 读取UDP数据– readString(Stream类) – 读取UDP字符串– parseInt(Stream类) – 解析UDP数据中整数– find(Stream类) – 在UDP数据中查找信息– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。
available(Stream类) – 检查是否有数据被接收说明本函数可用于检查设备是否接收到数据。函数将会返回等待读取的数据字节数。请注意，使用本函数以前需要先调用parsePacket函数。
WiFiUDP类对象可调用Stream类函数。available函数就是属于Stream类的。
语法wiFiUDP.available()
参数无
返回值等待读取的数据字节数。返回值数据类型：int
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiUdp_8程序目的/Purpose          : 用于演示ESP8266WiFiUdp库中available函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiUdp.h&gt; #define ssid      &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下WIFI名字#define password  &quot;12345678&quot;         //这里改成你的设备当前环境下WIFI密码 WiFiUDP Udp;//实例化WiFiUDP对象unsigned int localUdpPort = 1234;  // 自定义本地监听端口 void setup()&#123;  Serial.begin(115200);//打开串口  Serial.println();   Serial.printf(&quot;正在连接 %s &quot;, ssid);  WiFi.begin(ssid, password);//连接到wifi  while (WiFi.status() != WL_CONNECTED)//等待连接  &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;连接成功&quot;);   if(Udp.begin(localUdpPort))&#123;//启动Udp监听服务    Serial.println(&quot;监听成功&quot;);    //打印本地的ip地址，在UDP工具中会使用到    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串      Serial.printf(&quot;现在收听IP：%s, UDP端口：%d\n&quot;, WiFi.localIP().toString().c_str(), localUdpPort);  &#125;else&#123;    Serial.println(&quot;监听失败&quot;);  &#125;&#125; void loop()&#123;  int packetSize = Udp.parsePacket();//获得解析包  Serial.printf(&quot;当前UDP解析包字节数: %d\n&quot;, packetSize);  int n = Udp.available();  Serial.printf(&quot;当前UDP缓冲区字节数: %d\n&quot;, n);  delay(3000);&#125;


相关内容接收&#x2F;处理UDP数据类型– parsePacket – 解析数据– read(Stream类) – 读取UDP数据– readString(Stream类) – 读取UDP字符串– parseInt(Stream类) – 解析UDP数据中整数– find(Stream类) – 在UDP数据中查找信息– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。
read(Stream类) – 读取UDP数据说明本函数可用于从设备接收到数据中读取数据。函数将会返回等待读取的数据字节数。请注意，使用本函数以前需要先调用parsePacket函数。
WiFiUDP类对象可调用Stream类函数。本函数就是属于Stream类的。
语法WiFiUDP.read()WiFiUDP.read(buffer, len)
参数buffer：保存传入数据包的内存指针，数据类型为unsigned char*len：传入数据包的大小（单位是字节），数据类型为size_t
返回值返回值类型为整数型。
在没有使用任何参数的情况下调用此函数，函数的返回值情况如下所述:设备没有接收到数据时，返回值为-1设备接收到数据时，返回值为接收到的数据包中的第1个字符的ASCII码数值。
在使用了参数buffer和len调用此函数，函数的返回值情况如下所述:设备没有接收到数据时，返回值为-1设备接收到数据时，返回值为接收到的数据包的大小（单位是字节）。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiUdp_10程序目的/Purpose          : 用于演示ESP8266WiFiUdp库中read函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiUdp.h&gt; #define ssid      &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下WIFI名字#define password  &quot;xxxxxxx&quot;          //这里改成你的设备当前环境下WIFI密码 WiFiUDP Udp;//实例化WiFiUDP对象unsigned int localUdpPort = 1234;  // 自定义本地监听端口 void setup()&#123;  Serial.begin(115200);//打开串口  Serial.println();   Serial.printf(&quot;正在连接 %s &quot;, ssid);  WiFi.begin(ssid, password);//连接到wifi  while (WiFi.status() != WL_CONNECTED)//等待连接  &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;连接成功&quot;);   if(Udp.begin(localUdpPort))&#123;//启动Udp监听服务    Serial.println(&quot;监听成功&quot;);    //打印本地的ip地址，在UDP工具中会使用到    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串       Serial.printf(&quot;现在收听IP：%s, UDP端口：%d\n&quot;, WiFi.localIP().toString().c_str(), localUdpPort);  &#125;else&#123;    Serial.println(&quot;监听失败&quot;);  &#125;&#125; void loop()&#123;  int packetSize = Udp.parsePacket();//获得解析包  Serial.printf(&quot;当前UDP解析包字节数: %d\n&quot;, packetSize);  if(Udp.available())&#123;//判断是否有UDP数据包    char a = Udp.read();//连续调用read    Serial.printf(&quot;READ: %c\n&quot;, a);    a = Udp.read();    Serial.printf(&quot;READ: %c\n&quot;, a);    a = Udp.read();    Serial.printf(&quot;READ: %c\n&quot;, a);    a = Udp.read();    Serial.printf(&quot;READ: %c\n&quot;, a);    char incomingPacket[255];  // 存储Udp客户端发过来的数据    int len = Udp.read(incomingPacket, 255);    Serial.printf(&quot;READ: %s   len：%d\n&quot;, incomingPacket, len);  &#125;  delay(3000);&#125;

程序运行结果：

相关内容接收&#x2F;处理UDP数据类型– parsePacket – 解析数据– available(Stream类) – 检查是否有数据被接收– readString(Stream类) – 读取UDP字符串– parseInt(Stream类) – 解析UDP数据中整数– find(Stream类) – 在UDP数据中查找信息– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。
readString(Stream类) – 读取UDP字符串说明本函数可用于从设备接收到数据中读取数据信息。读取到的信息将以字符串格式返回。请注意，使用本函数以前需要先调用parsePacket函数。
WiFiUDP类对象可调用Stream类函数。本函数就是属于Stream类的。
语法wiFiUDP.readString()

参数无
返回值接收到的数据，类型为字符串。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiUdp_10程序目的/Purpose          : 用于演示ESP8266WiFiUdp库中readString函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiUdp.h&gt; #define ssid      &quot;TaichiMaker_WIFI&quot; // 这里改成你的设备当前环境下WIFI名字#define password  &quot;12345678&quot;         // 这里改成你的设备当前环境下WIFI密码 WiFiUDP Udp;//实例化WiFiUDP对象unsigned int localUdpPort = 1234;  // 自定义本地监听端口unsigned int remoteUdpPort = 4321;  // 自定义远程监听端口char  replyPacket[] = &quot;Hi, this is esp8266\n&quot;;  //发送的消息,仅支持英文 void setup()&#123;  Serial.begin(115200);//打开串口  Serial.println();   Serial.printf(&quot;正在连接 %s &quot;, ssid);  WiFi.begin(ssid, password);//连接到wifi  while (WiFi.status() != WL_CONNECTED)//等待连接  &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;连接成功&quot;);   if(Udp.begin(localUdpPort))&#123;//启动Udp监听服务    Serial.println(&quot;监听成功&quot;);    //打印本地的ip地址，在UDP工具中会使用到    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串       Serial.printf(&quot;现在收听IP：%s, UDP端口：%d\n&quot;, WiFi.localIP().toString().c_str(), localUdpPort);  &#125;else&#123;    Serial.println(&quot;监听失败&quot;);  &#125;&#125; void loop()&#123;  //解析Udp数据包  int packetSize = Udp.parsePacket();//获得解析包  if (packetSize)//解析包不为空  &#123;    //收到Udp数据包    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串    Serial.printf(&quot;收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\n&quot;, Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);          // 解析UDP数据包中的所以数据，以字符串格式返回    String udpStringVal = Udp.readString();         // 然后向串口打印返回的字符串    Serial.print(&quot;开发板接收到UDP数据中的字符串 &quot;); Serial.println(udpStringVal);     //向udp工具发送消息    Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口    Udp.write(replyPacket);//把数据写入发送缓冲区    Udp.endPacket();//发送数据  &#125;&#125;

相关内容接收&#x2F;处理UDP数据类型– parsePacket – 解析数据– available(Stream类) – 检查是否有数据被接收– read(Stream类) – 读取UDP数据– parseInt(Stream类) – 解析UDP数据中整数– find(Stream类) – 在UDP数据中查找信息– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。
parseInt(Stream类) – 解析UDP数据中整数说明本函数可用于从设备接收到的数据中寻找整数数值。读取到的信息将以字符串格式返回。请注意，使用本函数以前需要先调用parsePacket函数。
WiFiUDP类对象可调用Stream类函数。本函数就是属于Stream类的。
语法WiFiUDP.parseInt()

参数无
返回值在接收信息中找到的整数数值。类型：long
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiUdp_10程序目的/Purpose          : 用于演示ESP8266WiFiUdp库中parseInt函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiUdp.h&gt; #define ssid      &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下WIFI名字#define password  &quot;xxxxxxx&quot;          //这里改成你的设备当前环境下WIFI密码 WiFiUDP Udp;//实例化WiFiUDP对象unsigned int localUdpPort = 1234;  // 自定义本地监听端口unsigned int remoteUdpPort = 4321;  // 自定义远程监听端口char  replyPacket[] = &quot;Hi, this is esp8266\n&quot;;  //发送的消息,仅支持英文 void setup()&#123;  Serial.begin(115200);//打开串口  Serial.println();   Serial.printf(&quot;正在连接 %s &quot;, ssid);  WiFi.begin(ssid, password);//连接到wifi  while (WiFi.status() != WL_CONNECTED)//等待连接  &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;连接成功&quot;);   if(Udp.begin(localUdpPort))&#123;//启动Udp监听服务    Serial.println(&quot;监听成功&quot;);    //打印本地的ip地址，在UDP工具中会使用到    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串        Serial.printf(&quot;现在收听IP：%s, UDP端口：%d\n&quot;, WiFi.localIP().toString().c_str(), localUdpPort);  &#125;else&#123;    Serial.println(&quot;监听失败&quot;);  &#125;&#125; void loop()&#123;  //解析Udp数据包  int packetSize = Udp.parsePacket();//获得解析包  if (packetSize)//解析包不为空  &#123;    //收到Udp数据包    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串    Serial.printf(&quot;收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\n&quot;, Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);          // 解析UDP数据包中的整数    int udpIntVal = Udp.parseInt();         // 然后向串口打印UDP数据包中的整数    Serial.print(&quot;开发板接收到UDP数据中的整数数值&quot;); Serial.println(udpIntVal);     //向udp工具发送消息    Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口    Udp.write(replyPacket);//把数据写入发送缓冲区    Udp.endPacket();//发送数据  &#125;&#125;



相关内容接收&#x2F;处理UDP数据类型– parsePacket – 解析数据– available(Stream类) – 检查是否有数据被接收– read(Stream类) – 读取UDP数据– readString(Stream类) – 读取UDP字符串– find(Stream类) – 在UDP数据中查找信息– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。
find(Stream类) – 在UDP数据中查找信息说明本函数可用于从设备接收到的数据中寻找指定字符串信息。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。请注意，使用本函数以前需要先调用parsePacket函数。
WiFiUDP类对象可调用Stream类函数。本函数就是属于Stream类的。
语法wiFiUDP.find(target)

参数target: 被查找字符串。允许使用String或char类型。
返回值返回值类型为bool。当函数找到了指定字符串信息后将会立即结束函数执行并且返回“真”。否则将会返回“假”。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************项目名称/Project          : 零基础入门学用物联网程序名称/Program name     : ESP8266WiFiUdp_10团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)作者/Author              : 小凯日期/Date（YYYYMMDD）     : 20200319程序目的/Purpose          : 用于演示ESP8266WiFiUdp库中find函数-----------------------------------------------------------------------本示例程序为太极创客团队制作的《零基础入门学用物联网》中示例程序。该教程为对物联网开发感兴趣的朋友所设计和制作。如需了解更多该教程的信息，请参考以下网页：http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-nodemcu-web-client/http-request/***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiUdp.h&gt; #define ssid      &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下WIFI名字#define password  &quot;12345678&quot;         //这里改成你的设备当前环境下WIFI密码 WiFiUDP Udp;//实例化WiFiUDP对象unsigned int localUdpPort = 1234;  // 自定义本地监听端口unsigned int remoteUdpPort = 4321;  // 自定义远程监听端口char  replyPacket[] = &quot;Hi, this is esp8266\n&quot;;  //发送的消息,仅支持英文 void setup()&#123;  Serial.begin(115200);//打开串口  Serial.println();   Serial.printf(&quot;正在连接 %s &quot;, ssid);  WiFi.begin(ssid, password);//连接到wifi  while (WiFi.status() != WL_CONNECTED)//等待连接  &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;连接成功&quot;);   if(Udp.begin(localUdpPort))&#123;//启动Udp监听服务    Serial.println(&quot;监听成功&quot;);    //打印本地的ip地址，在UDP工具中会使用到    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串        Serial.printf(&quot;现在收听IP：%s, UDP端口：%d\n&quot;, WiFi.localIP().toString().c_str(), localUdpPort);  &#125;else&#123;    Serial.println(&quot;监听失败&quot;);  &#125;&#125; void loop()&#123;  //解析Udp数据包  int packetSize = Udp.parsePacket();//获得解析包  if (packetSize)//解析包不为空  &#123;    //收到Udp数据包    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串    Serial.printf(&quot;收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\n&quot;, Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);     // 使用find函数来查看用户输入信息中是否包含^_^    if(Udp.find(&quot;^_^&quot;)) &#123;      Serial.println(&quot;用户输入信息中含有 ^_^&quot;);     &#125; else &#123;      Serial.println(&quot;用户输入信息中不含有 ^_^&quot;);     &#125;          //向udp工具发送消息    Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口    Udp.write(replyPacket);//把数据写入发送缓冲区    Udp.endPacket();//发送数据  &#125;&#125;

相关内容接收&#x2F;处理UDP数据类型– parsePacket – 解析数据– available(Stream类) – 检查是否有数据被接收– read(Stream类) – 读取UDP数据– readString(Stream类) – 读取UDP字符串– parseInt(Stream类) – 解析UDP数据中整数– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。
发送UDP数据类型beginPacket – 配置UDP数据包接收设备的IP和端口说明此函数用于ESP8266开发板的UDP数据发送准备。其具体功能是设置UDP数据接收设备的IP地址和端口号。
语法wiFiUDP.beginPacket(ip,port)

参数ip：UDP数据接收设备的IP地址（IPAddress类型）port：UDP数据接收设备的IP地址监听端口号（uint16_t类型）
返回值返回值数据类型为整数型1：配置数据接收设备的IP地址和监听端口号成功0：配置数据接收设备的IP地址和监听端口号失败
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiUdp_6程序目的/Purpose          : 用于演示ESP8266WiFiUdp库中beginPacket函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiUdp.h&gt; #define ssid      &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下WIFI名字#define password  &quot;xxxxxxx&quot;          //这里改成你的设备当前环境下WIFI密码 WiFiUDP Udp;//实例化WiFiUDP对象unsigned int localUdpPort = 1234;  // 自定义本地监听端口unsigned int remoteUdpPort = 4321;  // 自定义远程监听端口char incomingPacket[255];  // 保存Udp工具发过来的消息char  replyPacket[] = &quot;Hi, this is esp8266\n&quot;;  //发送的消息,仅支持英文 void setup()&#123;  Serial.begin(115200);//打开串口  Serial.println();   Serial.printf(&quot;正在连接 %s &quot;, ssid);  WiFi.begin(ssid, password);//连接到wifi  while (WiFi.status() != WL_CONNECTED)//等待连接  &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;连接成功&quot;);   if(Udp.begin(localUdpPort))&#123;//启动Udp监听服务    Serial.println(&quot;监听成功&quot;);    //打印本地的ip地址，在UDP工具中会使用到    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串        Serial.printf(&quot;现在收听IP：%s, UDP端口：%d\n&quot;, WiFi.localIP().toString().c_str(), localUdpPort);  &#125;else&#123;    Serial.println(&quot;监听失败&quot;);  &#125;&#125; void loop()&#123;  //解析Udp数据包  int packetSize = Udp.parsePacket();//获得解析包  if (packetSize)//解析包不为空  &#123;    //收到Udp数据包    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串    Serial.printf(&quot;收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\n&quot;, Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);          // 读取Udp数据包并存放在incomingPacket    int len = Udp.read(incomingPacket, 255);//返回数据包字节数    if (len &gt; 0)    &#123;       incomingPacket[len] = 0;//清空缓存    &#125;    //向串口打印信息    Serial.printf(&quot;UDP数据包内容为: %s\n&quot;, incomingPacket);     //向udp工具发送消息    Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口    Udp.write(replyPacket);//把数据写入发送缓冲区    Udp.endPacket();//发送数据  &#125;&#125;

相关内容– endPacket – 发送UDP数据包– write – 向UDP数据包写入信息– print &#x2F; println (Stream类) – 发送UDP数据– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。
endPacket – 发送UDP数据包说明此函数用于发送UDP数据包。
语法wiFiUDP.endPacket()

参数无
返回值返回值数据类型为整数型1：数据发送成功0：数据发送失败
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiUdp_6程序目的/Purpose          : 用于演示ESP8266WiFiUdp库中endPacket函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiUdp.h&gt; #define ssid      &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下WIFI名字#define password  &quot;xxxxxxx&quot;          //这里改成你的设备当前环境下WIFI密码 WiFiUDP Udp;//实例化WiFiUDP对象unsigned int localUdpPort = 1234;  // 自定义本地监听端口unsigned int remoteUdpPort = 4321;  // 自定义远程监听端口char incomingPacket[255];  // 保存Udp工具发过来的消息char  replyPacket[] = &quot;Hi, this is esp8266\n&quot;;  //发送的消息,仅支持英文 void setup()&#123;  Serial.begin(115200);//打开串口  Serial.println();   Serial.printf(&quot;正在连接 %s &quot;, ssid);  WiFi.begin(ssid, password);//连接到wifi  while (WiFi.status() != WL_CONNECTED)//等待连接  &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;连接成功&quot;);   if(Udp.begin(localUdpPort))&#123;//启动Udp监听服务    Serial.println(&quot;监听成功&quot;);    //打印本地的ip地址，在UDP工具中会使用到    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串        Serial.printf(&quot;现在收听IP：%s, UDP端口：%d\n&quot;, WiFi.localIP().toString().c_str(), localUdpPort);  &#125;else&#123;    Serial.println(&quot;监听失败&quot;);  &#125;&#125; void loop()&#123;  //解析Udp数据包  int packetSize = Udp.parsePacket();//获得解析包  if (packetSize)//解析包不为空  &#123;    //收到Udp数据包    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串    Serial.printf(&quot;收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\n&quot;, Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);          // 读取Udp数据包并存放在incomingPacket    int len = Udp.read(incomingPacket, 255);//返回数据包字节数    if (len &gt; 0)    &#123;       incomingPacket[len] = 0;//清空缓存    &#125;    //向串口打印信息    Serial.printf(&quot;UDP数据包内容为: %s\n&quot;, incomingPacket);     //向udp工具发送消息    Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口    Udp.write(replyPacket);//把数据写入发送缓冲区    Udp.endPacket();//发送数据  &#125;&#125;

相关内容发送UDP数据类型– endPacket – 发送UDP数据包– write – 向UDP数据包写入信息– print &#x2F; println (Stream类) – 发送UDP数据– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。
write – 向UDP数据包写入信息说明将即将通过UDP协议发送的数据写入发送缓冲区。此函数必须置于beginPacket和endPacket之间。
请注意：此函数仅仅将数据写入发送缓冲区，但是数据不会发送。实施数据发送的函数是endPacket函数。
语法wiFiUDP.write(udp_data)

参数udp_data：此参数为写入发送缓冲区的数据，可使用字符串类型。
返回值写入发送缓冲区的数据大小（单位：字节）。返回值类型：size_t
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiUdp_6程序目的/Purpose          : 用于演示ESP8266WiFiUdp库中write函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiUdp.h&gt; #define ssid      &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下WIFI名字#define password  &quot;xxxxxxx&quot;          //这里改成你的设备当前环境下WIFI密码 WiFiUDP Udp;//实例化WiFiUDP对象unsigned int localUdpPort = 1234;  // 自定义本地监听端口unsigned int remoteUdpPort = 4321;  // 自定义远程监听端口char incomingPacket[255];  // 保存Udp工具发过来的消息char  replyPacket[] = &quot;Hi, this is esp8266\n&quot;;  //发送的消息,仅支持英文 void setup()&#123;  Serial.begin(115200);//打开串口  Serial.println();   Serial.printf(&quot;正在连接 %s &quot;, ssid);  WiFi.begin(ssid, password);//连接到wifi  while (WiFi.status() != WL_CONNECTED)//等待连接  &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;连接成功&quot;);   if(Udp.begin(localUdpPort))&#123;//启动Udp监听服务    Serial.println(&quot;监听成功&quot;);          //打印本地的ip地址，在UDP工具中会使用到    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串       Serial.printf(&quot;现在收听IP：%s, UDP端口：%d\n&quot;, WiFi.localIP().toString().c_str(), localUdpPort);  &#125;else&#123;    Serial.println(&quot;监听失败&quot;);  &#125;&#125; void loop()&#123;  //解析Udp数据包  int packetSize = Udp.parsePacket();//获得解析包  if (packetSize)//解析包不为空  &#123;    //收到Udp数据包    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串    Serial.printf(&quot;收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\n&quot;, Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);          // 读取Udp数据包并存放在incomingPacket    int len = Udp.read(incomingPacket, 255);//返回数据包字节数    if (len &gt; 0)    &#123;       incomingPacket[len] = 0;//清空缓存    &#125;    //向串口打印信息    Serial.printf(&quot;UDP数据包内容为: %s\n&quot;, incomingPacket);     //向udp工具发送消息    Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口    Udp.write(replyPacket);//把数据写入发送缓冲区    Udp.endPacket();//发送数据  &#125;&#125;

发送UDP数据类型– beginPacket – 配置UDP数据包接收设备的IP和端口– print &#x2F; println (Stream类) – 发送UDP数据– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。
print &#x2F; println (Stream类) – 发送UDP数据说明ESP8266开发板通过UDP协议发送UDP数据时，可以采用 print 或者 println 函数将UDP数据写入发送缓冲区。
print与println的功能十分相近。他们的区别是println会在写入数据的末尾添加换行符。
此函数必须置于beginPacket和endPacket之间。
请注意：此函数仅仅将数据写入发送缓冲区，但是数据不会发送。实施数据发送的函数是endPacket函数。
语法wiFiUDP.print(udp_data)wiFiUDP.println(udp_data)
参数udp_data：此参数为写入发送缓冲区的数据，可使用字符串类型。
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
print函数示例/**********************************************************************程序名称/Program name     : ESP8266WiFiUdp_12程序目的/Purpose          : 用于演示ESP8266WiFiUdp库中print函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiUdp.h&gt; #define ssid      &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下WIFI名字#define password  &quot;xxxxxxx&quot;          //这里改成你的设备当前环境下WIFI密码 WiFiUDP Udp;//实例化WiFiUDP对象unsigned int localUdpPort = 1234;  // 自定义本地监听端口unsigned int remoteUdpPort = 4321;  // 自定义远程监听端口char incomingPacket[255];  // 保存Udp工具发过来的消息char  replyPacket[] = &quot;Hi, this is esp8266\n&quot;;  //发送的消息,仅支持英文 void setup()&#123;  Serial.begin(115200);//打开串口  Serial.println();   Serial.printf(&quot;正在连接 %s &quot;, ssid);  WiFi.begin(ssid, password);//连接到wifi  while (WiFi.status() != WL_CONNECTED)//等待连接  &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;连接成功&quot;);   if(Udp.begin(localUdpPort))&#123;//启动Udp监听服务    Serial.println(&quot;监听成功&quot;);          //打印本地的ip地址，在UDP工具中会使用到    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串       Serial.printf(&quot;现在收听IP：%s, UDP端口：%d\n&quot;, WiFi.localIP().toString().c_str(), localUdpPort);  &#125;else&#123;    Serial.println(&quot;监听失败&quot;);  &#125;&#125; void loop()&#123;  //向udp工具发送消息  Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口  Udp.print(replyPacket);//把数据写入发送缓冲区  Udp.endPacket();//发送数据  Serial.println(&quot;UDP数据发送成功&quot;);  delay(3000);//延时3秒&#125;

println函数示例/**********************************************************************程序名称/Program name     : ESP8266WiFiUdp_13程序目的/Purpose          : 用于演示ESP8266WiFiUdp库中println函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiUdp.h&gt; #define ssid      &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下WIFI名字#define password  &quot;xxxxxxx&quot;          //这里改成你的设备当前环境下WIFI密码 WiFiUDP Udp;//实例化WiFiUDP对象unsigned int localUdpPort = 1234;  // 自定义本地监听端口unsigned int remoteUdpPort = 4321;  // 自定义远程监听端口char incomingPacket[255];  // 保存Udp工具发过来的消息char  replyPacket[] = &quot;Hi, this is esp8266\n&quot;;  //发送的消息,仅支持英文 void setup()&#123;  Serial.begin(115200);//打开串口  Serial.println();   Serial.printf(&quot;正在连接 %s &quot;, ssid);  WiFi.begin(ssid, password);//连接到wifi  while (WiFi.status() != WL_CONNECTED)//等待连接  &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;连接成功&quot;);   if(Udp.begin(localUdpPort))&#123;//启动Udp监听服务    Serial.println(&quot;监听成功&quot;);          //打印本地的ip地址，在UDP工具中会使用到    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串       Serial.printf(&quot;现在收听IP：%s, UDP端口：%d\n&quot;, WiFi.localIP().toString().c_str(), localUdpPort);  &#125;else&#123;    Serial.println(&quot;监听失败&quot;);  &#125;&#125; void loop()&#123;  //向udp工具发送消息  Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口  Udp.println(replyPacket);//把数据写入发送缓冲区  Udp.endPacket();//发送数据  Serial.println(&quot;UDP数据发送成功&quot;);  delay(3000);//延时3秒&#125;

发送UDP数据类型– beginPacket – 配置UDP数据包接收设备的IP和端口– endPacket – 发送UDP数据包– write – 向UDP数据包写入信息– Stream类 – 以上带有(Stream类)标注的函数属于Stream类函数。
获取发送UDP数据设备信息类型remoteIP – 获取发送UDP数据包的设备IP说明此函数用于获取向ESP8266开发板发送UDP数据包设备的IP地址。注：在调用 此函数前需要先调用parsePacket函数让ESP8266开发板对接收到的UDP数据进行初始检查。
语法wiFiUDP.remoteIP()

参数无
返回值此函数的返回值是向ESP8266开发板发送UDP数据包设备的IP地址。数据类型是IPAddress。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiUdp_6程序目的/Purpose          : 用于演示ESP8266WiFiUdp库中remoteIP函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiUdp.h&gt; #define ssid      &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下WIFI名字#define password  &quot;12345678&quot;         //这里改成你的设备当前环境下WIFI密码 WiFiUDP Udp;//实例化WiFiUDP对象unsigned int localUdpPort = 1234;  // 自定义本地监听端口unsigned int remoteUdpPort = 4321;  // 自定义远程监听端口char incomingPacket[255];  // 保存Udp工具发过来的消息char  replyPacket[] = &quot;Hi, this is esp8266\n&quot;;  //发送的消息,仅支持英文 void setup()&#123;  Serial.begin(115200);//打开串口  Serial.println();   Serial.printf(&quot;正在连接 %s &quot;, ssid);  WiFi.begin(ssid, password);//连接到wifi  while (WiFi.status() != WL_CONNECTED)//等待连接  &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;连接成功&quot;);   if(Udp.begin(localUdpPort))&#123;//启动Udp监听服务    Serial.println(&quot;监听成功&quot;);    //打印本地的ip地址，在UDP工具中会使用到    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串        Serial.printf(&quot;现在收听IP：%s, UDP端口：%d\n&quot;, WiFi.localIP().toString().c_str(), localUdpPort);  &#125;else&#123;    Serial.println(&quot;监听失败&quot;);  &#125;&#125; void loop()&#123;  //解析Udp数据包  int packetSize = Udp.parsePacket();//获得解析包  if (packetSize)//解析包不为空  &#123;    //收到Udp数据包    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串    Serial.printf(&quot;收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\n&quot;, Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);          // 读取Udp数据包并存放在incomingPacket    int len = Udp.read(incomingPacket, 255);//返回数据包字节数    if (len &gt; 0)    &#123;       incomingPacket[len] = 0;//清空缓存    &#125;    //向串口打印信息    Serial.printf(&quot;UDP数据包内容为: %s\n&quot;, incomingPacket);     //向udp工具发送消息    Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口    Udp.write(replyPacket);//把数据写入发送缓冲区    Udp.endPacket();//发送数据  &#125;&#125;





remotePort – 获取发送UDP数据包的设备的端口说明此函数用于获取向ESP8266开发板发送UDP数据包设备的端口。注：在调用 此函数前需要先调用parsePacket函数让ESP8266开发板对接收到的UDP数据进行初始检查。
语法wiFiUDP.remotePort()

参数无
返回值此函数的返回值是向ESP8266开发板发送UDP数据包设备的端口。数据类型是uint16_t。
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
/**********************************************************************程序名称/Program name     : ESP8266WiFiUdp_6程序目的/Purpose          : 用于演示ESP8266WiFiUdp库中remotePort函数***********************************************************************/ #include &lt;ESP8266WiFi.h&gt;#include &lt;WiFiUdp.h&gt; #define ssid      &quot;TaichiMaker_WIFI&quot; //这里改成你的设备当前环境下WIFI名字#define password  &quot;12345678&quot;         //这里改成你的设备当前环境下WIFI密码 WiFiUDP Udp;//实例化WiFiUDP对象unsigned int localUdpPort = 1234;  // 自定义本地监听端口unsigned int remoteUdpPort = 4321;  // 自定义远程监听端口char incomingPacket[255];  // 保存Udp工具发过来的消息char  replyPacket[] = &quot;Hi, this is esp8266\n&quot;;  //发送的消息,仅支持英文 void setup()&#123;  Serial.begin(115200);//打开串口  Serial.println();   Serial.printf(&quot;正在连接 %s &quot;, ssid);  WiFi.begin(ssid, password);//连接到wifi  while (WiFi.status() != WL_CONNECTED)//等待连接  &#123;    delay(500);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;连接成功&quot;);   if(Udp.begin(localUdpPort))&#123;//启动Udp监听服务    Serial.println(&quot;监听成功&quot;);    //打印本地的ip地址，在UDP工具中会使用到    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串        Serial.printf(&quot;现在收听IP：%s, UDP端口：%d\n&quot;, WiFi.localIP().toString().c_str(), localUdpPort);  &#125;else&#123;    Serial.println(&quot;监听失败&quot;);  &#125;&#125; void loop()&#123;  //解析Udp数据包  int packetSize = Udp.parsePacket();//获得解析包  if (packetSize)//解析包不为空  &#123;    //收到Udp数据包    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串    Serial.printf(&quot;收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\n&quot;, Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);          // 读取Udp数据包并存放在incomingPacket    int len = Udp.read(incomingPacket, 255);//返回数据包字节数    if (len &gt; 0)    &#123;       incomingPacket[len] = 0;//清空缓存    &#125;    //向串口打印信息    Serial.printf(&quot;UDP数据包内容为: %s\n&quot;, incomingPacket);     //向udp工具发送消息    Udp.beginPacket(Udp.remoteIP(), remoteUdpPort);//配置远端ip地址和端口    Udp.write(replyPacket);//把数据写入发送缓冲区    Udp.endPacket();//发送数据  &#125;&#125;





ESP8266 – DNSServer库DNS（Domain Name Server，域名服务器）是进行域名（如arduino-esp8266.readthedocs.io）和与之相对应的IP地址转换的服务器。如需了解更多有关DNS服务器的信息，可前往百度百科的域名服务器介绍页面获取更多介绍信息。
通过DNSServer库，我们可以使用ESP8266模块建立简易版的域名服务器。以下为DNSServer库的整体结构图。在此图下方有DNSServer库的函数目录。您可以通过点击目录项目打开各个函数的说明页面。

start – 启动DNS服务说明当ESP8266模块以无线终端模式工作时，调用本函数可以启动ESP8266模块的DNS服务。
语法dnsServer.start(port, domainName, domainIp)

参数port: DNS服务端口号。默认情况下设置为53（uint16_t型）
domainName: 映射的域名，也就是开启服务后可以直接访问的用于代替IP地址的域名（可使用字符串型）
domainIp: 映射的IP地址（IPAdress型）
返回值返回值为是否成功开启DNS服务，若开启则返回true。数据类型为布尔型
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
示例程序操作说明当您将以下程序编译并且上传给ESP8266开发板以后，接下来您可以使用手机连接ESP8266开发板所建立的WiFi网络。该WiFi网络名称是DNSServer example（连接此网络无需密码）。
请打开手机的浏览器，并且在浏览器地址栏中输入“www.example.com”。
输入地址后，再按下确认键。浏览器将会打开下图所示的页面。该页面正是由ESP8266开发板所建立的。
接下来，我将对此示例程序的基本工作流程给您做一个简单的介绍。请留意，在以下示例程序的控制下，ESP8266服务器将会扮演两个角色。第一个角色是DNS服务器，也就是本页面所要讲解的重点。第二个是网络服务器，也就是响应客户端的HTTP访问请求。
在以下示例程序中，我们使用了dnsServer.start(DNS_PORT, &quot;www.example.com&quot;, apIP)启动了DNS服务。当我们通过浏览器输入了www.example.com这一网址信息并按下确认键后，浏览器将会向ESP8266所建立的DNS服务器发送DNS服务请求。
ESP8266服务器在收到此请求后，将会通过服务器内的检索信息获取到www.example.com这一网址所对应的IP地址正是ESP8266服务器的IP地址。于是ESP8266DNS服务器将会把这一检索结果响应给浏览器。
浏览器得到了DNS服务器响应，也就是www.example.com网址所对应的IP正是ESP8266服务器的IP，于是浏览器将会再次向ESP8266的IP地址发送HTTP请求。
当ESP8266接收到浏览器客户端的HTTP访问请求后，ESP8266的网页服务器功能将会生成HTTP响应信息，并且返回给手机浏览器客户端。浏览器于是便显示出以下图片所显示的信息内容。

/**********************************************************************程序名称/Program name     : dnsServer.processNextRequest()演示程序目的/Purpose          :  此程序使用DNSServer库来演示持续处理DNS请求服务***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;DNSServer.h&gt;#include &lt;ESP8266WebServer.h&gt; const byte DNS_PORT = 53;//默认设置端口为53 IPAddress apIP(192, 168, 1, 1);DNSServer dnsServer;ESP8266WebServer webServer(80); void setup() &#123;  WiFi.mode(WIFI_AP);  WiFi.softAPConfig(apIP, apIP, IPAddress(255, 255, 255, 0));  WiFi.softAP(&quot;DNSServer example&quot;);   // 启动特定域名的DNS服务器  dnsServer.start(DNS_PORT, &quot;www.example.com&quot;, apIP);   // 利用简单的HTTP服务器以查看DNS服务器是否正常运行  webServer.onNotFound([]() &#123;    String message = &quot;Hello World!\n\n&quot;;    message += &quot;URI: &quot;;    message += webServer.uri();     webServer.send(200, &quot;text/plain&quot;, message);  &#125;);  webServer.begin();&#125; void loop() &#123;  dnsServer.processNextRequest();//处理DNS请求服务  webServer.handleClient();&#125;

相关内容– stop – 停止DNS服务– processNextRequest – 处理DNS请求– setErrorReplyCode – 设置错误响应码– setTTL – 设置TTL
stop – 停止DNS服务说明当ESP8266模块以无线终端模式工作时，调用本函数可以关闭ESP8266模块的DNS服务。
语法dnsServer.stop()

参数无
返回值返回是否成功关闭DNS服务。关闭成功返回true。返回值数据类型为布尔型
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
相关内容关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
注意: 以下示例程序使用了softAPConfig函数对ESP8266模块进行网络配置。由于不同的WiFi路由设备的网络配置是不同的，请根据您的WiFi网络配置参数对以下示例程序中的local_IP、gateway、subnet配置进行相应修改。详情请查阅ESP8266WiFiAP库的softAPConfig页面
/**********************************************************************  程序名称/Program name     : dnsServer.stop();演示  程序目的/Purpose          :   此程序使用ESP8266DNSServer库来演示在接入点模式下关闭建立的DNS服务***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;DNSServer.h&gt;#include &lt;ESP8266WebServer.h&gt; IPAddress local_IP(192, 168, 4, 1); //设置IP地址IPAddress gateway(192, 168, 4, 1); //设置网关地址IPAddress subnet(255, 255, 255, 0); //设置子网掩码 const byte DNS_PORT = 53; //DNS服务端口号，一般为53 DNSServer dnsServer;ESP8266WebServer webServer(80); void handleRoot() &#123;  webServer.send(200, &quot;text/plain&quot;, &quot;这是主页&quot;);&#125; void handleNext() &#123;  webServer.send(200, &quot;text/plain&quot;, &quot;这是另一个页面&quot;);&#125; void setup() &#123;  //初始化串口  Serial.begin(9600);  Serial.println();  //初始化网络  WiFi.mode(WIFI_AP);  WiFi.softAPConfig(local_IP, gateway, subnet);  WiFi.softAP(&quot;DNSServer example&quot;);   //初始化DNSServer  dnsServer.start(DNS_PORT, &quot;dnsexample&quot;, local_IP);   //初始化WebServer  webServer.on(&quot;/&quot;, handleRoot);  webServer.on(&quot;/next&quot;, handleNext);  webServer.begin();  Serial.println(&quot;初始化测试完毕，20秒后关闭DNS服务&quot;);  delay(5000);  delay(5000);  delay(5000);  Serial.println(&quot;即将关闭DNS服务&quot;);  dnsServer.stop();  Serial.println(&quot;DNS服务已关闭！&quot;);&#125; void loop()&#123;&#125;



相关内容– start – 启动DNS服务– processNextRequest – 处理DNS请求– setErrorReplyCode – 设置错误响应码– setTTL – 设置TTL
processNextRequest – 处理DNS请求说明processNextRequest函数用于处理DNS请求。当ESP8266模块收到UDP请求后，它将判断该请求是否查找域名映射的IP地址。如果是，则返回IP地址。若有错误则会返回setErrorReplyCode设定好的错误码。
语法dnsServer.processNextRequest()
参数无
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
示例程序操作说明当您将以下程序编译并且上传给ESP8266开发板以后，接下来您可以使用手机连接ESP8266开发板所建立的WiFi网络。该WiFi网络名称是DNSServer example（连接此网络无需密码）。
请打开手机的浏览器，并且在浏览器地址栏中输入“www.example.com”。
输入地址后，再按下确认键。浏览器将会打开下图所示的页面。该页面正是由ESP8266开发板所建立的。
接下来，我将对此示例程序的基本工作流程给您做一个简单的介绍。请留意，在以下示例程序的控制下，ESP8266服务器将会扮演两个角色。第一个角色是DNS服务器，也就是本页面所要讲解的重点。第二个是网络服务器，也就是响应客户端的HTTP访问请求。
在以下示例程序中，我们使用了dnsServer.start(DNS_PORT, &quot;www.example.com&quot;, apIP)启动了DNS服务。当我们通过浏览器输入了www.example.com这一网址信息并按下确认键后，浏览器将会向ESP8266所建立的DNS服务器发送DNS服务请求。
ESP8266服务器在收到此请求后，将会通过服务器内的检索信息获取到www.example.com这一网址所对应的IP地址正是ESP8266服务器的IP地址。于是ESP8266DNS服务器将会把这一检索结果响应给浏览器。
浏览器得到了DNS服务器响应，也就是www.example.com网址所对应的IP正是ESP8266服务器的IP，于是浏览器将会再次向ESP8266的IP地址发送HTTP请求。
当ESP8266接收到浏览器客户端的HTTP访问请求后，ESP8266的网页服务器功能将会生成HTTP响应信息，并且返回给手机浏览器客户端。浏览器于是便显示出以下图片所显示的信息内容。

/**********************************************************************程序名称/Program name     : dnsServer.processNextRequest()演示程序目的/Purpose          :  此程序使用DNSServer库来演示持续处理DNS请求服务***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;DNSServer.h&gt;#include &lt;ESP8266WebServer.h&gt; const byte DNS_PORT = 53;//默认设置端口为53 IPAddress apIP(192, 168, 1, 1);DNSServer dnsServer;ESP8266WebServer webServer(80); void setup() &#123;  WiFi.mode(WIFI_AP);  WiFi.softAPConfig(apIP, apIP, IPAddress(255, 255, 255, 0));  WiFi.softAP(&quot;DNSServer example&quot;);   // 启动特定域名的DNS服务器  dnsServer.start(DNS_PORT, &quot;www.example.com&quot;, apIP);   // 利用简单的HTTP服务器以查看DNS服务器是否正常运行  webServer.onNotFound([]() &#123;    String message = &quot;Hello World!\n\n&quot;;    message += &quot;URI: &quot;;    message += webServer.uri();     webServer.send(200, &quot;text/plain&quot;, message);  &#125;);  webServer.begin();&#125; void loop() &#123;  dnsServer.processNextRequest();//处理DNS请求服务  webServer.handleClient();&#125;

相关内容– stop – 停止DNS服务– processNextRequest – 处理DNS请求– setErrorReplyCode – 设置错误响应码– setTTL – 设置TTL
setErrorReplyCode – 设置错误响应码说明当客户端发送的查询域名不在ESP8266模块建立的DNS服务器检索中，则返回setErrorReplyCode函数设置的错误代码。
语法dnsServer.setErrorReplyCode(replyCode)

参数replyCode：此参数为DNS响应错误码。类型为DNSReplyCode。
ESP8266 – DNSServer库默认的DNS响应错误码如下

NoError &#x3D; 0,&#x2F;&#x2F;DNS查询成功完成
FormError &#x3D; 1,&#x2F;&#x2F;DNS查询格式错误
ServerFailure &#x3D; 2, &#x2F;&#x2F;服务器无法完成DNS请求
NonExistentDomain &#x3D; 3,&#x2F;&#x2F;域名不存在
NotImplemented &#x3D; 4,&#x2F;&#x2F;未定义
Refused &#x3D; 5,&#x2F;&#x2F;服务器拒绝回答查询
YXDomain &#x3D; 6,&#x2F;&#x2F;名称不应该存在，但该名称确实存在
YXRRSet &#x3D; 7,&#x2F;&#x2F;资源记录集不存在
NXRRSet &#x3D; 8&#x2F;&#x2F;服务器对该区域无权

返回值无
示例程序示例程序操作说明当您将以下程序编译并且上传给ESP8266开发板以后，接下来您可以使用手机连接ESP8266开发板所建立的WiFi网络。该WiFi网络名称是DNSServer example（连接此网络无需密码）。
请打开手机的浏览器，并且在浏览器地址栏中输入“www.example.com”。
输入地址后，再按下确认键。浏览器将会打开下图所示的页面。该页面正是由ESP8266开发板所建立的。
接下来，我将对此示例程序的基本工作流程给您做一个简单的介绍。请留意，在以下示例程序的控制下，ESP8266服务器将会扮演两个角色。第一个角色是DNS服务器，也就是本页面所要讲解的重点。第二个是网络服务器，也就是响应客户端的HTTP访问请求。
在以下示例程序中，我们使用了dnsServer.start(DNS_PORT, &quot;www.example.com&quot;, apIP)启动了DNS服务。当我们通过浏览器输入了www.example.com这一网址信息并按下确认键后，浏览器将会向ESP8266所建立的DNS服务器发送DNS服务请求。
ESP8266服务器在收到此请求后，将会通过服务器内的检索信息获取到www.example.com这一网址所对应的IP地址正是ESP8266服务器的IP地址。于是ESP8266DNS服务器将会把这一检索结果响应给浏览器。
浏览器得到了DNS服务器响应，也就是www.example.com网址所对应的IP正是ESP8266服务器的IP，于是浏览器将会再次向ESP8266的IP地址发送HTTP请求。
当ESP8266接收到浏览器客户端的HTTP访问请求后，ESP8266的网页服务器功能将会生成HTTP响应信息，并且返回给手机浏览器客户端。浏览器于是便显示出以下图片所显示的信息内容。

在以下示例程序中：当客户端发送的查询域名不在DNS服务器检索中，则返回以下语句所设置的错误代码。dnsServer.setErrorReplyCode(DNSReplyCode::ServerFailure);。
/**********************************************************************程序名称/Program name     : dnsServer.setErrorReplyCode();演示程序目的/Purpose          :  此程序使用DNSServer库来演示设置错误响应码***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;DNSServer.h&gt;#include &lt;ESP8266WebServer.h&gt; const byte DNS_PORT = 53;//默认设置端口为53IPAddress apIP(192, 168, 1, 1);DNSServer dnsServer;ESP8266WebServer webServer(80); void setup() &#123;  WiFi.mode(WIFI_AP);  WiFi.softAPConfig(apIP, apIP, IPAddress(255, 255, 255, 0));  WiFi.softAP(&quot;DNSServer example&quot;);   // 设置TTL值（单位：秒）  dnsServer.setTTL(300);    //当客户端发送的查询域名不在DNS服务器检索中，则返回以下语句所设置的错误代码。  dnsServer.setErrorReplyCode(DNSReplyCode::ServerFailure);   // 启动特定域名的DNS服务器  dnsServer.start(DNS_PORT, &quot;www.example.com&quot;, apIP);   // 利用简单的HTTP服务器以查看DNS服务器是否正常运行  webServer.onNotFound([]() &#123;    String message = &quot;Hello World!\n\n&quot;;    message += &quot;URI: &quot;;    message += webServer.uri();     webServer.send(200, &quot;text/plain&quot;, message);  &#125;);  webServer.begin();&#125; void loop() &#123;  dnsServer.processNextRequest();//持续监听  webServer.handleClient();&#125;

相关内容– start – 启动DNS服务– stop – 停止DNS服务– processNextRequest – 处理DNS请求– setTTL – 设置TTL
setTTL – 设置TTL说明此函数用于设置ESP8266模块DNS服务的TTL值。
通过增大TTL值，可以减少DNS递归查询过程，达到提升域名解析速度的效果。反之，通过缩小 TTL 值，以减少更换空间IP地址时造成的不可访问时间，减小空间IP地址造成的访问空窗期。根据不同应用场景和网络需求可以选择合适的TTL值达成更好的访问体验
语法setTTL(TTLval)
参数TTLval: 设置TTL数值(单位：秒)
返回值无
示例程序关于本函数的具体使用方法，请参考以下代码，尤其是代码中高亮的语句部分。
示例程序操作说明当您将以下程序编译并且上传给ESP8266开发板以后，接下来您可以使用手机连接ESP8266开发板所建立的WiFi网络。该WiFi网络名称是DNSServer example（连接此网络无需密码）。
请打开手机的浏览器，并且在浏览器地址栏中输入“www.example.com”。
输入地址后，再按下确认键。浏览器将会打开下图所示的页面。该页面正是由ESP8266开发板所建立的。
接下来，我将对此示例程序的基本工作流程给您做一个简单的介绍。请留意，在以下示例程序的控制下，ESP8266服务器将会扮演两个角色。第一个角色是DNS服务器，也就是本页面所要讲解的重点。第二个是网络服务器，也就是响应客户端的HTTP访问请求。
在以下示例程序中，我们使用了dnsServer.start(DNS_PORT, &quot;www.example.com&quot;, apIP)启动了DNS服务。当我们通过浏览器输入了www.example.com这一网址信息并按下确认键后，浏览器将会向ESP8266所建立的DNS服务器发送DNS服务请求。
ESP8266服务器在收到此请求后，将会通过服务器内的检索信息获取到www.example.com这一网址所对应的IP地址正是ESP8266服务器的IP地址。于是ESP8266DNS服务器将会把这一检索结果响应给浏览器。
浏览器得到了DNS服务器响应，也就是www.example.com网址所对应的IP正是ESP8266服务器的IP，于是浏览器将会再次向ESP8266的IP地址发送HTTP请求。
当ESP8266接收到浏览器客户端的HTTP访问请求后，ESP8266的网页服务器功能将会生成HTTP响应信息，并且返回给手机浏览器客户端。浏览器于是便显示出以下图片所显示的信息内容。

/**********************************************************************程序名称/Program name     : dnsServer.setErrorReplyCode();演示程序目的/Purpose          :  此程序使用DNSServer库来演示设置错误响应码***********************************************************************/#include &lt;ESP8266WiFi.h&gt;#include &lt;DNSServer.h&gt;#include &lt;ESP8266WebServer.h&gt; const byte DNS_PORT = 53;//默认设置端口为53IPAddress apIP(192, 168, 1, 1);DNSServer dnsServer;ESP8266WebServer webServer(80); void setup() &#123;  WiFi.mode(WIFI_AP);  WiFi.softAPConfig(apIP, apIP, IPAddress(255, 255, 255, 0));  WiFi.softAP(&quot;DNSServer example&quot;);   // 设置DNS服务的TTL数值为300  dnsServer.setTTL(300);   // 启动特定域名的DNS服务器  dnsServer.start(DNS_PORT, &quot;www.example.com&quot;, apIP);   // 利用简单的HTTP服务器以查看DNS服务器是否正常运行  webServer.onNotFound([]() &#123;    String message = &quot;Hello World!\n\n&quot;;    message += &quot;URI: &quot;;    message += webServer.uri();     webServer.send(200, &quot;text/plain&quot;, message);  &#125;);  webServer.begin();&#125; void loop() &#123;  dnsServer.processNextRequest();//持续监听  webServer.handleClient();&#125;

相关内容– start – 启动DNS服务– stop – 停止DNS服务– processNextRequest – 处理DNS请求– setErrorReplyCode – 设置错误响应码
ESP8266多任务处理 – Ticker库使用说明ESP8266在运行过程中，只能一条线式的依次执行任务。但是我们在开发物联网项目时，可能需要ESP8266在执行某一任务的过程中，还能处理其它任务。比如，我们使用ESP8266来控制电机运行的同时，还需要定时检查某一个引脚上连接按钮有没有被用户按下。
为了解决以上问题，我们可以使用Ticker库来解决这一问题。下面我们来通过一系列示例程序向您讲解Ticker库的使用方法。
示例1. Ticker库基本操作利用Ticker库，我们可以让ESP8266定时调用某一个函数。通过以下示例程序我们可以看到，ESP8266将会每隔一秒钟通过串口监视器输出一次信息。我们是通过语句ticker.attach(1, sayHi)来实现这一操作的。
该语句中的attach函数有两个参数。第一个参数可控制调用函数的时间间隔，单位是秒。这里的数字1说明ESP8266将会每隔一秒钟调用一次函数。那么具体调用哪一个函数呢？这个函数名称正是是通过第二个参数来限定的。也就是名称为sayHi的函数。该函数将会让ESP8266定时通过串口监视器输出一次信息。信息内容是“Hi”后面跟一个数值。这个数值是为了标注sayHi函数被调用了多少次。
/**********************************************************************程序名称/Program name     : a_basic_tinker程序目的/Purpose          : 本程序旨在演示如何使用Ticker库来定时执行操作。 ***********************************************************************/#include &lt;Ticker.h&gt; Ticker ticker;// 建立Ticker用于实现定时功能int count;    // 计数用变量 void setup() &#123;  Serial.begin(9600);  pinMode(LED_BUILTIN, OUTPUT);   // 每隔一秒钟调用sayHi函数一次，attach函数的第一个参数  // 是控制定时间隔的变量。该参数的单位为秒。第二个参数是  // 定时执行的函数名称。  ticker.attach(1, sayHi);&#125; void loop() &#123;  // 用LED呼吸灯效果来演示在Tinker对象控制下，ESP8266可以定时  // 执行其它任务  for (int fadeValue = 0 ; fadeValue &lt;= 1023; fadeValue += 5) &#123;    analogWrite(LED_BUILTIN, fadeValue);    delay(10);  &#125;   for (int fadeValue = 1023 ; fadeValue &gt;= 0; fadeValue -= 5) &#123;    analogWrite(LED_BUILTIN, fadeValue);    delay(10);  &#125;  delay(3000);&#125; // 在Tinker对象控制下，此函数将会定时执行。void sayHi()&#123;  count++;  Serial.print(&quot;Hi &quot;);  Serial.println(count);&#125;

示例2. 停止定时执行函数当Ticker定时调用某一函数执行到一定次数后，我们可以使用detach函数来停止定时调用函数。以下示例程序中的语句ticker.detach()将会让ticker对象停止调用函数。
/**********************************************************************程序名称/Program name     : b_detach程序目的/Purpose          : 本程序旨在演示如何停止Ticker库定时调用函数。***********************************************************************/#include &lt;Ticker.h&gt; Ticker ticker;// 建立Ticker用于实现定时功能int count;    // 计数用变量 void setup() &#123;  Serial.begin(9600);  pinMode(LED_BUILTIN, OUTPUT);    // 每隔一秒钟调用sayHi函数一次  ticker.attach(1, sayHi);&#125; void loop() &#123;  // 用LED呼吸灯效果来演示在Tinker对象控制下，ESP8266可以定时  // 执行其它任务    for (int fadeValue = 0 ; fadeValue &lt;= 1023; fadeValue += 5) &#123;    analogWrite(LED_BUILTIN, fadeValue);    delay(10);  &#125;   for (int fadeValue = 1023 ; fadeValue &gt;= 0; fadeValue -= 5) &#123;    analogWrite(LED_BUILTIN, fadeValue);    delay(10);  &#125;  delay(3000);&#125; // 在Tinker对象控制下，此函数将会定时执行。void sayHi()&#123;  count++;  Serial.print(&quot;Hi &quot;);  Serial.println(count);   // 当定时调用了6次后，停止定时调用函数  if (count &gt;= 6) &#123;    ticker.detach();  // 使用detach来停止ticker对象定时调用函数    Serial.print(&quot;ticker.detach()&quot;);  &#125;&#125;

示例3. 向定时调用函数传递参数我们可以向Ticker库定时调用的函数来传递参数。不过要注意的是，传递参数的数量只能时一个。如下示例程序所示，语句ticker.attach(1, sayHi, 8)有3个参数。其中第三个参数就是向定时调用的sayHi函数所传递的参数。
请注意：attach函数所能传递的参数最多只有一个。另外该参数仅能是以下类型中的一种：char, short, int, float, void*, char*。
/**********************************************************************程序名称/Program name     : c_parameter程序目的/Purpose          : 本程序旨在演示如何向Ticker库定时调用函数来传递参数。请注意：attach函数所能传递的参数最多只有一个。另外该参数仅能是这些类型中的一种：char, short, int, float, void*, char************************************************************************/#include &lt;Ticker.h&gt; Ticker ticker; int count; void setup() &#123;  Serial.begin(9600);  pinMode(LED_BUILTIN, OUTPUT);    ticker.attach(1, sayHi, 8);&#125; void loop() &#123;  for (int fadeValue = 0 ; fadeValue &lt;= 1023; fadeValue += 5) &#123;    analogWrite(LED_BUILTIN, fadeValue);    delay(10);  &#125;   for (int fadeValue = 1023 ; fadeValue &gt;= 0; fadeValue -= 5) &#123;    analogWrite(LED_BUILTIN, fadeValue);    delay(10);  &#125;  delay(3000);&#125; void sayHi(int hiTimes)&#123;  count++;  Serial.print(&quot;Hi &quot;);  Serial.println(count);   if (count &gt;= hiTimes) &#123;    ticker.detach();    Serial.print(&quot;ticker.detach();&quot;);  &#125;&#125;



示例4. 利用多个Ticker对象让ESP8266处理多任务我们可以建立多个Ticker对象。让多个Ticker对象来实现ESP8266的多任务处理。如下实例程序所示，我们通过语句Ticker buttonTicker;来建立第二个Ticker对象。
接下来我们使用buttonTicker.attach_ms(100, buttonCheck)来实现第二个Ticker对象的任务处理。这里我们使用了attach_ms函数，该函数与attach函数功能相似，唯一区别是。attach函数的时间单位是秒，而attach_ms的时间单位是毫秒。也就是说，这条语句将会让ESP8266每隔100毫秒执行一次buttonCheck函数。
/**********************************************************************程序名称/Program name     : d_multi_ms程序目的/Purpose          : 本程序旨在演示如何使用多个Ticker对象来让ESP8266处理多个任务。 ***********************************************************************/#include &lt;Ticker.h&gt; Ticker ticker;Ticker buttonTicker; int count; void setup() &#123;  Serial.begin(9600);  pinMode(LED_BUILTIN, OUTPUT);  pinMode(D3, INPUT_PULLUP);    ticker.attach(1, sayHi, 60);  buttonTicker.attach_ms(100, buttonCheck);&#125; void loop() &#123;  for (int fadeValue = 0 ; fadeValue &lt;= 1023; fadeValue += 5) &#123;    analogWrite(LED_BUILTIN, fadeValue);    delay(10);  &#125;   for (int fadeValue = 1023 ; fadeValue &gt;= 0; fadeValue -= 5) &#123;    analogWrite(LED_BUILTIN, fadeValue);    delay(10);  &#125;  delay(3000);&#125; void sayHi(int hiTimes)&#123;  count++;  Serial.print(&quot;Hi &quot;);  Serial.println(count);   if (count &gt;= hiTimes) &#123;    ticker.detach();    Serial.print(&quot;ticker.detach();&quot;);  &#125;&#125; void buttonCheck()&#123;  if (digitalRead(D3) == LOW)&#123;    Serial.println(&quot;D3 Button Pushed...&quot;);  &#125;&#125;



示例5. 使用”计数器”来控制ESP8266定时执行较复杂的函数Ticker定时调用的函数必须要“短小精悍”。比如以上一系列的示例程序中，我们仅仅让Ticker定时调用函数执行简单的串口数据输出，以及很基本的运算。事实上，在使用Ticker库时，定时调用函数必须要很快的执行完毕。否则会产生难以预料的问题。
这就产生了一个问题。假如我们需要ESP8266定时执行的操作较为复杂，这该如何是好呢？
假设我们让ESP8266定时向example.com网站服务器发送一个http请求，并且将服务器响应通过串口监视器显示出来。（如您对这一操作尚不了解，请参考《零基础入门学用物联网教程》第3-4-1节中的示例1。）
这个问题的答案就在以下示例程序中。在这段示例程序里，我们建立了一个计数变量count。在程序的第55到第59行中，Ticker定时调用的函数tickerCount仅仅对count变量进行自加。
当计数变量count达到我们需要的数值后，则让ESP8266执行较为复杂的函数。这一点是通过程序的第49到52行逻辑判断语句所实现的。
请注意，在每一次执行完操作后，我们都需要对count变量进行清零。否则程序将无法定时通过互联网向服务器发送请求。
/**********************************************************************项目名称/Project          : 零基础入门学用物联网程序名称/Program name     : e_timer_http团队/Team                : 太极创客团队 / Taichi-Maker (www.taichi-maker.com)作者/Author              : CYNO朔日期/Date（YYYYMMDD）     : 20200703程序目的/Purpose          : 本程序旨在演示如何使用计数器来控制ESP8266定时执行较复杂的函数。Ticker定时调用的函数必须要“短小精悍”。而不能是复杂且占用时间较长的函数。对于较为复杂的函数，我们可以使用计数器的方法来实现。 本程序将会定时让ESP8266向example网络服务器发送请求，并且将服务器响应信息显示在屏幕中。 如需了解本程序的详细说明，请参考以下函数：http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/esp8266-tips/tinker/-----------------------------------------------------------------------其它说明 / Other Description：本程序为太极创客团队制作的免费视频教程《零基础入门学用物联网 》中一部分。该教程系统的向您讲述ESP8266的物联网应用相关的软件和硬件知识。以下是该教程目录页：http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/                    ***********************************************************************/#include &lt;Ticker.h&gt;#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt; #define URL &quot;http://www.example.com&quot; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichimaker&quot;;const char* password = &quot;12345678&quot;; Ticker ticker; int count; void setup() &#123;  Serial.begin(9600);   //设置ESP8266工作模式为无线终端模式  WiFi.mode(WIFI_STA);    //连接WiFi  connectWifi();   ticker.attach(1, tickerCount);&#125; void loop() &#123;    if (count &gt;= 5)&#123;       httpRequest();    count = 0;  &#125;&#125; void tickerCount()&#123;  count++;  Serial.print(&quot;count = &quot;);  Serial.println(count);&#125; // 发送HTTP请求并且将服务器响应通过串口输出void httpRequest()&#123;  HTTPClient httpClient;   httpClient.begin(URL);   Serial.print(&quot;URL: &quot;); Serial.println(URL);   int httpCode = httpClient.GET();  Serial.print(&quot;Send GET request to URL: &quot;);  Serial.println(URL);    if (httpCode == HTTP_CODE_OK) &#123;    // 使用getString函数获取服务器响应体内容    String responsePayload = httpClient.getString();    Serial.println(&quot;Server Response Payload: &quot;);    Serial.println(responsePayload);  &#125; else &#123;    Serial.println(&quot;Server Respose Code：&quot;);    Serial.println(httpCode);  &#125;  httpClient.end();&#125; void connectWifi()&#123;//开始连接wifi  WiFi.begin(ssid, password);   //等待WiFi连接,连接成功打印IP  while (WiFi.status() != WL_CONNECTED) &#123;    delay(1000);    Serial.print(&quot;.&quot;);  &#125;  Serial.println(&quot;&quot;);  Serial.print(&quot;WiFi Connected!&quot;);   &#125;




]]></content>
      <categories>
        <category>ESP8266</category>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>protected</tag>
        <tag>ESP8266</tag>
      </tags>
  </entry>
</search>
