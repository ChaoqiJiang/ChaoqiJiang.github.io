<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++ STL学习笔记 | 柊</title><meta name="author" content="棨"><meta name="copyright" content="棨"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#59b9c6"><meta name="description" content="C++ STL学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ STL学习笔记">
<meta property="og:url" content="https://chaoqijiang.github.io/2023/01/08/C++STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="柊">
<meta property="og:description" content="C++ STL学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chaoqijiang.github.io/Image/avatar.png">
<meta property="article:published_time" content="2023-01-08T12:27:31.000Z">
<meta property="article:modified_time" content="2025-10-19T14:39:24.225Z">
<meta property="article:author" content="棨">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="STL">
<meta property="article:tag" content="protected">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chaoqijiang.github.io/Image/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++ STL学习笔记",
  "url": "https://chaoqijiang.github.io/2023/01/08/C++STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
  "image": "https://chaoqijiang.github.io/Image/avatar.png",
  "datePublished": "2023-01-08T12:27:31.000Z",
  "dateModified": "2025-10-19T14:39:24.225Z",
  "author": [
    {
      "@type": "Person",
      "name": "棨",
      "url": "https://chaoqijiang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chaoqijiang.github.io/2023/01/08/C++STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#59b9c6')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 24 || hour >= 24
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":30,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#165e83","bgDark":"#507ea4","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ STL学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/Image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴/归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/Image/topImage.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/Image/Logo.ico" alt="Logo"><span class="site-name">柊</span></a><a class="nav-page-title" href="/"><span class="site-name">C++ STL学习笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴/归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++ STL学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-08T12:27:31.000Z" title="发表于 2023-01-08 20:27:31">2023-01-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-19T14:39:24.225Z" title="更新于 2025-10-19 22:39:24">2025-10-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">20.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>82分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="STL概论"><a href="#STL概论" class="headerlink" title="STL概论"></a>STL概论</h1><p>​		为了建立数据结构和算法的一套标准，并且降低他们之间的耦合关系，以提升各自的独立性、弹性、交互操作性(相互合作性,interoperability),诞生了STL。</p>
<h2 id="STL基本概念"><a href="#STL基本概念" class="headerlink" title="STL基本概念"></a>STL基本概念</h2><p>​	STL(Standard Template Library,标准模板库)，是惠普实验室开发的一系列软件的统称。现在主要出现在 c++中，但是在引入 c++之前该技术已经存在很长时间了。</p>
<p>​	STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator),容器和算法之间通过迭代器进行无缝连接。</p>
<h2 id="STL六大组件简介"><a href="#STL六大组件简介" class="headerlink" title="STL六大组件简介"></a>STL六大组件简介</h2><p>​	STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。</p>
<ul>
<li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.</li>
<li>迭代器：扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-&gt; , operator++,operator–等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。</li>
<li>仿函数：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>空间配置器：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.</li>
</ul>
<p>​	STL六大组件的交互关系：容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。</p>
<h2 id="STL优点"><a href="#STL优点" class="headerlink" title="STL优点"></a>STL优点</h2><p>​	STL 是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。<br>​	STL 的一个重要特性是将<strong>数据和操作</strong>分离。<strong>数据由容器类别加以管理</strong>，操<strong>作则由可定制的算法定义</strong>。<strong>迭代器在两者之间充当“粘合剂</strong>”,以使算法可以和容器交互运作</p>
<p>​	STL 具有高可重用性，高性能，高移植性，跨平台的优点。</p>
<ul>
<li>高可重用性：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</li>
<li>高性能：如 map 可以高效地从十万条记录里面查找出指定的记录，因为 map 是采用红黑树的变体实现的。</li>
<li>高移植性：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。</li>
</ul>
<h1 id="STL三大组件"><a href="#STL三大组件" class="headerlink" title="STL三大组件"></a>STL三大组件</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>​	容器，置物之所也。</p>
<p>​	研究数据的特定排列方式，以利于搜索或排序或其他特殊目的，这一门学科我们称为数据结构。STL容器就是将运用最广泛的一些数据结构实现出来。<br>常用的数据结构：数组(array),链表(list),tree(树)，栈(stack),队列(queue),集合(set),映射表(map),根据数据在容器中的排列特性，这些数据分为序列式容器和关联式容器两种。</p>
<ul>
<li>序列式容器强调值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。</li>
<li>关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。**关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。**Set&#x2F;multiset容器 Map&#x2F;multimap容器</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>​	算法，问题之解法也。</p>
<p>​	以有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms).</p>
<p>​	算法分为:质变算法和非质变算法。</p>
<ul>
<li>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</li>
<li>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>​	迭代器(iterator)是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。</p>
<p>​	在《Design Patterns》一书中提供了23中设计模式的完整描述，其中iterator模式定义如下：<strong>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式</strong>。</p>
<p>​	迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器(container)和算法(algorithms)分开，彼此独立设计，最后再一贴胶着剂将他们撮合在一起。从技术角度来看，容器和算法的泛型化并不困难，c++的class template和function template可分别达到目标，如果设计出两这个之间的良好的胶着剂，才是大难题。</p>
<p>迭代器的种类:</p>
<ul>
<li>输入迭代器 提供对数据的只读访问 只读，支持++、&#x3D;&#x3D;、！&#x3D;</li>
<li>输出迭代器 提供对数据的只写访问 只写，支持++</li>
<li>前向迭代器 提供读写操作，并能向前推进迭代器 读写，支持++、&#x3D;&#x3D;、！&#x3D;</li>
<li>双向迭代器 提供读写操作，并能向前和向后操作 读写，支持++、–，</li>
<li>随机访问迭代器 提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器 读写，支持++、–、[n]、-n、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//STL 中的容器 算法 迭代器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v; <span class="comment">//STL 中的标准容器之一 ：动态数组</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">//vector 容器提供的插入数据的方法</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">	<span class="comment">//迭代器</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator pStart = v.<span class="built_in">begin</span>(); <span class="comment">//vector 容器提供了 begin()方法 返回指向第一个元素的迭代器</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>(); <span class="comment">//vector 容器提供了 end()方法 返回指向最后一个元素下一个位置的迭代器</span></span><br><span class="line">	<span class="comment">//通过迭代器遍历</span></span><br><span class="line">	<span class="keyword">while</span> (pStart != pEnd) &#123;</span><br><span class="line">		cout &lt;&lt; *pStart &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		pStart++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//算法 count 算法 用于统计元素的个数</span></span><br><span class="line">	<span class="type">int</span> n = <span class="built_in">count</span>(pStart, pEnd, <span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;n:&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//STL 容器不单单可以存储基础数据类型，也可以存储类对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Teacher</span>(<span class="type">int</span> age) :<span class="built_in">age</span>(age) &#123;&#125;;</span><br><span class="line">	~<span class="built_in">Teacher</span>() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;Teacher&gt; v; <span class="comment">//存储 Teacher 类型数据的容器</span></span><br><span class="line">	<span class="function">Teacher <span class="title">t1</span><span class="params">(<span class="number">10</span>)</span>, <span class="title">t2</span><span class="params">(<span class="number">20</span>)</span>, <span class="title">t3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">	v.<span class="built_in">push_back</span>(t1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(t2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(t3);</span><br><span class="line">	vector&lt;Teacher&gt;::iterator pStart = v.<span class="built_in">begin</span>();</span><br><span class="line">	vector&lt;Teacher&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line">	<span class="comment">//通过迭代器遍历</span></span><br><span class="line">	<span class="keyword">while</span> (pStart != pEnd) &#123;</span><br><span class="line">		cout &lt;&lt; pStart-&gt;age &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		pStart++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存储 Teacher 类型指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;Teacher*&gt; v; <span class="comment">//存储 Teacher 类型指针</span></span><br><span class="line">	Teacher* t1 = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="number">10</span>);</span><br><span class="line">	Teacher* t2 = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="number">20</span>);</span><br><span class="line">	Teacher* t3 = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(t1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(t2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(t3);</span><br><span class="line">	<span class="comment">//拿到容器迭代器</span></span><br><span class="line">	vector&lt;Teacher*&gt;::iterator pStart = v.<span class="built_in">begin</span>();</span><br><span class="line">	vector&lt;Teacher*&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line">	<span class="comment">//通过迭代器遍历</span></span><br><span class="line">	<span class="keyword">while</span> (pStart != pEnd) &#123;</span><br><span class="line">		cout &lt;&lt; (*pStart)-&gt;age &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		pStart++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//容器嵌套容器 难点(不理解，可以跳过)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; v;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v3;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">		v<span class="number">2.</span><span class="built_in">push_back</span>(i * <span class="number">10</span>);</span><br><span class="line">		v<span class="number">3.</span><span class="built_in">push_back</span>(i * <span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">	<span class="keyword">for</span> (vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator subIt = (*it).<span class="built_in">begin</span>(); subIt != (*it).<span class="built_in">end</span>(); subIt++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; *subIt &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="comment">//test03();</span></span><br><span class="line">	<span class="built_in">test04</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h1><h2 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h2><h3 id="string容器基本概念"><a href="#string容器基本概念" class="headerlink" title="string容器基本概念"></a>string容器基本概念</h3><p>​	C风格字符串(以空字符结尾的字符数组)太过复杂难于掌握，不适合大程序的开发，所以C++标准库定义了一种string类，定义在头文件<code>&lt;string&gt;</code>。</p>
<p>​	String和c风格字符串对比：</p>
<ul>
<li>Char*是一个指针，String是一个类<ul>
<li>string封装了<code>char*</code>，管理这个字符串，是一个<code>char*</code>型的容器。</li>
</ul>
</li>
<li>String封装了很多实用的成员方法<br>查找find，拷贝copy，删除delete 替换replace，插入insert</li>
<li>不用考虑内存释放和越界<br>string管理<code>char*</code>所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</li>
</ul>
<h3 id="string容器常用操作"><a href="#string容器常用操作" class="headerlink" title="string容器常用操作"></a>string容器常用操作</h3><h4 id="string-构造函数"><a href="#string-构造函数" class="headerlink" title="string 构造函数"></a>string 构造函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>();<span class="comment">//创建一个空的字符串 例如: string str; </span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; str);<span class="comment">//使用一个string对象初始化另一个string对象</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span>* s);<span class="comment">//使用字符串s初始化</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">int</span> n, <span class="type">char</span> c);<span class="comment">//使用n个字符c初始化 </span></span><br></pre></td></tr></table></figure>

<h5 id=""><a href="#" class="headerlink" title=""></a></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 构造演示</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">t1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1;<span class="comment">//创建一个空字符串</span></span><br><span class="line">	<span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">//拷贝构造，s2在初始化的时候初始化成值与s1相同的一个容器。</span></span><br><span class="line">	<span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;hurriedlu&quot;</span>)</span></span>;<span class="comment">//有参构造，在初始化的时候将字符串的值赋给s3。这里也可以是char型数组。</span></span><br><span class="line">	<span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;<span class="comment">//双参数有参构造。把n个字符c赋值给s4；</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s4 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="string基本赋值操作"><a href="#string基本赋值操作" class="headerlink" title="string基本赋值操作"></a>string基本赋值操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span>* s);<span class="comment">//char*类型字符串 赋值给当前的字符串</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">const</span> string &amp;s);<span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">char</span> c);<span class="comment">//字符赋值给当前的字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符赋给当前的字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;<span class="comment">//把字符串s赋给当前字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//用n个字符c赋给当前字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> start, <span class="type">int</span> n)</span></span>;<span class="comment">//将s从start开始n个字符赋值给字符串</span></span><br></pre></td></tr></table></figure>

<h5 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 基本赋值</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">t2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1, s2, s3, s4, s5, s6, s7, s8, s9;</span><br><span class="line">	s1 = s2;<span class="comment">//直接赋值</span></span><br><span class="line">	s2 = <span class="string">&quot;hurriedlu&quot;</span>;<span class="comment">//字符串直接赋值</span></span><br><span class="line">	s3 = <span class="string">&#x27;a&#x27;</span>;<span class="comment">//字符赋值</span></span><br><span class="line">	s<span class="number">4.</span><span class="built_in">assign</span>(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//利用内部函数进行赋值</span></span><br><span class="line">	s<span class="number">5.</span><span class="built_in">assign</span>(<span class="string">&quot;hello world&quot;</span>, <span class="number">5</span>);<span class="comment">//指定只复制前n个，此处为hello。也可以不是字符串是另一个string容器。</span></span><br><span class="line">	s<span class="number">6.</span><span class="built_in">assign</span>(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>);<span class="comment">//用n个字符c赋给当前字符串</span></span><br><span class="line">	s<span class="number">7.</span><span class="built_in">assign</span>(s4, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">//将s从start开始n个字符赋值给字符串。start从0起，包括start。</span></span><br><span class="line">	cout &lt;&lt; s7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="string存取字符操作"><a href="#string存取字符操作" class="headerlink" title="string存取字符操作"></a>string存取字符操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> n);<span class="comment">//通过[]方式取字符</span></span><br><span class="line"><span class="function"><span class="type">char</span>&amp; <span class="title">at</span><span class="params">(<span class="type">int</span> n)</span></span>;<span class="comment">//通过at方法获取字符</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1 = <span class="string">&quot;Hi!&quot;</span>;</span><br><span class="line">	cout &lt;&lt; s1[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//通过[]方式取字符</span></span><br><span class="line">	cout &lt;&lt; s<span class="number">1.</span><span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; endl;<span class="comment">//通过at方法获取字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><p>[]访问越界会直接挂掉；而at()会抛出一个异常（out_of_range）。</p>
<h4 id="string拼接操作"><a href="#string拼接操作" class="headerlink" title="string拼接操作"></a>string拼接操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> string&amp; str);<span class="comment">//重载+=操作符</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str);<span class="comment">//重载+=操作符</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span> c);<span class="comment">//重载+=操作符</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//把字符串s连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;<span class="comment">//同operator+=()</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> pos, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s中从pos开始的n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//在当前字符串结尾添加n个字符c</span></span><br></pre></td></tr></table></figure>



<h5 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1, s2;</span><br><span class="line">	s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">	s1 += s2;<span class="comment">//s1 = &quot;helloworld&quot;;</span></span><br><span class="line">	s1 += <span class="string">&quot;!&quot;</span>;<span class="comment">//s1 = &quot;helloworld!&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a>string查找和替换</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//查找str第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;  <span class="comment">//查找s第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos, <span class="type">int</span> n)</span> <span class="type">const</span></span>;  <span class="comment">//从pos位置查找s的前n个字符第一次位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;  <span class="comment">//查找字符c第一次出现位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//查找str最后一次位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//查找s最后一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos, <span class="type">int</span> n)</span> <span class="type">const</span></span>;<span class="comment">//从pos查找s的前n个字符最后一次位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//查找字符c最后一次出现位置</span></span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">const</span> string&amp; str)</span></span>; <span class="comment">//替换从pos开始n个字符为字符串str</span></span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">//替换从pos开始的n个字符为字符串s</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1, s2, s3;</span><br><span class="line">	s1 = <span class="string">&quot;hurriedlu&quot;</span>;</span><br><span class="line">	s2 = <span class="string">&quot;ie&quot;</span>;</span><br><span class="line">	cout &lt;&lt; s<span class="number">1.f</span>ind(s2, <span class="number">0</span>) &lt;&lt; endl; <span class="comment">//4,在s1字符串中查找s2字符串的内容，n表示从s1中的第几位开始查找，可缺省</span></span><br><span class="line">	cout &lt;&lt; s<span class="number">1.f</span>ind(<span class="string">&#x27;u&#x27;</span>, <span class="number">0</span>) &lt;&lt; endl;<span class="comment">//1，查找u这个字符，从s1的第零位开始</span></span><br><span class="line">	cout &lt;&lt; s<span class="number">1.f</span>ind(<span class="string">&#x27;u&#x27;</span>, <span class="number">2</span>) &lt;&lt; endl;<span class="comment">//8，查找u这个字符，从s1的第2位开始查找。</span></span><br><span class="line">	cout &lt;&lt; s<span class="number">1.</span><span class="built_in">rfind</span>(<span class="string">&#x27;u&#x27;</span>) &lt;&lt; endl; <span class="comment">//8，从后往前开始查找u这个字符。也可以指定从第几位开始查找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>当查找不到的时候，返回-1。</p>
<h4 id="string比较操作"><a href="#string比较操作" class="headerlink" title="string比较操作"></a>string比较操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。</span></span><br><span class="line"><span class="comment">比较区分大小写，比较时参考字典顺序，排越前面的越小。</span></span><br><span class="line"><span class="comment">大写的A比小写的a小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span></span>;<span class="comment">//与字符串s比较</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> <span class="type">const</span></span>;<span class="comment">//与字符串s比较</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1, s2, s3;</span><br><span class="line">	s1 = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">	s2 = <span class="string">&quot;aab&quot;</span>;</span><br><span class="line">	s3 = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">	cout &lt;&lt; s<span class="number">1.</span><span class="built_in">compare</span>(s2) &lt;&lt; endl;<span class="comment">//s1与s2进行比较，因为b大于a，被比较的s2大，因此返回-1</span></span><br><span class="line">	cout &lt;&lt; s<span class="number">2.</span><span class="built_in">compare</span>(s1) &lt;&lt; endl;<span class="comment">//s2与s1进行比较，被比较的s1小，返回1；</span></span><br><span class="line">	cout &lt;&lt; s<span class="number">3.</span><span class="built_in">compare</span>(s1) &lt;&lt; endl;<span class="comment">//s3与s1进行比较，相等，返回0；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="string子串"><a href="#string子串" class="headerlink" title="string子串"></a>string子串</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">substr</span><span class="params">(<span class="type">int</span> pos = <span class="number">0</span>, <span class="type">int</span> n = npos)</span> <span class="type">const</span></span>;<span class="comment">//返回由pos开始的n个字符组成的字符串</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-5"><a href="#样例-5" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串</span></span><br><span class="line">	string s1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	string s2 = s<span class="number">1.</span><span class="built_in">substr</span>(<span class="number">4</span>, <span class="number">3</span>);<span class="comment">//获取s1从第四位开始，连续3个字符的子串。</span></span><br><span class="line">	cout &lt;&lt; s2 &lt;&lt; endl;<span class="comment">//o w</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li><strong>当n小于pos的时候，则表示获取从pos开始的所有数据</strong></li>
</ul>
<h4 id="string插入和删除操作"><a href="#string插入和删除操作" class="headerlink" title="string插入和删除操作"></a>string插入和删除操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">const</span> string&amp; str)</span></span>; <span class="comment">//插入字符串</span></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//在指定位置插入n个字符c</span></span><br><span class="line"><span class="function">string&amp; <span class="title">erase</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n = npos)</span></span>;<span class="comment">//删除从Pos开始的n个字符 </span></span><br></pre></td></tr></table></figure>

<h5 id="样例-6"><a href="#样例-6" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t8</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1 = <span class="string">&quot;hellorld&quot;</span>;</span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">4</span>, <span class="string">&quot;o w&quot;</span>);<span class="comment">//在第n位插入指定的字符串</span></span><br><span class="line">	cout &lt;&lt; s1 &lt;&lt; endl;<span class="comment">//&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">11</span>, <span class="number">3</span>, <span class="string">&#x27;!&#x27;</span>);<span class="comment">//在第11个位置追加3个！</span></span><br><span class="line">	cout &lt;&lt; s1 &lt;&lt; endl;<span class="comment">//&quot;hello world!!!&quot;</span></span><br><span class="line"></span><br><span class="line">	s<span class="number">1.</span><span class="built_in">erase</span>(<span class="number">12</span>, <span class="number">2</span>);<span class="comment">//从第12个位置，删除连续的两个字符</span></span><br><span class="line">	cout &lt;&lt; s1 &lt;&lt; endl;<span class="comment">//&quot;hello world!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="string和c-style字符串转换"><a href="#string和c-style字符串转换" class="headerlink" title="string和c-style字符串转换"></a>string和c-style字符串转换</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//string 转 char*</span></span><br><span class="line">string str = <span class="string">&quot;hurriedlu&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = str.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="comment">//char* 转 string </span></span><br><span class="line"><span class="type">char</span>* s = <span class="string">&quot;hurriedlu&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(s)</span></span>;<span class="comment">//借助有参构造</span></span><br></pre></td></tr></table></figure>

<h5 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h5><p>​	存在<code>const char*</code>到<code>string</code>的隐式类型转换，但不存在从一个string对象到C_string的自动类型转换。</p>
<p><code>对于string类型的字符串，可以通过c_str()函数返回string对象对应的C_string</code>.<br> 通常，程序员在整个程序中应坚持使用string类对象，直到必须将内容转化为char*时才将其转换为C_string.</p>
<p>  为了修改string字符串的内容，下标操作符[]和at都会返回字符的引用。但<strong>当字符串的内存被重新分配之后，可能发生错误</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t9</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">	<span class="type">char</span>&amp; a = s[<span class="number">2</span>];<span class="comment">//获取s的下标为2的地址</span></span><br><span class="line">	<span class="type">char</span>&amp; b = s[<span class="number">3</span>];</span><br><span class="line">	a = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">	b = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;<span class="comment">//ab12efg</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>*)s.<span class="built_in">c_str</span>() &lt;&lt; endl;<span class="comment">//验证是否符合下方的说法，在改变之前获取其中字串的地址</span></span><br><span class="line"></span><br><span class="line">	s = <span class="string">&quot;pppppppppppppppppppppppp&quot;</span>;<span class="comment">//从新修改了s的字符串，变长了，触发了string的内存重分配策略</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//a = &#x27;1&#x27;;	</span></span><br><span class="line">	<span class="comment">//b = &#x27;2&#x27;; //再次执行，因为s的位置更新了，原先的位置被释放掉了，所以再次对原先位置的修改就会出错。</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>*)s.<span class="built_in">c_str</span>() &lt;&lt; endl;<span class="comment">//再次获取发现两个串的开头已经不一样了。</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>&amp; c = s[<span class="number">2</span>];</span><br><span class="line">	s = <span class="string">&quot;hhhhhhhhhhhhhhhhhhhhh&quot;</span>;<span class="comment">//修改字符串s的值，但不要触发内存重新分配</span></span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	c = <span class="string">&#x27;0&#x27;</span>;<span class="comment">//此时是可以再次修改的</span></span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><h3 id="vector容器基本概念"><a href="#vector容器基本概念" class="headerlink" title="vector容器基本概念"></a>vector容器基本概念</h3><p>​	vector的数据安排以及操作方式，与数组非常相似，两者的唯一差别在于空间的运用的灵活性。</p>
<p>​	数组是静态空间，一旦配置了就不能改变，要换大一点或者小一点的空间，可以，一切琐碎得由自己来，首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。Vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。因此vector的运用对于内存的合理利用与运用的灵活性有很大的帮助。</p>
<p>​	Vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率，一旦vector旧空间满了，如果客户每新增一个元素，vector内部只是扩充一个元素的空间，实为不智，因为所谓的扩充空间(不论多大)，一如刚所说，是”配置新空间-数据移动-释放旧空间”的大工程,时间成本很高，应该加入某种未雨绸缪的考虑，稍后我们便可以看到vector的空间配置策略。</p>
<p><img src="/./Image/C++STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/clip_image002.jpg" alt="说明: 2015-11-10_151152"></p>
<h3 id="vector迭代器"><a href="#vector迭代器" class="headerlink" title="vector迭代器"></a>vector迭代器</h3><p>​	Vector维护一个线性空间，所以不论元素的型别如何，普通指针都可以作为vector的迭代器，因为vector迭代器所需要的操作行为，如<code>operaroe*, operator-&gt;, operator++, operator--, operator+, operator-, operator+=, operator-=</code>, 普通指针天生具备。</p>
<p>Vector支持随机存取。所以vector提供的是随机访问迭代器(Random Access Iterators).</p>
<h3 id="vector的数据结构"><a href="#vector的数据结构" class="headerlink" title="vector的数据结构"></a>vector的数据结构</h3><p>Vector所采用的数据结构非常简单，线性连续空间，它以两个迭代器_Myfirst和_Mylast分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器_Myend指向整块连续内存空间的尾端。<br><strong>为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求大一些，以备将来可能的扩充</strong>，这便是容量的概念。换句话说，<strong>一个vector的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个vector容器就得另觅居所</strong>。</p>
<p>注意：<br>  所谓动态增加大小，<strong>并不是在原空间之后续接新空间</strong>(因为无法保证原空间之后尚有可配置的空间)，而是一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。<strong>因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了</strong>，务必小心。</p>
<h3 id="vector常用API操作"><a href="#vector常用API操作" class="headerlink" title="vector常用API操作"></a>vector常用API操作</h3><h4 id="vector容量分配策略"><a href="#vector容量分配策略" class="headerlink" title="vector容量分配策略"></a>vector容量分配策略</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">		cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//每插入一个数据，就输出一下vector容器的具体大小；   </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//1 2 3 4 6 6 9 9 9 13</span></span><br><span class="line">	<span class="comment">//并不是没插一个数就增加一次空间，因为这样会很浪费时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;数据类型&gt; v; <span class="comment">//采用模板实现类实现，默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">//有参构造，将v[begin(), end())区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector &amp;vec);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-7"><a href="#样例-7" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;<span class="comment">//默认构成</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>, <span class="number">8</span>)</span></span>;<span class="comment">//初始化成10个8；</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(v<span class="number">1.</span>begin(), v<span class="number">1.</span>begin() + <span class="number">5</span>)</span></span>;<span class="comment">//根据指定位置数据来初始化vector</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span> &#125;;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v5</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>;<span class="comment">//根据指定位置数据来初始化vector</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="vector常用赋值操作"><a href="#vector常用赋值操作" class="headerlink" title="vector常用赋值操作"></a>vector常用赋值操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">vector&amp; <span class="keyword">operator</span>=(<span class="type">const</span> vector  &amp;vec);<span class="comment">//重载等号操作符</span></span><br><span class="line"><span class="built_in">swap</span>(vec);<span class="comment">// 将vec与本身的元素互换。</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-8"><a href="#样例-8" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 常用的赋值操作</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">t3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;<span class="comment">//初始化成10个0的vector</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	v<span class="number">2.</span><span class="built_in">assign</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>());<span class="comment">//将指定区间的数赋值给v2。左开右闭原则。</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">	v3 = v2;<span class="comment">//借助内部重载的赋值操作符进行赋值</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">swap</span>(v2);<span class="comment">//使用内部的swap方法，使得v1与v2进行交换，v1变成空值，v2变成十个0.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it : v1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="vector大小操作"><a href="#vector大小操作" class="headerlink" title="vector大小操作"></a>vector大小操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">size</span>();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="built_in">resize</span>(<span class="type">int</span> num);<span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="built_in">resize</span>(<span class="type">int</span> num, elem);<span class="comment">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。</span></span><br><span class="line"><span class="built_in">capacity</span>();<span class="comment">//容器的容量</span></span><br><span class="line"><span class="built_in">reserve</span>(<span class="type">int</span> len);<span class="comment">//容器预留len个元素长度，预留位置不初始化，元素不可访问。</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-9"><a href="#样例-9" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// vector容器的大小操作</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">t4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> tmp;</span><br><span class="line"></span><br><span class="line">	tmp = v<span class="number">1.</span><span class="built_in">size</span>();<span class="comment">//获取容器中的元素的个数，注意不是容器的大小</span></span><br><span class="line">	cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> flag = v<span class="number">1.</span><span class="built_in">empty</span>();<span class="comment">//获取当前容器是否为空，为空返回true，否则false</span></span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">resize</span>(v<span class="number">1.</span><span class="built_in">size</span>() / <span class="number">2</span>);	<span class="comment">//重新指定容器的大小，如果指定的大小小于元素，则尾部超出指定大小后的所有元素都会被删除。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it : v1)				</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">resize</span>(v<span class="number">1.</span><span class="built_in">size</span>() + <span class="number">5</span>);	<span class="comment">//如果指定的大小大于当前所有元素的数量，则用默认值填充新的位置</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it : v1)				</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">resize</span>(v<span class="number">1.</span><span class="built_in">size</span>() + <span class="number">5</span>, <span class="number">10</span>);<span class="comment">//也可以指定填充新位置的值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it : v1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	tmp = v<span class="number">1.</span><span class="built_in">capacity</span>();<span class="comment">//获取容器当前的容量值</span></span><br><span class="line">	cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">reserve</span>(<span class="number">20</span>);</span><br><span class="line">	tmp = v<span class="number">1.</span><span class="built_in">capacity</span>();<span class="comment">//再次获取容器当前的容量值</span></span><br><span class="line">	cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">	tmp = v<span class="number">1.</span><span class="built_in">size</span>();<span class="comment">//再次获取容器中元素的个数</span></span><br><span class="line">	cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="vector数据存取操作"><a href="#vector数据存取操作" class="headerlink" title="vector数据存取操作"></a>vector数据存取操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">at</span>(<span class="type">int</span> idx); <span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据，越界时，运行直接报错</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回容器中第一个数据元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回容器中最后一个数据元素</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-10"><a href="#样例-10" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 元素的存取</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">t5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</span></span><br><span class="line">	<span class="comment">//operator[];//返回索引idx所指的数据，越界时，运行直接报错</span></span><br><span class="line">	<span class="comment">//front();//返回容器中第一个数据元素</span></span><br><span class="line">	<span class="comment">//back();//返回容器中最后一个数据元素</span></span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; v<span class="number">1.</span><span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; endl;<span class="comment">//利用at获取指定位置的元素。优点：当访问越界的会弹出一个out_of_range的异常</span></span><br><span class="line">	cout &lt;&lt; v1[<span class="number">2</span>] &lt;&lt; endl;<span class="comment">//也可以用下标的方式进行访问，在不会发生越界的情况下使用。</span></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">at</span>(<span class="number">0</span>) = <span class="number">0</span>;<span class="comment">//也可以修改</span></span><br><span class="line">	v1[<span class="number">3</span>] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it : v1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; v<span class="number">1.f</span>ront() &lt;&lt; endl;<span class="comment">//获取v1容器中第一个元素的值</span></span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; v<span class="number">1.</span><span class="built_in">back</span>() &lt;&lt; endl;<span class="comment">//获取v1容器中最后一个元素的值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="vector插入和删除操作"><a href="#vector插入和删除操作" class="headerlink" title="vector插入和删除操作"></a>vector插入和删除操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">insert</span>(const_iterator pos, <span class="type">int</span> count,ele);<span class="comment">//迭代器指向位置pos插入count个元素ele.</span></span><br><span class="line"><span class="built_in">push_back</span>(ele); <span class="comment">//尾部插入元素ele</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除最后一个元素</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator start, const_iterator end);<span class="comment">//删除迭代器从start到end之间的元素</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator pos);<span class="comment">//删除迭代器指向的元素</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//删除容器中所有元素</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-11"><a href="#样例-11" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 插入和删除</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">t6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">insert</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), <span class="number">0</span>);<span class="comment">//在指定位置（此处指定了容器的起始位置）插入以一个元素0；</span></span><br><span class="line"></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">10</span>);<span class="comment">//在容器的尾部插入一个元素</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it : v1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">pop_back</span>();<span class="comment">//删除容器中最后的一个元素</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it : v1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">erase</span>(v<span class="number">1.</span><span class="built_in">end</span>() - <span class="number">2</span>, v<span class="number">1.</span><span class="built_in">end</span>());<span class="comment">//删除指定位置的所有元素（此处指定了最后两个），范围依旧是左开右闭</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it : v1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">erase</span>(v<span class="number">1.</span><span class="built_in">begin</span>());<span class="comment">//删除指定位置的元素（此处指定了开头的一个元素）</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it : v1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	v<span class="number">1.</span><span class="built_in">clear</span>();<span class="comment">//删除容器中所有的元素</span></span><br><span class="line">	cout &lt;&lt; v<span class="number">1.</span><span class="built_in">empty</span>() &lt;&lt; endl;<span class="comment">//容器已经为空，输出1表示true。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="vector小案例"><a href="#vector小案例" class="headerlink" title="vector小案例"></a>vector小案例</h3><h4 id="使用用swap，收缩内存空间"><a href="#使用用swap，收缩内存空间" class="headerlink" title="使用用swap，收缩内存空间"></a>使用用swap，收缩内存空间</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;容量：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;<span class="comment">//此时可以看到整个容器内部的容量已经到达13万+</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;元素个数：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">//但元素个数只有10万个</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//此时 通过resize改变容器大小</span></span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">10</span>);<span class="comment">//使得元素的个数只有10个，但不修改容量，使得容量保持在13万</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;容量：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;<span class="comment">//容量有13万</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;元素个数：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">//元素个数只剩十个</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//容量没有改变</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始收缩内存</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	vector&lt;int&gt;(v)：利用拷贝构造函数来初始化一个匿名对象。初始化的时候系统会按照v的size进行开辟，而不是按照容量。</span></span><br><span class="line"><span class="comment">	swap(v)：本质是交换两个容器的指针，每个容器的名字是存储在栈的一个指针，而内容是存储在堆内的，因此相当于v这个指针指向了新开辟的匿名对象指向的堆，而v原来的东西被匿名对象指定；当执行完这个语句后，匿名对象就会消失，被回收掉。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	简单的说就是，新开辟一个vector数组，并使用一定的方法将要压缩的容器内部的元素赋值给新的数组</span></span><br><span class="line"><span class="comment">	然后两个数组交换</span></span><br><span class="line"><span class="comment">	新开辟的数组删除。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;容量：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;元素个数：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用reserve预留空间，避免造成时间浪费"><a href="#使用reserve预留空间，避免造成时间浪费" class="headerlink" title="使用reserve预留空间，避免造成时间浪费"></a>使用reserve预留空间，避免造成时间浪费</h4><p>用途：在已知会有巨量数据插入的时候，可以首先使用reserve手动帮助容器去确定大小。</p>
<p>使用原因：容器不清楚你会插入多少数据，本着节约空间的思想会尽可能少的开辟空间。但每次开辟空间都比较费时，因此需要这个方法来节约时间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="comment">//预先开辟空间</span></span><br><span class="line">	v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* pStart = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (pStart != &amp;v[<span class="number">0</span>]) &#123;<span class="comment">//比较空间首地址是否发生了变化，如果发生，则将记录刷新，同时计数器++</span></span><br><span class="line">			pStart = &amp;v[<span class="number">0</span>];</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt; count &lt;&lt; endl;<span class="comment">//输出统计了的重新分配的次数。</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="逆序遍历"><a href="#逆序遍历" class="headerlink" title="逆序遍历"></a>逆序遍历</h4><p>对一个给定的vector数组进行逆序输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用下标进行逆序遍历</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = v.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用逆向迭代器进行逆序遍历</span></span><br><span class="line">	<span class="comment">//迭代器需要是特殊的，否则会报错：&quot;std::reverse_iterator&lt;std::_Vector_iterator&lt;std::_Vector_val&lt;std::_Simple_types&lt;int&gt;&gt;&gt;&gt;&quot; 到 &quot;std::_Vector_iterator&lt;std::_Vector_val&lt;std::_Simple_types&lt;int&gt;&gt;&gt;&quot; 的适当转换</span></span><br><span class="line">	<span class="comment">//定义迭代器的时候，需要定义成reverse_iterator</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::reverse_iterator it = v.<span class="built_in">rbegin</span>(); it != v.<span class="built_in">rend</span>(); it++)</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h2><h3 id="deque容器基本概念"><a href="#deque容器基本概念" class="headerlink" title="deque容器基本概念"></a>deque容器基本概念</h3><p>​	Vector容器是单向开口的连续内存空间，deque则是一种双向开口的连续线性空间。<strong>所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作</strong>，当然，vector容器也可以在头尾两端插入元素，但是在其头部操作<strong>效率奇差</strong>，无法被接受。</p>
<p>​	Deque容器和vector容器最大的差异，一在于<strong>deque允许使用常数项时间对头端进行元素的插入和删除操作</strong>。二在于<strong>deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来</strong>，换句话说，像vector那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。也因此，deque没有必须要提供所谓的空间保留(reserve)功能.<br>虽然deque容器也提供了Random Access Iterator（随机存储迭代器）,但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用vector，而不是deque。<strong>对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque.</strong></p>
<p>简单的说就是，deque的底层是一个类似链表的数组，而vector是一个数组。</p>
<p><img src="/./Image/C++STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/clip_image002-16689529807244.jpg" alt="说明: 2015-11-19_204101"></p>
<h3 id="deque容器实现原理"><a href="#deque容器实现原理" class="headerlink" title="deque容器实现原理"></a>deque容器实现原理</h3><p>Deque容器是连续的空间，至少逻辑上看来如此，连续现行空间总是令我们联想到array和vector，array无法成长，vector虽可成长，却只能向尾端成长，而且其成长其实是一个假象，事实上(1) 申请更大空间 (2)原数据复制新空间 (3)释放原空间 三步骤，如果不是vector每次配置新的空间时都留有余裕，其成长假象所带来的代价是非常昂贵的。</p>
<p>​	Deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。Deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。<br>既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。Deque代码的实现远比vector或list都多得多。<br><strong>Deque采取一块所谓的map(注意，不是STL的map容器)作为主控，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是deque的存储空间的主体。</strong></p>
<p><strong><img src="/./Image/C++STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/clip_image002-16689529915256.jpg" alt="说明: 2015-11-19_204209"></strong></p>
<h3 id="deque常用API"><a href="#deque常用API" class="headerlink" title="deque常用API"></a>deque常用API</h3><h4 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;T&gt; deqT;<span class="comment">//默认构造形式</span></span><br><span class="line"><span class="built_in">deque</span>(beg, end);<span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(n, elem);<span class="comment">//构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="type">const</span> deque &amp;deq);<span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-12"><a href="#样例-12" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;<span class="comment">//默认构造</span></span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	<span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d2</span><span class="params">(v.begin(), v.end())</span></span>;<span class="comment">//将指定范围的数作为初始化的值</span></span><br><span class="line"></span><br><span class="line">	<span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;<span class="comment">//指定元素个数的初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d4</span><span class="params">(d3)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assign</span>(beg, end);<span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="built_in">assign</span>(n, elem);<span class="comment">//将n个elem拷贝赋值给本身。</span></span><br><span class="line">deque&amp; <span class="keyword">operator</span>=(<span class="type">const</span> deque &amp;deq); <span class="comment">//重载等号操作符 </span></span><br><span class="line"><span class="built_in">swap</span>(deq);<span class="comment">// 将deq与本身的元素互换</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-13"><a href="#样例-13" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d2;</span><br><span class="line">	d<span class="number">2.</span><span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">	d<span class="number">2.</span><span class="built_in">assign</span>(d<span class="number">1.</span><span class="built_in">begin</span>() + <span class="number">1</span>, d<span class="number">1.</span><span class="built_in">end</span>());<span class="comment">//复制指定位置的值到当前容器，并顶替掉当前容器已有的值。</span></span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::iterator it = d<span class="number">2.</span><span class="built_in">begin</span>(); it != d<span class="number">2.</span><span class="built_in">end</span>(); it++)</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d3;</span><br><span class="line">	d3 = d2;<span class="comment">//容器内部重载了赋值号这个操作，可以直接赋值。</span></span><br><span class="line"></span><br><span class="line">	d<span class="number">2.</span><span class="built_in">swap</span>(d1);<span class="comment">//两个容器的存储部分进行交换操作。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a>deque大小操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque.<span class="built_in">size</span>();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line">deque.<span class="built_in">empty</span>();<span class="comment">//判断容器是否为空</span></span><br><span class="line">deque.<span class="built_in">resize</span>(num);<span class="comment">//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line">deque.<span class="built_in">resize</span>(num, elem); <span class="comment">//重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-14"><a href="#样例-14" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; d<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">//获取d1的元素个数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(d<span class="number">1.</span><span class="built_in">empty</span>()!= <span class="literal">NULL</span>)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;不为空&quot;</span> &lt;&lt; endl;<span class="comment">//判断当前容器是否为空</span></span><br><span class="line"></span><br><span class="line">	d<span class="number">1.</span><span class="built_in">resize</span>(d<span class="number">1.</span><span class="built_in">size</span>() + <span class="number">2</span>);<span class="comment">//重新设置d1的元素的个数，如果变长用默认值填充，变短删除尾端元素</span></span><br><span class="line"></span><br><span class="line">	d<span class="number">1.</span><span class="built_in">resize</span>(d<span class="number">1.</span><span class="built_in">size</span>() + <span class="number">2</span>,<span class="number">-1</span>);<span class="comment">//重新设置d1的元素的个数，并指定填充元素的值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::iterator it = d<span class="number">1.</span><span class="built_in">begin</span>(); it != d<span class="number">1.</span><span class="built_in">end</span>(); it++)</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="deque双端插入和删除操作"><a href="#deque双端插入和删除操作" class="headerlink" title="deque双端插入和删除操作"></a>deque双端插入和删除操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(elem);<span class="comment">//在容器尾部添加一个数据</span></span><br><span class="line"><span class="built_in">push_front</span>(elem);<span class="comment">//在容器头部插入一个数据</span></span><br><span class="line"><span class="built_in">pop_back</span>();<span class="comment">//删除容器最后一个数据</span></span><br><span class="line"><span class="built_in">pop_front</span>();<span class="comment">//删除容器第一个数据</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-15"><a href="#样例-15" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line"></span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">1</span>);<span class="comment">//在d1的尾部插入一个1</span></span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">2</span>);<span class="comment">//再次尾插</span></span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_front</span>(<span class="number">3</span>);<span class="comment">//在d1的前面插入一个3，此时d1的值为： 3 1 2</span></span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::iterator it = d<span class="number">1.</span><span class="built_in">begin</span>(); it != d<span class="number">1.</span><span class="built_in">end</span>(); it++)</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	d<span class="number">1.</span><span class="built_in">pop_back</span>();<span class="comment">//删除一个尾部元素</span></span><br><span class="line">	d<span class="number">1.</span><span class="built_in">pop_front</span>();<span class="comment">//删除一个头部元素</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::iterator it = d<span class="number">1.</span><span class="built_in">begin</span>(); it != d<span class="number">1.</span><span class="built_in">end</span>(); it++)</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="deque数据存取"><a href="#deque数据存取" class="headerlink" title="deque数据存取"></a>deque数据存取</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">at</span>(idx);<span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range。</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个数据。</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个数据</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-16"><a href="#样例-16" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; d1[<span class="number">0</span>] &lt;&lt; endl;<span class="comment">//直接索引下标为0的元素</span></span><br><span class="line">	cout &lt;&lt; d<span class="number">1.</span><span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; endl;<span class="comment">//利用at返回对应下标的元素</span></span><br><span class="line">	cout &lt;&lt; d<span class="number">1.f</span>ront() &lt;&lt; endl;<span class="comment">//获取容器的第一个元素</span></span><br><span class="line">	cout &lt;&lt; d<span class="number">1.</span><span class="built_in">back</span>() &lt;&lt; endl;<span class="comment">//获取容器的最后一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="deque插入操作"><a href="#deque插入操作" class="headerlink" title="deque插入操作"></a>deque插入操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">insert</span>(pos,elem);<span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="built_in">insert</span>(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-17"><a href="#样例-17" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">insert</span>(d<span class="number">1.</span><span class="built_in">begin</span>(), <span class="number">12</span>);<span class="comment">//在d1容器的开头的位置插入一个值12</span></span><br><span class="line">	d<span class="number">1.</span><span class="built_in">insert</span>(d<span class="number">1.</span><span class="built_in">begin</span>(), <span class="number">5</span>, <span class="number">0</span>);<span class="comment">//在d1容器的开头插入5个0；</span></span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d2;</span><br><span class="line">	d<span class="number">2.</span><span class="built_in">insert</span>(d<span class="number">2.</span><span class="built_in">begin</span>(),d<span class="number">1.</span><span class="built_in">begin</span>(), d<span class="number">1.</span><span class="built_in">end</span>());<span class="comment">//在d2开头的位置插入d1容器的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="deque删除操作"><a href="#deque删除操作" class="headerlink" title="deque删除操作"></a>deque删除操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">clear</span>();<span class="comment">//移除容器的所有数据</span></span><br><span class="line"><span class="built_in">erase</span>(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="built_in">erase</span>(pos);<span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-18"><a href="#样例-18" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//clear();//移除容器的所有数据</span></span><br><span class="line">	<span class="comment">//erase(beg, end);//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line">	<span class="comment">//erase(pos);//删除pos位置的数据，返回下一个数据的位置。</span></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (d<span class="number">1.</span><span class="built_in">empty</span>())</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1容器是空的&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1容器不是空的&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	d<span class="number">1.</span><span class="built_in">clear</span>();<span class="comment">//对d1进行清空</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (d<span class="number">1.</span><span class="built_in">empty</span>())</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1容器是空的&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1容器不是空的&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//再次插入4个元素</span></span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	d<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	d<span class="number">1.</span><span class="built_in">erase</span>(d<span class="number">1.</span><span class="built_in">begin</span>() + <span class="number">2</span>, d<span class="number">1.</span><span class="built_in">end</span>());<span class="comment">//只保留前面两个元素</span></span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::iterator it = d<span class="number">1.</span><span class="built_in">begin</span>(); it != d<span class="number">1.</span><span class="built_in">end</span>(); it++)</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	d<span class="number">1.</span><span class="built_in">erase</span>(d<span class="number">1.</span><span class="built_in">end</span>() - <span class="number">1</span>);<span class="comment">//删除最后一个元素</span></span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::iterator it = d<span class="number">1.</span><span class="built_in">begin</span>(); it != d<span class="number">1.</span><span class="built_in">end</span>(); it++)</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h2><h3 id="stack容器基本概念"><a href="#stack容器基本概念" class="headerlink" title="stack容器基本概念"></a>stack容器基本概念</h3><p>​	stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口，形式如图所示。</p>
<p>​	stack容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，<strong>stack不允许有遍历行为</strong>。<br>​	有元素推入栈的操作称为:push,将元素推出stack的操作称为pop.</p>
<p><img src="/./Image/C++STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/clip_image002-16690312276401.jpg" alt="说明: 2015-11-15_195707"></p>
<h3 id="3-4-2-stack没有迭代器"><a href="#3-4-2-stack没有迭代器" class="headerlink" title="3.4.2 stack没有迭代器"></a>3.4.2 stack没有迭代器</h3><p>​	<strong>Stack所有元素的进出都必须符合”先进后出”的条件</strong>，只有stack顶端的元素，才有机会被外界取用。<strong>Stack不提供遍历功能，也不提供迭代器。</strong></p>
<h3 id="stack常用API"><a href="#stack常用API" class="headerlink" title="stack常用API"></a>stack常用API</h3><h4 id="stack构造函数"><a href="#stack构造函数" class="headerlink" title="stack构造函数"></a>stack构造函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;T&gt; stkT;<span class="comment">//stack采用模板类实现， stack对象的默认构造形式： </span></span><br><span class="line"><span class="built_in">stack</span>(<span class="type">const</span> stack &amp;stk);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-19"><a href="#样例-19" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; t1;<span class="comment">//无参构造</span></span><br><span class="line">	t<span class="number">1.</span><span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">t2</span><span class="params">(t1)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!t<span class="number">2.</span><span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; t<span class="number">2.</span><span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		t<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="stack赋值操作"><a href="#stack赋值操作" class="headerlink" title="stack赋值操作"></a>stack赋值操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> stack &amp;stk);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-20"><a href="#样例-20" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; t1;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; t2;</span><br><span class="line"></span><br><span class="line">	t2 = t1;<span class="comment">//直接赋值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!t<span class="number">2.</span><span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; t<span class="number">2.</span><span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		t<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="stack数据存取操作"><a href="#stack数据存取操作" class="headerlink" title="stack数据存取操作"></a>stack数据存取操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//向栈顶添加元素</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//从栈顶移除第一个元素</span></span><br><span class="line"><span class="built_in">top</span>();<span class="comment">//返回栈顶元素</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-21"><a href="#样例-21" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; t1;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">push</span>(<span class="number">1</span>);<span class="comment">//添加元素到栈顶</span></span><br><span class="line">	t<span class="number">1.</span><span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!t<span class="number">1.</span><span class="built_in">empty</span>())<span class="comment">//只要栈不空就循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; t<span class="number">1.</span><span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//获取当前的栈顶元素</span></span><br><span class="line">		t<span class="number">1.</span><span class="built_in">pop</span>();<span class="comment">//栈顶元素出栈</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="stack大小操作"><a href="#stack大小操作" class="headerlink" title="stack大小操作"></a>stack大小操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断堆栈是否为空</span></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//返回堆栈的大小</span></span><br></pre></td></tr></table></figure>

<h5 id="样例-22"><a href="#样例-22" class="headerlink" title="样例"></a>样例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; t1;</span><br><span class="line">	<span class="keyword">if</span>(t<span class="number">1.</span><span class="built_in">empty</span>())<span class="comment">//判断栈是否为空</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;空栈&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;非空栈&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	t<span class="number">1.</span><span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; t<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">//获取栈中元素的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h2><h3 id="queue容器基本概念"><a href="#queue容器基本概念" class="headerlink" title="queue容器基本概念"></a>queue容器基本概念</h3><p>​	Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口，queue容器允许从一端新增元素，从另一端移除元素。即队列。</p>
<h3 id="queue没有迭代器"><a href="#queue没有迭代器" class="headerlink" title="queue没有迭代器"></a>queue没有迭代器</h3><p>​	Queue所有元素的进出都必须符合”先进先出”的条件，只有queue的顶端元素，才有机会被外界取用。<strong>Queue不提供遍历功能，也不提供迭代器</strong>。</p>
<h3 id="queue常用API"><a href="#queue常用API" class="headerlink" title="queue常用API"></a>queue常用API</h3><h4 id="queue构造函数"><a href="#queue构造函数" class="headerlink" title="queue构造函数"></a>queue构造函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;T&gt; queT;<span class="comment">//queue采用模板类实现，queue对象的默认构造形式：</span></span><br><span class="line"><span class="built_in">queue</span>(<span class="type">const</span> queue &amp;que);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure>



<h5 id="样例-23"><a href="#样例-23" class="headerlink" title="样例"></a>样例</h5><h4 id="queue存取、插入和删除操作"><a href="#queue存取、插入和删除操作" class="headerlink" title="queue存取、插入和删除操作"></a>queue存取、插入和删除操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push</span>(elem);<span class="comment">//往队尾添加元素</span></span><br><span class="line"><span class="built_in">pop</span>();<span class="comment">//从队头移除第一个元素</span></span><br><span class="line"><span class="built_in">back</span>();<span class="comment">//返回最后一个元素</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">//返回第一个元素</span></span><br></pre></td></tr></table></figure>



<h5 id="样例-24"><a href="#样例-24" class="headerlink" title="样例"></a>样例</h5><h4 id="queue赋值操作"><a href="#queue赋值操作" class="headerlink" title="queue赋值操作"></a>queue赋值操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> queue &amp;que);<span class="comment">//重载等号操作符</span></span><br></pre></td></tr></table></figure>



<h5 id="样例-25"><a href="#样例-25" class="headerlink" title="样例"></a>样例</h5><h4 id="queue大小操作"><a href="#queue大小操作" class="headerlink" title="queue大小操作"></a>queue大小操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">empty</span>();<span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//返回队列的大小</span></span><br></pre></td></tr></table></figure>



<h5 id="样例-26"><a href="#样例-26" class="headerlink" title="样例"></a>样例</h5><h2 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h2><h3 id="list容器基本概念"><a href="#list容器基本概念" class="headerlink" title="list容器基本概念"></a>list容器基本概念</h3><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。<br>相较于vector的连续线性空间，list就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。<br>List和vector是两个最常被使用的容器。<br>List容器是一个双向链表。</p>
<p> 采用动态存储分配，不会造成内存浪费和溢出<br> 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素<br> 链表灵活，但是空间和时间额外耗费较大</p>
<h3 id="list容器的迭代器"><a href="#list容器的迭代器" class="headerlink" title="list容器的迭代器"></a>list容器的迭代器</h3><p>List容器不能像vector一样以普通指针作为迭代器，因为其节点不能保证在同一块连续的内存空间上。List迭代器必须有能力指向list的节点，并有能力进行正确的递增、递减、取值、成员存取操作。所谓”list正确的递增，递减、取值、成员取用”是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取的是节点的成员。<br>由于list是一个双向链表，迭代器必须能够具备前移、后移的能力，所以list容器提供的是Bidirectional Iterators.<br>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效。这在vector是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效，甚至List元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。</p>
<h3 id="list容器的数据结构"><a href="#list容器的数据结构" class="headerlink" title="list容器的数据结构"></a>list容器的数据结构</h3><p>list容器不仅是一个双向链表，而且还是一个循环的双向链表。</p>
<p>#define _CRT_SECURE_NO_WARNINGS<br>#include<iostream><br>#include<list><br>using namespace std;</p>
<p>int main(){</p>
<p>list<int> myList;<br>for (int i &#x3D; 0; i &lt; 10; i ++){<br>myList.push_back(i);<br>}</p>
<p>list<int>::_Nodeptr node &#x3D;  myList._Myhead-&gt;_Next;</p>
<p>for (int i &#x3D; 0; i &lt; myList._Mysize * 2;i++){<br>cout &lt;&lt; “Node:” &lt;&lt; node-&gt;_Myval &lt;&lt; endl;<br>node &#x3D; node-&gt;_Next;<br>if (node &#x3D;&#x3D; myList._Myhead){<br>node &#x3D; node-&gt;_Next;<br>}<br>}</p>
<p>system(“pause”);<br>return EXIT_SUCCESS;<br>}</p>
<h3 id="list常用API"><a href="#list常用API" class="headerlink" title="list常用API"></a>list常用API</h3><h4 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h4><p>list<T> lstT;&#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式：<br>list(beg,end);&#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。<br>list(n,elem);&#x2F;&#x2F;构造函数将n个elem拷贝给本身。<br>list(const list &amp;lst);&#x2F;&#x2F;拷贝构造函数。</p>
<h4 id="list数据元素插入和删除操作"><a href="#list数据元素插入和删除操作" class="headerlink" title="list数据元素插入和删除操作"></a>list数据元素插入和删除操作</h4><p>push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素<br>pop_back();&#x2F;&#x2F;删除容器中最后一个元素<br>push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素<br>pop_front();&#x2F;&#x2F;从容器开头移除第一个元素<br>insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。<br>insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。<br>insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。<br>clear();&#x2F;&#x2F;移除容器的所有数据<br>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。<br>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。<br>remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。</p>
<h4 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h4><p>size();&#x2F;&#x2F;返回容器中元素的个数<br>empty();&#x2F;&#x2F;判断容器是否为空<br>resize(num);&#x2F;&#x2F;重新指定容器的长度为num，<br>若容器变长，则以默认值填充新位置。<br>如果容器变短，则末尾超出容器长度的元素被删除。<br>resize(num, elem);&#x2F;&#x2F;重新指定容器的长度为num，<br>若容器变长，则以elem值填充新位置。<br>如果容器变短，则末尾超出容器长度的元素被删除。</p>
<h4 id="list赋值操作"><a href="#list赋值操作" class="headerlink" title="list赋值操作"></a>list赋值操作</h4><p>assign(beg, end);&#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。<br>assign(n, elem);&#x2F;&#x2F;将n个elem拷贝赋值给本身。<br>list&amp; operator&#x3D;(const list &amp;lst);&#x2F;&#x2F;重载等号操作符<br>swap(lst);&#x2F;&#x2F;将lst与本身的元素互换。</p>
<h4 id="list数据的存取"><a href="#list数据的存取" class="headerlink" title="list数据的存取"></a>list数据的存取</h4><p>front();&#x2F;&#x2F;返回第一个元素。<br>back();&#x2F;&#x2F;返回最后一个元素。</p>
<h4 id="list反转排序"><a href="#list反转排序" class="headerlink" title="list反转排序"></a>list反转排序</h4><p>reverse();&#x2F;&#x2F;反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。<br>sort(); &#x2F;&#x2F;list排序</p>
<p>3.7 set&#x2F;multiset容器<br>3.7.1 set&#x2F;multiset容器基本概念<br>3.7.1.1 set容器基本概念<br>Set的特性是。所有元素都会根据元素的键值自动被排序。Set的元素不像map那样可以同时拥有实值和键值，set的元素即是键值又是实值。Set不允许两个元素有相同的键值。<br>我们可以通过set的迭代器改变set元素的值吗？不行，因为set元素值就是其键值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织。换句话说，set的iterator是一种const_iterator.<br>set拥有和list某些相同的性质，当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效，被删除的那个元素的迭代器必然是一个例外。<br>3.7.1.2 multiset容器基本概念<br>multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。set和multiset的底层实现是红黑树，红黑树为平衡二叉树的一种。<br>树的简单知识：<br>二叉树就是任何节点最多只允许有两个字节点。分别是左子结点和右子节点。</p>
<p>二叉树示意图</p>
<p>二叉搜索树，是指二叉树中的节点按照一定的规则进行排序，使得对二叉树中元素访问更加高效。二叉搜索树的放置规则是：任何节点的元素值一定大于其左子树中的每一个节点的元素值，并且小于其右子树的值。因此从根节点一直向左走，一直到无路可走，即得到最小值，一直向右走，直至无路可走，可得到最大值。那么在儿茶搜索树中找到最大元素和最小元素是非常简单的事情。下图为二叉搜索树：</p>
<p>上面我们介绍了二叉搜索树，那么当一个二叉搜索树的左子树和右子树不平衡的时候，那么搜索依据上图表示，搜索9所花费的时间要比搜索17所花费的时间要多，由于我们的输入或者经过我们插入或者删除操作，二叉树失去平衡，造成搜索效率降低。<br>所以我们有了一个平衡二叉树的概念，所谓的平衡不是指的完全平衡。</p>
<p>RB-tree(红黑树)为二叉树的一种。</p>
<p>3.7.2 set常用API<br>3.7.2.1 set构造函数<br>set<T> st;&#x2F;&#x2F;set默认构造函数：<br>mulitset<T> mst; &#x2F;&#x2F;multiset默认构造函数:<br>set(const set &amp;st);&#x2F;&#x2F;拷贝构造函数<br>3.7.2.2 set赋值操作<br>set&amp; operator&#x3D;(const set &amp;st);&#x2F;&#x2F;重载等号操作符<br>swap(st);&#x2F;&#x2F;交换两个集合容器<br>3.7.2.3 set大小操作<br>size();&#x2F;&#x2F;返回容器中元素的数目<br>empty();&#x2F;&#x2F;判断容器是否为空</p>
<p>3.7.2.4 set插入和删除操作<br>insert(elem);&#x2F;&#x2F;在容器中插入元素。<br>clear();&#x2F;&#x2F;清除所有元素<br>erase(pos);&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。<br>erase(beg, end);&#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。<br>erase(elem);&#x2F;&#x2F;删除容器中值为elem的元素。</p>
<p>3.7.2.5 set查找操作<br>find(key);&#x2F;&#x2F;查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();<br>count(key);&#x2F;&#x2F;查找键key的元素个数<br>lower_bound(keyElem);&#x2F;&#x2F;返回第一个key&gt;&#x3D;keyElem元素的迭代器。<br>upper_bound(keyElem);&#x2F;&#x2F;返回第一个key&gt;keyElem元素的迭代器。<br>equal_range(keyElem);&#x2F;&#x2F;返回容器中key与keyElem相等的上下限的两个迭代器。</p>
<p>set的返回值   指定set排序规则:</p>
<p>&#x2F;&#x2F;插入操作返回值<br>void test01(){</p>
<p>set<int> s;<br>pair&lt;set<int>::iterator,bool&gt; ret &#x3D; s.insert(10);<br>if (ret.second){<br>cout &lt;&lt; “插入成功:” &lt;&lt; *ret.first &lt;&lt; endl;<br>}<br>else{<br>cout &lt;&lt; “插入失败:” &lt;&lt; *ret.first &lt;&lt; endl;<br>}</p>
<p>ret &#x3D; s.insert(10);<br>if(ret.second){<br>cout &lt;&lt; “插入成功:” &lt;&lt; *ret.first &lt;&lt; endl;<br>}<br>else{<br>cout &lt;&lt; “插入失败:” &lt;&lt; *ret.first &lt;&lt; endl;<br>}</p>
<p>}</p>
<p>struct MyCompare02{<br>bool operator()(int v1,int v2){<br>return v1 &gt; v2;<br>}<br>};</p>
<p>&#x2F;&#x2F;set从大到小<br>void test02(){</p>
<p>srand((unsigned int)time(NULL));<br>&#x2F;&#x2F;我们发现set容器的第二个模板参数可以设置排序规则，默认规则是less&lt;_Kty&gt;<br>set&lt;int, MyCompare02&gt; s;<br>for (int i &#x3D; 0; i &lt; 10;i++){<br>s.insert(rand() % 100);<br>}</p>
<p>for (set&lt;int, MyCompare02&gt;::iterator it &#x3D; s.begin(); it !&#x3D; s.end(); it ++){<br>cout &lt;&lt; *it &lt;&lt; “ “;<br>}<br>cout &lt;&lt; endl;<br>}</p>
<p>&#x2F;&#x2F;set容器中存放对象<br>class Person{<br>public:<br>Person(string name,int age){<br>this-&gt;mName &#x3D; name;<br>this-&gt;mAge &#x3D; age;<br>}<br>public:<br>string mName;<br>int mAge;<br>};</p>
<p>struct MyCompare03{<br>bool operator()(const Person&amp; p1,const Person&amp; p2){<br>return p1.mAge &gt; p2.mAge;<br>}<br>};</p>
<p>void test03(){</p>
<p>set&lt;Person, MyCompare03&gt; s;</p>
<p>Person p1(“aaa”, 20);<br>Person p2(“bbb”, 30);<br>Person p3(“ccc”, 40);<br>Person p4(“ddd”, 50);</p>
<p>s.insert(p1);<br>s.insert(p2);<br>s.insert(p3);<br>s.insert(p4);</p>
<p>for (set&lt;Person, MyCompare03&gt;::iterator it &#x3D; s.begin(); it !&#x3D; s.end(); it++){<br>cout &lt;&lt; “Name:” &lt;&lt; it-&gt;mName &lt;&lt; “ Age:” &lt;&lt; it-&gt;mAge &lt;&lt; endl;<br>}</p>
<p>}</p>
<p>3.7.3 对组(pair)<br>对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问。<br>类模板：template &lt;class T1, class T2&gt; struct pair.<br>如何创建对组?<br>&#x2F;&#x2F;第一种方法创建一个对组<br>pair&lt;string, int&gt; pair1(string(“name”), 20);<br>cout &lt;&lt; pair1.first &lt;&lt; endl; &#x2F;&#x2F;访问pair第一个值<br>cout &lt;&lt; pair1.second &lt;&lt; endl;&#x2F;&#x2F;访问pair第二个值<br>&#x2F;&#x2F;第二种<br>pair&lt;string, int&gt; pair2 &#x3D; make_pair(“name”, 30);<br>cout &lt;&lt; pair2.first &lt;&lt; endl;<br>cout &lt;&lt; pair2.second &lt;&lt; endl;<br>&#x2F;&#x2F;pair&#x3D;赋值<br>pair&lt;string, int&gt; pair3 &#x3D; pair2;<br>cout &lt;&lt; pair3.first &lt;&lt; endl;<br>cout &lt;&lt; pair3.second &lt;&lt; endl;</p>
<p>3.8 map&#x2F;multimap容器<br>3.8.1 map&#x2F;multimap基本概念<br>Map的特性是，所有元素都会根据元素的键值自动排序。Map所有的元素都是pair,同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。<br>我们可以通过map的迭代器改变map的键值吗？答案是不行，因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织。如果想要修改元素的实值，那么是可以的。<br>Map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。<br>Multimap和map的操作类似，唯一区别multimap键值可重复。<br>Map和multimap都是以红黑树为底层实现机制。<br>3.8.2 map&#x2F;multimap常用API<br>3.8.2.1 map构造函数<br>map&lt;T1, T2&gt; mapTT;&#x2F;&#x2F;map默认构造函数:<br>map(const map &amp;mp);&#x2F;&#x2F;拷贝构造函数</p>
<p>3.8.2.2 map赋值操作<br>map&amp; operator&#x3D;(const map &amp;mp);&#x2F;&#x2F;重载等号操作符<br>swap(mp);&#x2F;&#x2F;交换两个集合容器</p>
<p>3.8.2.3 map大小操作<br>size();&#x2F;&#x2F;返回容器中元素的数目<br>empty();&#x2F;&#x2F;判断容器是否为空<br>3.8.2.4 map插入数据元素操作<br>map.insert(…); &#x2F;&#x2F;往容器插入元素，返回pair&lt;iterator,bool&gt;<br>map&lt;int, string&gt; mapStu;<br>&#x2F;&#x2F; 第一种 通过pair的方式插入对象<br>mapStu.insert(pair&lt;int, string&gt;(3, “小张”));<br>&#x2F;&#x2F; 第二种 通过pair的方式插入对象<br>mapStu.inset(make_pair(-1, “校长”));<br>&#x2F;&#x2F; 第三种 通过value_type的方式插入对象<br>mapStu.insert(map&lt;int, string&gt;::value_type(1, “小李”));<br>&#x2F;&#x2F; 第四种 通过数组的方式插入值<br>mapStu[3] &#x3D; “小刘”;<br>mapStu[5] &#x3D; “小王”;<br>3.8.2.5 map删除操作<br>clear();&#x2F;&#x2F;删除所有元素<br>erase(pos);&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。<br>erase(beg,end);&#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。<br>erase(keyElem);&#x2F;&#x2F;删除容器中key为keyElem的对组。<br>3.8.2.6 map查找操作<br>find(key);&#x2F;&#x2F;查找键key是否存在,若存在，返回该键的元素的迭代器；&#x2F;若不存在，返回map.end();<br>count(keyElem);&#x2F;&#x2F;返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。<br>lower_bound(keyElem);&#x2F;&#x2F;返回第一个key&gt;&#x3D;keyElem元素的迭代器。<br>upper_bound(keyElem);&#x2F;&#x2F;返回第一个key&gt;keyElem元素的迭代器。<br>equal_range(keyElem);&#x2F;&#x2F;返回容器中key与keyElem相等的上下限的两个迭代器。<br>3.8.3 multimap案例<br>&#x2F;&#x2F;公司今天招聘了5个员工，5名员工进入公司之后，需要指派员工在那个部门工作<br>&#x2F;&#x2F;人员信息有: 姓名 年龄 电话 工资等组成<br>&#x2F;&#x2F;通过Multimap进行信息的插入 保存 显示<br>&#x2F;&#x2F;分部门显示员工信息 显示全部员工信息</p>
<p>#define _CRT_SECURE_NO_WARNINGS</p>
<p>#include<iostream><br>#include<map><br>#include<string><br>#include<vector><br>using namespace std;</p>
<p>&#x2F;&#x2F;multimap 案例<br>&#x2F;&#x2F;公司今天招聘了 5 个员工，5 名员工进入公司之后，需要指派员工在那个部门工作<br>&#x2F;&#x2F;人员信息有: 姓名 年龄 电话 工资等组成<br>&#x2F;&#x2F;通过 Multimap 进行信息的插入 保存 显示<br>&#x2F;&#x2F;分部门显示员工信息 显示全部员工信息</p>
<p>#define SALE_DEPATMENT 1 &#x2F;&#x2F;销售部门<br>#define DEVELOP_DEPATMENT 2 &#x2F;&#x2F;研发部门<br>#define FINACIAL_DEPATMENT 3 &#x2F;&#x2F;财务部门<br>#define ALL_DEPATMENT 4 &#x2F;&#x2F;所有部门</p>
<p>&#x2F;&#x2F;员工类<br>class person{<br>public:<br>string name; &#x2F;&#x2F;员工姓名<br>int age; &#x2F;&#x2F;员工年龄<br>double salary; &#x2F;&#x2F;员工工资<br>string tele; &#x2F;&#x2F;员工电话<br>};</p>
<p>&#x2F;&#x2F;创建5个员工<br>void CreatePerson(vector<person>&amp; vlist){</p>
<p>string seed &#x3D; “ABCDE”;<br>for (int i &#x3D; 0; i &lt; 5; i++){<br>person p;<br>p.name &#x3D; “员工”;<br>p.name +&#x3D; seed[i];<br>p.age &#x3D; rand() % 30 + 20;<br>p.salary &#x3D; rand() % 20000 + 10000;<br>p.tele &#x3D; “010-8888888”;<br>vlist.push_back(p);<br>}</p>
<p>}</p>
<p>&#x2F;&#x2F;5名员工分配到不同的部门<br>void PersonByGroup(vector<person>&amp; vlist, multimap&lt;int, person&gt;&amp; plist){</p>
<p>int operate &#x3D; -1; &#x2F;&#x2F;用户的操作</p>
<p>for (vector<person>::iterator it &#x3D; vlist.begin(); it !&#x3D; vlist.end(); it++){</p>
<p>cout &lt;&lt; “当前员工信息:” &lt;&lt; endl;<br>cout &lt;&lt; “姓名：” &lt;&lt; it-&gt;name &lt;&lt; “ 年龄:” &lt;&lt; it-&gt;age &lt;&lt; “ 工资:” &lt;&lt; it-&gt;salary &lt;&lt; “ 电话：” &lt;&lt; it-&gt;tele &lt;&lt; endl;<br>cout &lt;&lt; “请对该员工进行部门分配(1 销售部门, 2 研发部门, 3 财务部门):” &lt;&lt; endl;<br>scanf(“%d”, &amp;operate);</p>
<p>while (true){</p>
<p>if (operate &#x3D;&#x3D; SALE_DEPATMENT){  &#x2F;&#x2F;将该员工加入到销售部门<br>plist.insert(make_pair(SALE_DEPATMENT, *it));<br>break;<br>}<br>else if (operate &#x3D;&#x3D; DEVELOP_DEPATMENT){<br>plist.insert(make_pair(DEVELOP_DEPATMENT, *it));<br>break;<br>}<br>else if (operate &#x3D;&#x3D; FINACIAL_DEPATMENT){<br>plist.insert(make_pair(FINACIAL_DEPATMENT, *it));<br>break;<br>}<br>else{<br>cout &lt;&lt; “您的输入有误，请重新输入(1 销售部门, 2 研发部门, 3 财务部门):” &lt;&lt; endl;<br>scanf(“%d”, &amp;operate);<br>}</p>
<p>}</p>
<p>}<br>cout &lt;&lt; “员工部门分配完毕!” &lt;&lt; endl;<br>cout &lt;&lt; “***********************************************************” &lt;&lt; endl;</p>
<p>}</p>
<p>&#x2F;&#x2F;打印员工信息<br>void printList(multimap&lt;int, person&gt;&amp; plist, int myoperate){</p>
<p>if (myoperate &#x3D;&#x3D; ALL_DEPATMENT){<br>for (multimap&lt;int, person&gt;::iterator it &#x3D; plist.begin(); it !&#x3D; plist.end(); it++){<br>cout &lt;&lt; “姓名：” &lt;&lt; it-&gt;second.name &lt;&lt; “ 年龄:” &lt;&lt; it-&gt;second.age &lt;&lt; “ 工资:” &lt;&lt; it-&gt;second.salary &lt;&lt; “ 电话：” &lt;&lt; it-&gt;second.tele &lt;&lt; endl;<br>}<br>return;<br>}</p>
<p>multimap&lt;int, person&gt;::iterator it &#x3D; plist.find(myoperate);<br>int depatCount &#x3D; plist.count(myoperate);<br>int num &#x3D; 0;<br>if (it !&#x3D; plist.end()){<br>while (it !&#x3D; plist.end() &amp;&amp; num &lt; depatCount){<br>cout &lt;&lt; “姓名：” &lt;&lt; it-&gt;second.name &lt;&lt; “ 年龄:” &lt;&lt; it-&gt;second.age &lt;&lt; “ 工资:” &lt;&lt; it-&gt;second.salary &lt;&lt; “ 电话：” &lt;&lt; it-&gt;second.tele &lt;&lt; endl;<br>it++;<br>num++;<br>}<br>}<br>}</p>
<p>&#x2F;&#x2F;根据用户操作显示不同部门的人员列表<br>void ShowPersonList(multimap&lt;int, person&gt;&amp; plist, int myoperate){</p>
<p>switch (myoperate)<br>{<br>case SALE_DEPATMENT:<br>printList(plist, SALE_DEPATMENT);<br>break;<br>case DEVELOP_DEPATMENT:<br>printList(plist, DEVELOP_DEPATMENT);<br>break;<br>case FINACIAL_DEPATMENT:<br>printList(plist, FINACIAL_DEPATMENT);<br>break;<br>case ALL_DEPATMENT:<br>printList(plist, ALL_DEPATMENT);<br>break;<br>}<br>}</p>
<p>&#x2F;&#x2F;用户操作菜单<br>void PersonMenue(multimap&lt;int, person&gt;&amp; plist){</p>
<p>int flag &#x3D; -1;<br>int isexit &#x3D; 0;<br>while (true){<br>cout &lt;&lt; “请输入您的操作((1 销售部门, 2 研发部门, 3 财务部门, 4 所有部门, 0退出)：” &lt;&lt; endl;<br>scanf(“%d”, &amp;flag);</p>
<p>switch (flag)<br>{<br>case SALE_DEPATMENT:<br>ShowPersonList(plist, SALE_DEPATMENT);<br>break;<br>case DEVELOP_DEPATMENT:<br>ShowPersonList(plist, DEVELOP_DEPATMENT);<br>break;<br>case FINACIAL_DEPATMENT:<br>ShowPersonList(plist, FINACIAL_DEPATMENT);<br>break;<br>case ALL_DEPATMENT:<br>ShowPersonList(plist, ALL_DEPATMENT);<br>break;<br>case 0:<br>isexit &#x3D; 1;<br>break;<br>default:<br>cout &lt;&lt; “您的输入有误，请重新输入!” &lt;&lt; endl;<br>break;<br>}</p>
<p>if (isexit &#x3D;&#x3D; 1){<br>break;<br>}<br>}</p>
<p>}</p>
<p>int main(){</p>
<p>vector<person>  vlist; &#x2F;&#x2F;创建的5个员工 未分组<br>multimap&lt;int, person&gt; plist; &#x2F;&#x2F;保存分组后员工信息</p>
<p>&#x2F;&#x2F;创建5个员工<br>CreatePerson(vlist);<br>&#x2F;&#x2F;5名员工分配到不同的部门<br>PersonByGroup(vlist, plist);<br>&#x2F;&#x2F;根据用户输入显示不同部门员工信息列表 或者 显示全部员工的信息列表<br>PersonMenue(plist);</p>
<p>system(“pause”);<br>return EXIT_SUCCESS;<br>}</p>
<p>3.9 STL容器使用时机<br>vector  deque list  set multiset  map multimap<br>典型内存结构 单端数组  双端数组 双向链表  二叉树 二叉树  二叉树 二叉树<br>可随机存取 是  是 否 否 否 对key而言：不是 否<br>元素搜寻速度 慢  慢 非常慢 快 快 对key而言：快 对key而言：快<br>元素安插移除 尾端  头尾两端 任何位置  - - - -</p>
<p> vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。<br> deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。<br>   vector与deque的比较：<br> 一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置 却是不固定的。<br>  二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。<br>  三：deque支持头部的快速插入与快速移除，这是deque的优点。<br> list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。<br> set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。<br> map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。<br>\4. 常用算法<br>4.1 函数对象<br>重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象，也叫仿函数(functor),其实就是重载“()”操作符，使得类对象可以像函数那样调用。<br>注意:<br>1.函数对象(仿函数)是一个类，不是一个函数。<br>2.函数对象(仿函数)重载了”() ”操作符使得它可以像函数一样调用。<br>分类:假定某个类有一个重载的operator()，而且重载的operator()要求获取一个参数，我们就将这个类称为“一元仿函数”（unary functor）；相反，如果重载的operator()要求获取两个参数，就将这个类称为“二元仿函数”（binary functor）。<br>函数对象的作用主要是什么？STL提供的算法往往都有两个版本，其中一个版本表现出最常用的某种运算，另一版本则允许用户通过template参数的形式来指定所要采取的策略。</p>
<p>&#x2F;&#x2F;函数对象是重载了函数调用符号的类<br>class MyPrint<br>{<br>public:<br>MyPrint()<br>{<br>m_Num &#x3D; 0;<br>}<br>int m_Num;</p>
<p>public:<br>void operator() (int num)<br>{<br>cout &lt;&lt; num &lt;&lt; endl;<br>m_Num++;<br>}<br>};</p>
<p>&#x2F;&#x2F;函数对象<br>&#x2F;&#x2F;重载了()操作符的类实例化的对象，可以像普通函数那样调用,可以有参数 ，可以有返回值<br>void test01()<br>{<br>MyPrint myPrint;<br>myPrint(20);</p>
<p>}<br>&#x2F;&#x2F; 函数对象超出了普通函数的概念，可以保存函数的调用状态<br>void test02()<br>{<br>MyPrint myPrint;<br>myPrint(20);<br>myPrint(20);<br>myPrint(20);<br>cout &lt;&lt; myPrint.m_Num &lt;&lt; endl;<br>}</p>
<p>void doBusiness(MyPrint print,int num)<br>{<br>print(num);<br>}</p>
<p>&#x2F;&#x2F;函数对象作为参数<br>void test03()<br>{<br>&#x2F;&#x2F;参数1：匿名函数对象<br>doBusiness(MyPrint(),30);<br>}</p>
<p>总结：<br>1、函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题。<br>2、函数对象超出普通函数的概念，函数对象可以有自己的状态<br>3、函数对象可内联编译，性能好。用函数指针几乎不可能<br>4、模版函数对象使函数对象具有通用性，这也是它的优势之一</p>
<p>4.2 谓词<br>谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数)。如果operator接受一个参数，那么叫做一元谓词,如果接受两个参数，那么叫做二元谓词，谓词可作为一个判断式。<br>class GreaterThenFive<br>{<br>public:<br>bool operator()(int num)<br>{<br>return num &gt; 5;<br>}</p>
<p>};<br>&#x2F;&#x2F;一元谓词<br>void test01()<br>{<br>vector<int> v;<br>for (int i &#x3D; 0; i &lt; 10;i ++)<br>{<br>v.push_back(i);<br>}</p>
<p>vector<int>::iterator it &#x3D;  find_if(v.begin(), v.end(), GreaterThenFive());<br>if (it &#x3D;&#x3D; v.end())<br>{<br>cout &lt;&lt; “没有找到” &lt;&lt; endl;<br>}<br>else<br>{<br>cout &lt;&lt; “找到了: “ &lt;&lt; *it &lt;&lt; endl;<br>}<br>}</p>
<p>&#x2F;&#x2F;二元谓词<br>class MyCompare<br>{<br>public:<br>bool operator()(int num1, int num2)<br>{<br>return num1 &gt; num2;<br>}<br>};</p>
<p>void test02()<br>{<br>vector<int> v;<br>v.push_back(10);<br>v.push_back(40);<br>v.push_back(20);<br>v.push_back(90);<br>v.push_back(60);</p>
<p>&#x2F;&#x2F;默认从小到大<br>sort(v.begin(), v.end());<br>for (vector<int>::iterator it &#x3D; v.begin(); it !&#x3D; v.end();it++)<br>{<br>cout &lt;&lt; *it &lt;&lt; “ “;<br>}<br>cout &lt;&lt; endl;<br>cout &lt;&lt; “—————————-“ &lt;&lt; endl;<br>&#x2F;&#x2F;使用函数对象改变算法策略，排序从大到小<br>sort(v.begin(), v.end(),MyCompare());<br>for (vector<int>::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++)<br>{<br>cout &lt;&lt; *it &lt;&lt; “ “;<br>}<br>cout &lt;&lt; endl;<br>}</p>
<p>4.3 内建函数对象<br>STL内建了一些函数对象。分为:算数类函数对象,关系运算类函数对象，逻辑运算类仿函数。这些仿函数所产生的对象，用法和一般函数完全相同，当然我们还可以产生无名的临时对象来履行函数功能。使用内建函数对象，需要引入头文件 #include<functional>。</p>
<p> 6个算数类函数对象,除了negate是一元运算，其他都是二元运算。<br>template<class T> T plus<T>&#x2F;&#x2F;加法仿函数<br>template<class T> T minus<T>&#x2F;&#x2F;减法仿函数<br>template<class T> T multiplies<T>&#x2F;&#x2F;乘法仿函数<br>template<class T> T divides<T>&#x2F;&#x2F;除法仿函数<br>template<class T> T modulus<T>&#x2F;&#x2F;取模仿函数<br>template<class T> T negate<T>&#x2F;&#x2F;取反仿函数</p>
<p> 6个关系运算类函数对象,每一种都是二元运算。<br>template<class T> bool equal_to<T>&#x2F;&#x2F;等于<br>template<class T> bool not_equal_to<T>&#x2F;&#x2F;不等于<br>template<class T> bool greater<T>&#x2F;&#x2F;大于<br>template<class T> bool greater_equal<T>&#x2F;&#x2F;大于等于<br>template<class T> bool less<T>&#x2F;&#x2F;小于<br>template<class T> bool less_equal<T>&#x2F;&#x2F;小于等于</p>
<p> 逻辑运算类运算函数,not为一元运算，其余为二元运算。<br>template<class T> bool logical_and<T>&#x2F;&#x2F;逻辑与<br>template<class T> bool logical_or<T>&#x2F;&#x2F;逻辑或<br>template<class T> bool logical_not<T>&#x2F;&#x2F;逻辑非</p>
<p>内建函数对象举例:<br>&#x2F;&#x2F;取反仿函数<br>void test01()<br>{<br>negate<int> n;<br>cout &lt;&lt; n(50) &lt;&lt; endl;<br>}</p>
<p>&#x2F;&#x2F;加法仿函数<br>void test02()<br>{<br>plus<int> p;<br>cout &lt;&lt; p(10, 20) &lt;&lt; endl;<br>}</p>
<p>&#x2F;&#x2F;大于仿函数<br>void test03()<br>{<br>vector<int> v;<br>srand((unsigned int)time(NULL));<br>for (int i &#x3D; 0; i &lt; 10; i++){<br>v.push_back(rand() % 100);<br>}</p>
<p>for (vector<int>::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++){<br>cout &lt;&lt; *it &lt;&lt; “ “;<br>}<br>cout &lt;&lt; endl;<br>sort(v.begin(), v.end(), greater<int>());</p>
<p>for (vector<int>::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++){<br>cout &lt;&lt; *it &lt;&lt; “ “;<br>}<br>cout &lt;&lt; endl;</p>
<p>}</p>
<p>3.1.4 函数对象适配器<br>&#x2F;&#x2F;函数适配器bind1st bind2nd<br>&#x2F;&#x2F;现在我有这个需求 在遍历容器的时候，我希望将容器中的值全部加上100之后显示出来，怎么做？<br>&#x2F;&#x2F;我们直接给函数对象绑定参数 编译阶段就会报错<br>&#x2F;&#x2F;for_each(v.begin(), v.end(), bind2nd(myprint(),100));<br>&#x2F;&#x2F;如果我们想使用绑定适配器,需要我们自己的函数对象继承binary_function 或者 unary_function<br>&#x2F;&#x2F;根据我们函数对象是一元函数对象 还是二元函数对象<br>class MyPrint :public binary_function&lt;int,int,void&gt;<br>{<br>public:<br>void operator()(int v1,int v2) const<br>{<br>cout &lt;&lt; “v1 &#x3D; : “ &lt;&lt; v1 &lt;&lt; “ v2 &#x3D; :” &lt;&lt;v2  &lt;&lt; “ v1+v2 &#x3D; :” &lt;&lt; (v1 + v2) &lt;&lt; endl;<br>}<br>};<br>&#x2F;&#x2F;1、函数适配器<br>void test01()<br>{<br>vector<int>v;<br>for (int i &#x3D; 0; i &lt; 10; i++)<br>{<br>v.push_back(i);<br>}<br>cout &lt;&lt; “请输入起始值：” &lt;&lt; endl;<br>int x;<br>cin &gt;&gt; x;</p>
<p>for_each(v.begin(), v.end(), bind1st(MyPrint(), x));<br>&#x2F;&#x2F;for_each(v.begin(), v.end(), bind2nd( MyPrint(),x ));<br>}<br>&#x2F;&#x2F;总结：  bind1st和bind2nd区别?<br>&#x2F;&#x2F;bind1st ： 将参数绑定为函数对象的第一个参数<br>&#x2F;&#x2F;bind2nd ： 将参数绑定为函数对象的第二个参数<br>&#x2F;&#x2F;bind1st bind2nd将二元函数对象转为一元函数对象</p>
<p>class GreaterThenFive:public unary_function&lt;int,bool&gt;<br>{<br>public:<br>bool operator ()(int v) const<br>{<br>return v &gt; 5;<br>}<br>};</p>
<p>&#x2F;&#x2F;2、取反适配器<br>void test02()<br>{<br>vector <int> v;<br>for (int i &#x3D; 0; i &lt; 10;i++)<br>{<br>v.push_back(i);<br>}</p>
<p>&#x2F;&#x2F; vector<int>::iterator it &#x3D;  find_if(v.begin(), v.end(), GreaterThenFive()); &#x2F;&#x2F;返回第一个大于5的迭代器<br>&#x2F;&#x2F; vector<int>::iterator it &#x3D; find_if(v.begin(), v.end(),  not1(GreaterThenFive())); &#x2F;&#x2F;返回第一个小于5迭代器<br>&#x2F;&#x2F;自定义输入<br>vector<int>::iterator it &#x3D; find_if(v.begin(), v.end(), not1 ( bind2nd(greater<int>(),5)));<br>if (it &#x3D;&#x3D; v.end())<br>{<br>cout &lt;&lt; “没找到” &lt;&lt; endl;<br>}<br>else<br>{<br>cout &lt;&lt; “找到” &lt;&lt; *it &lt;&lt; endl;<br>}</p>
<p>&#x2F;&#x2F;排序  二元函数对象<br>sort(v.begin(), v.end(), not2(less<int>()));<br>for_each(v.begin(), v.end(), [](int val){cout &lt;&lt; val &lt;&lt; “ “; });</p>
<p>}<br>&#x2F;&#x2F;not1 对一元函数对象取反<br>&#x2F;&#x2F;not2 对二元函数对象取反</p>
<p>void MyPrint03(int v,int v2)<br>{<br>cout &lt;&lt; v + v2&lt;&lt; “ “;<br>}</p>
<p>&#x2F;&#x2F;3、函数指针适配器  ptr_fun<br>void test03()<br>{<br>vector <int> v;<br>for (int i &#x3D; 0; i &lt; 10; i++)<br>{<br>v.push_back(i);<br>}<br>&#x2F;&#x2F; ptr_fun( )把一个普通的函数指针适配成函数对象<br>for_each(v.begin(), v.end(), bind2nd( ptr_fun( MyPrint03 ), 100));<br>}</p>
<p>&#x2F;&#x2F;4、成员函数适配器<br>class Person<br>{<br>public:<br>Person(string name, int age)<br>{<br>m_Name &#x3D; name;<br>m_Age &#x3D; age;<br>}</p>
<p>&#x2F;&#x2F;打印函数<br>void ShowPerson(){<br>cout &lt;&lt; “成员函数:” &lt;&lt; “Name:” &lt;&lt; m_Name &lt;&lt; “ Age:” &lt;&lt; m_Age &lt;&lt; endl;<br>}<br>void Plus100()<br>{<br>m_Age +&#x3D; 100;<br>}<br>public:<br>string m_Name;<br>int m_Age;<br>};</p>
<p>void MyPrint04(Person &amp;p)<br>{<br>cout &lt;&lt; “姓名：” &lt;&lt;  p.m_Name &lt;&lt; “ 年龄：” &lt;&lt; p.m_Age &lt;&lt; endl;</p>
<p>};</p>
<p>void test04()<br>{<br>vector <Person>v;<br>Person p1(“aaa”, 10);<br>Person p2(“bbb”, 20);<br>Person p3(“ccc”, 30);<br>Person p4(“ddd”, 40);<br>v.push_back(p1);<br>v.push_back(p2);<br>v.push_back(p3);<br>v.push_back(p4);</p>
<p>&#x2F;&#x2F;for_each(v.begin(), v.end(), MyPrint04);<br>&#x2F;&#x2F;利用 mem_fun_ref 将Person内部成员函数适配<br>for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::ShowPerson));<br>&#x2F;&#x2F; for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::Plus100));<br>&#x2F;&#x2F; for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::ShowPerson));<br>}</p>
<p>void test05(){</p>
<p>vector&lt;Person*&gt; v1;<br>&#x2F;&#x2F;创建数据<br>Person p1(“aaa”, 10);<br>Person p2(“bbb”, 20);<br>Person p3(“ccc”, 30);<br>Person p4(“ddd”, 40);</p>
<p>v1.push_back(&amp;p1);<br>v1.push_back(&amp;p2);<br>v1.push_back(&amp;p3);<br>v1.push_back(&amp;p4);</p>
<p>for_each(v1.begin(), v1.end(), mem_fun(&amp;Person::ShowPerson));<br>}</p>
<p>&#x2F;&#x2F;如果容器存放的是对象指针，  那么用mem_fun<br>&#x2F;&#x2F;如果容器中存放的是对象实体，那么用mem_fun_ref</p>
<p>4.2 算法概述<br>算法主要是由头文件<algorithm> <functional> <numeric>组成。<br><algorithm>是所有STL头文件中最大的一个,其中常用的功能涉及到比较，交换，查找,遍历，复制，修改，反转，排序，合并等…<br><numeric>体积很小，只包括在几个序列容器上进行的简单运算的模板函数.<br><functional> 定义了一些模板类,用以声明函数对象。<br>4.3 常用遍历算法<br>&#x2F;*<br>  遍历算法 遍历容器元素<br>@param beg 开始迭代器<br>@param end 结束迭代器<br>@param _callback  函数回调或者函数对象<br>@return 函数对象<br><em>&#x2F;<br>for_each(iterator beg, iterator end, _callback);<br>&#x2F;</em><br>transform算法 将指定容器区间元素搬运到另一容器中<br>注意 : transform 不会给目标容器分配内存，所以需要我们提前分配好内存<br>@param beg1 源容器开始迭代器<br>@param end1 源容器结束迭代器<br>@param beg2 目标容器开始迭代器<br>@param _cakkback 回调函数或者函数对象<br>@return 返回目标容器迭代器<br>*&#x2F;<br>transform(iterator beg1, iterator end1, iterator beg2, _callbakc)</p>
<p>for_each:<br>&#x2F;*</p>
<p>template&lt;class _InIt,class _Fn1&gt; inline<br>void for_each(_InIt _First, _InIt _Last, _Fn1 _Func)<br>{<br>for (; _First !&#x3D; _Last; ++_First)<br>_Func(*_First);<br>}</p>
<p>*&#x2F;</p>
<p>&#x2F;&#x2F;普通函数<br>void print01(int val){<br>cout &lt;&lt; val &lt;&lt; “ “;<br>}<br>&#x2F;&#x2F;函数对象<br>struct print001{<br>void operator()(int val){<br>cout &lt;&lt; val &lt;&lt; “ “;<br>}<br>};</p>
<p>&#x2F;&#x2F;for_each算法基本用法<br>void test01(){</p>
<p>vector<int> v;<br>for (int i &#x3D; 0; i &lt; 10;i++){<br>v.push_back(i);<br>}</p>
<p>&#x2F;&#x2F;遍历算法<br>for_each(v.begin(), v.end(), print01);<br>cout &lt;&lt; endl;</p>
<p>for_each(v.begin(), v.end(), print001());<br>cout &lt;&lt; endl;</p>
<p>}</p>
<p>struct print02{<br>print02(){<br>mCount &#x3D; 0;<br>}<br>void operator()(int val){<br>cout &lt;&lt; val &lt;&lt; “ “;<br>mCount++;<br>}<br>int mCount;<br>};</p>
<p>&#x2F;&#x2F;for_each返回值<br>void test02(){</p>
<p>vector<int> v;<br>for (int i &#x3D; 0; i &lt; 10; i++){<br>v.push_back(i);<br>}</p>
<p>print02 p &#x3D; for_each(v.begin(), v.end(), print02());<br>cout &lt;&lt; endl;<br>cout &lt;&lt; p.mCount &lt;&lt; endl;<br>}</p>
<p>struct print03 : public binary_function&lt;int, int, void&gt;{<br>void operator()(int val,int bindParam) const{<br>cout &lt;&lt; val + bindParam &lt;&lt; “ “;<br>}<br>};</p>
<p>&#x2F;&#x2F;for_each绑定参数输出<br>void test03(){</p>
<p>vector<int> v;<br>for (int i &#x3D; 0; i &lt; 10; i++){<br>v.push_back(i);<br>}</p>
<p>for_each(v.begin(), v.end(), bind2nd(print03(),100));<br>}</p>
<p>transform:<br>&#x2F;&#x2F;transform 将一个容器中的值搬运到另一个容器中<br>&#x2F;*<br>template&lt;class _InIt, class _OutIt, class _Fn1&gt; inline<br>_OutIt _Transform(_InIt _First, _InIt _Last,_OutIt _Dest, _Fn1 _Func)<br>{ </p>
<p>for (; _First !&#x3D; _Last; ++_First, ++_Dest)<br><em>_Dest &#x3D; _Func(</em>_First);<br>return (_Dest);<br>}</p>
<p>template&lt;class _InIt1,class _InIt2,class _OutIt,class _Fn2&gt; inline<br>_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1,_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)<br>{<br>for (; _First1 !&#x3D; _Last1; ++_First1, ++_First2, ++_Dest)<br><em>_Dest &#x3D; _Func(</em>_First1, *_First2);<br>return (_Dest);<br>}<br>*&#x2F;</p>
<p>struct transformTest01{<br>int operator()(int val){<br>return val + 100;<br>}<br>};<br>struct print01{<br>void operator()(int val){<br>cout &lt;&lt; val &lt;&lt; “ “;<br>}<br>};<br>void test01(){</p>
<p>vector<int> vSource;<br>for (int i &#x3D; 0; i &lt; 10;i ++){<br>vSource.push_back(i + 1);<br>}</p>
<p>&#x2F;&#x2F;目标容器<br>vector<int> vTarget;<br>&#x2F;&#x2F;给vTarget开辟空间<br>vTarget.resize(vSource.size());<br>&#x2F;&#x2F;将vSource中的元素搬运到vTarget<br>vector<int>::iterator it &#x3D; transform(vSource.begin(), vSource.end(), vTarget.begin(), transformTest01());<br>&#x2F;&#x2F;打印<br>for_each(vTarget.begin(), vTarget.end(), print01()); cout &lt;&lt; endl;</p>
<p>}</p>
<p>&#x2F;&#x2F;将容器1和容器2中的元素相加放入到第三个容器中<br>struct transformTest02{<br>int operator()(int v1,int v2){<br>return v1 + v2;<br>}<br>};<br>void test02(){</p>
<p>vector<int> vSource1;<br>vector<int> vSource2;<br>for (int i &#x3D; 0; i &lt; 10; i++){<br>vSource1.push_back(i + 1);<br>}</p>
<p>&#x2F;&#x2F;目标容器<br>vector<int> vTarget;<br>&#x2F;&#x2F;给vTarget开辟空间<br>vTarget.resize(vSource1.size());<br>transform(vSource1.begin(), vSource1.end(), vSource2.begin(),vTarget.begin(), transformTest02());<br>&#x2F;&#x2F;打印<br>for_each(vTarget.begin(), vTarget.end(), print01()); cout &lt;&lt; endl;<br>}</p>
<p>4.4 常用查找算法<br>&#x2F;*<br>find算法 查找元素<br>@param beg 容器开始迭代器<br>@param end 容器结束迭代器<br>@param value 查找的元素<br>@return 返回查找元素的位置<br><em>&#x2F;<br>find(iterator beg, iterator end, value)<br>&#x2F;</em><br>find_if算法 条件查找<br>@param beg 容器开始迭代器<br>@param end 容器结束迭代器<br>@param  callback 回调函数或者谓词(返回bool类型的函数对象)<br>@return bool 查找返回true 否则false<br>*&#x2F;<br>find_if(iterator beg, iterator end, _callback);</p>
<p>&#x2F;*<br>adjacent_find算法 查找相邻重复元素<br>@param beg 容器开始迭代器<br>@param end 容器结束迭代器<br>@param  _callback 回调函数或者谓词(返回bool类型的函数对象)<br>@return 返回相邻元素的第一个位置的迭代器<br><em>&#x2F;<br>adjacent_find(iterator beg, iterator end, _callback);<br>&#x2F;</em><br>binary_search算法 二分查找法<br>注意: 在无序序列中不可用<br>@param beg 容器开始迭代器<br>@param end 容器结束迭代器<br>@param value 查找的元素<br>@return bool 查找返回true 否则false<br><em>&#x2F;<br>bool binary_search(iterator beg, iterator end, value);<br>&#x2F;</em><br>count算法 统计元素出现次数<br>@param beg 容器开始迭代器<br>@param end 容器结束迭代器<br>@param  value回调函数或者谓词(返回bool类型的函数对象)<br>@return int返回元素个数<br><em>&#x2F;<br>count(iterator beg, iterator end, value);<br>&#x2F;</em><br>count算法 统计元素出现次数<br>@param beg 容器开始迭代器<br>@param end 容器结束迭代器<br>@param  callback 回调函数或者谓词(返回bool类型的函数对象)<br>@return int返回元素个数<br>*&#x2F;<br>count_if(iterator beg, iterator end, _callback);</p>
<p>4.5 常用排序算法<br>&#x2F;*<br>merge算法 容器元素合并，并存储到另一容器中<br>@param beg1 容器1开始迭代器<br>@param end1 容器1结束迭代器<br>@param beg2 容器2开始迭代器<br>@param end2 容器2结束迭代器<br>@param dest  目标容器开始迭代器<br><em>&#x2F;<br>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)<br>&#x2F;</em><br>sort算法 容器元素排序<br>注意:两个容器必须是有序的<br>@param beg 容器1开始迭代器<br>@param end 容器1结束迭代器<br>@param _callback 回调函数或者谓词(返回bool类型的函数对象)<br><em>&#x2F;<br>sort(iterator beg, iterator end, _callback)<br>&#x2F;</em><br>sort算法 对指定范围内的元素随机调整次序<br>@param beg 容器开始迭代器<br>@param end 容器结束迭代器<br><em>&#x2F;<br>random_shuffle(iterator beg, iterator end)<br>&#x2F;</em><br>reverse算法 反转指定范围的元素<br>@param beg 容器开始迭代器<br>@param end 容器结束迭代器<br>*&#x2F;<br>reverse(iterator beg, iterator end)</p>
<p>4.6 常用拷贝和替换算法<br>&#x2F;*<br>copy算法 将容器内指定范围的元素拷贝到另一容器中<br>@param beg 容器开始迭代器<br>@param end 容器结束迭代器<br>@param dest 目标起始迭代器<br><em>&#x2F;<br>copy(iterator beg, iterator end, iterator dest)<br>&#x2F;</em><br>replace算法 将容器内指定范围的旧元素修改为新元素<br>@param beg 容器开始迭代器<br>@param end 容器结束迭代器<br>@param oldvalue 旧元素<br>@param oldvalue 新元素<br><em>&#x2F;<br>replace(iterator beg, iterator end, oldvalue, newvalue)<br>&#x2F;</em><br>replace_if算法 将容器内指定范围满足条件的元素替换为新元素<br>@param beg 容器开始迭代器<br>@param end 容器结束迭代器<br>@param callback函数回调或者谓词(返回Bool类型的函数对象)<br>@param oldvalue 新元素<br><em>&#x2F;<br>replace_if(iterator beg, iterator end, _callback, newvalue)<br>&#x2F;</em><br>swap算法 互换两个容器的元素<br>@param c1容器1<br>@param c2容器2<br>*&#x2F;<br>swap(container c1, container c2)</p>
<p>4.7 常用算数生成算法<br>&#x2F;*<br>accumulate算法 计算容器元素累计总和<br>@param beg 容器开始迭代器<br>@param end 容器结束迭代器<br>@param value累加值<br><em>&#x2F;<br>accumulate(iterator beg, iterator end, value)<br>&#x2F;</em><br>fill算法 向容器中添加元素<br>@param beg 容器开始迭代器<br>@param end 容器结束迭代器<br>@param value t填充元素<br>*&#x2F;<br>fill(iterator beg, iterator end, value)</p>
<p>4.8 常用集合算法<br>&#x2F;*<br>set_intersection算法 求两个set集合的交集<br>注意:两个集合必须是有序序列<br>@param beg1 容器1开始迭代器<br>@param end1 容器1结束迭代器<br>@param beg2 容器2开始迭代器<br>@param end2 容器2结束迭代器<br>@param dest  目标容器开始迭代器<br>@return 目标容器的最后一个元素的迭代器地址<br><em>&#x2F;<br>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)<br>&#x2F;</em><br>set_union算法 求两个set集合的并集<br>注意:两个集合必须是有序序列<br>@param beg1 容器1开始迭代器<br>@param end1 容器1结束迭代器<br>@param beg2 容器2开始迭代器<br>@param end2 容器2结束迭代器<br>@param dest  目标容器开始迭代器<br>@return 目标容器的最后一个元素的迭代器地址<br><em>&#x2F;<br>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)<br>&#x2F;</em><br>set_difference算法 求两个set集合的差集<br>注意:两个集合必须是有序序列<br>@param beg1 容器1开始迭代器<br>@param end1 容器1结束迭代器<br>@param beg2 容器2开始迭代器<br>@param end2 容器2结束迭代器<br>@param dest  目标容器开始迭代器<br>@return 目标容器的最后一个元素的迭代器地址<br>*&#x2F;<br>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</p>
<p>\5. STL综合案例(学校演讲比赛)<br>演讲比赛案例</p>
<p>比赛规则：</p>
<pre><code> 某市举行一场演讲比赛（ speech_contest ），共有24个人参加。比赛共三轮，前两轮为淘汰赛，第三轮为决赛。


  比赛方式：分组比赛，每组6个人；选手每次要随机分组，进行比赛；
</code></pre>
<p>第一轮分为4个小组，每组6个人。比如编号为: 100-123.  整体进行抽签（draw）后顺序演讲。当小组演讲完后，淘汰组内排名最后的三个选手，然后继续下一个小组的比赛。</p>
<p>第二轮分为2个小组，每组6人。比赛完毕，淘汰组内排名最后的三个选手，然后继续下一个小组的比赛。</p>
<p>第三轮只剩下1组6个人，本轮为决赛，选出前三名。</p>
<p>​      比赛评分：10个评委打分，去除最低、最高分，求平均分每个选手演讲完由10个评委分别打分。该选手的最终得分是去掉一个最高分和一个最低分，求得剩下的8个成绩的平均分。选手的名次按得分降序排列。</p>
<p>用STL编程，求解这个问题<br>1） 请打印出所有选手的名字与参赛号，并以参赛号的升序排列。<br>2） 打印每一轮比赛后，小组比赛成绩和小组晋级名单</p>
<p>需求分析：<br>\1) 产生选手 （ ABCDEFGHIJKLMNOPQRSTUVWX ） 姓名、得分；选手编号</p>
<p>\2) 第1轮  选手抽签 选手比赛 查看比赛结果<br>\3) 第2轮  选手抽签 选手比赛 查看比赛结果<br>\4) 第3轮  选手抽签 选手比赛 查看比赛结果<br>实现思路：<br>需要把选手信息、选手得分信息、选手比赛抽签信息、选手的晋级信息保存在容器中，需要涉及到各个容器的选型。<br>选手可以设计一个类Speaker（姓名和得分）<br>所有选手的编号可以单独放在一个vector容器中，做抽签用</p>
<p>所有选手编号和选手信息，可以放在容器内：map&lt;int, Speaker&gt;<br>所有选手的编号名单，可以放在容器：vecter<int> v1中<br>第1轮晋级编号名单，可以放在容器vecter<int> v2中<br>第2轮晋级编号名单，可以放在容器vecter<int> v3中<br>第3轮前三名名单，可以放在容器vecter<int> v4中</p>
<p>每个小组的比赛得分信息，按照从大到小的顺序放在multimap&lt;成绩, 编号, greater<int>&gt;中</p>
<p>每个选手的得分，可以放在容器deque<int> dscore; 方便去除最低最高分.</p>
<h2 id="案例及总结"><a href="#案例及总结" class="headerlink" title="案例及总结"></a>案例及总结</h2><h3 id="判断迭代器的类型"><a href="#判断迭代器的类型" class="headerlink" title="判断迭代器的类型"></a>判断迭代器的类型</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">it++; it--;<span class="comment">//如果这两个操作都支持，就证明是双向迭代器了。</span></span><br><span class="line">it = it + <span class="number">1</span>;<span class="comment">//如果这条语句也可以执行，就可以证明这个迭代器是随机访问迭代器。</span></span><br></pre></td></tr></table></figure>



<h3 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h3><ul>
<li><p>iterator</p>
<ul>
<li>普通迭代器</li>
</ul>
</li>
<li><p>reverse_iterator</p>
<ul>
<li>反转迭代器，提供了<code>rbegin()</code>、<code>rend()</code>两个迭代器，用以反向输出容器的值。</li>
</ul>
</li>
<li><p>const_iterator</p>
<ul>
<li><p>只读迭代器，防止在不应该被修改的地方被修改了。</p>
</li>
<li><pre><code class="language-cpp">void test(const deque&lt;int&gt; &amp;d)
{
    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++)
        cout &lt;&lt; *it &lt;&lt; endl;
}
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 网址分解</span><br><span class="line"></span><br><span class="line">给定一个网址，求出网址的各个域名并输出出来。</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 小测试，将str字符串中的网址的各级域名进行分解</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">	string str = &quot;www.pixiv.net&quot;;//数据</span><br><span class="line">	int pos = 0, start = 0;//结束点，起始点</span><br><span class="line">	vector&lt;string&gt; ans;//答案数组</span><br><span class="line">	while (pos == -1)&#123;		</span><br><span class="line">		pos = str.find(&quot;.&quot;, start);//获取新的结束点。从起始点开始查找，查找第一次出现 分隔符 . 的位置作为结束标志点.</span><br><span class="line">		</span><br><span class="line">		ans.push_back(str.substr(start, pos - start));//使用子串函数，从起始点开始，连续获取 结束点 - 起始点 个字符，并将这个字符存入答案中。</span><br><span class="line">		start = pos + 1;//新的起始点等于旧的结束点的后一位。</span><br><span class="line">	&#125;</span><br><span class="line">	//将获取到的答案进行输出。</span><br><span class="line">	for (auto it : ans)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; it &lt;&lt; endl;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="string大小写转换"><a href="#string大小写转换" class="headerlink" title="string大小写转换"></a>string大小写转换</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t10</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1 = <span class="string">&quot;Hurriedlu&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s<span class="number">1.</span><span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s1[i] = <span class="built_in">toupper</span>(s1[i]);<span class="comment">//小写转大写</span></span><br><span class="line"></span><br><span class="line">		s1[i] = <span class="built_in">tolower</span>(s1[i]);<span class="comment">//大写转小写</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chaoqijiang.github.io">棨</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chaoqijiang.github.io/2023/01/08/C++STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://chaoqijiang.github.io/2023/01/08/C++STL学习笔记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://chaoqijiang.github.io" target="_blank">柊</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/protected/">protected</a><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/STL/">STL</a></div><div class="post-share"><div class="social-share" data-image="/Image/avatar.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2022/09/08/%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%B1%BB_%E6%80%9D%E6%83%B3_%E6%95%88%E7%8E%87/" title="排序的总类 思想 效率"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">排序的总类 思想 效率</div></div><div class="info-2"><div class="info-item-1">各类排序算法的介绍，包括思想、效率等。</div></div></div></a><a class="pagination-related" href="/2023/01/25/CSharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" title="C Sharp学习笔记/基础教程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C Sharp学习笔记/基础教程</div></div><div class="info-2"><div class="info-item-1">C Sharp基础教程系列，带你入门C#编程。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%9F%E6%88%90/" title="AI提示词_学习笔记生成"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-08</div><div class="info-item-2">AI提示词_学习笔记生成</div></div><div class="info-2"><div class="info-item-1">AI提示词，用于引导AI生成学习笔记，根据提示的设定，对没有基础背景背景的小白生成学习笔记。</div></div></div></a><a class="pagination-related" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E8%AF%95%E9%A2%98%E7%94%9F%E6%88%90/" title="AI提示词_试题生成"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-08</div><div class="info-item-2">AI提示词_试题生成</div></div><div class="info-2"><div class="info-item-1">AI提示词，用于根据提示信息生成对应的试题，帮助学习者检验理解深度。</div></div></div></a><a class="pagination-related" href="/2025/05/04/Armbian%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8RNDIS%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E4%B8%8A%E7%BD%91/" title="Armbian系统使用RNDIS协议进行上网"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-04</div><div class="info-item-2">Armbian系统使用RNDIS协议进行上网</div></div><div class="info-2"><div class="info-item-1">Armbian系统使用RNDIS协议进行上网</div></div></div></a><a class="pagination-related" href="/2023/12/01/Docker%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" title="Docker基础教程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-01</div><div class="info-item-2">Docker基础教程</div></div><div class="info-2"><div class="info-item-1">Docker基础教程</div></div></div></a><a class="pagination-related" href="/2023/06/07/ESP8266%E7%9B%B8%E5%85%B3%E6%A1%88%E4%BE%8B%E7%AC%94%E8%AE%B0/" title="ESP8266相关案例笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-07</div><div class="info-item-2">ESP8266相关案例笔记</div></div><div class="info-2"><div class="info-item-1">ESP8266相关案例笔记</div></div></div></a><a class="pagination-related" href="/2023/06/07/ESP8266%E5%BC%95%E8%84%9A%E8%AF%B4%E6%98%8E/" title="ESP8266引脚说明"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-07</div><div class="info-item-2">ESP8266引脚说明</div></div><div class="info-2"><div class="info-item-1">ESP8266引脚说明</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/Image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">棨</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:chaoqijiang@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E6%A6%82%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">STL概论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">STL基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.</span> <span class="toc-text">STL六大组件简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E4%BC%98%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">STL优点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">STL三大组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">常用容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E5%AE%B9%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">string容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.1.</span> <span class="toc-text">string容器基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.2.</span> <span class="toc-text">string容器常用操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#string-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">string 构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">3.1.2.1.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E5%9F%BA%E6%9C%AC%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">string基本赋值操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B"><span class="toc-number">3.1.2.2.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E5%AD%98%E5%8F%96%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">string存取字符操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-1"><span class="toc-number">3.1.2.3.1.</span> <span class="toc-text">样例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">3.1.2.3.2.</span> <span class="toc-text">区别：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.2.4.</span> <span class="toc-text">string拼接操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-2"><span class="toc-number">3.1.2.4.1.</span> <span class="toc-text">样例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="toc-number">3.1.2.4.2.</span> <span class="toc-text">string查找和替换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-3"><span class="toc-number">3.1.2.4.3.</span> <span class="toc-text">样例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">3.1.2.4.4.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.2.5.</span> <span class="toc-text">string比较操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-4"><span class="toc-number">3.1.2.5.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E5%AD%90%E4%B8%B2"><span class="toc-number">3.1.2.6.</span> <span class="toc-text">string子串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-5"><span class="toc-number">3.1.2.6.1.</span> <span class="toc-text">样例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.1.2.6.2.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.2.7.</span> <span class="toc-text">string插入和删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-6"><span class="toc-number">3.1.2.7.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E5%92%8Cc-style%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.2.8.</span> <span class="toc-text">string和c-style字符串转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA"><span class="toc-number">3.1.2.8.1.</span> <span class="toc-text">提示</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">vector容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.2.1.</span> <span class="toc-text">vector容器基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">vector迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.3.</span> <span class="toc-text">vector的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E5%B8%B8%E7%94%A8API%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.4.</span> <span class="toc-text">vector常用API操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E5%AE%B9%E9%87%8F%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">vector容量分配策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.4.2.</span> <span class="toc-text">vector构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-7"><span class="toc-number">3.2.4.2.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E5%B8%B8%E7%94%A8%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.4.3.</span> <span class="toc-text">vector常用赋值操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-8"><span class="toc-number">3.2.4.3.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.4.4.</span> <span class="toc-text">vector大小操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-9"><span class="toc-number">3.2.4.4.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.4.5.</span> <span class="toc-text">vector数据存取操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-10"><span class="toc-number">3.2.4.5.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.4.6.</span> <span class="toc-text">vector插入和删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-11"><span class="toc-number">3.2.4.6.1.</span> <span class="toc-text">样例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E5%B0%8F%E6%A1%88%E4%BE%8B"><span class="toc-number">3.2.5.</span> <span class="toc-text">vector小案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%94%A8swap%EF%BC%8C%E6%94%B6%E7%BC%A9%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">使用用swap，收缩内存空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8reserve%E9%A2%84%E7%95%99%E7%A9%BA%E9%97%B4%EF%BC%8C%E9%81%BF%E5%85%8D%E9%80%A0%E6%88%90%E6%97%B6%E9%97%B4%E6%B5%AA%E8%B4%B9"><span class="toc-number">3.2.5.2.</span> <span class="toc-text">使用reserve预留空间，避免造成时间浪费</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.2.5.3.</span> <span class="toc-text">逆序遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">deque容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.3.1.</span> <span class="toc-text">deque容器基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.2.</span> <span class="toc-text">deque容器实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque%E5%B8%B8%E7%94%A8API"><span class="toc-number">3.3.3.</span> <span class="toc-text">deque常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">deque构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-12"><span class="toc-number">3.3.3.1.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">deque赋值操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-13"><span class="toc-number">3.3.3.2.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.3.3.</span> <span class="toc-text">deque大小操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-14"><span class="toc-number">3.3.3.3.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E5%8F%8C%E7%AB%AF%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.3.4.</span> <span class="toc-text">deque双端插入和删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-15"><span class="toc-number">3.3.3.4.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-number">3.3.3.5.</span> <span class="toc-text">deque数据存取</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-16"><span class="toc-number">3.3.3.5.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.3.6.</span> <span class="toc-text">deque插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-17"><span class="toc-number">3.3.3.6.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.3.7.</span> <span class="toc-text">deque删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-18"><span class="toc-number">3.3.3.7.1.</span> <span class="toc-text">样例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stack%E5%AE%B9%E5%99%A8"><span class="toc-number">3.4.</span> <span class="toc-text">stack容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stack%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.4.1.</span> <span class="toc-text">stack容器基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-stack%E6%B2%A1%E6%9C%89%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2 stack没有迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stack%E5%B8%B8%E7%94%A8API"><span class="toc-number">3.4.3.</span> <span class="toc-text">stack常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">stack构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-19"><span class="toc-number">3.4.3.1.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">stack赋值操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-20"><span class="toc-number">3.4.3.2.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.3.3.</span> <span class="toc-text">stack数据存取操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-21"><span class="toc-number">3.4.3.3.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.3.4.</span> <span class="toc-text">stack大小操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-22"><span class="toc-number">3.4.3.4.1.</span> <span class="toc-text">样例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#queue%E5%AE%B9%E5%99%A8"><span class="toc-number">3.5.</span> <span class="toc-text">queue容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#queue%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.5.1.</span> <span class="toc-text">queue容器基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue%E6%B2%A1%E6%9C%89%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.5.2.</span> <span class="toc-text">queue没有迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue%E5%B8%B8%E7%94%A8API"><span class="toc-number">3.5.3.</span> <span class="toc-text">queue常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">queue构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-23"><span class="toc-number">3.5.3.1.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E5%AD%98%E5%8F%96%E3%80%81%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">queue存取、插入和删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-24"><span class="toc-number">3.5.3.2.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.5.3.3.</span> <span class="toc-text">queue赋值操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-25"><span class="toc-number">3.5.3.3.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">3.5.3.4.</span> <span class="toc-text">queue大小操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-26"><span class="toc-number">3.5.3.4.1.</span> <span class="toc-text">样例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list%E5%AE%B9%E5%99%A8"><span class="toc-number">3.6.</span> <span class="toc-text">list容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.6.1.</span> <span class="toc-text">list容器基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.6.2.</span> <span class="toc-text">list容器的迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E5%AE%B9%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.6.3.</span> <span class="toc-text">list容器的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E5%B8%B8%E7%94%A8API"><span class="toc-number">3.6.4.</span> <span class="toc-text">list常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.4.1.</span> <span class="toc-text">list构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">3.6.4.2.</span> <span class="toc-text">list数据元素插入和删除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">3.6.4.3.</span> <span class="toc-text">list大小操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.6.4.4.</span> <span class="toc-text">list赋值操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%8F%96"><span class="toc-number">3.6.4.5.</span> <span class="toc-text">list数据的存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E5%8F%8D%E8%BD%AC%E6%8E%92%E5%BA%8F"><span class="toc-number">3.6.4.6.</span> <span class="toc-text">list反转排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%8F%8A%E6%80%BB%E7%BB%93"><span class="toc-number">3.7.</span> <span class="toc-text">案例及总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.7.1.</span> <span class="toc-text">判断迭代器的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.7.2.</span> <span class="toc-text">迭代器类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.7.3.</span> <span class="toc-text">string大小写转换</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/12/Hexo%E6%96%B0%E5%A2%9E%E5%88%86%E7%B1%BB%E6%A0%87%E7%AD%BE%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E8%AF%A6%E8%A7%A3/" title="Hexo 新增分类、标签与自定义页面详解">Hexo 新增分类、标签与自定义页面详解</a><time datetime="2025-10-12T05:46:03.000Z" title="发表于 2025-10-12 13:46:03">2025-10-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E9%80%9A%E7%94%A8%E8%93%9D%E5%9B%BE/" title="高可用高并发后端架构通用蓝图">高可用高并发后端架构通用蓝图</a><time datetime="2025-10-08T15:42:00.000Z" title="发表于 2025-10-08 23:42:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%9F%E6%88%90/" title="AI提示词_学习笔记生成">AI提示词_学习笔记生成</a><time datetime="2025-10-08T15:15:00.000Z" title="发表于 2025-10-08 23:15:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E8%AF%95%E9%A2%98%E7%94%9F%E6%88%90/" title="AI提示词_试题生成">AI提示词_试题生成</a><time datetime="2025-10-08T15:15:00.000Z" title="发表于 2025-10-08 23:15:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/Golang_swag/" title="Golang swag 库">Golang swag 库</a><time datetime="2025-10-08T15:07:00.000Z" title="发表于 2025-10-08 23:07:00">2025-10-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/Image/topImage.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By 棨</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>