<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C Sharp学习笔记/基础教程 | 柊</title><meta name="author" content="棨"><meta name="copyright" content="棨"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#59b9c6"><meta name="description" content="C Sharp基础教程系列，带你入门C#编程。">
<meta property="og:type" content="article">
<meta property="og:title" content="C Sharp学习笔记&#x2F;基础教程">
<meta property="og:url" content="https://chaoqijiang.github.io/2023/01/25/CSharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="柊">
<meta property="og:description" content="C Sharp基础教程系列，带你入门C#编程。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chaoqijiang.github.io/Image/avatar.png">
<meta property="article:published_time" content="2023-01-24T21:54:46.000Z">
<meta property="article:modified_time" content="2025-10-11T16:34:24.697Z">
<meta property="article:author" content="棨">
<meta property="article:tag" content="CSharp">
<meta property="article:tag" content="protected">
<meta property="article:tag" content="基础教程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chaoqijiang.github.io/Image/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C Sharp学习笔记/基础教程",
  "url": "https://chaoqijiang.github.io/2023/01/25/CSharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/",
  "image": "https://chaoqijiang.github.io/Image/avatar.png",
  "datePublished": "2023-01-24T21:54:46.000Z",
  "dateModified": "2025-10-11T16:34:24.697Z",
  "author": [
    {
      "@type": "Person",
      "name": "棨",
      "url": "https://chaoqijiang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://chaoqijiang.github.io/2023/01/25/CSharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#59b9c6')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 24
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":30,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#165e83","bgDark":"#507ea4","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C Sharp学习笔记/基础教程',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/Image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴/归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/Image/topImage.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/Image/Logo.ico" alt="Logo"><span class="site-name">柊</span></a><a class="nav-page-title" href="/"><span class="site-name">C Sharp学习笔记/基础教程</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴/归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C Sharp学习笔记/基础教程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-24T21:54:46.000Z" title="发表于 2023-01-25 05:54:46">2023-01-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-11T16:34:24.697Z" title="更新于 2025-10-12 00:34:24">2025-10-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CSharp/">CSharp</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">117.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>433分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="C-简介"><a href="#C-简介" class="headerlink" title="C#简介"></a>C#简介</h1><h2 id="CIL和JIT"><a href="#CIL和JIT" class="headerlink" title="CIL和JIT"></a>CIL和JIT</h2><p>在编译使用.NET Framework或.NET Core库的代码时，不是立即创建专用于操作系统的本机代码，而是把代码编译为通用中间语言(Common Intermediate Language, CIL)代码,这些代码并非专门用于任何一种操作系统，也非专门用于C#。其他NET语言(如Visual Basic .NET或F#)也会在第一阶段编译为这种语言。开发C#应用程序时，这个编译步骤由Visual Studio完成。Microsoft Intermediate Language(MSIL)这一术语，它是CIL原来的名称，许多开发人员仍沿用这个术语。</p>
<p>要执行应用程序，必须完成更多工作，这是Just-In-Time（JIT）编译器的任务，它把CIL编译为专用于OS和目标机器架构的本机代码。这样OS才能执行应用程序。这里编译器的名称Just-In-Time反映了CIL代码仅在需要时才编译的事实。这种编译可以在应用程序的运行过程中动态发生，不过开发人员一般不需要关心这个过程。除非要编写性能十分关键的高级代码，否则知道这个编译过程会在后台自动进行，并不需要人工干预就可以了。<br>过去，经常需要把代码编译为几个应用程序，每个应用程序都用于特定的操作系统和CPU架构。这通常是一种优化形式(例如，为了让代码在AMD芯片组上运行得更快)，但有时则是非常重要的(例如，使应用程序可以同时工作在Win9x和WinNT&#x2F;2000环境F)。现在就没必要了，因为JIT编译器使用CIL代码，而CIL代码是独立于计算机、操作系统和CPU的。目前有几种JIT编译器，每种编译器都用于不同的架构，CLR&#x2F;CoreCLR会使用合适的编译器创建所需的本机代码。</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>.NET垃圾回收会定期检查计算机的内存，从中删除不再需要的内容。执行垃圾回收的时间并不固定，可能<br>一秒钟内会进行数千次的检查，也可能每几秒钟才检查- -次，不过一定会进行检查。<br>这里要给程序员一些提示。因为是在不可预知的时间执行这项工作，所以在设计应用程序时，必须留意这<br>一点。需要许多内存才能运行的代码应自行完成清理工作，而不是坐等垃圾回收，但这不像听起来那样难。</p>
<h1 id="类和名称空间"><a href="#类和名称空间" class="headerlink" title="类和名称空间"></a>类和名称空间</h1><ul>
<li><p>类（class）构成程序主体</p>
<blockquote>
<p>​    类 (class) 是最基础的 C# 类型。类是一个数据结构，将<code>状态</code>（字段）和<code>操作</code>（方法和其他函数成员）组合在一个单元中。类为动态创建的类实例 (instance) 提供了定义，实例也称为对象 (object)。类支持继承 (inheritance) 和多态性 (polymorphism)，这是派生类 (derived class) 可用来扩展和专用化基类 (base class) 的机制。</p>
<p>​    使用类声明可以创建新的类。类声明以一个声明头开始，其组成方式如下：先指定类的特性和修饰符，然后是类的名称，接着是基类（如有）以及该类实现的接口。声明头后面跟着类 { 和 } 之间的成员声明组成。</p>
</blockquote>
</li>
<li><p>名称空间（namespace）以树型结构组织类和其他类型</p>
<blockquote>
<p>命名空间将类用良好的结构组合在一起，有效的避免了重名类带来的冲突。</p>
</blockquote>
</li>
</ul>
<p>eg：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello, World!&quot;</span>);            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于c#是完全面向对象的，因此入口点Main方法也需要在类内。</p>
<p>其中的<code>Console</code>这个类，是系统定义的，这个使用了这个类中的<code>WriteLine</code>的方法，用于将指定的字符串输出到控制台。</p>
<p>而编写的这个Program类，放在了ConsoleApp1这个命名空间中。</p>
<p>using System的作用就是，告诉编译器，如果我没有指定这个类的来源于哪个命名空间，就在引用的名称空间内部检索一边。</p>
<p>如果想要手动指定属于某个名称空间的类的话，可以这样：System.Console.WriteLine(“hello”);</p>
<h2 id="类库的引用"><a href="#类库的引用" class="headerlink" title="类库的引用"></a>类库的引用</h2><ul>
<li>类库引用是使用名称空间的物理基础</li>
</ul>
<h3 id="dll引用（黑盒引用）"><a href="#dll引用（黑盒引用）" class="headerlink" title="dll引用（黑盒引用）"></a>dll引用（黑盒引用）</h3><p>只能使用，但无法修改。同时增加了依赖关系，如果引用的dll有错误或者不存在，则程序可能无法使用。  </p>
<h3 id="项目引用（白盒引用）"><a href="#项目引用（白盒引用）" class="headerlink" title="项目引用（白盒引用）"></a>项目引用（白盒引用）</h3><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类（class）是现实世界事务的模型，将事务进行抽象后得到的结果，事务包括实体和逻辑等。</p>
<h3 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h3><p>对象也称为实例，是类实例化后得到的内存中的实体</p>
<p>实例化后的类就是对象，但不是所有的类都可以被实例化。</p>
<p>使用new操作符创建类的实例</p>
<h3 id="类的三大成员"><a href="#类的三大成员" class="headerlink" title="类的三大成员"></a>类的三大成员</h3><h4 id="属性（Property）"><a href="#属性（Property）" class="headerlink" title="属性（Property）"></a>属性（Property）</h4><p>存储数据，组合起来表示类或对象的当前状态</p>
<h4 id="方法（Method）"><a href="#方法（Method）" class="headerlink" title="方法（Method）"></a>方法（Method）</h4><p>由函数进化而来，表示类或对象能够做什么</p>
<h4 id="事件（Event）"><a href="#事件（Event）" class="headerlink" title="事件（Event）"></a>事件（Event）</h4><p>类或对象通知其他类或对象的机制，为c#特有</p>
<h3 id="静态成员与实例成员"><a href="#静态成员与实例成员" class="headerlink" title="静态成员与实例成员"></a>静态成员与实例成员</h3><ul>
<li>静态（static）成员在语义上表示他是“类的成员”</li>
<li>实例（非静态）成员在语义上表示他是“对象的成员”</li>
<li>绑定（binding）指的是编译器如何把一个成员与类或对象关联起来</li>
<li><code>.</code>操作符：用于成员的访问，全称为成员访问操作符。</li>
</ul>
<h1 id="C-的基本元素"><a href="#C-的基本元素" class="headerlink" title="C#的基本元素"></a>C#的基本元素</h1><ul>
<li>关键字（keyword）</li>
<li>操作符（operator）</li>
<li>标识符（identifier）<ul>
<li>合法的标识符：用于给类、对象等命名<ul>
<li>不能是关键字</li>
<li>可以由字母数字下划线组成，但不能以数字开头</li>
<li>如 果需要使用关键字作为标识符，需要在前面加上<code>@</code>（Unicode转义序列）</li>
<li>可以包含汉语，但不建议使用</li>
</ul>
</li>
<li>大小写规范<ul>
<li>大驼峰：命名空间、类型、接口、方法、属性、事件、非私有字段、枚举值</li>
<li>小驼峰：私有字段、参数、局部变量</li>
</ul>
</li>
<li>命名规范<ul>
<li>类、类的属性的名字是一个名词或者名词的复数形式‘</li>
<li>对类的方法命名的时候，需要是一个动词，或者动词短语</li>
</ul>
</li>
</ul>
</li>
<li>标点符号<ul>
<li>不同于加减乘除，不用来表示运算思想<ul>
<li><code>;</code>     表示语句结束</li>
<li><code>{}</code>  表示程序段</li>
<li>以及其他的一下</li>
</ul>
</li>
</ul>
</li>
<li>文本（值）<ul>
<li>整数<ul>
<li>int</li>
<li>long：结尾需要加L</li>
</ul>
</li>
<li>实数<ul>
<li>float：结尾需要加F</li>
<li>double</li>
</ul>
</li>
<li>字符<ul>
<li>char：单引号引起来的一个字符</li>
</ul>
</li>
<li>字符串<ul>
<li>string：双引号引起来的零个或多个字符串</li>
</ul>
</li>
<li>布尔<ul>
<li>bool：只能为true或false</li>
</ul>
</li>
<li>空<ul>
<li><code>null</code>，如str &#x3D; null；</li>
</ul>
</li>
</ul>
</li>
<li>注释与空白<ul>
<li>单行注释：<code>//</code>开头的一行</li>
<li>多行注释（块注释）：<code>/*  */</code>内的字符，不可以嵌套使用</li>
<li>空白：空格、换行、注释等。</li>
</ul>
</li>
</ul>
<p>除了注释与空白，其余的都是对编译器有意义的记号。也成为标记</p>
<h2 id="类型、变量与方法的概述"><a href="#类型、变量与方法的概述" class="headerlink" title="类型、变量与方法的概述"></a>类型、变量与方法的概述</h2><ul>
<li><p>类型（type），又称为数据类型（Data Type)</p>
</li>
<li><p>变量是存储数据的地方</p>
<ul>
<li>变量需要先声明后使用</li>
<li>声明方法：<ul>
<li>类型名 + 变量名</li>
</ul>
</li>
</ul>
</li>
<li><p>方法（旧称函数）是处理数据的逻辑，又称为算法</p>
<ul>
<li>方法的声明<ul>
<li>方法名需要是合法的标识符</li>
</ul>
</li>
<li>方法的使用<ul>
<li>类（对象）.方法名</li>
</ul>
</li>
</ul>
</li>
<li><p>程序 &#x3D; 变量 + 方法。</p>
</li>
</ul>
<h2 id="c-中的数据类型"><a href="#c-中的数据类型" class="headerlink" title="c#中的数据类型"></a>c#中的数据类型</h2><h3 id="数据类型的概述"><a href="#数据类型的概述" class="headerlink" title="数据类型的概述"></a>数据类型的概述</h3><h4 id="什么是类型（Type）"><a href="#什么是类型（Type）" class="headerlink" title="什么是类型（Type）"></a>什么是类型（Type）</h4><ul>
<li>是性质相同的值的集合</li>
<li>数据类型配备了一系列针对这种类型的值的操作</li>
<li>数据类型是数据在内存中存储时的“型号”</li>
</ul>
<h4 id="类型在C-中的作用"><a href="#类型在C-中的作用" class="headerlink" title="类型在C#中的作用"></a>类型在C#中的作用</h4><p>一个C#类型中所包含的信息有：</p>
<ul>
<li>存储此类型变量所需的空间大小</li>
<li>此类型的值可表示的最大、最小值范围</li>
<li>此类型所包含的成员（如方法、属性、事件等）</li>
<li>此类型有何基类派生而来</li>
<li>程序运行的时候，此类型的变量分配在内存的什么位置<ul>
<li>c++没有内存回收机制，因此没有手动回收的话可能会造成内存泄漏；c#存在垃圾收集器的机制，当一个对象没有再被使用的时候，会自动进行回收，没有手动释放的一说。换句话说就是c#相对比较安全。</li>
<li>实例永远是分配在堆内</li>
</ul>
</li>
<li>此类型允许的操作（运算）</li>
</ul>
<h4 id="C-语言的类型系统"><a href="#C-语言的类型系统" class="headerlink" title="C#语言的类型系统"></a>C#语言的类型系统</h4><h5 id="c-的五大数据类型"><a href="#c-的五大数据类型" class="headerlink" title="c#的五大数据类型"></a>c#的五大数据类型</h5><ul>
<li>类（Classes）：如Windows，Form，Console，Srting</li>
<li>结构体（Structres）：如Int32，Int64，Single，Double</li>
<li>枚举（Enumerations）如HorizontalAlignment，Visibility</li>
<li>接口（Interfaces）</li>
<li>委托（Delegates）</li>
</ul>
<h5 id="c-的派生谱系"><a href="#c-的派生谱系" class="headerlink" title="c#的派生谱系"></a>c#的派生谱系</h5><p><img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/image-20230128132020066.png" alt="image-20230128132020066"></p>
<p>关键字解析：</p>
<ul>
<li>第一组<ul>
<li>object、string：真正的数据类型</li>
<li>class、interface、delegate：不是具体的数据类型，而是用这三个关键字定义自己的数据类型</li>
</ul>
</li>
<li>第二组<ul>
<li>bool、byte、…、ushort：都是值类型</li>
<li>struct、enum：定义自己的类型的关键字</li>
</ul>
</li>
<li>第三组<ul>
<li>true、false：布尔类型的值</li>
<li>void、null：表示“空”</li>
<li>var、dynamic：声明变量</li>
</ul>
</li>
</ul>
<p>其中蓝色的都是基本数据类型（或称为<code>内建数据类型</code>），没有其他类型可以来构成他们</p>
<h2 id="变量、对象与内存"><a href="#变量、对象与内存" class="headerlink" title="变量、对象与内存"></a>变量、对象与内存</h2><h3 id="变量概述"><a href="#变量概述" class="headerlink" title="变量概述"></a>变量概述</h3><ul>
<li>表面上看，变量的用途是存储数据</li>
<li>实际上，变量表示了存储位置，并且每一个变量都有一个类型，以决定什么样的值能够存入变量。变量名表示（对应着）变量的值在内存中的存储位置，变量类型表示从这个位置开始，往后多少个字节，用来保存这个变量的值。</li>
<li>变量一共有七种<ul>
<li>静态变量（静态字段）</li>
<li>实例变量（成员变量，字段）</li>
<li>数组元素</li>
<li>值参数</li>
<li>引用参数（ref修饰）</li>
<li>输出形参（out修饰）</li>
<li>局部变量</li>
</ul>
</li>
<li>狭义的变量是指局部变量，因为其他种类的变量都有自己的约定名称<ul>
<li>局部变量就是方法体（函数体）内声明的变量</li>
</ul>
</li>
<li>变量的声明<ul>
<li>[有效的修饰符组合] 类型 变量名 [初始化器]</li>
<li>如：unsigned int a &#x3D; 10;</li>
</ul>
</li>
<li>局部变量实在stack上分配内存的</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Student student= <span class="keyword">new</span> Student();</span><br><span class="line">            <span class="built_in">int</span>[] array = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];<span class="comment">//数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Amount;<span class="comment">//静态成员变量</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Name;<span class="comment">//Age Name都是成员变量（字段）</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)<span class="comment">//a：引用参数变量；b:值参数变量</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h3 id="值类型的变量（简单数据类型）"><a href="#值类型的变量（简单数据类型）" class="headerlink" title="值类型的变量（简单数据类型）"></a>值类型的变量（简单数据类型）</h3><p>值类型没有实例，所谓的“实例”与变量名合二为一。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">描述</th>
<th align="left">范围</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bool</td>
<td align="left">布尔值</td>
<td align="left">True 或 False</td>
<td align="left">False</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">8 位无符号整数</td>
<td align="left">0 到 255</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">16 位 Unicode 字符</td>
<td align="left">U +0000 到 U +ffff</td>
<td align="left">‘\0’</td>
</tr>
<tr>
<td align="left">decimal</td>
<td align="left">128 位精确的十进制值，28-29 有效位数，也属于浮点数，只是底数是10.</td>
<td align="left">(-7.9 x 10^28^ 到 7.9 x 10^28^) &#x2F; 100 到 28</td>
<td align="left">0.0M</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">64 位双精度浮点型，常规的浮点数，底数是2</td>
<td align="left">(+&#x2F;-)5.0 x 10^-324^ 到 (+&#x2F;-)1.7 x 10^308^</td>
<td align="left">0.0D</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">32 位单精度浮点型</td>
<td align="left">-3.4 x 10^38^ 到 + 3.4 x 10^38^</td>
<td align="left">0.0F</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">32 位有符号整数类型</td>
<td align="left">-2,147,483,648 到 2,147,483,647</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">64 位有符号整数类型</td>
<td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
<td align="left">0L</td>
</tr>
<tr>
<td align="left">sbyte</td>
<td align="left">8 位有符号整数类型</td>
<td align="left">-128 到 127</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">16 位有符号整数类型</td>
<td align="left">-32,768 到 32,767</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">uint</td>
<td align="left">32 位无符号整数类型</td>
<td align="left">0 到 4,294,967,295</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">ulong</td>
<td align="left">64 位无符号整数类型</td>
<td align="left">0 到 18,446,744,073,709,551,615</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">ushort</td>
<td align="left">16 位无符号整数类型</td>
<td align="left">0 到 65,535</td>
<td align="left">0</td>
</tr>
</tbody></table>
<h3 id="引用类型（Reference-types）的变量与实例"><a href="#引用类型（Reference-types）的变量与实例" class="headerlink" title="引用类型（Reference types）的变量与实例"></a>引用类型（Reference types）的变量与实例</h3><p>​	引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。换句话说，它们指的是一个内存位置。使用多个变量时，引用类型可以指向一个内存位置。如果内存位置的数据是由一个变量改变的，其他变量会自动反映这种值的变化。<strong>内置的</strong> 引用类型有：<strong>object</strong>、<strong>dynamic</strong> 和 <strong>string</strong>。</p>
<p>​	引用类型变量与实例的关系：引用类型变量里存储的数据是对象的内存地址。</p>
<p>​	也就是说，在创建引用类型的变量的时候，会在内存中开辟一段4个字节的内存空间，并全部置0，当这个变量指向一个实例的时候，会在堆内开辟空间，将这个空间的首地址存储到这个变量里面来。</p>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><ul>
<li><p>成员变量：在类中定义的变量，在整个类中都有效，类中定义的方法都可以使用该变量。成员变量又可以分为实例成员变量和静态成员变量。</p>
<ul>
<li>静态成员变量：使用static修饰的成员变量，<code>static</code>用于把属性和方法绑定到类本身，而不是使用类创建的对象。使用静态成员变量时直接使用类名称进行调用，无论用户使用该类创建了多少个对象，静态成员变量始终只有一个，始终绑定到类本身，每个创建的对象中并不存在该静态成员变量。</li>
<li>实例成员变量：实例成员变量是绑定使用类创建的对象上的，要想使用实例成员变量，必须先使用类创建一个对象。使用实例成员变量时是使用对象名进行调用，使用同一类创建的多个对象中各自有自己的实例成员变量，互相隔离，互不干扰。</li>
</ul>
</li>
<li><p>局部变量：在方法体中定义的变量，其使用范围只局限在定义它的方法之中或者方法之中的循环体之内，作用域不超过一个大括号</p>
</li>
<li><p>全局变量：在类中定义的变量用<code>static</code>修饰的变量为全局变量，在整个<code>namespace</code>中的所有类中都可以使用</p>
</li>
</ul>
<p>需要注意的是：定义变量时不能在同一作用域内定义相同名称的变量</p>
<h3 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h3><p>​	<strong>对象（Object）类型</strong> 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换.</p>
<p>​	当一个值类型转换为对象类型时，则被称为 <strong>装箱</strong>；另一方面，当一个对象类型转换为值类型时，则被称为 <strong>拆箱</strong>。</p>
<p>​	装箱：当obj类型的变量要引用的值不是堆上的实例，而是栈上的一个值类型的时候，会先在堆上找一块可以存储下的空间，然后将值类型的值copy到堆上开辟的空间，最后将obj变量指向新开辟的空间上。</p>
<p>​	拆箱：一个值类型的变量想要拿到obj在堆上面存储的值。将堆上的值按照要求复制到变量内。注意，编译器并不检测箱子内的数据的类型，比如将short类型装箱，然后以char形式拆箱，编译器不会报错，但运行的时候会出现<code>System.InvalidCastException:“指定的转换无效。”</code>的异常。</p>
<p>还有就是，装箱和拆箱会损失系统性能。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">object</span> obj;<span class="comment">//需要注意，object类型是引用类型</span></span><br><span class="line">obj = x;<span class="comment">//装箱</span></span><br><span class="line"><span class="built_in">int</span> y = (<span class="built_in">int</span>)obj;<span class="comment">//拆箱</span></span><br><span class="line">Console.WriteLine(y);</span><br></pre></td></tr></table></figure>



<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>任意类型类型到Object都是装箱，从Object到原有类型都是拆箱。</p>
<p>虽然会损失系统性能，但对于多态来说是非常常用的。</p>
<p>发生装箱和拆箱的前提是两种类型之间存在了继承关系。如果没有继承关系，比如string和int，则相互转换属于类型转换而非装箱拆箱。</p>
<h2 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h2><p>除了这些简单的变量类型外，C#还提供了3个较复杂(但非常有用)的变量:枚举、结构和数组。</p>
<h3 id="枚举（Enum）"><a href="#枚举（Enum）" class="headerlink" title="枚举（Enum）"></a>枚举（Enum）</h3><ul>
<li>枚举类型 是由<code>基础整型数值类型</code>的一组命名常量定义的<code>值类型</code>。枚举类型是使用 <code>enum</code> 关键字声明的。</li>
<li>C# 枚举是<code>值类型</code>。换句话说，枚举包含自己的值，且不能继承或传递继承。</li>
<li>不是仅声明一个给定类型的变量，而是声明和描述一个用户定义的类型，再声明这个新类型的变量。</li>
<li>**枚举的基本类型可以是byte,sbyte,short,ushort,int,uint,long,ulong。默认情况下为int。**不可以为浮点数或string，甚至是class。</li>
<li>可以在声明的时候使用其他类型来节省空间。</li>
</ul>
<h4 id="声明-enum-变量"><a href="#声明-enum-变量" class="headerlink" title="声明 enum 变量"></a>声明 enum 变量</h4><p>声明枚举的一般语法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> &lt;enum_name&gt;</span><br><span class="line">&#123; </span><br><span class="line">    enumeration list </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li><em>enum_name</em> 指定枚举的类型名称。</li>
<li><em>enumeration list</em> 是一个用逗号分隔的标识符列表。</li>
</ul>
<p><strong>枚举列表中的每个符号代表一个整数值，一个比它前面的符号大的整数值。默认情况下，第一个枚举符号的值是 0</strong>。</p>
<p>例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Days &#123; Sun, Mon, tue, Wed, thu, Fri, Sat &#125;;</span><br></pre></td></tr></table></figure>



<p>​	默认情况下，枚举成员的关联常数值为类型 <code>int</code>；它们从零开始，并按定义文本顺序递增 1。 可以显式指定任何其他整数数值类型作为枚举类型的基础类型。 还可以显式指定关联的常数值，如下面的示例所示：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> ErrorCode : <span class="built_in">ushort</span></span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    Unknown = <span class="number">1</span>,</span><br><span class="line">    ConnectionLost = <span class="number">100</span>,</span><br><span class="line">    OutlierReading = <span class="number">200</span>,</span><br><span class="line">    NotFound = <span class="number">404</span>,</span><br><span class="line">    BadGateway = <span class="number">502</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>下面的实例演示了枚举变量的用法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnumTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">enum</span> Day &#123; Sun, Mon, Tue, Wed, Thu, Fri, Sat &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> x = (<span class="built_in">int</span>)Day.Sun;</span><br><span class="line">        <span class="built_in">int</span> y = (<span class="built_in">int</span>)Day.Fri;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Sun = &#123;0&#125;&quot;</span>, x);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Fri = &#123;0&#125;&quot;</span>, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Sun = <span class="number">0</span></span><br><span class="line">Fri = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>​	</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>不能在枚举类型的定义内定义方法。 若要向枚举类型添加功能，请创建扩展方法。</li>
<li>枚举类型 <code>E</code> 的默认值是由表达式 <code>(E)0</code> 生成的值，即使零没有相应的枚举成员也是如此。</li>
<li>可以使用枚举类型，通过一组互斥值或选项组合来表示选项。 若要表示选项组合，请将枚举类型定义为位标志。</li>
</ul>
<h4 id="作为位标志的枚举类型"><a href="#作为位标志的枚举类型" class="headerlink" title="作为位标志的枚举类型"></a>作为位标志的枚举类型</h4><p>​	如果希望枚举类型表示选项组合，请为这些选项定义枚举成员，以便单个选项成为位字段。 也就是说，这些枚举成员的关联值应该是 2 的幂。 然后，可以使用按位逻辑运算符<code>|</code>或 <code>&amp;</code> 分别合并选项或交叉组合选项。 若要指示枚举类型声明位字段，请对其应用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.flagsattribute">Flags</a> 属性。 如下面的示例所示，还可以在枚举类型的定义中包含一些典型组合。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">enum</span> Days</span><br><span class="line">    &#123;</span><br><span class="line">        None = <span class="number">0b</span>_0000_0000,  <span class="comment">// 0</span></span><br><span class="line">        Monday = <span class="number">0b</span>_0000_0001,  <span class="comment">// 1</span></span><br><span class="line">        Tuesday = <span class="number">0b</span>_0000_0010,  <span class="comment">// 2</span></span><br><span class="line">        Wednesday = <span class="number">0b</span>_0000_0100,  <span class="comment">// 4</span></span><br><span class="line">        Thursday = <span class="number">0b</span>_0000_1000,  <span class="comment">// 8</span></span><br><span class="line">        Friday = <span class="number">0b</span>_0001_0000,  <span class="comment">// 16</span></span><br><span class="line">        Saturday = <span class="number">0b</span>_0010_0000,  <span class="comment">// 32</span></span><br><span class="line">        Sunday = <span class="number">0b</span>_0100_0000,  <span class="comment">// 64</span></span><br><span class="line">        Weekend = Saturday | Sunday</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Days meetingDays = Days.Monday | Days.Wednesday | Days.Friday; <span class="comment">// 0001 0101 -&gt; 21</span></span><br><span class="line">            Console.WriteLine(meetingDays);</span><br><span class="line">            <span class="comment">// Output:</span></span><br><span class="line">            <span class="comment">// Monday, Wednesday, Friday</span></span><br><span class="line">            <span class="comment">//实际输出：21</span></span><br><span class="line"></span><br><span class="line">            Days workingFromHomeDays = Days.Thursday | Days.Friday;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Join a meeting by phone on <span class="subst">&#123;meetingDays &amp; workingFromHomeDays&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="comment">// Output:</span></span><br><span class="line">            <span class="comment">// Join a meeting by phone on Friday</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">bool</span> isMeetingOnTuesday = (meetingDays &amp; Days.Tuesday) == Days.Tuesday;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Is there a meeting on Tuesday: <span class="subst">&#123;isMeetingOnTuesday&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="comment">// Output:</span></span><br><span class="line">            <span class="comment">// Is there a meeting on Tuesday: False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> a = (Days)<span class="number">37</span>;</span><br><span class="line">            Console.WriteLine(a);</span><br><span class="line">            <span class="comment">// Output:</span></span><br><span class="line">            <span class="comment">// Monday, Wednesday, Saturday</span></span><br><span class="line">            <span class="comment">//实际输出：37</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="System-Enum-类型和枚举约束"><a href="#System-Enum-类型和枚举约束" class="headerlink" title="System.Enum 类型和枚举约束"></a>System.Enum 类型和枚举约束</h4><p>​	<code>System.Enum</code> 类型是<strong>所有枚举类型的抽象基类</strong>。 它提供多种方法来获取有关枚举类型及其值的信息。 有关更多信息和示例，请参阅 System.Enum API 参考页。</p>
<p>​	可在基类约束中使用 <code>System.Enum</code>（称为枚举约束），以指定类型参数为枚举类型。 所有枚举类型也都满足 struct 约束，此约束用于指定类型参数为不可为 null 的值类型。</p>
<h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p>对于任何枚举类型，<strong>枚举类型与其基础整型类型之间存在显式转换</strong>。 如果将枚举值转换为其基础类型，则结果为枚举成员的关联整数值。</p>
<p>如果基础整数类型转换到的枚举类型时，整数的值 不在 目标枚举类型的范围中（如下方样例中的，Season枚举内的值是0，1，2，3，但我将4转换为这个枚举类型），也不会报错，但对应的这个枚举的值就是目标转换的4（不是整型了，而是Season类型的枚举4，可以看到输出var的类型名是ConsoleApp.Season）。但如果进一步的查询4是否在Season枚举中，查询的结果是false。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Season</span><br><span class="line">&#123;</span><br><span class="line">    Spring,</span><br><span class="line">    Summer,</span><br><span class="line">    Autumn,</span><br><span class="line">    Winter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnumConversionExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      	Season a = Season.Autumn;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Integral value of <span class="subst">&#123;a&#125;</span> is <span class="subst">&#123;(<span class="built_in">int</span>)a&#125;</span>&quot;</span>);  </span><br><span class="line">        <span class="comment">// output: Integral value of Autumn is 2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> b = (Season)<span class="number">1</span>;</span><br><span class="line">        Console.WriteLine(b);  <span class="comment">// output: Summer</span></span><br><span class="line">        Console.WriteLine(b.GetType());     <span class="comment">//output: ConsoleApp.Season</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> c = (Season)<span class="number">4</span>;</span><br><span class="line">        Console.WriteLine(c);  <span class="comment">// output: 4</span></span><br><span class="line">        Console.WriteLine(c.GetType());  <span class="comment">//output: ConsoleApp.Season</span></span><br><span class="line">        </span><br><span class="line">        Console.WriteLine(Enum.IsDefined(<span class="keyword">typeof</span>(Season),<span class="number">4</span>));<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>使用 <code>Enum.IsDefined</code> 方法来确定枚举类型是否包含具有特定关联值的枚举成员。</p>
<p>对于任何枚举类型，都存在分别与 <code>System.Enum</code> 类型的装箱和取消装箱相互转换。</p>
<h5 id="string类型转换为枚举值"><a href="#string类型转换为枚举值" class="headerlink" title="string类型转换为枚举值"></a>string类型转换为枚举值</h5><p>需要借助<code>Enum.Parse()</code>方法。</p>
<p>基本语法如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">(目标枚举类型)Enum.Parse(<span class="keyword">typeof</span>(目标枚举类型),<span class="string">&quot;要转换的string字符串&quot;</span>);</span><br></pre></td></tr></table></figure>

<h6 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h6><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">enum</span> Error : <span class="built_in">short</span></span><br><span class="line">    &#123;</span><br><span class="line">        NOT_FOUND = <span class="number">404</span>,</span><br><span class="line">        BAD_GATEWAY = <span class="number">502</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Error err = Error.NOT_FOUND;</span><br><span class="line"></span><br><span class="line">            err = (Error)Enum.Parse(<span class="keyword">typeof</span>(Error), <span class="string">&quot;502&quot;</span>);<span class="comment">//将字符类型的502转换成对应的整型值为502的枚举类型。</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            Console.WriteLine(err);<span class="comment">//输出：BAD_GATEWAY</span></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="结构体（Struct）"><a href="#结构体（Struct）" class="headerlink" title="结构体（Struct）"></a>结构体（Struct）</h3><p>在 C# 中，结构体是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。<code>struct</code> 关键字用于创建结构体。</p>
<p>结构体是用来代表一个记录。假设您想跟踪图书馆中书的动态。yy您可能想跟踪每本书的以下属性：</p>
<ul>
<li><p>Title</p>
</li>
<li><p>Author</p>
</li>
<li><p>Subject</p>
</li>
<li><p>Book ID</p>
</li>
</ul>
<h4 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h4><p>struct 语句为程序定义了一个带有多个成员的新的数据类型。</p>
<p>例如，可以按照如下的方式声明 Book 结构：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Books</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> title;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> author;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> subject;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> book_id;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>下面的程序演示了结构的用法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Books</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> title;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> author;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> subject;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> book_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">testStructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Books Book1;        <span class="comment">/* 声明 Book1，类型为 Books */</span></span><br><span class="line">        Books Book2;        <span class="comment">/* 声明 Book2，类型为 Books */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* book 1 详述 */</span></span><br><span class="line">        Book1.title = <span class="string">&quot;C Programming&quot;</span>;</span><br><span class="line">        Book1.author = <span class="string">&quot;Nuha Ali&quot;</span>;</span><br><span class="line">        Book1.subject = <span class="string">&quot;C Programming Tutorial&quot;</span>;</span><br><span class="line">        Book1.book_id = <span class="number">6495407</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* book 2 详述 */</span></span><br><span class="line">        Book2.title = <span class="string">&quot;Telecom Billing&quot;</span>;</span><br><span class="line">        Book2.author = <span class="string">&quot;Zara Ali&quot;</span>;</span><br><span class="line">        Book2.subject = <span class="string">&quot;Telecom Billing Tutorial&quot;</span>;</span><br><span class="line">        Book2.book_id = <span class="number">6495700</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Book 1 title : &#123;0&#125;&quot;</span>, Book1.title);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Book 1 author : &#123;0&#125;&quot;</span>, Book1.author);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Book 1 subject : &#123;0&#125;&quot;</span>, Book1.subject);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Book 1 book_id :&#123;0&#125;&quot;</span>, Book1.book_id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Book 2 title : &#123;0&#125;&quot;</span>, Book2.title);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Book 2 author : &#123;0&#125;&quot;</span>, Book2.author);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Book 2 subject : &#123;0&#125;&quot;</span>, Book2.subject);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Book 2 book_id : &#123;0&#125;&quot;</span>, Book2.book_id);</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Book 1 title : C Programming</span><br><span class="line">Book 1 author : Nuha Ali</span><br><span class="line">Book 1 subject : C Programming Tutorial</span><br><span class="line">Book 1 book_id : 6495407</span><br><span class="line">Book 2 title : Telecom Billing</span><br><span class="line">Book 2 author : Zara Ali</span><br><span class="line">Book 2 subject : Telecom Billing Tutorial</span><br><span class="line">Book 2 book_id : 6495700</span><br></pre></td></tr></table></figure>

<h4 id="C-结构的特点"><a href="#C-结构的特点" class="headerlink" title="C# 结构的特点"></a>C# 结构的特点</h4><p>在 C# 中的结构与传统的 C 或 C++ 中的结构不同。C# 中的结构有以下特点：</p>
<ul>
<li><p><strong>结构可带有方法、字段、索引、属性、运算符方法和事件</strong>。</p>
</li>
<li><p>结构可定义构造函数，但不能定义析构函数。但是，不能为结构定义无参构造函数。无参构造函数(默认)是自动定义的，且不能被改变。</p>
</li>
<li><p>与类不同，结构不能继承其他的结构或类。</p>
</li>
<li><p>结构不能作为其他结构或类的基础结构。</p>
</li>
<li><p>结构可实现一个或多个接口。</p>
</li>
<li><p>结构成员不能指定为 abstract、virtual 或 protected。</p>
</li>
<li><p>当您使用 New 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。</p>
</li>
<li><p>如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。</p>
</li>
</ul>
<h4 id="类与结构的区别"><a href="#类与结构的区别" class="headerlink" title="类与结构的区别"></a>类与结构的区别</h4><p>类和结构有以下几个基本的不同点：</p>
<ul>
<li><p>类是引用类型，结构是值类型。</p>
</li>
<li><p>结构不支持继承。</p>
</li>
<li><p>结构不能声明默认的构造函数。</p>
</li>
<li><p>针对上述讨论，让我们重写前面的实例：</p>
</li>
</ul>
<h4 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Books</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> title;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> author;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> subject;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> book_id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValues</span>(<span class="params"><span class="built_in">string</span> t, <span class="built_in">string</span> a, <span class="built_in">string</span> s, <span class="built_in">int</span> id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        title = t;</span><br><span class="line">        author = a;</span><br><span class="line">        subject = s;</span><br><span class="line">        book_id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Title : &#123;0&#125;&quot;</span>, title);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Author : &#123;0&#125;&quot;</span>, author);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Subject : &#123;0&#125;&quot;</span>, subject);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Book_id :&#123;0&#125;&quot;</span>, book_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">testStructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Books Book1 = <span class="keyword">new</span> Books(); <span class="comment">/* 声明 Book1，类型为 Books */</span></span><br><span class="line">        Books Book2 = <span class="keyword">new</span> Books(); <span class="comment">/* 声明 Book2，类型为 Books */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* book 1 详述 */</span></span><br><span class="line">        Book1.setValues(<span class="string">&quot;C Programming&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Nuha Ali&quot;</span>, <span class="string">&quot;C Programming Tutorial&quot;</span>, <span class="number">6495407</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* book 2 详述 */</span></span><br><span class="line">        Book2.setValues(<span class="string">&quot;Telecom Billing&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Zara Ali&quot;</span>, <span class="string">&quot;Telecom Billing Tutorial&quot;</span>, <span class="number">6495700</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">        Book1.display();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">        Book2.display();</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Title : C Programming</span><br><span class="line">Author : Nuha Ali</span><br><span class="line">Subject : C Programming Tutorial</span><br><span class="line">Book_id : <span class="number">6495407</span></span><br><span class="line">Title : Telecom Billing</span><br><span class="line">Author : Zara Ali</span><br><span class="line">Subject : Telecom Billing Tutorial</span><br><span class="line">Book_id : <span class="number">6495700</span></span><br></pre></td></tr></table></figure>







<h3 id="C-数组（Array）"><a href="#C-数组（Array）" class="headerlink" title="C# 数组（Array）"></a>C# 数组（Array）</h3><p>数组是一个存储相同类型元素的固定大小的顺序集合。数组是用来存储数据的集合，通常认为数组是一个同一类型变量的集合。</p>
<p>声明数组变量并不是声明 number0、number1、…、number99 一个个单独的变量，而是声明一个就像 numbers 这样的变量，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来表示一个个单独的变量。数组中某个指定的元素是通过索引来访问的。</p>
<p>所有的数组都是由<strong>连续的内存位置</strong>组成的。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p>
<p>数组最大的一个局限性就是长度不可变。可以使用集合进行优化。 </p>
<h4 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h4><p>在 C# 中声明一个数组，可以使用下面的语法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">datatype[] arrayName;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li>datatype 用于指定被存储在数组中的元素的类型。</li>
<li>[ ]指定数组的秩（维度）。秩指定数组的大小。</li>
<li>arrayName 指定数组的名称。</li>
</ul>
<p>例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span>[] balance;</span><br></pre></td></tr></table></figure>



<h5 id="声明多维数组"><a href="#声明多维数组" class="headerlink" title="声明多维数组"></a>声明多维数组</h5><p>和一维的声明类似，但与c&#x2F;c++有一定的差异。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span>[,] d = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">3</span>,<span class="number">4</span>];<span class="comment">//二维数组的声明</span></span><br><span class="line"><span class="built_in">int</span>[,,] ints = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];<span class="comment">//三维数组</span></span><br></pre></td></tr></table></figure>



<h4 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h4><p><strong>声明一个数组不会在内存中初始化数组</strong>。当初始化数组变量时，可以赋值给数组。</p>
<p><strong>数组是一个引用类型</strong>，所以需要使用 new 关键字来创建数组的实例。</p>
<p>例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span>[] balance = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<h4 id="赋值给数组"><a href="#赋值给数组" class="headerlink" title="赋值给数组"></a>赋值给数组</h4><p>可以通过使用索引号赋值给一个单独的数组元素，比如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span>[] balance = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">10</span>];</span><br><span class="line">balance[<span class="number">0</span>] = <span class="number">4500.0</span>;</span><br></pre></td></tr></table></figure>

<p>可以在声明数组的同时给数组赋值，比如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span>[] balance = &#123; <span class="number">2340.0</span>, <span class="number">4523.69</span>, <span class="number">3421.0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以创建并初始化一个数组，比如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> [] marks = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>]  &#123; <span class="number">99</span>,  <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述情况下，你也可以省略数组的大小，比如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> [] marks = <span class="keyword">new</span> <span class="built_in">int</span>[]  &#123; <span class="number">99</span>,  <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以赋值一个数组变量到另一个目标数组变量中。在这种情况下，目标和源会指向相同的内存位置：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> [] marks = <span class="keyword">new</span> <span class="built_in">int</span>[]  &#123; <span class="number">99</span>,  <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] score = marks;</span><br></pre></td></tr></table></figure>

<p>当创建一个数组时，C# 编译器会根据数组类型隐式初始化每个数组元素为一个默认值。例如，int 数组的所有元素都会被初始化为 0。</p>
<h4 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h4><p>元素是通过带索引的数组名称来访问的。这是通过把元素的索引放置在数组名称后的方括号中来实现的。例如：</p>
<p>double salary &#x3D; balance[9];<br>下面是一个实例，使用上面提到的三个概念，即声明、赋值、访问数组：</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ArrayApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">MyArray</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">int</span> []  n = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>]; <span class="comment">/* n 是一个带有 10 个整数的数组 */</span></span><br><span class="line">         <span class="built_in">int</span> i,j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 初始化数组 n 中的元素 */</span>        </span><br><span class="line">         <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">         &#123;</span><br><span class="line">            n[ i ] = i + <span class="number">100</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 输出每个数组元素的值 */</span></span><br><span class="line">         <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ )</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Element[&#123;0&#125;] = &#123;1&#125;&quot;</span>, j, n[j]);</span><br><span class="line">         &#125;</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Element[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">Element[<span class="number">1</span>] = <span class="number">101</span></span><br><span class="line">Element[<span class="number">2</span>] = <span class="number">102</span></span><br><span class="line">Element[<span class="number">3</span>] = <span class="number">103</span></span><br><span class="line">Element[<span class="number">4</span>] = <span class="number">104</span></span><br><span class="line">Element[<span class="number">5</span>] = <span class="number">105</span></span><br><span class="line">Element[<span class="number">6</span>] = <span class="number">106</span></span><br><span class="line">Element[<span class="number">7</span>] = <span class="number">107</span></span><br><span class="line">Element[<span class="number">8</span>] = <span class="number">108</span></span><br><span class="line">Element[<span class="number">9</span>] = <span class="number">109</span></span><br></pre></td></tr></table></figure>



<h5 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span>[,] d = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">3</span>,<span class="number">4</span>];<span class="comment">//二维数组的声明</span></span><br><span class="line">            <span class="built_in">int</span>[,,] ints = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];<span class="comment">//三维数组</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ints[i,j,k] = i; </span><br><span class="line">                    &#125;</span><br><span class="line">                    d[i,j] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span>(<span class="built_in">double</span> x <span class="keyword">in</span> d)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(x);             </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="built_in">int</span> x <span class="keyword">in</span> ints)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(x);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用-foreach-循环"><a href="#使用-foreach-循环" class="headerlink" title="使用 foreach 循环"></a>使用 foreach 循环</h4><p>在前面的实例中，我们使用一个 for 循环来访问每个数组元素。也可以使用一个 foreach 语句来遍历数组。</p>
<h5 id="实例1-一维数组的使用"><a href="#实例1-一维数组的使用" class="headerlink" title="实例1 一维数组的使用"></a>实例1 一维数组的使用</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ArrayApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">MyArray</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">int</span> []  n = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>]; <span class="comment">/* n 是一个带有 10 个整数的数组 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 初始化数组 n 中的元素 */</span>        </span><br><span class="line">         <span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">         &#123;</span><br><span class="line">            n[i] = i + <span class="number">100</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 输出每个数组元素的值 */</span></span><br><span class="line">         <span class="keyword">foreach</span> (<span class="built_in">int</span> j <span class="keyword">in</span> n )</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="built_in">int</span> i = j<span class="number">-100</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Element[&#123;0&#125;] = &#123;1&#125;&quot;</span>, i, j);</span><br><span class="line">         &#125;</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Element[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">Element[<span class="number">1</span>] = <span class="number">101</span></span><br><span class="line">Element[<span class="number">2</span>] = <span class="number">102</span></span><br><span class="line">Element[<span class="number">3</span>] = <span class="number">103</span></span><br><span class="line">Element[<span class="number">4</span>] = <span class="number">104</span></span><br><span class="line">Element[<span class="number">5</span>] = <span class="number">105</span></span><br><span class="line">Element[<span class="number">6</span>] = <span class="number">106</span></span><br><span class="line">Element[<span class="number">7</span>] = <span class="number">107</span></span><br><span class="line">Element[<span class="number">8</span>] = <span class="number">108</span></span><br><span class="line">Element[<span class="number">9</span>] = <span class="number">109</span></span><br></pre></td></tr></table></figure>



<h4 id="数组的数组（锯齿数组）"><a href="#数组的数组（锯齿数组）" class="headerlink" title="数组的数组（锯齿数组）"></a>数组的数组（锯齿数组）</h4><p>普通的数组称为矩形数组，因为每一行的元素个数都相等。</p>
<p>如果需要每行的元素个数不同，可以使用锯齿数组（jagged array)</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span>[][] jaggedIntArray;</span><br><span class="line">            <span class="comment">//jaggedIntArray= new int[3][4];//不能像普通数组一样声明。就算可以，也没有意义。因为这样就像普通数组一样了。</span></span><br><span class="line">            <span class="comment">//jaggedIntArray = &#123; &#123;1, 2, 3 &#125;, &#123; 4, 5&#125;, &#123; 6, 7, 8, 9&#125; &#125;;//也不可以这样</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//可用的两种方法：</span></span><br><span class="line">            jaggedIntArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>][];<span class="comment">//先声明第一层</span></span><br><span class="line">            jaggedIntArray[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>];<span class="comment">//再声明第二层的第一个</span></span><br><span class="line">            jaggedIntArray[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];<span class="comment">//再声明第二层第二个</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//第二种方法</span></span><br><span class="line">            jaggedIntArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>][]</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历的时候，也不能简单的使用foreach了，需要根据层数嵌套</span></span><br><span class="line">            <span class="comment">//foreach(int i in jaggedIntArray)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    Console.WriteLine(i);//因为i的类型是int[]</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">int</span>[] it <span class="keyword">in</span> jaggedIntArray)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span>(<span class="built_in">int</span> i <span class="keyword">in</span> it)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.Write(<span class="string">$&quot;<span class="subst">&#123; i&#125;</span> &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="锯齿数组的注意事项"><a href="#锯齿数组的注意事项" class="headerlink" title="锯齿数组的注意事项"></a>锯齿数组的注意事项</h4><ul>
<li>声明和遍历方法均与普通的数组有一定的区别，需要注意。</li>
<li>有点类似于c++中的数组指针？外一层的类型是内一层的数组指针，每一个指针单独malloc大小存储数据。</li>
</ul>
<h4 id="C-数组细节"><a href="#C-数组细节" class="headerlink" title="C#	 数组细节"></a>C#	 数组细节</h4><table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-multi-dimensional-arrays.html">多维数组</a></td>
<td align="left">C# 支持多维数组。多维数组最简单的形式是二维数组。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-jagged-arrays.html">交错数组</a></td>
<td align="left">C# 支持交错数组，即数组的数组。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-passing-arrays-to-functions.html">传递数组给函数</a></td>
<td align="left">您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-param-arrays.html">参数数组</a></td>
<td align="left">这通常用于传递未知数量的参数给函数。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-array-class.html">Array 类</a></td>
<td align="left"><strong>在 System 命名空间中定义，是所有数组的基类，并提供了各种用于数组的属性和方法。</strong></td>
</tr>
<tr>
<td align="left">数组的数据类型</td>
<td align="left">数组元素的类型后面加上[]。如：System.Int32[]</td>
</tr>
</tbody></table>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>比如 <code>const int N = 1e5+10;</code></p>
<p>​	常量是固定值，程序执行期间不会改变。<strong>常量可以是任何基本数据类型</strong>，比如整数常量、浮点常量、字符常量或者字符串常量，还有枚举常量。</p>
<p>​	常量可以被当作常规的变量，只是它们的值在定义后不能被修改。</p>
<p>​	常量隶属于类型，因此没有实例常量一说。对于“实例常量”只能使用只读实例字段（属性）实现。</p>
<p>​	只读实例字段仍然是一个变量，访问变量需要访问这个这个变量所在的地址，<strong>访问变量的效率不如访问常量</strong>。</p>
<p>​	成员常量，是类的常量，如<code>Math.PI</code>, <code>int.MaxValue</code>等</p>
<p>​	局部常量，是在方法体内的常量，如</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;      </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">int</span> x = <span class="number">100</span>;          </span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h3><p>​	整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，没有前缀则表示十进制。</p>
<p>​	整数常量也可以有后缀，可以是 U 和 L 的组合，其中，U 和 L 分别表示 unsigned 和 long。后缀可以是大写或者小写，多个后缀以任意顺序进行组合。</p>
<p>这里有一些整数常量的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">212         /* 合法 */</span><br><span class="line">215u        /* 合法 */</span><br><span class="line">0xFeeL      /* 合法 */</span><br><span class="line">078         /* 非法：8 不是一个八进制数字 */</span><br><span class="line">032UU       /* 非法：不能重复后缀 */</span><br></pre></td></tr></table></figure>

<p>​	以下是各种类型的整数常量的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">85         /* 十进制 */</span><br><span class="line">0213       /* 八进制 */</span><br><span class="line">0x4b       /* 十六进制 */</span><br><span class="line">30         /* int */</span><br><span class="line">30u        /* 无符号 int */</span><br><span class="line">30l        /* long */</span><br><span class="line">30ul       /* 无符号 long */</span><br></pre></td></tr></table></figure>

<h3 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h3><p>​	一个浮点常量是由整数部分、小数点、小数部分和指数部分组成。可以使用小数形式或者指数形式来表示浮点常量。</p>
<p>​	这里有一些浮点常量的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.14159       /* 合法 */</span><br><span class="line">314159E-5L    /* 合法 */</span><br><span class="line">510E          /* 非法：不完全指数 */</span><br><span class="line">210f          /* 非法：没有小数或指数 */</span><br><span class="line">.e55          /* 非法：缺少整数或小数 */</span><br></pre></td></tr></table></figure>

<p>使用浮点形式表示时，必须包含小数点、指数或同时包含两者。使用指数形式表示时，必须包含整数部分、小数部分或同时包含两者。有符号的指数是用 e 或 E 表示的。</p>
<h3 id="字符常量和转义字符"><a href="#字符常量和转义字符" class="headerlink" title="字符常量和转义字符"></a>字符常量和转义字符</h3><p>字符常量是括在单引号里，例如，’x’，且可存储在一个简单的字符类型变量中。一个字符常量可以是一个普通字符（例如 ‘x’）、一个转义序列（例如 ‘\t’）或者一个通用字符（例如 ‘\u02C0’）。</p>
<p>在 C# 中有一些特定的字符，当它们的前面带有反斜杠时有特殊的意义，可用于表示换行符（\n）或制表符 tab（\t）。在这里，列出一些转义序列码：</p>
<table>
<thead>
<tr>
<th align="left">转义序列</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\\</td>
<td align="left">\ 字符</td>
</tr>
<tr>
<td align="left">\‘</td>
<td align="left">‘ 字符</td>
</tr>
<tr>
<td align="left">\“</td>
<td align="left">“ 字符</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">? 字符</td>
</tr>
<tr>
<td align="left">\a</td>
<td align="left">警告（产生蜂鸣）</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">退格键（Backspace）</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页符（Form feed）</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行符（Newline）</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">水平制表符 tab</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">垂直制表符 tab</td>
</tr>
<tr>
<td align="left">\ooo</td>
<td align="left">一到三位的八进制数</td>
</tr>
<tr>
<td align="left">\xhh . . .</td>
<td align="left">一个或多个数字的十六进制数</td>
</tr>
</tbody></table>
<p>以下是一些转义序列字符的实例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">EscapeChar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello\tWorld\n\n&quot;</span>);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello   World</span><br></pre></td></tr></table></figure>

<h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>字符串常量是括在双引号 <code>&quot;&quot;</code>里，或者是括在 <code>@&quot;&quot;</code> 里。字符串常量包含的字符与字符常量相似，可以是：普通字符、转义序列和通用字符</p>
<p>使用字符串常量时，可以把一个很长的行拆成多个行，可以使用空格分隔各个部分。</p>
<p>这里是一些字符串常量的实例。下面所列的各种形式表示相同的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string a = &quot;hello, world&quot;;                  // hello, world</span><br><span class="line">string b = @&quot;hello, world&quot;;               // hello, world</span><br><span class="line">string c = &quot;hello \t world&quot;;               // hello     world</span><br><span class="line">string d = @&quot;hello \t world&quot;;               // hello \t world</span><br><span class="line">string e = &quot;Joe said \&quot;Hello\&quot; to me&quot;;      // Joe said &quot;Hello&quot; to me</span><br><span class="line">string f = @&quot;Joe said &quot;&quot;Hello&quot;&quot; to me&quot;;   // Joe said &quot;Hello&quot; to me</span><br><span class="line">string g = &quot;\\\\server\\share\\file.txt&quot;;   // \\server\share\file.txt</span><br><span class="line">string h = @&quot;\\server\share\file.txt&quot;;      // \\server\share\file.txt</span><br><span class="line">string i = &quot;one\r\ntwo\r\nthree&quot;;</span><br><span class="line">string j = @&quot;one</span><br><span class="line">two</span><br><span class="line">three&quot;;</span><br></pre></td></tr></table></figure>



<h3 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h3><p>常量是使用 <strong>const</strong> 关键字来定义的 。定义一个常量的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &lt;data_type&gt; &lt;constant_name&gt; = value;</span><br></pre></td></tr></table></figure>

<p>下面的代码演示了如何在程序中定义和使用常量：</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConstTest</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title">SampleClass</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> c1 = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> c2 = c1 + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SampleClass</span>(<span class="params"><span class="built_in">int</span> p1, <span class="built_in">int</span> p2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      x = p1;</span><br><span class="line">      y = p2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    SampleClass mC = <span class="keyword">new</span> SampleClass(<span class="number">11</span>, <span class="number">22</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;x = &#123;0&#125;, y = &#123;1&#125;&quot;</span>, mC.x, mC.y);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;c1 = &#123;0&#125;, c2 = &#123;1&#125;&quot;</span>,</span><br><span class="line">             SampleClass.c1, SampleClass.c2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 11, y = 22</span><br><span class="line">c1 = 5, c2 = 10</span><br></pre></td></tr></table></figure>













<h2 id="字符串（String）类型与处理"><a href="#字符串（String）类型与处理" class="headerlink" title="字符串（String）类型与处理"></a>字符串（String）类型与处理</h2><p>​	<strong>字符串（String）类型</strong> 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。<strong>字符串（String）类型的值可以通过两种形式进行分配：双引号和 @双引号</strong></p>
<p>例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;hurriedlu&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>一个 @引号字符串：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="string">@&quot;hurriedlu&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>C# string 字符串的前面可以加 @（称作”逐字字符串”）将转义字符（\）当作普通字符对待，比如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">@&quot;C:\Windows&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string str = &quot;C:\\Windows&quot;;</span><br></pre></td></tr></table></figure>

<p>@ 字符串中可以<strong>任意换行</strong>，换行符及缩进空格都计算在字符串长度之内。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">@&quot;&lt;script type=&quot;&quot;text/javascript&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;!--</span></span><br><span class="line"><span class="string">    --&gt;</span></span><br><span class="line"><span class="string">&lt;/script&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>用户自定义引用类型有：class、interface 或 delegate。我们将在以后的章节中讨论这些类型。</p>
<h3 id="字符串的处理"><a href="#字符串的处理" class="headerlink" title="字符串的处理"></a>字符串的处理</h3><ul>
<li><p>string类型的遍历可以视为char变量的只读数组。</p>
<ul>
<li>例如：char c &#x3D; str[0];</li>
</ul>
</li>
<li><p>如果需要将string转换成一个可写的char数组，可以使用如下代码:</p>
<ul>
<li><pre><code class="language-c#">string str = &quot;hurriedlu&quot;;
char[] myChars = str.ToCharArray();
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 也可以使用foreach遍历字符串</span><br><span class="line"></span><br><span class="line">  - ```c#</span><br><span class="line">    string str = &quot;hurriedlu&quot;;</span><br><span class="line">    foreach(char c in str)</span><br><span class="line">    &#123;</span><br><span class="line">    	Console.Write($&quot;&#123;c&#125; &quot;);//输出：h u r r i e d l u</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>与普通数组一样，可以使用<code>.Length</code>获取数组长度。如：</p>
<ul>
<li><pre><code class="language-c#">string str = &quot;hurriedlu&quot;;
Console.WriteLine(str.Length);//输出：9
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 将字符串转换成全大写或全小写</span><br><span class="line"></span><br><span class="line">  - ```c#</span><br><span class="line">    string str = &quot;hUrrIEdlu&quot;;</span><br><span class="line">    Console.WriteLine(str);//原样输出</span><br><span class="line">    Console.WriteLine(str.ToLower());//转换成全小写后输出</span><br><span class="line">    Console.WriteLine(str.ToUpper());//转换成全大写后输出</span><br><span class="line">    //输出：hUrrIEdlu</span><br><span class="line">    //      hurriedlu</span><br><span class="line">    //      HURRIEDLU</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>注意，这个方法不会改变原有的值，而是创建一个新的值，新的值是全大&#x2F;小写的，并把这个值通过返回值的形式输出出去。</p>
</li>
</ul>
</li>
<li><p>去除多余的前后空格（也可以删除指定的字符）。使用Trim删除指定字符的时候，会遍历整个string遍历，遇到符合的字母就会删除，遇到不符合的就停止删除操作</p>
<ul>
<li><pre><code class="language-c#">string str = &quot;  hu  rr          &quot;;
Console.WriteLine(str.Trim());//去除多余的前后空格，输出“hu  rr”
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```c#</span><br><span class="line">  char[] trimChars = new char[] &#123; &#x27; &#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;u&#x27; &#125;;</span><br><span class="line">  string str = &quot;  hu  rriedlu          &quot;;</span><br><span class="line">  str = str.Trim(trimChars);//从头或者尾扫描，如果字符是数组trimChars的值就删掉，直到非trimChars数组的值停下，不再删除 直接返回剩余的字符串</span><br><span class="line">  Console.WriteLine(str);//删除指定的元素，这里指定了空格、h和i，输出“rriedl”</span><br><span class="line">  Console.WriteLine(str.Length);//输出6</span><br></pre></td></tr></table></figure>

- 可以看到在这个样例中，开头和结尾处的指定元素已经被删除了，但在中间的i并没有被删除。因为只要遇到非trimChars数组的值就停下，然后直接返回剩余的值。
</code></pre>
</li>
</ul>
</li>
<li><p>在字符串的指定位置添加空格，常用于对齐字符串（数字）。</p>
<ul>
<li><pre><code class="language-c#">string str1 = &quot;hurr&quot;;
string str2 = &quot;hurriedlu&quot;;
//9表示字符串将变成9长度，在新增加的位置上补‘0’.
str1 = str1.PadLeft(9, &#39;0&#39;);//可以自定义补充元素，如果不指定就默认是空格。
Console.WriteLine(str1);
Console.WriteLine(str2);
//输出：
// 00000hurr
// hurriedlu
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 动态（Dynamic）类型</span><br><span class="line"></span><br><span class="line">​	可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。</span><br><span class="line"></span><br><span class="line">### 声明动态类型的语法：</span><br><span class="line"></span><br><span class="line">```c#</span><br><span class="line">dynamic &lt;variable_name&gt; = value;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> d = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。</p>
<h2 id="隐式变量"><a href="#隐式变量" class="headerlink" title="隐式变量"></a>隐式变量</h2><p>​	可声明局部变量而无需提供显式类型。 <code>var</code> 关键字指示<strong>编译器通过初始化语句右侧的表达式推断变量的类型</strong>。 推断类型可以是内置类型、匿名类型、用户定义类型或 .NET 类库中定义的类型。 有关如何使用 <code>var</code> 初始化数组的详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/arrays/implicitly-typed-arrays">隐式类型化数组</a>。</p>
<p>以下示例演示使用 <code>var</code> 声明局部变量的各种方式：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i is compiled as an int</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s is compiled as a string</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a is compiled as int[]</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span>[] &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// expr is compiled as IEnumerable&lt;Customer&gt;</span></span><br><span class="line"><span class="comment">// or perhaps IQueryable&lt;Customer&gt;</span></span><br><span class="line"><span class="keyword">var</span> expr =</span><br><span class="line">    <span class="keyword">from</span> c <span class="keyword">in</span> customers</span><br><span class="line">    <span class="keyword">where</span> c.City == <span class="string">&quot;London&quot;</span></span><br><span class="line">    <span class="keyword">select</span> c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// anon is compiled as an anonymous type</span></span><br><span class="line"><span class="keyword">var</span> anon = <span class="keyword">new</span> &#123; Name = <span class="string">&quot;Terry&quot;</span>, Age = <span class="number">34</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list is compiled as List&lt;int&gt;</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure>



<p>重要的是了解 <code>var</code> 关键字并不意味着“变体”，并且并不指示变量是松散类型或是后期绑定。 <strong>它只表示由编译器确定并分配最适合的类型。</strong></p>
<p>在以下上下文中，可使用 <code>var</code> 关键字：</p>
<ul>
<li><p>在局部变量（在方法范围内声明的变量）上，如前面的示例所示。</p>
</li>
<li><p>在 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">for</a> 初始化语句中。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">1</span>; x &lt; <span class="number">10</span>; x++)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">foreach</a> 初始化语句中。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> list) &#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/using-statement">using</a> 域间中。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> <span class="keyword">file</span> = <span class="keyword">new</span> StreamReader(<span class="string">&quot;C:\\myfile.txt&quot;</span>)) &#123;...&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/how-to-use-implicitly-typed-local-variables-and-arrays-in-a-query-expression">如何在查询表达式中使用隐式类型化局部变量和数组</a>。</p>
<h3 id="var-和匿名类型"><a href="#var-和匿名类型" class="headerlink" title="var 和匿名类型"></a>var 和匿名类型</h3><p>在许多情况下，使用 <code>var</code> 是可选的，只是一种语法便利。 但是，在使用匿名类型初始化变量时，如果需要在以后访问对象的属性，则必须将变量声明为 <code>var</code>。 这是 LINQ 查询表达式中的常见方案。 有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/types/anonymous-types">匿名类型</a>。</p>
<p>从源代码角度来看，匿名类型没有名称。 因此，如果使用 <code>var</code> 初始化了查询变量，则访问返回对象序列中的属性的唯一方法是在 <code>foreach</code> 语句中将 <code>var</code> 用作迭代变量的类型。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ImplicitlyTypedLocals2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span>[] words = &#123; <span class="string">&quot;aPPLE&quot;</span>, <span class="string">&quot;BlUeBeRrY&quot;</span>, <span class="string">&quot;cHeRry&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a query produces a sequence of anonymous types,</span></span><br><span class="line">        <span class="comment">// then use var in the foreach statement to access the properties.</span></span><br><span class="line">        <span class="keyword">var</span> upperLowerWords =</span><br><span class="line">             <span class="keyword">from</span> w <span class="keyword">in</span> words</span><br><span class="line">             <span class="keyword">select</span> <span class="keyword">new</span> &#123; Upper = w.ToUpper(), Lower = w.ToLower() &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Execute the query</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> ul <span class="keyword">in</span> upperLowerWords)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Uppercase: &#123;0&#125;, Lowercase: &#123;1&#125;&quot;</span>, ul.Upper, ul.Lower);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Outputs:</span></span><br><span class="line"><span class="comment">    Uppercase: APPLE, Lowercase: apple</span></span><br><span class="line"><span class="comment">    Uppercase: BLUEBERRY, Lowercase: blueberry</span></span><br><span class="line"><span class="comment">    Uppercase: CHERRY, Lowercase: cherry</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>以下限制适用于隐式类型化变量声明：</p>
<ul>
<li>仅当局部变量在相同语句中进行声明和初始化时，才能使用 <code>var</code>；<strong>变量不能初始化为 null</strong>，也不能初始化为方法组或匿名函数。</li>
<li><code>var</code> 不能在类范围内对字段使用。</li>
<li>使用 <code>var</code> 声明的变量不能在初始化表达式中使用。 换句话说，此表达式是合法的：<code>int i = (i = 20);</code>，但是此表达式会生成编译时错误：<code>var i = (i = 20);</code></li>
<li>不能在相同语句中初始化多个隐式类型化变量。</li>
<li>如果一种名为 <code>var</code> 的类型处于范围内，则 <code>var</code> 关键字会解析为该类型名称，不会被视为隐式类型化局部变量声明的一部分。</li>
</ul>
<p>带 <code>var</code> 关键字的隐式类型只能应用于本地方法范围内的变量。 隐式类型不可用于类字段，因为 C# 编译器在处理代码时会遇到逻辑悖论：编译器需要知道字段的类型，但它在分析赋值表达式前无法确定类型，而表达式在不知道类型的情况下无法进行计算。 考虑下列代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> bookTitles;</span><br></pre></td></tr></table></figure>

<p><code>bookTitles</code> 是类型为 <code>var</code> 的类字段。 由于该字段没有要计算的表达式，编译器无法推断出 <code>bookTitles</code> 应该是哪种类型。 此外，向该字段添加表达式（就像对本地变量执行的操作一样）也是不够的：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> bookTitles = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure>

<p>当编译器在代码编译期间遇到字段时，它会在处理与其关联的任何表达式之前记录每个字段的类型。 编译器在尝试分析 <code>bookTitles</code> 时遇到相同的悖论：它需要知道字段的类型，但编译器通常会通过分析表达式来确定 <code>var</code> 的类型，这在事先不知道类型的情况下无法实现。</p>
<p>你可能会发现，对于在其中难以确定查询变量的确切构造类型的查询表达式，<code>var</code> 也可能会十分有用。 这可能会针对分组和排序操作发生。</p>
<p>当变量的特定类型在键盘上键入时很繁琐、或是显而易见、或是不会提高代码的可读性时，<code>var</code> 关键字也可能非常有用。 <code>var</code> 采用此方法提供帮助的一个示例是针对嵌套泛型类型（如用于分组操作的类型）。 在下面的查询中，查询变量的类型是 <code>IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt;</code>。 只要你和必须维护你的代码的其他人了解这一点，使用隐式类型化实现便利性和简便性时便不会出现问题。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Same as previous example except we use the entire last name as a key.</span></span><br><span class="line"><span class="comment">// Query variable is an IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt;</span></span><br><span class="line"><span class="keyword">var</span> studentQuery3 =</span><br><span class="line">    <span class="keyword">from</span> student <span class="keyword">in</span> students</span><br><span class="line">    <span class="keyword">group</span> student <span class="keyword">by</span> student.Last;</span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>var</code> 有助于简化代码，但是它的使用应该限制在需要使用它的情况下，或在它可使代码更易于读取的情况下</strong>。 有关何时正确使用 <code>var</code> 的详细信息，请参阅 C# 编码指南一文中的<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/coding-style/coding-conventions#implicitly-typed-local-variables">隐式类型本地变量</a>节。</p>
<h2 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C# 类型转换"></a>C# 类型转换</h2><h3 id="隐式转换和显示转换"><a href="#隐式转换和显示转换" class="headerlink" title="隐式转换和显示转换"></a>隐式转换和显示转换</h3><p>类型转换从根本上说是类型铸造，或者说是把数据从一种类型转换为另一种类型。在 C# 中，类型铸造有两种形式：</p>
<ul>
<li><p><strong>隐式类型转换</strong> - 这些转换是 C# 默认的以安全方式进行的转换, 不会导致数据丢失。例如，从小的整数类型转换为大的整数类型，从派生类转换为基类。</p>
<ul>
<li>当试图用一个引用变量去访问它引用的实例的成员时，只能访问到这个变量所具有的成员。当用基类变量指向一个派生类的实例时，变量只能调用基类的成员（即使出现了重载，也会使用基类的而非派生类）。</li>
</ul>
</li>
<li><p><strong>显式类型转换</strong> - 显式类型转换，即强制类型转换。显式转换需要强制转换运算符，而且强制转换会造成数据丢失。</p>
</li>
</ul>
<p>下面的实例显示了一个显式的类型转换：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">TypeConversionApplication</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title">ExplicitConversion</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">double</span> d = <span class="number">5673.74</span>;</span><br><span class="line">      <span class="built_in">int</span> i;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 强制转换 double 为 int</span></span><br><span class="line">      i = (<span class="built_in">int</span>)d;</span><br><span class="line">      Console.WriteLine(i);</span><br><span class="line">      Console.ReadKey();</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5673</span><br></pre></td></tr></table></figure>



<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p>如果彼此之间没有什么关系的类型不能进行强制转换。如string到int。</p>
</li>
<li><p>如果发生溢出，可以使用<code>checked</code>对可能溢出的代码进行修饰（或 包括），这样如果发生溢出就会抛出异常。详见<code>c#基本语句</code>中的<code>checked/unchecked语句</code></p>
</li>
</ul>
<h3 id="Convert转换"><a href="#Convert转换" class="headerlink" title="Convert转换"></a>Convert转换</h3><p>C# 提供了Convert类，其中内置了下列的一些类型转换方法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>ToBoolean</strong> 如果可能的话，把类型转换为布尔型。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>ToByte</strong> 把类型转换为字节类型。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>ToChar</strong> 如果可能的话，把类型转换为单个 Unicode 字符类型。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>ToDateTime</strong> 把类型（整数或字符串类型）转换为 日期-时间 结构。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>ToDecimal</strong> 把浮点型或整数类型转换为十进制类型。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>ToDouble</strong> 把类型转换为双精度浮点型。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>ToInt16</strong> 把类型转换为 16 位整数类型。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>ToInt32</strong> 把类型转换为 32 位整数类型。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>ToInt64</strong> 把类型转换为 64 位整数类型。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>ToSbyte</strong> 把类型转换为有符号字节类型。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>ToSingle</strong> 把类型转换为小浮点数类型。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>ToString</strong> 把类型转换为字符串类型。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>ToType</strong> 把类型转换为指定类型。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><strong>ToUInt16</strong> 把类型转换为 16 位无符号整数类型。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><strong>ToUInt32</strong> 把类型转换为 32 位无符号整数类型。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><strong>ToUInt64</strong> 把类型转换为 64 位无符号整数类型。</td>
</tr>
</tbody></table>
<p>下面的实例把不同值的类型转换为字符串类型：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">TypeConversionApplication</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title">StringConversion</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">int</span> i = <span class="number">75</span>;</span><br><span class="line">      <span class="built_in">float</span> f = <span class="number">53.005f</span>;</span><br><span class="line">      <span class="built_in">double</span> d = <span class="number">2345.7652</span>;</span><br><span class="line">      <span class="built_in">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      Console.WriteLine(i.ToString());</span><br><span class="line">      Console.WriteLine(f.ToString());</span><br><span class="line">      Console.WriteLine(d.ToString());</span><br><span class="line">      Console.WriteLine(b.ToString());</span><br><span class="line">      Console.ReadKey();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">75</span><br><span class="line">53.005</span><br><span class="line">2345.7652</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>使用Convert类进行数值转换的时候，是比较安全的，转换的时候会自动检测精度是否会受损或者字符串是否是一个正确的数值，如果发生溢出或不是正确的字符串，会抛出异常。</li>
<li>数值的有效表达方式：<ul>
<li>首先是一个可选符号(加号或减号)，然后是0位或多位数字，一个可选的句点后跟一位或多位数字，接着是一个可选的e或E，后跟一个可选符号和一位或多位数字，除了还可能有空格(在这个序列之前或之后)，不能有其他字符。利用这些可选的额外数据，可将- 1.2451e -24这样复杂的字符串识别为数值。</li>
</ul>
</li>
<li>总是要进行溢出检查，checked 和unchecked关键字以及项目属性设置不起作用。</li>
</ul>
<h3 id="Parse转换"><a href="#Parse转换" class="headerlink" title="Parse转换"></a>Parse转换</h3><p>用于string类型转其他类型，实际上是一种对字符串的解析。</p>
<p>需要注意的是，Parse只对格式正确的字符串进行解析，对于格式不正确的字符串会抛出<code>System.FormatException:“输入字符串的格式不正确。”</code>异常。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;123.456&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">&quot;123.123.234&quot;</span>;<span class="comment">//格式错误</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> d1 = <span class="built_in">double</span>.Parse(str1);</span><br><span class="line"><span class="comment">//double d2 = double.Parse(str2); //会抛出错误</span></span><br></pre></td></tr></table></figure>

<h4 id="升级版的TryParse"><a href="#升级版的TryParse" class="headerlink" title="升级版的TryParse"></a>升级版的TryParse</h4><p>尝试转换，转换成功通过参数带回。返回值是一个布尔类型的变量。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;123.456&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">&quot;123.123.234&quot;</span>;<span class="comment">//格式错误</span></span><br><span class="line"><span class="built_in">double</span> d1;</span><br><span class="line"><span class="built_in">double</span> d2;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">double</span>.TryParse(str1,<span class="keyword">out</span> d1))</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;转换成功&quot;</span>);    </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	Console.WriteLine(<span class="string">&quot;转换失败&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">double</span>.TryParse(str2, <span class="keyword">out</span> d2))</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;转换成功&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	Console.WriteLine(<span class="string">&quot;转换失败&quot;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="自定义类型转换"><a href="#自定义类型转换" class="headerlink" title="自定义类型转换"></a>自定义类型转换</h4><h5 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h5><p>​		类型转换有2种：隐式转换和显式转换。但是，不管是隐式转换，还是显式转换，都是生成了一个新对象返回的。改变新对象的属性，不会影响老对象！(dynamic对象除外，详情搜索dynamic动态类型。)</p>
<p>自定义隐式&#x2F;显式转换的方法需要用到几个关键字：implicit(隐式转换)、explicit(显式转换)、operator(操作符)。更多的注意点见下：</p>
<ul>
<li>方法必须是static</li>
<li>使用implicit或explicit</li>
<li>搭配operator(此也是c#关键字，可在类别或结构宣告内多载内建运算子或提供使用者定义的转换)</li>
<li>返回值为要转换为的目标类型，但不要在方法上声明，方法名为目标类型。注意：返回值不一定是本类类型。本类型和其他类型之间可以互相转换，只要定义转换方法就行。</li>
<li>参数为原始类型，方法名为目标类型</li>
<li>类A到类B的类型转换定义不能在类C中进行（即2个类的转换不能在第3个类中定义），否则会报错：用户定义的转换必须是转换成封闭类型，或者从封闭类型转换。具体查看后面的用户定义的转换必须是转换成封闭类型，或者从封闭类型转换</li>
<li>不能被virtual&#x2F;override修饰（不能“覆盖”运算符，因为它们是静态的。）Overriding implicit operators in C#</li>
</ul>
<p>对于自定义类型而言，可以手动的自定义类型转换。</p>
<h5 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            A a = <span class="keyword">new</span> A();</span><br><span class="line">            B b = (B)a;<span class="comment">//自定义类型转换</span></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">B</span>(<span class="params">A a</span>)<span class="comment">//自定义转换规则，显示类型转换，如果需要隐式转换，则将explicit换成implicit即可。</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            B b = <span class="keyword">new</span> B();<span class="comment">//创建一个目标对象</span></span><br><span class="line">            b.n = a.n;<span class="comment">//将自己的值按照一定的规则传给b对象</span></span><br><span class="line">            <span class="keyword">return</span> b;<span class="comment">//转换完成后返回目标对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="样例2"><a href="#样例2" class="headerlink" title="样例2"></a>样例2</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//================定义类型和方法================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Robot</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Robot</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Id = id;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 其他类型-&gt;本类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//隐式转换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">Robot</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Robot(<span class="number">101</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显式转换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">Robot</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Robot(id, <span class="string">&quot;miku&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 本类-&gt;其他类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//隐式转换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">string</span>(<span class="params">Robot robot</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> robot.Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显式转换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span>(<span class="params">Robot robot</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> robot.Id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//================测试代码================</span></span><br><span class="line"><span class="meta">#<span class="keyword">region</span> 其他类型-&gt;本类</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> gumiStr = <span class="string">&quot;gumi&quot;</span>;</span><br><span class="line">Robot gumi001 = gumiStr; <span class="comment">//隐式转换</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;隐式转换：gumi001 : &#123;0&#125;&quot;</span>, JsonConvert.SerializeObject(gumi001));</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> lukaId = <span class="number">1004</span>;</span><br><span class="line">Robot luka001 = (Robot)lukaId; <span class="comment">//显式转换</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;显式转换：luka001 : &#123;0&#125;&quot;</span>, JsonConvert.SerializeObject(luka001));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">region</span> 其他类型-&gt;本类</span></span><br><span class="line"></span><br><span class="line">Robot miku001 = <span class="keyword">new</span> Robot(<span class="number">1001</span>, <span class="string">&quot;miku10001&quot;</span>);</span><br><span class="line"><span class="comment">//隐式转换</span></span><br><span class="line"><span class="built_in">string</span> mikuName = miku001;</span><br><span class="line"><span class="comment">//显式转换</span></span><br><span class="line"><span class="built_in">int</span> mikuId = (<span class="built_in">int</span>)miku001;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;隐式转换：miku001 Name: &#123;0&#125;&quot;</span>, mikuName);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;显式转换：miku001 Id: &#123;0&#125;&quot;</span>, mikuId);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">隐式转换：gumi001 : &#123;<span class="string">&quot;Id&quot;</span>:<span class="number">101</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;gumi&quot;</span>&#125;</span><br><span class="line">显式转换：luka001 : &#123;<span class="string">&quot;Id&quot;</span>:<span class="number">1004</span>,<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;miku&quot;</span>&#125;</span><br><span class="line">隐式转换：miku001 Name: miku10001</span><br><span class="line">显式转换：miku001 Id: <span class="number">1001</span></span><br></pre></td></tr></table></figure>





<h5 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h5><p>问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,[[2,2],[2,2],[2,2],[2,2]]]</span><br></pre></td></tr></table></figure>

<p>这样一个字符串，如何可以反序列化成一个对象？（如何定义这个类？）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Newtonsoft.Json;</span><br><span class="line"><span class="keyword">using</span> Newtonsoft.Json.Linq;</span><br><span class="line">                    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> json = <span class="string">&quot;[1,[[2,2],[2,2],[2,2],[2,2]]]&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> root = JsonConvert.DeserializeObject&lt;Root&gt;(json);</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> ele <span class="keyword">in</span> root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ele.SingleValue.HasValue)</span><br><span class="line">            &#123;<span class="comment">//有值，原始数据为 1</span></span><br><span class="line">                Console.WriteLine(ele.SingleValue.Value);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;<span class="comment">//原始数据为 二维数组</span></span><br><span class="line">                Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot; &quot;</span>,ele.Select(x=&gt;<span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>,x))));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(JsonConvert.SerializeObject(root));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Root</span> : <span class="title">List</span>&lt;<span class="title">Element</span>&gt; &#123; &#125;</span><br><span class="line">[<span class="meta">JsonConverter(typeof(CConverter))</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">Element</span> : <span class="title">List</span>&lt;<span class="title">List</span>&lt;<span class="title">long</span>&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//该属性，存放 1 。后续可以通过判断该属性是否有值来得知原始数据的情况</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span>? SingleValue &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遇到 1 ，隐式转换为 该类型，其中 1 被存放到SingleValue属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">Element</span>(<span class="params"><span class="built_in">long</span> d</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Element &#123; SingleValue = d &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CConverter</span> : <span class="title">JsonConverter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">CanConvert</span>(<span class="params">Type objectType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (objectType == <span class="keyword">typeof</span>(Element));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> CanRead  &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">ReadJson</span>(<span class="params">JsonReader reader, Type objectType, <span class="built_in">object</span> existingValue, JsonSerializer serializer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">WriteJson</span>(<span class="params">JsonWriter writer, <span class="built_in">object</span> <span class="keyword">value</span>, JsonSerializer serializer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> ele = <span class="keyword">value</span> <span class="keyword">as</span> Element;</span><br><span class="line">        <span class="keyword">var</span> token = ele.SingleValue.HasValue ? JToken.FromObject(ele.SingleValue.Value) : JToken.FromObject(ele.ToList());</span><br><span class="line">        token.WriteTo(writer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> CanWrite &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来源：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1986028#:~:text=C%23%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%201%20%E6%96%B9%E6%B3%95%E5%BF%85%E9%A0%88%E6%98%AFstatic%202%20%E4%BD%BF%E7%94%A8%20implicit%20%E6%88%96%20explicit,%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%BF%85%E9%A1%BB%E6%98%AF%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%81%E9%97%AD%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%88%96%E8%80%85%E4%BB%8E%E5%B0%81%E9%97%AD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%207%20%E4%B8%8D%E8%83%BD%E8%A2%AB%20virtual%20%2F%20override%20%E4%BF%AE%E9%A5%B0%EF%BC%88%E4%B8%8D%E8%83%BD%E2%80%9C%E8%A6%86%E7%9B%96%E2%80%9D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%83%E4%BB%AC%E6%98%AF%E9%9D%99%E6%80%81%E7%9A%84%E3%80%82%20">https://cloud.tencent.com/developer/article/1986028#:~:text=C%23%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%201%20%E6%96%B9%E6%B3%95%E5%BF%85%E9%A0%88%E6%98%AFstatic%202%20%E4%BD%BF%E7%94%A8%20implicit%20%E6%88%96%20explicit,%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%BF%85%E9%A1%BB%E6%98%AF%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%81%E9%97%AD%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%88%96%E8%80%85%E4%BB%8E%E5%B0%81%E9%97%AD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%207%20%E4%B8%8D%E8%83%BD%E8%A2%AB%20virtual%20%2F%20override%20%E4%BF%AE%E9%A5%B0%EF%BC%88%E4%B8%8D%E8%83%BD%E2%80%9C%E8%A6%86%E7%9B%96%E2%80%9D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%83%E4%BB%AC%E6%98%AF%E9%9D%99%E6%80%81%E7%9A%84%E3%80%82%20</a></p>
<h3 id="C-中的-Lvalues-和-Rvalues"><a href="#C-中的-Lvalues-和-Rvalues" class="headerlink" title="C# 中的 Lvalues 和 Rvalues"></a>C# 中的 Lvalues 和 Rvalues</h3><p>C# 中的两种表达式：（变量和常量？）</p>
<ol>
<li><strong>lvalue</strong>：lvalue 表达式可以出现在赋值语句的左边或右边。</li>
<li><strong>rvalue</strong>：rvalue 表达式可以出现在赋值语句的右边，不能出现在赋值语句的左边。</li>
</ol>
<p>变量是 lvalue 的，所以可以出现在赋值语句的左边。数值是 rvalue 的，因此不能被赋值，不能出现在赋值语句的左边。下面是一个有效的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int g = 20;</span><br></pre></td></tr></table></figure>

<p>下面是一个无效的语句，会产生编译时错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 = 20;</span><br></pre></td></tr></table></figure>











<h2 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C# 运算符"></a>C# 运算符</h2><table>
<thead>
<tr>
<th>类别</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td>基本</td>
<td>x.y f(x) a[x] x++ x– new typeof default checked unchecked delegate sizeof -&gt;</td>
</tr>
<tr>
<td>一元</td>
<td>+ - ! ~ ++ – (T)x await &amp;x *x</td>
</tr>
<tr>
<td>乘法</td>
<td>* &#x2F; %</td>
</tr>
<tr>
<td>加减</td>
<td>+ -</td>
</tr>
<tr>
<td>移位</td>
<td>&lt;&lt; &gt;&gt;</td>
</tr>
<tr>
<td>关系</td>
<td>&lt; &gt; &lt;&#x3D; &gt;&#x3D;</td>
</tr>
<tr>
<td>类型检测</td>
<td>is as</td>
</tr>
<tr>
<td>相等</td>
<td>&#x3D;&#x3D; !&#x3D;</td>
</tr>
<tr>
<td>逻辑与</td>
<td>&amp;</td>
</tr>
<tr>
<td>逻辑异或</td>
<td>^</td>
</tr>
<tr>
<td>逻辑或</td>
<td>|</td>
</tr>
<tr>
<td>条件与</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>条件或</td>
<td>||</td>
</tr>
<tr>
<td>null 合并</td>
<td>??</td>
</tr>
<tr>
<td>条件</td>
<td>?:</td>
</tr>
<tr>
<td>赋值和lambda表达式</td>
<td>&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; +&#x3D; -&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D; &#x3D;&gt;</td>
</tr>
</tbody></table>
<ul>
<li>运算符也称为操作符</li>
<li>运算符的本质是函数的“简记法”</li>
<li>运算符不能脱离与它关联的数据类型</li>
</ul>
<p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。分类如下：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>其他运算</li>
</ul>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>C# 支持的所有算术运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">把两个操作数相加</td>
<td align="left">A + B 将得到 30</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">从第一个操作数中减去第二个操作数</td>
<td align="left">A - B 将得到 -10</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">把两个操作数相乘</td>
<td align="left">A * B 将得到 200</td>
</tr>
<tr>
<td align="left">&#x2F;</td>
<td align="left">分子除以分母</td>
<td align="left">B &#x2F; A 将得到 2</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">取模运算符，整除后的余数</td>
<td align="left">B % A 将得到 0</td>
</tr>
<tr>
<td align="left">++</td>
<td align="left">自增运算符，整数值增加 1</td>
<td align="left">A++ 将得到 11</td>
</tr>
<tr>
<td align="left">–</td>
<td align="left">自减运算符，整数值减少 1</td>
<td align="left">A– 将得到 9</td>
</tr>
</tbody></table>
<h3 id="乘法运算符"><a href="#乘法运算符" class="headerlink" title="乘法运算符"></a>乘法运算符</h3><p>对于 x * y 形式的运算，应用二元运算符重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。</p>
<p>下面列出了预定义的乘法运算符。这些运算符均计算 x 和 y 的乘积。</p>
<p>·    整数乘法：</p>
<p>int operator *(int x, int y);<br>uint operator *(uint x, uint y);<br>long operator *(long x, long y);<br>ulong operator *(ulong x, ulong y);</p>
<p>在 checked 上下文中，如果积超出结果类型的范围，则引发 System.OverflowException。在 unchecked 上下文中，不报告溢出并且结果类型范围外的任何有效高序位都被放弃。</p>
<p>·    浮点乘法：</p>
<p>float operator *(float x, float y);<br>double operator *(double x, double y);</p>
<p>根据 IEEE 754 算术运算法则计算乘积。下表列出了非零有限值、零、无穷大和 NaN 的所有可能组合的结果。在该表中，x 和 y 是正有限值，z 是 x * y 的结果。如果结果对目标类型而言太大，则 z 为无穷大。如果结果对目标类型而言太小，则 z 为零。</p>
<table>
<thead>
<tr>
<th></th>
<th>+y</th>
<th>–y</th>
<th>+0</th>
<th>–0</th>
<th>+∞</th>
<th>–∞</th>
<th>NaN</th>
</tr>
</thead>
<tbody><tr>
<td>+x</td>
<td>+z</td>
<td>–z</td>
<td>+0</td>
<td>–0</td>
<td>+∞</td>
<td>–∞</td>
<td>NaN</td>
</tr>
<tr>
<td>–x</td>
<td>–z</td>
<td>+z</td>
<td>–0</td>
<td>+0</td>
<td>–∞</td>
<td>+∞</td>
<td>NaN</td>
</tr>
<tr>
<td>+0</td>
<td>+0</td>
<td>–0</td>
<td>+0</td>
<td>–0</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>–0</td>
<td>–0</td>
<td>+0</td>
<td>–0</td>
<td>+0</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>+∞</td>
<td>+∞</td>
<td>–∞</td>
<td>NaN</td>
<td>NaN</td>
<td>+∞</td>
<td>–∞</td>
<td>NaN</td>
</tr>
<tr>
<td>–∞</td>
<td>–∞</td>
<td>+∞</td>
<td>NaN</td>
<td>NaN</td>
<td>–∞</td>
<td>+∞</td>
<td>NaN</td>
</tr>
<tr>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody></table>
<p>·    小数乘法：</p>
<p>decimal operator *(decimal x, decimal y);</p>
<p>如果结果值太大，不能用 decimal 格式表示，则将引发 System.OverflowException。如果结果值太小，无法用 decimal 格式表示，则结果为零。在进行任何舍入之前，结果的小数位数是两个操作数的小数位数的和。</p>
<p>小数乘法等效于使用 System.Decimal 类型的乘法运算符。</p>
<h3 id="除法运算符"><a href="#除法运算符" class="headerlink" title="除法运算符"></a>除法运算符</h3><p>对于 x &#x2F; y 形式的运算，应用二元运算符重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。</p>
<p>下面列出了预定义的除法运算符。这些运算符均计算 x 和 y 的商。</p>
<p>·    整数除法：</p>
<p>int operator &#x2F;(int x, int y);<br>uint operator &#x2F;(uint x, uint y);<br>long operator &#x2F;(long x, long y);<br>ulong operator &#x2F;(ulong x, ulong y);</p>
<p>如果右操作数的值为零，则引发 System.DivideByZeroException 导常。</p>
<p>除法将结果舍入到零。因此，结果的绝对值是小于或等于两个操作数的商的绝对值的最大可能整数。当两个操作数符号相同时，结果为零或正；当两个操作数符号相反时，结果为零或负。</p>
<p>如果左操作数为最小可表示 int 或 long 值，右操作数为 –1，则发生溢出。在 checked 上下文中，这会导致引发 System.ArithmeticException（或其子类）。在 unchecked 上下文中，它由实现定义为或者引发 System.ArithmeticException（或其子类），或者不以左操作数的结果值报告溢出。</p>
<p>·    浮点除法：</p>
<p>float operator &#x2F;(float x, float y);<br>double operator &#x2F;(double x, double y);</p>
<p>根据 IEEE 754 算法法则计算商。下表列出了非零有限值、零、无穷大和 NaN 的所有可能组合的结果。在该表中，x 和 y 是正有限值，z 是 x &#x2F; y 的结果。如果结果对目标类型而言太大，则 z 为无穷大。如果结果对目标类型而言太小，则 z 为零。</p>
<table>
<thead>
<tr>
<th></th>
<th>+y</th>
<th>–y</th>
<th>+0</th>
<th>–0</th>
<th>+∞</th>
<th>–∞</th>
<th>NaN</th>
</tr>
</thead>
<tbody><tr>
<td>+x</td>
<td>+z</td>
<td>–z</td>
<td>+∞</td>
<td>–∞</td>
<td>+0</td>
<td>–0</td>
<td>NaN</td>
</tr>
<tr>
<td>–x</td>
<td>–z</td>
<td>+z</td>
<td>–∞</td>
<td>+∞</td>
<td>–0</td>
<td>+0</td>
<td>NaN</td>
</tr>
<tr>
<td>+0</td>
<td>+0</td>
<td>–0</td>
<td>NaN</td>
<td>NaN</td>
<td>+0</td>
<td>–0</td>
<td>NaN</td>
</tr>
<tr>
<td>–0</td>
<td>–0</td>
<td>+0</td>
<td>NaN</td>
<td>NaN</td>
<td>–0</td>
<td>+0</td>
<td>NaN</td>
</tr>
<tr>
<td>+∞</td>
<td>+∞</td>
<td>–∞</td>
<td>+∞</td>
<td>–∞</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>–∞</td>
<td>–∞</td>
<td>+∞</td>
<td>–∞</td>
<td>+∞</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody></table>
<p>·    小数除法：</p>
<p>decimal operator &#x2F;(decimal x, decimal y);</p>
<p>如果右操作数的值为零，则引发 System.DivideByZeroException 导常。如果结果值太大，不能用 decimal 格式表示，则将引发 System.OverflowException。如果结果值太小，无法用 decimal 格式表示，则结果为零。结果的小数位数是最小的小数位数，它保留等于最接近真实算术结果的可表示小数值的结果。</p>
<p>小数除法等效于使用 System.Decimal 类型的除法运算符。</p>
<h3 id="余数运算符"><a href="#余数运算符" class="headerlink" title="余数运算符"></a>余数运算符</h3><p>对于 x % y 形式的运算，应用二元运算符重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。</p>
<p>下面列出了预定义的余数运算符。这些运算符均计算 x 除以 y 的余数。</p>
<p>·    整数余数：</p>
<p>int operator %(int x, int y);<br>uint operator %(uint x, uint y);<br>long operator %(long x, long y);<br>ulong operator %(ulong x, ulong y);</p>
<p>x % y 的结果是由 x – (x &#x2F; y) * y 生成的值。如果 y 为零，则将引发 System.DivideByZeroException。</p>
<p>如果左侧的操作数是最小的 int 或 long 值，且右侧的操作数是 -1，则将引发 System.OverflowException。只要 x % y 不引发异常，x &#x2F; y 也不会引发异常。</p>
<p>·    浮点余数：</p>
<p>float operator %(float x, float y);<br>double operator %(double x, double y);</p>
<p>下表列出了非零有限值、零、无穷大和 NaN 的所有可能组合的结果。在该表中，x 和 y 是有限的正值。z 是 x % y 的结果，按照 x – n * y 进行计算，其中 n 是小于或等于 x &#x2F; y 的最大可能整数。这种计算余数的方法类似于用于整数操作数的方法，但不同于 IEEE 754 定义（在此定义中，n 是最接近 x &#x2F; y 的整数）。</p>
<table>
<thead>
<tr>
<th></th>
<th>+y</th>
<th>–y</th>
<th>+0</th>
<th>–0</th>
<th>+∞</th>
<th>–∞</th>
<th>NaN</th>
</tr>
</thead>
<tbody><tr>
<td>+x</td>
<td>+z</td>
<td>+z</td>
<td>NaN</td>
<td>NaN</td>
<td>x</td>
<td>x</td>
<td>NaN</td>
</tr>
<tr>
<td>–x</td>
<td>–z</td>
<td>–z</td>
<td>NaN</td>
<td>NaN</td>
<td>–x</td>
<td>–x</td>
<td>NaN</td>
</tr>
<tr>
<td>+0</td>
<td>+0</td>
<td>+0</td>
<td>NaN</td>
<td>NaN</td>
<td>+0</td>
<td>+0</td>
<td>NaN</td>
</tr>
<tr>
<td>–0</td>
<td>–0</td>
<td>–0</td>
<td>NaN</td>
<td>NaN</td>
<td>–0</td>
<td>–0</td>
<td>NaN</td>
</tr>
<tr>
<td>+∞</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>–∞</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody></table>
<p>·    小数余数：</p>
<p>decimal operator %(decimal x, decimal y);</p>
<p>如果右操作数的值为零，则引发 System.DivideByZeroException 导常。在进行任何舍入之前，结果的小数位数是两个操作数中较大的小数位数，而且结果的符号与 x 的相同（如果非零）。</p>
<p>小数余数等效于使用 System.Decimal 类型的余数运算符。</p>
<h3 id="加法运算符"><a href="#加法运算符" class="headerlink" title="加法运算符"></a>加法运算符</h3><p>对于 x + y 形式的运算，应用二元运算符重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。</p>
<p>下面列出了预定义的加法运算符。对于数值和枚举类型，预定义的加法运算符计算两个操作数的和。当一个或两个操作数为 string 类型时，预定义的加法运算符把两个操作数的字符串表示形式串联起来。</p>
<p>·    整数加法：</p>
<p>int operator +(int x, int y);<br>uint operator +(uint x, uint y);<br>long operator +(long x, long y);<br>ulong operator +(ulong x, ulong y);</p>
<p>在 checked 上下文中，如果和超出结果类型的范围，则引发 System.OverflowException。在 unchecked 上下文中，不报告溢出并且结果类型范围外的任何有效高序位都被放弃。</p>
<p>·    浮点加法：</p>
<p>float operator +(float x, float y);<br>double operator +(double x, double y);</p>
<p>根据 IEEE 754 算术运算法则计算和。下表列出了非零有限值、零、无穷大和 NaN 的所有可能组合的结果。在该表中，x 和 y 是非零有限值，z 是 x + y 的结果。如果 x 和 y 的绝对值相同但符号相反，则 zz 为正零。如果 x + y 太大，不能用目标类型表示，则 z 是与 x + y 具有相同符号的无穷大。</p>
<table>
<thead>
<tr>
<th></th>
<th>y</th>
<th>+0</th>
<th>–0</th>
<th>+∞</th>
<th>–∞</th>
<th>NaN</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>z</td>
<td>x</td>
<td>x</td>
<td>+∞</td>
<td>–∞</td>
<td>NaN</td>
</tr>
<tr>
<td>+0</td>
<td>y</td>
<td>+0</td>
<td>+0</td>
<td>+∞</td>
<td>–∞</td>
<td>NaN</td>
</tr>
<tr>
<td>–0</td>
<td>y</td>
<td>+0</td>
<td>–0</td>
<td>+∞</td>
<td>–∞</td>
<td>NaN</td>
</tr>
<tr>
<td>+∞</td>
<td>+∞</td>
<td>+∞</td>
<td>+∞</td>
<td>+∞</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>–∞</td>
<td>–∞</td>
<td>–∞</td>
<td>–∞</td>
<td>NaN</td>
<td>–∞</td>
<td>NaN</td>
</tr>
<tr>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody></table>
<p>·    小数加法：</p>
<p>decimal operator +(decimal x, decimal y);</p>
<p>如果结果值太大，不能用 decimal 格式表示，则将引发 System.OverflowException。在进行任何舍入之前，结果的小数位数是两个操作数中较大的小数位数。</p>
<p>小数加法等效于使用 System.Decimal 类型的加法运算符。</p>
<p>·    枚举加法。每个枚举类型都隐式提供下列预定义运算符，其中 E 为枚举类型，U 为 E 的基础类型：</p>
<p>E operator +(E x, U y);<br>E operator +(U x, E y);</p>
<p>在运行时，这些运算符完全按 (E)((U)x + (U)y) 计算。</p>
<p>·    字符串串联：</p>
<p>string operator +(string x, string y);<br>string operator +(string x, object y);<br>string operator +(object x, string y);</p>
<p>这些二元 + 运算符的重载执行字符串串连。在字符串串联运算中，如果它的一个操作数为 null，则用空字符串来替换此操作数。否则，任何非字符串参数都通过调用从 object 类型继承的虚 ToString 方法，转换为它的字符串表示形式。如果 ToString 返回 null，则将替换成空字符串。</p>
<p>using System;</p>
<p>class Test<br>{<br>static void Main() {<br>string s &#x3D; null;<br>Console.WriteLine(“s &#x3D; &gt;” + s + “&lt;”);   &#x2F;&#x2F; displays s &#x3D; &gt;&lt;<br>int i &#x3D; 1;<br>Console.WriteLine(“i &#x3D; “ + i);      &#x2F;&#x2F; displays i &#x3D; 1<br>float f &#x3D; 1.2300E+15F;<br>Console.WriteLine(“f &#x3D; “ + f);      &#x2F;&#x2F; displays f &#x3D; 1.23E+15<br>decimal d &#x3D; 2.900m;<br>Console.WriteLine(“d &#x3D; “ + d);      &#x2F;&#x2F; displays d &#x3D; 2.900<br>}<br>}</p>
<p>字符串串联运算符的结果是一个字符串，由左操作数的字符后接右操作数的字符组成。字符串串联运算符从不返回 null 值。如果没有足够的内存可用于分配得到的字符串，则可能引发 System.OutOfMemoryException。</p>
<p>·    委托组合。每个委托类型都隐式提供以下预定义运算符，其中 D 是委托类型：</p>
<p>D operator +(D x, D y);</p>
<p>当两个操作数均为某个委托类型 D 时，二元 + 运算符执行委托组合。（如果操作数具有不同的委托类型，则发生绑定时错误。）如果第一个操作数为 null，则运算结果为第二个操作数的值（即使此操作数也为 null）。否则，如果第二个操作数为 null，则运算结果为第一个操作数的值。否则，运算结果是一个新委托实例，该实例在被调用时调用第一个操作数，然后调用第二个操作数。有关委托组合的示例，请参见第 ‎7.8.5 节和第 ‎15.4 节。由于 System.Delegate 不是委托类型，因此不为它定义 operator +。</p>
<h3 id="减法运算符"><a href="#减法运算符" class="headerlink" title="减法运算符"></a>减法运算符</h3><p>对于 x – y 形式的运算，应用二元运算符重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。</p>
<p>下面列出了预定义的减法运算符。这些运算符均从 x 中减去 y。</p>
<p>·    整数减法：</p>
<p>int operator –(int x, int y);<br>uint operator –(uint x, uint y);<br>long operator –(long x, long y);<br>ulong operator –(ulong x, ulong y);</p>
<p>在 checked 上下文中，如果差超出结果类型的范围，则引发 System.OverflowException。在 unchecked 上下文中，不报告溢出并且结果类型范围外的任何有效高序位都被放弃。</p>
<p>·    浮点减法：</p>
<p>float operator –(float x, float y);<br>double operator –(double x, double y);</p>
<p>根据 IEEE 754 算术运算法则计算差。下表列出了非零有限值、零、无穷大和 NaN 的所有可能组合的结果。在该表中，x 和 y 是非零有限值，z 是 x – y 的结果。如果 x 和 y 相等，则 z 为正零。如果 x – y 太大，不能用目标类型表示，则 z 是与 x – y 具有相同符号的无穷大。</p>
<table>
<thead>
<tr>
<th></th>
<th>y</th>
<th>+0</th>
<th>–0</th>
<th>+∞</th>
<th>–∞</th>
<th>NaN</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>z</td>
<td>x</td>
<td>x</td>
<td>–∞</td>
<td>+∞</td>
<td>NaN</td>
</tr>
<tr>
<td>+0</td>
<td>–y</td>
<td>+0</td>
<td>+0</td>
<td>–∞</td>
<td>+∞</td>
<td>NaN</td>
</tr>
<tr>
<td>–0</td>
<td>–y</td>
<td>–0</td>
<td>+0</td>
<td>–∞</td>
<td>+∞</td>
<td>NaN</td>
</tr>
<tr>
<td>+∞</td>
<td>+∞</td>
<td>+∞</td>
<td>+∞</td>
<td>NaN</td>
<td>+∞</td>
<td>NaN</td>
</tr>
<tr>
<td>–∞</td>
<td>–∞</td>
<td>–∞</td>
<td>–∞</td>
<td>–∞</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody></table>
<p>·    小数减法：</p>
<p>decimal operator –(decimal x, decimal y);</p>
<p>如果结果值太大，不能用 decimal 格式表示，则将引发 System.OverflowException。在进行任何舍入之前，结果的小数位数是两个操作数中较大的小数位数。</p>
<p>小数减法等效于使用 System.Decimal 类型的减法运算符。</p>
<p>·    枚举减法。每个枚举类型都隐式提供下列预定义运算符，其中 E 为枚举类型，U 为 E 的基础类型：</p>
<p>U operator –(E x, E y);</p>
<p>此运算符严格按 (U)((U)x – (U)y) 计算。换言之，运算符计算 x 和 y 的序数值之间的差，结果类型是枚举的基础类型。</p>
<p>E operator –(E x, U y);</p>
<p>此运算符严格按 (E)((U)x – y) 计算。换言之，该运算符从枚举的基础类型中减去一个值，得到枚举的值。</p>
<p>·    委托移除。每个委托类型都隐式提供以下预定义运算符，其中 D 是委托类型：</p>
<p>D operator –(D x, D y);</p>
<p>当两个操作数均为某个委托类型 D 时，二元 – 运算符执行委托移除。如果操作数具有不同的委托类型，则发生绑定时错误。如果第一个操作数为 null，则运算结果为 null。否则，如果第二个操作数为 null，则运算结果为第一个操作数的值。否则，两个操作数都表示包含一项或多项的调用列表（第 ‎15.1 节），并且只要第二个操作数列表是第一个操作数列表的适当的邻接子列表，那么结果就是从第一个操作数的调用列表中移除了第二个操作数的调用列表所含各项后的一个新调用列表。     （为确定子列表是否相等，用委托相等运算符（第 ‎7.10.8 节）比较相对应的项。）否则，结果为左操作数的值。在此过程中两个操作数的列表均未被更改。如果第二个操作数的列表与第一个操作数的列表中的多个邻接项子列表相匹配，则移除最右边的那个匹配邻接项的子列表。如果移除导致空列表，则结果为 null。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">D</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">C</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">M1</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">M2</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">     D cd1 = <span class="keyword">new</span> D(C.M1);</span><br><span class="line">     D cd2 = <span class="keyword">new</span> D(C.M2);</span><br><span class="line">     D cd3 = cd1 + cd2 + cd2 + cd1; <span class="comment">// M1 + M2 + M2 + M1</span></span><br><span class="line">     cd3 -= cd1;              <span class="comment">// =&gt; M1 + M2 + M2</span></span><br><span class="line"></span><br><span class="line">     cd3 = cd1 + cd2 + cd2 + cd1;    <span class="comment">// M1 + M2 + M2 + M1</span></span><br><span class="line">     cd3 -= cd1 + cd2;         <span class="comment">// =&gt; M2 + M1</span></span><br><span class="line"></span><br><span class="line">     cd3 = cd1 + cd2 + cd2 + cd1;    <span class="comment">// M1 + M2 + M2 + M1</span></span><br><span class="line">     cd3 -= cd2 + cd2;         <span class="comment">// =&gt; M1 + M1</span></span><br><span class="line"></span><br><span class="line">     cd3 = cd1 + cd2 + cd2 + cd1;    <span class="comment">// M1 + M2 + M2 + M1</span></span><br><span class="line">     cd3 -= cd2 + cd1;         <span class="comment">// =&gt; M1 + M2</span></span><br><span class="line"></span><br><span class="line">     cd3 = cd1 + cd2 + cd2 + cd1;    <span class="comment">// M1 + M2 + M2 + M1</span></span><br><span class="line">     cd3 -= cd1 + cd1;         <span class="comment">// =&gt; M1 + M2 + M2 + M1</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h3 id="关系和类型测试运算符"><a href="#关系和类型测试运算符" class="headerlink" title="关系和类型测试运算符"></a>关系和类型测试运算符</h3><p>&#x3D;&#x3D;、!&#x3D;、&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;、is 和 as 运算符称为关系和类型测试运算符。</p>
<ul>
<li>relational-expression:<ul>
<li>shift-expression</li>
<li>relational-expression  &lt;  shift-expression</li>
<li>relational-expression  &gt;  shift-expression</li>
<li>relational-expression  &lt;&#x3D;  shift-expression</li>
<li>relational-expression  &gt;&#x3D;  shift-expression</li>
<li>relational-expression  is  type</li>
<li>relational-expression  as  type</li>
</ul>
</li>
<li>equality-expression:<ul>
<li>relational-expression</li>
<li>equality-expression  &#x3D;&#x3D;  relational-expression</li>
<li>equality-expression  !&#x3D;  relational-expression</li>
</ul>
</li>
</ul>
<p>is 和 as 运算符分别在第 ‎7.10.10 节和第 ‎7.10.11 节中说明。</p>
<p>&#x3D;&#x3D;、!&#x3D;、&lt;、&gt;、&lt;&#x3D; 和 &gt;&#x3D; 运算符为比较运算符 (comparison operator)。</p>
<p>如果比较运算符的某个操作数为编译时类型 dynamic，则表达式是动态绑定的（第 ‎7.2.2 节）。在此情况下，表达式的编译时类型为 dynamic，并且会在运行时使用具有编译时类型 dynamic 的操作数的运行时类型进行下面所述的决策。</p>
<p>对于 <code>x op y</code> 形式（其中 op 为比较运算符）的运算，应用重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。</p>
<p>预定义的比较运算符详见下面各节的介绍。所有预定义的比较运算符都返回 bool 类型的结果，详见下表。</p>
<table>
<thead>
<tr>
<th><strong>运算</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>x &#x3D;&#x3D; y</td>
<td>如果 x 等于  y，则为  true，否则为 false</td>
</tr>
<tr>
<td>x !&#x3D; y</td>
<td>如果 x 不等于  y，则为  true，否则为 false</td>
</tr>
<tr>
<td>x &lt;  y</td>
<td>如果 x 小于  y，则为  true，否则为 false</td>
</tr>
<tr>
<td>x &gt;  y</td>
<td>如果 x 大于  y，则为  true，否则为 false</td>
</tr>
<tr>
<td>x &lt;&#x3D;  y</td>
<td>如果 x 小于或等于 y，则为  true，否则为 false</td>
</tr>
<tr>
<td>x &gt;&#x3D;  y</td>
<td>如果 x 大于或等于 y，则为  true，否则为 false</td>
</tr>
<tr>
<td>x is y</td>
<td>如果x的类型与y的类型一致，则为true，否则为false</td>
</tr>
</tbody></table>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><h4 id="整数比较运算符"><a href="#整数比较运算符" class="headerlink" title="整数比较运算符"></a>整数比较运算符</h4><p>预定义的整数比较运算符为：</p>
<p>bool operator &#x3D;&#x3D;(int x, int y);<br> bool operator &#x3D;&#x3D;(uint x, uint y);<br> bool operator &#x3D;&#x3D;(long x, long y);<br> bool operator &#x3D;&#x3D;(ulong x, ulong y);</p>
<p>bool operator !&#x3D;(int x, int y);<br> bool operator !&#x3D;(uint x, uint y);<br> bool operator !&#x3D;(long x, long y);<br> bool operator !&#x3D;(ulong x, ulong y);</p>
<p>bool operator &lt;(int x, int y);<br> bool operator &lt;(uint x, uint y);<br> bool operator &lt;(long x, long y);<br> bool operator &lt;(ulong x, ulong y);</p>
<p>bool operator &gt;(int x, int y);<br> bool operator &gt;(uint x, uint y);<br> bool operator &gt;(long x, long y);<br> bool operator &gt;(ulong x, ulong y);</p>
<p>bool operator &lt;&#x3D;(int x, int y);<br> bool operator &lt;&#x3D;(uint x, uint y);<br> bool operator &lt;&#x3D;(long x, long y);<br> bool operator &lt;&#x3D;(ulong x, ulong y);</p>
<p>bool operator &gt;&#x3D;(int x, int y);<br> bool operator &gt;&#x3D;(uint x, uint y);<br> bool operator &gt;&#x3D;(long x, long y);<br> bool operator &gt;&#x3D;(ulong x, ulong y);</p>
<p>这些运算符都比较两个整数操作数的数值并返回一个 bool 值，该值指示特定的关系是 true 还是 false。</p>
<h4 id="浮点比较运算符"><a href="#浮点比较运算符" class="headerlink" title="浮点比较运算符"></a>浮点比较运算符</h4><p>预定义的浮点比较运算符为：</p>
<p>bool operator &#x3D;&#x3D;(float x, float y);<br> bool operator &#x3D;&#x3D;(double x, double y);</p>
<p>bool operator !&#x3D;(float x, float y);<br> bool operator !&#x3D;(double x, double y);</p>
<p>bool operator &lt;(float x, float y);<br> bool operator &lt;(double x, double y);</p>
<p>bool operator &gt;(float x, float y);<br> bool operator &gt;(double x, double y);</p>
<p>bool operator &lt;&#x3D;(float x, float y);<br> bool operator &lt;&#x3D;(double x, double y);</p>
<p>bool operator &gt;&#x3D;(float x, float y);<br> bool operator &gt;&#x3D;(double x, double y);</p>
<p>这些运算符根据 IEEE 754 标准法则比较操作数：</p>
<p>·    如果两个操作数中的任何一个为 NaNN，则对于除 !&#x3D;（对于此运算符，结果为 true）外的所有运算符，结果均为 false。对于任何两个操作数，x !&#x3D; y 始终生成与 !(x &#x3D;&#x3D; y) 相同的结果。然而，当一个操作数或两个操作数为 NaN 时，&lt;、&gt;、&lt;&#x3D; 和 &gt;&#x3D; 运算符不产生与其对应的反向运算符的逻辑否定相同的结果。例如，如果 x 和 y 中的任何一个为 NaN，则 x &lt; y 为 false，而 !(x &gt;&#x3D; y) 为 true。</p>
<p>·    当两个操作数都不为 NaN 时，这些运算符就按下列顺序来比较两个浮点操作数的值</p>
<p>–∞ &lt; –max &lt; … &lt; –min &lt; –0.0 &#x3D;&#x3D; +0.0 &lt; +min &lt; … &lt; +max &lt; +∞</p>
<p>这里的 min 和 max 是可以用给定浮点格式表示的最小和最大正有限值。这样排序的显著特点是：</p>
<p>o  负零和正零被视为相等。</p>
<p>o  负无穷大被视为小于所有其他值，但等于其他负无穷大。</p>
<p>o  正无穷大被视为大于所有其他值，但等于其他正无穷大。</p>
<h4 id="小数比较运算符"><a href="#小数比较运算符" class="headerlink" title="小数比较运算符"></a>小数比较运算符</h4><p>预定义的小数比较运算符为：</p>
<p>bool operator &#x3D;&#x3D;(decimal x, decimal y);</p>
<p>bool operator !&#x3D;(decimal x, decimal y);</p>
<p>bool operator &lt;(decimal x, decimal y);</p>
<p>bool operator &gt;(decimal x, decimal y);</p>
<p>bool operator &lt;&#x3D;(decimal x, decimal y);</p>
<p>bool operator &gt;&#x3D;(decimal x, decimal y);</p>
<p>这些运算符都比较两个 decimal 操作数的数值并返回一个 bool 值，该值指示特定的关系是 true 还是 false。各小数比较等效于使用 System.Decimal 类型的相应关系运算符或相等运算符。</p>
<h4 id="布尔相等运算符"><a href="#布尔相等运算符" class="headerlink" title="布尔相等运算符"></a>布尔相等运算符</h4><p>预定义的布尔相等运算符为：</p>
<p>bool operator &#x3D;&#x3D;(bool x, bool y);</p>
<p>bool operator !&#x3D;(bool x, bool y);</p>
<p>如果 x 和 y 都为 true，或者如果 x 和 y 都为 false，则 &#x3D;&#x3D; 的结果为 true。否则，结果为 false。</p>
<p>如果 x 和 y 都为 true，或者如果 x 和 y 都为 false，则 !&#x3D; 的结果为 false。否则，结果为 true。当操作数为 bool 类型时，!&#x3D; 运算符产生与 ^ 运算符相同的结果。</p>
<h4 id="枚举比较运算符"><a href="#枚举比较运算符" class="headerlink" title="枚举比较运算符"></a>枚举比较运算符</h4><p>每种枚举类型都隐式提供下列预定义的比较运算符：</p>
<p>bool operator &#x3D;&#x3D;(E x, E y);</p>
<p>bool operator !&#x3D;(E x, E y);</p>
<p>bool operator &lt;(E x, E y);</p>
<p>bool operator &gt;(E x, E y);</p>
<p>bool operator &lt;&#x3D;(E x, E y);</p>
<p>bool operator &gt;&#x3D;(E x, E y);</p>
<p>x op y（其中 x 和 y 是具有基础类型 U 的枚举类型 E 的表达式，op 是一个比较运算符）的计算结果与 (E)((U)x) op ((U)y) 的计算结果完全相同。换言之，枚举类型比较运算符只比较两个操作数的基础整数值。</p>
<h4 id="引用类型相等运算符"><a href="#引用类型相等运算符" class="headerlink" title="引用类型相等运算符"></a>引用类型相等运算符</h4><p>预定义的引用类型相等运算符为：</p>
<p>bool operator &#x3D;&#x3D;(object x, object y);</p>
<p>bool operator !&#x3D;(object x, object y);</p>
<p>这些运算符返回两个引用是相等还是不相等的比较结果。</p>
<p>由于预定义的引用类型相等运算符接受 object 类型的操作数，因此它们适用于所有那些没有为自己声明适用的 operator &#x3D;&#x3D; 和 operator !&#x3D; 成员的类型。相反，任何适用的用户定义的相等运算符都有效地隐藏上述预定义的引用类型相等运算符。</p>
<p>预定义的引用类型相等运算符要求满足以下条件之一：</p>
<p>·    两个操作数均为已知的 reference-type 类型的值或文本 null。此外，存在从其中一个操作数的类型到另一个操作数的类型的显式引用转换（第 ‎6.2.4 节）。</p>
<p>·    一个操作数是类型为 T 的值，其中 T 为 type-parameter，另一个操作数为文本 null。此外，T 不具有值类型约束。</p>
<p>除非满足以下这些条件之一，否则将发生绑定时错误。这些规则中值得注意的含义是：</p>
<p>·    使用预定义的引用类型相等运算符比较两个在绑定时已能确定是不相同的引用时，会导致绑定时错误。例如，如果操作数的绑定时类型是两种类类型 A 和 B，并且如果 A 和 B 都不是从对方派生的，则两个操作数不可能引用同一对象。因此，此运算被认为是绑定时错误。</p>
<p>·    预定义的引用类型相等运算符不允许比较值类型操作数。因此，除非结构类型声明自己的相等运算符，否则不可能比较该结构类型的值。</p>
<p>·    预定义的引用类型相等运算符从不会导致对它们的操作数执行装箱操作。执行此类装箱操作毫无意义，这是因为对新分配的已装箱实例的引用必将不同于所有其他引用。</p>
<p>·    如果将类型参数类型 T 的操作数与 null进行比较，并且 T 的运行时类型为值类型，则比较结果为 false。</p>
<p>下面的示例检查未受约束的类型形参类型的实参是否为 null。</p>
<p>虽然 T 可能表示值类型，但是 x &#x3D;&#x3D; null 构造是允许的，当 T 为值类型时，结果只是被定义为 false。</p>
<p>对于 x &#x3D;&#x3D; y 或 x !&#x3D; y 形式的运算，如果存在任何适用的 operator &#x3D;&#x3D; 或 operator !&#x3D;，则运算符重载决策（第 ‎7.3.4 节）规则将选择该运算符而不是上述的预定义的引用类型相等运算符。不过，始终可以通过将一个或两个操作数显式强制转换为 object 类型来选择预定义的引用类型相等运算符。下面的示例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> t = <span class="built_in">string</span>.Copy(s);</span><br><span class="line">        Console.WriteLine(s == t);</span><br><span class="line">        Console.WriteLine((<span class="built_in">object</span>)s == t);</span><br><span class="line">        Console.WriteLine(s == (<span class="built_in">object</span>)t);</span><br><span class="line">        Console.WriteLine((<span class="built_in">object</span>)s == (<span class="built_in">object</span>)t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>产生输出</p>
<p>True<br> False<br> False<br> False</p>
<p>变量 s 和 t 引用两个包含相同字符的不同 string 实例。第一个比较输出 True，原因是当两个操作数都为 string 类型时选择了预定义的字符串相等运算符（第 ‎7.10.7 节）。其余的比较全都输出 False，这是因为是在一个或两个操作数为 object 类型时选定预定义的引用类型相等运算符。</p>
<p>注意，以上技术对值类型没有意义。下面的示例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">123</span>;</span><br><span class="line">        <span class="built_in">int</span> j = <span class="number">123</span>;</span><br><span class="line">        System.Console.WriteLine((<span class="built_in">object</span>)i == (<span class="built_in">object</span>)j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出 False，这是因为强制转换创建对已装箱 int 值的两个单独实例的引用。</p>
<h4 id="字符串相等运算符"><a href="#字符串相等运算符" class="headerlink" title="字符串相等运算符"></a>字符串相等运算符</h4><p>预定义的字符串相等运算符为：</p>
<p>bool operator &#x3D;&#x3D;(string x, string y);</p>
<p>bool operator !&#x3D;(string x, string y);</p>
<p>当下列条件中有一个为真时，两个 string 值被视为相等：</p>
<p>·    两个值都为 null。</p>
<p>·    两个值都是对字符串实例的非空引用，这两个字符串不仅具有相同的长度，而且在每个字符位置上的字符亦都彼此相同。</p>
<p>字符串相等运算符比较的是字符串值而不是对字符串的引用。当两个单独的字符串实例包含完全相同的字符序列时，字符串的值相等，但引用不相同。正如第 ‎7.10.6 节中所描述的那样，引用类型相等运算符可用于比较字符串引用而不是字符串值。</p>
<h4 id="委托相等运算符"><a href="#委托相等运算符" class="headerlink" title="委托相等运算符"></a>委托相等运算符</h4><p>每个委托类型都隐式地提供下列预定义的比较运算符：</p>
<p>bool operator &#x3D;&#x3D;(System.Delegate x, System.Delegate y);</p>
<p>bool operator !&#x3D;(System.Delegate x, System.Delegate y);</p>
<p>两个委托实例按下面这样被视为相等：</p>
<p>·    如果两个委托实例中有一个为 null，则当且仅当它们都为 null 时相等。</p>
<p>·    具有不同运行时类型的委托永远不相等。</p>
<p>·    如果两个委托实例都具有调用列表（第 ‎15.1) 节），则当且仅当它们的调用列表长度相同，并且一个实例的调用列表中的每项依次等于（如下面的定义）另一个的调用列表中的相应项时，这两个委托实例相等。</p>
<p>以下规则控制调用列表项的相等性：</p>
<p>·    如果两个调用列表项都引用同一静态方法，则这两项相等。</p>
<p>·    如果两个调用列表项都引用同一个目标对象（引用相等运算符定义的目标对象）上的同一个非静态方法，则这两个调用列表项相等。</p>
<p>·    允许（但不要求）具有相同被捕获外层变量实例集（可能为空集）且语义上相同的  anonymous-function-expression 计算生成的调用列表项相等。</p>
<h4 id="相等运算符和-null"><a href="#相等运算符和-null" class="headerlink" title="相等运算符和 null"></a>相等运算符和 null</h4><p>&#x3D;&#x3D; 和 !&#x3D; 运算符允许一个操作数是可为 null 的类型的值，另一个是 null 文本，即使运算中不存在预定义或用户定义的运算符（未提升或提升形式）。</p>
<p>对于下面某个形式的操作</p>
<p>x &#x3D;&#x3D; null  null &#x3D;&#x3D; x  x !&#x3D; null  null !&#x3D; x</p>
<p>其中 x 是可为 null 的类型的表达式，如果运算符重载决策（第 7.2.4 节）未能找到适用的运算符，则改为从 x 的 HasValue 属性计算结果。具体而言，前两种形式将转换为 !x.HasValue，后两种形式将转换为 x.HasValue。</p>
<h4 id="is-运算符"><a href="#is-运算符" class="headerlink" title="is 运算符"></a>is 运算符</h4><p>is 运算符用于动态检查对象的运行时类型是否与给定类型兼容。E is T 运算（其中 E 为表达式，T 为类型）的结果是布尔值，表示 E 的类型是否可通过引用转换、装箱转换或取消装箱转换而成功转换为类型 T。使用类型实参替换了所有类型形参后，按如下方式计算该运算：</p>
<ul>
<li><p>如果 E 是匿名函数，将发生编译时错误</p>
</li>
<li><p>如果 E 是方法组或 null 文本，或者如果 E 的类型是引用类型或可为 null 的类型并且 E 的值为 null，则结果为 false。</p>
</li>
<li><p>否则，根据下列规则让 D 表示 E 的动态类型：</p>
</li>
<li><p>如果 E 的类型为引用类型，则 D 为 E 引用的实例的运行时类型。</p>
</li>
<li><p>如果 E 的类型为可以为 null 的类型，则 D 为该可以为 null 的类型的基础类型。</p>
</li>
<li><p>如果 E 的类型为不可以为 null 值的类型，则 D 为 E 的类型。</p>
</li>
<li><p>该操作的结果取决于 D 和 T，具体如下：</p>
<ul>
<li><p>如果 T 为引用类型，那么，在以下情况下结果为 true：D 和 T 为相同类型，或者 D 为引用类型并且存在从 D 到 T 的隐式引用转换，或者 D 为值类型并且存在从 D 到 T 的装箱转换。</p>
</li>
<li><p>如果 T 为可以为 null 的类型，那么，当 D 为 T 的基础类型时结果为 true。</p>
</li>
<li><p>如果 T 为不可以为 null 值的类型，那么，如果 D 和 T 为相同类型，则结果为 true。</p>
</li>
<li><p>否则，结果为 false。</p>
</li>
</ul>
</li>
</ul>
<p>请注意，用户定义的转换不在 is 运算符考虑之列。</p>
<h3 id="as-运算符"><a href="#as-运算符" class="headerlink" title="as 运算符"></a>as 运算符</h3><p>as 运算符用于将一个值显式转换为一个给定的引用类型或可为 null 的类型。与强制转换表达式不同，<strong>as 运算符从不引发异常</strong>。它采用的是：如果指定的转换不可能实施，则运算结果为 null。</p>
<p>在 <code>E as T</code> 形式的操作中，E 必须为表达式，T 必须为引用类型、已知为引用类型的类型参数或可以为 null 的类型。此外，下列条件中必须至少有一条成立，否则会发生编译时错误：</p>
<p>·    存在从 E 到 T 的以下类型转换：标识（第 6.1.1 节）、隐式可以为 null（第 ‎6.1.4 节）、隐式引用（第 ‎6.1.6 节）、装箱（第 ‎6.1.7 节）、显式可以为 null（第 ‎6.2.3 节）、显式引用（第 ‎6.2.4 节）或取消装箱（第 ‎6.2.5 节）转换。</p>
<p>·    E 或 T 的类型为开放类型。</p>
<p>·    E 为 null 文本。</p>
<p>如果 E 的编译时类型不是 dynamic，则运算 E as T 将生成与下面的计算相同的结果</p>
<p><code>E is T ? (T)(E) : (T)null</code></p>
<p>不同的只是：实际执行中 E 只计算一次。编译器应该优化 E as T 以最多执行一次动态类型检查，而不是上面的扩展隐含的两次动态类型检查。</p>
<p>如果 E 的编译时类型为 dynamic，则与强制转换运算符不同，as 运算符不是动态绑定的（第 ‎7.2.2 节）。因此这种情况下的扩展为：</p>
<p><code>E is T ? (T)(object)(E) : (T)null</code></p>
<p>请注意，不能使用 as 运算符执行某些转换（如用户定义的转换），应改为使用强制转换表达式来执行这些转换。</p>
<p>在下面的示例中</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">X</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">F</span>(<span class="params"><span class="built_in">object</span> o</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">as</span> <span class="built_in">string</span>;   <span class="comment">// OK, string is a reference type</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">G</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">object</span> o</span>) <span class="keyword">where</span> T : Attribute</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">as</span> T;       <span class="comment">// Ok, T has a class constraint</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> U <span class="title">H</span>&lt;<span class="title">U</span>&gt;(<span class="params"><span class="built_in">object</span> o</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">as</span> U;       <span class="comment">// Error, U is unconstrained </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>G 的类型参数 T 已知为引用类型，原因是它有类约束。但 H 的类型参数 U 不是；因此，不允许在 H 中使用 as 运算符。</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>下表显示了 C# 支持的所有逻辑运算符。假设变量 A 为布尔值 true，变量 B 为布尔值 false，则：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;&amp;</td>
<td align="left">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>
<td align="left">(A &amp;&amp; B) 为假。</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>
<td align="left">(A || B) 为真。</td>
</tr>
<tr>
<td align="left">!</td>
<td align="left">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
<td align="left">!(A &amp;&amp; B) 为真。</td>
</tr>
</tbody></table>
<blockquote>
<h2 id="1-1-条件逻辑运算符"><a href="#1-1-条件逻辑运算符" class="headerlink" title="1.1 条件逻辑运算符"></a>1.1 条件逻辑运算符</h2><p>&amp;&amp; 和 || 运算符称为条件逻辑运算符。也称为“短路”逻辑运算符。</p>
<p>conditional-and-expression:<br>inclusive-or-expression<br>conditional-and-expression  &amp;&amp;  inclusive-or-expression</p>
<p>conditional-or-expression:<br>conditional-and-expression<br>conditional-or-expression  ||  conditional-and-expression</p>
<p>&amp;&amp; 和 || 运算符是 &amp; 和 | 运算符的条件版本：</p>
<p>·    x &amp;&amp; y 运算对应于 x &amp; y 运算，但仅当 x 不为 false 时才计算 y。</p>
<p>·    x || y 运算对应于 x | y 运算，但仅当 x 不为 true 时才计算 y。</p>
<p>如果条件逻辑运算符的某个操作数具有编译时类型 dynamic，则表达式是动态绑定的（第 ‎7.2.2 节）。在此情况下，表达式的编译时类型为 dynamic，并且会在运行时使用具有编译时类型 dynamic 的操作数的运行时类型进行下面所述的决策。</p>
<p>x &amp;&amp; y 或 x || y 形式的运算通过应用重载决策（第 ‎7.3.4 节）来处理，就好比运算的书写形式为 x &amp; y 或 x | y。然后，</p>
<p>·    如果重载决策未能找到单个最佳运算符，或者重载决策选择一个预定义的整数逻辑运算符，则发生绑定时错误。</p>
<p>·    否则，如果选定的运算符是一个预定义的布尔逻辑运算符（第 ‎7.11.3 节）或可以为 null 的布尔逻辑运算符（第 ‎7.11.4 节），则运算按第 ‎7.12.1 节中所描述的那样进行处理。</p>
<p>·    否则，选定的运算符为用户定义的运算符，且运算按第 ‎7.12.2 节中所描述的那样进行处理。</p>
<p>不可能直接重载条件逻辑运算符。不过，由于条件逻辑运算符按通常的逻辑运算符计算，因此通常的逻辑运算符的重载，在某些限制条件下，也被视为条件逻辑运算符的重载。第 ‎7.12.2 节对此有进一步描述。</p>
<h3 id="1-1-1-布尔条件逻辑运算符"><a href="#1-1-1-布尔条件逻辑运算符" class="headerlink" title="1.1.1 布尔条件逻辑运算符"></a>1.1.1 布尔条件逻辑运算符</h3><p>当 &amp;&amp; 或 || 的操作数为 bool 类型时，或者当操作数的类型本身未定义适用的 operator &amp; 或 operator |，但确实定义了到 bool 的隐式转换时，运算按下面这样处理：</p>
<p>·    运算 x &amp;&amp; y 的求值过程相当于 x ? y : false。换言之，首先计算 x 并将其转换为 bool 类型。如果 x 为 true，则计算 y 并将其转换为 bool 类型，并且这成为运算结果。否则，运算结果为 false。</p>
<p>·    运算 x || y 的求值过程相当于 x ? true : y。换言之，首先计算 x 并将其转换为 bool 类型。然后，如果 x 为 true，则运算结果为 true。否则，计算 y 并将其转换为 bool 类型，并且这作为运算结果。</p>
<h3 id="1-1-2-用户定义的条件逻辑运算符"><a href="#1-1-2-用户定义的条件逻辑运算符" class="headerlink" title="1.1.2 用户定义的条件逻辑运算符"></a>1.1.2 用户定义的条件逻辑运算符</h3><p>当 &amp;&amp; 或 || 的操作数所属的类型声明了适用的用户定义的 operator &amp; 或 operator | 时，下列两个条件必须都为真（其中 T 是声明的选定运算符的类型）：</p>
<p>·    选定运算符的返回类型和每个参数的类型都必须为 T。换言之，该运算符必须计算类型为 T 的两个操作数的逻辑 AND 或逻辑 OR，且必须返回类型为 T 的结果。</p>
<p>·    T 必须包含 operator true 和 operator false 的声明。</p>
<p>如果这两个要求中有一个未满足，则发生绑定时错误。如果这两个要求都满足，则通过将用户定义的 operator true 或 operator false 与选定的用户定义的运算符组合在一起来计算 &amp;&amp; 运算或 || 运算：</p>
<p>·    x &amp;&amp; y 运算按 T.false(x) ? x : T.&amp;(x, y) 进行计算，其中 T.false(x) 是 T 中声明的 operator false 的调用，T.&amp;(x, y) 是选定 operator &amp; 的调用。换言之，首先计算 x，然后对结果调用 operator false 以确定 x 是否肯定为 false。如果 x 肯定为假，则运算结果为先前为 x 计算的值。否则将计算 y，并对先前为 x 计算的值和为 y 计算的值调用选定的 operator &amp; 以产生运算结果。</p>
<p>·    x || y 运算按 T.true(x) ? x : T.|(x, y) 进行计算，其中 T.true(x) 是 T 中声明的 operator true 的调用，T.|(x, y) 是选定 operator | 的调用。换言之，首先计算 x，然后对结果调用 operator true 以确定 x 是否肯定为 true。然后，如果 x 肯定为真，则运算结果为先前为 x 计算的值。否则将计算 y，并对先前为 x 计算的值和为 y 计算的值调用选定的 operator | 以产生运算结果。</p>
<p>在这两个运算中，x 给定的表达式只计算一次，y 给定的表达式要么不计算，要么只计算一次。</p>
<p>有关实现了 operator true 和 operator false 的类型的示例，请参见第 ‎11.4.2 节。</p>
</blockquote>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p>
<table>
<thead>
<tr>
<th align="left">p</th>
<th align="left">q</th>
<th align="left">p &amp; q</th>
<th align="left">p | q</th>
<th align="left">p ^ q</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>假设如果 A &#x3D; 60，且 B &#x3D; 13，现在以二进制格式表示，它们如下所示：</p>
<p>A &#x3D; 0011 1100</p>
<p>B &#x3D; 0000 1101</p>
<p>-—————-</p>
<p>A&amp;B &#x3D; 0000 1100</p>
<p>A|B &#x3D; 0011 1101</p>
<p>A^B &#x3D; 0011 0001</p>
<p>~A &#x3D; 1100 0011</p>
<p>下表列出了 C# 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实 例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;</td>
<td align="left">如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>
<td align="left">(A &amp; B) 将得到 12，即为 0000 1100</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>
<td align="left">(A | B) 将得到 61，即为 0011 1101</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td>
<td align="left">(A ^ B) 将得到 49，即为 0011 0001</td>
</tr>
<tr>
<td align="left">~</td>
<td align="left">按位取反运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0，包括符号位。</td>
<td align="left">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>
<td align="left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
</tr>
<tr>
<td align="left">&gt;&gt;</td>
<td align="left">二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>
<td align="left">A &gt;&gt; 2 将得到 15，即为 0000 1111</td>
</tr>
</tbody></table>
<p>左移不管是正数还是负数，补的数都是0；</p>
<p>右移：如果正在操作的数是证书的话，最高位补入0；如果是负数则补入1</p>
<blockquote>
<h2 id="1-1-逻辑运算符"><a href="#1-1-逻辑运算符" class="headerlink" title="1.1 逻辑运算符"></a>1.1 逻辑运算符</h2><p>&amp;、^ 和 | 运算符称为逻辑运算符。</p>
<p>and-expression:<br>equality-expression<br>and-expression  &amp;  equality-expression</p>
<p>exclusive-or-expression:<br>and-expression<br>exclusive-or-expression  ^  and-expression</p>
<p>inclusive-or-expression:<br>exclusive-or-expression<br>inclusive-or-expression  |  exclusive-or-expression</p>
<p>如果逻辑运算符的某个操作数具有编译时类型 dynamic，则表达式是动态绑定的（第 ‎7.2.2 节）。在此情况下，表达式的编译时类型为 dynamic，并且会在运行时使用具有编译时类型 dynamic 的操作数的运行时类型进行下面所述的决策。</p>
<p>对于 x op y 形式的运算（其中 op 为一个逻辑运算符），应用重载决策（第 ‎7.3.4 节）以选择一个特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。</p>
<p>下列章节介绍了预定义的逻辑运算符。</p>
<h3 id="1-1-1-整数逻辑运算符"><a href="#1-1-1-整数逻辑运算符" class="headerlink" title="1.1.1 整数逻辑运算符"></a>1.1.1 整数逻辑运算符</h3><p>预定义的整数逻辑运算符为：</p>
<p>int operator &amp;(int x, int y);<br>uint operator &amp;(uint x, uint y);<br>long operator &amp;(long x, long y);<br>ulong operator &amp;(ulong x, ulong y);</p>
<p>int operator |(int x, int y);<br>uint operator |(uint x, uint y);<br>long operator |(long x, long y);<br>ulong operator |(ulong x, ulong y);</p>
<p>int operator ^(int x, int y);<br>uint operator ^(uint x, uint y);<br>long operator ^(long x, long y);<br>ulong operator ^(ulong x, ulong y);</p>
<p>&amp; 运算符计算两个操作数的按位逻辑 AND，| 运算符计算两个操作数的按位逻辑 OR，而 ^ 运算符计算两个操作数的按位逻辑 XOR。这些运算不可能产生溢出。</p>
<h3 id="1-1-2-枚举逻辑运算符"><a href="#1-1-2-枚举逻辑运算符" class="headerlink" title="1.1.2 枚举逻辑运算符"></a>1.1.2 枚举逻辑运算符</h3><p>每个枚举类型 E 都隐式地提供下列预定义的逻辑运算符：</p>
<p>E operator &amp;(E x, E y);<br>E operator |(E x, E y);<br>E operator ^(E x, E y);</p>
<p>x op y（其中 x 和 y 是具有基础类型 U 的枚举类型 E 的表达式，op 是一个逻辑运算符）的计算结果与 (E)((U)x op (U)y) 的计算结果完全相同。换言之，枚举类型逻辑运算符直接对两个操作数的基础类型执行逻辑运算。</p>
<h3 id="1-1-3-布尔逻辑运算符"><a href="#1-1-3-布尔逻辑运算符" class="headerlink" title="1.1.3 布尔逻辑运算符"></a>1.1.3 布尔逻辑运算符</h3><p>预定义的布尔逻辑运算符为：</p>
<p>bool operator &amp;(bool x, bool y);</p>
<p>bool operator |(bool x, bool y);</p>
<p>bool operator ^(bool x, bool y);</p>
<p>如果 x 和 y 均为 true，则 x &amp; y 的结果为 true。否则，结果为 false。</p>
<p>如果 x 或 y 为 true，则 x | y 的结果为 true。否则，结果为 false。</p>
<p>如果 x 为 true 且 y 为 false，或者 x 为 false 且 y 为 true，则 x ^ y 的结果为 true。否则，结果为 false。当操作数为 bool 类型时，^ 运算符计算结果与 !&#x3D; 运算符相同。</p>
<h3 id="1-1-4-可以为-null-的布尔逻辑运算符"><a href="#1-1-4-可以为-null-的布尔逻辑运算符" class="headerlink" title="1.1.4 可以为 null 的布尔逻辑运算符"></a>1.1.4 可以为 null 的布尔逻辑运算符</h3><p>可以为 null 的布尔类型 bool? 可表示三个值 true、false 和 null，并且在概念上类似于 SQL 中的布尔表达式的三值类型。为了确保针对 bool? 操作数的 &amp; 和 | 运算符产生的结果与 SQL 的三值逻辑一致，提供了下列预定义运算符：</p>
<p>bool? operator &amp;(bool? x, bool? y);</p>
<p>bool? operator |(bool? x, bool? y);</p>
<p>下表列出了这些运算符对 true、false 和 null 值的所有组合所产生的结果。</p>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>x &amp; y</th>
<th>x | y</th>
</tr>
</thead>
<tbody><tr>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>false</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>null</td>
<td>null</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>true</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>false</td>
<td>null</td>
<td>false</td>
<td>null</td>
</tr>
<tr>
<td>null</td>
<td>true</td>
<td>null</td>
<td>true</td>
</tr>
<tr>
<td>null</td>
<td>false</td>
<td>false</td>
<td>null</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
</tbody></table>
<h3 id="1-2-移位运算符"><a href="#1-2-移位运算符" class="headerlink" title="1.2 移位运算符"></a>1.2 移位运算符</h3><p>&lt;&lt; 和 &gt;&gt; 运算符用于执行移位运算。</p>
<p>shift-expression:<br>additive-expression<br>shift-expression  &lt;&lt;  additive-expression<br>shift-expression  right-shift  additive-expression</p>
<p>如果 shift-expression 的某个操作数具有编译时类型 dynamic，则表达式是动态绑定的（第 ‎7.2.2 节）。在此情况下，表达式的编译时类型为 dynamic，并且会在运行时使用具有编译时类型 dynamic 的操作数的运行时类型进行下面所述的决策。</p>
<p>对于 x &lt;&lt; count 或 x &gt;&gt; count 形式的运算，应用二元运算符重载决策（第 ‎7.3.4 节）以选择特定的运算符实现。操作数转换为所选运算符的参数类型，结果的类型是该运算符的返回类型。</p>
<p>当声明重载移位运算符时，第一个操作数的类型必须总是包含运算符声明的类或结构，并且第二个操作数的类型必须总是 int。</p>
<p>下面列出了预定义的移位运算符。</p>
<p>·    左移位：</p>
<p>int operator &lt;&lt;(int x, int count);<br>uint operator &lt;&lt;(uint x, int count);<br>long operator &lt;&lt;(long x, int count);<br>ulong operator &lt;&lt;(ulong x, int count);</p>
<p>&lt;&lt; 运算符将 x 向左位移若干个位，具体计算方法如下所述。</p>
<p>放弃 x 中经移位后会超出结果类型范围的那些高序位，将其余的位向左位移，将空出来的低序位均设置为零。</p>
<p>·    右移位：</p>
<p>int operator &gt;&gt;(int x, int count);<br>uint operator &gt;&gt;(uint x, int count);<br>long operator &gt;&gt;(long x, int count);<br>ulong operator &gt;&gt;(ulong x, int count);</p>
<p>&gt;&gt; 运算符将 x 向右位移若干个位，具体计算方法如下所述。</p>
<p>当 x 为 int 或 long 类型时，放弃 x 的低序位，将剩余的位向右位移，如果 x 非负，则将高序空位位置设置为零，如果 x 为负，则将其设置为 1。</p>
<p>当 x 为 uint 或 ulong 类型时，放弃 x 的低序位，将剩余的位向右位移，并将高序空位位置设置为零。</p>
<p>对于预定义运算符，位移的位数按下面这样计算：</p>
<p>·    当 x 的类型为 int 或 uint 时，位移计数由 count 的低序的 5 位给出。换言之，位移计数由 count &amp; 0x1F 计算出。</p>
<p>·    当 x 的类型为 long 或 ulong 时，位移计数由 count 的低序的 6 位给出。换言之，位移计数由 count &amp; 0x3F 计算出。</p>
<p>如果计算位移计数的结果为零，则移位运算符只返回 x 的值。</p>
<p>移位运算从不会导致溢出，并且在 checked 和 unchecked 上下文中产生的结果相同。</p>
<p>当 &gt;&gt; 运算符的左操作数为有符号的整型时，该运算符执行算术右移位，在此过程中，操作数的最有效位（符号位）的值扩展到高序空位位置。当 &gt;&gt; 运算符的左操作数为无符号的整型时，该运算符执行逻辑右移位，在此过程中，高序空位位置总是设置为零。若要执行与由操作数类型确定的不同的移位运算，可以使用显式强制转换。例如，如果 x 是 int 类型的变量，则 unchecked((int)((uint)x &gt;&gt; y)) 运算执行 x 的逻辑右移位。</p>
</blockquote>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>下表列出了 C# 支持的赋值运算符：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;</td>
<td align="left">简单的赋值运算符，把右边操作数的值赋给左边操作数</td>
<td align="left">C &#x3D; A + B 将把 A + B 的值赋给 C</td>
</tr>
<tr>
<td align="left">+&#x3D;</td>
<td align="left">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>
<td align="left">C +&#x3D; A 相当于 C &#x3D; C + A</td>
</tr>
<tr>
<td align="left">-&#x3D;</td>
<td align="left">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>
<td align="left">C -&#x3D; A 相当于 C &#x3D; C - A</td>
</tr>
<tr>
<td align="left">*&#x3D;</td>
<td align="left">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>
<td align="left">C *&#x3D; A 相当于 C &#x3D; C * A</td>
</tr>
<tr>
<td align="left">&#x2F;&#x3D;</td>
<td align="left">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>
<td align="left">C &#x2F;&#x3D; A 相当于 C &#x3D; C &#x2F; A</td>
</tr>
<tr>
<td align="left">%&#x3D;</td>
<td align="left">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>
<td align="left">C %&#x3D; A 相当于 C &#x3D; C % A</td>
</tr>
<tr>
<td align="left">&lt;&lt;&#x3D;</td>
<td align="left">左移且赋值运算符</td>
<td align="left">C &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2</td>
</tr>
<tr>
<td align="left">&gt;&gt;&#x3D;</td>
<td align="left">右移且赋值运算符</td>
<td align="left">C &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2</td>
</tr>
<tr>
<td align="left">&amp;&#x3D;</td>
<td align="left">按位与且赋值运算符</td>
<td align="left">C &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2</td>
</tr>
<tr>
<td align="left">^&#x3D;</td>
<td align="left">按位异或且赋值运算符</td>
<td align="left">C ^&#x3D; 2 等同于 C &#x3D; C ^ 2</td>
</tr>
<tr>
<td align="left">|&#x3D;</td>
<td align="left">按位或且赋值运算符</td>
<td align="left">C |&#x3D; 2 等同于 C &#x3D; C | 2</td>
</tr>
</tbody></table>
<blockquote>
<h2 id="1-1-赋值运算符"><a href="#1-1-赋值运算符" class="headerlink" title="1.1 赋值运算符"></a>1.1 赋值运算符</h2><p>赋值运算符为变量、属性、事件或索引器元素赋新值。</p>
<p>assignment:<br>unary-expression  assignment-operator  expression</p>
<h1 id="assignment-operator"><a href="#assignment-operator" class="headerlink" title="assignment-operator:"></a>assignment-operator:</h1><p>+&#x3D;<br>-&#x3D;</p>
<p>*&#x3D;<br>&#x2F;&#x3D;<br>%&#x3D;<br>&amp;&#x3D;<br>|&#x3D;<br>^&#x3D;<br>&lt;&lt;&#x3D;<br>right-shift-assignment</p>
<p>赋值的左操作数必须是属于变量、属性访问、索引器访问或事件访问类别的表达式。</p>
<p>&#x3D; 运算符称为简单赋值运算符。它将右操作数的值赋予左操作数给定的变量、属性或索引器元素。简单赋值运算符的左操作数一般不可以是一个事件访问（第 ‎10.8.1 节中描述的例外）。简单赋值运算符的介绍详见第 ‎7.17.1 节。</p>
<p>除 &#x3D; 运算符以外的赋值运算符称为复合赋值运算符 (compound assignment operator)。这些运算符对两个操作数执行指示的运算，然后将结果值赋予左操作数指定的变量、属性或索引器元素。复合赋值运算符的介绍详见第 ‎7.17.2 节。</p>
<p>以事件访问表达式作为左操作数的 +&#x3D; 和 -&#x3D; 运算符称为事件赋值运算符。当左操作数是事件访问时，其他赋值运算符都是无效的。事件赋值运算符的介绍详见第 ‎7.17.3 节。</p>
<p>赋值运算符为向右关联，即此类运算从右到左分组。例如，a &#x3D; b &#x3D; c 形式的表达式可以按 a &#x3D; (b &#x3D; c) 进行计算。</p>
<h3 id="1-1-1-简单赋值"><a href="#1-1-1-简单赋值" class="headerlink" title="1.1.1 简单赋值"></a>1.1.1 简单赋值</h3><p>&#x3D; 运算符称为简单赋值运算符。</p>
<p>如果简单赋值的左操作数为 E.P 或 E[Ei] 形式，其中 E 具有编译时类型 dynamic，则赋值是动态绑定的（第 ‎7.2.2 节）。在此情况下，赋值表达式的编译时类型为 dynamic，并且会在运行时基于 E 的运行时类型进行下面所述的决策。</p>
<p>在简单赋值中，右操作数必须为可以隐式转换为左操作数所属类型的表达式。运算将右操作数的值赋予左操作数指定的变量、属性或索引器元素。</p>
<p>简单赋值表达式的结果是赋予左操作数的值。结果的类型与左操作数相同，且始终为值类别。</p>
<p>如果左操作数为属性或索引器访问，则该属性或索引器必须具有 set 访问器。如果不是这样，则发生绑定时错误。</p>
<p>x &#x3D; y 形式的简单赋值的运行时处理包括以下步骤：</p>
<ul>
<li>如果 x 属于变量：<ul>
<li>计算 x 以产生变量。</li>
<li>计算 y，必要时还需通过隐式转换（第 ‎6.1 节）将其转换为 x 的类型。</li>
<li>如果 x给定的变量是 reference-type 的数组元素，则执行运行时检查以确保为 y 计算的值与以 x 为其元素的那个数组实例兼容。如果 y 为 null，或存在从 y 引用的实例的实际类型到包含 x 的数组实例的实际元素类型的隐式引用转换（第 ‎6.1.6 节），则检查成功。否则，将引发 System.ArrayTypeMismatchException。</li>
<li>y 的计算和转换后所产生的值存储在 x 的计算所确定的位置中。</li>
</ul>
</li>
<li>如果 x 属于属性或索引器访问：<ul>
<li>计算与 x 关联的实例表达式（如果 x 不是 static）和参数列表（如果 x 是索引器访问），结果用于后面的对和 set 访问器调用。</li>
<li>计算 y，必要时还需通过隐式转换（第 ‎6.1 节）将其转换为 x 的类型。</li>
<li>使用针对 y 计算的值作为 value 参数调用 x 的 set 访问器。</li>
</ul>
</li>
</ul>
<p>如果存在从 B 到 A 的隐式引用转换，则数组协变规则（第 ‎12.5 节）允许数组类型 A[] 的值是对数组类型 B[] 的实例的引用。由于这些规则，对 reference-type 的数组元素的赋值需要运行时检查以确保所赋的值与数组实例兼容。在下面的示例中</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>[] sa = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">object</span>[] oa = sa;</span><br><span class="line"></span><br><span class="line">oa[<span class="number">0</span>] = <span class="literal">null</span>;        <span class="comment">// Ok</span></span><br><span class="line">oa[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span>;       <span class="comment">// Ok</span></span><br><span class="line">oa[<span class="number">2</span>] = <span class="keyword">new</span> ArrayList(); <span class="comment">// ArrayTypeMismatchException</span></span><br></pre></td></tr></table></figure>

<p>最后的赋值将导致引发 System.ArrayTypeMismatchException，这是因为 ArrayList 的实例不能存储在 string[] 的元素中。</p>
<p>当 struct-type 中声明的属性或索引器是赋值的目标时，与属性或索引器访问关联的实例表达式必须为变量类别。如果该实例表达式归类为值类别，则发生绑定时错误。由于第 ‎7.6.4 节中所说明的原因，同样的规则也适用于字段。</p>
<p>给定下列声明：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; x = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; y = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Rectangle</span><br><span class="line">&#123;</span><br><span class="line">    Point a, b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params">Point a, Point b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Point A</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; a = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Point B</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> b; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; b = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的示例中</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Windows.Shapes;</span><br><span class="line"></span><br><span class="line">Point p = <span class="keyword">new</span> Point();</span><br><span class="line">p.X = <span class="number">100</span>;</span><br><span class="line">p.Y = <span class="number">100</span>;</span><br><span class="line">Rectangle r = <span class="keyword">new</span> Rectangle();</span><br><span class="line">r.A = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">r.B = p;</span><br></pre></td></tr></table></figure>

<p>由于 p 和 r 为变量，因此允许对 p.X、p.Y、r.A 和 r.B 进行赋值。但是，在以下示例中</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Rectangle r = <span class="keyword">new</span> Rectangle();</span><br><span class="line"> r.A.X = <span class="number">10</span>;</span><br><span class="line"> r.A.Y = <span class="number">10</span>;</span><br><span class="line"> r.B.X = <span class="number">100</span>;</span><br><span class="line"> r.B.Y = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>由于 r.A 和 r.B 不是变量，因此赋值全部无效。</p>
<h3 id="1-1-2-复合赋值"><a href="#1-1-2-复合赋值" class="headerlink" title="1.1.2 复合赋值"></a>1.1.2 复合赋值</h3><p>如果复合赋值的左操作数为 E.P 或 E[Ei] 形式，其中 E 具有编译时类型 dynamic，则赋值为动态绑定的（第 ‎7.2.2 节）。在此情况下，赋值表达式的编译时类型为 dynamic，并且会在运行时基于 E 的运行时类型进行下面所述的决策。</p>
<p>x op&#x3D; y 形式的运算是这样来处理的：应用重载决策（第 ‎7.3.4 节），就好比运算的书写形式为 x op y。然后，</p>
<p>·    如果选定的运算符的返回类型可“隐式”转换为 xx 的类型，则运算按 x &#x3D; x op y 计算，但 x 只计算一次。</p>
<p>·    否则，如果选定运算符是预定义的运算符，选定运算符的返回类型可“显式”转换为 x 的类型，并且 y 可“隐式”转换为 x 的类型或者该运算符是移位运算符，则运算按 x &#x3D; (T)(x op y) 计算（其中 T 是 x 的类型），但 x 只计算一次。</p>
<p>·    否则，复合赋值无效，且发生绑定时错误。</p>
<p>术语“只计算一次”表示：在 x op y 的计算中，x 的任何要素表达式的计算结果都临时保存起来，然后在执行对 x 的赋值时重用这些结果。例如，在计算赋值 A()[B()] +&#x3D; C() 时（其中 A 为返回 int[] 的方法，B 和 C 为返回 int 的方法），按 A、B、C 的顺序只调用这些方法一次。</p>
<p>当复合赋值的左操作数为属性访问或索引器访问时，属性或索引器必须同时具有 get 访问器和 set 访问器。如果不是这样，则发生绑定时错误。</p>
<p>上面的第二条规则允许在某些上下文中将 x op&#x3D; y 按 x &#x3D; (T)(x op y) 计算。按此规则，当左操作数为 sbyte、byte、short、ushort 或 char 类型时，预定义的运算符可用作复合运算符。甚至当两个参数都为这些类型之一时，预定义的运算符也产生 intint类型的结果，详见第 ‎7.3.6.2 节中的介绍。因此，不进行强制转换，就不可能把结果赋值给左操作数。</p>
<p>此规则对预定义运算符的直观效果只是：如果同时允许 x op y 和 x &#x3D; y，则允许 x op&#x3D; y。在下面的示例中</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">byte</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">char</span> ch = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">b += <span class="number">1</span>;      <span class="comment">// Ok</span></span><br><span class="line">b += <span class="number">1000</span>;    <span class="comment">// Error, b = 1000 not permitted</span></span><br><span class="line">b += i;      <span class="comment">// Error, b = i not permitted</span></span><br><span class="line">b += (<span class="built_in">byte</span>)i;   <span class="comment">// Ok</span></span><br><span class="line"></span><br><span class="line">ch += <span class="number">1</span>;       <span class="comment">// Error, ch = 1 not permitted</span></span><br><span class="line">ch += (<span class="built_in">char</span>)<span class="number">1</span>;  <span class="comment">// Ok</span></span><br></pre></td></tr></table></figure>

<p>每个错误的直观理由是对应的简单赋值也发生错误。</p>
<p>这还意味着复合赋值运算支持提升运算。在下面的示例中</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>? i = <span class="number">0</span>;</span><br><span class="line"> i += <span class="number">1</span>;      <span class="comment">// Ok</span></span><br></pre></td></tr></table></figure>

<p>使用了提升运算符 +(int?,int?)。</p>
<h3 id="1-1-3-事件赋值"><a href="#1-1-3-事件赋值" class="headerlink" title="1.1.3 事件赋值"></a>1.1.3 事件赋值</h3><p>如果 +&#x3D; 或 -&#x3D; 运算符的左操作数属于事件访问类别，则表达式按下面这样计算：</p>
<p>·    计算事件访问的实例表达式（如果有）。</p>
<p>·    计算 +&#x3D; 或 -&#x3D; 运算符的右操作数，如果需要，通过隐式转换（第 ‎6.1 节）转换为左操作数的类型。</p>
<p>·    调用该事件的事件访问器，所需的参数列表由右操作数（经过计算和必要的转换后）组成。如果运算符为 +&#x3D;，则调用 add 访问器；如果运算符为 -&#x3D;，则调用 remove 访问器。</p>
<p>事件赋值表达式不产生值。因此，事件赋值表达式只在 statement-expression（第 ‎8.6 节）的上下文中是有效的。</p>
</blockquote>
<h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><p>下表列出了 C# 支持的其他一些重要的运算符，包括 sizeof、typeof 和 ? :。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sizeof()</td>
<td align="left">返回数据类型的大小。默认情况下只能获取基本数据类型在内存中占据的字节数（除了string object）。如果需要获取自定义结构体实例的大小，需要放在不安全的上下文中。</td>
<td align="left">sizeof(int)，将返回 4.</td>
</tr>
<tr>
<td align="left">typeof()</td>
<td align="left">返回 class 的类型。</td>
<td align="left">typeof(StreamReader);</td>
</tr>
<tr>
<td align="left">&amp;</td>
<td align="left">返回变量的地址。</td>
<td align="left">&a; 将得到变量的实际地址。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">变量的指针。</td>
<td align="left">*a; 将指向一个变量。</td>
</tr>
<tr>
<td align="left">? :</td>
<td align="left">条件表达式</td>
<td align="left">如果条件为真 ? 则为 X : 否则为 Y</td>
</tr>
<tr>
<td align="left">new</td>
<td align="left">在内存中创建指定类型的实例，并调用实例构造器。在类中要慎用new，一旦在某个类中调用的new，当前编写的类型就和创建实例的这个类型构成了紧密的耦合。一旦创建实例的类有问题，那么当前类也会出问题。</td>
<td align="left">new Form();</td>
</tr>
<tr>
<td align="left">checked</td>
<td align="left">检查指定的运算是否产生溢出。如果产生抛出异常(OverflowException )</td>
<td align="left">uint i &#x3D; unit.MaxValue; uint j &#x3D; checked(i + 1); 或者checked{}(检查语句块)</td>
</tr>
<tr>
<td align="left">delegate</td>
<td align="left">声明匿名方法。一般并不作为操作符，而是声明委托数据类型。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">~</td>
<td align="left">求反操作符。对一个数在二进制层面按位取反</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="空合并运算符"><a href="#空合并运算符" class="headerlink" title="空合并运算符"></a>空合并运算符</h3><p>​	?? 运算符称为空合并运算符。</p>
<p>​	a ?? b 形式的空合并表达式要求 a 为可以为 null 的类型或引用类型。</p>
<p>​	如果 a 为非 null，则 a ?? b 的结果为 a；否则，结果为 b。仅当 a 为 null 时，该操作才计算 b。</p>
<p>​	空合并运算符为右结合运算符，表示操作从右向左进行组合。例如，a ?? b ?? c 形式的表达式可以按 a ?? (b ?? c) 进行计算。概括地说，E1 ?? E2 ?? … ?? EN 形式的表达式返回第一个非 null 的操作数，如果所有操作数都为 null，则返回 null。</p>
<p>表达式 a ?? b 的类型取决于对操作数可用的隐式转换。按照优先顺序，a ?? b 的类型为 A0、A 或 B，其中 A 是 a 的类型（如果 a 有类型），B 是 b 的类型（如果 b 有类型），A0 是 A 的基础类型（如果 A 是可以为 null 的类型）或 A（如果该项不是可以为 null 的类型）。具体而言，a ?? b 的处理过程如下：</p>
<p>·    如果 A 存在并且不是可以为 null 的类型或引用类型，将发生编译时错误。</p>
<p>·    如果 b 是动态表达式，则结果类型为 dynamic。在运行时，首先计算 a。如果 a 不为 null，则 aa 转换为动态类型，这成为结果。否则，计算 b，这成为结果。</p>
<p>·    否则，如果 A 存在并且是可以为 null 的类型，并且存在从 b 到 A0 的隐式转换，则结果类型为 A0。在运行时，首先计算 a。如果 a 不为 null，则 a 解包为类型 A0，这即是结果。否则，计算 b 并转换为类型 A0，这即是结果。</p>
<p>·    否则，如果 A 存在并且存在从 b 到 A 的隐式转换，则结果类型为 A。在运行时，首先计算 a。如果 a 不为 null，则 a 即是结果。否则，计算 b 并转换为类型 A，这即是结果。</p>
<p>·    否则，如果 b 的类型为 B，并且存在从 a 到 B 的隐式转换，则结果类型为 B。在运行时，首先计算 a。如果 a 不为 null，则 a 解包为类型 A0（如果 A 存在并且可以为 null）并转换为类型 B，并且这成为结果。否则，计算 b 并且 b 作为结果。</p>
<p>·    否则，a 和 b 不兼容，并发生编译时错误。</p>
<p>可以使用以下代码来检查一个可空类型变量是否为null，并在它为null时返回一个默认值：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>? x = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">int</span> y = x ?? <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>



<h3 id="空条件运算符"><a href="#空条件运算符" class="headerlink" title="?. 空条件运算符"></a>?. 空条件运算符</h3><p>在C#中，<code>?.</code>运算符被称为<strong>空条件运算符</strong>。它用于执行成员或元素访问操作，仅当操作数不为null时才执行。如果操作数为null，则表达式的结果为null。</p>
<p>例如，您可以使用以下代码来检查一个对象是否为null，并在它不为null时访问其成员：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">int</span>? length = s?.Length;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，由于s的值为null，因此length的值将被设置为null。</p>
<p>下面是一个使用<code>?.</code>运算符的示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">string</span> name = person?.Name;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了一个名为<code>Person</code>的类，它具有一个名为<code>Name</code>的属性。然后，我们创建了一个名为<code>person</code>的变量，它的值为null。接下来，我们使用<code>?.</code>运算符来访问<code>person</code>对象的<code>Name</code>属性。由于<code>person</code>的值为null，因此<code>name</code>变量的值将被设置为null。</p>
<p>如果我们将<code>person</code>变量的值更改为非null值，则可以正常访问其成员：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">string</span> name = person?.Name; <span class="comment">// name will be &quot;John&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，由于<code>person</code>的值不为null，因此我们可以正常访问其成员，并且<code>name</code>变量的值将被设置为”John”。</p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><h5 id="有助于避免繁杂的空值检查带来的代码歧义。"><a href="#有助于避免繁杂的空值检查带来的代码歧义。" class="headerlink" title="有助于避免繁杂的空值检查带来的代码歧义。"></a>有助于避免繁杂的空值检查带来的代码歧义。</h5><p>如果想得到给定客户的订单数，就需要在设置计数值之前检查空值:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (customer.orders != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	count = customer. orders.Count() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只编写了这段代码，但客户没有订单(即为null),就会抛出System.ArgumentNullException:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> count = customer .orders. Count() ;</span><br></pre></td></tr></table></figure>

<p>使用<code>?.</code>运算符，会把int? count设置为null，而不会抛出一一个异常。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>? count = customer . orders? .Count() ;</span><br></pre></td></tr></table></figure>

<p>结合上一节讨论的空合并操作符??与空条件运算符?.可以在结果是null时设置一个默认值。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>? count = customer.orders?.Count() ?? <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h5 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h5><p>空条件运算符的另一个用途是触发事件。触发事件的最常见方法是使用如下代码模式:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> onChanged = OnChanged;</span><br><span class="line"><span class="keyword">if</span> (onChanged != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">	onChanged(<span class="keyword">this</span>, <span class="keyword">args</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种模式不是线程安全的，因为有人会在null检查已经完成后，退订最后一个事件处理程序。此时会抛出异常，程序崩溃。使用空条件运算符可以避免这种情形:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">OnChanged?.Invoke(<span class="keyword">this</span>, <span class="keyword">args</span>) ;</span><br></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果使用运算符重载方法(例如&#x3D;&#x3D;)，但没有检查null, 就会抛出System.NullReferenceException.</p>
<h3 id="C-中的运算符优先级"><a href="#C-中的运算符优先级" class="headerlink" title="C# 中的运算符优先级"></a>C# 中的运算符优先级</h3><p>运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。</p>
<p>例如 x &#x3D; 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。</p>
<p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">运算符</th>
<th align="left">结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">后缀</td>
<td align="left">() [] -&gt; . ++ - -</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">一元</td>
<td align="left">+ - ! ~ ++ - - (type)* &amp; sizeof</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">乘除</td>
<td align="left">* &#x2F; %</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">加减</td>
<td align="left">+ -</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">移位</td>
<td align="left">&lt;&lt; &gt;&gt;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">关系</td>
<td align="left">&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">相等</td>
<td align="left">&#x3D;&#x3D; !&#x3D;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位与 AND</td>
<td align="left">&amp;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位异或 XOR</td>
<td align="left">^</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">位或 OR</td>
<td align="left">|</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">逻辑与 AND</td>
<td align="left">&amp;&amp;</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">逻辑或 OR</td>
<td align="left">||</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">条件</td>
<td align="left">?:</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">赋值</td>
<td align="left">&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;&gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">逗号</td>
<td align="left">,</td>
<td align="left">从左到右</td>
</tr>
</tbody></table>
<h2 id="c-表达式"><a href="#c-表达式" class="headerlink" title="c#表达式"></a>c#表达式</h2><ul>
<li>表达式（Expressions）是任何语言的基础组件之一（其二分别是命令和声明），而且是最重要的。</li>
<li>表达式是一种语法实体，用于表达一定的算法意图。</li>
<li>在C#中，表达式是由一个或多个操作数和零个或多个操作符组成的序列。表达式求值后，得到的结果为single value, object, method, or namespace.</li>
</ul>
<blockquote>
<p>expression 为 non-assignment-expression 或 assignment。</p>
<p>expression:<br>non-assignment-expression<br>assignment</p>
<p>non-assignment-expression:<br>conditional-expression<br>lambda-expression<br>query-expression</p>
<p>表示为 非赋值表达式或 分配<br>表达式：<br>非赋值表达式<br>分配<br>非赋值表达式：<br>条件表达式<br>lambda表达式<br>查询表达式</p>
</blockquote>
<h1 id="c-元组（Tuple）"><a href="#c-元组（Tuple）" class="headerlink" title="c#元组（Tuple）"></a>c#元组（Tuple）</h1><p>​	元组功能在 <strong>C# 7.0</strong> 及更高版本中可用，它提供了简洁的语法，用于将多个数据元素分组成一个轻型数据结构。 </p>
<p>​	元组是一种 有序的，有限不可变的，支持混杂类型的固定个数的 一种数据结构。混杂指的是 Tuple 中的若干元素类型，即可以是同类型，也可以是不同类型。如一个元组中可以有int、string等不同类型的数据</p>
<p>​	常用于方法数据的传入和传出</p>
<h2 id="使用元组的场景"><a href="#使用元组的场景" class="headerlink" title="使用元组的场景"></a>使用元组的场景</h2><ul>
<li><p>如果你的方法需要返回多个值 或者 方法需要传递多个值。</p>
</li>
<li><p>如果你不想为某些功能专门去定义一个类。</p>
</li>
<li><p>如果你有若干个混杂元素，并且想提供对其简单的访问方式。</p>
</li>
</ul>
<p>用法和匿名类类似，但是，方法的返回值不能指定为匿名类型。</p>
<h2 id="元组的缺陷"><a href="#元组的缺陷" class="headerlink" title="元组的缺陷"></a>元组的缺陷</h2><ul>
<li>Tuple 是引用类型不是值类型，意味着它会在 <code>托管堆</code> 上进行内存分配，如果 Tuple 过大并且没有很好的释放，对程序也是一个不小的性能挑战。</li>
</ul>
<h2 id="声明和使用样例"><a href="#声明和使用样例" class="headerlink" title="声明和使用样例"></a>声明和使用样例</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果定义的时候不声明字段名，则使用的时候只能使用默认的 Item + 数字编号（从1起）</span></span><br><span class="line">            (<span class="built_in">double</span> , <span class="built_in">int</span>)numbers1 = (<span class="number">0.98</span>, <span class="number">2</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;numbers1元组中第一个值为：<span class="subst">&#123;numbers1.Item1&#125;</span>\t第二个值为：<span class="subst">&#123;numbers1.Item2&#125;</span>\t\t元组的类型为：<span class="subst">&#123;numbers1.GetType()&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="comment">//如果在定义的时候声明了字段名，则使用的时候可以用字段名进行访问。此时，默认的Item名无法使用。</span></span><br><span class="line">            (<span class="built_in">int</span> num1, <span class="built_in">double</span> num2) numbers2 = (<span class="number">0</span>, <span class="number">0.02</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;numbers2元组中第一个值为：<span class="subst">&#123;numbers2.num1&#125;</span>\t第二个值为：<span class="subst">&#123;numbers2.num2&#125;</span>\t元组的类型为：<span class="subst">&#123;numbers2.GetType()&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            numbers2 = MySwap(numbers1);<span class="comment">//将number1的元组转换成num2的元组的形式</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;numbers2元组中第一个值为：<span class="subst">&#123;numbers2.num1&#125;</span>\t第二个值为：<span class="subst">&#123;numbers2.num2&#125;</span>\t元组的类型为：<span class="subst">&#123;numbers2.GetType()&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//并不可以使用foreach遍历。</span></span><br><span class="line">            <span class="comment">//foreach(var x in numbers2)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    Console.WriteLine(x);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个样例方法，演示使用元组进行数据的传入和传出。</span></span><br><span class="line">        <span class="keyword">static</span> (<span class="built_in">int</span>, <span class="built_in">double</span>)MySwap((<span class="built_in">double</span>, <span class="built_in">int</span>) x)</span><br><span class="line">        &#123;</span><br><span class="line">            (<span class="built_in">int</span>, <span class="built_in">double</span>) t;</span><br><span class="line">            t.Item1 = x.Item2;</span><br><span class="line">            t.Item2 = x.Item1;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用元组时的注意事项"><a href="#使用元组时的注意事项" class="headerlink" title="使用元组时的注意事项"></a>使用元组时的注意事项</h2><p>​	元组功能需要 <code>System.ValueTuple</code> 类型和相关的泛型类型（例如 <code>System.ValueTuple&lt;T1,T2&gt;</code>），这些类型在 <code>.NET Core</code> 和 <code>.NET Framework 4.7</code> 及更高版本中可用。 若要在面向 <code>.NET Framework 4.6.2</code> 或更早版本的项目中使用元组，请将 <code>NuGet</code> 包 <code>System.ValueTuple</code> 添加到项目。</p>
<h1 id="C-的基本语句"><a href="#C-的基本语句" class="headerlink" title="C#的基本语句"></a>C#的基本语句</h1><ul>
<li>语句是命令式编程语言（高级语言）中最小的独立元素。用于表达将要执行的动作。</li>
<li>语句对应着一组指令。</li>
<li>简单地说就是，陈述算法思想，控制逻辑走向，完成有意义的动作。</li>
<li><strong>在c#中，语句一定是出现在方法体内</strong>。</li>
</ul>
<h2 id="c-的语句种类"><a href="#c-的语句种类" class="headerlink" title="c#的语句种类"></a>c#的语句种类</h2><ul>
<li>声明语句<ul>
<li>用于声明变量、常量等</li>
</ul>
</li>
<li>表达式语句</li>
<li>嵌入式语句</li>
<li>块语句（简称“块”）</li>
<li>选择语句（判断、分支）</li>
<li>迭代语句（循环）</li>
<li>跳转语句</li>
<li>try…catch…finally语句</li>
<li>using语句</li>
<li>yield语句</li>
<li>checked&#x2F;unchecked语句</li>
<li>lock语句（用于多线程）</li>
<li>标签语句 labeled-statement（比较少见）</li>
<li>空语句</li>
</ul>
<h2 id="声明语句"><a href="#声明语句" class="headerlink" title="声明语句"></a>声明语句</h2><h3 id="声明一个或多个局部变量。"><a href="#声明一个或多个局部变量。" class="headerlink" title="声明一个或多个局部变量。"></a>声明一个或多个局部变量。</h3><ul>
<li><p>局部变量声明：</p>
<ul>
<li>局部变量类型 局部变量声明器</li>
</ul>
</li>
<li><p>局部变量类型：</p>
<ul>
<li><p>具体类型</p>
</li>
<li><p>var类型</p>
</li>
</ul>
</li>
<li><p>局部变量声明器：</p>
<ul>
<li><p>一个局部变量声明器</p>
</li>
<li><p>一组局部变量声明器 , 一个局部变量声明器</p>
</li>
</ul>
</li>
<li><p>一个局部变量声明符：</p>
<ul>
<li><p>标识符</p>
</li>
<li><p>标识符 &#x3D; 局部变量初始化器</p>
</li>
</ul>
</li>
<li><p>局部变量初始化器：</p>
<ul>
<li><p>表达式（值）</p>
</li>
<li><p>数组初始化器</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>local-variable-declaration 声明一个或多个局部变量。</p>
<p>local-variable-declaration:<br>local-variable-type  local-variable-declarators</p>
<p>local-variable-type:<br>type<br>var</p>
<p>local-variable-declarators:<br>local-variable-declarator<br>local-variable-declarators  ,  local-variable-declarator</p>
<p>local-variable-declarator:<br>identifier<br>identifier  &#x3D;  local-variable-initializer</p>
<p>local-variable-initializer:<br>expression<br>array-initializer</p>
</blockquote>
<h4 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x;<span class="comment">//指定类型声明，但没有初始化</span></span><br><span class="line">x = <span class="number">0</span>;<span class="comment">//赋值</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">100</span>;<span class="comment">//未指定类型的声明，靠编译器自动推断。一旦推断完成，就不可更改</span></span><br><span class="line"><span class="built_in">int</span> z = <span class="number">200</span>;<span class="comment">//与第一个样例不相等。这种是声明变量的时候追加了初始化器</span></span><br><span class="line"><span class="built_in">int</span>[] arr = &#123;x, y, z&#125;;<span class="comment">//数组初始化器初始化数组</span></span><br></pre></td></tr></table></figure>









<h3 id="声明局部常量"><a href="#声明局部常量" class="headerlink" title="声明局部常量"></a>声明局部常量</h3><ul>
<li>声明局部变量的前面加上<code>const</code>关键字。</li>
<li>常量在声明的时候必须跟上初始化器，设定初始值。</li>
<li>常量一旦定义不可修改。</li>
</ul>
<blockquote>
<p>local-constant-declaration 用于声明一个或多个局部常量。</p>
<p>local-constant-declaration:<br>const  type  constant-declarators</p>
<p>constant-declarators:<br>constant-declarator<br>constant-declarators  ,  constant-declarator</p>
<p>constant-declarator:<br>identifier  &#x3D;  constant-expression</p>
<p>local-constant-declaration 的 type 指定由该声明引入的常量的类型。此类型后接一个 constant-declarator 列表，其中每一项都引入一个新常量。cconstant-declarator 包含一个命名常量的 identifier，后接一个“&#x3D;”标记，然后是一个对该常量赋值的 constant-expression（第 ‎7.19 节）。</p>
<p>局部常量声明的 type 和 constant-expression 必须遵循与常量成员声明（第 ‎10.4 节）一样的规则。</p>
<p>可以在表达式中通过 simple-name（第 ‎7.6.2 节）来获取局部常量的值。</p>
<p>局部常量的范围是在其中声明了该常量的块。在局部常量的 constant-declarator 之前的文本位置中引用该局部常量是错误的。在局部常量的范围内声明其他具有相同名称的局部变量或常量是编译时错误。</p>
<p>声明多个常量的局部常量声明等效于多个同一类型的单个常量的声明。</p>
</blockquote>
<h4 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> PI = <span class="number">3.1415926</span>;</span><br></pre></td></tr></table></figure>







<h2 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h2><ul>
<li>简单的说就是可以形成表达式的语句。用于计算所给定的表达式。由此表达式计算出来的是（如果有）将被丢弃。</li>
<li>不是所有的表达式都允许被作为语句。</li>
</ul>
<blockquote>
<p>expression-statement:<br>statement-expression  ;</p>
<p>statement-expression:<br>invocation-expression<br>object-creation-expression<br>assignment<br>post-increment-expression<br>post-decrement-expression<br>pre-increment-expression<br>pre-decrement-expression<br>await-expression</p>
<ul>
<li>表达式语句：<ul>
<li>语句表达式；</li>
</ul>
</li>
<li>语句表达式：<ul>
<li>调用表达式</li>
<li>对象创建表达式</li>
<li>赋值</li>
<li>后增量表达式</li>
<li>减量后表达式</li>
<li>前增量表达式</li>
<li>减量前表达式</li>
<li>等待表达式</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="样例-5"><a href="#样例-5" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Console.WriteLine //成员访问，一旦添加括号即表示调用</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//方法调用表达式</span></span><br><span class="line">Form form= <span class="keyword">new</span> Form();<span class="comment">//对象创建表达式</span></span><br><span class="line">x = <span class="number">100</span>;<span class="comment">//赋值</span></span><br><span class="line">x++;<span class="comment">//自增，只关心结果，不关心返回值（返回值为自增前的x）</span></span><br><span class="line">x--;</span><br><span class="line">++x;</span><br><span class="line">--x;</span><br><span class="line"><span class="comment">//x + y;//不允许，因为无意义</span></span><br></pre></td></tr></table></figure>



<h2 id="块"><a href="#块" class="headerlink" title="块"></a>块</h2><ul>
<li>用于在只允许使用单个语句的上下文中编写多条语句。</li>
<li>块 由一个扩在大括号内的可选的语句序列组成。如果没有语句序列，则称块是空的。</li>
<li>所有语句都可以写在块内。</li>
<li>块语句一定被大括号包裹，但被大括号包裹的语句不一定是块语句。（块语句是语句，因此一定出现在方法体内。）</li>
<li>编译器将整个块视为一个完整的语句，不需要额外的分号。</li>
<li>一般与判断、循环连用。</li>
<li>块语句外声明的变量在块内也可以用，但在块内声明的在块外就无法使用。详见变量的生存期和作用域。</li>
</ul>
<h2 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h2><p>​	判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p>
<p>​	基本语法与c相同</p>
<table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">if 语句</td>
<td align="left">一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</td>
</tr>
<tr>
<td align="left">if…else</td>
<td align="left">一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</td>
</tr>
<tr>
<td align="left">嵌套 if 语句</td>
<td align="left">您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td>
</tr>
<tr>
<td align="left">switch 语句</td>
<td align="left">一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。需要注意switch的表达式类型必须是整形数、布尔类型、char、string或枚举类型。<strong>不允许是浮点类型</strong>，因为浮点不精确不可比较。</td>
</tr>
<tr>
<td align="left">嵌套 switch 语句</td>
<td align="left">您可以在一个 <strong>switch</strong> 语句内使用另一个 <strong>switch</strong> 语句。</td>
</tr>
</tbody></table>
<h3 id="Switch语句"><a href="#Switch语句" class="headerlink" title="Switch语句"></a>Switch语句</h3><p>C#与C++是有区别的。在C++中，可以在运行完一个case语句后，运行另一个case语句。即case后面的语句块中缺省break语句，一个case语句执行了两个以上的语句块。</p>
<p>在C#中，<strong>执行完每个部分的代码后，还需要有另一个语句break</strong>。在执行完一个case块后，再执行第二个case语句是非法的。</p>
<p>在C#代码中,还有其他方法可以防止程序流程从一个case语句转到下一个case语句。可以使用returm语句，中断当前函数的运行，而不是仅中断switch结构的执行(详见第6章)。也可以使用goto语句(如前所述)，</p>
<p>case语句实际上是在C#代码中定义的标签。</p>
<p>一个case语句处理完毕后，不能自由进入下一个case 语句，但这条规则有一个例外。如果把多个case语句放在一起(堆叠它们)， 其后加一个代码块，实际上是一次检查多个条件。如果满足这些条件中的任何一个，<br>就会执行代码，例如:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (&lt;testVar&gt;) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;compari sonVa11&gt;:</span><br><span class="line">	<span class="keyword">case</span> &lt;comparisonva12&gt; :</span><br><span class="line">		&lt;当&lt;testVar&gt;=&lt;comparisonva11&gt;或&lt;testVar&gt;=&lt;comparisonva12&gt;时要执行的代码 &gt;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，这些条件也适用于default语句。default 语句不一定要放在比较操作列表的最后，还可以把它和case语句放在一起。用break或returm添加一个断点， 可确保在任何情况下，该结构都有一条有效的执行路径。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="? : 运算符"></a>? : 运算符</h3><p> **条件运算符 ? :**可以用来替代 <strong>if…else</strong> 语句。它的一般形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exp1 ? Exp2 : Exp3;</span><br></pre></td></tr></table></figure>

<p>其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</p>
<p>? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>循环语句允许我们多次执行一个语句或语句组。</p>
<h3 id="基础循环"><a href="#基础循环" class="headerlink" title="基础循环"></a>基础循环</h3><p>C# 提供了以下几种循环类型。</p>
<p>基本语法与c++相同。此处不再赘述。</p>
<table>
<thead>
<tr>
<th align="left">循环类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-while-loop.html">while 循环</a></td>
<td align="left">当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-for-loop.html">for&#x2F;foreach 循环</a></td>
<td align="left">多次执行一个语句序列，简化管理循环变量的代码。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-do-while-loop.html">do…while 循环</a></td>
<td align="left">除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-nested-loops.html">嵌套循环</a></td>
<td align="left">您可以在 while、for 或 do..while 循环内使用一个或多个循环。</td>
</tr>
</tbody></table>
<h3 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h3><p>使用foreach可以迭代数组或者一个集合对象。</p>
<p>foreach循环用于列举出集合中所有的元素，foreach语句中的表达式由关键字in隔开的两个项组成。<strong>in右边的项是集合名，in左边的项是变量名，用来存放该集合中的每个元素。</strong></p>
<p>该循环的运行过程如下：每一次循环时，从集合中取出一个新的元素值。放到只读变量中去，如果括号中的整个表达式返回值为true，foreach块中的语句就能够执行。一旦集合中的元素都已经被访问到，整个表达式的值为false，控制流程就转入到foreach块后面 的执行语句。</p>
<p>foreach语句经常与数组一起使用，下面实例将通过foreach语句读取数组的值并进行显示。</p>
<p>只要这个类实现了<code>IEnumerable</code>这个接口的类，就可以被foreach遍历。比如数组、泛型list</p>
<p>循环的本意是调用类的迭代器。如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">System.Collections.IEnumerator enumerator = arr.GetEnumerator();<span class="comment">//获取arr的迭代器</span></span><br><span class="line"><span class="keyword">while</span>(enumerator.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(enumerator.Current); <span class="comment">//输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>（type objName <span class="keyword">in</span> collection/Array）</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong> objName的数据类型type必须与collection&#x2F;Array对象的类型相同或比它大。</p>
<ul>
<li>type<ul>
<li>迭代变量的数据类型</li>
</ul>
</li>
<li>objName<ul>
<li>迭代变量</li>
</ul>
</li>
<li>collection&#x2F;Array<ul>
<li>需要循环的集合</li>
</ul>
</li>
</ul>
<p>如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[,,] a = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>] &#123; &#123;&#123; <span class="number">1</span>, <span class="number">2</span> &#125;, &#123; <span class="number">3</span>,<span class="number">4</span>&#125;&#125;,&#123;&#123; <span class="number">5</span>, <span class="number">6</span> &#125;, &#123; <span class="number">7</span>,<span class="number">8</span>&#125;&#125; &#125;;<span class="comment">//定义一个2行2列2纵深的3维数组a</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">int</span> i <span class="keyword">in</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    Console .WriteLine (i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以下实例有三个部分：</p>
<ul>
<li>通过 foreach 循环输出整型数组中的元素。</li>
<li>通过 for 循环输出整型数组中的元素。</li>
<li>foreach 循环设置数组元素的计算器。</li>
</ul>
<h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ForEachTest</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">int</span>[] fibarray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span> &#125;;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> element <span class="keyword">in</span> fibarray)</span><br><span class="line">    &#123;</span><br><span class="line">      System.Console.WriteLine(element);</span><br><span class="line">    &#125;</span><br><span class="line">    System.Console.WriteLine();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类似 foreach 循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; fibarray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      System.Console.WriteLine(fibarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.Console.WriteLine();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置集合中元素的计算器*</span></span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> element <span class="keyword">in</span> fibarray)</span><br><span class="line">    &#123;</span><br><span class="line">      count += <span class="number">1</span>;</span><br><span class="line">      System.Console.WriteLine(<span class="string">&quot;Element #&#123;0&#125;: &#123;1&#125;&quot;</span>, count, element);</span><br><span class="line">    &#125;</span><br><span class="line">    System.Console.WriteLine(<span class="string">&quot;Number of elements in the array: &#123;0&#125;&quot;</span>, count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line"></span><br><span class="line">Element #1: 0</span><br><span class="line">Element #2: 1</span><br><span class="line">Element #3: 1</span><br><span class="line">Element #4: 2</span><br><span class="line">Element #5: 3</span><br><span class="line">Element #6: 5</span><br><span class="line">Element #7: 8</span><br><span class="line">Element #8: 13</span><br><span class="line">Number of elements in the array: 8</span><br></pre></td></tr></table></figure>



<h4 id="实例2-1"><a href="#实例2-1" class="headerlink" title="实例2"></a>实例2</h4><p>通过遍历多维数组来比较for和foreach</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[,,] a = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>] &#123; &#123;&#123; <span class="number">1</span>, <span class="number">2</span> &#125;, &#123; <span class="number">3</span>,<span class="number">4</span>&#125;&#125;,&#123;&#123; <span class="number">5</span>, <span class="number">6</span> &#125;, &#123; <span class="number">7</span>,<span class="number">8</span>&#125;&#125; &#125;;<span class="comment">// 定义一个2行2列2纵深的3维数组a</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; a.GetLength (<span class="number">0</span>) ;i++ )  <span class="comment">//用Array.GetLength(n)得到数组[0,1,,,n]上的维数的元素数，0代表行，1列，n代表此数组是n+1维</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; a.GetLength(<span class="number">1</span>); j++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> z = <span class="number">0</span>; z &lt; a.GetLength(<span class="number">2</span>);z++ )<span class="comment">//2代表得到纵深上的元素数，如果数组有n维就得写n个for循环</span></span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine(a[i,j,z]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[,,] a = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>] &#123; &#123;&#123; <span class="number">1</span>, <span class="number">2</span> &#125;, &#123; <span class="number">3</span>,<span class="number">4</span>&#125;&#125;,&#123;&#123; <span class="number">5</span>, <span class="number">6</span> &#125;, &#123; <span class="number">7</span>,<span class="number">8</span>&#125;&#125; &#125;;<span class="comment">//定义一个2行2列2纵深的3维数组a</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">int</span> i <span class="keyword">in</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  Console .WriteLine (i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两段程序的功能一样。</strong></p>
<h4 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>foreach是只读的<ul>
<li>foreach会迭代每个元素，依次把每个元素放在声明的变量中。如果在循环中试图给声明的变量赋一个值，编译器会报错。</li>
</ul>
</li>
<li>foreach是相对安全的，不存在访问非法元素的危险。</li>
<li>当循环次数特别大的时候，foreach的效率是远高于for的。（至少一个数量级）</li>
</ul>
<h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><p>循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。</p>
<p>C# 提供了下列的控制语句。点击链接查看每个语句的细节。</p>
<table>
<thead>
<tr>
<th align="left">控制语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">break 语句</td>
<td align="left">终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。</td>
</tr>
<tr>
<td align="left">continue 语句</td>
<td align="left">引起循环跳过主体的剩余部分，立即重新开始测试条件。</td>
</tr>
</tbody></table>
<h2 id="try语句-异常处理"><a href="#try语句-异常处理" class="headerlink" title="try语句(异常处理)"></a>try语句(异常处理)</h2><ul>
<li>​	try 语句提供一种机制，用于捕捉在块的执行期间发生的各种异常。此外，try 语句还能让您指定一个代码块，并保证当控制离开 try 语句时，总是先执行该代码。</li>
<li>不管是否发生异常，finally子句都会执行。</li>
<li>可以有多个catch子句，但只能执行其中的一个。</li>
<li>有三种可能的 try 语句形式：<ul>
<li>一个 try 块后接一个或多个 catch 块。</li>
<li>一个 try 块后接一个 finally 块。</li>
<li>一个 try 块后接一个或多个 catch 块，后面再跟一个 finally 块。</li>
</ul>
</li>
<li>C# 异常处理时建立在四个关键词之上的：<strong>try</strong>、<strong>catch</strong>、<strong>finally</strong> 和 <strong>throw</strong>。<ul>
<li><strong>try</strong>：一个 try 块标识了一个将被激活的特定的异常的代码块。后跟一个或多个 catch 块。</li>
<li><strong>catch</strong>：程序通过异常处理程序捕获异常。catch 关键字表示异常的捕获。可以不写异常类型，表示捕捉所有异常。</li>
<li><strong>finally</strong>：finally 块用于执行给定的语句，不管异常是否被抛出都会执行。例如，如果您打开一个文件，不管是否出现异常文件都要被关闭。</li>
<li><strong>throw</strong>：当问题出现时，程序抛出一个异常。使用 throw 关键字来完成。</li>
</ul>
</li>
</ul>
<h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 可能引起异常的语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName e1 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 错误处理代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName e2 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 错误处理代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName eN )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> eN;<span class="comment">//不处理，直接再次抛出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 要执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="样例-6"><a href="#样例-6" class="headerlink" title="样例"></a>样例</h3><p>C# 以 try 和 catch 块的形式提供了一种结构化的异常处理方案。使用这些块，把核心程序语句与错误处理语句分离开。</p>
<p>这些错误处理块是使用 <strong>try</strong>、<strong>catch</strong> 和 <strong>finally</strong> 关键字实现的。下面是一个当除以零时抛出异常的实例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ErrorHandlingApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">DivNumbers</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> result;</span><br><span class="line">        DivNumbers()</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">division</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = num1 / num2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (DivideByZeroException e)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Exception caught: &#123;0&#125;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Result: &#123;0&#125;&quot;</span>, result);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            DivNumbers d = <span class="keyword">new</span> DivNumbers();</span><br><span class="line">            d.division(<span class="number">25</span>, <span class="number">0</span>);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Exception caught: System.DivideByZeroException: Attempted to divide <span class="keyword">by</span> zero. </span><br><span class="line">at ...</span><br><span class="line">Result: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="样例2-1"><a href="#样例2-1" class="headerlink" title="样例2"></a>样例2</h3><p>捕捉全部异常</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> c;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">	c = b / a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> </span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;发生错误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>异常处理的详细说明详见<code>c#异常处理</code>部分</strong></p>
<blockquote>
<p>try-statement:<br>try  block  catch-clauses<br>try  block  finally-clause<br>try  block  catch-clauses  finally-clause</p>
<p>catch-clauses:<br>specific-catch-clauses  general-catch-clauseopt<br>specific-catch-clausesopt  general-catch-clause</p>
<p>specific-catch-clauses:<br>specific-catch-clause<br>specific-catch-clauses  specific-catch-clause</p>
<p>specific-catch-clause:<br>catch  (  class-type  identifieropt  )  block</p>
<p>general-catch-clause:<br>catch  block</p>
<p>finally-clause:<br>finally  block</p>
<ul>
<li>try语句：<ul>
<li>try-block catch子句</li>
<li>try-block finally子句</li>
<li>try-block catch子句 finally子句</li>
</ul>
</li>
<li>catch子句：<ul>
<li>通用捕获异常</li>
<li>特定捕获异常</li>
</ul>
</li>
<li>特定捕获异常：<ul>
<li>特定捕获异常</li>
<li>特定捕获条款</li>
<li>特定捕获条款：</li>
<li>catch（类类型 标识符<del>opt</del>）块</li>
</ul>
</li>
<li>一般捕获子句：<ul>
<li>catch子句</li>
</ul>
</li>
<li>finally-clause:<ul>
<li>finally子句</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h2><p>简单的说就是，在一个语句前面加上标签。</p>
<p>标签遵循标识符的规范。</p>
<p>类似于声明变量，只是不用加数据类型。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">hurr:<span class="comment">//标签</span></span><br><span class="line">    &#123;</span><br><span class="line">   	 	Console.WriteLine(<span class="string">&quot;hurriedlu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">goto</span> hurr;<span class="comment">//跳转到指定的标签处</span></span><br></pre></td></tr></table></figure>







<h2 id="checked-unchecked语句"><a href="#checked-unchecked语句" class="headerlink" title="checked&#x2F;unchecked语句"></a>checked&#x2F;unchecked语句</h2><p><code>checked</code> 和 <code>unchecked</code> 语句指定整型类型算术运算和转换的溢出检查上下文。 当发生整数算术溢出时，溢出检查上下文将定义发生的情况。 在已检查的上下文中，引发 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.overflowexception"><code>System.OverflowException</code></a>；如果在常数表达式中发生溢出，则会发生编译时错误。 在未检查的上下文中，会通过丢弃任何不适应目标类型的高序位来将操作结果截断。 例如，在加法示例中，它将从最大值包装到最小值。 以下示例显示了 <code>checked</code> 和 <code>unchecked</code> 上下文中的相同操作：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    checked</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> x = Int32.MaxValue;</span><br><span class="line">        <span class="built_in">int</span> y = x + <span class="number">1</span>;<span class="comment">//发生溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(OverflowException e)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;捕获到溢出异常&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>













<h1 id="C-的类和成员"><a href="#C-的类和成员" class="headerlink" title="C#的类和成员"></a>C#的类和成员</h1><p>更深入的了解一些细节。’</p>
<blockquote>
<p>类是一种数据结构，它可以包含数据成员（常量和字段）、函数成员（方法、属性、事件、索引器、运算符、实例构造函数、静态构造函数和析构函数）以及嵌套类型。类类型支持继承，继承是一种机制，它使派生类可以对基类进行扩展和专用化。 —— 《C# 语言规范》</p>
<p>当你定义一个类时，你定义了一个数据类型的蓝图。这实际上并没有定义任何的数据，但它定义了类的名称意味着什么，也就是说，类的对象由什么组成及在这个对象上可执行什么操作。对象是类的实例。构成类的方法和变量称为类的成员。</p>
</blockquote>
<h2 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h2><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>类的定义是以关键字 <strong>class</strong> 开始，后跟类的名称。类的主体，包含在一对花括号内。下面是类定义的一般形式：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&lt;access specifier&gt; <span class="keyword">class</span>  <span class="title">class_name</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// member variables</span></span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variable1;</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variable2;</span><br><span class="line">    ...</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variableN;</span><br><span class="line">    <span class="comment">// member methods</span></span><br><span class="line">    &lt;access specifier&gt; &lt;<span class="keyword">return</span> type&gt; method1(parameter_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">    &lt;access specifier&gt; &lt;<span class="keyword">return</span> type&gt; method2(parameter_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &lt;access specifier&gt; &lt;<span class="keyword">return</span> type&gt; methodN(parameter_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>访问标识符 &#x2F;&lt;access specifier&gt; 指定了对类及其成员的访问规则。如果没有指定，则使用默认的访问标识符。类的默认访问标识符是 <strong>internal</strong>，成员的默认访问标识符是 <strong>private</strong>。</li>
<li>数据类型 <data type> 指定了变量的类型，返回类型 <return type> 指定了返回的方法返回的数据类型。</li>
<li>如果要访问类的成员，你要使用点（.）运算符。</li>
<li>点运算符链接了对象的名称和成员的名称。</li>
<li>如果</li>
</ul>
<h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>所有类都直接或间接的继承自object（System.Object）</li>
<li>类只能继承一个父类，但能继承（完成）多个接口.<ul>
<li>关于继承的更多事宜，在面向对象编程单元中的继承子目录中有更详细的说明。</li>
</ul>
</li>
</ul>
<h3 id="System-Object"><a href="#System-Object" class="headerlink" title="System.Object"></a>System.Object</h3><p>​	所有类都继承于System.Object,所以这些类都可以访问该类中受保护的成员和公共成员。因为所有类都继承于System.Object，所以这些类都可以访问该类中受保护的成员和公共成员.</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回类型</th>
<th>是否是虚拟</th>
<th>是否是静态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object()</td>
<td>N&#x2F;A</td>
<td>否</td>
<td>否</td>
<td>System.Object类型的构造函数,由派生类型的构造函数自动调用</td>
</tr>
<tr>
<td>~Object()</td>
<td>N&#x2F;A</td>
<td>否</td>
<td>否</td>
<td>System.Object类型的析构函数，由派生类型的析构函数自动调用，不能手动调用</td>
</tr>
<tr>
<td>Equals(object)</td>
<td>bool</td>
<td>是</td>
<td>否</td>
<td>把调用该方法的对象与另一个对象相比，如果它们相等，就返回true。默认的实现代码会查看其对象参数是否引用了同一个对象(因为对象是引用类型)。如果想以不同方式来比较对象，则可以重写该方法，例如，比较两个对象的状态</td>
</tr>
<tr>
<td>Equals(object, object)</td>
<td>bool</td>
<td>否</td>
<td>是</td>
<td>这个方法比较传送给它的两个对象，看看它们是否相等。检查时使用了Equalsl(object)方法。 注意，如果两个对象都是空引用，这个方法就返回true</td>
</tr>
<tr>
<td>ReferenceEquals(object,object)</td>
<td>bool</td>
<td>否</td>
<td>是</td>
<td>这个方法比较传送给它的两个对象，看看它们是不是同一个实例的引用</td>
</tr>
<tr>
<td>ToString()</td>
<td>string</td>
<td>是</td>
<td>否</td>
<td>返回一个对应于对象实例的字符串。默认情况下，这是一个类类型的限定名称，但可以重写它，给类类型提供合适的实现代码</td>
</tr>
<tr>
<td>MemberwiseClone()</td>
<td>object</td>
<td>否</td>
<td>否</td>
<td>通过创建一个新对象实例并复制成员，以复制该对象。成员复制不会得到这些成员的新实例。新对象的任何引用类型成员都将引用与源类相同的对象，这个方法是受保护的，所以只能在类或派生的类中使用</td>
</tr>
<tr>
<td>GetType()</td>
<td>System.Type</td>
<td>否</td>
<td>否</td>
<td>以System.Type对象的形式返回对象的类型</td>
</tr>
<tr>
<td>GetHashCode()</td>
<td>int</td>
<td>是</td>
<td>否</td>
<td>在需要此参数的地方，用作对象的散列函数，它返回一个以压缩形式标识对象状态的值</td>
</tr>
</tbody></table>
<h3 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h3><table>
<thead>
<tr>
<th>成员</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>常量</td>
<td>与类关联的常量值</td>
</tr>
<tr>
<td>字段</td>
<td>类的变量</td>
</tr>
<tr>
<td>方法</td>
<td>类可执行的计算和操作</td>
</tr>
<tr>
<td>属性</td>
<td>与读写类的命名属性相关联的操作</td>
</tr>
<tr>
<td>索引器</td>
<td>与以数组方式索引类的实例相关联的操作</td>
</tr>
<tr>
<td>事件</td>
<td>可由类生成的通知</td>
</tr>
<tr>
<td>运算符</td>
<td>类所支持的转换和表达式运算符</td>
</tr>
<tr>
<td>构造函数</td>
<td>初始化类的实例或类本身所需要的操作</td>
</tr>
<tr>
<td>析构函数</td>
<td>在永久丢弃类的实例之前执行的操作</td>
</tr>
<tr>
<td>类型</td>
<td>类所声明的嵌套类型</td>
</tr>
</tbody></table>
<p>对于一个类或对象来说，最重要的三类成员就是属性（白色小扳手）、事件（黄色小闪电）和方法（紫色小方块）。</p>
<p>属性：这个对象或类当前处于什么状态</p>
<p>方法：当前这个类或方法能做什么</p>
<p>事件：能在什么情况下通知谁</p>
<p>存储数据、做事情、通知别人</p>
<h3 id="静态成员和实例成员"><a href="#静态成员和实例成员" class="headerlink" title="静态成员和实例成员"></a>静态成员和实例成员</h3><p>​	属性、方法和字段等成员是对象实例所特有的，此外，还有静态成员,例如静态方法、静态属性或静态字段。静态成员可以在类的实例之间共享，所以可将它们看成类的全局对象。静态属性和静态字段可以访问独立于任何对象实例的数据，静态方法可以执行与对象类型相关但与对象实例无关的命令。在使用静态成员时，甚至不需要实例化对象。</p>
<p>​	例如，Console.WriteLine()和Convert.ToString()方法就是静态的，根本不需要实例化Console或Convert类(如果试着进行这样的实例化，操作会失败,因为这些类的构造函数不是可公共可访问的，<br>如前所述)。</p>
<p>​	许多情况下，静态属性和静态方法有很好的效果。例如，可以使用静态属性跟踪给类创建了多少个实例。在UML语法中，类的静态成员带有下画线。</p>
<h2 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h2><p>​	如果希望类只包含静态成员，且不能用于实例化对象(如Console)。一种简单的方法是使用静态类，而不是把类的构造函数设置为私有。静态类只能包含静态成员，不能包含实例构造函数，因为按照定义，它根本不能被实例化。但静态类可以有一个静态构造函数，如上一节所述。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象是实例化的类。</p>
<h3 id="对象的生存周期"><a href="#对象的生存周期" class="headerlink" title="对象的生存周期"></a>对象的生存周期</h3><p>每一个对象都有一个明确的生命周期，除了”正在使用”的正常状态外，还有两个重要的阶段：</p>
<ul>
<li>构造阶段<ul>
<li>第一次实例化一个对象时，需要初始化该对象。这个初始化过程称为构造阶段，由构造函数完成。</li>
</ul>
</li>
<li>析构阶段<ul>
<li>在删除一个对象时，常常需要执行一些清理操作，如释放内存，这由析构函数完成。</li>
</ul>
</li>
</ul>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>对象的初始化过程是自动完成的，所有类定义都最少包含一个构造函数。</p>
<p>在C#中，使用<code>new</code>关键字来调用构造函数。</p>
<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>​	.NET Framework使用析构函数来清理对象。一般情况下，不需要提供析构函数的代码，而由默认的析构函数自动执行操作。但是，如果在删除对象实例前需要完成一些重要操作，就应提供具体的析构函数。</p>
<p>​	例如，如果变量超出了作用域,代码就不能访问它，但该变量仍存在于计算机内存的某个地方。只有在.NET运行程序执行其垃圾回收，进行清理时，该实例才被彻底删除。</p>
<h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><h3 id="什么是字段"><a href="#什么是字段" class="headerlink" title="什么是字段"></a>什么是字段</h3><ul>
<li>字段（field）是一种表示与对象或类型（类与结构体）关联的<strong>变量</strong><ul>
<li>方法体中的局部变量是在方法运行的时候为方法暂时存储数据的，而字段是为一个对象或类型存储数据</li>
</ul>
</li>
<li>字段是类型的成员，旧称”成员变量”</li>
<li>与<code>对象</code>关联的字段亦称”<code>实例字段</code>“</li>
<li>与<code>类型</code>关联的字段称为“<code>静态字段</code>“，由static修饰。<ul>
<li>静态字段为类所有，类不需要实例化即可使用。</li>
<li>需要注意的是，类一旦实例化成对象后便无法调用静态字段</li>
</ul>
</li>
<li><strong>对于实例字段，其初始化的时机是在实例创建的时候。</strong></li>
<li><strong>对于静态字段，是在运行环境加载这个数据类型的时候。</strong></li>
</ul>
<h3 id="字段的声明"><a href="#字段的声明" class="headerlink" title="字段的声明"></a>字段的声明</h3><ul>
<li>尽管字段声明带有分号,但它不是语句</li>
<li>字段的名字一定是名词</li>
<li>当声明字段的时候，一定要写在类体内，如果写到方法体中，就是局部变量了。</li>
<li>如果不手动指定字段的初始值，编译器会自动指定一个对应类型的默认初始值。<ul>
<li>也可以在构造函数中声明初始值</li>
</ul>
</li>
</ul>
<h4 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[特性] [访问修饰符（可多个）] 数据类型 变量声明器;</span><br></pre></td></tr></table></figure>

<h4 id="样例-7"><a href="#样例-7" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Amount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><ul>
<li><p>new</p>
</li>
<li><p>public</p>
</li>
<li><p>protected</p>
</li>
<li><p>private</p>
</li>
<li><p>static</p>
</li>
<li><p>readonly</p>
<ul>
<li>修饰的字段将变成只读字段</li>
</ul>
</li>
<li><p>volatile</p>
</li>
</ul>
<h3 id="只读字段"><a href="#只读字段" class="headerlink" title="只读字段"></a>只读字段</h3><p>又分为实例只读字段和静态只读字段</p>
<p>修饰符为<code>readonly</code></p>
<p>对于只读字段，只能在初始化的时候进行赋值（构造器属于初始化），一旦初始化完成不可再修改。类似于常量？</p>
<p>对于实例只读字段，常用于学生的编号等不可修改的场景；</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="什么是属性"><a href="#什么是属性" class="headerlink" title="什么是属性"></a>什么是属性</h3><p>​	<strong>属性（Property）</strong> 是类（class）、结构（structure）和接口（interface）的命名（named）成员。类或结构中的成员变量或方法称为 <strong>域（Field）</strong>。属性（Property）是域（Field）的扩展，且可使用相同的语法来访问。它们使用 <strong>访问器（accessors）</strong> 让私有域的值可被读写或操作。</p>
<p>​	属性（Property）不会确定存储位置。相反，它们具有可读写或计算它们值的 <strong>访问器（accessors）</strong>。</p>
<p>​	属性( property)是一种用于访问<strong>对象或类型的特征</strong>的成员，特征反映了状态</p>
<p>​	属性是字段的自然扩展</p>
<ul>
<li>从命名上看. field更偏向于实例对象在内存中的布局，property更偏向于反映现实世界对象的特征</li>
<li>对外:暴露数据，数据可以是存储在字段里的，也可以是动态计算出来的</li>
<li>对内:保护字段不被非法值“污染”</li>
</ul>
<p>​	属性由Get&#x2F;Set方法对进化而来。(在Java、C++ 中，经常在类中使用Set和Get方法来设置和获取值，防止这个关键字段被污染)</p>
<p>​	例如，有一个名为 Student 的类，带有 age、name 和 code 的私有域。我们不能在类的范围以外直接访问这些域，但是我们可以拥有访问这些私有域的属性。</p>
<h3 id="访问器（Accessors）"><a href="#访问器（Accessors）" class="headerlink" title="访问器（Accessors）"></a>访问器（Accessors）</h3><p>属性（Property）的访问器（accessor）<strong>包含有助于获取（读取或计算）或设置（写入）属性的可执行语句</strong>。</p>
<p>访问器（accessor）声明可包含一个 get 访问器、一个 set 访问器，或者同时包含二者。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Code</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">get</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> code;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">set</span></span><br><span class="line">   &#123;</span><br><span class="line">      code = <span class="keyword">value</span>;<span class="comment">//访问器中只提供value，表示要写入的值</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在属性中，value是访问器中的一个<code>上下文关键字</code>（例如<code>this</code>，在vs中用蓝色进行标识），在访问器这个特定的代码中，指代了传入的值。</p>
<h3 id="属性的声明"><a href="#属性的声明" class="headerlink" title="属性的声明"></a>属性的声明</h3><h4 id="完整声明"><a href="#完整声明" class="headerlink" title="完整声明"></a>完整声明</h4><p>后台（back）成员变量与访问器</p>
<p>正常的声明变量，然后在后面加一个大括号（访问器），在括号里面有set和get两部分。</p>
<p>也可以分开写（propfull）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> myVar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> MyProperty</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">get</span> &#123; <span class="keyword">return</span> myVar; &#125;</span><br><span class="line">	<span class="keyword">set</span> &#123; myVar = <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="简略声明-（自动属性）"><a href="#简略声明-（自动属性）" class="headerlink" title="简略声明 （自动属性）"></a>简略声明 （自动属性）</h4><p>只有访问器</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> MyProperty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">get</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//相关语句</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">set</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//相关语句</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果没有给get、set提供实现代码，这些块的实现代码（和底层的字段）都由编译器提供。</p>
<p>使用自动属性时，只能通过</p>
<h4 id="样例-8"><a href="#样例-8" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">runoob</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> code = <span class="string">&quot;N.A&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> name = <span class="string">&quot;not known&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明类型为 string 的 Code 属性</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Code</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> code;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                code = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明类型为 string 的 Name 属性</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                name = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明类型为 int 的 Age 属性</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> age;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span><span class="comment">//可以在里面写上相关的语句。value是访问器提供的一个变量，表示传入的值</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">value</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">value</span> &lt;= <span class="number">120</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    age = <span class="keyword">value</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Age value has error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Code = &quot;</span> + Code + <span class="string">&quot;, Name = &quot;</span> + Name + <span class="string">&quot;, Age = &quot;</span> + Age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">ExampleDemo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建一个新的 Student 对象</span></span><br><span class="line">            Student s = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置 student 的 code、name 和 age</span></span><br><span class="line">            s.Code = <span class="string">&quot;001&quot;</span>;</span><br><span class="line">            s.Name = <span class="string">&quot;Zara&quot;</span>;</span><br><span class="line">            s.Age = <span class="number">9</span>;<span class="comment">//在使用的时候不必使用get、set，直接赋值即可。</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Student Info: &#123;0&#125;&quot;</span>, s);</span><br><span class="line">            <span class="comment">// 增加年龄</span></span><br><span class="line">            s.Age += <span class="number">1</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Student Info: &#123;0&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Student t = <span class="keyword">new</span> Student();</span><br><span class="line">            t.Age = <span class="number">120</span>;</span><br><span class="line">            t.Age++;<span class="comment">//只要属性发生变化，就自动调用set方法，以检查值是否合法，一旦不合法，就报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="字段封装成属性"><a href="#字段封装成属性" class="headerlink" title="字段封装成属性"></a>字段封装成属性</h3><p>选中字段后，ctrl r + ctrl e;</p>
<p><img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/image-20230212121546115.png" alt="image-20230212121546115"></p>
<h3 id="限制属性的读写"><a href="#限制属性的读写" class="headerlink" title="限制属性的读写"></a>限制属性的读写</h3><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>在访问器中删除set部分，即完成了属性的只读</p>
<h5 id="样例-9"><a href="#样例-9" class="headerlink" title="样例"></a>样例</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Test.Age = 0;//在只读状态下无法写入</span></span><br><span class="line">            Console.WriteLine(Test.Age);<span class="comment">//但可以正常读</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">private</span> <span class="built_in">int</span> age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> age = <span class="number">10</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="类外只读类内读写"><a href="#类外只读类内读写" class="headerlink" title="类外只读类内读写"></a>类外只读类内读写</h4><p>对于的set和get方法设置成private即可。</p>
<h5 id="样例-10"><a href="#样例-10" class="headerlink" title="样例"></a>样例</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Test t = <span class="keyword">new</span> Test();</span><br><span class="line">            t.Tools(<span class="number">100</span>);<span class="comment">//类外不能直接写</span></span><br><span class="line">            Console.WriteLine(t.Age);<span class="comment">//类外可读</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">set</span> &#123; age = <span class="keyword">value</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Tools</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Age = a;<span class="comment">//类内可写</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>对于这种类内读写的属性对类外来说并不是只读属性，只是set从外界不能直接访问到</strong></p>
<h3 id="动态计算值的属性"><a href="#动态计算值的属性" class="headerlink" title="动态计算值的属性"></a>动态计算值的属性</h3><p>这个属性本身并没有封装一个字段，当从外界访问的时候，值是实时计算出来的。</p>
<h4 id="被动计算"><a href="#被动计算" class="headerlink" title="被动计算"></a>被动计算</h4><p>当调用的时候才会被计算。</p>
<p>如果访问的比较频繁，会比较浪费性能（每次访问都要计算）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Test t = <span class="keyword">new</span> Test();</span><br><span class="line">            t.Age = <span class="number">20</span>;</span><br><span class="line">            Console.WriteLine(t.Checked);<span class="comment">//输出Checked的值</span></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> age = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; age = <span class="keyword">value</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         动态计算值的属性。Checked这个属性，并没有封装一个字段，当从外界访问的时候，值是实时计算出来的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> Checked</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span><span class="comment">//获取值，必须确保一定有返回值</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.age &gt;= <span class="number">18</span>)<span class="comment">//计算，当 当前对象的age值大于等于18</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//得到计算结果 true</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//否则得到计算结果false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="主动计算"><a href="#主动计算" class="headerlink" title="主动计算"></a>主动计算</h4><p>每次修改都会计算</p>
<p>如果经常被设定但不经常check，还是被动计算比较好。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Test t = <span class="keyword">new</span> Test();</span><br><span class="line">            t.Age = <span class="number">20</span>;</span><br><span class="line">            Console.WriteLine(t.Check);<span class="comment">//输出Checked的值</span></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> age = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123; </span><br><span class="line">                age = <span class="keyword">value</span>;</span><br><span class="line">                <span class="comment">//在值发生变化的时候，同时自动计算check的值</span></span><br><span class="line">                <span class="keyword">this</span>.CalculateCheck();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主动的计算</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个计算属性</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">bool</span> check;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> Check</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> check; &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; check = <span class="keyword">value</span>; &#125;<span class="comment">//据说是只读的属性，但注释掉这行后无法执行？</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CalculateCheck</span>()   <span class="comment">//计算属性</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt;= <span class="number">18</span>)<span class="comment">//计算，当 当前对象的age值大于等于18</span></span><br><span class="line">                <span class="keyword">this</span>.Check = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">this</span>.Check = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>注意实例属性和静态属性<br>●属性的名字一 定是名词<br>只读属性一只有getter没 有setter<br>尽管语法上正确，几乎没有人使用”只写属性”，因为属性的主要目的是通过向外暴露数据而表示对象&#x2F;类型的状态</p>
<h3 id="属性与字段的关系"><a href="#属性与字段的关系" class="headerlink" title="属性与字段的关系"></a>属性与字段的关系</h3><ul>
<li>一般情况下，它们都用于表示实体(对象或类型)的状态</li>
<li>属性大多数情况下是字段的包装器( wrapper )</li>
<li>建议:永远使用属性(而不是字段)来暴露数据，即字段永远都是<code>private</code>或<code>protected</code>的</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法的由来"><a href="#方法的由来" class="headerlink" title="方法的由来"></a>方法的由来</h3><ul>
<li>方法（method）的前身是c&#x2F;c++语言的函数（function）<ul>
<li>方法是面向对象范畴的概念，在非面向对象语言中仍称为函数</li>
</ul>
</li>
<li>永远都是类（或结构体）的成员<ul>
<li>c#中方法不可独立于类（或结构体）之外</li>
<li>只有作为类（结构体）的成员的时候才称为方法</li>
</ul>
</li>
<li>方法是类（结构体）最基本的成员之一<ul>
<li>类基本成员只有两个，字段和方法</li>
</ul>
</li>
</ul>
<h3 id="方法的定义与调用"><a href="#方法的定义与调用" class="headerlink" title="方法的定义与调用"></a>方法的定义与调用</h3><p>方法的声明和定义是放在一起的，没有头文件的概念</p>
<p><strong>方法、属性的访问修饰符详见<code>c#封装</code>的部分。</strong></p>
<h4 id="方法声明详细语法"><a href="#方法声明详细语法" class="headerlink" title="方法声明详细语法"></a>方法声明详细语法</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)</span><br><span class="line">&#123;</span><br><span class="line">   Method Body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Access Specifier</strong>：访问修饰符，这个决定了变量或方法对于另一个类的可见性。（详见后面的c#封装）<ul>
<li>new</li>
<li>public</li>
<li>protected</li>
<li>internal</li>
<li>private</li>
<li>static（静态）</li>
<li>virtual</li>
<li>sealed</li>
<li>override</li>
<li>abstract</li>
<li>extern</li>
<li>async</li>
</ul>
</li>
<li><strong>Return type</strong>：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 <strong>void</strong>。</li>
<li><strong>Method name</strong>：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。<strong>并且需要时一个动词或动词短语，并满足大驼峰的规则</strong></li>
<li><strong>Parameter list</strong>：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。</li>
<li><strong>Method body</strong>：方法主体，包含了完成任务所需的指令集。</li>
</ul>
<h4 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h4><p><code>方法名(对应参数)；</code></p>
<h3 id="方法的返回值"><a href="#方法的返回值" class="headerlink" title="方法的返回值"></a>方法的返回值</h3><p>通过函数进行数据交换的最简单方式是利用返回值。</p>
<p>当函数返回一个值的时候，需要如下修改函数：</p>
<ol>
<li>在函数声明中指定返回值类型，但不使用void关键字。</li>
<li>使用return关键字结束函数的执行把返回值传给主调函数</li>
</ol>
<p>需要注意的是，返回值的类型必须是声明时的返回值类型，或者可以隐式的转换成该类型。如声明返回int，实际可以返回short。</p>
<p>return不一定在最后一行，一旦执行到return语句，方法将直接退出，不再执行return后面的语句（如果有）</p>
<h3 id="方法的参数"><a href="#方法的参数" class="headerlink" title="方法的参数"></a>方法的参数</h3><h4 id="传值参数（值参数）"><a href="#传值参数（值参数）" class="headerlink" title="传值参数（值参数）"></a>传值参数（值参数）</h4><ul>
<li><p>声明时不带修饰符的形参是值形参。</p>
</li>
<li><p>本质是作用域在当前方法的一个局部变量。其初始值是调用它的时候赋值在当前方法</p>
</li>
<li><p>它的初始值是在调用这个方法的时候赋值给它的实参的值。换句话说就是传进来的实参的一个副本。即堆值参数的操作永远不会影响原来变量的值。</p>
</li>
<li><p>当形参是值形参时，方法调用中的对应实参必须是表达式，并且它的类型可以隐式转换为形参的类型。</p>
</li>
<li><p>允许方法将新值赋给值参数。这样的赋值只影响由该值形参表示的局部存储位置，而不会影响在方法调用时由调用方给出的实参。</p>
</li>
<li><p>当传入的参数不是值类型的参数，而是引用类型的参数，则传入的是指向引用类型的对象。此时，方法内部和外部的两个变量指向的都是同一个对象。</p>
</li>
<li><p>如果如果给传入的变量创建一个新的对象，在方法内使用的是新创建的对象，在方法外还是原来的那个对象。如：</p>
<ul>
<li><pre><code class="language-c#">using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Policy;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using ShowInfos;
namespace ConsoleApp
{
    internal class Program
    {
        static void Main(string[] args)
        {
            A a = new A();
            a.Name= &quot;A&quot;;//创建一个对象，这个对象中的Name属性的值是A
            T(a);//把创建的引用类型的变量作为值传入到T方法中
            Console.WriteLine(a.Name);//T方法结束后再次输出a的Name属性，结果还是A
            Console.ReadLine();
        }
        static void T(A a)
        {
            Console.WriteLine(a.Name);//输出A
            a = new A();
            a.Name= &quot;B&quot;;
            Console.WriteLine(a.Name);//输出B
        }
    }

    class A//将被引用的对象
    {
        private string name;

        public string Name
        {
            get { return name; }
            set { name = value; }
        }
    }

}
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 还可以更直接一点，输出hashcode检查一下是否是同一个对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用值参数的时候，必须做到参数匹配。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 引用参数</span><br><span class="line"></span><br><span class="line">​	使用引用参数时，必须在方法的申明和调用中都使用关键字`ref`修饰符。</span><br><span class="line"></span><br><span class="line">​	**实参必须是变量**，在用作**实参前必须被赋值**。如果是引用类型的变量，可以赋值为一个引用或者null值。</span><br><span class="line"></span><br><span class="line">​	引用参数不会像值参数那样创建副本，而是直接指向传进来的参数所指向的地址。</span><br><span class="line"></span><br><span class="line">就像c++的`&amp;`修饰符一样，可以使用引用的方式带回所需的数据。</span><br><span class="line"></span><br><span class="line">##### 样例</span><br><span class="line"></span><br><span class="line">​	下面的代码阐明了引用参数的声明和调用的语法：</span><br><span class="line"></span><br><span class="line">```c#</span><br><span class="line">void MyMethod(ref int val)  //方法声明包含ref修饰符</span><br><span class="line">&#123;</span><br><span class="line">    //your code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> y = <span class="number">1</span>;		   <span class="comment">//必须先赋值</span></span><br><span class="line">MyMethod(<span class="keyword">ref</span> y);   <span class="comment">//方法调用</span></span><br><span class="line"></span><br><span class="line">MyMethod(<span class="keyword">ref</span> <span class="number">3</span>+<span class="number">5</span>);  <span class="comment">//错误,形参必须是变量</span></span><br></pre></td></tr></table></figure>

<p>​	如果传入的是引用类型的变量，则在方法内重新指向新的对象后，在方法外一样会指向新的对象。如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;      </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            A a = <span class="keyword">new</span> A();</span><br><span class="line">            a.Name = <span class="string">&quot;A&quot;</span>;</span><br><span class="line"></span><br><span class="line">            T(<span class="keyword">ref</span> a);<span class="comment">//引用参数要求调用的时候也明确声明是引用</span></span><br><span class="line"></span><br><span class="line">            Console.WriteLine(a.Name);<span class="comment">//还是输出B，最早创建的Name = “A&quot;</span></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">T</span>(<span class="params"><span class="keyword">ref</span> A a</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(a.Name);<span class="comment">//输出A</span></span><br><span class="line">            a = <span class="keyword">new</span> A();</span><br><span class="line">            a.Name= <span class="string">&quot;B&quot;</span>;</span><br><span class="line">            Console.WriteLine(a.Name);<span class="comment">//输出B</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">A</span><span class="comment">//被引用的对象</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; name = <span class="keyword">value</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h4><p>​	在声明的时候使用<code>out</code>关键字进行声明的参数</p>
<p>​	正常来说方法的返回值只能有一个，如果需要返回多个参数可以借助输出参数</p>
<p>​	输出参数和引用参数类似，都不会创建新的存储位置。引用参数在传入的时候必须有一个明确的值，而输出参数不需要，原有的值会被丢弃。</p>
<p>​	在方法返回前，必须对传进来的输出参数名确赋值，否则编译器会报错。</p>
<p>​	不能借助输出参数传入数据。因为在方法体中，如果未对输出参数进行赋值，则无法使用。一旦赋值先前带有的值则会被丢弃</p>
<h5 id="样例1-1"><a href="#样例1-1" class="headerlink" title="样例1"></a>样例1</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;      </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            A a = <span class="keyword">new</span> A();</span><br><span class="line">            a.Name= <span class="string">&quot;A&quot;</span>;</span><br><span class="line">            A b;<span class="comment">//不需要赋值</span></span><br><span class="line"></span><br><span class="line">            T(<span class="keyword">out</span> a, <span class="keyword">out</span> b);<span class="comment">//也需要在调用的时候声明出来</span></span><br><span class="line"></span><br><span class="line">            Console.WriteLine(b.Name);<span class="comment">//还是输出B</span></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">T</span>(<span class="params"><span class="keyword">out</span> A a, <span class="keyword">out</span> A b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Console.WriteLine(a.Name);//编译器报错：使用了未赋值的out参数&quot;a&quot;；</span></span><br><span class="line">            <span class="comment">//a = new A();</span></span><br><span class="line">            a = <span class="literal">null</span>;</span><br><span class="line">            b = <span class="keyword">new</span> A();</span><br><span class="line">            b.Name= <span class="string">&quot;B&quot;</span>;</span><br><span class="line">            Console.WriteLine(b.Name);<span class="comment">//输出B</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">A</span><span class="comment">//被引用的对象</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; name = <span class="keyword">value</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="样例2-TryParse转换"><a href="#样例2-TryParse转换" class="headerlink" title="样例2 TryParse转换"></a>样例2 TryParse转换</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            s = <span class="string">&quot;123.45.6&quot;</span>;</span><br><span class="line">            <span class="built_in">double</span> d = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">double</span>.TryParse(s, <span class="keyword">out</span> d))<span class="comment">//尝试的转换，如果转换成功，则返回true，否则为false。同时转换完成的值以输出参数的形式带出，转换失败带出对应参数的默认值</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;转换成功&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;转换失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;转换完成的值是：&#123;0&#125;&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="数组参数-形参数组-params"><a href="#数组参数-形参数组-params" class="headerlink" title="数组参数(形参数组,params)"></a>数组参数(形参数组,params)</h4><p>​	有时，当声明一个方法时，<strong>不能确定要传递给函数作为参数的参数数目</strong>。C# 参数数组解决了这个问题，<strong>参数数组通常用于传递未知数量的参数给函数。</strong></p>
<p>​	在使用数组作为形参时，C# 提供了 params 关键字，使调用数组为形参的方法时，既可以传递数组实参，也可以传递一组数组元素。params 的使用格式为：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> 返回类型 方法名称( <span class="keyword">params</span> 类型名称[] 数组名称 )</span><br></pre></td></tr></table></figure>

<p><strong>需要注意，在使用params进行修饰的时候，只能存在一个被修饰的形参，且这个形参位于最后</strong>（因为无法分辨那些是属于这个参数）。</p>
<h5 id="样例-11"><a href="#样例-11" class="headerlink" title="样例"></a>样例</h5><p>在不使用形参数组作为形参的时候，写法是这样的，需要先创建一个数组，然后传入数组：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;ans is &#123;0&#125;&quot;</span>, CalculateSum(arr));</span><br><span class="line"></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CalculateSum</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> arr)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += item;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而使用形参数组之后，就不需要先新建一个数组，而是直接把数通过形参全部传入，且不需要指定传入的数的个数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> ans = CalculateSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);<span class="comment">//可以直接传入数个参数而不声明参数个数</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;ans is &#123;0&#125;&quot;</span>, ans);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CalculateSum</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> arr)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += item;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="具名参数：参数的位置不再受约束"><a href="#具名参数：参数的位置不再受约束" class="headerlink" title="具名参数：参数的位置不再受约束"></a>具名参数：参数的位置不再受约束</h4><p>严格来说不是具名参数不是某个参数的种类，而是参数的使用方法</p>
<p>正常情况下，实参顺序要和形参顺序相等，这种调用就是不具名调用。如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            PrintInfo(<span class="string">&quot;张三&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintInfo</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, name, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>使用具名调用后：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            PrintInfo(name: <span class="string">&quot;张三&quot;</span>, age: <span class="number">0</span>);<span class="comment">//具名调用                                </span></span><br><span class="line"></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintInfo</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, name, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>提高代码的可读性</li>
<li>参数的位置不受参数列表的约束</li>
</ol>
<h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>当在调用一个方法的时候，这个参数可写可不写。因为在声明参数的时候这个参数带有默认值。</p>
<p>对于带有默认值的参数，如果在调用参数的时候不写这个参数，则这个参数获得声明时的值。</p>
<p>不建议用可选参数。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            PrintInfo(name: <span class="string">&quot;李四&quot;</span>, age: <span class="number">20</span>);<span class="comment">//可以正常调用</span></span><br><span class="line">            PrintInfo();<span class="comment">//当参数缺省时，使用默认值输出</span></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintInfo</span>(<span class="params"><span class="built_in">string</span> name = <span class="string">&quot;张三&quot;</span>, <span class="built_in">int</span> age = <span class="number">-1</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, name, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="元组参数"><a href="#元组参数" class="headerlink" title="元组参数"></a>元组参数</h4><h5 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个样例方法，演示使用元组进行数据的传入和传出。</span></span><br><span class="line"><span class="keyword">static</span> (<span class="built_in">int</span>, <span class="built_in">double</span>)MySwap((<span class="built_in">double</span>, <span class="built_in">int</span>) x)</span><br><span class="line">&#123;</span><br><span class="line">    (<span class="built_in">int</span>, <span class="built_in">double</span>) t;</span><br><span class="line">    t.Item1 = x.Item2;</span><br><span class="line">    t.Item2 = x.Item1;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体见<code>c#元组</code>部分</p>
<h4 id="扩展方法（this参数）"><a href="#扩展方法（this参数）" class="headerlink" title="扩展方法（this参数）"></a>扩展方法（this参数）</h4><p>方法必须是<strong>公有的、静态的</strong>，即被public static所修饰。</p>
<p>必须是形参列表中的<code>第一个</code>，由this修饰</p>
<p>必须由一个<code>静态类</code>（类名一般为 数据类型+Extension ，如DoubleExtension）来统一收纳。（必须放在一个静态类中）</p>
<p>当无法对一个类型的源码进行修改的时候，可以使用扩展方法对这种数据类型进行追加方法。</p>
<h5 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h5><ol>
<li>创建一个静态类，类名为要扩展的数据类型的名字 + Extension。（不强制要求，但是是规范）</li>
<li>在这个静态类中创建一个静态的公共的方法，声明方法与常规方法相同，除了形参列表外。</li>
<li>形参列表的规则：<ol>
<li>有且最少有一个形参，并且第一个形参需要在前面加上this修饰符。形参的数据类型就是要扩展的数据类型，形参名随便，稍后要用。</li>
<li>this修饰符只允许存在一个，并且修饰的形参必须是第一个形参。</li>
<li>后面可以有多个参数。</li>
</ol>
</li>
<li>方法体中是这个扩展方法的实现过程，实现完后可以没有返回。</li>
</ol>
<h5 id="样例-12"><a href="#样例-12" class="headerlink" title="样例"></a>样例</h5><p>给string类型的变量增加一个ShowInfo的方法，以实现将string字符串输出到控制台。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> s = <span class="string">&quot;hurr&quot;</span>;</span><br><span class="line">            s.ShowInfo();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StringExtension</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowInfo</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DoubleExtension</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Round</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">double</span> input, <span class="built_in">int</span> digits</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span> result = Math.Round(input, digits);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="各种参数的使用场景"><a href="#各种参数的使用场景" class="headerlink" title="各种参数的使用场景"></a>各种参数的使用场景</h4><ul>
<li>传值参数：参数的默认传递方式</li>
<li>输出参数：用于除返回值外还需要返回输出的场景</li>
<li>引用参数：用于需要修改实际参数值的场景</li>
<li>数组参数：用于简化方法的调用</li>
<li>具名参数：提高可读性</li>
<li>可选参数：使参数拥有默认值</li>
<li>扩展方法（this参数）：为目标数据类型“追加”方法</li>
</ul>
<h3 id="方法的重载（Overload）"><a href="#方法的重载（Overload）" class="headerlink" title="方法的重载（Overload）"></a>方法的重载（Overload）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>当为一个类创建方法的时候，方法名可以一样，但方法的签名不能一样。</li>
<li>方法签名（method signature）由方法的名字、类型形参的个数和它每一个形参（按从左到右的顺序）的类型和种类（值、引用或输出）组成。<strong>方法的签名不包含返回类型</strong></li>
<li>重载决策（调用哪一个重载）：用于在给定了参数列表和一组候选函数成员的情况下，选择一个最佳函数成员来实施调用。</li>
</ul>
<p>简单地说就是，当多个方法的方法名相同，但所需的形参列表不同(类型或种类)的时候，就构成了方法的重载。注意方法的返回值是无所谓的</p>
<h3 id="方法的调用与栈的关系"><a href="#方法的调用与栈的关系" class="headerlink" title="方法的调用与栈的关系"></a>方法的调用与栈的关系</h3><h4 id="方法调用时栈内存的分析"><a href="#方法调用时栈内存的分析" class="headerlink" title="方法调用时栈内存的分析"></a>方法调用时栈内存的分析</h4><ul>
<li><p>stack frame的分析：一个方法在被调用的时候在栈内存中的布局。</p>
</li>
<li><p>栈内存在内存中由高字节位向低字节位分配，分配到最低后就溢出了。 </p>
</li>
<li><p>在当前方法中调用另一个方法，当前方法称为主调者，被调用的方法称为被调者。</p>
<ul>
<li><pre><code class="language-c#">static void Main(string[] args)
{
    Student student= new Student(10,&quot;张三&quot;);
    student.ShowInfo();//Main：主调者 caller ；ShowInfo：被调者 callee
    Console.ReadLine();
}
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 传入的参数（变量）也需要压入栈中，并且在C#中，传入的变量归主调者管。入栈的时候，值是传入的参数，但类型是被调者形参决定的。如果主调者调用的方法的形参列表是double，但调用传入的时候是int类型的100，则在栈中，会分配一片double的空间，将int的100自动的进行隐式类型转换成double，然后存入。</span><br><span class="line"></span><br><span class="line">- 到被调者执行的时候，只需要再往栈中压入内部的局部变量即可（传进来的参数不用管，那个由主调者压）。</span><br><span class="line"></span><br><span class="line">- 除此之外，还需要压入主调者指针等其他参数</span><br><span class="line"></span><br><span class="line">- 返回值一般存储在cpu的寄存器中（前提是能存储下）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 静态方法</span><br><span class="line"></span><br><span class="line">#### 修饰符</span><br><span class="line"></span><br><span class="line">被static修饰。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 特点</span><br><span class="line"></span><br><span class="line">1. 静态方法属于类所有，类实例化前即可使用（不需要实例化就可以方法）。</span><br><span class="line">2. 静态方法只能访问类中的静态成员，而非静态方法可以访问类中的任何成员。</span><br><span class="line">3. 静态方法在使用上不需要实例化类，而非静态方法需要实例化后才能调用。</span><br><span class="line">4. 静态方法不能直接使用非静态成员，因为非静态成员与实例相关，通过对象点取间接使用。</span><br><span class="line">5. 静态方法中不能用this（与实例相关）。</span><br><span class="line">6. 静态方法的生命周期很长，一旦被创建，直到程序结束位置。</span><br><span class="line">   - 静态变量不管是在全局还是局部声明的static变量都存放于程序的全局变量区域。</span><br><span class="line">   - 静态变量的作用域是变量的可见代码域（块作用域，函数作用域，类作用域，程序全局作用域）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 注意事项</span><br><span class="line"></span><br><span class="line">- 静态方法可以使用类名也可以使用对象来调用，而非静态方法只能使用对象来调用[1](https://bing.com/search?q=使用静态方法的注意事项有哪些).</span><br><span class="line">- 静态方法可以直接访问静态的成员，但是不能直接访问非静态的成员[1](https://bing.com/search?q=使用静态方法的注意事项有哪些).</span><br><span class="line">- 静态方法不能出现this或者super关键字，因为静态方法可以直接使用类名进行访问，而this关键字代表的是调用方法的对象，此时就会产生冲突。</span><br><span class="line">- 静态方法不宜过多。可能会占用过多的内存。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 索引器?</span><br><span class="line"></span><br><span class="line">### 什么是索引器</span><br><span class="line"></span><br><span class="line">**索引器（Indexer）** 允许一个对象可以像数组一样使用下标的方式来访问。</span><br><span class="line"></span><br><span class="line">当为类定义一个索引器时，该类的行为就会像一个 **虚拟数组（virtual array）** 一样，可以使用数组访问运算符 **[ ]** 来访问该类的的成员。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 语法</span><br><span class="line"></span><br><span class="line">```c#</span><br><span class="line">element-type this[int index]</span><br><span class="line">&#123;</span><br><span class="line">   // get 访问器</span><br><span class="line">   get</span><br><span class="line">   &#123;</span><br><span class="line">      // 返回 index 指定的值</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // set 访问器</span><br><span class="line">   set</span><br><span class="line">   &#123;</span><br><span class="line">      // 设置 index 指定的值</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="索引器（Indexer）的用途"><a href="#索引器（Indexer）的用途" class="headerlink" title="索引器（Indexer）的用途"></a>索引器（Indexer）的用途</h3><p>​	索引器的行为的声明在某种程度上类似于属性（property）。就像属性（property），可使用 <strong>get</strong> 和 <strong>set</strong> 访问器来定义索引器。但是，属性返回或设置一个特定的<strong>数据成员</strong>，而索引器返回或设置<strong>对象实例的一个特定值</strong>。换句话说，它把实例数据分为更小的部分，并索引每个部分，获取或设置每个部分。</p>
<p>​	定义一个属性（property）包括提供属性名称。索引器定义的时候不带有名称，但带有 <strong>this</strong> 关键字，它指向对象实例。下面的实例演示了这个概念：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">IndexerApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">IndexedNames</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="built_in">string</span>[] namelist = <span class="keyword">new</span> <span class="built_in">string</span>[size];</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">int</span> size = <span class="number">10</span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">IndexedNames</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">         namelist[i] = <span class="string">&quot;N. A.&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">get</span></span><br><span class="line">         &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size<span class="number">-1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">               tmp = namelist[index];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">               tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ( tmp );</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">set</span></span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">if</span>( index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size<span class="number">-1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">               namelist[index] = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         IndexedNames names = <span class="keyword">new</span> IndexedNames();</span><br><span class="line">         names[<span class="number">0</span>] = <span class="string">&quot;Zara&quot;</span>;</span><br><span class="line">         names[<span class="number">1</span>] = <span class="string">&quot;Riz&quot;</span>;</span><br><span class="line">         names[<span class="number">2</span>] = <span class="string">&quot;Nuha&quot;</span>;</span><br><span class="line">         names[<span class="number">3</span>] = <span class="string">&quot;Asif&quot;</span>;</span><br><span class="line">         names[<span class="number">4</span>] = <span class="string">&quot;Davinder&quot;</span>;</span><br><span class="line">         names[<span class="number">5</span>] = <span class="string">&quot;Sunil&quot;</span>;</span><br><span class="line">         names[<span class="number">6</span>] = <span class="string">&quot;Rubic&quot;</span>;</span><br><span class="line">         <span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; IndexedNames.size; i++ )</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(names[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Zara</span><br><span class="line">Riz</span><br><span class="line">Nuha</span><br><span class="line">Asif</span><br><span class="line">Davinder</span><br><span class="line">Sunil</span><br><span class="line">Rubic</span><br><span class="line">N. A.</span><br><span class="line">N. A.</span><br><span class="line">N. A.</span><br></pre></td></tr></table></figure>





<h3 id="样例-13"><a href="#样例-13" class="headerlink" title="样例"></a>样例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;      </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Student student = <span class="keyword">new</span> Student();</span><br><span class="line">            student[<span class="number">0</span>] = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">            student[<span class="number">1</span>] = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">            student[<span class="number">2</span>] = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Student.size; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(student[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">int</span> size = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span>[] nameList = <span class="keyword">new</span> <span class="built_in">string</span>[size];<span class="comment">//创建一个string list</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span>()<span class="comment">//无参构造器，默认全部构造成“空”</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                nameList[i] = <span class="string">&quot;NA&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//索引器</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span><span class="comment">//读取</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> tmp;<span class="comment">//一个临时变量</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; nameList.Length)<span class="comment">//如果索引值在合法范围内</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = nameList[index];<span class="comment">//获取值</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = <span class="string">&quot;&quot;</span>;<span class="comment">//不在就返回空串</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> tmp;<span class="comment">//返回获取到的值</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">set</span><span class="comment">//写入</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(index &gt;=<span class="number">0</span> &amp;&amp; index &lt; size - <span class="number">1</span>) <span class="comment">//如果没有超过规定的大小</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nameList[index] = <span class="keyword">value</span>;<span class="comment">//就读入</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>索引器可以使用任何有效的访问修饰符（public、protected internal、protected、internal、private、private protected）。它们可能是密封、虚拟或者抽象的。与属性一样，可以在索引器中为get和set访问器指定不同的访问修饰符。还可以指定只读索引器（忽略set访问器）或只写索引器（忽略get访问器）。</p>
<p>属性的各种用法同样适用于索引器（唯一例外的是“自动实现属性”，编译器无法始终为索引器生成正确的存储）。</p>
<p><strong>创建索引器的必备要素：</strong></p>
<ol>
<li>必须先创建索引器所需要的容器（可以理解为数据的存放）；</li>
<li>创建索引器需要使用this关键字；</li>
<li>索引器中必须包含get和set访问器，在C# 7.0后可以使用表达式（&#x3D;&gt;）主体进行简化；</li>
<li>在使用表达式主体成员进行索引时，必须额外的提供容器的修改接口（因为表达式主体不包括set访问器）。</li>
</ol>
<p>索引器相当于一个方法，支持多个或多种类型的参数，与方法不同的是，索引器没有独立的名称，只能通过返回值的不同和参数的不同来区分不同的签名（从而实现重载），其返回值不能为void。索引器除了可以传入参数外，其返回值不能为void。索引器除了可以传入参数外，还可以对其进行赋值。</p>
<p>创建索引器时，其返回值为value关键字所使用的类型，定义了返回值类型的同时，也定义了其可接受的值类型。</p>
<p>总之，我对索引器的理解就是：是一个可以进行读写操作的自定义类中数据集合的接口。通过该接口，简化或丰富了该自定义类中数据集合的操作方式。</p>
<p>例如，在如下示例中，此索引器使用List作为容器，使用int类型的index进行索引，返回值为Measurements对象。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/488448024">https://zhuanlan.zhihu.com/p/488448024</a></p>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>对于类而言，可分为<code>静态构造器</code>和<code>实例构造器</code>两种。</p>
<h3 id="构造器（特殊的方法）"><a href="#构造器（特殊的方法）" class="headerlink" title="构造器（特殊的方法）"></a>构造器（特殊的方法）</h3><ul>
<li>构造器(constructor)（构造函数）是类的成员之一</li>
<li>狭义的构造器是指“实例构造器”（instance constructor）</li>
<li>一般来说构造器都是public的</li>
<li>当声明了一个类之后，但又没有写构造器，编译器就会为它准备一个默认的构造器。一旦写了构造器，编译器将不会添加默认构造器。</li>
<li>构造器没有返回值类型。</li>
<li>构造器的名称必须和类名称相同。</li>
<li>构造器可以被重载。</li>
<li>当调用子类构造器时 会自动调用父类的构造器。</li>
</ul>
<h4 id="构造器的声明"><a href="#构造器的声明" class="headerlink" title="构造器的声明"></a>构造器的声明</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">访问修饰符 类名(参数列表) [: <span class="keyword">base</span>(传递给父类构造器的实参)]</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="样例-14"><a href="#样例-14" class="headerlink" title="样例"></a>样例</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> a &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span> : <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> b &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>) : <span class="title">base</span>(<span class="params">a</span>)<span class="comment">//当调用子类的构造函数时，会自动调用父类的构造函数。如果父类不存在无参构造函数，则需要使用base关键字向父类的构造函数传递值。</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="静态构造器"><a href="#静态构造器" class="headerlink" title="静态构造器"></a>静态构造器</h3><p>​	在使用类中的静态成员的时候，需要预先初始化这些成员。</p>
<p>​	静态构造函数用于初始化任何<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/static">静态</a>数据，或执行仅需执行一次的特定操作。 将在创建第一个实例或引用任何静态成员之前自动调用静态构造函数。</p>
<p>​	他的语法规则和普通的构造器类似，要求都是方法名与类型相同，且都不可以有返回值；不同的是静态构造器的修饰符不再是public，而是static。</p>
<p>​	一个类只能有一个静态构造器，该构造器不能有访问修饰符，也不能带有任何参数。静态构造器不能直接调用，只能在下述情况下执行：</p>
<ul>
<li>创建包含静态构造函数的类实例时</li>
<li>访问包含静态构造函数的类的静态成员时</li>
</ul>
<p>​	首先先调用静态构造器，之后再实例化或访问静态成员。</p>
<p>​	可以说，只要类存在静态构造器，只要这个类被调用过，就会且只会调用一次静态构造器。</p>
<p>​	</p>
<h4 id="样例-15"><a href="#样例-15" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;正在执行Main方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">            A.num = <span class="number">10</span>;<span class="comment">//当访问包含静态构造函数的类的静态成员时，运行环境会将这个类加载到内存中，同时会触发这个类的静态构造器。</span></span><br><span class="line"></span><br><span class="line">            B b1 = <span class="keyword">new</span> B();<span class="comment">//创建包含静态构造函数的类实例时，也会在调用实例构造器的同时调用静态构造器。</span></span><br><span class="line"></span><br><span class="line">            B b2 = <span class="keyword">new</span> B();<span class="comment">//静态构造器只会执行一次，再次创建实例的时候，只会再次调用实例构造器，而不会调用静态构造器。</span></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> num;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="title">A</span>()<span class="comment">//静态构造器，只在运行环境加载这个类的时候调用，且只调用一次。</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;A的静态构造器已执行。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">class</span> <span class="title">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="title">B</span>()<span class="comment">//静态构造器，只在运行环境加载这个类的时候调用，且只调用一次。</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;B的静态构造器已执行。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;B的实例构造器已执行。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> id</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span>; <span class="keyword">set</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="析构器"><a href="#析构器" class="headerlink" title="析构器"></a>析构器</h2><p>析构方法（析构器）是在垃圾回收、释放资源时使用的。</p>
<ul>
<li>不能在结构中定义析构函数。只能对类使用析构函数。</li>
<li>析构函数不能重载，一个类只能有一个析构函数。</li>
<li>析构函数无法继承，他的子类将拥有除父类的析构函数外的所有元素（先执行子类的构造函数，再执行父类的构造函数。如果需要手动调用父类的构造函数，可以用base关键字）。</li>
<li>无法调用析构函数。它们是被自动调用的。</li>
<li>析构函数既没有修饰符，也没有参数。</li>
</ul>
<h3 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">~方法名()</span><br><span class="line">&#123;</span><br><span class="line">    语句块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无法控制何时调用析构函数，因为这是由垃圾回收器决定的。垃圾回收器检查是否存在应用程序不再使用的对象。如果垃圾回收器认为某个对象符合析构，则调用析构函数（如果有）并回收用来存储此对象的内存。程序退出时也会调用析构函数。</p>
<p>可以通过调用 <code>Collect</code> 强制进行垃圾回收，但大多数情况下应避免这样做，因为这样会导致性能问题。有关更多信息，请参见强制垃圾回收。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>​	接口定义了所有类继承接口时应遵循的语法合同。接口定义了语法合同 “是什么” 部分，派生类定义了语法合同 “怎么做” 部分。</p>
<p>​	接口定义了属性、方法和事件，这些都是接口的成员。接口只包含了成员的声明。成员的定义是派生类的责任。接口提供了派生类应遵循的标准结构。</p>
<p>​	接口使得实现接口的类或结构在形式上保持一致。</p>
<p>​	抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。</p>
<p>​	接口本身并不实现任何功能，它只是和声明实现该接口的对象订立一个必须实现哪些行为的契约。</p>
<p>​	抽象类不能直接实例化，但允许派生出具体的，具有实际功能的类。</p>
<p>​	可以使用virtual或abstract来实现接口成员，但不能使用static或const。</p>
<h3 id="定义接口-MyInterface-cs"><a href="#定义接口-MyInterface-cs" class="headerlink" title="定义接口: MyInterface.cs"></a>定义接口: MyInterface.cs</h3><p>接口使用 <code>interface</code> 关键字声明，它与类的声明类似。接口声明默认是 <code>public</code> 的。下面是一个接口声明的实例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IMyInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MethodToImplement</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码定义了接口 IMyInterface。通常接口命令以 <code>I</code> 字母开头，这个接口只有一个方法 MethodToImplement()，没有参数和返回值，当然我们可以按照需求设置参数和返回值。</p>
<p>值得注意的是，该方法<strong>并没有具体的实现</strong>。</p>
<p>接下来我们来实现以上接口：InterfaceImplementer.cs</p>
<h4 id="样例-16"><a href="#样例-16" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IMyInterface</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 接口成员</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MethodToImplement</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">InterfaceImplementer</span> : <span class="title">IMyInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InterfaceImplementer iImp = <span class="keyword">new</span> InterfaceImplementer();</span><br><span class="line">        iImp.MethodToImplement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodToImplement</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MethodToImplement() called.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InterfaceImplementer</code> 类实现了 <code>IMyInterface</code> 接口，接口的实现与类的继承语法格式类似：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">InterfaceImplementer</span> : <span class="title">IMyInterface</span></span><br></pre></td></tr></table></figure>

<p>​	继承接口后，我们需要实现接口的方法 <code>MethodToImplement()</code> , 方法名必须与接口定义的方法名一致。</p>
<h3 id="接口继承-InterfaceInheritance-cs"><a href="#接口继承-InterfaceInheritance-cs" class="headerlink" title="接口继承: InterfaceInheritance.cs"></a>接口继承: InterfaceInheritance.cs</h3><p>以下实例定义了两个接口 <code>IMyInterface</code> 和 <code>IParentInterface</code>。</p>
<p>如果一个接口继承其他接口，那么实现类或结构就需要实现所有接口的成员。</p>
<p>以下实例 <code>IMyInterface</code> 继承了 <code>IParentInterface</code> 接口，因此接口实现类必须实现 <code>MethodToImplement()</code> 和 <code>ParentInterfaceMethod()</code> 方法：</p>
<h4 id="样例-17"><a href="#样例-17" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IParentInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ParentInterfaceMethod</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IMyInterface</span> : <span class="title">IParentInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MethodToImplement</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">InterfaceImplementer</span> : <span class="title">IMyInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InterfaceImplementer iImp = <span class="keyword">new</span> InterfaceImplementer();</span><br><span class="line">        iImp.MethodToImplement();</span><br><span class="line">        iImp.ParentInterfaceMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodToImplement</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MethodToImplement() called.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ParentInterfaceMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ParentInterfaceMethod() called.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例输出结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MethodToImplement() called.</span><br><span class="line">ParentInterfaceMethod() called.</span><br></pre></td></tr></table></figure>









<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>嵌套类顾名思义就是类或者结构中定义的类</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Container</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Nested</span></span><br><span class="line">    &#123;</span><br><span class="line">        Nested() &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>嵌套类的默认访问权限是private ，可以指定为public，protected，private，internal，protected internal。</li>
<li>嵌套类型可以访问外部类（包裹嵌套类的类），如果要访问外部类型，要把外部类通过构造函数传进一个实例</li>
<li>嵌套类中只能访问外部类中的静态成员，不能直接访问外部类的非静态成员。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApplication11Anonymous</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Class1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> x;</span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">int</span> y;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Nested</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> xx;</span><br><span class="line">            <span class="built_in">string</span> ss;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">print</span>()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//int y = x;  //error,不能访问外部的非静态成员</span></span><br><span class="line">                <span class="built_in">int</span> z = y;    <span class="comment">//OK ,可以访问外部的静态成员</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Nested</span>(<span class="params">Class1 A</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                xx = A.x;   <span class="comment">//通过外部类的实例来访问外部类私有成员</span></span><br><span class="line">                ss = A.str; <span class="comment">//通过外部类的实例来访问外部类保护成员</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Class1 X = <span class="keyword">new</span> Class1();</span><br><span class="line">            Class1.Nested CN = <span class="keyword">new</span> Class1.Nested( X );     </span><br><span class="line">        &#125; </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>根据C#作用域的规则，外部类只能通过内部类的实例来访问内部类的public成员，不能访问protected，private。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Class2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> x;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">private</span> <span class="built_in">int</span> y;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//x = xx;   //当前上下文中不存在名称“xx”</span></span><br><span class="line">            <span class="comment">//x = zz;   //当前上下文中不存在名称“zz”</span></span><br><span class="line">            <span class="comment">//x = aa;   //当前上下文中不存在名称“aa”</span></span><br><span class="line">            x = Nested.aa;</span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">funcs</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这个只能访问Nested类的public成员</span></span><br><span class="line">            Nested XX = <span class="keyword">new</span> Nested();</span><br><span class="line">            x = XX.zz;</span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line">            <span class="comment">//x = XX.aa;//访问静态成员只能通过类名而不是实例</span></span><br><span class="line">            x = Nested.aa;</span><br><span class="line">            Console.WriteLine(x);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Nested</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="built_in">int</span> xx;</span><br><span class="line">            <span class="keyword">protected</span> <span class="built_in">int</span> yy;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> zz;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> aa;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="C-访问级别"><a href="#C-访问级别" class="headerlink" title="C# 访问级别"></a>C# 访问级别</h2><p>​	<strong>封装</strong> 被定义为”把一个或多个项目封闭在一个物理的或者逻辑的包中”。在面向对象程序设计方法论中，封装是为了防止<strong>对实现细节的访问</strong>。</p>
<p>​	抽象和封装是面向对象程序设计的相关特性。抽象允许相关信息可视化，封装则使开发者<em>实现所需级别的抽象</em>。</p>
<p>​	C# 封装根据具体的需要，设置使用者的访问权限，并通过 <strong>访问修饰符</strong> 来实现。</p>
<p>同一修饰符在一个类的声明中多次出现是编译时错误</p>
<p>在C#中，不同的类型和成员有不同的默认访问级别，如下：</p>
<ul>
<li>类型（类、结构、枚举、委托等）在命名空间中声明时，默认访问级别是内部的（internal），这意味着它们只能在同一个程序集中访问；在其他类型中嵌套时，默认访问级别是私有的，这意味着它们只能在包含它们的类型中访问。</li>
<li>类型成员（字段、属性、方法、事件等）默认访问级别是私有的，这意味着它们只能在类内部访问。</li>
<li>接口成员默认访问级别是公共的，这意味着它们必须在实现接口的类或结构中公开。</li>
</ul>
<p>不好意思深夜打扰老师了，刚刚遇到一个小问题，关于c# 中的gethashcode方法，new bing回答我的时候说到了“GetHashCode()方法返回的值不能用来判断对象是否相等，也不能用来存储或比较数据”，我有点没看懂这个意思，gethashcode方法是不能可靠的辨别对象是否是同一个吗？</p>
<p>一个 <strong>访问修饰符</strong> 定义了一个类成员的范围和可见性。C# 支持的访问修饰符如下所示：</p>
<ul>
<li>public：所有对象都可以访问；</li>
<li>private：对象本身在对象内部可以访问；</li>
<li>protected：只有该类对象及其子类对象可以访问</li>
<li>internal：同一个程序集的对象可以访问；</li>
<li>protected internal：访问限于当前程序集或派生自包含类的类型。</li>
<li>sealed：用于修饰类。一旦类被这个关键字所修饰，就不允许再被继承。</li>
</ul>
<h3 id="Public-访问修饰符"><a href="#Public-访问修饰符" class="headerlink" title="Public 访问修饰符"></a>Public 访问修饰符</h3><p>Public 访问修饰符允许一个类将其成员变量和成员函数暴露给其他的函数和对象。任何公有成员可以被外部的类访问。</p>
<p>下面的实例说明了这点：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RectangleApplication</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">  &#123;</span><br><span class="line">    *<span class="comment">//成员变量*</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> length;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">GetArea</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> length * width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;长度： &#123;0&#125;&quot;</span>, length);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;宽度： &#123;0&#125;&quot;</span>, width);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;面积： &#123;0&#125;&quot;</span>, GetArea());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;*<span class="comment">// Rectangle 结束*</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title">ExecuteRectangle</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      Rectangle r = <span class="keyword">new</span> Rectangle();</span><br><span class="line">      r.length = <span class="number">4.5</span>;</span><br><span class="line">      r.width = <span class="number">3.5</span>;</span><br><span class="line">      r.Display();</span><br><span class="line">      Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">长度： 4.5</span><br><span class="line">宽度： 3.5</span><br><span class="line">面积： 15.75</span><br></pre></td></tr></table></figure>

<p>在上面的实例中，成员变量 length 和 width 被声明为 public，所以它们可以被函数 Main() 使用 Rectangle 类的实例 r 访问。</p>
<p>成员函数 <em>Display()</em> 和 <em>GetArea()</em> 可以直接访问这些变量。</p>
<p>成员函数 <em>Display()</em> 也被声明为 public，所以它也能被 <em>Main()</em> 使用 Rectangle 类的实例 r 访问。</p>
<h3 id="Private-访问修饰符"><a href="#Private-访问修饰符" class="headerlink" title="Private 访问修饰符"></a>Private 访问修饰符</h3><p>Private 访问修饰符允许一个类将其成员变量和成员函数对其他的函数和对象进行隐藏。只有同一个类中的函数可以访问它的私有成员。即使是类的实例也不能访问它的私有成员。</p>
<p>下面的实例说明了这点：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RectangleApplication</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">  &#123;</span><br><span class="line">    *<span class="comment">//成员变量*</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Acceptdetails</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;请输入长度：&quot;</span>);</span><br><span class="line">      length = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;请输入宽度：&quot;</span>);</span><br><span class="line">      width = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">GetArea</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> length * width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;长度： &#123;0&#125;&quot;</span>, length);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;宽度： &#123;0&#125;&quot;</span>, width);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;面积： &#123;0&#125;&quot;</span>, GetArea());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;*<span class="comment">//end class Rectangle*   </span></span><br><span class="line">  <span class="keyword">class</span> <span class="title">ExecuteRectangle</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      Rectangle r = <span class="keyword">new</span> Rectangle();</span><br><span class="line">      r.Acceptdetails();</span><br><span class="line">      r.Display();</span><br><span class="line">      Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请输入长度：</span><br><span class="line">4.4</span><br><span class="line">请输入宽度：</span><br><span class="line">3.3</span><br><span class="line">长度： 4.4</span><br><span class="line">宽度： 3.3</span><br><span class="line">面积： 14.52</span><br></pre></td></tr></table></figure>

<p>在上面的实例中，成员变量 length 和 width 被声明为 private，所以它们不能被函数 Main() 访问。</p>
<p>成员函数 <em>AcceptDetails()</em> 和 <em>Display()</em> 可以访问这些变量。</p>
<p>由于成员函数 <em>AcceptDetails()</em> 和 <em>Display()</em> 被声明为 public，所以它们可以被 <em>Main()</em> 使用 Rectangle 类的实例 r 访问。</p>
<h3 id="Protected-访问修饰符"><a href="#Protected-访问修饰符" class="headerlink" title="Protected 访问修饰符"></a>Protected 访问修饰符</h3><p>Protected 访问修饰符允许子类访问它的基类的成员变量和成员函数。这样有助于实现继承。我们将在继承的章节详细讨论这个。更详细地讨论这个。</p>
<h3 id="Internal-访问修饰符"><a href="#Internal-访问修饰符" class="headerlink" title="Internal 访问修饰符"></a>Internal 访问修饰符</h3><p>Internal 访问说明符允许一个类将其成员变量和成员函数暴露给当前程序中的其他函数和对象。换句话说，带有 internal 访问修饰符的任何成员可以被定义在该成员所定义的应用程序内的任何类或方法访问。</p>
<p>如果一个类前面没有添加任何修饰符，则相当于添加了Internal修饰符。</p>
<p>但，如果声明了internal，则在同一个项目中可以访问，在其他项目中无法访问。</p>
<p>简单的说就是阻止跨项目的访问。</p>
<h4 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h4><p>环境说明：一个ConsoleApp项目下的Program文件，其中的命名空间时ConsoleApp，并且在ConsoleApp项目中的引用里添加了MyLib的引用</p>
<p>一个MyLib类库下的Calculator文件，其中的命名空间为MyNamespace。</p>
<p>一个MyLib类库下的test文件，其中的命名空间为MyNamespace2。</p>
<h5 id="Program文件："><a href="#Program文件：" class="headerlink" title="Program文件："></a>Program文件：</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//MyLib.MyNamespace.ADD Add = new MyLib.MyNamespace.ADD();//编译器报错： 错误 CS0122	“ADD”不可访问，因为它具有一定的保护级别 </span></span><br><span class="line"></span><br><span class="line">            MyLib.MyNamespace.SUB Sub = <span class="keyword">new</span> MyLib.MyNamespace.SUB();<span class="comment">//public修饰的则可以正常的访问</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Calculator文件"><a href="#Calculator文件" class="headerlink" title="Calculator文件"></a>Calculator文件</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyLib.MyNamespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">ADD</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SUB</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Sub</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x - y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">test</span></span><br><span class="line">    &#123;</span><br><span class="line">        ADD Add = <span class="keyword">new</span> ADD();<span class="comment">//在同一个命名空间中可以访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="test文件"><a href="#test文件" class="headerlink" title="test文件"></a>test文件</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyLib.MyNamespace2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">test</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyNamespace.ADD Add = <span class="keyword">new</span> MyNamespace.ADD();<span class="comment">//同一项目下跨命名空间也是可以访问的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/image-20230306085856474.png" alt="image-20230306085856474"></p>
<h3 id="Protected-Internal-访问修饰符"><a href="#Protected-Internal-访问修饰符" class="headerlink" title="Protected Internal 访问修饰符"></a>Protected Internal 访问修饰符</h3><p>Protected Internal 访问修饰符允许在本类,派生类或者包含该类的程序集中访问。这也被用于实现继承。</p>
<h1 id="面向对象编程（OOP）"><a href="#面向对象编程（OOP）" class="headerlink" title="面向对象编程（OOP）"></a>面向对象编程（OOP）</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是OOP的最重要的特征之一，任何类都可以从另一个类继承。</p>
<p>​	继承的本质是派生类在基类已有的成员的基础上，对基类进行的横向的和纵向的扩展。</p>
<ul>
<li>派生类基于已有的成员<ul>
<li>当继承发生时，子类继承了父类所有的成员（除了构造函数和析构函数）</li>
</ul>
</li>
<li>在派生和继承的过程中，进行的是扩展<ul>
<li>类的成员只能是越来越多，不可能减少。即不可以删除任何已有的成员。</li>
<li>一个类成员一旦被引入到继承链中，就会一直向下传递。</li>
<li>不要贸然引入新的类成员，不然可能造成对继承链的污染</li>
<li>部分动态语言可以做到移除成员变量，如python、js</li>
</ul>
</li>
<li>横向指的是添加类成员，纵向指的是重写类成员</li>
</ul>
<blockquote>
<p>​	在UML中，公共成员用+表示，其他成员用一(私有成员)、#(受 保护的成员)和斜体(虚拟成员)表示。</p>
<p>​	虚拟成员不能是私有成员，因为这样会自相矛盾一不能既要求派生类重写成员，又不让派生类访问该成员。</p>
<p>​	C#提供了第三种可访问性: protected, 只有派生类才能访问protected成员。对于外部代码来说，这个可访问性与私有成员一样:外部代码不能访问private成员和protected成员。详细说明见上方类与成员中</p>
</blockquote>
<h3 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h3><ul>
<li><p>当子类的构造器被调用的时候，会自动调用父类的构造器。先调用父类，再调用子类。当结束时，会按照与构造器调用顺序相反的顺序调用析构器。</p>
<ul>
<li><pre><code class="language-c#">using System;
using System.Windows.Forms;

namespace ConsoleApp
{
    internal class Program
    {
        static void Main(string[] args)
        {
            A a = new A();
            B b = new B();
            //输出结果：
            //A的构造器被调用了
            //A的构造器被调用了
            //B的构造器被调用了
            //B的析构器被调用了
            //A的析构器被调用了
            //A的析构器被调用了
            //请按任意键继续. . .

            Console.ReadKey();
        }
    }
    class A
    {
        public A()
        {
            Console.WriteLine(&quot;A的构造器被调用了&quot;);
        }
        ~A()
        {
            Console.WriteLine(&quot;A的析构器被调用了&quot;);
        }
    }
    class B : A
    {
        public B()
        {
            Console.WriteLine(&quot;B的构造器被调用了&quot;);
        }
        ~B()
        {
            Console.WriteLine(&quot;B的析构器被调用了&quot;);
        }
    }

}
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- 一个类可以被多个类继承，但一个类只能继承一个类，整个关系呈现一个 `树状` 的形态</span><br><span class="line"></span><br><span class="line">- 子类 is a 父类。一个子类的实例同时也是父类的一个实例。子类是属于父类的，在子类实例化的对象可以被父变量所指向，但父变量只能调用一些父类中拥有的成员。</span><br><span class="line"></span><br><span class="line">  - ```c#</span><br><span class="line">    using System;</span><br><span class="line">    using System.Windows.Forms;</span><br><span class="line">    </span><br><span class="line">    namespace ConsoleApp</span><br><span class="line">    &#123;</span><br><span class="line">        internal class Program</span><br><span class="line">        &#123;</span><br><span class="line">            static void Main(string[] args)</span><br><span class="line">            &#123;</span><br><span class="line">                A a = new A();</span><br><span class="line">                B b = new B();</span><br><span class="line">                A c = new B();</span><br><span class="line">                a.showinfo();//输出A</span><br><span class="line">                b.showinfo();//B</span><br><span class="line">                c.showinfo();//A </span><br><span class="line">                Console.WriteLine(a is B);//false，证明父类不属于子类</span><br><span class="line">                Console.WriteLine(b is A);//true，证明子类属于父类</span><br><span class="line">                Console.ReadKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        class A</span><br><span class="line">        &#123;</span><br><span class="line">            public void showinfo()</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;A&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        class B : A</span><br><span class="line">        &#123;</span><br><span class="line">            public void showinfo()</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;B&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>在子类中可以使用base关键字访问父类的元素，但只能向上访问一层。</p>
<ul>
<li><pre><code class="language-c#">using System;
using System.Windows.Forms;

namespace ConsoleApp
{
    internal class Program
    {
        static void Main(string[] args)
        {
            A a = new A();
            B b = new B();
            a.ShowInfo();//A
            b.ShowInfo();//B
            b.ShoeInfoFa();//A

            Console.ReadKey();
        }
    }

    class S
    {
        public string str { get; set; }
    }

    class A : S
    {
        public string str { get; set; }
        public A()
        {
            str = &quot;A&quot;;
        }
        public void ShowInfo()
        {
            Console.WriteLine(str);
        }
    }
    class B : A
    {
        public string str { get; set; }
        public B()
        {
            str = &quot;B&quot;;
        }
        public void ShowInfo()
        {
            Console.WriteLine(str);
        }
        public void ShoeInfoFa()
        {
            Console.WriteLine(base.str);
            //base.base.str = &quot;A&quot;;  //是不被允许的
        }
    }

}
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- 子类的访问权限不能超越父类的访问权限。如父类的一个字段是保护的，可以将这个字段在子类中设置成私有、保护  ，但不能设置成public或internal。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">## 多态性</span><br><span class="line"></span><br><span class="line">多态是同一个行为具有多个不同表现形式或形态的能力。</span><br><span class="line"></span><br><span class="line">**多态性**意味着有多重形式。在面向对象编程范式中，多态性往往表现为&quot;一个接口，多个功能&quot;。</span><br><span class="line"></span><br><span class="line">多态性可以是静态的或动态的。在**静态多态性**中，函数的响应是在编译时发生的。在**动态多态性**中，函数的响应是在运行时发生的。</span><br><span class="line"></span><br><span class="line">在 C# 中，每个类型都是多态的，因为包括用户定义类型在内的所有类型都继承自 Object。</span><br><span class="line"></span><br><span class="line">多态就是同一个接口，使用不同的实例而执行不同操作。</span><br><span class="line"></span><br><span class="line">多态的概念：让一个对象能够表现出多种状态。</span><br><span class="line"></span><br><span class="line">### 静态多态性</span><br><span class="line"></span><br><span class="line">在编译时，函数和对象的连接机制被称为早期绑定，也被称为静态绑定。C# 提供了两种技术来实现静态多态性。分别为：</span><br><span class="line"></span><br><span class="line">- 函数重载</span><br><span class="line">  - 具体见C#的类与成员中的方法部分 其中介绍了方法的重载</span><br><span class="line">- 运算符重载</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 运算符重载</span><br><span class="line"></span><br><span class="line">##### 概述</span><br><span class="line"></span><br><span class="line">可以重定义或重载 C# 中内置的运算符。因此，程序员也可以使用用户自定义类型的运算符。重载运算符是具有特殊名称的函数，是通过关键字 **operator** 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。</span><br><span class="line"></span><br><span class="line">注意，只能重载现有的C#运算符，不能创建新的运算符。</span><br><span class="line"></span><br><span class="line">​	运算符重载其实就是函数重载。首先通过指定的运算表达式调用对应的运算符函数，然后再将运算对象转化为运算符函数的实参，接着根据实参的类型来确定需要调用的函数的重载，这个过程是由编译器完成。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 可重载和不可重载运算符</span><br><span class="line"></span><br><span class="line">| 运算符                                | 描述                                               |</span><br><span class="line">| :------------------------------------ | :------------------------------------------------- |</span><br><span class="line">| +, -, !, ~, ++, --                    | 这些      一元运算符只有一个操作数，且可以被重载。 |</span><br><span class="line">| +, -, *, /, %                         | 这些二元运算符带有两个操作数，且可以被重载。       |</span><br><span class="line">| ==, !=, &lt;, &gt;, &lt;=, &gt;=                  | 这些比较运算符可以被重载。                         |</span><br><span class="line">| &amp;&amp;, \|\|                              | 这些条件逻辑运算符不能被直接重载。                 |</span><br><span class="line">| +=, -=, *=, /=, %=                    | 这些赋值运算符不能被重载。                         |</span><br><span class="line">| =, ., ?:, -&gt;, new, is, sizeof, typeof | 这些运算符不能被重载。                             |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 自定义类型转换</span><br><span class="line"></span><br><span class="line">###### 自定义隐式类型转换</span><br><span class="line"></span><br><span class="line">​	implicit 关键字用于声明隐式的用户定义类型转换运算符。</span><br><span class="line"></span><br><span class="line">​	如果可以确保转换过程不会造成数据丢失，则可使用该关键字在用户定义类型和其他类型之间进行隐式转换。隐式转换可以通过消除不必要的类型转换来提高源代码的可读性。 但是，因为隐式转换不需要程序员将一种类型显式强制转换为另一种类型，所以使用隐式转换时必须格外小心，以免出现意外结果。</span><br><span class="line"></span><br><span class="line">```c#</span><br><span class="line">using System;</span><br><span class="line">namespace ConsoleApp</span><br><span class="line">&#123; </span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Person p = new(&quot;张三&quot;);</span><br><span class="line">            string str1 = p;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(str1);//输出张三</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //Person类中此时只有一个属性Name，可以无损的转换成为string，因此可以使用自定义隐式类型转换进行转换</span><br><span class="line">    class Person</span><br><span class="line">    &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125;//姓名</span><br><span class="line"></span><br><span class="line">        public Person(string name)</span><br><span class="line">        &#123;</span><br><span class="line">            Name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static implicit operator string(Person p)</span><br><span class="line">        &#123;</span><br><span class="line">            return p.Name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h6 id="自定义显示类型转换"><a href="#自定义显示类型转换" class="headerlink" title="自定义显示类型转换"></a>自定义显示类型转换</h6><p>当类型转换时会（可能）发生数据丢失，此时需要定义显式类型转换而不是隐式转换</p>
<p>定义语法与隐式类似，只是关键字由<code>implicit</code>换成了<code>explicit</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Person p = <span class="keyword">new</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            <span class="built_in">string</span> str1 = (<span class="built_in">string</span>)p;</span><br><span class="line">            <span class="built_in">int</span> id = (<span class="built_in">int</span>)p;</span><br><span class="line">            Console.WriteLine(str1);<span class="comment">//输出张三</span></span><br><span class="line">            Console.WriteLine(id);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Person类中此时有两个属性：Name、Id</span></span><br><span class="line">    <span class="comment">// 不可以无损的转换到int或string，因此需要显式类型转换</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//姓名</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> uid &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;<span class="comment">//序列号</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            id++;</span><br><span class="line">            Name = name;</span><br><span class="line">            uid = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">string</span>(<span class="params">Person p</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> p.Name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span>(<span class="params">Person p</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> p.uid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="反向隐式类型转换"><a href="#反向隐式类型转换" class="headerlink" title="反向隐式类型转换"></a>反向隐式类型转换</h6><p>整个过程也可以反过来，用一个string类型的变量隐式的转换成Person类型的对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> str = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">            Person p = str;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(p.uid);</span><br><span class="line">            Console.WriteLine(p.Name);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义的反向隐式类型转换</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//姓名</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> uid &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;<span class="comment">//序列号</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            id++;</span><br><span class="line">            Name = name;</span><br><span class="line">            uid = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="反向显式类型转换"><a href="#反向显式类型转换" class="headerlink" title="反向显式类型转换"></a>反向显式类型转换</h6><p>既然可以反向隐式类型转换，那么就可以反向的显式类型转换。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> str = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">            Person p = (Person)str;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(p.uid);</span><br><span class="line">            Console.WriteLine(p.Name);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义的反向隐式类型转换</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//姓名</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> uid &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;<span class="comment">//序列号</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            id++;</span><br><span class="line">            Name = name;</span><br><span class="line">            uid = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h6 id="自定义类型转换的注意事项"><a href="#自定义类型转换的注意事项" class="headerlink" title="自定义类型转换的注意事项"></a>自定义类型转换的注意事项</h6><ul>
<li>一般情况下，隐式转换运算符应当从不引发异常并且从不丢失信息，以便可以在程序员不知晓的情况下安全使用它们。 如果转换运算符不能满足那些条件，则应将其标记为 explicit（显示类型转换）。</li>
<li>如果定义了隐式类型转换，则使用显式类型转换的语法也可以通过编译。</li>
</ul>
<h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><p>operator 关键字用于在类或结构声明中声明运算符。运算符声明可以采用下列四种形式之一：</p>
<ul>
<li>public static result-type operator unary-operator ( op-type operand )</li>
<li>public static result-type operator binary-operator ( op-type operand, op-type2 operand2 )</li>
<li>public static implicit operator conv-type-out ( conv-type-in operand )</li>
<li>public static explicit operator conv-type-out ( conv-type-in operand )</li>
</ul>
<p> 参数说明：</p>
<p>　　result-type：运算符的结果类型。<br>　　unary-operator：下列运算符之一：+ - ! ~ ++ — true false<br>　　op-type：第一个（或唯一一个）参数的类型。<br>　　operand：第一个（或唯一一个）参数的名称。<br>　　binary-operator：其中一个：+ - * &#x2F; % &amp; | ^ &lt;&lt; &gt;&gt; &#x3D;&#x3D; !&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D;<br>　　op-type2：第二个参数的类型。<br>　　operand2：第二个参数的名称。<br>　　conv-type-out：类型转换运算符的目标类型。<br>　　conv-type-in：类型转换运算符的输入类型。</p>
<p>注意</p>
<ul>
<li>运算符重载的声明方式：operator 关键字告诉编译器，它实际上是一个运算符重载，后面是相关运算符的符号。</li>
<li>运算符只能采用值参数，不能采用ref或out参数。可参考注意事项一实例。</li>
<li>前两种形式声明了用户定义的重载内置运算符的运算符。op-type 和 op-type2 中<strong>至少有一个必须是封闭类型</strong>（即运算符所属的类型，或理解为自定义的类型）。例如，这将防止重定义整数加法运算符。可参考注意事项二实例。</li>
<li>后两种形式声明了转换运算符。conv-type-in 和 conv-type-out 中正好有一个必须是封闭类型（即转换运算符只能从它的封闭类型转换为其他某个类型，或从其他某个类型转换为它的封闭类型）。</li>
<li>对于二元运算符，第一个参数是放在运算符左边的值，一般命名为lhs；第二个参数是放在运算符右边的值，一般命名为rhs。</li>
<li>C#要求所有的运算符重载都声明为<strong>public</strong>和<strong>static</strong>，必须是类的静态方法，这表示<strong>它们与它们的类或结构相关联，而不是与实例相关联</strong>。</li>
</ul>
<h5 id="样例-18"><a href="#样例-18" class="headerlink" title="样例"></a>样例</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Number n = <span class="keyword">new</span>(<span class="number">-1</span>);</span><br><span class="line">            Console.WriteLine(n);<span class="comment">// -1</span></span><br><span class="line">            Number n2 = + n;<span class="comment">//</span></span><br><span class="line">            Console.WriteLine(n2);<span class="comment">// 1</span></span><br><span class="line">            n = -n2;</span><br><span class="line">            Console.WriteLine(n);<span class="comment">// -1</span></span><br><span class="line">            n++;</span><br><span class="line">            Console.WriteLine(n);<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义的反向隐式类型转换</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Number</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Number</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Value = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">string</span>(<span class="params">Number n</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> n.Value.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重载-符号 使得值强制取反</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Number <span class="keyword">operator</span> -(Number n)</span><br><span class="line">        &#123;</span><br><span class="line">            n.Value = n.Value * <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重载-符号 使得值强制为正数</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Number <span class="keyword">operator</span> +(Number n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n.Value &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                positive(n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 重载++</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Number <span class="keyword">operator</span> ++ (Number n)</span><br><span class="line">        &#123;</span><br><span class="line">            n.Value++;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助函数</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Number <span class="title">positive</span>(<span class="params">Number n</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            n.Value = n.Value * <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="动态多态性"><a href="#动态多态性" class="headerlink" title="动态多态性"></a>动态多态性</h3><p>C# 允许使用关键字 <strong>abstract</strong> 创建抽象类，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。<strong>抽象类</strong>包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。</p>
<p>请注意，下面是有关抽象类的一些规则：</p>
<ul>
<li>您不能创建一个抽象类的实例。</li>
<li>您不能在一个抽象类外部声明一个抽象方法。</li>
<li>通过在类定义前面放置关键字 <strong>sealed</strong>，可以将类声明为<strong>密封类</strong>。当一个类被声明为 <strong>sealed</strong> 时，它不能被继承。抽象类不能被声明为 sealed。</li>
</ul>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>​	抽象类指的是函数成员没有被完全实现的类。（有至少一个函数成员没被实现）</p>
<p>​	反过来，如果一个类的成员全部都实现了，就是具体类。</p>
<p>​	在抽象类中，没被实现的成员一定要用<code>abstract</code>关键字修饰，而且这个成员不能是<code>private</code>类型。因为私有类型不允许被重写，因此将无法将抽象类转变为具体类。</p>
<p>​	换句话说，一旦一个成员被<code>abstract</code>修饰，就就不能实现。</p>
<p>​	同时，抽象类也必须要用<code>abstract</code>进行修饰。</p>
<p>​	抽象类不允许被实例化，只能被继承或声明变量引用一个子类实例。</p>
<p>​	当抽象类作为变量引用子类实例时，通过抽象类调用的是子类的方法而不是父类的方法。</p>
<p>​	当子类实现父类的抽象方法时，子类成员需要加上<code>override</code>关键字</p>
<p>​	抽象方法在某些语言中也被称为纯虚方法。</p>
<p>​	当一个类没有任何实现的方法，全是抽象成员，在Java、C#中本质上就已经是接口了</p>
<h5 id="样例-19"><a href="#样例-19" class="headerlink" title="样例"></a>样例</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//A a = new A();//一旦一个类是抽象类了，则这个类就不能实例化成对象</span></span><br><span class="line">            A c = <span class="keyword">new</span> C();<span class="comment">//但可以作为变量接收子类的实例.	当抽象类作为变量引用子类实例时，通过抽象类调用的是子类的方法而不是父类的方法。</span></span><br><span class="line">            B b = <span class="keyword">new</span> B();</span><br><span class="line">            c.ShowClassName();   <span class="comment">//this is C</span></span><br><span class="line">            b.ShowClassName();   <span class="comment">//this is B</span></span><br><span class="line">            c.Show();            <span class="comment">//A 的 show被执行//不影响父类中已有的类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">A</span><span class="comment">//同时类名也需要加上abstract关键字</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowClassName</span>()</span>;<span class="comment">//当一个类需要多次被子类修改，且在父类中没有实现的必要，就可以使用抽象。关键字abstract</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;A 的 show被执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">B</span> : <span class="title">A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ShowClassName</span>()<span class="comment">//当子类实现父类的抽象方法时，子类成员需要加上`override`关键字。</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;this is B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;B 的 show被执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">C</span> : <span class="title">A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ShowClassName</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;this is C&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;C 的 show被执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h3><ul>
<li><p>一个纯抽象类的本质就是接口。接口是由抽象类进化而来。</p>
<ul>
<li>进化过程：<ul>
<li><img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/image-20230312203400886.png" alt="image-20230312203400886"></li>
<li>接口中的抽象方法不需要<code>abstract</code>修饰</li>
<li>抽象类中的方法不允许是<code>private</code>，但接口中的<strong>抽象方法</strong>必须是<code>public</code>（不允许有修饰符，强制public）</li>
<li>注意：接口的默认访问修饰符是internal，接口的成员才是public！！！！！</li>
</ul>
</li>
</ul>
</li>
<li><p>接口的产生：自底向上（重构），自顶向下（设计）</p>
<ul>
<li><p>自顶向下一般适用于非常了解技术、业务逻辑的人。</p>
</li>
<li><p>自底向下一般在重构代码的时候使用。</p>
</li>
</ul>
</li>
<li><p>与抽象类一样 也不允许实例化，但一样允许作为接口接收子类的实例。当通过接口调用子类的成员时，会调用最先实现这个成员的类所在的数据  </p>
</li>
<li><p>定义与抽象类类似，类的关键字由<code>abstract</code>关键字替换为<code>interface</code>。</p>
</li>
<li><p>接口要求内部所有成员的访问权限均是public。</p>
<ul>
<li>声明接口类时默认就是public</li>
<li>里面的成员也不需要额外的声明，只需要返回值、方法名、参数列表这些基本元素即可。</li>
</ul>
</li>
<li><p>当一个类没有实现接口的所有方法时，此时这个类就转换为了抽象类，要遵循抽象类的约束。类前面加上abstract</p>
</li>
<li><p>接口的命名：不成文的约定：以i开头，加上一个名词。</p>
</li>
<li><p>接口即契约：甲方“我不会多要”；乙方“我不会少给”。</p>
<ul>
<li>乙方不会少给：硬性规定，即一个类只要实现了接口，就必需实现接口里面的所有方法，一旦未全部实现，类就还只是个抽象类，就不能实例化</li>
<li>甲方不会多要：软性规定，是个设计问题</li>
</ul>
</li>
<li><p>接口还保证调用者去调用这些功能的时候都是实现好的，只需要关注功能，不需要关注功能是谁提供的。</p>
</li>
<li><p>在代码中 只要有可以替换的地方，就一定会有接口的存在。</p>
</li>
<li><p>接口就是为了解耦而生。</p>
</li>
<li><p>松耦合它最大的好处就是可以让这个功能的提供方变得可替换，从而降低紧耦合的时候功能的提供方不能被替换所带来的这个高风险和高成本</p>
</li>
<li><p>使用接口替换调实例变量时，只能调用接口内约定的方法。</p>
</li>
</ul>
<h4 id="接口隔离：显式接口实现"><a href="#接口隔离：显式接口实现" class="headerlink" title="接口隔离：显式接口实现"></a>接口隔离：显式接口实现</h4><p>使用接口替换调实例变量时，只能调用接口内约定的方法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Remoting.Messaging;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Controls;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            IA a = <span class="keyword">new</span> A();</span><br><span class="line">            IB b = <span class="keyword">new</span> A();</span><br><span class="line">            a.A();<span class="comment">//由于接口是显式实现，因此只能调用接口中约定的方法</span></span><br><span class="line">            <span class="comment">//a.B();</span></span><br><span class="line">            b.B();<span class="comment">//b也一样</span></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title">IA</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">A</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title">IB</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">B</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">A</span> : <span class="title">IA</span>, <span class="title">IB</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span> IA.A()<span class="comment">//接口的显式实现</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;A方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> IB.B()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;B方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个接口，</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICustomer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SomeMethod</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//隐式实现接口,代码大致如下</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer1</span> : <span class="title">ICustomer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显式实现接口，代码大致如下</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer2</span> : <span class="title">ICustomer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span> ICustomer.SomeMethod()<span class="comment">//</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="样例-20"><a href="#样例-20" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            A a = <span class="keyword">new</span> C();</span><br><span class="line">            a.ShowClassName();           <span class="comment">//this is B    //当通过接口调用子类的成员时，会调用最先实现这个成员的类所在的数据</span></span><br><span class="line">            a.test();                    <span class="comment">//C test       </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title">A</span><span class="comment">//声明接口只需要interface 接口名  即可。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ShowClassName</span>()</span>;<span class="comment">//内部的成员只需要返回值 方法名 参数列表，不需要其他的声明标识符</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">test</span>()</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">B</span> : <span class="title">A</span><span class="comment">//当一个类没有实现接口的所有方法时，此时这个类就转换为了抽象类，要遵循抽象类的约束。类前面加上abstract</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowClassName</span>()<span class="comment">//当实现接口的时候，没必要加上override，直接按照正常的格式书写方法即可。</span></span></span><br><span class="line">        &#123;                                                                      </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;this is B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span>()</span>;<span class="comment">//同时作为抽象方法抛给别的类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">C</span> : <span class="title">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowClassName</span>()<span class="comment">//当实现接口的时候，没必要加上override，直接按照正常的格式书写方法即可。</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;this is B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">test</span>()<span class="comment">//实现的时候也需要按照抽象类的约束 加上override。</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;C test&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="样例：实现对数组的求平均和求和。"><a href="#样例：实现对数组的求平均和求和。" class="headerlink" title="样例：实现对数组的求平均和求和。"></a>样例：实现对数组的求平均和求和。</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Controls;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要求：对下面两个序列求平均和求和。</span></span><br><span class="line">            <span class="built_in">int</span>[] arr1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">            ArrayList arr2 = <span class="keyword">new</span> ArrayList &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;OldTools arr1 和：<span class="subst">&#123;OldTools.Sum(arr1)&#125;</span>\t平均：<span class="subst">&#123;OldTools.Avg(arr1)&#125;</span>&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;OldTools arr2 和：<span class="subst">&#123;OldTools.Sum(arr2)&#125;</span>\t平均：<span class="subst">&#123;OldTools.Avg(arr2)&#125;</span>&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;NewTools arr1 和：<span class="subst">&#123;NewTools.Sum(arr1)&#125;</span>\t平均：<span class="subst">&#123;NewTools.Avg(arr1)&#125;</span>&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;NewTools arr2 和：<span class="subst">&#123;NewTools.Sum(arr2)&#125;</span>\t平均：<span class="subst">&#123;NewTools.Avg(arr2)&#125;</span>&quot;</span>);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传统的方法：</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">OldTools</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//求和</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Sum</span>(<span class="params"><span class="built_in">int</span>[] arr </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> arr)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求平均</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Avg</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">double</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> arr)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += item;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum / count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求和</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Sum</span>(<span class="params">ArrayList arr</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> arr)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += (<span class="built_in">int</span>)item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求平均</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Avg</span>(<span class="params">ArrayList arr</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">double</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> arr)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += (<span class="built_in">int</span>)item;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum / count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">NewTools</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//可以发现，主体部分都是foreach，foreach的本质是迭代，也就是实现了IEnumerable接口的类型都可以被迭代。</span></span><br><span class="line">        <span class="comment">//因此 可以做一下修改，使用接口来接受子类的实例，可以大幅的降低代码重复</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//求和</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Sum</span>(<span class="params">IEnumerable arr</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> arr)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += (<span class="built_in">int</span>)item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求平均</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Avg</span>(<span class="params">IEnumerable arr</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">double</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> arr)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += (<span class="built_in">int</span>)item;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum / count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="样例：解决紧耦合-引入接口"><a href="#样例：解决紧耦合-引入接口" class="headerlink" title="样例：解决紧耦合:引入接口"></a>样例：解决紧耦合:引入接口</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Remoting.Messaging;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Controls;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            NokiaPhone phone1 = <span class="keyword">new</span> NokiaPhone(); </span><br><span class="line">            PhoneUser user = <span class="keyword">new</span> PhoneUser(phone1);<span class="comment">//给用户一个诺基亚的手机</span></span><br><span class="line">            user.UserPhone();<span class="comment">//用户使用手机</span></span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\n\n用户更换手机了\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            EricssonPhone phone2 = <span class="keyword">new</span> EricssonPhone();</span><br><span class="line">            user.phone = phone2;</span><br><span class="line">            user.UserPhone();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">PhoneUser</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> IPhone phone &#123; <span class="keyword">set</span>; <span class="keyword">get</span>; &#125;<span class="comment">//不再具体是某一款具体类型</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PhoneUser</span>(<span class="params">IPhone phone</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.phone = phone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UserPhone</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            phone.Dail();</span><br><span class="line">            phone.Send();</span><br><span class="line">            phone.Receive();</span><br><span class="line">            phone.Pickup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title">IPhone</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Dail</span>()</span>;<span class="comment">//拨号</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Pickup</span>()</span>;<span class="comment">//接电话</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Send</span>()</span>;<span class="comment">//发短信</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Receive</span>()</span>;<span class="comment">//收短信</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">NokiaPhone</span> : <span class="title">IPhone</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dail</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;使用诺基亚打电话&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Pickup</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;使用诺基亚接电话&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Receive</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;使用诺基亚发短息&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;使用诺基亚收短信&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">EricssonPhone</span> : <span class="title">IPhone</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dail</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;使用爱立信打电话&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Pickup</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;使用爱立信接电话&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Receive</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;使用爱立信发短息&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;使用爱立信收短信&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="接口和抽象类的概述"><a href="#接口和抽象类的概述" class="headerlink" title="接口和抽象类的概述"></a>接口和抽象类的概述</h3><ul>
<li><p>接口和抽象类都是软件工程的产物</p>
</li>
<li><p>具体类 -&gt; 抽象类 -&gt; 接口：越来越抽象，内部实现的东西越来越少</p>
<ul>
<li>对于方法成员，方法体就是它的实现</li>
<li>对于数据成员，字段就是实现</li>
</ul>
</li>
<li><p>抽象类是未完全实现逻辑的类(可以有字段和public成员，它们代表了“具体逻辑”)</p>
<ul>
<li>接口是完全未实现。</li>
</ul>
</li>
<li><p>抽象类为复用而生:专门作为基类来使用，也具有解耦功龍</p>
</li>
<li><p>封装确定的，开放不确定的，推迟到合适的子类中去实现。</p>
<ul>
<li>就是开闭原则</li>
</ul>
</li>
<li><p>接口是完全未实现逻辑的“类”(“纯虚类”:只有函数成员:成员全部public)</p>
</li>
<li><p>接口为解耦而生:“高内聚，低耦合”，方便单元测试</p>
</li>
<li><p>接口是一个“协约”，早已为工业生产所熟知(有分工必有协作，有协作必有协约)</p>
</li>
<li><p>它们都不能实例化。只能用来声明变量、引用具体类(concrete class)的实例</p>
<ul>
<li>因为有完成的成员</li>
</ul>
</li>
<li><p>依赖越直接 耦合就越紧。</p>
</li>
<li><p>需要注意：当使用接口接口实现两个类的解耦合的时候，实际上是把紧耦合的关系转嫁给了接口也就是说，当类实现一个接口的时候，类与接口之间的关系也是“紧耦合”的。</p>
</li>
</ul>
<h3 id="依赖反转（倒置）"><a href="#依赖反转（倒置）" class="headerlink" title="依赖反转（倒置）"></a>依赖反转（倒置）</h3><p>单元测试：依赖反转（依赖倒置）在开发中的直接应用和直接受益者。</p>
<p>自顶向下 逐步求精。</p>
<p><img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/image-20230313104007404.png" alt="image-20230313104007404"></p>
<p>可以看到，图片中右侧有效的改善了依赖。</p>
<p>所谓的依赖倒置，就是由原本的司机直接指向类，变成类指向一个接口，然后再用另一个类去调用这个接口的方法（IVehicle）。</p>
<p>再次进化：</p>
<p><img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/image-20230313104436372.png" alt="image-20230313104436372"></p>
<p>DriverBase派生出了两个子类：Driver、AiDriver。当需要这两个类调用Car、Truck类的时候，只需要通过IVehicle字段调用自己的run方法即可。</p>
<p>这样以来，Driver可以驱动Car和Truck，AiDriver也可以驱动这两个类。</p>
<h4 id="单元测试（使用依赖倒置）（需完善）"><a href="#单元测试（使用依赖倒置）（需完善）" class="headerlink" title="单元测试（使用依赖倒置）（需完善）"></a>单元测试（使用依赖倒置）（需完善）</h4><p>对DeskFan进行测试，如果直接修改Power电压 可能会造成其他使用这个Power的类损毁（出bug）。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Remoting.Messaging;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Controls;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            DeskFan fan = <span class="keyword">new</span> DeskFan(<span class="keyword">new</span> PowerSupply());<span class="comment">//创建一个电扇，并给电扇配一个电源</span></span><br><span class="line">            Console.WriteLine(fan.Work()); <span class="comment">//输出风扇的工作状态</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">PowerSupply</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetPower</span>()<span class="comment">//想要测试的话 只能修改程序里面的值。当程序创建完成后 不可以轻易修改。</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;<span class="comment">//标准电源 输出100</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">DeskFan</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> PowerSupply powerSupply;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DeskFan</span>(<span class="params">PowerSupply powerSupply</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.powerSupply = powerSupply;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Work</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> power = powerSupply.GetPower();</span><br><span class="line">            <span class="keyword">if</span>(power &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;不工作&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(power &lt; <span class="number">100</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Slow&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(power &lt; <span class="number">200</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Fast&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;电压过高&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行自底向上的解耦重构并进行单元测试。</p>
<p>一般测试的时候，新建一个测试项目而不是在原先的项目上测试。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





<p>显示类型实现</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>反射并不是C#的功能，而是.Net框架的功能。换句话说就是，只要有.Net框架的地方，都可以实现反射。</p>
<p>反射：以不变应万变</p>
<h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><h3 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h3><p>对于用父类对象调用子类方法的时候，会从父类开始，向子类搜索第一个能被调用的方法。如果从父类到最终子类的途中存在已经实现了的方法，就直接调用这个方法。如果强制调用子类方法，则需要手动将父类转换成对应子类后调用。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            A a = <span class="keyword">new</span> C();</span><br><span class="line">            a.Say();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Say</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">B</span> : <span class="title">A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Say</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">C</span> : <span class="title">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Say</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="c-设计原则"><a href="#c-设计原则" class="headerlink" title="c#设计原则"></a>c#设计原则</h1><ul>
<li>单一职责原则（Single Responsibility Principle）；</li>
<li>开闭原则（Open Closed Principle）；</li>
<li>里氏替换原则（Liskov Substitution Principle）；</li>
<li>迪米特法则（Law of Demeter），又叫“最少知道法则”；</li>
<li>接口隔离原则（Interface Segregation Principle）；</li>
<li>依赖倒置原则（Dependence Inversion Principle）。</li>
</ul>
<p>6 个原则结合使用的好处：建立稳定、灵活、健壮的设计。</p>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p><strong>单一职责原则的定义是：应该有且仅有一个原因引起类的变更。</strong></p>
<p>举个例子。</p>
<p>我们以打电话为例，电话通话的时候有 4 个过程发生：拨号、通话、回应、挂机。那我们写一个接口，类图如下：</p>
<p><img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/image-20230307072642501.png" alt="image-20230307072642501"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//接电话</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dial</span>(<span class="params"><span class="built_in">string</span> phoneNumber</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通话</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chat</span>(<span class="params"><span class="built_in">object</span> o</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//挂电话</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hangup</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	IPhone这个接口包含了两个职责：协议管理和数据传送。dial 和 hangup 这两个方法实现的是协议管理，分别负责拨号接通和挂机，chat 方法实现的是数据传送。不管是协议接通的变化还是输出传送的变化，都会引起这个接口的变化。所以，IPhone这个接口并不符合单一职责原则。若要让IPhone满足单一职责原则，我们就要对其进行拆分，拆分后的类图如下：</p>
<p><img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/image-20230307073137336.png" alt="image-20230307073137336"></p>
<p>​	这样设计就完美了，一个类实现了两个接口，把两个职责融合在一个类中。你会觉得这个Phone有两个原因引起变化了啊，是的，但是别忘了我们是面向接口编程，我们对外公布的是接口而不是实现类。</p>
<p>​	另外，单一职责原则不仅适用于接口和类，也适用于方法。<strong>一个方法尽可能只做一件事</strong>，比如一个修改用户密码的方法，不要把这个方法放到“修改用户信息”方法中。</p>
<h3 id="单一职责的好处"><a href="#单一职责的好处" class="headerlink" title="单一职责的好处"></a>单一职责的好处</h3><ul>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li>
<li>可读性高，复杂性降低，可读性自然就提高了；</li>
<li>可维护性提高，可读性提高了，那自然更容易维护了；</li>
<li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li>
</ul>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>​	在面向对象的语言中，继承是必不可少的、非常优秀的语言机制，它有如下优点：</p>
<ol>
<li>代码共享，减少创建类的工作量，每个子类都拥有父类的属性和方法；</li>
<li>提高代码的重用性；</li>
<li>子类可以形似父类，但又异于父类；</li>
<li>提高代码的可扩展性；</li>
<li>提高产品或项目的开放性。</li>
</ol>
<p>有优点就必然存在缺点：</p>
<ol>
<li>继承是侵入性的。只要继承，就必须拥有父类的属性和方法。</li>
<li>降低代码的灵活性。子类会多一些父类的约束。</li>
<li>增强了耦合性。当父类的常量、变量、方法被修改时，需要考虑子类的修改。</li>
</ol>
<p>​	为了让“利”的因素发挥最大的作用，同时减少“弊”带来的麻烦，引入了里氏替换原则（LSP）。</p>
<p>历史替换原则最正宗的定义是：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代替o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。</p>
<p>通俗点讲，就是只要父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常。</p>
<p>里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义。</p>
<ol>
<li><p>子类必须完全实现父类的方法。</p>
<ul>
<li><p>我们在做系统设计的时候，经常会定义一个接口或抽象类，然后编码实现，调用类则直接传入接口或抽象类，其实这里就已经使用了里氏替换原则。我们以打CS举例，来描述一下里面用到的枪。类图如下：</p>
</li>
<li><p><img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/image-20230307073608061.png" alt="image-20230307073608061"></p>
</li>
<li><p>枪的主要职责是射击，如何射击在各个具体的子类中实现，在士兵类Soldier中定义了一个方法 killEnemy，使用枪来kill敌人，具体用什么枪，调用的时候才知道。</p>
</li>
<li><p>**注意：**在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。</p>
</li>
<li><p>实现代码：</p>
<ul>
<li><pre><code class="language-c#">using System;
using System.Windows.Forms;

namespace ConsoleApp
{
    //internal class Program
    //{
    //    static void Main(string[] args)
    //    {
    //        A a = new C();
    //        a.ShowClassName();           //this is B    //当通过接口调用子类的成员时，会调用最先实现这个成员的类所在的数据
    //        a.test();                    //C test       


    //        Console.ReadKey();
    //    }
    //}

    //枪的抽象类
    public abstract class AbstractGun
    {
        //射击方法
        public abstract void shoot();
    }

    //手枪、步枪、机枪的实现代码
    //手枪：
    public class HandGun : AbstractGun
    {
        //射击方法
        public override void shoot()
        {
            Console.WriteLine(&quot;手枪射击了&quot;);
        }
    }
    //步枪
    public class Rifle : AbstractGun
    {
        public override void shoot()
        {
            Console.WriteLine(&quot;步枪射击了&quot;);
        }
    }
    //机枪
    public class MachineGun : AbstractGun
    {
        public override void shoot()
        {
            Console.WriteLine(&quot;机枪射击了&quot;);
        }
    }


    //士兵的源码
    public class Soldier
    {
        private AbstractGun gun;

        public Soldier(AbstractGun gun)
        {
            this.gun = gun;
        }

        //士兵开始射击
        public void killEnemy()
        {
            Console.WriteLine(&quot;士兵开始杀戮&quot;);
            this.gun.shoot();//开枪
        }
    }



    //客户端源码
    public class Client
    {
        public static void Main(string[] args)
        {
            //创建一个士兵的对象，并给他一把手枪
            Soldier soldier1 =  new Soldier(new HandGun());
            
            //士兵射击
            soldier1.killEnemy();

            //再次创建一个士兵，这次给他一把机枪
            Soldier soldier2 = new Soldier(new MachineGun());
            soldier2.killEnemy();//士兵2也射击

            //执行结果
            //士兵开始杀戮
            //手枪射击了
            //士兵开始杀戮
            //机枪射击了

            //可以看到，里氏替换原则的特性：父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常。

            Console.ReadKey();
        }
    }
}
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 孩子类可以有自己的个性。</span><br><span class="line"></span><br><span class="line">   1. 孩子类当然可以有自己的属性和方法了，也正因如此，在子类出现的地方，父类未必就可以代替。</span><br><span class="line"></span><br><span class="line">   2. 还是以上面的关于枪支的例子为例，步枪有 AK47、SKS狙击步枪等型号，把这两个型号的枪引入后的Rifle的子类图如下：</span><br><span class="line"></span><br><span class="line">   3. ![image-20230307081242661](./Image/C#学习笔记_基础教程.assets/image-20230307081242661.png)</span><br><span class="line"></span><br><span class="line">   4. SKS狙击步枪可以配一个8倍镜进行远程瞄准，相对于父类步枪，这就是SKS的个性。源码如下：</span><br><span class="line"></span><br><span class="line">   5. ```c#</span><br><span class="line">      using System;</span><br><span class="line">      using System.Windows.Forms;</span><br><span class="line">      </span><br><span class="line">      namespace ConsoleApp</span><br><span class="line">      &#123;</span><br><span class="line">          //internal class Program</span><br><span class="line">          //&#123;</span><br><span class="line">          //    static void Main(string[] args)</span><br><span class="line">          //    &#123;</span><br><span class="line">          //        A a = new C();</span><br><span class="line">          //        a.ShowClassName();           //this is B    //当通过接口调用子类的成员时，会调用最先实现这个成员的类所在的数据</span><br><span class="line">          //        a.test();                    //C test       </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">          //        Console.ReadKey();</span><br><span class="line">          //    &#125;</span><br><span class="line">          //&#125;</span><br><span class="line">      </span><br><span class="line">          //枪的抽象类</span><br><span class="line">          public abstract class AbstractGun</span><br><span class="line">          &#123;</span><br><span class="line">              //射击方法</span><br><span class="line">              public abstract void shoot();</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          //手枪、步枪、机枪的实现代码</span><br><span class="line">          //手枪：</span><br><span class="line">          public class HandGun : AbstractGun</span><br><span class="line">          &#123;</span><br><span class="line">              //射击方法</span><br><span class="line">              public override void shoot()</span><br><span class="line">              &#123;</span><br><span class="line">                  Console.WriteLine(&quot;手枪射击了&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          //步枪</span><br><span class="line">          public class Rifle : AbstractGun</span><br><span class="line">          &#123;</span><br><span class="line">              public override void shoot()</span><br><span class="line">              &#123;</span><br><span class="line">                  Console.WriteLine(&quot;步枪射击了&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          //机枪</span><br><span class="line">          public class MachineGun : AbstractGun</span><br><span class="line">          &#123;</span><br><span class="line">              public override void shoot()</span><br><span class="line">              &#123;</span><br><span class="line">                  Console.WriteLine(&quot;机枪射击了&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">          //士兵的源码</span><br><span class="line">          public class Soldier</span><br><span class="line">          &#123;</span><br><span class="line">              private AbstractGun gun;</span><br><span class="line">      </span><br><span class="line">              public Soldier(AbstractGun gun)</span><br><span class="line">              &#123;</span><br><span class="line">                  this.gun = gun;</span><br><span class="line">              &#125;</span><br><span class="line">      </span><br><span class="line">              //士兵开始射击</span><br><span class="line">              public void killEnemy()</span><br><span class="line">              &#123;</span><br><span class="line">                  Console.WriteLine(&quot;士兵开始杀戮&quot;);</span><br><span class="line">                  this.gun.shoot();//开枪</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">          //客户端源码</span><br><span class="line">          public class Client</span><br><span class="line">          &#123;</span><br><span class="line">              public static void Main(string[] args)</span><br><span class="line">              &#123;</span><br><span class="line">                  //创建一个狙击手的对象，并给他一把狙击枪</span><br><span class="line">                  Spinner spinner = new Spinner();</span><br><span class="line">                  spinner.setSks(new SKS());</span><br><span class="line">                  spinner.killEnemy();</span><br><span class="line">                  //输出结果</span><br><span class="line">                  //使用8倍镜进行瞄准</span><br><span class="line">                  //SKS射击</span><br><span class="line">      </span><br><span class="line">                  Console.ReadKey();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          //sks</span><br><span class="line">          public class SKS : Rifle</span><br><span class="line">          &#123;</span><br><span class="line">              //配一个8倍镜</span><br><span class="line">              public void zoomOut()</span><br><span class="line">              &#123;</span><br><span class="line">                  Console.WriteLine(&quot;使用8倍镜进行瞄准&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">              public void shoot()</span><br><span class="line">              &#123;</span><br><span class="line">                  Console.WriteLine(&quot;SKS射击&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          //狙击手</span><br><span class="line">          public class Spinner</span><br><span class="line">          &#123;</span><br><span class="line">              private SKS sks;</span><br><span class="line">              </span><br><span class="line">              public void setSks(SKS sks)</span><br><span class="line">              &#123;</span><br><span class="line">                  this.sks = sks;</span><br><span class="line">              &#125;</span><br><span class="line">      </span><br><span class="line">              public void killEnemy()</span><br><span class="line">              &#123;</span><br><span class="line">                  //先瞄准后开枪</span><br><span class="line">                  sks.zoomOut();</span><br><span class="line">                  sks.shoot();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>覆盖或实现父类的方法时，输入参数可以被放大。</p>
<ul>
<li>即方法的重载</li>
</ul>
</li>
<li><p>覆盖或实现父类的方法时，输出结果可以被缩小。</p>
<ul>
<li>父类的一个方法的返回值是类型T，子类的相同方法（重载或重写）的返回值为类型S，那么里氏替换原则就要求S必须小于等于T。为什么呢？因为重写父类方法，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这时重写父类方法的要求。</li>
</ul>
</li>
</ol>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><ul>
<li>模块间的依赖通过抽象发生，实现类之间不直接发生依赖关系，其依赖关系是通过接口或抽象类产生的；</li>
<li>接口或抽象类不依赖于实现类；</li>
<li>实现类依赖接口或抽象类。</li>
</ul>
<p>说白了，就是“面向接口编程”。</p>
<p><strong>依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。</strong></p>
<p>以汽车和司机举例，画出类图：</p>
<p><img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/image-20230307083434548.png" alt="image-20230307083434548"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//奔驰车</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Benz</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;奔驰车开始运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//司机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Driver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">driver</span>(<span class="params">Benz benz</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        benz.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Driver driver = <span class="keyword">new</span> Driver();</span><br><span class="line">        driver.driver(<span class="keyword">new</span> Benz());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	由于司机现在只有开奔驰的方法，所以他是开不了宝马的。一个拿有C驾照的司机能开奔驰，不能开宝马？太不合理了。所以，这就暴露出上面的设计问题了。我们对上面的功能重新设计，首先新建两个接口。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//汽车接口ICar：</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title">ICar</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//司机接口IDriver：</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title">IDriver</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">driver</span>(<span class="params">ICar car</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IDriver中，通过传入ICar接口实现了抽象之间的依赖关系。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//汽车实现类：奔驰和宝马。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Benz</span> : <span class="title">ICar</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;奔驰车开始运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BWM</span> : <span class="title">ICar</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;宝马车开始运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建司机实现类：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Driver</span> : <span class="title">IDriver</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span> IDriver.driver(ICar car)</span><br><span class="line">        &#123;</span><br><span class="line">            car.run();<span class="comment">//开车</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            IDriver driver = <span class="keyword">new</span> Driver();</span><br><span class="line">            ICar car = <span class="keyword">new</span> Benz();</span><br><span class="line">            driver.driver(car);<span class="comment">//司机开奔驰</span></span><br><span class="line">            car = <span class="keyword">new</span> BWM();</span><br><span class="line">            driver.driver(car);<span class="comment">//司机开宝马</span></span><br><span class="line">            <span class="comment">//如果还有别的车，直接new别的车就行</span></span><br><span class="line">            <span class="comment">//Client属于高层业务逻辑，它对低层模块的依赖都建立在抽象上，driver的表面类型是IDriver，benz的表面类型是ICar。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="依赖倒置原则的使用建议："><a href="#依赖倒置原则的使用建议：" class="headerlink" title="依赖倒置原则的使用建议："></a>依赖倒置原则的使用建议：</h3><ol>
<li>每个类尽量都有接口或抽象类，或者接口和抽象类两者都具备。</li>
<li>变量的表面类型尽量是接口或抽象类。</li>
<li>任何类都不应该从具体类派生。</li>
<li>尽量不要重写基类的方法。如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要重写。</li>
<li>结合里氏替换原则使用。</li>
</ol>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><h3 id="接口隔离原则的定义"><a href="#接口隔离原则的定义" class="headerlink" title="接口隔离原则的定义"></a>接口隔离原则的定义</h3><blockquote>
<p>Clients should not be forced to depend upon interfaces that they don’t use.<br>客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。</p>
</blockquote>
<blockquote>
<p>The dependency of one class to another one should depend on the smallest possible interface.<br>类间的依赖关系应建立在最小的接口上。</p>
</blockquote>
<p>也就是说: 接口尽量细化，接口中的方法尽量少。</p>
<h3 id="接口隔离原则和单一职责原则"><a href="#接口隔离原则和单一职责原则" class="headerlink" title="接口隔离原则和单一职责原则"></a>接口隔离原则和单一职责原则</h3><p>从功能上来看，接口隔离原则和单一职责原则都是为了提高类的内聚, 降低类之间的耦合, 体现了封装的思想。但二者还是有区别的。</p>
<p>（1）从原则约束来看: 接口隔离原则更关注的是接口依赖程度的隔离；而单一职责原则更加注重的是接口职责的划分。</p>
<p>（2）从接口的细化程度来看: 单一职责原则对接口的划分更加精细，而接口隔离原则注重的是相同功能的接口的隔离。接口隔离里面的最小接口有时可以是多个单一职责的公共接口。</p>
<p>（3）单一职责原则更加偏向对业务的约束: 接口隔离原则更加偏向设计架构的约束。这个应该好理解，职责是根据业务功能来划分的，所以单一原则更加偏向业务；而接口隔离更多是为了“高内聚”，偏向架构的设计。</p>
<p>​	接口隔离原则就是客户端不应该依赖它不需要的接口，或者说类间的依赖关系应该建立在最小的接口上。</p>
<p>​	以搜索美女为例，设计了如下的类图：</p>
<p><img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/image-20230307091119168.png" alt="image-20230307091119168"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//美女及其实现类：</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IPettyGirl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//高颜值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goodLooking</span>()</span>;</span><br><span class="line">    <span class="comment">//好身材</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">niceBody</span>()</span>;</span><br><span class="line">    <span class="comment">//有气质</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">greatTemperament</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PettyGril</span> : <span class="title">IPettyGirl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PettyGril</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//高颜值</span></span><br><span class="line">    <span class="keyword">void</span> IPettyGirl.goodLooking()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">this</span>.name&#125;</span> 颜值很高 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//好身材</span></span><br><span class="line">    <span class="keyword">void</span> IPettyGirl.niceBody()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">this</span>.name&#125;</span> 身材很好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有气质</span></span><br><span class="line">    <span class="keyword">void</span> IPettyGirl.greatTemperament()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">this</span>.name&#125;</span> 气质出众&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索程序及其子类源代码如下：</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractSearcher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> IPettyGirl gril;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractSearcher</span>(<span class="params">IPettyGirl gril</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gril = gril;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出美女信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title">Searcher</span> : <span class="title">AbstractSearcher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Searcher</span>(<span class="params">IPettyGirl girl</span>):<span class="title">base</span>(<span class="params">girl</span>)<span class="comment">//调用父类的构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">show</span>()<span class="comment">//实现抽象方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;美女信息如下：&quot;</span>);</span><br><span class="line">        <span class="keyword">base</span>.gril.goodLooking();</span><br><span class="line">        <span class="keyword">base</span>.gril.niceBody();</span><br><span class="line">        <span class="keyword">base</span>.gril.greatTemperament();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//场景调用类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IPettyGirl aa = <span class="keyword">new</span> PettyGril(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        AbstractSearcher searcher = <span class="keyword">new</span> Searcher(aa);</span><br><span class="line">        searcher.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment"> * 美女信息如下：</span></span><br><span class="line"><span class="comment">    aa 颜值很高</span></span><br><span class="line"><span class="comment">    aa 身材很好</span></span><br><span class="line"><span class="comment">    aa 气质出众 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>IPettyGirl接口是否做到了最优化？并没有。</p>
<p>每个人的审美观不一样，张三认为颜值高就是美女，即使身材和气质一般；李四认为身材好就行，不在乎颜值和气质；而王五则认为颜值和身材都是外在，只要有气质，那就是美女。这时，IPettyGirl接口就满足不了了，因为IPettyGirl的要求是颜值、身材、气质兼具才是美女。所以为了满足各种人的口味，我们需要重新设计接口的结构。把IPettyGirl拆分为3个接口，分别表示颜值高、身材好、气质佳。修改后的类图如下：</p>
<p><img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/image-20230310142839136.png" alt="image-20230310142839136"></p>
<h1 id="c-异常处理"><a href="#c-异常处理" class="headerlink" title="c#异常处理"></a>c#异常处理</h1><p>非中断（正常）模式下的调试</p>
<h2 id="输出调试信息"><a href="#输出调试信息" class="headerlink" title="输出调试信息"></a>输出调试信息</h2><ul>
<li>Debug.WriteLine()</li>
<li>Trace.WriteLine()</li>
</ul>
<p>这两个命令用法几乎相同，区别在于：第一个命令仅在调试模式下运行，而第二个命令还可用于发布程序。实际上Debug.Write甚至不能编译到可发布的程序中，在发布版本中，该命令会消失，可以减小文件体积。</p>
<p>这两个方法都包含在System.Diangnostics名称空间中。using static只能用于静态类，比如System.Console，因此该指令不能用在- Debug.WriteLine()、Trace.WriteLine()函数中。</p>
<p>​	异常是在程序执行期间出现的问题。C# 中的异常是对程序运行时出现的特殊情况的一种响应，比如尝试除以零。</p>
<p>​	异常提供了一种把程序控制权从某个部分转移到另一个部分的方式。C# 异常处理时建立在四个关键词之上的：<code>try</code>、<code>catch</code>、<code>finally</code> 和 <code>throw</code>。</p>
<ul>
<li>try：一个 try 块标识了一个将被激活的特定的异常的代码块。后跟一个或多个 catch 块。</li>
<li>catch：程序通过异常处理程序捕获异常。catch 关键字表示异常的捕获。</li>
<li>finally：finally 块用于执行给定的语句，不管异常是否被抛出都会执行。例如，如果您打开一个文件，不管是否出现异常文件都要被关闭。</li>
<li>throw：当问题出现时，程序抛出一个异常。使用 throw 关键字来完成。</li>
</ul>
<p>基本语法详见 <code>C#基本语句 - try语句</code>。</p>
<h2 id="C-中的异常类"><a href="#C-中的异常类" class="headerlink" title="C# 中的异常类"></a>C# 中的异常类</h2><p>C# 异常是使用类来表示的。C# 中的异常类主要是直接或间接地派生于 <code>System.Exception</code> 类。<code>System.ApplicationException</code> 和 <code>System.SystemException</code> 类是派生于 <code>System.Exception</code> 类的异常类。</p>
<p><code>System.ApplicationException</code> 类支持由应用程序生成的异常。所以程序员定义的异常都应派生自该类。</p>
<p><code>System.SystemException</code> 类是所有预定义的系统异常的基类。</p>
<p>下表列出了一些派生自 <code>System.SystemException</code> 类的预定义的异常类：</p>
<table>
<thead>
<tr>
<th align="left">异常类</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">System.IO.IOException</td>
<td align="left">处理 I&#x2F;O 错误。</td>
</tr>
<tr>
<td align="left">System.IndexOutOfRangeException</td>
<td align="left">处理当方法指向超出范围的数组索引时生成的错误。</td>
</tr>
<tr>
<td align="left">System.ArrayTypeMismatchException</td>
<td align="left">处理当数组类型不匹配时生成的错误。</td>
</tr>
<tr>
<td align="left">System.NullReferenceException</td>
<td align="left">处理当依从一个空对象时生成的错误。</td>
</tr>
<tr>
<td align="left">System.DivideByZeroException</td>
<td align="left">处理当除以零时生成的错误。</td>
</tr>
<tr>
<td align="left">System.InvalidCastException</td>
<td align="left">处理在类型转换期间生成的错误。</td>
</tr>
<tr>
<td align="left">System.OutOfMemoryException</td>
<td align="left">处理空闲内存不足生成的错误。</td>
</tr>
<tr>
<td align="left">System.StackOverflowException</td>
<td align="left">处理栈溢出生成的错误。</td>
</tr>
</tbody></table>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>​	C# 以 try 和 catch 块的形式提供了一种结构化的异常处理方案。使用这些块，把核心程序语句与错误处理语句分离开。</p>
<p>​	这些错误处理块是使用 try、catch 和 finally 关键字实现的。下面是一个当除以零时抛出异常的实例：</p>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ErrorHandlingApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">DivNumbers</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> result;</span><br><span class="line">        DivNumbers()</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">division</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = num1 / num2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (DivideByZeroException e)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Exception caught: &#123;0&#125;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Result: &#123;0&#125;&quot;</span>, result);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DivNumbers d = <span class="keyword">new</span> DivNumbers();</span><br><span class="line">        d.division(<span class="number">25</span>, <span class="number">0</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Exception caught: System.DivideByZeroException: Attempted to divide <span class="keyword">by</span> zero. </span><br><span class="line">at ...</span><br><span class="line">Result: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="创建用户自定义异常"><a href="#创建用户自定义异常" class="headerlink" title="创建用户自定义异常"></a>创建用户自定义异常</h2><p>您也可以定义自己的异常。用户自定义的异常类是派生自 <code>ApplicationException</code> 类。下面的实例演示了这点：</p>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UserDefinedException</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">TestTemperature</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         Temperature temp = <span class="keyword">new</span> Temperature();</span><br><span class="line">         <span class="keyword">try</span></span><br><span class="line">         &#123;</span><br><span class="line">            temp.showTemp();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span>(TempIsZeroException e)</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;TempIsZeroException: &#123;0&#125;&quot;</span>, e.Message);</span><br><span class="line">         &#125;</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TempIsZeroException</span>: <span class="title">ApplicationException</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">TempIsZeroException</span>(<span class="params"><span class="built_in">string</span> message</span>): <span class="title">base</span>(<span class="params">message</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Temperature</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">int</span> temperature = <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showTemp</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(temperature == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">throw</span> (<span class="keyword">new</span> TempIsZeroException(<span class="string">&quot;Zero Temperature found&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;Temperature: &#123;0&#125;&quot;</span>, temperature);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TempIsZeroException: Zero Temperature found</span><br></pre></td></tr></table></figure>

<h2 id="抛出对象"><a href="#抛出对象" class="headerlink" title="抛出对象"></a>抛出对象</h2><p>如果异常是直接或间接派生自 <code>System.Exception</code> 类，您可以抛出一个对象。您可以在 catch 块中使用 <code>throw</code> 语句来抛出当前的对象，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">throw</span> e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="c-泛型"><a href="#c-泛型" class="headerlink" title="c#泛型"></a>c#泛型</h1><p>​	泛型是一种在.NET中引入类型参数的概念，它使得设计类和方法可以推迟一个或多个类型的指定，直到客户端代码声明并实例化类或方法。例如，通过使用泛型类型参数T，您可以编写一个单一的类，其他客户端代码可以使用它而不会产生运行时转换或装箱操作的成本或风险。</p>
<p>​	泛型类和方法结合了可重用性、类型安全性和效率，而它们的非泛型对应物则不能做到这一点。泛型最常用于集合和操作它们的方法。System.Collections.Generic命名空间包含了几个基于泛型的集合类。</p>
<p>​	也可以创建自定义的泛型类型和方法，以提供您自己的类型安全和高效的通用解决方案和设计模式。</p>
<h2 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h2><h3 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h3><p>值类型区别于引用类型的一个特点是值类型必须包含一个值。</p>
<p>使用可空泛型<code>System.Nullable&lt;T&gt;</code>类提供了使值类型为空的一种方式。</p>
<h4 id="基本语法-4"><a href="#基本语法-4" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">System.Nullable&lt;类型名&gt; 变量名; <span class="comment">// 创建指定类型的可空类型</span></span><br><span class="line">类型名? 变量名;<span class="comment">// 两个语句功能相等</span></span><br></pre></td></tr></table></figure>



<h4 id="使用可空类型时的注意事项"><a href="#使用可空类型时的注意事项" class="headerlink" title="使用可空类型时的注意事项"></a>使用可空类型时的注意事项</h4><ul>
<li>可以使用只读属性Nullable&lt;T&gt;.HasValue和Nullable&lt;T&gt;.Value来检查和获取可空值类型变量的值。<ul>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.nullable-1.hasvalue">Nullable.HasValue</a>指示可为空值类型的实例是否具有其基础类型的值。</li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.nullable-1.hasvalue">如果HasValue</a>为<code>true</code>，则<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.nullable-1.value">Nullable.Value</a>获取基础类型的值。如果<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.nullable-1.hasvalue">HasValue</a>为<code>false</code>，则<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.nullable-1.value">Value</a>属性将抛出<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.invalidoperationexception">InvalidOperationException</a>。</li>
</ul>
</li>
<li>在使用泛型约束时，需要注意多个泛型约束不能以OR方式（更不严格）组合，只能以AND方式（更严格）组合。这意味着一个方法不能同时处理两种情况。泛型约束也不能用于为方法创建唯一签名，因此您需要使用两个单独的方法名称。</li>
</ul>
<p>例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 声明一个变量 nullableInt ，它除了拥有int变量的所有值外，还可以拥有null值。</span></span><br><span class="line">            System.Nullable&lt;<span class="built_in">int</span>&gt; nullableInt;</span><br><span class="line">            nullableInt = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(nullableInt == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;nullableInt 的值是 null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Console.WriteLine(nullableInt.GetType().FullName); // 注意 在值为null的时候，获取不到类型；当值为数值时，类型为int32.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同理 也可以存在可空类型的其他值类型 如bool：</span></span><br><span class="line">            <span class="comment">// 注意，可空类型的语法可以进行缩写：bool? nullableBool等价于Nullable&lt;bool&gt; nullableBool</span></span><br><span class="line">            <span class="built_in">bool</span>? nullableBool = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nullableBool == <span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;nullableBool的值是true&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nullableBool == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;nullableBool的值为false&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nullableBool == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;nullableBool的值为null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 可空类型还有一个属性：HasValue，可以使用这个属性类查看可空类型的变量是否有值</span></span><br><span class="line">            <span class="comment">// 如果HasValue值为true，则说明存在非null值，否则值为null。</span></span><br><span class="line">            <span class="comment">// 注意 这并不适用于引用类型，即便引用类型也存在一个HasValue的属性。因为引用变量的值为null则表示不存在对象，所有不能通过对象来访问这个属性，不然就会抛出空引用的错误</span></span><br><span class="line">            Console.WriteLine(nullableInt.HasValue);<span class="comment">// false</span></span><br><span class="line">            nullableInt = <span class="number">1</span>;</span><br><span class="line">            Console.WriteLine(nullableInt.HasValue);<span class="comment">// true</span></span><br><span class="line">            Console.WriteLine(nullableInt.Value);<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="从可空值类型到基础类型的转换"><a href="#从可空值类型到基础类型的转换" class="headerlink" title="从可空值类型到基础类型的转换"></a>从可空值类型到基础类型的转换</h4><p>如果要将可空值类型的值分配给不可空值类型变量，您可能需要指定要分配的值来代替<code>null</code>. 使用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator">null 合并运算符<code>??</code></a>来执行此操作（也可以使用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.nullable-1.getvalueordefault#system-nullable-1-getvalueordefault(-0)">Nullable.GetValueOrDefault(T)</a>方法来达到相同目的）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>? a = <span class="number">28</span>;</span><br><span class="line"><span class="built_in">int</span> b = a ?? <span class="number">-1</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;b is <span class="subst">&#123;b&#125;</span>&quot;</span>);  <span class="comment">// output: b is 28</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>? c = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">int</span> d = c ?? <span class="number">-1</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;d is <span class="subst">&#123;d&#125;</span>&quot;</span>);  <span class="comment">// output: d is -1</span></span><br></pre></td></tr></table></figure>

<p>也可以使用强制类型转换将可空类型强转成普通类型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = (<span class="built_in">int</span>)nullableInt;</span><br></pre></td></tr></table></figure>



<h5 id="空合并运算符-1"><a href="#空合并运算符-1" class="headerlink" title="?? 空合并运算符"></a>?? 空合并运算符</h5><p>在C#中，??运算符被称为空合并运算符。它会返回其左操作数的值（如果不为null）。否则，它会计算右操作数并返回其结果。如果左操作数的值不为null，则??运算符不会计算其右操作数1。</p>
<p>例如，您可以使用以下代码来检查一个可空类型变量是否为null，并在它为null时返回一个默认值：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>? x = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">int</span> y = x ?? <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，由于x的值为null，因此y的值将被设置为-1。</p>
<p>更多信息，详见c#运算符。</p>
<h4 id="可空类型与运算符"><a href="#可空类型与运算符" class="headerlink" title="可空类型与运算符"></a>可空类型与运算符</h4><p>对于简单类型，可以直接使用原有的运算符。</p>
<p>如果一个或两个操作数是<code>null</code>，则产生<code>null</code>；否则，运算符使用其操作数中包含的值来计算结果。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>? a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span>? b = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">int</span>? c = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">a++;        <span class="comment">// a is 11</span></span><br><span class="line">a = a * c;  <span class="comment">// a is 110</span></span><br><span class="line">a = a + b;  <span class="comment">// a is null</span></span><br></pre></td></tr></table></figure>



<p>对于<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/comparison-operators">比较运算符</a> <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, 和<code>&gt;=</code>，如果一个或两个操作数是<code>null</code>，则结果是<code>false</code>；否则，比较操作数包含的值。不要假设因为特定比较（例如<code>&lt;=</code>）返回<code>false</code>，所以相反的比较 ( <code>&gt;</code>) 返回<code>true</code>。下面的例子表明 10 是</p>
<ul>
<li>既不大于也不等于<code>null</code></li>
<li>不少于<code>null</code></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>? a = <span class="number">10</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;a&#125;</span> &gt;= null is <span class="subst">&#123;a &gt;= <span class="literal">null</span>&#125;</span>&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;a&#125;</span> &lt; null is <span class="subst">&#123;a &lt; <span class="literal">null</span>&#125;</span>&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;a&#125;</span> == null is <span class="subst">&#123;a == <span class="literal">null</span>&#125;</span>&quot;</span>);</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 10 &gt;= null is False</span></span><br><span class="line"><span class="comment">// 10 &lt; null is False</span></span><br><span class="line"><span class="comment">// 10 == null is False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>? b = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">int</span>? c = <span class="literal">null</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;null &gt;= null is <span class="subst">&#123;b &gt;= c&#125;</span>&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;null == null is <span class="subst">&#123;b == c&#125;</span>&quot;</span>);</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// null &gt;= null is False</span></span><br><span class="line"><span class="comment">// null == null is True</span></span><br></pre></td></tr></table></figure>



<h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h5><p>对于<code>bool?</code>类型，预定义的<code>&amp;</code>和<code>|</code>运算符不遵循本节中描述的规则：运算符评估的结果可以是非空的，即使其中一个操作数是<code>null</code>。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/boolean-logical-operators#nullable-boolean-logical-operators">布尔逻辑运算符</a>一文的可空<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/boolean-logical-operators">布尔逻辑运算</a>符部分。</p>
<h4 id="可空类型的装箱和拆箱"><a href="#可空类型的装箱和拆箱" class="headerlink" title="可空类型的装箱和拆箱"></a>可空类型的装箱和拆箱</h4><p>可空值类型的实例按如下方式<code>T?</code>装箱：</p>
<p>如果HasValue返回false，则生成空引用。<br>如果HasValue返回true，则基础值类型的相应值被装箱，而不是<code>Nullable&lt;T&gt;T</code>的实例。<br>可以将值类型的装箱值取消装箱T为相应的可为空值类型T?，如以下示例所示：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">41</span>;</span><br><span class="line"><span class="built_in">object</span> aBoxed = a;</span><br><span class="line"><span class="built_in">int</span>? aNullable = (<span class="built_in">int</span>?)aBoxed;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;Value of aNullable: <span class="subst">&#123;aNullable&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">object</span> aNullableBoxed = aNullable;</span><br><span class="line"><span class="keyword">if</span> (aNullableBoxed <span class="keyword">is</span> <span class="built_in">int</span> valueOfA)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;aNullableBoxed is boxed int: <span class="subst">&#123;valueOfA&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Value of aNullable: 41</span></span><br><span class="line"><span class="comment">// aNullableBoxed is boxed int: 41</span></span><br></pre></td></tr></table></figure>





<h3 id="List"><a href="#List" class="headerlink" title="List&lt;T&gt;"></a>List&lt;T&gt;</h3><p>List&lt;T&gt;是C#中的一个泛型集合类型，它表示一组强类型对象，可以通过索引访问。它提供了用于创建对象列表、向列表中添加项以及查找、排序和更新列表项的方法1。</p>
<p>List&lt;T&gt;是ArrayList的泛型版本，属于System.Collections.Generic命名空间。与ArrayList不同，List&lt;T&gt;可以包含指定类型的元素，并且由于它是泛型的，因此在编译时进行类型检查，不会执行装箱和拆箱操作。</p>
<p>下面是一个简单的示例，演示如何创建一个<code>List&lt;T&gt;</code>并向其中添加元素：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">numbers.Add(<span class="number">1</span>);</span><br><span class="line">numbers.Add(<span class="number">2</span>);</span><br><span class="line">numbers.Add(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个名为<code>numbers</code>的<code>List&lt;int&gt;</code>，并使用<code>Add</code>方法向其中添加了三个元素。</p>
<h4 id="对泛型列表进行排序和搜索"><a href="#对泛型列表进行排序和搜索" class="headerlink" title="对泛型列表进行排序和搜索"></a>对泛型列表进行排序和搜索</h4><p>要对List&lt;T&gt;排序，可以在要排序的类型上提供IComparable&lt;T&gt;接口，或者提供IComparer&lt;T&gt;接口。另外，还可以提供泛型委托，作为排序方法。从了解代码工作原理的角度看，这非常有趣，因为实现上述接口并不比实现其非泛型版本更麻烦。</p>
<p>一般情况下，给列表排序需要有一个方法来比较两个T类型的对象。要在列表中搜索，只需要一个方法来检查T类型的对象，看它是否满足某个条件。定义这样的方法很简单，这里给出两个可以使用的泛型委托类型:</p>
<ul>
<li><p>Comparison&lt;T&gt;: 这个委托类型用于排序方法，其返回类型和参数如下:</p>
<ul>
<li><pre><code class="language-c#">int method(T objectA, T objectB)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- Predicate\&lt;T&gt;: 这个委托类型用于搜索方法，其返回类型和参数如下:</span><br><span class="line"></span><br><span class="line">  - ```c#</span><br><span class="line">    bool method (T targetobject)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>可以定义任意多个这样的方法，使用它们实现List&lt;T&gt;的搜索和排序方法。</p>
<h2 id="定义泛型类型"><a href="#定义泛型类型" class="headerlink" title="定义泛型类型"></a>定义泛型类型</h2><h3 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h3><p>泛型类封装不特定于特定数据类型的操作。 泛型类最常见用法是用于链接列表、哈希表、堆栈、队列和树等集合。 无论存储数据的类型如何，添加项和从集合删除项等操作的执行方式基本相同。</p>
<p>对于大多数需要集合类的方案，推荐做法是使用 .NET 类库中提供的集合类。 有关使用这些类的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/standard/generics/collections">.NET 中的泛型集合</a>。</p>
<p>通常，创建泛型类是从现有具体类开始，然后每次逐个将类型更改为类型参数，直到泛化和可用性达到最佳平衡。 创建自己的泛型类时，需要考虑以下重要注意事项：</p>
<h4 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h4><p>要创建泛型类，需要在类名后面添加尖括号<code>&lt;&gt;</code>，并在其中指定一个或多个类型参数。类型参数可以在类的定义中用作占位符，表示未知的类型。当客户端代码声明并实例化类时，它将指定类型参数的具体类型。</p>
<p>下面是一个简单的示例，演示如何创建一个泛型类：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyGenericClass</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetValue</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了一个名为<code>MyGenericClass&lt;T&gt;</code>的泛型类。该类具有一个名为<code>value</code>的私有字段，其类型为<code>T</code>。我们还定义了一个构造函数和一个名为<code>GetValue</code>的方法，它们都使用了类型参数<code>T</code>。</p>
<p>要使用这个泛型类，您需要在声明并实例化它时指定类型参数的具体类型。例如，您可以使用以下代码创建一个<code>MyGenericClass&lt;int&gt;</code>的实例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">MyGenericClass&lt;<span class="built_in">int</span>&gt; myInt = <span class="keyword">new</span> MyGenericClass&lt;<span class="built_in">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">int</span> <span class="keyword">value</span> = myInt.GetValue(); <span class="comment">// value will be 10</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个名为<code>myInt</code>的<code>MyGenericClass&lt;int&gt;</code>实例，并使用构造函数将其初始化为10。然后，我们调用了<code>GetValue</code>方法来获取存储在该实例中的值。</p>
<p>其中 上面提到的<code>T</code>可以是任意标识符。但一般只使用T</p>
<p>也可以在定义泛型类时指定多个类型参数。只需在类名后面的尖括号<code>&lt;&gt;</code>中用逗号分隔多个类型参数即可。</p>
<p>下面是一个简单的示例，演示如何创建一个带有两个类型参数的泛型类：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T1 value1;</span><br><span class="line">    <span class="keyword">private</span> T2 value2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyGenericClass</span>(<span class="params">T1 value1, T2 value2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.value1 = value1;</span><br><span class="line">        <span class="keyword">this</span>.value2 = value2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T1 <span class="title">GetValue1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> value1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T2 <span class="title">GetValue2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> value2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了一个名为<code>MyGenericClass&lt;T1, T2&gt;</code>的泛型类。该类具有两个私有字段，分别为<code>value1</code>和<code>value2</code>，它们的类型分别为<code>T1</code>和<code>T2</code>。我们还定义了一个构造函数和两个方法，它们都使用了类型参数<code>T1</code>和<code>T2</code>。</p>
<p>要使用这个泛型类，您需要在声明并实例化它时指定类型参数的具体类型。例如，您可以使用以下代码创建一个<code>MyGenericClass&lt;int, string&gt;</code>的实例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">MyGenericClass&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; myPair = <span class="keyword">new</span> MyGenericClass&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;(<span class="number">10</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">int</span> value1 = myPair.GetValue1(); <span class="comment">// value1 will be 10</span></span><br><span class="line"><span class="built_in">string</span> value2 = myPair.GetValue2(); <span class="comment">// value2 will be &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个名为<code>myPair</code>的<code>MyGenericClass&lt;int, string&gt;</code>实例，并使用构造函数将其初始化为<code>(10, &quot;hello&quot;)</code>。然后，我们调用了<code>GetValue1</code>和<code>GetValue2</code>方法来获取存储在该实例中的值。</p>
<h5 id="default关键字"><a href="#default关键字" class="headerlink" title="default关键字"></a>default关键字</h5><p>在泛型类或方法中，可以使用<code>default</code>关键字来获取类型参数的默认值。<code>default(T)</code>表达式将返回类型<code>T</code>的默认值。对于引用类型，它将返回null；对于值类型，它将返回该类型的默认值（例如，对于<code>int</code>类型，它将返回0）。</p>
<p>下面是一个简单的示例，演示如何在泛型类中使用<code>default</code>关键字：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyGenericClass</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">value</span> = <span class="literal">default</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetValue</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了一个名为<code>MyGenericClass&lt;T&gt;</code>的泛型类。该类具有一个名为<code>value</code>的私有字段，其类型为<code>T</code>。我们还定义了一个构造函数，在其中使用了<code>default(T)</code>表达式来初始化<code>value</code>字段。</p>
<p>要使用这个泛型类，您需要在声明并实例化它时指定类型参数的具体类型。例如，您可以使用以下代码创建一个<code>MyGenericClass&lt;int&gt;</code>的实例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">MyGenericClass&lt;<span class="built_in">int</span>&gt; myInt = <span class="keyword">new</span> MyGenericClass&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="built_in">int</span> <span class="keyword">value</span> = myInt.GetValue(); <span class="comment">// value will be 0</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个名为<code>myInt</code>的<code>MyGenericClass&lt;int&gt;</code>实例，并使用构造函数将其初始化。由于我们在构造函数中使用了<code>default(T)</code>表达式来初始化<code>value</code>字段，因此该字段的值将被设置为0。</p>
<h4 id="where泛型约束"><a href="#where泛型约束" class="headerlink" title="where泛型约束"></a>where泛型约束</h4><p>泛型定义中的 <code>where</code> 子句指定对用作泛型类型、方法、委托或本地函数中类型参数的参数类型的约束。 约束可指定接口、基类或要求泛型类型为引用、值或非托管类型。 约束声明类型参数必须具有的功能，并且约束必须位于任何声明的基类或实现的接口之后。</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>泛型约束用于限制可替换类型参数的类型。当我们创建一个新的泛型类型实例时，我们可以使用约束来限制可替换类型参数的类型。如果客户端代码使用不满足约束的类型，编译器会发出错误。约束通过使用 where 上下文关键字指定1。</p>
<p>例如，你可以声明一个泛型类 AGenericClass ，以使类型参数 T 实现 IComparable&lt;T&gt; 接口：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AGenericClass</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">IComparable</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，你就可以在泛型类中使用 Employee.Name 属性。 约束指定所有类型为 T 的项都保证是 Employee 对象或从 Employee 继承的对象。 可以对同一类型参数应用多个约束，约束本身也可以是泛型类型1。</p>
<p>泛型约束有多种类型，它们可以帮助你限制可替换类型参数的类型。下面是一些常见的泛型约束类型：</p>
<ul>
<li>where T : struct：类型参数必须是非空值类型。所有值类型都具有可访问的无参数构造函数，因此 struct 约束意味着 new() 约束，不能与 new() 约束结合使用。您不能将 struct 约束与 unmanaged 约束结合使用1。</li>
<li>where T : class：类型参数必须是引用类型。此约束也适用于任何类、接口、委托或数组类型。在可为空上下文中，T 必须是非空引用类型1。</li>
<li>where T : class?：类型参数必须是引用类型，可以为空或非空。此约束也适用于任何类、接口、委托或数组类型1。</li>
<li>where T : notnull：类型参数必须是非空类型。参数可以是非空引用类型或非空值类型1。</li>
<li>where T : new()：类型参数必须具有公共无参数构造函数。与其他约束一起使用时，new() 约束必须最后指定。new() 约束不能与 struct 和 unmanaged 约束结合使用1。</li>
<li>where T : &lt;base class name&gt;：类型参数必须是指定基类或从指定基类派生。在可为空上下文中，T 必须是从指定基类派生的非空引用类型1。</li>
</ul>
<p>这些约束可以帮助你更好地控制泛型类的行为，并确保客户端代码使用正确的类型来实例化泛型类。</p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>协变 逆变</p>
<p>泛型缓存</p>
<h1 id="c-委托"><a href="#c-委托" class="headerlink" title="c#委托"></a>c#委托</h1><h2 id="什么是委托"><a href="#什么是委托" class="headerlink" title="什么是委托"></a>什么是委托</h2><p>C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针，是函数指针的升级版，可以按照某些约束指向某个方法，使得对方法的间接调用。</p>
<p>委托（Delegate） 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。</p>
<p>委托（Delegate）特别用于实现事件和回调方法。所有的委托都派生自 <strong>System.Delegate</strong> 类。</p>
<p>从数据结构来讲，委托是和类一样是一种用户自定义<strong>类型</strong>；从设计模式来讲，委托（类）提供了<strong>方法</strong>（对象）的抽象。</p>
<h2 id="为什么要使用委托"><a href="#为什么要使用委托" class="headerlink" title="为什么要使用委托"></a>为什么要使用委托</h2><h2 id="c-的内置泛型委托"><a href="#c-的内置泛型委托" class="headerlink" title="c#的内置泛型委托"></a>c#的内置泛型委托</h2><h3 id="Action委托"><a href="#Action委托" class="headerlink" title="Action委托"></a>Action委托</h3><p>​	Action&lt;T&gt;是.NET Framework内置的泛型委托，可以使用Action&lt;T&gt;委托以参数形式传递方法，而不用显示声明自定义的委托。封装的方法必须与此委托定义的方法签名相对应。也就是说，封装的方法必须具有一个通过值传递给它的参数，并且<strong>不能有返回值</strong>。</p>
<p>​	Action其实就是没有返回值的delegate。</p>
<h4 id="Action委托定义"><a href="#Action委托定义" class="headerlink" title="Action委托定义"></a>Action委托定义</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">System</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">//     封装一个方法，该方法不具有参数且不返回值。</span></span><br><span class="line">    [<span class="meta">TypeForwardedFrom(<span class="string">&quot;System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Action委托至少0个参数，至多16个参数，无返回值。</li>
<li>Action 表示无参，无返回值的委托。</li>
<li>Action&lt;int,string&gt; 表示有传入参数int,string无返回值的委托。</li>
<li>Action&lt;int,string,bool&gt; 表示有传入参数int,string,bool无返回值的委托。</li>
<li>Action&lt;int,int,int,int&gt; 表示有传入4个int型参数，无返回值的委托。</li>
</ul>
<h4 id="样例-21"><a href="#样例-21" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//等待被委托的对象</span></span><br><span class="line">            Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Action委托的定义</span></span><br><span class="line">            Action action = <span class="keyword">new</span> Action(calculator.Report);<span class="comment">//使用action委托指向了新创建的方法</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//以下三条语句的功能相同，都是调用calculator的Report</span></span><br><span class="line">            calculator.Report();<span class="comment">//直接调用目标发放</span></span><br><span class="line">            action.Invoke();<span class="comment">//使用委托的Invoke方法进行间接调用</span></span><br><span class="line">            action();<span class="comment">//简便写法，模仿了函数指针</span></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Report</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;I have 3 methods&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> res = a + b;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Sub</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> res = a - b;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Func委托"><a href="#Func委托" class="headerlink" title="Func委托"></a>Func委托</h3><p>Func委托代表有返回类型的委托。</p>
<h4 id="Func委托定义"><a href="#Func委托定义" class="headerlink" title="Func委托定义"></a>Func委托定义</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">System</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">//     封装一个方法，该方法具有两个参数，并返回由 TResult 参数指定的类型的值。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 参数:</span></span><br><span class="line">    <span class="comment">//   arg1:</span></span><br><span class="line">    <span class="comment">//     此委托封装的方法的第一个参数。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   arg2:</span></span><br><span class="line">    <span class="comment">//     此委托封装的方法的第二个参数。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 类型参数:</span></span><br><span class="line">    <span class="comment">//   T1:</span></span><br><span class="line">    <span class="comment">//     此委托封装的方法的第一个参数的类型。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   T2:</span></span><br><span class="line">    <span class="comment">//     此委托封装的方法的第二个参数的类型。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   TResult:</span></span><br><span class="line">    <span class="comment">//     此委托封装的方法的返回值类型。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 返回结果:</span></span><br><span class="line">    <span class="comment">//     此委托封装的方法的返回值。</span></span><br><span class="line">    [<span class="meta">TypeForwardedFrom(<span class="string">&quot;System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>, <span class="keyword">in</span> <span class="title">T2</span>, <span class="keyword">out</span> <span class="title">TResult</span>&gt;(<span class="params">T1 arg1, T2 arg2</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>Func至少0个输入参数，至多16个输入参数，根据返回值泛型返回。<strong>必须有返回值，不可void。</strong></p>
<p>Func&lt;int&gt; 表示没有输入参参，返回值为int类型的委托。</p>
<p>Func&lt;object,string,int&gt; 表示传入参数为object, string ，返回值为int类型的委托。</p>
<p>Func&lt;object,string,int&gt; 表示传入参数为object, string， 返回值为int类型的委托。</p>
<p>Func&lt;T1,T2,,T3,int&gt; 表示传入参数为T1,T2,,T3(泛型)，返回值为int类型的委托。</p>
<h4 id="样例-22"><a href="#样例-22" class="headerlink" title="样例"></a>样例</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//等待被委托的对象</span></span><br><span class="line">            Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//Func委托：分别指向了calculator的两个方法</span></span><br><span class="line">            Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; func1 = <span class="keyword">new</span> Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt;(calculator.Add);</span><br><span class="line">            Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; func2 = <span class="keyword">new</span> Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt;(calculator.Sub);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Func&lt;void&gt; func3 = new Func&lt;void&gt;(calculator.Report);报错，不允许没有返回值</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> x = <span class="number">100</span>;</span><br><span class="line">            <span class="built_in">int</span> y = <span class="number">200</span>;</span><br><span class="line">            <span class="built_in">int</span> z;</span><br><span class="line"></span><br><span class="line">            z = func1.Invoke(x, y);<span class="comment">//可以用Invoke调用</span></span><br><span class="line">            Console.WriteLine(z);</span><br><span class="line">            <span class="comment">//z = func2.Invoke(x, y);</span></span><br><span class="line">            z = func2(x, y);<span class="comment">//也可以模仿函数指针的形式调用</span></span><br><span class="line">            Console.WriteLine(z);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Report</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;I have 3 methods&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> res = a + b;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Sub</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> res = a - b;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="自定义委托"><a href="#自定义委托" class="headerlink" title="自定义委托"></a>自定义委托</h2><p>委托是一种类（class），类是数据类型，所以委托也是一种数据类型。委托也可以创建实例、声明对象</p>
<p>与类一样，委托类型必须在被使用之前进行声明。</p>
<p>他的声明方式与一般的类不同。</p>
<p>需要注意声明委托的地方：委托是一个类，是在命名空间下面的一个类，与其他类同级。</p>
<p>类是可以被嵌套的，因此委托也可以，所以，委托是可以被声明在一个类中，运行可能也不会报错，但此时的委托已经不是一个独立的类了，而是外层类的一个嵌套类</p>
<p>委托所封装的方法必须“类型兼容”，即声明委托的时候，所使用的目标方法的返回值类型、目标方法的参数列表类型，必须与目标方法保持一致。     声明的是什么类型，创建对象时指向的也得是什么类型。</p>
<p>常用于将一个方法赋值给一个自定义的委托类型。前提是方法和委托的签名一样（即参数和返回值相同）</p>
<h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><p>新参列表只需要保证类型数量一致即可，形参名是否相等无所谓。</p>
<p>注意委托是一个类，直属于命名空间，与其他类平级。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delegate</span> 目标方法的返回值 委托名（目标方法的形参列表）</span><br></pre></td></tr></table></figure>

<h4 id="样例1-2"><a href="#样例1-2" class="headerlink" title="样例1"></a>样例1</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">double</span> <span class="title">Calc</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span>;<span class="comment">//自定义委托的声明</span></span><br></pre></td></tr></table></figure>







<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="使用new运算符"><a href="#使用new运算符" class="headerlink" title="使用new运算符"></a>使用new运算符</h4><p>new运算符的操作数的组成如下：</p>
<ul>
<li>委托类型名</li>
<li>一组圆括号，其中包含作为调用列表中的第一个成员的方法的名字。方法可以是实例方法或静态方法。</li>
</ul>
<p>如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Calc calc1 = <span class="keyword">new</span> Calc(calculator.Add);</span><br><span class="line">Calc calc2 = <span class="keyword">new</span> Calc(calculator.Sub);</span><br></pre></td></tr></table></figure>



<h4 id="使用快捷语法"><a href="#使用快捷语法" class="headerlink" title="使用快捷语法"></a>使用快捷语法</h4><p>快键语法，它<strong>仅由方法说明符构成</strong>。之所以能这样，是因为在方法名称和其相应的委托类型之间<strong>有隐式转换</strong>。</p>
<p>如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Calc calc3 = calculator.Mul;</span><br><span class="line">Calc calc4 = calculator.Div;</span><br></pre></td></tr></table></figure>



<h3 id="赋值委托"><a href="#赋值委托" class="headerlink" title="赋值委托"></a>赋值委托</h3><p> 由于委托是引用类型，我们可以通过给它赋值来改变包含在委托变量中的方法地址引用。旧的引用会被垃圾回收器回收。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Calc calc1 = <span class="keyword">new</span> Calc(calculator.Add);</span><br><span class="line">calc1 = <span class="keyword">new</span> Calc(calculator.Sub);</span><br></pre></td></tr></table></figure>



<h3 id="组合委托"><a href="#组合委托" class="headerlink" title="组合委托"></a>组合委托</h3><p>也称为委托的多播（Multicasting of a Delegate）</p>
<p>委托可以使用额外的运算符来组合。这个运算最终会创建一个新的委托，其调用列表是两个操作数的委托调用列表的副本的连接。</p>
<p>委托是恒定的，操作数委托创建后不会被改变。<strong>委托组合拷贝的是操作数的副本</strong>。</p>
<p>可以使用+&#x3D;运算符，为委托新增方法。</p>
<p>同样可以使用-&#x3D;运算符，为委托移除方法。</p>
<p>具体的应用场景？</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">NumberChanger</span>(<span class="params"><span class="built_in">int</span> n</span>)</span>;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DelegateAppl</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">TestDelegate</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">static</span> <span class="built_in">int</span> num = <span class="number">10</span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">AddNum</span>(<span class="params"><span class="built_in">int</span> p</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         num += p;</span><br><span class="line">         <span class="keyword">return</span> num;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">MultNum</span>(<span class="params"><span class="built_in">int</span> q</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         num *= q;</span><br><span class="line">         <span class="keyword">return</span> num;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">getNum</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">return</span> num;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">// 创建委托实例</span></span><br><span class="line">         NumberChanger nc;</span><br><span class="line">         NumberChanger nc1 = <span class="keyword">new</span> NumberChanger(AddNum);</span><br><span class="line">         NumberChanger nc2 = <span class="keyword">new</span> NumberChanger(MultNum);</span><br><span class="line">         nc = nc1;</span><br><span class="line">         nc += nc2;</span><br><span class="line">         <span class="comment">// 调用多播</span></span><br><span class="line">         nc(<span class="number">5</span>);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;Value of Num: &#123;0&#125;&quot;</span>, getNum());</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Value of Num: 75</span><br></pre></td></tr></table></figure>



<h3 id="委托调用"><a href="#委托调用" class="headerlink" title="委托调用"></a>委托调用</h3><p>委托调用跟方法调用类似。委托调用后，调用列表的每个方法将会被执行。</p>
<p><strong>在调用委托前，应判断委托是否为空</strong>。调用空委托会抛出异常。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(calc1 != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    c = calc1.Invoke(a, b);</span><br><span class="line">    Console.WriteLine(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h3><p>匿名方法是在初始化委托时内联声明的方法。</p>
<h4 id="基本结构："><a href="#基本结构：" class="headerlink" title="基本结构："></a>基本结构：</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">deleage( 参数 ) &#123; 语句块 &#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDel</span> (<span class="params"><span class="built_in">int</span> x</span>)</span>; <span class="comment">//定义一个委托 </span></span><br><span class="line"></span><br><span class="line">MyDel del = <span class="built_in">delegate</span>( <span class="built_in">int</span> x)&#123; <span class="keyword">return</span> x; &#125;;</span><br></pre></td></tr></table></figure>

<p>从上面我们可以看到，<strong>匿名方法是不会显示声明返回值的</strong>。</p>
<h2 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h2><p>我们每次要使用一个委托时，都需要先声明这个委托类，规定参数和返回值类型，然后才能实例化、调用。为了简化这个过程， .NET 框架为我们封装了三个泛型委托类，因此大部分情况下我们不必再声明委托，可以拿来直接实例化使用，方便了我们的日常写代码。<br>这三种泛型委托包括：Func委托、Action委托和Predicate委托。</p>
<h3 id="自定义泛型委托"><a href="#自定义泛型委托" class="headerlink" title="自定义泛型委托"></a>自定义泛型委托</h3><h4 id="声明-2"><a href="#声明-2" class="headerlink" title="声明"></a>声明</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">DelCompareT</span>&lt;<span class="title">T</span>&gt;(<span class="params">T t1,T t2</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">public <span class="type">static</span> T GetMaxT&lt;T&gt;(T[] nums, DelCompareT&lt;T&gt; del)</span><br><span class="line">&#123;</span><br><span class="line">    T maxx = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(del(maxx, nums[i]) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maxx = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="委托的一般使用"><a href="#委托的一般使用" class="headerlink" title="委托的一般使用"></a>委托的一般使用</h2><p>常用于把委托当作方法的参数传到方法里面去。</p>
<p>一个具有委托类型参数的方法，在方法体内使用传进来的委托间接的调用委托封装的那个方法，这样就形成了一种动态调用方法的结构。</p>
<p>像这种把委托当作参数传进方法的用法，具体可分为两种：模板方法、回调（callback）方法</p>
<h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>​	所谓模板方法，就是将传进来的委托参数，借用指定的外部方法来产生结果。</p>
<p>​	相当于在写的方法中有一个“填空题”，中间空缺的位置就用传进来的委托参数填补，也就是通过传进来的委托参数简介的调用指定的外部方法。这个方法一般是具有返回值的，当拿到返回值后，再继续执行后面的逻辑。</p>
<p>​	写了一个方法，这个方法是一个模板，这个模板里有一处是不确定的，区域部分是确定好的，这个不确定的部分，就是靠传进来的委托类型的参数所包含的方法来填补</p>
<h4 id="样例-23"><a href="#样例-23" class="headerlink" title="样例"></a>样例</h4><p>没有直接使用MakePizza，而是通过委托间接的调用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ProductFactory productFactory = <span class="keyword">new</span> ProductFactory();<span class="comment">//生产工厂的实例</span></span><br><span class="line">            WrapFactory wrapFactory = <span class="keyword">new</span> WrapFactory();<span class="comment">//包装工厂的实例</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//开始使用模板方法</span></span><br><span class="line">            <span class="comment">//准备委托类型的变量，当作参数传入模板方法</span></span><br><span class="line">            Func&lt;Product&gt; func1 = <span class="keyword">new</span> Func&lt;Product&gt;(productFactory.MakePizza);<span class="comment">//生产披萨的委托 </span></span><br><span class="line">            Func&lt;Product&gt; func2 = <span class="keyword">new</span> Func&lt;Product&gt;(productFactory.MakeToyCar);<span class="comment">//生产玩具车</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用模板方法</span></span><br><span class="line">            Box box1 = wrapFactory.WrapPorduct(func1);</span><br><span class="line">            Box box2 = wrapFactory.WrapPorduct(func2);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(box1.Product.Name);</span><br><span class="line">            Console.WriteLine(box2.Product.Name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产品</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Product</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//包装产品的箱子</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Box</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> Product Product &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将产品包上箱子交给客户</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">WrapFactory</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//模板方法，大部分逻辑都已经被固定了，最大限度的实现了代码的重用</span></span><br><span class="line">        <span class="comment">//准备一个箱子</span></span><br><span class="line">        <span class="comment">//获取产品</span></span><br><span class="line">        <span class="comment">//将产品装入box</span></span><br><span class="line">        <span class="comment">//将打包好的box送回</span></span><br><span class="line">        <span class="comment">//回调方法：使用Func委托，返回值是Product</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Box <span class="title">WrapPorduct</span>(<span class="params">Func&lt;Product&gt; getProduct</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Box box = <span class="keyword">new</span> Box();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//间接调用 生产工厂的生产方法 拿到一个product的对象</span></span><br><span class="line">            <span class="comment">//可以动态的选择调用方法</span></span><br><span class="line">            Product product = getProduct();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            box.Product = product;</span><br><span class="line">            <span class="keyword">return</span> box;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生产工厂</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">ProductFactory</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//生产披萨</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Product <span class="title">MakePizza</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Product product = <span class="keyword">new</span> Product();</span><br><span class="line">            product.Name = <span class="string">&quot;Pizza&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> product;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生存玩具车</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Product <span class="title">MakeToyCar</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Product product = <span class="keyword">new</span> Product();</span><br><span class="line">            product.Name = <span class="string">&quot;ToyCar&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> product;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h3><p>回调：callback</p>
<p>回调方法是是通过委托类型的参数传进主调方法的被调用方法，主调方法可以根据自己的逻辑决定是否调用这个方法。换句话说就是，某个方法可以调用它，也可以不调用它，而且可以动态地选择后续调用的方法。</p>
<p>在以回调方法的形式来使用委托的时候，要做的是把委托类型的参数传进主调方法里面去，被传进主调方法里面的委托类型的参数，它内部会封装一个被回调的方法，也就是常说的回调方法。主调函数会根据自己的逻辑决定是否调用这个回调方法。</p>
<p>就像一个流水线一样，主调方法会在主要逻辑执行完毕后，决定是否调用这个回调方法</p>
<p>回调方法一般都位于主调方法的末尾，一般用于执行后续的工作，一般是没有返回值的。																																																																																																																</p>
<h3 id="样例-24"><a href="#样例-24" class="headerlink" title="样例"></a>样例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//委托的声明以及初始化实例</span></span><br><span class="line">            Calc calc1 = <span class="keyword">new</span> Calc(calculator.Add);</span><br><span class="line">            Calc calc2 = <span class="keyword">new</span> Calc(calculator.Sub);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//快键语法，它仅由方法说明符构成。</span></span><br><span class="line">            <span class="comment">//之所以能这样，是因为在方法名称和其相应的委托类型之间有隐式转换。</span></span><br><span class="line">            Calc calc3 = calculator.Mul;</span><br><span class="line">            Calc calc4 = calculator.Div;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">double</span> a = <span class="number">100</span>;</span><br><span class="line">            <span class="built_in">double</span> b = <span class="number">200</span>;</span><br><span class="line">            <span class="built_in">double</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//间接调用4个委托，也可以不用Invoke关键字，直接（）调用</span></span><br><span class="line">            c = calc1.Invoke(a, b);</span><br><span class="line">            Console.WriteLine(c);</span><br><span class="line">            c = calc2.Invoke(a, b);</span><br><span class="line">            Console.WriteLine(c);</span><br><span class="line">            c = calc3.Invoke(a, b);                </span><br><span class="line">            Console.WriteLine(c);</span><br><span class="line">            c = calc4.Invoke(a, b);</span><br><span class="line">            Console.WriteLine(c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">double</span> <span class="title">Calc</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span>;<span class="comment">//自定义委托的声明，只需要保证类型一致即可，形参名是否相等无所谓</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Sub</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x - y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Mul</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x * y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Div</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x / y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="样例2：借助委托，使用一个方法调用不同的方法。"><a href="#样例2：借助委托，使用一个方法调用不同的方法。" class="headerlink" title="样例2：借助委托，使用一个方法调用不同的方法。"></a>样例2：借助委托，使用一个方法调用不同的方法。</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 委托</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明一个委托，指向一个函数</span></span><br><span class="line">    <span class="comment">//委托所指向的函数必须和委托具有相同的签名（即参数和返回值）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">DelSayHi</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//DelSayHi del = SayHiChinese;//不再创建一个对象，而是直接给一个方法</span></span><br><span class="line">            <span class="comment">//del(&quot;张三&quot;);</span></span><br><span class="line"></span><br><span class="line">            Test(<span class="string">&quot;张三&quot;</span>, SayHiChinese);</span><br><span class="line">            Test(<span class="string">&quot;张三&quot;</span>, SayHiEnglish);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"><span class="built_in">string</span> name, DelSayHi del</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            del(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SayHiChinese</span>(<span class="params">String name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;你好，&quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SayHiEnglish</span>(<span class="params">String name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;hi，&quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="样例3：借助委托，利用一个方法实现将string数组中每个元素变成全大写或全小写，然后再加上双引号"><a href="#样例3：借助委托，利用一个方法实现将string数组中每个元素变成全大写或全小写，然后再加上双引号" class="headerlink" title="样例3：借助委托，利用一个方法实现将string数组中每个元素变成全大写或全小写，然后再加上双引号"></a>样例3：借助委托，利用一个方法实现将string数组中每个元素变成全大写或全小写，然后再加上双引号</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Security.AccessControl;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace 委托</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明一个委托</span></span><br><span class="line">    delegate <span class="type">void</span> <span class="title function_">DelStr</span><span class="params">(<span class="built_in">string</span>[] str)</span>;</span><br><span class="line"></span><br><span class="line">    internal <span class="class"><span class="keyword">class</span> <span class="title">Program</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">static</span> <span class="type">void</span> <span class="title function_">Main</span><span class="params">(<span class="built_in">string</span>[] args)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>[] str = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Any&quot;</span>, <span class="string">&quot;Hurr&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Test(str, ProStrToUpper);//转大写</span></span><br><span class="line">            <span class="comment">//Test(str, ProStrToLower);//转小写</span></span><br><span class="line">            Test(str, ProStrSYH);<span class="comment">//加双引号</span></span><br><span class="line"></span><br><span class="line">            foreach(var s in str)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(s);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public <span class="type">static</span> <span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="built_in">string</span>[] str, DelStr del)</span></span><br><span class="line">        &#123;</span><br><span class="line">            del(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public <span class="type">static</span> <span class="type">void</span> <span class="title function_">ProStrToUpper</span><span class="params">(<span class="built_in">string</span>[] str)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                str[i] = str[i].ToUpper();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public <span class="type">static</span> <span class="type">void</span> <span class="title function_">ProStrToLower</span><span class="params">(<span class="built_in">string</span>[] str)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.Length; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                str[i] = str[i].ToLower();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public <span class="type">static</span> <span class="type">void</span> <span class="title function_">ProStrSYH</span><span class="params">(<span class="built_in">string</span>[] str)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                str[i] = <span class="string">&quot;\&quot;&quot;</span> + str[i] + <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="样例4：借助委托，利用一个方法实现将string数组中每个元素变成全大写或全小写，然后再加上双引号。"><a href="#样例4：借助委托，利用一个方法实现将string数组中每个元素变成全大写或全小写，然后再加上双引号。" class="headerlink" title="样例4：借助委托，利用一个方法实现将string数组中每个元素变成全大写或全小写，然后再加上双引号。"></a>样例4：借助委托，利用一个方法实现将string数组中每个元素变成全大写或全小写，然后再加上双引号。</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.AccessControl;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 委托</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明一个委托</span></span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">DelStr</span>(<span class="params"><span class="built_in">string</span>[] str</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">string</span> <span class="title">DelProStr</span>(<span class="params"><span class="built_in">string</span> str</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>[] str = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Any&quot;</span>, <span class="string">&quot;Hurr&quot;</span> &#125;;</span><br><span class="line">            <span class="comment">//ProStr(str, ProStrToUpper);</span></span><br><span class="line">            <span class="comment">//ProStr(str, ProStrToLower);</span></span><br><span class="line">            ProStr(str, ProStrSYH);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> s <span class="keyword">in</span> str)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(s);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ProStr</span>(<span class="params"><span class="built_in">string</span>[] name, DelProStr del </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; name.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                name[i] = del(name[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">ProStrToUpper</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> str.ToUpper();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">ProStrToLower</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> str.ToLower();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">ProStrSYH</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;\&quot;&quot;</span> + str + <span class="string">&quot;\&quot;&quot;</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="在上一个样例的基础上，修改成使用匿名方法的委托。"><a href="#在上一个样例的基础上，修改成使用匿名方法的委托。" class="headerlink" title="在上一个样例的基础上，修改成使用匿名方法的委托。"></a>在上一个样例的基础上，修改成使用匿名方法的委托。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Security.AccessControl;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace 委托</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明一个委托</span></span><br><span class="line">    delegate <span class="type">void</span> <span class="title function_">DelStr</span><span class="params">(<span class="built_in">string</span>[] str)</span>;</span><br><span class="line">    public delegate <span class="built_in">string</span> <span class="title function_">DelProStr</span><span class="params">(<span class="built_in">string</span> str)</span>;</span><br><span class="line"></span><br><span class="line">    internal <span class="class"><span class="keyword">class</span> <span class="title">Program</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">static</span> <span class="type">void</span> <span class="title function_">Main</span><span class="params">(<span class="built_in">string</span>[] args)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>[] str = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Any&quot;</span>, <span class="string">&quot;Hurr&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ProStr(str, delegate (string s)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    return s.ToUpper();</span></span><br><span class="line">            <span class="comment">//&#125;);</span></span><br><span class="line">            <span class="comment">//ProStr(str, delegate (string s)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    return s.ToLower();</span></span><br><span class="line">            <span class="comment">//&#125;);</span></span><br><span class="line">            ProStr(str, delegate (<span class="built_in">string</span> s)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;\&quot;&quot;</span> + s + <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            foreach (var s in str)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(s);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public <span class="type">static</span> <span class="type">void</span> <span class="title function_">ProStr</span><span class="params">(<span class="built_in">string</span>[] name, DelProStr del)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; name.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                name[i] = del(name[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="泛型委托的应用：求任意数组的最大值"><a href="#泛型委托的应用：求任意数组的最大值" class="headerlink" title="泛型委托的应用：求任意数组的最大值"></a>泛型委托的应用：求任意数组的最大值</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Globalization;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 泛型委托</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">DelCompare</span>(<span class="params"><span class="built_in">object</span> x, <span class="built_in">object</span> y</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个泛型委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">DelCompareT</span>&lt;<span class="title">T</span>&gt;(<span class="params">T t1,T t2</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//object[] o = &#123; 1, 5, 3, 9 &#125;;</span></span><br><span class="line">            <span class="comment">//object[] o2 = &#123; &quot;hurr&quot;, &quot;Any&quot;, &quot;Jam&quot; &#125;;</span></span><br><span class="line">            <span class="comment">//object result = GetMax(o, CompareInt);</span></span><br><span class="line">            <span class="comment">//result = GetMax(o2, CompareString);</span></span><br><span class="line">            <span class="comment">//Console.WriteLine(result);</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">            <span class="keyword">var</span> Result = GetMaxT&lt;<span class="built_in">int</span>&gt;(nums, CompareIntNew);</span><br><span class="line">            Console.WriteLine(Result);</span><br><span class="line"></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetMaxNum</span>(<span class="params"><span class="built_in">int</span>[] num</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> maxx = num[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(maxx &lt; num[i])</span><br><span class="line">                    maxx = num[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetMaxName</span>(<span class="params"><span class="built_in">string</span>[] names</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> maxx = names[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; names.Length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(maxx.Length &lt; names[i].Length)</span><br><span class="line">                    maxx = names[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//传参的时候可以传一个委托，用于执行比较方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">object</span> <span class="title">GetMax</span>(<span class="params"><span class="built_in">object</span>[] nums, DelCompare del</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">object</span> maxx = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//要传一个委托的比较方法</span></span><br><span class="line">                <span class="keyword">if</span> ( del(maxx, nums[i]) &lt; <span class="number">0</span>)</span><br><span class="line">                    maxx = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//泛型委托的应用</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">GetMaxT</span>&lt;<span class="title">T</span>&gt;(<span class="params">T[] nums, DelCompareT&lt;T&gt; del</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            T maxx = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(del(maxx, nums[i]) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxx = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CompareInt</span>(<span class="params"><span class="built_in">object</span> x, <span class="built_in">object</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> a = (<span class="built_in">int</span>)x;</span><br><span class="line">            <span class="built_in">int</span> b = (<span class="built_in">int</span>)y;</span><br><span class="line">            <span class="keyword">return</span> a - b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CompareIntNew</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x - y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CompareString</span>(<span class="params"><span class="built_in">object</span> x, <span class="built_in">object</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> s1 = (<span class="built_in">string</span>)x;</span><br><span class="line">            <span class="built_in">string</span> s2 = (<span class="built_in">string</span>)y;</span><br><span class="line">            <span class="keyword">return</span> s1.Length - s2.Length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CompareStringNew</span>(<span class="params">String x, <span class="built_in">string</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x.Length - y.Length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="使用委托的时机"><a href="#使用委托的时机" class="headerlink" title="使用委托的时机"></a>使用委托的时机</h2><p>​	委托和接口都允许类设计器分离类型声明和实现。 任何<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/0b0thckt(v=vs.100)">类</a>或<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/ah19swz4(v=vs.100)">结构</a>都能继承和实现给定的<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/87d83y5b(v=vs.100)">接口</a>。 可以为任何类上的方法创建<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/900fyy8e(v=vs.100)">委托</a>，前提是该方法符合委托的方法签名。 接口引用或委托可由不了解实现该接口或委托方法的类的对象使用。 既然存在这些相似性，那么类设计器何时应使用委托，何时又该使用接口呢？</p>
<p>在以下情况下，请使用委托：</p>
<ul>
<li>当使用事件设计模式时。</li>
<li>当封装静态方法可取时。</li>
<li>当调用方不需要访问实现该方法的对象中的其他属性、方法或接口时。</li>
<li>需要方便的组合。</li>
<li>当类可能需要该方法的多个实现时。</li>
</ul>
<p>在以下情况下，请使用接口：</p>
<ul>
<li>当存在一组可能被调用的相关方法时。</li>
<li>当类只需要方法的单个实现时。</li>
<li>当使用接口的类想要将该接口强制转换为其他接口或类类型时。</li>
<li>当正在实现的方法链接到类的类型或标识时：例如比较方法。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/zh-cn/library/ey2t2ys5(v=vs.100)">IComparable</a> 或泛型版本 <a target="_blank" rel="noopener" href="https://msdn.microsoft.com/zh-cn/library/4d7sx9hd(v=vs.100)">IComparable</a> 就是一个使用单一方法接口而不使用委托的很好的示例。 <strong>IComparable</strong> 声明 <a target="_blank" rel="noopener" href="https://msdn.microsoft.com/zh-cn/library/4ah99705(v=vs.100)">CompareTo</a> 方法，该方法返回一个整数，指定相同类型的两个对象之间的小于、等于或大于关系。 <strong>IComparable</strong> 可用作排序算法的基础。 虽然将委托比较方法用作排序算法的基础是有效的，但是并不理想。 因为进行比较的能力属于类，而比较算法不会在运行时改变，所以单一方法接口是理想的。</p>
<p>来源：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/ms173173(v=vs.100)">https://learn.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/ms173173(v=vs.100)</a></p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>纵然匿名方法使用很方便，可惜她很快就成了过气网红，没能领多长时间的风骚。如今已经很少见到了，因为delegate关键字限制了她用途的扩展。自从C# 3.0开始，她就被Lambda表达式取代，而且Lambda表达式用起来更简单。<strong>Lambda表达式本质上是改进的匿名方法。</strong></p>
<h3 id="表达式Lambda"><a href="#表达式Lambda" class="headerlink" title="表达式Lambda"></a>表达式Lambda</h3><p>当匿名函数只有一行代码时，可采用这种形式。例如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">MyCalculator myCal = (num1, num2) =&gt;  num1 + num2;</span><br><span class="line"><span class="built_in">int</span> num = myCal(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>其中<code>=&gt;</code>符号代表Lambda表达式，它的左侧是参数，右侧是要返回或执行的语句。参数要放在圆括号中，若只有一个参数，为了方便起见可省略圆括号。有多个参数或者没有参数时，不可省略圆括号。<br>相比匿名函数，在表达式Lambda中，方法体的花括号{}和return关键字被省略掉了。</p>
<h3 id="语句Lambda"><a href="#语句Lambda" class="headerlink" title="语句Lambda"></a>语句Lambda</h3><p>当匿名函数有多行代码时，只能采用语句Lambda。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">MyCalculator myCal = (<span class="built_in">int</span> num1, <span class="built_in">int</span> num2)=&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(System.Reflection.MethodBase.GetCurrentMethod().Name);</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">int</span> num = myCal(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>语句Lambda不可以省略{}和return语句。</p>
<h3 id="Lambda的主要用处"><a href="#Lambda的主要用处" class="headerlink" title="Lambda的主要用处"></a>Lambda的主要用处</h3><p>实际中用到Lambda表达式的地方大都是委托，例如linq的对集合类的扩展查询方法；<br>很多架构的搭建需要调用自定义方法，也离不开委托；<br>事件机制是基于委托的；<br>等等。</p>
<h3 id="Lambda样例"><a href="#Lambda样例" class="headerlink" title="Lambda样例"></a>Lambda样例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Lambda</span>表达式</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">DelOne</span>()</span>;<span class="comment">//没有参数，没有返回值的委托</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">DelTwo</span>(<span class="params"><span class="built_in">string</span> str</span>)</span>;<span class="comment">//有参数，但没有返回值的委托</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">string</span> <span class="title">DelThree</span>(<span class="params"><span class="built_in">string</span> str</span>)</span>;<span class="comment">//有参数，也有返回值的委托</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//使用lambda表达式创建三个对应的委托</span></span><br><span class="line">            DelOne d1 = () =&gt; &#123; Console.WriteLine(<span class="string">&quot;这是一个没有参数 没有返回值的Lambda表达式&quot;</span>); &#125;;</span><br><span class="line">            DelTwo d2 = (<span class="built_in">string</span> name) =&gt; &#123; Console.WriteLine(<span class="string">&quot;这是一个有参数但没有返回值的Lambda表达式，值为：&quot;</span> + name); &#125;;</span><br><span class="line">            DelThree d3 = (<span class="built_in">string</span> name) =&gt; &#123; Console.WriteLine(<span class="string">&quot;这是一个具有参数和返回值委托&quot;</span>); <span class="keyword">return</span> <span class="string">&quot;hello,&quot;</span> + name; &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用三个委托</span></span><br><span class="line">            d1();</span><br><span class="line">            d2(<span class="string">&quot;hurr&quot;</span>);</span><br><span class="line">            Console.WriteLine(d3(<span class="string">&quot;hurr&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="样例2：移除指定集合的元素"><a href="#样例2：移除指定集合的元素" class="headerlink" title="样例2：移除指定集合的元素"></a>样例2：移除指定集合的元素</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="type">int</span>&gt; <span class="built_in">list</span> = new List&lt;<span class="type">int</span>&gt;() &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="built_in">list</span>.RemoveAll(n =&gt; n &gt; <span class="number">4</span>);<span class="comment">//使用lambda表达式来确定删除的范围。范围是大于4的元素</span></span><br><span class="line">foreach (<span class="type">int</span> i in <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="C-事件（Event）"><a href="#C-事件（Event）" class="headerlink" title="C# 事件（Event）"></a>C# 事件（Event）</h1><h2 id="事件的概述"><a href="#事件的概述" class="headerlink" title="事件的概述"></a>事件的概述</h2><p>​	事件（Event） 基本上说是一个<strong>用户操作</strong>，如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件。例如，中断。</p>
<p>事件可以感知发生了什么事情，</p>
<p>事件 使 对象或类具备了<strong>通知能力</strong>的成员。</p>
<p>​	事件本身不会主动通知别的对象或类，事件的拥有者在完成某个逻辑的之后，明确的告诉事件成员通知其他人的时候，才会进行通知。即事件不会主动发声，当被拥有者的某些内部逻辑触发后，才能够发声。</p>
<p>事件的功能 &#x3D; 通知 + 可选的事件参数（详细信息）</p>
<p>事件的使用时机：</p>
<p>​	用于对象或类之间的动作协调与信息传递（消息推送）</p>
<p>​	C# 中使用<strong>事件机制实现线程间的通信</strong>。</p>
<h3 id="事件模型（发生-相应模型）"><a href="#事件模型（发生-相应模型）" class="headerlink" title="事件模型（发生-相应模型）"></a>事件模型（发生-相应模型）</h3><h4 id="事件的组成部分"><a href="#事件的组成部分" class="headerlink" title="事件的组成部分"></a>事件的组成部分</h4><ul>
<li>事件的拥有者（event source， 对象）</li>
<li>事件成员（event，成员）</li>
<li>事件的响应者（event subscriber，对象）</li>
<li>事件处理器（event handler， 成员）<ul>
<li>本质是一个回调方法</li>
</ul>
</li>
<li>事件订阅<ul>
<li>把事件处理器和事件关联在一起，本质上是一种以委托类型为基础的“约定”</li>
</ul>
</li>
</ul>
<p>发布器（publisher）(事件的拥有者) </p>
<p>​	发布器是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器（publisher）类的对象调用这个事件，并通知其他的对象。</p>
<p>订阅器（事件的响应者）</p>
<p>​	订阅器（subscriber） 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器（subscriber）类中的方法（事件处理程序）。</p>
<h5 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>事件处理器是方法成员</li>
<li>挂接事件处理器的时候，可以使用委托实例，也可以直接使用方法名（语法糖）</li>
<li>事件处理器对事件的订阅不是随意的，匹配与否由声明事件时所使用的委托类型来检测。<ul>
<li>用于订阅这个事件的事件处理器必须和事件遵循同一个约定，这个约定既约束了事件能够把什么样的消息发送给事件处理器，也约束了事件的处理器能够处理什么样的消息。</li>
<li>如果事件是使用某个约定定义的，而且事件处理器也遵循同样的约定，那就可以说事件处理器与事件是匹配的，就可以拿这个事件处理器去订阅这个事件。</li>
<li>如果提供的事件处理器与想订阅的事件没有遵循同一个约定，那么此时就可以说这个事件处理器与事件是不匹配的。此时编译器就会报错。</li>
<li>这个约定，就是所说的委托。</li>
</ul>
</li>
<li>事件可以同步调用也可以异步调用。</li>
</ul>
<h4 id="发生-响应的五个动作："><a href="#发生-响应的五个动作：" class="headerlink" title="发生-响应的五个动作："></a>发生-响应的五个动作：</h4><ol>
<li><p>我有一个事件</p>
</li>
<li><p>有人关心我这个事件（订阅）</p>
</li>
<li><p>我的事件发生了</p>
</li>
<li><p>关心事件的人依次被通知到</p>
</li>
<li><p>被通知到的人根据拿到事件信息（数据、参数、通知）对事件进行响应（处理时间）</p>
</li>
</ol>
<p>注意：以下几个术语表示的是同一个对象：</p>
<ul>
<li><p>事件的订阅者</p>
<ul>
<li>事件消息的接收者</li>
<li>事件的处理者</li>
<li>事件的响应者</li>
<li>被事件所通知的对象</li>
</ul>
</li>
<li><p>事件参数</p>
<ul>
<li>事件信息</li>
<li>事件消息</li>
<li>事件数据</li>
</ul>
</li>
</ul>
<h4 id="样例-25"><a href="#样例-25" class="headerlink" title="样例"></a>样例</h4><p>闹钟响了我起床了：</p>
<ul>
<li>闹钟：事件</li>
<li>响了：事件发生了</li>
<li>我：我被通知到了</li>
<li>起床：我根据通知到的信息（闹钟响了）做出响应（起床）</li>
<li>隐藏关系：订阅<ul>
<li>我订阅了这个闹钟，我才会被这个闹钟通知，就像我的闹钟不会通知别人起床一样，如果我没有订阅别人的闹钟，那么别人的闹钟响了我也不会去响应，</li>
</ul>
</li>
</ul>
<h3 id="事件的应用场景"><a href="#事件的应用场景" class="headerlink" title="事件的应用场景"></a>事件的应用场景</h3><ul>
<li>常用于开发客户端程序<ul>
<li>如桌面、手机等开发的客户端，这些程序常是用户通过事件来“驱动”</li>
</ul>
</li>
</ul>
<h3 id="事件的注意事项"><a href="#事件的注意事项" class="headerlink" title="事件的注意事项"></a>事件的注意事项</h3><ul>
<li>对于事件的机制各种语言的实现方法不尽相同</li>
<li>Java中没有事件这个成员，也没有委托。Java使用接口实现相应功能</li>
<li>MVC、MVP、MVVM等模式是事件模式的高级用法。<ul>
<li>事件模式本身也是一种设计模式</li>
</ul>
</li>
<li>经常使用已有的事件，自己声明事件的情况较少<ul>
<li>自己声明的场景：自定义控件</li>
</ul>
</li>
</ul>
<h2 id="事件的应用"><a href="#事件的应用" class="headerlink" title="事件的应用"></a>事件的应用</h2><h3 id="样例1-3"><a href="#样例1-3" class="headerlink" title="样例1"></a>样例1</h3><ul>
<li>创建一个事件拥有者Timer</li>
<li>创建两个事件响应者A和B</li>
<li>分别在响应者内部设置事件处理器<ul>
<li>名字自定义，不限于Action</li>
</ul>
</li>
<li>分别订阅时间拥有着的拥有的Elapsed事件<ul>
<li>订阅只能+&#x3D; 或 -&#x3D;</li>
</ul>
</li>
<li>开启事件<ul>
<li>Elapsed对应的开启方法为start</li>
</ul>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Timers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Timer timer = <span class="keyword">new</span> Timer();<span class="comment">//事件的拥有者</span></span><br><span class="line">            <span class="comment">//事件的图标是一个黄色的小闪电，此处用Elapsed演示：度过一段时间后就会触发。(小扳手是属性，小方块是方法)</span></span><br><span class="line">            timer.Interval = <span class="number">1000</span>;<span class="comment">//时间间隔1000ms，事件拥有者 拥有的 事件</span></span><br><span class="line"></span><br><span class="line">            A a = <span class="keyword">new</span> A();<span class="comment">//事件响应者</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建事件，并订阅事件，+=左边是事件，右边是事件响应者的事件处理器</span></span><br><span class="line">            <span class="comment">//事件订阅操作符： +=。只能是+= 或 -=，不能分开写</span></span><br><span class="line">            timer.Elapsed += a.Action;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            timer.Start();<span class="comment">//开启事件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            B b = <span class="keyword">new</span> B();<span class="comment">//再次创建一个事件的响应者</span></span><br><span class="line">            timer.Elapsed += b.Action;<span class="comment">//并订阅时间拥有着timer的Elapsed事件。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事件的响应者</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//自动生成的事件处理器（vs的修补功能）</span></span><br><span class="line">        <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"><span class="built_in">object</span> sender, ElapsedEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//throw new NotImplementedException();</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;+1s&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"><span class="built_in">object</span> sender, ElapsedEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Ohhhhh!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="样例2-事件的拥有者和事件的响应者是完全不同的两个对象"><a href="#样例2-事件的拥有者和事件的响应者是完全不同的两个对象" class="headerlink" title="样例2 事件的拥有者和事件的响应者是完全不同的两个对象"></a>样例2 事件的拥有者和事件的响应者是完全不同的两个对象</h3><p>VC、MVB设计模式的雏形。</p>
<p><img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/1677713203984.jpg" alt="1677713203984"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Form form = <span class="keyword">new</span> Form();<span class="comment">//事件的拥有者</span></span><br><span class="line"></span><br><span class="line">            Controller controller = <span class="keyword">new</span> Controller(form);<span class="comment">//事件的响应者</span></span><br><span class="line"></span><br><span class="line">            form.ShowDialog();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Controller</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> Form form;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Controller</span>(<span class="params">Form form</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(form == <span class="literal">null</span>) </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">&quot;form is null&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.form = form;</span><br><span class="line">                <span class="keyword">this</span>.form.Click += <span class="keyword">this</span>.FormClicked;<span class="comment">//事件 及 事件订阅</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//vs自动生成的事件处理器</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FormClicked</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//throw new NotImplementedException();</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.form.Text = DateTime.Now.ToString();<span class="comment">//当点击窗口时，让窗口的标题栏显示当前时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="样例3事件的拥有者和事件的响应者是同一个对象。"><a href="#样例3事件的拥有者和事件的响应者是同一个对象。" class="headerlink" title="样例3事件的拥有者和事件的响应者是同一个对象。"></a>样例3事件的拥有者和事件的响应者是同一个对象。</h3><p>即一个对象用自己的方法去订阅处理自己的事件。</p>
<p><img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/1677713203935.jpg" alt="1677713203935"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            MyForm myForm = <span class="keyword">new</span> MyForm();<span class="comment">//事件的拥有者和响应者</span></span><br><span class="line"></span><br><span class="line">            myForm.Click += myForm.FormClicked;<span class="comment">//事件订阅</span></span><br><span class="line"></span><br><span class="line">            myForm.ShowDialog();           </span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyForm_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">MyForm</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//事件处理器</span></span><br><span class="line">        <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">FormClicked</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.Text = DateTime.Now.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="样例4-事件的拥有者是事件响应者的一个字段成员，事件响应者用自己的方法订阅着自己字段成员的某个事件"><a href="#样例4-事件的拥有者是事件响应者的一个字段成员，事件响应者用自己的方法订阅着自己字段成员的某个事件" class="headerlink" title="样例4 事件的拥有者是事件响应者的一个字段成员，事件响应者用自己的方法订阅着自己字段成员的某个事件"></a>样例4 事件的拥有者是事件响应者的一个字段成员，事件响应者用自己的方法订阅着自己字段成员的某个事件</h3><p><img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/1677713203967.jpg" alt="1677713203967"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            MyForm myForm = <span class="keyword">new</span> MyForm();<span class="comment">//事件响应者</span></span><br><span class="line">            myForm.ShowDialog();</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">MyForm</span> : <span class="title">Form</span></span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">private</span> TextBox textBox;</span><br><span class="line">        <span class="keyword">private</span> Button button;<span class="comment">//事件的拥有者</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyForm</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.textBox = <span class="keyword">new</span> TextBox();</span><br><span class="line">            <span class="keyword">this</span>.button = <span class="keyword">new</span> Button();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使添加的按钮和文本框显示出来</span></span><br><span class="line">            <span class="keyword">this</span>.Controls.Add(textBox);</span><br><span class="line">            <span class="keyword">this</span>.Controls.Add(button);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.button.Click += <span class="keyword">this</span>.ButtonClicked;<span class="comment">//事件 事件订阅</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//美化</span></span><br><span class="line">            <span class="keyword">this</span>.button.Text = <span class="string">&quot;Say Hello&quot;</span>;</span><br><span class="line">            <span class="keyword">this</span>.button.Top = <span class="number">100</span>;<span class="comment">//按键的上边缘距离绘制窗口的顶端的距离</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//事件处理器</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ButtonClicked</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.textBox.Text = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="声明事件（Event）"><a href="#声明事件（Event）" class="headerlink" title="声明事件（Event）"></a>声明事件（Event）</h2><p>事件是基于委托的：</p>
<p>​	第一层：事件需要委托类型来做一个约束。约束既规定事件能发送什么样的消息给响应者，也规定事件响应者能收到什么样的事件消息。这就决定了事件响应者的事件处理器，必须能够和这个约束匹配上，才能够订阅这个事件。</p>
<p>​	第二层意思：当事件响应者向事件拥有者提供了能够匹配这个事件的事件处理器之后，需要把事件处理器保存或者记录下来。能够记录或者说引用方法的任务，只有委托类型的实例能够做到。</p>
<p>简而言之，只有委托能把五要素连起来</p>
<p>委托是事件的底层基础，事件是委托的上层建筑。</p>
<p>声明一个委托类型和声明一个委托类型的字段，都可以简化为声明一个委托。</p>
<p>如果形参含有ref out方法参数就用不了func和action委托</p>
<h3 id="完整声明-1"><a href="#完整声明-1" class="headerlink" title="完整声明"></a>完整声明</h3><h3 id="简略声明"><a href="#简略声明" class="headerlink" title="简略声明"></a>简略声明</h3><p>在类的内部声明事件，首先必须声明该事件的委托类型。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">BoilerLogHandler</span>(<span class="params"><span class="built_in">string</span> status</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>然后，声明事件本身，使用 event 关键字：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于上面的委托定义事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> BoilerLogHandler BoilerEventLog;</span><br></pre></td></tr></table></figure>

<p>上面的代码定义了一个名为 BoilerLogHandler 的委托和一个名为 BoilerEventLog 的事件，该事件在生成的时候会调用委托。</p>
<h2 id="样例-26"><a href="#样例-26" class="headerlink" title="样例"></a>样例</h2><h3 id="样例1-4"><a href="#样例1-4" class="headerlink" title="样例1"></a>样例1</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SimpleEvent</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> System;</span><br><span class="line">  <span class="comment">/***********发布器类***********/</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventTest</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">NumManipulationHandler</span>()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> NumManipulationHandler ChangeNum;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnNumChanged</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( ChangeNum != <span class="literal">null</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        ChangeNum(); <span class="comment">/* 事件被触发 */</span></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;event not fire&quot;</span> );</span><br><span class="line">        Console.ReadKey(); <span class="comment">/* 回车继续 */</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventTest</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">int</span> n = <span class="number">5</span>;</span><br><span class="line">      SetValue( n );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetValue</span>(<span class="params"> <span class="built_in">int</span> n </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="keyword">value</span> != n )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">value</span> = n;</span><br><span class="line">        OnNumChanged();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/***********订阅器类***********/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">subscribEvent</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printf</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine( <span class="string">&quot;event fire&quot;</span> );</span><br><span class="line">      Console.ReadKey(); <span class="comment">/* 回车继续 */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/***********触发***********/</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      EventTest e = <span class="keyword">new</span> EventTest(); <span class="comment">/* 实例化对象,第一次没有触发事件 */</span></span><br><span class="line">      subscribEvent v = <span class="keyword">new</span> subscribEvent(); <span class="comment">/* 实例化对象 */</span></span><br><span class="line">      e.ChangeNum += <span class="keyword">new</span> EventTest.NumManipulationHandler( v.printf ); <span class="comment">/* 注册 */</span></span><br><span class="line">      e.SetValue( <span class="number">7</span> );</span><br><span class="line">      e.SetValue( <span class="number">11</span> );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">event not fire</span><br><span class="line">event fire</span><br><span class="line">event fire</span><br></pre></td></tr></table></figure>



<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例 2"></a>实例 2</h3><p>本实例提供一个简单的用于热水锅炉系统故障排除的应用程序。当维修工程师检查锅炉时，锅炉的温度和压力会随着维修工程师的备注自动记录到日志文件中。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">BoilerEventAppl</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// boiler 类</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title">Boiler</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="built_in">int</span> temp;</span><br><span class="line">      <span class="keyword">private</span> <span class="built_in">int</span> pressure;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Boiler</span>(<span class="params"><span class="built_in">int</span> t, <span class="built_in">int</span> p</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         temp = t;</span><br><span class="line">         pressure = p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">getTemp</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">return</span> temp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">getPressure</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">return</span> pressure;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 事件发布器</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title">DelegateBoilerEvent</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">BoilerLogHandler</span>(<span class="params"><span class="built_in">string</span> status</span>)</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 基于上面的委托定义事件</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">event</span> BoilerLogHandler BoilerEventLog;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LogProcess</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">string</span> remarks = <span class="string">&quot;O. K&quot;</span>;</span><br><span class="line">         Boiler b = <span class="keyword">new</span> Boiler(<span class="number">100</span>, <span class="number">12</span>);</span><br><span class="line">         <span class="built_in">int</span> t = b.getTemp();</span><br><span class="line">         <span class="built_in">int</span> p = b.getPressure();</span><br><span class="line">         <span class="keyword">if</span>(t &gt; <span class="number">150</span> || t &lt; <span class="number">80</span> || p &lt; <span class="number">12</span> || p &gt; <span class="number">15</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            remarks = <span class="string">&quot;Need Maintenance&quot;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         OnBoilerEventLog(<span class="string">&quot;Logging Info:\n&quot;</span>);</span><br><span class="line">         OnBoilerEventLog(<span class="string">&quot;Temparature &quot;</span> + t + <span class="string">&quot;\nPressure: &quot;</span> + p);</span><br><span class="line">         OnBoilerEventLog(<span class="string">&quot;\nMessage: &quot;</span> + remarks);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">OnBoilerEventLog</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span> (BoilerEventLog != <span class="literal">null</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            BoilerEventLog(message);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 该类保留写入日志文件的条款</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title">BoilerInfoLogger</span></span><br><span class="line">   &#123;</span><br><span class="line">      FileStream fs;</span><br><span class="line">      StreamWriter sw;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">BoilerInfoLogger</span>(<span class="params"><span class="built_in">string</span> filename</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         fs = <span class="keyword">new</span> FileStream(filename, FileMode.Append, FileAccess.Write);</span><br><span class="line">         sw = <span class="keyword">new</span> StreamWriter(fs);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Logger</span>(<span class="params"><span class="built_in">string</span> info</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         sw.WriteLine(info);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Close</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">         sw.Close();</span><br><span class="line">         fs.Close();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 事件订阅器</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RecordBoilerInfo</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Logger</span>(<span class="params"><span class="built_in">string</span> info</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(info);</span><br><span class="line">      &#125;<span class="comment">//end of Logger</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         BoilerInfoLogger filelog = <span class="keyword">new</span> BoilerInfoLogger(<span class="string">&quot;e:\\boiler.txt&quot;</span>);</span><br><span class="line">         DelegateBoilerEvent boilerEvent = <span class="keyword">new</span> DelegateBoilerEvent();</span><br><span class="line">         boilerEvent.BoilerEventLog += <span class="keyword">new</span></span><br><span class="line">         DelegateBoilerEvent.BoilerLogHandler(Logger);</span><br><span class="line">         boilerEvent.BoilerEventLog += <span class="keyword">new</span></span><br><span class="line">         DelegateBoilerEvent.BoilerLogHandler(filelog.Logger);</span><br><span class="line">         boilerEvent.LogProcess();</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">         filelog.Close();</span><br><span class="line">      &#125;<span class="comment">//end of main</span></span><br><span class="line"></span><br><span class="line">   &#125;<span class="comment">//end of RecordBoilerInfo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Logging info:</span><br><span class="line"></span><br><span class="line">Temperature 100</span><br><span class="line">Pressure 12</span><br><span class="line"></span><br><span class="line">Message: O. K</span><br></pre></td></tr></table></figure>





<h1 id="集合、比较和转换"><a href="#集合、比较和转换" class="headerlink" title="集合、比较和转换"></a>集合、比较和转换</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>集合:可以使用集合来维护对象组。与前面章节使用的数组不同，集合可以包含更高级的功能，例如，控制对它们包含的对象的访问、搜索和排序等。本章将介绍如何使用和创建集合类，学习充分利用它们的一些强大技术。</li>
<li>比较:在处理对象时，常要比较它们。这对于集合尤其重要，因为这是排序的实现方式。本章将介绍如何以各种方式比较对象(包括运算符重载)，如何使用IComparable和IComparer接口对集合进行排序。</li>
<li>转换:前面的章节介绍了如何把对象从一*种类型转换为另- 种类型。 本章讨论如何定制类型转换，以满足自己的需要。</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>大多数集合都在System.Collections，System.Collections.Generic两个命名空间。其中System.Collections.Generic专门用于泛型集合。</p>
<p>针对特定类型的集合类型位于System.Collections.Specialized;命名空间；</p>
<p>线程安全的集合类位于System.Collections.Concurrent;命名空间。</p>
<p>System.Collections名称空间中的以下几个接口提供了基本的集合功能:</p>
<ul>
<li>IEnumerable：可以迭代集合中的项。</li>
<li>ICollection： 继承于IEnumerable。 可以获取集合中项的个数,并能把项复制到一个简单的数组类型中。</li>
<li>IList：继承于lEnumerable 和ICollection。 提供了集合的项列表，允许访问这些项，并提供其他- -些</li>
<li>与项列表相关的基本功能。</li>
<li>IDictionary：继 承于lEnumerable 和ICollection。 类似于IList,但提供了可通过键值(而不是索引)访问</li>
<li>的项列表。</li>
</ul>
<p>System.Array类实现了IList、ICollection 和lEnumerable,但不支持IList的- -些更高级功能，它表示大小固<br>定的项列表。</p>
<h3 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h3><p>集合（Collection）类是专门用于数据存储和检索的类。这些类提供了对栈（stack）、队列（queue）、列表（list）和哈希表（hash table）的支持。大多数集合类实现了相同的接口。</p>
<p>集合（Collection）类服务于不同的目的，如为元素动态分配内存，基于索引访问列表项等等。这些类创建 Object 类的对象的集合。在 C# 中，Object 类是所有数据类型的基类。</p>
<h3 id="集合和列表实现的接口"><a href="#集合和列表实现的接口" class="headerlink" title="集合和列表实现的接口"></a>集合和列表实现的接口</h3><table>
<thead>
<tr>
<th>接口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lEoumerable&lt;T&gt;</td>
<td>如果将foreach语句用于集合，就需要IEoumerable接口。这个接口定义了方法GetEoumerator0,它返回一个实现了IEnumerator接口的枚举</td>
</tr>
<tr>
<td>ICollection&lt;T&gt;</td>
<td>ICollection&lt;T&gt;接口由泛型集合类实现。使用这个接口可以获得集合中的元素个数(Count属性),把集合复制到数组中(CopyTo0方法),还可以从集合中添加和删除元素(Add0, Remove),Clear()</td>
</tr>
<tr>
<td>IList&lt;T&gt;</td>
<td>IList<T>接口用于可通过位置访问其中的元素列表，这个接口定义了-个索引器，可以在集合的指定位置插入或删除某些项(nsert0和RemoveAt0方法)lList<T>接口派生自LCollction<T>接口</td>
</tr>
<tr>
<td>ISet&lt;T&gt;</td>
<td>ISet<T>接口是.NET 4中新增的。实现这个接口的集允许合并不同的集，获得两个集的交集，检查两个集是否重叠。ISet<T>接口派生自lCollection<T>接口</td>
</tr>
<tr>
<td>IDictionary&lt;TKey,TValue&gt;</td>
<td>IDictionary&lt;TKey,TValue&gt;接口由包含键和值的泛型集合类实现。使用这个接口可以访问所有的键和值，使用键类型的索引器可以访问某些项，还可以添加或删除某些项</td>
</tr>
<tr>
<td>ILookup&lt;TKey,Tvalue&gt;</td>
<td>lLookup&lt;TKey,Tvalue&gt;接口类似于Dictionary&lt;IKey,TValue &gt;接口,实现该接口的集合有键和值，且可以通过一个键包含多个值</td>
</tr>
<tr>
<td>IComparer &lt;T&gt;</td>
<td>接口IComparer <T>由比较器实现，通过Compare()方法给集合中的元素排序</td>
</tr>
<tr>
<td>IEqualityComparer&lt;T&gt;</td>
<td>接口IEqualityComparer<T>由一个比较器实现，该比较器可用于字典中的键。使用这个接口,可以对对象进行相等性比较。在.NET4中，这个接口也由数组和元组实现</td>
</tr>
<tr>
<td>IProducerConsumerCollection&lt;I&gt;</td>
<td>IProducerConsumerCollection<I>接口是.NET4中新增的，它支持新的线程安全的集合类</td>
</tr>
</tbody></table>
<h3 id="各种集合类和它们的用法"><a href="#各种集合类和它们的用法" class="headerlink" title="各种集合类和它们的用法"></a>各种集合类和它们的用法</h3><table>
<thead>
<tr>
<th align="left">类</th>
<th align="left">描述和用法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-arraylist.html">动态数组（ArrayList）</a></td>
<td align="left">它代表了可被单独<strong>索引</strong>的对象的有序集合。它基本上可以替代一个数组。但是，与数组不同的是，您可以使用<strong>索引</strong>在指定的位置添加和移除项目，动态数组会自动重新调整它的大小。它也允许在列表中进行动态内存分配、增加、搜索、排序各项。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-hashtable.html">哈希表（Hashtable）</a></td>
<td align="left">它使用<strong>键</strong>来访问集合中的元素。当您使用键访问元素时，则使用哈希表，而且您可以识别一个有用的键值。哈希表中的每一项都有一个<strong>键&#x2F;值</strong>对。键用于访问集合中的项目。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-sortedlist.html">排序列表（SortedList）</a></td>
<td align="left">它可以使用<strong>键</strong>和<strong>索引</strong>来访问列表中的项。排序列表是数组和哈希表的组合。它包含一个可使用键或索引访问各项的列表。如果您使用索引访问各项，则它是一个动态数组（ArrayList），如果您使用键访问各项，则它是一个哈希表（Hashtable）。集合中的各项总是按键值排序。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-stack.html">堆栈（Stack）</a></td>
<td align="left">它代表了一个<strong>后进先出</strong>的对象集合。当您需要对各项进行后进先出的访问时，则使用堆栈。当您在列表中添加一项，称为<strong>推入</strong>元素，当您从列表中移除一项时，称为<strong>弹出</strong>元素。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-queue.html">队列（Queue）</a></td>
<td align="left">它代表了一个<strong>先进先出</strong>的对象集合。当您需要对各项进行先进先出的访问时，则使用队列。当您在列表中添加一项，称为<strong>入队</strong>，当您从列表中移除一项时，称为<strong>出队</strong>。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-bitarray.html">点阵列（BitArray）</a></td>
<td align="left">它代表了一个使用值 1 和 0 来表示的<strong>二进制</strong>数组。当您需要存储位，但是事先不知道位数时，则使用点阵列。您可以使用<strong>整型索引</strong>从点阵列集合中访问各项，索引从零开始。</td>
</tr>
</tbody></table>
<h3 id="使用简单集合"><a href="#使用简单集合" class="headerlink" title="使用简单集合"></a>使用简单集合</h3><p>本部分中的示例使用泛型 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1">List</a> 类，通过此类可使用对象的强类型列表。</p>
<p>以下示例创建字符串列表，并通过使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">foreach</a> 语句循环访问字符串。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a list of strings.</span></span><br><span class="line"><span class="keyword">var</span> salmons = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">salmons.Add(<span class="string">&quot;chinook&quot;</span>);</span><br><span class="line">salmons.Add(<span class="string">&quot;coho&quot;</span>);</span><br><span class="line">salmons.Add(<span class="string">&quot;pink&quot;</span>);</span><br><span class="line">salmons.Add(<span class="string">&quot;sockeye&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate through the list.</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> salmon <span class="keyword">in</span> salmons)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(salmon + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output: chinook coho pink sockeye</span></span><br></pre></td></tr></table></figure>

<p>如果集合中的内容是事先已知的，则可以使用集合初始值设定项来初始化集合。 </p>
<p>以下示例与上一示例相同，除了有一个集合初始值设定项用于将元素添加到集合</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a list of strings by using a</span></span><br><span class="line"><span class="comment">// collection initializer.</span></span><br><span class="line"><span class="keyword">var</span> salmons = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;chinook&quot;</span>, <span class="string">&quot;coho&quot;</span>, <span class="string">&quot;pink&quot;</span>, <span class="string">&quot;sockeye&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate through the list.</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> salmon <span class="keyword">in</span> salmons)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(salmon + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output: chinook coho pink sockeye</span></span><br></pre></td></tr></table></figure>

<p>可以使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">for</a> 语句，而不是 <code>foreach</code> 语句来循环访问集合。 通过按索引位置访问集合元素实现此目的。 元素的索引开始于 0，结束于元素计数减 1。</p>
<p>以下示例通过使用 <code>for</code> 而不是 <code>foreach</code> 循环访问集合中的元素。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a list of strings by using a</span></span><br><span class="line"><span class="comment">// collection initializer.</span></span><br><span class="line"><span class="keyword">var</span> salmons = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;chinook&quot;</span>, <span class="string">&quot;coho&quot;</span>, <span class="string">&quot;pink&quot;</span>, <span class="string">&quot;sockeye&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; salmons.Count; index++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(salmons[index] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output: chinook coho pink sockeye</span></span><br></pre></td></tr></table></figure>

<p>以下示例通过指定要删除的对象，从集合中删除一个元素。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a list of strings by using a</span></span><br><span class="line"><span class="comment">// collection initializer.</span></span><br><span class="line"><span class="keyword">var</span> salmons = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;chinook&quot;</span>, <span class="string">&quot;coho&quot;</span>, <span class="string">&quot;pink&quot;</span>, <span class="string">&quot;sockeye&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove an element from the list by specifying</span></span><br><span class="line"><span class="comment">// the object.</span></span><br><span class="line">salmons.Remove(<span class="string">&quot;coho&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate through the list.</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> salmon <span class="keyword">in</span> salmons)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(salmon + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output: chinook pink sockeye</span></span><br></pre></td></tr></table></figure>

<p>以下示例从一个泛型列表中删除元素。 使用以降序进行循环访问的 <code>for</code> 语句，而非 <code>foreach</code> 语句。 这是因为 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1.removeat">RemoveAt</a> 方法将导致已移除的元素后的元素的索引值减小。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove odd numbers.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = numbers.Count - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers[index] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Remove the element by specifying</span></span><br><span class="line">        <span class="comment">// the zero-based index in the list.</span></span><br><span class="line">        numbers.RemoveAt(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历列表</span></span><br><span class="line"><span class="comment">// 一个lambda表达式被放置在ForEach方法中</span></span><br><span class="line"><span class="comment">// of the List(T) object.</span></span><br><span class="line">numbers.ForEach(</span><br><span class="line">    number =&gt; Console.Write(number + <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">// Output: 0 2 4 6 8</span></span><br></pre></td></tr></table></figure>

<p>对于 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1">List</a> 中的元素类型，还可以定义自己的类。 在下面的示例中，由 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1">List</a> 使用的 <code>Galaxy</code> 类在代码中定义。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IterateThroughList</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> theGalaxies = <span class="keyword">new</span> List&lt;Galaxy&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Galaxy() &#123; Name=<span class="string">&quot;Tadpole&quot;</span>, MegaLightYears=<span class="number">400</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> Galaxy() &#123; Name=<span class="string">&quot;Pinwheel&quot;</span>, MegaLightYears=<span class="number">25</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> Galaxy() &#123; Name=<span class="string">&quot;Milky Way&quot;</span>, MegaLightYears=<span class="number">0</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> Galaxy() &#123; Name=<span class="string">&quot;Andromeda&quot;</span>, MegaLightYears=<span class="number">3</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (Galaxy theGalaxy <span class="keyword">in</span> theGalaxies)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(theGalaxy.Name + <span class="string">&quot;  &quot;</span> + theGalaxy.MegaLightYears);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">//  Tadpole  400</span></span><br><span class="line">    <span class="comment">//  Pinwheel  25</span></span><br><span class="line">    <span class="comment">//  Milky Way  0</span></span><br><span class="line">    <span class="comment">//  Andromeda  3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Galaxy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MegaLightYears &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















<h3 id="集合的类型"><a href="#集合的类型" class="headerlink" title="集合的类型"></a>集合的类型</h3><p>许多通用集合由 .NET 提供。 每种类型的集合用于特定的用途。</p>
<p>本部分介绍了一些通用集合类：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic">System.Collections.Generic</a> 类</li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent">System.Collections.Concurrent</a> 类</li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections">System.Collections</a> 类</li>
</ul>
<h4 id="System-Collections-Generic-类"><a href="#System-Collections-Generic-类" class="headerlink" title="System.Collections.Generic 类"></a>System.Collections.Generic 类</h4><p>可以使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic">System.Collections.Generic</a> 命名空间中的某个类来创建泛型集合。 当集合中的所有项都具有相同的数据类型时，泛型集合会非常有用。 泛型集合通过仅允许添加所需的数据类型，强制实施强类型化。</p>
<p>下表列出了 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic">System.Collections.Generic</a> 命名空间中的一些常用类：</p>
<table>
<thead>
<tr>
<th align="left">类</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.dictionary-2">Dictionary</a></td>
<td align="left">表示基于键进行组织的键&#x2F;值对的集合。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1">List</a></td>
<td align="left">表示可按索引访问的对象的列表。 提供用于对列表进行搜索、排序和修改的方法。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.queue-1">Queue</a></td>
<td align="left">表示对象的先进先出 (FIFO) 集合。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.sortedlist-2">SortedList</a></td>
<td align="left">表示基于相关的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.icomparer-1">IComparer</a> 实现按键进行排序的键&#x2F;值对的集合。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.stack-1">Stack</a></td>
<td align="left">表示对象的后进先出 (LIFO) 集合。</td>
</tr>
</tbody></table>
<p>有关其他信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/standard/collections/commonly-used-collection-types">常用集合类型</a>、<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/standard/collections/selecting-a-collection-class">选择集合类</a>和 。</p>
<h4 id="System-Collections-Concurrent-类"><a href="#System-Collections-Concurrent-类" class="headerlink" title="System.Collections.Concurrent 类"></a>System.Collections.Concurrent 类</h4><p>在 .NET Framework 4 以及更新的版本中，<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent">System.Collections.Concurrent</a> 命名空间中的集合可提供高效的线程安全操作，以便从多个线程访问集合项。</p>
<p>只要多个线程同时访问集合，就应使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent">System.Collections.Concurrent</a> 命名空间中的类，而不是 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic">System.Collections.Generic</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections">System.Collections</a> 命名空间中的相应类型。 有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/standard/collections/thread-safe/">线程安全集合</a>和 。</p>
<p>包含在 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent">System.Collections.Concurrent</a> 命名空间中的一些类为 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.blockingcollection-1">BlockingCollection</a>、<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentdictionary-2">ConcurrentDictionary</a>、<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentqueue-1">ConcurrentQueue</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentstack-1">ConcurrentStack</a>。</p>
<h4 id="System-Collections-类"><a href="#System-Collections-类" class="headerlink" title="System.Collections 类"></a>System.Collections 类</h4><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections">System.Collections</a> 命名空间中的类不会将元素作为特别类型化的对象存储，而是作为 <code>Object</code> 类型的对象存储。</p>
<p>只要可能，则应使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic">System.Collections.Generic</a> 命名空间或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent">System.Collections.Concurrent</a> 命名空间中的泛型集合，而不是 <code>System.Collections</code> 命名空间中的旧类型。</p>
<p>下表列出了 <code>System.Collections</code> 命名空间中的一些常用类：</p>
<table>
<thead>
<tr>
<th align="left">类</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.arraylist">ArrayList</a></td>
<td align="left">表示对象的数组，这些对象的大小会根据需要动态增加。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.hashtable">Hashtable</a></td>
<td align="left">表示根据键的哈希代码进行组织的键&#x2F;值对的集合。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.queue">Queue</a></td>
<td align="left">表示对象的先进先出 (FIFO) 集合。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.stack">Stack</a></td>
<td align="left">表示对象的后进先出 (LIFO) 集合。</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.specialized">System.Collections.Specialized</a> 命名空间提供专门类型化以及强类型化的集合类，例如只包含字符串的集合以及链接列表和混合字典。</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>​	在C#中，ArrayList是一个非泛型的对象集合，其大小会动态增加。它与数组相同，除了它的大小会动态增加。当不知道数据的类型和大小时，可以使用ArrayList添加未知数据。</p>
<p>​	创建ArrayList时，需要引入包含ArrayList类的命名空间<code>System.Collections</code>。可以使用<code>new</code>关键字创建<code>ArrayList</code>对象。例如：使用ArrayList arlist &#x3D; new ArrayList();</p>
<p>​	ArrayList可以包含多个null和重复值。</p>
<p>​	Insert 和 InsertRange的区别：（也适用于Add的两个方法）</p>
<ul>
<li>Insert只能插入一个元素，InsertRange可以插入一堆元素</li>
<li>如果使用Insert插入一个数组如<code>arrayList.Insert(0, new int[]{0, 0, 0});</code>，则表示将数组作为一个整体插入。如执行上面的语句，则表示插入一个<code>int[]</code>类型的元素</li>
<li>如果使用<code>InsertRange</code>插入一个数组，如<code>arrayList.InsertRange(1, new int[] { -1, -1, -1 });</code>,则表示将数组中的元素逐个添加到集合中。相当于执行了3次插入，每次插入“-1”。</li>
</ul>
<p>​	访问ArrayList时，可以使用索引器，与数组相同。索引从零开始，并且每个后续元素都会增加一。当需要访问其中的数据时，需要显式转换为适当的类型，或使用var变量。</p>
<p>​	迭代ArrayList时，可以使用foreach和for循环。ArrayList的Count属性返回ArrayList中元素的总数。</p>
<p>​	相对于数组，ArrayList的优点在于它是一个动态的、可调整大小的对象集合。它的大小可以根据需要动态增加或减少。这意味着不需要预先指定ArrayList的大小，而可以根据需要添加或删除元素。此外，ArrayList可以存储不同类型的数据，而数组只能存储特定类型的数据。</p>
<p>​	<strong>然而，由于ArrayList不是强类型的，因此每次插入或检索都需要进行类型转换。此外，当ArrayList达到其容量时，它会动态扩展其内部数组的大小，这会带来一些性能损失</strong>。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建了一个集合对象</span></span><br><span class="line">            ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据里氏转换原则，如果一个地方需要父类，可以使用一个子类代替。</span></span><br><span class="line">            <span class="comment">// 因为ArrayList里面存放的元素是Object类型的，而所有元素都是继承于Object，因此可以存放任何的元素到ArrayList。</span></span><br><span class="line">            <span class="comment">// 属于拆箱和装箱。</span></span><br><span class="line">            arrayList.Add(<span class="number">1</span>);<span class="comment">// 存放一个int</span></span><br><span class="line">            arrayList.Add(<span class="string">&quot;Hello World!&quot;</span>);<span class="comment">// 存放一个string</span></span><br><span class="line">            arrayList.Add(<span class="number">1</span>);<span class="comment">//可以存放重复值</span></span><br><span class="line">            arrayList.Add(<span class="literal">null</span>);<span class="comment">//null也可以放进去。</span></span><br><span class="line">            arrayList.Add(<span class="keyword">new</span> Person());<span class="comment">//自定义类型也可以。</span></span><br><span class="line">            arrayList.Add(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);<span class="comment">//甚至数组也可以。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除集合中的元素</span></span><br><span class="line">            arrayList.Remove(<span class="number">1</span>);<span class="comment">//通过元素删除 删除第一次出现的这个元素。</span></span><br><span class="line">            arrayList.RemoveAt(<span class="number">2</span>);<span class="comment">// 通过下标进行删除（从0起）。</span></span><br><span class="line">            arrayList.RemoveRange(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 删除指定范围的元素。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在指定的位置插入一个元素。</span></span><br><span class="line">            arrayList.Insert(<span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);<span class="comment">//在指定的位置插入一个元素</span></span><br><span class="line">            arrayList.InsertRange(<span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;);<span class="comment">// 在指定的集合插入一个元素</span></span><br><span class="line">            <span class="comment">// Insert 和 InsertRange的区别：（也适用于Add的两个方法）</span></span><br><span class="line">            <span class="comment">// 前者只会插入一个元素（如果插入数组，则将整个数组视为一个整体插入）</span></span><br><span class="line">            <span class="comment">// 后者只能插入一个集合或数组，并将数组中的元素依次插入</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            arrayList.Add(<span class="string">&quot;over&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 可以通过count属性来获取ArrayList的长度。</span></span><br><span class="line">            <span class="comment">// 可以使用foreach实现此功能。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arrayList.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> item = arrayList[i];<span class="comment">//调用的时候需要显示的转换成为目标类型。</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (item <span class="keyword">is</span> Person)</span><br><span class="line">                &#123;</span><br><span class="line">                    ((Person)item).Say();<span class="comment">//如果当前类型可以显示转换为Person类，则调用其中的Say方法。</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">is</span> <span class="built_in">int</span>[])<span class="comment">//如果当前元素是数组，则遍历数组</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> x <span class="title">in</span> (<span class="params"><span class="built_in">int</span>[]</span>)item)</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.Write(x + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Console.WriteLine();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(item); <span class="comment">//如果是简单类型，自动调用了ToString方法</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Say</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;this is Person&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="ArrayList分配空间的方式"><a href="#ArrayList分配空间的方式" class="headerlink" title="ArrayList分配空间的方式"></a>ArrayList分配空间的方式</h4><p>ArrayList类使用内部的T []数组来实现。如果使用List&lt;T&gt; (int)构造函数进行初始化，它将分配指定大小的数组。如果使用默认构造函数，它将使用默认容量4，但在这种情况下，数组只会在第一次添加时分配。每次向列表中添加元素时，它首先检查容量是否已达到（即现有计数是否等于容量）。如果是，则创建一个新的大小为前一个数组两倍的新数组，将所有现有元素复制到其中，然后继续写入新元素。这将一直持续下去，直到达到您引用的硬限制（Int32.MaxValue）。</p>
<p>​	也就是说 初始插入数据的时候分配4个空间，以后的每次超限都会将空间扩大一倍。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 创建了一个集合对象</span></span><br><span class="line">            ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * count:表示这个集合中实际包含的元素的个数。</span></span><br><span class="line"><span class="comment">             * capcity：表示这个集合中可以包含的元素的个数。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当其中没有元素的时候，实际包含的和可包含的都是0.</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;未添加数据时&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;arrayList.Count:&quot;</span> + arrayList.Count);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;arrayList.Capacity:&quot;</span> + arrayList.Capacity);</span><br><span class="line"></span><br><span class="line">            arrayList.Add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加了一个数据之后，实际包含的个数变成了1，可包含的个数变成了4</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;只添加一个数据时&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;arrayList.Count:&quot;</span> + arrayList.Count);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;arrayList.Capacity:&quot;</span> + arrayList.Capacity);</span><br><span class="line"></span><br><span class="line">            arrayList.Add(<span class="number">1</span>); arrayList.Add(<span class="number">1</span>); arrayList.Add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加了4个数据之后，实际包含的个数变成了4，可包含的个数变成了4</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;添加了4个数据时&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;arrayList.Count:&quot;</span> + arrayList.Count);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;arrayList.Capacity:&quot;</span> + arrayList.Capacity);</span><br><span class="line"></span><br><span class="line">            arrayList.Add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//再次添加了一个数据之后，实际包含的个数变成了5，可包含的个数变成了8</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;添加了5个数据时&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;arrayList.Count:&quot;</span> + arrayList.Count);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;arrayList.Capacity:&quot;</span> + arrayList.Capacity);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 再次实验 使得其中的数量再次超界</span></span><br><span class="line">            arrayList.Add(<span class="number">1</span>); arrayList.Add(<span class="number">1</span>); arrayList.Add(<span class="number">1</span>); arrayList.Add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 可以看到 可包含的个数达到16个了。</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;添加了9个数据时&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;arrayList.Count:&quot;</span> + arrayList.Count);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;arrayList.Capacity:&quot;</span> + arrayList.Capacity);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 也就是说 初始插入数据的时候分配4个空间，以后的每次超限都会将空间扩大一倍</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="键-值对集合（Hashtable）"><a href="#键-值对集合（Hashtable）" class="headerlink" title="键&#x2F;值对集合（Hashtable）"></a>键&#x2F;值对集合（Hashtable）</h3><p>根据键去找值。键和值一一对应。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 声明一个键值对</span></span><br><span class="line">            Hashtable ht = <span class="keyword">new</span> Hashtable();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加元素</span></span><br><span class="line">            ht.Add(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>);<span class="comment">// 前者是键，后者是值。</span></span><br><span class="line">            ht.Add(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            ht.Add(<span class="number">3</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">            ht.Add(<span class="literal">false</span>, <span class="string">&quot;错误&quot;</span>);<span class="comment">//任何类型均可作为键或值，因为所需的参数是Object类型。</span></span><br><span class="line">            <span class="comment">//ht.Add(3, &quot;王六&quot;);// 当发生值重复的时候，会抛出异常System.ArgumentException:“Item has already been added. Key in dictionary: &#x27;3&#x27;  Key being added: &#x27;3&#x27;”</span></span><br><span class="line">            ht[<span class="number">4</span>] = <span class="string">&quot;王六&quot;</span>;<span class="comment">// 也可以使用这种方式来添加数据</span></span><br><span class="line">            ht[<span class="number">4</span>] = <span class="string">&quot;王七&quot;</span>;<span class="comment">// 此时可以避免因键重复而导致的异常。</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 访问元素</span></span><br><span class="line">            <span class="comment">// 在键值对集合中，是通过键去找值的。</span></span><br><span class="line">            <span class="comment">// 因此，在键值对集合中，键必须是唯一的，而值可以重复。</span></span><br><span class="line">            <span class="comment">//Console.WriteLine(ht[false]); //根据键 false 去寻找对应的值，然后输出值。 可以看到 这里输出了“错误”</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因此，在键值对集合中，不能用for循环来遍历。只能用forweach遍历。具体方法如下：</span></span><br><span class="line">            <span class="comment">// 需要注意的是，如果使用foreach进行遍历，其顺序是与添加顺序相逆的。</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> ht.Keys)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(ht[item]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//或者直接遍历值。</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> ht.Values)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(item);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Console.WriteLine(); Console.WriteLine();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;常用方法演示&quot;</span>);</span><br><span class="line">            <span class="comment">// hashtable常用的一些方法：</span></span><br><span class="line">            <span class="comment">// 插入数据前判断一下要插入的“键”是否是已存在的</span></span><br><span class="line">            <span class="keyword">if</span> (!ht.ContainsKey(<span class="string">&quot;abc&quot;</span>))<span class="comment">// 如果键值对集合中不存在键为abc的对，</span></span><br><span class="line">            &#123;</span><br><span class="line">                ht.Add(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>);<span class="comment">// 则添加abc -&gt; cba的键值对</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//删除键值对中的指定元素</span></span><br><span class="line">            ht.Remove(<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> ht.Values)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(item);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 清空键值对集合</span></span><br><span class="line">            ht.Clear();</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            Console.WriteLine(); Console.WriteLine();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;注意事项部分：&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//注意事项</span></span><br><span class="line">            Console.WriteLine(ht.ContainsKey(<span class="number">0</span>));<span class="comment">//查看一下是否存在键为0的键值对</span></span><br><span class="line">            Console.WriteLine(ht[<span class="number">0</span>]);<span class="comment">//在不存在的前提下方法一下这个键值对</span></span><br><span class="line">            Console.WriteLine(ht.ContainsKey(<span class="number">0</span>));<span class="comment">//此时可以发现。如果不存在，则访问后还不存在。</span></span><br><span class="line">            ht[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            Console.WriteLine(ht.ContainsKey(<span class="number">0</span>));<span class="comment">//除非手动插入</span></span><br><span class="line">            Console.WriteLine(); Console.WriteLine();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Dictionary：字典键值对"><a href="#Dictionary：字典键值对" class="headerlink" title="Dictionary：字典键值对"></a>Dictionary：字典键值对</h3><p>Dictionary是一个通用集合，通常用于存储键&#x2F;值对。</p>
<p>它的工作方式与非通用的哈希表非常相似。Dictionary的优点是它是一种通用类型。Dictionary定义在System.Collections.Generic命名空间下。</p>
<p>Dictionary&lt;TKey, TValue&gt;存储键值对，实现了IDictionary&lt;TKey, TValue&gt;接口。键必须是唯一的且不能为空。值可以为空或重复。可以通过传递关联键来访问值，例如myDictionary [key] 。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建一个字典键值对集合</span></span><br><span class="line">            <span class="comment">//与hashtable不同，键和值的类型在定义的时候就已经被定义了。</span></span><br><span class="line">            Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//添加数据</span></span><br><span class="line">            <span class="comment">//键只能是int，值只能是string</span></span><br><span class="line">            <span class="comment">//同样键不可以重复</span></span><br><span class="line">            dic.Add(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">            dic.Add(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">            dic[<span class="number">3</span>] = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历</span></span><br><span class="line">            <span class="comment">//可以以键值对的形式进行遍历</span></span><br><span class="line">            <span class="keyword">foreach</span>(KeyValuePair&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; kvp <span class="keyword">in</span> dic)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;key:<span class="subst">&#123;kvp.Key&#125;</span>\tvalue:<span class="subst">&#123;kvp.Value&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















<h3 id="List-泛型集合"><a href="#List-泛型集合" class="headerlink" title="List 泛型集合"></a>List 泛型集合</h3><p>对集合中的类型已经有了比较确切的定义（和数组一样）。</p>
<p>具体操作和普通的ArrayList类型。</p>
<p>特殊的地方就是可以与数组相互转换。能转成什么类型的数组取决于是什么类型的集合。</p>
<h3 id="使用-LINQ-访问集合"><a href="#使用-LINQ-访问集合" class="headerlink" title="使用 LINQ 访问集合"></a>使用 LINQ 访问集合</h3><p>可以使用 LINQ（语言集成查询）来访问集合。 LINQ 查询提供筛选、排序和分组功能。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/">C# 中的 LINQ 入门</a>。</p>
<p>以下示例运行一个对泛型 <code>List</code> 的 LINQ 查询。 LINQ 查询返回一个包含结果的不同集合。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowLINQ</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Element&gt; elements = BuildList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LINQ Query.</span></span><br><span class="line">    <span class="keyword">var</span> subset = <span class="keyword">from</span> theElement <span class="keyword">in</span> elements</span><br><span class="line">                 <span class="keyword">where</span> theElement.AtomicNumber &lt; <span class="number">22</span></span><br><span class="line">                 <span class="keyword">orderby</span> theElement.Name</span><br><span class="line">                 <span class="keyword">select</span> theElement;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (Element theElement <span class="keyword">in</span> subset)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(theElement.Name + <span class="string">&quot; &quot;</span> + theElement.AtomicNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">//  Calcium 20</span></span><br><span class="line">    <span class="comment">//  Potassium 19</span></span><br><span class="line">    <span class="comment">//  Scandium 21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Element&gt; <span class="title">BuildList</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> List&lt;Element&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        &#123; <span class="keyword">new</span> Element() &#123; Symbol=<span class="string">&quot;K&quot;</span>, Name=<span class="string">&quot;Potassium&quot;</span>, AtomicNumber=<span class="number">19</span>&#125;&#125;,</span><br><span class="line">        &#123; <span class="keyword">new</span> Element() &#123; Symbol=<span class="string">&quot;Ca&quot;</span>, Name=<span class="string">&quot;Calcium&quot;</span>, AtomicNumber=<span class="number">20</span>&#125;&#125;,</span><br><span class="line">        &#123; <span class="keyword">new</span> Element() &#123; Symbol=<span class="string">&quot;Sc&quot;</span>, Name=<span class="string">&quot;Scandium&quot;</span>, AtomicNumber=<span class="number">21</span>&#125;&#125;,</span><br><span class="line">        &#123; <span class="keyword">new</span> Element() &#123; Symbol=<span class="string">&quot;Ti&quot;</span>, Name=<span class="string">&quot;Titanium&quot;</span>, AtomicNumber=<span class="number">22</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Element</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Symbol &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> AtomicNumber &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="对集合排序"><a href="#对集合排序" class="headerlink" title="对集合排序"></a>对集合排序</h3><p>以下示例阐释了对集合排序的过程。 该示例对 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1">List</a> 中存储的 <code>Car</code> 类的实例进行排序。 <code>Car</code> 类实现 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.icomparable-1">IComparable</a> 接口，此操作需要实现 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.icomparable-1.compareto">CompareTo</a> 方法。</p>
<p>每次对 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.icomparable-1.compareto">CompareTo</a> 方法的调用均会执行用于排序的单一比较。 <code>CompareTo</code> 方法中用户编写的代码针对当前对象与另一个对象的每个比较返回一个值。 如果当前对象小于另一个对象，则返回的值小于零；如果当前对象大于另一个对象，则返回的值大于零；如果当前对象等于另一个对象，则返回的值等于零。 这使你可以在代码中定义大于、小于和等于条件。</p>
<p>在 <code>ListCars</code> 方法中，<code>cars.Sort()</code> 语句对列表进行排序。 对 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1">List</a> 的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1.sort">Sort</a> 方法的此调用将导致为 <code>List</code> 中的 <code>Car</code> 对象自动调用 <code>CompareTo</code> 方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListCars();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ListCars</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> cars = <span class="keyword">new</span> List&lt;Car&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                &#123; <span class="keyword">new</span> Car() &#123; Name = <span class="string">&quot;car1&quot;</span>, Color = <span class="string">&quot;blue&quot;</span>, Speed = <span class="number">20</span>&#125;&#125;,</span><br><span class="line">                &#123; <span class="keyword">new</span> Car() &#123; Name = <span class="string">&quot;car2&quot;</span>, Color = <span class="string">&quot;red&quot;</span>, Speed = <span class="number">50</span>&#125;&#125;,</span><br><span class="line">                &#123; <span class="keyword">new</span> Car() &#123; Name = <span class="string">&quot;car3&quot;</span>, Color = <span class="string">&quot;green&quot;</span>, Speed = <span class="number">10</span>&#125;&#125;,</span><br><span class="line">                &#123; <span class="keyword">new</span> Car() &#123; Name = <span class="string">&quot;car4&quot;</span>, Color = <span class="string">&quot;blue&quot;</span>, Speed = <span class="number">50</span>&#125;&#125;,</span><br><span class="line">                &#123; <span class="keyword">new</span> Car() &#123; Name = <span class="string">&quot;car5&quot;</span>, Color = <span class="string">&quot;blue&quot;</span>, Speed = <span class="number">30</span>&#125;&#125;,</span><br><span class="line">                &#123; <span class="keyword">new</span> Car() &#123; Name = <span class="string">&quot;car6&quot;</span>, Color = <span class="string">&quot;red&quot;</span>, Speed = <span class="number">60</span>&#125;&#125;,</span><br><span class="line">                &#123; <span class="keyword">new</span> Car() &#123; Name = <span class="string">&quot;car7&quot;</span>, Color = <span class="string">&quot;green&quot;</span>, Speed = <span class="number">50</span>&#125;&#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 按颜色字母顺序排序，然后按速度降序排序。</span></span><br><span class="line">            cars.Sort();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// View all of the cars.</span></span><br><span class="line">            <span class="keyword">foreach</span> (Car thisCar <span class="keyword">in</span> cars)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(thisCar.Color.PadRight(<span class="number">5</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                Console.Write(thisCar.Speed.ToString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                Console.Write(thisCar.Name);</span><br><span class="line">                Console.WriteLine();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Output:</span></span><br><span class="line">            <span class="comment">//  blue  50 car4</span></span><br><span class="line">            <span class="comment">//  blue  30 car5</span></span><br><span class="line">            <span class="comment">//  blue  20 car1</span></span><br><span class="line">            <span class="comment">//  green 50 car7</span></span><br><span class="line">            <span class="comment">//  green 10 car3</span></span><br><span class="line">            <span class="comment">//  red   60 car6</span></span><br><span class="line">            <span class="comment">//  red   50 car2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">IComparable</span>&lt;<span class="title">Car</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Speed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Color &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 摘要：</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 将当前实例与同一类型的另一个对象进行比较，并返回一个整数，</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 该整数指示当前实例在排序顺序中是在其他对象之前、之后还是出现在相同的位置。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;other&quot;&gt;</span>要与此实例进行比较的对象。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 一个值，表示被比较对象的相对顺序。返回值具有以下含义：</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>  价值–意义</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>  小于零–此实例在排序顺序上位于其他实例之前。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>  零–此实例与其他实例在排序顺序中出现在相同的位置。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>  大于零–此实例在排序顺序上跟在其他实例之后。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params">Car other</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对该方法的调用将进行一次用于排序的比较。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 确定被比较对象的相对顺序。</span></span><br><span class="line">            <span class="comment">// 按颜色字母顺序排序，然后按速度降序排序。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 比较颜色。</span></span><br><span class="line">            <span class="built_in">int</span> compare;</span><br><span class="line">            compare = String.Compare(<span class="keyword">this</span>.Color, other.Color, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果颜色相同，请比较速度。</span></span><br><span class="line">            <span class="keyword">if</span> (compare == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                compare = <span class="keyword">this</span>.Speed.CompareTo(other.Speed);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用降序表示速度。</span></span><br><span class="line">                compare = -compare;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> compare;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义自定义集合"><a href="#定义自定义集合" class="headerlink" title="定义自定义集合"></a>定义自定义集合</h3><p>可以通过实现 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.ienumerable-1">IEnumerable</a>&lt;T&gt; 或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerable">IEnumerable</a> 接口来定义集合。</p>
<p>尽管可以定义自定义集合，但通常最好使用包含在 .NET 中的集合，这在本文前面的<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/collections#BKMK_KindsOfCollections">集合类型</a>中进行了介绍。</p>
<p>以下示例定义一个名为 <code>AllColors</code> 的自定义集合类。 此类实现 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerable">IEnumerable</a> 接口，此操作需要实现 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerable.getenumerator">GetEnumerator</a> 方法。</p>
<p><code>GetEnumerator</code> 方法返回 <code>ColorEnumerator</code> 类的一个实例。 <code>ColorEnumerator</code> 实现 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerator">IEnumerator</a> 接口，此操作需要实现 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerator.current">Current</a> 属性、<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerator.movenext">MoveNext</a> 方法以及 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerator.reset">Reset</a> 方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ListColors</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> colors = <span class="keyword">new</span> AllColors();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (Color theColor <span class="keyword">in</span> colors)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(theColor.Name + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    <span class="comment">// Output: red blue green</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Collection class.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AllColors</span> : <span class="title">System.Collections.IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    Color[] _colors =</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> Color() &#123; Name = <span class="string">&quot;red&quot;</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> Color() &#123; Name = <span class="string">&quot;blue&quot;</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> Color() &#123; Name = <span class="string">&quot;green&quot;</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> System.Collections.<span class="function">IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ColorEnumerator(_colors);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Instead of creating a custom enumerator, you could</span></span><br><span class="line">        <span class="comment">// use the GetEnumerator of the array.</span></span><br><span class="line">        <span class="comment">//return _colors.GetEnumerator();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Custom enumerator.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">ColorEnumerator</span> : <span class="title">System.Collections.IEnumerator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> Color[] _colors;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> _position = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ColorEnumerator</span>(<span class="params">Color[] colors</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _colors = colors;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">object</span> System.Collections.IEnumerator.Current</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> _colors[_position];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span> System.Collections.IEnumerator.MoveNext()</span><br><span class="line">        &#123;</span><br><span class="line">            _position++;</span><br><span class="line">            <span class="keyword">return</span> (_position &lt; _colors.Length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> System.Collections.IEnumerator.Reset()</span><br><span class="line">        &#123;</span><br><span class="line">            _position = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Element class.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器用于对集合执行自定义迭代。 迭代器可以是一种方法，或是一个 <code>get</code> 访问器。 迭代器使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/yield">yield return</a> 语句返回集合的每一个元素，每次返回一个元素。</p>
<p>通过使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">foreach</a> 语句调用迭代器。 <code>foreach</code> 循环的每次迭代都会调用迭代器。 迭代器中到达 <code>yield return</code> 语句时，会返回一个表达式，并保留当前在代码中的位置。 下次调用迭代器时，将从该位置重新开始执行。</p>
<p>有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/iterators">迭代器 (C#)</a>。</p>
<p>下面的示例使用迭代器方法。 迭代器方法具有位于 <code>for</code> 循环中的 <code>yield return</code> 语句。 在 <code>ListEvenNumbers</code> 方法中，<code>foreach</code> 语句体的每次迭代都会创建对迭代器方法的调用，并将继续到下一个 <code>yield return</code> 语句。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ListEvenNumbers</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="function"><span class="built_in">int</span> number <span class="keyword">in</span> <span class="title">EvenSequence</span>(<span class="params"><span class="number">5</span>, <span class="number">18</span></span>))</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(number.ToString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    <span class="comment">// Output: 6 8 10 12 14 16 18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">EvenSequence</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">int</span> firstNumber, <span class="built_in">int</span> lastNumber</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Yield even numbers in the range.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> number = firstNumber; number &lt;= lastNumber; number++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (number % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>对象间的比较可以分为两大类，分别是<code>类型比较</code>、<code>引用比较</code>、<code>值比较</code>、<code>深度比较</code>、<code>大小比较</code>等</p>
<ul>
<li>类型比较，即比较两个对象的类型是否是同一个</li>
<li>引用比较，即比较两个对象的引用是否相同，可以使用Object.ReferenceEquals方法或者&#x3D;&#x3D;操作符（对于引用类型）。</li>
<li>值比较，即比较两个对象的值是否相等，可以使用Object.Equals方法或者重载的&#x3D;&#x3D;操作符（对于值类型或者自定义类型）。</li>
<li>深度比较，即比较两个引用类型对象中包含的所有属性或字段是否相等，可以使用一些第三方库，如Objects Comparer或者自己实现一个递归的比较方法。</li>
<li>大小比较，即比较两个对象的大小顺序，可以使用IComparable接口或者IComparer&lt;T&gt;接口。</li>
</ul>
<p>注意：类型比较和引用比较不是指的同一个。类型比较是指比较两个对象的类型是否相同，可以使用<code>GetType</code>方法或者<code>is</code>操作符。引用比较是指比较两个对象的引用是否相同，可以使用<code>Object.ReferenceEquals</code>方法或者<code>==</code>操作符（对于引用类型）。</p>
<h3 id="类型比较"><a href="#类型比较" class="headerlink" title="类型比较"></a>类型比较</h3><p>在比较对象时，常需要了解它们的类型，才能确定是否可以进行值的比较。常用的方法有：<code>GetType()</code>和<code>is</code> 运算符。它可以提供可读性较高的代码，还可以检查基类。在<code>is</code>运算符之前，需要了解处理值类型(与引用类型相反)时后台的一些常见操作:封箱(boxing)和拆箱(unboxing)。</p>
<h4 id="is运算符"><a href="#is运算符" class="headerlink" title="is运算符"></a>is运算符</h4><h5 id="基本语法-5"><a href="#基本语法-5" class="headerlink" title="基本语法"></a>基本语法</h5><p>&lt;operand&gt; is &lt;type&gt;<br>这个表达式的结果如下:</p>
<ul>
<li>如果&lt;type&gt;是一个类类型， 而&lt;operand&gt;也是该类型，或者它继承了该类型，或者它可以封箱到该类型中，则结果为true。</li>
<li>如果&lt;type&gt;是 一个接口类型，而&lt;operand&gt; 也是该类型，或者它是实现该接口的类型，则结果为tnue.</li>
<li>如果&lt;type&gt;是一个值类型， 而&lt;operand&gt;也是该类型， 或者它可以拆箱到该类型中，则结果为true。</li>
</ul>
<h5 id="样例-27"><a href="#样例-27" class="headerlink" title="样例"></a>样例</h5><p>is运算符是一种用来判断对象是否是某种类型，或者是否可以转换为某种类型的运算符。如果是，这个运算符就返回true，否则返回false12。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> x = <span class="number">100</span>;</span><br><span class="line">Console.WriteLine(x <span class="keyword">is</span> <span class="built_in">double</span>); <span class="comment">// 输出：True</span></span><br><span class="line">Console.WriteLine(x <span class="keyword">is</span> <span class="built_in">int</span>); <span class="comment">// 输出：False</span></span><br></pre></td></tr></table></figure>

<p>is运算符还可以用来匹配表达式与模式，如常量模式，关系模式，属性模式等3。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsFirstFridayOfOctober</span>(<span class="params">DateTime date</span>)</span> =&gt; date <span class="keyword">is</span> &#123; Month: <span class="number">10</span>, Day: &lt;=<span class="number">7</span>, DayOfWeek: DayOfWeek.Friday &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsFirstFridayOfOctober</span>(<span class="params">DateTime date</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> date.Month == <span class="number">10</span> &amp;&amp; date.Day &lt;= <span class="number">7</span> &amp;&amp; date.DayOfWeek == DayOfWeek.Friday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，is运算符将date与一个属性模式匹配，判断它是否是10月的第一个星期五。</p>
<h3 id="引用比较"><a href="#引用比较" class="headerlink" title="引用比较"></a>引用比较</h3><p>引用比较是一种用来判断两个对象是否指向同一个内存地址的比较方式。在c#中，可以使用Object.ReferenceEquals静态方法或者&#x3D;&#x3D;运算符（对于引用类型）来进行引用比较。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s3 = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>.ToCharArray());</span><br><span class="line">Console.WriteLine(Object.ReferenceEquals(s1, s2)); <span class="comment">// 输出：True</span></span><br><span class="line">Console.WriteLine(Object.ReferenceEquals(s1, s3)); <span class="comment">// 输出：False</span></span><br><span class="line">Console.WriteLine(s1 == s2); <span class="comment">// 输出：True</span></span><br><span class="line">Console.WriteLine(s1 == s3); <span class="comment">// 输出：True</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，s1和s2都是指向字符串常量池中的同一个字符串对象，所以引用比较返回true。而s3是通过构造函数创建的一个新的字符串对象，所以引用比较返回false。注意，&#x3D;&#x3D;运算符对于字符串类型是进行内容比较的，所以s1和s3的内容比较返回true。</p>
<h3 id="值比较"><a href="#值比较" class="headerlink" title="值比较"></a>值比较</h3><p>值比较是一种用来判断两个对象的内容是否相等的比较方式。在c#中，可以使用Object.Equals静态方法或者&#x3D;&#x3D;运算符（对于值类型）来进行值比较。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> y = <span class="number">10</span>;</span><br><span class="line">Console.WriteLine(Object.Equals(x, y)); <span class="comment">// 输出：True</span></span><br><span class="line">Console.WriteLine(x == y); <span class="comment">// 输出：True</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，x和y都是值类型，所以它们的值比较返回true。注意，&#x3D;&#x3D;运算符对于值类型是进行值比较的，而对于引用类型是进行引用比较的。</p>
<h4 id="IComparable和IComparer接口"><a href="#IComparable和IComparer接口" class="headerlink" title="IComparable和IComparer接口"></a>IComparable和IComparer接口</h4><p>IComparable和IComparer接日是.NETFramework中比较对象的标准方式。这两个接口之间的区别如下:</p>
<ul>
<li>IComparable 在要比较的对象的类中实现，可以比较该对象和另一个对象。</li>
<li>IComparer 在一个单独的类中实现，可以比较任意两个对象</li>
</ul>
<p>​	IComparable提供了一个方法CompareTo() , 这个方法接受一个对象。 例如，在实现该方法时，使其可以接<br>受一个Peson对象，以便确定这个人比当前的人更年老还是更年轻。实际上，这个方法返回一个int, 所以也<br>可以确定第二个人与当前的人的年龄差:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(person1.CompareTo(person2) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;SameAge&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(person1.CompareTo(person2) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;person1 is older&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;person1 is Younger&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>IComparer也提供-一个方法Compare()。 这个方法接受两个对象，返回一个整型结果，这与Compare To()相同。<br>对于支持IComparer的对象，可使用下面的代码:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (personComparer.Compare(personl, person2) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	WriteLine (<span class="string">&quot;Same age&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (personComparer.Compare(person1, person2) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;person1 is older&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;person1 is Younger&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="值比较的方法"><a href="#值比较的方法" class="headerlink" title="值比较的方法"></a>值比较的方法</h4><ul>
<li>使用String.Compare()方法，它接受两个字符串作为参数，并返回一个整数值，表示两个字符串的比较结果。如果两个字符串相等，返回0；如果第一个字符串小于第二个字符串，返回负数；如果第一个字符串大于第二个字符串，返回正数。</li>
<li>使用CompareTo()方法，它是一个实例方法，用于比较当前对象和另一个对象的值。它也返回一个整数值，表示两个对象的比较结果。如果两个对象相等，返回0；如果当前对象小于另一个对象，返回负数；如果当前对象大于另一个对象，返回正数。</li>
<li>使用&#x3D;&#x3D;和!&#x3D;运算符，它们用于比较两个值是否相等或不相等。它们返回一个布尔值，表示两个值的比较结果。如果两个值相等，返回true；如果两个值不相等，返回false。</li>
</ul>
<h4 id="对自定义类实现sort排序"><a href="#对自定义类实现sort排序" class="headerlink" title="对自定义类实现sort排序"></a>对自定义类实现sort排序</h4><p>在c#中实现对自定义类的sort排序的方法有以下几种：</p>
<ul>
<li>让自定义类实现IComparable接口，并定义CompareTo方法，用于比较当前对象和另一个对象。然后使用List&lt;T&gt;.Sort()方法对列表进行排序，它会使用默认的比较器。</li>
<li>定义一个实现IComparer接口的类，并定义Compare方法，用于比较两个对象。然后使用List&lt;T&gt;.Sort(IComparer&lt;T&gt;)方法对列表进行排序，它会使用指定的比较器。</li>
<li>使用LINQ的orderby子句对列表进行排序，它会返回一个排序后的序列。可以指定排序的属性和顺序。</li>
</ul>
<h5 id="样例-28"><a href="#样例-28" class="headerlink" title="样例"></a>样例</h5><p>假设有一个自定义类Student，有两个属性Name和Score，表示学生的姓名和成绩。</p>
<ul>
<li>使用IComparable接口的示例代码：</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;StudentA&gt; studentsA = <span class="keyword">new</span> List&lt;StudentA&gt;()<span class="comment">// 创建要比较的序列</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> StudentA(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>),</span><br><span class="line">                <span class="keyword">new</span> StudentA(<span class="string">&quot;李四&quot;</span>, <span class="number">21</span>),</span><br><span class="line">                <span class="keyword">new</span> StudentA(<span class="string">&quot;王五&quot;</span>, <span class="number">-10</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            studentsA.Sort();<span class="comment">//直接调用</span></span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> t <span class="keyword">in</span> studentsA)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;name : <span class="subst">&#123;t.Name&#125;</span>   age : <span class="subst">&#123;t.Age&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 样例1 在自定义的类内定义比较方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 使用Icomparable实现类内自带比较方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">StudentA</span> : <span class="title">IComparable</span>&lt;<span class="title">StudentA</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params">StudentA other</span>)<span class="comment">//加上一个?表示这个参数是一个可空类型，可以接受null作为值。这样可以增加方法的灵活性，可以处理null的情况。例如，如果other是null，那么可以返回1，表示当前对象大于null。</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> other.Age - <span class="keyword">this</span>.Age;<span class="comment">//调整这个实现正序、逆序的排序</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StudentA</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Name = name;</span><br><span class="line">            Age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用IComparer接口的示例代码：</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;StudentB&gt; studentsB = <span class="keyword">new</span> List&lt;StudentB&gt;()<span class="comment">// 创建要比较的序列</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> StudentB(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>),</span><br><span class="line">                <span class="keyword">new</span> StudentB(<span class="string">&quot;李四&quot;</span>, <span class="number">21</span>),</span><br><span class="line">                <span class="keyword">new</span> StudentB(<span class="string">&quot;王五&quot;</span>, <span class="number">-10</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 实例化比较对象</span></span><br><span class="line">            MyComparer myComparer = <span class="keyword">new</span> MyComparer();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用Sort进行排序</span></span><br><span class="line">            studentsB.Sort(myComparer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> t <span class="keyword">in</span> studentsB)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;name : <span class="subst">&#123;t.Name&#125;</span>   age : <span class="subst">&#123;t.Age&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 样例2 使用第三方比较类实现</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">StudentB</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StudentB</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Name = name;</span><br><span class="line">            Age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// yo</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">MyComparer</span> : <span class="title">IComparer</span>&lt;<span class="title">StudentB</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Compare</span>(<span class="params">StudentB x, StudentB y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x.Age - y.Age;<span class="comment">//调整这个实现正序、逆序的排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用LINQ的orderby子句的示例代码：</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义Student类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Score &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个Student列表</span></span><br><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> List&lt;Student&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> Student() &#123; Name = <span class="string">&quot;Alice&quot;</span>, Score = <span class="number">90</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Student() &#123; Name = <span class="string">&quot;Bob&quot;</span>, Score = <span class="number">80</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Student() &#123; Name = <span class="string">&quot;Charlie&quot;</span>, Score = <span class="number">85</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Student() &#123; Name = <span class="string">&quot;David&quot;</span>, Score = <span class="number">95</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用LINQ的orderby子句对列表进行排序，按照成绩升序，姓名降序</span></span><br><span class="line"><span class="keyword">var</span> sortedStudents = <span class="keyword">from</span> student <span class="keyword">in</span> students <span class="keyword">orderby</span> student.Score, student.Name <span class="keyword">descending</span> <span class="keyword">select</span> student;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印排序后的序列</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> student <span class="keyword">in</span> sortedStudents)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;student.Name&#125;</span>: <span class="subst">&#123;student.Score&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h2><ul>
<li>文本文件有不同的存储方式，将字符串以什么形式保存为二进制，这个就是编码。常见的编码有UTF-8、ASCII、Unicode、gbk等。</li>
<li>如果出现乱码一般都是编码的问题，文本文件相关的函数一般都具有一个Encoding类型的参数。</li>
<li>取得编码的方式：Encoding.Defaule，Encoding.UTF8、Encoding.GetEncoding(“GBK”)</li>
<li>常用静态方法<ul>
<li>void AppendAllText(string path, string contents);<ul>
<li>将文本contents附加到文件path中</li>
</ul>
</li>
<li>bool Exists(string path)<ul>
<li>判断文件path是否存在</li>
</ul>
</li>
<li>string[ ReadAllL ines(string path)读取文本文件到字符串数组中</li>
<li>string ReadAIIText(string path)读取文本文件到字符串中<br>void WriteAllText(string path, string contents)<br>将文本contents保存到文件path中，会覆盖旧内容。<br>WriteAllL ines(string path,string[ contents);<br>将字符串数组逐行保存到文件path中，会覆盖旧内容。</li>
</ul>
</li>
</ul>
<h2 id="输入输出的类"><a href="#输入输出的类" class="headerlink" title="输入输出的类"></a>输入输出的类</h2><h3 id="Path类"><a href="#Path类" class="headerlink" title="Path类"></a>Path类</h3><p>Path 类是 C# 中的一个<code>静态类</code>，它属于 <code>System.IO</code> 命名空间和 <code>System.Runtime.dll</code> 程序集。这个类用于对包含文件路径或目录路径信息的字符串实例执行操作。路径是一个字符串，它提供了文件或目录的位置，它可以是绝对位置或相对位置。这些操作以跨平台的方式执行。</p>
<p>例如，可以使用 Path 类的一些方法来检查文件路径是否有扩展名（HasExtension），检查文件路径是否为根路径（IsPathRooted），获取临时文件的完整路径（GetFullPath），获取临时文件的位置（GetTempPath）以及获取可用于使用的临时文件名（GetTempFileName）。</p>
<p>此外，还可以使用 Combine 方法将多个路径组合在一起。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> str = <span class="string">@&quot;D:\Documents\hurriedlu\资源\hurr.wav&quot;</span>;<span class="comment">// @的意思是忽略后续字符串中的转义字符，当作普通字符进行处理</span></span><br><span class="line">            <span class="comment">// 获取路径中的文件名：</span></span><br><span class="line">            <span class="comment">// 传统做法：</span></span><br><span class="line">            <span class="built_in">int</span> index = str.LastIndexOf(<span class="string">&quot;\\&quot;</span>);<span class="comment">//找到最后一个斜杠的位置</span></span><br><span class="line">            <span class="built_in">string</span> name = str.Substring(index + <span class="number">1</span>);<span class="comment">// 从最后一个斜杠的下一个位置开始截取，截取剩下全部的字符</span></span><br><span class="line">            Console.WriteLine(name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用Path类实现</span></span><br><span class="line">            <span class="comment">//获取文件的名字。</span></span><br><span class="line">            Console.WriteLine(Path.GetFileName(str));<span class="comment">//hurr.wav</span></span><br><span class="line">            <span class="comment">//只获取文件名而不获取扩展名。</span></span><br><span class="line">            Console.WriteLine(Path.GetFileNameWithoutExtension(str));<span class="comment">//hurr</span></span><br><span class="line">            <span class="comment">//只获取扩展名(包括点)。</span></span><br><span class="line">            Console.WriteLine(Path.GetExtension(str));<span class="comment">//.wav</span></span><br><span class="line">            <span class="comment">//获取文件所在的文件夹的地址(文件夹的绝对地址)</span></span><br><span class="line">            Console.WriteLine(Path.GetDirectoryName(str));<span class="comment">//D:\Documents\hurriedlu\资源</span></span><br><span class="line">            <span class="comment">//组合路径</span></span><br><span class="line">            <span class="comment">//注意，如果组合时当前分块没有扩展名，则会自动添加/。例如：将文件名和扩展名组合在一起：hurr\.wav</span></span><br><span class="line">            Console.WriteLine(Path.Combine(Path.GetFileNameWithoutExtension(str), Path.GetExtension(str)));</span><br><span class="line">            <span class="comment">//组合可以不止两个，但依然存在上面的问题 例如：D:\Documents\hurriedlu\资源\hurr\.wav</span></span><br><span class="line">            Console.WriteLine(Path.Combine(Path.GetDirectoryName(str), Path.GetFileNameWithoutExtension(str), Path.GetExtension(str)));</span><br><span class="line">            <span class="comment">//组合文件夹和文件名</span></span><br><span class="line">            Console.WriteLine(Path.Combine(Path.GetDirectoryName(str), Path.GetFileName(str)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取完整的路径（绝对地址）。</span></span><br><span class="line">            Console.WriteLine(Path.GetFullPath(str));</span><br><span class="line">            <span class="comment">//检查提供的路径是否含有扩展名（返回类型bool）</span></span><br><span class="line">            Console.WriteLine(Path.HasExtension(str));</span><br><span class="line">            <span class="comment">//检查是否是根路径</span></span><br><span class="line">            Console.WriteLine(Path.IsPathRooted(str));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取临时文件位置</span></span><br><span class="line">            <span class="built_in">string</span> temp = Path.GetTempPath();</span><br><span class="line">            Console.WriteLine(temp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建临时文件</span></span><br><span class="line">            temp = Path.GetTempFileName();</span><br><span class="line">            Console.WriteLine(temp);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * GetTempFileName 方法用于在磁盘上创建一个唯一命名的零字节临时文件，并返回该文件的完整路径。</span></span><br><span class="line"><span class="comment">             * 该临时文件将在用户的临时文件夹内创建，该路径是由 GetTempPath 方法返回的路径。</span></span><br><span class="line"><span class="comment">             * 需要注意的是，如果在不删除先前的临时文件的情况下使用此方法创建超过 65535 个文件，</span></span><br><span class="line"><span class="comment">             * GetTempFileName 方法将引发 IOException。</span></span><br><span class="line"><span class="comment">             * 如果没有可用的唯一临时文件名，GetTempFileName 方法也会引发 IOException。</span></span><br><span class="line"><span class="comment">             * 要解决此错误，请删除所有不需要的临时文件。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p>File 类是 C# 中的一个<code>静态类</code>，它属于 <code>System.IO</code> 命名空间和 <code>System.Runtime.dll</code> 程序集。这个类提供了用于创建、复制、删除、移动和打开单个文件的静态方法，并帮助创建 <code>FileStream</code> 对象。</p>
<p>可以使用 File 类执行诸如复制、移动、重命名、创建、打开、删除和追加到单个文件的典型操作。还可以使用 File 类获取和设置与文件创建、访问和写入相关的文件属性或 DateTime 信息。</p>
<p>例如，可以使用 Exists 方法检查文件是否存在，使用 Copy 方法复制文件，使用 Create 方法创建或覆盖文件，使用 Delete 方法删除文件，使用 ReadAllText 方法读取文件内容，使用 WriteAllText 方法创建新文件并将内容写入其中（如果文件已存在，则将其覆盖）。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="判断文件是否存在：Exists"><a href="#判断文件是否存在：Exists" class="headerlink" title="判断文件是否存在：Exists"></a>判断文件是否存在：Exists</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (File.Exists(<span class="string">@&quot;D:\tmp\tmp.txt&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;已存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="创建文件：Create"><a href="#创建文件：Create" class="headerlink" title="创建文件：Create"></a>创建文件：Create</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">File.Create(<span class="string">@&quot;D:\tmp\tmp.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​	使用File创建一个文件。注意，只能创建文件，而不能创建目录。如果目录不存在，则会抛出异常。<br>​	当使用File创建文件的时候，如果重复执行（已存在要创建的文件），则会对要创建的文件进行修改，而不是删除再创建。</p>
<h5 id="剪切（移动）一个文件：Move"><a href="#剪切（移动）一个文件：Move" class="headerlink" title="剪切（移动）一个文件：Move"></a>剪切（移动）一个文件：Move</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">File.Move(<span class="string">@&quot;D:\tmp\tmp1.txt&quot;</span>, <span class="string">@&quot;D:\tmp\1\tmp.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>同时在移动的过程中允许对移动的文件进行重命名操作。</p>
<h5 id="复制一个文件：Copy"><a href="#复制一个文件：Copy" class="headerlink" title="复制一个文件：Copy"></a>复制一个文件：Copy</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">File.Copy(<span class="string">@&quot;D:\tmp\tmp.txt&quot;</span>, <span class="string">@&quot;D:\tmp\tmp1.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果目标文件（tmp1）已存在，则会抛出异常</p>
<h5 id="删除一个文件：Delete"><a href="#删除一个文件：Delete" class="headerlink" title="删除一个文件：Delete"></a>删除一个文件：Delete</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">File.Delete(<span class="string">@&quot;D:\tmp\tmp.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注意，使用File删除文件的时候，是直接删除一个文件，而非移动到回收站</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//使用File创建一个文件。注意，只能创建文件，而不能创建目录。如果目录不存在，则会抛出异常。</span></span><br><span class="line">            <span class="comment">//当使用File创建文件的时候，如果重复执行（已存在要创建的文件），则会对要创建的文件进行修改，而不是删除再创建。</span></span><br><span class="line">            <span class="comment">//File.Create(@&quot;D:\tmp\tmp.txt&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除一个指定的文件</span></span><br><span class="line">            <span class="comment">// 直接删除一个文件，不经过回收站</span></span><br><span class="line">            <span class="comment">//File.Delete(@&quot;D:\tmp\tmp.txt&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//复制一个文件</span></span><br><span class="line">            <span class="comment">//如果目标文件（tmp1）已存在，则会抛出异常</span></span><br><span class="line">            <span class="comment">//File.Copy(@&quot;D:\tmp\tmp.txt&quot;, @&quot;D:\tmp\tmp1.txt&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动一个文件</span></span><br><span class="line">            <span class="comment">// 同时在移动的过程中允许对移动的文件进行重命名操作。</span></span><br><span class="line">            <span class="comment">//File.Move(@&quot;D:\tmp\tmp1.txt&quot;, @&quot;D:\tmp\1\tmp.txt&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断文件是否存在</span></span><br><span class="line">            <span class="comment">//if (File.Exists(@&quot;D:\tmp\tmp.txt&quot;))</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    Console.WriteLine(&quot;已存在&quot;);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            <span class="comment">//else</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    Console.WriteLine(&quot;不存在&quot;);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="使用File读写数据"><a href="#使用File读写数据" class="headerlink" title="使用File读写数据"></a>使用File读写数据</h4><p>一般来说，只是用File操作小文件。</p>
<p>对于ReadAllBytes来说可以读取非文本文件，但对于其他方法来说，只能读取文本文件。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//逐行读取文本，并将每一行的文本信息转换成一个string对象存入string数组中</span></span><br><span class="line">            <span class="comment">// 参数二可以缺省，如果缺省则使用默认的编码格式进行解码。也可以指定解码方式</span></span><br><span class="line">            <span class="built_in">string</span>[] str = File.ReadAllLines(<span class="string">@&quot;D:\tmp\tmp.txt&quot;</span>,Encoding.UTF8);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">string</span> item <span class="keyword">in</span> str)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(item);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//直接读取所有的文本，存入一个string类型的变量中后返回</span></span><br><span class="line">            <span class="comment">//同上方的逐行读取一样，也可以指定解码编码</span></span><br><span class="line">            <span class="comment">//会将所有的字符（包括回车）存入string字符串中返回。</span></span><br><span class="line">            <span class="built_in">string</span> s = File.ReadAllText(<span class="string">@&quot;D:\tmp\tmp.txt&quot;</span>, Encoding.UTF8);</span><br><span class="line">            Console.WriteLine(s);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//以字节的形式去读取一个文件，将每个字节的二进制编码直接汇集成数组返回。</span></span><br><span class="line">            <span class="comment">//输出的时候需要将字节数组转换为字符串</span></span><br><span class="line">            <span class="built_in">byte</span>[] buffer = File.ReadAllBytes(<span class="string">@&quot;D:\tmp\tmp.txt&quot;</span>);</span><br><span class="line">            <span class="built_in">string</span> strbuf = Encoding.UTF8.GetString(buffer);</span><br><span class="line">            strbuf = Encoding.GetEncoding(<span class="string">&quot;UTF-8&quot;</span>).GetString(buffer);<span class="comment">//也可以这么写。但需要注意，如果编码输入错误，会直接抛异常！！！</span></span><br><span class="line">            Console.WriteLine(strbuf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用File写数据"><a href="#使用File写数据" class="headerlink" title="使用File写数据"></a>使用File写数据</h4><p>注意，使用file写数据会使得原先的所有文本信息丢失。</p>
<p>使用方法和读数据类似</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//使用WriteAllBytes逐字节写入到指定文件中</span></span><br><span class="line">            <span class="comment">//注意！！！会从文件头开始写，导致先前的所有文本都丢失</span></span><br><span class="line">            <span class="comment">//string str = &quot;张三李四王五&quot;;</span></span><br><span class="line">            <span class="comment">//byte[] buffer = Encoding.UTF8.GetBytes(str);//将字符串变成字节数组</span></span><br><span class="line">            <span class="comment">//File.WriteAllBytes(@&quot;D:\tmp\tmp.txt&quot;, buffer);//将转换完成的字节数组写入到指定的文件中</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//以行的形式写入到指定的文本文件中</span></span><br><span class="line">            <span class="comment">//也是从文件头开始写</span></span><br><span class="line">            <span class="comment">//File.WriteAllLines(@&quot;D:\tmp\tmp.txt&quot;, new string[] &#123;&quot;tmp&quot;, &quot;test&quot;&#125;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//以字符串的形式写入到指定的文本文件中去</span></span><br><span class="line">            <span class="comment">//依然复写</span></span><br><span class="line">            <span class="comment">//File.WriteAllText(@&quot;D:\tmp\tmp.txt&quot;, &quot;副本&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用file追加数据"><a href="#使用file追加数据" class="headerlink" title="使用file追加数据"></a>使用file追加数据</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//向指定的文本文件追加n行文本</span></span><br><span class="line">            <span class="comment">//从源文件末尾开始追加，保留原有文本</span></span><br><span class="line">            <span class="comment">//File.AppendAllLines(@&quot;D:\tmp\tmp.txt&quot;, new string[] &#123; &quot;hurr&quot;, &quot;visual&quot; &#125;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//向指定的文本文件追加指定字符串</span></span><br><span class="line">            <span class="comment">//保留原有文本，支持转义字符</span></span><br><span class="line">            <span class="comment">//File.AppendAllText(@&quot;D:\tmp\tmp.txt&quot;, &quot;\n测试&quot;);</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，追加数据的话，只能追加文本文件，File并没有能追加二进制数据的能力。</p>
<h4 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h4><p>使用File只适合读取小文件，对于大文件不适用。因为File的读写是一次性完成的，容易爆内存</p>
<h3 id="FileInfo类"><a href="#FileInfo类" class="headerlink" title="FileInfo类"></a>FileInfo类</h3><p>可以看作非静态的File类。</p>
<p>FileInfo 类是 C# 中的一个类，它属于 System.IO 命名空间和 System.Runtime.dll 程序集。这个类提供了用于创建、复制、删除、移动和打开文件的属性和实例方法，并帮助创建 FileStream 对象。</p>
<p>FileInfo 类提供了许多用于操作文件的实例方法。与静态 File 类不同，FileInfo 类允许您在同一文件上执行多个操作，而不需要每次都进行安全检查。</p>
<p>下面是一些常用的 FileInfo 类方法（与File类似）：</p>
<ul>
<li><code>AppendText</code>：创建一个 StreamWriter，它将文本追加到由此 FileInfo 实例表示的文件中。</li>
<li><code>CopyTo</code>：将现有文件复制到新文件，不允许覆盖现有文件。</li>
<li><code>Create</code>：创建文件。</li>
<li><code>CreateText</code>：创建一个 StreamWriter，它写入新文本文件。</li>
<li><code>Decrypt</code>：解密由当前帐户使用 Encrypt 方法加密的文件。</li>
<li><code>Delete</code>：删除指定的文件。</li>
<li><code>Encrypt</code>：加密文件，以便只有加密该文件的帐户才能解密它。</li>
<li><code>GetAccessControl</code>：获取封装指定文件的访问控制列表 (ACL) 条目的 FileSecurity 对象。</li>
<li><code>MoveTo</code>：将指定的文件移动到新位置，提供指定新文件名的选项。</li>
<li><code>Open</code>：以指定的 FileMode 打开文件。</li>
<li><code>OpenRead</code>：创建一个只读 FileStream。</li>
<li><code>OpenText</code>：创建一个使用 UTF8 编码从现有文本文件读取的 StreamReader。</li>
<li><code>OpenWrite</code>：创建一个只写 FileStream。</li>
<li><code>Replace</code>：使用当前 FileInfo 对象描述的文件替换指定文件的内容，删除原始文件，并创建被替换文件的备份。</li>
</ul>
<h4 id="FileInfo的专用属性："><a href="#FileInfo的专用属性：" class="headerlink" title="FileInfo的专用属性："></a>FileInfo的专用属性：</h4><ul>
<li>Director<ul>
<li>检索一个DirectorInfo对象，表示包括当前文件的目录。这个属性是只读的。</li>
</ul>
</li>
<li>DirectorName<ul>
<li>返回文件目录的路径，这个属性也是只读的。</li>
</ul>
</li>
<li>IsReadOnly<ul>
<li>文件只读的快捷方式，也可以通过Attributes来访问这个属性。</li>
</ul>
</li>
<li>Length<ul>
<li>获取文件的大小（以字节为单位），返回long值，这个属性是只读的。</li>
</ul>
</li>
</ul>
<h3 id="Directory类"><a href="#Directory类" class="headerlink" title="Directory类"></a>Directory类</h3><p>Directory 类是 C# 中的一个静态类，它属于 Sys<code>t</code>em.IO 命名空间和 <code>System.Runtime.dll</code> 程序集。这个类提供了用于创建、复制、移动和删除目录和子目录的静态方法。</p>
<p>可以使用 Directory 类执行诸如复制、移动、重命名、创建和删除目录的典型操作。要创建目录，可以使用 CreateDirectory 方法。要删除目录，可以使用 Delete 方法。要获取或设置应用程序的当前目录，可以使用 GetCurrentDirectory 或 SetCurrentDirectory 方法。使用 Exists 方法检查目录是否存在，使用 CreateDirectory 方法创建目录，使用 Move 方法移动目录，使用 GetDirectories 方法获取目录中的所有子目录。</p>
<p>Directory 类提供了许多用于操作目录和子目录的静态方法。下面是一些常用的 Directory 类方法：</p>
<ul>
<li><code>CreateDirectory</code>：创建目录。</li>
<li><code>Delete</code>：删除目录。<ul>
<li>使用这个方法的时候，需要注意catch一下。当要删除的目录为非空目录时，需要指定第二个参数为true。</li>
<li>并且默认只删除最后的以后的一个文件夹</li>
</ul>
</li>
<li><code>Exists</code>：检查目录是否存在。</li>
<li><code>GetDirectories</code>：返回指定目录中的所有子目录的string对象数组。</li>
<li><code>GetFiles</code>：返回指定目录中的所有文件名称的string对象数组。</li>
<li><code>GetFileSystemEntries</code>：返回指定目录中的所有文件和子目录的string数组</li>
<li><code>Move</code>：移动目录。</li>
<li><code>EnumerateDirectories</code>：枚举目录中的所有子目录。</li>
<li><code>EnumerateFiles</code>：枚举目录中的所有文件。</li>
<li><code>EnumerateFileSystemEntries</code>：枚举目录中的所有文件和子目录。</li>
</ul>
<p>注意：Enum和Get的功能类似，只是返回类型由string数组变成<code>IEnumerable&lt;string&gt;</code>的集合。</p>
<p>当存在大量文件和目录的时候，EnumerateXXX方法要好于Get XXX方法。</p>
<p>其余不常用的方法</p>
<ul>
<li><code>GetCreationTime</code>：获取目录的创建时间。</li>
<li><code>GetCreationTimeUtc</code>：获取目录的 UTC 创建时间。</li>
<li><code>GetCurrentDirectory</code>：获取应用程序的当前工作目录。</li>
<li><code>GetDirectories</code>：获取目录中的所有子目录。</li>
<li><code>GetDirectoryRoot</code>：获取指定路径的根目录信息。</li>
<li><code>GetLastAccessTime</code>：获取目录上次访问时间。</li>
<li><code>GetLastAccessTimeUtc</code>：获取目录上次 UTC 访问时间。</li>
<li><code>GetLastWriteTime</code>：获取目录上次写入时间。</li>
<li><code>GetLastWriteTimeUtc</code>：获取目录上次 UTC 写入时间。</li>
<li><code>GetLogicalDrives</code>：检索计算机上逻辑驱动器名称的字符串数组。</li>
<li><code>SetCreationTime</code>：设置目录的创建时间。</li>
<li><code>SetCreationTimeUtc</code>：设置目录的 UTC 创建时间。</li>
<li><code>SetCurrentDirectory</code>：设置应用程序的当前工作目录。</li>
<li><code>SetLastAccessTime</code>：设置目录上次访问时间。</li>
<li><code>SetLastAccessTimeUtc</code>：设置目录上次 UTC 访问时间。</li>
<li><code>SetLastWriteTime</code>：设置目录上次写入时间。</li>
<li><code>SetLastWriteTimeUtc</code>：设置目录上次 UTC 写入时间。</li>
</ul>
<h3 id="DirectorInfo类"><a href="#DirectorInfo类" class="headerlink" title="DirectorInfo类"></a>DirectorInfo类</h3><p>DirectoryInfo类的作用类似于FileInfo类。它是一个实例化的对象，表示计算机上的单一目录。与FileInfo类一样，在Directory和DirectoryInfo之间存在许多类似的方法调用。选择使用File 或FileInfo方法的规则也适用于DirectoryInfo方法: </p>
<ul>
<li>如果执行单一调用，就使用静态Directory类。</li>
<li>如果执行一系列调用，则使用实例化的DirectoryInfo对象。</li>
</ul>
<p>DirectoryInfo类的大多数属性继承自FileSystemInfo， 与FileInfo 类一样， 但这些属性作用于目录上，而不是文件上。还有两个DirectoryInfo专用属性。</p>
<ul>
<li>Parent<ul>
<li>检索一个DirectorInfo对象，表示包含当前目录的目录。这个属性是只读的。</li>
</ul>
</li>
<li>Root<ul>
<li>检索一个DirectorInfo对象，表示包含当前目录的根目录，例如C:\。这个属性是只读的。</li>
</ul>
</li>
</ul>
<h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><h3 id="FileStream"><a href="#FileStream" class="headerlink" title="FileStream"></a>FileStream</h3><p>FileStream是C#中用于读写文件的类，它属于System.IO命名空间。要使用FileStream操作文件，您需要创建一个FileStream类的对象。这个对象有四个参数：文件名、FileMode、FileAccess和FileShare。它为文件操作提供了一个流，可以执行同步和异步的读写操作。</p>
<p>当您创建一个FileStream类的对象时，需要提供四个参数：文件名、FileMode、FileAccess和FileShare。</p>
<ul>
<li>文件名（FileName）：指定要打开或创建的文件的名称。</li>
<li>FileMode：指定操作文件时所使用的模式。它是一个枚举类型，包括以下几种值：Append（在文件末尾追加内容）、Create（创建新文件，如果文件已存在则覆盖）、CreateNew（创建新文件，如果文件已存在则引发异常）、Open（打开现有文件）、OpenOrCreate（打开现有文件，如果文件不存在则创建新文件）和Truncate（打开现有文件并截断为零字节）。</li>
<li>FileAccess：指定对文件的访问权限。它是一个枚举类型，包括以下几种值：Read（读取权限）、ReadWrite（读写权限）和Write（写入权限）。</li>
<li>FileShare：指定文件的共享级别。它是一个枚举类型，包括以下几种值：None（拒绝共享）、Read（允许随后打开该文件进行读取）、ReadWrite（允许随后打开该文件进行读取或写入）、Write（允许随后打开该文件进行写入）和Delete（允许随后删除该文件）。</li>
</ul>
<h4 id="using框架"><a href="#using框架" class="headerlink" title="using框架"></a>using框架</h4><p>将创建文件流对象的过程写在using框架中，会自动挡释放占用的资源</p>
<ul>
<li>创建流的过程写在小括号中</li>
<li>创建、写入的过程写在大括号中</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用FileStream读取文件"><a href="#使用FileStream读取文件" class="headerlink" title="使用FileStream读取文件"></a>使用FileStream读取文件</h4><h5 id="样例1-5"><a href="#样例1-5" class="headerlink" title="样例1"></a>样例1</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用文件流打开一个文件</span></span><br><span class="line">            <span class="comment">// 常用的一个重载是第一个参数是路径，第二个参数是打开方式</span></span><br><span class="line">            <span class="comment">// 其中第二个参数是一个枚举类型的参数。可以选择打开、创建、追加等方式打开文件</span></span><br><span class="line">            <span class="comment">// 这里选的枚举值是打开或创建。对于单独打开来说，如果文件不存在就会跑异常，对于打开或创建来说，如果不存在就创建一个，然后再打开</span></span><br><span class="line">            <span class="comment">// 第三个参数的意思是对文件进行什么操作。是读、写还是又读又写</span></span><br><span class="line">            FileStream fsReader = <span class="keyword">new</span> FileStream(<span class="string">@&quot;D:\tmp\tmp.txt&quot;</span>, FileMode.OpenOrCreate, FileAccess.Read);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一个5兆的buffer</span></span><br><span class="line">            <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取数据，一次只读5兆的数据</span></span><br><span class="line">            <span class="comment">//参数依次为：读取到哪个数组、从哪个地方开始读、读多少数据</span></span><br><span class="line">            <span class="comment">//能少则少，降低内存压力</span></span><br><span class="line">            <span class="comment">//返回值是实际读到的字节数</span></span><br><span class="line">            <span class="built_in">int</span> len = fsReader.Read(buffer, <span class="number">0</span>, buffer.Length);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将读到的字节按照指定的编码格式解码成字符串</span></span><br><span class="line">            <span class="comment">//最好限制一下解码长度。可能版本更新了修复了？？</span></span><br><span class="line">            <span class="built_in">string</span> str = Encoding.UTF8.GetString(buffer, <span class="number">0</span>, len);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(str);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;读到了<span class="subst">&#123;len &#125;</span>个字节&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//使用完毕后一定要关闭流</span></span><br><span class="line">            <span class="comment">//文件流是少数的几个垃圾回收机制gc回收不了的东西</span></span><br><span class="line">            fsReader.Close();<span class="comment">//关闭流</span></span><br><span class="line">            fsReader.Dispose();<span class="comment">//释放资源</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="样例2-使用using框架改造样例1"><a href="#样例2-使用using框架改造样例1" class="headerlink" title="样例2 使用using框架改造样例1"></a>样例2 使用using框架改造样例1</h5><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>];</span><br><span class="line">            <span class="built_in">int</span> len;</span><br><span class="line">            <span class="keyword">using</span> (FileStream fsReader = <span class="keyword">new</span> FileStream(<span class="string">@&quot;D:\tmp\tmp.txt&quot;</span>, FileMode.OpenOrCreate, FileAccess.Read))</span><br><span class="line">            &#123;                </span><br><span class="line">                len = fsReader.Read(buffer, <span class="number">0</span>, buffer.Length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> str = Encoding.UTF8.GetString(buffer, <span class="number">0</span>, len);</span><br><span class="line">            Console.WriteLine(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="使用FileStream写入文件"><a href="#使用FileStream写入文件" class="headerlink" title="使用FileStream写入文件"></a>使用FileStream写入文件</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//5KB的buffer</span></span><br><span class="line">            <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; buffer.Length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                buffer[i] = (<span class="built_in">byte</span>)((i % <span class="number">26</span>) + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 对于文件流的写入，只要每次流不断，文件指针就不会断。</span></span><br><span class="line"><span class="comment">             * 比如下方的例子中的Write方法，第二个值的意思是相对文件指针的位置，</span></span><br><span class="line"><span class="comment">             * 虽然循环了十次，但写入的起始位置第一次是0，第二次就是50兆+1的位置，</span></span><br><span class="line"><span class="comment">             * 依次类推。</span></span><br><span class="line"><span class="comment">             * 虽然wirte的第2、3个参数是int，但不代表不能写入超过int大小的字节数</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             * 对于覆盖：</span></span><br><span class="line"><span class="comment">             * 不想file的全部覆盖，filestream的覆盖是只覆盖有的字符。</span></span><br><span class="line"><span class="comment">             * 比如文件原先是已经存在了的，文件中存在100字节的内容</span></span><br><span class="line"><span class="comment">             * 现在往里面写50个字节，则只有前50个字节会被覆盖，后50个字节原来是什么还是什么</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">using</span> (FileStream fsWrite = <span class="keyword">new</span> FileStream(<span class="string">@&quot;D:\tmp\tmp_using_test.txt&quot;</span>, FileMode.OpenOrCreate, FileAccess.Write))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++)</span><br><span class="line">                &#123;</span><br><span class="line">                    fsWrite.Write(buffer, <span class="number">0</span>, buffer.Length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="StreamReader、StreamWriter"><a href="#StreamReader、StreamWriter" class="headerlink" title="StreamReader、StreamWriter"></a>StreamReader、StreamWriter</h3><p>常用于操作字符。</p>
<p>using框架同样适用于这两个。</p>
<h4 id="样例1：使用StreamReader逐行读取文本文件，并将结果在控制台显示出来。"><a href="#样例1：使用StreamReader逐行读取文本文件，并将结果在控制台显示出来。" class="headerlink" title="样例1：使用StreamReader逐行读取文本文件，并将结果在控制台显示出来。"></a>样例1：使用StreamReader逐行读取文本文件，并将结果在控制台显示出来。</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (StreamReader sr = <span class="keyword">new</span> StreamReader(<span class="string">@&quot;D:\tmp\tmp.txt&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 只要文件流没到结束</span></span><br><span class="line">                <span class="keyword">while</span>(!sr.EndOfStream)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//输出读到的行</span></span><br><span class="line">                    Console.WriteLine(sr.ReadLine());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="样例2：使用StreamWriter向文本文件写入数据"><a href="#样例2：使用StreamWriter向文本文件写入数据" class="headerlink" title="样例2：使用StreamWriter向文本文件写入数据"></a>样例2：使用StreamWriter向文本文件写入数据</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//对于要写入的文件来说，如果文件不存在会自动创建</span></span><br><span class="line">            <span class="keyword">using</span> (StreamWriter sw = <span class="keyword">new</span> StreamWriter(<span class="string">@&quot;D:\tmp\tmp_StreamWrite_test.txt&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//和file一样，全部覆盖</span></span><br><span class="line">                <span class="comment">//第二个参数可以缺省，缺省则表示使用ANSI编码（当前地区的默认编码）写入</span></span><br><span class="line">                sw.Write(<span class="string">&quot;StreamWrite测试&quot;</span>, Encoding.UTF8);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果需要追加，则需要在创建流的时候使用第二个参数</span></span><br><span class="line">            <span class="keyword">using</span> (StreamWriter sw = <span class="keyword">new</span> StreamWriter(<span class="string">@&quot;D:\tmp\tmp_StreamWrite_test.txt&quot;</span>, <span class="literal">true</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                sw.Write(<span class="string">&quot;\n追加测试&quot;</span>, Encoding.UTF8);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h2><p>用于操作文件夹和目录。</p>
<p>可以创建、复制、移动和删除目录和子目录。</p>
<p>Directory类是静态类，直接调用即可。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//在指定目录下创建一个文件夹</span></span><br><span class="line">            <span class="comment">//可以依次创建直到指定的目录都可以被访问到</span></span><br><span class="line">            <span class="comment">//如果指定的目录不存在则不进行操作</span></span><br><span class="line">            <span class="comment">//Directory.CreateDirectory(@&quot;D:\tmp\tmp\CreateTheDirectory&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除指定的文件夹：</span></span><br><span class="line">            <span class="comment">// 只能删除空的文件夹。如果文件夹非空，则抛异常</span></span><br><span class="line">            <span class="comment">// 只会删除指定的文件夹，对于指定文件夹之前的路径不会进行删除</span></span><br><span class="line">            <span class="comment">//Directory.Delete(@&quot;D:\tmp\tmp\CreateTheDirectory&quot;);</span></span><br><span class="line">            <span class="comment">// 如果要删除目标文件夹不是空的，里面含义子目录或者文件，可以使用第二个参数</span></span><br><span class="line">            <span class="comment">// 将第二个参数的值设置成true后表示全部删除</span></span><br><span class="line">            <span class="comment">//Directory.Delete(@&quot;D:\tmp\tmp\CreateTheDirectory&quot;,true);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//移动指定的文件夹</span></span><br><span class="line">            <span class="comment">// 如果指定的文件夹不存在，则抛出异常</span></span><br><span class="line">            <span class="comment">// 在移动的时候可以对文件夹进行重命名</span></span><br><span class="line">            <span class="comment">// 如果文件夹中存在子文件夹或文件，则照样移动</span></span><br><span class="line">            <span class="comment">//Directory.Move(@&quot;D:\tmp\tmp1&quot;, @&quot;D:\tmp\tmp\tmpTest&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取指定文件夹下的所有文件名</span></span><br><span class="line">            <span class="comment">// 对所有的文件汇集到string数组中，但不汇集子目录下的文件</span></span><br><span class="line">            <span class="comment">//string[] FileName = Directory.GetFiles(@&quot;D:\tmp\&quot;);</span></span><br><span class="line">            <span class="comment">//foreach (string str in FileName)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    Console.WriteLine(str);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            <span class="comment">// 可以筛选只要符合要求的文件。比如只要MP3文件</span></span><br><span class="line">            <span class="comment">// 使用第二个参数可以进行搜索匹配，支持通配符</span></span><br><span class="line">            <span class="comment">//FileName = Directory.GetFiles(@&quot;D:\tmp\&quot;, &quot;*.mp3&quot;);</span></span><br><span class="line">            <span class="comment">//foreach (string str in FileName)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    Console.WriteLine(str);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取指定目录下所有文件夹的路径</span></span><br><span class="line">            <span class="comment">// 如果指定的文件夹不存在，则抛异常</span></span><br><span class="line">            <span class="comment">//string[] DirectoryName = Directory.GetDirectories(@&quot;D:\tmp1\&quot;);</span></span><br><span class="line">            <span class="comment">//foreach(string dir in DirectoryName)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    Console.WriteLine(dir);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断指定的路径是否存在</span></span><br><span class="line">            Console.WriteLine(Directory.Exists(<span class="string">@&quot;D:\tmp\&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>















































<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="进程和线程基础知识"><a href="#进程和线程基础知识" class="headerlink" title="进程和线程基础知识"></a>进程和线程基础知识</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>可以将计算机中每一个运行的程序视为一个进程。而一个进程又是由多个线程组成的。</p>
<p>进程指一个应用程序所运行的操作系统单元，它是操作系统环境中的基本成分、是系统进行资源分配的基本单位。</p>
<p>进程是执行程序的实例。<br>当运行一个应用程序后，就生成了一个进程，这个进程拥有自己的独立内存空间。<br>每一个进程对应一个活动的程序，当进程激活时，操作系统就将系统的资源包括内存、I&#x2F;O和CPU等分配给它，使它执行。</p>
<ul>
<li>进程在运行时创建的资源随着进程的终止而死亡。</li>
<li>进程间获得专用数据或内存的唯一途径就是通过协议来共享内存块，这是一种协作策略。</li>
<li>一个进程可以创建多个线程及子进程（启动外部程序）。</li>
<li>一个进程内部的线程可以共享该进程所分配的资源。</li>
</ul>
<p>由于进程之间的切换非常消耗资源和时间，为了提高操作系统的并发性，提高CPU的利用率，在进程下面又加入了线程的概念。<br>线程的创建与撤销、线程之间的切换所占用的资源比进程少很多。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>在.Net环境下，是不允许跨线程访问的。</p>
<p>进程可以分为若干个独立执行流（路径），这些执行流被称为线程。</p>
<p>线程是指进程内的一个<strong>执行单元</strong>，也是进程内的可调度实体。<br>线程是进程的一个实体，是CPU调度和分配时间的基本单位。</p>
<p>线程基本不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），但是它可与同一进程的其它线程共享进程所拥有的全部资源。<br>所以线程间共享内存空间很容易做到，多线程协作也很容易和便捷。</p>
<p>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程间可以并发执行。</p>
<p>线程提供了多任务处理的能力。</p>
<h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><ul>
<li><p>地址空间：</p>
<ul>
<li><p>进程拥有自己独立的内存地址空间；</p>
</li>
<li><p>线程共享进程的地址空间；</p>
<blockquote>
<p>换句话说就是进程间彼此是完全隔绝的，同一进程的所有线程共享(堆heap)内存；</p>
</blockquote>
</li>
</ul>
</li>
<li><p>资源拥有：</p>
<ul>
<li>进程是资源分配和拥有的单位</li>
<li>同一进程内的线程共享进程的资源；</li>
</ul>
</li>
<li><p>系统粒度：</p>
<ul>
<li>进程是分配资源的基本单位</li>
<li>线程则是系统（处理器）调度的基本单位；</li>
</ul>
</li>
<li><p>执行过程：</p>
<ul>
<li>每个独立的进程都有一个程序运行的入口、顺序执行序列和程序的出口；</li>
<li>线程不能独立执行，必须依存于进程中；</li>
</ul>
</li>
<li><p>系统开销：</p>
<p>创建或撤销进程时，系统都要为之分配或回收资源（如内存空间、IO设备）<br>进程间的切换也要消耗远大于线程切换的开销。</p>
</li>
</ul>
<p>二者均可并发执行。</p>
<p>一个程序至少有一个进程，一个进程至少有一个线程（主线程）。<br>主线程以函数地址的形式，如Main或WinMain函数，提供程序的启动点，当主线程终止时，进程也随之终止。<br>一个进程中的所有线程都在该进程的虚拟地址空间中，使用该进程的全局变量和系统资源。</p>
<h3 id="并发-并行"><a href="#并发-并行" class="headerlink" title="并发&#x2F;并行"></a>并发&#x2F;并行</h3><p>在单CPU系统中，系统调度在某一刻只能让一个线程运行，虽然这种调度机制有多种形式（时分&#x2F;频分），但无论如何，要通过不断切换需要运行的线程，这种运行模式称为并发（Concurrent）。</p>
<p>而在多CPU系统中，可以让两个以上的线程同时运行，这种运行模式称为并行（Parallel）。</p>
<h3 id="同步-异步操作"><a href="#同步-异步操作" class="headerlink" title="同步&#x2F;异步操作"></a>同步&#x2F;异步操作</h3><h4 id="同步与异步的定义"><a href="#同步与异步的定义" class="headerlink" title="同步与异步的定义"></a>同步与异步的定义</h4><p>同步和异步关注的是消息通信机制 (synchronous communication&#x2F; asynchronous communication)</p>
<ul>
<li>同步，就是调用某个东西，调用方得等待这个调用返回结果才能继续往后执行。（类似于函数调用？直到执行完成后才能进行下一步操作）</li>
<li>异步，和同步相反 调用方不会立即得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状态来通知调用者，或者通过回掉函数来处理这个调用。</li>
</ul>
<p>所有的程序最终都会由计算机硬件来执行，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。<br>这些无须消耗CPU时间的I&#x2F;O操作是异步操作的硬件基础。<br>硬盘、光驱、网卡、声卡、显卡都具有DMA功能。</p>
<p>DMA（DirectMemory Access）是直接内存访问的意思，它是不经过CPU而直接进行内存数据存储的数据交换模式。</p>
<p>I&#x2F;O操作包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.Net Remoting等跨进程的调用。</p>
<p>异步操作可达到避免调用线程堵塞的目的，从而提高软件的可响应性。</p>
<h4 id="同步与异步的对比"><a href="#同步与异步的对比" class="headerlink" title="同步与异步的对比"></a>同步与异步的对比</h4><p>线程不是一个计算机的硬件功能，而是操作系统提供的一种逻辑功能，线程本质上是进程中一段并发运行的代码，所以线程需要操作系统投入CPU资源来运行和调度。</p>
<p>异步模式无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必共享变量，减少了死锁的可能。</p>
<p>不过，编写异步操作的复杂程度比较高，程序主要使用回调方式进行处理，与人的思维方式有出入，而且难以调试。</p>
<p>计算密集型工作使用多线程（如图形处理、算法）；IO密集型工作使用异步机制。</p>
<h3 id="任务管理器"><a href="#任务管理器" class="headerlink" title="任务管理器"></a>任务管理器</h3><p>映射名称列：<br>	进程并不拥有独立于其所属实例的映射名称；</p>
<blockquote>
<p>如果运行5个Notepad拷贝，你会看到5个称为Notepad.exe的进程；</p>
</blockquote>
<p>它们是根据进程ID进行区分的，该进程ID是由系统维护，并可以循环使用。</p>
<p>CPU列：<br>它是进程中线程所占用的CPU时间百分比</p>
<p>每个任务管理器中的进程，其实内部都包含若干个线程，每个时间点都是某个程序进程中的某个线程在运行。</p>
<h3 id="线程是如何工作的"><a href="#线程是如何工作的" class="headerlink" title="线程是如何工作的"></a>线程是如何工作的</h3><p>线程被一个线程协调程序管理着——一个CLR委托给操作系统的函数。<br>线程协调程序确保将所有活动的线程被分配适当的执行时间；<br>并且那些等待或阻止的线程——比如说在排它锁中、或在用户输入——都是不消耗CPU时间的。</p>
<p>在单核处理器的电脑中，线程协调程序完成一个时间片之后迅速地在活动的线程之间进行切换执行。<br>这就导致“波涛汹涌”的行为，例如在第一个例子，每次重复的X 或 Y 块相当于分给线程的时间片。<br>在Windows XP中时间片通常在10毫秒内选择要比CPU开销在处理线程切换的时候的消耗大的多。(即通常在几微秒区间)</p>
<p>在多核的电脑中，多线程被实现成混合时间片和真实的并发——不同的线程在不同的CPU上运行。<br>但这仍然会出现一些时间切片,因为操作系统的服务线程、以及一些其他的应用程序都会争夺对CPU的使用权。</p>
<p>线程由于外部因素（比如时间片）被中断被称为被抢占，在大多数情况下,一个线程在被抢占的那一刻就失去了对它的控制权。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>当使用线程（Thread）时，必须注意同步处理的问题</p>
<p>理论上每个Thread都是独立运行的个体，由CLR来主导排程，视Thread的优先权的设置，每个Thread会分到特定的运行时间，当某个Thread的运行时间用完时，CLR就会强制将运行权由该Thread取回，转交给下个Thread</p>
<p>这也就意味着Thread本身无法得知自己何时会丧失运行权，所以会发生所谓的race condition（竞速状态）。</p>
<p>当两个线程争夺一个锁的时候（在这个例子里是locker），一个线程等待，或者说被阻止到那个锁变的可用。<br>在这种情况下，就确保了在同一时刻只有一个线程能进入临界区，所以”Done”只被打印了1次。代码以如此方式在不确定的多线程环境中被叫做线程安全。</p>
<p>临时暂停，或阻止是多线程的协同工作，同步活动的本质特征。<br>等待一个排它锁被释放是一个线程被阻止的原因，另一个原因是线程想要暂停或Sleep一段时间：</p>
<p>Thread.Sleep (TimeSpan.FromSeconds (30)); &#x2F;&#x2F; 阻止30秒</p>
<p>一个线程也可以使用它的Join方法来等待另一个线程结束：</p>
<p>Threadt &#x3D; new Thread(Go); &#x2F;&#x2F; 假设Go是某个静态方法</p>
<p>t.Start();</p>
<p>t.Join(); &#x2F;&#x2F; 等待（阻止）直到线程t结束</p>
<h2 id="使用多线程的情况分析"><a href="#使用多线程的情况分析" class="headerlink" title="使用多线程的情况分析"></a>使用多线程的情况分析</h2><h3 id="2-1-为什么要使用多线程"><a href="#2-1-为什么要使用多线程" class="headerlink" title="2.1 为什么要使用多线程"></a>2.1 为什么要使用多线程</h3><ul>
<li>并发需要<br>在C&#x2F;S或B&#x2F;S模式下的服务端需要处理来自不同终端的并发请求，使用单线程是不可思议的。</li>
<li>提高应用程序的响应速度<br>当一个耗时的操作进行时，当前程序都会等待这个操作结束<br>此时程序不会响应键盘、鼠标、菜单等操作，程序处于假死状态；<br>使用多线程可将耗时长的操作（Time Consuming）置于一个新的线程，此时程序仍能响应用户的其它操作</li>
<li>提高CPU利用率<br>在多CPU体系中，操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</li>
<li>改善程序结构<br>一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分<br>这样的程序会利于理解和修改。</li>
<li>花销小、切换快<br>线程间的切换时间很小，可以忽略不计</li>
<li>方便的通信机制<br>线程间共享内存，互相间交换数据很简单。</li>
</ul>
<p>多线程的意义在于<br>一个应用程序中，有多个执行部分可以同时执行：<br>一个线程可以在后台读取数据，而另一个线程可以在前台展现已读取的数据。</p>
<p>C#支持通过多线程并行地执行代码，一个线程有它独立的执行路径，能够与其它的线程同时地运行。<br>一个C#程序开始于一个单线程，这个单线程是被CLR和操作系统（也称为“主线程”）自动创建的，并具有多线程创建额外的线程。</p>
<h4 id="何时使用多线程"><a href="#何时使用多线程" class="headerlink" title="何时使用多线程"></a>何时使用多线程</h4><p>多线程程序一般被用来在后台执行耗时的任务：主线程保持运行，而工作线程执行后台工作。</p>
<ul>
<li>对于Windows Forms程序来说，如果主线程执行了一个冗长的操作，键盘和鼠标的操作会变的迟钝，程序也会失去响应，进入假死的状态，可能导致用户强制结束程序进程而出现错误。<br>有鉴于此，应该在主线程运行一个耗时任务时另外添加一个工作线程，同时在主线程上有一个友好的提示“处理中…”，允许继续接收事件（比如响应鼠标、键盘操作）。<br>同时程序还应该实现“取消”功能，允许取消&#x2F;结束当前工作线程。<br>BackgroundWorker类就提供这一功能。</li>
<li>在没有用户界面的程序里，比如说WindowsService中使用多线程特别的有意义。<br>当一个任务有潜在的耗时（在等待被请求方的响应——比如应用服务器，数据库服务器），用工作线程完成任务意味着主线程可以在发送请求后立即做其它的事情。</li>
<li>另一个多线程的用途是在需要完成一个复杂的计算工作时,它会在多核的电脑上运行得更快，如果工作量被多个线程分开的话（C#中可使用Environment.ProcessorCount属性来侦测处理芯片的数量）。</li>
</ul>
<p>远程服务器，或WebServices或ASP.NET程序将别无选择，必须使用多线程；</p>
<p>一个单线程的ASP.NET Web Service是不可想象的；</p>
<p>幸运的是，应用服务器中多线程是相当普遍的；</p>
<p>唯一值得关心的是提供适当锁机制的静态变量问题。</p>
<h3 id="何时不用多线程"><a href="#何时不用多线程" class="headerlink" title="何时不用多线程"></a>何时不用多线程</h3><p>多线程也同样会带来缺点，最大的问题是它使程序变的过于复杂。<br>拥有多线程本身并不复杂，复杂是的线程的交互作用。<br>无论交互是否是有意的，都会带来较长的开发周期，以及带来间歇性和非重复性的Bugs。<br>因此，要么多线程的交互设计简单一些，要么就根本不使用多线程，除非你有强烈的重写和调试欲望。</p>
<p>当用户频繁地分配和切换线程时，多线程会带来增加资源和CPU的开销。<br>在某些情况下，太多的I&#x2F;O操作是非常棘手的，当只有一个或两个工作线程要比有众多的线程在相同时间执行任务快的多。</p>
<h2 id="C-中的线程"><a href="#C-中的线程" class="headerlink" title="C#中的线程"></a>C#中的线程</h2><h3 id="程序域"><a href="#程序域" class="headerlink" title="程序域"></a>程序域</h3><p>在.Net中Process由AppDomain对象所取代。</p>
<p>虽然AppDomain在CLR中被视为Process的替代品，但实际上AppDomain跟Process是属于主从关系的，AppDomain被放置在一个Process中，<br>每个Process可以拥有多个AppDomain，<br>每个AppDomain又可拥有多个Thread对象。</p>
<p>Process、AppDomain、Thread的关系如下图所示：</p>
<p><img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/image-20230515195414250.png" alt="image-20230515195414250"></p>
<p>AppDomain定义了一些事件供程序员使用。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AssemblyLoad</td>
<td>触发于AppDomain载入一个Assembly时</td>
</tr>
<tr>
<td>DomainUnLoad</td>
<td>触发于AppDomain卸载时，也就是Unload函数被调用或是该AppDomain被消灭前</td>
</tr>
<tr>
<td>ProcessExit</td>
<td>当默认的AppDomain被卸载时触发，多半是应用程序退出时</td>
</tr>
</tbody></table>
<p>各AppDomain间互不影响。</p>
<h3 id="C-中实现线程的方法"><a href="#C-中实现线程的方法" class="headerlink" title="C#中实现线程的方法"></a>C#中实现线程的方法</h3><p>一个C#程序成为多线程可以通过2种方式来实现：</p>
<ul>
<li>明确地创建和运行多线程</li>
<li>使用.NET Framework中封装了多线程的类<br>比如:<ul>
<li>BackgroundWorker类</li>
<li>线程池</li>
<li>Threading Timer</li>
</ul>
</li>
</ul>
<h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>使用Thread类通过ThreadStart（无参数）或ParameterizedThreadStart（一个输入参数）类型的委托创建一个Thread对象，开启一个新线程，执行该委托传递的任务，此时线程尚未处于运行状态。</li>
<li>调用Start()函数启动线程，当前线程继续执行。</li>
<li>调用Join()函数可以阻塞当前线程，直到调用Join()的线程终止。</li>
<li>调用Abort()方法，如需中止线程，在调用该方法的线程上抛出ThreadAbortException异常，以结束该线程</li>
<li>可以通过Thread.ResetAbort()方法阻止线程的中止。</li>
</ul>
<h3 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Name</td>
<td>属性，获取或设置线程的名称</td>
</tr>
<tr>
<td>Priority</td>
<td>属性，获取或设置线程的优先级</td>
</tr>
<tr>
<td>ThreadState</td>
<td>属性，获取线程当前的状态</td>
</tr>
<tr>
<td>IsAlive</td>
<td>属性，获取当前线程是否处于启动状态</td>
</tr>
<tr>
<td>IsBackground</td>
<td>属性，获取或设置值，表示该线程是否为后台线程</td>
</tr>
<tr>
<td>CurrentThread</td>
<td>属性，获取当前正在运行的线程</td>
</tr>
</tbody></table>
<h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Start()</td>
<td>方法，启动线程</td>
</tr>
<tr>
<td>Sleep(int millisecondsTimout)</td>
<td>方法，将当前线程暂停指定的毫秒数</td>
</tr>
<tr>
<td>Suspend()</td>
<td>方法，挂起当前线程（已经被弃用）</td>
</tr>
<tr>
<td>Join()</td>
<td>方法，阻塞调用线程，直到某个线程终止为止</td>
</tr>
<tr>
<td>Interrupt()</td>
<td>方法，中断当前线程</td>
</tr>
<tr>
<td>Resume()</td>
<td>方法，继续已经挂起的线程（已经被弃用）</td>
</tr>
<tr>
<td>Abort()</td>
<td>方法，终止线程（已经被弃用）</td>
</tr>
</tbody></table>
<h3 id="开启线程"><a href="#开启线程" class="headerlink" title="开启线程"></a>开启线程</h3><p>首先用new申请Thread对象，然后对象调用Start()方法启用线程。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DownLoad</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;DownLoad Begin &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;DownLoad End&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建Thread对象</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(DownLoad);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        thread.Start();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Main&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Thread.CurrentThread.ManagedThreadId获取当前线程的ID，便于管理。</p>
</blockquote>
<p>用Lambda表达式代替函数调用，也能达到相同的效果</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;DownLoad Begin &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;DownLoad End&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.Start();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Main&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>有两种为线程传递参数的方法：</p>
<ul>
<li>Start()函数传参法</li>
<li>对象成员方法传参法</li>
<li>匿名方法传参法</li>
</ul>
<h4 id="Start-函数传参"><a href="#Start-函数传参" class="headerlink" title="Start()函数传参"></a>Start()函数传参</h4><p>为某方法创建新线程后，在使用Start()方法启动线程时传递该方法需要的参数。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DownLoad</span>(<span class="params"><span class="built_in">object</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;DownLoad Begin &quot;</span> + name);</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;DownLoad End&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建Thread对象</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(DownLoad);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        thread.Start(<span class="string">&quot;April&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Main&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对象传递"><a href="#对象传递" class="headerlink" title="对象传递"></a>对象传递</h4><p>初始化一个对象，然后用对象的方法初始化Thread，这样该线程就可以使用这个对象的所有成员。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Download</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> Id;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> Name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Download</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Id = id;</span><br><span class="line">            Name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DownloadFile</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;DownLoad Begin &quot;</span> + <span class="string">&quot;ID: &quot;</span> + Id + <span class="string">&quot; Name: &quot;</span> + Name);</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;DownLoad End&quot;</span>);              </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Download download = <span class="keyword">new</span> Download(<span class="number">1</span>, <span class="string">&quot;人民日报&quot;</span>);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(download.DownloadFile);</span><br><span class="line">        thread.Start();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Main&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匿名方法-1"><a href="#匿名方法-1" class="headerlink" title="匿名方法"></a>匿名方法</h4><p>需要接收多个参数的解决方案是使用一个匿名方法调用，方法如下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="built_in">delegate</span>() &#123; WriteText(<span class="string">&quot;Hello&quot;</span>); &#125;);</span><br><span class="line">        t.Start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteText</span>(<span class="params"><span class="built_in">string</span> text</span>)</span></span><br><span class="line">    &#123; </span><br><span class="line">        Console.WriteLine(text); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的优点是目标方法（这里是WriteText），可以接收任意数量的参数，并且没有装箱操作。</p>
<p>不过这需要将一个外部变量放入到匿名方法中，如下示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> text = <span class="string">&quot;Before&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="built_in">delegate</span> () &#123; WriteText(text); &#125;);</span><br><span class="line"></span><br><span class="line">        text = <span class="string">&quot;After&quot;</span>;</span><br><span class="line"></span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteText</span>(<span class="params"><span class="built_in">string</span> text</span>)</span> </span><br><span class="line">    &#123; </span><br><span class="line">        Console.WriteLine(text); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是:<br>当外部变量的值被修改，匿名方法可能进行无意的互动，导致一些古怪的现象。<br>一旦线程开始运行，外部变量最好被处理成只读的。除非有人愿意使用适当的锁。</p>
<h3 id="线程命名"><a href="#线程命名" class="headerlink" title="线程命名"></a>线程命名</h3><p>线程可以通过它的Name属性进行命名，这非常有利于调试：</p>
<p>可以用Console.WriteLine打印出线程的名字</p>
<p>Microsoft Visual Studio可以将线程的名字显示在调试工具栏的位置上。</p>
<p>线程的名字可以在被任何时间设置，但只能设置一次，重命名会引发异常。</p>
<p>程序的主线程也可以被命名，下面例子里主线程通过CurrentThread命名：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ThreadNaming</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thread.CurrentThread.Name = <span class="string">&quot;main&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Thread worker = <span class="keyword">new</span> Thread(Go);</span><br><span class="line"></span><br><span class="line">        worker.Name = <span class="string">&quot;worker&quot;</span>;</span><br><span class="line"></span><br><span class="line">        worker.Start();</span><br><span class="line"></span><br><span class="line">        Go();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello from &quot;</span> + Thread.CurrentThread.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p>Hellofrom main</p>
<p>Hellofrom worker</p>
<h3 id="前台线程和后台线程"><a href="#前台线程和后台线程" class="headerlink" title="前台线程和后台线程"></a>前台线程和后台线程</h3><ul>
<li>前台线程(用户界面线程)<br>只要存在有一个前台线程在运行，应用程序就在运行<br>通常用来处理用户的输入并响应各种事件和消息</li>
<li>后台线程(工作线程)<br>应用程序关闭时，如果后台线程没有执行完，会被强制性的关闭<br>用来执行程序的后台处理任务，比如计算、调度、对串口的读写操作等</li>
</ul>
<p>例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DownLoad</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;DownLoad Begin &quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;DownLoad End&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建Thread对象</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(DownLoad);</span><br><span class="line">        <span class="comment">//设为后台线程</span></span><br><span class="line">        thread.IsBackground = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        thread.Start();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，thread被设置为后台线程。<br>Main执行完后，没有前台线程了，应用程序就结束，虽然后台线程thread此时尚未执行完，也被终止。</p>
<blockquote>
<p>改变线程从前台到后台不会以任何方式改变它在CPU协调程序中的优先级和状态。</p>
</blockquote>
<p>拥有一个后台工作线程是有益的，最直接的理由是当提到结束程序它总是可能有最后的发言权。</p>
<p>交织以不会消亡的前台线程，保证程序的正常退出。</p>
<p>抛弃一个前台工作线程是尤为险恶的，尤其对Windows Forms程序，因为程序直到主线程结束时才退出（至少对用户来说），但是它的进程仍然运行着。</p>
<p>在Windows任务管理器它将从应用程序栏消失不见，但却可以在进程栏找到它。</p>
<p>除非用户找到并结束它，它将继续消耗资源，并可能阻止一个新的实例的运行从开始或影响它的特性。</p>
<p>对于程序失败退出的普遍原因就是存在“被忘记”的前台线程。</p>
<table>
<thead>
<tr>
<th>线程类型</th>
<th>动作</th>
<th>结束</th>
<th>后续处理</th>
</tr>
</thead>
<tbody><tr>
<td>前台线程</td>
<td>主程序关闭</td>
<td>否</td>
<td>显示关闭线程&#x2F;杀掉当前进程</td>
</tr>
<tr>
<td>后台线程</td>
<td>主程序关闭</td>
<td>是</td>
<td>无</td>
</tr>
</tbody></table>
<h3 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p>Thread类创建的线程默认为前台线程，可以通过IsBackground属性设置其为前台或后台线程。</p>
<blockquote>
<p>用Thread类创建的线程是前台线程，线程池中的线程总是后台线程</p>
</blockquote>
</li>
<li><p>可以通过Priority属性设置线程的优先级。</p>
</li>
<li><p>线程内部可以通过try catch捕获该异常，在catch模块中进行一些必要的处理<br>如释放持有的锁和文件资源等</p>
</li>
<li><p>慎重使用Abort()方法<br>如果在当前线程中抛出该异常，其结果是可预测的<br>但是对于其他线程，它会中断任何正在执行的代码，有可能中断静态对象的生成，造成不可预测的结果。</p>
</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>ThreadPool类维护一个线程的列表，提供给用户以执行不同的小任务，减少频繁创建线程的开销。</p>
<p>该线程池可用于执行任务、发送工作项、处理异步 I&#x2F;O、代表其他线程等待以及处理计时器。</p>
<p>线程池其实就是一个存放线程对象的“池子(pool)”，他提供了一些基本方法，如：设置pool中最小&#x2F;最大线程数量、把要执行的方法排入队列等等。ThreadPool是一个静态类，因此可以直接使用，不用创建对象。</p>
<h3 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h3><p>每新建一个线程都需要占用内存空间和其他资源<br>而新建了那么多线程，有很多在休眠，或者在等待资源释放；<br>又有许多线程只是周期性的做一些小工作，如刷新数据等等，太浪费了，划不来。<br>实际编程中大量线程突发，然后在短时间内结束的情况很少见。</p>
<p>于是，就提出了线程池的概念。</p>
<p>线程池中的线程执行完指定的方法后并不会自动消除，而是以挂起状态返回线程池，如果应用程序再次向线程池发出请求，那么处以挂起状态的线程就会被激活并执行任务，而不会创建新线程，这就节约了很多开销。</p>
<p>只有当线程数达到最大线程数量，系统才会自动销毁线程。</p>
<p>因此，使用线程池可以避免大量的创建和销毁的开支，具有更好的性能和稳定性，其次，开发人员把线程交给系统管理，可以集中精力处理其他任务。</p>
<h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><ul>
<li>设置线程池最大最小：<br><code>ThreadPool.SetMaxThreads (int workerThreads,int completionPortThreads)</code><ul>
<li>设置可以同时处于活动状态的线程池的请求数目。所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。<br>还可以设置最小线程数。</li>
<li>将任务添加进线程池:<br><code>ThreadPool.QueueUserWorkItem(new WaitCallback(方法名));</code>或<code>ThreadPool.QueueUserWorkItem(new WaitCallback(方法名), 参数);</code></li>
</ul>
</li>
</ul>
<p>但是线程池的使用也有一些限制：</p>
<ul>
<li>线程池中的线程均为后台线程，并且不能修改为前台线程</li>
<li>不能给入池的线程设置优先级或名称</li>
<li>对于COM对象，入池的所有线程都是多线程单元（MTA）线程，许多COM对象都需要单线程单元（STA） 线程</li>
<li>入池的线程只适合时间较短的任务，如果线程需要长时间运行，应使用Thread类创建线程或使用Task的LongRunning选项</li>
<li>.Net下线程池最小默认允许4个工作线程，最大允许2048个工作线程。<br>并发线程启动后，瞬间会启动4个线程。<br>而剩下的会依据环境每0.5秒或者1秒启动一个。<br>如果同时运行的线程达到Max工作线程，那么剩下的就会挂起<br>直到线程池中的线程有空闲得了，才会去执行。</li>
</ul>
<h2 id="Parallel类"><a href="#Parallel类" class="headerlink" title="Parallel类"></a>Parallel类</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>Parallel和Task类都位于System.Threading.Task命名空间中，是对Thread和ThreadPool类更高级的抽象。</p>
<p>Parrallel类有For()、ForEach()、Invoke()三个方法</p>
<ul>
<li>Invoke()<br>实现任务并行性<br>允许同时调用不同的方法，</li>
<li>Parallel.For()和 Parallel.ForEach()<br>实现数据并行性<br>在每次迭代中调用相同的代码</li>
</ul>
<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="Parallel-For"><a href="#Parallel-For" class="headerlink" title="Parallel.For()"></a>Parallel.For()</h4><p>Parallel.For()方法类似于 C#的 for循环语旬,也是多次执行一个任务。<br>使用Parallel.For()方法,可以并行运行迭代。</p>
<p>迭代的顺序没有定义，不能保证。</p>
<p>在For()方法中：</p>
<ul>
<li>前两个参数定义了循环的开头和结束。示例从0迭代到 9。</li>
<li>第 3个参数是一个Action委托<br>是要并行运行迭代的方法</li>
<li>整数参数是循环的迭代次数,该参数被传递给Action委托引用的方法。</li>
<li>Parallel.For()方法的返回类型是ParalleLoopResult结构,它提供了循环是否结束的信息。</li>
</ul>
<p>案例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ParallelLoopResult result = Parallel.For(<span class="number">0</span>, <span class="number">10</span>, i =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine</span><br><span class="line">        (<span class="string">&quot;i:&#123;0&#125;, thread id: &#123;1&#125;&quot;</span>, i, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        Thread.Sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Is completed: &#123;0&#125;&quot;</span>, result.IsCompleted);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//i: 0, thread id: 9</span></span><br><span class="line">    <span class="comment">//i: 2, thread id: 10</span></span><br><span class="line">    <span class="comment">//i: 1, thread id: 9</span></span><br><span class="line">    <span class="comment">//i: 3, thread id: 10</span></span><br><span class="line">    <span class="comment">//i: 4, thread id: 9</span></span><br><span class="line">    <span class="comment">//i: 6, thread id: 11</span></span><br><span class="line">    <span class="comment">//i: 7, thread id: 10</span></span><br><span class="line">    <span class="comment">//i: 5, thread id: 9</span></span><br><span class="line">    <span class="comment">//i: 8, thread id: 12</span></span><br><span class="line">    <span class="comment">//i: 9, thread id: 11</span></span><br><span class="line">    <span class="comment">//Is completed: True</span></span><br><span class="line"></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同For()循环类似，Parallel.For()方法也可以中断循环的执行。</p>
<p>Parallel.For()方法的一个重载版本接受第3个Action&lt;int, ParallelLoopState&gt;类型的参数。<br>使用这些参数定义一个方法,就可以调用ParalleLoopState的Break()或Stop()方法,以影响循环的结果。</p>
<blockquote>
<p>注意,迭代的顺序没有定义</p>
</blockquote>
<p>案例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ParallelLoopResult result = Parallel.For(<span class="number">0</span>, <span class="number">100</span>, (i, state) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;i:&#123;0&#125;, thread id: &#123;1&#125;&quot;</span>, i, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">10</span>)</span><br><span class="line">            state.Break();</span><br><span class="line"></span><br><span class="line">        Thread.Sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Is completed: &#123;0&#125;&quot;</span>, result.IsCompleted);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Lowest break iteration: &#123;0&#125;&quot;</span>, result.LowestBreakIteration);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//i: 0, thread id: 10</span></span><br><span class="line">    <span class="comment">//i: 25, thread id: 6</span></span><br><span class="line">    <span class="comment">//i: 1, thread id: 10</span></span><br><span class="line">    <span class="comment">//i: 2, thread id: 10</span></span><br><span class="line">    <span class="comment">//i: 3, thread id: 10</span></span><br><span class="line">    <span class="comment">//i: 4, thread id: 10</span></span><br><span class="line">    <span class="comment">//i: 5, thread id: 10</span></span><br><span class="line">    <span class="comment">//i: 6, thread id: 10</span></span><br><span class="line">    <span class="comment">//i: 7, thread id: 10</span></span><br><span class="line">    <span class="comment">//i: 8, thread id: 10</span></span><br><span class="line">    <span class="comment">//i: 9, thread id: 10</span></span><br><span class="line">    <span class="comment">//i: 10, thread id: 10</span></span><br><span class="line">    <span class="comment">//i: 11, thread id: 10</span></span><br><span class="line">    <span class="comment">//Is completed: False</span></span><br><span class="line">    <span class="comment">//Lowest break iteration: 11</span></span><br><span class="line"></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Parallel-For-TLocal"><a href="#Parallel-For-TLocal" class="headerlink" title="Parallel.For &lt; TLocal &gt;"></a>Parallel.For &lt; TLocal &gt;</h4><p>Parallel.For()方法可能使用几个线程来执行循环 。</p>
<p>如果需要对每个线程进行初始化,就可以使用Parallel.For方法。<br>除了from和to对应的值之外,For()方法的泛型版本还接受3个委托参数:</p>
<ul>
<li>第一个参数的类型是Func&lt; TLocal &gt;<br>因为这里的例子对于TLocal使用字符串,所以该方法需要定义为Func&lt; string &gt;,即返回string的方法。<br>这个方法仅对于用于执行迭代的每个线程调用一次</li>
<li>第二个委托参数为循环体定义了委托<br>在示例中,该参数的类型是Func&lt;int, ParallelLoopState, string, string&gt;。<br>其中第一个参数是循环迭代,第二个参数 ParallelLoopstate允许停止循环,如前所述 。<br>循环体方法通过第3个参数接收从init方法返回的值,循环体方法还需要返回一个值,其类型是用泛型for参数定义的。</li>
<li>For()方法的最后一个参数指定一个委托Action&lt; TLocal &gt;;在该示例中,接收一个字符串。<br>这个方法仅对于每个线程调用一次,这是一个线程退出方法。</li>
</ul>
<p>案例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Parallel.For&lt;<span class="built_in">string</span>&gt;(<span class="number">0</span>, <span class="number">20</span>, () =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;init thread &#123;0&#125;,\t task &#123;1&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId, Task.CurrentId);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.Format(<span class="string">&quot;t&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    &#125;,</span><br><span class="line">    (i, pls, str) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;body i &#123;0&#125; \t str &#123;1&#125; \t thread &#123;2&#125; \t task &#123;3&#125;&quot;</span>, i, str, Thread.CurrentThread.ManagedThreadId, Task.CurrentId);</span><br><span class="line">        Thread.Sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.Format(<span class="string">&quot;i \t&#123;0&#125;&quot;</span>, i);</span><br><span class="line">    &#125;,</span><br><span class="line">    (str) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;finally\t &#123;0&#125;&quot;</span>, str);</span><br><span class="line">    &#125;);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Parallel.For 方法 (Int32, Int32, Func, Func&lt;Int32, ParallelLoopState, TLocal, TLocal&gt;, Action)</strong></p>
<p>参数表：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>数据类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>TLoca</td>
<td>线程本地数据的类型</td>
</tr>
<tr>
<td>fromInclusive</td>
<td>System.Int32</td>
<td>开始索引（含）</td>
</tr>
<tr>
<td>toExclusive</td>
<td>System.Int32</td>
<td>结束索引（不含）</td>
</tr>
<tr>
<td>localInit</td>
<td>System.Func</td>
<td>用于返回每个任务的本地数据的初始状态的函数委托</td>
</tr>
<tr>
<td>body</td>
<td>System.Func&lt;Int32, ParallelLoopState, TLocal, TLocal&gt;</td>
<td>将为每个迭代调用一次的委托</td>
</tr>
<tr>
<td>localFinally</td>
<td>System.Action</td>
<td>用于对每个任务的本地状态执行一个最终操作的委托</td>
</tr>
<tr>
<td>返回值</td>
<td>System.Threading.Tasks.ParallelLoopResult</td>
<td></td>
</tr>
</tbody></table>
<p>在迭代范围 (fromInclusive，toExclusive) ，为每个值调用一次body 委托。<br>为它提供以下参数：</p>
<ul>
<li>迭代次数 (Int32)</li>
<li>可用来提前退出循环的ParallelLoopState实例</li>
<li>可以在同一线程上执行的迭代之间共享的某些本地状态。</li>
</ul>
<p>对于参与循环执行的每个任务调用 localInit 委托一次，并返回每个任务的初始本地状态。<br>这些初始状态传递给第一个在该任务上 调用的 body。<br>然后，每个后续正文调用返回可能修改过的状态值，传递到下一个正文调用。<br>最后，每个任务上的最后正文调用返回传递给 localFinally 委托的状态值。<br>每个任务调用 localFinally 委托一次，以对每个任务的本地状态执行最终操作。<br>此委托可以被多个任务同步调用；<br>因此您必须同步对任何共享变量的访问。</p>
<p>Parallel.For方法比在它执行生存期的线程可能使用更多任务，作为现有的任务完成并被新任务替换。<br>这使基础 TaskScheduler 对象有机会添加、更改或移除服务循环的线程。</p>
<p>如果 fromInclusive 大于或等于 toExclusive，则该方法立即返回，而无需执行任何迭代。</p>
<h4 id="Parallel-ForEach"><a href="#Parallel-ForEach" class="headerlink" title="Parallel.ForEach()"></a>Parallel.ForEach()</h4><p>Parallel.ForEach()方法遍历实现了IEnumerable的集合,其方式类似于foreach语句,但以异步方式遍历。<br>这里也没有确定遍历顺序。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] data = &#123; <span class="string">&quot;zero&quot;</span>, <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>, <span class="string">&quot;six&quot;</span>, <span class="string">&quot;seven&quot;</span>, <span class="string">&quot;eight&quot;</span>, <span class="string">&quot;nine&quot;</span>, <span class="string">&quot;ten&quot;</span>, <span class="string">&quot;eleven&quot;</span>, <span class="string">&quot;twelve&quot;</span> &#125;;</span><br><span class="line">    ParallelLoopResult result = Parallel.ForEach&lt;<span class="built_in">string</span>&gt;(data, (s) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断循环<br>如果需要中断循环,就可以使用ForEach()方法的重载版本和ParallelLoopState参数。其方式与前面的For()方法相同。<br>ForEach()方法的一个重载版本也可以用于访问索引器,从而获得迭代次数<br>如下所示:　</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] data = &#123; <span class="string">&quot;zero&quot;</span>, <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>, <span class="string">&quot;six&quot;</span>, <span class="string">&quot;seven&quot;</span>, <span class="string">&quot;eight&quot;</span>, <span class="string">&quot;nine&quot;</span>, <span class="string">&quot;ten&quot;</span>, <span class="string">&quot;eleven&quot;</span>, <span class="string">&quot;twelve&quot;</span> &#125;;</span><br><span class="line">    ParallelLoopResult result = Parallel.ForEach&lt;<span class="built_in">string</span>&gt;(data, (s, pls, l) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;\t&#123;1&#125;&quot;</span>, s, l);</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pls.Break();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Lowest break iteration: &#123;0&#125;&quot;</span>, result.LowestBreakIteration);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-4-Parallel-Invoke"><a href="#4-2-4-Parallel-Invoke" class="headerlink" title="4.2.4 Parallel.Invoke()"></a>4.2.4 Parallel.Invoke()</h3><p>如果多个任务应并行运行,就可以使用Parallel.Invoke()方法。<br>Parallel.Invoke()方法允许传递一个Action委托数组,在其中可以指定应运行的方法。<br>示例代码传递了要并行调用的Foo()和Bar()方法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Parallel.Invoke(Foo, Bar);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Foo</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Foo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Bar</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Bar&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如需同时执行多个不同的任务，可以使用Parallel.Invoke()方法，它允许传递一个Action委托数组。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Parallel.Invoke(Func1, Func2, Func3);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Task类"><a href="#Task类" class="headerlink" title="Task类"></a>Task类</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>相比于Thread类，Task类为控制线程提供了更大的灵活性。</p>
<ul>
<li>Task类可以获取线程的返回值</li>
<li>可以定义连续的任务：在一个任务结束结束后开启下一个任务</li>
<li>可以在层次结构中安排任务，在父任务中可以创建子任务<br>这样就创建了一种依赖关系，如果父任务被取消，子任务也随之取消</li>
</ul>
<blockquote>
<p>注意：<br>Task类默认使用线程池中的线程，如果该任务需长期运行，应使用TaskCreationOptions.LongRunning属性告诉任务管理器创建一个新的线程，而不是使用线程池中的线程。</p>
</blockquote>
<h3 id="任务Task和线程Thread的区别："><a href="#任务Task和线程Thread的区别：" class="headerlink" title="任务Task和线程Thread的区别："></a>任务Task和线程Thread的区别：</h3><ul>
<li>任务是架构在线程之上的<br>也就是说任务最终还是要<strong>抛给线程</strong>去执行。</li>
<li><strong>任务跟线程不是一对一的关系</strong><br>比如开10个任务并不是说会开10个线程，这一点任务有点类似线程池，但是任务相比线程池有很小的开销和精确的控制。</li>
<li>Task和Thread一样，位于System.Threading命名空间下!</li>
</ul>
<h3 id="Task的生存周期与状态"><a href="#Task的生存周期与状态" class="headerlink" title="Task的生存周期与状态"></a>Task的生存周期与状态</h3><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Created</td>
<td>表示默认初始化任务，但是“工厂创建的”实例直接跳过。</td>
</tr>
<tr>
<td>WaitingToRun</td>
<td>这种状态表示等待任务调度器分配线程给任务执行。</td>
</tr>
<tr>
<td>RanToCompletion</td>
<td>任务执行完毕。</td>
</tr>
</tbody></table>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//查看Task中的状态</span></span><br><span class="line">    <span class="keyword">var</span> task1 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Begin&quot;</span>);</span><br><span class="line">        System.Threading.Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Finish&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Before start:&quot;</span> + task1.Status);</span><br><span class="line">    task1.Start();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;After start:&quot;</span> + task1.Status);</span><br><span class="line">    task1.Wait();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;After Finish:&quot;</span> + task1.Status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Before start:Created</span></span><br><span class="line"><span class="comment">     * After start:WaitingToRun</span></span><br><span class="line"><span class="comment">     * Begin</span></span><br><span class="line"><span class="comment">     * Finish</span></span><br><span class="line"><span class="comment">     * After Finish:RanToCompletion</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Task的使用方法"><a href="#Task的使用方法" class="headerlink" title="Task的使用方法"></a>Task的使用方法</h3><h4 id="启动任务"><a href="#启动任务" class="headerlink" title="启动任务"></a>启动任务</h4><p>以下程序演示了几种通过Task类启动任务的方式：</p>
<ul>
<li><p>实例化后手动start()</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> task1 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//TODO you code</span></span><br><span class="line">&#125;);</span><br><span class="line">task1.Start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Task工厂对象创建新任务并执行</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">TaskFactory tf = <span class="keyword">new</span> TaskFactory();</span><br><span class="line">Task t1 = tf.StartNew(TaskMethod.DoTask, <span class="string">&quot;using a task factory&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>工厂创建，直接执行</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Task t2 = Task.Factory.StartNew(TaskMethod.DoTask, <span class="string">&quot;factory via a task&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>案例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ThreadExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        TaskFactory tf = <span class="keyword">new</span> TaskFactory();</span><br><span class="line">        Task t1 = tf.StartNew(TaskMethod.DoTask, <span class="string">&quot;using a task factory&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Task t2 = Task.Factory.StartNew(TaskMethod.DoTask, <span class="string">&quot;factory via a task&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Task t3 = <span class="keyword">new</span> Task(TaskMethod.DoTask, <span class="string">&quot;using a task constructor and start&quot;</span>);</span><br><span class="line">        t3.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要.NetFramework 4.5以上</span></span><br><span class="line">        <span class="keyword">var</span> t4 = Task.Run(() =&gt; TaskMethod.DoTask(<span class="string">&quot;using Run method&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">TaskMethod</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">object</span> taskLock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoTask</span>(<span class="params"><span class="built_in">object</span> msg</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (taskLock)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(msg);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Task id:&#123;0&#125;, Thread id :&#123;1&#125;&quot;</span>,</span><br><span class="line">                               Task.CurrentId == <span class="literal">null</span> ? <span class="string">&quot;no task&quot;</span> : Task.CurrentId.ToString(),</span><br><span class="line">                               Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务控制"><a href="#任务控制" class="headerlink" title="任务控制"></a>任务控制</h4><h5 id="Task-Wait"><a href="#Task-Wait" class="headerlink" title="Task.Wait()"></a>Task.Wait()</h5><p>就是等待任务执行（task1）完成，task1的状态变为Completed。</p>
<h5 id="Task-WaitAll"><a href="#Task-WaitAll" class="headerlink" title="Task.WaitAll()"></a>Task.WaitAll()</h5><p>等待所有的任务都执行完成：<br>例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Task.WaitAll(task,task2,task3...N)</span><br><span class="line">Console.WriteLine(<span class="string">&quot;All task finished!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>即当task,task2,task3…N全部任务都执行完成之后才会往下执行代码（打印出：“All task finished!”）</p>
<h5 id="Task-WaitAny"><a href="#Task-WaitAny" class="headerlink" title="Task.WaitAny()"></a>Task.WaitAny()</h5><p>同Task.WaitAll，等待任何一个任务完成就继续向下执行，将上面的代码WaitAll替换为WaitAny</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Task.WaitAny(task,task2,task3...N)</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Any task finished!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>即当task,task2,task3…N任意一个任务都执行完成之后就会往下执行代码（打印出：” Any task finished!”）</p>
<h5 id="Task-ContinueWith"><a href="#Task-ContinueWith" class="headerlink" title="Task.ContinueWith()"></a>Task.ContinueWith()</h5><p>在第一个Task完成后自动启动下一个Task，实现Task的延续，编写如下代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TaskFactory tf = <span class="keyword">new</span> TaskFactory();</span><br><span class="line">    Task t1 = tf.StartNew(()=&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Current Task id = &#123;0&#125;&quot;</span>, Task.CurrentId);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;执行任务1\r\n&quot;</span>);</span><br><span class="line">        Thread.Sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Task t2 = t1.ContinueWith((t) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Last Task id = &#123;0&#125;&quot;</span>, t.Id);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Current Task id = &#123;0&#125;&quot;</span>, Task.CurrentId);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;执行任务2\r\n&quot;</span>);</span><br><span class="line">        Thread.Sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Task t3 = t2.ContinueWith(<span class="built_in">delegate</span>(Task t) </span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Last Task id = &#123;0&#125;&quot;</span>, t.Id);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Current Task id = &#123;0&#125;&quot;</span>, Task.CurrentId);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;执行任务3\r\n&quot;</span>);</span><br><span class="line">    &#125;, TaskContinuationOptions.OnlyOnRanToCompletion);</span><br><span class="line"></span><br><span class="line">    Console.ReadKey(); </span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//执行结果</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//Current Task id = 1</span></span><br><span class="line">    <span class="comment">//执行任务1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Last Task id = 1</span></span><br><span class="line">    <span class="comment">//Current Task id = 2</span></span><br><span class="line">    <span class="comment">//执行任务2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Last Task id = 2</span></span><br><span class="line">    <span class="comment">//Current Task id = 3</span></span><br><span class="line">    <span class="comment">//执行任务3</span></span><br></pre></td></tr></table></figure>

<p>从执行结果可以看出，任务1，2，3被顺序执行，同时通过 TaskContinuationOptions 还可以指定何种情况下继续执行该任务，常用的值包括OnlyOnFaulted, OnlyOnCanceled, NotOnFaulted, NotOnCanceled等。如将上例中的OnlyOnRanToCompletion改为OnlyOnFaulted，任务2结束之后，任务3将不被执行。</p>
<p>对于ContinueWith()的使用，MSDN演示了更加优雅的“流式”调用方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">   <span class="keyword">var</span> backgroundScheduler = TaskScheduler.Default;  </span><br><span class="line">   <span class="keyword">var</span> uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  </span><br><span class="line">   Task.Factory.StartNew(<span class="built_in">delegate</span> &#123; DoBackgroundComputation(); &#125;,  </span><br><span class="line">                         backgroundScheduler).  </span><br><span class="line">   ContinueWith(<span class="built_in">delegate</span> &#123; UpdateUI(); &#125;, uiScheduler).  </span><br><span class="line">                ContinueWith(<span class="built_in">delegate</span> &#123; DoAnotherBackgroundComputation(); &#125;,  </span><br><span class="line">                             backgroundScheduler).  </span><br><span class="line">                ContinueWith(<span class="built_in">delegate</span> &#123; UpdateUIAgain(); &#125;, uiScheduler);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="RunSynchronously"><a href="#RunSynchronously" class="headerlink" title="RunSynchronously()"></a>RunSynchronously()</h5><p>用于实现同步调用，直接在当前线程上调用该任务。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TaskMethod.DoTask(<span class="string">&quot;Just Main thread&quot;</span>);</span><br><span class="line">    Task t1 = <span class="keyword">new</span> Task(TaskMethod.DoTask, <span class="string">&quot;using Run Sync&quot;</span>);</span><br><span class="line">    t1.RunSynchronously();</span><br><span class="line">    <span class="comment">//输出结果</span></span><br><span class="line">    <span class="comment">//Just Main thread</span></span><br><span class="line">    <span class="comment">//Task id: no task, Thread id: 9</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//using Run Sync</span></span><br><span class="line">    <span class="comment">//Task id:1, Thread id :9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务取消"><a href="#任务取消" class="headerlink" title="任务取消"></a>任务取消</h4><p>当我们启动了一个task,出现异常或者用户点击取消等等，我们可以取消这个任务。</p>
<p>我们通过cancellation的tokens来取消一个Task。<br>在很多Task的Body里面包含循环，我们可以在轮询的时候判断IsCancellationRequested属性是否为True<br>如果是True的话就return或者抛出异常，抛出异常后面再说，因为还没有说异常处理的东西。</p>
<p>下面在代码中看下如何实现任务的取消，代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> tokenSource = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">            <span class="keyword">var</span> token = tokenSource.Token;</span><br><span class="line">            <span class="keyword">var</span> task = Task.Factory.StartNew(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.Threading.Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">if</span> (token.IsCancellationRequested)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">&quot;Abort mission success!&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, token);</span><br><span class="line">            token.Register(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Press enter to cancel task...&quot;</span>);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">            tokenSource.Cancel();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这里开启了一个Task,并给token注册了一个方法，输出一条信息，然后执行ReadKey开始等待用户输入，用户点击回车后，执行tokenSource.Cancel方法，取消任务。</p>
<blockquote>
<p>注意：<br>因为任务通常运行以异步方式在线程池线程上，创建并启动任务的线程将继续执行，一旦该任务已实例化。<br>在某些情况下，当调用线程的主应用程序线程，该应用程序可能会终止之前任何任务实际开始执行。<br>其他情况下，应用程序的逻辑可能需要调用线程继续执行，仅当一个或多个任务执行完毕。<br>您可以同步调用线程的执行，以及异步任务它启动通过调用 Wait 方法来等待要完成的一个或多个任务。<br>若要等待完成一项任务，可以调用其 Task.Wait 方法。<br>调用 Wait 方法将一直阻塞调用线程直到单一类实例都已完成执行。</p>
</blockquote>
<h4 id="接收任务的返回值"><a href="#接收任务的返回值" class="headerlink" title="接收任务的返回值"></a>接收任务的返回值</h4><p>对于任务有返回值的情况，可使用Task泛型类，TResult定义了返回值的类型，以下代码演示了调用返回int值的任务的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    var t5 = new Task&lt;int&gt;(TaskWithResult, Tuple.Create&lt;int, int&gt;(1, 2));</span><br><span class="line">    t5.Start();</span><br><span class="line">    t5.Wait();</span><br><span class="line">    Console.WriteLine(&quot;adder results: &#123;0&#125;&quot;, t5.Result);</span><br><span class="line"></span><br><span class="line">    Console.ReadKey(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int TaskWithResult(object o)</span><br><span class="line">&#123;</span><br><span class="line">    Tuple&lt;int, int&gt; adder = (Tuple&lt;int, int&gt;)o;</span><br><span class="line">    return adder.Item1 + adder.Item2;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="任务的层次结构"><a href="#任务的层次结构" class="headerlink" title="任务的层次结构"></a>任务的层次结构</h3><p>如果在一个Task内部创建了另一个任务，这两者间就存在父&#x2F;子的层次结构，当父任务被取消时，子任务也会被取消。</p>
<p>如果不希望使用该层次结构，可在创建子任务时选择TaskCreationOptions.DetachedFromParent。</p>
<h2 id="BackgroundWorker控件"><a href="#BackgroundWorker控件" class="headerlink" title="BackgroundWorker控件"></a>BackgroundWorker控件</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>C#提供了BackgroundWorker控件帮助用户更简单、安全地实现多线程运算。</p>
<p>该控件提供了DoWork, ProgressChanged 和 RunWorkerCompleted事件<br>为DoWork添加事件处理函数，再调用RunWorkerAsync()方法，即可创建一个新的线程执行DoWork任务</p>
<p>ProgressChanged和RunWorkerCompleted事件均在UI线程中执行，添加相应的处理函数，即可完成任务线程与UI线程间的交互，可用于显示任务的执行状态（完成百分比）、执行结果等。</p>
<p>同时，该控件还提供了CancleAsync()方法，以中断线程的执行<br>需注意的是，调用该方法后，只是将控件的CancellationPending属性置True，用户需在程序执行过程中查询该属性以判定是否应中断线程。</p>
<p>具体用法可参考MSDN：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.componentmodel.backgroundworker?view=netframework-4.7.2">BackgroundWorker用法范例</a><br>可以看的出来，BackgroundWorker组件提供了一种执行异步操作（后台线程）的同时，并且还能妥妥的显示操作进度的解决方案。</p>
<h3 id="属性表-1"><a href="#属性表-1" class="headerlink" title="属性表"></a>属性表</h3><h4 id="WorkerReportsProgress"><a href="#WorkerReportsProgress" class="headerlink" title="WorkerReportsProgress"></a>WorkerReportsProgress</h4><p>bool类型，指示BackgroundWorker是否可以报告进度更新。</p>
<ul>
<li>True时，可以成功调用ReportProgress方法</li>
<li>否则将引发InvalidOperationException异常</li>
</ul>
<p>用法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> BackgroundWorker bgWorker = <span class="keyword">new</span> BackgroundWorker();</span><br><span class="line">bgWorker.WorkerReportsProgress = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h4 id="WorkerSupportsCancellation"><a href="#WorkerSupportsCancellation" class="headerlink" title="WorkerSupportsCancellation"></a>WorkerSupportsCancellation</h4><p>bool类型，指示BackgroundWorker是否支持异步取消操作</p>
<ul>
<li><p>True时，将可以成功调用CancelAsync方法</p>
</li>
<li><p>否则将引发InvalidOperationException异<br>用法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">bgWorker.WorkerSupportsCancellation = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="CancellationPending"><a href="#CancellationPending" class="headerlink" title="CancellationPending"></a>CancellationPending</h4><p>bool类型，指示应用程序是否已请求取消后台操作。<br>此属性通常放在用户执行的异步操作内部，用来判断用户是否取消执行异步操作。<br>当执行BackgroundWorker.CancelAsync()方法时，该属性值将变为True。<br>用法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在DoWork中键入如下代码</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (bgWorker.CancellationPending)</span><br><span class="line">      &#123;</span><br><span class="line">          e.Cancel = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          bgWorker.ReportProgress(i,<span class="string">&quot;Working&quot;</span>);</span><br><span class="line">          System.Threading.Thread.Sleep(<span class="number">10</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;   </span><br></pre></td></tr></table></figure>

<h4 id="IsBusy"><a href="#IsBusy" class="headerlink" title="IsBusy"></a>IsBusy</h4><p>bool类型，指示BackgroundWorker是否正在执行一个异步操作。<br>此属性通常放在BackgroundWorker.RunWorkerAsync()方法之前，避免多次调用RunWorkerAsync()方法引发异常。<br>当执行BackgroundWorker.RunWorkerAsync()方法是，该属性值将变为True。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//防止重复执行异步操作引发错误</span></span><br><span class="line"> <span class="keyword">if</span> (bgWorker.IsBusy)</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> bgWorker.RunWorkerAsync();</span><br></pre></td></tr></table></figure>

<h3 id="方法表-1"><a href="#方法表-1" class="headerlink" title="方法表"></a>方法表</h3><h4 id="RunWorkerAsync"><a href="#RunWorkerAsync" class="headerlink" title="RunWorkerAsync()"></a>RunWorkerAsync()</h4><p>开始执行一个后台操作。</p>
<p>调用该方法后，将触发BackgroundWorker.DoWork事件，并以异步的方式执行DoWork事件中的代码。<br>该方法还有一个带参数的重载方法：RunWorkerAsync(Object)。<br>该方法允许传递一个Object类型的参数到后台操作中，并且可以通过DoWork事件的DoWorkEventArgs.Argument属性将该参数提取出来。</p>
<blockquote>
<p>注：当BackgroundWorker的IsBusy属性为True时，调用该方法将引发InvalidOperationException异常。</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在启动异步操作的地方键入代码</span></span><br><span class="line">bgWorker.RunWorkerAsync(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="ReportProgress-Int-percentProgress"><a href="#ReportProgress-Int-percentProgress" class="headerlink" title="ReportProgress(Int percentProgress)"></a>ReportProgress(Int percentProgress)</h4><p>报告操作进度。</p>
<p>调用该方法后，将触发BackgroundWorker. ProgressChanged事件。<br>另外，该方法包含了一个int类型的参数percentProgress，用来表示当前异步操作所执行的进度百分比。</p>
<p>该方法还有一个重载方法：ReportProgress(Int percentProgress, Object userState)。<br>允许传递一个Object类型的状态对象到 ProgressChanged事件中<br>并且可以通过ProgressChanged事件的ProgressChangedEventArgs.UserState属性取得参数值。</p>
<blockquote>
<p>注：调用该方法之前需确保WorkerReportsProgress属性值为True，否则将引发InvalidOperationException异常。</p>
</blockquote>
<p>用法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//向ProgressChanged报告进度</span></span><br><span class="line">    bgWorker.ReportProgress(i,<span class="string">&quot;Working&quot;</span>);</span><br><span class="line">    System.Threading.Thread.Sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CancelAsync"><a href="#CancelAsync" class="headerlink" title="CancelAsync()"></a>CancelAsync()</h4><p>请求取消当前正在执行的异步操作。</p>
<p>调用该方法将使BackgroundWorker.CancellationPending属性设置为True。<br>但需要注意的是，并非每次调用CancelAsync()都能确保异步操作，CancelAsync()通常不适用于取消一个紧密执行的操作，更适用于在循环体中执行。<br>用法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在需要执行取消操作的地方键入以下代码</span></span><br><span class="line">bgWorker.CancelAsync();</span><br></pre></td></tr></table></figure>

<h3 id="事件表"><a href="#事件表" class="headerlink" title="事件表"></a>事件表</h3><h4 id="DoWork"><a href="#DoWork" class="headerlink" title="DoWork"></a>DoWork</h4><p>用于承载异步操作。当调用BackgroundWorker.RunWorkerAsync()时触发。</p>
<p>需要注意的是：<br>由于DoWork事件内部的代码运行在非UI线程之上，所以在DoWork事件内部应避免于用户界面交互，<br>而于用户界面交互的操作应放置在ProgressChanged和RunWorkerCompleted事件中。</p>
<h4 id="ProgressChanged"><a href="#ProgressChanged" class="headerlink" title="ProgressChanged"></a>ProgressChanged</h4><p>当调用BackgroundWorker.ReportProgress(int percentProgress)方式时触发该事件。<br>该事件的ProgressChangedEventArgs.ProgressPercentage属性可以接收来自ReportProgress方法传递的percentProgress参数值,ProgressChangedEventArgs.UserState属性可以接收来自ReportProgress方法传递的userState参数。</p>
<h4 id="RunWorkerCompleted"><a href="#RunWorkerCompleted" class="headerlink" title="RunWorkerCompleted"></a>RunWorkerCompleted</h4><p>异步操作完成或取消时执行的操作，当调用DoWork事件执行完成时触发。</p>
<p>该事件的RunWorkerCompletedEventArgs参数包含三个常用的属性Error,Cancelled,Result。其中，Error表示在执行异步操作期间发生的错误；Cancelled用于判断用户是否取消了异步操作；Result属性接收来自DoWork事件的DoWorkEventArgs参数的Result属性值，可用于传递异步操作的执行结果。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> <span class="title">bcworker</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//后台工作</span></span><br><span class="line">        <span class="keyword">private</span> BackgroundWorker bw = <span class="keyword">new</span> BackgroundWorker();</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            <span class="comment">//后台工作初始化</span></span><br><span class="line">            bw.WorkerReportsProgress = <span class="literal">true</span>;<span class="comment">//报告进度</span></span><br><span class="line">            bw.WorkerSupportsCancellation = <span class="literal">true</span>;<span class="comment">//支持取消</span></span><br><span class="line">            bw.DoWork += <span class="keyword">new</span> DoWorkEventHandler(bgWorker_DoWork);<span class="comment">//开始工作</span></span><br><span class="line">            bw.ProgressChanged += <span class="keyword">new</span> ProgressChangedEventHandler(bgWorker_ProgessChanged);<span class="comment">//进度改变事件</span></span><br><span class="line">            bw.RunWorkerCompleted += <span class="keyword">new</span> RunWorkerCompletedEventHandler(bgWorker_WorkerCompleted);<span class="comment">//进度完成事件</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnStart_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//后台工作运行中，避免重入</span></span><br><span class="line">            <span class="keyword">if</span> (bw.IsBusy) <span class="keyword">return</span>;</span><br><span class="line">            bw.RunWorkerAsync(<span class="string">&quot;参数&quot;</span>);<span class="comment">//触发DoWork事件并异步执行，IsBusy置为True</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后台工作将异步执行</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bgWorker_DoWork</span>(<span class="params"><span class="built_in">object</span> sender, DoWorkEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//(string)e.Argument == &quot;参数&quot;;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (bw.CancellationPending)</span><br><span class="line">                &#123;<span class="comment">//用户取消了工作</span></span><br><span class="line">                    e.Cancel = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    bw.ReportProgress(i, <span class="string">&quot;Working&quot;</span>);<span class="comment">//报告进度，触发ProgressChanged事件</span></span><br><span class="line">                    Thread.Sleep(<span class="number">10</span>);<span class="comment">//模拟工作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进度改变事件</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bgWorker_ProgessChanged</span>(<span class="params"><span class="built_in">object</span> sender, ProgressChangedEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//(string)e.UserState==&quot;Working&quot;</span></span><br><span class="line">            progressBar1.Value = e.ProgressPercentage;<span class="comment">//取得进度更新控件，不用Invoke了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后台工作执行完毕,IsBusy置为False</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bgWorker_WorkerCompleted</span>(<span class="params"><span class="built_in">object</span> sender, RunWorkerCompletedEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//e.Error == null 是否发生错误</span></span><br><span class="line">            <span class="comment">//e.Cancelled 完成是由于取消还是正常完成</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnCancel_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bw.IsBusy) bw.CancelAsync();<span class="comment">//设置CancellationPending属性为True</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="调用系统对话框"><a href="#调用系统对话框" class="headerlink" title="调用系统对话框"></a>调用系统对话框</h1><p>注意，需要在winform应用程序下实现。</p>
<p>如需在控制台中使用，注意引入System.Windows.Forms命名空间（需要先引入对应的dll），而且还存在某些问题</p>
<h2 id="打开文件对话框"><a href="#打开文件对话框" class="headerlink" title="打开文件对话框"></a>打开文件对话框</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OpenFileDialogFunction</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*实例化出打开文件对话框的对象*/</span></span><br><span class="line">    OpenFileDialog ofd = <span class="keyword">new</span> OpenFileDialog();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置对话框的参数*/</span></span><br><span class="line">    <span class="comment">//设置对话框的标题</span></span><br><span class="line">    ofd.Title = <span class="string">&quot;对话框的标题&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置对话框是否可以多选文件。允许多选为true，否则为false</span></span><br><span class="line">    ofd.Multiselect = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置对话框的初始目录</span></span><br><span class="line">    <span class="comment">//默认是在当前用户的文档文件夹下？</span></span><br><span class="line">    ofd.InitialDirectory = <span class="string">@&quot;D:\files&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置允许打开文件的类型</span></span><br><span class="line">    <span class="comment">//竖线分隔，前面是提示信息，后面是筛选的文件格式。支持多个，可以一对一，也可以一对多。</span></span><br><span class="line">    <span class="comment">//对于一对多（多个文件格式）,每个筛选条件后面都需要加上分号表示结束。</span></span><br><span class="line">    ofd.Filter = <span class="string">&quot;文本文件|*.txt; | 可执行文件|*.exe;*.apk; | 压缩文件|*.zip;*.rar;*.7z; | 所有文件|*.*;&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*显示对话框*/</span></span><br><span class="line">    ofd.ShowDialog();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取选中文件的路径*/</span></span><br><span class="line">    <span class="comment">//对于允许多选的打开文件类型，可以通过FileNames获取。</span></span><br><span class="line">    <span class="comment">//如果允许了多选文件，并且运行的时候确实多选了文件，使用FileName属性获取也不会报错</span></span><br><span class="line">    <span class="comment">//只是只会获取到多选中第一个文件的路径</span></span><br><span class="line">    <span class="built_in">string</span>[] fileName = ofd.FileNames;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*将获取到的信息展示出来*/</span></span><br><span class="line">    lblInfo.Text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="built_in">string</span> <span class="keyword">file</span> <span class="keyword">in</span> ofd.FileNames)</span><br><span class="line">    &#123;</span><br><span class="line">        lblInfo.Text += <span class="keyword">file</span>;</span><br><span class="line">        lblInfo.Text += <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="保存文件对话框"><a href="#保存文件对话框" class="headerlink" title="保存文件对话框"></a>保存文件对话框</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveFileDialogFunction</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//实例化出一个保存对话框的对象</span></span><br><span class="line">    SaveFileDialog sfd = <span class="keyword">new</span> SaveFileDialog();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置对话框的属性*/</span></span><br><span class="line">    <span class="comment">//设置对话框的标题</span></span><br><span class="line">    sfd.Title = <span class="string">&quot;保存对话框的标题&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置保存对话框的默认路径</span></span><br><span class="line">    sfd.InitialDirectory = <span class="string">@&quot;D:\files&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置保存的格式</span></span><br><span class="line">    sfd.Filter = <span class="string">&quot;文本文件|*.txt; | 所有文件|*.*&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于保存对话框来说，不存在多选的选项</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*展示对话框*/</span></span><br><span class="line">    sfd.ShowDialog();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取用户要保存的路径*/</span></span><br><span class="line">    <span class="comment">//因为不允许多选，因此这里只有这一个属性</span></span><br><span class="line">    <span class="built_in">string</span> path = sfd.FileName;</span><br><span class="line">    lblInfo.Text = path;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Socket套接字"><a href="#Socket套接字" class="headerlink" title="Socket套接字"></a>Socket套接字</h1><p>Socket作为进程通信机制，通常也被称为套接字。用于描述IP地址和端口号，是一个通信链的句柄。</p>
<p>建立连接的时候，服务器应该有一个用于监听的Socket，用于监听应用程序是否有人连接。这个有用于监听的Socket就相当于电话的接线员，一旦检测到有连接，就创建一个负责跟客户端连接的Socket。此时，服务器端Socket的数量为2（至少两个），其中一个只负责监听，另外一个只负责通信；而客户端，从始至终都只有1个Socket。</p>
<p>需要注意，一个Socket一次只能连接一台主机，且Socket被关闭后无法再次被使用。</p>
<p>每个Socket对象只能一台主机连接，如果需要连接多台主机，必须创建多个Socket对象。</p>
<h2 id="Socket的通信过程"><a href="#Socket的通信过程" class="headerlink" title="Socket的通信过程"></a>Socket的通信过程</h2><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><ol>
<li>申请一个Socket</li>
<li>绑定到一个IP地址和端口号上</li>
<li>开启侦听，等待连接</li>
</ol>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol>
<li>申请一个Socket</li>
<li>连接服务器（需要指明ip地址和端口号）</li>
</ol>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>服务器接到连接请求后，产生一个新的Socket（端口号需要大于1024）与客户端建立连接并进行通信，<strong>原监听Socket继续监听</strong>。</p>
<p><img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/image-20230521163803975.png" alt="image-20230521163803975"></p>
<h2 id="Socket的构造函数"><a href="#Socket的构造函数" class="headerlink" title="Socket的构造函数"></a>Socket的构造函数</h2><p>连接通过构造函数</p>
<h1 id="GDI"><a href="#GDI" class="headerlink" title="GDI+"></a>GDI+</h1><p>​	GDI+ (Graphics Device Interface)是一种绘图装置接口，可应用程序和绘图硬件分隔，让我们能够编写与装置无关的应用程序。它可以让我们不需注意特定显示装置的详细数据，便可在屏幕或打印机显示信息。我们可以呼叫GDI+类别所提供的方法，然后这些方法会适当地呼叫特定的装置驱动程序，而完成绘图。而且与.NET进行了更好的融合。</p>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Data;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">GDITest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 在Windows中，当窗口移动、最小化、还原或遮盖时，窗口的内容会被清除。</span></span><br><span class="line"><span class="comment">        * 为了保持窗口内容的一致性，需要在窗口的Paint事件中重新绘制窗口内容。</span></span><br><span class="line"><span class="comment">        * 这就是为什么需要重新绘制的原因。</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * 只要在事件中添加了对应的方法后，只要对应的图形出显示屏</span></span><br><span class="line"><span class="comment">        * 系统就会自动调用这个事件。重新绘制（只要出一点就调用）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 使用GDI绘制一条直线</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">GDITest1</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用GDI绘制的时候，需要准备一根笔、颜色、两个点、绘制直线的对象</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建GDI对象</span></span><br><span class="line">            <span class="comment">//Graphics g = new Graphics(); 不能直接创建</span></span><br><span class="line">            Graphics g = <span class="keyword">this</span>.CreateGraphics();<span class="comment">//只能通过this创建对象</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建画笔对象</span></span><br><span class="line">            Pen pen = <span class="keyword">new</span> Pen(Brushes.Blue);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建两个点，用于确定绘制范围</span></span><br><span class="line">            Point p1 = <span class="keyword">new</span> Point(<span class="number">30</span>, <span class="number">50</span>);</span><br><span class="line">            Point p2 = <span class="keyword">new</span> Point(<span class="number">250</span>, <span class="number">250</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//开始绘制</span></span><br><span class="line">            g.DrawLine(pen, p1, p2);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 使用GDI绘制一个矩形</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">GDITest2</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获得GDI对象</span></span><br><span class="line">            Graphics g = <span class="keyword">this</span>.CreateGraphics();</span><br><span class="line">            <span class="comment">//实例化画笔</span></span><br><span class="line">            Pen pen = <span class="keyword">new</span> Pen(Brushes.Blue);</span><br><span class="line">            <span class="comment">//设置绘制的大小</span></span><br><span class="line">            Size size = <span class="keyword">new</span> System.Drawing.Size(<span class="number">80</span>, <span class="number">80</span>);</span><br><span class="line">            <span class="comment">//设置要绘制的矩形尺寸，从窗口左上角开始的50，50点开始，生成一个80x80像素的矩形</span></span><br><span class="line">            Rectangle r1 = <span class="keyword">new</span> Rectangle(<span class="keyword">new</span> Point(<span class="number">50</span>, <span class="number">50</span>), size);</span><br><span class="line">            <span class="comment">//使用画笔绘制出指定的矩形</span></span><br><span class="line">            g.DrawRectangle(pen, r1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 绘制一个扇形</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">GDITest3</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Graphics g = <span class="keyword">this</span>.CreateGraphics();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从文本框中拿到所需要的信息</span></span><br><span class="line">            <span class="keyword">if</span> (txt1.Text == <span class="string">&quot;&quot;</span> || txt2.Text == <span class="string">&quot;&quot;</span> || txt3.Text == <span class="string">&quot;&quot;</span> || txt4.Text == <span class="string">&quot;&quot;</span> || txt5.Text == <span class="string">&quot;&quot;</span> || txt6.Text == <span class="string">&quot;&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                MessageBox.Show(<span class="string">&quot;请在个文本框中分别输入信息以生成扇形&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">int</span> x = <span class="built_in">int</span>.Parse(txt1.Text);</span><br><span class="line">            <span class="built_in">int</span> y = <span class="built_in">int</span>.Parse(txt2.Text);</span><br><span class="line">            <span class="built_in">int</span> L = <span class="built_in">int</span>.Parse(txt3.Text);</span><br><span class="line">            <span class="built_in">int</span> W = <span class="built_in">int</span>.Parse(txt4.Text);</span><br><span class="line">            <span class="built_in">float</span> f1 = <span class="built_in">float</span>.Parse(txt5.Text);</span><br><span class="line">            <span class="built_in">float</span> f2 = <span class="built_in">float</span>.Parse(txt6.Text);            </span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成一个画笔和对应的颜色</span></span><br><span class="line">            Pen pen = <span class="keyword">new</span> Pen(Color.Blue);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成一个矩形</span></span><br><span class="line">            Size size = <span class="keyword">new</span> System.Drawing.Size(L, W);<span class="comment">//设置一下初始位置</span></span><br><span class="line">            Rectangle r1 = <span class="keyword">new</span> Rectangle(<span class="keyword">new</span> Point(x, y), size);<span class="comment">//借助位置生成一个矩形</span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment">//需要四个参数，分别是画笔、矩形和两个角度。</span></span><br><span class="line">            <span class="comment">//两个角度分别是：从x轴到扇形的第一条边沿顺时针方向度量的角（以度为单位）</span></span><br><span class="line">            <span class="comment">//和： 从上一个参数开始到扇形的第二条边沿顺时针方向度量的角（以度为单位）</span></span><br><span class="line">            g.DrawPie(pen, r1, f1, f2);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 使用GDI绘制一个文本</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">GDITest4</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> x = <span class="built_in">int</span>.Parse(txt1.Text);</span><br><span class="line">            <span class="built_in">int</span> y = <span class="built_in">int</span>.Parse (txt2.Text);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取GDI对象</span></span><br><span class="line">            Graphics g =<span class="keyword">this</span>.CreateGraphics();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//所需参数：</span></span><br><span class="line">            <span class="comment">//要显示的文本信息</span></span><br><span class="line">            <span class="comment">//字体信息</span></span><br><span class="line">            <span class="comment">//颜色</span></span><br><span class="line">            <span class="comment">//显示位置</span></span><br><span class="line">            g.DrawString(txtInfo.Text, <span class="keyword">new</span> Font(<span class="string">&quot;微软雅黑&quot;</span>, <span class="number">20</span>, FontStyle.Bold), Brushes.Black, <span class="keyword">new</span> Point(x, y));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 绘制一个验证码</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">GDITest5</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//生成随机数</span></span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="built_in">string</span> str = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> rNum = random.Next(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">                str += rNum.ToString();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成位图</span></span><br><span class="line">            <span class="comment">//因为Bitmap继承于Image，而Image是抽象类不可以被实例化，因此只能用Bitmap替代Image传入GDI</span></span><br><span class="line">            Bitmap bmp = <span class="keyword">new</span> Bitmap(<span class="number">100</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建GDI对象</span></span><br><span class="line">            Graphics g = Graphics.FromImage(bmp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置一些随机化的值</span></span><br><span class="line">            <span class="comment">//生成的字体从这些集合中选</span></span><br><span class="line">            <span class="built_in">string</span>[] fonts = &#123; <span class="string">&quot;微软雅黑&quot;</span>, <span class="string">&quot;宋体&quot;</span>, <span class="string">&quot;隶书&quot;</span>, <span class="string">&quot;黑体&quot;</span>, <span class="string">&quot;仿宋&quot;</span> &#125;;</span><br><span class="line">            <span class="comment">//文字的颜色在这个集合中随机选</span></span><br><span class="line">            Color[] colors = &#123; Color.Yellow, Color.Blue, Color.Red, Color.Black, Color.Green &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//将产生的随机数绘制到位图中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Point point = <span class="keyword">new</span> Point(i * <span class="number">15</span> + <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">                g.DrawString(str[i].ToString(), <span class="keyword">new</span> Font(fonts[random.Next(<span class="number">0</span>,<span class="number">5</span>)], <span class="number">15</span>, FontStyle.Bold), <span class="keyword">new</span> SolidBrush(colors[random.Next(<span class="number">0</span>,<span class="number">5</span>)]), point);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//增加干扰线</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; <span class="number">15</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//随机生成点作为绘制坐标。</span></span><br><span class="line">                <span class="comment">//要求起始点的横坐标在0到图片的宽度之间，纵坐标在0到图片的高度之间随机选择</span></span><br><span class="line">                Point p1 = <span class="keyword">new</span> Point(random.Next(<span class="number">0</span>, bmp.Width), random.Next(<span class="number">0</span>, bmp.Height));</span><br><span class="line">                Point p2 = <span class="keyword">new</span> Point(random.Next(<span class="number">0</span>, bmp.Width), random.Next(<span class="number">0</span>, bmp.Height));</span><br><span class="line"></span><br><span class="line">                g.DrawLine(<span class="keyword">new</span> Pen(Brushes.Green), p1, p2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//增加像素颗粒</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                bmp.SetPixel(random.Next(<span class="number">0</span>, bmp.Width), random.Next(<span class="number">0</span>, bmp.Height), Color.Black);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将图片镶嵌到PictureBox中</span></span><br><span class="line">            pictureBox1.Image = bmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btn1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            GDITest1();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在窗口改变的时候重新绘制指定的GDI</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_Paint</span>(<span class="params"><span class="built_in">object</span> sender, PaintEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//GDITest1();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button2_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            GDITest2();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btn3_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            GDITest3();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_Load</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btn4_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            GDITest4();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btn5_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            GDITest5();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="关于二进制序列化需要注意的事项"><a href="#关于二进制序列化需要注意的事项" class="headerlink" title="关于二进制序列化需要注意的事项:"></a>关于二进制序列化需要注意的事项:</h2><ul>
<li>要序列化的类型必须标记为: [Serializable]</li>
<li>该类型的父类也必须标记为: [Serializable]</li>
<li>该类型中的所有成员的类型也必须标记为: [Seralizable]</li>
<li>序列化只会对类中的<strong>字段</strong>序列化。(只能序列化一些状态信息)</li>
<li>需要头文件：<code>System.Runtime.Serialization.Formatters.Binary</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Runtime.Serialization.Formatters.Binary;</span><br><span class="line"></span><br><span class="line">namespace ConsoleApp</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Program</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 序列化步骤：</span></span><br><span class="line"><span class="comment">         * 首先将要序列化的对象的类标记为可以被序列化的</span></span><br><span class="line"><span class="comment">         * 然后产生一个文件流用于写入被序列化的对象（可缺省？）</span></span><br><span class="line"><span class="comment">         * 接着创建一个BinaryFormatter的对象用于对目标类进行序列化</span></span><br><span class="line"><span class="comment">         * 最后调用这个对象的Serialize方法将目标对象进行序列化，并保存到对应的位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">static</span> <span class="type">void</span> <span class="title function_">Main</span><span class="params">(<span class="built_in">string</span>[] args)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建Person对象</span></span><br><span class="line">            Person p = new Person();</span><br><span class="line">            p.Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">            p.Age = <span class="number">30</span>;</span><br><span class="line">            p.Gender = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            using (FileStream fsWrite = new FileStream(@<span class="string">&quot;D:\tmp\tmp.txt&quot;</span>, FileMode.OpenOrCreate, FileAccess.Write))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//创建用于序列化的对象</span></span><br><span class="line">                BinaryFormatter bf = new BinaryFormatter();</span><br><span class="line">                <span class="comment">//开始序列化</span></span><br><span class="line">                bf.Serialize(fsWrite, p);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;序列化完成&quot;</span>);          </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//开始反序列化</span></span><br><span class="line">            <span class="comment">//将保存到文件的对象的字段信息还原成一个对象</span></span><br><span class="line"></span><br><span class="line">            using(FileStream fsRead = new FileStream(@<span class="string">&quot;D:\tmp\tmp.txt&quot;</span>, FileMode.Open, FileAccess.Read))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//创建用于反序列化的对象</span></span><br><span class="line">                BinaryFormatter bf = new BinaryFormatter();</span><br><span class="line">                <span class="comment">//反序列化对象</span></span><br><span class="line">                <span class="comment">//返回的是一个object类型的对象</span></span><br><span class="line">                object o =  bf.Deserialize(fsRead);</span><br><span class="line">                <span class="comment">//经is判断可以得出o是Person的对象</span></span><br><span class="line">                Console.WriteLine(o is Person);</span><br><span class="line">                <span class="comment">//拆箱成为原始类型的对象</span></span><br><span class="line">                Person pt = (Person)o;</span><br><span class="line">                <span class="comment">//输出反序列化后的一些信息</span></span><br><span class="line">                Console.WriteLine(pt.Name);</span><br><span class="line">                Console.WriteLine(pt.Age);</span><br><span class="line">                Console.WriteLine(pt.Gender);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将类标记为可以被序列化的</span></span><br><span class="line">    [Serializable]</span><br><span class="line">    public <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        public <span class="built_in">string</span> Name &#123; get; <span class="built_in">set</span>; &#125;</span><br><span class="line">        public <span class="type">int</span> Age &#123; get; <span class="built_in">set</span>; &#125;</span><br><span class="line">        public <span class="type">char</span> Gender &#123; get; <span class="built_in">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="c-复制"><a href="#c-复制" class="headerlink" title="c#复制"></a>c#复制</h1><p>c#中复制可分为深复制、浅复制两种。</p>
<p>首先要明确拷贝产生的结果都是reference type（引用类型）的，本质上还是指向一个对象（毕竟primitive type（简单类型）不需要）</p>
<p>所以深拷贝和浅拷贝的区别，就是拷贝这个reference指向的对象是不是之前的。</p>
<h2 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h2><p>对于值类型来说，C#中的浅复制指的是创建一个新对象，并将当前对象的值类型字段复制到新对象中。</p>
<p>对于数据是引用类型时，只复制引用，而不复制引用的对象本身。因此，原始对象和副本对象指向同一个对象。浅复制可以使用Object.MemberwiseClone方法来实现，也可以使用其他方式。与深复制相比，浅复制更快，但也更容易出现数据不一致或内存泄漏的问题。</p>
<h3 id="使用浅复制的场景"><a href="#使用浅复制的场景" class="headerlink" title="使用浅复制的场景"></a>使用浅复制的场景</h3><ul>
<li>当我们想要创建一个新对象，但不想完全复制原始对象的所有数据时，例如，当原始对象包含大量的引用类型字段时，深复制会消耗更多的内存和时间。</li>
<li>当我们想要保持原始对象和副本对象之间的一些联系时，例如，当原始对象和副本对象共享一些引用类型字段时，我们可以通过修改其中一个来影响另一个。</li>
<li>当我们不需要担心数据不一致或内存泄漏的问题时，例如，当原始对象和副本对象的生命周期相同或相近时，或者当我们可以正确地管理引用类型字段的释放时。</li>
</ul>
<h3 id="样例-29"><a href="#样例-29" class="headerlink" title="样例"></a>样例</h3><p>假设有一个类Person，它有两个字段：name和address。name是一个字符串，是值类型；address是一个类Address，是引用类型。</p>
<p>下面是Person类的定义：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, Address address</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">ShallowCopy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Person)<span class="keyword">this</span>.MemberwiseClone();<span class="comment">//MemberwiseClone()功能见后续解释</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是Address类的定义：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Address</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> city;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> street;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span>(<span class="params"><span class="built_in">string</span> city, <span class="built_in">string</span> street</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.city = city;</span><br><span class="line">        <span class="keyword">this</span>.street = street;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们创建一个Person对象p1，并用ShallowCopy方法创建一个浅复制对象p2：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="keyword">new</span> Address(<span class="string">&quot;Beijing&quot;</span>, <span class="string">&quot;Xidan&quot;</span>));</span><br><span class="line">Person p2 = p1.ShallowCopy();</span><br></pre></td></tr></table></figure>

<p>这时，p1和p2都有相同的name和address字段的值，但是它们指向不同的对象。如果我们修改p1的name字段，那么p2的name字段不会受到影响，因为它们是值类型：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">p1.name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">Console.WriteLine(p1.name); <span class="comment">// Bob</span></span><br><span class="line">Console.WriteLine(p2.name); <span class="comment">// Alice</span></span><br></pre></td></tr></table></figure>

<p>但是如果我们修改p1的address字段，那么p2的address字段也会受到影响，因为它们是引用类型，并且指向同一个Address对象：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">p1.address.city = <span class="string">&quot;Shanghai&quot;</span>;</span><br><span class="line">Console.WriteLine(p1.address.city); <span class="comment">// Shanghai</span></span><br><span class="line">Console.WriteLine(p2.address.city); <span class="comment">// Shanghai</span></span><br></pre></td></tr></table></figure>

<h4 id="样例中部分方法的解释"><a href="#样例中部分方法的解释" class="headerlink" title="样例中部分方法的解释"></a>样例中部分方法的解释</h4><h5 id="MemberwiseClone"><a href="#MemberwiseClone" class="headerlink" title="MemberwiseClone()"></a>MemberwiseClone()</h5><p>MemberwiseClone();是一个Object类的方法，它可以创建一个新对象，其字段是对原始对象字段的逐位复制。如果字段是值类型的，那么新对象和原始对象的字段值相同；如果字段是引用类型的，那么新对象和原始对象的字段指向同一个引用对象。因此，MemberwiseClone();方法可以实现浅复制。要使用这个方法，我们需要在自定义类中定义一个ShallowCopy()方法，并在其中调用MemberwiseClone();方法，然后返回新对象。</p>
<h3 id="浅复制与赋值的区别"><a href="#浅复制与赋值的区别" class="headerlink" title="浅复制与赋值的区别"></a>浅复制与赋值的区别</h3><p>浅复制和赋值的区别是，浅复制会创建一个<strong>新对象</strong>，并将原始对象的值类型字段复制到新对象中，而赋值只是将原始对象的引用赋给一个变量，不会创建新对象。例如，如果我们用赋值代替浅复制：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="keyword">new</span> Address(<span class="string">&quot;Beijing&quot;</span>, <span class="string">&quot;Xidan&quot;</span>));</span><br><span class="line">Person p2 = p1;</span><br></pre></td></tr></table></figure>

<p>这时，p1和p2都指向同一个Person对象，如果我们修改p1或p2的任何字段，都会影响另一个变量：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">p1.name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">Console.WriteLine(p1.name); <span class="comment">// Bob</span></span><br><span class="line">Console.WriteLine(p2.name); <span class="comment">// Bob</span></span><br><span class="line"></span><br><span class="line">p2.address.city = <span class="string">&quot;Shanghai&quot;</span>;</span><br><span class="line">Console.WriteLine(p1.address.city); <span class="comment">// Shanghai</span></span><br><span class="line">Console.WriteLine(p2.address.city); <span class="comment">// Shanghai</span></span><br></pre></td></tr></table></figure>





<h2 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h2><p>为什么要用到深拷贝呢？比如我们建了某个类Person，并且实例化出一个对象，然后，突然需要把这个对象复制一遍，并且复制出来的对象要跟之前的一模一样，如果两个变量直接赋值，如： <code>A a = new A(); A b = a;</code> 得到的还是同一个对象，并没有复制真正的内容。这时候如果需要复制真正内容的话，就需要用到深拷贝的方式了。</p>
<h3 id="几种常见的深拷贝方式"><a href="#几种常见的深拷贝方式" class="headerlink" title="几种常见的深拷贝方式"></a>几种常见的深拷贝方式</h3><h4 id="利用反射实现"><a href="#利用反射实现" class="headerlink" title="利用反射实现"></a>利用反射实现</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">DeepCopyByReflection</span>&lt;<span class="title">T</span>&gt;(<span class="params">T obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="built_in">string</span> || obj.GetType().IsValueType)</span><br><span class="line">　　<span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">　　<span class="built_in">object</span> retval = Activator.CreateInstance(obj.GetType());</span><br><span class="line">　　FieldInfo[] fields = obj.GetType().GetFields(BindingFlags.Public|BindingFlags.NonPublic|BindingFlags.Static|BindingFlags.Instance);</span><br><span class="line">　　<span class="keyword">foreach</span>(<span class="keyword">var</span> field <span class="keyword">in</span> fields)</span><br><span class="line">　　&#123;</span><br><span class="line">　　　　<span class="keyword">try</span></span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　　　field.SetValue(retval, DeepCopyByReflection(field.GetValue(obj)));</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">return</span> (T)retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用二进制序列化和反序列化"><a href="#利用二进制序列化和反序列化" class="headerlink" title="利用二进制序列化和反序列化"></a>利用二进制序列化和反序列化</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">DeepCopyByBinary</span>&lt;<span class="title">T</span>&gt;(<span class="params">T obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="built_in">object</span> retval;</span><br><span class="line">　　<span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">　　&#123;</span><br><span class="line">　　　　BinaryFormatter bf = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line">　　　　bf.Serialize(ms, obj);</span><br><span class="line">　　　　ms.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line">　　　　retval = bf.Deserialize(ms);</span><br><span class="line">　　　　ms.Close();</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> (T)retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，使用二进制序列化和反序列化时，在需要序列化的类上要加上[Serializable]</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用xml序列化和反序列化"><a href="#利用xml序列化和反序列化" class="headerlink" title="利用xml序列化和反序列化"></a>利用xml序列化和反序列化</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">DeepCopyByXml</span>&lt;<span class="title">T</span>&gt;(<span class="params">T obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="built_in">object</span> retval;</span><br><span class="line">　　<span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">　　&#123;</span><br><span class="line">　　　　XmlSerializer xml=<span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(T));</span><br><span class="line">　　　　xml.Serialize(ms, obj);</span><br><span class="line">　　　　ms.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line">　　　　retval = xml.Deserialize(ms);</span><br><span class="line">　　　　ms.Close();</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> (T)retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>c#中复制可分为深复制、浅复制两种。</p>
<p>首先要明确拷贝产生的结果都是reference type（引用类型）的，本质上还是指向一个对象（毕竟primitive type（简单类型）不需要）</p>
<p>所以深拷贝和浅拷贝的区别，就是拷贝这个reference指向的对象是不是之前的。</p>
<p>有以下两种方式，更推荐第一种：</p>
<h2 id="泛型-反射"><a href="#泛型-反射" class="headerlink" title="泛型+反射"></a>泛型+反射</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 利用反射实现深拷贝*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">object</span> <span class="title">DeepCopy</span>(<span class="params"><span class="built_in">object</span> _object</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Type T = _object.GetType();</span><br><span class="line">    <span class="built_in">object</span> o = Activator.CreateInstance(T);</span><br><span class="line">    PropertyInfo[] PI = T.GetProperties();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; PI.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PropertyInfo P = PI[i];</span><br><span class="line">        P.SetValue(o, P.GetValue(_object));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>反射是.NET中的重要机制,通过反射,可以在运行时获得程序或程序集中每一个类型(包括类、结构、委托、接口和枚举等)的成员和成员的信息。有了反射,即可对每一个类型了如指掌。另外<strong>我还可以直接创建对象,即使这个对象的类型在编译时还不知道</strong>。可以实现从对象的外部来了解对象(或程序集)内部结构的功能,哪怕你不知道这个对象(或程序集)是个什么东西,另外.NET中的反射还可以运态创建出对象并执行它其中的方法。<br>为什么要用反射呢? 举个最简单的例子,当你在VS的设计器里拖入一个控件后,设计器会通过反射获取这个控件的属性,并提供给你进行设置，<strong>设计器在做的时候,根本不可能预知将来有什么控件会被你拖入进去，所以要用反射</strong>。</p>
</blockquote>
<p>这样的好处在于，它消除了模块之间的耦合，便于动态接口调用，在一些灵活的系统里面比较常用。</p>
<h3 id="反射和泛型来实现深拷贝怎么做"><a href="#反射和泛型来实现深拷贝怎么做" class="headerlink" title="反射和泛型来实现深拷贝怎么做"></a>反射和泛型来实现深拷贝怎么做</h3><ul>
<li>首先我们应该获取传入参数的那个对象的类型，也就是反射的GetType()</li>
<li>接下来Activator.CreateInstance(T); 用类型创建新拷贝的对象</li>
<li>PropertyInfo[] PI &#x3D; T.GetProperties(); 这里使用PropertyInfo了解属性的名称、数据类型、声明类型、反射类型和只读或可写状态等,获取或设置属性值。</li>
<li>接下来用Property的SetValue和GetValue来给新对象属性逐个赋值</li>
<li>大功告成，返回新对象就行</li>
</ul>
<p>所以思路很清晰，调用的时候 Test b &#x3D; (Test)DeepCopy(a); 泛型把object转回来就行</p>
<p>总的来说我觉得这是一种比较简单直接也好理解的方法</p>
<h2 id="二进制流的方式（序列化）"><a href="#二进制流的方式（序列化）" class="headerlink" title="二进制流的方式（序列化）"></a>二进制流的方式（序列化）</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> 深拷贝 【不建议使用二进制流方法，此方法即使在类前面加了可序列化标志，调用该方法时也会报未序列化错误】，推荐使用反射方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">DeepCopy</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (MemoryStream stream = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryFormatter bFormatter = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line">        bFormatter.Serialize(stream, <span class="keyword">this</span>);</span><br><span class="line">        stream.Seek(<span class="number">0</span>, SeekOrigin.Begin);</span><br><span class="line">        <span class="keyword">return</span> (InvoiceDetailResponse)bFormatter.Deserialize(stream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h1 id="return原则"><a href="#return原则" class="headerlink" title="return原则"></a>return原则</h1><h2 id="尽早return"><a href="#尽早return" class="headerlink" title="尽早return"></a>尽早return</h2><p>在进入方法的时候先判断是否满足条件，如果不满足直接return；而不是判断条件是否满足而执行指定的代码。</p>
<h2 id="必须保证一定可以return"><a href="#必须保证一定可以return" class="headerlink" title="必须保证一定可以return"></a>必须保证一定可以return</h2><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>只能创建一个对象</p>
<ol>
<li>将构造函数私有化</li>
<li>对外提供一个静态方法，返回一个对象</li>
<li>创建一个单例</li>
<li>返回单例</li>
</ol>
<p>演示环境：WinForm</p>
<h2 id="Form1代码："><a href="#Form1代码：" class="headerlink" title="Form1代码："></a>Form1代码：</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Data;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 单例模式</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_Load</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;            </span><br><span class="line">            Form2 frm2 = Form2.GetSingle();</span><br><span class="line">            frm2.ShowDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Form2代码"><a href="#Form2代码" class="headerlink" title="Form2代码"></a>Form2代码</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Data;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 单例模式</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form2</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//全局唯一的单例</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Form2 FrmSingle = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先私有化构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Form2</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form2_Load</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 提供一个静态方法，返回一个对象</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Form2 <span class="title">GetSingle</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//只有这个对象没被实例化的时候才会被创建对象</span></span><br><span class="line">            <span class="keyword">if</span>(FrmSingle == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                FrmSingle = <span class="keyword">new</span> Form2();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果已经存在了一个对象，则直接返回这个对象</span></span><br><span class="line">            <span class="keyword">return</span> FrmSingle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="XML-可扩展的标记语言"><a href="#XML-可扩展的标记语言" class="headerlink" title="XML 可扩展的标记语言"></a>XML 可扩展的标记语言</h1><p>用于存储数据，并且严格区分大小写。</p>
<p>xml中所有能看到的都是元素</p>
<p>其中一对一对的标签都是节点。</p>
<p>节点包含元素，但元素不都是节点。</p>
<p>对于xml文档来说，有且只能有一个根节点。</p>
<h2 id="通过代码创建xml文档"><a href="#通过代码创建xml文档" class="headerlink" title="通过代码创建xml文档"></a>通过代码创建xml文档</h2><ol>
<li>引用命名空间</li>
<li>创建xml文档对象</li>
<li>创建根节点</li>
<li>创建子节点</li>
<li>为子节点再创建子节点</li>
<li>将子节点添加到父节点</li>
<li>保存xml对象。</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Xml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">XML</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//2. 创建xml对象</span></span><br><span class="line">            XmlDocument doc = <span class="keyword">new</span> XmlDocument();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 创建第一行描述信息，并添加到doc文档中</span></span><br><span class="line">            <span class="comment">//第一个参数是xml的版本号，第二个是编码方式</span></span><br><span class="line">            <span class="comment">//返回的是一个类型为XmlDeclaration的xml节点信息</span></span><br><span class="line">            XmlDeclaration dec =  doc.CreateXmlDeclaration(<span class="string">&quot;1.0&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4. 将节点加入到xml文档中</span></span><br><span class="line">            doc.AppendChild(dec); <span class="comment">//追加节点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建根节点</span></span><br><span class="line">            XmlElement books = doc.CreateElement(<span class="string">&quot;Books&quot;</span>);</span><br><span class="line">            <span class="comment">//将根节点添加到文档中</span></span><br><span class="line">            doc.AppendChild(books);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5. 给根节点Books创建子节点</span></span><br><span class="line">            XmlElement book1 = doc.CreateElement(<span class="string">&quot;Boook&quot;</span>);</span><br><span class="line">            <span class="comment">//将创建出来的子节点添加到根节点中</span></span><br><span class="line">            books.AppendChild(book1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//6. 给Book1添加子节点</span></span><br><span class="line">            XmlElement name1 = doc.CreateElement (<span class="string">&quot;Name&quot;</span>);</span><br><span class="line">            XmlElement price1 = doc.CreateElement(<span class="string">&quot;Price&quot;</span>);</span><br><span class="line">            XmlElement des1 = doc.CreateElement(<span class="string">&quot;Des&quot;</span>);</span><br><span class="line">            <span class="comment">//给这个子节点添加文本</span></span><br><span class="line">            name1.InnerText = <span class="string">&quot;西游记&quot;</span>;</span><br><span class="line">            price1.InnerText = <span class="string">&quot;10&quot;</span>;</span><br><span class="line">            des1.InnerText = <span class="string">&quot;向西的游记&quot;</span>;</span><br><span class="line">            <span class="comment">//将子节点添加到Book1中</span></span><br><span class="line">            book1.AppendChild(name1);</span><br><span class="line">            book1.AppendChild (price1);</span><br><span class="line">            book1.AppendChild (des1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将xml进行保存</span></span><br><span class="line">            doc.Save(<span class="string">@&quot;D:\tmp\test.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="创建带属性的XML文档"><a href="#创建带属性的XML文档" class="headerlink" title="创建带属性的XML文档"></a>创建带属性的XML文档</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Main</span><span class="params">(<span class="built_in">string</span>[] args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建xml对象</span></span><br><span class="line">    XmlDocument doc = new XmlDocument();</span><br><span class="line">    <span class="comment">//创建版本声明</span></span><br><span class="line">    XmlDeclaration dec = doc.CreateXmlDeclaration(<span class="string">&quot;1.1&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, null);</span><br><span class="line">    <span class="comment">//将版本声明添加到xml对象中</span></span><br><span class="line">    doc.AppendChild(dec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建根节点</span></span><br><span class="line">    XmlElement order = doc.CreateElement(<span class="string">&quot;Order&quot;</span>);</span><br><span class="line">    doc.AppendChild(order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建子节点，并将子节点添加到根节点</span></span><br><span class="line">    XmlElement customerName = doc.CreateElement(<span class="string">&quot;CustomerName&quot;</span>);</span><br><span class="line">    customerName.InnerText = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    order.AppendChild(customerName);</span><br><span class="line"></span><br><span class="line">    XmlElement customerNumber = doc.CreateElement(<span class="string">&quot;CustomerNumber&quot;</span>);</span><br><span class="line">    customerNumber.InnerText = <span class="string">&quot;10001&quot;</span>;</span><br><span class="line">    order.AppendChild(customerNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建带属性的子节点</span></span><br><span class="line">    XmlElement items = doc.CreateElement(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    order.AppendChild(items);</span><br><span class="line"></span><br><span class="line">    XmlElement orderItem1 = doc.CreateElement(<span class="string">&quot;OrderItem&quot;</span>);</span><br><span class="line">    <span class="comment">//给节点添加属性</span></span><br><span class="line">    orderItem1.SetAttribute(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;码表&quot;</span>);</span><br><span class="line">    orderItem1.SetAttribute(<span class="string">&quot;Count&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">    <span class="comment">//将这个子节点添加到Item</span></span><br><span class="line">    items.AppendChild(orderItem1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加更多带属性的子节点</span></span><br><span class="line">    XmlElement orderItem2 = doc.CreateElement(<span class="string">&quot;OrderItem&quot;</span>);</span><br><span class="line">    orderItem2.SetAttribute(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;ESP8266&quot;</span>);</span><br><span class="line">    orderItem2.SetAttribute(<span class="string">&quot;Count&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">    items.AppendChild(orderItem2);</span><br><span class="line">    XmlElement orderItem3 = doc.CreateElement(<span class="string">&quot;OrderItem&quot;</span>);</span><br><span class="line">    orderItem3.SetAttribute(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;ESP8266&quot;</span>);</span><br><span class="line">    orderItem3.SetAttribute(<span class="string">&quot;Count&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">    items.AppendChild(orderItem3);</span><br><span class="line">    XmlElement orderItem4 = doc.CreateElement(<span class="string">&quot;OrderItem&quot;</span>);</span><br><span class="line">    orderItem4.SetAttribute(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;ESP32&quot;</span>);</span><br><span class="line">    orderItem4.SetAttribute(<span class="string">&quot;Count&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">    items.AppendChild(orderItem4);</span><br><span class="line"></span><br><span class="line">    doc.Save(@<span class="string">&quot;D:\tmp\Order.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="向XML文档中追加内容"><a href="#向XML文档中追加内容" class="headerlink" title="向XML文档中追加内容"></a>向XML文档中追加内容</h2><p>大致流程</p>
<ol>
<li>实例化XML对象</li>
<li>创建根节点XmlElement，但不给对象</li>
<li>通过File的Exists判断文件是否存在</li>
<li>如果存在则加载到根节点</li>
<li>如果不存在则创建根节点并添加版本信息</li>
<li>生成要追加的子节点</li>
<li>将子节点保存到根节点中</li>
<li>保存Xml对象</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//追加XML文档</span></span><br><span class="line">    <span class="comment">//只要对XML操作，就需要创建XML对象。</span></span><br><span class="line">    XmlDocument doc = <span class="keyword">new</span> XmlDocument();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个根节点，但不给对象</span></span><br><span class="line">    XmlElement books = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果XML文件存在，只需要拿到根节点</span></span><br><span class="line">    <span class="comment">//如果文件不存在，则需要创建XML文档</span></span><br><span class="line">    <span class="keyword">if</span> (File.Exists(<span class="string">@&quot;D:\tmp\test.xml&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//文件存在， 拿到根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//先加载</span></span><br><span class="line">        doc.Load(<span class="string">@&quot;D:\tmp\test.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//后获取</span></span><br><span class="line">        books = doc.DocumentElement;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不存在，就先创建在添加</span></span><br><span class="line">        XmlDeclaration dec = doc.CreateXmlDeclaration(<span class="string">&quot;1.0&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        doc.AppendChild(dec);<span class="comment">//将说明添加进去</span></span><br><span class="line">        <span class="comment">//创建根节点</span></span><br><span class="line">        books = doc.CreateElement(<span class="string">&quot;Books&quot;</span>);</span><br><span class="line">        doc.AppendChild(books);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到根节点后，就可以往里面添加数据了。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//给根节点Books创建子节点</span></span><br><span class="line">    XmlElement book1 = doc.CreateElement(<span class="string">&quot;Boook&quot;</span>);</span><br><span class="line">    <span class="comment">//将创建出来的子节点添加到根节点中</span></span><br><span class="line">    books.AppendChild(book1);</span><br><span class="line">    <span class="comment">//给Book1添加子节点</span></span><br><span class="line">    XmlElement name1 = doc.CreateElement(<span class="string">&quot;Name&quot;</span>);</span><br><span class="line">    XmlElement price1 = doc.CreateElement(<span class="string">&quot;Price&quot;</span>);</span><br><span class="line">    XmlElement des1 = doc.CreateElement(<span class="string">&quot;Des&quot;</span>);</span><br><span class="line">    <span class="comment">//给这个子节点添加文本</span></span><br><span class="line">    name1.InnerText = <span class="string">&quot;C#开发&quot;</span>;</span><br><span class="line">    price1.InnerText = <span class="string">&quot;110&quot;</span>;</span><br><span class="line">    des1.InnerText = <span class="string">&quot;csharp&quot;</span>;</span><br><span class="line">    <span class="comment">//将子节点添加到Book1中</span></span><br><span class="line">    book1.AppendChild(name1);</span><br><span class="line">    book1.AppendChild(price1);</span><br><span class="line">    book1.AppendChild(des1);</span><br><span class="line">    <span class="comment">//将xml进行保存</span></span><br><span class="line">    doc.Save(<span class="string">@&quot;D:\tmp\test.xml&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="读取Xml文档"><a href="#读取Xml文档" class="headerlink" title="读取Xml文档"></a>读取Xml文档</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//实例化xml对象</span></span><br><span class="line">    XmlDocument doc = <span class="keyword">new</span> XmlDocument();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载要读取的文件</span></span><br><span class="line">    doc.Load(<span class="string">@&quot;D:\tmp\test.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取根节点</span></span><br><span class="line">    XmlElement books = doc.DocumentElement;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据父节点获取子节点。返回的是子节点的集合</span></span><br><span class="line">    XmlNodeList xnl = books.ChildNodes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (XmlNode xn <span class="keyword">in</span> xnl)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(xn.InnerText);<span class="comment">//遍历集合中每个子节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="读取带有属性的Xml文档"><a href="#读取带有属性的Xml文档" class="headerlink" title="读取带有属性的Xml文档"></a>读取带有属性的Xml文档</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建xml对象</span></span><br><span class="line">    XmlDocument doc = <span class="keyword">new</span> XmlDocument();</span><br><span class="line">    <span class="comment">//加载文档</span></span><br><span class="line">    doc.Load(<span class="string">@&quot;D:\tmp\Order.xml&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查找指定的路径下的节点，返回的是一个节点的集合</span></span><br><span class="line">    XmlNodeList xnl = doc.SelectNodes(<span class="string">&quot;/Order/items/OrderItem&quot;</span>);</span><br><span class="line">	<span class="comment">//遍历这个集合，并输出其中的值</span></span><br><span class="line">    <span class="keyword">foreach</span> (XmlNode xn <span class="keyword">in</span> xnl)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(xn.Attributes[<span class="string">&quot;Name&quot;</span>].Value);</span><br><span class="line">        Console.WriteLine(xn.Attributes[<span class="string">&quot;Count&quot;</span>].Value);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建xml对象并加载文档</span></span><br><span class="line">    XmlDocument doc = <span class="keyword">new</span> XmlDocument();</span><br><span class="line">    doc.Load(<span class="string">@&quot;D:\tmp\Order.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找到指定的节点</span></span><br><span class="line">    XmlNode xn = doc.SelectSingleNode(<span class="string">&quot;/Order/items&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除指定节点下的所有子节点</span></span><br><span class="line">    xn.RemoveAll();</span><br><span class="line">    doc.Save(<span class="string">@&quot;D:\tmp\Order2.xml&quot;</span>);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h2 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>当需要往节点中添加标签的时候，需要使用InnerXml属性添加。</li>
<li>当要添加文本的时候，需要使用InnerText添加。</li>
<li>区别：InnerText添加的时候会对一些特殊字符进行转义。</li>
</ul>
<h1 id="对象的生存周期-1"><a href="#对象的生存周期-1" class="headerlink" title="对象的生存周期"></a>对象的生存周期</h1><p>每一个对象都有一个明确的生命周期，除了”正在使用”的正常状态外，还有两个重要的阶段：</p>
<ul>
<li>构造阶段<ul>
<li>第一次实例化一个对象时，需要初始化该对象。这个初始化过程称为构造阶段，由构造函数完成。</li>
</ul>
</li>
<li>析构阶段<ul>
<li>在删除一个对象时，常常需要执行一些清理操作，如释放内存，这由析构函数完成。</li>
</ul>
</li>
</ul>
<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p>对象的初始化过程是自动完成的，所有类定义都最少包含一个构造函数。</p>
<p>在C#中，使用<code>new</code>关键字来调用构造函数。</p>
<h4 id="析构函数-1"><a href="#析构函数-1" class="headerlink" title="析构函数"></a>析构函数</h4><p>​	.NET Framework使用析构函数来清理对象。一般情况下，不需要提供析构函数的代码，而由默认的析构函数自动执行操作。但是，如果在删除对象实例前需要完成一些重要操作，就应提供具体的析构函数。</p>
<p>​	例如，如果变量超出了作用域,代码就不能访问它，但该变量仍存在于计算机内存的某个地方。只有在.NET运行程序执行其垃圾回收，进行清理时，该实例才被彻底删除。</p>
<h1 id="C-编码约定"><a href="#C-编码约定" class="headerlink" title="C# 编码约定"></a>C# 编码约定</h1><p>编码约定可实现以下目的：</p>
<ul>
<li>它们为代码创建一致的外观，以确保读取器专注于内容而非布局。</li>
<li>它们使得读取器可以通过基于之前的经验进行的假设更快地理解代码。</li>
<li>它们便于复制、更改和维护代码。</li>
<li>它们展示 C# 最佳做法。</li>
</ul>
<p>Microsoft 根据本文中的准则来开发样本和文档。 根据 <a target="_blank" rel="noopener" href="https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md">.NET 运行时 C# 编码样式</a>指南采用它们。 可使用它们，或者按照你的需求采用它们。 主要目标是在项目、团队、组织或公司源代码中实现一致性和可读性。</p>
<h2 id="简要"><a href="#简要" class="headerlink" title="简要"></a>简要</h2><h3 id="Pascal-（大驼峰）命名方式"><a href="#Pascal-（大驼峰）命名方式" class="headerlink" title="Pascal （大驼峰）命名方式"></a>Pascal （大驼峰）命名方式</h3><p>命名空间、类、接口、抽象类、结构体、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%9E%9A%E4%B8%BE%E7%B1%BB&spm=1001.2101.3001.7020">枚举类</a>、方法名、以及类中的属性，须要使用 Pascal 命名规范；名称中每一个单词的首字母都要大写；</p>
<h3 id="Camel-（小驼峰）命名方式"><a href="#Camel-（小驼峰）命名方式" class="headerlink" title="Camel （小驼峰）命名方式"></a>Camel （小驼峰）命名方式</h3><p>方法参数、局部变量、以及私有的成员变量，须要使用 Camel 命名规范；名称中第一个单词是小写的，从第二个单词起，后面每一个单词的首字母都要大写；</p>
<h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><p>编写 C# 代码时需要考虑几个命名约定。</p>
<p>在下面的示例中，在使用 <code>protected</code> 和 <code>protected internal</code> 元素时，还需遵守与标记了 <code>public</code> 的元素相关的任何指南 - 所有这些元素都旨在对外部调用方可见。</p>
<h3 id="帕斯卡拼写法-大驼峰"><a href="#帕斯卡拼写法-大驼峰" class="headerlink" title="帕斯卡拼写法(大驼峰)"></a>帕斯卡拼写法(大驼峰)</h3><p>命名 <code>class</code>、<code>record</code> 或 <code>struct</code> 时，使用 pascal 大小写（“PascalCasing”）。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DataService</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title">PhysicalAddress</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">string</span> Street,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">string</span> City,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">string</span> StateOrProvince,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">string</span> ZipCode</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> ValueCoordinate</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名 <code>interface</code> 时，使用 pascal 大小写并在名称前面加上前缀 <code>I</code>。 这可以清楚地向使用者表明这是 <code>interface</code>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWorkerQueue</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名类型的 <code>public</code> 成员（例如字段、属性、事件、方法和本地函数）时，请使用 pascal 大小写。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleEvents</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// A public field, these should be used sparingly</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsValid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// An init-only property</span></span><br><span class="line">    <span class="keyword">public</span> IWorkerQueue WorkerQueue &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// An event</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action EventProcessing;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartEventProcessing</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Local function</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CountQueueItems</span>()</span> =&gt; WorkerQueue.Count;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写位置记录时，对参数使用 pascal 大小写，因为它们是记录的公共属性。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title">PhysicalAddress</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">string</span> Street,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">string</span> City,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">string</span> StateOrProvince,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="built_in">string</span> ZipCode</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>有关位置记录的详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/record#positional-syntax-for-property-definition">属性定义的位置语法</a>。</p>
<h3 id="驼峰式大小写（小驼峰）"><a href="#驼峰式大小写（小驼峰）" class="headerlink" title="驼峰式大小写（小驼峰）"></a>驼峰式大小写（小驼峰）</h3><p>命名 <code>private</code> 或 <code>internal</code> 字段时，使用驼峰式大小写（“camelCasing”），并且它们以 <code>_</code> 作为前缀。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DataService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IWorkerQueue _workerQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在支持语句完成的 IDE 中编辑遵循这些命名约定的 C# 代码时，键入 <code>_</code> 将显示所有对象范围的成员。</p>
<p>使用为 <code>private</code> 或 <code>internal</code> 的<code>static</code> 字段时 请使用 <code>s_</code> 前缀，对于线程静态，请使用 <code>t_</code>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DataService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IWorkerQueue s_workerQueue;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">ThreadStatic</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TimeSpan t_timeSpan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写方法参数时，请使用驼峰式大小写。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">SomeMethod</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">int</span> someNumber, <span class="built_in">bool</span> isValid</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关 C# 命名约定的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md">C# 编码样式</a>。</p>
<h3 id="其他命名约定"><a href="#其他命名约定" class="headerlink" title="其他命名约定"></a>其他命名约定</h3><ul>
<li><p>在不包括 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/using-directive">using 指令</a>的示例中，使用命名空间限定。 如果你知道命名空间默认导入项目中，则不必完全限定来自该命名空间的名称。 如果对于单行来说过长，则可以在点 (.) 后中断限定名称，如下面的示例所示。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> currentPerformanceCounterCategory = <span class="keyword">new</span> System.Diagnostics.</span><br><span class="line">    PerformanceCounterCategory();</span><br></pre></td></tr></table></figure>
</li>
<li><p>你不必更改使用 Visual Studio 设计器工具创建的对象的名称以使它们适合其他准则。</p>
</li>
</ul>
<h2 id="布局约定"><a href="#布局约定" class="headerlink" title="布局约定"></a>布局约定</h2><p>好的布局利用格式设置来强调代码的结构并使代码更便于阅读。 Microsoft 示例和样本符合以下约定：</p>
<ul>
<li><p>使用默认的代码编辑器设置（智能缩进、4 字符缩进、制表符保存为空格）。 有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/visualstudio/ide/reference/options-text-editor-csharp-formatting">选项、文本编辑器、C#、格式设置</a>。</p>
</li>
<li><p>每行只写一条语句。</p>
</li>
<li><p>每行只写一个声明。</p>
</li>
<li><p>如果连续行未自动缩进，请将它们缩进一个制表符位（四个空格）。</p>
</li>
<li><p>在方法定义与属性定义之间添加至少一个空白行。</p>
</li>
<li><p>使用括号突出表达式中的子句，如下面的代码所示。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((val1 &gt; val2) &amp;&amp; (val1 &gt; val3))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Take appropriate action.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="将-using-指令放在命名空间声明之外"><a href="#将-using-指令放在命名空间声明之外" class="headerlink" title="将 using 指令放在命名空间声明之外"></a>将 using 指令放在命名空间声明之外</h2><p>当 <code>using</code> 指令位于命名空间声明之外时，该导入的命名空间是其完全限定的名称。 这样就比较清楚了。 如果 <code>using</code> 指令位于命名空间内部，它可以是相对于该命名空间的，也可以是完全限定的名称。 这容易说不清楚。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Azure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CoolStuff.AwesomeFeature</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Awesome</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Stuff</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            WaitUntil wait = WaitUntil.Completed;</span><br><span class="line">            …</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设存在对 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/azure.waituntil">WaitUntil</a> 类的引用（直接或间接）。</p>
<p>现在，让我们稍作改动：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">CoolStuff.AwesomeFeature</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> Azure;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Awesome</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Stuff</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            WaitUntil wait = WaitUntil.Completed;</span><br><span class="line">            …</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>今天的编译成功了。 明天的也没问题。 但在下周的某个时候，此（保持不变）代码故障，并出现两个错误：</p>
<p>控制台复制</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">- error CS0246: The type or namespace name &#x27;WaitUntil&#x27; could not be found (are you missing a using directive or an assembly reference?)</span><br><span class="line">- error CS0103: The name &#x27;WaitUntil&#x27; does not exist in the current context</span><br></pre></td></tr></table></figure>

<p>其中一个依赖项已在命名空间中引入了此类，然后以 <code>.Azure</code> 结尾：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">CoolStuff.Azure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SecretsManagement</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">FetchFromKeyVault</span>(<span class="params"><span class="built_in">string</span> vaultId, <span class="built_in">string</span> secretId</span>)</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>放置在命名空间中的 <code>using</code> 指令与上下文相关，使名称解析复杂化。 在此示例中，它是它找到的第一个命名空间。</p>
<ul>
<li><code>CoolStuff.AwesomeFeature.Azure</code></li>
<li><code>CoolStuff.Azure</code></li>
<li><code>Azure</code></li>
</ul>
<p>添加匹配 <code>CoolStuff.Azure</code> 或 <code>CoolStuff.AwesomeFeature.Azure</code> 的新命名空间将在全局 <code>Azure</code> 命名空间前匹配。 可以通过向 <code>using</code> 声明添加 <code>global::</code> 修饰符来解决此问题。 但是，改为将 <code>using</code> 声明放在命名空间之外更容易。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">CoolStuff.AwesomeFeature</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">global</span>::Azure;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Awesome</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Stuff</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            WaitUntil wait = WaitUntil.Completed;</span><br><span class="line">            …</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="注释约定"><a href="#注释约定" class="headerlink" title="注释约定"></a>注释约定</h2><ul>
<li><p>将注释放在单独的行上，而非代码行的末尾。</p>
</li>
<li><p>以大写字母开始注释文本。</p>
</li>
<li><p>以句点结束注释文本。</p>
</li>
<li><p>在注释分隔符 (&#x2F;&#x2F;) 与注释文本之间插入一个空格，如下面的示例所示。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The following declaration creates a query. It does not run</span></span><br><span class="line"><span class="comment">// the query.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>请勿在注释周围创建格式化的星号块。</p>
</li>
<li><p>请确保所有公共成员都有必要的 XML 注释，从而提供有关其行为的适当说明。</p>
</li>
</ul>
<h2 id="语言准则"><a href="#语言准则" class="headerlink" title="语言准则"></a>语言准则</h2><p>以下各节介绍 C# 遵循以准备代码示例和样本的做法。</p>
<h3 id="字符串数据类型"><a href="#字符串数据类型" class="headerlink" title="字符串数据类型"></a>字符串数据类型</h3><ul>
<li><p>使用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/tokens/interpolated">字符串内插</a>来连接短字符串，如下面的代码所示。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> displayName = <span class="string">$&quot;<span class="subst">&#123;nameList[n].LastName&#125;</span>, <span class="subst">&#123;nameList[n].FirstName&#125;</span>&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若要在循环中追加字符串，尤其是在使用大量文本时，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.text.stringbuilder">StringBuilder</a> 对象。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> phrase = <span class="string">&quot;lalalalalalalalalalalalalalalalalalalalalalalalalalalalalala&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> manyPhrases = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    manyPhrases.Append(phrase);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Console.WriteLine(&quot;tra&quot; + manyPhrases);</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="隐式类型本地变量"><a href="#隐式类型本地变量" class="headerlink" title="隐式类型本地变量"></a>隐式类型本地变量</h3><ul>
<li><p>当变量类型明显来自赋值的右侧时，或者当精度类型不重要时，请对本地变量进行<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables">隐式类型化</a>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> var1 = <span class="string">&quot;This is clearly a string.&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> var2 = <span class="number">27</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当类型并非明显来自赋值的右侧时，请勿使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/declarations#implicitly-typed-local-variables">var</a>。 请勿假设类型明显来自方法名称。 如果变量类型为 <code>new</code> 运算符或显式强制转换，则将其视为明显来自方法名称。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> var3 = Convert.ToInt32(Console.ReadLine()); </span><br><span class="line"><span class="built_in">int</span> var4 = ExampleClass.ResultSoFar();</span><br></pre></td></tr></table></figure>
</li>
<li><p>请勿依靠变量名称来指定变量的类型。 它可能不正确。 在以下示例中，变量名称 <code>inputInt</code> 会产生误导性。 它是字符串。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inputInt = Console.ReadLine();</span><br><span class="line">Console.WriteLine(inputInt);</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免使用 <code>var</code> 来代替 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/reference-types">dynamic</a>。 如果想要进行运行时类型推理，请使用 <code>dynamic</code>。 有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/advanced-topics/interop/using-type-dynamic">使用类型 dynamic（C# 编程指南）</a>。</p>
</li>
<li><p>使用隐式类型化来确定 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement"><code>for</code></a> 循环中循环变量的类型。</p>
<p>下面的示例在 <code>for</code> 语句中使用隐式类型化。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> phrase = <span class="string">&quot;lalalalalalalalalalalalalalalalalalalalalalalalalalalalalala&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> manyPhrases = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    manyPhrases.Append(phrase);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Console.WriteLine(&quot;tra&quot; + manyPhrases);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不要使用隐式类型化来确定 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement"><code>foreach</code></a> 循环中循环变量的类型。 在大多数情况下，集合中的元素类型并不明显。 不应仅依靠集合的名称来推断其元素的类型。</p>
<p>下面的示例在 <code>foreach</code> 语句中使用显式类型化。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="built_in">char</span> ch <span class="keyword">in</span> laugh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;h&#x27;</span>)</span><br><span class="line">        Console.Write(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Console.Write(ch);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine();</span><br></pre></td></tr></table></figure>

<p> 备注</p>
<p>注意不要意外更改可迭代集合的元素类型。 例如，在 <code>foreach</code> 语句中从 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.linq.iqueryable">System.Linq.IQueryable</a> 切换到 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerable">System.Collections.IEnumerable</a> 很容易，这会更改查询的执行。</p>
</li>
</ul>
<h3 id="无符号数据类型"><a href="#无符号数据类型" class="headerlink" title="无符号数据类型"></a>无符号数据类型</h3><p>通常，使用 <code>int</code> 而非无符号类型。 <code>int</code> 的使用在整个 C# 中都很常见，并且当你使用 <code>int</code> 时，更易于与其他库交互。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>当在声明行上初始化数组时，请使用简洁的语法。 在以下示例中，请注意不能使用 <code>var</code> 替代 <code>string[]</code>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] vowels1 = &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;u&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>如果使用显式实例化，则可以使用 <code>var</code>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vowels2 = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;u&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/standard/delegates-lambdas"><code>Func&lt;&gt;</code> 和 <code>Action&lt;&gt;</code></a>，而不是定义委托类型。 在类中，定义委托方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Action&lt;<span class="built_in">string</span>&gt; ActionExample1 = x =&gt; Console.WriteLine(<span class="string">$&quot;x is: <span class="subst">&#123;x&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Action&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; ActionExample2 = (x, y) =&gt; </span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;x is: <span class="subst">&#123;x&#125;</span>, y is <span class="subst">&#123;y&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Func&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; FuncExample1 = x =&gt; Convert.ToInt32(x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; FuncExample2 = (x, y) =&gt; x + y;</span><br></pre></td></tr></table></figure>

<p>使用 <code>Func&lt;&gt;</code> 或 <code>Action&lt;&gt;</code> 委托定义的签名来调用方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ActionExample1(<span class="string">&quot;string for x&quot;</span>);</span><br><span class="line"></span><br><span class="line">ActionExample2(<span class="string">&quot;string for x&quot;</span>, <span class="string">&quot;string for y&quot;</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;The value is <span class="subst">&#123;FuncExample1(<span class="string">&quot;1&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;The sum is <span class="subst">&#123;FuncExample2(<span class="number">1</span>, <span class="number">2</span>)&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果创建委托类型的实例，请使用简洁的语法。 在类中，定义委托类型和具有匹配签名的方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Del</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DelMethod</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;DelMethod argument: &#123;0&#125;&quot;</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建委托类型的实例，然后调用该实例。 以下声明显示了紧缩的语法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Del exampleDel2 = DelMethod;</span><br><span class="line">exampleDel2(<span class="string">&quot;Hey&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以下声明使用了完整的语法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Del exampleDel1 = <span class="keyword">new</span> Del(DelMethod);</span><br><span class="line">exampleDel1(<span class="string">&quot;Hey&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="try-catch-和-using-语句正在异常处理中"><a href="#try-catch-和-using-语句正在异常处理中" class="headerlink" title="try-catch 和 using 语句正在异常处理中"></a><code>try</code>-<code>catch</code> 和 <code>using</code> 语句正在异常处理中</h3><ul>
<li><p>对大多数异常处理使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/try-catch">try-catch</a> 语句。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetValueFromArray</span>(<span class="params"><span class="built_in">string</span>[] array, <span class="built_in">int</span> index</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (System.IndexOutOfRangeException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Index is out of range: &#123;0&#125;&quot;</span>, index);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过使用 C# <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/using-statement">using 语句</a>简化你的代码。 如果具有 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/try-finally">try-finally</a> 语句（该语句中 <code>finally</code> 块的唯一代码是对 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/api/system.idisposable.dispose">Dispose</a> 方法的调用），请使用 <code>using</code> 语句代替。</p>
<p>在以下示例中，<code>try</code>-<code>finally</code> 语句仅在 <code>finally</code> 块中调用 <code>Dispose</code>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Font font1 = <span class="keyword">new</span> Font(<span class="string">&quot;Arial&quot;</span>, <span class="number">10.0f</span>);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">byte</span> charset = font1.GdiCharSet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (font1 != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ((IDisposable)font1).Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>using</code> 语句执行相同的操作。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (Font font2 = <span class="keyword">new</span> Font(<span class="string">&quot;Arial&quot;</span>, <span class="number">10.0f</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">byte</span> charset2 = font2.GdiCharSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用不需要大括号的新 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/using-statement"><code>using</code> 语法</a>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Font font3 = <span class="keyword">new</span> Font(<span class="string">&quot;Arial&quot;</span>, <span class="number">10.0f</span>);</span><br><span class="line"><span class="built_in">byte</span> charset3 = font3.GdiCharSet;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="和-运算符"><a href="#和-运算符" class="headerlink" title="&amp;&amp; 和 || 运算符"></a><code>&amp;&amp;</code> 和 <code>||</code> 运算符</h3><p>若要通过跳过不必要的比较来避免异常并提高性能，请在执行比较时使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#conditional-logical-and-operator-"><code>&amp;&amp;</code></a>（而不是 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#logical-and-operator-"><code>&amp;</code></a>）和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#conditional-logical-or-operator-"><code>||</code></a>（而不是 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/boolean-logical-operators#logical-or-operator-"><code>|</code></a>），如下面的示例所示。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Console.Write(<span class="string">&quot;Enter a dividend: &quot;</span>);</span><br><span class="line"><span class="built_in">int</span> dividend = Convert.ToInt32(Console.ReadLine());</span><br><span class="line"></span><br><span class="line">Console.Write(<span class="string">&quot;Enter a divisor: &quot;</span>);</span><br><span class="line"><span class="built_in">int</span> divisor = Convert.ToInt32(Console.ReadLine());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((divisor != <span class="number">0</span>) &amp;&amp; (dividend / divisor &gt; <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Quotient: &#123;0&#125;&quot;</span>, dividend / divisor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Attempted division by 0 ends up here.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果除数为 0，则 <code>if</code> 语句中的第二个子句将导致运行时错误。 但是，当第一个表达式为 false 时，&amp;&amp; 运算符将发生短路。 也就是说，它并不评估第二个表达式。 如果 <code>divisor</code> 为 0，则 &amp; 运算符将同时计算这两个表达式，这会导致运行时错误。</p>
<h3 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a><code>new</code> 运算符</h3><ul>
<li><p>使用对象实例化的简洁形式之一，如以下声明中所示。 第二个示例显示了从 C# 9 开始可用的语法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> ExampleClass();</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ExampleClass instance2 = <span class="keyword">new</span>();</span><br></pre></td></tr></table></figure>

<p>前面的声明等效于下面的声明。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ExampleClass instance2 = <span class="keyword">new</span> ExampleClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用对象初始值设定项简化对象创建，如以下示例中所示。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> instance3 = <span class="keyword">new</span> ExampleClass &#123; Name = <span class="string">&quot;Desktop&quot;</span>, ID = <span class="number">37414</span>,</span><br><span class="line">    Location = <span class="string">&quot;Redmond&quot;</span>, Age = <span class="number">2.3</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>下面的示例设置了与前面的示例相同的属性，但未使用初始值设定项。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> instance4 = <span class="keyword">new</span> ExampleClass();</span><br><span class="line">instance4.Name = <span class="string">&quot;Desktop&quot;</span>;</span><br><span class="line">instance4.ID = <span class="number">37414</span>;</span><br><span class="line">instance4.Location = <span class="string">&quot;Redmond&quot;</span>;</span><br><span class="line">instance4.Age = <span class="number">2.3</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>如果你正在定义一个稍后不需要删除的事件处理程序，请使用 lambda 表达式。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Form2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.Click += (s, e) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(</span><br><span class="line">                ((MouseEventArgs)e).Location.ToString());</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lambda 表达式缩短了以下传统定义。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.Click += <span class="keyword">new</span> EventHandler(Form1_Click);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Form1_Click</span>(<span class="params"><span class="built_in">object</span>? sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(((MouseEventArgs)e).Location.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>使用类名调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/static">static</a> 成员：ClassName.StaticMember。 这种做法通过明确静态访问使代码更易于阅读。 请勿使用派生类的名称来限定基类中定义的静态成员。 编译该代码时，代码可读性具有误导性，如果向派生类添加具有相同名称的静态成员，代码可能会被破坏。</p>
<h3 id="LINQ-查询"><a href="#LINQ-查询" class="headerlink" title="LINQ 查询"></a>LINQ 查询</h3><ul>
<li><p>对查询变量使用有意义的名称。 下面的示例为位于西雅图的客户使用 <code>seattleCustomers</code>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> seattleCustomers = <span class="keyword">from</span> customer <span class="keyword">in</span> customers</span><br><span class="line">                       <span class="keyword">where</span> customer.City == <span class="string">&quot;Seattle&quot;</span></span><br><span class="line">                       <span class="keyword">select</span> customer.Name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用别名确保匿名类型的属性名称都使用 Pascal 大小写格式正确大写。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> localDistributors =</span><br><span class="line">    <span class="keyword">from</span> customer <span class="keyword">in</span> customers</span><br><span class="line">    <span class="keyword">join</span> distributor <span class="keyword">in</span> distributors <span class="keyword">on</span> customer.City <span class="keyword">equals</span> distributor.City</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span> &#123; Customer = customer, Distributor = distributor &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果结果中的属性名称模棱两可，请对属性重命名。 例如，如果你的查询返回客户名称和分销商 ID，而不是在结果中将它们保留为 <code>Name</code> 和 <code>ID</code>，请对它们进行重命名以明确 <code>Name</code> 是客户的名称，<code>ID</code> 是分销商的 ID。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> localDistributors2 =</span><br><span class="line">    <span class="keyword">from</span> customer <span class="keyword">in</span> customers</span><br><span class="line">    <span class="keyword">join</span> distributor <span class="keyword">in</span> distributors <span class="keyword">on</span> customer.City <span class="keyword">equals</span> distributor.City</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span> &#123; CustomerName = customer.Name, DistributorID = distributor.ID &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在查询变量和范围变量的声明中使用隐式类型化。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> seattleCustomers = <span class="keyword">from</span> customer <span class="keyword">in</span> customers</span><br><span class="line">                       <span class="keyword">where</span> customer.City == <span class="string">&quot;Seattle&quot;</span></span><br><span class="line">                       <span class="keyword">select</span> customer.Name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对齐 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/from-clause"><code>from</code></a> 子句下的查询子句，如上面的示例所示。</p>
</li>
<li><p>在其他查询子句前面使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/where-clause"><code>where</code></a> 子句，确保后面的查询子句作用于经过缩减和筛选的一组数据。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> seattleCustomers2 = <span class="keyword">from</span> customer <span class="keyword">in</span> customers</span><br><span class="line">                        <span class="keyword">where</span> customer.City == <span class="string">&quot;Seattle&quot;</span></span><br><span class="line">                        <span class="keyword">orderby</span> customer.Name</span><br><span class="line">                        <span class="keyword">select</span> customer;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用多行 <code>from</code> 子句代替 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/join-clause"><code>join</code></a> 子句来访问内部集合。 例如，<code>Student</code> 对象的集合可能包含测验分数的集合。 当执行以下查询时，它返回高于 90 的分数，并返回得到该分数的学生的姓氏。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scoreQuery = <span class="keyword">from</span> student <span class="keyword">in</span> students</span><br><span class="line">                 <span class="keyword">from</span> score <span class="keyword">in</span> student.Scores!</span><br><span class="line">                 <span class="keyword">where</span> score &gt; <span class="number">90</span></span><br><span class="line">                 <span class="keyword">select</span> <span class="keyword">new</span> &#123; Last = student.LastName, score &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>请遵循<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/standard/security/secure-coding-guidelines">安全编码准则</a>中的准则。</p>
<h2 id="请参阅"><a href="#请参阅" class="headerlink" title="请参阅"></a>请参阅</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md">.NET 运行时编码准则</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/visual-basic/programming-guide/program-structure/coding-conventions">Visual Basic 编码约定</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/standard/security/secure-coding-guidelines">安全编码准则</a></li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="XXX-ToString-格式化数值结果表"><a href="#XXX-ToString-格式化数值结果表" class="headerlink" title="XXX.ToString 格式化数值结果表"></a>XXX.ToString 格式化数值结果表</h2><table>
<thead>
<tr>
<th>格式说明符</th>
<th>说明</th>
<th>示例</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>C</td>
<td>货币</td>
<td>15.ToString(“C”)</td>
<td>￥15.00</td>
</tr>
<tr>
<td></td>
<td></td>
<td>15.ToString(“C1”)</td>
<td>￥15.0</td>
</tr>
<tr>
<td></td>
<td></td>
<td>15.ToString(“C3”)</td>
<td>￥15.000</td>
</tr>
<tr>
<td>D</td>
<td>十进制数</td>
<td>15.ToString(“D1”)</td>
<td>15</td>
</tr>
<tr>
<td></td>
<td></td>
<td>15.ToString(“D2”)</td>
<td>15</td>
</tr>
<tr>
<td></td>
<td></td>
<td>15.ToString(“D5”)</td>
<td>00015</td>
</tr>
<tr>
<td>E</td>
<td>科学型</td>
<td>15.ToString(“E”)</td>
<td>1.500000E+001</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1500.ToString(“E”)</td>
<td>1.500000E+003</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0.15.ToString(“E”)</td>
<td>1.500000E-001</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0.0015.ToString(“E”)</td>
<td>1.500000E-003</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0.0015.ToString(“E0”)</td>
<td>2E-003</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0.0015.ToString(“E1”)</td>
<td>1.5E-003</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0.0015.ToString(“E2”)</td>
<td>1.50E-003</td>
</tr>
<tr>
<td>F</td>
<td>固定点</td>
<td>15.ToString(“F1”)</td>
<td>15.0</td>
</tr>
<tr>
<td></td>
<td></td>
<td>15.ToString(“F2”)</td>
<td>15.00</td>
</tr>
<tr>
<td>G</td>
<td>常规</td>
<td>2.5.ToString(“G”)</td>
<td>2.5</td>
</tr>
<tr>
<td>N</td>
<td>数字</td>
<td>1500000.ToString(“N”)</td>
<td>1,500,000.00</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1500000.ToString(“N0”)</td>
<td>1,500,000</td>
</tr>
<tr>
<td></td>
<td></td>
<td>1500000.ToString(“N1”)</td>
<td>1,500,000.0</td>
</tr>
<tr>
<td>X</td>
<td>十六进制</td>
<td>15.ToString(“X”)</td>
<td>F</td>
</tr>
<tr>
<td></td>
<td></td>
<td>15.ToString(“X3”)</td>
<td>00F</td>
</tr>
</tbody></table>
<h2 id="String-Format-格式化数值结果表"><a href="#String-Format-格式化数值结果表" class="headerlink" title="String.Format 格式化数值结果表"></a>String.Format 格式化数值结果表</h2><table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
<th>示例</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>C</td>
<td>货币</td>
<td>string.Format(“{0:C3}”, 2)</td>
<td>＄2.000</td>
</tr>
<tr>
<td>D</td>
<td>十进制</td>
<td>string.Format(“{0:D3}”, 2)</td>
<td>002</td>
</tr>
<tr>
<td>E</td>
<td>科学计数法</td>
<td>1.20E+001</td>
<td>1.20E+001</td>
</tr>
<tr>
<td>G</td>
<td>常规</td>
<td>string.Format(“{0:G}”, 2)</td>
<td>2</td>
</tr>
<tr>
<td>N</td>
<td>用分号隔开的数字</td>
<td>string.Format(“{0:N}”, 250000)</td>
<td>250,000.00</td>
</tr>
<tr>
<td>X</td>
<td>十六进制</td>
<td>string.Format(“{0:X000}”, 12)</td>
<td>C</td>
</tr>
<tr>
<td>0</td>
<td>零占位符</td>
<td>string.Format(“{0:000.000}”, 12.3)</td>
<td>012.300</td>
</tr>
<tr>
<td>#</td>
<td>数字占位符</td>
<td>String.Format(“{0:#}”, 12.3)</td>
<td>12</td>
</tr>
<tr>
<td></td>
<td></td>
<td>String.Format(“{0:##}”, 12.3)</td>
<td>12</td>
</tr>
<tr>
<td></td>
<td></td>
<td>String.Format(“{0:###}”, 12.3)</td>
<td>12</td>
</tr>
<tr>
<td></td>
<td></td>
<td>String.Format(“{0:###.#}”, 12.3)</td>
<td>12.3</td>
</tr>
</tbody></table>
<h2 id="String-Format-自定义模式输出"><a href="#String-Format-自定义模式输出" class="headerlink" title="String.Format 自定义模式输出"></a>String.Format 自定义模式输出</h2><ol>
<li>“0”描述：占位符，如果可能，填充位</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">String.Format(<span class="string">&quot;&#123;0:000000&#125;&quot;</span>, <span class="number">1234</span>);  <span class="comment">// 结果：001234</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>“#”描述：占位符，如果可能，填充位</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">String.Format(<span class="string">&quot;&#123;0:######&#125;&quot;</span>, <span class="number">1234</span>);  <span class="comment">// 结果：1234</span></span><br><span class="line">String.Format(<span class="string">&quot;&#123;0:#0####&#125;&quot;</span>, <span class="number">1234</span>);  <span class="comment">// 结果：01234</span></span><br><span class="line">String.Format(<span class="string">&quot;&#123;0:0#0####&#125;&quot;</span>, <span class="number">1234</span>);  <span class="comment">// 结果：0001234</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>“.”描述：小数点</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">String.Format(<span class="string">&quot;&#123;0:000.000&#125;&quot;</span>, <span class="number">1234</span>);  <span class="comment">// 结果：1234.000</span></span><br><span class="line">String.Format(<span class="string">&quot;&#123;0:000.000&#125;&quot;</span>, <span class="number">4321.12543</span>);  <span class="comment">// 结果：4321.125</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>“,”描述：数字分组，也用于增倍器</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">String.Format(<span class="string">&quot;&#123;0:0,0&#125;&quot;</span>, <span class="number">1234567</span>);  <span class="comment">// 结果：1,234,567</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>“%”描述：格式为百分数</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">String.Format(<span class="string">&quot;&#123;0:0%&#125;&quot;</span>, <span class="number">1234</span>);  <span class="comment">// 结果：123400%</span></span><br><span class="line">String.Format(<span class="string">&quot;&#123;0:#%&#125;&quot;</span>, <span class="number">1234.125</span>);  <span class="comment">// 结果：123413%</span></span><br><span class="line">String.Format(<span class="string">&quot;&#123;0:0.00%&#125;&quot;</span>, <span class="number">1234</span>);  <span class="comment">// 结果： 123400.00%</span></span><br><span class="line">String.Format(<span class="string">&quot;&#123;0:#.00%&#125;&quot;</span>, <span class="number">1234.125</span>);  <span class="comment">// 结果：123412.50%</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>“abc”描述：显示单引号内的文本</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">String.Format(<span class="string">&quot;&#123;0:&#x27;文本&#x27;0&#125;&quot;</span>, <span class="number">1234</span>);  <span class="comment">// 结果：文本1234</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>“”描述：用于转移符</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">String.Format(<span class="string">&quot;\&quot;abc!\&quot;&quot;</span>);  <span class="comment">// 结果：abc!</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>c”@”描述：后跟要打印字符串c</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">String.Format(<span class="string">@&quot;&quot;</span>abc!<span class="string">&quot;&quot;</span>);  <span class="comment">// 结果：abc! </span></span><br></pre></td></tr></table></figure>



<h1 id="c-的一些小样例"><a href="#c-的一些小样例" class="headerlink" title="c#的一些小样例"></a>c#的一些小样例</h1><h2 id="读取键盘输入的值到变量"><a href="#读取键盘输入的值到变量" class="headerlink" title="读取键盘输入的值到变量"></a>读取键盘输入的值到变量</h2><p><strong>System</strong> 命名空间中的 <strong>Console</strong> 类提供了一个函数 <strong>ReadLine()</strong>，用于接收来自用户的输入，并把它存储到一个变量中。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num;</span><br><span class="line">num = Convert.ToInt32(Console.ReadLine());</span><br></pre></td></tr></table></figure>

<p>函数 <strong>Convert.ToInt32()</strong> 把用户输入的数据转换为 int 数据类型，因为 <strong>Console.ReadLine()</strong> 只接受字符串格式的数据。</p>
<h2 id="c-指针"><a href="#c-指针" class="headerlink" title="c#指针"></a>c#指针</h2><p>c#是可以用指针的，但不推荐。如果必须要使用，则需要在这段程序的前面加上修饰符<code>unsafe</code>，表示在书写不安全的代码。</p>
<p>同时可能还需要在visual studio的项目-项目属性-生成（build）勾选上允许不安全代码。</p>
<p>这样：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">Fun</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">int</span>* p = &amp;a;</span><br><span class="line">            Console.WriteLine(*p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>或这样：把涉及到指针的代码放到一个代码块内，然后声明这个代码块是不安全的</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">Fun</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">unsafe</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span>* p = &amp;a;</span><br><span class="line">                Console.WriteLine(*p);</span><br><span class="line">            &#125;            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>





<h2 id="强制分配数组在栈空间中"><a href="#强制分配数组在栈空间中" class="headerlink" title="强制分配数组在栈空间中"></a>强制分配数组在栈空间中</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">Fun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] a = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>];<span class="comment">//正常的创建一个数组</span></span><br><span class="line">        <span class="keyword">unsafe</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span>* b = <span class="keyword">stackalloc</span> <span class="built_in">int</span>[<span class="number">10</span>];<span class="comment">//强制的在栈上创建一个数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="常量和只读字段的区别"><a href="#常量和只读字段的区别" class="headerlink" title="常量和只读字段的区别"></a>常量和只读字段的区别</h2><ul>
<li>常量隶属于类,而不是对象,即没有”实例常量”</li>
<li>“实例常量”的角色由只读实例字段担当</li>
</ul>
<h3 id="常见的应用场景"><a href="#常见的应用场景" class="headerlink" title="常见的应用场景"></a>常见的应用场景</h3><ul>
<li>为了提高程序可读性和执行效率 &#x3D;&#x3D;&gt; 常量</li>
<li>为了防止对象的值被改变 &#x3D;&#x3D;&gt; 只读字段</li>
<li>向外暴露不允许修改的数据 &#x3D;&#x3D;&gt; 只读属性(静态或非静态), 功能与常量有一些重叠</li>
<li>当希望成为常量的值其类型不能被常量声明接收时(类&#x2F;自定义结构体) &#x3D;&#x3D;&gt; 静态只读字段 (这句话太绕了)</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(Web.WebsiteURL);</span><br><span class="line"></span><br><span class="line">            Web web = <span class="keyword">new</span> Web();</span><br><span class="line">            Console.WriteLine(web.version);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Web</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">// 常量</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> WebsiteURL = <span class="string">&quot;http://www.baidu.com&quot;</span>;</span><br><span class="line">        <span class="comment">// 只读字段</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">string</span> version = <span class="string">&quot;1.0.0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="各种“只读”的应用场景"><a href="#各种“只读”的应用场景" class="headerlink" title="各种“只读”的应用场景"></a>各种“只读”的应用场景</h2><p>为了提高程序的可读性和执行效率——常量</p>
<p>为了放置对象的值被修改——只读字段</p>
<p>向外暴露不允许修改的数据——只读属性</p>
<p>当希望成为常量的值其类型不能被常量声明接受时（类&#x2F;自定义结构）——静态只读字段（常量只能是基本数据类型）</p>
<h2 id="值类型和值参数的区别"><a href="#值类型和值参数的区别" class="headerlink" title="值类型和值参数的区别"></a>值类型和值参数的区别</h2><p>值参数是一个变量，他有值类型和引用类型两种。</p>
<p>值类型在作为参数传递进方法的时候是复制传入</p>
<h2 id="判断两个对象是否是同一个"><a href="#判断两个对象是否是同一个" class="headerlink" title="判断两个对象是否是同一个"></a>判断两个对象是否是同一个</h2><p>因为在c#中，所有的类都继承于Object，而object具有一个方法，就是GetHashCode。</p>
<p>GetHashCode获取到的值类似于对象的指纹，每一个对象都具有不同的hash</p>
<p>GetHashCode获取到的值是一个32位有符号整型。（有疑问，为什么是32位？是因为编译出来的是32位的应用吗）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hurr&quot;</span>;</span><br><span class="line">Console.WriteLine(s.GetHashCode());<span class="comment">//获取并输出s字符串的hash</span></span><br></pre></td></tr></table></figure>





<h2 id="TryParse类型转换"><a href="#TryParse类型转换" class="headerlink" title="TryParse类型转换"></a>TryParse类型转换</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            s = <span class="string">&quot;123.45.6&quot;</span>;</span><br><span class="line">            <span class="built_in">double</span> d = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">double</span>.TryParse(s, <span class="keyword">out</span> d))<span class="comment">//尝试的转换，如果转换成功，则返回true，否则为false。同时转换完成的值以输出参数的形式带出</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;转换成功&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;转换失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;转换完成的值是：&#123;0&#125;&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="使用Split方法使得string字符串进行按指定符号分割。"><a href="#使用Split方法使得string字符串进行按指定符号分割。" class="headerlink" title="使用Split方法使得string字符串进行按指定符号分割。"></a>使用Split方法使得string字符串进行按指定符号分割。</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Policy;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> ShowInfos;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> str = <span class="string">&quot;tim,hurrr;amy.Lisa&quot;</span>;<span class="comment">//一个字符串，里面存在多个符号</span></span><br><span class="line">            <span class="built_in">string</span>[] res = str.Split(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);<span class="comment">//用string类自带的Split方法，指出其中的符号，并存到一个string数组中返回</span></span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> res)<span class="comment">//遍历分割完的字符串</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(item);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="string的花样玩法：深入理解C-中-“-”-符号的作用以及用法"><a href="#string的花样玩法：深入理解C-中-“-”-符号的作用以及用法" class="headerlink" title="string的花样玩法：深入理解C# 中 “$” 符号的作用以及用法"></a>string的花样玩法：深入理解C# 中 “$” 符号的作用以及用法</h2><p>前言：<code>$</code>是c# 6.0 的语言特性，功能类似<code>string.format()</code>，更方便的地方在于不要像<code>format</code>一样使用索引，可以直接使用变量、表达式或者方法的执行。</p>
<h3 id="C-中-的作用"><a href="#C-中-的作用" class="headerlink" title="C#中$的作用"></a>C#中<code>$</code>的作用</h3><p>谈及这个<code>$</code>，其实它是C#6.0语法中模板字符串的一种写法，什么是模版字符串？还记得你们用过的格式化字符串吗？<code>string.Format()</code> 这个方法，是最常用的方法之一。</p>
<p>那<code>$</code>又是什么呢？它是为了替代<code>string.format()</code>的，原先赋值需要占位符和变量，当需要拼接多个变量会造成语句过长等不易理解问题。</p>
<p><code>$</code>是为了替代<code>string.format()</code>，可以把字符串中的C#变量<code>{}</code>包含起来达到识别C#变量的目的<code>$&quot;{id}&quot;</code>；也支持表达式，使用<code>$&quot;{(你的表达式)}&quot;</code>；或者方法的执行，使用<code>$&quot;{(方法)}&quot;</code>。</p>
<h3 id="C-中-的用法"><a href="#C-中-的用法" class="headerlink" title="C#中$的用法"></a>C#中<code>$</code>的用法</h3><p>C# 中<code>$</code>符号的作用是C#6.0中新出现的一个特性，也即是字符串的拼接优化。</p>
<h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="string">$&quot;string <span class="subst">&#123;参数&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>解释：以<code>$</code>符号开头开始字符串，其中以<code>{}</code>来进行传参，可以多个参数累加。</p>
<p>例如:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> results = <span class="string">$&quot;Hello <span class="subst">&#123;Name&#125;</span>&quot;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="的示例"><a href="#的示例" class="headerlink" title="$的示例"></a><code>$</code>的示例</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="built_in">string</span>.Format(<span class="string">&quot;我的名字叫&#123;1&#125;，我今年&#123;1&#125;岁。&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">23</span>);</span><br><span class="line">Console.WriteLine(str);</span><br></pre></td></tr></table></figure>

<p>这是我们使用<code>string.format()</code>的写法，下来我们使用<code>$</code>改写一下。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">$&quot;我的名字叫<span class="subst">&#123;<span class="string">&quot;张三&quot;</span>&#125;</span>，我今年<span class="subst">&#123;<span class="number">23</span>&#125;</span>岁。&quot;</span>;</span><br><span class="line">Console.WriteLine(str);</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>通过上面这个案例，我们发现，现在使用<code>$</code>代码简洁，可读性强。</p>
<p>可能有些朋友觉得效果不太明显，那么请看下面这个案例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">23</span>;</span><br><span class="line"><span class="keyword">var</span> sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="built_in">string</span>.Format(<span class="string">&quot;我叫&#123;0&#125;,我的年龄为&#123;1&#125;,我的性别是&#123;2&#125;&quot;</span>, name, age, sex);</span><br><span class="line"><span class="keyword">var</span> show = <span class="string">$&quot;我叫<span class="subst">&#123;name&#125;</span>,我的年龄为<span class="subst">&#123;age&#125;</span>,我的性别是<span class="subst">&#123;sex&#125;</span>&quot;</span>;</span><br><span class="line">Console.WriteLine(message);</span><br><span class="line">Console.WriteLine(show);</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200610092838146.png" alt="在这里插入图片描述"><br>如果还感受不到，那么请你试想一下：如果我们要操作的数据很多，假设它是一个多条的SQL语句，那么在长篇字符串中定位索引，那是不是很累啊！纵使你写对了索引（没写对还得一个个检查、修改），好不容易完工了。但下一个需求让你加两个参数，你的索引位置又得变，还得在万码丛中查找你原来索引在哪里的，是不是很恶心？</p>
<p>哈哈，不用沮丧，此时C#6.0模版字符串就可以闪亮登场啦！</p>
<p>怎么用？总结一下，就是在字符串的双引号前面加一个 $ 符号，在需要使用变量的地方用{变量}就可以了。这个在我们上面的案例中，也有体现。</p>
<h3 id="关于-的补充知识"><a href="#关于-的补充知识" class="headerlink" title="关于$的补充知识"></a>关于<code>$</code>的补充知识</h3><p>正如我们上面所说，<code>{变量}</code>表示在字符串中输出变量的值，当然<code>{}</code>中间也可以是一个表达式或者方法的执行。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="string">$&quot;我的姓名是<span class="subst">&#123;GetName()&#125;</span>&quot;</span>;</span><br><span class="line"><span class="string">$&quot;name的类型是<span class="subst">&#123;name.GetType()&#125;</span>&quot;</span>;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>如上，这样就很方便，帅气了！那么变量和索引可以混用吗？当然也是可以的，如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">23</span>;</span><br><span class="line"><span class="keyword">var</span> sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> show = <span class="built_in">string</span>.Format(<span class="string">$&quot;我是<span class="subst">&#123;name&#125;</span>，今年<span class="subst">&#123;age&#125;</span>，家住在&#123;&#123;0&#125;&#125;&quot;</span>, sex); </span><br><span class="line">Console.WriteLine(show);</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200610094030175.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>要注意的是需要用两次大括号 <code>{{}}</code> 将索引包含起来，也就是这样的形式，<code>&quot;({*2)索引(}*2)&quot;</code>。因为一次是输出表达式，两次就转义成普通的占位符了，这点一定要注意！</p>
</blockquote>
<h2 id="查询枚举类型是否包含具有特定关联值的枚举成员"><a href="#查询枚举类型是否包含具有特定关联值的枚举成员" class="headerlink" title="查询枚举类型是否包含具有特定关联值的枚举成员"></a>查询枚举类型是否包含具有特定关联值的枚举成员</h2><p>使用Enum.IsDefined 方法</p>
<p>如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">enum</span> Season</span><br><span class="line">    &#123;</span><br><span class="line">        Spring,</span><br><span class="line">        Summer,</span><br><span class="line">        Autumn,</span><br><span class="line">        Winter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> c = (Season)<span class="number">4</span>;</span><br><span class="line">            Console.WriteLine(c);  <span class="comment">// output: 4</span></span><br><span class="line">            Console.WriteLine(c.GetType());<span class="comment">//output：ConsoleApp.Season</span></span><br><span class="line">            Console.WriteLine(Enum.IsDefined(<span class="keyword">typeof</span>(Season),<span class="number">4</span>));<span class="comment">//false</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="添加引用依赖：类库"><a href="#添加引用依赖：类库" class="headerlink" title="添加引用依赖：类库"></a>添加引用依赖：类库</h2><p><img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/image-20230306082409521.png" alt="image-20230306082409521"></p>
<p>纠错：</p>
<p>​	如果是别人编写的dll，不是微软自带的，需要在最下方的浏览中添加进来。而不是在程序集中添加。</p>
<h2 id="MD5转换"><a href="#MD5转换" class="headerlink" title="MD5转换"></a>MD5转换</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Security.Cryptography;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(GetMD5(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetMD5</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将目标字符串转换成字节</span></span><br><span class="line">            <span class="built_in">byte</span>[] buffer = Encoding.UTF8.GetBytes(str);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建MD5对象</span></span><br><span class="line">            MD5 md5 = MD5.Create();</span><br><span class="line">            <span class="built_in">byte</span>[] MD5Buffer =  md5.ComputeHash(buffer);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> strmd5 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="comment">//将加密完成的字节数组转换成字符串</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; MD5Buffer.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                strmd5 += MD5Buffer[i].ToString(<span class="string">&quot;x&quot;</span>);<span class="comment">//注意需要转换成16进制。默认是10进制</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> strmd5;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="对于使用-Net-FrameWork的控制台应用程序，调用From窗体。"><a href="#对于使用-Net-FrameWork的控制台应用程序，调用From窗体。" class="headerlink" title="对于使用.Net FrameWork的控制台应用程序，调用From窗体。"></a>对于使用.Net FrameWork的控制台应用程序，调用From窗体。</h1><ol>
<li>引入依赖<ol>
<li>右击引用，选择添加引用<img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/image-20230517150043313.png" alt="image-20230517150043313"></li>
<li>找到System.Windwos.Forms，选择确认加入引用<img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/image-20230517150238641.png" alt="image-20230517150238641"></li>
<li>使用using语句引用导入的forms。如果这一步报错，则表示上一步的引入没引成功。<img src="/./Image/C#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.assets/image-20230517150336335.png" alt="image-20230517150336335"></li>
</ol>
</li>
<li>实例化Form对象，然后ShowDialog显示出来。</li>
</ol>
<h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><p>string的比较，能否直接用<code>==</code>。</p>
<p>输入一个string的字符串，假设输入的值与待比较的值相等，<code>==</code>是否可以进行比较。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">str = Console.ReadLine();<span class="comment">//假设输入hurr</span></span><br><span class="line"><span class="keyword">if</span>(str.ToLower() == <span class="string">&quot;hurr&quot;</span>)<span class="comment">//true or false？</span></span><br></pre></td></tr></table></figure>

<p>在c#中string也是引用类型，因此str是一个4字节的变量，而输入的文本存储在堆中，<code>==</code>运算符是否可以比较存储的值而不是变量的值。</p>
<p>属性与类的关系</p>
<p>完整声明中的private部分，是否可以是为一个动态计算值的属性？</p>
<p>c#索引器</p>
<p>一个类只能有一个list？</p>
<p>是否需要单独拎出一个类作为属性类来实现？是否增加了耦合？就像在当前类中new另外一个类</p>
<p>委托中组合委托（组播）的用途？引用场景？</p>
<p>委托的用途：常见的使用场景？</p>
<p>自定义委托相比Action或Func有什么特点？或者是有什么不可替代性？</p>
<p>枚举中：作为位标志的枚举类型的部分</p>
<p>c#的锯齿数组与c++中的数组指针的区别</p>
<p>c#中是否存在着：不使用Main方法作为入口点。如像在c++中的 <code>static int s = execute();</code>这样的语句，在main前面，初始化静态变量的时候调用第三方函数，使得第三方函数的运行在main前。</p>
<p>方法参数中的引用参数，ref修饰符在public的位置时，表示的是什么意思？（p86）</p>
<p>ref在参数前面，表示的是指定的参数是引用参数，在声明和调用的时候要在参数前面加上ref修饰符；</p>
<p>如果这样，ref此时表示什么意思？</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ref</span> <span class="built_in">int</span> <span class="title">ReturnByRef</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] arr = &#123; <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">ref</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p>接口</p>
<p>当一个类实现了多个接口的时候，是不是必须显式实现接口？</p>
<p>c#中的GetHashCode</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=net-8.0">在C#中，GetHashCode()方法是用来返回一个对象的哈希码，也就是一个整数值，用于表示对象的内容或状态</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=net-8.0">1</a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9084735/will-string-gethashcode-return-negative-value">。GetHashCode()方法可以返回负值，因为它没有限制哈希码的范围</a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9084735/will-string-gethashcode-return-negative-value">2</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=net-8.0">。GetHashCode()方法只要求相等的对象返回相同的哈希码，但不要求不相等的对象返回不同的哈希码</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=net-8.0">1</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.string.gethashcode?view=net-8.0">3</a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9084735/will-string-gethashcode-return-negative-value">。因此，GetHashCode()方法返回的值不能用来判断对象是否相等，也不能用来存储或比较数据</a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9084735/will-string-gethashcode-return-negative-value">2</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.string.gethashcode?view=net-8.0">3</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=net-8.0">。GetHashCode()方法只能用来优化一些数据结构或算法，例如哈希表或字典</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=net-8.0">1</a>。</p>
<p>gethashcode是否能可靠的判断两个对象是否相等？</p>
<p>如何判断两个对象是否相等。</p>
<p><a target="_blank" rel="noopener" href="https://www.educba.com/c-sharp-object-compare/">在C#中，判断两个对象是否相等有多种方法，取决于你想要比较的是对象的引用还是值。</a><a target="_blank" rel="noopener" href="https://www.educba.com/c-sharp-object-compare/">1</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/equality-operators">如果你想要比较两个对象的引用，也就是说，它们是否指向同一个内存地址，你可以使用<code>Object.ReferenceEquals</code>方法或者<code>==</code>运算符（如果该类型重载了该运算符）。</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/equality-operators">2</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/equality-operators">如果你想要比较两个对象的值，也就是说，它们是否具有相同的属性和字段，你可以使用<code>Object.Equals</code>方法或者<code>IEquatable</code>接口（如果该类型实现了该接口）。</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/equality-operators">2</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4951233/compare-two-objects-and-find-the-differences">另外，你也可以使用反射来遍历两个对象的所有属性，并返回它们之间的差异。</a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4951233/compare-two-objects-and-find-the-differences">3</a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/2920399/c-sharp-how-to-find-if-two-objects-are-equal">4</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://chaoqijiang.github.io">棨</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://chaoqijiang.github.io/2023/01/25/CSharp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">https://chaoqijiang.github.io/2023/01/25/CSharp学习笔记_基础教程/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://chaoqijiang.github.io" target="_blank">柊</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/protected/">protected</a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">基础教程</a><a class="post-meta__tags" href="/tags/CSharp/">CSharp</a></div><div class="post-share"><div class="social-share" data-image="/Image/avatar.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2022/09/08/%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%B1%BB_%E6%80%9D%E6%83%B3_%E6%95%88%E7%8E%87/" title="排序的总类 思想 效率"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">排序的总类 思想 效率</div></div><div class="info-2"><div class="info-item-1">各类排序算法的介绍，包括思想、效率等。</div></div></div></a><a class="pagination-related" href="/2023/02/28/Openwrt%E8%8E%B7%E5%8F%96%E5%88%B0%E4%BA%86ipv6%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%BD%86%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8/" title="Openwrt获取到了ipv6地址，但无法使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Openwrt获取到了ipv6地址，但无法使用</div></div><div class="info-2"><div class="info-item-1">Openwrt下属设备获取到了ipv6地址，但无法使用。获取到了ipv6地址，但经测试无法使用ipv6的地址，而且ping具有v4/v6双栈响应的网站，显示的目标ip是ipv4。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/12/01/Docker%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" title="Docker基础教程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-01</div><div class="info-item-2">Docker基础教程</div></div><div class="info-2"><div class="info-item-1">Docker基础教程</div></div></div></a><a class="pagination-related" href="/2024/02/29/Java%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" title="Java基础教程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-29</div><div class="info-item-2">Java基础教程</div></div><div class="info-2"><div class="info-item-1">Java基础教程，包括Java概述、Java技术体系平台、Java重要特点以及Java的运行机制及运行过程。</div></div></div></a><a class="pagination-related" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%9F%E6%88%90/" title="AI提示词_学习笔记生成"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-08</div><div class="info-item-2">AI提示词_学习笔记生成</div></div><div class="info-2"><div class="info-item-1">AI提示词，用于引导AI生成学习笔记，根据提示的设定，对没有基础背景背景的小白生成学习笔记。</div></div></div></a><a class="pagination-related" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E8%AF%95%E9%A2%98%E7%94%9F%E6%88%90/" title="AI提示词_试题生成"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-08</div><div class="info-item-2">AI提示词_试题生成</div></div><div class="info-2"><div class="info-item-1">AI提示词，用于根据提示信息生成对应的试题，帮助学习者检验理解深度。</div></div></div></a><a class="pagination-related" href="/2023/06/07/ESP8266%E5%BC%95%E8%84%9A%E8%AF%B4%E6%98%8E/" title="ESP8266引脚说明"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-07</div><div class="info-item-2">ESP8266引脚说明</div></div><div class="info-2"><div class="info-item-1">ESP8266引脚说明</div></div></div></a><a class="pagination-related" href="/2023/06/07/ESP8266%E7%9B%B8%E5%85%B3%E6%A1%88%E4%BE%8B%E7%AC%94%E8%AE%B0/" title="ESP8266相关案例笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-07</div><div class="info-item-2">ESP8266相关案例笔记</div></div><div class="info-2"><div class="info-item-1">ESP8266相关案例笔记</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/Image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">棨</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">40</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:chaoqijiang@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">C#简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CIL%E5%92%8CJIT"><span class="toc-number">1.1.</span> <span class="toc-text">CIL和JIT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">垃圾回收机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4"><span class="toc-number">2.</span> <span class="toc-text">类和名称空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%BA%93%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">类库的引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dll%E5%BC%95%E7%94%A8%EF%BC%88%E9%BB%91%E7%9B%92%E5%BC%95%E7%94%A8%EF%BC%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">dll引用（黑盒引用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%BC%95%E7%94%A8%EF%BC%88%E7%99%BD%E7%9B%92%E5%BC%95%E7%94%A8%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">项目引用（白盒引用）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.1.</span> <span class="toc-text">类与对象的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%B8%89%E5%A4%A7%E6%88%90%E5%91%98"><span class="toc-number">2.2.2.</span> <span class="toc-text">类的三大成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%EF%BC%88Property%EF%BC%89"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">属性（Property）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%88Method%EF%BC%89"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">方法（Method）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%EF%BC%88Event%EF%BC%89"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">事件（Event）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%8E%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98"><span class="toc-number">2.2.3.</span> <span class="toc-text">静态成员与实例成员</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0"><span class="toc-number">3.</span> <span class="toc-text">C#的基本元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E6%96%B9%E6%B3%95%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">类型、变量与方法的概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">c#中的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">3.2.1.</span> <span class="toc-text">数据类型的概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%EF%BC%88Type%EF%BC%89"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">什么是类型（Type）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%9C%A8C-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">类型在C#中的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">C#语言的类型系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#c-%E7%9A%84%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.1.3.1.</span> <span class="toc-text">c#的五大数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-%E7%9A%84%E6%B4%BE%E7%94%9F%E8%B0%B1%E7%B3%BB"><span class="toc-number">3.2.1.3.2.</span> <span class="toc-text">c#的派生谱系</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E3%80%81%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%86%85%E5%AD%98"><span class="toc-number">3.3.</span> <span class="toc-text">变量、对象与内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%A6%82%E8%BF%B0"><span class="toc-number">3.3.1.</span> <span class="toc-text">变量概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%88%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">3.3.2.</span> <span class="toc-text">值类型的变量（简单数据类型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88Reference-types%EF%BC%89%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.3.3.</span> <span class="toc-text">引用类型（Reference types）的变量与实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.3.4.</span> <span class="toc-text">变量的作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="toc-number">3.3.5.</span> <span class="toc-text">装箱和拆箱</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">3.3.5.1.</span> <span class="toc-text">扩展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">复杂数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%EF%BC%88Enum%EF%BC%89"><span class="toc-number">3.4.1.</span> <span class="toc-text">枚举（Enum）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E-enum-%E5%8F%98%E9%87%8F"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">声明 enum 变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">样例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E4%BD%8D%E6%A0%87%E5%BF%97%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.1.4.</span> <span class="toc-text">作为位标志的枚举类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#System-Enum-%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%9E%9A%E4%B8%BE%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.4.1.5.</span> <span class="toc-text">System.Enum 类型和枚举约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.1.6.</span> <span class="toc-text">转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#string%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9E%9A%E4%B8%BE%E5%80%BC"><span class="toc-number">3.4.1.6.1.</span> <span class="toc-text">string类型转换为枚举值</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-1"><span class="toc-number">3.4.1.6.1.1.</span> <span class="toc-text">样例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88Struct%EF%BC%89"><span class="toc-number">3.4.2.</span> <span class="toc-text">结构体（Struct）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">定义结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%BB%93%E6%9E%84%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">C# 结构的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E7%BB%93%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">类与结构的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-2"><span class="toc-number">3.4.2.4.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%95%B0%E7%BB%84%EF%BC%88Array%EF%BC%89"><span class="toc-number">3.4.3.</span> <span class="toc-text">C# 数组（Array）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">声明数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">3.4.3.1.1.</span> <span class="toc-text">声明多维数组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">初始化数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E7%BB%99%E6%95%B0%E7%BB%84"><span class="toc-number">3.4.3.3.</span> <span class="toc-text">赋值给数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">3.4.3.4.</span> <span class="toc-text">访问数组元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.4.3.4.1.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2"><span class="toc-number">3.4.3.4.2.</span> <span class="toc-text">实例2</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-foreach-%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.4.3.5.</span> <span class="toc-text">使用 foreach 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.4.3.5.1.</span> <span class="toc-text">实例1 一维数组的使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%88%E9%94%AF%E9%BD%BF%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-number">3.4.3.6.</span> <span class="toc-text">数组的数组（锯齿数组）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%AF%E9%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.4.3.7.</span> <span class="toc-text">锯齿数组的注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%95%B0%E7%BB%84%E7%BB%86%E8%8A%82"><span class="toc-number">3.4.3.8.</span> <span class="toc-text">C#	 数组细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">3.5.</span> <span class="toc-text">常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F"><span class="toc-number">3.5.1.</span> <span class="toc-text">整数常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%B8%B8%E9%87%8F"><span class="toc-number">3.5.2.</span> <span class="toc-text">浮点常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F%E5%92%8C%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">3.5.3.</span> <span class="toc-text">字符常量和转义字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="toc-number">3.5.4.</span> <span class="toc-text">字符串常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F"><span class="toc-number">3.5.5.</span> <span class="toc-text">定义常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">3.5.6.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A4%84%E7%90%86"><span class="toc-number">3.6.</span> <span class="toc-text">字符串（String）类型与处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.6.1.</span> <span class="toc-text">字符串的处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%8F%98%E9%87%8F"><span class="toc-number">3.7.</span> <span class="toc-text">隐式变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#var-%E5%92%8C%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.7.1.</span> <span class="toc-text">var 和匿名类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8"><span class="toc-number">3.7.2.</span> <span class="toc-text">备注</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.8.</span> <span class="toc-text">C# 类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.8.1.</span> <span class="toc-text">隐式转换和显示转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">3.8.1.1.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Convert%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.8.2.</span> <span class="toc-text">Convert转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-number">3.8.2.1.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parse%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.8.3.</span> <span class="toc-text">Parse转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%87%E7%BA%A7%E7%89%88%E7%9A%84TryParse"><span class="toc-number">3.8.3.1.</span> <span class="toc-text">升级版的TryParse</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.8.3.2.</span> <span class="toc-text">自定义类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">3.8.3.2.1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B1"><span class="toc-number">3.8.3.2.2.</span> <span class="toc-text">样例1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B2"><span class="toc-number">3.8.3.2.3.</span> <span class="toc-text">样例2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-number">3.8.3.2.4.</span> <span class="toc-text">实际应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84-Lvalues-%E5%92%8C-Rvalues"><span class="toc-number">3.8.4.</span> <span class="toc-text">C# 中的 Lvalues 和 Rvalues</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.</span> <span class="toc-text">C# 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.1.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.2.</span> <span class="toc-text">乘法运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.3.</span> <span class="toc-text">除法运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%99%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.4.</span> <span class="toc-text">余数运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.5.</span> <span class="toc-text">加法运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.6.</span> <span class="toc-text">减法运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%B5%8B%E8%AF%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.7.</span> <span class="toc-text">关系和类型测试运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.8.</span> <span class="toc-text">比较运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.8.1.</span> <span class="toc-text">整数比较运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.8.2.</span> <span class="toc-text">浮点比较运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%95%B0%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.8.3.</span> <span class="toc-text">小数比较运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.8.4.</span> <span class="toc-text">布尔相等运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.8.5.</span> <span class="toc-text">枚举比较运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.8.6.</span> <span class="toc-text">引用类型相等运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.8.7.</span> <span class="toc-text">字符串相等运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.8.8.</span> <span class="toc-text">委托相等运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C-null"><span class="toc-number">3.9.8.9.</span> <span class="toc-text">相等运算符和 null</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#is-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.8.10.</span> <span class="toc-text">is 运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#as-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.9.</span> <span class="toc-text">as 运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.10.</span> <span class="toc-text">逻辑运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%9D%A1%E4%BB%B6%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.10.</span> <span class="toc-text">1.1 条件逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E5%B8%83%E5%B0%94%E6%9D%A1%E4%BB%B6%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.10.1.</span> <span class="toc-text">1.1.1 布尔条件逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E6%9D%A1%E4%BB%B6%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.10.2.</span> <span class="toc-text">1.1.2 用户定义的条件逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.10.3.</span> <span class="toc-text">位运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.11.</span> <span class="toc-text">1.1 逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E6%95%B4%E6%95%B0%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.11.1.</span> <span class="toc-text">1.1.1 整数逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E6%9E%9A%E4%B8%BE%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.11.2.</span> <span class="toc-text">1.1.2 枚举逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.11.3.</span> <span class="toc-text">1.1.3 布尔逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-4-%E5%8F%AF%E4%BB%A5%E4%B8%BA-null-%E7%9A%84%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.11.4.</span> <span class="toc-text">1.1.4 可以为 null 的布尔逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.11.5.</span> <span class="toc-text">1.2 移位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.11.6.</span> <span class="toc-text">赋值运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.12.</span> <span class="toc-text">1.1 赋值运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#assignment-operator"><span class="toc-number">4.</span> <span class="toc-text">assignment-operator:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E7%AE%80%E5%8D%95%E8%B5%8B%E5%80%BC"><span class="toc-number">4.0.1.</span> <span class="toc-text">1.1.1 简单赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC"><span class="toc-number">4.0.2.</span> <span class="toc-text">1.1.2 复合赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-%E4%BA%8B%E4%BB%B6%E8%B5%8B%E5%80%BC"><span class="toc-number">4.0.3.</span> <span class="toc-text">1.1.3 事件赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.0.4.</span> <span class="toc-text">其他运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.0.5.</span> <span class="toc-text">空合并运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.0.6.</span> <span class="toc-text">?. 空条件运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E9%80%94"><span class="toc-number">4.0.6.1.</span> <span class="toc-text">用途</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E5%8A%A9%E4%BA%8E%E9%81%BF%E5%85%8D%E7%B9%81%E6%9D%82%E7%9A%84%E7%A9%BA%E5%80%BC%E6%A3%80%E6%9F%A5%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%BB%A3%E7%A0%81%E6%AD%A7%E4%B9%89%E3%80%82"><span class="toc-number">4.0.6.1.1.</span> <span class="toc-text">有助于避免繁杂的空值检查带来的代码歧义。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.0.6.1.2.</span> <span class="toc-text">触发事件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">4.0.6.2.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.0.7.</span> <span class="toc-text">C# 中的运算符优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">c#表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-%E5%85%83%E7%BB%84%EF%BC%88Tuple%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">c#元组（Tuple）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%83%E7%BB%84%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">5.1.</span> <span class="toc-text">使用元组的场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BB%84%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">5.2.</span> <span class="toc-text">元组的缺陷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B"><span class="toc-number">5.3.</span> <span class="toc-text">声明和使用样例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%83%E7%BB%84%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.4.</span> <span class="toc-text">使用元组时的注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.</span> <span class="toc-text">C#的基本语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E7%9A%84%E8%AF%AD%E5%8F%A5%E7%A7%8D%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">c#的语句种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.2.</span> <span class="toc-text">声明语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%82"><span class="toc-number">6.2.1.</span> <span class="toc-text">声明一个或多个局部变量。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-3"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%B1%80%E9%83%A8%E5%B8%B8%E9%87%8F"><span class="toc-number">6.2.2.</span> <span class="toc-text">声明局部常量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-4"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">样例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.3.</span> <span class="toc-text">表达式语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-5"><span class="toc-number">6.3.0.1.</span> <span class="toc-text">样例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%97"><span class="toc-number">6.4.</span> <span class="toc-text">块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.5.</span> <span class="toc-text">选择语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.5.1.</span> <span class="toc-text">Switch语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.5.2.</span> <span class="toc-text">? : 运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.6.</span> <span class="toc-text">循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.6.1.</span> <span class="toc-text">基础循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#foreach%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.6.2.</span> <span class="toc-text">foreach循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">6.6.2.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-2"><span class="toc-number">6.6.2.2.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2-1"><span class="toc-number">6.6.2.3.</span> <span class="toc-text">实例2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-3"><span class="toc-number">6.6.2.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.6.3.</span> <span class="toc-text">循环控制语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try%E8%AF%AD%E5%8F%A5-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">6.7.</span> <span class="toc-text">try语句(异常处理)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-number">6.7.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-6"><span class="toc-number">6.7.2.</span> <span class="toc-text">样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B2-1"><span class="toc-number">6.7.3.</span> <span class="toc-text">样例2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.8.</span> <span class="toc-text">标签语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#checked-unchecked%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.9.</span> <span class="toc-text">checked&#x2F;unchecked语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98"><span class="toc-number">7.</span> <span class="toc-text">C#的类和成员</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB-1"><span class="toc-number">7.1.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">7.1.1.</span> <span class="toc-text">类的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-4"><span class="toc-number">7.1.2.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System-Object"><span class="toc-number">7.1.3.</span> <span class="toc-text">System.Object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98"><span class="toc-number">7.1.4.</span> <span class="toc-text">成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98"><span class="toc-number">7.1.5.</span> <span class="toc-text">静态成员和实例成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB"><span class="toc-number">7.2.</span> <span class="toc-text">静态类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.3.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F"><span class="toc-number">7.3.1.</span> <span class="toc-text">对象的生存周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.1.2.</span> <span class="toc-text">析构函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5"><span class="toc-number">7.4.</span> <span class="toc-text">字段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E6%AE%B5"><span class="toc-number">7.4.1.</span> <span class="toc-text">什么是字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">7.4.2.</span> <span class="toc-text">字段的声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2"><span class="toc-number">7.4.2.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-7"><span class="toc-number">7.4.2.2.</span> <span class="toc-text">样例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.4.2.3.</span> <span class="toc-text">访问修饰符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%AD%97%E6%AE%B5"><span class="toc-number">7.4.3.</span> <span class="toc-text">只读字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">7.5.</span> <span class="toc-text">属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B1%9E%E6%80%A7"><span class="toc-number">7.5.1.</span> <span class="toc-text">什么是属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%99%A8%EF%BC%88Accessors%EF%BC%89"><span class="toc-number">7.5.2.</span> <span class="toc-text">访问器（Accessors）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">7.5.3.</span> <span class="toc-text">属性的声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E5%A3%B0%E6%98%8E"><span class="toc-number">7.5.3.1.</span> <span class="toc-text">完整声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E7%95%A5%E5%A3%B0%E6%98%8E-%EF%BC%88%E8%87%AA%E5%8A%A8%E5%B1%9E%E6%80%A7%EF%BC%89"><span class="toc-number">7.5.3.2.</span> <span class="toc-text">简略声明 （自动属性）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-8"><span class="toc-number">7.5.3.3.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E5%B0%81%E8%A3%85%E6%88%90%E5%B1%9E%E6%80%A7"><span class="toc-number">7.5.4.</span> <span class="toc-text">字段封装成属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">7.5.5.</span> <span class="toc-text">限制属性的读写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">7.5.5.1.</span> <span class="toc-text">只读属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-9"><span class="toc-number">7.5.5.1.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%A4%96%E5%8F%AA%E8%AF%BB%E7%B1%BB%E5%86%85%E8%AF%BB%E5%86%99"><span class="toc-number">7.5.5.2.</span> <span class="toc-text">类外只读类内读写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-10"><span class="toc-number">7.5.5.2.1.</span> <span class="toc-text">样例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%AE%A1%E7%AE%97%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">7.5.6.</span> <span class="toc-text">动态计算值的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A2%AB%E5%8A%A8%E8%AE%A1%E7%AE%97"><span class="toc-number">7.5.6.1.</span> <span class="toc-text">被动计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E8%AE%A1%E7%AE%97"><span class="toc-number">7.5.6.2.</span> <span class="toc-text">主动计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E4%B8%8E%E5%AD%97%E6%AE%B5%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.5.7.</span> <span class="toc-text">属性与字段的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">7.6.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E7%94%B1%E6%9D%A5"><span class="toc-number">7.6.1.</span> <span class="toc-text">方法的由来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%B0%83%E7%94%A8"><span class="toc-number">7.6.2.</span> <span class="toc-text">方法的定义与调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E%E8%AF%A6%E7%BB%86%E8%AF%AD%E6%B3%95"><span class="toc-number">7.6.2.1.</span> <span class="toc-text">方法声明详细语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">7.6.2.2.</span> <span class="toc-text">方法的调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">7.6.3.</span> <span class="toc-text">方法的返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">7.6.4.</span> <span class="toc-text">方法的参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E5%80%BC%E5%8F%82%E6%95%B0%EF%BC%88%E5%80%BC%E5%8F%82%E6%95%B0%EF%BC%89"><span class="toc-number">7.6.4.1.</span> <span class="toc-text">传值参数（值参数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0"><span class="toc-number">7.6.4.2.</span> <span class="toc-text">输出参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B1-1"><span class="toc-number">7.6.4.2.1.</span> <span class="toc-text">样例1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B2-TryParse%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.6.4.2.2.</span> <span class="toc-text">样例2 TryParse转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8F%82%E6%95%B0-%E5%BD%A2%E5%8F%82%E6%95%B0%E7%BB%84-params"><span class="toc-number">7.6.4.3.</span> <span class="toc-text">数组参数(形参数组,params)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-11"><span class="toc-number">7.6.4.3.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E5%8F%82%E6%95%B0%EF%BC%9A%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%86%8D%E5%8F%97%E7%BA%A6%E6%9D%9F"><span class="toc-number">7.6.4.4.</span> <span class="toc-text">具名参数：参数的位置不再受约束</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">7.6.4.4.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">7.6.4.5.</span> <span class="toc-text">可选参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%BB%84%E5%8F%82%E6%95%B0"><span class="toc-number">7.6.4.6.</span> <span class="toc-text">元组参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B"><span class="toc-number">7.6.4.6.1.</span> <span class="toc-text">使用样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95%EF%BC%88this%E5%8F%82%E6%95%B0%EF%BC%89"><span class="toc-number">7.6.4.7.</span> <span class="toc-text">扩展方法（this参数）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="toc-number">7.6.4.7.1.</span> <span class="toc-text">具体步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-12"><span class="toc-number">7.6.4.7.2.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.6.4.8.</span> <span class="toc-text">各种参数的使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89"><span class="toc-number">7.6.5.</span> <span class="toc-text">方法的重载（Overload）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">7.6.5.1.</span> <span class="toc-text">定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E4%B8%8E%E6%A0%88%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.6.6.</span> <span class="toc-text">方法的调用与栈的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%97%B6%E6%A0%88%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">7.6.6.1.</span> <span class="toc-text">方法调用时栈内存的分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%99%A8%EF%BC%88Indexer%EF%BC%89%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">7.6.7.</span> <span class="toc-text">索引器（Indexer）的用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-13"><span class="toc-number">7.6.8.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">7.7.</span> <span class="toc-text">构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%88%E7%89%B9%E6%AE%8A%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">7.7.1.</span> <span class="toc-text">构造器（特殊的方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">7.7.1.1.</span> <span class="toc-text">构造器的声明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-14"><span class="toc-number">7.7.1.1.1.</span> <span class="toc-text">样例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">7.7.2.</span> <span class="toc-text">静态构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-15"><span class="toc-number">7.7.2.1.</span> <span class="toc-text">样例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%99%A8"><span class="toc-number">7.8.</span> <span class="toc-text">析构器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-3"><span class="toc-number">7.8.1.</span> <span class="toc-text">基本语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.9.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3-MyInterface-cs"><span class="toc-number">7.9.1.</span> <span class="toc-text">定义接口: MyInterface.cs</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-16"><span class="toc-number">7.9.1.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF-InterfaceInheritance-cs"><span class="toc-number">7.9.2.</span> <span class="toc-text">接口继承: InterfaceInheritance.cs</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-17"><span class="toc-number">7.9.2.1.</span> <span class="toc-text">样例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-number">7.10.</span> <span class="toc-text">嵌套类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E8%AE%BF%E9%97%AE%E7%BA%A7%E5%88%AB"><span class="toc-number">7.11.</span> <span class="toc-text">C# 访问级别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Public-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.11.1.</span> <span class="toc-text">Public 访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Private-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.11.2.</span> <span class="toc-text">Private 访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Protected-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.11.3.</span> <span class="toc-text">Protected 访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Internal-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.11.4.</span> <span class="toc-text">Internal 访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%EF%BC%9A"><span class="toc-number">7.11.4.1.</span> <span class="toc-text">样例：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Program%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="toc-number">7.11.4.1.1.</span> <span class="toc-text">Program文件：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Calculator%E6%96%87%E4%BB%B6"><span class="toc-number">7.11.4.1.2.</span> <span class="toc-text">Calculator文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#test%E6%96%87%E4%BB%B6"><span class="toc-number">7.11.4.1.3.</span> <span class="toc-text">test文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Protected-Internal-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.11.5.</span> <span class="toc-text">Protected Internal 访问修饰符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88OOP%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">面向对象编程（OOP）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">8.1.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">8.1.1.</span> <span class="toc-text">继承的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%98%BE%E7%A4%BA%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.1.1.0.0.1.</span> <span class="toc-text">自定义显示类型转换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.1.1.0.0.2.</span> <span class="toc-text">反向隐式类型转换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.1.1.0.0.3.</span> <span class="toc-text">反向显式类型转换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.1.1.0.0.4.</span> <span class="toc-text">自定义类型转换的注意事项</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">8.1.1.0.1.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-18"><span class="toc-number">8.1.1.0.2.</span> <span class="toc-text">样例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">8.1.2.</span> <span class="toc-text">动态多态性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">8.1.2.1.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-19"><span class="toc-number">8.1.2.1.1.</span> <span class="toc-text">样例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-1"><span class="toc-number">8.1.3.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%EF%BC%9A%E6%98%BE%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.1.3.1.</span> <span class="toc-text">接口隔离：显式接口实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-20"><span class="toc-number">8.1.3.2.</span> <span class="toc-text">样例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E6%B1%82%E5%B9%B3%E5%9D%87%E5%92%8C%E6%B1%82%E5%92%8C%E3%80%82"><span class="toc-number">8.1.3.3.</span> <span class="toc-text">样例：实现对数组的求平均和求和。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%EF%BC%9A%E8%A7%A3%E5%86%B3%E7%B4%A7%E8%80%A6%E5%90%88-%E5%BC%95%E5%85%A5%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.1.3.4.</span> <span class="toc-text">样例：解决紧耦合:引入接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">8.1.4.</span> <span class="toc-text">接口和抽象类的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%EF%BC%88%E5%80%92%E7%BD%AE%EF%BC%89"><span class="toc-number">8.1.5.</span> <span class="toc-text">依赖反转（倒置）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%EF%BC%89%EF%BC%88%E9%9C%80%E5%AE%8C%E5%96%84%EF%BC%89"><span class="toc-number">8.1.5.1.</span> <span class="toc-text">单元测试（使用依赖倒置）（需完善）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">8.1.6.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-number">8.1.6.1.</span> <span class="toc-text">依赖注入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.7.</span> <span class="toc-text">虚方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">9.</span> <span class="toc-text">c#设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-number">9.1.</span> <span class="toc-text">单一职责原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">9.1.1.</span> <span class="toc-text">单一职责的好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-number">9.2.</span> <span class="toc-text">里氏替换原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99"><span class="toc-number">9.3.</span> <span class="toc-text">依赖倒置原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE%EF%BC%9A"><span class="toc-number">9.3.1.</span> <span class="toc-text">依赖倒置原则的使用建议：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="toc-number">9.4.</span> <span class="toc-text">接口隔离原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">9.4.1.</span> <span class="toc-text">接口隔离原则的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E5%92%8C%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-number">9.4.2.</span> <span class="toc-text">接口隔离原则和单一职责原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">c#异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF"><span class="toc-number">10.1.</span> <span class="toc-text">输出调试信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">10.2.</span> <span class="toc-text">C# 中的异常类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">10.3.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-3"><span class="toc-number">10.3.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">10.4.</span> <span class="toc-text">创建用户自定义异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-4"><span class="toc-number">10.4.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.5.</span> <span class="toc-text">抛出对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-%E6%B3%9B%E5%9E%8B"><span class="toc-number">11.</span> <span class="toc-text">c#泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="toc-number">11.1.</span> <span class="toc-text">使用泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.1.1.</span> <span class="toc-text">可空类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-4"><span class="toc-number">11.1.1.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">11.1.1.2.</span> <span class="toc-text">使用可空类型时的注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%8F%AF%E7%A9%BA%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.1.1.3.</span> <span class="toc-text">从可空值类型到基础类型的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6-1"><span class="toc-number">11.1.1.3.1.</span> <span class="toc-text">?? 空合并运算符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">11.1.1.4.</span> <span class="toc-text">可空类型与运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-1"><span class="toc-number">11.1.1.4.1.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="toc-number">11.1.1.5.</span> <span class="toc-text">可空类型的装箱和拆箱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">11.1.2.</span> <span class="toc-text">List&lt;T&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%B3%9B%E5%9E%8B%E5%88%97%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2"><span class="toc-number">11.1.2.1.</span> <span class="toc-text">对泛型列表进行排序和搜索</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.2.</span> <span class="toc-text">定义泛型类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">11.2.1.</span> <span class="toc-text">定义泛型类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.1.1.</span> <span class="toc-text">定义方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#default%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">11.2.1.1.1.</span> <span class="toc-text">default关键字</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#where%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">11.2.1.2.</span> <span class="toc-text">where泛型约束</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">11.2.1.2.1.</span> <span class="toc-text">作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.2.</span> <span class="toc-text">泛型方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-%E5%A7%94%E6%89%98"><span class="toc-number">12.</span> <span class="toc-text">c#委托</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A7%94%E6%89%98"><span class="toc-number">12.1.</span> <span class="toc-text">什么是委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A7%94%E6%89%98"><span class="toc-number">12.2.</span> <span class="toc-text">为什么要使用委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E7%9A%84%E5%86%85%E7%BD%AE%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98"><span class="toc-number">12.3.</span> <span class="toc-text">c#的内置泛型委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Action%E5%A7%94%E6%89%98"><span class="toc-number">12.3.1.</span> <span class="toc-text">Action委托</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Action%E5%A7%94%E6%89%98%E5%AE%9A%E4%B9%89"><span class="toc-number">12.3.1.1.</span> <span class="toc-text">Action委托定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-21"><span class="toc-number">12.3.1.2.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Func%E5%A7%94%E6%89%98"><span class="toc-number">12.3.2.</span> <span class="toc-text">Func委托</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Func%E5%A7%94%E6%89%98%E5%AE%9A%E4%B9%89"><span class="toc-number">12.3.2.1.</span> <span class="toc-text">Func委托定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-22"><span class="toc-number">12.3.2.2.</span> <span class="toc-text">样例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A7%94%E6%89%98"><span class="toc-number">12.4.</span> <span class="toc-text">自定义委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E-1"><span class="toc-number">12.4.1.</span> <span class="toc-text">声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B1-2"><span class="toc-number">12.4.1.1.</span> <span class="toc-text">样例1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">12.4.2.</span> <span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8new%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">12.4.2.1.</span> <span class="toc-text">使用new运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%8D%B7%E8%AF%AD%E6%B3%95"><span class="toc-number">12.4.2.2.</span> <span class="toc-text">使用快捷语法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E5%A7%94%E6%89%98"><span class="toc-number">12.4.3.</span> <span class="toc-text">赋值委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%A7%94%E6%89%98"><span class="toc-number">12.4.4.</span> <span class="toc-text">组合委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E8%B0%83%E7%94%A8"><span class="toc-number">12.4.5.</span> <span class="toc-text">委托调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95"><span class="toc-number">12.4.6.</span> <span class="toc-text">匿名方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">12.4.6.1.</span> <span class="toc-text">基本结构：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98"><span class="toc-number">12.5.</span> <span class="toc-text">泛型委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98"><span class="toc-number">12.5.1.</span> <span class="toc-text">自定义泛型委托</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E-2"><span class="toc-number">12.5.1.1.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">12.5.1.2.</span> <span class="toc-text">应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E7%9A%84%E4%B8%80%E8%88%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">12.6.</span> <span class="toc-text">委托的一般使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95"><span class="toc-number">12.6.1.</span> <span class="toc-text">模板方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-23"><span class="toc-number">12.6.1.1.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E6%96%B9%E6%B3%95"><span class="toc-number">12.6.2.</span> <span class="toc-text">回调方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-24"><span class="toc-number">12.6.3.</span> <span class="toc-text">样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B2%EF%BC%9A%E5%80%9F%E5%8A%A9%E5%A7%94%E6%89%98%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">12.6.4.</span> <span class="toc-text">样例2：借助委托，使用一个方法调用不同的方法。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B3%EF%BC%9A%E5%80%9F%E5%8A%A9%E5%A7%94%E6%89%98%EF%BC%8C%E5%88%A9%E7%94%A8%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%B0%86string%E6%95%B0%E7%BB%84%E4%B8%AD%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E5%8F%98%E6%88%90%E5%85%A8%E5%A4%A7%E5%86%99%E6%88%96%E5%85%A8%E5%B0%8F%E5%86%99%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E5%8A%A0%E4%B8%8A%E5%8F%8C%E5%BC%95%E5%8F%B7"><span class="toc-number">12.6.5.</span> <span class="toc-text">样例3：借助委托，利用一个方法实现将string数组中每个元素变成全大写或全小写，然后再加上双引号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B4%EF%BC%9A%E5%80%9F%E5%8A%A9%E5%A7%94%E6%89%98%EF%BC%8C%E5%88%A9%E7%94%A8%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%B0%86string%E6%95%B0%E7%BB%84%E4%B8%AD%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E5%8F%98%E6%88%90%E5%85%A8%E5%A4%A7%E5%86%99%E6%88%96%E5%85%A8%E5%B0%8F%E5%86%99%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E5%8A%A0%E4%B8%8A%E5%8F%8C%E5%BC%95%E5%8F%B7%E3%80%82"><span class="toc-number">12.6.6.</span> <span class="toc-text">样例4：借助委托，利用一个方法实现将string数组中每个元素变成全大写或全小写，然后再加上双引号。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%B8%8A%E4%B8%80%E4%B8%AA%E6%A0%B7%E4%BE%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%EF%BC%8C%E4%BF%AE%E6%94%B9%E6%88%90%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95%E7%9A%84%E5%A7%94%E6%89%98%E3%80%82"><span class="toc-number">12.6.7.</span> <span class="toc-text">在上一个样例的基础上，修改成使用匿名方法的委托。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E6%B1%82%E4%BB%BB%E6%84%8F%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">12.6.8.</span> <span class="toc-text">泛型委托的应用：求任意数组的最大值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%94%E6%89%98%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">12.7.</span> <span class="toc-text">使用委托的时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">12.8.</span> <span class="toc-text">Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8FLambda"><span class="toc-number">12.8.1.</span> <span class="toc-text">表达式Lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5Lambda"><span class="toc-number">12.8.2.</span> <span class="toc-text">语句Lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda%E7%9A%84%E4%B8%BB%E8%A6%81%E7%94%A8%E5%A4%84"><span class="toc-number">12.8.3.</span> <span class="toc-text">Lambda的主要用处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda%E6%A0%B7%E4%BE%8B"><span class="toc-number">12.8.4.</span> <span class="toc-text">Lambda样例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B2%EF%BC%9A%E7%A7%BB%E9%99%A4%E6%8C%87%E5%AE%9A%E9%9B%86%E5%90%88%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">12.8.4.1.</span> <span class="toc-text">样例2：移除指定集合的元素</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%BA%8B%E4%BB%B6%EF%BC%88Event%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">C# 事件（Event）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">13.1.</span> <span class="toc-text">事件的概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%8F%91%E7%94%9F-%E7%9B%B8%E5%BA%94%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="toc-number">13.1.1.</span> <span class="toc-text">事件模型（发生-相应模型）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">13.1.1.1.</span> <span class="toc-text">事件的组成部分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-5"><span class="toc-number">13.1.1.1.1.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E7%94%9F-%E5%93%8D%E5%BA%94%E7%9A%84%E4%BA%94%E4%B8%AA%E5%8A%A8%E4%BD%9C%EF%BC%9A"><span class="toc-number">13.1.1.2.</span> <span class="toc-text">发生-响应的五个动作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-25"><span class="toc-number">13.1.1.3.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">13.1.2.</span> <span class="toc-text">事件的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">13.1.3.</span> <span class="toc-text">事件的注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">13.2.</span> <span class="toc-text">事件的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B1-3"><span class="toc-number">13.2.1.</span> <span class="toc-text">样例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B2-%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8B%A5%E6%9C%89%E8%80%85%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%93%8D%E5%BA%94%E8%80%85%E6%98%AF%E5%AE%8C%E5%85%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.2.2.</span> <span class="toc-text">样例2 事件的拥有者和事件的响应者是完全不同的两个对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B3%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8B%A5%E6%9C%89%E8%80%85%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%93%8D%E5%BA%94%E8%80%85%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E3%80%82"><span class="toc-number">13.2.3.</span> <span class="toc-text">样例3事件的拥有者和事件的响应者是同一个对象。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B4-%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8B%A5%E6%9C%89%E8%80%85%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E8%80%85%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%88%90%E5%91%98%EF%BC%8C%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E8%80%85%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%A2%E9%98%85%E7%9D%80%E8%87%AA%E5%B7%B1%E5%AD%97%E6%AE%B5%E6%88%90%E5%91%98%E7%9A%84%E6%9F%90%E4%B8%AA%E4%BA%8B%E4%BB%B6"><span class="toc-number">13.2.4.</span> <span class="toc-text">样例4 事件的拥有者是事件响应者的一个字段成员，事件响应者用自己的方法订阅着自己字段成员的某个事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%BA%8B%E4%BB%B6%EF%BC%88Event%EF%BC%89"><span class="toc-number">13.3.</span> <span class="toc-text">声明事件（Event）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E5%A3%B0%E6%98%8E-1"><span class="toc-number">13.3.1.</span> <span class="toc-text">完整声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E7%95%A5%E5%A3%B0%E6%98%8E"><span class="toc-number">13.3.2.</span> <span class="toc-text">简略声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-26"><span class="toc-number">13.4.</span> <span class="toc-text">样例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B1-4"><span class="toc-number">13.4.1.</span> <span class="toc-text">样例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-2"><span class="toc-number">13.4.2.</span> <span class="toc-text">实例 2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E3%80%81%E6%AF%94%E8%BE%83%E5%92%8C%E8%BD%AC%E6%8D%A2"><span class="toc-number">14.</span> <span class="toc-text">集合、比较和转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">14.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">14.2.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="toc-number">14.2.1.</span> <span class="toc-text">集合概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%92%8C%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.2.2.</span> <span class="toc-text">集合和列表实现的接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E7%B1%BB%E5%92%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">14.2.3.</span> <span class="toc-text">各种集合类和它们的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E9%9B%86%E5%90%88"><span class="toc-number">14.2.4.</span> <span class="toc-text">使用简单集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">14.2.5.</span> <span class="toc-text">集合的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#System-Collections-Generic-%E7%B1%BB"><span class="toc-number">14.2.5.1.</span> <span class="toc-text">System.Collections.Generic 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#System-Collections-Concurrent-%E7%B1%BB"><span class="toc-number">14.2.5.2.</span> <span class="toc-text">System.Collections.Concurrent 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#System-Collections-%E7%B1%BB"><span class="toc-number">14.2.5.3.</span> <span class="toc-text">System.Collections 类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-number">14.2.6.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">14.2.6.1.</span> <span class="toc-text">ArrayList分配空间的方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE-%E5%80%BC%E5%AF%B9%E9%9B%86%E5%90%88%EF%BC%88Hashtable%EF%BC%89"><span class="toc-number">14.2.7.</span> <span class="toc-text">键&#x2F;值对集合（Hashtable）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dictionary%EF%BC%9A%E5%AD%97%E5%85%B8%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-number">14.2.8.</span> <span class="toc-text">Dictionary：字典键值对</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List-%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88"><span class="toc-number">14.2.9.</span> <span class="toc-text">List 泛型集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-LINQ-%E8%AE%BF%E9%97%AE%E9%9B%86%E5%90%88"><span class="toc-number">14.2.10.</span> <span class="toc-text">使用 LINQ 访问集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%9B%86%E5%90%88%E6%8E%92%E5%BA%8F"><span class="toc-number">14.2.11.</span> <span class="toc-text">对集合排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88"><span class="toc-number">14.2.12.</span> <span class="toc-text">定义自定义集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">14.2.13.</span> <span class="toc-text">迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83"><span class="toc-number">14.3.</span> <span class="toc-text">比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83"><span class="toc-number">14.3.1.</span> <span class="toc-text">类型比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#is%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">14.3.1.1.</span> <span class="toc-text">is运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-5"><span class="toc-number">14.3.1.1.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-27"><span class="toc-number">14.3.1.1.2.</span> <span class="toc-text">样例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%AF%94%E8%BE%83"><span class="toc-number">14.3.2.</span> <span class="toc-text">引用比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E6%AF%94%E8%BE%83"><span class="toc-number">14.3.3.</span> <span class="toc-text">值比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IComparable%E5%92%8CIComparer%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.3.3.1.</span> <span class="toc-text">IComparable和IComparer接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E6%AF%94%E8%BE%83%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">14.3.3.2.</span> <span class="toc-text">值比较的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%AE%9E%E7%8E%B0sort%E6%8E%92%E5%BA%8F"><span class="toc-number">14.3.3.3.</span> <span class="toc-text">对自定义类实现sort排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-28"><span class="toc-number">14.3.3.3.1.</span> <span class="toc-text">样例</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">15.</span> <span class="toc-text">文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81"><span class="toc-number">15.1.</span> <span class="toc-text">文件编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E7%B1%BB"><span class="toc-number">15.2.</span> <span class="toc-text">输入输出的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Path%E7%B1%BB"><span class="toc-number">15.2.1.</span> <span class="toc-text">Path类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File%E7%B1%BB"><span class="toc-number">15.2.2.</span> <span class="toc-text">File类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">15.2.2.1.</span> <span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%EF%BC%9AExists"><span class="toc-number">15.2.2.1.1.</span> <span class="toc-text">判断文件是否存在：Exists</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%EF%BC%9ACreate"><span class="toc-number">15.2.2.1.2.</span> <span class="toc-text">创建文件：Create</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%AA%E5%88%87%EF%BC%88%E7%A7%BB%E5%8A%A8%EF%BC%89%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%9AMove"><span class="toc-number">15.2.2.1.3.</span> <span class="toc-text">剪切（移动）一个文件：Move</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%9ACopy"><span class="toc-number">15.2.2.1.4.</span> <span class="toc-text">复制一个文件：Copy</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%9ADelete"><span class="toc-number">15.2.2.1.5.</span> <span class="toc-text">删除一个文件：Delete</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8File%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">15.2.2.2.</span> <span class="toc-text">使用File读写数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8File%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">15.2.2.3.</span> <span class="toc-text">使用File写数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8file%E8%BF%BD%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="toc-number">15.2.2.4.</span> <span class="toc-text">使用file追加数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-6"><span class="toc-number">15.2.2.5.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileInfo%E7%B1%BB"><span class="toc-number">15.2.3.</span> <span class="toc-text">FileInfo类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FileInfo%E7%9A%84%E4%B8%93%E7%94%A8%E5%B1%9E%E6%80%A7%EF%BC%9A"><span class="toc-number">15.2.3.1.</span> <span class="toc-text">FileInfo的专用属性：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Directory%E7%B1%BB"><span class="toc-number">15.2.4.</span> <span class="toc-text">Directory类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DirectorInfo%E7%B1%BB"><span class="toc-number">15.2.5.</span> <span class="toc-text">DirectorInfo类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-number">15.3.</span> <span class="toc-text">文件流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FileStream"><span class="toc-number">15.3.1.</span> <span class="toc-text">FileStream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#using%E6%A1%86%E6%9E%B6"><span class="toc-number">15.3.1.1.</span> <span class="toc-text">using框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8FileStream%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">15.3.1.2.</span> <span class="toc-text">使用FileStream读取文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B1-5"><span class="toc-number">15.3.1.2.1.</span> <span class="toc-text">样例1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B2-%E4%BD%BF%E7%94%A8using%E6%A1%86%E6%9E%B6%E6%94%B9%E9%80%A0%E6%A0%B7%E4%BE%8B1"><span class="toc-number">15.3.1.2.2.</span> <span class="toc-text">样例2 使用using框架改造样例1</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8FileStream%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">15.3.1.3.</span> <span class="toc-text">使用FileStream写入文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StreamReader%E3%80%81StreamWriter"><span class="toc-number">15.3.2.</span> <span class="toc-text">StreamReader、StreamWriter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B1%EF%BC%9A%E4%BD%BF%E7%94%A8StreamReader%E9%80%90%E8%A1%8C%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%EF%BC%8C%E5%B9%B6%E5%B0%86%E7%BB%93%E6%9E%9C%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%98%BE%E7%A4%BA%E5%87%BA%E6%9D%A5%E3%80%82"><span class="toc-number">15.3.2.1.</span> <span class="toc-text">样例1：使用StreamReader逐行读取文本文件，并将结果在控制台显示出来。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B2%EF%BC%9A%E4%BD%BF%E7%94%A8StreamWriter%E5%90%91%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">15.3.2.2.</span> <span class="toc-text">样例2：使用StreamWriter向文本文件写入数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Directory"><span class="toc-number">15.4.</span> <span class="toc-text">Directory</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">16.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">16.1.</span> <span class="toc-text">进程和线程基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">16.1.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">16.1.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">16.1.3.</span> <span class="toc-text">线程和进程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91-%E5%B9%B6%E8%A1%8C"><span class="toc-number">16.1.4.</span> <span class="toc-text">并发&#x2F;并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">16.1.5.</span> <span class="toc-text">同步&#x2F;异步操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">16.1.5.1.</span> <span class="toc-text">同步与异步的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">16.1.5.2.</span> <span class="toc-text">同步与异步的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">16.1.6.</span> <span class="toc-text">任务管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">16.1.7.</span> <span class="toc-text">线程是如何工作的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">16.1.8.</span> <span class="toc-text">线程安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90"><span class="toc-number">16.2.</span> <span class="toc-text">使用多线程的情况分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">16.2.1.</span> <span class="toc-text">2.1 为什么要使用多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">16.2.1.1.</span> <span class="toc-text">何时使用多线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%B8%8D%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">16.2.2.</span> <span class="toc-text">何时不用多线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">16.3.</span> <span class="toc-text">C#中的线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%9F%9F"><span class="toc-number">16.3.1.</span> <span class="toc-text">程序域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">16.3.2.</span> <span class="toc-text">C#中实现线程的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread%E7%B1%BB"><span class="toc-number">16.4.</span> <span class="toc-text">Thread类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">16.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%A1%A8"><span class="toc-number">16.4.2.</span> <span class="toc-text">属性表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="toc-number">16.4.3.</span> <span class="toc-text">方法表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E7%BA%BF%E7%A8%8B"><span class="toc-number">16.4.4.</span> <span class="toc-text">开启线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">16.4.5.</span> <span class="toc-text">传递参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Start-%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82"><span class="toc-number">16.4.5.1.</span> <span class="toc-text">Start()函数传参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%92"><span class="toc-number">16.4.5.2.</span> <span class="toc-text">对象传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95-1"><span class="toc-number">16.4.5.3.</span> <span class="toc-text">匿名方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%91%BD%E5%90%8D"><span class="toc-number">16.4.6.</span> <span class="toc-text">线程命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%8F%B0%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">16.4.7.</span> <span class="toc-text">前台线程和后台线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-7"><span class="toc-number">16.4.8.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">16.5.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">16.5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">16.5.2.</span> <span class="toc-text">线程池的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">16.5.3.</span> <span class="toc-text">线程池的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parallel%E7%B1%BB"><span class="toc-number">16.6.</span> <span class="toc-text">Parallel类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">16.6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">16.6.2.</span> <span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-For"><span class="toc-number">16.6.2.1.</span> <span class="toc-text">Parallel.For()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-For-TLocal"><span class="toc-number">16.6.2.2.</span> <span class="toc-text">Parallel.For &lt; TLocal &gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-ForEach"><span class="toc-number">16.6.2.3.</span> <span class="toc-text">Parallel.ForEach()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-Parallel-Invoke"><span class="toc-number">16.6.3.</span> <span class="toc-text">4.2.4 Parallel.Invoke()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Task%E7%B1%BB"><span class="toc-number">16.7.</span> <span class="toc-text">Task类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="toc-number">16.7.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1Task%E5%92%8C%E7%BA%BF%E7%A8%8BThread%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">16.7.2.</span> <span class="toc-text">任务Task和线程Thread的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Task%E7%9A%84%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F%E4%B8%8E%E7%8A%B6%E6%80%81"><span class="toc-number">16.7.3.</span> <span class="toc-text">Task的生存周期与状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Task%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">16.7.4.</span> <span class="toc-text">Task的使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%BB%BB%E5%8A%A1"><span class="toc-number">16.7.4.1.</span> <span class="toc-text">启动任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="toc-number">16.7.4.2.</span> <span class="toc-text">任务控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Task-Wait"><span class="toc-number">16.7.4.2.1.</span> <span class="toc-text">Task.Wait()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Task-WaitAll"><span class="toc-number">16.7.4.2.2.</span> <span class="toc-text">Task.WaitAll()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Task-WaitAny"><span class="toc-number">16.7.4.2.3.</span> <span class="toc-text">Task.WaitAny()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Task-ContinueWith"><span class="toc-number">16.7.4.2.4.</span> <span class="toc-text">Task.ContinueWith()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RunSynchronously"><span class="toc-number">16.7.4.2.5.</span> <span class="toc-text">RunSynchronously()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%8F%96%E6%B6%88"><span class="toc-number">16.7.4.3.</span> <span class="toc-text">任务取消</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">16.7.4.4.</span> <span class="toc-text">接收任务的返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">16.7.5.</span> <span class="toc-text">任务的层次结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BackgroundWorker%E6%8E%A7%E4%BB%B6"><span class="toc-number">16.8.</span> <span class="toc-text">BackgroundWorker控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="toc-number">16.8.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%A1%A8-1"><span class="toc-number">16.8.2.</span> <span class="toc-text">属性表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WorkerReportsProgress"><span class="toc-number">16.8.2.1.</span> <span class="toc-text">WorkerReportsProgress</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WorkerSupportsCancellation"><span class="toc-number">16.8.2.2.</span> <span class="toc-text">WorkerSupportsCancellation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CancellationPending"><span class="toc-number">16.8.2.3.</span> <span class="toc-text">CancellationPending</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IsBusy"><span class="toc-number">16.8.2.4.</span> <span class="toc-text">IsBusy</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A1%A8-1"><span class="toc-number">16.8.3.</span> <span class="toc-text">方法表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RunWorkerAsync"><span class="toc-number">16.8.3.1.</span> <span class="toc-text">RunWorkerAsync()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReportProgress-Int-percentProgress"><span class="toc-number">16.8.3.2.</span> <span class="toc-text">ReportProgress(Int percentProgress)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CancelAsync"><span class="toc-number">16.8.3.3.</span> <span class="toc-text">CancelAsync()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%A1%A8"><span class="toc-number">16.8.4.</span> <span class="toc-text">事件表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DoWork"><span class="toc-number">16.8.4.1.</span> <span class="toc-text">DoWork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ProgressChanged"><span class="toc-number">16.8.4.2.</span> <span class="toc-text">ProgressChanged</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RunWorkerCompleted"><span class="toc-number">16.8.4.3.</span> <span class="toc-text">RunWorkerCompleted</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">16.8.5.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">17.</span> <span class="toc-text">调用系统对话框</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">17.1.</span> <span class="toc-text">打开文件对话框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">17.2.</span> <span class="toc-text">保存文件对话框</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Socket%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">18.</span> <span class="toc-text">Socket套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">18.1.</span> <span class="toc-text">Socket的通信过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-number">18.1.1.</span> <span class="toc-text">服务器端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">18.1.2.</span> <span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">18.1.3.</span> <span class="toc-text">过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">18.2.</span> <span class="toc-text">Socket的构造函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GDI"><span class="toc-number">19.</span> <span class="toc-text">GDI+</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF"><span class="toc-number">19.1.</span> <span class="toc-text">后端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">20.</span> <span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BA%8F%E5%88%97%E5%8C%96%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9"><span class="toc-number">20.1.</span> <span class="toc-text">关于二进制序列化需要注意的事项:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-%E5%A4%8D%E5%88%B6"><span class="toc-number">21.</span> <span class="toc-text">c#复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E5%A4%8D%E5%88%B6"><span class="toc-number">21.1.</span> <span class="toc-text">浅复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B5%85%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">21.1.1.</span> <span class="toc-text">使用浅复制的场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-29"><span class="toc-number">21.1.2.</span> <span class="toc-text">样例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E4%B8%AD%E9%83%A8%E5%88%86%E6%96%B9%E6%B3%95%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-number">21.1.2.1.</span> <span class="toc-text">样例中部分方法的解释</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MemberwiseClone"><span class="toc-number">21.1.2.1.1.</span> <span class="toc-text">MemberwiseClone()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">21.1.3.</span> <span class="toc-text">浅复制与赋值的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%A4%8D%E5%88%B6"><span class="toc-number">21.2.</span> <span class="toc-text">深复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%96%B9%E5%BC%8F"><span class="toc-number">21.2.1.</span> <span class="toc-text">几种常见的深拷贝方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">21.2.1.1.</span> <span class="toc-text">利用反射实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">21.2.1.2.</span> <span class="toc-text">利用二进制序列化和反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8xml%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">21.2.1.3.</span> <span class="toc-text">利用xml序列化和反序列化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B-%E5%8F%8D%E5%B0%84"><span class="toc-number">21.3.</span> <span class="toc-text">泛型+反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%9B%E5%9E%8B%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-number">21.3.1.</span> <span class="toc-text">反射和泛型来实现深拷贝怎么做</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%88%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%89"><span class="toc-number">21.4.</span> <span class="toc-text">二进制流的方式（序列化）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#return%E5%8E%9F%E5%88%99"><span class="toc-number">22.</span> <span class="toc-text">return原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BD%E6%97%A9return"><span class="toc-number">22.1.</span> <span class="toc-text">尽早return</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%85%E9%A1%BB%E4%BF%9D%E8%AF%81%E4%B8%80%E5%AE%9A%E5%8F%AF%E4%BB%A5return"><span class="toc-number">22.2.</span> <span class="toc-text">必须保证一定可以return</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">23.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Form1%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">23.1.</span> <span class="toc-text">Form1代码：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Form2%E4%BB%A3%E7%A0%81"><span class="toc-number">23.2.</span> <span class="toc-text">Form2代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#XML-%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80"><span class="toc-number">24.</span> <span class="toc-text">XML 可扩展的标记语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E5%88%9B%E5%BB%BAxml%E6%96%87%E6%A1%A3"><span class="toc-number">24.1.</span> <span class="toc-text">通过代码创建xml文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B8%A6%E5%B1%9E%E6%80%A7%E7%9A%84XML%E6%96%87%E6%A1%A3"><span class="toc-number">24.2.</span> <span class="toc-text">创建带属性的XML文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91XML%E6%96%87%E6%A1%A3%E4%B8%AD%E8%BF%BD%E5%8A%A0%E5%86%85%E5%AE%B9"><span class="toc-number">24.3.</span> <span class="toc-text">向XML文档中追加内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96Xml%E6%96%87%E6%A1%A3"><span class="toc-number">24.4.</span> <span class="toc-text">读取Xml文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%B8%A6%E6%9C%89%E5%B1%9E%E6%80%A7%E7%9A%84Xml%E6%96%87%E6%A1%A3"><span class="toc-number">24.5.</span> <span class="toc-text">读取带有属性的Xml文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">24.6.</span> <span class="toc-text">删除节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-8"><span class="toc-number">24.7.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F-1"><span class="toc-number">25.</span> <span class="toc-text">对象的生存周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="toc-number">25.0.0.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-1"><span class="toc-number">25.0.0.2.</span> <span class="toc-text">析构函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%BC%96%E7%A0%81%E7%BA%A6%E5%AE%9A"><span class="toc-number">26.</span> <span class="toc-text">C# 编码约定</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%A6%81"><span class="toc-number">26.1.</span> <span class="toc-text">简要</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pascal-%EF%BC%88%E5%A4%A7%E9%A9%BC%E5%B3%B0%EF%BC%89%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">26.1.1.</span> <span class="toc-text">Pascal （大驼峰）命名方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Camel-%EF%BC%88%E5%B0%8F%E9%A9%BC%E5%B3%B0%EF%BC%89%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">26.1.2.</span> <span class="toc-text">Camel （小驼峰）命名方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A"><span class="toc-number">26.2.</span> <span class="toc-text">命名约定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%95%E6%96%AF%E5%8D%A1%E6%8B%BC%E5%86%99%E6%B3%95-%E5%A4%A7%E9%A9%BC%E5%B3%B0"><span class="toc-number">26.2.1.</span> <span class="toc-text">帕斯卡拼写法(大驼峰)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%BC%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%86%99%EF%BC%88%E5%B0%8F%E9%A9%BC%E5%B3%B0%EF%BC%89"><span class="toc-number">26.2.2.</span> <span class="toc-text">驼峰式大小写（小驼峰）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A"><span class="toc-number">26.2.3.</span> <span class="toc-text">其他命名约定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B1%80%E7%BA%A6%E5%AE%9A"><span class="toc-number">26.3.</span> <span class="toc-text">布局约定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86-using-%E6%8C%87%E4%BB%A4%E6%94%BE%E5%9C%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%A3%B0%E6%98%8E%E4%B9%8B%E5%A4%96"><span class="toc-number">26.4.</span> <span class="toc-text">将 using 指令放在命名空间声明之外</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%E7%BA%A6%E5%AE%9A"><span class="toc-number">26.5.</span> <span class="toc-text">注释约定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E5%87%86%E5%88%99"><span class="toc-number">26.6.</span> <span class="toc-text">语言准则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">26.6.1.</span> <span class="toc-text">字符串数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F"><span class="toc-number">26.6.2.</span> <span class="toc-text">隐式类型本地变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">26.6.3.</span> <span class="toc-text">无符号数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">26.6.4.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98"><span class="toc-number">26.6.5.</span> <span class="toc-text">委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch-%E5%92%8C-using-%E8%AF%AD%E5%8F%A5%E6%AD%A3%E5%9C%A8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%AD"><span class="toc-number">26.6.6.</span> <span class="toc-text">try-catch 和 using 语句正在异常处理中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">26.6.7.</span> <span class="toc-text">&amp;&amp; 和 || 运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">26.6.8.</span> <span class="toc-text">new 运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">26.6.9.</span> <span class="toc-text">事件处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">26.6.10.</span> <span class="toc-text">静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LINQ-%E6%9F%A5%E8%AF%A2"><span class="toc-number">26.6.11.</span> <span class="toc-text">LINQ 查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">26.7.</span> <span class="toc-text">安全性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E5%8F%82%E9%98%85"><span class="toc-number">26.8.</span> <span class="toc-text">请参阅</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-number">27.</span> <span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#XXX-ToString-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%95%B0%E5%80%BC%E7%BB%93%E6%9E%9C%E8%A1%A8"><span class="toc-number">27.1.</span> <span class="toc-text">XXX.ToString 格式化数值结果表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-Format-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%95%B0%E5%80%BC%E7%BB%93%E6%9E%9C%E8%A1%A8"><span class="toc-number">27.2.</span> <span class="toc-text">String.Format 格式化数值结果表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-Format-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%BC%8F%E8%BE%93%E5%87%BA"><span class="toc-number">27.3.</span> <span class="toc-text">String.Format 自定义模式输出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%A0%B7%E4%BE%8B"><span class="toc-number">28.</span> <span class="toc-text">c#的一些小样例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E7%9A%84%E5%80%BC%E5%88%B0%E5%8F%98%E9%87%8F"><span class="toc-number">28.1.</span> <span class="toc-text">读取键盘输入的值到变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E6%8C%87%E9%92%88"><span class="toc-number">28.2.</span> <span class="toc-text">c#指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E5%88%86%E9%85%8D%E6%95%B0%E7%BB%84%E5%9C%A8%E6%A0%88%E7%A9%BA%E9%97%B4%E4%B8%AD"><span class="toc-number">28.3.</span> <span class="toc-text">强制分配数组在栈空间中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%AA%E8%AF%BB%E5%AD%97%E6%AE%B5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">28.4.</span> <span class="toc-text">常量和只读字段的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">28.4.1.</span> <span class="toc-text">常见的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E2%80%9C%E5%8F%AA%E8%AF%BB%E2%80%9D%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">28.5.</span> <span class="toc-text">各种“只读”的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC%E5%8F%82%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">28.6.</span> <span class="toc-text">值类型和值参数的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA"><span class="toc-number">28.7.</span> <span class="toc-text">判断两个对象是否是同一个</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TryParse%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">28.8.</span> <span class="toc-text">TryParse类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Split%E6%96%B9%E6%B3%95%E4%BD%BF%E5%BE%97string%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E8%A1%8C%E6%8C%89%E6%8C%87%E5%AE%9A%E7%AC%A6%E5%8F%B7%E5%88%86%E5%89%B2%E3%80%82"><span class="toc-number">28.9.</span> <span class="toc-text">使用Split方法使得string字符串进行按指定符号分割。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E7%9A%84%E8%8A%B1%E6%A0%B7%E7%8E%A9%E6%B3%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3C-%E4%B8%AD-%E2%80%9C-%E2%80%9D-%E7%AC%A6%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95"><span class="toc-number">28.10.</span> <span class="toc-text">string的花样玩法：深入理解C# 中 “$” 符号的作用以及用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">28.10.1.</span> <span class="toc-text">C#中$的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">28.10.2.</span> <span class="toc-text">C#中$的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">28.10.2.1.</span> <span class="toc-text">语法格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">28.10.3.</span> <span class="toc-text">$的示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-%E7%9A%84%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86"><span class="toc-number">28.10.4.</span> <span class="toc-text">关于$的补充知识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E5%85%B7%E6%9C%89%E7%89%B9%E5%AE%9A%E5%85%B3%E8%81%94%E5%80%BC%E7%9A%84%E6%9E%9A%E4%B8%BE%E6%88%90%E5%91%98"><span class="toc-number">28.11.</span> <span class="toc-text">查询枚举类型是否包含具有特定关联值的枚举成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%BC%95%E7%94%A8%E4%BE%9D%E8%B5%96%EF%BC%9A%E7%B1%BB%E5%BA%93"><span class="toc-number">28.12.</span> <span class="toc-text">添加引用依赖：类库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MD5%E8%BD%AC%E6%8D%A2"><span class="toc-number">28.13.</span> <span class="toc-text">MD5转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E4%BD%BF%E7%94%A8-Net-FrameWork%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%8C%E8%B0%83%E7%94%A8From%E7%AA%97%E4%BD%93%E3%80%82"><span class="toc-number">29.</span> <span class="toc-text">对于使用.Net FrameWork的控制台应用程序，调用From窗体。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">30.</span> <span class="toc-text">存在的问题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/12/Hexo%E6%96%B0%E5%A2%9E%E5%88%86%E7%B1%BB%E6%A0%87%E7%AD%BE%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E8%AF%A6%E8%A7%A3/" title="Hexo 新增分类、标签与自定义页面详解">Hexo 新增分类、标签与自定义页面详解</a><time datetime="2025-10-12T05:46:03.000Z" title="发表于 2025-10-12 13:46:03">2025-10-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E9%80%9A%E7%94%A8%E8%93%9D%E5%9B%BE/" title="高可用高并发后端架构通用蓝图">高可用高并发后端架构通用蓝图</a><time datetime="2025-10-08T15:42:00.000Z" title="发表于 2025-10-08 23:42:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%9F%E6%88%90/" title="AI提示词_学习笔记生成">AI提示词_学习笔记生成</a><time datetime="2025-10-08T15:15:00.000Z" title="发表于 2025-10-08 23:15:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/AI%E6%8F%90%E7%A4%BA%E8%AF%8D_%E8%AF%95%E9%A2%98%E7%94%9F%E6%88%90/" title="AI提示词_试题生成">AI提示词_试题生成</a><time datetime="2025-10-08T15:15:00.000Z" title="发表于 2025-10-08 23:15:00">2025-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/08/Golang_swag/" title="Golang swag 库">Golang swag 库</a><time datetime="2025-10-08T15:07:00.000Z" title="发表于 2025-10-08 23:07:00">2025-10-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/Image/topImage.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By 棨</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>